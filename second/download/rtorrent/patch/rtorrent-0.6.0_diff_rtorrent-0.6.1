diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/config.h.in	2006-07-09 04:12:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/config.h.in	2006-08-14 00:24:37.000000000 +0800
@@ -1,8 +1,11 @@
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
+/* Determine the block size */
+#undef FS_STAT_BLOCK_SIZE
+
 /* Type of block count member in stat struct */
 #undef FS_STAT_COUNT_TYPE
 
 /* Function to determine filesystem stats from fd */
 #undef FS_STAT_FD
 
@@ -94,12 +97,15 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
 /* Define this if the compiler supports the unused attribute */
 #undef SUPPORT_ATTRIBUTE_UNUSED
 
+/* Http user agent */
+#undef USER_AGENT
+
 /* Use execinfo.h */
 #undef USE_EXECINFO
 
 /* Enable extra debugging checks. */
 #undef USE_EXTRA_DEBUG
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/configure	2006-07-09 04:12:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/configure	2006-08-14 00:24:20.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.6.0.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.6.1.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -416,14 +416,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.6.0'
-PACKAGE_STRING='rtorrent 0.6.0'
+PACKAGE_VERSION='0.6.1'
+PACKAGE_STRING='rtorrent 0.6.1'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -950,13 +950,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.6.0 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.6.1 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1016,13 +1016,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.6.0:";;
+     short | recursive ) echo "Configuration of rtorrent 0.6.1:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1165,13 +1165,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.6.0
+rtorrent configure 0.6.1
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1179,13 +1179,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.6.0, which was
+It was created by rtorrent $as_me 0.6.1, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1823,13 +1823,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.6.0'
+ VERSION='0.6.1'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -14059,12 +14059,17 @@
 
 
 cat >>confdefs.h <<\_ACEOF
 #define FS_STAT_COUNT_TYPE fsblkcnt_t
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define FS_STAT_BLOCK_SIZE (m_stat.f_frsize)
+_ACEOF
+
       echo "$as_me:$LINENO: result: ok" >&5
 echo "${ECHO_T}ok" >&6
       have_stat_vfs=yes
 
 else
   echo "$as_me: failed program was:" >&5
@@ -14316,12 +14321,17 @@
 
 
 cat >>confdefs.h <<\_ACEOF
 #define FS_STAT_COUNT_TYPE fsblkcnt_t
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define FS_STAT_BLOCK_SIZE (m_stat.f_frsize)
+_ACEOF
+
       echo "$as_me:$LINENO: result: ok" >&5
 echo "${ECHO_T}ok" >&6
       have_stat_vfs=yes
 
 else
   echo "$as_me: failed program was:" >&5
@@ -14578,12 +14588,17 @@
 
 
 cat >>confdefs.h <<\_ACEOF
 #define FS_STAT_COUNT_TYPE long
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define FS_STAT_BLOCK_SIZE (m_stat.f_bsize)
+_ACEOF
+
       echo "$as_me:$LINENO: result: ok" >&5
 echo "${ECHO_T}ok" >&6
 
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
@@ -14620,12 +14635,17 @@
 
 
 cat >>confdefs.h <<\_ACEOF
 #define FS_STAT_COUNT_TYPE int
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define FS_STAT_BLOCK_SIZE (4096)
+_ACEOF
+
       echo "$as_me:$LINENO: result: No filesystem stats available" >&5
 echo "${ECHO_T}No filesystem stats available" >&6
 
         fi
       fi
 
@@ -14863,12 +14883,17 @@
 
 
 cat >>confdefs.h <<\_ACEOF
 #define FS_STAT_COUNT_TYPE long
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define FS_STAT_BLOCK_SIZE (m_stat.f_bsize)
+_ACEOF
+
       echo "$as_me:$LINENO: result: ok" >&5
 echo "${ECHO_T}ok" >&6
 
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
@@ -14905,12 +14930,17 @@
 
 
 cat >>confdefs.h <<\_ACEOF
 #define FS_STAT_COUNT_TYPE int
 _ACEOF
 
+
+cat >>confdefs.h <<\_ACEOF
+#define FS_STAT_BLOCK_SIZE (4096)
+_ACEOF
+
       echo "$as_me:$LINENO: result: No filesystem stats available" >&5
 echo "${ECHO_T}No filesystem stats available" >&6
 
         fi
       fi
 
@@ -15029,36 +15059,36 @@
 
 if test -n "$PKG_CONFIG"; then
     if test -n "$STUFF_CFLAGS"; then
         pkg_cv_STUFF_CFLAGS="$STUFF_CFLAGS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libtorrent >= 0.10.0\"") >&5
-  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libtorrent >= 0.10.0") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libtorrent >= 0.10.1\"") >&5
+  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libtorrent >= 0.10.1") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_STUFF_CFLAGS=`$PKG_CONFIG --cflags "sigc++-2.0 libtorrent >= 0.10.0" 2>/dev/null`
+  pkg_cv_STUFF_CFLAGS=`$PKG_CONFIG --cflags "sigc++-2.0 libtorrent >= 0.10.1" 2>/dev/null`
 else
   pkg_failed=yes
 fi
     fi
 else
 	pkg_failed=untried
 fi
 if test -n "$PKG_CONFIG"; then
     if test -n "$STUFF_LIBS"; then
         pkg_cv_STUFF_LIBS="$STUFF_LIBS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libtorrent >= 0.10.0\"") >&5
-  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libtorrent >= 0.10.0") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libtorrent >= 0.10.1\"") >&5
+  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libtorrent >= 0.10.1") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_STUFF_LIBS=`$PKG_CONFIG --libs "sigc++-2.0 libtorrent >= 0.10.0" 2>/dev/null`
+  pkg_cv_STUFF_LIBS=`$PKG_CONFIG --libs "sigc++-2.0 libtorrent >= 0.10.1" 2>/dev/null`
 else
   pkg_failed=yes
 fi
     fi
 else
 	pkg_failed=untried
@@ -15071,31 +15101,31 @@
 if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
         _pkg_short_errors_supported=yes
 else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        STUFF_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "sigc++-2.0 libtorrent >= 0.10.0"`
+	        STUFF_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "sigc++-2.0 libtorrent >= 0.10.1"`
         else
-	        STUFF_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sigc++-2.0 libtorrent >= 0.10.0"`
+	        STUFF_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sigc++-2.0 libtorrent >= 0.10.1"`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$STUFF_PKG_ERRORS" >&5
 
-	{ { echo "$as_me:$LINENO: error: Package requirements (sigc++-2.0 libtorrent >= 0.10.0) were not met:
+	{ { echo "$as_me:$LINENO: error: Package requirements (sigc++-2.0 libtorrent >= 0.10.1) were not met:
 
 $STUFF_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
 Alternatively, you may set the environment variables STUFF_CFLAGS
 and STUFF_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 " >&5
-echo "$as_me: error: Package requirements (sigc++-2.0 libtorrent >= 0.10.0) were not met:
+echo "$as_me: error: Package requirements (sigc++-2.0 libtorrent >= 0.10.1) were not met:
 
 $STUFF_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
@@ -15138,12 +15168,17 @@
 
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_CONFIG_H 1
 _ACEOF
 
 
+cat >>confdefs.h <<\_ACEOF
+#define USER_AGENT std::string(PACKAGE "/" VERSION "/") + torrent::version()
+_ACEOF
+
+
 
 	echo "$as_me:$LINENO: checking if compiler supports __attribute__((unused))" >&5
 echo $ECHO_N "checking if compiler supports __attribute__((unused))... $ECHO_C" >&6
 if test "${cc_cv_attribute_unused+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -15597,13 +15632,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.6.0, which was
+This file was extended by rtorrent $as_me 0.6.1, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -15660,13 +15695,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.6.0
+rtorrent config.status 0.6.1
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/configure.ac	2006-06-05 04:16:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/configure.ac	2006-08-14 00:22:05.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.6.0, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.6.1, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
@@ -20,17 +20,18 @@
 
 TORRENT_WITHOUT_VARIABLE_FDSET()
 TORRENT_WITHOUT_NCURSESW()
 TORRENT_WITHOUT_STATVFS()
 TORRENT_WITHOUT_STATFS()
 
-PKG_CHECK_MODULES(STUFF, sigc++-2.0 libtorrent >= 0.10.0,
+PKG_CHECK_MODULES(STUFF, sigc++-2.0 libtorrent >= 0.10.1,
 	          CXXFLAGS="$CXXFLAGS $STUFF_CFLAGS $CURL_CFLAGS";
 		  LIBS="$LIBS $STUFF_LIBS $CURL_LIBS")
 
 AC_DEFINE(HAVE_CONFIG_H, 1, true if config.h was included)
+AC_DEFINE(USER_AGENT, [std::string(PACKAGE "/" VERSION "/") + torrent::version()], Http user agent)
 
 CC_ATTRIBUTE_UNUSED(
 	AC_DEFINE([__UNUSED], [__attribute__((unused))], [Wrapper around unused attribute]),
 	AC_DEFINE([__UNUSED], [], [Null-wrapper if unused attribute is unsupported])
 )
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/doc/rtorrent.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/doc/rtorrent.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/doc/rtorrent.1	2006-07-06 08:16:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/doc/rtorrent.1	2006-08-16 06:49:48.000000000 +0800
@@ -1,12 +1,12 @@
 .\" This manpage has been automatically generated by docbook2man 
 .\" from a DocBook document.  This tool can be found at:
 .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
 .\" Please send any bug reports, improvements, comments, patches, 
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
-.TH "RTORRENT" "1" "05 July 2006" "BitTorrent client for ncurses" ""
+.TH "RTORRENT" "1" "15 August 2006" "BitTorrent client for ncurses" ""
 
 .SH NAME
 rtorrent \- a BitTorrent client for ncurses
 .SH SYNOPSIS
 
 \fBrtorrent\fR [ \fB-h\fR ] [ \fB-n\fR ] [ \fB-o key1=opt1,...\fR ] [ \fB-O key=opt\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
@@ -165,12 +165,20 @@
 \fBmax_peers = \fIvalue\fB\fR
 Set the maximum number of peers to allow in each download.
 .TP
 \fBmin_peers = \fIvalue\fB\fR
 Set the minimum number of peers to try to connect to in each download.
 .TP
+\fBmax_peers_seed = \fIvalue\fB\fR
+Set the maximum number of peers to allow while seeding, or -1 (default) to use
+max_peers.
+.TP
+\fBmin_peers_seed = \fIvalue\fB\fR
+Set the minimum number of peers to try to connect to while seeding, or -1 (default) to use
+min_peers.
+.TP
 \fBmax_uploads = \fIvalue\fB\fR
 Set the maximum number of simultaneous uploads per download.
 .TP
 \fBdownload_rate = \fIKB\fB\fR
 Set the maximum global download rate.
 .TP
@@ -315,13 +323,14 @@
 \fBcomplete\fR, \fBincomplete\fR,
 .TP
 \fBkey_layout = \fIquerty|azerty\fB\fR
 Change the key-bindings.
 .SH "ADVANCED SETTINGS"
 .PP
-This list contains settings users shouldn't need to touch.
+This list contains settings users shouldn't need to touch, some may
+even cause crashes or similar if incorrectly set.
 .TP
 \fBhash_read_ahead = \fIMB\fB\fR
 Configure how far ahead we ask the kernel to read when doing hash
 checking. The hash checker uses madvise(..., MADV_WILLNEED) for the
 requests.
 .TP
@@ -331,12 +340,16 @@
 .TP
 \fBhash_max_tries = \fItries\fB\fR
 Number of attempts to check the hash while using the mincore status,
 before forcing. Overworked systems might need lower values to get a
 decent hash checking rate.
 .TP
+\fBsafe_sync = \fIyes|no\fB\fR
+Always use MS_SYNC rather than MS_ASYNC when syncing chunks. This may
+be nessesary in case of filesystem bugs like NFS in linux ~2.6.13.
+.TP
 \fBmax_open_files = \fIvalue\fB\fR
 Number of files to simultaneously keep open. Libtorrent dynamically
 opens and closes files when mapping files to memory. Defaults to 128.
 .TP
 \fBmax_open_sockets = \fIvalue\fB\fR
 Number of sockets to simultaneously keep open. This value is set to be
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/doc/rtorrent.1.xml	2006-07-06 02:53:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/doc/rtorrent.1.xml	2006-08-16 03:21:46.000000000 +0800
@@ -443,12 +443,32 @@
 Set the minimum number of peers to try to connect to in each download.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
+        <term>max_peers_seed = <replaceable>value</replaceable></term>
+        <listitem><para>
+
+Set the maximum number of peers to allow while seeding, or -1 (default) to use
+max_peers.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>min_peers_seed = <replaceable>value</replaceable></term>
+        <listitem><para>
+
+Set the minimum number of peers to try to connect to while seeding, or -1 (default) to use
+min_peers.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term>max_uploads = <replaceable>value</replaceable></term>
         <listitem><para>
 
 Set the maximum number of simultaneous uploads per download.
 
         </para></listitem>
@@ -754,13 +774,16 @@
 
 
 
   <refsect1>
     <title>ADVANCED SETTINGS</title>
     <para>
-      This list contains settings users shouldn't need to touch.
+
+This list contains settings users shouldn't need to touch, some may
+even cause crashes or similar if incorrectly set.
+
     </para>
 
     <variablelist>
 
       <varlistentry>
         <term>hash_read_ahead = <replaceable>MB</replaceable></term>
@@ -792,12 +815,22 @@
 decent hash checking rate.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
+        <term>safe_sync = <replaceable>yes|no</replaceable></term>
+        <listitem><para>
+
+Always use MS_SYNC rather than MS_ASYNC when syncing chunks. This may
+be nessesary in case of filesystem bugs like NFS in linux ~2.6.13.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term>max_open_files = <replaceable>value</replaceable></term>
         <listitem><para>
 
 Number of files to simultaneously keep open. Libtorrent dynamically
 opens and closes files when mapping files to memory. Defaults to 128.
 
@@ -921,13 +954,15 @@
 
 
   <refsect1>
     <title>AUTHORS</title>
     <para>
       <simplelist type="vert">
-	<member>Jari "Rakshasa" Sundell <email>jaris@ifi.uio.no</email></member>
+
+<member>Jari "Rakshasa" Sundell <email>jaris@ifi.uio.no</email></member>
+
       </simplelist>
     </para>
   </refsect1>
 
 
 </refentry>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/doc/rtorrent.rc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/doc/rtorrent.rc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/doc/rtorrent.rc	2006-05-28 04:17:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/doc/rtorrent.rc	2006-08-16 03:21:46.000000000 +0800
@@ -3,12 +3,16 @@
 # uncomment the options you wish to enable.
 
 # Maximum and minimum number of peers to connect to per torrent.
 #min_peers = 40
 #max_peers = 100
 
+# Same as above but for seeding completed torrents (-1 = same as downloading)
+#min_peers_seed = 10
+#max_peers_seed = 50
+
 # Maximum number of simultanious uploads per torrent.
 #max_uploads = 15
 
 # Global upload and download rate in KiB. "0" for unlimited.
 #download_rate = 0
 #upload_rate = 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/algorithm.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/algorithm.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/algorithm.h	2006-05-27 07:20:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/algorithm.h	2006-07-24 06:57:05.000000000 +0800
@@ -53,12 +53,21 @@
     __f(*__tmp);
   }
 
   return __f;
 }
 
+template <typename InputIter, typename Function, typename Accumulator>
+Accumulator
+accumulate(InputIter first, InputIter last, Function function, Accumulator acc) {
+  while (first != last)
+    acc += function(*first++);
+
+  return acc;
+}
+
 // Return a range with a distance of no more than __distance and
 // between __first and __last, centered on __middle1.
 template <typename _InputIter, typename _Distance>
 std::pair<_InputIter, _InputIter>
 advance_bidirectional(_InputIter __first, _InputIter __middle1, _InputIter __last, _Distance __distance) {
   _InputIter __middle2 = __middle1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/error_number.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/error_number.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/error_number.h	2006-05-27 07:20:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/error_number.h	2006-07-19 00:05:46.000000000 +0800
@@ -48,12 +48,13 @@
   static const int e_again       = EAGAIN;
   static const int e_connreset   = ECONNRESET;
   static const int e_connaborted = ECONNABORTED;
   static const int e_deadlk      = EDEADLK;
 
   static const int e_noent       = ENOENT;
+  static const int e_nomem       = ENOMEM;
   static const int e_notdir      = ENOTDIR;
   
   static const int e_intr        = EINTR;
 
   error_number() : m_errno(0) {}
   error_number(int e) : m_errno(e) {}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/fs_stat.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/fs_stat.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/fs_stat.h	2006-05-27 07:20:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/fs_stat.h	2006-07-19 06:43:37.000000000 +0800
@@ -68,15 +68,15 @@
   typedef FS_STAT_STRUCT     fs_stat_type;
 
   bool                       update(int fd)                       { return FS_STAT_FD; }
   bool                       update(const char* fn)               { return FS_STAT_FN; }
   bool                       update(const std::string& filename)  { return update(filename.c_str()); }
 
-  blocksize_type             blocksize()                          { return m_stat.f_bsize; }
+  blocksize_type             blocksize()                          { return FS_STAT_BLOCK_SIZE; }
   blockcount_type            blocks_avail()                       { return m_stat.f_bavail; }
-  int64_t                    bytes_avail()                        { return (int64_t) m_stat.f_bsize * m_stat.f_bavail; }
+  int64_t                    bytes_avail()                        { return (int64_t) blocksize() * m_stat.f_bavail; }
 
 private:
   fs_stat_type               m_stat;
 };
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/functional.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/functional.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/functional.h	2006-06-25 07:45:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/functional.h	2006-08-11 22:47:40.000000000 +0800
@@ -205,12 +205,30 @@
 template <typename Type, typename Ftor>
 inline _greater<Type, Ftor>
 greater(Type t, Ftor f) {
   return _greater<Type, Ftor>(t, f);
 }
 
+template <typename FtorA, typename FtorB>
+struct greater2_t : public std::binary_function<typename FtorA::argument_type, typename FtorB::argument_type, bool> {
+  greater2_t(FtorA f_a, FtorB f_b) : m_f_a(f_a), m_f_b(f_b) {}
+
+  bool operator () (typename FtorA::argument_type a, typename FtorB::argument_type b) {
+    return m_f_a(a) > m_f_b(b);
+  }
+
+  FtorA m_f_a;
+  FtorB m_f_b;
+};
+
+template <typename FtorA, typename FtorB>
+inline greater2_t<FtorA, FtorB>
+greater2(FtorA f_a, FtorB f_b) {
+  return greater2_t<FtorA,FtorB>(f_a,f_b);
+}
+
 template <typename Type, typename Ftor>
 struct less_equal_t {
   typedef bool result_type;
 
   less_equal_t(Type t, Ftor f) : m_t(t), m_f(f) {}
 
@@ -275,30 +293,64 @@
 on(Src s, Dest d) {
   return on_t<Src, Dest>(s, d);
 }  
 
 // Creates a functor for accessing a member.
 template <typename Class, typename Member>
-struct mem_ptr_ref_t : public std::unary_function<Class&, Member&> {
-  mem_ptr_ref_t(Member Class::*m) : m_member(m) {}
+struct mem_ptr_t : public std::unary_function<Class*, Member&> {
+  mem_ptr_t(Member Class::*m) : m_member(m) {}
+
+  Member& operator () (Class* c) {
+    return c->*m_member;
+  }
+
+  const Member& operator () (const Class* c) {
+    return c->*m_member;
+  }
+
+  Member Class::*m_member;
+};
+
+template <typename Class, typename Member>
+inline mem_ptr_t<Class, Member>
+mem_ptr(Member Class::*m) {
+  return mem_ptr_t<Class, Member>(m);
+}
+
+template <typename Class, typename Member>
+struct mem_ref_t : public std::unary_function<Class&, Member&> {
+  mem_ref_t(Member Class::*m) : m_member(m) {}
 
   Member& operator () (Class& c) {
     return c.*m_member;
   }
 
+  Member Class::*m_member;
+};
+
+template <typename Class, typename Member>
+struct const_mem_ref_t : public std::unary_function<const Class&, const Member&> {
+  const_mem_ref_t(const Member Class::*m) : m_member(m) {}
+
   const Member& operator () (const Class& c) {
     return c.*m_member;
   }
 
-  Member Class::*m_member;
+  const Member Class::*m_member;
 };
 
 template <typename Class, typename Member>
-inline mem_ptr_ref_t<Class, Member>
-mem_ptr_ref(Member Class::*m) {
-  return mem_ptr_ref_t<Class, Member>(m);
+inline mem_ref_t<Class, Member>
+mem_ref(Member Class::*m) {
+  return mem_ref_t<Class, Member>(m);
+}
+
+template <typename Class, typename Member>
+inline const_mem_ref_t<Class, Member>
+const_mem_ref(const Member Class::*m) {
+  return const_mem_ref_t<Class, Member>(m);
 }
 
 template <typename Cond, typename Then>
 struct if_then_t {
   if_then_t(Cond c, Then t) : m_cond(c), m_then(t) {}
 
@@ -329,40 +381,38 @@
 inline void
 call_delete_func(T* t) {
   delete t;
 }
 
 template <typename Operation>
-class bind1st_t : public std::unary_function<typename Operation::second_argument_type,
-					     typename Operation::result_type> {
-protected:
-  typedef typename reference_fix<typename Operation::first_argument_type>::type value_type;
+class bind1st_t : public std::unary_function<typename Operation::second_argument_type, typename Operation::result_type> {
+public:
+  typedef typename reference_fix<typename Operation::first_argument_type>::type  value_type;
   typedef typename reference_fix<typename Operation::second_argument_type>::type argument_type;
 
-  Operation  m_op;
-  value_type m_value;
-
-public:
   bind1st_t(const Operation& op, const value_type v) :
     m_op(op), m_value(v) {}
 
   typename Operation::result_type
   operator () (const argument_type arg) {
     return m_op(m_value, arg);
   }
-};	    
+
+protected:
+  Operation  m_op;
+  value_type m_value;
+};
 
 template <typename Operation, typename Type>
 inline bind1st_t<Operation>
 bind1st(const Operation& op, const Type& val) {
   return bind1st_t<Operation>(op, val);
 }
 
 template <typename Operation>
-class bind2nd_t : public std::unary_function<typename Operation::first_argument_type,
-					     typename Operation::result_type> {
+class bind2nd_t : public std::unary_function<typename Operation::first_argument_type, typename Operation::result_type> {
 public:
   typedef typename reference_fix<typename Operation::first_argument_type>::type argument_type;
   typedef typename reference_fix<typename Operation::second_argument_type>::type value_type;
 
   bind2nd_t(const Operation& op, const value_type v) :
     m_op(op), m_value(v) {}
@@ -372,14 +422,13 @@
     return m_op(arg, m_value);
   }
 
 protected:
   Operation  m_op;
   value_type m_value;
-
-};	    
+};
 
 template <typename Operation, typename Type>
 inline bind2nd_t<Operation>
 bind2nd(const Operation& op, const Type& val) {
   return bind2nd_t<Operation>(op, val);
 }
@@ -388,12 +437,13 @@
 // be replaced by TR1 stuff later. Requires an object to bind, instead
 // of using a seperate functor for that.
 
 template <typename Object, typename Ret>
 class mem_fun0 {
 public:
+  typedef Ret result_type;
   typedef Ret (Object::*Function)();
 
   mem_fun0() : m_object(NULL) {}
   mem_fun0(Object* o, Function f) : m_object(o), m_function(f) {}
 
   bool is_valid() const { return m_object; }
@@ -405,12 +455,13 @@
   Function m_function;
 };
 
 template <typename Object, typename Ret>
 class const_mem_fun0 {
 public:
+  typedef Ret result_type;
   typedef Ret (Object::*Function)() const;
 
   const_mem_fun0() : m_object(NULL) {}
   const_mem_fun0(Object* o, Function f) : m_object(o), m_function(f) {}
 
   bool is_valid() const { return m_object; }
@@ -422,12 +473,13 @@
   Function m_function;
 };
 
 template <typename Object, typename Ret, typename Arg1>
 class mem_fun1 {
 public:
+  typedef Ret result_type;
   typedef Ret (Object::*Function)(Arg1);
 
   mem_fun1() : m_object(NULL) {}
   mem_fun1(Object* o, Function f) : m_object(o), m_function(f) {}
 
   bool is_valid() const { return m_object; }
@@ -439,12 +491,13 @@
   Function m_function;
 };
 
 template <typename Object, typename Ret, typename Arg1>
 class const_mem_fun1 {
 public:
+  typedef Ret result_type;
   typedef Ret (Object::*Function)(Arg1) const;
 
   const_mem_fun1() : m_object(NULL) {}
   const_mem_fun1(Object* o, Function f) : m_object(o), m_function(f) {}
 
   bool is_valid() const { return m_object; }
@@ -456,12 +509,13 @@
   Function m_function;
 };
 
 template <typename Object, typename Ret, typename Arg1, typename Arg2>
 class mem_fun2 : public std::binary_function<Arg1, Arg2, Ret> {
 public:
+  typedef Ret result_type;
   typedef Ret (Object::*Function)(Arg1, Arg2);
   typedef Object object_type;
 
   mem_fun2() : m_object(NULL) {}
   mem_fun2(Object* o, Function f) : m_object(o), m_function(f) {}
 
@@ -477,12 +531,13 @@
   Function m_function;
 };
 
 template <typename Object, typename Ret, typename Arg1, typename Arg2, typename Arg3>
 class mem_fun3 {
 public:
+  typedef Ret result_type;
   typedef Ret (Object::*Function)(Arg1, Arg2, Arg3);
 
   mem_fun3() : m_object(NULL) {}
   mem_fun3(Object* o, Function f) : m_object(o), m_function(f) {}
 
   bool is_valid() const { return m_object; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/ranges.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/ranges.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/ranges.h	2006-05-27 07:20:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/ranges.h	2006-08-03 06:56:14.000000000 +0800
@@ -80,13 +80,13 @@
 template <typename Type>
 void
 ranges<Type>::insert(value_type r) {
   if (r.first >= r.second)
     return;
 
-  iterator first = std::find_if(begin(), end(), rak::less_equal(r.first, rak::mem_ptr_ref(&value_type::second)));
+  iterator first = std::find_if(begin(), end(), rak::less_equal(r.first, rak::const_mem_ref(&value_type::second)));
 
   if (first == end() || r.second < first->first) {
     // The new range is before the first, after the last or between
     // two ranges.
     Base::insert(first, r);
     return;
@@ -104,19 +104,19 @@
 // }
 
 // Find the first ranges that has an end greater than index.
 template <typename Type>
 inline typename ranges<Type>::iterator
 ranges<Type>::find(Type index) {
-  return std::find_if(begin(), end(), rak::less(index, rak::mem_ptr_ref(&value_type::second)));
+  return std::find_if(begin(), end(), rak::less(index, rak::const_mem_ref(&value_type::second)));
 }
 
 template <typename Type>
 inline typename ranges<Type>::const_iterator
 ranges<Type>::find(Type index) const {
-  return std::find_if(begin(), end(), rak::less(index, rak::mem_ptr_ref(&value_type::second)));
+  return std::find_if(begin(), end(), rak::less(index, rak::const_mem_ref(&value_type::second)));
 }
 
 // Use find with no closest match.
 template <typename Type>
 inline bool
 ranges<Type>::has(Type index) const {
@@ -125,13 +125,13 @@
   return itr != end() && index >= itr->first;
 }
 
 template <typename Type>
 inline void
 ranges<Type>::unify(iterator first) {
-  iterator last = std::find_if((first + 1), end(), rak::less(first->second, rak::mem_ptr_ref(&value_type::first)));
+  iterator last = std::find_if((first + 1), end(), rak::less(first->second, rak::const_mem_ref(&value_type::first)));
 
   first->second = std::max(first->second, (last - 1)->second);
   Base::erase((first + 1), last);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/string_manip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/string_manip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/rak/string_manip.h	2006-05-27 07:20:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/rak/string_manip.h	2006-08-13 01:44:53.000000000 +0800
@@ -204,12 +204,33 @@
     ++first;
   }
 
   return dest;
 }
 
+template <typename InputIterator, typename OutputIterator> 
+OutputIterator
+copy_escape_html(InputIterator first1, InputIterator last1, OutputIterator first2, OutputIterator last2) {
+  while (first1 != last1) {
+    if (std::isalpha(*first1, std::locale::classic()) ||
+        std::isdigit(*first1, std::locale::classic()) ||
+        *first1 == '-') {
+      if (first2 == last2) break; else *(first2++) = *first1;
+
+    } else {
+      if (first2 == last2) break; else *(first2++) = '%';
+      if (first2 == last2) break; else *(first2++) = value_to_hexchar<1>(*first1);
+      if (first2 == last2) break; else *(first2++) = value_to_hexchar<0>(*first1);
+    }
+
+    ++first1;
+  }
+
+  return first2;
+}
+
 template <typename Sequence>
 Sequence
 copy_escape_html(const Sequence& src) {
   Sequence dest;
   copy_escape_html(src.begin(), src.end(), std::back_inserter(dest));
 
@@ -227,12 +248,25 @@
     ++first;
   }
 
   return dest;
 }
 
+template <typename InputIterator, typename OutputIterator> 
+OutputIterator
+transform_hex(InputIterator first1, InputIterator last1, OutputIterator first2, OutputIterator last2) {
+  while (first1 != last1) {
+    if (first2 == last2) break; else *(first2++) = value_to_hexchar<1>(*first1);
+    if (first2 == last2) break; else *(first2++) = value_to_hexchar<0>(*first1);
+
+    ++first1;
+  }
+
+  return first2;
+}
+
 template <typename Sequence>
 Sequence
 transform_hex(const Sequence& src) {
   Sequence dest;
   transform_hex(src.begin(), src.end(), std::back_inserter(dest));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/scripts/checks.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/scripts/checks.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/scripts/checks.m4	2006-06-05 15:34:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/scripts/checks.m4	2006-07-19 06:40:46.000000000 +0800
@@ -226,12 +226,13 @@
     [
       AC_DEFINE(FS_STAT_FD, [fstatvfs(fd, &m_stat) == 0], Function to determine filesystem stats from fd)
       AC_DEFINE(FS_STAT_FN, [statvfs(fn, &m_stat) == 0], Function to determine filesystem stats from filename)
       AC_DEFINE(FS_STAT_STRUCT, [struct statvfs], Type of second argument to statfs function)
       AC_DEFINE(FS_STAT_SIZE_TYPE, [unsigned long], Type of block size member in stat struct)
       AC_DEFINE(FS_STAT_COUNT_TYPE, [fsblkcnt_t], Type of block count member in stat struct)
+      AC_DEFINE(FS_STAT_BLOCK_SIZE, [(m_stat.f_frsize)], Determine the block size)
       AC_MSG_RESULT(ok)
       have_stat_vfs=yes
     ],
     [
       AC_MSG_RESULT(no)
       have_stat_vfs=no
@@ -262,12 +263,13 @@
     [
       AC_DEFINE(FS_STAT_FD, [fstatfs(fd, &m_stat) == 0], Function to determine filesystem stats from fd)
       AC_DEFINE(FS_STAT_FN, [statfs(fn, &m_stat) == 0], Function to determine filesystem stats from filename)
       AC_DEFINE(FS_STAT_STRUCT, [struct statfs], Type of second argument to statfs function)
       AC_DEFINE(FS_STAT_SIZE_TYPE, [long], Type of block size member in stat struct)
       AC_DEFINE(FS_STAT_COUNT_TYPE, [long], Type of block count member in stat struct)
+      AC_DEFINE(FS_STAT_BLOCK_SIZE, [(m_stat.f_bsize)], Determine the block size)
       AC_MSG_RESULT(ok)
     ],
     [
       AC_MSG_RESULT(no)
     ])
 ])
@@ -275,12 +277,13 @@
 AC_DEFUN([TORRENT_DISABLED_STATFS], [
       AC_DEFINE(FS_STAT_FD, [(errno = ENOSYS) == 0], Function to determine filesystem stats from fd)
       AC_DEFINE(FS_STAT_FN, [(errno = ENOSYS) == 0], Function to determine filesystem stats from filename)
       AC_DEFINE(FS_STAT_STRUCT, [struct {blocksize_type  f_bsize; blockcount_type f_bavail;}], Type of second argument to statfs function)
       AC_DEFINE(FS_STAT_SIZE_TYPE, [int], Type of block size member in stat struct)
       AC_DEFINE(FS_STAT_COUNT_TYPE, [int], Type of block count member in stat struct)
+      AC_DEFINE(FS_STAT_BLOCK_SIZE, [(4096)], Determine the block size)
       AC_MSG_RESULT(No filesystem stats available)
 ])
 
 AC_DEFUN([TORRENT_WITHOUT_STATVFS], [
   AC_ARG_WITH(statvfs,
     [  --without-statvfs       Don't try to use statvfs to find free diskspace.],
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/control.cc	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/control.cc	2006-08-16 06:48:07.000000000 +0800
@@ -90,27 +90,30 @@
   delete m_inputStdin;
   delete m_input;
 
   delete m_commandScheduler;
   delete m_variables;
 
+  delete m_viewManager;
+
   delete m_ui;
   delete m_display;
   delete m_core;
+  delete m_scheduler;
 
   delete m_clientInfo;
 }
 
 void
 Control::initialize() {
   display::Canvas::initialize();
   display::Window::slot_schedule(rak::make_mem_fun(m_display, &display::Manager::schedule));
   display::Window::slot_unschedule(rak::make_mem_fun(m_display, &display::Manager::unschedule));
   display::Window::slot_adjust(rak::make_mem_fun(m_display, &display::Manager::adjust_layout));
 
-  m_core->get_poll_manager()->get_http_stack()->set_user_agent(std::string(PACKAGE "/" VERSION "/") + torrent::version());
+  m_core->get_poll_manager()->get_http_stack()->set_user_agent(USER_AGENT);
 
   m_core->initialize_second();
   m_core->listen_open();
   m_core->download_store()->enable(m_variables->get_value("session_lock"));
 
   m_core->set_hashing_view(*m_viewManager->find_throw("hashing"));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/curl_stack.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/curl_stack.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/curl_stack.cc	2006-07-05 00:58:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/curl_stack.cc	2006-08-11 05:20:10.000000000 +0800
@@ -71,23 +71,22 @@
     if (code > 0)
       throw std::runtime_error("Error calling curl_multi_perform");
 
     if (s != m_size) {
       // Done with some handles.
       int t;
+      CURLMsg* msg;
 
-      do {
-        CURLMsg* msg = curl_multi_info_read((CURLM*)m_handle, &t);
-
+      while ((msg = curl_multi_info_read((CURLM*)m_handle, &t)) != NULL) {
         CurlGetList::iterator itr = std::find_if(m_getList.begin(), m_getList.end(), rak::equal(msg->easy_handle, std::mem_fun(&CurlGet::handle)));
 
         if (itr == m_getList.end())
           throw std::logic_error("Could not find CurlGet with the right easy_handle");
         
         (*itr)->perform(msg);
-      } while (t);
+      }
     }
 
   } while (code == CURLM_CALL_MULTI_PERFORM);
 }
 
 unsigned int
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download.cc	2006-07-08 03:22:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download.cc	2006-08-09 04:08:08.000000000 +0800
@@ -88,19 +88,17 @@
   // value, it indicates the last time the torrent changed its state,
   // resume/pause.
   m_variables.insert("state_changed",      new utils::VariableObject(bencode(), "rtorrent", "state_changed", torrent::Object::TYPE_VALUE));
 
   m_variables.insert("directory",          new utils::VariableStringSlot(rak::mem_fn(&m_fileList, &torrent::FileList::root_dir), rak::mem_fn(this, &Download::set_root_directory)));
 
+  m_variables.insert("info_hash",          new utils::VariableStringSlot(rak::mem_fn(&m_download, &torrent::Download::info_hash), NULL));
+
   m_variables.insert("min_peers",          new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::peers_min), rak::mem_fn(&m_download, &download_type::set_peers_min)));
   m_variables.insert("max_peers",          new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::peers_max), rak::mem_fn(&m_download, &download_type::set_peers_max)));
   m_variables.insert("max_uploads",        new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::uploads_max), rak::mem_fn(&m_download, &download_type::set_uploads_max)));
-  m_variables.insert("max_chunks_queued",  new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::max_chunks_queued), rak::mem_fn(&m_download, &download_type::set_max_chunks_queued)));
-
-  m_variables.insert("timeout_sync",       new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::timeout_sync), rak::mem_fn(&m_download, &download_type::set_timeout_sync)));
-  m_variables.insert("timeout_safe_sync",  new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::timeout_safe_sync), rak::mem_fn(&m_download, &download_type::set_timeout_safe_sync)));
 
   m_variables.insert("priority",           new utils::VariableValueSlot(rak::mem_fn(this, &Download::priority), rak::mem_fn(this, &Download::set_priority)));
 
   m_variables.insert("ignore_commands",    new utils::VariableObject(bencode(), "rtorrent", "ignore_commands", torrent::Object::TYPE_VALUE));
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download_factory.cc	2006-07-09 02:28:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download_factory.cc	2006-08-16 23:56:45.000000000 +0800
@@ -169,27 +169,24 @@
 
   initialize_rtorrent(download, rtorrent);
 
   // Move to 'rtorrent'.
   download->variable()->set("connection_leech", m_variables.get("connection_leech"));
   download->variable()->set("connection_seed",  m_variables.get("connection_seed"));
+
+  download->variable()->set("max_uploads",      control->variable()->get("max_uploads"));
   download->variable()->set("min_peers",        control->variable()->get("min_peers"));
   download->variable()->set("max_peers",        control->variable()->get("max_peers"));
-  download->variable()->set("max_uploads",      control->variable()->get("max_uploads"));
 
-  if (!control->variable()->get_value("timeout_sync") != 0)
-    download->variable()->set("timeout_sync", control->variable()->get("timeout_sync"));
-
-  if (!control->variable()->get_value("timeout_safe_sync") != 0)
-    download->variable()->set("timeout_safe_sync", control->variable()->get("timeout_safe_sync"));
-
-  if (!control->variable()->get_value("max_chunks_queued") != 0)
-    download->variable()->set("max_chunks_queued", control->variable()->get("max_chunks_queued"));
-  else
-    // Temporary until we fix the library.
-    download->variable()->set("max_chunks_queued", (512 << 20) / download->download()->chunks_size());
+  if (download->variable()->get_value("complete") != 0) {
+    if (control->variable()->get_value("min_peers_seed") >= 0)
+      download->variable()->set("min_peers", control->variable()->get("min_peers_seed"));
+
+    if (control->variable()->get_value("max_peers_seed") >= 0)
+      download->variable()->set("max_peers", control->variable()->get("max_peers_seed"));
+  }
 
   if (!control->variable()->get_value("use_udp_trackers"))
     download->enable_udp_trackers(false);
 
   if (!rtorrent->has_key_string("directory"))
     download->variable()->set("directory", m_variables.get("directory"));
@@ -202,12 +199,13 @@
   torrent::Object& resumeObject = root->has_key_map("libtorrent_resume")
     ? root->get_key("libtorrent_resume")
     : root->insert_key("libtorrent_resume", torrent::Object(torrent::Object::TYPE_MAP));
 
   torrent::resume_load_addresses(*download->download(), resumeObject);
   torrent::resume_load_file_priorities(*download->download(), resumeObject);
+  torrent::resume_load_tracker_settings(*download->download(), resumeObject);
 
   // The action of inserting might cause the torrent to be
   // opened/started or such. Figure out a nicer way of handling this.
   if (m_manager->download_list()->insert(download) == m_manager->download_list()->end()) {
     // ATM doesn't really ever get here.
     delete download;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download.h	2006-07-08 04:47:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download.h	2006-08-13 01:40:32.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_CORE_DOWNLOAD_H
 #define RTORRENT_CORE_DOWNLOAD_H
 
+#include <rak/string_manip.h>
 #include <sigc++/connection.h>
 #include <torrent/download.h>
 #include <torrent/file_list.h>
 #include <torrent/tracker_list.h>
 #include <torrent/torrent.h>
 
@@ -80,20 +81,18 @@
 
   variable_map_type*  variable()                                     { return &m_variables; }
   int64_t             variable_value(const std::string& key) const   { return m_variables.get_value(key); }
   const std::string&  variable_string(const std::string& key) const  { return m_variables.get_string(key); }
 
   download_type*       download()                              { return &m_download; }
-  const download_type* download() const                        { return &m_download; }
+  const download_type* c_download() const                      { return &m_download; }
 
   torrent::Object*    bencode()                                { return m_download.bencode(); }
   file_list_type*     file_list()                              { return &m_fileList; }
   tracker_list_type*  tracker_list()                           { return &m_trackerList; }
 
-  const std::string&  info_hash() const                        { return m_download.info_hash(); }
-
   const std::string&  message() const                          { return m_message; }
   void                set_message(const std::string& msg)      { m_message = msg; }
 
   uint32_t            chunks_failed() const                    { return m_chunksFailed; }
 
   void                enable_udp_trackers(bool state);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download_list.cc	2006-07-08 04:13:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download_list.cc	2006-08-16 03:24:32.000000000 +0800
@@ -318,13 +318,13 @@
       download->set_connection_type(download->variable()->get_string("connection_leech"));
 
       // For the moment, clear the resume data so we force hash-check
       // on non-complete downloads after a crash. This shouldn't be
       // needed, but for some reason linux 2.6 is very lazy about
       // updating mtime.
-      torrent::resume_clear_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
+      torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"), true);
     }
 
     // Update the priority to ensure it has the correct
     // seeding/unfinished modifiers.
     download->set_priority(download->priority());
     download->download()->start();
@@ -436,16 +436,18 @@
       resume(download);
 
     break;
 
   case Download::variable_hashing_last:
 
-    if (download->is_done())
+    if (download->is_done()) {
       confirm_finished(download);
-    else
-      download->set_message("Hash check on download completion found bad chunks.");
+    } else {
+      download->set_message("Hash check on download completion found bad chunks, consider using \"safe_sync\".");
+      control->core()->push_log("Hash check on download completion found bad chunks, consider using \"safe_sync\".");
+    }
     
     break;
 
   case Download::variable_hashing_stopped:
   default:
     // Either an error or someone wrote to the hashing variable...
@@ -498,12 +500,18 @@
 
   download->variable()->set("complete", (int64_t)1);
 
   download->set_connection_type(download->variable()->get_string("connection_seed"));
   download->set_priority(download->priority());
 
+  if (download->variable_value("min_peers") == control->variable()->get_value("min_peers") && control->variable()->get_value("min_peers_seed") >= 0)
+    download->variable()->set("min_peers", control->variable()->get("min_peers_seed"));
+
+  if (download->variable_value("max_peers") == control->variable()->get_value("max_peers") && control->variable()->get_value("max_peers_seed") >= 0)
+    download->variable()->set("max_peers", control->variable()->get("max_peers_seed"));
+
   // Do this before the slots are called in case one of them closes
   // the download.
   if (!download->is_active() && control->variable()->get_value("session_on_completion") != 0) {
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     control->core()->download_store()->save(download);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download_store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download_store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/download_store.cc	2006-07-02 04:16:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/download_store.cc	2006-08-13 01:45:42.000000000 +0800
@@ -106,14 +106,17 @@
     return;
 
   // Move this somewhere else?
   d->bencode()->get_key("rtorrent").insert_key("total_uploaded", d->download()->up_rate()->total());
   d->bencode()->get_key("rtorrent").insert_key("chunks_done", d->download()->chunks_done());
 
-  torrent::resume_save_addresses(*d->download(), d->download()->bencode()->get_key("libtorrent_resume"));
-  torrent::resume_save_file_priorities(*d->download(), d->download()->bencode()->get_key("libtorrent_resume"));
+  torrent::Object& resumeObject = d->download()->bencode()->get_key("libtorrent_resume");
+
+  torrent::resume_save_addresses(*d->download(), resumeObject);
+  torrent::resume_save_file_priorities(*d->download(), resumeObject);
+  torrent::resume_save_tracker_settings(*d->download(), resumeObject);
 
   f << *d->bencode();
 
   if (!f.good())
     return;
 
@@ -168,10 +171,10 @@
 
   return true;
 }
 
 std::string
 DownloadStore::create_filename(Download* d) {
-  return m_path + rak::transform_hex(d->info_hash()) + ".torrent";
+  return m_path + rak::transform_hex(d->download()->info_hash()) + ".torrent";
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/log.cc	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/log.cc	2006-08-03 06:21:54.000000000 +0800
@@ -56,10 +56,10 @@
 
   m_signalUpdate.emit();
 }
 
 Log::iterator
 Log::find_older(rak::timer t) {
-  return std::find_if(begin(), end(), rak::on(rak::mem_ptr_ref(&Type::first), std::bind2nd(std::less_equal<rak::timer>(), t)));
+  return std::find_if(begin(), end(), rak::on(rak::mem_ref(&Type::first), std::bind2nd(std::less_equal<rak::timer>(), t)));
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/view_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/view_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/core/view_manager.cc	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/core/view_manager.cc	2006-08-16 07:35:21.000000000 +0800
@@ -150,13 +150,14 @@
   m_filter["hashing"]     = new ViewFilterVariableValue("hashing", 0, true);
 }
 
 void
 ViewManager::clear() {
   std::for_each(begin(), end(), rak::call_delete<View>());
-  std::for_each(m_sort.begin(), m_sort.end(), rak::on(rak::mem_ptr_ref(&sort_map::value_type::second), rak::call_delete<ViewSort>()));
+  std::for_each(m_sort.begin(), m_sort.end(), rak::on(rak::mem_ref(&sort_map::value_type::second), rak::call_delete<ViewSort>()));
+  std::for_each(m_filter.begin(), m_filter.end(), rak::on(rak::mem_ref(&filter_map::value_type::second), rak::call_delete<ViewFilter>()));
 
   base_type::clear();
 }
 
 ViewManager::iterator
 ViewManager::insert(const std::string& name) {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: attributes.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/canvas.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/canvas.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/canvas.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/canvas.cc	2006-08-11 18:45:46.000000000 +0800
@@ -36,12 +36,13 @@
 
 #include "config.h"
 
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <sys/termios.h>
+#include <torrent/exceptions.h>
 
 #include "canvas.h"
 
 namespace display {
 
 bool Canvas::m_isInitialized = false;
@@ -50,12 +51,34 @@
 Canvas::resize(int x, int y, int w, int h) {
   wresize(m_window, h, w);
   mvwin(m_window, y, x);
 }
 
 void
+Canvas::print_attributes(unsigned int x, unsigned int y, const char* first, const char* last, const attributes_list* attributes) {
+  move(x, y);
+
+  int attr = A_NORMAL;
+  attributes_list::const_iterator attrItr = attributes->begin();
+
+  while (first != last) {
+    if (attrItr != attributes->end() && attrItr->position() <= first) {
+      attr = attrItr->attributes();
+      // Set colors or something.
+
+      attrItr++;
+      continue;
+    }
+
+    waddch(m_window, *first++ | attr);
+  }
+
+  // Reset the color.
+}
+
+void
 Canvas::initialize() {
   if (m_isInitialized)
     return;
   
   m_isInitialized = true;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/canvas.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/canvas.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/canvas.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/canvas.h	2006-08-16 04:23:44.000000000 +0800
@@ -35,18 +35,22 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_DISPLAY_CANVAS_H
 #define RTORRENT_DISPLAY_CANVAS_H
 
 #include <string>
-#include <ncurses.h>
+#include <vector>
+
+#include "attributes.h"
 
 namespace display {
 
 class Canvas {
 public:
+  typedef std::vector<Attributes> attributes_list;
+
   Canvas(int x = 0, int y = 0, int width = 0, int height = 0) :
     m_window(newwin(height, width, y, x)) {}
   ~Canvas() { delwin(m_window); }
 
   void                refresh()                                               { wnoutrefresh(m_window); }
   static void         refresh_std()                                           { wnoutrefresh(stdscr); }
@@ -56,16 +60,19 @@
   void                resize(int w, int h)                                    { wresize(m_window, h, w); }
   void                resize(int x, int y, int w, int h);
 
   static void         resize_term(int x, int y)                               { resizeterm(y, x); }
   static void         resize_term(std::pair<int, int> dim)                    { resizeterm(dim.second, dim.first); }
 
-  int                 get_x()                                                 { int x, y; getyx(m_window, y, x); return x; }
-  int                 get_y()                                                 { int x, y; getyx(m_window, y, x); return y; }
-  int                 get_width()                                             { int x, y; getmaxyx(m_window, y, x); return x; }
-  int                 get_height()                                            { int x, y; getmaxyx(m_window, y, x); return y; }
+  unsigned int        get_x()                                                 { int x, y; getyx(m_window, y, x); return x; }
+  unsigned int        get_y()                                                 { int x, y; getyx(m_window, y, x); return y; }
+
+  unsigned int        width()                                                 { int x, y; getmaxyx(m_window, y, x); return x; }
+  unsigned int        height()                                                { int x, y; getmaxyx(m_window, y, x); return y; }
+
+  void                move(unsigned int x, unsigned int y)                    { wmove(m_window, y, x); }
 
   chtype              get_background()                                        { return getbkgd(m_window); }
   void                set_background(chtype c)                                { return wbkgdset(m_window, c); }
 
   void                erase()                                                 { werase(m_window); }
   static void         erase_std()                                             { werase(stdscr); }
@@ -76,49 +83,20 @@
 				   chtype bl, chtype br)                      { wborder(m_window, ls, rs, ts, bs, tl, tr, bl, br); }
 
   // The format string is non-const, but that will not be a problem
   // since the string shall always be a C string choosen at
   // compiletime. Might cause extra copying of the string?
 
-  void                print(int x, int y, char* str)                          { mvwprintw(m_window, y, x, str); }
-
-  template <typename A1>
-  void                print(int x, int y, char* str, A1 a1)                   { mvwprintw(m_window, y, x, str, a1); }
-
-  template <typename A1, typename A2>
-  void                print(int x, int y, char* str, A1 a1, A2 a2)            { mvwprintw(m_window, y, x, str, a1, a2); }
-
-  template <typename A1, typename A2, typename A3>
-  void                print(int x, int y, char* str,
-	                    A1 a1, A2 a2, A3 a3)                              { mvwprintw(m_window, y, x, str, a1, a2, a3); }
+  void                print(unsigned int x, unsigned int y, const char* str, ...);
 
-  template <typename A1, typename A2, typename A3, typename A4>
-  void                print(int x, int y, char* str,
-	                    A1 a1, A2 a2, A3 a3, A4 a4)                       { mvwprintw(m_window, y, x, str, a1, a2, a3, a4); }
+  void                print_attributes(unsigned int x, unsigned int y, const char* first, const char* last, const attributes_list* attributes);
 
-  template <typename A1, typename A2, typename A3, typename A4, typename A5>
-  void                print(int x, int y, char* str,
-        	            A1 a1, A2 a2, A3 a3, A4 a4, A5 a5)                { mvwprintw(m_window, y, x, str, a1, a2, a3, a4, a5); }
+  void                print_char(const chtype ch)                                 { waddch(m_window, ch); }
+  void                print_char(unsigned int x, unsigned int y, const chtype ch) { mvwaddch(m_window, y, x, ch); }
 
-  template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
-  void                print(int x, int y, char* str,
-			    A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6)         { mvwprintw(m_window, y, x, str, a1, a2, a3, a4, a5, a6); }
-
-  template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
-  void                print(int x, int y, char* str,
-               	            A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)  { mvwprintw(m_window, y, x, str, a1, a2, a3, a4, a5, a6, a7); }
-
-  template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
-  void                print(int x, int y, char* str,
-               	            A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) { mvwprintw(m_window, y, x, str, a1, a2, a3, a4, a5, a6, a7, a8); }
-
-  void                print_char(const chtype ch) { waddch(m_window, ch); }
-
-  void                print_char(int x, int y, const chtype ch) { mvwaddch(m_window, y, x, ch); }
-
-  void                set_attr(int x, int y, int n, int attr, int color)      { mvwchgat(m_window, y, x, n, attr, color, NULL); }
+  void                set_attr(unsigned int x, unsigned int y, unsigned int n, int attr, int color) { mvwchgat(m_window, y, x, n, attr, color, NULL); }
 
   // Initialize stdscr.
   static void         initialize();
   static void         cleanup();
 
   static int          get_screen_width()                                      { int x, y; getmaxyx(stdscr, y, x); return x; }
@@ -134,13 +112,19 @@
 
   static bool         m_isInitialized;
 
   WINDOW*             m_window;
 };
 
-// Undefines 'timeout' that ncurses defines which screws up the global
-// namespace. Idiots; Especially you, ESR.
-#undef timeout
+inline void
+Canvas::print(unsigned int x, unsigned int y, const char* str, ...) {
+  va_list arglist;
+
+  va_start(arglist, str);
+  wmove(m_window, y, x);
+  vw_printw(m_window, const_cast<char*>(str), arglist);
+  va_end(arglist);
+}
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/client_info.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/client_info.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/client_info.cc	2006-07-05 17:26:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/client_info.cc	2006-08-12 04:41:57.000000000 +0800
@@ -69,12 +69,13 @@
   insert(TYPE_AZUREUS, "BC", "BitComet");
   insert(TYPE_AZUREUS, "UT", "uTorrent");
   insert(TYPE_AZUREUS, "lt", "libTorrent");
   insert(TYPE_AZUREUS, "CT", "CTorrent");
   insert(TYPE_AZUREUS, "MT", "MoonlightTorrent");
   insert(TYPE_AZUREUS, "LT", "libtorrent");
+  insert(TYPE_AZUREUS, "LP", "Lphant");
   insert(TYPE_AZUREUS, "KT", "KTorrent");
   insert(TYPE_AZUREUS, "BX", "Bittorrent X");
   insert(TYPE_AZUREUS, "TS", "Torrentstorm");
   insert(TYPE_AZUREUS, "TN", "TorrentDotNET");
   insert(TYPE_AZUREUS, "TR", "Transmission");
   insert(TYPE_AZUREUS, "SS", "SwarmScope");
@@ -121,21 +122,21 @@
 
   std::memcpy(itr->first, key, keySize);
   itr->second = name;
 }
 
 char*
-ClientInfo::print(char* first, char* last, const char* id) {
+ClientInfo::print(char* first, char* last, const char* id) const {
 
   if (id[0] == '-' && id[7] == '-' &&
       std::isalpha(id[1]) && std::isalpha(id[2]) &&
       std::isxdigit(id[3]) && std::isxdigit(id[4]) && std::isxdigit(id[5]) && std::isxdigit(id[6])) {
     // TYPE_AZUREUS.
 
-    iterator itr = std::find_if(m_containers[TYPE_AZUREUS].begin(), m_containers[TYPE_AZUREUS].end(),
-				client_info_equal(id + 1, sizeof_key(TYPE_AZUREUS)));
+    const_iterator itr = std::find_if(m_containers[TYPE_AZUREUS].begin(), m_containers[TYPE_AZUREUS].end(),
+                                      client_info_equal(id + 1, sizeof_key(TYPE_AZUREUS)));
 
     if (itr != m_containers[TYPE_AZUREUS].end())
       first = print_buffer(first, last, "%s %hhu.%hhu.%hhu.%hhu", itr->second,
 			   rak::hexchar_to_value(id[3]), rak::hexchar_to_value(id[4]),
 			   rak::hexchar_to_value(id[5]), rak::hexchar_to_value(id[6]));
     
@@ -145,14 +146,14 @@
 			   rak::hexchar_to_value(id[5]), rak::hexchar_to_value(id[6]));
 
   } else if (std::isalpha(id[0]) && id[4] == '-' &&
 	     std::isxdigit(id[1]) && std::isxdigit(id[2]) && std::isxdigit(id[3])) {
     // TYPE_THREE_COMPACT.
 
-    iterator itr = std::find_if(m_containers[TYPE_COMPACT].begin(), m_containers[TYPE_COMPACT].end(),
-				client_info_equal(id, sizeof_key(TYPE_COMPACT)));
+    const_iterator itr = std::find_if(m_containers[TYPE_COMPACT].begin(), m_containers[TYPE_COMPACT].end(),
+                                      client_info_equal(id, sizeof_key(TYPE_COMPACT)));
 
     if (itr != m_containers[TYPE_COMPACT].end())
       first = print_buffer(first, last, "%s %hhu.%hhu.%hhu", itr->second,
 			   rak::hexchar_to_value(id[1]), rak::hexchar_to_value(id[2]), rak::hexchar_to_value(id[3]));
     
     else
@@ -160,14 +161,14 @@
 			   rak::hexchar_to_value(id[1]), rak::hexchar_to_value(id[2]), rak::hexchar_to_value(id[3]));
     
   } else if (std::isalpha(id[0]) && id[2] == '-' && id[4] == '-' && id[6] == '-' &&
 	     std::isxdigit(id[1]) && std::isxdigit(id[3]) && std::isxdigit(id[5])) {
     // TYPE_THREE_SPARSE.
 
-    iterator itr = std::find_if(m_containers[TYPE_MAINLINE].begin(), m_containers[TYPE_MAINLINE].end(),
-				client_info_equal(id, sizeof_key(TYPE_MAINLINE)));
+    const_iterator itr = std::find_if(m_containers[TYPE_MAINLINE].begin(), m_containers[TYPE_MAINLINE].end(),
+                                      client_info_equal(id, sizeof_key(TYPE_MAINLINE)));
 
     if (itr != m_containers[TYPE_MAINLINE].end())
       first = print_buffer(first, last, "%s %hhu.%hhu.%hhu", itr->second,
 			   rak::hexchar_to_value(id[1]), rak::hexchar_to_value(id[3]), rak::hexchar_to_value(id[5]));
     
     else
@@ -185,7 +186,15 @@
     first = print_buffer(first, last, "unknown");
   }
 
   return first;
 }
 
+std::string
+ClientInfo::str(const char* id) const {
+  char buf[128];
+  print(buf, buf + 127, id);
+
+  return std::string(buf);
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/client_info.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/client_info.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/client_info.h	2006-05-28 02:27:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/client_info.h	2006-08-12 04:49:34.000000000 +0800
@@ -49,27 +49,32 @@
   static const uint32_t key_size = 3;
 
   typedef uint32_t                               size_type;
   typedef std::pair<char[key_size], const char*> value_type;
   typedef std::vector<value_type>                container_type;
   typedef container_type::iterator               iterator;
+  typedef container_type::const_iterator         const_iterator;
 
   typedef enum {
     TYPE_AZUREUS,
     TYPE_COMPACT,
     TYPE_MAINLINE,
     TYPE_MAXSIZE
   } Type;
 
   ClientInfo();
 
   void                insert(Type t, const char* key, const char* name);
 
-  char*               print(char* first, char* last, const char* id);
+  char*               print(char* first, char* last, const char* id) const;
 
-  size_type           sizeof_key(Type t) {
+  // Fix this...
+  std::string         str(const char* id) const;
+  std::string         str_str(const std::string& id) const { return str(id.c_str()); }
+
+  size_type           sizeof_key(Type t) const {
     switch (t) {
     case TYPE_AZUREUS:  return 2;
     case TYPE_COMPACT:  return 1;
     case TYPE_MAINLINE: return 1;
     default:
     case TYPE_MAXSIZE:  return 0;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: frame.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: frame.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/Makefile.am	2006-06-10 05:49:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/Makefile.am	2006-08-13 21:58:06.000000000 +0800
@@ -1,17 +1,29 @@
 noinst_LIBRARIES = libsub_display.a
 
 libsub_display_a_SOURCES = \
+	attributes.h \
 	canvas.cc \
 	canvas.h \
 	client_info.cc \
 	client_info.h \
+	frame.cc \
+	frame.h \
 	manager.cc \
 	manager.h \
 	utils.cc \
 	utils.h \
+	text_element.h \
+	text_element_helpers.h \
+	text_element_lambda.h \
+	text_element_list.cc \
+	text_element_list.h \
+	text_element_string.cc \
+	text_element_string.h \
+	text_element_value.cc \
+	text_element_value.h \
 	window.cc \
 	window.h \
 	window_download_chunks_seen.cc \
 	window_download_chunks_seen.h \
 	window_download_list.cc \
 	window_download_list.h \
@@ -26,20 +38,20 @@
 	window_input.cc \
 	window_input.h \
 	window_log.cc \
 	window_log.h \
 	window_log_complete.cc \
 	window_log_complete.h \
-	window_peer_info.cc \
-	window_peer_info.h \
 	window_peer_list.cc \
 	window_peer_list.h \
 	window_statusbar.cc \
 	window_statusbar.h \
 	window_string_list.cc \
 	window_string_list.h \
+	window_text.cc \
+	window_text.h \
 	window_title.cc \
 	window_title.h \
 	window_tracker_list.cc \
 	window_tracker_list.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/Makefile.in	2006-07-09 04:12:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/Makefile.in	2006-08-14 00:24:21.000000000 +0800
@@ -53,22 +53,24 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_display_a_AR = $(AR) $(ARFLAGS)
 libsub_display_a_LIBADD =
 am_libsub_display_a_OBJECTS = canvas.$(OBJEXT) client_info.$(OBJEXT) \
-	manager.$(OBJEXT) utils.$(OBJEXT) window.$(OBJEXT) \
+	frame.$(OBJEXT) manager.$(OBJEXT) utils.$(OBJEXT) \
+	text_element_list.$(OBJEXT) text_element_string.$(OBJEXT) \
+	text_element_value.$(OBJEXT) window.$(OBJEXT) \
 	window_download_chunks_seen.$(OBJEXT) \
 	window_download_list.$(OBJEXT) \
 	window_download_statusbar.$(OBJEXT) \
 	window_download_transfer_list.$(OBJEXT) \
 	window_file_list.$(OBJEXT) window_http_queue.$(OBJEXT) \
 	window_input.$(OBJEXT) window_log.$(OBJEXT) \
-	window_log_complete.$(OBJEXT) window_peer_info.$(OBJEXT) \
-	window_peer_list.$(OBJEXT) window_statusbar.$(OBJEXT) \
-	window_string_list.$(OBJEXT) window_title.$(OBJEXT) \
+	window_log_complete.$(OBJEXT) window_peer_list.$(OBJEXT) \
+	window_statusbar.$(OBJEXT) window_string_list.$(OBJEXT) \
+	window_text.$(OBJEXT) window_title.$(OBJEXT) \
 	window_tracker_list.$(OBJEXT)
 libsub_display_a_OBJECTS = $(am_libsub_display_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -193,20 +195,32 @@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 noinst_LIBRARIES = libsub_display.a
 libsub_display_a_SOURCES = \
+	attributes.h \
 	canvas.cc \
 	canvas.h \
 	client_info.cc \
 	client_info.h \
+	frame.cc \
+	frame.h \
 	manager.cc \
 	manager.h \
 	utils.cc \
 	utils.h \
+	text_element.h \
+	text_element_helpers.h \
+	text_element_lambda.h \
+	text_element_list.cc \
+	text_element_list.h \
+	text_element_string.cc \
+	text_element_string.h \
+	text_element_value.cc \
+	text_element_value.h \
 	window.cc \
 	window.h \
 	window_download_chunks_seen.cc \
 	window_download_chunks_seen.h \
 	window_download_list.cc \
 	window_download_list.h \
@@ -221,20 +235,20 @@
 	window_input.cc \
 	window_input.h \
 	window_log.cc \
 	window_log.h \
 	window_log_complete.cc \
 	window_log_complete.h \
-	window_peer_info.cc \
-	window_peer_info.h \
 	window_peer_list.cc \
 	window_peer_list.h \
 	window_statusbar.cc \
 	window_statusbar.h \
 	window_string_list.cc \
 	window_string_list.h \
+	window_text.cc \
+	window_text.h \
 	window_title.cc \
 	window_title.h \
 	window_tracker_list.cc \
 	window_tracker_list.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
@@ -284,28 +298,32 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/canvas.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client_info.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/frame.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/manager.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/text_element_list.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/text_element_string.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/text_element_value.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_chunks_seen.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_statusbar.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_transfer_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_file_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_http_queue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_input.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_log.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_log_complete.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_peer_info.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_peer_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_statusbar.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_string_list.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_text.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_title.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_tracker_list.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/manager.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/manager.cc	2006-08-07 21:40:30.000000000 +0800
@@ -58,42 +59,12 @@
 
 void
 Manager::force_redraw() {
   m_forceRedraw = true;
 }
 
-
-Manager::iterator
-Manager::insert(iterator pos, Window* w) {
-  return Base::insert(pos, w);
-}
-
-// Swap with the function below.
-Manager::iterator
-Manager::erase(iterator pos) {
-  if (pos != end())
-    return erase(*pos);
-  else
-    return end();
-}
-
-Manager::iterator
-Manager::erase(Window* w) {
-  iterator itr = std::find(begin(), end(), w);
-
-  if (itr == end())
-    throw std::logic_error("Manager::erase(...) did not find the window");
-
-  return Base::erase(itr);
-}
-
-Manager::iterator
-Manager::find(Window* w) {
-  return std::find(begin(), end(), w);
-}
-
 void
 Manager::schedule(Window* w, rak::timer t) {
   rak::priority_queue_erase(&m_scheduler, w->task_update());
   rak::priority_queue_insert(&m_scheduler, w->task_update(), t);
   schedule_update();
 }
@@ -103,40 +74,14 @@
   rak::priority_queue_erase(&m_scheduler, w->task_update());
   schedule_update();
 }
 
 void
 Manager::adjust_layout() {
-  int staticHeight = std::for_each(begin(), end(),
-				   rak::if_then(std::mem_fun(&Window::is_active),
-						rak::accumulate(0, std::mem_fun(&Window::get_min_height)))).m_then.result;
-  int countDynamic = std::for_each(begin(), end(),
-				   rak::if_then(std::mem_fun(&Window::is_active),
-						rak::accumulate(0, std::mem_fun(&Window::is_dynamic)))).m_then.result;
-
-  int dynamic = std::max(0, Canvas::get_screen_height() - staticHeight);
-  int height = 0, h;
-
-  for (iterator itr = begin(); itr != end(); ++itr, height += h) {
-    h = 0;
-
-    if (!(*itr)->is_active())
-      continue;
-
-    if ((*itr)->is_dynamic()) {
-      dynamic -= h = (dynamic + countDynamic - 1) / countDynamic;
-      countDynamic--;
-    } else {
-      h = 0;
-    }
-
-    h += (*itr)->get_min_height();
-
-    (*itr)->resize(0, height, Canvas::get_screen_width(), h);
-    (*itr)->mark_dirty();
-  }
+  Canvas::redraw_std();
+  m_rootFrame.balance(0, 0, Canvas::get_screen_width(), Canvas::get_screen_height());
 }
 
 void
 Manager::receive_update() {
   if (m_forceRedraw) {
     m_forceRedraw = false;
@@ -140,19 +85,21 @@
 Manager::receive_update() {
   if (m_forceRedraw) {
     m_forceRedraw = false;
 
     display::Canvas::resize_term(display::Canvas::term_size());
     Canvas::redraw_std();
+
     adjust_layout();
+    m_rootFrame.redraw();
   }
 
   Canvas::refresh_std();
 
   rak::priority_queue_perform(&m_scheduler, cachedTime);
-  std::for_each(begin(), end(), rak::if_then(std::mem_fun(&Window::is_active), std::mem_fun(&Window::refresh)));
+  m_rootFrame.refresh();
 
   Canvas::do_update();
 
   m_timeLastUpdate = cachedTime;
   schedule_update();
 }
@@ -163,12 +110,11 @@
     rak::priority_queue_erase(&taskScheduler, &m_taskUpdate);
     return;
   }
 
   if (!m_taskUpdate.is_queued() || m_taskUpdate.time() > m_scheduler.top()->time()) {
     rak::priority_queue_erase(&taskScheduler, &m_taskUpdate);
-    rak::priority_queue_insert(&taskScheduler, &m_taskUpdate,
-			       std::max(m_scheduler.top()->time(), m_timeLastUpdate + 50000));
+    rak::priority_queue_insert(&taskScheduler, &m_taskUpdate, std::max(m_scheduler.top()->time(), m_timeLastUpdate + 50000));
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/manager.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/manager.h	2006-07-25 21:25:36.000000000 +0800
@@ -37,57 +37,44 @@
 #ifndef RTORRENT_DISPLAY_MANAGER_H
 #define RTORRENT_DISPLAY_MANAGER_H
 
 #include <list>
 #include <rak/priority_queue_default.h>
 
+#include "frame.h"
+
 namespace display {
 
 class Window;
 
-class Manager : private std::list<Window*> {
+class Manager {
 public:
-  typedef std::list<Window*> Base;
-
-  using Base::iterator;
-  using Base::const_iterator;
-  using Base::reverse_iterator;
-  using Base::const_reverse_iterator;
-
-  using Base::begin;
-  using Base::end;
-  using Base::rbegin;
-  using Base::rend;
-
-  using Base::push_front;
-  using Base::push_back;
-
   Manager();
   ~Manager();
 
   void                force_redraw();
 
-  iterator            insert(iterator pos, Window* w);
-  iterator            erase(iterator pos);
-  iterator            erase(Window* w);
-
-  iterator            find(Window* w);
-
   void                schedule(Window* w, rak::timer t);
   void                unschedule(Window* w);
 
   void                adjust_layout();
   void                receive_update();
 
+  // New interface.
+  Frame*              root_frame() { return &m_rootFrame; }
+
 private:
   void                schedule_update();
 
   bool                m_forceRedraw;
   rak::timer          m_timeLastUpdate;
 
   rak::priority_queue_default m_scheduler;
   rak::priority_item          m_taskUpdate;
+
+  // New interface.
+  Frame               m_rootFrame;
 };
 
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_helpers.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_lambda.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_list.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_list.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_string.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_string.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_value.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: text_element_value.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/utils.cc	2006-07-08 04:14:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/utils.cc	2006-08-14 20:30:28.000000000 +0800
@@ -167,13 +167,17 @@
 
   return first;
 }
 
 char*
 print_download_status(char* first, char* last, core::Download* d) {
-  if (!d->is_active())
+  if (d->is_active())
+    ;
+  else if (d->variable_value("hashing") != 0)
+    first = print_buffer(first, last, "Hashing: ");
+  else if (!d->is_active())
     first = print_buffer(first, last, "Inactive: ");
 
   if (d->is_hash_checking()) {
     first = print_buffer(first, last, "Checking hash [%2i%%]",
                          (d->download()->chunks_hashed() * 100) / d->download()->chunks_total());
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window.cc	2006-08-03 05:23:31.000000000 +0800
@@ -43,34 +43,50 @@
 namespace display {
 
 Window::SlotTimer  Window::m_slotSchedule;
 Window::SlotWindow Window::m_slotUnschedule;
 Window::Slot       Window::m_slotAdjust;
 
-Window::Window(Canvas* c, bool d, int h) :
-  m_canvas(c),
-  m_active(true),
-  m_dynamic(d),
-  m_minHeight(h) {
+// When constructing the window we set flag_offscreen so that redraw
+// doesn't get triggered until after a successful Frame::balance call.
+
+Window::Window(Canvas* canvas, int flags, extent_type minWidth, extent_type minHeight, extent_type maxWidth, extent_type maxHeight) :
+  m_canvas(canvas),
+  m_flags(flags | flag_offscreen),
+
+  m_minWidth(minWidth),
+  m_minHeight(minHeight),
+
+  m_maxWidth(maxWidth),
+  m_maxHeight(maxHeight) {
 
   m_taskUpdate.set_slot(rak::mem_fn(this, &Window::redraw));
 }
 
 Window::~Window() {
-  m_slotUnschedule(this);
+  if (is_active())
+    m_slotUnschedule(this);
+
   delete m_canvas;
 }
 
 void
-Window::set_active(bool a) {
-  if (a)
+Window::set_active(bool state) {
+  if (state == is_active())
+    return;
+
+  if (state) {
+    // Set offscreen so we don't try rendering before Frame::balance
+    // has been called.
+    m_flags |= flag_active | flag_offscreen;
     mark_dirty();
-  else
-    m_slotUnschedule(this);
 
-  m_active = a;
+  } else {
+    m_flags &= ~flag_active;
+    m_slotUnschedule(this);
+  }
 }
 
 void
 Window::resize(int x, int y, int w, int h) {
   if (x < 0 || y < 0)
     throw std::logic_error("Window::resize(...) bad x or y position");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_chunks_seen.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_chunks_seen.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_chunks_seen.cc	2006-07-02 00:03:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_chunks_seen.cc	2006-08-05 05:53:27.000000000 +0800
@@ -49,24 +49,24 @@
 
 #include "window_download_chunks_seen.h"
 
 namespace display {
 
 WindowDownloadChunksSeen::WindowDownloadChunksSeen(core::Download* d, unsigned int *focus) :
-  Window(new Canvas, true),
+  Window(new Canvas, 0, 0, 0, extent_full, extent_full),
   m_download(d),
   m_focus(focus) {
 }
 
 void
 WindowDownloadChunksSeen::redraw() {
   // TODO: Make this depend on tracker signal.
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(10)).round_seconds());
   m_canvas->erase();
 
-  if (m_canvas->get_height() < 3 || m_canvas->get_width() < 18)
+  if (m_canvas->height() < 3 || m_canvas->width() < 18)
     return;
 
   m_canvas->print(2, 0, "Chunks seen: [C/A/D %i/%i/%.2f]",
                   (int)m_download->download()->peers_complete(),
                   (int)m_download->download()->peers_accounted(),
                   std::floor(m_download->distributed_copies() * 100.0f) / 100.0f);
@@ -99,13 +99,13 @@
 
   std::vector<torrent::BlockList*>::const_iterator itrTransfer = transferChunks.begin();
 
   while (itrTransfer != transferChunks.end() && (uint32_t)(chunk - seen) > (*itrTransfer)->index())
     itrTransfer++;
 
-  for (int y = 1; y < m_canvas->get_height() && chunk < last; ++y) {
+  for (unsigned int y = 1; y < m_canvas->height() && chunk < last; ++y) {
     m_canvas->print(0, y, "%5u ", (int)(chunk - seen));
 
     while (chunk < last) {
       chtype attr;
 
       if (bitfield->get(chunk - seen)) {
@@ -121,24 +121,24 @@
       }
 
       m_canvas->print_char(attr | rak::value_to_hexchar<0>(std::min<uint8_t>(*chunk, 0xF)));
       chunk++;
 
       if ((chunk - seen) % 10 == 0) {
-        if (m_canvas->get_x() + 12 > m_canvas->get_width())
+        if (m_canvas->get_x() + 12 > m_canvas->width())
           break;
 
         m_canvas->print_char(' ');
       }
     }
   }
 }
 
 unsigned int
 WindowDownloadChunksSeen::rows() const {
-  if (m_canvas->get_width() < 18)
+  if (m_canvas->width() < 18)
     return 0;
 
   return (m_download->download()->chunks_total() + chunks_per_row() - 1) / chunks_per_row();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_chunks_seen.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_chunks_seen.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_chunks_seen.h	2006-06-05 05:24:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_chunks_seen.h	2006-07-28 03:34:11.000000000 +0800
@@ -51,15 +51,15 @@
 public:
   WindowDownloadChunksSeen(core::Download* d, unsigned int* focus);
 
   virtual void     redraw();
 
   unsigned int     rows() const;
-  unsigned int     chunks_per_row() const   { return (m_canvas->get_width() - 6) / 11 * 10; }
+  unsigned int     chunks_per_row() const   { return (width() - 6) / 11 * 10; }
 
-  unsigned int     max_focus() const        { return std::max<int>(rows() - get_height() + 1, 0); }
+  unsigned int     max_focus() const        { return std::max<int>(rows() - height() + 1, 0); }
 
 private:
   core::Download*  m_download;
 
   unsigned int*    m_focus;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_list.cc	2006-06-13 00:49:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_list.cc	2006-08-04 21:38:24.000000000 +0800
@@ -70,34 +70,34 @@
 
   if (m_view == NULL)
     return;
 
   m_canvas->print(0, 0, "%s", ("[View: " + m_view->name() + "]").c_str());
 
-  if (m_view->empty_visible() || m_canvas->get_width() < 5 || m_canvas->get_height() < 2)
+  if (m_view->empty_visible() || m_canvas->width() < 5 || m_canvas->height() < 2)
     return;
 
   typedef std::pair<core::View::iterator, core::View::iterator> Range;
 
   Range range = rak::advance_bidirectional(m_view->begin_visible(),
                                            m_view->focus() != m_view->end_visible() ? m_view->focus() : m_view->begin_visible(),
                                            m_view->end_visible(),
-                                           m_canvas->get_height() / 3);
+                                           m_canvas->height() / 3);
 
   // Make sure we properly fill out the last lines so it looks like
   // there are more torrents, yet don't hide it if we got the last one
   // in focus.
   if (range.second != m_view->end_visible())
     ++range.second;
 
   int pos = 1;
 
   while (range.first != range.second) {
-    char buffer[m_canvas->get_width()];
+    char buffer[m_canvas->width() + 1];
     char* position;
-    char* last = buffer + m_canvas->get_width() - 2;
+    char* last = buffer + m_canvas->width() - 2 + 1;
 
     position = print_download_title(buffer, last, *range.first);
     m_canvas->print(0, pos++, "%c %s", range.first == m_view->focus() ? '*' : ' ', buffer);
     
     position = print_download_info(buffer, last, *range.first);
     m_canvas->print(0, pos++, "%c %s", range.first == m_view->focus() ? '*' : ' ', buffer);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_list.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_list.h	2006-08-05 05:53:27.000000000 +0800
@@ -48,13 +48,15 @@
 }
 
 namespace display {
 
 class WindowDownloadList : public Window {
 public:
-  WindowDownloadList() : Window(new Canvas, true), m_view(NULL) {}
+  WindowDownloadList() :
+    Window(new Canvas, 0, 120, 1, extent_full, extent_full),
+    m_view(NULL) {}
   ~WindowDownloadList();
 
   virtual void        redraw();
 
   void                set_view(core::View* l);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_statusbar.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_statusbar.cc	2006-08-05 05:53:27.000000000 +0800
@@ -46,25 +46,25 @@
 
 #include "core/download.h"
 
 namespace display {
 
 WindowDownloadStatusbar::WindowDownloadStatusbar(core::Download* d) :
-  Window(new Canvas, false, 3),
+  Window(new Canvas, 0, 0, 3, extent_full, extent_static),
   m_download(d) {
 }
 
 void
 WindowDownloadStatusbar::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
 
   m_canvas->erase();
 
-  char buffer[m_canvas->get_width()];
+  char buffer[m_canvas->width()];
   char* position;
-  char* last = buffer + m_canvas->get_width() - 2;
+  char* last = buffer + m_canvas->width() - 2;
 
   position = print_download_info(buffer, last, m_download);
   m_canvas->print(0, 0, "%s", buffer);
 
   position = buffer + std::max(snprintf(buffer, last - buffer, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I/C/A: %i/%i/%i/%i Failed: %i",
 					(int)m_download->download()->peers_connected(),
@@ -75,15 +75,13 @@
 					(int)m_download->download()->peers_currently_unchoked(),
 					(int)m_download->download()->peers_currently_interested(),
 					(int)m_download->download()->peers_complete(),
 					(int)m_download->download()->peers_accounted(),
 					(int)m_download->chunks_failed()),
 			       0);
-//   position = buffer + std::max(snprintf(position, last - buffer, " Priority: %s",
-// 					core::Download::priority_to_string(m_download->variable()->get("priority").as_value())),
-// 			       0);
+
   m_canvas->print(0, 1, "%s", buffer);
 
   position = print_download_status(buffer, last, m_download);
   m_canvas->print(0, 2, "[%c:%i] %s",
 		  m_download->tracker_list()->is_busy() ? 'C' : ' ',
 		  (int)(m_download->download()->tracker_list().timeout() / 1000000),
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_transfer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_transfer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_transfer_list.cc	2006-06-25 06:09:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_transfer_list.cc	2006-08-05 05:53:27.000000000 +0800
@@ -46,37 +46,37 @@
 
 #include "window_download_transfer_list.h"
 
 namespace display {
 
 WindowDownloadTransferList::WindowDownloadTransferList(core::Download* d, unsigned int *focus) :
-  Window(new Canvas, true),
+  Window(new Canvas, 0, 0, 0, extent_full, extent_full),
   m_download(d),
   m_focus(focus) {
 }
 
 void
 WindowDownloadTransferList::redraw() {
   // TODO: Make this depend on tracker signal.
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
   m_canvas->erase();
 
-  if (m_canvas->get_height() < 3 || m_canvas->get_width() < 18)
+  if (m_canvas->height() < 3 || m_canvas->width() < 18)
     return;
 
   const torrent::TransferList* transfers = m_download->download()->transfer_list();
 
   m_canvas->print(2, 0, "Transfer list: [Size %i]", transfers->size());
 
   torrent::TransferList::const_iterator itr = transfers->begin();
 
   // This is just for testing and the layout and included information
   // is just something i threw in there, someone really should
   // prettify this. (This is a very subtle hint)
 
-  for (int y = 1; y < m_canvas->get_height() && itr != transfers->end(); ++y, ++itr) {
+  for (unsigned int y = 1; y < m_canvas->height() && itr != transfers->end(); ++y, ++itr) {
     m_canvas->print(0, y, "%5u [P: %u F: %u]", (*itr)->index(), (*itr)->priority(), (*itr)->failed());
 
     // Handle window size.
     for (torrent::BlockList::const_iterator bItr = (*itr)->begin(), bLast = (*itr)->end(); bItr != bLast; ++bItr) {
       char id;
       chtype attr = A_NORMAL;
@@ -103,13 +103,13 @@
     }      
   }
 }
 
 unsigned int
 WindowDownloadTransferList::rows() const {
-  if (m_canvas->get_width() < 18)
+  if (m_canvas->width() < 18)
     return 0;
 
 //   return (m_download->download()->chunks_total() + chunks_per_row() - 1) / chunks_per_row();
   return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_transfer_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_transfer_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_download_transfer_list.h	2006-06-13 05:00:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_download_transfer_list.h	2006-07-28 03:35:37.000000000 +0800
@@ -62,13 +62,13 @@
 
   WindowDownloadTransferList(core::Download* d, unsigned int* focus);
 
   virtual void        redraw();
 
   unsigned int        rows() const;
-  unsigned int        max_focus() const        { return std::max<int>(rows() - get_height() + 1, 0); }
+  unsigned int        max_focus() const        { return std::max<int>(rows() - height() + 1, 0); }
 
 private:
   char                key_id(torrent::BlockTransfer::key_type key);
 
   core::Download*     m_download;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_file_list.cc	2006-06-05 04:45:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_file_list.cc	2006-08-05 05:53:27.000000000 +0800
@@ -46,13 +46,13 @@
 
 #include "window_file_list.h"
 
 namespace display {
 
 WindowFileList::WindowFileList(core::Download* d, unsigned int* focus) :
-  Window(new Canvas, true),
+  Window(new Canvas, 0, 0, 0, extent_full, extent_full),
   m_download(d),
   m_focus(focus) {
 }
 
 /*
 std::wstring
@@ -75,13 +75,13 @@
 WindowFileList::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(10)).round_seconds());
   m_canvas->erase();
 
   torrent::FileList fl = m_download->download()->file_list();
 
-  if (fl.size() == 0 || m_canvas->get_height() < 2)
+  if (fl.size() == 0 || m_canvas->height() < 2)
     return;
 
   int pos = 0;
 
   m_canvas->print( 2, pos, "File");
   m_canvas->print(55, pos, "Size");
@@ -92,13 +92,13 @@
 
   ++pos;
 
   if (*m_focus >= fl.size())
     throw std::logic_error("WindowFileList::redraw() called on an object with a bad focus value");
 
-  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, fl.size(), m_canvas->get_height() - pos);
+  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, fl.size(), m_canvas->height() - pos);
 
   while (range.first != range.second) {
     torrent::File e = fl.get(range.first);
 
     std::string path = e.path_str();
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window.h	2006-06-05 05:25:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window.h	2006-08-16 06:29:19.000000000 +0800
@@ -47,36 +47,64 @@
 
 class Canvas;
 class Manager;
 
 class Window {
 public:
+  typedef uint32_t extent_type;
+
   typedef rak::mem_fun0<Manager, void>                      Slot;
   typedef rak::mem_fun1<Manager, void, Window*>             SlotWindow;
   typedef rak::mem_fun2<Manager, void, Window*, rak::timer> SlotTimer;
 
-  Window(Canvas* c = NULL, bool d = false, int h = 1);
+  static const int flag_active    = (1 << 0);
+  static const int flag_offscreen = (1 << 1);
+  static const int flag_left      = (1 << 2);
+  static const int flag_bottom    = (1 << 3);
+
+  static const extent_type extent_static = extent_type();
+  static const extent_type extent_full   = ~extent_type();
+
+  Window(Canvas* canvas, int flags,
+         extent_type minWidth, extent_type minHeight,
+         extent_type maxWidth, extent_type maxHeight);
 
   virtual ~Window();
 
-  bool                is_active()                          { return m_active; }
-  bool                is_dynamic()                         { return m_dynamic; }
+  bool                is_active() const                    { return m_flags & flag_active; }
+  void                set_active(bool state);
+
+  bool                is_offscreen() const                 { return m_flags & flag_offscreen; }
+  void                set_offscreen(bool state)            { if (state) m_flags |= flag_offscreen; else m_flags &= ~flag_offscreen; }
+
+  bool                is_left() const                      { return m_flags & flag_left; }
+  void                set_left(bool state)                 { if (state) m_flags |= flag_left; else m_flags &= ~flag_left; }
+
+  bool                is_bottom() const                    { return m_flags & flag_bottom; }
+  void                set_bottom(bool state)               { if (state) m_flags |= flag_bottom; else m_flags &= ~flag_bottom; }
+
+  bool                is_width_dynamic() const             { return m_maxWidth > m_minWidth; }
+  bool                is_height_dynamic() const            { return m_maxHeight > m_minHeight; }
+
+  // Do not call mark_dirty() from withing redraw() as it may cause
+  // infinite looping in the display scheduler.
   bool                is_dirty()                           { return m_taskUpdate.is_queued(); }
+  void                mark_dirty()                         { if (!is_active()) return; m_slotSchedule(this, cachedTime); }
 
-  int                 get_min_height() const               { return m_minHeight; }
+  extent_type         min_width() const                    { return m_minWidth; }
+  extent_type         min_height() const                   { return m_minHeight; }
 
-  bool                get_active()                         { return m_active; }
-  void                set_active(bool a);
+  extent_type         max_width() const                    { return std::max(m_maxWidth, m_minWidth); }
+  extent_type         max_height() const                   { return std::max(m_maxHeight, m_minHeight); }
+
+  extent_type         width() const                        { return m_canvas->width(); }
+  extent_type         height() const                       { return m_canvas->height(); }
 
   void                refresh()                            { m_canvas->refresh(); }
   void                resize(int x, int y, int w, int h);
 
-  int                 get_height() const                   { return m_canvas->get_height(); }
-
-  void                mark_dirty()                         { m_slotSchedule(this, cachedTime + 1); }
-
   virtual void        redraw() = 0;
 
   rak::priority_item* task_update()                        { return &m_taskUpdate; }
 
   // Slot for adjust and refresh.
   static void         slot_schedule(SlotTimer s)           { m_slotSchedule = s; }
@@ -90,15 +118,19 @@
   static SlotTimer    m_slotSchedule;
   static SlotWindow   m_slotUnschedule;
   static Slot         m_slotAdjust;
 
   Canvas*             m_canvas;
 
-  bool                m_active;
-  bool                m_dynamic;
-  int                 m_minHeight;
+  int                 m_flags;
+
+  extent_type         m_minWidth;
+  extent_type         m_minHeight;
+
+  extent_type         m_maxWidth;
+  extent_type         m_maxHeight;
 
   rak::priority_item  m_taskUpdate;
 };
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_http_queue.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_http_queue.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_http_queue.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_http_queue.cc	2006-08-16 06:25:44.000000000 +0800
@@ -45,13 +45,13 @@
 #include "rak/functional.h"
 #include "window_http_queue.h"
 
 namespace display {
 
 WindowHttpQueue::WindowHttpQueue(core::HttpQueue* q) :
-  Window(new Canvas, false, 1),
+  Window(new Canvas, 0, 0, 1, extent_full, 1),
   m_queue(q) {
   
   set_active(false);
   m_connInsert = m_queue->signal_insert().connect(sigc::mem_fun(*this, &WindowHttpQueue::receive_insert));
   m_connErase  = m_queue->signal_erase().connect(sigc::mem_fun(*this, &WindowHttpQueue::receive_erase));
 }
@@ -69,26 +69,24 @@
     return;
   } 
 
   m_canvas->erase();
   m_canvas->print(0, 0, "Http [%i]", m_queue->size());
 
-  int pos = 10;
+  unsigned int pos = 10;
   Container::iterator itr = m_container.begin();
 
-  while (itr != m_container.end() && pos + 20 < m_canvas->get_width()) {
+  while (itr != m_container.end() && pos + 20 < m_canvas->width()) {
     if (itr->m_http == NULL)
       m_canvas->print(pos, 0, "%s done", itr->m_name.c_str());
 
     else if (itr->m_http->size_total() == 0)
       m_canvas->print(pos, 0, "%s ---%%", itr->m_name.c_str());
 
     else
-      m_canvas->print(pos, 0, "%s %3i%%",
-		      itr->m_name.c_str(),
-		      (int)(100.0 * itr->m_http->size_done() / itr->m_http->size_total()));
+      m_canvas->print(pos, 0, "%s %3i%%", itr->m_name.c_str(), (int)(100.0 * itr->m_http->size_done() / itr->m_http->size_total()));
 
     pos += itr->m_name.size() + 6;
     ++itr;
   }
 }
 
@@ -97,13 +95,14 @@
   for (Container::iterator itr = m_container.begin(); itr != m_container.end();)
     if (itr->m_http == NULL && itr->m_timer < cachedTime)
       itr = m_container.erase(itr);
     else
       ++itr;
 
-  mark_dirty();
+  // Bad, can't have this here as it is called from redraw().
+  //   mark_dirty();
 }
 
 std::string
 WindowHttpQueue::create_name(core::CurlGet* h) {
   size_t p = h->url().rfind('/', h->url().size() - std::min<int>(10, h->url().size()));
 
@@ -137,14 +136,13 @@
   
   mark_dirty();
 }
 
 void
 WindowHttpQueue::receive_erase(core::CurlGet* h) {
-  Container::iterator itr = std::find_if(m_container.begin(), m_container.end(),
-					 rak::equal(h, std::mem_fun_ref(&Node::get_http)));
+  Container::iterator itr = std::find_if(m_container.begin(), m_container.end(), rak::equal(h, std::mem_fun_ref(&Node::get_http)));
 
   if (itr == m_container.end())
     throw std::logic_error("WindowHttpQueue::receive_erase(...) tried to remove an object we don't have");
 
   itr->m_http = NULL;
   itr->m_timer = cachedTime + rak::timer::from_seconds(1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_input.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_input.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_input.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_input.cc	2006-07-28 00:42:06.000000000 +0800
@@ -40,22 +40,16 @@
 #include "window_input.h"
 
 #include "input/text_input.h"
 
 namespace display {
 
-WindowInput::WindowInput(input::TextInput* input) :
-  Window(new Canvas, false, 1),
-  m_input(input),
-  m_focus(false) {
-}
-
 void
 WindowInput::redraw() {
   m_canvas->erase();
-  m_canvas->print(0, 0, "> %s", m_input->c_str());
+  m_canvas->print(0, 0, "%s> %s", m_title.c_str(), m_input != NULL ? m_input->c_str() : "<NULL>");
 
   if (m_focus)
-    m_canvas->set_attr(m_input->get_pos() + 2, 0, 1, A_REVERSE, COLOR_PAIR(0));
+    m_canvas->set_attr(m_input->get_pos() + 2 + m_title.size(), 0, 1, A_REVERSE, COLOR_PAIR(0));
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_input.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_input.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_input.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_input.h	2006-08-05 05:53:27.000000000 +0800
@@ -34,33 +34,44 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_DISPLAY_WINDOW_INPUT_H
 #define RTORRENT_DISPLAY_WINDOW_INPUT_H
 
+#include <string>
+
 #include "window.h"
 
 namespace input {
   class TextInput;
 }
 
 namespace display {
 
 class WindowInput : public Window {
 public:
-  WindowInput(input::TextInput* input);
+  WindowInput() :
+    Window(new Canvas, 0, 0, 1, extent_full, 1),
+    m_input(NULL),
+    m_focus(false) {}
+
+  input::TextInput*   input()                            { return m_input; }
+  void                set_input(input::TextInput* input) { m_input = input; }
 
-  input::TextInput* get_input()       { return m_input; }
+  const std::string&  title() const                      { return m_title; }
+  void                set_title(const std::string& str)  { m_title = str; }
 
-  bool              get_focus()       { return m_focus; }
-  void              set_focus(bool f) { mark_dirty(); m_focus = f; }
+  bool                focus() const                      { return m_focus; }
+  void                set_focus(bool f)                  { m_focus = f; if (is_active()) mark_dirty(); }
 
-  virtual void      redraw();
+  virtual void        redraw();
 
 private:
-  input::TextInput* m_input;
-  bool              m_focus;
+  input::TextInput*   m_input;
+  std::string         m_title;
+
+  bool                m_focus;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_log.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_log.cc	2006-08-05 05:53:27.000000000 +0800
@@ -42,54 +42,65 @@
 #include "utils.h"
 #include "window_log.h"
 
 namespace display {
 
 WindowLog::WindowLog(core::Log* l) :
-  Window(new Canvas, false, 0),
+  Window(new Canvas, 0, 0, 0, extent_full, extent_static),
   m_log(l) {
 
-  m_active = false;
+  m_taskUpdate.set_slot(rak::mem_fn(this, &WindowLog::receive_update)),
 
   // We're trying out scheduled tasks instead.
   m_connUpdate = l->signal_update().connect(sigc::mem_fun(*this, &WindowLog::receive_update));
 }
 
 WindowLog::~WindowLog() {
+  priority_queue_erase(&taskScheduler, &m_taskUpdate);
   m_connUpdate.disconnect();
 }
 
 WindowLog::iterator
 WindowLog::find_older() {
   return m_log->find_older(cachedTime - rak::timer::from_seconds(60));
 }
 
 void
 WindowLog::redraw() {
   m_canvas->erase();
 
-  int pos = 0;
+  int pos = m_canvas->height();
 
-  for (core::Log::iterator itr = m_log->begin(), end = find_older(); itr != end && pos < m_canvas->get_height(); ++itr) {
+  for (core::Log::iterator itr = m_log->begin(), last = find_older(); itr != last && pos > 0; ++itr, --pos) {
     char buffer[16];
     print_hhmmss_local(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
 
-    m_canvas->print(0, pos++, "(%s) %s", buffer, itr->second.c_str());
+    m_canvas->print(0, pos - 1, "(%s) %s", buffer, itr->second.c_str());
   }
 }
 
+// When WindowLog is activated, call receive_update() to ensure it
+// gets updated.
 void
 WindowLog::receive_update() {
-  iterator itr = find_older();
-  int h = std::min(std::distance(m_log->begin(), itr), (std::iterator_traits<iterator>::difference_type)10);
+  if (!is_active())
+    return;
 
-  if (h != m_minHeight) {
-    set_active(h != 0);
+  iterator itr = find_older();
+  extent_type height = std::min(std::distance(m_log->begin(), itr), (std::iterator_traits<iterator>::difference_type)10);
 
-    m_minHeight = h;
+  if (height != m_maxHeight) {
+    m_minHeight = height != 0 ? 1 : 0;
+    m_maxHeight = height;
     m_slotAdjust();
+
+  } else {
+    mark_dirty();
   }
 
-  mark_dirty();
+  priority_queue_erase(&taskScheduler, &m_taskUpdate);
+
+  if (height != 0)
+    priority_queue_insert(&taskScheduler, &m_taskUpdate, (cachedTime + rak::timer::from_seconds(30)).round_seconds());
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_log_complete.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_log_complete.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_log_complete.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_log_complete.cc	2006-08-05 05:53:27.000000000 +0800
@@ -42,13 +42,13 @@
 #include "utils.h"
 #include "window_log_complete.h"
 
 namespace display {
 
 WindowLogComplete::WindowLogComplete(core::Log* l) :
-  Window(new Canvas, true),
+  Window(new Canvas, 0, 30, 1, extent_full, extent_full),
   m_log(l) {
 
   // We're trying out scheduled tasks instead.
   m_connUpdate = l->signal_update().connect(sigc::mem_fun(*this, &WindowLogComplete::receive_update));
 }
 
@@ -62,21 +62,33 @@
 }
 
 void
 WindowLogComplete::redraw() {
   m_canvas->erase();
 
-  int pos = 0;
+  if (m_canvas->width() < 16)
+    return;
 
-  m_canvas->print(std::max(0, (int)m_canvas->get_width() / 2 - 5), pos++, "*** Log ***");
+  int pos = m_canvas->height();
 
-  for (core::Log::iterator itr = m_log->begin(), e = m_log->end(); itr != e && pos < m_canvas->get_height(); ++itr) {
+  for (core::Log::iterator itr = m_log->begin(), last = m_log->end(); itr != last && pos > 0; ++itr) {
     char buffer[16];
-    print_hhmmss_local(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
 
-    m_canvas->print(0, pos++, "(%s) %s", buffer, itr->second.c_str());
+    // Use an arbitrary min width of 60 for allowing multiple
+    // lines. This should ensure we don't mess up the display when the
+    // screen is shrunk too much.
+    unsigned int timeWidth = 3 + print_hhmmss_local(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds())) - buffer;
+
+    unsigned int logWidth  = m_canvas->width() > 60 ? (m_canvas->width() - timeWidth) : (60 - timeWidth);
+    unsigned int logHeight = (itr->second.size() + logWidth - 1) / logWidth;
+
+    for (unsigned int j = logHeight; j > 0 && pos > 0; --j, --pos)
+      if (j == 1)
+        m_canvas->print(0, pos - 1, "(%s) %s", buffer, itr->second.substr(0, m_canvas->width() - timeWidth).c_str());
+      else
+        m_canvas->print(timeWidth, pos - 1, "%s", itr->second.substr(logWidth * (j - 1), m_canvas->width() - timeWidth).c_str());
   }
 }
 
 void
 WindowLogComplete::receive_update() {
   mark_dirty();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_log.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_log.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_log.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_log.h	2006-07-31 04:07:28.000000000 +0800
@@ -49,20 +49,22 @@
 public:
   typedef core::Log::iterator iterator;
 
   WindowLog(core::Log* l);
   ~WindowLog();
 
-  virtual void     redraw();
+  virtual void        redraw();
 
-  void             receive_update();
+  void                receive_update();
 
 private:
-  inline iterator  find_older();
+  inline iterator     find_older();
 
-  core::Log*       m_log;
-  sigc::connection m_connUpdate;
+  core::Log*          m_log;
+  sigc::connection    m_connUpdate;
+
+  rak::priority_item  m_taskUpdate;
 };
 
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display: window_peer_info.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display: window_peer_info.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_peer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_peer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_peer_list.cc	2006-07-06 02:18:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_peer_list.cc	2006-08-05 05:53:27.000000000 +0800
@@ -49,13 +49,13 @@
 #include "client_info.h"
 #include "window_peer_list.h"
 
 namespace display {
 
 WindowPeerList::WindowPeerList(core::Download* d, PList* l, PList::iterator* f) :
-  Window(new Canvas, true),
+  Window(new Canvas, 0, 0, 0, extent_full, extent_full),
   m_download(d),
   m_list(l),
   m_focus(f) {
 }
 
 void
@@ -84,13 +84,13 @@
 
   typedef std::pair<PList::iterator, PList::iterator> Range;
 
   Range range = rak::advance_bidirectional(m_list->begin(),
                                            *m_focus != m_list->end() ? *m_focus : m_list->begin(),
                                            m_list->end(),
-                                           m_canvas->get_height() - y);
+                                           m_canvas->height() - y);
 
   if (m_download->download()->chunks_total() <= 0)
     throw std::logic_error("WindowPeerList::redraw() m_slotChunksTotal() returned invalid value");
 
   while (range.first != range.second) {
     torrent::Peer& p = *range.first;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_statusbar.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_statusbar.cc	2006-07-28 03:44:30.000000000 +0800
@@ -43,28 +43,22 @@
 #include "canvas.h"
 #include "utils.h"
 #include "window_statusbar.h"
 
 namespace display {
 
-WindowStatusbar::WindowStatusbar(Control* c) :
-  Window(new Canvas, false, 1),
-  m_lastTick(0),
-  m_control(c) {
-}
-
 void
 WindowStatusbar::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
 
   m_canvas->erase();
 
   // TODO: Make a buffer with size = get_width?
-  char buffer[m_canvas->get_width() + 1];
+  char buffer[m_canvas->width() + 1];
   char* position;
-  char* last = buffer + m_canvas->get_width();
+  char* last = buffer + m_canvas->width();
 
 //   if (torrent::up_throttle() == 0)
 //     position = std::max(snprintf(buffer, 128, "off/"), 0);
 //   else
 //     position = std::max(snprintf(buffer, 128, "%3i/", torrent::up_throttle() / 1024), 0);
 
@@ -98,15 +92,14 @@
   position = print_status_info(buffer, last);
   m_canvas->print(0, 0, "%s", buffer);
 
   last = last - (position - buffer);
 
   if (last > buffer) {
-    position = print_status_extra(buffer, last, m_control);
-    m_canvas->print(m_canvas->get_width() - (position - buffer), 0, "%s", buffer);
+    position = print_status_extra(buffer, last, control);
+    m_canvas->print(m_canvas->width() - (position - buffer), 0, "%s", buffer);
   }
 
-
-  m_lastTick = m_control->tick();
+  m_lastTick = control->tick();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_statusbar.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_statusbar.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_statusbar.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_statusbar.h	2006-08-05 05:53:27.000000000 +0800
@@ -38,24 +38,23 @@
 #define RTORRENT_DISPLAY_WINDOW_STATUSBAR_H
 
 #include <inttypes.h>
 
 #include "window.h"
 
-class Control;
-
 namespace display {
 
 class WindowStatusbar : public Window {
 public:
-  WindowStatusbar(Control* c);
+  WindowStatusbar() :
+    Window(new Canvas, 0, 0, 1, extent_full, extent_static),
+    m_lastTick(0) {}
 
   virtual void   redraw();
 
 private:
   uint64_t       m_lastTick;
-  Control*       m_control;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_string_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_string_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_string_list.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_string_list.cc	2006-08-05 05:53:27.000000000 +0800
@@ -40,13 +40,13 @@
 #include "utils.h"
 #include "window_string_list.h"
 
 namespace display {
 
 WindowStringList::WindowStringList() :
-  Window(new Canvas, true) {
+  Window(new Canvas, 0, 0, 0, extent_full, extent_full) {
 }
 
 WindowStringList::~WindowStringList() {
 }
 
 void
@@ -58,28 +58,28 @@
   size_t width = 0;
 
   iterator itr = m_first;
 
   while (itr != m_last) {
 
-    if (ypos == (size_t)m_canvas->get_height()) {
+    if (ypos == (size_t)m_canvas->height()) {
       ypos = 0;
       xpos += width + 2;
       
-      if (xpos + 20 >= (size_t)m_canvas->get_width())
+      if (xpos + 20 >= (size_t)m_canvas->width())
 	break;
 
       width = 0;
     }
 
     width = std::max(itr->size(), width);
 
-    if (xpos + itr->size() <= (size_t)m_canvas->get_width())
+    if (xpos + itr->size() <= (size_t)m_canvas->width())
       m_canvas->print(xpos, ypos++, "%s", itr->c_str());
     else
-      m_canvas->print(xpos, ypos++, "%s", itr->substr(0, m_canvas->get_width() - xpos).c_str());
+      m_canvas->print(xpos, ypos++, "%s", itr->substr(0, m_canvas->width() - xpos).c_str());
 
     ++itr;
   }
 
   m_drawEnd = itr;
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: window_text.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display: window_text.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_title.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_title.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_title.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_title.cc	2006-08-04 21:52:16.000000000 +0800
@@ -38,21 +38,16 @@
 
 #include "canvas.h"
 #include "window_title.h"
 
 namespace display {
 
-WindowTitle::WindowTitle(const std::string& s) :
-  Window(new Canvas, false, 1),
-  m_title(s) {
-}
-
 void
 WindowTitle::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
   m_canvas->erase();
 
-  m_canvas->print(std::max(0, (m_canvas->get_width() - (int)m_title.size()) / 2 - 4), 0,
+  m_canvas->print(std::max(0, ((int)m_canvas->width() - (int)m_title.size()) / 2 - 4), 0,
 		  "*** %s ***", m_title.c_str());
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_title.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_title.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_title.h	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_title.h	2006-08-05 05:53:27.000000000 +0800
@@ -41,17 +41,20 @@
 #include "window.h"
 
 namespace display {
 
 class WindowTitle : public Window {
 public:
-  WindowTitle(const std::string& s);
+  WindowTitle() : Window(new Canvas, 0, 0, 1, extent_full, extent_static) {}
 
-  virtual void redraw();
+  const std::string&  title() const                       { return m_title; }
+  void                set_title(const std::string& title) { m_title = title; mark_dirty(); }
+
+  virtual void        redraw();
 
 private:
-  std::string  m_title;
+  std::string         m_title;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/display/window_tracker_list.cc	2006-05-27 07:20:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/display/window_tracker_list.cc	2006-08-05 05:53:27.000000000 +0800
@@ -46,13 +46,13 @@
 
 #include "window_tracker_list.h"
 
 namespace display {
 
 WindowTrackerList::WindowTrackerList(core::Download* d, unsigned int* focus) :
-  Window(new Canvas, true),
+  Window(new Canvas, 0, 0, 0, extent_full, extent_full),
   m_download(d),
   m_focus(focus) {
 }
 
 void
 WindowTrackerList::redraw() {
@@ -71,13 +71,13 @@
 
   if (*m_focus >= tl->size())
     throw std::logic_error("WindowTrackerList::redraw() called on an object with a bad focus value.");
 
   typedef std::pair<unsigned int, unsigned int> Range;
 
-  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, tl->size(), (m_canvas->get_height() + 1) / 2);
+  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, tl->size(), (m_canvas->height() + 1) / 2);
 
   while (range.first != range.second) {
     torrent::Tracker t = tl->get(range.first);
 
     m_canvas->print(0, pos++, "%c %s",
 		    range.first == *m_focus ? '*' : ' ',
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/bindings.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/bindings.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/bindings.cc	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/bindings.cc	2006-07-28 00:45:54.000000000 +0800
@@ -41,13 +41,13 @@
 #include "bindings.h"
 
 namespace input {
 
 bool
 Bindings::pressed(int key) {
-  if (!m_active)
+  if (!m_enabled)
     return false;
 
   const_iterator itr = find(key);
 
   if (itr != end())
     itr->second();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/bindings.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/bindings.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/bindings.h	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/bindings.h	2006-07-28 00:45:44.000000000 +0800
@@ -60,22 +60,22 @@
   using Base::find;
 
   using Base::erase;
 
   using Base::operator[];
 
-  Bindings() : m_active(true) {}
+  Bindings() : m_enabled(true) {}
 
-  void                activate()          { m_active = true; }
-  void                disable()           { m_active = false; }
+  void                enable()           { m_enabled = true; }
+  void                disable()          { m_enabled = false; }
 
   bool                pressed(int key);
 
   void                ignore(int key)     { (*this)[key] = Slot(); }
 
 private:
-  bool                m_active;
+  bool                m_enabled;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/manager.cc	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/manager.cc	2006-08-06 02:53:23.000000000 +0800
@@ -35,36 +35,36 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <algorithm>
 #include <functional>
-#include <stdexcept>
+#include <torrent/exceptions.h>
 
 #include "manager.h"
 #include "bindings.h"
 #include "text_input.h"
 
 namespace input {
 
 void
 Manager::erase(Bindings* b) {
   iterator itr = std::find(begin(), end(), b);
 
   if (itr == end())
-    throw std::logic_error("Manager::erase(...) could not find binding");
+    return;
 
   Base::erase(itr);
 
   if (std::find(begin(), end(), b) != end())
-    throw std::logic_error("Manager::erase(...) found duplicate bindings");
+    throw torrent::client_error("Manager::erase(...) found duplicate bindings.");
 }
 
 void
 Manager::pressed(int key) {
-  if (m_textInput != NULL && m_textInput->pressed(key))
-    return;
-
-  std::find_if(begin(), end(), std::bind2nd(std::mem_fun(&Bindings::pressed), key));
+  if (m_textInput != NULL)
+    m_textInput->pressed(key);
+  else
+    std::find_if(rbegin(), rend(), std::bind2nd(std::mem_fun(&Bindings::pressed), key));
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/manager.h	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/manager.h	2006-07-31 06:07:35.000000000 +0800
@@ -34,46 +34,43 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_INPUT_MANAGER_H
 #define RTORRENT_INPUT_MANAGER_H
 
-#include <list>
+#include <vector>
 
 namespace input {
 
 class Bindings;
 class TextInput;
 
-class Manager : private std::list<Bindings*> {
+class Manager : private std::vector<Bindings*> {
 public:
-  typedef std::list<Bindings*> Base;
+  typedef std::vector<Bindings*> Base;
 
   using Base::iterator;
   using Base::const_iterator;
   using Base::reverse_iterator;
   using Base::const_reverse_iterator;
 
   using Base::begin;
   using Base::end;
   using Base::rbegin;
   using Base::rend;
 
   using Base::push_back;
-  using Base::push_front;
 
   Manager() : m_textInput(NULL) {}
 
   void erase(Bindings* b);
 
   void pressed(int key);
 
   void set_text_input(TextInput* input = NULL) { m_textInput = input; }
 
-  // Slot for unreacted keys.
-
 private:
   TextInput* m_textInput;
 };
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/path_input.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/path_input.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/path_input.cc	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/path_input.cc	2006-07-28 00:17:44.000000000 +0800
@@ -48,12 +48,14 @@
 PathInput::PathInput() :
   m_showNext(false) {
 }
 
 bool
 PathInput::pressed(int key) {
+  // Consider binding tab in m_bindings instead.
+
   if (key != '\t') {
     m_showNext = false;
     return TextInput::pressed(key);
 
   } else if (m_showNext) {
     m_signalShowNext.emit();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/text_input.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/text_input.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/text_input.cc	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/text_input.cc	2006-07-28 00:18:55.000000000 +0800
@@ -41,13 +41,16 @@
 #include "text_input.h"
 
 namespace input {
 
 bool
 TextInput::pressed(int key) {
-  if (m_alt) {
+  if (m_bindings.pressed(key)) {
+    return true;
+
+  } else if (m_alt) {
     m_alt = false;
 
     switch (key) {
 //     case 'b':
 //       Base::insert(m_pos, "M^b");
 //       break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/text_input.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/text_input.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/input/text_input.h	2006-05-27 07:20:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/input/text_input.h	2006-07-28 00:20:39.000000000 +0800
@@ -35,13 +35,14 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_INPUT_TEXT_INPUT_H
 #define RTORRENT_INPUT_TEXT_INPUT_H
 
 #include <string>
-#include <sigc++/slot.h>
+
+#include "bindings.h"
 
 namespace input {
 
 class TextInput : private std::string {
 public:
   typedef std::string       Base;
@@ -65,16 +66,20 @@
 
   void                slot_dirty(SlotDirty s)    { m_slotDirty = s; }
   void                mark_dirty()               { m_slotDirty(); }
 
   std::string&        str()                      { return *this; }
 
+  Bindings&           bindings()                 { return m_bindings; }
+
 private:
   size_type           m_pos;
 
   bool                m_alt;
   SlotDirty           m_slotDirty;
+
+  Bindings            m_bindings;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/option_handler_rules.cc	2006-07-08 05:01:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/option_handler_rules.cc	2006-08-16 03:21:46.000000000 +0800
@@ -43,12 +43,13 @@
 #include <rak/file_stat.h>
 #include <rak/fs_stat.h>
 #include <rak/functional.h>
 #include <rak/path.h>
 #include <rak/string_manip.h>
 #include <torrent/object.h>
+#include <torrent/chunk_manager.h>
 #include <torrent/connection_manager.h>
 #include <torrent/exceptions.h>
 #include <torrent/file.h>
 #include <torrent/path.h>
 #include <torrent/rate.h>
 #include <torrent/torrent.h>
@@ -210,14 +211,16 @@
   core::Manager::DListItr itr = m->core()->download_list()->begin();
 
   while ((itr = std::find_if(itr, m->core()->download_list()->end(), std::mem_fun(&core::Download::is_seeding))) != m->core()->download_list()->end()) {
     int64_t totalUpload = (*itr)->download()->up_rate()->total();
     int64_t totalDone = (*itr)->download()->bytes_done();
 
-    if ((totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) || (maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio))
-        m->core()->download_list()->stop_try(*itr);
+    if ((totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) || (maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio)) {
+      m->core()->download_list()->stop_try(*itr);
+      (*itr)->variable()->set("ignore_commands", (int64_t)1);
+    }
 
     ++itr;
   }
 }
 
 void
@@ -419,18 +422,17 @@
 
   variables->insert("http_proxy",            new utils::VariableStringSlot(rak::mem_fn(c->core()->get_poll_manager()->get_http_stack(), &core::CurlStack::http_proxy),
                                                                            rak::mem_fn(c->core()->get_poll_manager()->get_http_stack(), &core::CurlStack::set_http_proxy)));
 
   variables->insert("min_peers",             new utils::VariableValue(40));
   variables->insert("max_peers",             new utils::VariableValue(100));
+  variables->insert("min_peers_seed",        new utils::VariableValue(-1));
+  variables->insert("max_peers_seed",        new utils::VariableValue(-1));
   variables->insert("max_uploads",           new utils::VariableValue(15));
   variables->insert("max_chunks_queued",     new utils::VariableValue(0));
 
-  variables->insert("timeout_sync",          new utils::VariableValue(0));
-  variables->insert("timeout_safe_sync",     new utils::VariableValue(0));
-
   variables->insert("download_rate",         new utils::VariableValueSlot(rak::ptr_fn(&torrent::down_throttle), rak::mem_fn(control->ui(), &ui::Root::set_down_throttle_i64),
                                                                           0, (1 << 10)));
   variables->insert("upload_rate",           new utils::VariableValueSlot(rak::ptr_fn(&torrent::up_throttle), rak::mem_fn(control->ui(), &ui::Root::set_up_throttle_i64),
                                                                           0, (1 << 10)));
 
   variables->insert("hash_max_tries",        new utils::VariableValueSlot(rak::ptr_fn(&torrent::hash_max_tries), rak::ptr_fn(&torrent::set_hash_max_tries)));
@@ -460,12 +462,24 @@
   variables->insert("send_buffer_size",      new utils::VariableValueSlot(rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::send_buffer_size),
                                                                           rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::set_send_buffer_size)));
   
   variables->insert("receive_buffer_size",   new utils::VariableValueSlot(rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::receive_buffer_size),
                                                                           rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::set_receive_buffer_size)));
   
+  variables->insert("max_memory_usage",      new utils::VariableValueSlot(rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::max_memory_usage),
+                                                                          rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::set_max_memory_usage)));
+
+  variables->insert("safe_sync",             new utils::VariableValueSlot(rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::safe_sync),
+                                                                          rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::set_safe_sync)));
+
+  variables->insert("timeout_sync",          new utils::VariableValueSlot(rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::timeout_sync),
+                                                                          rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::set_timeout_sync)));
+
+  variables->insert("timeout_safe_sync",     new utils::VariableValueSlot(rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::timeout_safe_sync),
+                                                                          rak::mem_fn(torrent::chunk_manager(), &torrent::ChunkManager::set_timeout_safe_sync)));
+
   variables->insert("port_range",            new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_port_range, c)));
 
   variables->insert("hash_read_ahead",       new utils::VariableValueSlot(rak::ptr_fn(torrent::hash_read_ahead), rak::bind_ptr_fn(&apply_hash_read_ahead, c)));
   variables->insert("hash_interval",         new utils::VariableValueSlot(rak::ptr_fn(torrent::hash_interval), rak::bind_ptr_fn(&apply_hash_interval, c)));
 
   variables->insert("umask",                 new utils::VariableValueSlot(rak::mem_fn(control, &Control::umask), rak::mem_fn(control, &Control::set_umask), 8));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download.cc	2006-07-02 01:01:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download.cc	2006-08-16 02:35:11.000000000 +0800
@@ -33,178 +33,249 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
 #include <sigc++/bind.h>
 #include <rak/functional.h>
+#include <rak/string_manip.h>
+#include <torrent/exceptions.h>
+#include <torrent/chunk_manager.h>
+#include <torrent/connection_manager.h>
 #include <torrent/torrent.h>
 #include <torrent/tracker_list.h>
 
 #include "core/download.h"
-#include "input/bindings.h"
 #include "input/manager.h"
 #include "display/window_title.h"
 #include "display/window_download_statusbar.h"
 
+#include "display/text_element_lambda.h"
+#include "display/text_element_helpers.h"
+
 #include "control.h"
 #include "download.h"
+#include "root.h"
 #include "element_file_list.h"
-#include "element_peer_info.h"
+#include "element_menu.h"
+#include "element_text.h"
 #include "element_peer_list.h"
 #include "element_tracker_list.h"
 #include "element_chunks_seen.h"
 #include "element_transfer_list.h"
 
 namespace ui {
 
-Download::Download(DPtr d, Control* c) :
+Download::Download(core::Download* d) :
   m_download(d),
   m_state(DISPLAY_MAX_SIZE),
+  m_focusDisplay(false) {
 
-  m_windowTitle(new WTitle(d->download()->name())),
-  m_windowDownloadStatus(new WDownloadStatus(d)),
-
-  m_window(c->display()->end()),
-
-  m_control(c),
-  m_bindings(new input::Bindings) {
+  m_windowDownloadStatus = new WDownloadStatus(d);
+  m_windowDownloadStatus->set_bottom(true);
 
-  m_focus = m_peers.end();
-
-  m_uiArray[DISPLAY_PEER_LIST]     = new ElementPeerList(d, &m_peers, &m_focus);
-  m_uiArray[DISPLAY_PEER_INFO]     = new ElementPeerInfo(d, &m_peers, &m_focus);
+  m_uiArray[DISPLAY_MENU]          = create_menu();
+  m_uiArray[DISPLAY_PEER_LIST]     = new ElementPeerList(d);
+  m_uiArray[DISPLAY_INFO]          = create_info();
   m_uiArray[DISPLAY_FILE_LIST]     = new ElementFileList(d);
   m_uiArray[DISPLAY_TRACKER_LIST]  = new ElementTrackerList(d);
   m_uiArray[DISPLAY_CHUNKS_SEEN]   = new ElementChunksSeen(d);
   m_uiArray[DISPLAY_TRANSFER_LIST] = new ElementTransferList(d);
 
-  bind_keys();
-
-  m_download->download()->peer_list(m_peers);
+  m_uiArray[DISPLAY_MENU]->slot_exit(sigc::mem_fun(&m_slotExit, &slot_type::operator()));
+  m_uiArray[DISPLAY_PEER_LIST]->slot_exit(sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_PEER_LIST));
+  m_uiArray[DISPLAY_INFO]->slot_exit(sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_INFO));
+  m_uiArray[DISPLAY_FILE_LIST]->slot_exit(sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_FILE_LIST));
+  m_uiArray[DISPLAY_TRACKER_LIST]->slot_exit(sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_TRACKER_LIST));
+  m_uiArray[DISPLAY_CHUNKS_SEEN]->slot_exit(sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_CHUNKS_SEEN));
+  m_uiArray[DISPLAY_TRANSFER_LIST]->slot_exit(sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_TRANSFER_LIST));
 
-  m_connPeerConnected    = m_download->download()->signal_peer_connected(sigc::mem_fun(*this, &Download::receive_peer_connected));
-  m_connPeerDisconnected = m_download->download()->signal_peer_disconnected(sigc::mem_fun(*this, &Download::receive_peer_disconnected));
+  bind_keys();
 }
 
 Download::~Download() {
-  if (m_window != m_control->display()->end())
-    throw std::logic_error("ui::Download::~Download() called on an active object");
-
-  m_connPeerConnected.disconnect();
-  m_connPeerDisconnected.disconnect();
-
-  delete m_bindings;
+  if (is_active())
+    throw torrent::client_error("ui::Download::~Download() called on an active object.");
 
   std::for_each(m_uiArray, m_uiArray + DISPLAY_MAX_SIZE, rak::call_delete<ElementBase>());
 
-  delete m_windowTitle;
   delete m_windowDownloadStatus;
 }
 
-void
-Download::activate() {
-  if (m_window != m_control->display()->end())
-    throw std::logic_error("ui::Download::activate() called on an already activated object");
+inline ElementBase*
+Download::create_menu() {
+  ElementMenu* element = new ElementMenu;
+
+  element->push_back("Peer list",
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_focus), DISPLAY_PEER_LIST),
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_PEER_LIST));
+  element->push_back("Info",
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_focus), DISPLAY_INFO),
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_INFO));
+  element->push_back("File list",
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_focus), DISPLAY_FILE_LIST),
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_FILE_LIST));
+  element->push_back("Tracker list",
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_focus), DISPLAY_TRACKER_LIST),
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_TRACKER_LIST));
+  element->push_back("Chunks seen",
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_focus), DISPLAY_CHUNKS_SEEN),
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_CHUNKS_SEEN));
+  element->push_back("Transfer list",
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_focus), DISPLAY_TRANSFER_LIST),
+                     sigc::bind(sigc::mem_fun(this, &Download::activate_display_menu), DISPLAY_TRANSFER_LIST));
 
-  m_control->display()->push_front(m_windowDownloadStatus);
-  m_window = m_control->display()->insert(m_control->display()->begin(), NULL);
-  m_control->display()->push_front(m_windowTitle);
+  element->set_entry(0, false);
 
-  m_control->input()->push_front(m_bindings);
+  m_bindings['p'] = sigc::bind(sigc::mem_fun(element, &ElementMenu::set_entry_trigger), 0);
+  m_bindings['o'] = sigc::bind(sigc::mem_fun(element, &ElementMenu::set_entry_trigger), 1);
+  m_bindings['i'] = sigc::bind(sigc::mem_fun(element, &ElementMenu::set_entry_trigger), 2);
+  m_bindings['u'] = sigc::bind(sigc::mem_fun(element, &ElementMenu::set_entry_trigger), 3);
 
-  activate_display(DISPLAY_PEER_LIST);
+  return element;
 }
 
-void
-Download::disable() {
-  if (m_window == m_control->display()->end())
-    throw std::logic_error("ui::Download::disable() called on an already disabled object");
+inline ElementBase*
+Download::create_info() {
+  using namespace display::helpers;
 
-  disable_display();
+  ElementText* element = new ElementText(m_download);
 
-  m_control->display()->erase(m_window);
-  m_control->display()->erase(m_windowTitle);
-  m_control->display()->erase(m_windowDownloadStatus);
+  element->set_column(1);
+  element->set_interval(1);
 
-  m_window = m_control->display()->end();
+  // Get these bindings with some kind of string map.
 
-  m_control->input()->erase(m_bindings);
-}
+  element->push_column("Name:",             te_string(&torrent::Download::name));
+  element->push_column("Local id:",         te_string(&torrent::Download::local_id, string_base::flag_escape_html));
+  element->push_column("Info hash:",        te_string(&torrent::Download::info_hash, string_base::flag_escape_hex));
+  element->push_column("Created:",          te_value(&torrent::Download::creation_date, value_base::flag_date), " ", te_value(&torrent::Download::creation_date, value_base::flag_time));
 
-void
-Download::activate_display(Display d) {
-  if (m_window == m_control->display()->end())
-    throw std::logic_error("ui::Download::activate_display(...) could not find previous display iterator");
+  element->push_back("");
+  element->push_column("Directory:",        te_string(&torrent::FileList::root_dir));
+  element->push_column("Tied to file:",     te_variable_string("tied_to_file"));
 
-  if (d >= DISPLAY_MAX_SIZE)
-    throw std::logic_error("ui::Download::activate_display(...) out of bounds");
+  element->push_back("");
+  element->push_column("Chunks:",           te_value(&torrent::Download::chunks_done), " / ", te_value(&torrent::Download::chunks_total), " * ", te_value(&torrent::Download::chunks_size));
+  element->push_column("Priority:",         te_variable_value("priority"));
 
-  m_state = d;
-  m_uiArray[d]->activate(m_control, m_window);
+  element->push_column("State changed:",    te_variable_value("state_changed", value_base::flag_timer | value_base::flag_elapsed));
 
-  m_control->display()->adjust_layout();
-}
+  element->push_back("");
+  element->push_column("Memory usage:",     te_value(&torrent::ChunkManager::memory_usage, value_base::flag_mb), " MB");
+  element->push_column("Max memory usage:", te_value(&torrent::ChunkManager::max_memory_usage, value_base::flag_mb), " MB");
+  element->push_column("Free diskspace:",   te_value(&torrent::Download::free_diskspace, value_base::flag_mb), " MB");
+  element->push_column("Safe diskspace:",   te_value(&torrent::ChunkManager::safe_free_diskspace, value_base::flag_mb), " MB");
 
-// Does not delete disabled window.
-void
-Download::disable_display() {
-  m_uiArray[m_state]->disable(m_control);
+  element->push_back("");
+  element->push_column("Safe sync:",        display::text_element_branch_void(rak::make_mem_fun(torrent::chunk_manager(), &torrent::ChunkManager::safe_sync), te_string("yes"), te_string("no")));
+  element->push_column("Send buffer:",      te_value(&torrent::ConnectionManager::send_buffer_size, value_base::flag_kb), " KB");
+  element->push_column("Receive buffer:",   te_value(&torrent::ConnectionManager::receive_buffer_size, value_base::flag_kb), " KB");
 
-  m_state   = DISPLAY_MAX_SIZE;
-  *m_window = NULL;
+  element->set_column_width(element->column_width() + 1);
+
+  return element;
 }
 
 void
-Download::receive_next() {
-  if (m_focus != m_peers.end())
-    ++m_focus;
-  else
-    m_focus = m_peers.begin();
+Download::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::Download::activate() called on an already activated object.");
 
-  mark_dirty();
-}
+  control->input()->push_back(&m_bindings);
 
-void
-Download::receive_prev() {
-  if (m_focus != m_peers.begin())
-    --m_focus;
-  else
-    m_focus = m_peers.end();
+  m_frame = frame;
+  m_frame->initialize_row(2);
 
-  mark_dirty();
+  m_frame->frame(1)->initialize_window(m_windowDownloadStatus);
+  m_windowDownloadStatus->set_active(true);
+
+  activate_display_menu(DISPLAY_PEER_LIST);
 }
 
 void
-Download::receive_disconnect_peer() {
-  if (m_focus == m_peers.end())
-    return;
+Download::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::Download::disable() called on an already disabled object.");
 
-  m_download->download()->disconnect_peer(*m_focus);
+  control->input()->erase(&m_bindings);
 
-  mark_dirty();
-}
+  activate_display_focus(DISPLAY_MAX_SIZE);
 
-void
-Download::receive_peer_connected(torrent::Peer p) {
-  m_peers.push_back(p);
+  m_windowDownloadStatus->set_active(false);
+  m_frame->clear();
+
+  m_frame = NULL;
 }
 
 void
-Download::receive_peer_disconnected(torrent::Peer p) {
-  PList::iterator itr = std::find(m_peers.begin(), m_peers.end(), p);
+Download::activate_display(Display displayType, bool focusDisplay) {
+  if (!is_active())
+    throw torrent::client_error("ui::Download::activate_display(...) !is_active().");
+
+  if (displayType > DISPLAY_MAX_SIZE)
+    throw torrent::client_error("ui::Download::activate_display(...) out of bounds");
 
-  if (itr == m_peers.end())
-    throw std::logic_error("Download::receive_peer_disconnected(...) received a peer we don't have in our list");
+  if (focusDisplay == m_focusDisplay && displayType == m_state)
+    return;
 
-  if (itr == m_focus)
-    m_focus = m_peers.erase(itr);
-  else
-    m_peers.erase(itr);
+  display::Frame* frame = m_frame->frame(0);
+
+  // Cleanup previous state.
+  switch (m_state) {
+  case DISPLAY_MENU:
+    break;
+
+  case DISPLAY_PEER_LIST:
+  case DISPLAY_INFO:
+  case DISPLAY_FILE_LIST:
+  case DISPLAY_TRACKER_LIST:
+  case DISPLAY_CHUNKS_SEEN:
+  case DISPLAY_TRANSFER_LIST:
+    m_uiArray[DISPLAY_MENU]->disable();
+    m_uiArray[m_state]->disable();
+
+    frame->clear();
+    break;
+
+  case DISPLAY_MAX_SIZE:
+    break;
+  }
+
+  m_state = displayType;
+  m_focusDisplay = focusDisplay;
+
+  // Initialize new state.
+  switch (displayType) {
+  case DISPLAY_MENU:
+    break;
+
+  case DISPLAY_PEER_LIST:
+  case DISPLAY_INFO:
+  case DISPLAY_FILE_LIST:
+  case DISPLAY_TRACKER_LIST:
+  case DISPLAY_CHUNKS_SEEN:
+  case DISPLAY_TRANSFER_LIST:
+    frame->initialize_column(2);
+
+    m_uiArray[DISPLAY_MENU]->activate(frame->frame(0), !focusDisplay);
+    m_uiArray[displayType]->activate(frame->frame(1), focusDisplay);
+    break;
+
+  case DISPLAY_MAX_SIZE:
+    break;
+  }
+
+  // Set title.
+  switch (displayType) {
+  case DISPLAY_MAX_SIZE: break;
+  default: control->ui()->window_title()->set_title(m_download->download()->name()); break;
+  }
+
+  control->display()->adjust_layout();
 }
 
 void
 Download::receive_max_uploads(int t) {
   m_windowDownloadStatus->mark_dirty();
 
@@ -223,77 +294,31 @@
   m_windowDownloadStatus->mark_dirty();
 
   m_download->download()->set_peers_max(std::max(m_download->download()->peers_max() + t, (uint32_t)5));
 }
 
 void
-Download::receive_change(Display d) {
-  if (d == m_state)
-    return;
-
-  disable_display();
-  activate_display(d);
-}
-
-void
-Download::receive_snub_peer() {
-  if (m_focus == m_peers.end())
-    return;
-
-  m_focus->set_snubbed(!m_focus->is_snubbed());
-
-  mark_dirty();
-}
-
-void
 Download::receive_next_priority() {
   m_download->set_priority((m_download->priority() + 1) % 4);
 }
 
 void
 Download::receive_prev_priority() {
   m_download->set_priority((m_download->priority() - 1) % 4);
 }
 
 void
 Download::bind_keys() {
-  (*m_bindings)['1'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_uploads), -1);
-  (*m_bindings)['2'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_uploads), 1);
-  (*m_bindings)['3'] = sigc::bind(sigc::mem_fun(this, &Download::receive_min_peers), -5);
-  (*m_bindings)['4'] = sigc::bind(sigc::mem_fun(this, &Download::receive_min_peers), 5);
-  (*m_bindings)['5'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_peers), -5);
-  (*m_bindings)['6'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_peers), 5);
-  (*m_bindings)['+'] = sigc::mem_fun(this, &Download::receive_next_priority);
-  (*m_bindings)['-'] = sigc::mem_fun(this, &Download::receive_prev_priority);
-
-  (*m_bindings)['k'] = sigc::mem_fun(this, &Download::receive_disconnect_peer);
-
-  (*m_bindings)['t'] = sigc::bind(sigc::mem_fun(m_download->tracker_list(), &torrent::TrackerList::manual_request), false);
-  (*m_bindings)['T'] = sigc::bind(sigc::mem_fun(m_download->tracker_list(), &torrent::TrackerList::manual_request), true);
-
-  (*m_bindings)['p'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_INFO);
-  (*m_bindings)['o'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_TRACKER_LIST);
-  (*m_bindings)['i'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_CHUNKS_SEEN);
-  (*m_bindings)['u'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_TRANSFER_LIST);
-
-  (*m_bindings)[KEY_UP]   = sigc::mem_fun(this, &Download::receive_prev);
-  (*m_bindings)[KEY_DOWN] = sigc::mem_fun(this, &Download::receive_next);
-
-  // Key bindings for sub-ui's.
-  m_uiArray[DISPLAY_PEER_LIST]->get_bindings()[KEY_RIGHT]   = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_FILE_LIST);
-  m_uiArray[DISPLAY_PEER_INFO]->get_bindings()[KEY_LEFT]    = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
-  m_uiArray[DISPLAY_FILE_LIST]->get_bindings()[KEY_LEFT]    = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
-  m_uiArray[DISPLAY_TRACKER_LIST]->get_bindings()[KEY_LEFT] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
-  m_uiArray[DISPLAY_CHUNKS_SEEN]->get_bindings()[KEY_LEFT]  = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
-  m_uiArray[DISPLAY_TRANSFER_LIST]->get_bindings()[KEY_LEFT]= sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
-
-  // Doesn't belong here.
-  m_uiArray[DISPLAY_PEER_LIST]->get_bindings()['*'] = sigc::mem_fun(this, &Download::receive_snub_peer);
-  m_uiArray[DISPLAY_PEER_INFO]->get_bindings()['*'] = sigc::mem_fun(this, &Download::receive_snub_peer);
-}
+  m_bindings['1'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_uploads), -1);
+  m_bindings['2'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_uploads), 1);
+  m_bindings['3'] = sigc::bind(sigc::mem_fun(this, &Download::receive_min_peers), -5);
+  m_bindings['4'] = sigc::bind(sigc::mem_fun(this, &Download::receive_min_peers), 5);
+  m_bindings['5'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_peers), -5);
+  m_bindings['6'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_peers), 5);
+  m_bindings['+'] = sigc::mem_fun(this, &Download::receive_next_priority);
+  m_bindings['-'] = sigc::mem_fun(this, &Download::receive_prev_priority);
 
-void
-Download::mark_dirty() {
-  (*m_window)->mark_dirty();
+  m_bindings['t'] = sigc::bind(sigc::mem_fun(m_download->tracker_list(), &torrent::TrackerList::manual_request), false);
+  m_bindings['T'] = sigc::bind(sigc::mem_fun(m_download->tracker_list(), &torrent::TrackerList::manual_request), true);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download.h	2006-06-10 05:43:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download.h	2006-08-09 00:10:08.000000000 +0800
@@ -41,101 +41,77 @@
 #include <torrent/peer.h>
 #include <sigc++/connection.h>
 
 #include "display/manager.h"
 #include "utils/list_focus.h"
 
-class Control;
+#include "element_base.h"
 
 namespace display {
-  class WindowTitle;
-  class WindowStatusbar;
   class WindowDownloadStatusbar;
 }
 
 namespace core {
   class Download;
 }
 
 namespace ui {
 
-class ElementBase;
-
-class Download {
+class Download : public ElementBase {
 public:
-  typedef display::WindowTitle             WTitle;
   typedef display::WindowDownloadStatusbar WDownloadStatus;
 
-  typedef core::Download*                  DPtr;
   typedef std::list<torrent::Peer>         PList;
-  typedef display::Manager::iterator       MItr;
 
   typedef enum {
+    DISPLAY_MENU,
     DISPLAY_PEER_LIST,
-    DISPLAY_PEER_INFO,
+    DISPLAY_INFO,
     DISPLAY_FILE_LIST,
     DISPLAY_TRACKER_LIST,
     DISPLAY_CHUNKS_SEEN,
     DISPLAY_TRANSFER_LIST,
     DISPLAY_MAX_SIZE
   } Display;
 
-  Download(DPtr d, Control* c);
+  Download(core::Download* d);
   ~Download();
 
-  input::Bindings&    get_bindings() { return *m_bindings; }
-
-  void                activate();
+  void                activate(display::Frame* frame, bool focus = true);
   void                disable();
 
-  void                activate_display(Display d);
-  void                disable_display();
+  void                activate_display(Display d, bool focusDisplay);
+
+  void                activate_display_focus(Display d) { activate_display(d, true); }
+  void                activate_display_menu(Display d)  { activate_display(d, false); }
 
   void                receive_next_priority();
   void                receive_prev_priority();
 
+  display::Window*    window() { return NULL; }
+
 private:
   Download(const Download&);
   void operator = (const Download&);
 
-  void                receive_next();
-  void                receive_prev();
-
-  void                receive_disconnect_peer();
-
-  void                receive_peer_connected(torrent::Peer p);
-  void                receive_peer_disconnected(torrent::Peer p);
+  inline ElementBase* create_menu();
+  inline ElementBase* create_info();
 
   void                receive_max_uploads(int t);
   void                receive_min_peers(int t);
   void                receive_max_peers(int t);
-  void                receive_change(Display d);
-
-  void                receive_snub_peer();
 
   void                bind_keys();
 
-  void                mark_dirty();
-
-  DPtr                m_download;
-  PList               m_peers;
-  PList::iterator     m_focus;
+  core::Download*     m_download;
 
   Display             m_state;
-
   ElementBase*        m_uiArray[DISPLAY_MAX_SIZE];
 
-  WTitle*             m_windowTitle;
-  WDownloadStatus*    m_windowDownloadStatus;
-
-  MItr                m_window;
-
-  Control*            m_control;
-  input::Bindings*    m_bindings;
+  bool                m_focusDisplay;
 
-  sigc::connection    m_connPeerConnected;
-  sigc::connection    m_connPeerDisconnected;
+  WDownloadStatus*    m_windowDownloadStatus;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download_list.cc	2006-07-08 05:03:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download_list.cc	2006-08-07 23:48:35.000000000 +0800
@@ -33,13 +33,12 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
 #include <rak/functional.h>
 #include <rak/string_manip.h>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
@@ -51,437 +50,282 @@
 #include "core/view_manager.h"
 
 #include "input/bindings.h"
 #include "input/manager.h"
 #include "input/path_input.h"
 
-#include "display/window_http_queue.h"
-#include "display/window_input.h"
 #include "display/window_log.h"
 #include "display/window_title.h"
-#include "display/window_statusbar.h"
 
 #include "control.h"
 #include "download.h"
 #include "download_list.h"
 #include "element_download_list.h"
 #include "element_log_complete.h"
 #include "element_string_list.h"
 #include "root.h"
 
 namespace ui {
 
-DownloadList::DownloadList(Control* c) :
-  m_state(DISPLAY_MAX_SIZE),
+DownloadList::DownloadList() :
+  m_state(DISPLAY_MAX_SIZE) {
 
-  m_window(c->display()->end()),
-
-  m_windowTitle(new WTitle("rTorrent " VERSION " - libTorrent " + std::string(torrent::version()))),
-  m_windowHttpQueue(new WHttp(c->core()->http_queue())),
-
-  m_uiDownload(NULL),
-
-  m_control(c),
-  m_bindings(new input::Bindings)
-{
+  m_uiArray[DISPLAY_DOWNLOAD]      = NULL;
   m_uiArray[DISPLAY_DOWNLOAD_LIST] = new ElementDownloadList();
-  m_uiArray[DISPLAY_LOG]           = new ElementLogComplete(&m_control->core()->get_log_complete());
-  m_windowLog                      = new WLog(&m_control->core()->get_log_important());
-
-  receive_change_view("main");
+  m_uiArray[DISPLAY_LOG]           = new ElementLogComplete(&control->core()->get_log_complete());
+  m_uiArray[DISPLAY_STRING_LIST]   = new ElementStringList();
 
-  if (m_view == NULL)
-    throw torrent::client_error("View \"main\" must be present to initialize the main display.");
-
-  m_taskUpdate.set_slot(rak::mem_fn(this, &DownloadList::task_update)),
+  m_windowLog                      = new WLog(&control->core()->get_log_important());
 
   setup_keys();
-  setup_input();
 }
 
 DownloadList::~DownloadList() {
   if (is_active())
     throw std::logic_error("ui::DownloadList::~DownloadList() called on an active object");
 
   std::for_each(m_uiArray, m_uiArray + DISPLAY_MAX_SIZE, rak::call_delete<ElementBase>());
 
-  delete m_windowTitle;
-  delete m_bindings;
-
   delete m_windowLog;
-  delete m_windowTextInput->get_input();
-  delete m_windowTextInput;
-  delete m_windowHttpQueue;
 }
 
 void
-DownloadList::activate() {
+DownloadList::activate(display::Frame* frame, bool focus) {
   if (is_active())
-    throw std::logic_error("ui::Download::activate() called on an already activated object");
-
-  priority_queue_insert(&taskScheduler, &m_taskUpdate, cachedTime);
+    throw torrent::client_error("ui::DownloadList::activate() called on an already activated object");
 
-  m_windowTextInput->set_active(false);
+  m_frame = frame;
 
-  m_control->display()->push_front(m_windowTextInput);
-  m_control->display()->push_front(m_windowHttpQueue);
-  m_control->display()->push_front(m_windowLog);
-  m_window = m_control->display()->insert(m_control->display()->begin(), NULL);
-  m_control->display()->push_front(m_windowTitle);
-
-  m_control->input()->push_front(m_bindings);
-
-  m_control->core()->download_list()->slot_map_erase()["0_download_list"] = sigc::mem_fun(this, &DownloadList::receive_download_erased);
+  control->input()->push_back(&m_bindings);
+  control->core()->download_list()->slot_map_erase()["0_download_list"] = sigc::mem_fun(this, &DownloadList::receive_download_erased);
 
   activate_display(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::disable() {
   if (!is_active())
-    throw std::logic_error("ui::Download::disable() called on an already disabled object");
-
-  if (m_windowTextInput->is_active()) {
-    m_windowTextInput->get_input()->clear();
-    receive_exit_input(INPUT_NONE);
-  }
-
-  disable_display();
-
-  priority_queue_erase(&taskScheduler, &m_taskUpdate);
+    throw std::logic_error("ui::DownloadList::disable() called on an already disabled object");
 
-  m_control->display()->erase(m_window);
-  m_control->display()->erase(m_windowTitle);
-  m_control->display()->erase(m_windowTextInput);
-  m_control->display()->erase(m_windowLog);
-  m_control->display()->erase(m_windowHttpQueue);
+  receive_exit_input(INPUT_NONE);
+  activate_display(DISPLAY_MAX_SIZE);
 
-  m_window = m_control->display()->end();
+  m_frame = NULL;
 
-  m_control->input()->erase(m_bindings);
+  control->input()->erase(&m_bindings);
 }
 
-void
-DownloadList::activate_display(Display d) {
-  if (!is_active())
-    throw std::logic_error("ui::DownloadList::activate_display(...) could not find previous display iterator");
-
-  if (d >= DISPLAY_MAX_SIZE)
-    throw std::logic_error("ui::DownloadList::activate_display(...) out of bounds");
-
-  m_state = d;
-  m_uiArray[d]->activate(m_control, m_window);
-
-  m_control->display()->adjust_layout();
+core::View*
+DownloadList::current_view() {
+  return dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST])->view();
 }
 
-// Does not delete disabled window.
 void
-DownloadList::disable_display() {
-  m_uiArray[m_state]->disable(m_control);
-
-  m_state   = DISPLAY_MAX_SIZE;
-  *m_window = NULL;
-}
+DownloadList::activate_display(Display displayType) {
+  if (!is_active())
+    throw torrent::client_error("ui::DownloadList::activate_display(...) !is_active().");
 
-void
-DownloadList::receive_next() {
-  m_view->next_focus();
-  m_view->set_last_changed();
-}
+  if (displayType > DISPLAY_MAX_SIZE)
+    throw torrent::client_error("ui::DownloadList::activate_display(...) out of bounds");
 
-void
-DownloadList::receive_prev() {
-  m_view->prev_focus();
-  m_view->set_last_changed();
-}
-
-void
-DownloadList::receive_start_download() {
-  if (m_view->focus() == m_view->end_visible())
+  if (displayType == m_state)
     return;
 
-  m_control->core()->download_list()->start_normal(*m_view->focus());
-  m_view->set_last_changed();
-}
+  // Cleanup previous state.
+  switch (m_state) {
+  case DISPLAY_DOWNLOAD:
+    m_uiArray[m_state]->disable();
 
-void
-DownloadList::receive_stop_download() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+    delete m_uiArray[m_state];
+    m_uiArray[m_state] = NULL;
 
-  if ((*m_view->focus())->variable()->get_value("state") == 1)
-    m_control->core()->download_list()->stop_normal(*m_view->focus());
-  else
-    m_control->core()->download_list()->erase(*m_view->focus());
+    break;
+    
+  case DISPLAY_DOWNLOAD_LIST:
+    m_uiArray[DISPLAY_DOWNLOAD_LIST]->disable();
 
-  m_view->set_last_changed();
-}
+    m_windowLog->set_active(false);
+    m_frame->frame(1)->clear();
 
-void
-DownloadList::receive_close_download() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+    m_frame->clear();
+    break;
 
-  m_control->core()->download_list()->stop_normal(*m_view->focus());
-  m_control->core()->download_list()->close(*m_view->focus());
-  m_view->set_last_changed();
-}
+  case DISPLAY_LOG:
+  case DISPLAY_STRING_LIST:
+    m_uiArray[m_state]->disable();
+    break;
+    
+  default:
+    break;
+  }
 
-void
-DownloadList::receive_view_download() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+  m_state = displayType;
 
-  if (m_uiDownload != NULL)
-    throw std::logic_error("DownloadList::receive_view_download() called but m_uiDownload != NULL");
+  // Initialize new state.
+  switch (displayType) {
+  case DISPLAY_DOWNLOAD:
+    // If no download has the focus, just return to the download list.
+    if (current_view()->focus() == current_view()->end_visible()) {
+      m_state = DISPLAY_MAX_SIZE;
 
-  disable();
+      activate_display(DISPLAY_DOWNLOAD_LIST);
+      return;
 
-  m_uiDownload = new Download(*m_view->focus(), m_control);
+    } else {
+      Download* download = new Download(*current_view()->focus());
 
-  m_uiDownload->activate();
-  m_uiDownload->get_bindings()[KEY_LEFT] = sigc::mem_fun(*this, &DownloadList::receive_exit_download);
-}
+      download->activate(m_frame);
+      download->slot_exit(sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_DOWNLOAD_LIST));
+    
+      m_uiArray[DISPLAY_DOWNLOAD] = download;
+      break;
+    }
 
-void
-DownloadList::receive_exit_download() {
-  if (m_uiDownload == NULL)
-    throw std::logic_error("DownloadList::receive_exit_download() called but m_uiDownload == NULL");
-
-  m_uiDownload->disable();
-  delete m_uiDownload;
-  m_uiDownload = NULL;
+  case DISPLAY_DOWNLOAD_LIST:
+    m_frame->initialize_row(2);
 
-  m_view->set_last_changed();
-  activate();
+    m_uiArray[DISPLAY_DOWNLOAD_LIST]->activate(m_frame->frame(0));
 
-  m_control->display()->adjust_layout();
-}
+    m_frame->frame(1)->initialize_window(m_windowLog);
+    m_windowLog->set_active(true);
+    m_windowLog->receive_update();
+    break;
+
+  case DISPLAY_LOG:
+  case DISPLAY_STRING_LIST:
+    m_uiArray[displayType]->activate(m_frame);
+    break;
 
-void
-DownloadList::receive_next_priority() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+  default:
+    break;
+  }
+
+  // Set title.
+  switch (displayType) {
+  case DISPLAY_DOWNLOAD_LIST: control->ui()->window_title()->set_title("rTorrent " VERSION " - libTorrent " + std::string(torrent::version())); break;
+  case DISPLAY_LOG:           control->ui()->window_title()->set_title("Log"); break;
+  default: break;
+  }
 
-  (*m_view->focus())->set_priority(((*m_view->focus())->priority() + 1) % 4);
+  control->display()->adjust_layout();
 }
 
 void
-DownloadList::receive_prev_priority() {
-  if (m_view->focus() == m_view->end_visible())
+DownloadList::receive_view_input(Input type) {
+  if (control->ui()->current_input() != NULL)
     return;
 
-  (*m_view->focus())->set_priority(((*m_view->focus())->priority() - 1) % 4);
-}
+  input::PathInput* input = new input::PathInput;
 
-void
-DownloadList::receive_check_hash() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+  const char* title;
 
-  // Catch here?
-  m_control->core()->download_list()->check_hash(*m_view->focus());
-}
+  switch (type) {
+  case INPUT_LOAD_DEFAULT:
+    title = "load_start";
+    break;
 
-void
-DownloadList::receive_ignore_ratio() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+  case INPUT_LOAD_MODIFIED:
+    title = "load";
+    break;
 
-  if ((*m_view->focus())->variable()->get_value("ignore_commands") != 0) {
-    (*m_view->focus())->variable()->set("ignore_commands", (int64_t)0);
-    m_control->core()->push_log("Torrent set to heed commands.");
-  } else {
-    (*m_view->focus())->variable()->set("ignore_commands", (int64_t)1);
-    m_control->core()->push_log("Torrent set to ignore commands");
-  }
-}
+  case INPUT_CHANGE_DIRECTORY:
+    title = "change_directory";
 
-void
-DownloadList::receive_clear_tied() {
-  if (m_view->focus() == m_view->end_visible())
-    return;
+    input->str() = control->variable()->get_string("directory");
+    input->set_pos(input->str().length());
 
-  const std::string& tiedFile = (*m_view->focus())->variable()->get_string("tied_to_file");
+    break;
 
-  if (!tiedFile.empty()) {
-    // Move this into core?
-    m_control->core()->delete_tied(*m_view->focus());
+  case INPUT_COMMAND:
+    title = "command";
+    break;
 
-    m_control->core()->push_log("Cleared tied to file association for download.");
+  default:
+    throw torrent::client_error("DownloadList::receive_view_input(...) Invalid input type.");
   }
-}
 
-void
-DownloadList::receive_view_input(Input type) {
-  if (m_windowTextInput->get_active())
-    return;
+  ElementStringList* esl = dynamic_cast<ElementStringList*>(m_uiArray[DISPLAY_STRING_LIST]);
 
-  m_control->ui()->window_statusbar()->set_active(false);
-  m_windowTextInput->set_active(true);
-  m_control->display()->adjust_layout();
+  input->signal_show_next().connect(sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_STRING_LIST));
+  input->signal_show_next().connect(sigc::mem_fun(*esl, &ElementStringList::next_screen));
 
-  m_control->input()->set_text_input(m_windowTextInput->get_input());
+  input->signal_show_range().connect(sigc::hide(sigc::hide(sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_STRING_LIST))));
+  input->signal_show_range().connect(sigc::mem_fun(*esl, &ElementStringList::set_range<utils::Directory::iterator>));
 
-  m_windowTextInput->set_focus(true);
+  input->bindings()['\n']      = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
+  input->bindings()[KEY_ENTER] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
+  input->bindings()['\x07']    = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), INPUT_NONE);
 
-  if (type == INPUT_CHANGE_DIRECTORY) {
-    m_windowTextInput->get_input()->str() = m_control->variable()->get_string("directory");
-    m_windowTextInput->get_input()->set_pos(m_windowTextInput->get_input()->str().length());
-  }
-
-  (*m_bindings)['\n']      = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
-  (*m_bindings)[KEY_ENTER] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
-  (*m_bindings)['\x07']    = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), INPUT_NONE);
+  control->ui()->enable_input(title, input);
 }
 
 void
 DownloadList::receive_exit_input(Input type) {
-  if (!m_windowTextInput->get_active())
+  input::TextInput* input = control->ui()->current_input();
+  
+  // We should check that this object is the one holding the input.
+  if (input == NULL)
     return;
 
-  m_control->ui()->window_statusbar()->set_active(true);
-  m_windowTextInput->set_active(false);
-  m_control->input()->set_text_input();
-    
+  control->ui()->disable_input();
+
   try {
 
     switch (type) {
     case INPUT_NONE:
       break;
 
     case INPUT_LOAD_DEFAULT:
     case INPUT_LOAD_MODIFIED:
-      m_control->core()->try_create_download_expand(m_windowTextInput->get_input()->str(), type == INPUT_LOAD_DEFAULT);
+      control->core()->try_create_download_expand(input->str(), type == INPUT_LOAD_DEFAULT);
       break;
 
     case INPUT_CHANGE_DIRECTORY:
-      if (m_view->focus() == m_view->end_visible())
+      if (current_view()->focus() == current_view()->end_visible())
         throw torrent::input_error("No download in focus to change root directory.");
 
-      (*m_view->focus())->variable()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
-      m_control->core()->push_log("New root dir \"" + (*m_view->focus())->variable()->get_string("directory") + "\" for torrent.");
+      (*current_view()->focus())->variable()->set("directory", rak::trim(input->str()));
+      control->core()->push_log("New root directory \"" + (*current_view()->focus())->variable()->get_string("directory") + "\" for torrent.");
       break;
 
     case INPUT_COMMAND:
-      m_control->variable()->process_command(m_windowTextInput->get_input()->str());
+      control->variable()->process_command(input->str());
       break;
+
+    default:
+      throw torrent::client_error("DownloadList::receive_exit_input(...) Invalid input type.");
     }
 
   } catch (torrent::input_error& e) {
-    m_control->core()->push_log(e.what());
+    control->core()->push_log(e.what());
   }
 
-  // Clean up.
-  m_windowTextInput->get_input()->clear();
-  m_windowTextInput->set_focus(false);
-
-  m_bindings->erase('\n');
-  m_bindings->erase(KEY_ENTER);
-
-  // Urgh... this is ugly...
-  (*m_bindings)['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
-  (*m_bindings)[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
-
-  receive_change(DISPLAY_DOWNLOAD_LIST);
-}
-
-void
-DownloadList::receive_change(Display d) {
-  if (d == m_state)
-    return;
+  activate_display(DISPLAY_DOWNLOAD_LIST);
 
-  disable_display();
-  activate_display(d);
+  delete input;
 }
 
 void
 DownloadList::receive_download_erased(core::Download* d) {
-  if (m_view->focus() == m_view->end_visible() || *m_view->focus() != d)
-    return;
-
-  if (m_uiDownload != NULL)
-    receive_exit_download();
-
-  receive_next();
-}
-
-void
-DownloadList::receive_change_view(const std::string& name) {
-  core::ViewManager::iterator itr = m_control->view_manager()->find(name);
-
-  if (itr == m_control->view_manager()->end()) {
-    m_control->core()->push_log("Could not find view \"" + name + "\".");
+  if (m_state != DISPLAY_DOWNLOAD || current_view()->focus() == current_view()->end_visible() || *current_view()->focus() != d)
     return;
-  }
-
-  m_view = *itr;
-  m_view->sort();
-
-  ElementDownloadList* ui = dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST]);
 
-  if (ui == NULL)
-    throw torrent::client_error("DownloadList::receive_change_view(...) could not cast ui.");
-
-  ui->set_view(m_view);
-}
-
-void
-DownloadList::task_update() {
-  m_windowLog->receive_update();
-
-  priority_queue_insert(&taskScheduler, &m_taskUpdate, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
+  activate_display(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::setup_keys() {
-  (*m_bindings)['\x13']        = sigc::mem_fun(*this, &DownloadList::receive_start_download);
-  (*m_bindings)['\x04']        = sigc::mem_fun(*this, &DownloadList::receive_stop_download);
-  (*m_bindings)['\x0B']        = sigc::mem_fun(*this, &DownloadList::receive_close_download);
-  (*m_bindings)['\x12']        = sigc::mem_fun(*this, &DownloadList::receive_check_hash);
-  (*m_bindings)['+']           = sigc::mem_fun(*this, &DownloadList::receive_next_priority);
-  (*m_bindings)['-']           = sigc::mem_fun(*this, &DownloadList::receive_prev_priority);
-  (*m_bindings)['I']           = sigc::mem_fun(*this, &DownloadList::receive_ignore_ratio);
-  (*m_bindings)['U']           = sigc::mem_fun(*this, &DownloadList::receive_clear_tied);
-
-  (*m_bindings)['\x7f']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
-  (*m_bindings)[KEY_BACKSPACE] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
-  (*m_bindings)['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
-  (*m_bindings)[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
-  (*m_bindings)['\x0F']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_CHANGE_DIRECTORY);
-  (*m_bindings)['\x10']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_COMMAND);
-
-  (*m_bindings)[KEY_UP]        = sigc::mem_fun(*this, &DownloadList::receive_prev);
-  (*m_bindings)[KEY_DOWN]      = sigc::mem_fun(*this, &DownloadList::receive_next);
-  (*m_bindings)[KEY_RIGHT]     = sigc::mem_fun(*this, &DownloadList::receive_view_download);
-  (*m_bindings)['l']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_LOG);
-
-  (*m_bindings)['1']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "main");
-  (*m_bindings)['2']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "name");
-  (*m_bindings)['3']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "started");
-  (*m_bindings)['4']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "stopped");
-  (*m_bindings)['5']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "complete");
-  (*m_bindings)['6']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "incomplete");
-  (*m_bindings)['7']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "hashing");
-
-  m_uiArray[DISPLAY_LOG]->get_bindings()[' '] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_DOWNLOAD_LIST);
-}
-
-void
-DownloadList::setup_input() {
-  input::PathInput* p    = new input::PathInput;
-  ElementStringList* esl = new ElementStringList();
-  m_windowTextInput      = new WInput(p);
-
-  p->slot_dirty(sigc::mem_fun(*m_windowTextInput, &WInput::mark_dirty));
-
-  p->signal_show_next().connect(sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_STRING_LIST));
-  p->signal_show_next().connect(sigc::mem_fun(*esl, &ElementStringList::next_screen));
+  m_bindings['\x7f']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
+  m_bindings[KEY_BACKSPACE] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
+  m_bindings['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
+  m_bindings[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
+  m_bindings['\x0F']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_CHANGE_DIRECTORY);
+  m_bindings['\x10']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_COMMAND);
 
-  p->signal_show_range().connect(sigc::hide(sigc::hide(sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_STRING_LIST))));
-  p->signal_show_range().connect(sigc::mem_fun(*esl, &ElementStringList::set_range<utils::Directory::iterator>));
+  m_uiArray[DISPLAY_LOG]->bindings()[' ']                 = sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_DOWNLOAD_LIST);
+  m_uiArray[DISPLAY_LOG]->bindings()[KEY_LEFT]            = sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_DOWNLOAD_LIST);
 
-  m_uiArray[DISPLAY_STRING_LIST] = esl;
+  m_uiArray[DISPLAY_DOWNLOAD_LIST]->bindings()[KEY_RIGHT] = sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_DOWNLOAD);
+  m_uiArray[DISPLAY_DOWNLOAD_LIST]->bindings()['l']       = sigc::bind(sigc::mem_fun(*this, &DownloadList::activate_display), DISPLAY_LOG);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/download_list.h	2006-06-27 00:12:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/download_list.h	2006-08-06 02:57:23.000000000 +0800
@@ -38,12 +38,13 @@
 #define RTORRENT_UI_DOWNLOAD_LIST_H
 
 #include <sigc++/slot.h>
 
 #include "display/manager.h"
 
+#include "element_base.h"
 #include "globals.h"
 
 class Control;
 
 namespace core {
   class Download;
@@ -52,39 +53,34 @@
 
 namespace input {
   class Bindings;
 }
 
 namespace display {
+  class Frame;
   class WindowDownloadList;
   class WindowHttpQueue;
   class WindowInput;
   class WindowLog;
   class WindowLogComplete;
-  class WindowTitle;
 }
 
 namespace ui {
 
 class Download;
-class ElementBase;
 
-class DownloadList {
+class DownloadList : public ElementBase {
 public:
   typedef display::WindowDownloadList              WList;
-  typedef display::WindowHttpQueue                 WHttp;
-  typedef display::WindowInput                     WInput;
   typedef display::WindowLog                       WLog;
   typedef display::WindowLogComplete               WLogComplete;
-  typedef display::WindowTitle                     WTitle;
 
   typedef sigc::slot1<void, const std::string&>    SlotOpenUri;
 
-  typedef display::Manager::iterator               MItr;
-
   typedef enum {
+    DISPLAY_DOWNLOAD,
     DISPLAY_DOWNLOAD_LIST,
     DISPLAY_LOG,
     DISPLAY_STRING_LIST,
     DISPLAY_MAX_SIZE
   } Display;
 
@@ -93,82 +89,40 @@
     INPUT_LOAD_DEFAULT,
     INPUT_LOAD_MODIFIED,
     INPUT_CHANGE_DIRECTORY,
     INPUT_COMMAND
   } Input;
 
-  DownloadList(Control* c);
+  DownloadList();
   ~DownloadList();
 
-  input::Bindings&    get_bindings()               { return *m_bindings; }
-
-  bool                is_active() const            { return m_window != m_control->display()->end(); }
-
-  void                activate();
+  void                activate(display::Frame* frame, bool focus = true);
   void                disable();
 
   void                activate_display(Display d);
-  void                disable_display();
+
+  core::View*         current_view();
 
   void                slot_open_uri(SlotOpenUri s) { m_slotOpenUri = s; }
 
 private:
   DownloadList(const DownloadList&);
   void operator = (const DownloadList&);
 
-  void                receive_next();
-  void                receive_prev();
-
-  void                receive_start_download();
-  void                receive_stop_download();
-  void                receive_close_download();
-
-  void                receive_view_download();
-  void                receive_exit_download();
-
-  void                receive_next_priority();
-  void                receive_prev_priority();
-
-  void                receive_check_hash();
-
-  void                receive_ignore_ratio();
-  void                receive_clear_tied();
-
   void                receive_view_input(Input type);
   void                receive_exit_input(Input type);
 
-  void                receive_change(Display d);
-
   void                receive_download_erased(core::Download* d);
 
-  void                receive_change_view(const std::string& name);
-
-  void                task_update();
-
   void                setup_keys();
   void                setup_input();
 
   Display             m_state;
 
   ElementBase*        m_uiArray[DISPLAY_MAX_SIZE];
-
-  MItr                m_window;
-
-  WTitle*             m_windowTitle;
   WLog*               m_windowLog;
-  WInput*             m_windowTextInput;
-  WHttp*              m_windowHttpQueue;
-
-  rak::priority_item  m_taskUpdate;
-
-  Download*           m_uiDownload;
-
-  core::View*         m_view;
-
-  Control*            m_control;
-  input::Bindings*    m_bindings;
 
   SlotOpenUri         m_slotOpenUri;
 };
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_base.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_base.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_base.h	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_base.h	2006-08-07 23:32:20.000000000 +0800
@@ -34,29 +34,42 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UI_ELEMENT_BASE_H
 #define RTORRENT_UI_ELEMENT_BASE_H
 
-#include "display/manager.h"
 #include "input/bindings.h"
 
+namespace display {
+  class Frame;
+  class Window;
+}
+
 namespace ui {
 
 class ElementBase {
 public:
-  typedef display::Manager::iterator MItr;
+  typedef sigc::slot0<void> slot_type;
 
+  ElementBase() : m_frame(NULL), m_focus(false) {}
   virtual ~ElementBase() {}
 
-  virtual void        activate(Control* c, MItr mItr) = 0;
-  virtual void        disable(Control* c) = 0;
+  bool                is_active() const { return m_frame != NULL; }
+
+  input::Bindings&    bindings()        { return m_bindings; }
 
-  input::Bindings&    get_bindings() { return m_bindings; }
+  virtual void        activate(display::Frame* frame, bool focus = true) = 0;
+  virtual void        disable() = 0;
+
+  void                slot_exit(const slot_type& s) { m_slotExit = s; }
 
 protected:
+  display::Frame*     m_frame;
+  bool                m_focus;
+
   input::Bindings     m_bindings;
+  slot_type           m_slotExit;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_chunks_seen.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_chunks_seen.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_chunks_seen.cc	2006-06-05 05:23:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_chunks_seen.cc	2006-08-08 00:00:26.000000000 +0800
@@ -33,14 +33,15 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <torrent/exceptions.h>
 
+#include "display/frame.h"
 #include "display/window_download_chunks_seen.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_chunks_seen.h"
 
@@ -48,41 +49,54 @@
 
 ElementChunksSeen::ElementChunksSeen(core::Download* d) :
   m_download(d),
   m_window(NULL),
   m_focus(0) {
 
+  m_bindings[KEY_LEFT] = sigc::mem_fun(&m_slotExit, &slot_type::operator());
+
   m_bindings[KEY_DOWN]  = sigc::mem_fun(*this, &ElementChunksSeen::receive_next);
   m_bindings[KEY_UP]    = sigc::mem_fun(*this, &ElementChunksSeen::receive_prev);
   m_bindings[KEY_NPAGE] = sigc::mem_fun(*this, &ElementChunksSeen::receive_pagenext);
   m_bindings[KEY_PPAGE] = sigc::mem_fun(*this, &ElementChunksSeen::receive_pageprev);
-//   m_bindings[' ']      = sigc::mem_fun(*this, &ElementChunksSeen::receive_cycle_group);
-//   m_bindings['*']      = sigc::mem_fun(*this, &ElementChunksSeen::receive_disable);
 }
 
 void
-ElementChunksSeen::activate(Control* c, MItr mItr) {
-  if (m_window != NULL)
-    throw std::logic_error("ui::ElementChunksSeen::activate(...) called on an object in the wrong state");
+ElementChunksSeen::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::ElementChunksSeen::activate(...) is_active().");
+
+  if (focus)
+    control->input()->push_back(&m_bindings);
 
-  c->input()->push_front(&m_bindings);
+  m_window = new WChunksSeen(m_download, &m_focus);
+  m_window->set_active(true);
 
-  *mItr = m_window = new WChunksSeen(m_download, &m_focus);
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementChunksSeen::disable(Control* c) {
-  if (m_window == NULL)
-    throw std::logic_error("ui::ElementChunksSeen::disable(...) called on an object in the wrong state");
+ElementChunksSeen::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::ElementChunksSeen::disable(...) !is_active().");
 
-  c->input()->erase(&m_bindings);
+  control->input()->erase(&m_bindings);
+
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
+display::Window*
+ElementChunksSeen::window() {
+  return m_window;
+}
+
 // void
 // ElementChunksSeen::receive_disable() {
 //   if (m_window == NULL)
 //     throw std::logic_error("ui::ElementChunksSeen::receive_disable(...) called on a disabled object");
 
 //   if (m_download->download()->tracker(m_focus).is_enabled())
@@ -119,13 +133,13 @@
 
 void
 ElementChunksSeen::receive_pagenext() {
   if (m_window == NULL)
     throw torrent::client_error("ui::ElementChunksSeen::receive_pagenext(...) called on a disabled object");
 
-  unsigned int visible = m_window->get_height() - 1;
+  unsigned int visible = m_window->height() - 1;
   unsigned int scrollable = std::max<int>(m_window->rows() - visible, 0);
 
   if (scrollable == 0 || m_focus == scrollable)
     m_focus = 0;
   else if (m_focus + visible / 2 < scrollable)
     m_focus += visible / 2;
@@ -137,13 +151,13 @@
 
 void
 ElementChunksSeen::receive_pageprev() {
   if (m_window == NULL)
     throw torrent::client_error("ui::ElementChunksSeen::receive_pageprev(...) called on a disabled object");
 
-  unsigned int visible = m_window->get_height() - 1;
+  unsigned int visible = m_window->height() - 1;
   unsigned int scrollable = std::max<int>(m_window->rows() - visible, 0);
 
   if (m_focus > visible / 2)
     m_focus -= visible / 2;
   else if (scrollable > 0 && m_focus == 0)
     m_focus = scrollable;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_chunks_seen.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_chunks_seen.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_chunks_seen.h	2006-06-05 04:54:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_chunks_seen.h	2006-08-06 02:57:23.000000000 +0800
@@ -52,14 +52,16 @@
 class ElementChunksSeen : public ElementBase {
 public:
   typedef display::WindowDownloadChunksSeen WChunksSeen;
 
   ElementChunksSeen(core::Download* d);
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  display::Window*    window();
 
 private:
 //   void                receive_disable();
   void                receive_next();
   void                receive_prev();
   void                receive_pagenext();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_download_list.cc	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_download_list.cc	2006-08-15 22:59:43.000000000 +0800
@@ -33,51 +33,210 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <sigc++/bind.h>
+#include <torrent/exceptions.h>
 
+#include "core/download.h"
+#include "core/manager.h"
+#include "core/view.h"
+#include "core/view_manager.h"
+#include "display/frame.h"
+#include "display/manager.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_download_list.h"
 
 namespace ui {
 
+ElementDownloadList::ElementDownloadList() :
+  m_window(NULL),
+  m_view(NULL) {
+
+  receive_change_view("main");
+
+  if (m_view == NULL)
+    throw torrent::client_error("View \"main\" must be present to initialize the main display.");
+
+  m_bindings['\x13']        = sigc::mem_fun(*this, &ElementDownloadList::receive_start_download);
+  m_bindings['\x04']        = sigc::mem_fun(*this, &ElementDownloadList::receive_stop_download);
+  m_bindings['\x0B']        = sigc::mem_fun(*this, &ElementDownloadList::receive_close_download);
+  m_bindings['\x12']        = sigc::mem_fun(*this, &ElementDownloadList::receive_check_hash);
+  m_bindings['+']           = sigc::mem_fun(*this, &ElementDownloadList::receive_next_priority);
+  m_bindings['-']           = sigc::mem_fun(*this, &ElementDownloadList::receive_prev_priority);
+  m_bindings['I']           = sigc::mem_fun(*this, &ElementDownloadList::receive_ignore_ratio);
+  m_bindings['U']           = sigc::mem_fun(*this, &ElementDownloadList::receive_clear_tied);
+
+  m_bindings['1']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "main");
+  m_bindings['2']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "name");
+  m_bindings['3']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "started");
+  m_bindings['4']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "stopped");
+  m_bindings['5']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "complete");
+  m_bindings['6']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "incomplete");
+  m_bindings['7']           = sigc::bind(sigc::mem_fun(*this, &ElementDownloadList::receive_change_view), "hashing");
+
+  m_bindings[KEY_UP]   = m_bindings['P' - '@'] = sigc::mem_fun(*this, &ElementDownloadList::receive_prev);
+  m_bindings[KEY_DOWN] = m_bindings['N' - '@'] = sigc::mem_fun(*this, &ElementDownloadList::receive_next);
+}
+
 void
-ElementDownloadList::activate(Control* c, MItr mItr) {
-  if (m_window != NULL)
-    throw std::logic_error("ui::ElementDownloadList::activate(...) called on an object in the wrong state");
+ElementDownloadList::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::ElementDownloadList::activate(...) is_active().");
 
-  c->input()->push_front(&m_bindings);
+  control->input()->push_back(&m_bindings);
 
   m_window = new WDownloadList();
+  m_window->set_active(true);
   m_window->set_view(m_view);
 
-  *mItr = m_window;
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementDownloadList::disable(Control* c) {
-  if (m_window == NULL)
-    throw std::logic_error("ui::ElementDownloadList::disable(...) called on an object in the wrong state");
+ElementDownloadList::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::ElementDownloadList::disable(...) !is_active().");
 
-  c->input()->erase(&m_bindings);
+  control->input()->erase(&m_bindings);
+
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
 void
 ElementDownloadList::set_view(core::View* l) {
   m_view = l;
+  m_view->sort();
 
   if (m_window == NULL)
     return;
 
   m_window->set_view(l);
   m_window->mark_dirty();
 }
 
+void
+ElementDownloadList::receive_next() {
+  m_view->next_focus();
+  m_view->set_last_changed();
+}
+
+void
+ElementDownloadList::receive_prev() {
+  m_view->prev_focus();
+  m_view->set_last_changed();
+}
+
+void
+ElementDownloadList::receive_start_download() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  control->core()->download_list()->start_normal(*m_view->focus());
+  m_view->set_last_changed();
+}
+
+void
+ElementDownloadList::receive_stop_download() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  if ((*m_view->focus())->variable()->get_value("state") == 1)
+    control->core()->download_list()->stop_normal(*m_view->focus());
+  else
+    control->core()->download_list()->erase(*m_view->focus());
+
+  m_view->set_last_changed();
+}
+
+void
+ElementDownloadList::receive_close_download() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  core::Download* download = *m_view->focus();
+
+  download->variable()->set("ignore_commands", (int64_t)1);
+
+  control->core()->download_list()->stop_normal(download);
+  control->core()->download_list()->close(download);
+  m_view->set_last_changed();
+}
+
+void
+ElementDownloadList::receive_next_priority() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  (*m_view->focus())->set_priority(((*m_view->focus())->priority() + 1) % 4);
+  m_window->mark_dirty();
+}
+
+void
+ElementDownloadList::receive_prev_priority() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  (*m_view->focus())->set_priority(((*m_view->focus())->priority() - 1) % 4);
+  m_window->mark_dirty();
+}
+
+void
+ElementDownloadList::receive_check_hash() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  // Catch here?
+  control->core()->download_list()->check_hash(*m_view->focus());
+}
+
+void
+ElementDownloadList::receive_ignore_ratio() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  if ((*m_view->focus())->variable()->get_value("ignore_commands") != 0) {
+    (*m_view->focus())->variable()->set("ignore_commands", (int64_t)0);
+    control->core()->push_log("Torrent set to heed commands.");
+  } else {
+    (*m_view->focus())->variable()->set("ignore_commands", (int64_t)1);
+    control->core()->push_log("Torrent set to ignore commands.");
+  }
+}
+
+void
+ElementDownloadList::receive_clear_tied() {
+  if (m_view->focus() == m_view->end_visible())
+    return;
+
+  const std::string& tiedFile = (*m_view->focus())->variable()->get_string("tied_to_file");
+
+  if (!tiedFile.empty()) {
+    // Move this into core?
+    control->core()->delete_tied(*m_view->focus());
+
+    control->core()->push_log("Cleared tied to file association for download.");
+  }
+}
+
+void
+ElementDownloadList::receive_change_view(const std::string& name) {
+  core::ViewManager::iterator itr = control->view_manager()->find(name);
+
+  if (itr == control->view_manager()->end()) {
+    control->core()->push_log("Could not find view \"" + name + "\".");
+    return;
+  }
+
+  set_view(*itr);
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_download_list.h	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_download_list.h	2006-08-06 02:57:23.000000000 +0800
@@ -51,21 +51,39 @@
 namespace ui {
 
 class ElementDownloadList : public ElementBase {
 public:
   typedef display::WindowDownloadList WDownloadList;
 
-  ElementDownloadList() : m_window(NULL), m_view(NULL) {}
+  ElementDownloadList();
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
 
+  core::View*         view() { return m_view; }
   void                set_view(core::View* l);
 
+  void                receive_next();
+  void                receive_prev();
+
+  void                receive_start_download();
+  void                receive_stop_download();
+  void                receive_close_download();
+
+  void                receive_next_priority();
+  void                receive_prev_priority();
+
+  void                receive_check_hash();
+
+  void                receive_ignore_ratio();
+  void                receive_clear_tied();
+
+  void                receive_change_view(const std::string& name);
+
 private:
-  WDownloadList*       m_window;
-  core::View*          m_view;
+  WDownloadList*      m_window;
+  core::View*         m_view;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_file_list.cc	2006-06-05 04:54:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_file_list.cc	2006-08-15 23:00:44.000000000 +0800
@@ -36,12 +36,13 @@
 
 #include "config.h"
 
 #include <torrent/exceptions.h>
 #include <torrent/file_list.h>
 
+#include "display/frame.h"
 #include "display/window_file_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_file_list.h"
 
@@ -49,41 +50,57 @@
 
 ElementFileList::ElementFileList(core::Download* d) :
   m_download(d),
   m_window(NULL),
   m_focus(0) {
 
+  m_bindings[KEY_LEFT] = sigc::mem_fun(&m_slotExit, &slot_type::operator());
+
   m_bindings[' '] = sigc::mem_fun(*this, &ElementFileList::receive_priority);
   m_bindings['*'] = sigc::mem_fun(*this, &ElementFileList::receive_change_all);
-  m_bindings[KEY_DOWN] = sigc::mem_fun(*this, &ElementFileList::receive_next);
-  m_bindings[KEY_UP] = sigc::mem_fun(*this, &ElementFileList::receive_prev);
   m_bindings[KEY_NPAGE] = sigc::mem_fun(*this, &ElementFileList::receive_pagenext);
   m_bindings[KEY_PPAGE] = sigc::mem_fun(*this, &ElementFileList::receive_pageprev);
+
+  m_bindings[KEY_DOWN] = m_bindings['P' - '@'] = sigc::mem_fun(*this, &ElementFileList::receive_next);
+  m_bindings[KEY_UP]   = m_bindings['N' - '@'] = sigc::mem_fun(*this, &ElementFileList::receive_prev);
 }
 
 void
-ElementFileList::activate(Control* c, MItr mItr) {
+ElementFileList::activate(display::Frame* frame, bool focus) {
   if (m_window != NULL)
-    throw torrent::client_error("ui::ElementFileList::activate(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementFileList::activate(...) is_active().");
+
+  if (focus)
+    control->input()->push_back(&m_bindings);
 
-  c->input()->push_front(&m_bindings);
+  m_window = new WFileList(m_download, &m_focus);
+  m_window->set_active(true);
 
-  *mItr = m_window = new WFileList(m_download, &m_focus);
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementFileList::disable(Control* c) {
+ElementFileList::disable() {
   if (m_window == NULL)
-    throw torrent::client_error("ui::ElementFileList::disable(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementFileList::disable(...) !is_active().");
 
-  c->input()->erase(&m_bindings);
+  control->input()->erase(&m_bindings);
+
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
+display::Window*
+ElementFileList::window() {
+  return m_window;
+}
+
 void
 ElementFileList::receive_next() {
   if (m_window == NULL)
     throw torrent::client_error("ui::ElementFileList::receive_next(...) called on a disabled object");
 
   if (++m_focus >= m_download->download()->file_list().size())
@@ -112,13 +129,13 @@
 
 void
 ElementFileList::receive_pagenext() {
   if (m_window == NULL)
     throw torrent::client_error("ui::ElementFileList::receive_pagenext(...) called on a disabled object");
 
-  unsigned int count = (m_window->get_height() - 1) / 2;
+  unsigned int count = (m_window->height() - 1) / 2;
 
   if (m_focus + count < m_download->download()->file_list().size())
     m_focus += count;
   else if (m_focus == m_download->download()->file_list().size() - 1)
     m_focus = 0;
   else 
@@ -134,13 +151,13 @@
 
   torrent::FileList fl = m_download->download()->file_list();
 
   if (fl.size() == 0)
     return;
 
-  unsigned int count = (m_window->get_height() - 1) / 2;
+  unsigned int count = (m_window->height() - 1) / 2;
 
   if (m_focus > count)
     m_focus -= count;
   else if (m_focus == 0)
     m_focus = fl.size() - 1;
   else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_file_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_file_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_file_list.h	2006-06-05 04:54:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_file_list.h	2006-08-06 02:57:23.000000000 +0800
@@ -55,14 +55,16 @@
 public:
   typedef torrent::priority_t Priority;
   typedef display::WindowFileList  WFileList;
 
   ElementFileList(core::Download* d);
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  display::Window*    window();
 
 private:
   void                receive_next();
   void                receive_prev();
   void                receive_pagenext();
   void                receive_pageprev();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_log_complete.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_log_complete.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_log_complete.cc	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_log_complete.cc	2006-08-06 02:58:55.000000000 +0800
@@ -33,14 +33,16 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <torrent/exceptions.h>
 
+#include "display/frame.h"
+#include "display/manager.h"
 #include "display/window_log_complete.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_log_complete.h"
 
@@ -49,27 +51,39 @@
 ElementLogComplete::ElementLogComplete(core::Log* l) :
   m_window(NULL),
   m_log(l) {
 }
 
 void
-ElementLogComplete::activate(Control* c, MItr mItr) {
-  if (m_window != NULL)
-    throw std::logic_error("ui::ElementLogComplete::activate(...) called on an object in the wrong state");
+ElementLogComplete::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::ElementLogComplete::activate(...) is_active().");
 
-  c->input()->push_front(&m_bindings);
+  control->input()->push_back(&m_bindings);
 
-  *mItr = m_window = new WLogComplete(m_log);
+  m_window = new WLogComplete(m_log);
+  m_window->set_active(true);
+
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementLogComplete::disable(Control* c) {
-  if (m_window == NULL)
-    throw std::logic_error("ui::ElementLogComplete::disable(...) called on an object in the wrong state");
+ElementLogComplete::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::ElementLogComplete::disable(...) !is_active().");
+
+  control->input()->erase(&m_bindings);
 
-  c->input()->erase(&m_bindings);
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
+display::Window*
+ElementLogComplete::window() {
+  return m_window;
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_log_complete.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_log_complete.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_log_complete.h	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_log_complete.h	2006-08-06 02:57:23.000000000 +0800
@@ -52,14 +52,16 @@
 class ElementLogComplete : public ElementBase {
 public:
   typedef display::WindowLogComplete    WLogComplete;
 
   ElementLogComplete(core::Log* l);
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  display::Window*    window();
 
 private:
   WLogComplete*       m_window;
   
   core::Log*          m_log;
 };
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui: element_menu.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui: element_menu.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui: element_peer_info.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui: element_peer_info.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_peer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_peer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_peer_list.cc	2006-05-27 07:20:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_peer_list.cc	2006-08-15 23:00:15.000000000 +0800
@@ -33,46 +33,225 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
-
+#include <sigc++/bind.h>
+#include <torrent/exceptions.h>
+#include <torrent/rate.h>
+
+#include "display/client_info.h"
+#include "display/frame.h"
+#include "display/manager.h"
+#include "display/text_element_helpers.h"
+#include "display/text_element_lambda.h"
 #include "display/window_peer_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_peer_list.h"
+#include "element_text.h"
 
 namespace ui {
 
-ElementPeerList::ElementPeerList(core::Download* d, PList* l, PList::iterator* f) :
+ElementPeerList::ElementPeerList(core::Download* d) :
   m_download(d),
-  m_window(NULL),
-  m_list(l),
-  m_focus(f) {
+  m_state(DISPLAY_MAX_SIZE) {
+
+  m_listItr = m_list.end();
+
+  m_download->download()->peer_list(m_list);
+
+  m_connPeerConnected    = m_download->download()->signal_peer_connected(sigc::mem_fun(*this, &ElementPeerList::receive_peer_connected));
+  m_connPeerDisconnected = m_download->download()->signal_peer_disconnected(sigc::mem_fun(*this, &ElementPeerList::receive_peer_disconnected));
+
+  m_windowList  = new display::WindowPeerList(m_download, &m_list, &m_listItr);
+  m_elementInfo = create_info();
+
+  m_elementInfo->slot_exit(sigc::bind(sigc::mem_fun(this, &ElementPeerList::activate_display), DISPLAY_LIST));
+
+  m_bindings['k']       = sigc::mem_fun(this, &ElementPeerList::receive_disconnect_peer);
+  m_bindings['*']       = sigc::mem_fun(this, &ElementPeerList::receive_snub_peer);
+  m_bindings[KEY_LEFT]  = sigc::mem_fun(&m_slotExit, &slot_type::operator());  
+  m_bindings[KEY_RIGHT] = sigc::bind(sigc::mem_fun(this, &ElementPeerList::activate_display), DISPLAY_INFO);
+
+  m_bindings[KEY_UP]   = m_bindings['P' - '@'] = sigc::mem_fun(this, &ElementPeerList::receive_prev);
+  m_bindings[KEY_DOWN] = m_bindings['N' - '@'] = sigc::mem_fun(this, &ElementPeerList::receive_next);
+}
+
+ElementPeerList::~ElementPeerList() {
+  m_connPeerConnected.disconnect();
+  m_connPeerDisconnected.disconnect();
+
+  delete m_windowList;
+  delete m_elementInfo;
+}
+
+inline ElementText*
+ElementPeerList::create_info() {
+  using namespace display::helpers;
+
+  ElementText* element = new ElementText(NULL);
+
+  element->set_column(1);
+  element->set_interval(1);
+
+  // Get these bindings with some kind of string map.
+
+  element->push_back("Peer info:");
+
+  element->push_back("");
+  element->push_column("Address:",
+                       display::text_element_string_slot(rak::on(std::mem_fun(&torrent::Peer::address), std::ptr_fun(&te_address))), ":",
+                       display::text_element_value_slot(rak::on(std::mem_fun(&torrent::Peer::address), std::ptr_fun(&te_port))));
+
+  element->push_column("Id:",        display::text_element_string_slot(std::mem_fun(&torrent::Peer::id), string_base::flag_escape_html));
+  element->push_column("Client:",    display::text_element_string_slot(rak::on(std::mem_fun(&torrent::Peer::id), rak::make_mem_fun(control->client_info(), &display::ClientInfo::str_str))));
+  element->push_column("Options:",   display::text_element_string_slot(std::mem_fun(&torrent::Peer::options), string_base::flag_escape_hex | string_base::flag_fixed_width, 0, 8));
+  element->push_column("Connected:", display::text_element_branch(std::mem_fun(&torrent::Peer::is_incoming), te_string("incoming"), te_string("outgoing")));
+
+  element->push_back("");
+  element->push_column("Snubbed:", display::text_element_branch(std::mem_fun(&torrent::Peer::is_snubbed), te_string("yes"), te_string("no")));
+  element->push_column("Done:",    display::text_element_value_slot(rak::on(std::mem_fun(&torrent::Peer::bitfield), std::ptr_fun(&te_bitfield_percentage))));
+  element->push_column("Rate:",
+                       display::text_element_value_slot(rak::on(std::mem_fun(&torrent::Peer::up_rate), std::mem_fun(&torrent::Rate::rate)), value_base::flag_kb), " KB / ",
+                       display::text_element_value_slot(rak::on(std::mem_fun(&torrent::Peer::down_rate), std::mem_fun(&torrent::Rate::rate)), value_base::flag_kb), " KB");
+  element->push_column("Total:",
+                       display::text_element_value_slot(rak::on(std::mem_fun(&torrent::Peer::up_rate), std::mem_fun(&torrent::Rate::total)), value_base::flag_xb), " / ",
+                       display::text_element_value_slot(rak::on(std::mem_fun(&torrent::Peer::down_rate), std::mem_fun(&torrent::Rate::total)), value_base::flag_xb));
+
+  element->set_column_width(element->column_width() + 1);
+
+  return element;
+}
+
+void
+ElementPeerList::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::ElementPeerList::activate(...) is_active().");
+
+  if (focus)
+    control->input()->push_back(&m_bindings);
+
+  m_frame = frame;
+  m_focus = focus;
+
+  activate_display(DISPLAY_LIST);
+}
+
+void
+ElementPeerList::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::ElementPeerList::disable(...) !is_active().");
 
+  control->input()->erase(&m_bindings);
+
+  activate_display(DISPLAY_MAX_SIZE);
+
+  m_frame->clear();
+  m_frame = NULL;
+}
+
+void
+ElementPeerList::activate_display(Display display) {
+  if (display == m_state)
+    return;
+
+  switch (m_state) {
+  case DISPLAY_INFO:
+    m_elementInfo->disable();
+    break;
+
+  case DISPLAY_LIST:
+    m_windowList->set_active(false);
+    m_frame->clear();
+    break;
+
+  case DISPLAY_MAX_SIZE:
+    break;
+  }
+
+  m_state = display;
+
+  switch (m_state) {
+  case DISPLAY_INFO:
+    m_elementInfo->activate(m_frame, true);
+    break;
+
+  case DISPLAY_LIST:
+    m_windowList->set_active(true);
+    m_frame->initialize_window(m_windowList);
+    break;
+
+  case DISPLAY_MAX_SIZE:
+    break;
+  }
+
+  control->display()->adjust_layout();
+}
+
+void
+ElementPeerList::receive_next() {
+  if (m_listItr != m_list.end())
+    ++m_listItr;
+  else
+    m_listItr = m_list.begin();
+
+  updated_itr();
+}
+
+void
+ElementPeerList::receive_prev() {
+  if (m_listItr != m_list.begin())
+    --m_listItr;
+  else
+    m_listItr = m_list.end();
+
+  updated_itr();
+}
+
+void
+ElementPeerList::receive_disconnect_peer() {
+  if (m_listItr == m_list.end())
+    return;
+
+  m_download->download()->disconnect_peer(*m_listItr);
 }
 
 void
-ElementPeerList::activate(Control* c, MItr mItr) {
-  if (m_window != NULL)
-    throw std::logic_error("ui::ElementPeerList::activate(...) called on an object in the wrong state");
+ElementPeerList::receive_peer_connected(torrent::Peer p) {
+  m_list.push_back(p);
+}
+
+void
+ElementPeerList::receive_peer_disconnected(torrent::Peer p) {
+  PList::iterator itr = std::find(m_list.begin(), m_list.end(), p);
 
-  c->input()->push_front(&m_bindings);
+  if (itr == m_list.end())
+    throw torrent::client_error("ElementPeerList::receive_peer_disconnected(...) itr == m_list.end().");
 
-  *mItr = m_window = new WPeerList(m_download, m_list, m_focus);
+  if (itr == m_listItr)
+    m_listItr = m_list.erase(itr);
+  else
+    m_list.erase(itr);
+
+  updated_itr();
 }
 
 void
-ElementPeerList::disable(Control* c) {
-  if (m_window == NULL)
-    throw std::logic_error("ui::ElementPeerList::disable(...) called on an object in the wrong state");
+ElementPeerList::receive_snub_peer() {
+  if (m_listItr == m_list.end())
+    return;
+
+  m_listItr->set_snubbed(!m_listItr->is_snubbed());
 
-  c->input()->erase(&m_bindings);
+  updated_itr();
+}
 
-  delete m_window;
-  m_window = NULL;
+inline void
+ElementPeerList::updated_itr() {
+  m_windowList->mark_dirty();
+  m_elementInfo->set_object(m_listItr != m_list.end() ? &*m_listItr : NULL);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_peer_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_peer_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_peer_list.h	2006-05-27 07:20:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_peer_list.h	2006-08-13 01:57:27.000000000 +0800
@@ -38,35 +38,60 @@
 #define RTORRENT_UI_ELEMENT_PEER_LIST_H
 
 #include "core/download.h"
 
 #include "element_base.h"
 
-class Control;
-
-namespace display {
-  class WindowPeerList;
-}
-
 namespace ui {
 
+class ElementText;
+
 class ElementPeerList : public ElementBase {
 public:
-  typedef display::WindowPeerList       WPeerList;
-  typedef std::list<torrent::Peer>      PList;
+  typedef std::list<torrent::Peer> PList;
 
-  ElementPeerList(core::Download* d, PList* l, PList::iterator* f);
+  typedef enum {
+    DISPLAY_LIST,
+    DISPLAY_INFO,
+    DISPLAY_MAX_SIZE
+  } Display;
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  ElementPeerList(core::Download* d);
+  ~ElementPeerList();
+
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  void                activate_display(Display display);
 
 private:
+  inline ElementText* create_info();
+
+  void                receive_next();
+  void                receive_prev();
+
+  void                receive_disconnect_peer();
+
+  void                receive_peer_connected(torrent::Peer p);
+  void                receive_peer_disconnected(torrent::Peer p);
+
+  void                receive_snub_peer();
+
+  inline void         updated_itr();
+
   core::Download*     m_download;
-  WPeerList*          m_window;
   
-  PList*              m_list;
-  PList::iterator*    m_focus;
+  Display             m_state;
+  display::Window*    m_windowList;
+  
+  ElementText*        m_elementInfo;
+
+  PList               m_list;
+  PList::iterator     m_listItr;
+
+  sigc::connection    m_connPeerConnected;
+  sigc::connection    m_connPeerDisconnected;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_string_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_string_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_string_list.cc	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_string_list.cc	2006-08-06 02:58:55.000000000 +0800
@@ -33,43 +33,49 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <torrent/exceptions.h>
 
+#include "display/frame.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_string_list.h"
 
 namespace ui {
 
 ElementStringList::ElementStringList() :
   m_window(NULL) {
 }
 
 void
-ElementStringList::activate(Control* c, MItr mItr) {
-  if (m_window != NULL)
-    throw std::logic_error("ui::ElementStringList::activate(...) called on an object in the wrong state");
+ElementStringList::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::ElementStringList::activate(...) is_active().");
 
-  c->input()->push_front(&m_bindings);
+  control->input()->push_back(&m_bindings);
 
-  *mItr = m_window = new WStringList();
+  m_window = new WStringList();
+  m_window->set_active(true);
 
-  m_window->set_range(m_list.begin(), m_list.end());
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementStringList::disable(Control* c) {
-  if (m_window == NULL)
-    throw std::logic_error("ui::ElementStringList::disable(...) called on an object in the wrong state");
+ElementStringList::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::ElementStringList::disable(...) !is_active().");
 
-  c->input()->erase(&m_bindings);
+  control->input()->erase(&m_bindings);
+
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_string_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_string_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_string_list.h	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_string_list.h	2006-08-06 02:57:23.000000000 +0800
@@ -54,14 +54,16 @@
 public:
   typedef display::WindowStringList     WStringList;
   typedef std::list<std::string>        List;
 
   ElementStringList();
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  display::Window*    window() { return m_window; }
 
   template <typename InputIter>
   void                set_range(InputIter first, InputIter last) {
     m_list.clear();
 
     while (first != last)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui: element_text.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui: element_text.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_tracker_list.cc	2006-05-27 07:20:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_tracker_list.cc	2006-08-15 23:01:49.000000000 +0800
@@ -37,12 +37,13 @@
 #include "config.h"
 
 #include <torrent/exceptions.h>
 #include <torrent/tracker.h>
 #include <torrent/tracker_list.h>
 
+#include "display/frame.h"
 #include "display/window_tracker_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_tracker_list.h"
 
@@ -50,39 +51,55 @@
 
 ElementTrackerList::ElementTrackerList(core::Download* d) :
   m_download(d),
   m_window(NULL),
   m_focus(0) {
 
-  m_bindings[KEY_DOWN] = sigc::mem_fun(*this, &ElementTrackerList::receive_next);
-  m_bindings[KEY_UP]   = sigc::mem_fun(*this, &ElementTrackerList::receive_prev);
+  m_bindings[KEY_LEFT] = sigc::mem_fun(&m_slotExit, &slot_type::operator());
+
   m_bindings[' ']      = sigc::mem_fun(*this, &ElementTrackerList::receive_cycle_group);
   m_bindings['*']      = sigc::mem_fun(*this, &ElementTrackerList::receive_disable);
+
+  m_bindings[KEY_DOWN] = m_bindings['P' - '@'] = sigc::mem_fun(*this, &ElementTrackerList::receive_next);
+  m_bindings[KEY_UP]   = m_bindings['N' - '@'] = sigc::mem_fun(*this, &ElementTrackerList::receive_prev);
 }
 
 void
-ElementTrackerList::activate(Control* c, MItr mItr) {
+ElementTrackerList::activate(display::Frame* frame, bool focus) {
   if (m_window != NULL)
-    throw torrent::client_error("ui::ElementTrackerList::activate(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementTrackerList::activate(...) is_active().");
+
+  if (focus)
+    control->input()->push_back(&m_bindings);
 
-  c->input()->push_front(&m_bindings);
+  m_window = new WTrackerList(m_download, &m_focus);
+  m_window->set_active(true);
 
-  *mItr = m_window = new WTrackerList(m_download, &m_focus);
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementTrackerList::disable(Control* c) {
+ElementTrackerList::disable() {
   if (m_window == NULL)
-    throw torrent::client_error("ui::ElementTrackerList::disable(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementTrackerList::disable(...) !is_active().");
 
-  c->input()->erase(&m_bindings);
+  control->input()->erase(&m_bindings);
+
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
+display::Window*
+ElementTrackerList::window() {
+  return m_window;
+}
+
 void
 ElementTrackerList::receive_disable() {
   if (m_window == NULL)
     throw torrent::client_error("ui::ElementTrackerList::receive_disable(...) called on a disabled object");
 
   torrent::Tracker t = m_download->download()->tracker_list().get(m_focus);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_tracker_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_tracker_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_tracker_list.h	2006-05-27 07:20:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_tracker_list.h	2006-08-06 02:57:23.000000000 +0800
@@ -52,14 +52,16 @@
 class ElementTrackerList : public ElementBase {
 public:
   typedef display::WindowTrackerList    WTrackerList;
 
   ElementTrackerList(core::Download* d);
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  display::Window*    window();
 
 private:
   void                receive_next();
   void                receive_prev();
 
   void                receive_disable();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_transfer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_transfer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_transfer_list.cc	2006-06-10 05:34:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_transfer_list.cc	2006-08-08 00:00:26.000000000 +0800
@@ -33,14 +33,15 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <torrent/exceptions.h>
 
+#include "display/frame.h"
 #include "display/window_download_transfer_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_transfer_list.h"
 
@@ -48,41 +49,54 @@
 
 ElementTransferList::ElementTransferList(core::Download* d) :
   m_download(d),
   m_window(NULL),
   m_focus(0) {
 
+  m_bindings[KEY_LEFT] = sigc::mem_fun(&m_slotExit, &slot_type::operator());
+
   m_bindings[KEY_DOWN]  = sigc::mem_fun(*this, &ElementTransferList::receive_next);
   m_bindings[KEY_UP]    = sigc::mem_fun(*this, &ElementTransferList::receive_prev);
   m_bindings[KEY_NPAGE] = sigc::mem_fun(*this, &ElementTransferList::receive_pagenext);
   m_bindings[KEY_PPAGE] = sigc::mem_fun(*this, &ElementTransferList::receive_pageprev);
-//   m_bindings[' ']      = sigc::mem_fun(*this, &ElementTransferList::receive_cycle_group);
-//   m_bindings['*']      = sigc::mem_fun(*this, &ElementTransferList::receive_disable);
 }
 
 void
-ElementTransferList::activate(Control* c, MItr mItr) {
-  if (m_window != NULL)
-    throw std::logic_error("ui::ElementTransferList::activate(...) called on an object in the wrong state");
+ElementTransferList::activate(display::Frame* frame, bool focus) {
+  if (is_active())
+    throw torrent::client_error("ui::ElementTransferList::activate(...) is_active().");
+
+  if (focus)
+    control->input()->push_back(&m_bindings);
 
-  c->input()->push_front(&m_bindings);
+  m_window = new WTransferList(m_download, &m_focus);
+  m_window->set_active(true);
 
-  *mItr = m_window = new WTransferList(m_download, &m_focus);
+  m_frame = frame;
+  m_frame->initialize_window(m_window);
 }
 
 void
-ElementTransferList::disable(Control* c) {
-  if (m_window == NULL)
-    throw std::logic_error("ui::ElementTransferList::disable(...) called on an object in the wrong state");
+ElementTransferList::disable() {
+  if (!is_active())
+    throw torrent::client_error("ui::ElementTransferList::disable(...) !is_active().");
+
+  control->input()->erase(&m_bindings);
 
-  c->input()->erase(&m_bindings);
+  m_frame->clear();
+  m_frame = NULL;
 
   delete m_window;
   m_window = NULL;
 }
 
+display::Window*
+ElementTransferList::window() {
+  return m_window;
+}
+
 // void
 // ElementTransferList::receive_disable() {
 //   if (m_window == NULL)
 //     throw std::logic_error("ui::ElementTransferList::receive_disable(...) called on a disabled object");
 
 //   if (m_download->download()->tracker(m_focus).is_enabled())
@@ -92,65 +106,65 @@
 
 //   m_window->mark_dirty();
 // }
 
 void
 ElementTransferList::receive_next() {
-//   if (m_window == NULL)
-//     throw torrent::client_error("ui::ElementTransferList::receive_next(...) called on a disabled object");
+  if (m_window == NULL)
+    throw torrent::client_error("ui::ElementTransferList::receive_next(...) called on a disabled object");
 
-//   if (++m_focus > m_window->max_focus())
-//     m_focus = 0;
+  if (++m_focus > m_window->max_focus())
+    m_focus = 0;
 
 //   m_window->mark_dirty();
 }
 
 void
 ElementTransferList::receive_prev() {
-//   if (m_window == NULL)
-//     throw torrent::client_error("ui::ElementTransferList::receive_prev(...) called on a disabled object");
+  if (m_window == NULL)
+    throw torrent::client_error("ui::ElementTransferList::receive_prev(...) called on a disabled object");
 
-//   if (m_focus > 0)
-//     --m_focus;
-//   else
-//     m_focus = m_window->max_focus();
+  if (m_focus > 0)
+    --m_focus;
+  else
+    m_focus = m_window->max_focus();
 
 //   m_window->mark_dirty();
 }
 
 void
 ElementTransferList::receive_pagenext() {
-//   if (m_window == NULL)
-//     throw torrent::client_error("ui::ElementTransferList::receive_pagenext(...) called on a disabled object");
+  if (m_window == NULL)
+    throw torrent::client_error("ui::ElementTransferList::receive_pagenext(...) called on a disabled object");
 
-//   unsigned int visible = m_window->get_height() - 1;
-//   unsigned int scrollable = std::max<int>(m_window->rows() - visible, 0);
+  unsigned int visible = m_window->height() - 1;
+  unsigned int scrollable = std::max<int>(m_window->rows() - visible, 0);
 
-//   if (scrollable == 0 || m_focus == scrollable)
-//     m_focus = 0;
-//   else if (m_focus + visible / 2 < scrollable)
-//     m_focus += visible / 2;
-//   else 
-//     m_focus = scrollable;
+  if (scrollable == 0 || m_focus == scrollable)
+    m_focus = 0;
+  else if (m_focus + visible / 2 < scrollable)
+    m_focus += visible / 2;
+  else 
+    m_focus = scrollable;
 
 //   m_window->mark_dirty();
 }
 
 void
 ElementTransferList::receive_pageprev() {
-//   if (m_window == NULL)
-//     throw torrent::client_error("ui::ElementTransferList::receive_pageprev(...) called on a disabled object");
+  if (m_window == NULL)
+    throw torrent::client_error("ui::ElementTransferList::receive_pageprev(...) called on a disabled object");
 
-//   unsigned int visible = m_window->get_height() - 1;
-//   unsigned int scrollable = std::max<int>(m_window->rows() - visible, 0);
+  unsigned int visible = m_window->height() - 1;
+  unsigned int scrollable = std::max<int>(m_window->rows() - visible, 0);
 
-//   if (m_focus > visible / 2)
-//     m_focus -= visible / 2;
-//   else if (scrollable > 0 && m_focus == 0)
-//     m_focus = scrollable;
-//   else
-//     m_focus = 0;
+  if (m_focus > visible / 2)
+    m_focus -= visible / 2;
+  else if (scrollable > 0 && m_focus == 0)
+    m_focus = scrollable;
+  else
+    m_focus = 0;
 
 //   m_window->mark_dirty();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_transfer_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_transfer_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/element_transfer_list.h	2006-06-10 05:32:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/element_transfer_list.h	2006-08-06 02:57:23.000000000 +0800
@@ -52,14 +52,16 @@
 class ElementTransferList : public ElementBase {
 public:
   typedef display::WindowDownloadTransferList WTransferList;
 
   ElementTransferList(core::Download* d);
 
-  void                activate(Control* c, MItr mItr);
-  void                disable(Control* c);
+  void                activate(display::Frame* frame, bool focus = true);
+  void                disable();
+
+  display::Window*    window();
 
 private:
 //   void                receive_disable();
   void                receive_next();
   void                receive_prev();
   void                receive_pagenext();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/Makefile.am	2006-06-10 05:45:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/Makefile.am	2006-08-08 22:11:35.000000000 +0800
@@ -11,18 +11,20 @@
 	element_download_list.cc \
 	element_download_list.h \
 	element_file_list.cc \
 	element_file_list.h \
 	element_log_complete.cc \
 	element_log_complete.h \
-	element_peer_info.cc \
-	element_peer_info.h \
+	element_menu.cc \
+	element_menu.h \
 	element_peer_list.cc \
 	element_peer_list.h \
 	element_string_list.cc \
 	element_string_list.h \
+	element_text.cc \
+	element_text.h \
 	element_tracker_list.cc \
 	element_tracker_list.h \
 	element_transfer_list.cc \
 	element_transfer_list.h \
 	root.cc \
 	root.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/Makefile.in	2006-07-09 04:12:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/Makefile.in	2006-08-14 00:24:21.000000000 +0800
@@ -55,15 +55,16 @@
 ARFLAGS = cru
 libsub_ui_a_AR = $(AR) $(ARFLAGS)
 libsub_ui_a_LIBADD =
 am_libsub_ui_a_OBJECTS = download.$(OBJEXT) download_list.$(OBJEXT) \
 	element_chunks_seen.$(OBJEXT) element_download_list.$(OBJEXT) \
 	element_file_list.$(OBJEXT) element_log_complete.$(OBJEXT) \
-	element_peer_info.$(OBJEXT) element_peer_list.$(OBJEXT) \
-	element_string_list.$(OBJEXT) element_tracker_list.$(OBJEXT) \
-	element_transfer_list.$(OBJEXT) root.$(OBJEXT)
+	element_menu.$(OBJEXT) element_peer_list.$(OBJEXT) \
+	element_string_list.$(OBJEXT) element_text.$(OBJEXT) \
+	element_tracker_list.$(OBJEXT) element_transfer_list.$(OBJEXT) \
+	root.$(OBJEXT)
 libsub_ui_a_OBJECTS = $(am_libsub_ui_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -200,18 +201,20 @@
 	element_download_list.cc \
 	element_download_list.h \
 	element_file_list.cc \
 	element_file_list.h \
 	element_log_complete.cc \
 	element_log_complete.h \
-	element_peer_info.cc \
-	element_peer_info.h \
+	element_menu.cc \
+	element_menu.h \
 	element_peer_list.cc \
 	element_peer_list.h \
 	element_string_list.cc \
 	element_string_list.h \
+	element_text.cc \
+	element_text.h \
 	element_tracker_list.cc \
 	element_tracker_list.h \
 	element_transfer_list.cc \
 	element_transfer_list.h \
 	root.cc \
 	root.h
@@ -267,15 +270,16 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_chunks_seen.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_download_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_file_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_log_complete.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_peer_info.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_menu.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_peer_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_string_list.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_text.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_tracker_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_transfer_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/root.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/root.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/root.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/root.cc	2006-07-05 17:59:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/root.cc	2006-08-05 06:00:37.000000000 +0800
@@ -38,57 +38,84 @@
 
 #include <stdexcept>
 #include <string.h>
 #include <sigc++/bind.h>
 #include <torrent/torrent.h>
 
+#include "core/manager.h"
+#include "display/frame.h"
+#include "display/window_http_queue.h"
+#include "display/window_title.h"
+#include "display/window_input.h"
 #include "display/window_statusbar.h"
 #include "input/manager.h"
+#include "input/text_input.h"
 #include "utils/variable_map.h"
 
 #include "control.h"
 #include "download_list.h"
 
 #include "root.h"
 
 namespace ui {
 
 Root::Root() :
   m_control(NULL),
   m_downloadList(NULL),
+  m_windowTitle(NULL),
+  m_windowHttpQueue(NULL),
+  m_windowInput(NULL),
   m_windowStatusbar(NULL) {
 }
 
 void
 Root::init(Control* c) {
   if (m_control != NULL)
     throw std::logic_error("Root::init() called twice on the same object");
 
   m_control = c;
-  setup_keys();
 
-  m_windowStatusbar = new WStatusbar(m_control);
-  m_downloadList =    new DownloadList(m_control);
+  m_windowTitle     = new WTitle();
+  m_windowHttpQueue = new WHttpQueue(control->core()->http_queue());
+  m_windowInput     = new WInput();
+  m_windowStatusbar = new WStatusbar();
+
+  m_downloadList    = new DownloadList();
+
+  display::Frame* rootFrame = m_control->display()->root_frame();
+
+  rootFrame->initialize_row(5);
+  rootFrame->frame(0)->initialize_window(m_windowTitle);
+  rootFrame->frame(2)->initialize_window(m_windowHttpQueue);
+  rootFrame->frame(3)->initialize_window(m_windowInput);
+  rootFrame->frame(4)->initialize_window(m_windowStatusbar);
+
+  m_windowTitle->set_active(true);
+  m_windowStatusbar->set_active(true);
+  m_windowStatusbar->set_bottom(true);
 
-  m_control->display()->push_back(m_windowStatusbar);
+  setup_keys();
 
-  m_downloadList->activate();
-  //  m_downloadList->slot_open_uri(sigc::mem_fun(m_control->get_core(), &core::Manager::insert));
+  m_downloadList->activate(rootFrame->frame(1));
 }
 
 void
 Root::cleanup() {
   if (m_control == NULL)
     throw std::logic_error("Root::cleanup() called twice on the same object");
 
   if (m_downloadList->is_active())
     m_downloadList->disable();
 
-  m_control->display()->erase(m_windowStatusbar);
+  m_control->display()->root_frame()->clear();
 
   delete m_downloadList;
+
+  delete m_windowTitle;
+  delete m_windowHttpQueue;
+  delete m_windowInput;
   delete m_windowStatusbar;
 
   m_control->input()->erase(&m_bindings);
   m_control = NULL;
 }
 
@@ -155,7 +182,50 @@
 
 void
 Root::adjust_up_throttle(int throttle) {
   set_up_throttle(std::max<int>(torrent::up_throttle() / 1024 + throttle, 0));
 }
 
+void
+Root::enable_input(const std::string& title, input::TextInput* input) {
+  if (m_windowInput->input() != NULL)
+    throw torrent::client_error("Root::enable_input(...) m_windowInput->input() != NULL.");
+
+  input->slot_dirty(sigc::mem_fun(m_windowInput, &WInput::mark_dirty));
+
+  m_windowStatusbar->set_active(false);
+
+  m_windowInput->set_active(true);
+  m_windowInput->set_input(input);
+  m_windowInput->set_title(title);
+  m_windowInput->set_focus(true);
+
+  input->bindings()['\x0C'] = sigc::mem_fun(m_control->display(), &display::Manager::force_redraw); // ^L
+  input->bindings()['\x11'] = sigc::mem_fun(m_control, &Control::receive_normal_shutdown); // ^Q
+
+  control->input()->set_text_input(input);
+  control->display()->adjust_layout();
+}
+
+void
+Root::disable_input() {
+  if (m_windowInput->input() == NULL)
+    throw torrent::client_error("Root::disable_input() m_windowInput->input() == NULL.");
+
+  m_windowInput->input()->slot_dirty(sigc::slot0<void>());
+
+  m_windowStatusbar->set_active(true);
+
+  m_windowInput->set_active(false);
+  m_windowInput->set_focus(false);
+  m_windowInput->set_input(NULL);
+
+  control->input()->set_text_input(NULL);
+  control->display()->adjust_layout();
+}
+
+input::TextInput*
+Root::current_input() {
+  return m_windowInput->input();
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/root.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/root.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/ui/root.h	2006-05-27 07:20:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/ui/root.h	2006-07-28 00:39:44.000000000 +0800
@@ -40,46 +40,67 @@
 #include <inttypes.h>
 #include "input/bindings.h"
 
 class Control;
 
 namespace display {
+  class Frame;
+  class WindowTitle;
+  class WindowHttpQueue;
+  class WindowInput;
   class WindowStatusbar;
 }
 
+namespace input {
+  class TextInput;
+}
+
 namespace ui {
 
 class DownloadList;
 
 class Root {
 public:
+  typedef display::WindowTitle     WTitle;
+  typedef display::WindowHttpQueue WHttpQueue;
+  typedef display::WindowInput     WInput;
   typedef display::WindowStatusbar WStatusbar;
 
   Root();
 
   void                init(Control* c);
   void                cleanup();
 
-  WStatusbar*         window_statusbar()            { return m_windowStatusbar; }
+  WTitle*             window_title()                          { return m_windowTitle; }
+  WStatusbar*         window_statusbar()                      { return m_windowStatusbar; }
+  WInput*             window_input()                          { return m_windowInput; }
 
   void                set_down_throttle(unsigned int throttle);
   void                set_up_throttle(unsigned int throttle);
 
   // Rename to raw or something, make base function.
   void                set_down_throttle_i64(int64_t throttle) { set_down_throttle(throttle >> 10); }
   void                set_up_throttle_i64(int64_t throttle)   { set_up_throttle(throttle >> 10); }
 
   void                adjust_down_throttle(int throttle);
   void                adjust_up_throttle(int throttle);
 
+  void                enable_input(const std::string& title, input::TextInput* input);
+  void                disable_input();
+
+  input::TextInput*   current_input();
+
 private:
   void                setup_keys();
 
   Control*            m_control;
   DownloadList*       m_downloadList;
 
+  WTitle*             m_windowTitle;
+  WHttpQueue*         m_windowHttpQueue;
+  WInput*             m_windowInput;
   WStatusbar*         m_windowStatusbar;
 
   input::Bindings     m_bindings;
 };
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable.cc	2006-05-27 07:20:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable.cc	2006-08-14 06:54:05.000000000 +0800
@@ -44,17 +44,22 @@
 
 const torrent::Object Variable::m_emptyObject;
 
 const char*
 Variable::string_to_value_unit(const char* pos, value_type* value, int base, int unit) {
   char* last;
-
   *value = strtoll(pos, &last, base);
 
-  if (last == pos)
+  if (last == pos) {
+    if (strcasecmp(pos, "no") == 0) { *value = 0; return pos + strlen("no"); }
+    if (strcasecmp(pos, "yes") == 0) { *value = 1; return pos + strlen("yes"); }
+    if (strcasecmp(pos, "true") == 0) { *value = 1; return pos + strlen("true"); }
+    if (strcasecmp(pos, "false") == 0) { *value = 0; return pos + strlen("false"); }
+
     throw torrent::input_error("Could not convert string to value.");
+  }
 
   switch (*last) {
   case 'b':
   case 'B':
     ++last;
     break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable_generic.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable_generic.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable_generic.cc	2006-05-27 07:20:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable_generic.cc	2006-08-09 04:04:05.000000000 +0800
@@ -159,24 +159,33 @@
 VariableVoidSlot::get() {
   return m_cache;
 }
 
 void
 VariableVoidSlot::set(const torrent::Object& arg) {
+  if (!m_slotSet.is_valid())
+    return;
+
   m_slotSet();
 }
 
 const torrent::Object&
 VariableValueSlot::get() {
+  if (!m_slotGet.is_valid())
+    return m_cache;
+
   m_cache = m_slotGet() / m_unit;
 
   return m_cache;
 }
 
 void
 VariableValueSlot::set(const torrent::Object& arg) {
+  if (!m_slotSet.is_valid())
+    return;
+
   value_type value;
 
   switch (arg.type()) {
   case torrent::Object::TYPE_STRING:
     string_to_value_unit(arg.as_string().c_str(), &value, m_base, m_unit);
 
@@ -193,19 +202,25 @@
     throw torrent::input_error("Not a value");
   }
 }
 
 const torrent::Object&
 VariableStringSlot::get() {
+  if (!m_slotGet.is_valid())
+    return m_cache;
+
   m_cache = m_slotGet();
 
   return m_cache;
 }
 
 void
 VariableStringSlot::set(const torrent::Object& arg) {
+  if (!m_slotSet.is_valid())
+    return;
+
   switch (arg.type()) {
   case torrent::Object::TYPE_STRING:
     m_slotSet(arg.as_string());
     break;
   case torrent::Object::TYPE_NONE:
     m_slotSet(std::string());
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable_generic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable_generic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable_generic.h	2006-05-27 07:20:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable_generic.h	2006-08-09 04:07:29.000000000 +0800
@@ -164,12 +164,18 @@
   template <typename SlotGet, typename SlotSet>
   VariableStringSlot(SlotGet* slotGet, SlotSet* slotSet) {
     m_slotGet.set(rak::convert_fn<string_type>(slotGet));
     m_slotSet.set(rak::convert_fn<void, const string_type&>(slotSet));
   }
 
+  template <typename SlotGet>
+  VariableStringSlot(SlotGet* slotGet, void* slotSet) {
+    m_slotGet.set(rak::convert_fn<string_type>(slotGet));
+    m_slotSet.set(NULL);
+  }
+
   virtual const torrent::Object& get();
   virtual void                   set(const torrent::Object& arg);
 
 private:
   slot_get_type       m_slotGet;
   slot_set_type       m_slotSet;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.0/src/utils/variable_map.cc	2006-05-27 07:20:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.6.1/src/utils/variable_map.cc	2006-08-03 06:21:54.000000000 +0800
@@ -48,13 +48,13 @@
 #include "variable.h"
 #include "variable_map.h"
 
 namespace utils {
 
 VariableMap::~VariableMap() {
-  std::for_each(base_type::begin(), base_type::end(), rak::on(rak::mem_ptr_ref(&value_type::second), rak::call_delete<Variable>()));
+  std::for_each(base_type::begin(), base_type::end(), rak::on(rak::mem_ref(&value_type::second), rak::call_delete<Variable>()));
 }
 
 void
 VariableMap::insert(const std::string& key, Variable* v) {
   iterator itr = base_type::find(key);
 
@@ -105,15 +105,13 @@
 
 std::string::const_iterator
 parse_unknown(std::string::const_iterator first, std::string::const_iterator last, VariableMap::mapped_type* dest) {
   if (*first == '"') {
     std::string::const_iterator next = std::find_if(++first, last, std::bind2nd(std::equal_to<char>(), '"'));
     
-    if (first == last ||
-	first == next ||
-	next == last)
+    if (first == last || first == next || next == last)
       throw torrent::input_error("Could not find closing '\"'.");
 
     *dest = std::string(first, next);
     return ++next;
 
   } else {
