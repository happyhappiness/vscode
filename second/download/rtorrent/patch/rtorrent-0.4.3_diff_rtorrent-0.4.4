diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/config.h.in	2006-01-18 01:27:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/config.h.in	2006-01-26 01:58:47.000000000 +0800
@@ -1,11 +1,14 @@
 /* config.h.in.  Generated from configure.ac by autoheader.  */
 
 /* true if config.h was included */
 #undef HAVE_CONFIG_H
 
+/* defined if ncurses wide character support is available */
+#undef HAVE_NCURSESW
+
 /* Name of package */
 #undef PACKAGE
 
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/configure	2006-01-18 01:25:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/configure	2006-02-01 18:48:01.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.4.3.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.4.4.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -266,14 +266,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.4.3'
-PACKAGE_STRING='rtorrent 0.4.3'
+PACKAGE_VERSION='0.4.4'
+PACKAGE_STRING='rtorrent 0.4.4'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CXX CXXFLAGS LDFLAGS CPPFLAGS ac_ct_CXX EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE RANLIB ac_ct_RANLIB CC CFLAGS ac_ct_CC CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE PKG_CONFIG STUFF_CFLAGS STUFF_LIBS LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -743,13 +743,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.4.3 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.4.4 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -805,13 +805,13 @@
   --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.4.3:";;
+     short | recursive ) echo "Configuration of rtorrent 0.4.4:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -933,13 +933,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.4.3
+rtorrent configure 0.4.4
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -947,13 +947,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.4.3, which was
+It was created by rtorrent $as_me 0.4.4, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1591,13 +1591,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.4.3'
+ VERSION='0.4.4'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -3849,13 +3849,143 @@
 
 fi
 rm -f conftest*
 fi
 
 
-echo "$as_me:$LINENO: checking for library containing wbkgdset" >&5
+
+echo "$as_me:$LINENO: checking for library containing add_wch" >&5
+echo $ECHO_N "checking for library containing add_wch... $ECHO_C" >&6
+if test "${ac_cv_search_add_wch+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_add_wch=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char add_wch ();
+int
+main ()
+{
+add_wch ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_add_wch="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_add_wch" = no; then
+  for ac_lib in ncursesw; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char add_wch ();
+int
+main ()
+{
+add_wch ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_add_wch="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_add_wch" >&5
+echo "${ECHO_T}$ac_cv_search_add_wch" >&6
+if test "$ac_cv_search_add_wch" != no; then
+  test "$ac_cv_search_add_wch" = "none required" || LIBS="$ac_cv_search_add_wch $LIBS"
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_NCURSESW 1
+_ACEOF
+
+else
+  echo "$as_me:$LINENO: checking for library containing wbkgdset" >&5
 echo $ECHO_N "checking for library containing wbkgdset... $ECHO_C" >&6
 if test "${ac_cv_search_wbkgdset+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_wbkgdset=no
@@ -3978,12 +4108,15 @@
 
 else
   echo "*** The ncurses library is required!";exit 1
 fi
 
 
+fi
+
+
 
   echo "$as_me:$LINENO: checking for execinfo.h" >&5
 echo $ECHO_N "checking for execinfo.h... $ECHO_C" >&6
 
   cat >conftest.$ac_ext <<_ACEOF
 #include <execinfo.h>
@@ -4652,13 +4785,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.4.3, which was
+This file was extended by rtorrent $as_me 0.4.4, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -4715,13 +4848,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.4.3
+rtorrent config.status 0.4.4
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/configure.ac	2006-01-18 01:23:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/configure.ac	2006-01-25 03:53:02.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.4.3, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.4.4, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 sinclude(scripts/checks.m4)
 sinclude(scripts/common.m4)
@@ -12,13 +12,17 @@
 TORRENT_ENABLE_WERROR()
 
 AC_PROG_CXX
 AC_PROG_RANLIB
 AC_SYS_LARGEFILE
 
-AC_SEARCH_LIBS(wbkgdset, ncurses curses,,echo "*** The ncurses library is required!";exit 1)
+
+AC_SEARCH_LIBS(add_wch, ncursesw,
+  AC_DEFINE(HAVE_NCURSESW, 1, defined if ncurses wide character support is available),
+  AC_SEARCH_LIBS(wbkgdset, ncurses curses,,echo "*** The ncurses library is required!";exit 1)
+)
 
 TORRENT_CHECK_EXECINFO()
 TORRENT_CHECK_CURL()
 TORRENT_OTFD()
 
 TORRENT_WITHOUT_VARIABLE_FDSET()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/doc/rtorrent.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/doc/rtorrent.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/doc/rtorrent.1	2006-01-09 23:34:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/doc/rtorrent.1	2006-02-05 03:22:45.000000000 +0800
@@ -1,12 +1,12 @@
 .\" This manpage has been automatically generated by docbook2man 
 .\" from a DocBook document.  This tool can be found at:
 .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
 .\" Please send any bug reports, improvements, comments, patches, 
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
-.TH "RTORRENT" "1" "09 January 2006" "BitTorrent client for ncurses" ""
+.TH "RTORRENT" "1" "04 February 2006" "BitTorrent client for ncurses" ""
 
 .SH NAME
 rtorrent \- a BitTorrent client for ncurses
 .SH SYNOPSIS
 
 \fBrtorrent\fR [ \fB-h\fR ] [ \fB-o key1=opt1,...\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
@@ -54,19 +54,29 @@
 \fB^d\fR
 Stop an active download, or remove a stopped download.
 .TP
 \fB^r\fR
 Initiate hash check of torrent.
 .TP
+\fB^O\fR
+Change the destination directory of the download. The
+torrent must be closed.
+.TP
+\fB+ | -\fR
+Change the priority of the download.
+.TP
 \fBbackspace\fR
 Add torrent using an URL or file path. Use
 \fBtab\fR to view directory content and do
 auto-complete.
 .TP
 \fBl\fR
 View log. Exit by pressing the space-bar.
+.TP
+\fB^P\fR
+Call commands or change settings.
 .SS "DOWNLOAD VIEW KEYS"
 .TP
 \fB->\fR
 View torrent file list. Use the space-bar to change the
 file priority and \fB*\fR to change the
 priority of all files.
@@ -179,12 +189,16 @@
 \fBschedule = \fIid\fB,\fIstart\fB,\fIinterval\fB,\fIcommand\fB\fR
 Call \fBcommand\fR every \fBinterval\fR
 seconds, starting from \fBstart\fR\&. An
 \fBinterval\fR of zero calls the task once, while a
 \fBstart\fR of zero calls it immediately. Currently
 \fBcommand\fR is forwarded to the option handler.
+\fBstart\fR and \fBinterval\fR may
+optionally use a time format, \fBdd:hh:mm:ss\fR\&. F.ex to
+start a task every day at \fB18:00\fR, use
+\fB18:00:00\fR\&.
 .TP
 \fBschedule_remove = \fIid\fB\fR
 Delete \fBid\fR from the scheduler.
 .TP
 \fBload = \fIfile\fB\fR
 .TP
@@ -195,15 +209,14 @@
 \fBstart\fR is non-zero. The loaded file will be tied
 to the filename provided.
 .TP
 \fBstop_untied =\fR
 .TP
 \fBremove_untied =\fR
-Stop or remove the torrents that are tied to filenames that has been
-deleted, the association is then cleared. Don't use
-\fBremove_untied\fR as it crashes the client.
+Stop or remove the torrents that are tied to filenames that have been
+deleted, the association is then cleared.
 .SH "ADVANCED SETTINGS"
 .PP
 This list contains settings users shouldn't need to touch.
 .TP
 \fBhash_read_ahead = \fIMB\fB\fR
 Configure how far ahead we ask the kernel to read when doing
@@ -230,10 +243,21 @@
 at startup. This gives the client 128 sockets to use as it
 wishes.
 .TP
 \fBumask = \fI0644\fB\fR
 Set the umask for this process, which is applied to all
 files created by the program.
+.TP
+\fBworking_directory = \fIdirectory\fB\fR
+Changes the working directory of the process using
+\fBchdir\fR\&.
+.TP
+\fBsession_on_completion = \fIyes\fB\fR
+Controls whetever the session torrent is updated when a torrent
+finishes. By default on.
+.TP
+\fBsession_lock = \fIyes\fB\fR
+Controls whetever a lock file is created in the session directory.
 .SH "AUTHORS"
 .PP
 
 Jari "Rakshasa" Sundell <jaris@ifi.uio.no>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/doc/rtorrent.1.xml	2006-01-07 05:07:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/doc/rtorrent.1.xml	2006-02-05 01:36:03.000000000 +0800
@@ -137,12 +137,27 @@
 	  <listitem><para>
             Initiate hash check of torrent.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
+	  <term>^O</term>
+	  <listitem><para>
+            Change the destination directory of the download. The
+            torrent must be closed.
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
+	  <term>+ | -</term>
+	  <listitem><para>
+            Change the priority of the download.
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
 	  <term>backspace</term>
 	  <listitem><para>
             Add torrent using an URL or file path. Use
             <emphasis>tab</emphasis> to view directory content and do
             auto-complete.
           </para></listitem>
@@ -152,12 +167,19 @@
 	  <term>l</term>
 	  <listitem><para>
             View log. Exit by pressing the space-bar.
           </para></listitem>
 	</varlistentry>
 
+	<varlistentry>
+	  <term>^P</term>
+	  <listitem><para>
+            Call commands or change settings.
+          </para></listitem>
+	</varlistentry>
+
       </variablelist>
 
     </refsect2>
 
     <refsect2>
       <title>Download View Keys</title>
@@ -421,12 +443,17 @@
 Call <emphasis>command</emphasis> every <emphasis>interval</emphasis>
 seconds, starting from <emphasis>start</emphasis>. An
 <emphasis>interval</emphasis> of zero calls the task once, while a
 <emphasis>start</emphasis> of zero calls it immediately. Currently
 <emphasis>command</emphasis> is forwarded to the option handler.
 
+<emphasis>start</emphasis> and <emphasis>interval</emphasis> may
+optionally use a time format, <emphasis>dd:hh:mm:ss</emphasis>. F.ex to
+start a task every day at <emphasis>18:00</emphasis>, use
+<emphasis>18:00:00</emphasis>.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>schedule_remove = <replaceable>id</replaceable></term>
         <listitem><para>
@@ -452,15 +479,14 @@
 
       <varlistentry>
         <term>stop_untied =</term>
         <term>remove_untied =</term>
         <listitem><para>
 
-Stop or remove the torrents that are tied to filenames that has been
-deleted, the association is then cleared. Don't use
-<emphasis>remove_untied</emphasis> as it crashes the client.
+Stop or remove the torrents that are tied to filenames that have been
+deleted, the association is then cleared.
 
         </para></listitem>
       </varlistentry>
 
     </variablelist>
 
@@ -527,29 +553,40 @@
           Set the umask for this process, which is applied to all
           files created by the program.
 
         </para></listitem>
       </varlistentry>
 
-<!--       <varlistentry> -->
-<!--         <term>throttle_interval = <replaceable>ms</replaceable></term> -->
-<!--         <listitem><para> -->
-<!--           Interval between throttle ticks in milli-seconds, must be -->
-<!--           between <emphasis>1-5000</emphasis> and defaults to -->
-<!--           <emphasis>1000</emphasis>. Shorter intervals will cause less -->
-<!--           bandwidth usage spikes while requiring more CPU resources. -->
-<!--         </para></listitem> -->
-<!--       </varlistentry> -->
-
-<!--       <varlistentry> -->
-<!--         <term>tracker_dump = <replaceable>yes | no</replaceable></term> -->
-<!--         <listitem><para> -->
-<!--           Dump data received from trackers to the files -->
-<!--           "./tracker_dump.*". -->
-<!--         </para></listitem> -->
-<!--       </varlistentry> -->
+      <varlistentry>
+        <term>working_directory = <replaceable>directory</replaceable></term>
+        <listitem><para>
+
+Changes the working directory of the process using
+<emphasis>chdir</emphasis>.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>session_on_completion = <replaceable>yes</replaceable></term>
+        <listitem><para>
+
+Controls whetever the session torrent is updated when a torrent
+finishes. By default on.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>session_lock = <replaceable>yes</replaceable></term>
+        <listitem><para>
+
+Controls whetever a lock file is created in the session directory.
+
+        </para></listitem>
+      </varlistentry>
 
     </variablelist>
 
   </refsect1>
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/rak/functional_fun.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/rak/functional_fun.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/rak/functional_fun.h	2006-01-12 13:07:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/rak/functional_fun.h	2006-01-28 03:17:50.000000000 +0800
@@ -177,12 +177,41 @@
 private:
   Object*    m_object;
   Func       m_func;
   const Arg1 m_arg1;
 };
 
+template <typename Result, typename Arg1>
+class ptr_fn1_t : public function_base1<Result, Arg1> {
+public:
+  typedef Result (*Func)(Arg1);
+
+  ptr_fn1_t(Func func) : m_func(func) {}
+  virtual ~ptr_fn1_t() {}
+  
+  virtual Result operator () (Arg1 arg1) { return m_func(arg1); }
+
+private:
+  Func    m_func;
+};
+
+template <typename Result, typename Arg1>
+class ptr_fn0_b1_t : public function_base0<Result> {
+public:
+  typedef Result (*Func)(Arg1);
+
+  ptr_fn0_b1_t(Func func, const Arg1 arg1) : m_func(func), m_arg1(arg1) {}
+  virtual ~ptr_fn0_b1_t() {}
+  
+  virtual Result operator () () { return m_func(m_arg1); }
+
+private:
+  Func    m_func;
+  Arg1    m_arg1;
+};
+
 template <typename Result, typename Arg1, typename Arg2>
 class ptr_fn1_b1_t : public function_base1<Result, Arg2> {
 public:
   typedef Result (*Func)(Arg1, Arg2);
 
   ptr_fn1_b1_t(Func func, const Arg1 arg1) : m_func(func), m_arg1(arg1) {}
@@ -192,43 +221,55 @@
 
 private:
   Func    m_func;
   Arg1    m_arg1;
 };
 
-template <typename Object, typename Result>
+template <typename Result, typename Object>
 function_base0<Result>*
 mem_fn(Object* object, Result (Object::*func)()) {
   return new mem_fn0_t<Object, Result>(object, func);
 }
 
-template <typename Object, typename Result, typename Arg1>
+template <typename Arg1, typename Result, typename Object>
 function_base1<Result, Arg1>*
 mem_fn(Object* object, Result (Object::*func)(Arg1)) {
   return new mem_fn1_t<Object, Result, Arg1>(object, func);
 }
 
-template <typename Object, typename Result>
+template <typename Result, typename Object>
 function_base0<Result>*
 mem_fn(const Object* object, Result (Object::*func)() const) {
   return new const_mem_fn0_t<Object, Result>(object, func);
 }
 
-template <typename Object, typename Result, typename Arg1>
+template <typename Arg1, typename Result, typename Object>
 function_base1<Result, Arg1>*
 mem_fn(const Object* object, Result (Object::*func)(Arg1) const) {
   return new const_mem_fn1_t<Object, Result, Arg1>(object, func);
 }
 
-template <typename Object, typename Result, typename Arg1>
+template <typename Arg1, typename Result, typename Object>
 function_base0<Result>*
 bind_mem_fn(Object* object, Result (Object::*func)(Arg1), const Arg1 arg1) {
   return new mem_fn0_b1_t<Object, Result, Arg1>(object, func, arg1);
 }
 
-template <typename Result, typename Arg1, typename Arg2>
+template <typename Arg1, typename Result>
+function_base1<Result, Arg1>*
+ptr_fn(Result (*func)(Arg1)) {
+  return new ptr_fn1_t<Result, Arg1>(func);
+}
+
+template <typename Arg1, typename Result>
+function_base0<Result>*
+bind_ptr_fn(Result (*func)(Arg1), const Arg1 arg1) {
+  return new ptr_fn0_b1_t<Result, Arg1>(func, arg1);
+}
+
+template <typename Arg1, typename Arg2, typename Result>
 function_base1<Result, Arg2>*
 bind_ptr_fn(Result (*func)(Arg1, Arg2), const Arg1 arg1) {
   return new ptr_fn1_b1_t<Result, Arg1, Arg2>(func, arg1);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/rak/functional.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/rak/functional.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/rak/functional.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/rak/functional.h	2006-01-19 03:53:38.000000000 +0800
@@ -318,27 +318,28 @@
   return bind1st_t<Operation>(op, val);
 }
 
 template <typename Operation>
 class bind2nd_t : public std::unary_function<typename Operation::first_argument_type,
 					     typename Operation::result_type> {
-protected:
+public:
   typedef typename reference_fix<typename Operation::first_argument_type>::type argument_type;
   typedef typename reference_fix<typename Operation::second_argument_type>::type value_type;
 
-  Operation  m_op;
-  value_type m_value;
-
-public:
   bind2nd_t(const Operation& op, const value_type v) :
     m_op(op), m_value(v) {}
 
   typename Operation::result_type
   operator () (const argument_type arg) {
     return m_op(arg, m_value);
   }
+
+protected:
+  Operation  m_op;
+  value_type m_value;
+
 };	    
 
 template <typename Operation, typename Type>
 inline bind2nd_t<Operation>
 bind2nd(const Operation& op, const Type& val) {
   return bind2nd_t<Operation>(op, val);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/rak/timer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/rak/timer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/rak/timer.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/rak/timer.h	2006-01-26 03:58:37.000000000 +0800
@@ -64,12 +64,14 @@
   bool                operator >= (const timer& t) const { return m_time >= t.m_time; }
   bool                operator == (const timer& t) const { return m_time == t.m_time; }
   bool                operator != (const timer& t) const { return m_time != t.m_time; }
 
   timer               operator - (const timer& t) const  { return timer(m_time - t.m_time); }
   timer               operator + (const timer& t) const  { return timer(m_time + t.m_time); }
+  timer               operator * (int64_t t) const       { return timer(m_time * t); }
+  timer               operator / (int64_t t) const       { return timer(m_time / t); }
 
   timer               operator -= (int64_t t)            { m_time -= t; return *this; }
   timer               operator -= (const timer& t)       { m_time -= t.m_time; return *this; }
 
   timer               operator += (int64_t t)            { m_time += t; return *this; }
   timer               operator += (const timer& t)       { m_time += t.m_time; return *this; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler.cc	2006-02-05 03:43:28.000000000 +0800
@@ -34,13 +34,16 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <algorithm>
+#include <cstdlib>
+#include <time.h>
 #include <rak/functional.h>
+#include <rak/string_manip.h>
 #include <torrent/exceptions.h>
 
 #include "command_scheduler.h"
 #include "command_scheduler_item.h"
 
 CommandScheduler::~CommandScheduler() {
@@ -95,12 +98,114 @@
 
   } catch (torrent::input_error& e) {
     if (m_slotErrorMessage.is_valid())
       m_slotErrorMessage("Scheduled command failed: " + item->key() + ": " + e.what());
   }
 
-  uint32_t interval = item->interval();
+  // Still schedule if we caught a torrrent::input_error?
+  rak::timer next = item->next_time_scheduled();
 
-  // Enable if we caught a torrrent::input_error?
-  if (interval != 0)
-    item->enable(interval);
+  if (next == rak::timer()) {
+    // Remove from scheduler?
+    return;
+  }
+
+  if (next <= cachedTime)
+    throw torrent::internal_error("CommandScheduler::call_item(...) tried to schedule a zero interval item.");
+
+  item->enable(next);
+}
+
+void
+CommandScheduler::parse(const std::string& arg) {
+  char key[21];
+  char bufAbsolute[21];
+  char bufInterval[21];
+  char command[2048];
+
+  if (std::sscanf(arg.c_str(), "%20[^,],%20[^,],%20[^,],%2047[^\n]", key, bufAbsolute, bufInterval, command) != 4)
+    throw torrent::input_error("Invalid arguments to command.");
+
+  uint32_t absolute = parse_absolute(bufAbsolute);
+  uint32_t interval = parse_interval(bufInterval);
+
+  CommandSchedulerItem* item = *insert(rak::trim(std::string(key)));
+
+  item->set_command(rak::trim(std::string(command)));
+  item->set_interval(interval);
+
+  item->enable((cachedTime + rak::timer(absolute) * 1000000).round_seconds());
+}
+
+uint32_t
+CommandScheduler::parse_absolute(const char* str) {
+  Time result = parse_time(str);
+  time_t t;
+
+  // Do the local time thing.
+  struct tm local;
+
+  switch (result.first) {
+  case 1:
+    return result.second;
+
+  case 2:
+    t = cachedTime.tval().tv_sec;
+
+    if (localtime_r(&t, &local) == NULL)
+      throw torrent::input_error("Could not convert unix time to local time.");
+
+    return (result.second + 3600 - 60 * local.tm_min - local.tm_sec) % 3600;
+
+  case 3:
+    t = cachedTime.tval().tv_sec;
+
+    if (localtime_r(&t, &local) == NULL)
+      throw torrent::input_error("Could not convert unix time to local time.");
+
+    return (result.second + 24 * 3600 - 3600 * local.tm_hour - 60 * local.tm_min - local.tm_sec) % (24 * 3600);
+
+  case 0:
+  default:
+    throw torrent::input_error("Could not parse interval.");
+  }
+}
+
+uint32_t
+CommandScheduler::parse_interval(const char* str) {
+  Time result = parse_time(str);
+
+  if (result.first == 0)
+    throw torrent::input_error("Could not parse interval.");
+  
+  return result.second;
+}
+
+CommandScheduler::Time
+CommandScheduler::parse_time(const char* str) {
+  Time result(0, 0);
+
+  while (true) {
+    char* pos;
+    result.first++;
+    result.second += strtol(str, &pos, 10);
+
+    if (pos == str || result.second < 0)
+      return Time(0, 0);
+
+    while (std::isspace(*pos))
+      ++pos;
+
+    if (*pos == '\0')
+      return result;
+
+    if (*pos != ':' || result.first > 3)
+      return Time(0, 0);
+
+    if (result.first < 3)
+      result.second *= 60;
+    else
+      result.second *= 24;
+
+    str = pos + 1;
+  }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler.h	2006-01-29 09:34:37.000000000 +0800
@@ -43,12 +43,13 @@
 
 class CommandSchedulerItem;
 
 class CommandScheduler : public std::vector<CommandSchedulerItem*> {
 public:
   typedef rak::function1<void, const std::string&> SlotString;
+  typedef std::pair<int, int>                      Time;
   typedef std::vector<CommandSchedulerItem*>       base_type;
 
   using base_type::value_type;
   using base_type::begin;
   using base_type::end;
 
@@ -63,12 +64,20 @@
   iterator            find(const std::string& key);
 
   // If the key already exists then the old item is deleted. It is
   // safe to call erase on end().
   iterator            insert(const std::string& key);
   void                erase(iterator itr);
+  void                erase(const std::string& key)                    { erase(find(key)); }
+
+  void                parse(const std::string& arg);
+
+  static uint32_t     parse_absolute(const char* str);
+  static uint32_t     parse_interval(const char* str);
+
+  static Time         parse_time(const char* str);
 
 private:
   void                call_item(value_type item);
 
   SlotString          m_slotCommand;
   SlotString          m_slotErrorMessage;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler_item.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler_item.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler_item.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler_item.cc	2006-01-26 03:54:56.000000000 +0800
@@ -33,27 +33,52 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <torrent/exceptions.h>
+
 #include "command_scheduler_item.h"
 
 CommandSchedulerItem::~CommandSchedulerItem() {
   priority_queue_erase(&taskScheduler, &m_task);
 }
 
 void
-CommandSchedulerItem::enable(uint32_t first) {
+CommandSchedulerItem::enable(rak::timer t) {
+  if (t == rak::timer())
+    throw torrent::internal_error("CommandSchedulerItem::enable() t == rak::timer().");
+
   if (is_queued())
     disable();
 
   // If 'first' is zero then we execute the task
   // immediately. ''interval()'' will not return zero so we never end
   // up in an infinit loop.
-  priority_queue_insert(&taskScheduler, &m_task, (cachedTime + ((int64_t)first * 1000000)).round_seconds());
+  m_timeScheduled = t;
+  priority_queue_insert(&taskScheduler, &m_task, t);
 }
 
 void
 CommandSchedulerItem::disable() {
+  m_timeScheduled = rak::timer();
   priority_queue_erase(&taskScheduler, &m_task);
 }
+
+rak::timer
+CommandSchedulerItem::next_time_scheduled() const {
+  if (m_interval == 0)
+    return rak::timer();
+
+  if (m_timeScheduled == rak::timer())
+    throw torrent::internal_error("CommandSchedulerItem::next_time_scheduled() m_timeScheduled == rak::timer().");
+
+  rak::timer next = m_timeScheduled;
+
+  // This should be done in a non-looping manner.
+  do {
+    next += rak::timer(m_interval) * 1000000;
+  } while (next <= cachedTime.round_seconds());
+
+  return next;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler_item.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler_item.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/command_scheduler_item.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/command_scheduler_item.h	2006-01-26 02:39:05.000000000 +0800
@@ -45,35 +45,38 @@
 
   CommandSchedulerItem(const std::string& key) : m_key(key), m_interval(0) {}
   ~CommandSchedulerItem();
 
   bool                is_queued() const                       { return m_task.is_queued(); }
 
-  //void                enable()                                { enable(interval()); }
-  void                enable(uint32_t first);
+  void                enable(rak::timer t);
   void                disable();
 
   const std::string&  key() const                             { return m_key; }
 
   const std::string&  command() const                         { return m_command; }
   void                set_command(const std::string& s)       { m_command = s; }
 
   // 'interval()' should in the future return some more dynamic values.
   uint32_t            interval() const                        { return m_interval; }
   void                set_interval(uint32_t v)                { m_interval = v; }
 
+  rak::timer          time_scheduled() const                  { return m_timeScheduled; }
+  rak::timer          next_time_scheduled() const;
+
   void                set_slot(Slot::base_type* s)            { m_task.set_slot(s); }
 
 private:
   CommandSchedulerItem(const CommandSchedulerItem&);
   void operator = (const CommandSchedulerItem&);
 
   std::string         m_key;
   std::string         m_command;
   
   uint32_t            m_interval;
+  rak::timer          m_timeScheduled;
 
   rak::priority_item  m_task;
 
   // Flags for various things.
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/control.cc	2006-01-12 12:29:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/control.cc	2006-02-04 06:59:41.000000000 +0800
@@ -50,12 +50,13 @@
 #include "command_scheduler.h"
 
 #include "control.h"
 
 Control::Control() :
   m_shutdownReceived(false),
+  m_shutdownQuick(false),
 
   m_ui(new ui::Root()),
   m_core(new core::Manager()),
   m_display(new display::Manager()),
   m_input(new input::Manager()),
   m_inputStdin(new input::InputEvent(STDIN_FILENO)),
@@ -64,13 +65,13 @@
   m_variables(new utils::VariableMap()),
 
   m_tick(0) {
 
   m_inputStdin->slot_pressed(sigc::mem_fun(m_input, &input::Manager::pressed));
 
-  m_taskShutdown.set_slot(rak::mem_fn(this, &Control::receive_shutdown));
+  m_taskShutdown.set_slot(rak::mem_fn(this, &Control::handle_shutdown));
 
   m_commandScheduler->set_slot_command(rak::mem_fn(m_variables, &utils::VariableMap::process_command));
   m_commandScheduler->set_slot_error_message(rak::mem_fn(m_core, &core::Manager::push_log));
 }
 
 Control::~Control() {
@@ -89,50 +90,50 @@
 Control::initialize() {
   display::Canvas::initialize();
   display::Window::slot_schedule(rak::make_mem_fun(m_display, &display::Manager::schedule));
   display::Window::slot_unschedule(rak::make_mem_fun(m_display, &display::Manager::unschedule));
   display::Window::slot_adjust(rak::make_mem_fun(m_display, &display::Manager::adjust_layout));
 
-  m_core->get_poll_manager()->signal_interrupted().connect(sigc::mem_fun(*m_inputStdin, &input::InputEvent::event_read));
-  m_core->get_poll_manager()->signal_interrupted().connect(sigc::ptr_fun(display::Canvas::do_update));
   m_core->get_poll_manager()->get_http_stack()->set_user_agent(std::string(PACKAGE "/" VERSION "/") + torrent::version());
 
   m_core->initialize_second();
   m_core->listen_open();
+  m_core->download_store().enable(m_variables->get_string("session_lock") == "yes");
 
   m_ui->init(this);
 
   m_inputStdin->insert(m_core->get_poll_manager()->get_torrent_poll());
 }
 
 void
 Control::cleanup() {
   priority_queue_erase(&taskScheduler, &m_taskShutdown);
 
   m_inputStdin->remove(m_core->get_poll_manager()->get_torrent_poll());
 
+  m_core->download_store().disable();
+
   m_ui->cleanup();
   m_core->cleanup();
   
   display::Canvas::erase_std();
   display::Canvas::refresh_std();
   display::Canvas::do_update();
   display::Canvas::cleanup();
 }
 
-// I think it should be safe to initiate the shutdown from anywhere,
-// but if it isn't, use a delay task.
 void
-Control::receive_shutdown() {
-  if (!m_shutdownReceived) {
+Control::handle_shutdown() {
+  if (!m_shutdownQuick) {
     torrent::listen_close();
-    
     m_core->shutdown(false);
-    m_shutdownReceived = true;
 
     if (!m_taskShutdown.is_queued())
       priority_queue_insert(&taskScheduler, &m_taskShutdown, cachedTime + 5 * 1000000);
 
   } else {
     m_core->shutdown(true);
   }
+
+  m_shutdownQuick = true;
+  m_shutdownReceived = false;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/control.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/control.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/control.h	2006-01-13 14:10:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/control.h	2006-01-31 01:34:09.000000000 +0800
@@ -67,19 +67,22 @@
 
 class Control {
 public:
   Control();
   ~Control();
   
-  bool                is_shutdown_completed()       { return m_shutdownReceived && torrent::is_inactive(); }
+  bool                is_shutdown_completed()       { return m_shutdownQuick && torrent::is_inactive(); }
   bool                is_shutdown_received()        { return m_shutdownReceived; }
 
   void                initialize();
   void                cleanup();
 
-  void                receive_shutdown();
+  void                handle_shutdown();
+
+  void                receive_normal_shutdown()     { m_shutdownReceived = true; }
+  void                receive_quick_shutdown()      { m_shutdownReceived = true; m_shutdownQuick = true; }
 
   ui::Root*           ui()                          { return m_ui; }
   core::Manager*      core()                        { return m_core; }
   display::Manager*   display()                     { return m_display; }
   input::Manager*     input()                       { return m_input; }
   input::InputEvent*  input_stdin()                 { return m_inputStdin; }
@@ -92,12 +95,13 @@
 
 private:
   Control(const Control&);
   void operator = (const Control&);
 
   bool                m_shutdownReceived;
+  bool                m_shutdownQuick;
 
   ui::Root*           m_ui;
   core::Manager*      m_core;
   display::Manager*   m_display;
   input::Manager*     m_input;
   input::InputEvent*  m_inputStdin;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_get.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_get.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_get.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_get.cc	2006-02-04 07:02:57.000000000 +0800
@@ -135,21 +135,24 @@
 void
 CurlGet::set_http_proxy(const char* s) {
   curl_easy_setopt(m_handle, CURLOPT_PROXY, s);
 }
 
 void
+CurlGet::set_bind_address(const char* s) {
+  curl_easy_setopt(m_handle, CURLOPT_INTERFACE, s);
+}
+
+void
 CurlGet::perform(CURLMsg* msg) {
   if (msg->msg != CURLMSG_DONE)
     throw std::logic_error("CurlGet::process got CURLMSG that isn't done");
 
   if (msg->data.result == CURLE_OK)
     m_signalDone.emit();
   else
     m_signalFailed.emit(curl_easy_strerror(msg->data.result));
 
-  if (m_handle != NULL)
-    throw std::logic_error("CurlGet::perform finished but the object wasn't closed.");
-
+  // Do nothing below after emitting the signals.
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_get.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_get.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_get.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_get.h	2006-01-22 06:22:53.000000000 +0800
@@ -65,12 +65,13 @@
 
   double             size_done();
   double             size_total();
 
   void               set_user_agent(const char* s);
   void               set_http_proxy(const char* s);
+  void               set_bind_address(const char* s);
 
  protected:
   CURL*              handle()                       { return m_handle; }
 
   void               perform(CURLMsg* msg);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_stack.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_stack.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_stack.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_stack.cc	2006-01-22 06:23:47.000000000 +0800
@@ -106,12 +106,15 @@
   if (!m_userAgent.empty())
     get->set_user_agent(m_userAgent.c_str());
 
   if (!m_httpProxy.empty())
     get->set_http_proxy(m_httpProxy.c_str());
 
+  if (!m_bindAddress.empty())
+    get->set_bind_address(m_bindAddress.c_str());
+
   CURLMcode code;
 
   if ((code = curl_multi_add_handle((CURLM*)m_handle, get->handle())) > 0)
     throw std::logic_error("curl_multi_add_handle \"" + std::string(curl_multi_strerror(code)));
 
   m_size++;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_stack.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_stack.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/curl_stack.h	2006-01-10 08:32:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/curl_stack.h	2006-01-22 06:21:41.000000000 +0800
@@ -68,12 +68,15 @@
   const std::string&  user_agent() const                   { return m_userAgent; }
   void                set_user_agent(const std::string& s) { m_userAgent = s; }
 
   const std::string&  http_proxy() const                   { return m_httpProxy; }
   void                set_http_proxy(const std::string& s) { m_httpProxy = s; }
 
+  const std::string&  bind_address() const                   { return m_bindAddress; }
+  void                set_bind_address(const std::string& s) { m_bindAddress = s; }
+
   static void         global_init();
   static void         global_cleanup();
 
  protected:
   void                add_get(CurlGet* get);
   void                remove_get(CurlGet* get);
@@ -86,11 +89,12 @@
 
   int                 m_size;
   CurlGetList         m_getList;
 
   std::string         m_userAgent;
   std::string         m_httpProxy;
+  std::string         m_bindAddress;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download.cc	2006-02-04 04:26:03.000000000 +0800
@@ -38,29 +38,53 @@
 
 #include <stdexcept>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 #include <sigc++/signal.h>
 #include <torrent/exceptions.h>
+#include <torrent/torrent.h>
+
+#include "utils/variable_generic.h"
 
 #include "download.h"
 
 namespace core {
 
 Download::Download(torrent::Download d) :
   m_download(d),
 
-  m_chunksFailed(0),
-  m_connectionLeech(torrent::Download::CONNECTION_LEECH),
-  m_connectionSeed(torrent::Download::CONNECTION_SEED) {
+  m_chunksFailed(0) {
 
   m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
   m_connTrackerFailed = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
   m_connStorageError = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
 
   m_download.signal_chunk_failed(sigc::mem_fun(*this, &Download::receive_chunk_failed));
+
+  m_variables.insert("connection_current", new utils::VariableSlotString<const char*, const std::string&>(rak::mem_fn(this, &Download::connection_current),
+													  rak::mem_fn(this, &Download::set_connection_current)));
+  m_variables.insert("connection_leech",   new utils::VariableAny(connection_type_to_string(torrent::Download::CONNECTION_LEECH)));
+  m_variables.insert("connection_seed",    new utils::VariableAny(connection_type_to_string(torrent::Download::CONNECTION_SEED)));
+  m_variables.insert("state",              new utils::VariableBencode(&m_download.bencode(), "rtorrent", "state", torrent::Bencode::TYPE_STRING));
+  m_variables.insert("tied_to_file",       new utils::VariableBencode(&m_download.bencode(), "rtorrent", "tied_to_file", torrent::Bencode::TYPE_STRING));
+
+  m_variables.insert("directory",          new utils::VariableSlotString<>(rak::mem_fn(&m_download, &torrent::Download::root_dir),
+									   rak::mem_fn(this, &Download::set_root_directory)));
+
+  m_variables.insert("min_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &torrent::Download::peers_min),
+											    rak::mem_fn(&m_download, &torrent::Download::set_peers_min),
+											    "%u"));
+  m_variables.insert("max_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &torrent::Download::peers_max),
+											    rak::mem_fn(&m_download, &torrent::Download::set_peers_max),
+											    "%u"));
+  m_variables.insert("max_uploads",        new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &torrent::Download::uploads_max),
+											    rak::mem_fn(&m_download, &torrent::Download::set_uploads_max),
+											    "%u"));
+  m_variables.insert("priority",           new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(this, &Download::priority),
+											    rak::mem_fn(this, &Download::set_priority),
+											    "%u"));
 }
 
 Download::~Download() {
   if (!m_download.is_valid())
     return;
 
@@ -70,44 +94,57 @@
 
   m_download = torrent::Download();
 }
 
 void
 Download::start() {
-  if (is_done()) {
-    m_download.set_connection_type(m_connectionSeed);
-    torrent::download_set_priority(m_download, 2);
-  } else {
-    m_download.set_connection_type(m_connectionLeech);
-    torrent::download_set_priority(m_download, 4);
-  }
+  if (is_done())
+    m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_seed").as_string()));
+  else
+    m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_leech").as_string()));
 
+  // Update the priority to ensure it has the correct
+  // seeding/unfinished modifiers.
+  set_priority(priority());
   m_download.start();
 }
 
 void
-Download::set_root_directory(const std::string& d) {
-  m_download.set_root_dir(d +
-			  (!d.empty() && *d.rbegin() != '/' ? "/" : "") +
-			  (m_download.size_file_entries() > 1 ? m_download.name() : ""));
-}
-
-void
 Download::enable_udp_trackers(bool state) {
   for (int i = 0, last = m_download.size_trackers(); i < last; ++i)
     if (m_download.tracker(i).tracker_type() == torrent::Tracker::TRACKER_UDP)
       if (state)
 	m_download.tracker(i).enable();
       else
 	m_download.tracker(i).disable();
 }
 
+uint32_t
+Download::priority() {
+  return get_bencode().get_key("rtorrent").get_key("priority").as_value();
+}
+
+void
+Download::set_priority(uint32_t p) {
+  if (p >= 4)
+    throw torrent::input_error("Priority out of range.");
+
+  // Seeding torrents get half the priority of unfinished torrents.
+  if (!is_done())
+    torrent::download_set_priority(m_download, p * p * 2);
+  else
+    torrent::download_set_priority(m_download, p * p);
+
+  get_bencode().get_key("rtorrent").insert_key("priority", (int64_t)p);
+}
+
 void
 Download::receive_finished() {
-  m_download.set_connection_type(m_connectionSeed);
-  torrent::download_set_priority(m_download, 2);
+  m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_seed").as_string()));
+  // FIXME
+  //torrent::download_set_priority(m_download, 2);
 }
 
 void
 Download::receive_tracker_msg(std::string msg) {
   if (msg.empty())
     m_message = "";
@@ -140,12 +177,55 @@
     return "seed";
   default:
     return "unknown";
   }
 }
 
+uint32_t
+Download::string_to_priority(const std::string& name) {
+  if (name == "off")
+    return 0;
+  else if (name == "low")
+    return 1;
+  else if (name == "normal")
+    return 2;
+  else if (name == "high")
+    return 3;
+  else
+    throw torrent::input_error("Could not convert string to priority.");
+}
+
+const char*
+Download::priority_to_string(uint32_t p) {
+  switch (p) {
+  case 0:
+    return "off";
+  case 1:
+    return "low";
+  case 2:
+    return "normal";
+  case 3:
+    return "high";
+  default:
+    throw torrent::input_error("Priority out of range.");
+  }
+}
+
 void
 Download::receive_chunk_failed(uint32_t idx) {
   m_chunksFailed++;
 }
 
+// Clean up.
+void
+Download::set_root_directory(const std::string& d) {
+  if (d.empty())
+    m_download.set_root_dir("./" + (m_download.size_file_entries() > 1 ? m_download.name() : std::string()));
+  else
+    m_download.set_root_dir(d +
+			    (*d.rbegin() != '/' ? "/" : "") +
+			    (m_download.size_file_entries() > 1 ? m_download.name() : ""));
+
+  m_download.bencode().get_key("rtorrent").insert_key("directory", d);
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_factory.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_factory.cc	2006-02-01 20:42:22.000000000 +0800
@@ -39,17 +39,20 @@
 #include <fstream>
 #include <sstream>
 #include <stdexcept>
 #include <torrent/bencode.h>
 #include <torrent/exceptions.h>
 
+#include "utils/variable_generic.h"
+
 #include "curl_get.h"
 #include "http_queue.h"
 #include "globals.h"
 #include "manager.h"
 
+#include "download.h"
 #include "download_factory.h"
 
 namespace core {
 
 DownloadFactory::DownloadFactory(const std::string& uri, Manager* m) :
   m_manager(m),
@@ -57,18 +60,22 @@
   m_commited(false),
   m_loaded(false),
 
   m_uri(uri),
   m_session(false),
   m_start(false),
-  m_printLog(true),
-  m_tiedToFile(false) {
+  m_printLog(true) {
 
   m_taskLoad.set_slot(rak::mem_fn(this, &DownloadFactory::receive_load));
   m_taskCommit.set_slot(rak::mem_fn(this, &DownloadFactory::receive_commit));
-}  
+
+  m_variables.insert("connection_leech", new utils::VariableAny(control->variables()->get("connection_leech")));
+  m_variables.insert("connection_seed",  new utils::VariableAny(control->variables()->get("connection_seed")));
+  m_variables.insert("directory",        new utils::VariableAny(control->variables()->get("directory")));
+  m_variables.insert("tied_to_file",     new utils::VariableBool(false));
+}
 
 DownloadFactory::~DownloadFactory() {
   priority_queue_erase(&taskScheduler, &m_taskLoad);
   priority_queue_erase(&taskScheduler, &m_taskCommit);
 
   delete m_stream;
@@ -90,18 +97,18 @@
   if (m_stream)
     throw torrent::client_error("DownloadFactory::load() called on an object with m_stream != NULL");
 
   if (std::strncmp(m_uri.c_str(), "http://", 7) == 0) {
     // Http handling here.
     m_stream = new std::stringstream;
-    HttpQueue::iterator itr = m_manager->get_http_queue().insert(m_uri, m_stream);
+    HttpQueue::iterator itr = m_manager->http_queue().insert(m_uri, m_stream);
 
     (*itr)->signal_done().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_loaded));
     (*itr)->signal_failed().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_failed));
 
-    m_tiedToFile = false;
+    m_variables.set("tied_to_file", (int64_t)false);
 
   } else {
     m_stream = new std::fstream(m_uri.c_str(), std::ios::in);
 
     if (m_stream->good())
       receive_loaded();
@@ -130,43 +137,80 @@
 DownloadFactory::receive_success() {
   if (m_stream == NULL)
     throw torrent::client_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
 
   Manager::DListItr itr = m_manager->insert(m_stream, m_printLog);
 
-  if (itr == m_manager->get_download_list().end()) {
+  if (itr == m_manager->download_list().end()) {
     // core::Manager should already have added the error message to
     // the log.
     m_slotFinished();
     return;
   }
 
-  torrent::Bencode& bencode = (*itr)->get_bencode();
+  torrent::Bencode& root = (*itr)->get_bencode();
+
+  if (!m_session) {
+    // We only allow session torrents to keep their
+    // 'rtorrent/libtorrent' sections.
+    root.erase_key("rtorrent");
+    root.erase_key("libtorrent");
+  }
+
+  if (!root.has_key("rtorrent") ||
+      !root.get_key("rtorrent").is_map())
+    root.insert_key("rtorrent", torrent::Bencode(torrent::Bencode::TYPE_MAP));
+    
+  torrent::Bencode& rtorrent = root.get_key("rtorrent");
+
+  if (!rtorrent.has_key("state") ||
+      !rtorrent.get_key("state").is_string() ||
+      (rtorrent.get_key("state").as_string() != "stopped" &&
+       rtorrent.get_key("state").as_string() != "started"))
+    rtorrent.insert_key("state", "stopped");
+  
+  if (!rtorrent.has_key("tied_to_file") ||
+      !rtorrent.get_key("tied_to_file").is_string())
+    rtorrent.insert_key("tied_to_file", std::string());
+
+  if (rtorrent.has_key("priority") &&
+      rtorrent.get_key("priority").is_value())
+    (*itr)->variables()->set("priority", rtorrent.get_key("priority").as_value() % 4);
+  else
+    (*itr)->variables()->set("priority", (int64_t)2);
+
+  // Move to 'rtorrent'.
+  (*itr)->variables()->set("connection_leech", m_variables.get("connection_leech"));
+  (*itr)->variables()->set("connection_seed",  m_variables.get("connection_seed"));
+  (*itr)->variables()->set("min_peers",        control->variables()->get("min_peers"));
+  (*itr)->variables()->set("max_peers",        control->variables()->get("max_peers"));
+  (*itr)->variables()->set("max_uploads",      control->variables()->get("max_uploads"));
+
+  if (control->variables()->get("use_udp_trackers").as_string() == "no")
+    (*itr)->enable_udp_trackers(false);
 
   if (m_session) {
-    // Hmm... this safe?
-    if (bencode.get_key("rtorrent").get_key("state").as_string() == "started")
-      m_manager->start(*itr, m_printLog);
+    if (!rtorrent.has_key("directory") ||
+	!rtorrent.get_key("directory").is_string())
+      (*itr)->variables()->set("directory", m_variables.get("directory"));
+    else
+      (*itr)->variables()->set("directory", rtorrent.get_key("directory"));
 
-    if (bencode.get_key("rtorrent").has_key("tied") &&
-	bencode.get_key("rtorrent").get_key("tied").is_string())
-      (*itr)->set_tied_to_file(bencode.get_key("rtorrent").get_key("tied").as_string());
+    if ((*itr)->variables()->get_string("state") == "started")
+      m_manager->start(*itr, m_printLog);
 
   } else {
-    // Remove the settings if this isn't a session torrent.
-    //bencode.erase_key("rtorrent");
+    (*itr)->variables()->set("directory", m_variables.get("directory"));
 
-    if (m_tiedToFile) {
-      (*itr)->set_tied_to_file(m_uri);
-      bencode.get_key("rtorrent").insert_key("tied", m_uri);
-    }
+    if (m_variables.get("tied_to_file").as_value())
+      (*itr)->variables()->set("tied_to_file", m_uri);
 
     if (m_start)
       m_manager->start(*itr, m_printLog);
 
-    m_manager->get_download_store().save(*itr);
+    m_manager->download_store().save(*itr);
   }
 
   m_slotFinished();
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_factory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_factory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_factory.h	2006-01-10 08:32:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_factory.h	2006-01-18 04:23:23.000000000 +0800
@@ -42,12 +42,14 @@
 #define RTORRENT_CORE_DOWNLOAD_FACTORY_H
 
 #include <iosfwd>
 #include <sigc++/slot.h>
 #include <rak/priority_queue_default.h>
 
+#include "utils/variable_map.h"
+
 #include "http_queue.h"
 
 namespace core {
 
 class Manager;
 
@@ -62,24 +64,23 @@
   // Calling of receive_load() is delayed so you can change whatever
   // you want without fear of the slots being triggered as you call
   // load() or commit().
   void                load();
   void                commit();
 
+  utils::VariableMap* variables()              { return &m_variables; }
+
   bool                get_session() const   { return m_session; }
   void                set_session(bool v)   { m_session = v; }
 
   bool                get_start() const     { return m_start; }
   void                set_start(bool v)     { m_start = v; }
 
   bool                print_log() const        { return m_printLog; }
   void                set_print_log(bool v)    { m_printLog = v; }
 
-  bool                tied_to_file() const     { return m_tiedToFile; }
-  void                set_tied_to_file(bool v) { m_tiedToFile = v; }
-
   void                slot_finished(Slot s) { m_slotFinished = s; }
 
 private:
   void                receive_load();
   void                receive_loaded();
   void                receive_commit();
@@ -93,13 +94,14 @@
   bool                m_loaded;
 
   std::string         m_uri;
   bool                m_session;
   bool                m_start;
   bool                m_printLog;
-  bool                m_tiedToFile;
+
+  utils::VariableMap  m_variables;
 
   Slot                m_slotFinished;
   rak::priority_item  m_taskLoad;
   rak::priority_item  m_taskCommit;
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download.h	2006-01-10 08:32:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download.h	2006-01-28 02:41:08.000000000 +0800
@@ -38,12 +38,14 @@
 #define RTORRENT_CORE_DOWNLOAD_H
 
 #include <sigc++/connection.h>
 #include <torrent/download.h>
 #include <torrent/torrent.h>
 
+#include "utils/variable_map.h"
+
 namespace core {
 
 class Download {
 public:
   typedef torrent::Download::ConnectionType ConnType;
 
@@ -52,35 +54,29 @@
 
   bool               is_open()                       { return m_download.is_open(); }
   inline bool        is_done();
 
   void               start();
 
+  utils::VariableMap* variables()                                  { return &m_variables; }
+  std::string        variable_string(const std::string& key)       { return m_variables.get_string(key); }
+
   torrent::Download& get_download()                  { return m_download; }
   const torrent::Download& get_download() const      { return m_download; }
   std::string        get_hash()                      { return m_download.info_hash(); }
   torrent::Bencode&  get_bencode()                   { return m_download.bencode(); }
   
   const std::string& get_message()                   { return m_message; }
 
   uint32_t           chunks_failed() const                         { return m_chunksFailed; }
 
-  void               set_root_directory(const std::string& d);
-
-  ConnType           get_connection_current() const                { return m_download.connection_type(); }
-  ConnType           get_connection_leech() const                  { return m_connectionLeech; }
-  ConnType           get_connection_seed() const                   { return m_connectionSeed; }
-
-  void               set_connection_leech(const std::string& name) { m_connectionLeech = string_to_connection_type(name); }
-  void               set_connection_seed(const std::string& name)  { m_connectionSeed = string_to_connection_type(name); }
-
-  const std::string& tied_to_file() const                          { return m_tiedToFile; }
-  void               set_tied_to_file(const std::string& str)      { m_tiedToFile = str; }
-
   void               enable_udp_trackers(bool state);
 
+  uint32_t           priority();
+  void               set_priority(uint32_t p);
+
   // Helper functions for calling functions in torrent::Download
   // through sigc++.
   template <typename Ret, Ret (torrent::Download::*func)()>
   void               call()                                                { (m_download.*func)(); }
 
   template <typename Ret, typename Arg1, Ret (torrent::Download::*func)(Arg1)>
@@ -90,31 +86,39 @@
 
   void               receive_finished();
 
   static ConnType    string_to_connection_type(const std::string& name);
   static const char* connection_type_to_string(ConnType t);
 
+  static uint32_t    string_to_priority(const std::string& name);
+  static const char* priority_to_string(uint32_t p);
+
 private:
+  Download(const Download&);
+  void operator () (const Download&);
+
   void               receive_tracker_msg(std::string msg);
   void               receive_storage_error(std::string msg);
 
   void               receive_chunk_failed(uint32_t idx);
 
+  const char*        connection_current() const                    { return connection_type_to_string(m_download.connection_type()); }
+  void               set_connection_current(const std::string& t)  { return m_download.set_connection_type(string_to_connection_type(t.c_str())); }
+
+  void               set_root_directory(const std::string& d);
+
   torrent::Download  m_download;
 
   std::string        m_message;
   uint32_t           m_chunksFailed;
 
-  ConnType           m_connectionLeech;
-  ConnType           m_connectionSeed;
-
-  std::string        m_tiedToFile;
-
   sigc::connection   m_connTrackerSucceded;
   sigc::connection   m_connTrackerFailed;
   sigc::connection   m_connStorageError;
+
+  utils::VariableMap  m_variables;
 };
 
 inline bool
 Download::is_done() {
   return m_download.chunks_done() == m_download.chunks_total();
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_list.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_list.cc	2006-02-01 20:41:28.000000000 +0800
@@ -44,76 +44,86 @@
 
 #include "download.h"
 #include "download_list.h"
 
 namespace core {
 
+struct download_list_call {
+  download_list_call(Download* d) : m_download(d) {}
+
+  void operator () (const DownloadList::SlotMap::value_type& s) {
+    s.second(m_download);
+  }
+
+  Download* m_download;
+};    
+
 DownloadList::iterator
 DownloadList::insert(std::istream* str) {
   torrent::Download d = torrent::download_add(str);
 
   iterator itr = Base::insert(end(), new Download(d));
   (*itr)->get_download().signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::finished), *itr));
 
-  m_slotMapInsert.for_each(*itr);
+  std::for_each(m_slotMapInsert.begin(), m_slotMapInsert.end(), download_list_call(*itr));
 
   return itr;
 }
 
 DownloadList::iterator
 DownloadList::erase(iterator itr) {
-  m_slotMapErase.for_each(*itr);
+  std::for_each(m_slotMapErase.begin(), m_slotMapErase.end(), download_list_call(*itr));
 
   torrent::download_remove((*itr)->get_download());
   delete *itr;
 
   return Base::erase(itr);
 }
 
 void
 DownloadList::open(Download* d) {
   if (d->get_download().is_open())
     return;
 
-  m_slotMapOpen.for_each(d);
+  std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(d));
 }
 
 void
 DownloadList::close(Download* d) {
   if (!d->get_download().is_open())
     return;
 
   stop(d);
-  m_slotMapClose.for_each(d);
+  std::for_each(m_slotMapClose.begin(), m_slotMapClose.end(), download_list_call(d));
 }
 
 void
 DownloadList::start(Download* d) {
   if (d->get_download().is_active() ||
       !d->get_download().is_hash_checked())
     return;
 
   open(d);
-  m_slotMapStart.for_each(d);
+  std::for_each(m_slotMapStart.begin(), m_slotMapStart.end(), download_list_call(d));
 }
 
 void
 DownloadList::stop(Download* d) {
   if (!d->get_download().is_active())
     return;
 
-  m_slotMapStop.for_each(d);
+  std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(d));
 }
 
 void
 DownloadList::clear() {
   std::for_each(begin(), end(), rak::call_delete<Download>());
 
   Base::clear();
 }
 
 void
 DownloadList::finished(Download* d) {
-  m_slotMapFinished.for_each(d);
+  std::for_each(m_slotMapFinished.begin(), m_slotMapFinished.end(), download_list_call(d));
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_list.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_list.h	2006-02-01 20:43:23.000000000 +0800
@@ -36,26 +36,28 @@
 
 #ifndef RTORRENT_CORE_DOWNLOAD_LIST_H
 #define RTORRENT_CORE_DOWNLOAD_LIST_H
 
 #include <iosfwd>
 #include <list>
-
-#include "download_slot_map.h"
+#include <map>
+#include <string>
+#include <sigc++/slot.h>
 
 namespace core {
 
 class Download;
 
 // Container for all downloads. Add slots to the slot maps to cause
 // some action to be taken when the torrent changes states. Don't
 // change the states from outside of core.
 
 class DownloadList : private std::list<Download*> {
 public:
-  typedef std::list<Download*> Base;
+  typedef std::list<Download*>                                 Base;
+  typedef std::map<std::string, sigc::slot1<void, Download*> > SlotMap;
 
   using Base::iterator;
   using Base::const_iterator;
   using Base::reverse_iterator;
   using Base::const_reverse_iterator;
   using Base::value_type;
@@ -77,33 +79,33 @@
   void                open(Download* d);
   void                close(Download* d);
 
   void                start(Download* d);
   void                stop(Download* d);
 
-  DownloadSlotMap&    slot_map_insert()     { return m_slotMapInsert; }
-  DownloadSlotMap&    slot_map_erase()      { return m_slotMapErase; }
-  DownloadSlotMap&    slot_map_open()       { return m_slotMapOpen; }
-  DownloadSlotMap&    slot_map_close()      { return m_slotMapClose; }
-  DownloadSlotMap&    slot_map_start()      { return m_slotMapStart; }
-  DownloadSlotMap&    slot_map_stop()       { return m_slotMapStop; }
+  SlotMap&            slot_map_insert()     { return m_slotMapInsert; }
+  SlotMap&            slot_map_erase()      { return m_slotMapErase; }
+  SlotMap&            slot_map_open()       { return m_slotMapOpen; }
+  SlotMap&            slot_map_close()      { return m_slotMapClose; }
+  SlotMap&            slot_map_start()      { return m_slotMapStart; }
+  SlotMap&            slot_map_stop()       { return m_slotMapStop; }
 
-  DownloadSlotMap&    slot_map_finished()   { return m_slotMapFinished; }
+  SlotMap&            slot_map_finished()   { return m_slotMapFinished; }
 
 private:
   void                clear();
 
   void                finished(Download* d);
 
-  DownloadSlotMap     m_slotMapInsert;
-  DownloadSlotMap     m_slotMapErase;
-  DownloadSlotMap     m_slotMapOpen;
-  DownloadSlotMap     m_slotMapClose;
-  DownloadSlotMap     m_slotMapStart;
-  DownloadSlotMap     m_slotMapStop;
+  SlotMap             m_slotMapInsert;
+  SlotMap             m_slotMapErase;
+  SlotMap             m_slotMapOpen;
+  SlotMap             m_slotMapClose;
+  SlotMap             m_slotMapStart;
+  SlotMap             m_slotMapStop;
 
-  DownloadSlotMap     m_slotMapFinished;
+  SlotMap             m_slotMapFinished;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_store.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_store.cc	2006-02-03 01:12:18.000000000 +0800
@@ -49,50 +49,89 @@
 #include "download.h"
 #include "download_store.h"
 
 namespace core {
 
 void
-DownloadStore::use(const std::string& path) {
-  m_path = path;
+DownloadStore::enable(bool lock) {
+  if (is_enabled())
+    throw torrent::input_error("Session directory already enabled.");
 
-  if (!m_path.empty() && *m_path.rbegin() != '/')
-    m_path += '/';
+  if (m_path.empty())
+    return;
+
+  if (lock)
+    m_lockfile.set_path(m_path + "rtorrent.lock");
+  else
+    m_lockfile.set_path(std::string());
+
+  if (!m_lockfile.try_lock())
+    throw torrent::input_error("Could not lock session directory: \"" + m_path + "\", held by \"" + m_lockfile.locked_by() + "\".");
+}
+
+void
+DownloadStore::disable() {
+  if (!is_enabled())
+    return;
+
+  m_lockfile.unlock();
+}
+
+void
+DownloadStore::set_path(const std::string& path) {
+  if (is_enabled())
+    throw torrent::input_error("Tried to change session directory while it is enabled.");
+
+  if (!path.empty() && *path.rbegin() != '/')
+    m_path = path + '/';
+  else
+    m_path = path;
 }
 
 void
 DownloadStore::save(Download* d) {
-  if (!is_active())
+  if (!is_enabled())
     return;
 
   std::fstream f((create_filename(d) + ".new").c_str(), std::ios::out | std::ios::trunc);
 
   if (!f.is_open())
     return;
 
   f << d->get_bencode();
 
-  if (f.fail())
+  if (!f.good())
+    return;
+
+  f.close();
+
+  // Test the new file, to ensure it is a valid bencode string.
+  f.open((create_filename(d) + ".new").c_str(), std::ios::in);
+
+  torrent::Bencode tmp;
+  f >> tmp;
+
+  if (!f.good())
     return;
 
   f.close();
 
   ::rename((create_filename(d) + ".new").c_str(), create_filename(d).c_str());
 }
 
 void
 DownloadStore::remove(Download* d) {
-  if (!is_active())
+  if (!is_enabled())
     return;
 
   ::unlink(create_filename(d).c_str());
 }
 
 utils::Directory
 DownloadStore::get_formated_entries() {
-  if (!is_active())
+  if (!is_enabled())
     return utils::Directory();
 
   utils::Directory d(m_path);
 
   if (!d.update())
     throw torrent::storage_error("core::DownloadStore::update() could not open directory \"" + m_path + "\"");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_store.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_store.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/download_store.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/download_store.h	2006-02-01 20:07:24.000000000 +0800
@@ -37,35 +37,40 @@
 #ifndef RTORRENT_CORE_DOWNLOAD_STORE_H
 #define RTORRENT_CORE_DOWNLOAD_STORE_H
 
 #include <string>
 
 #include "utils/directory.h"
+#include "utils/lockfile.h"
 
 namespace core {
 
 class Download;
 
 class DownloadStore {
 public:
 
-  // Disable by passing an empty string.
-  void              use(const std::string& path);
+  bool                is_enabled()                            { return m_lockfile.is_locked(); }
 
-  bool              is_active() { return !m_path.empty(); }
+  void                enable(bool lock);
+  void                disable();
 
-  void              save(Download* d);
-  void              remove(Download* d);
+  const std::string&  path() const                            { return m_path; }
+  void                set_path(const std::string& path);
+
+  void                save(Download* d);
+  void                remove(Download* d);
 
   // Currently shows all entries in the correct format.
-  utils::Directory  get_formated_entries();
+  utils::Directory    get_formated_entries();
 
 private:
-  static bool       is_correct_format(std::string f);
-  std::string       create_filename(Download* d);
+  static bool         is_correct_format(std::string f);
+  std::string         create_filename(Download* d);
 
-  std::string       m_path;
+  std::string         m_path;
+  utils::Lockfile     m_lockfile;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/manager.cc	2006-01-13 14:22:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/manager.cc	2006-02-01 21:02:02.000000000 +0800
@@ -64,29 +64,26 @@
 
 static void
 connect_signal_network_log(Download* d, torrent::Download::SlotString s) {
   d->get_download().signal_network_log(s);
 }
 
-// static void
-// connect_signal_tracker_log(Download* d, torrent::Download::SlotString s) {
-//   d->get_download().signal_tracker_failed(s);
-// }
-
 static void
 connect_signal_storage_log(Download* d, torrent::Download::SlotString s) {
   d->get_download().signal_storage_error(s);
 }
 
 // Hmm... find some better place for all this.
 static void
 delete_tied(Download* d) {
+  const std::string tie = d->variables()->get("tied_to_file").as_string();
+
   // This should be configurable, need to wait for the variable
   // thingie to be implemented.
-  if (!d->tied_to_file().empty())
-    ::unlink(d->tied_to_file().c_str());
+  if (!tie.empty())
+    ::unlink(tie.c_str());
 }
 
 Manager::Manager() :
   m_pollManager(NULL),
   m_portFirst(6890),
   m_portLast(6999) {
@@ -102,26 +99,24 @@
     throw std::runtime_error("Could not create any PollManager.");
 
   // Need to initialize this before parseing options.
   torrent::initialize(m_pollManager->get_torrent_poll());
 }
 
+// Most of this should be possible to move out.
 void
 Manager::initialize_second() {
   torrent::Http::set_factory(m_pollManager->get_http_stack()->get_http_factory());
   m_httpQueue.slot_factory(m_pollManager->get_http_stack()->get_http_factory());
 
   CurlStack::global_init();
 
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
-  m_downloadList.slot_map_insert()["0_initialize_bencode"]  = sigc::mem_fun(*this, &Manager::initialize_bencode);
   m_downloadList.slot_map_insert()["1_connect_network_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-//   m_downloadList.slot_map_insert()["1_connect_tracker_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   m_downloadList.slot_map_insert()["1_connect_storage_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-  //m_downloadList.slot_map_insert()["1_enable_udp_trackers"] = sigc::bind(sigc::mem_fun(&core::Download::enable_udp_trackers), true);
 
   m_downloadList.slot_map_erase()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
   m_downloadList.slot_map_erase()["1_store_remove"]         = sigc::mem_fun(m_downloadStore, &DownloadStore::remove);
   m_downloadList.slot_map_erase()["1_delete_tied"]          = sigc::ptr_fun(&delete_tied);
 
   m_downloadList.slot_map_open()["1_download_open"]         = sigc::mem_fun(&Download::call<void, &torrent::Download::open>);
@@ -188,13 +183,13 @@
   return m_downloadList.erase(itr);
 }  
 
 void
 Manager::start(Download* d, bool printLog) {
   try {
-    d->get_bencode().get_key("rtorrent").insert_key("state", "started");
+    d->variables()->set("state", "started");
 
     if (d->get_download().is_active())
       return;
 
     if (!d->get_download().is_open())
       m_downloadList.open(d);
@@ -213,13 +208,13 @@
   }
 }
 
 void
 Manager::stop(Download* d) {
   try {
-    d->get_bencode().get_key("rtorrent").insert_key("state", "stopped");
+    d->variables()->set("state", "stopped");
 
     m_downloadList.stop(d);
 
   } catch (torrent::local_error& e) {
     m_logImportant.push_front(e.what());
     m_logComplete.push_front(e.what());
@@ -285,25 +280,14 @@
     torrent::set_bind_address(addr);
     listen_open();
 
   } else {
     torrent::set_bind_address(addr);
   }
-}
-
-void
-Manager::initialize_bencode(Download* d) {
-  torrent::Bencode& bencode = d->get_bencode();
 
-  if (!bencode.has_key("rtorrent") ||
-      !bencode.get_key("rtorrent").is_map())
-    bencode.insert_key("rtorrent", torrent::Bencode(torrent::Bencode::TYPE_MAP));
-    
-  if (!bencode.get_key("rtorrent").has_key("state") ||
-      !bencode.get_key("rtorrent").get_key("state").is_string())
-    bencode.get_key("rtorrent").insert_key("state", "stopped");
+  m_pollManager->get_http_stack()->set_bind_address(torrent::bind_address());
 }
 
 void
 Manager::prepare_hash_check(Download* d) {
   m_downloadList.close(d);
   d->get_download().hash_resume_clear();
@@ -325,25 +309,29 @@
 
 void
 Manager::receive_download_done_hash_checked(Download* d) {
   if (!d->get_download().is_active())
     m_downloadList.start(d);
 
+  if (control->variables()->get_string("session_on_completion") == "yes")
+    m_downloadStore.save(d);
+
   // Don't send if we did a hash check and found incompelete chunks.
-  //if (d->is_done())
+  if (d->is_done())
     d->get_download().tracker_send_completed();
 }
 
 void
 Manager::try_create_download(const std::string& uri, bool start, bool printLog, bool tied) {
   // Adding download.
   DownloadFactory* f = new DownloadFactory(uri, this);
 
+  f->variables()->set("tied_to_file", tied ? "yes" : "no");
+
   f->set_start(start);
   f->set_print_log(printLog);
-  f->set_tied_to_file(tied);
   f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
   f->load();
   f->commit();
 }
 
 // Move this somewhere better.
@@ -399,13 +387,13 @@
 
   path_expand(&paths, uri);
 
   if (tied)
     for (std::vector<std::string>::iterator itr = paths.begin(); itr != paths.end(); )
       if (std::find_if(m_downloadList.begin(), m_downloadList.end(),
-		       rak::equal(*itr, std::mem_fun(&Download::tied_to_file))) != m_downloadList.end())
+		       rak::equal(*itr, rak::bind2nd(std::mem_fun(&Download::variable_string), "tied_to_file"))) != m_downloadList.end())
 	itr = paths.erase(itr);
       else
 	itr++;
 
   if (!paths.empty())
     for (std::vector<std::string>::iterator itr = paths.begin(); itr != paths.end(); ++itr)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/manager.h	2006-01-13 14:16:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/manager.h	2006-02-01 19:43:00.000000000 +0800
@@ -57,16 +57,16 @@
   typedef DownloadList::iterator                    DListItr;
   typedef sigc::slot1<void, DownloadList::iterator> SlotReady;
   typedef sigc::slot0<void>                         SlotFailed;
 
   Manager();
 
-  DownloadList&       get_download_list()                 { return m_downloadList; }
-  DownloadStore&      get_download_store()                { return m_downloadStore; }
-  HashQueue&          get_hash_queue()                    { return m_hashQueue; }
-  HttpQueue&          get_http_queue()                    { return m_httpQueue; }
+  DownloadList&       download_list()                 { return m_downloadList; }
+  DownloadStore&      download_store()                { return m_downloadStore; }
+  HashQueue&          hash_queue()                    { return m_hashQueue; }
+  HttpQueue&          http_queue()                    { return m_httpQueue; }
 
   PollManager*        get_poll_manager()                  { return m_pollManager; }
   Log&                get_log_important()                 { return m_logImportant; }
   Log&                get_log_complete()                  { return m_logComplete; }
 
   void                set_port_range(int a, int b)        { m_portFirst = a; m_portLast = b; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/poll_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/poll_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/poll_manager.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/poll_manager.cc	2006-01-22 04:51:44.000000000 +0800
@@ -92,11 +92,9 @@
 }
 
 void
 PollManager::check_error() {
   if (errno != EINTR)
     throw std::runtime_error("Poll::work(): select error");
-
-  m_signalInterrupted.emit();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/poll_manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/poll_manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/core/poll_manager.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/core/poll_manager.h	2006-01-22 04:51:07.000000000 +0800
@@ -60,15 +60,12 @@
 
   CurlStack*          get_http_stack()             { return &m_httpStack; }
   torrent::Poll*      get_torrent_poll()           { return m_poll; }
 
   virtual void        poll(rak::timer timeout) = 0;
 
-  // Use a signal, connect checking for input and updating the display.
-  Signal&             signal_interrupted()         { return m_signalInterrupted; }
-
 protected:
   PollManager(const PollManager&);
   void operator = (const PollManager&);
 
   void                check_error();
 
@@ -76,13 +73,11 @@
   CurlStack           m_httpStack;
 
   unsigned int        m_setSize;
   fd_set*             m_readSet;
   fd_set*             m_writeSet;
   fd_set*             m_errorSet;
-
-  Signal              m_signalInterrupted;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/canvas.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/canvas.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/canvas.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/canvas.cc	2006-01-21 00:16:46.000000000 +0800
@@ -33,12 +33,15 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <unistd.h>
+#include <sys/ioctl.h>
+
 #include "canvas.h"
 
 namespace display {
 
 bool Canvas::m_isInitialized = false;
 
@@ -71,7 +74,17 @@
   m_isInitialized = false;
 
   noraw();
   endwin();
 }
 
+std::pair<int, int>
+Canvas::term_size() {
+  struct winsize ws;
+
+  if (ioctl(STDIN_FILENO, TIOCGWINSZ, &ws) == 0)
+    return std::pair<int, int>(ws.ws_col, ws.ws_row);
+  else
+    return std::pair<int, int>(80, 24);
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/canvas.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/canvas.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/canvas.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/canvas.h	2006-01-21 00:27:54.000000000 +0800
@@ -48,16 +48,20 @@
     m_window(newwin(height, width, y, x)) {}
   ~Canvas() { delwin(m_window); }
 
   void                refresh()                                               { wnoutrefresh(m_window); }
   static void         refresh_std()                                           { wnoutrefresh(stdscr); }
   void                redraw()                                                { redrawwin(m_window); }
+  static void         redraw_std()                                            { redrawwin(stdscr); }
 
   void                resize(int w, int h)                                    { wresize(m_window, h, w); }
   void                resize(int x, int y, int w, int h);
 
+  static void         resize_term(int x, int y)                               { resizeterm(y, x); }
+  static void         resize_term(std::pair<int, int> dim)                    { resizeterm(dim.second, dim.first); }
+
   int                 get_x()                                                 { int x, y; getyx(m_window, y, x); return x; }
   int                 get_y()                                                 { int x, y; getyx(m_window, y, x); return y; }
   int                 get_width()                                             { int x, y; getmaxyx(m_window, y, x); return x; }
   int                 get_height()                                            { int x, y; getmaxyx(m_window, y, x); return y; }
 
   chtype              get_background()                                        { return getbkgd(m_window); }
@@ -113,12 +117,14 @@
   static void         initialize();
   static void         cleanup();
 
   static int          get_screen_width()                                      { int x, y; getmaxyx(stdscr, y, x); return x; }
   static int          get_screen_height()                                     { int x, y; getmaxyx(stdscr, y, x); return y; }
 
+  static std::pair<int, int> term_size();
+
   static void         do_update()                                             { doupdate(); }
 
 private:
   Canvas(const Canvas&);
   void operator = (const Canvas&);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/manager.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/manager.cc	2006-01-22 07:07:22.000000000 +0800
@@ -44,20 +44,27 @@
 #include "globals.h"
 #include "manager.h"
 #include "window.h"
 
 namespace display {
 
-Manager::Manager() {
+Manager::Manager() :
+  m_forceRedraw(false) {
   m_taskUpdate.set_slot(rak::mem_fn(this, &Manager::receive_update));
 }
 
 Manager::~Manager() {
   priority_queue_erase(&taskScheduler, &m_taskUpdate);
 }
 
+void
+Manager::force_redraw() {
+  m_forceRedraw = true;
+}
+
+
 Manager::iterator
 Manager::insert(iterator pos, Window* w) {
   return Base::insert(pos, w);
 }
 
 // Swap with the function below.
@@ -128,12 +135,20 @@
     (*itr)->mark_dirty();
   }
 }
 
 void
 Manager::receive_update() {
+  if (m_forceRedraw) {
+    m_forceRedraw = false;
+
+    display::Canvas::resize_term(display::Canvas::term_size());
+    Canvas::redraw_std();
+    adjust_layout();
+  }
+
   Canvas::refresh_std();
 
   rak::priority_queue_perform(&m_scheduler, cachedTime);
   std::for_each(begin(), end(), rak::if_then(std::mem_fun(&Window::is_active), std::mem_fun(&Window::refresh)));
 
   Canvas::do_update();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/manager.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/manager.h	2006-01-20 01:56:56.000000000 +0800
@@ -61,12 +61,14 @@
   using Base::push_front;
   using Base::push_back;
 
   Manager();
   ~Manager();
 
+  void                force_redraw();
+
   iterator            insert(iterator pos, Window* w);
   iterator            erase(iterator pos);
   iterator            erase(Window* w);
 
   iterator            find(Window* w);
 
@@ -77,12 +79,13 @@
 
 private:
   void                receive_update();
 
   void                schedule_update();
 
+  bool                m_forceRedraw;
   rak::timer          m_timeLastUpdate;
 
   rak::priority_queue_default m_scheduler;
   rak::priority_item          m_taskUpdate;
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/utils.cc	2006-01-16 22:06:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/utils.cc	2006-02-04 01:08:10.000000000 +0800
@@ -36,144 +36,254 @@
 
 #include "config.h"
 
 #include <cstring>
 #include <sstream>
 #include <iomanip>
+#include <torrent/exceptions.h>
 #include <torrent/rate.h>
 #include <torrent/tracker.h>
 
 #include "core/download.h"
 #include <rak/timer.h>
 
 #include "utils.h"
 
 namespace display {
 
+inline char*
+print_buffer(char* first, char* last, const char* format) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2, typename Arg3>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2, const Arg3& arg3) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2, arg3);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
 char*
-print_string(char* buf, unsigned int length, char* str) {
+print_string(char* first, char* last, char* str) {
   // We don't have any nice simple functions for copying strings that
   // return the end address.
-  while (length-- != 0 && *str != '\0')
-    *(buf++) = *(str++);
+  while (first != last && *str != '\0')
+    *(first++) = *(str++);
 
-  return buf;
+  return first;
 }
 
 char*
-print_hhmmss(char* buf, unsigned int length, time_t t) {
+print_hhmmss(char* first, char* last, time_t t) {
   std::tm *u = std::localtime(&t);
   
   if (u == NULL)
-    return "inv_time";
-
-  int s = snprintf(buf, length, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
+    //return "inv_time";
+    throw torrent::internal_error("print_hhmmss(...) failed.");
 
-  return buf + std::max(s, 0);
+  return print_buffer(first, last, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
 }
 
 char*
-print_ddhhmm(char* buf, unsigned int length, time_t t) {
-  int s;
-
+print_ddhhmm(char* first, char* last, time_t t) {
   if (t / (24 * 3600) < 100)
-    s = snprintf(buf, length, "%2i:%02i:%02i", (int)t / (24 * 3600), ((int)t / 3600) % 24, ((int)t / 60) % 60);
+    return print_buffer(first, last, "%2i:%02i:%02i", (int)t / (24 * 3600), ((int)t / 3600) % 24, ((int)t / 60) % 60);
   else
-    s = snprintf(buf, length, "--:--:--");
-  
-  return buf + std::max(s, 0);
+    return print_buffer(first, last, "--:--:--");
 }
 
 char*
-print_ddmmyyyy(char* buf, unsigned int length, time_t t) {
+print_ddmmyyyy(char* first, char* last, time_t t) {
   std::tm *u = std::gmtime(&t);
   
   if (u == NULL)
-    return "inv_time";
-
-  int s = snprintf(buf, length, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
+    //return "inv_time";
+    throw torrent::internal_error("print_ddmmyyyy(...) failed.");
 
-  return buf + std::max(s, 0);
+  return print_buffer(first, last, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
 }
 
 char*
-print_download_title(char* buf, unsigned int length, core::Download* d) {
-  return buf + std::max(snprintf(buf, length, "%s", d->get_download().name().c_str()), 0);
+print_download_title(char* first, char* last, core::Download* d) {
+  return print_buffer(first, last, "%s", d->get_download().name().c_str());
 }
 
 char*
-print_download_info(char* buf, unsigned int length, core::Download* d) {
-  char* last = buf + length;
-
-  buf += std::max(snprintf(buf, last - buf, "Torrent: "), 0);
+print_download_info(char* first, char* last, core::Download* d) {
+  first = print_buffer(first, last, "Torrent: ");
 
   if (!d->get_download().is_open())
-    buf += std::max(snprintf(buf, last - buf, "closed            "), 0);
+    first = print_buffer(first, last, "closed            ");
+
   else if (d->is_done())
-    buf += std::max(snprintf(buf, last - buf, "done %10.1f MB",
-			     (double)d->get_download().bytes_total() / (double)(1 << 20)), 0);
+    first = print_buffer(first, last, "done %10.1f MB", (double)d->get_download().bytes_total() / (double)(1 << 20));
   else
-    buf += std::max(snprintf(buf, last - buf, "%6.1f / %6.1f MB",
-			     (double)d->get_download().bytes_done() / (double)(1 << 20),
-			     (double)d->get_download().bytes_total() / (double)(1 << 20)), 0);
-  
-  buf += std::max(snprintf(buf, last - buf, " Rate: %5.1f / %5.1f KB Uploaded: %7.1f MB ",
-			   (double)d->get_download().up_rate()->rate() / (1 << 10),
-			   (double)d->get_download().down_rate()->rate() / (1 << 10),
-			   (double)d->get_download().up_rate()->total() / (1 << 20)), 0);
+    first = print_buffer(first, last, "%6.1f / %6.1f MB",
+		       (double)d->get_download().bytes_done() / (double)(1 << 20),
+		       (double)d->get_download().bytes_total() / (double)(1 << 20));
+  
+  first = print_buffer(first, last, " Rate: %5.1f / %5.1f KB Uploaded: %7.1f MB",
+		     (double)d->get_download().up_rate()->rate() / (1 << 10),
+		     (double)d->get_download().down_rate()->rate() / (1 << 10),
+		     (double)d->get_download().up_rate()->total() / (1 << 20));
+
+  if (d->get_download().is_active() && !d->is_done()) {
+    first = print_buffer(first, last, " ");
+    first = print_download_percentage_done(first, last, d);
+
+    first = print_buffer(first, last, " ");
+    first = print_download_time_left(first, last, d);
+  } else {
+    first = print_buffer(first, last, "               ");
+  }
+
+  if (d->priority() != 2)
+    first = print_buffer(first, last, " [%s]", core::Download::priority_to_string(d->priority()));
 
-  buf = print_download_time_left(buf, last - buf, d);
+  if (first > last)
+    throw torrent::internal_error("print_download_info(...) wrote past end of the buffer.");
 
-  return buf;
+  return first;
 }
 
 char*
-print_download_status(char* buf, unsigned int length, core::Download* d) {
-  char* last = buf + length;
-
+print_download_status(char* first, char* last, core::Download* d) {
   if (!d->get_download().is_active())
-    buf += std::max(snprintf(buf, last - buf, "Inactive: "), 0);
+    first = print_buffer(first, last, "Inactive: ");
 
   if (d->get_download().is_hash_checking())
-    buf += std::max(snprintf(buf, last - buf, "Checking hash [%2i%%]",
-			     (d->get_download().chunks_hashed() * 100) / d->get_download().chunks_total()), 0);
+    first = print_buffer(first, last, "Checking hash [%2i%%]",
+		       (d->get_download().chunks_hashed() * 100) / d->get_download().chunks_total());
 
   else if (d->get_download().is_tracker_busy() &&
 	   d->get_download().tracker_focus() < d->get_download().size_trackers())
-    buf += std::max(snprintf(buf, last - buf, "Tracker[%i:%i]: Connecting to %s",
-			     d->get_download().tracker(d->get_download().tracker_focus()).group(),
-			     d->get_download().tracker_focus(),
-			     d->get_download().tracker(d->get_download().tracker_focus()).url().c_str()), 0);
+    first = print_buffer(first, last, "Tracker[%i:%i]: Connecting to %s",
+		       d->get_download().tracker(d->get_download().tracker_focus()).group(),
+		       d->get_download().tracker_focus(),
+		       d->get_download().tracker(d->get_download().tracker_focus()).url().c_str());
 
   else if (!d->get_message().empty())
-    buf += std::max(snprintf(buf, last - buf, "%s", d->get_message().c_str()), 0);
+    first = print_buffer(first, last, "%s", d->get_message().c_str());
 
   else
-    buf[0] = '\0';
+    *first = '\0';
+
+  if (first > last)
+    throw torrent::internal_error("print_download_status(...) wrote past end of the buffer.");
 
-  return buf;
+  return first;
 }
 
 char*
-print_download_time_left(char* buf, unsigned int length, core::Download* d) {
-  uint32_t rate;
+print_download_time_left(char* first, char* last, core::Download* d) {
+  uint32_t rate = d->get_download().down_rate()->rate();
 
-  if (!d->get_download().is_active() ||
-      (rate = d->get_download().down_rate()->rate()) < 512) {
-    buf += std::max(0, snprintf(buf, length, "--:--:--"));
-    return buf;
-  }
+  if (rate < 512)
+    return print_buffer(first, last, "--:--:--");
   
   time_t remaining = (d->get_download().bytes_total() - d->get_download().bytes_done()) / (rate & ~(uint32_t)(512 - 1));
 
-  return print_ddhhmm(buf, length, remaining);
+  return print_ddhhmm(first, last, remaining);
 }
 
-// char*
-// print_entry_tags(char* buf, unsigned int length) {
+char*
+print_download_percentage_done(char* first, char* last, core::Download* d) {
+  if (!d->is_open() || d->is_done())
+    //return print_buffer(first, last, "[--%%]");
+    return print_buffer(first, last, "     ");
+  else
+    return print_buffer(first, last, "[%2u%%]", (d->get_download().chunks_done() * 100) / d->get_download().chunks_total());
+}
+
+char*
+print_status_info(char* first, char* last) {
+  if (torrent::up_throttle() == 0)
+    first = print_buffer(first, last, "[Throttle off");
+  else
+    first = print_buffer(first, last, "[Throttle %3i", torrent::up_throttle() / 1024);
+
+  if (torrent::down_throttle() == 0)
+    first = print_buffer(first, last, "/off KB]");
+  else
+    first = print_buffer(first, last, "/%3i KB]", torrent::down_throttle() / 1024);
+  
+  first = print_buffer(first, last, " [Rate %5.1f/%5.1f KB]",
+		       (double)torrent::up_rate()->rate() / 1024.0,
+		       (double)torrent::down_rate()->rate() / 1024.0);
+
+  first = print_buffer(first, last, " [Listen %s:%u]",
+		       torrent::local_address().c_str(),
+		       (unsigned int)torrent::listen_port());
   
-// }
+  if (first > last)
+    throw torrent::internal_error("print_status_info(...) wrote past end of the buffer.");
+
+  std::string bindAddress = torrent::bind_address();
+
+  if (!bindAddress.empty())
+    first = print_buffer(first, last, " [Bind %s]", bindAddress.c_str());
 
-// char*
-// print_entry_file(char* buf, unsigned int length, const torrent::Entry& entry);
+  return first;
+}
+
+char*
+print_status_extra(char* first, char* last, Control* c) {
+  first = print_buffer(first, last, " [U %i/%i]",
+		       torrent::currently_unchoked(),
+		       torrent::max_unchoked());
+
+  first = print_buffer(first, last, " [S %i/%i/%i]",
+		       torrent::total_handshakes(),
+		       torrent::open_sockets(),
+		       torrent::max_open_sockets());
+		       
+  first = print_buffer(first, last, " [F %i/%i]",
+		       torrent::open_files(),
+		       torrent::max_open_files());
+
+  return first;
+}
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/utils.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/utils.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/utils.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/utils.h	2006-02-02 23:26:49.000000000 +0800
@@ -49,25 +49,31 @@
 }
 
 namespace torrent {
   class Entry;
 }
 
+class Control;
+
 namespace display {
 
-char*       print_string(char* buf, unsigned int length, char* str);
+char*       print_string(char* first, char* last, char* str);
+
+char*       print_hhmmss(char* first, char* last, time_t t);
+char*       print_ddhhmm(char* first, char* last, time_t t);
+char*       print_ddmmyyyy(char* first, char* last, time_t t);
+
+char*       print_download_title(char* first, char* last, core::Download* d);
+char*       print_download_info(char* first, char* last, core::Download* d);
+char*       print_download_status(char* first, char* last, core::Download* d);
+char*       print_download_time_left(char* first, char* last, core::Download* d);
+char*       print_download_percentage_done(char* first, char* last, core::Download* d);
 
-char*       print_hhmmss(char* buf, unsigned int length, time_t t);
-char*       print_ddhhmm(char* buf, unsigned int length, time_t t);
-char*       print_ddmmyyyy(char* buf, unsigned int length, time_t t);
-
-char*       print_download_title(char* buf, unsigned int length, core::Download* d);
-char*       print_download_info(char* buf, unsigned int length, core::Download* d);
-char*       print_download_status(char* buf, unsigned int length, core::Download* d);
-char*       print_download_time_left(char* buf, unsigned int length, core::Download* d);
+char*       print_entry_tags(char* first, char* last);
+char*       print_entry_file(char* first, char* last, const torrent::Entry& entry);
 
-char*       print_entry_tags(char* buf, unsigned int length);
-char*       print_entry_file(char* buf, unsigned int length, const torrent::Entry& entry);
+char*       print_status_info(char* first, char* last);
+char*       print_status_extra(char* first, char* last, Control* c);
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_download_list.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_download_list.cc	2006-01-25 02:21:19.000000000 +0800
@@ -80,23 +80,23 @@
   if (range.second != m_list->end())
     ++range.second;
 
   int pos = 0;
 
   while (range.first != range.second) {
-    char buffer[m_canvas->get_width() - 2];
+    char buffer[m_canvas->get_width()];
     char* position;
     char* last = buffer + m_canvas->get_width() - 2;
 
-    position = print_download_title(buffer, last - buffer, *range.first);
+    position = print_download_title(buffer, last, *range.first);
     m_canvas->print(0, pos++, "%c %s", range.first == m_list->get_focus() ? '*' : ' ', buffer);
     
-    position = print_download_info(buffer, last - buffer, *range.first);
+    position = print_download_info(buffer, last, *range.first);
     m_canvas->print(0, pos++, "%c %s", range.first == m_list->get_focus() ? '*' : ' ', buffer);
 
-    position = print_download_status(buffer, last - buffer, *range.first);
+    position = print_download_status(buffer, last, *range.first);
     m_canvas->print(0, pos++, "%c %s", range.first == m_list->get_focus() ? '*' : ' ', buffer);
 
     ++range.first;
   }    
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_download_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_download_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_download_statusbar.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_download_statusbar.cc	2006-01-25 02:21:19.000000000 +0800
@@ -55,30 +55,35 @@
 void
 WindowDownloadStatusbar::redraw() {
   m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
 
   m_canvas->erase();
 
-  char buffer[m_canvas->get_width() - 2];
+  char buffer[m_canvas->get_width()];
   char* position;
   char* last = buffer + m_canvas->get_width() - 2;
 
-  position = print_download_info(buffer, last - buffer, m_download);
+  position = print_download_info(buffer, last, m_download);
   m_canvas->print(0, 0, "%s", buffer);
 
-  m_canvas->print(0, 1, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I: %i/%i Failed: %i",
-		  (int)m_download->get_download().peers_connected(),
-		  (int)m_download->get_download().peers_not_connected(),
-		  (int)m_download->get_download().peers_min(),
-		  (int)m_download->get_download().peers_max(),
-		  (int)m_download->get_download().uploads_max(),
-		  (int)m_download->get_download().peers_currently_unchoked(),
-		  (int)m_download->get_download().peers_currently_interested(),
-		  (int)m_download->chunks_failed());
+  position = buffer + std::max(snprintf(buffer, last - buffer, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I: %i/%i Failed: %i",
+					(int)m_download->get_download().peers_connected(),
+					(int)m_download->get_download().peers_not_connected(),
+					(int)m_download->get_download().peers_min(),
+					(int)m_download->get_download().peers_max(),
+					(int)m_download->get_download().uploads_max(),
+					(int)m_download->get_download().peers_currently_unchoked(),
+					(int)m_download->get_download().peers_currently_interested(),
+					(int)m_download->chunks_failed()),
+			       0);
+//   position = buffer + std::max(snprintf(position, last - buffer, " Priority: %s",
+// 					core::Download::priority_to_string(m_download->variables()->get("priority").as_value())),
+// 			       0);
+  m_canvas->print(0, 1, "%s", buffer);
 
-  position = print_download_status(buffer, last - buffer, m_download);
+  position = print_download_status(buffer, last, m_download);
   m_canvas->print(0, 2, "[%c:%i] %s",
 		  m_download->get_download().is_tracker_busy() ? 'C' : ' ',
 		  (int)(m_download->get_download().tracker_timeout() / 1000000),
 		  buffer);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_file_list.cc	2006-01-17 23:52:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_file_list.cc	2006-01-21 04:14:56.000000000 +0800
@@ -49,12 +49,27 @@
 WindowFileList::WindowFileList(core::Download* d, unsigned int* focus) :
   Window(new Canvas, true),
   m_download(d),
   m_focus(focus) {
 }
 
+std::wstring
+hack_wstring(const std::string& src) {
+  size_t length = ::mbstowcs(NULL, src.c_str(), src.size());
+
+  if (length == (size_t)-1)
+    return std::wstring(L"<invalid>");
+
+  std::wstring dest;
+  dest.resize(length);
+  
+  ::mbstowcs(&*dest.begin(), src.c_str(), src.size());
+
+  return dest;
+}
+
 void
 WindowFileList::redraw() {
   m_slotSchedule(this, (cachedTime + 10 * 1000000).round_seconds());
   m_canvas->erase();
 
   if (m_download->get_download().size_file_entries() == 0 ||
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_log.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_log.cc	2006-01-25 02:26:43.000000000 +0800
@@ -68,13 +68,13 @@
   m_canvas->erase();
 
   int pos = 0;
 
   for (core::Log::iterator itr = m_log->begin(), end = find_older(); itr != end && pos < m_canvas->get_height(); ++itr) {
     char buffer[16];
-    print_hhmmss(buffer, 16, static_cast<time_t>(itr->first.seconds()));
+    print_hhmmss(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
 
     m_canvas->print(0, pos++, "(%s) %s", buffer, itr->second.c_str());
   }
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_log_complete.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_log_complete.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_log_complete.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_log_complete.cc	2006-01-25 02:28:11.000000000 +0800
@@ -68,13 +68,13 @@
   int pos = 0;
 
   m_canvas->print(std::max(0, (int)m_canvas->get_width() / 2 - 5), pos++, "*** Log ***");
 
   for (core::Log::iterator itr = m_log->begin(), e = m_log->end(); itr != e && pos < m_canvas->get_height(); ++itr) {
     char buffer[16];
-    print_hhmmss(buffer, 16, static_cast<time_t>(itr->first.seconds()));
+    print_hhmmss(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
 
     m_canvas->print(0, pos++, "(%s) %s", buffer, itr->second.c_str());
   }
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_peer_info.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_peer_info.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_peer_info.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_peer_info.cc	2006-02-04 04:28:35.000000000 +0800
@@ -68,26 +68,28 @@
   m_canvas->print(0, y++, "Chunks:  %u / %u * %u",
 		  d.chunks_done(),
 		  d.chunks_total(),
 		  d.chunks_size());
 
   char buffer[32], *position;
-  position = print_ddmmyyyy(buffer, 32, static_cast<time_t>(d.creation_date()));
-  position = print_string(position, buffer + 32 - position, " ");
-  position = print_hhmmss(position, buffer + 32 - position, static_cast<time_t>(d.creation_date()));
+  position = print_ddmmyyyy(buffer, buffer + 32, static_cast<time_t>(d.creation_date()));
+  position = print_string(position, buffer + 32, " ");
+  position = print_hhmmss(position, buffer + 32, static_cast<time_t>(d.creation_date()));
 
   m_canvas->print(0, y++, "Created: %s", buffer);
 
   y++;
 
   m_canvas->print(0, y++, "Connection Type: %s ( %s / %s )",
-		  core::Download::connection_type_to_string(m_download->get_connection_current()),
-		  core::Download::connection_type_to_string(m_download->get_connection_leech()),
-		  core::Download::connection_type_to_string(m_download->get_connection_seed()));
-  m_canvas->print(0, y++, "Tied to file: %s",
-		  m_download->tied_to_file().c_str());
+		  m_download->variables()->get("connection_current").as_string().c_str(),
+		  m_download->variables()->get("connection_seed").as_string().c_str(),
+		  m_download->variables()->get("connection_leech").as_string().c_str());
+  m_canvas->print(0, y++, "Priority:        %u", torrent::download_priority(m_download->get_download()));
+
+  m_canvas->print(0, y++, "Directory:       %s", m_download->variable_string("directory").c_str());
+  m_canvas->print(0, y++, "Tied to file:    %s", m_download->variable_string("tied_to_file").c_str());
 
   y++;
 
   if (*m_focus == m_list->end()) {
     m_canvas->print(0, y++, "No peer in focus");
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/display/window_statusbar.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/display/window_statusbar.cc	2006-01-25 03:13:57.000000000 +0800
@@ -38,12 +38,13 @@
 
 #include <torrent/rate.h>
 #include <torrent/torrent.h>
 
 #include "control.h"
 #include "canvas.h"
+#include "utils.h"
 #include "window_statusbar.h"
 
 namespace display {
 
 WindowStatusbar::WindowStatusbar(Control* c) :
   Window(new Canvas, false, 1),
@@ -55,47 +56,57 @@
 WindowStatusbar::redraw() {
   m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
 
   m_canvas->erase();
 
   // TODO: Make a buffer with size = get_width?
-  int pos = 0;
-  char buf[128];
+  char buffer[m_canvas->get_width() + 1];
+  char* position;
+  char* last = buffer + m_canvas->get_width();
+
+//   if (torrent::up_throttle() == 0)
+//     position = std::max(snprintf(buffer, 128, "off/"), 0);
+//   else
+//     position = std::max(snprintf(buffer, 128, "%3i/", torrent::up_throttle() / 1024), 0);
+
+//   if (torrent::down_throttle() == 0)
+//     pos = snprintf(buf + pos, 128 - pos, "off");
+//   else
+//     pos = snprintf(buf + pos, 128 - pos, "%-3i", torrent::down_throttle() / 1024);
+
+//   m_canvas->print(0, 0, "Throttle U/D: %s  Rate: %5.1f / %5.1f KB  Listen: %s:%i%s",
+// 		  buf,
+// 		  (double)torrent::up_rate()->rate() / 1024.0,
+// 		  (double)torrent::down_rate()->rate() / 1024.0,
+// 		  !torrent::local_address().empty() ? torrent::local_address().c_str() : "<default>",
+// 		  (int)torrent::listen_port(),
+// 		  !torrent::bind_address().empty() ? ("  Bind: " + torrent::bind_address()).c_str() : "");
+
+// #ifndef USE_EXTRA_DEBUG
+//   pos = snprintf(buf, 128, "[U %i/%i][S %i/%i/%i][F %i/%i]",
+// #else
+//   pos = snprintf(buf, 128, "%i [U %i/%i][S %i/%i/%i][F %i/%i]",
+// 		 (int)(m_control->tick() - m_lastTick),
+// #endif
+// 		 torrent::currently_unchoked(),
+// 		 torrent::max_unchoked(),
+// 		 torrent::total_handshakes(),
+// 		 torrent::open_sockets(),
+// 		 torrent::max_open_sockets(),
+// 		 torrent::open_files(),
+// 		 torrent::max_open_files());
+
+  position = print_status_info(buffer, last);
+  m_canvas->print(0, 0, "%s", buffer);
+
+  last = last - (position - buffer);
+
+  if (last > buffer) {
+    position = print_status_extra(buffer, last, m_control);
+    m_canvas->print(m_canvas->get_width() - (position - buffer), 0, "%s", buffer);
+  }
 
-  if (torrent::up_throttle() == 0)
-    pos = snprintf(buf, 128, "off/");
-  else
-    pos = snprintf(buf, 128, "%3i/", torrent::up_throttle() / 1024);
-
-  if (torrent::down_throttle() == 0)
-    pos = snprintf(buf + pos, 128 - pos, "off");
-  else
-    pos = snprintf(buf + pos, 128 - pos, "%-3i", torrent::down_throttle() / 1024);
-
-  m_canvas->print(0, 0, "Throttle U/D: %s  Rate: %5.1f / %5.1f KB  Listen: %s:%i%s",
-		  buf,
-		  (double)torrent::up_rate()->rate() / 1024.0,
-		  (double)torrent::down_rate()->rate() / 1024.0,
-		  !torrent::local_address().empty() ? torrent::local_address().c_str() : "<default>",
-		  (int)torrent::listen_port(),
-		  !torrent::bind_address().empty() ? ("  Bind: " + torrent::bind_address()).c_str() : "");
-
-#ifndef USE_EXTRA_DEBUG
-  pos = snprintf(buf, 128, "[U %i/%i][S %i/%i/%i][F %i/%i]",
-#else
-  pos = snprintf(buf, 128, "%i [U %i/%i][S %i/%i/%i][F %i/%i]",
-		 (int)(m_control->tick() - m_lastTick),
-#endif
-		 torrent::currently_unchoked(),
-		 torrent::max_unchoked(),
-		 torrent::total_handshakes(),
-		 torrent::open_sockets(),
-		 torrent::max_open_sockets(),
-		 torrent::open_files(),
-		 torrent::max_open_files());
-
-  m_canvas->print(m_canvas->get_width() - pos, 0, "%s", buf);
 
   m_lastTick = m_control->tick();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/main.cc	2006-01-14 11:17:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/main.cc	2006-02-01 21:01:47.000000000 +0800
@@ -74,25 +74,12 @@
 #include "command_scheduler.h"
 #include "command_scheduler_item.h"
 
 void do_panic(int signum);
 void print_help();
 
-bool
-is_resized() {
-  static int x = 0;
-  static int y = 0;
-  
-  bool r = display::Canvas::get_screen_width() != x || display::Canvas::get_screen_height() != y;
-
-  x = display::Canvas::get_screen_width();
-  y = display::Canvas::get_screen_height();
-
-  return r;
-}
-
 int
 parse_options(Control* c, utils::VariableMap* optionHandler, int argc, char** argv) {
   try {
     OptionParser optionParser;
 
     // Converted.
@@ -113,13 +100,13 @@
   }
 }
 
 void
 load_session_torrents(Control* c) {
   // Load session torrents.
-  std::list<std::string> l = c->core()->get_download_store().get_formated_entries().make_list();
+  std::list<std::string> l = c->core()->download_store().get_formated_entries().make_list();
 
   for (std::list<std::string>::iterator first = l.begin(), last = l.end(); first != last; ++first) {
     core::DownloadFactory* f = new core::DownloadFactory(*first, c->core());
 
     // Replace with session torrent flag.
     f->set_session(true);
@@ -154,26 +141,31 @@
 }
 
 int
 main(int argc, char** argv) {
   try {
 
+    // Temporary.
+    //setlocale(LC_ALL, "");
+
     cachedTime = rak::timer::current();
 
     control = new Control;
     
     srandom(cachedTime.usec());
     srand48(cachedTime.usec());
 
     initialize_option_handler(control);
 
     SignalHandler::set_ignore(SIGPIPE);
-    SignalHandler::set_handler(SIGINT,  sigc::mem_fun(control, &Control::receive_shutdown));
-    SignalHandler::set_handler(SIGSEGV, sigc::bind(sigc::ptr_fun(&do_panic), SIGSEGV));
-    SignalHandler::set_handler(SIGBUS,  sigc::bind(sigc::ptr_fun(&do_panic), SIGBUS));
-    SignalHandler::set_handler(SIGFPE,  sigc::bind(sigc::ptr_fun(&do_panic), SIGFPE));
+    SignalHandler::set_handler(SIGINT,   sigc::mem_fun(control, &Control::receive_normal_shutdown));
+    SignalHandler::set_handler(SIGTERM,  sigc::mem_fun(control, &Control::receive_quick_shutdown));
+    SignalHandler::set_handler(SIGWINCH, sigc::mem_fun(control->display(), &display::Manager::force_redraw));
+    SignalHandler::set_handler(SIGSEGV,  sigc::bind(sigc::ptr_fun(&do_panic), SIGSEGV));
+    SignalHandler::set_handler(SIGBUS,   sigc::bind(sigc::ptr_fun(&do_panic), SIGBUS));
+    SignalHandler::set_handler(SIGFPE,   sigc::bind(sigc::ptr_fun(&do_panic), SIGFPE));
 
     control->core()->initialize_first();
 
     OptionFile optionFile;
     optionFile.slot_option(sigc::mem_fun(control->variables(), &utils::VariableMap::process_command));
 
@@ -181,28 +173,25 @@
       control->core()->get_log_important().push_front("Could not load \"~/.rtorrent.rc\".");
 
     int firstArg = parse_options(control, control->variables(), argc, argv);
 
     control->initialize();
 
-    // Just to make sure we did all the stuff on the queue before
-    // loading any torrents.
-    //
-    // Remove this?
-    //rak::priority_queue_perform(&taskScheduler, cachedTime);
-
     // Load session torrents and perform scheduled tasks to ensure
     // session torrents are loaded before arg torrents.
     load_session_torrents(control);
     rak::priority_queue_perform(&taskScheduler, cachedTime);
 
     load_arg_torrents(control, argv + firstArg, argv + argc);
 
     control->display()->adjust_layout();
 
     while (!control->is_shutdown_completed()) {
+      if (control->is_shutdown_received())
+	control->handle_shutdown();
+
       control->inc_tick();
 
       cachedTime = rak::timer::current();
       rak::priority_queue_perform(&taskScheduler, cachedTime);
 
       // Do shutdown check before poll, not after.
@@ -258,28 +247,12 @@
     std::cout << "A bus error propably means you ran out of diskspace." << std::endl;
 
   exit(-1);
 }
 
 void
-receive_tracker_dump(std::istream* s) {
-  std::stringstream filename;
-  filename << "./tracker_dump." << rak::timer::current().seconds();
-
-  std::fstream out(filename.str().c_str(), std::ios::out | std::ios::trunc);
-
-  if (!out.is_open())
-    return;
-  
-  s->seekg(0);
-
-  std::copy(std::istream_iterator<char>(*s), std::istream_iterator<char>(),
-	    std::ostream_iterator<char>(out));
-}
-
-void
 print_help() {
   std::cout << "Rakshasa's BitTorrent client version " VERSION "." << std::endl;
   std::cout << std::endl;
   std::cout << "All value pairs (f.ex rate and queue size) will be in the UP/DOWN" << std::endl;
   std::cout << "order. Use the up/down/left/right arrow keys to move between screens." << std::endl;
   std::cout << std::endl;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/option_file.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/option_file.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/option_file.cc	2006-01-14 11:18:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/option_file.cc	2006-01-28 03:38:28.000000000 +0800
@@ -65,32 +65,6 @@
 
     throw std::runtime_error(buffer);
   }
 
   return true;
 }
-
-// void
-// OptionFile::parse_line(const char* line) {
-  //const char* last = std::find(line, line + max_size_line, '\0');
-
-//   if (line[0] == '#')
-//     return;
-
-//   int result;
-//   char key[64];
-//   char opt[512];
-
-//   opt[0] = '\0';
-
-//   // Check for empty lines, and options within "abc".
-//   if ((result = std::sscanf(line, "%63s = \"%511[^\"]", key, opt)) != 2 &&
-//       (result = std::sscanf(line, "%63s = %511s", key, opt)) != 2 &&
-//       result == 1)
-//     throw torrent::input_error("Error parseing option file.");
-
-//   if (opt[0] == '"' && opt[1] == '"')
-//     opt[0] = '\0';
-
-//   if (result >= 1)
-//     m_slotOption(key, opt);
-// }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/option_handler_rules.cc	2006-01-13 14:31:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/option_handler_rules.cc	2006-02-05 01:35:45.000000000 +0800
@@ -34,171 +34,67 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <cstdio>
-#include <functional>
-#include <arpa/inet.h>
-#include <netinet/in.h>
+#include <unistd.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <rak/file_stat.h>
 #include <rak/functional.h>
 #include <rak/string_manip.h>
 #include <torrent/bencode.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 
+#include "core/download.h"
 #include "core/manager.h"
 #include "ui/root.h"
 #include "utils/directory.h"
 #include "utils/variable_generic.h"
 #include "utils/variable_map.h"
 
 #include "globals.h"
 #include "control.h"
 #include "option_handler_rules.h"
 #include "command_scheduler.h"
-#include "command_scheduler_item.h"
-
-void receive_tracker_dump(std::istream* s);
-
-void
-OptionHandlerInt::process(const std::string& key, const std::string& arg) {
-  int a;
-    
-  if (std::sscanf(arg.c_str(), "%i", &a) != 1)
-    throw torrent::input_error("Invalid argument for \"" + key + "\": \"" + arg + "\", must be an integer.");
-    
-  m_apply(m_control, a);
-}
-
-void
-OptionHandlerOctal::process(const std::string& key, const std::string& arg) {
-  int a;
-    
-  if (std::sscanf(arg.c_str(), "%o", &a) != 1)
-    throw torrent::input_error("Invalid argument for \"" + key + "\": \"" + arg + "\", must be an octal.");
-    
-  m_apply(m_control, a);
-}
-
-void
-OptionHandlerString::process(const std::string& key, const std::string& arg) {
-  m_apply(m_control, arg);
-}
-
-void
-apply_download_min_peers(Control* m, int arg) {
-  m->core()->get_download_list().slot_map_insert()["1_min_peers"] = sigc::bind(sigc::mem_fun(&core::Download::call<void, uint32_t, &torrent::Download::set_peers_min>), arg);
-}
-
-void
-apply_download_max_peers(Control* m, int arg) {
-  m->core()->get_download_list().slot_map_insert()["1_max_peers"] = sigc::bind(sigc::mem_fun(&core::Download::call<void, uint32_t, &torrent::Download::set_peers_max>), arg);
-}
 
 void
-apply_download_max_uploads(Control* m, int arg) {
-  m->core()->get_download_list().slot_map_insert()["1_max_uploads"] = sigc::bind(sigc::mem_fun(&core::Download::call<void, uint32_t, &torrent::Download::set_uploads_max>), arg);
-}
-
-void
-apply_download_directory(Control* m, const std::string& arg) {
-  if (!arg.empty())
-    m->core()->get_download_list().slot_map_insert()["1_directory"] = sigc::bind(sigc::mem_fun(&core::Download::set_root_directory), arg);
-  else
-    m->core()->get_download_list().slot_map_insert().erase("1_directory");
-}
-
-void
-apply_connection_leech(Control* m, const std::string& arg) {
-  core::Download::string_to_connection_type(arg);
-  m->core()->get_download_list().slot_map_insert()["1_connection_leech"] = sigc::bind(sigc::mem_fun(&core::Download::set_connection_leech), arg);
-}
-
-void
-apply_connection_seed(Control* m, const std::string& arg) {
-  core::Download::string_to_connection_type(arg);
-  m->core()->get_download_list().slot_map_insert()["1_connection_seed"] = sigc::bind(sigc::mem_fun(&core::Download::set_connection_seed), arg);
-}
-
-void
-apply_global_download_rate(Control* m, int arg) {
-  m->ui()->set_down_throttle(arg);
-}
-
-void
-apply_global_upload_rate(Control* m, int arg) {
-  m->ui()->set_up_throttle(arg);
+apply_umask(int arg) {
+  umask(arg);
 }
 
 void
-apply_umask(Control* m, int arg) {
-  umask(arg);
+apply_working_directory(const std::string& path) {
+  if (chdir(path.c_str()) != 0)
+    throw torrent::input_error("Could not change working directory.");
 }
 
 void
 apply_hash_read_ahead(Control* m, int arg) {
   torrent::set_hash_read_ahead(arg << 20);
 }
 
 void
 apply_hash_interval(Control* m, int arg) {
   torrent::set_hash_interval(arg * 1000);
 }
 
-void
-apply_hash_max_tries(Control* m, int arg) {
-  torrent::set_hash_max_tries(arg);
-}
-
-void
-apply_max_open_files(Control* m, int arg) {
-  torrent::set_max_open_files(arg);
-}
-
-void
-apply_max_open_sockets(Control* m, int arg) {
-  torrent::set_max_open_sockets(arg);
-}
-
-void
-apply_ip(Control* m, const std::string& arg) {
-  torrent::set_local_address(arg);
-}
-
 // The arg string *must* have been checked with validate_port_range
 // first.
 void
 apply_port_range(Control* m, const std::string& arg) {
   int a = 0, b = 0;
     
   std::sscanf(arg.c_str(), "%i-%i", &a, &b);
 
   m->core()->set_port_range(a, b);
 }
 
 void
-apply_tracker_dump(Control* m, const std::string& arg) {
-  if (arg == "yes")
-    m->core()->get_download_list().slot_map_insert()["1_tracker_dump"] = sigc::bind(sigc::mem_fun(&core::Download::call<sigc::connection, torrent::Download::SlotIStream, &torrent::Download::signal_tracker_dump>), sigc::ptr_fun(&receive_tracker_dump));
-  else
-    m->core()->get_download_list().slot_map_insert().erase("1_tracker_dump");
-}
-
-void
-apply_use_udp_trackers(Control* m, const std::string& arg) {
-  if (arg == "yes")
-    m->core()->get_download_list().slot_map_insert().erase("1_use_udp_trackers");
-  else
-    m->core()->get_download_list().slot_map_insert()["1_use_udp_trackers"] = sigc::bind(sigc::mem_fun(&core::Download::enable_udp_trackers), false);
-}
-
-void
 apply_http_proxy(Control* m, const std::string& arg) {
   m->core()->get_poll_manager()->get_http_stack()->set_http_proxy(arg);
 }
 
 void
 apply_load(Control* m, const std::string& arg) {
@@ -209,127 +105,102 @@
 apply_load_start(Control* m, const std::string& arg) {
   m->core()->try_create_download_expand(arg, true, false, true);
 }
 
 void
 apply_stop_untied(Control* m, const std::string& arg) {
-  core::Manager::DListItr itr = m->core()->get_download_list().begin();
+  core::Manager::DListItr itr = m->core()->download_list().begin();
 
-  while ((itr = std::find_if(itr, m->core()->get_download_list().end(),
-			     rak::on(std::mem_fun(&core::Download::tied_to_file), std::not1(std::mem_fun_ref(&std::string::empty)))))
-	 != m->core()->get_download_list().end()) {
+  while ((itr = std::find_if(itr, m->core()->download_list().end(),
+			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
+				     std::not1(std::mem_fun_ref(&std::string::empty)))))
+	 != m->core()->download_list().end()) {
     rak::file_stat fs;
 
-    if (!fs.update((*itr)->tied_to_file())) {
-      (*itr)->set_tied_to_file(std::string());
-      (*itr)->get_bencode().get_key("rtorrent").erase_key("tied");
-
+    if (!fs.update((*itr)->variable_string("tied_to_file"))) {
+      (*itr)->variables()->set("tied_to_file", std::string());
       m->core()->stop(*itr);
     }
 
     ++itr;
   }
 }
 
 void
 apply_remove_untied(Control* m, const std::string& arg) {
-  core::Manager::DListItr itr = m->core()->get_download_list().begin();
+  core::Manager::DListItr itr = m->core()->download_list().begin();
 
-  while ((itr = std::find_if(itr, m->core()->get_download_list().end(),
-			     rak::on(std::mem_fun(&core::Download::tied_to_file), std::not1(std::mem_fun_ref(&std::string::empty)))))
-	 != m->core()->get_download_list().end()) {
+  while ((itr = std::find_if(itr, m->core()->download_list().end(),
+			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
+				     std::not1(std::mem_fun_ref(&std::string::empty)))))
+	 != m->core()->download_list().end()) {
     rak::file_stat fs;
 
-    if (!fs.update((*itr)->tied_to_file())) {
-      (*itr)->set_tied_to_file(std::string());
-      (*itr)->get_bencode().get_key("rtorrent").erase_key("tied");
-
+    if (!fs.update((*itr)->variable_string("tied_to_file"))) {
+      (*itr)->variables()->set("tied_to_file", std::string());
       m->core()->stop(*itr);
       itr = m->core()->erase(itr);
 
     } else {
       ++itr;
     }
   }
 }
 
 void
-apply_session_directory(Control* m, const std::string& arg) {
-  m->core()->get_download_store().use(arg);
-}
-
-void
 apply_encoding_list(Control* m, const std::string& arg) {
   torrent::encoding_list()->push_back(arg);
 }
 
 void
-apply_schedule(Control* m, const std::string& arg) {
-  int first;
-  int interval;
-  char key[21];
-  char command[2048];
-
-  if (std::sscanf(arg.c_str(), "%20[^,],%i,%i,%2047[^\n]", key, &first, &interval, command) != 4)
-    throw torrent::input_error("Invalid arguments to command.");
-
-  CommandSchedulerItem* item = *m->command_scheduler()->insert(rak::trim(std::string(key)));
-
-  item->set_command(rak::trim(std::string(command)));
-  item->set_interval(interval);
-
-  item->enable(first);
-}
-
-void
-apply_schedule_remove(Control* m, const std::string& arg) {
-  m->command_scheduler()->erase(m->command_scheduler()->find(rak::trim(arg)));
-}
-
-void
 initialize_option_handler(Control* c) {
   utils::VariableMap* variables = control->variables();
 
   // Cleaned up.
-  variables->insert("check_hash",          new utils::VariableValue("yes"));
-  variables->insert("port_random",         new utils::VariableValue("yes"));
-  variables->insert("session",             new utils::VariableSlotString<>(NULL, rak::mem_fn(&control->core()->get_download_store(), &core::DownloadStore::use)));
-
-  // Old.
+  variables->insert("check_hash",            new utils::VariableAny("yes"));
+  variables->insert("use_udp_trackers",      new utils::VariableAny("yes"));
+  variables->insert("port_random",           new utils::VariableAny("yes"));
+  variables->insert("session",               new utils::VariableSlotString<>(NULL, rak::mem_fn(&control->core()->download_store(), &core::DownloadStore::set_path)));
+  variables->insert("session_lock",          new utils::VariableAny("no"));
+  variables->insert("session_on_completion", new utils::VariableAny("yes"));
+
+  variables->insert("connection_leech",    new utils::VariableAny("leech"));
+  variables->insert("connection_seed",     new utils::VariableAny("seed"));
+
+  variables->insert("directory",           new utils::VariableAny("./"));
+  variables->insert("working_directory",   new utils::VariableSlotString<>(NULL, rak::ptr_fn(&apply_working_directory)));
+  variables->insert("ip",                  new utils::VariableSlotString<>(NULL, rak::ptr_fn(&torrent::set_local_address)));
   variables->insert("bind",                new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::bind)));
 
-  variables->insert("ip",                  new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_ip, c)));
-  variables->insert("port_range",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_port_range, c)));
+  variables->insert("min_peers",           new utils::VariableValue(40));
+  variables->insert("max_peers",           new utils::VariableValue(100));
+  variables->insert("max_uploads",         new utils::VariableValue(15));
+
+  variables->insert("download_rate",       new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_down_throttle), "%i"));
+  variables->insert("upload_rate",         new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_up_throttle), "%i"));
 
-  variables->insert("directory",           new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_download_directory, c)));
+  variables->insert("hash_max_tries",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_hash_max_tries), "%i"));
+  variables->insert("max_open_files",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_files), "%i"));
+  variables->insert("max_open_sockets",    new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_sockets), "%i"));
 
-  variables->insert("max_peers",           new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_download_max_peers, c), "%i"));
-  variables->insert("min_peers",           new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_download_min_peers, c), "%i"));
-  variables->insert("max_uploads",         new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_download_max_uploads, c), "%i"));
+  variables->insert("print",               new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::push_log)));
 
-  variables->insert("download_rate",       new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_global_download_rate, c), "%i"));
-  variables->insert("upload_rate",         new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_global_upload_rate, c), "%i"));
+  variables->insert("schedule",            new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::parse)));
+  variables->insert("schedule_remove",     new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::erase)));
+
+  // Old.
+  variables->insert("port_range",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_port_range, c)));
 
   variables->insert("hash_read_ahead",     new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_read_ahead, c), "%i"));
   variables->insert("hash_interval",       new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_interval, c), "%i"));
-  variables->insert("hash_max_tries",      new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_max_tries, c), "%i"));
-  variables->insert("max_open_files",      new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_max_open_files, c), "%i"));
-  variables->insert("max_open_sockets",    new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_max_open_sockets, c), "%i"));
-
-  variables->insert("umask",               new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_umask, c), "%o"));
 
-  variables->insert("connection_leech",    new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_connection_leech, c)));
-  variables->insert("connection_seed",     new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_connection_seed, c)));
+  variables->insert("umask",               new utils::VariableSlotValue<int, int>(NULL, rak::ptr_fn(&apply_umask), "%o"));
 
   variables->insert("load",                new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_load, c)));
   variables->insert("load_start",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_load_start, c)));
   variables->insert("stop_untied",         new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_stop_untied, c)));
   variables->insert("remove_untied",       new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_remove_untied, c)));
 
   variables->insert("encoding_list",       new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_encoding_list, c)));
-  variables->insert("tracker_dump",        new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_tracker_dump, c)));
-  variables->insert("use_udp_trackers",    new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_use_udp_trackers, c)));
 
   variables->insert("http_proxy",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_http_proxy, c)));
-  variables->insert("schedule",            new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_schedule, c)));
-  variables->insert("schedule_remove",     new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_schedule_remove, c)));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/option_handler_rules.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/option_handler_rules.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/option_handler_rules.h	2006-01-12 12:30:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/option_handler_rules.h	2006-01-29 01:44:50.000000000 +0800
@@ -34,58 +34,11 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_OPTION_HANDLER_RULES_H
 #define RTORRENT_OPTION_HANDLER_RULES_H
 
-#include <cstdio>
-#include <string>
-#include <stdexcept>
-#include <sigc++/bind.h>
-
 class Control;
 
 void initialize_option_handler(Control* c);
 
-class OptionHandlerInt {
-public:
-  typedef void (*Apply)(Control*, int);
-
-  OptionHandlerInt(Control* c, Apply a) :
-    m_control(c), m_apply(a) {}
-
-  virtual void process(const std::string& key, const std::string& arg);
-
-private:
-  Control* m_control;
-  Apply        m_apply;
-};
-
-class OptionHandlerOctal {
-public:
-  typedef void (*Apply)(Control*, int);
-
-  OptionHandlerOctal(Control* c, Apply a) :
-    m_control(c), m_apply(a) {}
-
-  virtual void process(const std::string& key, const std::string& arg);
-
-private:
-  Control* m_control;
-  Apply        m_apply;
-};
-
-class OptionHandlerString {
-public:
-  typedef void (*Apply)(Control*, const std::string&);
-
-  OptionHandlerString(Control* c, Apply a) :
-    m_control(c), m_apply(a) {}
-
-  virtual void process(const std::string& key, const std::string& arg);
-
-private:
-  Control*     m_control;
-  Apply        m_apply;
-};
-
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download.cc	2006-01-24 05:43:28.000000000 +0800
@@ -227,19 +227,31 @@
   m_focus->set_snubbed(!m_focus->is_snubbed());
 
   mark_dirty();
 }
 
 void
+Download::receive_next_priority() {
+  m_download->set_priority((m_download->priority() + 1) % 4);
+}
+
+void
+Download::receive_prev_priority() {
+  m_download->set_priority((m_download->priority() - 1) % 4);
+}
+
+void
 Download::bind_keys() {
   (*m_bindings)['1'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_uploads), -1);
   (*m_bindings)['2'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_uploads), 1);
   (*m_bindings)['3'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_min_peers), -5);
   (*m_bindings)['4'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_min_peers), 5);
   (*m_bindings)['5'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_peers), -5);
   (*m_bindings)['6'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_peers), 5);
+  (*m_bindings)['+'] = sigc::mem_fun(*this, &Download::receive_next_priority);
+  (*m_bindings)['-'] = sigc::mem_fun(*this, &Download::receive_prev_priority);
 
   (*m_bindings)['t'] = sigc::bind(sigc::mem_fun(m_download->get_download(), &torrent::Download::tracker_manual_request), false);
   (*m_bindings)['T'] = sigc::bind(sigc::mem_fun(m_download->get_download(), &torrent::Download::tracker_manual_request), true);
 
   (*m_bindings)['p'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_PEER_INFO);
   (*m_bindings)['o'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_TRACKER_LIST);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download.h	2006-01-24 05:45:46.000000000 +0800
@@ -85,12 +85,15 @@
   void                activate();
   void                disable();
 
   void                activate_display(Display d);
   void                disable_display();
 
+  void                receive_next_priority();
+  void                receive_prev_priority();
+
 private:
   Download(const Download&);
   void operator = (const Download&);
 
   void                receive_next();
   void                receive_prev();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download_list.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download_list.cc	2006-02-01 20:45:07.000000000 +0800
@@ -38,12 +38,13 @@
 
 #include <stdexcept>
 #include <rak/functional.h>
 #include <rak/string_manip.h>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
+#include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 
 #include "core/download.h"
 #include "core/manager.h"
 
 #include "input/bindings.h"
@@ -69,17 +70,17 @@
 DownloadList::DownloadList(Control* c) :
   m_state(DISPLAY_MAX_SIZE),
 
   m_window(c->display()->end()),
 
   m_windowTitle(new WTitle("rTorrent " VERSION " - libTorrent " + std::string(torrent::version()))),
-  m_windowHttpQueue(new WHttp(&c->core()->get_http_queue())),
+  m_windowHttpQueue(new WHttp(&c->core()->http_queue())),
 
   m_uiDownload(NULL),
 
-  m_downloadList(&c->core()->get_download_list()),
+  m_downloadList(&c->core()->download_list()),
 
   m_control(c),
   m_bindings(new input::Bindings)
 {
   m_uiArray[DISPLAY_DOWNLOAD_LIST] = new ElementDownloadList(&m_downloadList);
   m_uiArray[DISPLAY_LOG]           = new ElementLogComplete(&m_control->core()->get_log_complete());
@@ -120,23 +121,25 @@
   m_control->display()->push_front(m_windowLog);
   m_window = m_control->display()->insert(m_control->display()->begin(), NULL);
   m_control->display()->push_front(m_windowTitle);
 
   m_control->input()->push_front(m_bindings);
 
+  m_control->core()->download_list().slot_map_erase()["0_download_list"] = sigc::mem_fun(this, &DownloadList::receive_download_erased);
+
   activate_display(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::disable() {
   if (!is_active())
     throw std::logic_error("ui::Download::disable() called on an already disabled object");
 
   if (m_windowTextInput->is_active()) {
     m_windowTextInput->get_input()->clear();
-    receive_exit_input(true);
+    receive_exit_input(INPUT_NONE);
   }
 
   disable_display();
 
   priority_queue_erase(&taskScheduler, &m_taskUpdate);
 
@@ -231,57 +234,105 @@
   activate();
 
   m_control->display()->adjust_layout();
 }
 
 void
+DownloadList::receive_next_priority() {
+  if (m_downloadList.get_focus() == m_downloadList.end())
+    return;
+
+  (*m_downloadList.get_focus())->set_priority(((*m_downloadList.get_focus())->priority() + 1) % 4);
+}
+
+void
+DownloadList::receive_prev_priority() {
+  if (m_downloadList.get_focus() == m_downloadList.end())
+    return;
+
+  (*m_downloadList.get_focus())->set_priority(((*m_downloadList.get_focus())->priority() - 1) % 4);
+}
+
+void
 DownloadList::receive_check_hash() {
   if (m_downloadList.get_focus() == m_downloadList.end())
     return;
 
   m_control->core()->check_hash(*m_downloadList.get_focus());
 }
 
 void
-DownloadList::receive_view_input(bool useDefault) {
+DownloadList::receive_view_input(Input type) {
   if (m_windowTextInput->get_active())
     return;
 
   m_control->ui()->window_statusbar()->set_active(false);
   m_windowTextInput->set_active(true);
   m_control->display()->adjust_layout();
 
   m_control->input()->set_text_input(m_windowTextInput->get_input());
 
   m_windowTextInput->set_focus(true);
 
-  (*m_bindings)['\n'] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), useDefault);
-  (*m_bindings)[KEY_ENTER] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), useDefault);
+  if (type == INPUT_CHANGE_DIRECTORY) {
+    m_windowTextInput->get_input()->str() = m_control->variables()->get_string("directory");
+    m_windowTextInput->get_input()->set_pos(m_windowTextInput->get_input()->str().length());
+  }
+
+  (*m_bindings)['\n']      = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
+  (*m_bindings)[KEY_ENTER] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
+  (*m_bindings)['\x07']    = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), INPUT_NONE);
 }
 
 void
-DownloadList::receive_exit_input(bool useDefault) {
+DownloadList::receive_exit_input(Input type) {
   if (!m_windowTextInput->get_active())
     return;
 
   m_control->ui()->window_statusbar()->set_active(true);
   m_windowTextInput->set_active(false);
   m_control->input()->set_text_input();
+    
+  try {
 
-  m_control->core()->try_create_download_expand(m_windowTextInput->get_input()->str(), useDefault);
+    switch (type) {
+    case INPUT_NONE:
+      break;
+
+    case INPUT_LOAD_DEFAULT:
+    case INPUT_LOAD_MODIFIED:
+      m_control->core()->try_create_download_expand(m_windowTextInput->get_input()->str(), type == INPUT_LOAD_DEFAULT);
+      break;
+
+    case INPUT_CHANGE_DIRECTORY:
+      if (m_downloadList.get_focus() == m_downloadList.end())
+	throw torrent::input_error("No download in focus to change root directory.");
+
+      (*m_downloadList.get_focus())->variables()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
+      m_control->core()->push_log("New root dir \"" + (*m_downloadList.get_focus())->variables()->get_string("directory") + "\"");
+      break;
+
+    case INPUT_COMMAND:
+      m_control->variables()->process_command(m_windowTextInput->get_input()->str());
+      break;
+    }
+
+  } catch (torrent::input_error& e) {
+    m_control->core()->push_log(e.what());
+  }
 
   // Clean up.
   m_windowTextInput->get_input()->clear();
   m_windowTextInput->set_focus(false);
 
   m_bindings->erase('\n');
   m_bindings->erase(KEY_ENTER);
 
   // Urgh... this is ugly...
-  (*m_bindings)['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), false);
-  (*m_bindings)[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), false);
+  (*m_bindings)['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
+  (*m_bindings)[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
 
   receive_change(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::receive_change(Display d) {
@@ -290,28 +341,44 @@
 
   disable_display();
   activate_display(d);
 }
 
 void
+DownloadList::receive_download_erased(core::Download* d) {
+  if (m_downloadList.get_focus() == m_downloadList.end() ||
+      *m_downloadList.get_focus() != d)
+    return;
+
+  if (m_uiDownload != NULL)
+    receive_exit_download();
+
+  receive_next();
+}
+
+void
 DownloadList::task_update() {
   m_windowLog->receive_update();
 
   priority_queue_insert(&taskScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
 }
 
 void
 DownloadList::setup_keys() {
   (*m_bindings)['\x13']        = sigc::mem_fun(*this, &DownloadList::receive_start_download);
   (*m_bindings)['\x04']        = sigc::mem_fun(*this, &DownloadList::receive_stop_download);
   (*m_bindings)['\x12']        = sigc::mem_fun(*this, &DownloadList::receive_check_hash);
+  (*m_bindings)['+']           = sigc::mem_fun(*this, &DownloadList::receive_next_priority);
+  (*m_bindings)['-']           = sigc::mem_fun(*this, &DownloadList::receive_prev_priority);
 
-  (*m_bindings)['\x7f']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), true);
-  (*m_bindings)[KEY_BACKSPACE] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), true);
-  (*m_bindings)['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), false);
-  (*m_bindings)[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), false);
+  (*m_bindings)['\x7f']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
+  (*m_bindings)[KEY_BACKSPACE] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
+  (*m_bindings)['\n']          = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
+  (*m_bindings)[KEY_ENTER]     = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_MODIFIED);
+  (*m_bindings)['\x0F']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_CHANGE_DIRECTORY);
+  (*m_bindings)['\x10']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_COMMAND);
 
   (*m_bindings)[KEY_UP]        = sigc::mem_fun(*this, &DownloadList::receive_prev);
   (*m_bindings)[KEY_DOWN]      = sigc::mem_fun(*this, &DownloadList::receive_next);
   (*m_bindings)[KEY_RIGHT]     = sigc::mem_fun(*this, &DownloadList::receive_view_download);
   (*m_bindings)['l']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_LOG);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/download_list.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/download_list.h	2006-01-28 03:42:44.000000000 +0800
@@ -84,12 +84,20 @@
     DISPLAY_DOWNLOAD_LIST,
     DISPLAY_LOG,
     DISPLAY_STRING_LIST,
     DISPLAY_MAX_SIZE
   } Display;
 
+  typedef enum {
+    INPUT_NONE,
+    INPUT_LOAD_DEFAULT,
+    INPUT_LOAD_MODIFIED,
+    INPUT_CHANGE_DIRECTORY,
+    INPUT_COMMAND
+  } Input;
+
   DownloadList(Control* c);
   ~DownloadList();
 
   input::Bindings&    get_bindings()               { return *m_bindings; }
 
   bool                is_active() const            { return m_window != m_control->display()->end(); }
@@ -112,19 +120,24 @@
   void                receive_start_download();
   void                receive_stop_download();
 
   void                receive_view_download();
   void                receive_exit_download();
 
+  void                receive_next_priority();
+  void                receive_prev_priority();
+
   void                receive_check_hash();
 
-  void                receive_view_input(bool useDefault);
-  void                receive_exit_input(bool useDefault);
+  void                receive_view_input(Input type);
+  void                receive_exit_input(Input type);
 
   void                receive_change(Display d);
 
+  void                receive_download_erased(core::Download* d);
+
   void                task_update();
 
   void                setup_keys();
   void                setup_input();
 
   Display             m_state;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/root.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/root.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/ui/root.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/ui/root.cc	2006-01-31 01:19:57.000000000 +0800
@@ -105,14 +105,15 @@
   m_bindings['Z']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), -1);
   m_bindings['S']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), 5);
   m_bindings['X']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), -5);
   m_bindings['D']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), 50);
   m_bindings['C']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), -50);
 
-  m_bindings[KEY_RESIZE]    = sigc::mem_fun(*m_control->display(), &display::Manager::adjust_layout);
-  m_bindings['\x11']        = sigc::mem_fun(*m_control, &Control::receive_shutdown);
+  //m_bindings[KEY_RESIZE]    = sigc::mem_fun(*m_control->display(), &display::Manager::adjust_layout);
+  m_bindings['\x0C']        = sigc::mem_fun(m_control->display(), &display::Manager::force_redraw);
+  m_bindings['\x11']        = sigc::mem_fun(m_control, &Control::receive_normal_shutdown);
 }
 
 void
 Root::set_down_throttle(unsigned int throttle) {
   if (m_windowStatusbar != NULL)
     m_windowStatusbar->mark_dirty();
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils: lockfile.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils: lockfile.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/Makefile.am	2006-01-12 08:48:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/Makefile.am	2006-02-01 18:47:42.000000000 +0800
@@ -1,12 +1,14 @@
 noinst_LIBRARIES = libsub_utils.a
 
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
 	list_focus.h \
+	lockfile.cc \
+	lockfile.h \
 	variable.h \
 	variable_generic.cc \
 	variable_generic.h \
 	variable_map.cc \
 	variable_map.h
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/Makefile.in	2006-01-18 01:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/Makefile.in	2006-02-01 18:48:00.000000000 +0800
@@ -50,13 +50,13 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
 libsub_utils_a_AR = $(AR) $(ARFLAGS)
 libsub_utils_a_LIBADD =
-am_libsub_utils_a_OBJECTS = directory.$(OBJEXT) \
+am_libsub_utils_a_OBJECTS = directory.$(OBJEXT) lockfile.$(OBJEXT) \
 	variable_generic.$(OBJEXT) variable_map.$(OBJEXT)
 libsub_utils_a_OBJECTS = $(am_libsub_utils_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
@@ -155,12 +155,14 @@
 target_alias = @target_alias@
 noinst_LIBRARIES = libsub_utils.a
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
 	list_focus.h \
+	lockfile.cc \
+	lockfile.h \
 	variable.h \
 	variable_generic.cc \
 	variable_generic.h \
 	variable_map.cc \
 	variable_map.h
 
@@ -210,12 +212,13 @@
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directory.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lockfile.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable_generic.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable_map.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_generic.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_generic.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_generic.cc	2006-01-13 13:36:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_generic.cc	2006-02-05 03:35:49.000000000 +0800
@@ -33,24 +33,134 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <stdlib.h>
+
 #include "variable_generic.h"
 
 namespace utils {
 
+VariableAny::~VariableAny() {
+}
+
+const torrent::Bencode&
+VariableAny::get() {
+  return m_variable;
+}
+
+void
+VariableAny::set(const torrent::Bencode& arg) {
+  m_variable = arg;
+}
+
 VariableValue::~VariableValue() {
 }
 
 const torrent::Bencode&
 VariableValue::get() {
   return m_variable;
 }
 
 void
 VariableValue::set(const torrent::Bencode& arg) {
-  m_variable = arg;
+  uint64_t value;
+  const char* first;
+  char* last;
+
+  switch (arg.get_type()) {
+  case torrent::Bencode::TYPE_NONE:
+    m_variable = (int64_t)0;
+    break;
+
+  case torrent::Bencode::TYPE_VALUE:
+    m_variable = arg;
+    break;
+
+  case torrent::Bencode::TYPE_STRING:
+    first = arg.as_string().c_str();
+    value = strtoll(first, &last, 0);
+
+    if (last == first || *last != '\0')
+      throw torrent::input_error("Could not convert string to value.");
+
+    m_variable = value;
+    break;
+
+  default:
+    throw torrent::input_error("VariableValue unsupported type restriction.");
+  }
+}
+
+VariableBool::~VariableBool() {
+}
+
+const torrent::Bencode&
+VariableBool::get() {
+  return m_variable;
+}
+
+void
+VariableBool::set(const torrent::Bencode& arg) {
+  if (arg.is_value()) {
+    m_variable = arg.as_value() ? (int64_t)1 : (int64_t)0;
+
+  } else if (arg.is_string()) {
+
+    if (arg.as_string() == "yes" ||
+	arg.as_string() == "true")
+      m_variable = (int64_t)1;
+
+    else if (arg.as_string() == "no" ||
+	     arg.as_string() == "false")
+      m_variable = (int64_t)0;
+
+    else
+      throw torrent::input_error("String does not parse as a boolean.");
+
+  } else {
+    throw torrent::input_error("Input is not a boolean.");
+  }
+}
+
+VariableBencode::~VariableBencode() {
+}
+
+const torrent::Bencode&
+VariableBencode::get() {
+  if (m_root.empty())
+    return m_bencode->get_key(m_key);
+  else
+    return m_bencode->get_key(m_root).get_key(m_key);
+}
+
+void
+VariableBencode::set(const torrent::Bencode& arg) {
+  // Consider removing if TYPE_NONE.
+  torrent::Bencode* root;
+
+  if (m_root.empty())
+    root = m_bencode;
+  else
+    root = &m_bencode->get_key(m_root);
+
+  switch (m_type) {
+  case torrent::Bencode::TYPE_NONE:
+    root->insert_key(m_key, arg);
+    break;
+
+  case torrent::Bencode::TYPE_STRING:
+    if (arg.get_type() == torrent::Bencode::TYPE_STRING)
+      root->insert_key(m_key, arg);
+    else
+      throw torrent::input_error("VariableBencode could not convert to string.");
+      
+    break;
+
+  default:
+    throw torrent::input_error("VariableBencode unsupported type restriction.");
+  }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_generic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_generic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_generic.h	2006-01-14 11:36:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_generic.h	2006-01-29 07:40:02.000000000 +0800
@@ -31,12 +31,15 @@
 //
 // Contact:  Jari Sundell <jaris@ifi.uio.no>
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
+// Parts of this seems ugly in an attempt to avoid copying
+// data. Propably need to rewrite torrent::Bencode.
+
 #ifndef RTORRENT_UTILS_VARIABLE_GENERIC_H
 #define RTORRENT_UTILS_VARIABLE_GENERIC_H
 
 #include <cstdio>
 #include <string>
 #include <limits>
@@ -46,24 +49,71 @@
 #include <torrent/exceptions.h>
 
 #include "variable.h"
 
 namespace utils {
 
+class VariableAny : public Variable {
+public:
+  VariableAny(const torrent::Bencode& v = torrent::Bencode()) :
+    m_variable(v) {}
+  virtual ~VariableAny();
+
+  virtual const torrent::Bencode& get();
+  virtual void                    set(const torrent::Bencode& arg);
+
+private:
+  torrent::Bencode    m_variable;
+};
+
 class VariableValue : public Variable {
 public:
-  VariableValue(const torrent::Bencode& v = torrent::Bencode()) : m_variable(v) {}
+  VariableValue(int64_t v) : m_variable(v) {}
   virtual ~VariableValue();
 
   virtual const torrent::Bencode& get();
+  virtual void                    set(const torrent::Bencode& arg);
+
+private:
+  torrent::Bencode    m_variable;
+};
+
+class VariableBool : public Variable {
+public:
+  VariableBool(bool state) : m_variable(state ? (int64_t)1 : (int64_t)0) {}
+  VariableBool(const torrent::Bencode& v = torrent::Bencode((int64_t)0)) { set(v); }
+  virtual ~VariableBool();
+
+  virtual const torrent::Bencode& get();
   virtual void        set(const torrent::Bencode& arg);
 
 private:
   torrent::Bencode    m_variable;
 };
 
+class VariableBencode : public Variable {
+public:
+  typedef torrent::Bencode::Type Type;
+
+  VariableBencode(torrent::Bencode* b,
+		  const std::string& root,
+		  const std::string& key,
+		  Type t = torrent::Bencode::TYPE_NONE) :
+    m_bencode(b), m_root(root), m_key(key), m_type(t) {}
+  virtual ~VariableBencode();
+
+  virtual const torrent::Bencode& get();
+  virtual void        set(const torrent::Bencode& arg);
+
+private:
+  torrent::Bencode*   m_bencode;
+  std::string         m_root;
+  std::string         m_key;
+  Type                m_type;
+};
+
 template <typename Get = std::string, typename Set = const std::string&>
 class VariableSlotString : public Variable {
 public:
   typedef rak::function0<Get>       SlotGet;
   typedef rak::function1<void, Set> SlotSet;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable.h	2006-01-13 08:05:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable.h	2006-01-29 07:30:53.000000000 +0800
@@ -34,25 +34,27 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UTILS_VARIABLE_H
 #define RTORRENT_UTILS_VARIABLE_H
 
+#include <string>
+
 namespace torrent {
   class Bencode;
 }
 
 namespace utils {
 
 class Variable {
 public:
   Variable() {}
   virtual ~Variable() {}
 
   virtual const torrent::Bencode& get() = 0;
-  virtual void set(const torrent::Bencode& arg) = 0;
+  virtual void                    set(const torrent::Bencode& arg) = 0;
 
 protected:
   Variable(const Variable&);
   void operator = (const Variable&);
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_map.cc	2006-01-18 00:26:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_map.cc	2006-01-30 23:06:14.000000000 +0800
@@ -33,12 +33,13 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <cctype>
 #include <algorithm>
 #include <rak/functional.h>
 #include <torrent/exceptions.h>
 #include <torrent/bencode.h>
 
 #include "variable.h"
@@ -57,24 +58,24 @@
   if (itr != base_type::end())
     throw torrent::internal_error("VariableMap::insert(...) tried to insert an already existing key.");
 
   base_type::insert(itr, value_type(key, v));
 }
 
-const torrent::Bencode&
+const VariableMap::mapped_type&
 VariableMap::get(const std::string& key) {
   iterator itr = base_type::find(key);
 
   if (itr == base_type::end())
     throw torrent::input_error("Variable \"" + key + "\" does not exist.");
 
   return itr->second->get();
 }
 
 void
-VariableMap::set(const std::string& key, const torrent::Bencode& arg) {
+VariableMap::set(const std::string& key, const mapped_type& arg) {
   iterator itr = base_type::find(key);
 
   // Later, allow the user to create new variables. Have a slot to
   // register that thing.
   if (itr == base_type::end())
     throw torrent::input_error("Variable \"" + key + "\" does not exist.");
@@ -91,13 +92,13 @@
     dest->push_back(*first);
 
   return first;
 }
 
 std::string::const_iterator
-parse_unknown(std::string::const_iterator first, std::string::const_iterator last, torrent::Bencode* dest) {
+parse_unknown(std::string::const_iterator first, std::string::const_iterator last, VariableMap::mapped_type* dest) {
   if (*first == '"') {
     std::string::const_iterator next = std::find_if(++first, last, std::bind2nd(std::equal_to<char>(), '"'));
     
     if (first == last ||
 	first == next ||
 	next == last)
@@ -113,17 +114,17 @@
     *dest = std::string(first, next);
     return next;
   }
 }
 
 std::string::const_iterator
-parse_args(std::string::const_iterator first, std::string::const_iterator last, torrent::Bencode::List* dest) {
+parse_args(std::string::const_iterator first, std::string::const_iterator last, VariableMap::mapped_type::List* dest) {
   first = std::find_if(first, last, std::not1(std::ptr_fun(&std::isspace)));
 
   while (first != last) {
-    dest->push_back(torrent::Bencode());
+    dest->push_back(VariableMap::mapped_type());
 
     first = parse_unknown(first, last, &dest->back());
     first = std::find_if(first, last, std::not1(std::ptr_fun(&std::isspace)));
 
     if (first != last && *first != ',')
       throw torrent::input_error("A string with blanks must be quoted.");
@@ -145,17 +146,17 @@
   pos = parse_name(pos, command.end(), &key);
   pos = std::find_if(pos, command.end(), std::not1(std::ptr_fun(&std::isspace)));
   
   if (pos == command.end() || *pos != '=')
     throw torrent::input_error("Could not find '='.");
 
-  torrent::Bencode args(torrent::Bencode::TYPE_LIST);
+  mapped_type args(mapped_type::TYPE_LIST);
   parse_args(pos + 1, command.end(), &args.as_list());
 
   if (args.as_list().empty())
-    set(key, torrent::Bencode());
+    set(key, mapped_type());
 
   else if (++args.as_list().begin() == args.as_list().end())
     set(key, *args.as_list().begin());
 
   else
     set(key, args);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.3/src/utils/variable_map.h	2006-01-13 09:47:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.4/src/utils/variable_map.h	2006-01-29 05:28:39.000000000 +0800
@@ -45,27 +45,29 @@
 
 class Variable;
 
 class VariableMap : public std::map<std::string, Variable*> {
 public:
   typedef std::map<std::string, Variable*> base_type;
+  typedef torrent::Bencode                 mapped_type;
 
   using base_type::iterator;
   using base_type::value_type;
 
   VariableMap() {}
   ~VariableMap();
 
   void                insert(const std::string& key, Variable* v);
 
   // Consider taking char* start and finish instead of std::string to
   // avoid copying. Or make a view class.
-  const torrent::Bencode& get(const std::string& key);
+  const mapped_type&  get(const std::string& key);
+  const std::string&  get_string(const std::string& key)                         { return get(key).as_string(); }
 
-  void                set(const std::string& key, const torrent::Bencode& arg);
-  void                set_string(const std::string& key, const std::string& arg) { set(key, torrent::Bencode(arg)); }
+  void                set(const std::string& key, const mapped_type& arg);
+  void                set_string(const std::string& key, const std::string& arg) { set(key, mapped_type(arg)); }
 
   // Temporary.
   void                process_command(const std::string& command);
 
 private:
   VariableMap(const VariableMap&);
