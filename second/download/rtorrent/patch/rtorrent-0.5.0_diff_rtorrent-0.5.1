diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/config.h.in	2006-04-01 04:39:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/config.h.in	2006-05-02 00:47:02.000000000 +0800
@@ -51,12 +51,15 @@
 /* Define to the one symbol short name of this package. */
 #undef PACKAGE_TARNAME
 
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
+/* enable ipv6 stuff */
+#undef RAK_USE_INET6
+
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
 /* Define this if the compiler supports the unused attribute */
 #undef SUPPORT_ATTRIBUTE_UNUSED
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure	2006-04-07 01:38:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure	2006-05-02 00:47:12.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.5.0.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.5.1.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -420,14 +420,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.5.0'
-PACKAGE_STRING='rtorrent 0.5.0'
+PACKAGE_VERSION='0.5.1'
+PACKAGE_STRING='rtorrent 0.5.1'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -950,13 +950,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.5.0 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.5.1 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1016,22 +1016,23 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.5.0:";;
+     short | recursive ) echo "Configuration of rtorrent 0.5.1:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-debug          enable debug information [default=yes]
   --enable-extra-debug    enable extra debugging checks. [default=no]
   --enable-werror         enable the -Werror and -Wall flag [default=no]
+  --enable-ipv6           disable ipv6 [default=no]
   --disable-dependency-tracking  speeds up one-time build
   --enable-dependency-tracking   do not reject slow dependency extractors
   --enable-shared[=PKGS]
                           build shared libraries [default=yes]
   --enable-static[=PKGS]
                           build static libraries [default=yes]
@@ -1046,12 +1047,13 @@
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]
   --with-pic              try to use only PIC/non-PIC objects [default=use
                           both]
   --with-tags[=TAGS]
                           include additional configurations [automatic]
   --without-variable-fdset       do not use non-portable variable sized fd_set's.
+  --without-ncursesw      Don't try to use wide char ncurses.
 
 Some influential environment variables:
   CXX         C++ compiler command
   CXXFLAGS    C++ compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
               nonstandard directory <lib dir>
@@ -1160,13 +1162,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.5.0
+rtorrent configure 0.5.1
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1174,13 +1176,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.5.0, which was
+It was created by rtorrent $as_me 0.5.1, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1818,13 +1820,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.5.0'
+ VERSION='0.5.1'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -2009,12 +2011,28 @@
             CXXFLAGS="$CXXFLAGS -Werror -Wall"
         fi
 
 fi;
 
 
+
+  # Check whether --enable-ipv6 or --disable-ipv6 was given.
+if test "${enable_ipv6+set}" = set; then
+  enableval="$enable_ipv6"
+
+        if test "$enableval" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define RAK_USE_INET6 1
+_ACEOF
+
+        fi
+
+fi;
+
+
 ac_ext=cc
 ac_cpp='$CXXCPP $CPPFLAGS'
 ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
 if test -n "$ac_tool_prefix"; then
@@ -4185,13 +4203,13 @@
     esac
   fi
   rm -rf conftest*
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 4191 "configure"' > conftest.$ac_ext
+  echo '#line 4209 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
    if test "$lt_cv_prog_gnu_ld" = yes; then
@@ -5293,13 +5311,13 @@
 
   F77=$ac_ct_F77
 fi
 
 
 # Provide some information about the compiler.
-echo "$as_me:5299:" \
+echo "$as_me:5317:" \
      "checking for Fortran 77 compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
 { (eval echo "$as_me:$LINENO: \"$ac_compiler --version </dev/null >&5\"") >&5
   (eval $ac_compiler --version </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
@@ -6327,17 +6345,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:6333: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:6351: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:6337: \$? = $ac_status" >&5
+   echo "$as_me:6355: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s conftest.err; then
        lt_cv_prog_compiler_rtti_exceptions=yes
      fi
@@ -6560,17 +6578,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:6566: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:6584: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:6570: \$? = $ac_status" >&5
+   echo "$as_me:6588: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s conftest.err; then
        lt_prog_compiler_pic_works=yes
      fi
@@ -6620,17 +6638,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:6626: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:6644: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:6630: \$? = $ac_status" >&5
+   echo "$as_me:6648: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s out/conftest.err; then
        lt_cv_prog_compiler_c_o=yes
@@ -7954,13 +7972,13 @@
   hardcode_into_libs=yes
 
   # find out which ABI we are using
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 7960 "configure"' > conftest.$ac_ext
+    echo '#line 7978 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
       case `/usr/bin/file conftest.$ac_objext` in
@@ -8825,13 +8843,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 8831 "configure"
+#line 8849 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -8923,13 +8941,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self_static=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 8929 "configure"
+#line 8947 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -11102,17 +11120,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11108: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11126: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:11112: \$? = $ac_status" >&5
+   echo "$as_me:11130: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s conftest.err; then
        lt_prog_compiler_pic_works_CXX=yes
      fi
@@ -11162,17 +11180,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:11168: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:11186: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:11172: \$? = $ac_status" >&5
+   echo "$as_me:11190: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s out/conftest.err; then
        lt_cv_prog_compiler_c_o_CXX=yes
@@ -11673,13 +11691,13 @@
   hardcode_into_libs=yes
 
   # find out which ABI we are using
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 11679 "configure"' > conftest.$ac_ext
+    echo '#line 11697 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
       case `/usr/bin/file conftest.$ac_objext` in
@@ -12544,13 +12562,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 12550 "configure"
+#line 12568 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -12642,13 +12660,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self_static=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 12648 "configure"
+#line 12666 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -13469,17 +13487,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13475: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13493: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:13479: \$? = $ac_status" >&5
+   echo "$as_me:13497: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s conftest.err; then
        lt_prog_compiler_pic_works_F77=yes
      fi
@@ -13529,17 +13547,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13535: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13553: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:13539: \$? = $ac_status" >&5
+   echo "$as_me:13557: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s out/conftest.err; then
        lt_cv_prog_compiler_c_o_F77=yes
@@ -14843,13 +14861,13 @@
   hardcode_into_libs=yes
 
   # find out which ABI we are using
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 14849 "configure"' > conftest.$ac_ext
+    echo '#line 14867 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
       case `/usr/bin/file conftest.$ac_objext` in
@@ -15584,17 +15602,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15590: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15608: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:15594: \$? = $ac_status" >&5
+   echo "$as_me:15612: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s conftest.err; then
        lt_cv_prog_compiler_rtti_exceptions=yes
      fi
@@ -15817,17 +15835,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15823: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15841: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:15827: \$? = $ac_status" >&5
+   echo "$as_me:15845: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s conftest.err; then
        lt_prog_compiler_pic_works_GCJ=yes
      fi
@@ -15877,17 +15895,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}? :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:15883: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:15901: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:15887: \$? = $ac_status" >&5
+   echo "$as_me:15905: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      if test ! -s out/conftest.err; then
        lt_cv_prog_compiler_c_o_GCJ=yes
@@ -17211,13 +17229,13 @@
   hardcode_into_libs=yes
 
   # find out which ABI we are using
   libsuff=
   case "$host_cpu" in
   x86_64*|s390x*|powerpc64*)
-    echo '#line 17217 "configure"' > conftest.$ac_ext
+    echo '#line 17235 "configure"' > conftest.$ac_ext
     if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
       case `/usr/bin/file conftest.$ac_objext` in
@@ -18082,13 +18100,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 18088 "configure"
+#line 18106 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -18180,13 +18198,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self_static=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 18186 "configure"
+#line 18204 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -19560,13 +19578,201 @@
 fi
 rm -f conftest*
 fi
 
 
 
-echo "$as_me:$LINENO: checking for library containing add_wch" >&5
+  echo "$as_me:$LINENO: checking for execinfo.h" >&5
+echo $ECHO_N "checking for execinfo.h... $ECHO_C" >&6
+
+  cat >conftest.$ac_ext <<_ACEOF
+#include <execinfo.h>
+      int main() { backtrace((void**)0, 0); backtrace_symbols((char**)0, 0); return 0;}
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+      echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+cat >>confdefs.h <<\_ACEOF
+#define USE_EXECINFO 1
+_ACEOF
+
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+      echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+
+
+  if test "${my_cv_curl_vers+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+    my_cv_curl_vers=NONE
+        check="7.12.0"
+        check_hex="070C00"
+
+    echo "$as_me:$LINENO: checking for curl >= $check" >&5
+echo $ECHO_N "checking for curl >= $check... $ECHO_C" >&6
+
+    if eval curl-config --version 2>/dev/null >/dev/null; then
+      ver=`curl-config --version | sed -e "s/libcurl //g"`
+      hex_ver=`curl-config --vernum | tr 'a-f' 'A-F'`
+      ok=`echo "ibase=16; if($hex_ver>=$check_hex) $hex_ver else 0" | bc`
+
+      if test x$ok != x0; then
+        my_cv_curl_vers="$ver"
+        echo "$as_me:$LINENO: result: $my_cv_curl_vers" >&5
+echo "${ECHO_T}$my_cv_curl_vers" >&6
+
+	CURL_CFLAGS=`curl-config --cflags`
+	CURL_LIBS=`curl-config --libs`
+      else
+        echo "$as_me:$LINENO: result: FAILED" >&5
+echo "${ECHO_T}FAILED" >&6
+        { { echo "$as_me:$LINENO: error: $ver is too old. Need version $check or higher." >&5
+echo "$as_me: error: $ver is too old. Need version $check or higher." >&2;}
+   { (exit 1); exit 1; }; }
+      fi
+    else
+      echo "$as_me:$LINENO: result: FAILED" >&5
+echo "${ECHO_T}FAILED" >&6
+      { { echo "$as_me:$LINENO: error: curl-config was not found" >&5
+echo "$as_me: error: curl-config was not found" >&2;}
+   { (exit 1); exit 1; }; }
+    fi
+
+fi
+
+
+
+  ac_ext=cc
+ac_cpp='$CXXCPP $CPPFLAGS'
+ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
+
+  echo "$as_me:$LINENO: checking for proper overloaded template function disambiguation" >&5
+echo $ECHO_N "checking for proper overloaded template function disambiguation... $ECHO_C" >&6
+
+  cat >conftest.$ac_ext <<_ACEOF
+template <typename T> void f(T&) {}
+      template <typename T> void f(T*) {}
+      int main() { int *i = 0; f(*i); f(i); }
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_cxx_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+      echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+
+      echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+      { { echo "$as_me:$LINENO: error: your compiler does not properly handle overloaded template function disambiguation" >&5
+echo "$as_me: error: your compiler does not properly handle overloaded template function disambiguation" >&2;}
+   { (exit 1); exit 1; }; }
+
+fi
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+
+  ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+
+# Check whether --with-variable-fdset or --without-variable-fdset was given.
+if test "${with_variable_fdset+set}" = set; then
+  withval="$with_variable_fdset"
+
+      if test "$withval" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define USE_VARIABLE_FDSET 1
+_ACEOF
+
+      fi
+
+else
+
+
+cat >>confdefs.h <<\_ACEOF
+#define USE_VARIABLE_FDSET 1
+_ACEOF
+
+
+fi;
+
+
+
+# Check whether --with-ncursesw or --without-ncursesw was given.
+if test "${with_ncursesw+set}" = set; then
+  withval="$with_ncursesw"
+
+      if test "$withval" = "no"; then
+	echo "$as_me:$LINENO: checking for library containing add_wch" >&5
 echo $ECHO_N "checking for library containing add_wch... $ECHO_C" >&6
 if test "${ac_cv_search_add_wch+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_add_wch=no
@@ -19820,25 +20026,45 @@
   echo "*** The ncurses library is required!";exit 1
 fi
 
 
 fi
 
+      else
+	echo "$as_me:$LINENO: checking for library containing wbkgdset" >&5
+echo $ECHO_N "checking for library containing wbkgdset... $ECHO_C" >&6
+if test "${ac_cv_search_wbkgdset+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_wbkgdset=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-
-  echo "$as_me:$LINENO: checking for execinfo.h" >&5
-echo $ECHO_N "checking for execinfo.h... $ECHO_C" >&6
-
-  cat >conftest.$ac_ext <<_ACEOF
-#include <execinfo.h>
-      int main() { backtrace((void**)0, 0); backtrace_symbols((char**)0, 0); return 0;}
-
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char wbkgdset ();
+int
+main ()
+{
+wbkgdset ();
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
@@ -19846,165 +20072,358 @@
 			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-
-      echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-
-cat >>confdefs.h <<\_ACEOF
-#define USE_EXECINFO 1
-_ACEOF
-
-
+  ac_cv_search_wbkgdset="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
-      echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-
 fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-
-
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_wbkgdset" = no; then
+  for ac_lib in ncurses curses; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-  if test "${my_cv_curl_vers+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char wbkgdset ();
+int
+main ()
+{
+wbkgdset ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_wbkgdset="-l$ac_lib"
+break
 else
-
-    my_cv_curl_vers=NONE
-        check="7.12.0"
-        check_hex="070C00"
-
-    echo "$as_me:$LINENO: checking for curl >= $check" >&5
-echo $ECHO_N "checking for curl >= $check... $ECHO_C" >&6
-
-    if eval curl-config --version 2>/dev/null >/dev/null; then
-      ver=`curl-config --version | sed -e "s/libcurl //g"`
-      hex_ver=`curl-config --vernum | tr 'a-f' 'A-F'`
-      ok=`echo "ibase=16; if($hex_ver>=$check_hex) $hex_ver else 0" | bc`
-
-      if test x$ok != x0; then
-        my_cv_curl_vers="$ver"
-        echo "$as_me:$LINENO: result: $my_cv_curl_vers" >&5
-echo "${ECHO_T}$my_cv_curl_vers" >&6
-
-	CURL_CFLAGS=`curl-config --cflags`
-	CURL_LIBS=`curl-config --libs`
-      else
-        echo "$as_me:$LINENO: result: FAILED" >&5
-echo "${ECHO_T}FAILED" >&6
-        { { echo "$as_me:$LINENO: error: $ver is too old. Need version $check or higher." >&5
-echo "$as_me: error: $ver is too old. Need version $check or higher." >&2;}
-   { (exit 1); exit 1; }; }
-      fi
-    else
-      echo "$as_me:$LINENO: result: FAILED" >&5
-echo "${ECHO_T}FAILED" >&6
-      { { echo "$as_me:$LINENO: error: curl-config was not found" >&5
-echo "$as_me: error: curl-config was not found" >&2;}
-   { (exit 1); exit 1; }; }
-    fi
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_wbkgdset" >&5
+echo "${ECHO_T}$ac_cv_search_wbkgdset" >&6
+if test "$ac_cv_search_wbkgdset" != no; then
+  test "$ac_cv_search_wbkgdset" = "none required" || LIBS="$ac_cv_search_wbkgdset $LIBS"
 
+else
+  echo "*** The ncurses library is required!";exit 1
+fi
 
+      fi
 
-  ac_ext=cc
-ac_cpp='$CXXCPP $CPPFLAGS'
-ac_compile='$CXX -c $CXXFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CXX -o conftest$ac_exeext $CXXFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_cxx_compiler_gnu
-
-  echo "$as_me:$LINENO: checking for proper overloaded template function disambiguation" >&5
-echo $ECHO_N "checking for proper overloaded template function disambiguation... $ECHO_C" >&6
+else
 
-  cat >conftest.$ac_ext <<_ACEOF
-template <typename T> void f(T&) {}
-      template <typename T> void f(T*) {}
-      int main() { int *i = 0; f(*i); f(i); }
+      echo "$as_me:$LINENO: checking for library containing add_wch" >&5
+echo $ECHO_N "checking for library containing add_wch... $ECHO_C" >&6
+if test "${ac_cv_search_add_wch+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_add_wch=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char add_wch ();
+int
+main ()
+{
+add_wch ();
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>conftest.er1
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_cxx_werror_flag"
+	 { ac_try='test -z "$ac_c_werror_flag"
 			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-
-      echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-
+  ac_cv_search_add_wch="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-
-      echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
-      { { echo "$as_me:$LINENO: error: your compiler does not properly handle overloaded template function disambiguation" >&5
-echo "$as_me: error: your compiler does not properly handle overloaded template function disambiguation" >&2;}
-   { (exit 1); exit 1; }; }
-
 fi
-rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
-
-  ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_add_wch" = no; then
+  for ac_lib in ncursesw; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char add_wch ();
+int
+main ()
+{
+add_wch ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_add_wch="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_add_wch" >&5
+echo "${ECHO_T}$ac_cv_search_add_wch" >&6
+if test "$ac_cv_search_add_wch" != no; then
+  test "$ac_cv_search_add_wch" = "none required" || LIBS="$ac_cv_search_add_wch $LIBS"
 
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_NCURSESW 1
+_ACEOF
 
+else
+  echo "$as_me:$LINENO: checking for library containing wbkgdset" >&5
+echo $ECHO_N "checking for library containing wbkgdset... $ECHO_C" >&6
+if test "${ac_cv_search_wbkgdset+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_func_search_save_LIBS=$LIBS
+ac_cv_search_wbkgdset=no
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-# Check whether --with-variable-fdset or --without-variable-fdset was given.
-if test "${with_variable_fdset+set}" = set; then
-  withval="$with_variable_fdset"
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char wbkgdset ();
+int
+main ()
+{
+wbkgdset ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_wbkgdset="none required"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-      if test "$withval" = "yes"; then
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+if test "$ac_cv_search_wbkgdset" = no; then
+  for ac_lib in ncurses curses; do
+    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
 
-cat >>confdefs.h <<\_ACEOF
-#define USE_VARIABLE_FDSET 1
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char wbkgdset ();
+int
+main ()
+{
+wbkgdset ();
+  ;
+  return 0;
+}
 _ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"
+			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_search_wbkgdset="-l$ac_lib"
+break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-      fi
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+  done
+fi
+LIBS=$ac_func_search_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_search_wbkgdset" >&5
+echo "${ECHO_T}$ac_cv_search_wbkgdset" >&6
+if test "$ac_cv_search_wbkgdset" != no; then
+  test "$ac_cv_search_wbkgdset" = "none required" || LIBS="$ac_cv_search_wbkgdset $LIBS"
 
 else
+  echo "*** The ncurses library is required!";exit 1
+fi
 
 
-cat >>confdefs.h <<\_ACEOF
-#define USE_VARIABLE_FDSET 1
-_ACEOF
+fi
 
 
 fi;
 
 
 
@@ -20562,13 +20981,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.5.0, which was
+This file was extended by rtorrent $as_me 0.5.1, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -20625,13 +21044,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.5.0
+rtorrent config.status 0.5.1
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure.ac	2006-03-18 06:41:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure.ac	2006-05-02 00:28:12.000000000 +0800
@@ -1,31 +1,28 @@
-AC_INIT(rtorrent, 0.5.0, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.5.1, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
 TORRENT_ENABLE_EXTRA_DEBUG()
 TORRENT_ENABLE_WERROR()
 
+TORRENT_DISABLE_IPV6
+
 AC_PROG_CXX
 AC_PROG_LIBTOOL
 AC_SYS_LARGEFILE
 
-
-AC_SEARCH_LIBS(add_wch, ncursesw,
-  AC_DEFINE(HAVE_NCURSESW, 1, defined if ncurses wide character support is available),
-  AC_SEARCH_LIBS(wbkgdset, ncurses curses,,echo "*** The ncurses library is required!";exit 1)
-)
-
 TORRENT_CHECK_EXECINFO()
 TORRENT_CHECK_CURL()
 TORRENT_OTFD()
 
 TORRENT_WITHOUT_VARIABLE_FDSET()
+TORRENT_WITHOUT_NCURSESW()
 
 PKG_CHECK_MODULES(STUFF, sigc++-2.0 libtorrent >= 0.9.0,
 	          CXXFLAGS="$CXXFLAGS $STUFF_CFLAGS $CURL_CFLAGS";
 		  LIBS="$LIBS $STUFF_LIBS $CURL_LIBS")
 
 AC_DEFINE(HAVE_CONFIG_H, 1, true if config.h was included)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1	2006-04-06 23:49:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1	2006-05-04 02:31:41.000000000 +0800
@@ -1,12 +1,12 @@
 .\" This manpage has been automatically generated by docbook2man 
 .\" from a DocBook document.  This tool can be found at:
 .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
 .\" Please send any bug reports, improvements, comments, patches, 
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
-.TH "RTORRENT" "1" "06 April 2006" "BitTorrent client for ncurses" ""
+.TH "RTORRENT" "1" "03 May 2006" "BitTorrent client for ncurses" ""
 
 .SH NAME
 rtorrent \- a BitTorrent client for ncurses
 .SH SYNOPSIS
 
 \fBrtorrent\fR [ \fB-h\fR ] [ \fB-o key1=opt1,...\fR ] [ \fB-O key=opt\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
@@ -45,12 +45,15 @@
 Decrease the download throttle by 1/5/50 KB.
 .SS "MAIN VIEW KEYS"
 .TP
 \fB->\fR
 View download.
 .TP
+\fB1 - 6\fR
+Change view.
+.TP
 \fB^s\fR
 Start download.
 .TP
 \fB^d\fR
 Stop an active download, or remove a stopped download.
 .TP
@@ -105,13 +108,13 @@
 the "min interval" set by the tracker.
 .TP
 \fBk\fR
 Disconnect peer.
 .TP
 \fB*\fR
-Choke/Snubb peer.
+Choke/Snub peer.
 .SH "OPTIONS"
 .TP
 \fB-b \fIa.b.c.d\fB\fR
 Bind listening socket and outgoing connections to this network
 interface address.
 .TP
@@ -161,12 +164,14 @@
 .TP
 \fBbind = \fIa.b.c.d\fB\fR
 Bind listening socket and outgoing connections to this network
 interface address.
 .TP
 \fBip = \fIa.b.c.d\fB\fR
+.TP
+\fBip = \fIhostname\fB\fR
 Set the address reported to the tracker.
 .TP
 \fBport_range = \fIa-b\fB\fR
 Try to open a listening port in the range \fBa\fR up to
 and including \fBb\fR\&.
 .TP
@@ -214,23 +219,59 @@
 Stop or remove the torrents that are tied to filenames that have been
 deleted, the association is then cleared.
 .TP
 \fBload = \fIfile\fB\fR
 .TP
 \fBload_start = \fIfile\fB\fR
-Load and possibly start a file, or possibly mutiple files by using the
-wildcard "*". This is meant for use with
+Load and possibly start a file, or possibly multiple files by using the
+wild-card "*". This is meant for use with
 \fBschedule\fR, though ensure that the
 \fBstart\fR is non-zero. The loaded file will be tied
 to the filename provided.
 .TP
 \fBimport = \fIfile\fB\fR
 .TP
 \fBtry_import = \fIfile\fB\fR
 Load a resource file. \fBtry_import\fR does not throw
 torrent::input_error exception on bad input.
+.SH "DISPLAY SETTINGS"
+.PP
+Display related settings.
+.TP
+\fBview_add = \fIname\fB\fR
+Create a new view.
+.TP
+\fBview_sort = \fIname\fB\fR
+.TP
+\fBview_sort = \fIname\fB,\fIseconds\fB\fR
+Sort a view according the the criteria set by
+\fBview_sort_current\fR\&. If the optional argument is
+supplied, the view is not sorted if a change happened during the last
+\fBseconds\fR\&. This command is meant to be used with
+\fBschedule\fR\&.
+.TP
+\fBview_sort_new = \fIname\fB,\fI\&...\fB\fR
+.TP
+\fBview_sort_current = \fIname\fB,\fI\&...\fB\fR
+Set the sorting criteria for when new elements inserted or
+\fBview_sort\fR is called. The list can contain any
+number of criteria, including zero, from the following:
+
+\fBname\fR, \fBname_reverse\fR,
+\fBstopped\fR, \fBstarted\fR,
+\fBcomplete\fR, \fBincomplete\fR,
+\fBstate_changed\fR,
+\fBstate_changed_reverse\fR
+.TP
+\fBview_filter = \fIname\fB,\fI\&...\fB\fR
+Set a list of filter to apply when new new downloads are added and
+when \fBview_sort\fR gets called. All filters must
+match for the download to be included.
+
+\fBstopped\fR, \fBstarted\fR,
+\fBcomplete\fR, \fBincomplete\fR,
 .SH "ADVANCED SETTINGS"
 .PP
 This list contains settings users shouldn't need to touch.
 .TP
 \fBhash_read_ahead = \fIMB\fB\fR
 Configure how far ahead we ask the kernel to read when doing hash
@@ -261,17 +302,27 @@
 .TP
 \fBworking_directory = \fIdirectory\fB\fR
 Changes the working directory of the process using
 \fBchdir\fR\&.
 .TP
 \fBsession_on_completion = \fIyes\fB\fR
-Controls whetever the session torrent is updated when a torrent
-finishes. By default on.
+Controls if the session torrent is saved when a torrent finishes. By
+default on.
 .TP
 \fBsession_lock = \fIyes\fB\fR
-Controls whetever a lock file is created in the session directory.
+Controls if a lock file is created in the session directory on startup.
+.TP
+\fBsession_save = \fR
+Save the session files for all downloads.
+.TP
+\fBuse_udp_trackers = \fIyes\fB\fR
+Use UDP trackers. Disable if you are behind a firewall etc that does
+not allow connections to UDP trackers.
+.TP
+\fBenable_trackers = \fIyes\fB\fR
+Set to \fBno\fR to disable tracker requests.
 .TP
 \fBtracker_dump = \fIfilename\fB\fR
 Dump tracker requests to \fBfilename\fR, disable by
 supplying an empty string. Only torrents loaded while
 \fBtracker_dump\fR contains a non-empty string will be
 logged at the moment, although disabling it will work as expected.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1.xml	2006-04-06 23:49:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1.xml	2006-05-04 02:31:38.000000000 +0800
@@ -117,12 +117,21 @@
 	  <listitem><para>
             View download.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
+	  <term>1 - 6</term>
+	  <listitem><para>
+
+Change view.
+
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
 	  <term>^s</term>
 	  <listitem><para>
             Start download.
           </para></listitem>
 	</varlistentry>
 
@@ -266,13 +275,13 @@
 	</varlistentry>
 
 	<varlistentry>
 	  <term>*</term>
 	  <listitem><para>
 
-Choke/Snubb peer.
+Choke/Snub peer.
 
           </para></listitem>
 	</varlistentry>
 
       </variablelist>
 
@@ -424,12 +433,13 @@
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>ip = <replaceable>a.b.c.d</replaceable></term>
+        <term>ip = <replaceable>hostname</replaceable></term>
         <listitem><para>
 
 Set the address reported to the tracker.
 
         </para></listitem>
       </varlistentry>
@@ -544,14 +554,14 @@
 
       <varlistentry>
         <term>load = <replaceable>file</replaceable></term>
         <term>load_start = <replaceable>file</replaceable></term>
         <listitem><para>
 
-Load and possibly start a file, or possibly mutiple files by using the
-wildcard "*". This is meant for use with
+Load and possibly start a file, or possibly multiple files by using the
+wild-card "*". This is meant for use with
 <emphasis>schedule</emphasis>, though ensure that the
 <emphasis>start</emphasis> is non-zero. The loaded file will be tied
 to the filename provided.
 
         </para></listitem>
       </varlistentry>
@@ -570,12 +580,85 @@
     </variablelist>
 
   </refsect1>
 
 
   <refsect1>
+    <title>DISPLAY SETTINGS</title>
+    <para>
+      Display related settings.
+    </para>
+
+    <variablelist>
+
+      <varlistentry>
+        <term>view_add = <replaceable>name</replaceable></term>
+        <listitem><para>
+
+Create a new view.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>view_sort = <replaceable>name</replaceable></term>
+        <term>view_sort = <replaceable>name</replaceable>,<replaceable>seconds</replaceable></term>
+        <listitem><para>
+
+Sort a view according the the criteria set by
+<emphasis>view_sort_current</emphasis>. If the optional argument is
+supplied, the view is not sorted if a change happened during the last
+<emphasis>seconds</emphasis>. This command is meant to be used with
+<emphasis>schedule</emphasis>.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>view_sort_new = <replaceable>name</replaceable>,<replaceable>...</replaceable></term>
+        <term>view_sort_current = <replaceable>name</replaceable>,<replaceable>...</replaceable></term>
+        <listitem><para>
+
+Set the sorting criteria for when new elements inserted or
+<emphasis>view_sort</emphasis> is called. The list can contain any
+number of criteria, including zero, from the following:
+
+        </para><para>
+
+<emphasis>name</emphasis>, <emphasis>name_reverse</emphasis>,
+<emphasis>stopped</emphasis>, <emphasis>started</emphasis>,
+<emphasis>complete</emphasis>, <emphasis>incomplete</emphasis>,
+<emphasis>state_changed</emphasis>,
+<emphasis>state_changed_reverse</emphasis>
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>view_filter = <replaceable>name</replaceable>,<replaceable>...</replaceable></term>
+        <listitem><para>
+
+Set a list of filter to apply when new new downloads are added and
+when <emphasis>view_sort</emphasis> gets called. All filters must
+match for the download to be included.
+
+        </para><para>
+
+<emphasis>stopped</emphasis>, <emphasis>started</emphasis>,
+<emphasis>complete</emphasis>, <emphasis>incomplete</emphasis>,
+
+        </para></listitem>
+      </varlistentry>
+
+    </variablelist>
+
+  </refsect1>
+
+
+
+  <refsect1>
     <title>ADVANCED SETTINGS</title>
     <para>
       This list contains settings users shouldn't need to touch.
     </para>
 
     <variablelist>
@@ -654,23 +737,51 @@
       </varlistentry>
 
       <varlistentry>
         <term>session_on_completion = <replaceable>yes</replaceable></term>
         <listitem><para>
 
-Controls whetever the session torrent is updated when a torrent
-finishes. By default on.
+Controls if the session torrent is saved when a torrent finishes. By
+default on.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>session_lock = <replaceable>yes</replaceable></term>
         <listitem><para>
 
-Controls whetever a lock file is created in the session directory.
+Controls if a lock file is created in the session directory on startup.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>session_save = </term>
+        <listitem><para>
+
+Save the session files for all downloads.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>use_udp_trackers = <replaceable>yes</replaceable></term>
+        <listitem><para>
+
+Use UDP trackers. Disable if you are behind a firewall etc that does
+not allow connections to UDP trackers.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>enable_trackers = <replaceable>yes</replaceable></term>
+        <listitem><para>
+
+Set to <emphasis>no</emphasis> to disable tracker requests.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>tracker_dump = <replaceable>filename</replaceable></term>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.rc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.rc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.rc	2006-01-07 05:07:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.rc	2006-05-02 00:27:58.000000000 +0800
@@ -24,17 +24,19 @@
 # Watch a directory for new torrents, and stop those that have been
 # deleted.
 #schedule = watch_directory,5,5,load_start=./watch/*.torrent
 #schedule = untied_directory,5,5,stop_untied=
 
 # The ip address reported to the tracker.
-#ip = rakshasa
+#ip = 127.0.0.1
+#ip = rakshasa.no
 
 # The ip address the listening socket and outgoing connections is
 # bound to.
-#bind = rakshasa
+#bind = 127.0.0.1
+#bind = rakshasa.no
 
 # Port range to use for listening.
 #port_range = 6890-6999
 
 # Start opening ports at a random position within the port range.
 #port_random = no
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/functional_fun.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/functional_fun.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/functional_fun.h	2006-03-03 00:24:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/functional_fun.h	2006-05-02 00:29:59.000000000 +0800
@@ -74,38 +74,68 @@
 template <typename Result>
 class function0 {
 public:
   typedef Result                 result_type;
   typedef function_base0<Result> base_type;
 
-  bool is_valid() const { return m_base.get() != NULL; }
+  bool                is_valid() const     { return m_base.get() != NULL; }
 
-  void set(base_type* base) { m_base = std::auto_ptr<base_type>(base); }
+  void                set(base_type* base) { m_base = std::auto_ptr<base_type>(base); }
+  base_type*          release()            { return m_base.release(); }
 
-  Result operator () () { return (*m_base)(); }
+  Result operator () ()                    { return (*m_base)(); }
 
 private:
   std::auto_ptr<base_type> m_base;
 };
 
 template <typename Result, typename Arg1>
 class function1 {
 public:
   typedef Result                       result_type;
   typedef function_base1<Result, Arg1> base_type;
 
-  bool is_valid() const { return m_base.get() != NULL; }
+  bool                is_valid() const     { return m_base.get() != NULL; }
 
-  void set(base_type* base) { m_base = std::auto_ptr<base_type>(base); }
+  void                set(base_type* base) { m_base = std::auto_ptr<base_type>(base); }
+  base_type*          release()            { return m_base.release(); }
 
-  Result operator () (Arg1 arg1) { return (*m_base)(arg1); }
+  Result operator () (Arg1 arg1)           { return (*m_base)(arg1); }
 
 private:
   std::auto_ptr<base_type> m_base;
 };
 
+template <typename Result>
+class ptr_fn0_t : public function_base0<Result> {
+public:
+  typedef Result (*Func)();
+
+  ptr_fn0_t(Func func) : m_func(func) {}
+  virtual ~ptr_fn0_t() {}
+  
+  virtual Result operator () () { return m_func(); }
+
+private:
+  Func    m_func;
+};
+
+template <typename Result, typename Arg1>
+class ptr_fn1_t : public function_base1<Result, Arg1> {
+public:
+  typedef Result (*Func)(Arg1);
+
+  ptr_fn1_t(Func func) : m_func(func) {}
+  virtual ~ptr_fn1_t() {}
+  
+  virtual Result operator () (Arg1 arg1) { return m_func(arg1); }
+
+private:
+  Func    m_func;
+};
+
 template <typename Object, typename Result>
 class mem_fn0_t : public function_base0<Result> {
 public:
   typedef Result (Object::*Func)();
 
   mem_fn0_t(Object* object, Func func) : m_object(object), m_func(func) {}
@@ -178,26 +208,12 @@
   Object*    m_object;
   Func       m_func;
   const Arg1 m_arg1;
 };
 
 template <typename Result, typename Arg1>
-class ptr_fn1_t : public function_base1<Result, Arg1> {
-public:
-  typedef Result (*Func)(Arg1);
-
-  ptr_fn1_t(Func func) : m_func(func) {}
-  virtual ~ptr_fn1_t() {}
-  
-  virtual Result operator () (Arg1 arg1) { return m_func(arg1); }
-
-private:
-  Func    m_func;
-};
-
-template <typename Result, typename Arg1>
 class ptr_fn0_b1_t : public function_base0<Result> {
 public:
   typedef Result (*Func)(Arg1);
 
   ptr_fn0_b1_t(Func func, const Arg1 arg1) : m_func(func), m_arg1(arg1) {}
   virtual ~ptr_fn0_b1_t() {}
@@ -221,57 +237,140 @@
 
 private:
   Func    m_func;
   Arg1    m_arg1;
 };
 
+template <typename Result>
+class value_fn0_t : public function_base0<Result> {
+public:
+  value_fn0_t(const Result& val) : m_value(val) {}
+  
+  virtual Result operator () () { return m_value; }
+
+private:
+  Result  m_value;
+};
+
+template <typename Result, typename SrcResult>
+class convert_fn0_t : public function_base0<Result> {
+public:
+  typedef function0<SrcResult> src_type;
+
+  convert_fn0_t(typename src_type::base_type* object) { m_object.set(object); }
+  virtual ~convert_fn0_t() {}
+  
+  virtual Result operator () () {
+    return m_object();
+  }
+
+private:
+  src_type m_object;
+};
+
+template <typename Result, typename Arg1, typename SrcResult, typename SrcArg1>
+class convert_fn1_t : public function_base1<Result, Arg1> {
+public:
+  typedef function1<SrcResult, SrcArg1> src_type;
+
+  convert_fn1_t(typename src_type::base_type* object) { m_object.set(object); }
+  virtual ~convert_fn1_t() {}
+  
+  virtual Result operator () (Arg1 arg1) {
+    return m_object(arg1);
+  }
+
+private:
+  src_type m_object;
+};
+
+template <typename Result>
+inline function_base0<Result>*
+ptr_fn(Result (*func)()) {
+  return new ptr_fn0_t<Result>(func);
+}
+
+template <typename Arg1, typename Result>
+inline function_base1<Result, Arg1>*
+ptr_fn(Result (*func)(Arg1)) {
+  return new ptr_fn1_t<Result, Arg1>(func);
+}
+
 template <typename Result, typename Object>
-function_base0<Result>*
+inline function_base0<Result>*
 mem_fn(Object* object, Result (Object::*func)()) {
   return new mem_fn0_t<Object, Result>(object, func);
 }
 
 template <typename Arg1, typename Result, typename Object>
-function_base1<Result, Arg1>*
+inline function_base1<Result, Arg1>*
 mem_fn(Object* object, Result (Object::*func)(Arg1)) {
   return new mem_fn1_t<Object, Result, Arg1>(object, func);
 }
 
 template <typename Result, typename Object>
-function_base0<Result>*
+inline function_base0<Result>*
 mem_fn(const Object* object, Result (Object::*func)() const) {
   return new const_mem_fn0_t<Object, Result>(object, func);
 }
 
 template <typename Arg1, typename Result, typename Object>
-function_base1<Result, Arg1>*
+inline function_base1<Result, Arg1>*
 mem_fn(const Object* object, Result (Object::*func)(Arg1) const) {
   return new const_mem_fn1_t<Object, Result, Arg1>(object, func);
 }
 
 template <typename Arg1, typename Result, typename Object>
-function_base0<Result>*
+inline function_base0<Result>*
 bind_mem_fn(Object* object, Result (Object::*func)(Arg1), const Arg1 arg1) {
   return new mem_fn0_b1_t<Object, Result, Arg1>(object, func, arg1);
 }
 
 template <typename Arg1, typename Result>
-function_base1<Result, Arg1>*
-ptr_fn(Result (*func)(Arg1)) {
-  return new ptr_fn1_t<Result, Arg1>(func);
-}
-
-template <typename Arg1, typename Result>
-function_base0<Result>*
+inline function_base0<Result>*
 bind_ptr_fn(Result (*func)(Arg1), const Arg1 arg1) {
   return new ptr_fn0_b1_t<Result, Arg1>(func, arg1);
 }
 
 template <typename Arg1, typename Arg2, typename Result>
-function_base1<Result, Arg2>*
+inline function_base1<Result, Arg2>*
 bind_ptr_fn(Result (*func)(Arg1, Arg2), const Arg1 arg1) {
   return new ptr_fn1_b1_t<Result, Arg1, Arg2>(func, arg1);
 }
 
+template <typename Result>
+inline function_base0<Result>*
+value_fn(const Result& val) {
+  return new value_fn0_t<Result>(val);
+}
+
+template <typename Result, typename SrcResult>
+inline function_base0<Result>*
+convert_fn(function_base0<SrcResult>* src) {
+  return new convert_fn0_t<Result, SrcResult>(src);
+}
+
+// This overload ensures that if we try to convert to the same type,
+// it will optimize away the unneeded layer.
+template <typename Result>
+inline function_base0<Result>*
+convert_fn(function_base0<Result>* src) {
+  return src;
+}
+
+template <typename Result, typename Arg1, typename SrcResult, typename SrcArg1>
+inline function_base1<Result, Arg1>*
+convert_fn(function_base1<SrcResult, SrcArg1>* src) {
+  return new convert_fn1_t<Result, Arg1, SrcResult, SrcArg1>(src);
+}
+
+// This overload ensures that if we try to convert to the same type,
+// it will optimize away the unneeded layer.
+template <typename Result, typename Arg1>
+inline function_base1<Result, Arg1>*
+convert_fn(function_base1<Result, Arg1>* src) {
+  return src;
+}
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/socket_address.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/socket_address.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/socket_address.h	2006-04-03 01:00:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/socket_address.h	2006-05-02 00:29:59.000000000 +0800
@@ -90,24 +90,27 @@
   bool                set_address_str(const std::string& a)   { return set_address_c_str(a.c_str()); }
   bool                set_address_c_str(const char* a);
 
   uint32_t            length() const;
 
   socket_address_inet*        sa_inet()                       { return reinterpret_cast<socket_address_inet*>(this); }
-  socket_address_inet6*       sa_inet6()                      { return reinterpret_cast<socket_address_inet6*>(this); }
-
   const socket_address_inet*  sa_inet() const                 { return reinterpret_cast<const socket_address_inet*>(this); }
-  const socket_address_inet6* sa_inet6() const                { return reinterpret_cast<const socket_address_inet6*>(this); }
 
   sockaddr*           c_sockaddr()                            { return &m_sa.m_sockaddr; }
   sockaddr_in*        c_sockaddr_inet()                       { return &m_sa.m_sockaddrInet; }
-  sockaddr_in6*       c_sockaddr_inet6()                      { return &m_sa.m_sockaddrInet6; }
 
   const sockaddr*     c_sockaddr() const                      { return &m_sa.m_sockaddr; }
   const sockaddr_in*  c_sockaddr_inet() const                 { return &m_sa.m_sockaddrInet; }
+
+#ifdef RAK_USE_INET6
+  socket_address_inet6*       sa_inet6()                      { return reinterpret_cast<socket_address_inet6*>(this); }
+  const socket_address_inet6* sa_inet6() const                { return reinterpret_cast<const socket_address_inet6*>(this); }
+
+  sockaddr_in6*       c_sockaddr_inet6()                      { return &m_sa.m_sockaddrInet6; }
   const sockaddr_in6* c_sockaddr_inet6() const                { return &m_sa.m_sockaddrInet6; }
+#endif
 
   // Copy a socket address which has the length 'length. Zero out any
   // extranous bytes and ensure it does not go beyond the size of this
   // struct.
   void                copy(const socket_address& src, size_t length);
 
@@ -120,13 +123,15 @@
   bool                operator < (const socket_address& rhs) const;
 
 private:
   union sa_union {
     sockaddr            m_sockaddr;
     sockaddr_in         m_sockaddrInet;
+#ifdef RAK_USE_INET6
     sockaddr_in6        m_sockaddrInet6;
+#endif
   };
 
   sa_union            m_sa;
 };
 
 // Remeber to set the AF_INET.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/scripts/checks.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/scripts/checks.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/scripts/checks.m4	2006-01-04 05:01:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/scripts/checks.m4	2006-05-02 00:27:59.000000000 +0800
@@ -178,6 +178,26 @@
     [
       if test "$withval" = "yes"; then
         TORRENT_CHECK_POSIX_FALLOCATE
       fi
     ])
 ])
+
+AC_DEFUN([TORRENT_WITHOUT_NCURSESW], [
+  AC_ARG_WITH(ncursesw,
+    [  --without-ncursesw      Don't try to use wide char ncurses.],
+    [
+      if test "$withval" = "no"; then
+	AC_SEARCH_LIBS(add_wch, ncursesw,
+	  AC_DEFINE(HAVE_NCURSESW, 1, defined if ncurses wide character support is available),
+	  AC_SEARCH_LIBS(wbkgdset, ncurses curses,,echo "*** The ncurses library is required!";exit 1)
+        )
+      else
+	AC_SEARCH_LIBS(wbkgdset, ncurses curses,,echo "*** The ncurses library is required!";exit 1)
+      fi
+    ],[
+      AC_SEARCH_LIBS(add_wch, ncursesw,
+	AC_DEFINE(HAVE_NCURSESW, 1, defined if ncurses wide character support is available),
+	AC_SEARCH_LIBS(wbkgdset, ncurses curses,,echo "*** The ncurses library is required!";exit 1)
+      )
+    ])
+])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/scripts/common.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/scripts/common.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/scripts/common.m4	2006-04-01 04:09:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/scripts/common.m4	2006-05-02 00:27:59.000000000 +0800
@@ -176,6 +177,17 @@
           AC_DEFINE(USE_ALIGNED, 1, Require byte alignment)
         fi
     ],[
         TORRENT_CHECK_ALIGNED
   ])
 ])
+
+
+AC_DEFUN([TORRENT_DISABLE_IPV6], [
+  AC_ARG_ENABLE(ipv6,
+    [  --enable-ipv6           disable ipv6 [[default=no]]],
+    [
+        if test "$enableval" = "yes"; then
+            AC_DEFINE(RAK_USE_INET6, 1, enable ipv6 stuff)
+        fi
+    ])
+])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.cc	2006-03-29 06:15:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/control.cc	2006-05-02 00:30:08.000000000 +0800
@@ -34,15 +34,20 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <unistd.h>
+#include <sys/stat.h>
 #include <torrent/connection_manager.h>
 
 #include "core/manager.h"
+#include "core/download_store.h"
+#include "core/view_manager.h"
+#include "core/scheduler.h"
+
 #include "display/canvas.h"
 #include "display/client_info.h"
 #include "display/window.h"
 #include "display/manager.h"
 #include "input/manager.h"
 #include "input/input_event.h"
@@ -55,24 +60,27 @@
 
 Control::Control() :
   m_shutdownReceived(false),
   m_shutdownQuick(false),
 
   m_ui(new ui::Root()),
-  m_core(new core::Manager()),
   m_display(new display::Manager()),
   m_input(new input::Manager()),
   m_inputStdin(new input::InputEvent(STDIN_FILENO)),
 
   m_commandScheduler(new CommandScheduler()),
   m_variables(new utils::VariableMap()),
 
   m_clientInfo(new display::ClientInfo),
 
   m_tick(0) {
 
+  m_core        = new core::Manager();
+  m_viewManager = new core::ViewManager(m_core->download_list());
+  m_scheduler   = new core::Scheduler(m_core->download_list());
+
   m_inputStdin->slot_pressed(sigc::mem_fun(m_input, &input::Manager::pressed));
 
   m_taskShutdown.set_slot(rak::mem_fn(this, &Control::handle_shutdown));
 
   m_commandScheduler->set_slot_command(rak::mem_fn(m_variables, &utils::VariableMap::process_command));
   m_commandScheduler->set_slot_error_message(rak::mem_fn(m_core, &core::Manager::push_log));
@@ -100,26 +108,28 @@
   display::Window::slot_adjust(rak::make_mem_fun(m_display, &display::Manager::adjust_layout));
 
   m_core->get_poll_manager()->get_http_stack()->set_user_agent(std::string(PACKAGE "/" VERSION "/") + torrent::version());
 
   m_core->initialize_second();
   m_core->listen_open();
-  m_core->download_store().enable(m_variables->get_string("session_lock") == "yes");
+  m_core->download_store()->enable(m_variables->get_value("session_lock"));
+
+  m_scheduler->set_view(*m_viewManager->find_throw("scheduler"));
 
   m_ui->init(this);
 
   m_inputStdin->insert(m_core->get_poll_manager()->get_torrent_poll());
 }
 
 void
 Control::cleanup() {
   priority_queue_erase(&taskScheduler, &m_taskShutdown);
 
   m_inputStdin->remove(m_core->get_poll_manager()->get_torrent_poll());
 
-  m_core->download_store().disable();
+  m_core->download_store()->disable();
 
   m_ui->cleanup();
   m_core->cleanup();
   
   display::Canvas::erase_std();
   display::Canvas::refresh_std();
@@ -140,6 +150,19 @@
     m_core->shutdown(true);
   }
 
   m_shutdownQuick = true;
   m_shutdownReceived = false;
 }
+
+void
+Control::set_umask(mode_t m) {
+  ::umask(m);
+
+  m_umask = m;
+}
+
+void
+Control::set_working_directory(const std::string& dir) {
+  if (::chdir(dir.c_str()) != 0)
+    throw torrent::input_error("Could not change working directory.");
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/control.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.h	2006-04-01 04:48:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/control.h	2006-05-02 00:29:58.000000000 +0800
@@ -35,22 +35,25 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_CONTROL_H
 #define RTORRENT_CONTROL_H
 
 #include <inttypes.h>
+#include <sys/types.h>
 #include <rak/timer.h>
 #include <rak/priority_queue_default.h>
 #include <torrent/torrent.h>
 
 namespace ui {
   class Root;
 }
 
 namespace core {
   class Manager;
+  class ViewManager;
+  class Scheduler;
 }
 
 namespace display {
   class Manager;
   class ClientInfo;
 }
@@ -79,44 +82,59 @@
 
   void                handle_shutdown();
 
   void                receive_normal_shutdown()     { m_shutdownReceived = true; }
   void                receive_quick_shutdown()      { m_shutdownReceived = true; m_shutdownQuick = true; }
 
-  ui::Root*           ui()                          { return m_ui; }
   core::Manager*      core()                        { return m_core; }
+  core::ViewManager*  view_manager()                { return m_viewManager; }
+  core::Scheduler*    scheduler()                   { return m_scheduler; }
+
+  ui::Root*           ui()                          { return m_ui; }
   display::Manager*   display()                     { return m_display; }
   input::Manager*     input()                       { return m_input; }
   input::InputEvent*  input_stdin()                 { return m_inputStdin; }
 
   CommandScheduler*   command_scheduler()           { return m_commandScheduler; }
   utils::VariableMap* variable()                    { return m_variables; }
 
   display::ClientInfo* client_info()                { return m_clientInfo; }
 
   uint64_t            tick() const                  { return m_tick; }
   void                inc_tick()                    { m_tick++; }
 
+  mode_t              umask() const                 { return m_umask; }
+  void                set_umask(mode_t m);
+
+  const std::string&  working_directory() const     { return m_workingDirectory; }
+  void                set_working_directory(const std::string& dir);
+
 private:
   Control(const Control&);
   void operator = (const Control&);
 
   bool                m_shutdownReceived;
   bool                m_shutdownQuick;
 
-  ui::Root*           m_ui;
   core::Manager*      m_core;
+  core::ViewManager*  m_viewManager;
+  core::Scheduler*    m_scheduler;
+
+  ui::Root*           m_ui;
   display::Manager*   m_display;
   input::Manager*     m_input;
   input::InputEvent*  m_inputStdin;
 
   CommandScheduler*   m_commandScheduler;
   utils::VariableMap* m_variables;
 
   display::ClientInfo* m_clientInfo;
 
   uint64_t            m_tick;
 
+  mode_t              m_umask;
+  std::string         m_workingDirectory;
+
   rak::priority_item  m_taskShutdown;
 };
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.cc	2006-04-01 05:38:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.cc	2006-05-02 00:30:07.000000000 +0800
@@ -57,39 +57,50 @@
   m_fileList(d.file_list()),
   m_trackerList(d.tracker_list()),
 
   m_chunksFailed(0) {
 
   m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
-  m_connTrackerFailed = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
-  m_connStorageError = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
+  m_connTrackerFailed   = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
+  m_connStorageError    = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
 
   m_download.signal_chunk_failed(sigc::mem_fun(*this, &Download::receive_chunk_failed));
 
-  m_variables.insert("connection_current", new utils::VariableSlotString<const char*, const std::string&>(rak::mem_fn(this, &Download::connection_current),
-													  rak::mem_fn(this, &Download::set_connection_current)));
+  m_variables.insert("connection_current", new utils::VariableStringSlot(rak::mem_fn(this, &Download::connection_current),
+									 rak::mem_fn(this, &Download::set_connection_current)));
+
   m_variables.insert("connection_leech",   new utils::VariableAny(connection_type_to_string(download_type::CONNECTION_LEECH)));
   m_variables.insert("connection_seed",    new utils::VariableAny(connection_type_to_string(download_type::CONNECTION_SEED)));
-  m_variables.insert("state",              new utils::VariableObject(bencode(), "rtorrent", "state", torrent::Object::TYPE_STRING));
-  m_variables.insert("tied_to_file",       new utils::VariableObject(bencode(), "rtorrent", "tied_to_file", torrent::Object::TYPE_STRING));
 
-  m_variables.insert("directory",          new utils::VariableSlotString<const std::string&>(rak::mem_fn(&m_fileList, &torrent::FileList::root_dir),
-											     rak::mem_fn(this, &Download::set_root_directory)));
+  // 0 - stopped
+  // 1 - started
+  m_variables.insert("state",              new utils::VariableObject(bencode(), "rtorrent", "state", torrent::Object::TYPE_VALUE));
+  m_variables.insert("complete",           new utils::VariableObject(bencode(), "rtorrent", "complete", torrent::Object::TYPE_VALUE));
+
+  // 0 - Not hashing
+  // 1 - Normal hashing
+  // 2 - Download finished, hashing
+  m_variables.insert("hashing",            new utils::VariableObject(bencode(), "rtorrent", "hashing", torrent::Object::TYPE_VALUE));
+  m_variables.insert("tied_to_file",       new utils::VariableObject(bencode(), "rtorrent", "tied_to_file", torrent::Object::TYPE_STRING));
 
-  m_variables.insert("min_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &download_type::peers_min),
-											    rak::mem_fn(&m_download, &download_type::set_peers_min),
-											    "%u"));
-  m_variables.insert("max_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &download_type::peers_max),
-											    rak::mem_fn(&m_download, &download_type::set_peers_max),
-											    "%u"));
-  m_variables.insert("max_uploads",        new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &download_type::uploads_max),
-											    rak::mem_fn(&m_download, &download_type::set_uploads_max),
-											    "%u"));
-  m_variables.insert("priority",           new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(this, &Download::priority),
-											    rak::mem_fn(this, &Download::set_priority),
-											    "%u"));
+  // The "state_changed" variable is required to be a valid unix time
+  // value, it indicates the last time the torrent changed its state,
+  // resume/pause.
+  m_variables.insert("state_changed",      new utils::VariableObject(bencode(), "rtorrent", "state_changed", torrent::Object::TYPE_VALUE));
+
+  m_variables.insert("directory",          new utils::VariableStringSlot(rak::mem_fn(&m_fileList, &torrent::FileList::root_dir),
+									 rak::mem_fn(this, &Download::set_root_directory)));
+
+  m_variables.insert("min_peers",          new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::peers_min),
+									rak::mem_fn(&m_download, &download_type::set_peers_min)));
+  m_variables.insert("max_peers",          new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::peers_max),
+									rak::mem_fn(&m_download, &download_type::set_peers_max)));
+  m_variables.insert("max_uploads",        new utils::VariableValueSlot(rak::mem_fn(&m_download, &download_type::uploads_max),
+									rak::mem_fn(&m_download, &download_type::set_uploads_max)));
+  m_variables.insert("priority",           new utils::VariableValueSlot(rak::mem_fn(this, &Download::priority),
+									rak::mem_fn(this, &Download::set_priority)));
 }
 
 Download::~Download() {
   if (!m_download.is_valid())
     return;
 
@@ -98,31 +109,12 @@
   m_connStorageError.disconnect();
 
   m_download = download_type();
 }
 
 void
-Download::start() {
-  if (is_done())
-    m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_seed").as_string()));
-  else
-    m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_leech").as_string()));
-
-  // Update the priority to ensure it has the correct
-  // seeding/unfinished modifiers.
-  set_priority(priority());
-
-  m_download.start();
-}
-
-void
-Download::stop() {
-  m_download.stop();
-}
-
-void
 Download::enable_udp_trackers(bool state) {
   torrent::TrackerList tl = m_download.tracker_list();
 
   for (int i = 0, last = tl.size(); i < last; ++i)
     if (tl.get(i).tracker_type() == torrent::Tracker::TRACKER_UDP)
       if (state)
@@ -148,19 +140,12 @@
     torrent::download_set_priority(m_download, p * p);
 
   bencode()->get_key("rtorrent").insert_key("priority", (int64_t)p);
 }
 
 void
-Download::receive_finished() {
-  m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_seed").as_string()));
-  // FIXME
-  //torrent::download_set_priority(m_download, 2);
-}
-
-void
 Download::receive_tracker_msg(std::string msg) {
   if (msg.empty())
     m_message = "";
   else
     m_message = "Tracker: [" + msg + "]";
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.cc	2006-04-07 00:34:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_factory.cc	2006-05-02 00:30:07.000000000 +0800
@@ -51,12 +51,13 @@
 #include "http_queue.h"
 #include "globals.h"
 #include "manager.h"
 
 #include "download.h"
 #include "download_factory.h"
+#include "download_store.h"
 
 namespace core {
 
 DownloadFactory::DownloadFactory(const std::string& uri, Manager* m) :
   m_manager(m),
   m_stream(NULL),
@@ -100,13 +101,13 @@
   if (m_stream)
     throw torrent::client_error("DownloadFactory::load() called on an object with m_stream != NULL");
 
   if (std::strncmp(m_uri.c_str(), "http://", 7) == 0) {
     // Http handling here.
     m_stream = new std::stringstream;
-    HttpQueue::iterator itr = m_manager->http_queue().insert(m_uri, m_stream);
+    HttpQueue::iterator itr = m_manager->http_queue()->insert(m_uri, m_stream);
 
     (*itr)->signal_done().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_loaded));
     (*itr)->signal_failed().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_failed));
 
     m_variables.set("tied_to_file", (int64_t)false);
 
@@ -138,22 +139,22 @@
 
 void
 DownloadFactory::receive_success() {
   if (m_stream == NULL)
     throw torrent::client_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
 
-  DownloadList::iterator itr = m_manager->download_list().insert(m_stream, m_printLog);
+  Download* download = m_manager->download_list()->create(m_stream, m_printLog);
 
-  if (itr == m_manager->download_list().end()) {
+  if (download == NULL) {
     // core::Manager should already have added the error message to
     // the log.
     m_slotFinished();
     return;
   }
 
-  torrent::Object* root = (*itr)->bencode();
+  torrent::Object* root = download->bencode();
 
   if (!m_session) {
     // We only allow session torrents to keep their
     // 'rtorrent/libtorrent' sections.
     root->erase_key("rtorrent");
     root->erase_key("libtorrent");
@@ -161,65 +162,55 @@
 
   if (!root->has_key_map("rtorrent"))
     root->insert_key("rtorrent", torrent::Object(torrent::Object::TYPE_MAP));
     
   torrent::Object* rtorrent = &root->get_key("rtorrent");
 
-  if (!rtorrent->has_key_string("state") ||
-      (rtorrent->get_key("state").as_string() != "stopped" &&
-       rtorrent->get_key("state").as_string() != "started"))
-    rtorrent->insert_key("state", "stopped");
-  
-  if (!rtorrent->has_key_string("tied_to_file"))
-    rtorrent->insert_key("tied_to_file", std::string());
+  initialize_rtorrent(download, rtorrent);
 
-  if (rtorrent->has_key_value("priority"))
-    (*itr)->variable()->set("priority", rtorrent->get_key("priority").as_value() % 4);
-  else
-    (*itr)->variable()->set("priority", (int64_t)2);
+  if (m_manager->download_list()->insert(download) == m_manager->download_list()->end()) {
+    // ATM doesn't really ever get here.
+    delete download;
 
-  // Move to 'rtorrent'.
-  (*itr)->variable()->set("connection_leech", m_variables.get("connection_leech"));
-  (*itr)->variable()->set("connection_seed",  m_variables.get("connection_seed"));
-  (*itr)->variable()->set("min_peers",        control->variable()->get("min_peers"));
-  (*itr)->variable()->set("max_peers",        control->variable()->get("max_peers"));
-  (*itr)->variable()->set("max_uploads",      control->variable()->get("max_uploads"));
-
-  if (rtorrent->has_key_value("key")) {
-    (*itr)->tracker_list()->set_key(rtorrent->get_key("key").as_value());
-
-  } else {
-    (*itr)->tracker_list()->set_key(rand() % (std::numeric_limits<uint32_t>::max() - 1) + 1);
-    rtorrent->insert_key("key", (*itr)->tracker_list()->key());
+    m_slotFinished();
+    return;
   }
 
-  if (control->variable()->get_string("use_udp_trackers") == "no")
-    (*itr)->enable_udp_trackers(false);
+  // Move to 'rtorrent'.
+  download->variable()->set("connection_leech", m_variables.get("connection_leech"));
+  download->variable()->set("connection_seed",  m_variables.get("connection_seed"));
+  download->variable()->set("min_peers",        control->variable()->get("min_peers"));
+  download->variable()->set("max_peers",        control->variable()->get("max_peers"));
+  download->variable()->set("max_uploads",      control->variable()->get("max_uploads"));
+
+  if (!control->variable()->get_value("use_udp_trackers"))
+    download->enable_udp_trackers(false);
 
-  if (rtorrent->has_key_value("total_uploaded"))
-    (*itr)->download()->up_rate()->set_total(rtorrent->get_key("total_uploaded").as_value());
-    
   if (m_session) {
     if (!rtorrent->has_key_string("directory"))
-      (*itr)->variable()->set("directory", m_variables.get("directory"));
+      download->variable()->set("directory", m_variables.get("directory"));
     else
-      (*itr)->variable()->set("directory", rtorrent->get_key("directory"));
+      download->variable()->set("directory", rtorrent->get_key("directory"));
 
-    if ((*itr)->variable()->get_string("state") == "started")
-      m_manager->download_list().resume(*itr);
+    // This torrent was queued for hashing or hashing when the session
+    // file was saved. Or it was in a started state.
+    if (download->variable()->get_value("hashing") != Download::variable_hashing_stopped ||
+	download->variable()->get_value("state") != 0)
+      m_manager->download_list()->resume(download);
 
   } else {
-    (*itr)->variable()->set("directory", m_variables.get("directory"));
+    download->variable()->set("directory", m_variables.get("directory"));
 
     if (m_variables.get("tied_to_file").as_value())
-      (*itr)->variable()->set("tied_to_file", m_uri);
+      download->variable()->set("tied_to_file", m_uri);
 
+    // Use the state thingie here, move below.
     if (m_start)
-      m_manager->download_list().start(*itr);
+      m_manager->download_list()->start(download);
 
-    m_manager->download_store().save(*itr);
+    m_manager->download_store()->save(download);
   }
 
   m_slotFinished();
 }
 
 void
@@ -233,7 +224,44 @@
     m_manager->get_log_complete().push_front(msg + ": \"" + m_uri + "\"");
   }
 
   m_slotFinished();
 }
 
+void
+DownloadFactory::initialize_rtorrent(Download* download, torrent::Object* rtorrent) {
+  if (!rtorrent->has_key_value("state") || rtorrent->get_key("state").as_value() > 1) {
+    rtorrent->insert_key("state", (int64_t)m_start);
+    rtorrent->insert_key("state_changed", cachedTime.seconds());
+
+  } else if (!rtorrent->has_key_value("state_changed") ||
+	     rtorrent->get_key("state_changed").as_value() > cachedTime.seconds() || rtorrent->get_key("state_changed").as_value() == 0) {
+    rtorrent->insert_key("state_changed", cachedTime.seconds());
+  }
+
+  if (!rtorrent->has_key_value("complete"))
+    rtorrent->insert_key("complete", (int64_t)0);
+
+  if (!rtorrent->has_key_value("hashing"))
+    rtorrent->insert_key("hashing", Download::variable_hashing_stopped);
+
+  if (!rtorrent->has_key_string("tied_to_file"))
+    rtorrent->insert_key("tied_to_file", std::string());
+
+  if (rtorrent->has_key_value("priority"))
+    download->variable()->set("priority", rtorrent->get_key("priority").as_value() % 4);
+  else
+    download->variable()->set("priority", (int64_t)2);
+
+  if (rtorrent->has_key_value("key")) {
+    download->tracker_list()->set_key(rtorrent->get_key("key").as_value());
+
+  } else {
+    download->tracker_list()->set_key(rand() % (std::numeric_limits<uint32_t>::max() - 1) + 1);
+    rtorrent->insert_key("key", download->tracker_list()->key());
+  }
+
+  if (rtorrent->has_key_value("total_uploaded"))
+    download->download()->up_rate()->set_total(rtorrent->get_key("total_uploaded").as_value());
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_factory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.h	2006-04-01 04:53:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_factory.h	2006-05-02 00:29:58.000000000 +0800
@@ -84,12 +84,14 @@
   void                receive_load();
   void                receive_loaded();
   void                receive_commit();
   void                receive_success();
   void                receive_failed(const std::string& msg);
 
+  void                initialize_rtorrent(Download* download, torrent::Object* rtorrent);
+
   Manager*            m_manager;
   std::iostream*      m_stream;
 
   bool                m_commited;
   bool                m_loaded;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.h	2006-04-01 05:37:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.h	2006-05-02 00:29:58.000000000 +0800
@@ -52,23 +52,23 @@
   typedef torrent::Download             download_type;
   typedef torrent::FileList             file_list_type;
   typedef torrent::TrackerList          tracker_list_type;
   typedef download_type::ConnectionType connection_type;
   typedef utils::VariableMap            variable_map_type;
 
+  static const int64_t variable_hashing_stopped = 0;
+  static const int64_t variable_hashing_started = 1;
+  static const int64_t variable_hashing_last    = 2;
+
   Download(download_type d);
   ~Download();
 
   bool                is_open() const                          { return m_download.is_open(); }
+  bool                is_active() const                        { return m_download.is_active(); }
   inline bool         is_done() const                          { return m_download.chunks_done() == m_download.chunks_total(); }
 
-  void                start();
-  void                stop();
-
-  // Add functions like pause/etc.
-
   variable_map_type*  variable()                               { return &m_variables; }
   std::string         variable_string(const std::string& key)  { return m_variables.get_string(key); }
 
   download_type*       download()                              { return &m_download; }
   const download_type* download() const                        { return &m_download; }
 
@@ -74,13 +74,15 @@
 
   torrent::Object*    bencode()                                { return m_download.bencode(); }
   file_list_type*     file_list()                              { return &m_fileList; }
   tracker_list_type*  tracker_list()                           { return &m_trackerList; }
 
   const std::string&  info_hash() const                        { return m_download.info_hash(); }
+
   const std::string&  message() const                          { return m_message; }
+  void                set_message(const std::string& msg)      { m_message = msg; }
 
   uint32_t            chunks_failed() const                    { return m_chunksFailed; }
 
   void                enable_udp_trackers(bool state);
 
   uint32_t            priority();
@@ -93,13 +95,13 @@
 
   template <typename Ret, typename Arg1, Ret (download_type::*func)(Arg1)>
   void                call(Arg1 a1)                                         { (m_download.*func)(a1); }
 
   bool operator == (const std::string& str)                                { return str == m_download.info_hash(); }
 
-  void                receive_finished();
+  void                set_connection_type(const std::string& t) { m_download.set_connection_type(string_to_connection_type(t)); }
 
   static connection_type string_to_connection_type(const std::string& name);
   static const char*     connection_type_to_string(connection_type t);
 
   static uint32_t     string_to_priority(const std::string& name);
   static const char*  priority_to_string(uint32_t p);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.cc	2006-04-01 04:57:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.cc	2006-05-04 21:15:19.000000000 +0800
@@ -44,35 +44,57 @@
 #include <torrent/object_stream.h>
 #include <torrent/torrent.h>
 
 #include "rak/functional.h"
 
 #include "globals.h"
+#include "hash_queue.h"
 #include "manager.h"
 
 #include "download.h"
 #include "download_list.h"
+#include "download_store.h"
 
 namespace core {
 
+inline void
+DownloadList::check_contains(Download* d) {
+#ifdef USE_EXTRA_DEBUG
+  if (std::find(begin(), end(), d) == end())
+    throw torrent::internal_error("DownloadList::check_contains(...) failed.");
+#endif
+}
+
 struct download_list_call {
   download_list_call(Download* d) : m_download(d) {}
 
-  void operator () (const DownloadList::SlotMap::value_type& s) {
+  void operator () (const DownloadList::slot_map::value_type& s) {
     s.second(m_download);
   }
 
   Download* m_download;
 };    
 
-DownloadList::iterator
-DownloadList::insert(std::istream* str, bool printLog) {
+DownloadList::~DownloadList() {
+  std::for_each(begin(), end(), std::bind1st(std::mem_fun(&DownloadList::close), this));
+  std::for_each(begin(), end(), rak::call_delete<Download>());
+
+  base_type::clear();
+}
+
+void
+DownloadList::session_save() {
+  std::for_each(begin(), end(), std::bind1st(std::mem_fun(&DownloadStore::save), control->core()->download_store()));
+}
+
+Download*
+DownloadList::create(std::istream* str, bool printLog) {
   torrent::Object* object = new torrent::Object;
+  torrent::Download download;
 
   try {
-
     *str >> *object;
     
     // Catch, delete.
     if (str->fail())
       throw torrent::input_error("Could not create download, the input is not a valid torrent.");
 
@@ -73,123 +95,361 @@
     *str >> *object;
     
     // Catch, delete.
     if (str->fail())
       throw torrent::input_error("Could not create download, the input is not a valid torrent.");
 
-    torrent::Download d = torrent::download_add(object);
-
-    iterator itr = Base::insert(end(), new Download(d));
-
-    (*itr)->download()->signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::finished), *itr));
-    std::for_each(m_slotMapInsert.begin(), m_slotMapInsert.end(), download_list_call(*itr));
-
-    return itr;
+    download = torrent::download_add(object);
 
   } catch (torrent::local_error& e) {
     delete object;
 
     if (printLog)
       control->core()->push_log(e.what());
 
-    return end();
+    return NULL;
+  }
+
+  // There's no non-critical exceptions that should be throwable by
+  // the ctor, so don't catch.
+  return new Download(download);
+}
+
+DownloadList::iterator
+DownloadList::insert(Download* download) {
+  iterator itr = base_type::insert(end(), download);
+
+  try {
+    (*itr)->download()->signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::received_finished), download));
+    std::for_each(m_slotMapInsert.begin(), m_slotMapInsert.end(), download_list_call(*itr));
+
+  } catch (torrent::local_error& e) {
+    // Should perhaps relax this, just print an error and remove the
+    // downloads?
+    throw torrent::internal_error("Caught during DownloadList::insert(...): " + std::string(e.what()));
   }
+
+  return itr;
+}
+
+void
+DownloadList::erase(Download* download) {
+  check_contains(download);
+
+  erase(std::find(begin(), end(), download));
 }
 
 DownloadList::iterator
 DownloadList::erase(iterator itr) {
-  // Make safe to erase active downloads.
+  if (itr == end())
+    throw torrent::internal_error("DownloadList::erase(...) could not find download.");
 
-  if ((*itr)->download()->is_active())
-    throw std::logic_error("DownloadList::erase(...) called on an active download.");
+  close(*itr);
+
+  control->core()->download_store()->remove(*itr);
 
   std::for_each(m_slotMapErase.begin(), m_slotMapErase.end(), download_list_call(*itr));
 
   torrent::download_remove(*(*itr)->download());
   delete *itr;
 
-  return Base::erase(itr);
+  return base_type::erase(itr);
 }
 
+// void
+// DownloadList::save(Download* d) {
+  
+// }
+
 void
-DownloadList::open(Download* d) {
+DownloadList::open(Download* download) {
   try {
 
-    if (!d->download()->is_open())
-      std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(d));
+    open_throw(download);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
 void
-DownloadList::close(Download* d) {
-  try {
+DownloadList::open_throw(Download* download) {
+  check_contains(download);
+
+  if (download->download()->is_open())
+    return;
+  
+  download->download()->open();
+
+  std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(download));
+}
 
-    if (d->download()->is_active())
-      std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(d));
+void
+DownloadList::close(Download* download) {
+  try {
 
-    if (d->download()->is_open())
-      std::for_each(m_slotMapClose.begin(), m_slotMapClose.end(), download_list_call(d));
+    close_throw(download);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
 void
-DownloadList::start(Download* d) {
-  d->variable()->set("state", "started");
+DownloadList::close_throw(Download* download) {
+  check_contains(download);
+
+  if (!download->download()->is_open())
+    return;
+
+  if (download->download()->is_active())
+    pause(download);
+  
+  // Save the torrent on close, this covers shutdown and if a torrent
+  // is manually closed which would clear the progress data. For
+  // better crash protection, save regulary in addition to this.
+  //
+  // Used to be in pause, but this was wrong for rehashing etc.
+  //
+  // Reconsider this save. Should be done explicitly when shutting down.
+  //control->core()->download_store()->save(download);
+  control->core()->hash_queue()->remove(download);
+
+  download->download()->close();
+
+  std::for_each(m_slotMapClose.begin(), m_slotMapClose.end(), download_list_call(download));
+}
+
+void
+DownloadList::start(Download* download) {
+  check_contains(download);
+
+  download->variable()->set("state", (int64_t)1);
+
+  resume(download);
+}
+
+void
+DownloadList::stop(Download* download) {
+  check_contains(download);
+
+  download->variable()->set("state", (int64_t)0);
 
-  resume(d);
+  pause(download);
 }
 
 void
-DownloadList::stop(Download* d) {
-  d->variable()->set("state", "stopped");
+DownloadList::resume(Download* download) {
+  check_contains(download);
+
+  try {
+
+    if (download->download()->is_active())
+      return;
 
-  pause(d);
+    // Properly escape when resume get's called during hashing. The
+    // 'state' is changed by the call to DownloadList::start so it
+    // will automagically start afterwards.
+    if (control->core()->hash_queue()->find(download) != control->core()->hash_queue()->end())
+      return;
+
+    download->variable()->set("state_changed", cachedTime.seconds());
+
+    open_throw(download);
+
+    // Manual or end-of-download rehashing clears the resume data so
+    // we can just start the hashing again without clearing it again.
+    //
+    // It is also assumed the is_hash_checked flag gets cleared when
+    // 'hashing' was set.
+    if (!download->download()->is_hash_checked()) {
+
+      // Set 'hashing' to started if hashing wasn't started, else keep
+      // the old value.
+      if (download->variable()->get_value("hashing") == Download::variable_hashing_stopped)
+	download->variable()->set("hashing", Download::variable_hashing_started);
+
+      control->core()->hash_queue()->insert(download);
+      return;
+    }
+
+    if (download->is_done()) {
+      download->set_connection_type(download->variable()->get_string("connection_seed"));
+    } else {
+      download->set_connection_type(download->variable()->get_string("connection_leech"));
+
+      // For the moment, clear the resume data so we force hash-check
+      // on non-complete downloads after a crash. This shouldn't be
+      // needed, but for some reason linux 2.6 is very lazy about
+      // updating mtime.
+      download->download()->hash_resume_clear();
+    }
+
+    // Update the priority to ensure it has the correct
+    // seeding/unfinished modifiers.
+    download->set_priority(download->priority());
+    download->download()->start();
+
+    std::for_each(m_slotMapStart.begin(), m_slotMapStart.end(), download_list_call(download));
+
+  } catch (torrent::local_error& e) {
+    control->core()->push_log(e.what());
+  }
 }
 
 void
-DownloadList::resume(Download* d) {
+DownloadList::pause(Download* download) {
+  check_contains(download);
+
   try {
-    if (!d->download()->is_open())
-      std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(d));
-      
-    if (d->download()->is_hash_checked())
-      std::for_each(m_slotMapStart.begin(), m_slotMapStart.end(), download_list_call(d));
-    else
-      // TODO: This can cause infinit looping?
-      control->core()->hash_queue().insert(d, sigc::bind(sigc::mem_fun(*this, &DownloadList::resume), d));
+
+    // Make sure we don't start hash checking a download that we won't
+    // start.
+    control->core()->hash_queue()->remove(download);
+
+    if (!download->download()->is_active())
+      return;
+
+    download->download()->stop();
+    download->download()->hash_resume_save();
+    
+    std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(download));
+
+    download->variable()->set("state_changed", cachedTime.seconds());
+
+    // Save the state after all the slots, etc have been called so we
+    // include the modifications they may make.
+    //control->core()->download_store()->save(download);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
 void
-DownloadList::pause(Download* d) {
+DownloadList::check_hash(Download* download) {
+  check_contains(download);
+
   try {
 
-    if (d->download()->is_active())
-      std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(d));
+    download->variable()->set("hashing", Download::variable_hashing_started);
+    check_hash_throw(download);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
+// Throw in addition to not setting 'hashing'.
 void
-DownloadList::clear() {
-  std::for_each(begin(), end(), rak::call_delete<Download>());
+DownloadList::check_hash_throw(Download* download) {
+  check_contains(download);
+
+  close_throw(download);
+  download->download()->hash_resume_clear();
+  open_throw(download);
+
+  // If any more stuff is added here, make sure resume etc are still
+  // correct.
+  control->core()->hash_queue()->insert(download);
+}
+
+void
+DownloadList::hash_done(Download* download) {
+  check_contains(download);
 
-  Base::clear();
+  if (!download->download()->is_hash_checked() ||
+      download->download()->is_hash_checking() ||
+      download->download()->is_active())
+    throw torrent::internal_error("DownloadList::hash_done(...) download in invalid state.");
+
+  // Need to find some sane conditional here. Can we check the total
+  // downloaded to ensure something was transferred, thus we didn't
+  // just hash an already completed torrent with lacking session data?
+  //
+  // Perhaps we should use a seperate variable or state, and check
+  // that. Thus we can bork the download if the hash check doesn't
+  // confirm all the data, avoiding large BW usage on f.ex. the
+  // ReiserFS bug with >4GB files.
+
+  int64_t hashing = download->variable()->get_value("hashing");
+  download->variable()->set("hashing", Download::variable_hashing_stopped);
+
+  switch (hashing) {
+  case Download::variable_hashing_started:
+    // Normal re/hashing.
+
+    if (download->is_done())
+      download->variable()->set("complete", (int64_t)1);
+    
+    // Save resume data so we update time-stamps and priorities if
+    // they were invalid/changed when loading.
+    download->download()->hash_resume_save();
+
+    if (download->variable()->get_value("state") == 1)
+      resume(download);
+
+    return;
+
+  case Download::variable_hashing_last:
+
+    if (download->is_done()) {
+
+      confirm_finished(download);
+
+      if (download->variable()->get_value("state") == 1)
+	resume(download);
+
+    } else {
+      download->set_message("Hash check on download completion found bad chunks.");
+    }
+    
+    return;
+
+  case Download::variable_hashing_stopped:
+  default:
+    // Either an error or someone wrote to the hashing variable...
+    download->set_message("Hash check completed but the \"hashing\" variable is in an invalid state.");
+    return;
+  }
 }
 
 void
-DownloadList::finished(Download* d) {
-  std::for_each(m_slotMapFinished.begin(), m_slotMapFinished.end(), download_list_call(d));
+DownloadList::received_finished(Download* download) {
+  check_contains(download);
+
+  if (control->variable()->get_value("check_hash")) {
+    // Set some 'checking_finished_thingie' variable to make hash_done
+    // trigger correctly, also so it can bork on missing data.
+
+    download->variable()->set("hashing", Download::variable_hashing_last);
+    check_hash_throw(download);
+
+  } else {
+    confirm_finished(download);
+  }
+}
+
+// The download must be open when we call this function.
+void
+DownloadList::confirm_finished(Download* download) {
+  check_contains(download);
+
+  // FIXME
+  //torrent::download_set_priority(m_download, 2);
+
+  download->variable()->set("complete", (int64_t)1);
+  download->set_connection_type(download->variable()->get_string("connection_seed"));
+
+  download->download()->tracker_list().send_completed();
+
+  // Do this before the slots are called in case one of them closes
+  // the download.
+  if (!download->is_active() && control->variable()->get_value("session_on_completion") == 1) {
+    download->download()->hash_resume_save();
+    control->core()->download_store()->save(download);
+  }
+
+  std::for_each(m_slotMapFinished.begin(), m_slotMapFinished.end(), download_list_call(download));
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.h	2006-03-18 06:16:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.h	2006-05-02 22:23:10.000000000 +0800
@@ -50,66 +50,105 @@
 // Container for all downloads. Add slots to the slot maps to cause
 // some action to be taken when the torrent changes states. Don't
 // change the states from outside of core.
 
 class DownloadList : private std::list<Download*> {
 public:
-  typedef std::list<Download*>                                 Base;
-  typedef std::map<std::string, sigc::slot1<void, Download*> > SlotMap;
+  typedef std::list<Download*>             base_type;
+  typedef sigc::slot1<void, Download*>     slot_type;
+  typedef std::map<std::string, slot_type> slot_map;
 
-  using Base::iterator;
-  using Base::const_iterator;
-  using Base::reverse_iterator;
-  using Base::const_reverse_iterator;
-  using Base::value_type;
-  using Base::pointer;
-
-  using Base::begin;
-  using Base::end;
-  using Base::rbegin;
-  using Base::rend;
+  using base_type::iterator;
+  using base_type::const_iterator;
+  using base_type::reverse_iterator;
+  using base_type::const_reverse_iterator;
+  using base_type::value_type;
+  using base_type::pointer;
 
-  using Base::empty;
-  using Base::size;
+  using base_type::begin;
+  using base_type::end;
+  using base_type::rbegin;
+  using base_type::rend;
 
-  ~DownloadList() { clear(); }
+  using base_type::empty;
+  using base_type::size;
 
-  iterator            insert(std::istream* str, bool printLog);
+  ~DownloadList();
+
+  void                session_save();
+
+  // Might move this to DownloadFactory.
+  Download*           create(std::istream* str, bool printLog);
+
+  iterator            insert(Download* d);
+
+  void                erase(Download* d);
   iterator            erase(iterator itr);
 
+  //void                save(Download* d);
+
   void                open(Download* d);
+  void                open_throw(Download* d);
+
   void                close(Download* d);
+  void                close_throw(Download* d);
 
   void                start(Download* d);
   void                stop(Download* d);
 
   // These do not change the rtorrent:state.
   void                resume(Download* d);
   void                pause(Download* d);
 
-  SlotMap&            slot_map_insert()     { return m_slotMapInsert; }
-  SlotMap&            slot_map_erase()      { return m_slotMapErase; }
-  SlotMap&            slot_map_open()       { return m_slotMapOpen; }
-  SlotMap&            slot_map_close()      { return m_slotMapClose; }
-  SlotMap&            slot_map_start()      { return m_slotMapStart; }
-  SlotMap&            slot_map_stop()       { return m_slotMapStop; }
+  void                check_hash(Download* d);
+  void                check_hash_throw(Download* d);
+
+  void                hash_done(Download* d);
+
+  slot_map&           slot_map_insert()                                 { return m_slotMapInsert; }
+  slot_map&           slot_map_erase()                                  { return m_slotMapErase; }
+  slot_map&           slot_map_open()                                   { return m_slotMapOpen; }
+  slot_map&           slot_map_close()                                  { return m_slotMapClose; }
+  slot_map&           slot_map_start()                                  { return m_slotMapStart; }
+  slot_map&           slot_map_stop()                                   { return m_slotMapStop; }
+
+  // The finished slots will be called when an active download with
+  // "finished" == 0 performs a hash check which returns a done
+  // torrent.
+  //
+  // But how to avoid sending 'completed' messages to the tracker?
+  // Also we need to handle cases when a hashing torrent starts up
+  // after a shutdown.
+
+  slot_map&           slot_map_hash_done()                              { return m_slotMapHashDone; }
+  slot_map&           slot_map_finished()                               { return m_slotMapFinished; }
+
+  bool                has_slot_insert(const std::string& key) const     { return m_slotMapInsert.find(key) != m_slotMapInsert.end(); }
+  bool                has_slot_erase(const std::string& key) const      { return m_slotMapErase.find(key) != m_slotMapErase.end(); }
+  bool                has_slot_open(const std::string& key) const       { return m_slotMapOpen.find(key) != m_slotMapOpen.end(); }
+  bool                has_slot_close(const std::string& key) const      { return m_slotMapClose.find(key) != m_slotMapClose.end(); }
+  bool                has_slot_start(const std::string& key) const      { return m_slotMapStart.find(key) != m_slotMapStart.end(); }
+  bool                has_slot_stop(const std::string& key) const       { return m_slotMapStop.find(key) != m_slotMapStop.end(); }
 
-  SlotMap&            slot_map_finished()   { return m_slotMapFinished; }
+  bool                has_slot_hash_done(const std::string& key) const  { return m_slotMapFinished.find(key) != m_slotMapFinished.end(); }
+  bool                has_slot_finished(const std::string& key) const   { return m_slotMapFinished.find(key) != m_slotMapFinished.end(); }
 
 private:
-  void                clear();
+  inline void         check_contains(Download* d);
 
-  void                finished(Download* d);
+  void                received_finished(Download* d);
+  void                confirm_finished(Download* d);
 
-  SlotMap             m_slotMapInsert;
-  SlotMap             m_slotMapErase;
-  SlotMap             m_slotMapOpen;
-  SlotMap             m_slotMapClose;
-  SlotMap             m_slotMapStart;
-  SlotMap             m_slotMapStop;
+  slot_map            m_slotMapInsert;
+  slot_map            m_slotMapErase;
+  slot_map            m_slotMapOpen;
+  slot_map            m_slotMapClose;
+  slot_map            m_slotMapStart;
+  slot_map            m_slotMapStop;
 
-  SlotMap             m_slotMapFinished;
+  slot_map            m_slotMapHashDone;
+  slot_map            m_slotMapFinished;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/hash_queue.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.cc	2006-04-01 05:01:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/hash_queue.cc	2006-05-02 00:30:07.000000000 +0800
@@ -38,32 +38,34 @@
 
 #include <algorithm>
 #include <stdexcept>
 #include <sigc++/bind.h>
 
 #include "download.h"
+#include "download_list.h"
 #include "rak/functional.h"
 #include "hash_queue.h"
 
 namespace core {
 
 void
-HashQueue::insert(Download* d, Slot s) {
-  if (d->download()->is_hash_checking() ||
-      find(d) != end())
+HashQueue::insert(Download* download) {
+  if (download->download()->is_hash_checking() || find(download) != end())
     return;
 
-  if (d->download()->is_hash_checked()) {
-    s();
+  if (download->download()->is_hash_checked()) {
+    m_downloadList->hash_done(download);
     return;
   }
 
-  iterator itr = Base::insert(end(), new HashQueueNode(d, s));
+  if (find(download) != end())
+    throw torrent::internal_error("HashQueue::insert(...) download already in queue.");
 
-  (*itr)->set_connection(d->download()->signal_hash_done(sigc::bind(sigc::mem_fun(*this, &HashQueue::receive_hash_done),
-								       (*itr)->download())));
+  iterator itr = Base::insert(end(), new HashQueueNode(download));
+
+  (*itr)->set_connection(download->download()->signal_hash_done(sigc::bind(sigc::mem_fun(*this, &HashQueue::receive_hash_done), download)));
 
   fill_queue();
 }
 
 void
 HashQueue::remove(Download* d) {
@@ -92,19 +94,16 @@
 HashQueue::receive_hash_done(Download* d) {
   iterator itr = find(d);
 
   if (itr == end())
     return;
 
-  Slot s = (*itr)->get_slot();
-
   delete *itr;
   Base::erase(itr);
 
-  // Can we call this before the delete?
-  s();
+  m_downloadList->hash_done(d);
   fill_queue();
 }
 
 void
 HashQueue::fill_queue() {
   if (empty() || front()->download()->download()->is_hash_checking())
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/hash_queue.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.h	2006-04-01 04:52:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/hash_queue.h	2006-05-02 00:29:58.000000000 +0800
@@ -41,19 +41,19 @@
 #include <sigc++/slot.h>
 #include <sigc++/connection.h>
 
 namespace core {
 
 class Download;
+class DownloadList;
 
 class HashQueueNode;
 
 class HashQueue : private std::list<HashQueueNode*> {
 public:
   typedef std::list<HashQueueNode*> Base;
-  typedef sigc::slot0<void>         Slot;
 
   using Base::iterator;
   using Base::const_iterator;
   using Base::reverse_iterator;
   using Base::const_reverse_iterator;
 
@@ -65,41 +65,43 @@
   using Base::front;
   using Base::back;
 
   using Base::empty;
   using Base::size;
 
-  void                insert(Download* d, Slot s);
+  // Replace 'dl' with a slot.
+  HashQueue(DownloadList* dl) : m_downloadList(dl) {}
+
+  void                insert(Download* d);
 
   // It's safe to try to remove downloads not in the queue. The hash
   // checking is not stopped if it has already started.
   void                remove(Download* d);
 
   iterator            find(Download* d);
 
 private:
   void                receive_hash_done(Download* d);
 
   void                fill_queue();
+
+  DownloadList*       m_downloadList;
 };
 
 class HashQueueNode {
 public:
-  HashQueueNode(Download* d, HashQueue::Slot s) : m_download(d), m_slot(s) {}
+  HashQueueNode(Download* d) : m_download(d) {}
   ~HashQueueNode()                                       { disconnect(); }
 
   void                disconnect()                       { m_connection.disconnect(); }
-
   Download*           download()                         { return m_download; }
-  HashQueue::Slot     get_slot()                         { return m_slot; }
 
   void                set_connection(sigc::connection c) { m_connection = c; }
 
 private:
   Download*           m_download;
-  HashQueue::Slot     m_slot;
   sigc::connection    m_connection;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/Makefile.am	2005-12-22 08:33:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.am	2006-05-02 00:28:02.000000000 +0800
@@ -24,9 +24,15 @@
 	manager.h \
 	poll_manager.cc \
 	poll_manager.h \
 	poll_manager_epoll.cc \
 	poll_manager_epoll.h \
 	poll_manager_select.cc \
-	poll_manager_select.h
+	poll_manager_select.h \
+	scheduler.cc \
+	scheduler.h \
+	view.cc \
+	view.h \
+	view_manager.cc \
+	view_manager.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/Makefile.in	2006-04-07 01:43:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.in	2006-05-02 00:47:09.000000000 +0800
@@ -55,13 +55,14 @@
 libsub_core_a_LIBADD =
 am_libsub_core_a_OBJECTS = curl_get.$(OBJEXT) curl_stack.$(OBJEXT) \
 	download.$(OBJEXT) download_factory.$(OBJEXT) \
 	download_list.$(OBJEXT) download_store.$(OBJEXT) \
 	hash_queue.$(OBJEXT) http_queue.$(OBJEXT) log.$(OBJEXT) \
 	manager.$(OBJEXT) poll_manager.$(OBJEXT) \
-	poll_manager_epoll.$(OBJEXT) poll_manager_select.$(OBJEXT)
+	poll_manager_epoll.$(OBJEXT) poll_manager_select.$(OBJEXT) \
+	scheduler.$(OBJEXT) view.$(OBJEXT) view_manager.$(OBJEXT)
 libsub_core_a_OBJECTS = $(am_libsub_core_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -208,13 +209,19 @@
 	manager.h \
 	poll_manager.cc \
 	poll_manager.h \
 	poll_manager_epoll.cc \
 	poll_manager_epoll.h \
 	poll_manager_select.cc \
-	poll_manager_select.h
+	poll_manager_select.h \
+	scheduler.cc \
+	scheduler.h \
+	view.cc \
+	view.h \
+	view_manager.cc \
+	view_manager.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .lo .o .obj
@@ -271,12 +278,15 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/http_queue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_epoll.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_select.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scheduler.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/view.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/view_manager.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.cc	2006-04-03 01:59:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.cc	2006-05-02 01:45:28.000000000 +0800
@@ -56,12 +56,15 @@
 #include "utils/variable_map.h"
 
 #include "globals.h"
 #include "curl_get.h"
 #include "download.h"
 #include "download_factory.h"
+#include "download_store.h"
+#include "hash_queue.h"
+#include "http_queue.h"
 #include "manager.h"
 #include "poll_manager_epoll.h"
 #include "poll_manager_select.h"
 
 namespace core {
 
@@ -111,12 +114,26 @@
 }
 
 Manager::Manager() :
   m_pollManager(NULL),
   m_portFirst(6890),
   m_portLast(6999) {
+
+  m_downloadStore = new DownloadStore();
+  m_downloadList = new DownloadList();
+
+  m_httpQueue = new HttpQueue();
+  m_hashQueue = new HashQueue(m_downloadList);
+}
+
+Manager::~Manager() {
+  delete m_downloadList;
+  delete m_hashQueue;
+
+  delete m_downloadStore;
+  delete m_httpQueue;
 }
 
 void
 Manager::initialize_first() {
   if ((m_pollManager = PollManagerEPoll::create(sysconf(_SC_OPEN_MAX))) != NULL)
     m_logImportant.push_front("Using 'epoll' based polling.");
@@ -130,41 +147,23 @@
 }
 
 // Most of this should be possible to move out.
 void
 Manager::initialize_second() {
   torrent::Http::set_factory(m_pollManager->get_http_stack()->get_http_factory());
-  m_httpQueue.slot_factory(m_pollManager->get_http_stack()->get_http_factory());
+  m_httpQueue->slot_factory(m_pollManager->get_http_stack()->get_http_factory());
 
   CurlStack::global_init();
 
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
-  m_downloadList.slot_map_insert()["1_connect_network_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-  m_downloadList.slot_map_insert()["1_connect_storage_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-  m_downloadList.slot_map_insert()["1_connect_tracker_dump"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_dump), sigc::ptr_fun(&receive_tracker_dump));
-
-  m_downloadList.slot_map_erase()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
-  m_downloadList.slot_map_erase()["1_store_remove"]         = sigc::mem_fun(m_downloadStore, &DownloadStore::remove);
-  m_downloadList.slot_map_erase()["1_delete_tied"]          = sigc::ptr_fun(&delete_tied);
-
-  m_downloadList.slot_map_open()["1_download_open"]         = sigc::mem_fun(&Download::call<void, &torrent::Download::open>);
-
-  // Currently does not call stop, might want to add a function that
-  // checks if we're running, and if so stop?
-  m_downloadList.slot_map_close()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
-  m_downloadList.slot_map_close()["2_download_close"]       = sigc::mem_fun(&Download::call<void, &torrent::Download::close>);
-
-  m_downloadList.slot_map_start()["1_download_start"]       = sigc::mem_fun(&Download::start);
-
-  m_downloadList.slot_map_stop()["1_download_stop"]         = sigc::mem_fun(&Download::stop);
-  m_downloadList.slot_map_stop()["2_hash_resume_save"]      = sigc::mem_fun(&Download::call<void, &torrent::Download::hash_resume_save>);
-  m_downloadList.slot_map_stop()["3_store_save"]            = sigc::mem_fun(m_downloadStore, &DownloadStore::save);
+  m_downloadList->slot_map_insert()["1_connect_network_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
+  m_downloadList->slot_map_insert()["1_connect_storage_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
+  m_downloadList->slot_map_insert()["1_connect_tracker_dump"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_dump), sigc::ptr_fun(&receive_tracker_dump));
 
-  m_downloadList.slot_map_finished()["1_download_done"]     = sigc::mem_fun(*this, &Manager::receive_download_done);
-  m_downloadList.slot_map_finished()["2_receive_finished"]  = sigc::mem_fun(&Download::receive_finished);
+  m_downloadList->slot_map_erase()["1_delete_tied"]          = sigc::ptr_fun(&delete_tied);
 }
 
 void
 Manager::cleanup() {
   // Need to disconnect log signals? Not really since we won't receive
   // any more.
@@ -174,60 +173,33 @@
 
   delete m_pollManager;
 }
 
 void
 Manager::shutdown(bool force) {
+  // This doesn't trigger a compiler error on gcc-3.4.5 for some reason.
+//   if (!force)
+//     std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::pause), &m_downloadList));
+//   else
+//     std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::close), &m_downloadList));
+
   if (!force)
-    std::for_each(m_downloadList.begin(), m_downloadList.end(), std::bind1st(std::mem_fun(&DownloadList::pause), &m_downloadList));
+    std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::pause), m_downloadList));
   else
-    std::for_each(m_downloadList.begin(), m_downloadList.end(), std::bind1st(std::mem_fun(&DownloadList::close), &m_downloadList));
-}
-
-void
-Manager::check_hash(Download* d) {
-  bool restart = d->download()->is_active();
-
-  try {
-    prepare_hash_check(d);
-
-    if (restart)
-      m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(m_downloadList, &DownloadList::resume), d));
-    else
-      m_hashQueue.insert(d, sigc::slot0<void>());
-
-  } catch (torrent::local_error& e) {
-    m_logImportant.push_front(e.what());
-    m_logComplete.push_front(e.what());
-  }
-}  
-
-void
-Manager::receive_download_done(Download* d) {
-  if (control->variable()->get("check_hash").as_string() == "yes") {
-    // Start the hash checking, send completed to tracker after
-    // finishing.
-    prepare_hash_check(d);
-
-    // TODO: Need to restart the torrent.
-    m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(*this, &Manager::receive_download_done_hash_checked), d));
-
-  } else {
-    receive_download_done_hash_checked(d);
-  }
+    std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::close), m_downloadList));
 }
 
 void
 Manager::listen_open() {
-  if (control->variable()->get_string("port_open") != "yes")
+  if (!control->variable()->get_value("port_open"))
     return;
 
   if (m_portFirst > m_portLast)
     throw torrent::input_error("Invalid port range for listening");
 
-  if (control->variable()->get("port_random").as_string() == "yes") {
+  if (control->variable()->get_value("port_random")) {
     int boundary = m_portFirst + random() % (m_portLast - m_portFirst + 1);
 
     if (torrent::connection_manager()->listen_open(boundary, m_portLast) ||
 	torrent::connection_manager()->listen_open(m_portFirst, boundary))
       return;
 
@@ -236,12 +208,17 @@
       return;
   }
 
   throw torrent::input_error("Could not open/bind a port for listening: " + std::string(rak::error_number::current().c_str()));
 }
 
+std::string
+Manager::bind_address() const {
+  return rak::socket_address::cast_from(torrent::connection_manager()->bind_address())->address_str();
+}
+
 void
 Manager::set_bind_address(const std::string& addr) {
   int err;
   rak::address_info* ai;
 
   if ((err = rak::address_info::get_address_info(addr.c_str(), PF_INET, SOCK_STREAM, &ai)) != 0)
@@ -255,22 +232,27 @@
       listen_open();
 
     } else {
       torrent::connection_manager()->set_bind_address(ai->address()->c_sockaddr());
     }
 
-    rak::address_info::free_address_info(ai);
+    m_pollManager->get_http_stack()->set_bind_address(!ai->address()->is_address_any() ? ai->address()->address_str() : std::string());
 
-    m_pollManager->get_http_stack()->set_bind_address(addr);
+    rak::address_info::free_address_info(ai);
 
   } catch (torrent::input_error& e) {
     rak::address_info::free_address_info(ai);
     throw e;
   }
 }
 
+std::string
+Manager::local_address() const {
+  return rak::socket_address::cast_from(torrent::connection_manager()->local_address())->address_str();
+}
+
 void
 Manager::set_local_address(const std::string& addr) {
   int err;
   rak::address_info* ai;
 
   if ((err = rak::address_info::get_address_info(addr.c_str(), PF_INET, SOCK_STREAM, &ai)) != 0)
@@ -278,53 +260,25 @@
   
   try {
 
     torrent::connection_manager()->set_local_address(ai->address()->c_sockaddr());
     rak::address_info::free_address_info(ai);
 
-    m_pollManager->get_http_stack()->set_bind_address(addr);
-
   } catch (torrent::input_error& e) {
     rak::address_info::free_address_info(ai);
     throw e;
   }
 }
 
 void
-Manager::prepare_hash_check(Download* d) {
-  m_downloadList.close(d);
-  d->download()->hash_resume_clear();
-  m_downloadList.open(d);
-
-  if (d->download()->is_hash_checking() ||
-      d->download()->is_hash_checked())
-    throw std::logic_error("Manager::check_hash(...) closed the torrent but is_hash_check{ing,ed}() == true");
-
-  if (m_hashQueue.find(d) != m_hashQueue.end())
-    throw std::logic_error("Manager::check_hash(...) closed the torrent but it was found in m_hashQueue");
-}
-
-void
 Manager::receive_http_failed(std::string msg) {
   m_logImportant.push_front("Http download error: \"" + msg + "\"");
   m_logComplete.push_front("Http download error: \"" + msg + "\"");
 }
 
 void
-Manager::receive_download_done_hash_checked(Download* d) {
-  m_downloadList.resume(d);
-
-  if (control->variable()->get_string("session_on_completion") == "yes")
-    m_downloadStore.save(d);
-
-  // Don't send if we did a hash check and found incompelete chunks.
-  if (d->is_done())
-    d->download()->tracker_list().send_completed();
-}
-
-void
 Manager::try_create_download(const std::string& uri, bool start, bool printLog, bool tied) {
   // Adding download.
   DownloadFactory* f = new DownloadFactory(uri, this);
 
   f->variable()->set("tied_to_file", tied ? "yes" : "no");
 
@@ -387,14 +341,14 @@
   paths.reserve(32);
 
   path_expand(&paths, uri);
 
   if (tied)
     for (std::vector<std::string>::iterator itr = paths.begin(); itr != paths.end(); )
-      if (std::find_if(m_downloadList.begin(), m_downloadList.end(),
-		       rak::equal(*itr, rak::bind2nd(std::mem_fun(&Download::variable_string), "tied_to_file"))) != m_downloadList.end())
+      if (std::find_if(m_downloadList->begin(), m_downloadList->end(),
+		       rak::equal(*itr, rak::bind2nd(std::mem_fun(&Download::variable_string), "tied_to_file"))) != m_downloadList->end())
 	itr = paths.erase(itr);
       else
 	itr++;
 
   if (!paths.empty())
     for (std::vector<std::string>::iterator itr = paths.begin(); itr != paths.end(); ++itr)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.h	2006-03-18 04:00:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.h	2006-05-02 00:29:58.000000000 +0800
@@ -37,36 +37,40 @@
 #ifndef RTORRENT_CORE_MANAGER_H
 #define RTORRENT_CORE_MANAGER_H
 
 #include <iosfwd>
 
 #include "download_list.h"
-#include "download_store.h"
-#include "hash_queue.h"
-#include "http_queue.h"
 #include "poll_manager.h"
 #include "log.h"
 
 namespace torrent {
   class Bencode;
 }
 
 namespace core {
 
+class DownloadStore;
+class HashQueue;
+class HttpQueue;
+
 class Manager {
 public:
   typedef DownloadList::iterator                    DListItr;
   typedef sigc::slot1<void, DownloadList::iterator> SlotReady;
   typedef sigc::slot0<void>                         SlotFailed;
 
   Manager();
+  ~Manager();
+
 
-  DownloadList&       download_list()                 { return m_downloadList; }
-  DownloadStore&      download_store()                { return m_downloadStore; }
-  HashQueue&          hash_queue()                    { return m_hashQueue; }
-  HttpQueue&          http_queue()                    { return m_httpQueue; }
+  DownloadList*       download_list()                     { return m_downloadList; }
+  DownloadStore*      download_store()                    { return m_downloadStore; }
+
+  HashQueue*          hash_queue()                        { return m_hashQueue; }
+  HttpQueue*          http_queue()                        { return m_httpQueue; }
 
   PollManager*        get_poll_manager()                  { return m_pollManager; }
   Log&                get_log_important()                 { return m_logImportant; }
   Log&                get_log_complete()                  { return m_logComplete; }
 
   void                set_port_range(int a, int b)        { m_portFirst = a; m_portLast = b; }
@@ -75,42 +79,38 @@
   void                initialize_first();
   void                initialize_second();
   void                cleanup();
 
   void                listen_open();
 
+  std::string         bind_address() const;
   void                set_bind_address(const std::string& addr);
+
+  std::string         local_address() const;
   void                set_local_address(const std::string& addr);
 
   void                shutdown(bool force);
 
-  void                check_hash(Download* d);
-
   void                push_log(const std::string& msg)    { m_logImportant.push_front(msg); m_logComplete.push_front(msg); }
 
   // Temporary, find a better place for this.
   void                try_create_download(const std::string& uri, bool start, bool printLog = true, bool tied = false);
   void                try_create_download_expand(const std::string& uri, bool start, bool printLog = true, bool tied = false);
 
 private:
   void                create_http(const std::string& uri);
   void                create_final(std::istream* s);
 
   void                initialize_bencode(Download* d);
 
-  void                prepare_hash_check(Download* d);
-
   void                receive_http_failed(std::string msg);
-  void                receive_download_done_hash_checked(Download* d);
-  void                receive_download_inserted(Download* d);
-  void                receive_download_done(Download* d);
-
-  DownloadList        m_downloadList;
-  DownloadStore       m_downloadStore;
-  HashQueue           m_hashQueue;
-  HttpQueue           m_httpQueue;
+
+  DownloadList*       m_downloadList;
+  DownloadStore*      m_downloadStore;
+  HashQueue*          m_hashQueue;
+  HttpQueue*          m_httpQueue;
 
   PollManager*        m_pollManager;
   Log                 m_logImportant;
   Log                 m_logComplete;
 
   int                 m_portFirst;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/poll_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/poll_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/poll_manager.cc	2006-01-22 04:51:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/poll_manager.cc	2006-05-02 00:30:07.000000000 +0800
@@ -33,14 +33,14 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <cerrno>
 #include <stdexcept>
+#include <rak/error_number.h>
 
 #include "poll_manager.h"
 
 namespace core {
 
 PollManager::PollManager(torrent::Poll* poll) :
@@ -90,11 +90,11 @@
   delete m_errorSet;
 #endif
 }
 
 void
 PollManager::check_error() {
-  if (errno != EINTR)
-    throw std::runtime_error("Poll::work(): select error");
+  if (rak::error_number::current().value() != rak::error_number::e_intr)
+    throw std::runtime_error("Poll::work(): " + std::string(rak::error_number::current().c_str()));
 }
 
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: scheduler.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: scheduler.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: view.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: view.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: view_manager.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: view_manager.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.cc	2006-04-01 05:41:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/utils.cc	2006-05-02 00:30:08.000000000 +0800
@@ -52,27 +52,37 @@
 #include "utils.h"
 
 namespace display {
 
 char*
 print_string(char* first, char* last, char* str) {
+  if (first == last)
+    return first;
+
   // We don't have any nice simple functions for copying strings that
   // return the end address.
-  while (first != last && *str != '\0')
+  while (first + 1 != last && *str != '\0')
     *(first++) = *(str++);
 
+  *first = '\0';
+
   return first;
 }
 
 char*
 print_hhmmss(char* first, char* last, time_t t) {
+  return print_buffer(first, last, "%2d:%02d:%02d", (int)t / 3600, ((int)t / 60) % 60, (int)t % 60);
+}
+
+char*
+print_hhmmss_local(char* first, char* last, time_t t) {
   std::tm *u = std::localtime(&t);
   
   if (u == NULL)
     //return "inv_time";
-    throw torrent::internal_error("print_hhmmss(...) failed.");
+    throw torrent::internal_error("print_hhmmss_local(...) failed.");
 
   return print_buffer(first, last, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
 }
 
 char*
 print_ddhhmm(char* first, char* last, time_t t) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/utils.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.h	2006-03-02 02:53:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/utils.h	2006-05-02 00:29:58.000000000 +0800
@@ -56,12 +56,13 @@
 
 namespace display {
 
 char*       print_string(char* first, char* last, char* str);
 
 char*       print_hhmmss(char* first, char* last, time_t t);
+char*       print_hhmmss_local(char* first, char* last, time_t t);
 char*       print_ddhhmm(char* first, char* last, time_t t);
 char*       print_ddmmyyyy(char* first, char* last, time_t t);
 
 char*       print_download_title(char* first, char* last, core::Download* d);
 char*       print_download_info(char* first, char* last, core::Download* d);
 char*       print_download_status(char* first, char* last, core::Download* d);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_download_list.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_download_list.cc	2006-05-02 00:30:08.000000000 +0800
@@ -36,68 +36,77 @@
 
 #include "config.h"
 
 #include <rak/algorithm.h>
 
 #include "core/download.h"
+#include "core/view.h"
 
 #include "canvas.h"
 #include "globals.h"
 #include "utils.h"
 #include "window_download_list.h"
 
 namespace display {
 
-WindowDownloadList::WindowDownloadList(DList* l) :
-  Window(new Canvas, true),
-  m_list(l) {
-
-  m_connChanged = m_list->signal_changed().connect(sigc::mem_fun(*this, &Window::mark_dirty));
+WindowDownloadList::~WindowDownloadList() {
+  m_connChanged.disconnect();
 }
 
-WindowDownloadList::~WindowDownloadList() {
+void
+WindowDownloadList::set_view(core::View* l) {
+  m_view = l;
+
   m_connChanged.disconnect();
+
+  if (m_view != NULL)
+    m_connChanged = m_view->signal_changed().connect(sigc::mem_fun(*this, &Window::mark_dirty));
 }
 
 void
 WindowDownloadList::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
 
   m_canvas->erase();
 
-  if (m_list->base().empty() || m_canvas->get_width() < 5)
+  if (m_view == NULL)
+    return;
+
+  m_canvas->print(0, 0, "%s", ("[View: " + m_view->name() + "]").c_str());
+
+  if (m_view->empty() || m_canvas->get_width() < 5 || m_canvas->get_height() < 2)
     return;
 
-  typedef std::pair<DList::iterator, DList::iterator> Range;
+  typedef std::pair<core::View::iterator, core::View::iterator> Range;
 
-  Range range = rak::advance_bidirectional(m_list->begin(),
-					   m_list->get_focus() != m_list->end() ? m_list->get_focus() : m_list->begin(),
-					   m_list->end(),
+  Range range = rak::advance_bidirectional(m_view->begin(),
+					   m_view->focus() != m_view->end() ? m_view->focus() : m_view->begin(),
+					   m_view->end(),
 					   m_canvas->get_height() / 3);
 
   // Make sure we properly fill out the last lines so it looks like
   // there are more torrents, yet don't hide it if we got the last one
   // in focus.
-  if (range.second != m_list->end())
+  if (range.second != m_view->end())
     ++range.second;
 
-  int pos = 0;
+  int pos = 1;
 
   while (range.first != range.second) {
     char buffer[m_canvas->get_width()];
     char* position;
     char* last = buffer + m_canvas->get_width() - 2;
 
     position = print_download_title(buffer, last, *range.first);
-    m_canvas->print(0, pos++, "%c %s", range.first == m_list->get_focus() ? '*' : ' ', buffer);
+    m_canvas->print(0, pos++, "%c %s", range.first == m_view->focus() ? '*' : ' ', buffer);
     
     position = print_download_info(buffer, last, *range.first);
-    m_canvas->print(0, pos++, "%c %s", range.first == m_list->get_focus() ? '*' : ' ', buffer);
+    m_canvas->print(0, pos++, "%c %s", range.first == m_view->focus() ? '*' : ' ', buffer);
 
     position = print_download_status(buffer, last, *range.first);
-    m_canvas->print(0, pos++, "%c %s", range.first == m_list->get_focus() ? '*' : ' ', buffer);
+    m_canvas->print(0, pos++, "%c %s", range.first == m_view->focus() ? '*' : ' ', buffer);
 
     ++range.first;
   }    
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_download_list.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_download_list.h	2006-05-02 00:29:58.000000000 +0800
@@ -39,27 +39,30 @@
 
 #include <sigc++/connection.h>
 
 #include "window.h"
 
 #include "core/download_list.h"
-#include "utils/list_focus.h"
+
+namespace core {
+  class View;
+}
 
 namespace display {
 
 class WindowDownloadList : public Window {
 public:
-  typedef utils::ListFocus<core::DownloadList> DList;
-
-  WindowDownloadList(DList* l);
+  WindowDownloadList() : Window(new Canvas, true), m_view(NULL) {}
   ~WindowDownloadList();
 
   virtual void        redraw();
 
+  void                set_view(core::View* l);
+
 private:
-  DList*              m_list;
+  core::View*         m_view;
 
   sigc::connection    m_connChanged;
 };
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_log.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_log.cc	2006-05-02 00:30:08.000000000 +0800
@@ -68,13 +68,13 @@
   m_canvas->erase();
 
   int pos = 0;
 
   for (core::Log::iterator itr = m_log->begin(), end = find_older(); itr != end && pos < m_canvas->get_height(); ++itr) {
     char buffer[16];
-    print_hhmmss(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
+    print_hhmmss_local(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
 
     m_canvas->print(0, pos++, "(%s) %s", buffer, itr->second.c_str());
   }
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_log_complete.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_log_complete.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_log_complete.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_log_complete.cc	2006-05-02 00:30:08.000000000 +0800
@@ -68,13 +68,13 @@
   int pos = 0;
 
   m_canvas->print(std::max(0, (int)m_canvas->get_width() / 2 - 5), pos++, "*** Log ***");
 
   for (core::Log::iterator itr = m_log->begin(), e = m_log->end(); itr != e && pos < m_canvas->get_height(); ++itr) {
     char buffer[16];
-    print_hhmmss(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
+    print_hhmmss_local(buffer, buffer + 16, static_cast<time_t>(itr->first.seconds()));
 
     m_canvas->print(0, pos++, "(%s) %s", buffer, itr->second.c_str());
   }
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_info.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_peer_info.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_info.cc	2006-04-01 05:06:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_peer_info.cc	2006-05-02 00:30:08.000000000 +0800
@@ -63,27 +63,31 @@
 void
 WindowPeerInfo::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
   m_canvas->erase();
 
   int y = 0;
+  char buffer[256];
+  char* position;
+
   torrent::Download* d = m_download->download();
 
   m_canvas->print(0, y++, "Hash:    %s", rak::transform_hex(d->info_hash()).c_str());
   m_canvas->print(0, y++, "Id:      %s", rak::copy_escape_html(d->local_id()).c_str());
   m_canvas->print(0, y++, "Chunks:  %u / %u * %u",
 		  d->chunks_done(),
 		  d->chunks_total(),
 		  d->chunks_size());
 
-  char buffer[32], *position;
-  position = print_ddmmyyyy(buffer, buffer + 32, static_cast<time_t>(d->creation_date()));
-  position = print_string(position, buffer + 32, " ");
-  position = print_hhmmss(position, buffer + 32, static_cast<time_t>(d->creation_date()));
+  y++;
+
+  position = print_date(buffer, buffer + 256, static_cast<time_t>(d->creation_date()));
+  m_canvas->print(0, y++, "Created:       %s", buffer);
 
-  m_canvas->print(0, y++, "Created: %s", buffer);
+  position = print_timer(buffer, buffer + 256, static_cast<time_t>(m_download->variable()->get_value("state_changed")));
+  m_canvas->print(0, y++, "State Changed: %s", buffer);
 
   y++;
 
   m_canvas->print(0, y++, "Connection Type: %s ( %s / %s )",
 		  m_download->variable()->get("connection_current").as_string().c_str(),
 		  m_download->variable()->get("connection_seed").as_string().c_str(),
@@ -137,7 +141,24 @@
 WindowPeerInfo::done_percentage(torrent::Peer& p) {
   int chunks = m_download->download()->chunks_total();
 
   return chunks ? (100 * p.chunks_done()) / chunks : 0;
 }
 
+char*
+WindowPeerInfo::print_date(char* buf, char* end, time_t t) {
+  buf = print_ddmmyyyy(buf, end, t);
+  buf = print_string(buf, end, " ");
+  buf = print_hhmmss_local(buf, end, t);
+
+  return buf;
+}
+
+char*
+WindowPeerInfo::print_timer(char* buf, char* end, time_t t) {
+  if (t == 0)
+    return print_string(buf, end, "--:--:--");
+  else
+    return print_hhmmss(buf, end, cachedTime.seconds() - t);
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_info.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_peer_info.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_info.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_peer_info.h	2006-05-02 00:29:58.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_DISPLAY_PEER_INFO_H
 #define RTORRENT_DISPLAY_PEER_INFO_H
 
+#include <ctime>
 #include <list>
 #include <torrent/peer.h>
 
 #include "window.h"
 
 namespace core {
@@ -51,20 +52,23 @@
 class WindowPeerInfo : public Window {
 public:
   typedef std::list<torrent::Peer> PList;
 
   WindowPeerInfo(core::Download* d, PList* l, PList::iterator* f);
 
-  virtual void     redraw();
+  virtual void        redraw();
 
 private:
-  int              done_percentage(torrent::Peer& p);
+  int                 done_percentage(torrent::Peer& p);
 
-  core::Download*  m_download;
+  char*               print_date(char* buf, char* end, time_t t);
+  char*               print_timer(char* buf, char* end, time_t t);
 
-  PList*           m_list;
-  PList::iterator* m_focus;
+  core::Download*     m_download;
+
+  PList*              m_list;
+  PList::iterator*    m_focus;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/main.cc	2006-04-01 04:48:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/main.cc	2006-05-04 01:19:44.000000000 +0800
@@ -47,12 +47,13 @@
 #ifdef USE_EXECINFO
 #include <execinfo.h>
 #endif
 
 #include "core/download.h"
 #include "core/download_factory.h"
+#include "core/download_store.h"
 #include "core/manager.h"
 #include "display/canvas.h"
 #include "display/window.h"
 #include "display/manager.h"
 #include "input/bindings.h"
 
@@ -94,13 +95,13 @@
   }
 }
 
 void
 load_session_torrents(Control* c) {
   // Load session torrents.
-  std::list<std::string> l = c->core()->download_store().get_formated_entries().make_list();
+  std::list<std::string> l = c->core()->download_store()->get_formated_entries().make_list();
 
   for (std::list<std::string>::iterator first = l.begin(), last = l.end(); first != last; ++first) {
     core::DownloadFactory* f = new core::DownloadFactory(*first, c->core());
 
     // Replace with session torrent flag.
     f->set_session(true);
@@ -159,15 +160,58 @@
     control->core()->initialize_first();
 
     // Initialize option handlers after libtorrent to ensure
     // torrent::ConnectionManager* is valid etc.
     initialize_option_handler(control);
 
-    // Move env and go through "try_import".
-    if (!control->variable()->process_file("~/.rtorrent.rc"))
-      control->core()->get_log_important().push_front("Could not load \"~/.rtorrent.rc\".");
+    // Currently not doing any sorting on main.
+    control->variable()->process_command("view_add = main");
+    //control->variable()->process_command("view_sort_current = name,started,name");
+
+    control->variable()->process_command("view_add = name");
+    control->variable()->process_command("view_sort_new = name,name");
+    control->variable()->process_command("view_sort_current = name,name");
+
+    control->variable()->process_command("view_add = started");
+    control->variable()->process_command("view_filter = started,started");
+    control->variable()->process_command("view_sort_new = started,name");
+    control->variable()->process_command("view_sort_current = started,name");
+
+    control->variable()->process_command("view_add = stopped");
+    control->variable()->process_command("view_filter = stopped,stopped");
+    control->variable()->process_command("view_sort_new = stopped,name");
+    control->variable()->process_command("view_sort_current = stopped,name");
+
+    control->variable()->process_command("view_add = complete");
+    control->variable()->process_command("view_filter = complete,complete");
+    control->variable()->process_command("view_sort_new = complete,state_changed");
+    control->variable()->process_command("view_sort_current = complete,state_changed_reverse");
+
+    control->variable()->process_command("view_add = incomplete");
+    control->variable()->process_command("view_filter = incomplete,incomplete");
+    control->variable()->process_command("view_sort_new = incomplete,state_changed");
+    control->variable()->process_command("view_sort_current = incomplete,state_changed_reverse");
+
+    control->variable()->process_command("schedule = view_main,10,10,view_sort=main,20");
+    control->variable()->process_command("schedule = view_name,10,10,view_sort=name,20");
+    control->variable()->process_command("schedule = view_started,10,10,view_sort=started,5");
+    control->variable()->process_command("schedule = view_stopped,10,10,view_sort=stopped,5");
+    control->variable()->process_command("schedule = view_complete,10,10,view_sort=complete,5");
+    control->variable()->process_command("schedule = view_incomplete,10,10,view_sort=incomplete,5");
+
+    //control->variable()->process_command("schedule = scheduler,10,10,download_scheduler=");
+    control->variable()->process_command("schedule = session_save,1800,1800,session_save=");
+
+    // Changing these will bork the (non-existant) scheduler.
+    control->variable()->process_command("view_add = scheduler");
+    control->variable()->process_command("view_sort_new = scheduler,state_changed"); // add started?
+    control->variable()->process_command("view_sort_current = scheduler,state_changed");
+
+    //    control->variable()->process_command("schedule = scheduler,10,10,download_scheduler=");
+
+    control->variable()->process_command("try_import = ~/.rtorrent.rc");
 
     int firstArg = parse_options(control, argc, argv);
 
     control->initialize();
 
     // Load session torrents and perform scheduled tasks to ensure
@@ -193,12 +237,14 @@
       rak::priority_queue_perform(&taskScheduler, cachedTime);
 
       // Do shutdown check before poll, not after.
       control->core()->get_poll_manager()->poll(client_next_timeout());
     }
 
+    control->core()->download_list()->session_save();
+
     control->cleanup();
 
   } catch (std::exception& e) {
     display::Canvas::cleanup();
     delete control;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/option_handler_rules.cc	2006-04-03 22:51:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_handler_rules.cc	2006-05-02 00:30:08.000000000 +0800
@@ -49,35 +49,27 @@
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 #include <torrent/tracker.h>
 #include <torrent/tracker_list.h>
 
 #include "core/download.h"
+#include "core/download_store.h"
 #include "core/manager.h"
+#include "core/scheduler.h"
+#include "core/view_manager.h"
 #include "ui/root.h"
 #include "utils/directory.h"
 #include "utils/variable_generic.h"
 #include "utils/variable_map.h"
 
 #include "globals.h"
 #include "control.h"
 #include "option_handler_rules.h"
 #include "command_scheduler.h"
 
 void
-apply_umask(int arg) {
-  umask(arg);
-}
-
-void
-apply_working_directory(const std::string& path) {
-  if (chdir(path.c_str()) != 0)
-    throw torrent::input_error("Could not change working directory.");
-}
-
-void
 apply_hash_read_ahead(__UNUSED Control* m, int arg) {
   torrent::set_hash_read_ahead(arg << 20);
 }
 
 void
 apply_hash_interval(__UNUSED Control* m, int arg) {
@@ -93,59 +85,54 @@
   std::sscanf(arg.c_str(), "%i-%i", &a, &b);
 
   m->core()->set_port_range(a, b);
 }
 
 void
-apply_http_proxy(Control* m, const std::string& arg) {
-  m->core()->get_poll_manager()->get_http_stack()->set_http_proxy(arg);
-}
-
-void
 apply_load(Control* m, const std::string& arg) {
   m->core()->try_create_download_expand(arg, false, false, true);
 }
 
 void
 apply_load_start(Control* m, const std::string& arg) {
   m->core()->try_create_download_expand(arg, true, false, true);
 }
 
 void
-apply_stop_untied(Control* m, __UNUSED const std::string& arg) {
-  core::Manager::DListItr itr = m->core()->download_list().begin();
+apply_stop_untied(Control* m) {
+  core::Manager::DListItr itr = m->core()->download_list()->begin();
 
-  while ((itr = std::find_if(itr, m->core()->download_list().end(),
+  while ((itr = std::find_if(itr, m->core()->download_list()->end(),
 			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
 				     std::not1(std::mem_fun_ref(&std::string::empty)))))
-	 != m->core()->download_list().end()) {
+	 != m->core()->download_list()->end()) {
     rak::file_stat fs;
 
     if (!fs.update(rak::path_expand((*itr)->variable_string("tied_to_file")))) {
       (*itr)->variable()->set("tied_to_file", std::string());
-      m->core()->download_list().stop(*itr);
+      m->core()->download_list()->stop(*itr);
     }
 
     ++itr;
   }
 }
 
 void
-apply_remove_untied(Control* m, __UNUSED const std::string& arg) {
-  core::Manager::DListItr itr = m->core()->download_list().begin();
+apply_remove_untied(Control* m) {
+  core::Manager::DListItr itr = m->core()->download_list()->begin();
 
-  while ((itr = std::find_if(itr, m->core()->download_list().end(),
+  while ((itr = std::find_if(itr, m->core()->download_list()->end(),
 			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
 				     std::not1(std::mem_fun_ref(&std::string::empty)))))
-	 != m->core()->download_list().end()) {
+	 != m->core()->download_list()->end()) {
     rak::file_stat fs;
 
     if (!fs.update(rak::path_expand((*itr)->variable_string("tied_to_file")))) {
       (*itr)->variable()->set("tied_to_file", std::string());
-      m->core()->download_list().stop(*itr);
-      itr = m->core()->download_list().erase(itr);
+      m->core()->download_list()->stop(*itr);
+      itr = m->core()->download_list()->erase(itr);
 
     } else {
       ++itr;
     }
   }
 }
@@ -156,23 +143,23 @@
 }
 
 void
 apply_enable_trackers(Control* m, __UNUSED const std::string& arg) {
   bool state = (arg != "no");
 
-  for (core::Manager::DListItr itr = m->core()->download_list().begin(), last = m->core()->download_list().end(); itr != last; ++itr) {
+  for (core::Manager::DListItr itr = m->core()->download_list()->begin(), last = m->core()->download_list()->end(); itr != last; ++itr) {
 
     torrent::TrackerList tl = (*itr)->download()->tracker_list();
 
     for (int i = 0, last = tl.size(); i < last; ++i)
       if (state)
 	tl.get(i).enable();
       else
 	tl.get(i).disable();
 
-    if (state && control->variable()->get_string("use_udp_trackers") == "no")
+    if (state && !control->variable()->get_value("use_udp_trackers"))
       (*itr)->enable_udp_trackers(false);
   }    
 }
 
 void
 apply_tos(const std::string& arg) {
@@ -195,74 +182,190 @@
 
   else 
     throw torrent::input_error("Invalid TOS identifier.");
 }
 
 void
+apply_view_filter(Control* control, const std::string& arg) {
+  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+
+  std::string name = rak::trim(*itr);
+  
+  if (name.empty())
+    throw torrent::input_error("First argument must be a string.");
+
+  core::ViewManager::filter_args filterArgs;
+
+  while (++itr != rak::split_iterator(arg)) {
+    filterArgs.push_back(rak::trim(*itr));
+
+    if (filterArgs.back().empty())
+      throw torrent::input_error("One of the arguments is empty.");
+  }
+
+  control->view_manager()->set_filter(name, filterArgs);
+}
+
+void
+apply_view_sort(Control* control, const std::string& arg) {
+  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+
+  std::string name = rak::trim(*itr);
+  ++itr;
+
+  if (name.empty())
+    throw torrent::input_error("First argument must be a string.");
+
+  // Need some generic tools for this, rather than hacking up
+  // something every time...
+  std::string arg1;
+  int32_t value = 0;
+
+  if (itr != rak::split_iterator(arg) && !(arg1 = *itr).empty()) {
+    char* endPtr;
+
+    if ((value = strtol(arg1.c_str(), &endPtr, 0)) < 0 || *endPtr != '\0')
+      throw torrent::input_error("Second argument must be a value.");
+  }
+      
+  control->view_manager()->sort(name, value);
+}
+
+void
+apply_view_sort_current(Control* control, const std::string& arg) {
+  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+
+  std::string name = rak::trim(*itr);
+  
+  if (name.empty())
+    throw torrent::input_error("First argument must be a string.");
+
+  core::ViewManager::sort_args sortArgs;
+
+  while (++itr != rak::split_iterator(arg)) {
+    sortArgs.push_back(rak::trim(*itr));
+
+    if (sortArgs.back().empty())
+      throw torrent::input_error("One of the arguments is empty.");
+  }
+
+  control->view_manager()->set_sort_current(name, sortArgs);
+}
+
+void
+apply_view_sort_new(Control* control, const std::string& arg) {
+  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+
+  std::string name = rak::trim(*itr);
+  
+  if (name.empty())
+    throw torrent::input_error("First argument must be a string.");
+
+  core::ViewManager::sort_args sortArgs;
+
+  while (++itr != rak::split_iterator(arg)) {
+    sortArgs.push_back(rak::trim(*itr));
+
+    if (sortArgs.back().empty())
+      throw torrent::input_error("One of the arguments is empty.");
+  }
+
+  control->view_manager()->set_sort_new(name, sortArgs);
+}
+
+void
+apply_import(const std::string& path) {
+  if (!control->variable()->process_file(path))
+    throw torrent::input_error("Could not open option file: " + path);
+}
+
+void
+apply_try_import(const std::string& path) {
+  if (!control->variable()->process_file(path))
+    control->core()->push_log("Could not read resource file: " + path);
+}
+
+void
 initialize_option_handler(Control* c) {
   utils::VariableMap* variables = control->variable();
 
-  // Cleaned up.
-  variables->insert("check_hash",            new utils::VariableAny("yes"));
-  variables->insert("use_udp_trackers",      new utils::VariableAny("yes"));
-  variables->insert("port_open",             new utils::VariableAny("yes"));
-  variables->insert("port_random",           new utils::VariableAny("yes"));
+  variables->insert("check_hash",            new utils::VariableBool(true));
+  variables->insert("use_udp_trackers",      new utils::VariableBool(true));
+  variables->insert("port_open",             new utils::VariableBool(true));
+  variables->insert("port_random",           new utils::VariableBool(true));
 
   variables->insert("tracker_dump",          new utils::VariableAny(std::string()));
 
-  variables->insert("session",               new utils::VariableSlotString<>(NULL, rak::mem_fn(&control->core()->download_store(), &core::DownloadStore::set_path)));
-  variables->insert("session_lock",          new utils::VariableAny("yes"));
-  variables->insert("session_on_completion", new utils::VariableAny("yes"));
+  variables->insert("session",               new utils::VariableStringSlot(rak::mem_fn(control->core()->download_store(), &core::DownloadStore::path),
+									   rak::mem_fn(control->core()->download_store(), &core::DownloadStore::set_path)));
+  variables->insert("session_lock",          new utils::VariableBool(true));
+  variables->insert("session_on_completion", new utils::VariableBool(true));
+  variables->insert("session_save",          new utils::VariableVoidSlot(rak::mem_fn(c->core()->download_list(), &core::DownloadList::session_save)));
 
   variables->insert("connection_leech",      new utils::VariableAny("leech"));
   variables->insert("connection_seed",       new utils::VariableAny("seed"));
 
   variables->insert("directory",             new utils::VariableAny("./"));
-  variables->insert("working_directory",     new utils::VariableSlotString<>(NULL, rak::ptr_fn(&apply_working_directory)));
-  variables->insert("bind",                  new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::set_bind_address)));
-  variables->insert("ip",                    new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::set_local_address)));
 
-  variables->insert("tos",                   new utils::VariableSlotString<>(NULL, rak::ptr_fn(&apply_tos)));
+  variables->insert("tos",                   new utils::VariableStringSlot(rak::value_fn(std::string()), rak::ptr_fn(&apply_tos)));
+
+  variables->insert("bind",                  new utils::VariableStringSlot(rak::mem_fn(control->core(), &core::Manager::bind_address),
+									   rak::mem_fn(control->core(), &core::Manager::set_bind_address)));
+  variables->insert("ip",                    new utils::VariableStringSlot(rak::mem_fn(control->core(), &core::Manager::local_address),
+									   rak::mem_fn(control->core(), &core::Manager::set_local_address)));
+
+  variables->insert("http_proxy",            new utils::VariableStringSlot(rak::mem_fn(c->core()->get_poll_manager()->get_http_stack(), &core::CurlStack::http_proxy),
+									   rak::mem_fn(c->core()->get_poll_manager()->get_http_stack(), &core::CurlStack::set_http_proxy)));
 
   variables->insert("min_peers",             new utils::VariableValue(40));
   variables->insert("max_peers",             new utils::VariableValue(100));
   variables->insert("max_uploads",           new utils::VariableValue(15));
 
-  variables->insert("download_rate",         new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_down_throttle), "%i"));
-  variables->insert("upload_rate",           new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_up_throttle), "%i"));
-
-  variables->insert("hash_max_tries",        new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_hash_max_tries), "%i"));
-  variables->insert("max_open_files",        new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_files), "%i"));
-  variables->insert("max_open_sockets",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_sockets), "%i"));
-
-  variables->insert("print",                 new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::push_log)));
-  variables->insert("import",                new utils::VariableSlotString<>(NULL, rak::mem_fn(control->variable(), &utils::VariableMap::process_file_throw)));
-  variables->insert("try_import",            new utils::VariableSlotString<>(NULL, rak::mem_fn(control->variable(), &utils::VariableMap::process_file_nothrow)));
+  variables->insert("download_rate",         new utils::VariableValueSlot(rak::ptr_fn(&torrent::down_throttle), rak::mem_fn(control->ui(), &ui::Root::set_down_throttle_i64),
+									  0, (1 << 10)));
+  variables->insert("upload_rate",           new utils::VariableValueSlot(rak::ptr_fn(&torrent::up_throttle), rak::mem_fn(control->ui(), &ui::Root::set_up_throttle_i64),
+									  0, (1 << 10)));
+
+  variables->insert("hash_max_tries",        new utils::VariableValueSlot(rak::ptr_fn(&torrent::hash_max_tries), rak::ptr_fn(&torrent::set_hash_max_tries)));
+  variables->insert("max_open_files",        new utils::VariableValueSlot(rak::ptr_fn(&torrent::max_open_files), rak::ptr_fn(&torrent::set_max_open_files)));
+  variables->insert("max_open_sockets",      new utils::VariableValueSlot(rak::ptr_fn(&torrent::max_open_sockets), rak::ptr_fn(&torrent::set_max_open_sockets)));
+
+  variables->insert("print",                 new utils::VariableStringSlot(rak::value_fn(std::string()), rak::mem_fn(control->core(), &core::Manager::push_log)));
+  variables->insert("import",                new utils::VariableStringSlot(rak::value_fn(std::string()), rak::ptr_fn(&apply_import)));
+  variables->insert("try_import",            new utils::VariableStringSlot(rak::value_fn(std::string()), rak::ptr_fn(&apply_try_import)));
+
+  variables->insert("view_add",              new utils::VariableStringSlot(rak::value_fn(std::string()), rak::mem_fn(c->view_manager(), &core::ViewManager::insert_throw)));
+  variables->insert("view_filter",           new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_filter, c)));
+
+  variables->insert("view_sort",             new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_sort, c)));
+  variables->insert("view_sort_new",         new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_sort_new, c)));
+  variables->insert("view_sort_current",     new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_sort_current, c)));
+
+  variables->insert("schedule",              new utils::VariableStringSlot(rak::value_fn(std::string()), rak::mem_fn(c->command_scheduler(), &CommandScheduler::parse)));
+  variables->insert("schedule_remove",       new utils::VariableStringSlot(rak::value_fn(std::string()),
+									   rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::erase)));
 
-  variables->insert("schedule",              new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::parse)));
-  variables->insert("schedule_remove",       new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::erase)));
+  variables->insert("download_scheduler",    new utils::VariableVoidSlot(rak::mem_fn(control->scheduler(), &core::Scheduler::update)));
 
-  variables->insert("send_buffer_size",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::mem_fn(torrent::connection_manager(),
-													   &torrent::ConnectionManager::set_send_buffer_size), "%u"));
+  variables->insert("send_buffer_size",      new utils::VariableValueSlot(rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::send_buffer_size),
+									  rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::set_send_buffer_size)));
   
-  variables->insert("receive_buffer_size",   new utils::VariableSlotValue<int, uint32_t>(NULL, rak::mem_fn(torrent::connection_manager(),
-													   &torrent::ConnectionManager::set_receive_buffer_size), "%u"));
+  variables->insert("receive_buffer_size",   new utils::VariableValueSlot(rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::receive_buffer_size),
+									  rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::set_receive_buffer_size)));
   
-  // Old.
-  variables->insert("port_range",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_port_range, c)));
-
-  variables->insert("hash_read_ahead",     new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_read_ahead, c), "%i"));
-  variables->insert("hash_interval",       new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_interval, c), "%i"));
-
-  variables->insert("umask",               new utils::VariableSlotValue<int, int>(NULL, rak::ptr_fn(&apply_umask), "%o"));
-
-  variables->insert("load",                new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_load, c)));
-  variables->insert("load_start",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_load_start, c)));
-  variables->insert("stop_untied",         new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_stop_untied, c)));
-  variables->insert("remove_untied",       new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_remove_untied, c)));
+  variables->insert("port_range",            new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_port_range, c)));
 
-  variables->insert("enable_trackers",     new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_enable_trackers, c)));
+  variables->insert("hash_read_ahead",       new utils::VariableValueSlot(rak::ptr_fn(torrent::hash_read_ahead), rak::bind_ptr_fn(&apply_hash_read_ahead, c)));
+  variables->insert("hash_interval",         new utils::VariableValueSlot(rak::ptr_fn(torrent::hash_interval), rak::bind_ptr_fn(&apply_hash_interval, c)));
 
-  variables->insert("encoding_list",       new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_encoding_list, c)));
+  variables->insert("umask",                 new utils::VariableValueSlot(rak::mem_fn(control, &Control::umask), rak::mem_fn(control, &Control::set_umask), 8));
+  variables->insert("working_directory",     new utils::VariableStringSlot(rak::mem_fn(control, &Control::working_directory),
+									   rak::mem_fn(control, &Control::set_working_directory)));
+
+  variables->insert("load",                  new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_load, c)));
+  variables->insert("load_start",            new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_load_start, c)));
+  variables->insert("stop_untied",           new utils::VariableVoidSlot(rak::bind_ptr_fn(&apply_stop_untied, c)));
+  variables->insert("remove_untied",         new utils::VariableVoidSlot(rak::bind_ptr_fn(&apply_remove_untied, c)));
 
-  variables->insert("http_proxy",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_http_proxy, c)));
+  variables->insert("enable_trackers",       new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_enable_trackers, c)));
+  variables->insert("encoding_list",         new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_encoding_list, c)));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.cc	2006-04-01 04:56:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/download_list.cc	2006-05-02 00:30:08.000000000 +0800
@@ -42,13 +42,16 @@
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 
 #include "core/download.h"
+#include "core/download_list.h"
 #include "core/manager.h"
+#include "core/view.h"
+#include "core/view_manager.h"
 
 #include "input/bindings.h"
 #include "input/manager.h"
 #include "input/path_input.h"
 
 #include "display/window_http_queue.h"
@@ -70,25 +73,28 @@
 DownloadList::DownloadList(Control* c) :
   m_state(DISPLAY_MAX_SIZE),
 
   m_window(c->display()->end()),
 
   m_windowTitle(new WTitle("rTorrent " VERSION " - libTorrent " + std::string(torrent::version()))),
-  m_windowHttpQueue(new WHttp(&c->core()->http_queue())),
+  m_windowHttpQueue(new WHttp(c->core()->http_queue())),
 
   m_uiDownload(NULL),
 
-  m_downloadList(&c->core()->download_list()),
-
   m_control(c),
   m_bindings(new input::Bindings)
 {
-  m_uiArray[DISPLAY_DOWNLOAD_LIST] = new ElementDownloadList(&m_downloadList);
+  m_uiArray[DISPLAY_DOWNLOAD_LIST] = new ElementDownloadList();
   m_uiArray[DISPLAY_LOG]           = new ElementLogComplete(&m_control->core()->get_log_complete());
   m_windowLog                      = new WLog(&m_control->core()->get_log_important());
 
+  receive_change_view("main");
+
+  if (m_view == NULL)
+    throw torrent::internal_error("View \"main\" must be present to initialize the main display.");
+
   m_taskUpdate.set_slot(rak::mem_fn(this, &DownloadList::task_update)),
 
   setup_keys();
   setup_input();
 }
 
@@ -121,13 +127,13 @@
   m_control->display()->push_front(m_windowLog);
   m_window = m_control->display()->insert(m_control->display()->begin(), NULL);
   m_control->display()->push_front(m_windowTitle);
 
   m_control->input()->push_front(m_bindings);
 
-  m_control->core()->download_list().slot_map_erase()["0_download_list"] = sigc::mem_fun(this, &DownloadList::receive_download_erased);
+  m_control->core()->download_list()->slot_map_erase()["0_download_list"] = sigc::mem_fun(this, &DownloadList::receive_download_erased);
 
   activate_display(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::disable() {
@@ -176,58 +182,64 @@
   m_state   = DISPLAY_MAX_SIZE;
   *m_window = NULL;
 }
 
 void
 DownloadList::receive_next() {
-  m_downloadList.inc_focus();
+  m_view->next_focus();
+  m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_prev() {
-  m_downloadList.dec_focus();
+  m_view->prev_focus();
+  m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_start_download() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
-  m_control->core()->download_list().start(*m_downloadList.get_focus());
+  m_control->core()->download_list()->start(*m_view->focus());
+  m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_stop_download() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
-  if ((*m_downloadList.get_focus())->download()->is_active())
-    m_control->core()->download_list().stop(*m_downloadList.get_focus());
+  if ((*m_view->focus())->download()->is_active())
+    m_control->core()->download_list()->stop(*m_view->focus());
   else
-    m_downloadList.set_focus(m_control->core()->download_list().erase(m_downloadList.get_focus()));
+    m_control->core()->download_list()->erase(*m_view->focus());
+
+  m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_close_download() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
-  m_control->core()->download_list().close(*m_downloadList.get_focus());
+  m_control->core()->download_list()->close(*m_view->focus());
+  m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_view_download() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
   if (m_uiDownload != NULL)
     throw std::logic_error("DownloadList::receive_view_download() called but m_uiDownload != NULL");
 
   disable();
 
-  m_uiDownload = new Download(*m_downloadList.get_focus(), m_control);
+  m_uiDownload = new Download(*m_view->focus(), m_control);
 
   m_uiDownload->activate();
   m_uiDownload->get_bindings()[KEY_LEFT] = sigc::mem_fun(*this, &DownloadList::receive_exit_download);
 }
 
 void
@@ -236,39 +248,41 @@
     throw std::logic_error("DownloadList::receive_exit_download() called but m_uiDownload == NULL");
 
   m_uiDownload->disable();
   delete m_uiDownload;
   m_uiDownload = NULL;
 
+  m_view->set_last_changed();
   activate();
 
   m_control->display()->adjust_layout();
 }
 
 void
 DownloadList::receive_next_priority() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
-  (*m_downloadList.get_focus())->set_priority(((*m_downloadList.get_focus())->priority() + 1) % 4);
+  (*m_view->focus())->set_priority(((*m_view->focus())->priority() + 1) % 4);
 }
 
 void
 DownloadList::receive_prev_priority() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
-  (*m_downloadList.get_focus())->set_priority(((*m_downloadList.get_focus())->priority() - 1) % 4);
+  (*m_view->focus())->set_priority(((*m_view->focus())->priority() - 1) % 4);
 }
 
 void
 DownloadList::receive_check_hash() {
-  if (m_downloadList.get_focus() == m_downloadList.end())
+  if (m_view->focus() == m_view->end())
     return;
 
-  m_control->core()->check_hash(*m_downloadList.get_focus());
+  // Catch here?
+  m_control->core()->download_list()->check_hash(*m_view->focus());
 }
 
 void
 DownloadList::receive_view_input(Input type) {
   if (m_windowTextInput->get_active())
     return;
@@ -309,17 +323,17 @@
     case INPUT_LOAD_DEFAULT:
     case INPUT_LOAD_MODIFIED:
       m_control->core()->try_create_download_expand(m_windowTextInput->get_input()->str(), type == INPUT_LOAD_DEFAULT);
       break;
 
     case INPUT_CHANGE_DIRECTORY:
-      if (m_downloadList.get_focus() == m_downloadList.end())
+      if (m_view->focus() == m_view->end())
 	throw torrent::input_error("No download in focus to change root directory.");
 
-      (*m_downloadList.get_focus())->variable()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
-      m_control->core()->push_log("New root dir \"" + (*m_downloadList.get_focus())->variable()->get_string("directory") + "\" for torrent.");
+      (*m_view->focus())->variable()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
+      m_control->core()->push_log("New root dir \"" + (*m_view->focus())->variable()->get_string("directory") + "\" for torrent.");
       break;
 
     case INPUT_COMMAND:
       m_control->variable()->process_command(m_windowTextInput->get_input()->str());
       break;
     }
@@ -350,23 +364,42 @@
   disable_display();
   activate_display(d);
 }
 
 void
 DownloadList::receive_download_erased(core::Download* d) {
-  if (m_downloadList.get_focus() == m_downloadList.end() ||
-      *m_downloadList.get_focus() != d)
+  if (m_view->focus() == m_view->end() || *m_view->focus() != d)
     return;
 
   if (m_uiDownload != NULL)
     receive_exit_download();
 
   receive_next();
 }
 
 void
+DownloadList::receive_change_view(const std::string& name) {
+  core::ViewManager::iterator itr = m_control->view_manager()->find(name);
+
+  if (itr == m_control->view_manager()->end()) {
+    m_control->core()->push_log("Could not find view \"" + name + "\".");
+    return;
+  }
+
+  m_view = *itr;
+  m_view->sort();
+
+  ElementDownloadList* ui = dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST]);
+
+  if (ui == NULL)
+    throw torrent::internal_error("DownloadList::receive_change_view(...) could not cast ui.");
+
+  ui->set_view(m_view);
+}
+
+void
 DownloadList::task_update() {
   m_windowLog->receive_update();
 
   priority_queue_insert(&taskScheduler, &m_taskUpdate, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
 }
 
@@ -388,12 +421,19 @@
 
   (*m_bindings)[KEY_UP]        = sigc::mem_fun(*this, &DownloadList::receive_prev);
   (*m_bindings)[KEY_DOWN]      = sigc::mem_fun(*this, &DownloadList::receive_next);
   (*m_bindings)[KEY_RIGHT]     = sigc::mem_fun(*this, &DownloadList::receive_view_download);
   (*m_bindings)['l']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_LOG);
 
+  (*m_bindings)['1']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "main");
+  (*m_bindings)['2']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "name");
+  (*m_bindings)['3']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "started");
+  (*m_bindings)['4']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "stopped");
+  (*m_bindings)['5']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "complete");
+  (*m_bindings)['6']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "incomplete");
+
   m_uiArray[DISPLAY_LOG]->get_bindings()[' '] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::setup_input() {
   input::PathInput* p    = new input::PathInput;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.h	2006-03-17 22:27:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/download_list.h	2006-05-02 00:29:58.000000000 +0800
@@ -36,20 +36,23 @@
 
 #ifndef RTORRENT_UI_DOWNLOAD_LIST_H
 #define RTORRENT_UI_DOWNLOAD_LIST_H
 
 #include <sigc++/slot.h>
 
-#include "core/download_list.h"
 #include "display/manager.h"
-#include "utils/list_focus.h"
 
 #include "globals.h"
 
 class Control;
 
+namespace core {
+  class Download;
+  class View;
+}
+
 namespace input {
   class Bindings;
 }
 
 namespace display {
   class WindowDownloadList;
@@ -71,14 +74,12 @@
   typedef display::WindowHttpQueue                 WHttp;
   typedef display::WindowInput                     WInput;
   typedef display::WindowLog                       WLog;
   typedef display::WindowLogComplete               WLogComplete;
   typedef display::WindowTitle                     WTitle;
 
-  typedef utils::ListFocus<core::DownloadList>     DList;
-
   typedef sigc::slot1<void, const std::string&>    SlotOpenUri;
 
   typedef display::Manager::iterator               MItr;
 
   typedef enum {
     DISPLAY_DOWNLOAD_LIST,
@@ -133,12 +134,14 @@
   void                receive_exit_input(Input type);
 
   void                receive_change(Display d);
 
   void                receive_download_erased(core::Download* d);
 
+  void                receive_change_view(const std::string& name);
+
   void                task_update();
 
   void                setup_keys();
   void                setup_input();
 
   Display             m_state;
@@ -153,13 +156,13 @@
   WHttp*              m_windowHttpQueue;
 
   rak::priority_item  m_taskUpdate;
 
   Download*           m_uiDownload;
 
-  DList               m_downloadList;
+  core::View*         m_view;
 
   Control*            m_control;
   input::Bindings*    m_bindings;
 
   SlotOpenUri         m_slotOpenUri;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_download_list.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_download_list.cc	2006-05-02 00:30:08.000000000 +0800
@@ -35,33 +35,30 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
 
-#include "display/window_download_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_download_list.h"
 
 namespace ui {
 
-ElementDownloadList::ElementDownloadList(DList* l) :
-  m_window(NULL),
-  m_list(l) {
-}
-
 void
 ElementDownloadList::activate(Control* c, MItr mItr) {
   if (m_window != NULL)
     throw std::logic_error("ui::ElementDownloadList::activate(...) called on an object in the wrong state");
 
   c->input()->push_front(&m_bindings);
 
-  *mItr = m_window = new WDownloadList(m_list);
+  m_window = new WDownloadList();
+  m_window->set_view(m_view);
+
+  *mItr = m_window;
 }
 
 void
 ElementDownloadList::disable(Control* c) {
   if (m_window == NULL)
     throw std::logic_error("ui::ElementDownloadList::disable(...) called on an object in the wrong state");
@@ -69,7 +66,18 @@
   c->input()->erase(&m_bindings);
 
   delete m_window;
   m_window = NULL;
 }
 
+void
+ElementDownloadList::set_view(core::View* l) {
+  m_view = l;
+
+  if (m_window == NULL)
+    return;
+
+  m_window->set_view(l);
+  m_window->mark_dirty();
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_download_list.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_download_list.h	2006-05-02 00:29:58.000000000 +0800
@@ -35,37 +35,37 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UI_ELEMENT_DOWNLOAD_LIST_H
 #define RTORRENT_UI_ELEMENT_DOWNLOAD_LIST_H
 
 #include "core/download_list.h"
-#include "utils/list_focus.h"
+#include "display/window_download_list.h"
 
 #include "element_base.h"
 
 class Control;
 
-namespace display {
-  class WindowDownloadList;
+namespace core {
+  class View;
 }
 
 namespace ui {
 
 class ElementDownloadList : public ElementBase {
 public:
-  typedef display::WindowDownloadList          WDownloadList;
-  typedef utils::ListFocus<core::DownloadList> DList;
+  typedef display::WindowDownloadList WDownloadList;
 
-  ElementDownloadList(DList* l);
+  ElementDownloadList() : m_window(NULL), m_view(NULL) {}
 
   void                activate(Control* c, MItr mItr);
   void                disable(Control* c);
 
+  void                set_view(core::View* l);
+
 private:
-  WDownloadList*      m_window;
-  
-  DList*              m_list;
+  WDownloadList*       m_window;
+  core::View*          m_view;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/root.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/root.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/root.cc	2006-01-31 01:19:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/root.cc	2006-05-02 00:30:08.000000000 +0800
@@ -105,15 +105,14 @@
   m_bindings['Z']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), -1);
   m_bindings['S']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), 5);
   m_bindings['X']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), -5);
   m_bindings['D']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), 50);
   m_bindings['C']           = sigc::bind(sigc::mem_fun(*this, &Root::adjust_down_throttle), -50);
 
-  //m_bindings[KEY_RESIZE]    = sigc::mem_fun(*m_control->display(), &display::Manager::adjust_layout);
-  m_bindings['\x0C']        = sigc::mem_fun(m_control->display(), &display::Manager::force_redraw);
-  m_bindings['\x11']        = sigc::mem_fun(m_control, &Control::receive_normal_shutdown);
+  m_bindings['\x0C']        = sigc::mem_fun(m_control->display(), &display::Manager::force_redraw); // ^L
+  m_bindings['\x11']        = sigc::mem_fun(m_control, &Control::receive_normal_shutdown); // ^Q
 }
 
 void
 Root::set_down_throttle(unsigned int throttle) {
   if (m_windowStatusbar != NULL)
     m_windowStatusbar->mark_dirty();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/root.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/root.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/root.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/root.h	2006-05-02 00:29:58.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UI_ROOT_H
 #define RTORRENT_UI_ROOT_H
 
+#include <inttypes.h>
 #include "input/bindings.h"
 
 class Control;
 
 namespace display {
   class WindowStatusbar;
@@ -60,12 +61,16 @@
 
   WStatusbar*         window_statusbar()            { return m_windowStatusbar; }
 
   void                set_down_throttle(unsigned int throttle);
   void                set_up_throttle(unsigned int throttle);
 
+  // Rename to raw or something, make base function.
+  void                set_down_throttle_i64(int64_t throttle) { set_down_throttle(throttle >> 10); }
+  void                set_up_throttle_i64(int64_t throttle)   { set_up_throttle(throttle >> 10); }
+
   void                adjust_down_throttle(int throttle);
   void                adjust_up_throttle(int throttle);
 
 private:
   void                setup_keys();
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/Makefile.am	2006-02-01 18:47:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/Makefile.am	2006-05-02 00:28:04.000000000 +0800
@@ -3,12 +3,13 @@
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
 	list_focus.h \
 	lockfile.cc \
 	lockfile.h \
+	variable.cc \
 	variable.h \
 	variable_generic.cc \
 	variable_generic.h \
 	variable_map.cc \
 	variable_map.h
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/Makefile.in	2006-04-07 01:43:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/Makefile.in	2006-05-02 00:47:10.000000000 +0800
@@ -51,13 +51,14 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_utils_a_AR = $(AR) $(ARFLAGS)
 libsub_utils_a_LIBADD =
 am_libsub_utils_a_OBJECTS = directory.$(OBJEXT) lockfile.$(OBJEXT) \
-	variable_generic.$(OBJEXT) variable_map.$(OBJEXT)
+	variable.$(OBJEXT) variable_generic.$(OBJEXT) \
+	variable_map.$(OBJEXT)
 libsub_utils_a_OBJECTS = $(am_libsub_utils_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -183,12 +184,13 @@
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
 	list_focus.h \
 	lockfile.cc \
 	lockfile.h \
+	variable.cc \
 	variable.h \
 	variable_generic.cc \
 	variable_generic.h \
 	variable_map.cc \
 	variable_map.h
 
@@ -239,12 +241,13 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directory.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lockfile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable_generic.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable_map.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils: variable.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_generic.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.cc	2006-03-21 03:31:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_generic.cc	2006-05-02 00:30:08.000000000 +0800
@@ -39,33 +39,22 @@
 #include <stdlib.h>
 
 #include "variable_generic.h"
 
 namespace utils {
 
-VariableAny::~VariableAny() {
-}
-
 const torrent::Object&
 VariableAny::get() {
   return m_variable;
 }
 
 void
 VariableAny::set(const torrent::Object& arg) {
   m_variable = arg;
 }
 
-VariableValue::~VariableValue() {
-}
-
-const torrent::Object&
-VariableValue::get() {
-  return m_variable;
-}
-
 void
 VariableValue::set(const torrent::Object& arg) {
   uint64_t value;
   const char* first;
   char* last;
 
@@ -90,46 +79,37 @@
 
   default:
     throw torrent::input_error("VariableValue unsupported type restriction.");
   }
 }
 
-VariableBool::~VariableBool() {
-}
-
-const torrent::Object&
-VariableBool::get() {
-  return m_variable;
-}
-
 void
 VariableBool::set(const torrent::Object& arg) {
-  if (arg.is_value()) {
+  switch (arg.type()) {
+  case torrent::Object::TYPE_VALUE:
     m_variable = arg.as_value() ? (int64_t)1 : (int64_t)0;
+    break;
 
-  } else if (arg.is_string()) {
-
-    if (arg.as_string() == "yes" ||
-	arg.as_string() == "true")
+  case torrent::Object::TYPE_STRING:
+    // Move the checks into some is_true, is_false think in Variable.
+    if (arg.as_string() == "yes" || arg.as_string() == "true")
       m_variable = (int64_t)1;
 
-    else if (arg.as_string() == "no" ||
-	     arg.as_string() == "false")
+    else if (arg.as_string() == "no" || arg.as_string() == "false")
       m_variable = (int64_t)0;
 
     else
       throw torrent::input_error("String does not parse as a boolean.");
 
-  } else {
+    break;
+
+  default:
     throw torrent::input_error("Input is not a boolean.");
   }
 }
 
-VariableObject::~VariableObject() {
-}
-
 const torrent::Object&
 VariableObject::get() {
   if (m_root.empty())
     return m_bencode->get_key(m_key);
   else
     return m_bencode->get_key(m_root).get_key(m_key);
@@ -148,19 +128,91 @@
   switch (m_type) {
   case torrent::Object::TYPE_NONE:
     root->insert_key(m_key, arg);
     break;
 
   case torrent::Object::TYPE_STRING:
-    if (arg.type() == torrent::Object::TYPE_STRING)
+    if (arg.is_string())
       root->insert_key(m_key, arg);
     else
       throw torrent::input_error("VariableObject could not convert to string.");
       
     break;
 
+  case torrent::Object::TYPE_VALUE:
+    if (arg.is_value())
+      root->insert_key(m_key, arg);
+    else
+      throw torrent::input_error("VariableObject could not convert to value.");
+
+    break;
+
   default:
     throw torrent::input_error("VariableObject unsupported type restriction.");
   }
 }
 
+// 
+// New and prettified.
+//
+
+const torrent::Object&
+VariableVoidSlot::get() {
+  return m_cache;
+}
+
+void
+VariableVoidSlot::set(const torrent::Object& arg) {
+  m_slotSet();
+}
+
+const torrent::Object&
+VariableValueSlot::get() {
+  m_cache = m_slotGet() / m_unit;
+
+  return m_cache;
+}
+
+void
+VariableValueSlot::set(const torrent::Object& arg) {
+  value_type value;
+
+  switch (arg.type()) {
+  case torrent::Object::TYPE_STRING:
+    string_to_value_unit(arg.as_string().c_str(), &value, m_base, m_unit);
+
+    // Check if we hit the end of the input.
+
+    m_slotSet(value);
+    break;
+
+  case torrent::Object::TYPE_VALUE:
+    m_slotSet(arg.as_value());
+    break;
+
+  default:
+    throw torrent::input_error("Not a value");
+  }
+}
+
+const torrent::Object&
+VariableStringSlot::get() {
+  m_cache = m_slotGet();
+
+  return m_cache;
+}
+
+void
+VariableStringSlot::set(const torrent::Object& arg) {
+  switch (arg.type()) {
+  case torrent::Object::TYPE_STRING:
+    m_slotSet(arg.as_string());
+    break;
+  case torrent::Object::TYPE_NONE:
+    m_slotSet(std::string());
+    break;
+  default:
+    throw torrent::input_error("Not a string.");
+  }
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_generic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.h	2006-03-21 03:40:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_generic.h	2006-05-02 00:29:58.000000000 +0800
@@ -53,169 +53,133 @@
 namespace utils {
 
 class VariableAny : public Variable {
 public:
   VariableAny(const torrent::Object& v = torrent::Object()) :
     m_variable(v) {}
-  virtual ~VariableAny();
 
   virtual const torrent::Object&  get();
   virtual void                    set(const torrent::Object& arg);
 
-private:
+protected:
   torrent::Object    m_variable;
 };
 
-class VariableValue : public Variable {
+class VariableValue : public VariableAny {
 public:
-  VariableValue(int64_t v) : m_variable(v) {}
-  virtual ~VariableValue();
-
-  virtual const torrent::Object& get();
-  virtual void                    set(const torrent::Object& arg);
+  VariableValue(int64_t v) { m_variable = v; }
 
-private:
-  torrent::Object    m_variable;
+  virtual void        set(const torrent::Object& arg);
 };
 
-class VariableBool : public Variable {
+class VariableBool : public VariableAny {
 public:
-  VariableBool(bool state) : m_variable(state ? (int64_t)1 : (int64_t)0) {}
-  VariableBool(const torrent::Object& v = torrent::Object((int64_t)0)) { set(v); }
-  virtual ~VariableBool();
+  VariableBool(bool state = false)  { m_variable = state ? (int64_t)1 : (int64_t)0; }
 
-  virtual const torrent::Object& get();
   virtual void        set(const torrent::Object& arg);
-
-private:
-  torrent::Object    m_variable;
 };
 
 class VariableObject : public Variable {
 public:
   typedef torrent::Object::type_type Type;
 
   VariableObject(torrent::Object* b,
 		  const std::string& root,
 		  const std::string& key,
 		  Type t = torrent::Object::TYPE_NONE) :
     m_bencode(b), m_root(root), m_key(key), m_type(t) {}
-  virtual ~VariableObject();
 
   virtual const torrent::Object& get();
   virtual void        set(const torrent::Object& arg);
 
 private:
-  torrent::Object*   m_bencode;
+  torrent::Object*    m_bencode;
   std::string         m_root;
   std::string         m_key;
   Type                m_type;
 };
 
-template <typename Get = std::string, typename Set = const std::string&>
-class VariableSlotString : public Variable {
+//
+// New and pretty.
+//
+
+class VariableVoidSlot : public Variable {
 public:
-  typedef rak::function0<Get>       SlotGet;
-  typedef rak::function1<void, Set> SlotSet;
+  typedef rak::function0<void> slot_set_type;
 
-  VariableSlotString(typename SlotGet::base_type* slotGet, typename SlotSet::base_type* slotSet) {
-    m_slotGet.set(slotGet);
+  VariableVoidSlot(slot_set_type::base_type* slotSet) {
     m_slotSet.set(slotSet);
   }
 
-  virtual ~VariableSlotString() {}
+  virtual const torrent::Object& get();
+  virtual void                   set(const torrent::Object& arg);
+
+private:
+  slot_set_type       m_slotSet;
+
+  // Store the cache here to avoid unnessesary copying and such. This
+  // should not result in any unresonable memory usage since few
+  // strings will be very large.
+  torrent::Object     m_cache;
+};
 
-  virtual const torrent::Object& get() {
-    m_cache = m_slotGet();
+class VariableValueSlot : public Variable {
+public:
+  typedef rak::function0<value_type>        slot_get_type;
+  typedef rak::function1<void, value_type>  slot_set_type;
+  typedef std::pair<value_type, value_type> range_type;
 
-    if (!m_cache.is_string())
-      throw torrent::internal_error("VariableSlotString::get() got wrong type.");
+  template <typename SlotGet, typename SlotSet>
+  VariableValueSlot(SlotGet* slotGet, SlotSet* slotSet, unsigned int base = 0, unsigned int unit = 1,
+		    range_type range = range_type(std::numeric_limits<value_type>::min(), std::numeric_limits<value_type>::max())) :
+    m_base(base),
+    m_unit(unit),
+    m_range(range) {
 
-    return m_cache;
+    m_slotGet.set(rak::convert_fn<value_type>(slotGet));
+    m_slotSet.set(rak::convert_fn<void, value_type>(slotSet));
   }
 
-  virtual void set(const torrent::Object& arg) {
-    switch (arg.type()) {
-    case torrent::Object::TYPE_STRING:
-      m_slotSet(arg.as_string());
-      break;
-    case torrent::Object::TYPE_NONE:
-      m_slotSet("");
-      break;
-    default:
-      throw torrent::internal_error("VariableSlotString::set(...) got wrong type.");
-    }    
-  }
+  virtual const torrent::Object& get();
+  virtual void                   set(const torrent::Object& arg);
 
 private:
-  SlotGet             m_slotGet;
-  SlotSet             m_slotSet;
+  slot_get_type       m_slotGet;
+  slot_set_type       m_slotSet;
+
+  unsigned int        m_base;
+  unsigned int        m_unit;
+  range_type          m_range;
 
   // Store the cache here to avoid unnessesary copying and such. This
   // should not result in any unresonable memory usage since few
   // strings will be very large.
-  torrent::Object    m_cache;
+  torrent::Object     m_cache;
 };
 
-template <typename Get, typename Set>
-class VariableSlotValue : public Variable {
+class VariableStringSlot : public Variable {
 public:
-  typedef rak::function0<Get>         SlotGet;
-  typedef rak::function1<void, Set>   SlotSet;
-  typedef std::pair<int64_t, int64_t> Range;
-
-  VariableSlotValue(typename SlotGet::base_type* slotGet,
-		    typename SlotSet::base_type* slotSet,
-		    const char* pattern,
-		    Range range = Range(std::numeric_limits<int64_t>::min(),
-					std::numeric_limits<int64_t>::max())) {
-    m_slotGet.set(slotGet);
-    m_slotSet.set(slotSet);
-    m_pattern = pattern;
-    m_range = range;
-  }
-
-  virtual ~VariableSlotValue() {}
-
-  virtual const torrent::Object& get() {
-    m_cache = m_slotGet();
+  typedef rak::function0<string_type>              slot_get_type;
+  typedef rak::function1<void, const string_type&> slot_set_type;
 
-    // Need this?
-    if (!m_cache.is_value())
-      throw torrent::internal_error("VariableSlotValue::get() got wrong type.");
-
-    return m_cache;
+  template <typename SlotGet, typename SlotSet>
+  VariableStringSlot(SlotGet* slotGet, SlotSet* slotSet) {
+    m_slotGet.set(rak::convert_fn<string_type>(slotGet));
+    m_slotSet.set(rak::convert_fn<void, const string_type&>(slotSet));
   }
 
-  virtual void set(const torrent::Object& arg) {
-    if (arg.is_string()) {
-      Set v;
-
-      if (std::sscanf(arg.as_string().c_str(), m_pattern, &v) != 1)
-	throw torrent::input_error("Not a value.");
-      
-      m_slotSet(v);
-
-    } else if (arg.is_value()) {
-      m_slotSet(arg.as_value());
-
-    } else {
-      throw torrent::input_error("Not a value");
-    }
-  }
+  virtual const torrent::Object& get();
+  virtual void                   set(const torrent::Object& arg);
 
 private:
-  SlotGet             m_slotGet;
-  SlotSet             m_slotSet;
-
-  const char*         m_pattern;
-  Range               m_range;
+  slot_get_type       m_slotGet;
+  slot_set_type       m_slotSet;
 
   // Store the cache here to avoid unnessesary copying and such. This
   // should not result in any unresonable memory usage since few
   // strings will be very large.
-  torrent::Object    m_cache;
+  torrent::Object     m_cache;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable.h	2006-03-21 03:25:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable.h	2006-05-02 00:29:58.000000000 +0800
@@ -34,30 +34,38 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UTILS_VARIABLE_H
 #define RTORRENT_UTILS_VARIABLE_H
 
-#include <string>
-
-namespace torrent {
-  class Object;
-}
+#include <torrent/object.h>
 
 namespace utils {
 
 class Variable {
 public:
+  typedef torrent::Object::value_type  value_type;
+  typedef torrent::Object::string_type string_type;
+  typedef torrent::Object::list_type   list_type;
+  typedef torrent::Object::map_type    map_type;
+  typedef torrent::Object::key_type    key_type;
+
   Variable() {}
   virtual ~Variable() {}
 
   virtual const torrent::Object& get() = 0;
-  virtual void                    set(const torrent::Object& arg) = 0;
+  virtual void                   set(const torrent::Object& arg) = 0;
 
 protected:
   Variable(const Variable&);
   void operator = (const Variable&);
+
+  static const char*  string_to_value_unit(const char* pos, value_type* value, int base, int unit);
+
+  // Temporary hack, until torrent::Object is extended to allow
+  // references so we can return a copy, not a const reference.
+  static const torrent::Object m_emptyObject;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.cc	2006-03-21 03:40:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_map.cc	2006-05-02 00:30:08.000000000 +0800
@@ -62,14 +62,14 @@
     throw torrent::internal_error("VariableMap::insert(...) tried to insert an already existing key.");
 
   base_type::insert(itr, value_type(key, v));
 }
 
 const VariableMap::mapped_type&
-VariableMap::get(const std::string& key) {
-  iterator itr = base_type::find(key);
+VariableMap::get(const std::string& key) const {
+  const_iterator itr = base_type::find(key);
 
   if (itr == base_type::end())
     throw torrent::input_error("Variable \"" + key + "\" does not exist.");
 
   return itr->second->get();
 }
@@ -195,18 +195,7 @@
     throw torrent::input_error(buffer);
   }
 
   return true;
 }
 
-void
-VariableMap::process_file_throw(const std::string& path) {
-  if (!process_file(path))
-    throw torrent::input_error("Could not open option file: " + path);
-}
-
-void
-VariableMap::process_file_nothrow(const std::string& path) {
-  process_file(path);
-}
-
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.h	2006-03-21 03:40:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_map.h	2006-05-02 00:29:58.000000000 +0800
@@ -47,12 +47,13 @@
 class Variable;
 
 class VariableMap : public std::map<std::string, Variable*> {
 public:
   typedef std::map<std::string, Variable*> base_type;
   typedef torrent::Object                  mapped_type;
+  typedef mapped_type::value_type          mapped_value_type;
 
   static const int max_size_key = 128;
   static const int max_size_opt = 1024;
   static const int max_size_line = max_size_key + max_size_opt + 64;
 
   using base_type::iterator;
@@ -62,24 +63,23 @@
   ~VariableMap();
 
   void                insert(const std::string& key, Variable* v);
 
   // Consider taking char* start and finish instead of std::string to
   // avoid copying. Or make a view class.
-  const mapped_type&  get(const std::string& key);
-  const std::string&  get_string(const std::string& key)                         { return get(key).as_string(); }
+  const mapped_type&  get(const std::string& key) const;
+  const std::string&  get_string(const std::string& key) const                   { return get(key).as_string(); }
+  mapped_value_type   get_value(const std::string& key) const                    { return get(key).as_value(); }
 
   void                set(const std::string& key, const mapped_type& arg);
   void                set_string(const std::string& key, const std::string& arg) { set(key, mapped_type(arg)); }
 
   // Relocate.
   void                process_command(const std::string& command);
   void                process_stream(std::istream* str);
   bool                process_file(const std::string& path);
-  void                process_file_throw(const std::string& path);
-  void                process_file_nothrow(const std::string& path);
 
 private:
   VariableMap(const VariableMap&);
   void operator = (const VariableMap&);
 };
 
