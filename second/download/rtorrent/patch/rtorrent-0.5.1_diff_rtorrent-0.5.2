diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure	2006-05-02 00:47:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/configure	2006-05-19 23:31:38.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.5.1.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.5.2.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -420,14 +420,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.5.1'
-PACKAGE_STRING='rtorrent 0.5.1'
+PACKAGE_VERSION='0.5.2'
+PACKAGE_STRING='rtorrent 0.5.2'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -950,13 +950,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.5.1 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.5.2 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1016,13 +1016,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.5.1:";;
+     short | recursive ) echo "Configuration of rtorrent 0.5.2:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1162,13 +1162,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.5.1
+rtorrent configure 0.5.2
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1176,13 +1176,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.5.1, which was
+It was created by rtorrent $as_me 0.5.2, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1820,13 +1820,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.5.1'
+ VERSION='0.5.2'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -20981,13 +20981,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.5.1, which was
+This file was extended by rtorrent $as_me 0.5.2, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -21044,13 +21044,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.5.1
+rtorrent config.status 0.5.2
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/configure.ac	2006-05-02 00:28:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/configure.ac	2006-05-19 23:15:32.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.5.1, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.5.2, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/doc/rtorrent.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1	2006-05-04 02:31:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/doc/rtorrent.1	2006-05-19 23:43:20.000000000 +0800
@@ -1,18 +1,18 @@
 .\" This manpage has been automatically generated by docbook2man 
 .\" from a DocBook document.  This tool can be found at:
 .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
 .\" Please send any bug reports, improvements, comments, patches, 
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
-.TH "RTORRENT" "1" "03 May 2006" "BitTorrent client for ncurses" ""
+.TH "RTORRENT" "1" "19 May 2006" "BitTorrent client for ncurses" ""
 
 .SH NAME
 rtorrent \- a BitTorrent client for ncurses
 .SH SYNOPSIS
 
-\fBrtorrent\fR [ \fB-h\fR ] [ \fB-o key1=opt1,...\fR ] [ \fB-O key=opt\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
+\fBrtorrent\fR [ \fB-h\fR ] [ \fB-n\fR ] [ \fB-o key1=opt1,...\fR ] [ \fB-O key=opt\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
 
 .SH "DESCRIPTION"
 .PP
 \fBrtorrent\fR is a BitTorrent client for ncurses,
 using the \fBlibtorrent\fR library. The client
 and library is written in C++ with emphasis on speed and
@@ -45,22 +45,25 @@
 Decrease the download throttle by 1/5/50 KB.
 .SS "MAIN VIEW KEYS"
 .TP
 \fB->\fR
 View download.
 .TP
-\fB1 - 6\fR
+\fB1 - 7\fR
 Change view.
 .TP
-\fB^s\fR
+\fB^S\fR
 Start download.
 .TP
-\fB^d\fR
+\fB^D\fR
 Stop an active download, or remove a stopped download.
 .TP
-\fB^r\fR
+\fB^K\fR
+Close a torrent and its files.
+.TP
+\fB^R\fR
 Initiate hash check of torrent.
 .TP
 \fB^O\fR
 Change the destination directory of the download. The
 torrent must be closed.
 .TP
@@ -124,12 +127,15 @@
 \fB-h\fR
 Display help and exit.
 .TP
 \fB-i \fIa.b.c.d\fB\fR
 Set the address reported to the tracker.
 .TP
+\fB-n\fR
+Don't load ~/.rtorrent.rc on startup.
+.TP
 \fB-o key1=opt1,...\fR
 .TP
 \fB-O key=opt\fR
 Set any number of options, see the SETTINGS section. The options given
 here override the resource files. Use capital \fB-O\fR
 to allow comma in the option.
@@ -212,15 +218,18 @@
 .TP
 \fBschedule_remove = \fIid\fB\fR
 Delete \fBid\fR from the scheduler.
 .TP
 \fBstop_untied =\fR
 .TP
+\fBclose_untied =\fR
+.TP
 \fBremove_untied =\fR
-Stop or remove the torrents that are tied to filenames that have been
-deleted, the association is then cleared.
+Stop, close or remove the torrents that are tied to filenames that
+have been deleted, the association with the file is then cleared so
+the event will not trigger more than once.
 .TP
 \fBload = \fIfile\fB\fR
 .TP
 \fBload_start = \fIfile\fB\fR
 Load and possibly start a file, or possibly multiple files by using the
 wild-card "*". This is meant for use with
@@ -293,12 +302,17 @@
 .TP
 \fBmax_open_sockets = \fIvalue\fB\fR
 Number of sockets to simultaneously keep open. This value is set to be
 \fBsysconf(_SC_OPEN_MAX) - 256\fR at startup. This
 gives the client 128 sockets to use as it wishes.
 .TP
+\fBsend_buffer_size = \fIvalue\fB\fR
+.TP
+\fBreceive_buffer_size = \fIvalue\fB\fR
+Adjust the send and receive buffer size for socket.
+.TP
 \fBumask = \fI0644\fB\fR
 Set the umask for this process, which is applied to all files created
 by the program.
 .TP
 \fBworking_directory = \fIdirectory\fB\fR
 Changes the working directory of the process using
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/doc/rtorrent.1.xml	2006-05-04 02:31:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/doc/rtorrent.1.xml	2006-05-13 08:29:23.000000000 +0800
@@ -19,12 +19,13 @@
   
 
   <refsynopsisdiv>
     <cmdsynopsis>
       <command>rtorrent</command>
       <arg choice="opt">-h</arg>
+      <arg choice="opt">-n</arg>
       <arg choice="opt">-o key1=opt1,...</arg>
       <arg choice="opt">-O key=opt</arg>
       <arg choice="opt" rep="repeat">URL | FILE</arg>
     </cmdsynopsis>
   </refsynopsisdiv>
   
@@ -117,36 +118,47 @@
 	  <listitem><para>
             View download.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
-	  <term>1 - 6</term>
+	  <term>1 - 7</term>
 	  <listitem><para>
 
 Change view.
 
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
-	  <term>^s</term>
+	  <term>^S</term>
 	  <listitem><para>
             Start download.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
-	  <term>^d</term>
+	  <term>^D</term>
 	  <listitem><para>
-            Stop an active download, or remove a stopped download.
+
+Stop an active download, or remove a stopped download.
+
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
+	  <term>^K</term>
+	  <listitem><para>
+
+Close a torrent and its files.
+
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
-	  <term>^r</term>
+	  <term>^R</term>
 	  <listitem><para>
             Initiate hash check of torrent.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
@@ -330,12 +342,21 @@
 Set the address reported to the tracker.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
+        <term>-n</term>
+        <listitem><para>
+
+Don't load ~/.rtorrent.rc on startup.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term>-o key1=opt1,...</term>
         <term>-O key=opt</term>
         <listitem><para>
 
 Set any number of options, see the SETTINGS section. The options given
 here override the resource files. Use capital <emphasis>-O</emphasis>
@@ -540,17 +561,19 @@
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>stop_untied =</term>
+        <term>close_untied =</term>
         <term>remove_untied =</term>
         <listitem><para>
 
-Stop or remove the torrents that are tied to filenames that have been
-deleted, the association is then cleared.
+Stop, close or remove the torrents that are tied to filenames that
+have been deleted, the association with the file is then cleared so
+the event will not trigger more than once.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>load = <replaceable>file</replaceable></term>
@@ -714,12 +737,22 @@
 gives the client 128 sockets to use as it wishes.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
+        <term>send_buffer_size = <replaceable>value</replaceable></term>
+        <term>receive_buffer_size = <replaceable>value</replaceable></term>
+        <listitem><para>
+
+Adjust the send and receive buffer size for socket.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term>umask = <replaceable>0644</replaceable></term>
         <listitem><para>
 
 Set the umask for this process, which is applied to all files created
 by the program.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/error_number.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/rak/error_number.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/error_number.h	2006-05-02 00:29:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/rak/error_number.h	2006-05-12 05:40:59.000000000 +0800
@@ -46,12 +46,16 @@
 public:
   static const int e_access      = EACCES;
   static const int e_again       = EAGAIN;
   static const int e_connreset   = ECONNRESET;
   static const int e_connaborted = ECONNABORTED;
   static const int e_deadlk      = EDEADLK;
+
+  static const int e_noent       = ENOENT;
+  static const int e_notdir      = ENOTDIR;
+  
   static const int e_intr        = EINTR;
 
   error_number() : m_errno(0) {}
   error_number(int e) : m_errno(e) {}
 
   bool                is_valid() const             { return m_errno != 0; }
@@ -61,12 +65,14 @@
 
   bool                is_blocked_momentary() const { return m_errno == e_again || m_errno == e_intr; }
   bool                is_blocked_prolonged() const { return m_errno == e_deadlk; }
 
   bool                is_closed() const            { return m_errno == e_connreset || m_errno == e_connaborted; }
 
+  bool                is_bad_path() const          { return m_errno == e_noent || m_errno == e_notdir || m_errno == e_access; }
+
   static error_number current()                    { return errno; }
   static void         clear_global()               { errno = 0; }
 
   bool operator == (const error_number& e) const   { return m_errno == e.m_errno; }
 
 private:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/functional_fun.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/rak/functional_fun.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/functional_fun.h	2006-05-02 00:29:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/rak/functional_fun.h	2006-05-05 20:04:12.000000000 +0800
@@ -340,37 +340,47 @@
 template <typename Result>
 inline function_base0<Result>*
 value_fn(const Result& val) {
   return new value_fn0_t<Result>(val);
 }
 
+template <typename A, typename B>
+struct equal_types_t {
+  typedef A first_type;
+  typedef B second_type;
+
+  const static int result = 0;
+};
+
+template <typename A>
+struct equal_types_t<A, A> {
+  typedef A first_type;
+  typedef A second_type;
+
+  const static int result = 1;
+};
+
 template <typename Result, typename SrcResult>
 inline function_base0<Result>*
 convert_fn(function_base0<SrcResult>* src) {
-  return new convert_fn0_t<Result, SrcResult>(src);
-}
-
-// This overload ensures that if we try to convert to the same type,
-// it will optimize away the unneeded layer.
-template <typename Result>
-inline function_base0<Result>*
-convert_fn(function_base0<Result>* src) {
-  return src;
+  if (equal_types_t<function_base0<Result>, function_base0<SrcResult> >::result)
+    // The pointer cast never gets done if the types are different,
+    // but needs to be here to pleasant the compiler.
+    return reinterpret_cast<typename equal_types_t<function_base0<Result>, function_base0<SrcResult> >::first_type*>(src);
+  else
+    return new convert_fn0_t<Result, SrcResult>(src);
 }
 
 template <typename Result, typename Arg1, typename SrcResult, typename SrcArg1>
 inline function_base1<Result, Arg1>*
 convert_fn(function_base1<SrcResult, SrcArg1>* src) {
-  return new convert_fn1_t<Result, Arg1, SrcResult, SrcArg1>(src);
-}
-
-// This overload ensures that if we try to convert to the same type,
-// it will optimize away the unneeded layer.
-template <typename Result, typename Arg1>
-inline function_base1<Result, Arg1>*
-convert_fn(function_base1<Result, Arg1>* src) {
-  return src;
+  if (equal_types_t<function_base1<Result, Arg1>, function_base1<SrcResult, SrcArg1> >::result)
+    // The pointer cast never gets done if the types are different,
+    // but needs to be here to pleasant the compiler.
+    return reinterpret_cast<typename equal_types_t<function_base1<Result, Arg1>, function_base1<SrcResult, SrcArg1> >::first_type*>(src);
+  else
+    return new convert_fn1_t<Result, Arg1, SrcResult, SrcArg1>(src);
 }
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/functional.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/rak/functional.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/rak/functional.h	2006-05-02 00:29:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/rak/functional.h	2006-05-09 00:55:55.000000000 +0800
@@ -347,13 +347,13 @@
   typedef typename reference_fix<typename Operation::second_argument_type>::type value_type;
 
   bind2nd_t(const Operation& op, const value_type v) :
     m_op(op), m_value(v) {}
 
   typename Operation::result_type
-  operator () (const argument_type arg) {
+  operator () (argument_type arg) {
     return m_op(arg, m_value);
   }
 
 protected:
   Operation  m_op;
   value_type m_value;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/command_scheduler.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/command_scheduler.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/command_scheduler.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/command_scheduler.cc	2006-05-13 07:57:51.000000000 +0800
@@ -82,16 +82,16 @@
   base_type::erase(itr);
 }
 
 void
 CommandScheduler::call_item(value_type item) {
   if (item->is_queued())
-    throw torrent::internal_error("CommandScheduler::call_item(...) called but item is still queued.");
+    throw torrent::client_error("CommandScheduler::call_item(...) called but item is still queued.");
 
   if (std::find(begin(), end(), item) == end())
-    throw torrent::internal_error("CommandScheduler::call_item(...) called but the item isn't in the scheduler.");
+    throw torrent::client_error("CommandScheduler::call_item(...) called but the item isn't in the scheduler.");
 
   // Remove the item before calling the command if it should be
   // removed.
 
   try {
     m_slotCommand(item->command());
@@ -107,13 +107,13 @@
   if (next == rak::timer()) {
     // Remove from scheduler?
     return;
   }
 
   if (next <= cachedTime)
-    throw torrent::internal_error("CommandScheduler::call_item(...) tried to schedule a zero interval item.");
+    throw torrent::client_error("CommandScheduler::call_item(...) tried to schedule a zero interval item.");
 
   item->enable(next);
 }
 
 void
 CommandScheduler::parse(const std::string& arg) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/command_scheduler_item.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/command_scheduler_item.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/command_scheduler_item.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/command_scheduler_item.cc	2006-05-13 07:57:51.000000000 +0800
@@ -44,13 +44,13 @@
   priority_queue_erase(&taskScheduler, &m_task);
 }
 
 void
 CommandSchedulerItem::enable(rak::timer t) {
   if (t == rak::timer())
-    throw torrent::internal_error("CommandSchedulerItem::enable() t == rak::timer().");
+    throw torrent::client_error("CommandSchedulerItem::enable() t == rak::timer().");
 
   if (is_queued())
     disable();
 
   // If 'first' is zero then we execute the task
   // immediately. ''interval()'' will not return zero so we never end
@@ -68,13 +68,13 @@
 rak::timer
 CommandSchedulerItem::next_time_scheduled() const {
   if (m_interval == 0)
     return rak::timer();
 
   if (m_timeScheduled == rak::timer())
-    throw torrent::internal_error("CommandSchedulerItem::next_time_scheduled() m_timeScheduled == rak::timer().");
+    throw torrent::client_error("CommandSchedulerItem::next_time_scheduled() m_timeScheduled == rak::timer().");
 
   rak::timer next = m_timeScheduled;
 
   // This should be done in a non-looping manner.
   do {
     next += rak::timer::from_seconds(m_interval);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/control.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/control.cc	2006-05-13 04:10:17.000000000 +0800
@@ -110,12 +110,13 @@
   m_core->get_poll_manager()->get_http_stack()->set_user_agent(std::string(PACKAGE "/" VERSION "/") + torrent::version());
 
   m_core->initialize_second();
   m_core->listen_open();
   m_core->download_store()->enable(m_variables->get_value("session_lock"));
 
+  m_core->set_hashing_view(*m_viewManager->find_throw("hashing"));
   m_scheduler->set_view(*m_viewManager->find_throw("scheduler"));
 
   m_ui->init(this);
 
   m_inputStdin->insert(m_core->get_poll_manager()->get_torrent_poll());
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.cc	2006-05-02 00:30:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download.cc	2006-05-13 05:58:23.000000000 +0800
@@ -54,12 +54,14 @@
 
 Download::Download(download_type d) :
   m_download(d),
   m_fileList(d.file_list()),
   m_trackerList(d.tracker_list()),
 
+  m_hashFailed(false),
+
   m_chunksFailed(0) {
 
   m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
   m_connTrackerFailed   = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
   m_connStorageError    = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download.h	2006-05-02 00:29:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download.h	2006-05-13 06:00:07.000000000 +0800
@@ -53,21 +53,31 @@
   typedef torrent::FileList             file_list_type;
   typedef torrent::TrackerList          tracker_list_type;
   typedef download_type::ConnectionType connection_type;
   typedef utils::VariableMap            variable_map_type;
 
   static const int64_t variable_hashing_stopped = 0;
-  static const int64_t variable_hashing_started = 1;
+  static const int64_t variable_hashing_initial = 1;
   static const int64_t variable_hashing_last    = 2;
+  static const int64_t variable_hashing_rehash  = 3;
 
   Download(download_type d);
   ~Download();
 
   bool                is_open() const                          { return m_download.is_open(); }
   bool                is_active() const                        { return m_download.is_active(); }
-  inline bool         is_done() const                          { return m_download.chunks_done() == m_download.chunks_total(); }
+  bool                is_done() const                          { return m_download.chunks_done() == m_download.chunks_total(); }
+
+  // FIXME: Fixed a bug in libtorrent that caused is_hash_checked to
+  // return true when the torrent is closed. Remove this redundant
+  // test in the next milestone.
+  bool                is_hash_checked() const                  { return m_download.is_open() && m_download.is_hash_checked(); }
+  bool                is_hash_checking() const                 { return m_download.is_hash_checking(); }
+
+  bool                is_hash_failed() const                   { return m_hashFailed; }
+  void                set_hash_failed(bool v)                  { m_hashFailed = v; }
 
   variable_map_type*  variable()                               { return &m_variables; }
   std::string         variable_string(const std::string& key)  { return m_variables.get_string(key); }
 
   download_type*       download()                              { return &m_download; }
   const download_type* download() const                        { return &m_download; }
@@ -124,12 +134,14 @@
 
   // Store the FileList instance so we can use slots etc on it.
   download_type       m_download;
   file_list_type      m_fileList;
   tracker_list_type   m_trackerList;
 
+  bool                m_hashFailed;
+
   std::string         m_message;
   uint32_t            m_chunksFailed;
 
   variable_map_type   m_variables;
 
   sigc::connection    m_connTrackerSucceded;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.cc	2006-05-04 21:15:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download_list.cc	2006-05-19 03:30:16.000000000 +0800
@@ -44,26 +44,25 @@
 #include <torrent/object_stream.h>
 #include <torrent/torrent.h>
 
 #include "rak/functional.h"
 
 #include "globals.h"
-#include "hash_queue.h"
 #include "manager.h"
 
 #include "download.h"
 #include "download_list.h"
 #include "download_store.h"
 
 namespace core {
 
 inline void
 DownloadList::check_contains(Download* d) {
 #ifdef USE_EXTRA_DEBUG
   if (std::find(begin(), end(), d) == end())
-    throw torrent::internal_error("DownloadList::check_contains(...) failed.");
+    throw torrent::client_error("DownloadList::check_contains(...) failed.");
 #endif
 }
 
 struct download_list_call {
   download_list_call(Download* d) : m_download(d) {}
 
@@ -71,13 +70,14 @@
     s.second(m_download);
   }
 
   Download* m_download;
 };    
 
-DownloadList::~DownloadList() {
+void
+DownloadList::clear() {
   std::for_each(begin(), end(), std::bind1st(std::mem_fun(&DownloadList::close), this));
   std::for_each(begin(), end(), rak::call_delete<Download>());
 
   base_type::clear();
 }
 
@@ -117,18 +117,20 @@
 DownloadList::iterator
 DownloadList::insert(Download* download) {
   iterator itr = base_type::insert(end(), download);
 
   try {
     (*itr)->download()->signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::received_finished), download));
-    std::for_each(m_slotMapInsert.begin(), m_slotMapInsert.end(), download_list_call(*itr));
+    (*itr)->download()->signal_hash_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::hash_done), download));
+
+    std::for_each(slot_map_insert().begin(), slot_map_insert().end(), download_list_call(*itr));
 
   } catch (torrent::local_error& e) {
     // Should perhaps relax this, just print an error and remove the
     // downloads?
-    throw torrent::internal_error("Caught during DownloadList::insert(...): " + std::string(e.what()));
+    throw torrent::client_error("Caught during DownloadList::insert(...): " + std::string(e.what()));
   }
 
   return itr;
 }
 
 void
@@ -138,19 +140,22 @@
   erase(std::find(begin(), end(), download));
 }
 
 DownloadList::iterator
 DownloadList::erase(iterator itr) {
   if (itr == end())
-    throw torrent::internal_error("DownloadList::erase(...) could not find download.");
+    throw torrent::client_error("DownloadList::erase(...) could not find download.");
+
+  // Makes sure close doesn't restart hashing of this download.
+  (*itr)->set_hash_failed(true);
 
   close(*itr);
 
   control->core()->download_store()->remove(*itr);
 
-  std::for_each(m_slotMapErase.begin(), m_slotMapErase.end(), download_list_call(*itr));
+  std::for_each(slot_map_erase().begin(), slot_map_erase().end(), download_list_call(*itr));
 
   torrent::download_remove(*(*itr)->download());
   delete *itr;
 
   return base_type::erase(itr);
 }
@@ -177,13 +182,13 @@
 
   if (download->download()->is_open())
     return;
   
   download->download()->open();
 
-  std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(download));
+  std::for_each(slot_map_open().begin(), slot_map_open().end(), download_list_call(download));
 }
 
 void
 DownloadList::close(Download* download) {
   try {
 
@@ -195,31 +200,56 @@
 }
 
 void
 DownloadList::close_throw(Download* download) {
   check_contains(download);
 
-  if (!download->download()->is_open())
+  if (!download->is_open())
     return;
 
-  if (download->download()->is_active())
+  // When pause gets called it will clear the initial hash checking. 
+
+  if (download->is_active())
     pause(download);
   
   // Save the torrent on close, this covers shutdown and if a torrent
   // is manually closed which would clear the progress data. For
   // better crash protection, save regulary in addition to this.
   //
   // Used to be in pause, but this was wrong for rehashing etc.
   //
   // Reconsider this save. Should be done explicitly when shutting down.
   //control->core()->download_store()->save(download);
-  control->core()->hash_queue()->remove(download);
+
+  // FIXME: Urgh, need to do something sane when closing a download
+  // that has been queued for hashing. ATM just close the torrent and
+  // call the hash_removed slots. This might open and restart the
+  // hashing of this torrent.
+
+//   if (download->is_hash_checking()) {
+//     download->download()->close();
+
+//     // Hash removed slot must be called after close as we can't atm
+//     // stop already started hash checks except through close.
+//     std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
+
+//   } else {
+//     download->download()->close();
+//   }
+
+  // But this isn't correct either, i think... ATM do the borking
+  // thing, the hash queue won't be updated. Need to properly handle
+  // erasing a download.
+
+  // Propably should do its own thingie in erase rather than calling
+  // close.
 
   download->download()->close();
 
-  std::for_each(m_slotMapClose.begin(), m_slotMapClose.end(), download_list_call(download));
+  std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
+  std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
 }
 
 void
 DownloadList::start(Download* download) {
   check_contains(download);
 
@@ -243,38 +273,33 @@
 
   try {
 
     if (download->download()->is_active())
       return;
 
-    // Properly escape when resume get's called during hashing. The
-    // 'state' is changed by the call to DownloadList::start so it
-    // will automagically start afterwards.
-    if (control->core()->hash_queue()->find(download) != control->core()->hash_queue()->end())
-      return;
-
-    download->variable()->set("state_changed", cachedTime.seconds());
-
-    open_throw(download);
-
     // Manual or end-of-download rehashing clears the resume data so
     // we can just start the hashing again without clearing it again.
     //
     // It is also assumed the is_hash_checked flag gets cleared when
     // 'hashing' was set.
-    if (!download->download()->is_hash_checked()) {
+    if (!download->is_hash_checked()) {
+      download->set_hash_failed(false);
 
       // Set 'hashing' to started if hashing wasn't started, else keep
       // the old value.
       if (download->variable()->get_value("hashing") == Download::variable_hashing_stopped)
-	download->variable()->set("hashing", Download::variable_hashing_started);
+	download->variable()->set("hashing", Download::variable_hashing_initial);
 
-      control->core()->hash_queue()->insert(download);
+      std::for_each(slot_map_hash_queued().begin(), slot_map_hash_queued().end(), download_list_call(download));
       return;
     }
 
+    download->variable()->set("state_changed", cachedTime.seconds());
+
+    open_throw(download);
+
     if (download->is_done()) {
       download->set_connection_type(download->variable()->get_string("connection_seed"));
     } else {
       download->set_connection_type(download->variable()->get_string("connection_leech"));
 
       // For the moment, clear the resume data so we force hash-check
@@ -286,36 +311,39 @@
 
     // Update the priority to ensure it has the correct
     // seeding/unfinished modifiers.
     download->set_priority(download->priority());
     download->download()->start();
 
-    std::for_each(m_slotMapStart.begin(), m_slotMapStart.end(), download_list_call(download));
+    std::for_each(slot_map_start().begin(), slot_map_start().end(), download_list_call(download));
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
 void
 DownloadList::pause(Download* download) {
   check_contains(download);
 
   try {
 
-    // Make sure we don't start hash checking a download that we won't
-    // start.
-    control->core()->hash_queue()->remove(download);
+    // Don't stop if we're doing the final hashing.
+    if (download->variable()->get_value("hashing") == Download::variable_hashing_initial) {
+      download->variable()->set("hashing", Download::variable_hashing_stopped);
+
+      std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
+    }
 
     if (!download->download()->is_active())
       return;
 
     download->download()->stop();
     download->download()->hash_resume_save();
     
-    std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(download));
+    std::for_each(slot_map_stop().begin(), slot_map_stop().end(), download_list_call(download));
 
     download->variable()->set("state_changed", cachedTime.seconds());
 
     // Save the state after all the slots, etc have been called so we
     // include the modifications they may make.
     //control->core()->download_store()->save(download);
@@ -328,42 +356,26 @@
 void
 DownloadList::check_hash(Download* download) {
   check_contains(download);
 
   try {
 
-    download->variable()->set("hashing", Download::variable_hashing_started);
-    check_hash_throw(download);
+    download->variable()->set("hashing", Download::variable_hashing_rehash);
+    hash_clear(download);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
-// Throw in addition to not setting 'hashing'.
-void
-DownloadList::check_hash_throw(Download* download) {
-  check_contains(download);
-
-  close_throw(download);
-  download->download()->hash_resume_clear();
-  open_throw(download);
-
-  // If any more stuff is added here, make sure resume etc are still
-  // correct.
-  control->core()->hash_queue()->insert(download);
-}
-
 void
 DownloadList::hash_done(Download* download) {
   check_contains(download);
 
-  if (!download->download()->is_hash_checked() ||
-      download->download()->is_hash_checking() ||
-      download->download()->is_active())
-    throw torrent::internal_error("DownloadList::hash_done(...) download in invalid state.");
+  if (!download->is_hash_checked() || download->is_hash_checking() || download->is_active())
+    throw torrent::client_error("DownloadList::hash_done(...) download in invalid state.");
 
   // Need to find some sane conditional here. Can we check the total
   // downloaded to ensure something was transferred, thus we didn't
   // just hash an already completed torrent with lacking session data?
   //
   // Perhaps we should use a seperate variable or state, and check
@@ -372,84 +384,104 @@
   // ReiserFS bug with >4GB files.
 
   int64_t hashing = download->variable()->get_value("hashing");
   download->variable()->set("hashing", Download::variable_hashing_stopped);
 
   switch (hashing) {
-  case Download::variable_hashing_started:
+  case Download::variable_hashing_initial:
+  case Download::variable_hashing_rehash:
     // Normal re/hashing.
 
     if (download->is_done())
       download->variable()->set("complete", (int64_t)1);
     
     // Save resume data so we update time-stamps and priorities if
     // they were invalid/changed when loading.
     download->download()->hash_resume_save();
 
     if (download->variable()->get_value("state") == 1)
       resume(download);
 
-    return;
+    break;
 
   case Download::variable_hashing_last:
 
-    if (download->is_done()) {
-
+    if (download->is_done())
       confirm_finished(download);
-
-      if (download->variable()->get_value("state") == 1)
-	resume(download);
-
-    } else {
+    else
       download->set_message("Hash check on download completion found bad chunks.");
-    }
     
-    return;
+    break;
 
   case Download::variable_hashing_stopped:
   default:
     // Either an error or someone wrote to the hashing variable...
     download->set_message("Hash check completed but the \"hashing\" variable is in an invalid state.");
     return;
   }
+
+  std::for_each(slot_map_hash_done().begin(), slot_map_hash_done().end(), download_list_call(download));
+}
+
+void
+DownloadList::hash_clear(Download* download) {
+  check_contains(download);
+
+  // Set hash failed so close_throw won't cause the hash queue to
+  // reopen this download.
+  download->set_hash_failed(true);
+
+  close_throw(download);
+  download->download()->hash_resume_clear();
+
+  download->set_hash_failed(false);
+
+  if (download->is_open())
+    throw torrent::internal_error("DownloadList::hash_clear(...) download still open.");
+
+  // If any more stuff is added here, make sure resume etc are still
+  // correct.
+  std::for_each(slot_map_hash_queued().begin(), slot_map_hash_queued().end(), download_list_call(download));
 }
 
 void
 DownloadList::received_finished(Download* download) {
   check_contains(download);
 
   if (control->variable()->get_value("check_hash")) {
     // Set some 'checking_finished_thingie' variable to make hash_done
     // trigger correctly, also so it can bork on missing data.
 
     download->variable()->set("hashing", Download::variable_hashing_last);
-    check_hash_throw(download);
+    hash_clear(download);
 
   } else {
     confirm_finished(download);
   }
 }
 
 // The download must be open when we call this function.
 void
 DownloadList::confirm_finished(Download* download) {
   check_contains(download);
 
-  // FIXME
-  //torrent::download_set_priority(m_download, 2);
-
   download->variable()->set("complete", (int64_t)1);
-  download->set_connection_type(download->variable()->get_string("connection_seed"));
 
-  download->download()->tracker_list().send_completed();
+  download->set_connection_type(download->variable()->get_string("connection_seed"));
+  download->set_priority(download->priority());
 
   // Do this before the slots are called in case one of them closes
   // the download.
   if (!download->is_active() && control->variable()->get_value("session_on_completion") == 1) {
     download->download()->hash_resume_save();
     control->core()->download_store()->save(download);
   }
 
-  std::for_each(m_slotMapFinished.begin(), m_slotMapFinished.end(), download_list_call(download));
+  std::for_each(slot_map_finished().begin(), slot_map_finished().end(), download_list_call(download));
+
+  if (!download->is_active() && download->variable()->get_value("state") == 1)
+    resume(download);
+
+  download->download()->tracker_list().send_completed();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_list.h	2006-05-02 22:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download_list.h	2006-05-13 05:28:10.000000000 +0800
@@ -69,13 +69,13 @@
   using base_type::rbegin;
   using base_type::rend;
 
   using base_type::empty;
   using base_type::size;
 
-  ~DownloadList();
+  void                clear();
 
   void                session_save();
 
   // Might move this to DownloadFactory.
   Download*           create(std::istream* str, bool printLog);
 
@@ -97,58 +97,88 @@
 
   // These do not change the rtorrent:state.
   void                resume(Download* d);
   void                pause(Download* d);
 
   void                check_hash(Download* d);
-  void                check_hash_throw(Download* d);
 
-  void                hash_done(Download* d);
-
-  slot_map&           slot_map_insert()                                 { return m_slotMapInsert; }
-  slot_map&           slot_map_erase()                                  { return m_slotMapErase; }
-  slot_map&           slot_map_open()                                   { return m_slotMapOpen; }
-  slot_map&           slot_map_close()                                  { return m_slotMapClose; }
-  slot_map&           slot_map_start()                                  { return m_slotMapStart; }
-  slot_map&           slot_map_stop()                                   { return m_slotMapStop; }
+  enum {
+    SLOTS_INSERT,
+    SLOTS_ERASE,
+    SLOTS_OPEN,
+    SLOTS_CLOSE,
+    SLOTS_START,
+    SLOTS_STOP,
+    SLOTS_HASH_QUEUED,
+    SLOTS_HASH_REMOVED,
+    SLOTS_HASH_DONE,
+    SLOTS_FINISHED,
+
+    SLOTS_MAX_SIZE
+  };
+
+  slot_map&           slots(int m)                                      { return m_slotMaps[m]; }
+  const slot_map&     slots(int m) const                                { return m_slotMaps[m]; }
+
+  slot_map*           slot_map_begin()                                  { return m_slotMaps; }
+  const slot_map*     slot_map_begin() const                            { return m_slotMaps; }
+  slot_map*           slot_map_end()                                    { return m_slotMaps + SLOTS_MAX_SIZE; }
+  const slot_map*     slot_map_end() const                              { return m_slotMaps + SLOTS_MAX_SIZE; }
+
+  slot_map&           slot_map_insert()                                 { return m_slotMaps[SLOTS_INSERT]; }
+  const slot_map&     slot_map_insert() const                           { return m_slotMaps[SLOTS_INSERT]; }
+  slot_map&           slot_map_erase()                                  { return m_slotMaps[SLOTS_ERASE]; }
+  const slot_map&     slot_map_erase() const                            { return m_slotMaps[SLOTS_ERASE]; }
+  slot_map&           slot_map_open()                                   { return m_slotMaps[SLOTS_OPEN]; }
+  const slot_map&     slot_map_open() const                             { return m_slotMaps[SLOTS_OPEN]; }
+  slot_map&           slot_map_close()                                  { return m_slotMaps[SLOTS_CLOSE]; }
+  const slot_map&     slot_map_close() const                            { return m_slotMaps[SLOTS_CLOSE]; }
+  slot_map&           slot_map_start()                                  { return m_slotMaps[SLOTS_START]; }
+  const slot_map&     slot_map_start() const                            { return m_slotMaps[SLOTS_START]; }
+  slot_map&           slot_map_stop()                                   { return m_slotMaps[SLOTS_STOP]; }
+  const slot_map&     slot_map_stop() const                             { return m_slotMaps[SLOTS_STOP]; }
 
   // The finished slots will be called when an active download with
   // "finished" == 0 performs a hash check which returns a done
   // torrent.
   //
   // But how to avoid sending 'completed' messages to the tracker?
   // Also we need to handle cases when a hashing torrent starts up
   // after a shutdown.
 
-  slot_map&           slot_map_hash_done()                              { return m_slotMapHashDone; }
-  slot_map&           slot_map_finished()                               { return m_slotMapFinished; }
-
-  bool                has_slot_insert(const std::string& key) const     { return m_slotMapInsert.find(key) != m_slotMapInsert.end(); }
-  bool                has_slot_erase(const std::string& key) const      { return m_slotMapErase.find(key) != m_slotMapErase.end(); }
-  bool                has_slot_open(const std::string& key) const       { return m_slotMapOpen.find(key) != m_slotMapOpen.end(); }
-  bool                has_slot_close(const std::string& key) const      { return m_slotMapClose.find(key) != m_slotMapClose.end(); }
-  bool                has_slot_start(const std::string& key) const      { return m_slotMapStart.find(key) != m_slotMapStart.end(); }
-  bool                has_slot_stop(const std::string& key) const       { return m_slotMapStop.find(key) != m_slotMapStop.end(); }
+  slot_map&           slot_map_hash_queued()                            { return m_slotMaps[SLOTS_HASH_QUEUED]; }
+  const slot_map&     slot_map_hash_queued() const                      { return m_slotMaps[SLOTS_HASH_QUEUED]; }
+  slot_map&           slot_map_hash_removed()                           { return m_slotMaps[SLOTS_HASH_REMOVED]; }
+  const slot_map&     slot_map_hash_removed() const                     { return m_slotMaps[SLOTS_HASH_REMOVED]; }
+  slot_map&           slot_map_hash_done()                              { return m_slotMaps[SLOTS_HASH_DONE]; }
+  const slot_map&     slot_map_hash_done() const                        { return m_slotMaps[SLOTS_HASH_DONE]; }
+  slot_map&           slot_map_finished()                               { return m_slotMaps[SLOTS_FINISHED]; }
+  const slot_map&     slot_map_finished() const                         { return m_slotMaps[SLOTS_FINISHED]; }
+
+  bool                has_slot_insert(const std::string& key) const     { return slot_map_insert().find(key) != slot_map_insert().end(); }
+  bool                has_slot_erase(const std::string& key) const      { return slot_map_erase().find(key) != slot_map_erase().end(); }
+  bool                has_slot_open(const std::string& key) const       { return slot_map_open().find(key) != slot_map_open().end(); }
+  bool                has_slot_close(const std::string& key) const      { return slot_map_close().find(key) != slot_map_close().end(); }
+  bool                has_slot_start(const std::string& key) const      { return slot_map_start().find(key) != slot_map_start().end(); }
+  bool                has_slot_stop(const std::string& key) const       { return slot_map_stop().find(key) != slot_map_stop().end(); }
+
+  bool                has_slot_hash_queued(const std::string& key) const{ return slot_map_hash_queued().find(key) != slot_map_hash_queued().end(); }
+  bool                has_slot_hash_done(const std::string& key) const  { return slot_map_hash_done().find(key) != slot_map_hash_done().end(); }
+  bool                has_slot_finished(const std::string& key) const   { return slot_map_finished().find(key) != slot_map_finished().end(); }
 
-  bool                has_slot_hash_done(const std::string& key) const  { return m_slotMapFinished.find(key) != m_slotMapFinished.end(); }
-  bool                has_slot_finished(const std::string& key) const   { return m_slotMapFinished.find(key) != m_slotMapFinished.end(); }
+  static void         erase_key(slot_map& sm, const std::string& key)   { sm.erase(key); }
 
 private:
+  void                hash_done(Download* d);
+  void                hash_clear(Download* d);
+
   inline void         check_contains(Download* d);
 
   void                received_finished(Download* d);
   void                confirm_finished(Download* d);
 
-  slot_map            m_slotMapInsert;
-  slot_map            m_slotMapErase;
-  slot_map            m_slotMapOpen;
-  slot_map            m_slotMapClose;
-  slot_map            m_slotMapStart;
-  slot_map            m_slotMapStop;
-
-  slot_map            m_slotMapHashDone;
-  slot_map            m_slotMapFinished;
+  slot_map            m_slotMaps[SLOTS_MAX_SIZE];
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download_store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/download_store.cc	2006-05-02 00:30:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/download_store.cc	2006-05-12 05:44:07.000000000 +0800
@@ -38,12 +38,13 @@
 
 #include "config.h"
 
 #include <fstream>
 #include <stdio.h>
 #include <unistd.h>
+#include <rak/error_number.h>
 #include <rak/path.h>
 #include <rak/string_manip.h>
 #include <torrent/object.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 #include <torrent/rate.h>
@@ -65,13 +66,16 @@
   if (lock)
     m_lockfile.set_path(m_path + "rtorrent.lock");
   else
     m_lockfile.set_path(std::string());
 
   if (!m_lockfile.try_lock())
-    throw torrent::input_error("Could not lock session directory: \"" + m_path + "\", held by \"" + m_lockfile.locked_by_as_string() + "\".");
+    if (rak::error_number::current().is_bad_path())
+      throw torrent::input_error("Could not lock session directory: \"" + m_path + "\", " + rak::error_number::current().c_str());
+    else
+      throw torrent::input_error("Could not lock session directory: \"" + m_path + "\", held by \"" + m_lockfile.locked_by_as_string() + "\".");
 }
 
 void
 DownloadStore::disable() {
   if (!is_enabled())
     return;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: hash_queue.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core: hash_queue.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.am	2006-05-02 00:28:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/Makefile.am	2006-05-13 03:56:55.000000000 +0800
@@ -11,14 +11,12 @@
 	download_factory.h \
 	download_list.cc \
 	download_list.h \
 	download_slot_map.h \
 	download_store.cc \
 	download_store.h \
-	hash_queue.cc \
-	hash_queue.h \
 	http_queue.cc \
 	http_queue.h \
 	log.cc \
 	log.h \
 	manager.cc \
 	manager.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/Makefile.in	2006-05-02 00:47:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/Makefile.in	2006-05-19 23:31:35.000000000 +0800
@@ -53,16 +53,16 @@
 ARFLAGS = cru
 libsub_core_a_AR = $(AR) $(ARFLAGS)
 libsub_core_a_LIBADD =
 am_libsub_core_a_OBJECTS = curl_get.$(OBJEXT) curl_stack.$(OBJEXT) \
 	download.$(OBJEXT) download_factory.$(OBJEXT) \
 	download_list.$(OBJEXT) download_store.$(OBJEXT) \
-	hash_queue.$(OBJEXT) http_queue.$(OBJEXT) log.$(OBJEXT) \
-	manager.$(OBJEXT) poll_manager.$(OBJEXT) \
-	poll_manager_epoll.$(OBJEXT) poll_manager_select.$(OBJEXT) \
-	scheduler.$(OBJEXT) view.$(OBJEXT) view_manager.$(OBJEXT)
+	http_queue.$(OBJEXT) log.$(OBJEXT) manager.$(OBJEXT) \
+	poll_manager.$(OBJEXT) poll_manager_epoll.$(OBJEXT) \
+	poll_manager_select.$(OBJEXT) scheduler.$(OBJEXT) \
+	view.$(OBJEXT) view_manager.$(OBJEXT)
 libsub_core_a_OBJECTS = $(am_libsub_core_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -196,14 +196,12 @@
 	download_factory.h \
 	download_list.cc \
 	download_list.h \
 	download_slot_map.h \
 	download_store.cc \
 	download_store.h \
-	hash_queue.cc \
-	hash_queue.h \
 	http_queue.cc \
 	http_queue.h \
 	log.cc \
 	log.h \
 	manager.cc \
 	manager.h \
@@ -271,13 +269,12 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_get.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/curl_stack.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download_factory.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download_store.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hash_queue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/http_queue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_epoll.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_select.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.cc	2006-05-02 01:45:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/manager.cc	2006-05-16 01:47:16.000000000 +0800
@@ -57,17 +57,17 @@
 
 #include "globals.h"
 #include "curl_get.h"
 #include "download.h"
 #include "download_factory.h"
 #include "download_store.h"
-#include "hash_queue.h"
 #include "http_queue.h"
 #include "manager.h"
 #include "poll_manager_epoll.h"
 #include "poll_manager_select.h"
+#include "view.h"
 
 namespace core {
 
 static void
 connect_signal_network_log(Download* d, torrent::Download::slot_string_type s) {
   d->download()->signal_network_log(s);
@@ -111,32 +111,41 @@
   // thingie to be implemented.
   if (!tie.empty())
     ::unlink(tie.c_str());
 }
 
 Manager::Manager() :
+  m_hashingView(NULL),
+
   m_pollManager(NULL),
   m_portFirst(6890),
   m_portLast(6999) {
 
   m_downloadStore = new DownloadStore();
   m_downloadList = new DownloadList();
 
   m_httpQueue = new HttpQueue();
-  m_hashQueue = new HashQueue(m_downloadList);
 }
 
 Manager::~Manager() {
   delete m_downloadList;
-  delete m_hashQueue;
 
   delete m_downloadStore;
   delete m_httpQueue;
 }
 
 void
+Manager::set_hashing_view(View* v) {
+  if (v == NULL || m_hashingView != NULL)
+    throw torrent::client_error("Manager::set_hashing_view(...) received NULL or is already set.");
+
+  m_hashingView = v;
+  v->signal_changed().connect(sigc::mem_fun(this, &Manager::receive_hashing_changed));
+}
+
+void
 Manager::initialize_first() {
   if ((m_pollManager = PollManagerEPoll::create(sysconf(_SC_OPEN_MAX))) != NULL)
     m_logImportant.push_front("Using 'epoll' based polling.");
   else if ((m_pollManager = PollManagerSelect::create(sysconf(_SC_OPEN_MAX))) != NULL)
     m_logImportant.push_front("Using 'select' based polling.");
   else
@@ -157,20 +166,22 @@
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
   m_downloadList->slot_map_insert()["1_connect_network_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   m_downloadList->slot_map_insert()["1_connect_storage_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   m_downloadList->slot_map_insert()["1_connect_tracker_dump"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_dump), sigc::ptr_fun(&receive_tracker_dump));
 
-  m_downloadList->slot_map_erase()["1_delete_tied"]          = sigc::ptr_fun(&delete_tied);
+  m_downloadList->slot_map_erase()["1_delete_tied"] = sigc::ptr_fun(&delete_tied);
 }
 
 void
 Manager::cleanup() {
   // Need to disconnect log signals? Not really since we won't receive
   // any more.
 
+  m_downloadList->clear();
+
   torrent::cleanup();
   CurlStack::global_cleanup();
 
   delete m_pollManager;
 }
 
@@ -355,7 +366,38 @@
       try_create_download(*itr, start, printLog, tied);
 
   else
     try_create_download(uri, start, printLog, tied);
 }
 
+// DownloadList's hashing related functions don't actually start the
+// hashing, it only reacts to events. This functions checks the
+// hashing view and starts hashing if nessesary.
+void
+Manager::receive_hashing_changed() {
+  if (m_hashingView->empty_visible() ||
+      std::find_if(m_hashingView->begin_visible(), m_hashingView->end_visible(), std::mem_fun(&Download::is_hash_checking)) != m_hashingView->end_visible())
+    return;
+
+  for (View::iterator itr = m_hashingView->begin_visible(), last = m_hashingView->end_visible(); itr != last; ++itr) {
+
+    try {
+
+      if ((*itr)->is_hash_checked())
+	throw torrent::client_error("core::Manager::receive_hashing_changed() hash already checked.");
+  
+      if ((*itr)->is_hash_failed())
+	continue;
+
+      m_downloadList->open_throw(*itr);
+      (*itr)->download()->hash_check();
+
+      return;
+
+    } catch (torrent::local_error& e) {
+      (*itr)->set_hash_failed(true);
+      push_log(e.what());
+    }
+  }
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/manager.h	2006-05-02 00:29:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/manager.h	2006-05-13 03:57:16.000000000 +0800
@@ -47,14 +47,14 @@
   class Bencode;
 }
 
 namespace core {
 
 class DownloadStore;
-class HashQueue;
 class HttpQueue;
+class View;
 
 class Manager {
 public:
   typedef DownloadList::iterator                    DListItr;
   typedef sigc::slot1<void, DownloadList::iterator> SlotReady;
   typedef sigc::slot0<void>                         SlotFailed;
@@ -59,19 +59,20 @@
   typedef sigc::slot1<void, DownloadList::iterator> SlotReady;
   typedef sigc::slot0<void>                         SlotFailed;
 
   Manager();
   ~Manager();
 
-
   DownloadList*       download_list()                     { return m_downloadList; }
   DownloadStore*      download_store()                    { return m_downloadStore; }
 
-  HashQueue*          hash_queue()                        { return m_hashQueue; }
   HttpQueue*          http_queue()                        { return m_httpQueue; }
 
+  View*               hashing_view()                      { return m_hashingView; }
+  void                set_hashing_view(View* v);
+
   PollManager*        get_poll_manager()                  { return m_pollManager; }
   Log&                get_log_important()                 { return m_logImportant; }
   Log&                get_log_complete()                  { return m_logComplete; }
 
   void                set_port_range(int a, int b)        { m_portFirst = a; m_portLast = b; }
 
@@ -101,17 +102,20 @@
   void                create_final(std::istream* s);
 
   void                initialize_bencode(Download* d);
 
   void                receive_http_failed(std::string msg);
 
+  void                receive_hashing_changed();
+
   DownloadList*       m_downloadList;
   DownloadStore*      m_downloadStore;
-  HashQueue*          m_hashQueue;
   HttpQueue*          m_httpQueue;
 
+  View*               m_hashingView;
+
   PollManager*        m_pollManager;
   Log                 m_logImportant;
   Log                 m_logComplete;
 
   int                 m_portFirst;
   int                 m_portLast;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/scheduler.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/scheduler.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/scheduler.cc	2006-05-02 00:30:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/scheduler.cc	2006-05-13 07:57:50.000000000 +0800
@@ -62,13 +62,13 @@
 Scheduler::set_view(View* view) {
   m_view = view;
 }
 
 Scheduler::size_type
 Scheduler::active() const {
-  return std::count_if(m_view->begin(), m_view->end(), std::mem_fun(&Download::is_active));
+  return std::count_if(m_view->begin_visible(), m_view->end_visible(), std::mem_fun(&Download::is_active));
 }
 
 void
 Scheduler::update() {
   size_type curActive = active();
   //  size_type curInactive = m_view->size() - curActive;
@@ -77,27 +77,27 @@
   m_view->sort();
 
   // Just a hack for now, need to take into consideration how many
   // inactive we can switch with.
   size_type target = m_maxActive - std::min(m_cycle, m_maxActive);
 
-  for (View::iterator itr = m_view->begin(), last = m_view->end(); curActive > target; ++itr) {
+  for (View::iterator itr = m_view->begin_visible(), last = m_view->end_visible(); curActive > target; ++itr) {
     if (itr == last)
-      throw torrent::internal_error("Scheduler::update() loop bork.");
+      throw torrent::client_error("Scheduler::update() loop bork.");
 
     if ((*itr)->is_active()) {
       m_downloadList->pause(*itr);
       --curActive;
     }      
   }
 
   m_view->sort();
 
-  for (View::iterator itr = m_view->begin(), last = m_view->end(); curActive < m_maxActive; ++itr) {
+  for (View::iterator itr = m_view->begin_visible(), last = m_view->end_visible(); curActive < m_maxActive; ++itr) {
     if (itr == last)
-      throw torrent::internal_error("Scheduler::update() loop bork.");
+      throw torrent::client_error("Scheduler::update() loop bork.");
 
     if (!(*itr)->is_active()) {
       m_downloadList->resume(*itr);
       ++curActive;
     }      
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view.cc	2006-05-02 00:30:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view.cc	2006-05-13 07:57:50.000000000 +0800
@@ -35,12 +35,14 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <algorithm>
 #include <functional>
+#include <rak/functional.h>
+#include <sigc++/bind.h>
 #include <torrent/download.h>
 
 #include "download.h"
 #include "download_list.h"
 
 #include "view.h"
@@ -48,43 +50,42 @@
 namespace core {
 
 View::~View() {
   if (m_name.empty())
     return;
 
-  std::string key = "0_view_" + m_name;
-
-  m_list->slot_map_insert().erase(key);
-  m_list->slot_map_erase().erase(key);
+  std::for_each(m_list->slot_map_begin(), m_list->slot_map_end(),
+		rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
 }
 
 void
-View::initialize(const std::string& name, core::DownloadList* list) {
+View::initialize(const std::string& name, core::DownloadList* dlist) {
   if (!m_name.empty())
-    throw torrent::internal_error("View::initialize(...) called on an already initialized view.");
+    throw torrent::client_error("View::initialize(...) called on an already initialized view.");
 
   if (name.empty())
-    throw torrent::internal_error("View::initialize(...) called with an empty name.");
+    throw torrent::client_error("View::initialize(...) called with an empty name.");
 
   std::string key = "0_view_" + name;
 
-  if (list->has_slot_insert(key) || list->has_slot_erase(key))
-    throw torrent::internal_error("View::initialize(...) duplicate key name found in DownloadList.");
+  if (dlist->has_slot_insert(key) || dlist->has_slot_erase(key))
+    throw torrent::client_error("View::initialize(...) duplicate key name found in DownloadList.");
 
   m_name = name;
+  m_list = dlist;
 
-  m_list = list;
-  m_size = 0;
-  m_focus = 0;
+  // Urgh, wrong. No filtering being done.
+  std::for_each(m_list->begin(), m_list->end(), rak::bind1st(std::mem_fun(&View::push_back), this));
 
-  set_last_changed(rak::timer());
+  m_size = base_type::size();
+  m_focus = 0;
 
-  std::for_each(m_list->begin(), m_list->end(), std::bind1st(std::mem_fun(&View::received_insert), this));
+  m_list->slot_map_insert()[key] = sigc::bind(sigc::mem_fun(this, &View::received), (int)DownloadList::SLOTS_INSERT);
+  m_list->slot_map_erase()[key]  = sigc::bind(sigc::mem_fun(this, &View::received), (int)DownloadList::SLOTS_ERASE);
 
-  m_list->slot_map_insert()[key] = sigc::mem_fun(this, &View::received_insert);
-  m_list->slot_map_erase()[key]  = sigc::mem_fun(this, &View::received_erase);
+  set_last_changed(rak::timer());
 }
 
 void
 View::next_focus() {
   if (empty())
     return;
@@ -141,18 +142,18 @@
 
   const View::filter_list& m_filter;
 };
 
 void
 View::sort() {
-  Download* curFocus = focus() != end() ? *focus() : NULL;
+  Download* curFocus = focus() != end_visible() ? *focus() : NULL;
 
   // Don't go randomly switching around equivalent elements.
-  std::stable_sort(begin(), end(), view_downloads_compare(m_sortCurrent));
+  std::stable_sort(begin(), end_visible(), view_downloads_compare(m_sortCurrent));
 
-  m_focus = position(std::find(begin(), end(), curFocus));
+  m_focus = position(std::find(begin(), end_visible(), curFocus));
   m_signalChanged.emit();
 }
 
 void
 View::filter() {
   iterator split = std::stable_partition(base_type::begin(), base_type::end(), view_downloads_filter(m_filter));
@@ -161,42 +162,93 @@
 
   // Fix focus
   m_focus = std::min(m_focus, m_size);
 }
 
 void
-View::received_insert(core::Download* d) {
-  // Chagne according to filtered/not.
-  iterator itr;
-  
-  if (view_downloads_filter(m_filter)(d)) {
-    itr = std::find_if(begin(), end(), std::bind1st(view_downloads_compare(m_sortNew), d));
+View::set_filter_on(int event) {
+  if (event == DownloadList::SLOTS_INSERT || event == DownloadList::SLOTS_ERASE || event >= DownloadList::SLOTS_MAX_SIZE)
+    throw torrent::client_error("View::filter_on(...) invalid event.");
 
-    m_size++;
-    m_focus += (m_focus >= position(itr));
+  m_list->slots(event)["0_view_" + m_name]  = sigc::bind(sigc::mem_fun(this, &View::received), event);
+}
 
-  } else {
-    itr = end_filtered();
-  }
+void
+View::clear_filter_on() {
+  // Don't clear insert and erase as these are required to keep the
+  // View up-to-date with the available downloads.
+  std::for_each(m_list->slot_map_begin() + DownloadList::SLOTS_OPEN, m_list->slot_map_end(),
+		rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
+}
 
-  if (m_focus > m_size)
-    throw torrent::internal_error("View::received_insert(...) m_focus > m_size.");
+inline void
+View::insert_visible(Download* d) {
+  iterator itr = std::find_if(begin_visible(), end_visible(), std::bind1st(view_downloads_compare(m_sortNew), d));
+
+  m_size++;
+  m_focus += (m_focus >= position(itr));
 
   base_type::insert(itr, d);
-  m_signalChanged.emit();
 }
 
-void
-View::received_erase(core::Download* d) {
-  iterator itr = std::find(begin(), end_filtered(), d);
-
+inline void
+View::erase(iterator itr) {
   if (itr == end_filtered())
-    return;
+    throw torrent::client_error("View::erase_visible(...) iterator out of range.");
 
-  m_size -= (itr < end());
+  m_size -= (itr < end_visible());
   m_focus -= (m_focus > position(itr));
 
   base_type::erase(itr);
+}
+
+void
+View::received(core::Download* download, int event) {
+  iterator itr = std::find(base_type::begin(), base_type::end(), download);
+
+  switch (event) {
+  case DownloadList::SLOTS_INSERT:
+  
+    if (itr != base_type::end())
+      throw torrent::client_error("View::received(..., SLOTS_INSERT) already inserted.");
+
+    if (view_downloads_filter(m_filter)(download))
+      insert_visible(download);
+    else
+      base_type::insert(end_filtered(), download);
+
+    if (m_focus > m_size)
+      throw torrent::client_error("View::received(...) m_focus > m_size.");
+
+    break;
+
+  case DownloadList::SLOTS_ERASE:
+    erase(itr);
+    break;
+
+  default:
+    if (itr == end_filtered())
+      throw torrent::client_error("View::received(..., SLOTS_*) could not find download.");
+
+    if (view_downloads_filter(m_filter)(download)) {
+      
+      // Erase even if it is in visible so that the download is
+      // re-sorted.
+      erase(itr);
+      insert_visible(download);
+
+    } else {
+
+      if (itr >= begin_filtered())
+	return;
+
+      erase(itr);
+      base_type::push_back(download);
+    }
+
+    break;
+  }
+
   m_signalChanged.emit();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view.h	2006-05-02 00:29:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view.h	2006-05-13 08:11:09.000000000 +0800
@@ -61,44 +61,46 @@
 
 class Download;
 class DownloadList;
 class ViewSort;
 class ViewFilter;
 
-class View : public std::vector<core::Download*> {
+class View : private std::vector<Download*> {
 public:
-  typedef std::vector<core::Download*>   base_type;
+  typedef std::vector<Download*>         base_type;
   typedef sigc::signal0<void>            signal_type;
   typedef std::vector<const ViewSort*>   sort_list;
   typedef std::vector<const ViewFilter*> filter_list;
 
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::reverse_iterator;
   using base_type::const_reverse_iterator;
   
   using base_type::size_type;
 
-  using base_type::begin;
-  using base_type::rbegin;
-
   View() {}
   ~View();
 
-  void                initialize(const std::string& name, core::DownloadList* list);
+  void                initialize(const std::string& name, DownloadList* dlist);
 
   const std::string&  name() const                            { return m_name; }
 
-  bool                empty() const                           { return m_size == 0; }
+  bool                empty_visible() const                   { return m_size == 0; }
+
   size_type           size() const                            { return m_size; }
 
   // Perhaps this should be renamed?
-  iterator            end()                                   { return begin() + m_size; }
-  const_iterator      end() const                             { return begin() + m_size; }
+  iterator            begin_visible()                         { return begin(); }
+  const_iterator      begin_visible() const                   { return begin(); }
 
-//   using base_type::rend;
+  iterator            end_visible()                           { return begin() + m_size; }
+  const_iterator      end_visible() const                     { return begin() + m_size; }
+
+  iterator            begin_filtered()                        { return begin() + m_size; }
+  const_iterator      begin_filtered() const                  { return begin() + m_size; }
 
   iterator            end_filtered()                          { return base_type::end(); }
   const_iterator      end_filtered() const                    { return base_type::end(); }
 
   iterator            focus()                                 { return begin() + m_focus; }
   const_iterator      focus() const                           { return begin() + m_focus; }
@@ -111,13 +113,17 @@
 
   void                set_sort_new(const sort_list& s)        { m_sortNew = s; }
   void                set_sort_current(const sort_list& s)    { m_sortCurrent = s; }
 
   // Need to explicity trigger filtering.
   void                filter();
+
   void                set_filter(const filter_list& s)        { m_filter = s; }
+  void                set_filter_on(int event);
+
+  void                clear_filter_on();
 
   // The time of the last change to the view, semantics of this is
   // user-dependent. Used by f.ex. ViewManager to decide if it should
   // sort and/or filter a view.
   //
   // Currently initialized to rak::timer(), though perhaps we should
@@ -130,22 +136,26 @@
   signal_type&        signal_changed()                        { return m_signalChanged; }
 
 private:
   View(const View&);
   void operator = (const View&);
 
-  void                received_insert(core::Download* d);
-  void                received_erase(core::Download* d);
+  void                push_back(Download* d)                  { base_type::push_back(d); }
+
+  inline void         insert_visible(Download* d);
+  inline void         erase(iterator itr);
+
+  void                received(Download* d, int event);
 
   size_type           position(const_iterator itr) const      { return itr - begin(); }
 
   // An received thing for changed status so we can sort and filter.
 
   std::string         m_name;
 
-  core::DownloadList* m_list;
+  DownloadList*       m_list;
 
   size_type           m_size;
   size_type           m_focus;
 
   sort_list           m_sortNew;
   sort_list           m_sortCurrent;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view_manager.cc	2006-05-04 01:30:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view_manager.cc	2006-05-13 07:57:50.000000000 +0800
@@ -40,12 +40,14 @@
 #include <rak/functional.h>
 #include <torrent/exceptions.h>
 
 #include "globals.h"
 
 #include "download.h"
+#include "download_list.h"
+#include "manager.h"
 #include "view.h"
 #include "view_manager.h"
 
 namespace core {
 
 class ViewSortFalse : public ViewSort {
@@ -77,21 +79,25 @@
   std::string m_name;
   std::string m_value;
 };
 
 class ViewSortVariableValue : public ViewSort {
 public:
-  ViewSortVariableValue(const std::string& name) :
+  ViewSortVariableValue(const std::string& name, bool reverse = false) :
     m_name(name) {}
 
   virtual bool operator () (Download* d1, Download* d2) const {
-    return d1->variable()->get_value(m_name) < d2->variable()->get_value(m_name);
+    if (m_reverse)
+      return d2->variable()->get_value(m_name) < d1->variable()->get_value(m_name);
+    else
+      return d1->variable()->get_value(m_name) < d2->variable()->get_value(m_name);
   }
 
 private:
   std::string m_name;
+  bool        m_reverse;
 };
 
 class ViewSortReverse : public ViewSort {
 public:
   ViewSortReverse(ViewSort* s) : m_sort(s) {}
   ~ViewSortReverse() { delete m_sort; }
@@ -103,22 +109,23 @@
 private:
   ViewSort* m_sort;
 };
 
 class ViewFilterVariableValue : public ViewFilter {
 public:
-  ViewFilterVariableValue(const std::string& name, torrent::Object::value_type v) :
-    m_name(name), m_value(v) {}
+  ViewFilterVariableValue(const std::string& name, torrent::Object::value_type v, bool inverse = false) :
+    m_name(name), m_value(v), m_inverse(inverse) {}
 
   virtual bool operator () (Download* d1) const {
-    return d1->variable()->get_value(m_name) == m_value;
+    return (d1->variable()->get_value(m_name) == m_value) != m_inverse;
   }
 
 private:
   std::string                 m_name;
   torrent::Object::value_type m_value;
+  bool                        m_inverse;
 };
 
 // Really need to implement a factory and allow options in the sort
 // statements.
 ViewManager::ViewManager(DownloadList* dl) :
   m_list(dl) {
@@ -126,23 +133,24 @@
 //   m_sort["first"]        = new ViewSortNot(new ViewSort());
   m_sort["last"]          = new ViewSortFalse();
   m_sort["name"]          = new ViewSortName();
   m_sort["name_reverse"]  = new ViewSortReverse(new ViewSortName());
 
   m_sort["stopped"]       = new ViewSortVariableValue("state");
-  m_sort["started"]       = new ViewSortReverse(new ViewSortVariableValue("state"));
+  m_sort["started"]       = new ViewSortVariableValue("state", true);
   m_sort["complete"]      = new ViewSortVariableValue("complete");
-  m_sort["incomplete"]    = new ViewSortReverse(new ViewSortVariableValue("complete"));
+  m_sort["incomplete"]    = new ViewSortVariableValue("complete", true);
 
   m_sort["state_changed"]         = new ViewSortVariableValue("state_changed");
-  m_sort["state_changed_reverse"] = new ViewSortReverse(new ViewSortVariableValue("state_changed"));
+  m_sort["state_changed_reverse"] = new ViewSortVariableValue("state_changed", true);
 
   m_filter["started"]     = new ViewFilterVariableValue("state", 1);
   m_filter["stopped"]     = new ViewFilterVariableValue("state", 0);
-  m_filter["complete"]    = new ViewFilterVariableValue("complete", 1);
+  m_filter["complete"]    = new ViewFilterVariableValue("complete", 0, true);
   m_filter["incomplete"]  = new ViewFilterVariableValue("complete", 0);
+  m_filter["hashing"]     = new ViewFilterVariableValue("hashing", 0, true);
 }
 
 void
 ViewManager::clear() {
   std::for_each(begin(), end(), rak::call_delete<View>());
   std::for_each(m_sort.begin(), m_sort.end(), rak::on(rak::mem_ptr_ref(&sort_map::value_type::second), rak::call_delete<ViewSort>()));
@@ -150,13 +158,13 @@
   base_type::clear();
 }
 
 ViewManager::iterator
 ViewManager::insert(const std::string& name) {
   if (find(name) != end())
-    throw torrent::internal_error("ViewManager::insert(...) name already inserted.");
+    throw torrent::client_error("ViewManager::insert(...) name already inserted.");
 
   View* view = new View();
   view->initialize(name, m_list);
 
   return base_type::insert(end(), view);
 }
@@ -241,7 +249,39 @@
 ViewManager::set_filter(const std::string& name, const filter_args& args) {
   iterator viewItr = find_throw(name);
 
   (*viewItr)->set_filter(build_filter_list(args));
 }
 
+void
+ViewManager::set_filter_on(const std::string& name, const filter_args& args) {
+  iterator viewItr = find_throw(name);
+
+  (*viewItr)->clear_filter_on();
+
+  for (filter_args::const_iterator itr = args.begin(); itr != args.end(); ++itr) {
+
+    if (*itr == "start")
+      (*viewItr)->set_filter_on(DownloadList::SLOTS_START);
+
+    else if (*itr == "stop")
+      (*viewItr)->set_filter_on(DownloadList::SLOTS_STOP);
+
+    else if (*itr == "hash_queued")
+      (*viewItr)->set_filter_on(DownloadList::SLOTS_HASH_QUEUED);
+
+    else if (*itr == "hash_removed")
+      (*viewItr)->set_filter_on(DownloadList::SLOTS_HASH_REMOVED);
+
+    else if (*itr == "hash_done")
+      (*viewItr)->set_filter_on(DownloadList::SLOTS_HASH_DONE);
+
+    else if (*itr == "finished")
+      (*viewItr)->set_filter_on(DownloadList::SLOTS_FINISHED);
+
+    else
+      throw torrent::input_error("Invalid filter on identifier.");
+
+  }
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view_manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view_manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/core/view_manager.h	2006-05-02 00:29:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/core/view_manager.h	2006-05-09 04:22:39.000000000 +0800
@@ -98,12 +98,13 @@
   void                sort(const std::string& name, uint32_t timeout = 0);
 
   void                set_sort_new(const std::string& name, const sort_args& sort);
   void                set_sort_current(const std::string& name, const sort_args& sort);
 
   void                set_filter(const std::string& name, const filter_args& args);
+  void                set_filter_on(const std::string& name, const filter_args& args);
 
 private:
   inline sort_list    build_sort_list(const sort_args& args);
   inline filter_list  build_filter_list(const sort_args& args);
 
   DownloadList*       m_list;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/utils.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/display/utils.cc	2006-05-13 07:57:50.000000000 +0800
@@ -76,13 +76,13 @@
 char*
 print_hhmmss_local(char* first, char* last, time_t t) {
   std::tm *u = std::localtime(&t);
   
   if (u == NULL)
     //return "inv_time";
-    throw torrent::internal_error("print_hhmmss_local(...) failed.");
+    throw torrent::client_error("print_hhmmss_local(...) failed.");
 
   return print_buffer(first, last, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
 }
 
 char*
 print_ddhhmm(char* first, char* last, time_t t) {
@@ -95,13 +95,13 @@
 char*
 print_ddmmyyyy(char* first, char* last, time_t t) {
   std::tm *u = std::gmtime(&t);
   
   if (u == NULL)
     //return "inv_time";
-    throw torrent::internal_error("print_ddmmyyyy(...) failed.");
+    throw torrent::client_error("print_ddmmyyyy(...) failed.");
 
   return print_buffer(first, last, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
 }
 
 char*
 print_address(char* first, char* last, const rak::socket_address* sa) {
@@ -151,23 +151,23 @@
   }
 
   if (d->priority() != 2)
     first = print_buffer(first, last, " [%s]", core::Download::priority_to_string(d->priority()));
 
   if (first > last)
-    throw torrent::internal_error("print_download_info(...) wrote past end of the buffer.");
+    throw torrent::client_error("print_download_info(...) wrote past end of the buffer.");
 
   return first;
 }
 
 char*
 print_download_status(char* first, char* last, core::Download* d) {
-  if (!d->download()->is_active())
+  if (!d->is_active())
     first = print_buffer(first, last, "Inactive: ");
 
-  if (d->download()->is_hash_checking()) {
+  if (d->is_hash_checking()) {
     first = print_buffer(first, last, "Checking hash [%2i%%]",
 		       (d->download()->chunks_hashed() * 100) / d->download()->chunks_total());
 
   } else if (d->tracker_list()->is_busy() && d->tracker_list()->focus() < d->tracker_list()->size()) {
     torrent::TrackerList* tl = d->tracker_list();
 
@@ -179,13 +179,13 @@
 
   } else {
     *first = '\0';
   }
 
   if (first > last)
-    throw torrent::internal_error("print_download_status(...) wrote past end of the buffer.");
+    throw torrent::client_error("print_download_status(...) wrote past end of the buffer.");
 
   return first;
 }
 
 char*
 print_download_time_left(char* first, char* last, core::Download* d) {
@@ -230,13 +230,13 @@
     first = print_buffer(first, last, " [Local ");
     first = print_address(first, last, torrent::connection_manager()->local_address());
     first = print_buffer(first, last, "]");
   }
   
   if (first > last)
-    throw torrent::internal_error("print_status_info(...) wrote past end of the buffer.");
+    throw torrent::client_error("print_status_info(...) wrote past end of the buffer.");
 
   if (!rak::socket_address::cast_from(torrent::connection_manager()->bind_address())->is_address_any()) {
     first = print_buffer(first, last, " [Bind ");
     first = print_address(first, last, torrent::connection_manager()->bind_address());
     first = print_buffer(first, last, "]");
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/display/window_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/display/window_download_list.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/display/window_download_list.cc	2006-05-13 04:11:01.000000000 +0800
@@ -70,26 +70,26 @@
 
   if (m_view == NULL)
     return;
 
   m_canvas->print(0, 0, "%s", ("[View: " + m_view->name() + "]").c_str());
 
-  if (m_view->empty() || m_canvas->get_width() < 5 || m_canvas->get_height() < 2)
+  if (m_view->empty_visible() || m_canvas->get_width() < 5 || m_canvas->get_height() < 2)
     return;
 
   typedef std::pair<core::View::iterator, core::View::iterator> Range;
 
-  Range range = rak::advance_bidirectional(m_view->begin(),
-					   m_view->focus() != m_view->end() ? m_view->focus() : m_view->begin(),
-					   m_view->end(),
+  Range range = rak::advance_bidirectional(m_view->begin_visible(),
+					   m_view->focus() != m_view->end_visible() ? m_view->focus() : m_view->begin_visible(),
+					   m_view->end_visible(),
 					   m_canvas->get_height() / 3);
 
   // Make sure we properly fill out the last lines so it looks like
   // there are more torrents, yet don't hide it if we got the last one
   // in focus.
-  if (range.second != m_view->end())
+  if (range.second != m_view->end_visible())
     ++range.second;
 
   int pos = 1;
 
   while (range.first != range.second) {
     char buffer[m_canvas->get_width()];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/main.cc	2006-05-04 01:19:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/main.cc	2006-05-13 04:09:35.000000000 +0800
@@ -75,12 +75,13 @@
 parse_options(Control* c, int argc, char** argv) {
   try {
     OptionParser optionParser;
 
     // Converted.
     optionParser.insert_flag('h', sigc::ptr_fun(&print_help));
+    optionParser.insert_flag('n', OptionParser::Slot());
 
     optionParser.insert_option('b', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "bind"));
     optionParser.insert_option('d', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "directory"));
     optionParser.insert_option('i', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "ip"));
     optionParser.insert_option('p', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "port_range"));
     optionParser.insert_option('s', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "session"));
@@ -170,48 +171,61 @@
     control->variable()->process_command("view_add = name");
     control->variable()->process_command("view_sort_new = name,name");
     control->variable()->process_command("view_sort_current = name,name");
 
     control->variable()->process_command("view_add = started");
     control->variable()->process_command("view_filter = started,started");
+    control->variable()->process_command("view_filter_on = started,start,stop");
     control->variable()->process_command("view_sort_new = started,name");
     control->variable()->process_command("view_sort_current = started,name");
 
     control->variable()->process_command("view_add = stopped");
     control->variable()->process_command("view_filter = stopped,stopped");
+    control->variable()->process_command("view_filter_on = stopped,start,stop");
     control->variable()->process_command("view_sort_new = stopped,name");
     control->variable()->process_command("view_sort_current = stopped,name");
 
     control->variable()->process_command("view_add = complete");
     control->variable()->process_command("view_filter = complete,complete");
+    control->variable()->process_command("view_filter_on = complete,hash_done,finished");
     control->variable()->process_command("view_sort_new = complete,state_changed");
     control->variable()->process_command("view_sort_current = complete,state_changed_reverse");
 
     control->variable()->process_command("view_add = incomplete");
     control->variable()->process_command("view_filter = incomplete,incomplete");
+    control->variable()->process_command("view_filter_on = incomplete,hash_done,finished");
     control->variable()->process_command("view_sort_new = incomplete,state_changed");
     control->variable()->process_command("view_sort_current = incomplete,state_changed_reverse");
 
+    control->variable()->process_command("view_add = hashing");
+    control->variable()->process_command("view_filter = hashing,hashing");
+    control->variable()->process_command("view_filter_on = hashing,hash_queued,hash_removed,hash_done");
+    control->variable()->process_command("view_sort_new = hashing,state_changed");
+    control->variable()->process_command("view_sort_current = hashing,state_changed");
+
     control->variable()->process_command("schedule = view_main,10,10,view_sort=main,20");
     control->variable()->process_command("schedule = view_name,10,10,view_sort=name,20");
-    control->variable()->process_command("schedule = view_started,10,10,view_sort=started,5");
-    control->variable()->process_command("schedule = view_stopped,10,10,view_sort=stopped,5");
-    control->variable()->process_command("schedule = view_complete,10,10,view_sort=complete,5");
-    control->variable()->process_command("schedule = view_incomplete,10,10,view_sort=incomplete,5");
+//     control->variable()->process_command("schedule = view_started,10,10,view_sort=started,5");
+//     control->variable()->process_command("schedule = view_stopped,10,10,view_sort=stopped,5");
+//     control->variable()->process_command("schedule = view_complete,10,10,view_sort=complete,5");
+//     control->variable()->process_command("schedule = view_incomplete,10,10,view_sort=incomplete,5");
 
     //control->variable()->process_command("schedule = scheduler,10,10,download_scheduler=");
     control->variable()->process_command("schedule = session_save,1800,1800,session_save=");
 
     // Changing these will bork the (non-existant) scheduler.
     control->variable()->process_command("view_add = scheduler");
     control->variable()->process_command("view_sort_new = scheduler,state_changed"); // add started?
     control->variable()->process_command("view_sort_current = scheduler,state_changed");
 
     //    control->variable()->process_command("schedule = scheduler,10,10,download_scheduler=");
 
-    control->variable()->process_command("try_import = ~/.rtorrent.rc");
+    if (OptionParser::has_flag('n', argc, argv))
+      control->core()->push_log("Ignoring ~/.rtorrent.rc.");
+    else
+      control->variable()->process_command("try_import = ~/.rtorrent.rc");
 
     int firstArg = parse_options(control, argc, argv);
 
     control->initialize();
 
     // Load session torrents and perform scheduled tasks to ensure
@@ -292,12 +306,13 @@
   std::cout << std::endl;
   std::cout << "All value pairs (f.ex rate and queue size) will be in the UP/DOWN" << std::endl;
   std::cout << "order. Use the up/down/left/right arrow keys to move between screens." << std::endl;
   std::cout << std::endl;
   std::cout << "Usage: rtorrent [OPTIONS]... [FILE]... [URL]..." << std::endl;
   std::cout << "  -h                Display this very helpful text" << std::endl;
+  std::cout << "  -n                Don't try to load ~/.rtorrent.rc on startup" << std::endl;
   std::cout << "  -b <a.b.c.d>      Bind the listening socket to this IP" << std::endl;
   std::cout << "  -i <a.b.c.d>      Change the IP that is sent to the tracker" << std::endl;
   std::cout << "  -p <int>-<int>    Set port range for incoming connections" << std::endl;
   std::cout << "  -d <directory>    Save torrents to this directory by default" << std::endl;
   std::cout << "  -s <directory>    Set the session directory" << std::endl;
   std::cout << "  -o key=opt,...    Set options, see 'rtorrent.rc' file" << std::endl;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_handler_rules.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/option_handler_rules.cc	2006-05-11 21:32:39.000000000 +0800
@@ -114,12 +114,31 @@
 
     ++itr;
   }
 }
 
 void
+apply_close_untied(Control* m) {
+  core::Manager::DListItr itr = m->core()->download_list()->begin();
+
+  while ((itr = std::find_if(itr, m->core()->download_list()->end(),
+			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
+				     std::not1(std::mem_fun_ref(&std::string::empty)))))
+	 != m->core()->download_list()->end()) {
+    rak::file_stat fs;
+
+    if (!fs.update(rak::path_expand((*itr)->variable_string("tied_to_file")))) {
+      (*itr)->variable()->set("tied_to_file", std::string());
+      m->core()->download_list()->close(*itr);
+    }
+
+    ++itr;
+  }
+}
+
+void
 apply_remove_untied(Control* m) {
   core::Manager::DListItr itr = m->core()->download_list()->begin();
 
   while ((itr = std::find_if(itr, m->core()->download_list()->end(),
 			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
 				     std::not1(std::mem_fun_ref(&std::string::empty)))))
@@ -203,12 +222,33 @@
   }
 
   control->view_manager()->set_filter(name, filterArgs);
 }
 
 void
+apply_view_filter_on(Control* control, const std::string& arg) {
+  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+
+  std::string name = rak::trim(*itr);
+  
+  if (name.empty())
+    throw torrent::input_error("First argument must be a string.");
+
+  core::ViewManager::filter_args filterArgs;
+
+  while (++itr != rak::split_iterator(arg)) {
+    filterArgs.push_back(rak::trim(*itr));
+
+    if (filterArgs.back().empty())
+      throw torrent::input_error("One of the arguments is empty.");
+  }
+
+  control->view_manager()->set_filter_on(name, filterArgs);
+}
+
+void
 apply_view_sort(Control* control, const std::string& arg) {
   rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
 
   std::string name = rak::trim(*itr);
   ++itr;
 
@@ -332,12 +372,13 @@
   variables->insert("print",                 new utils::VariableStringSlot(rak::value_fn(std::string()), rak::mem_fn(control->core(), &core::Manager::push_log)));
   variables->insert("import",                new utils::VariableStringSlot(rak::value_fn(std::string()), rak::ptr_fn(&apply_import)));
   variables->insert("try_import",            new utils::VariableStringSlot(rak::value_fn(std::string()), rak::ptr_fn(&apply_try_import)));
 
   variables->insert("view_add",              new utils::VariableStringSlot(rak::value_fn(std::string()), rak::mem_fn(c->view_manager(), &core::ViewManager::insert_throw)));
   variables->insert("view_filter",           new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_filter, c)));
+  variables->insert("view_filter_on",        new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_filter_on, c)));
 
   variables->insert("view_sort",             new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_sort, c)));
   variables->insert("view_sort_new",         new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_sort_new, c)));
   variables->insert("view_sort_current",     new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_view_sort_current, c)));
 
   variables->insert("schedule",              new utils::VariableStringSlot(rak::value_fn(std::string()), rak::mem_fn(c->command_scheduler(), &CommandScheduler::parse)));
@@ -361,11 +402,12 @@
   variables->insert("working_directory",     new utils::VariableStringSlot(rak::mem_fn(control, &Control::working_directory),
 									   rak::mem_fn(control, &Control::set_working_directory)));
 
   variables->insert("load",                  new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_load, c)));
   variables->insert("load_start",            new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_load_start, c)));
   variables->insert("stop_untied",           new utils::VariableVoidSlot(rak::bind_ptr_fn(&apply_stop_untied, c)));
+  variables->insert("close_untied",          new utils::VariableVoidSlot(rak::bind_ptr_fn(&apply_close_untied, c)));
   variables->insert("remove_untied",         new utils::VariableVoidSlot(rak::bind_ptr_fn(&apply_remove_untied, c)));
 
   variables->insert("enable_trackers",       new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_enable_trackers, c)));
   variables->insert("encoding_list",         new utils::VariableStringSlot(rak::value_fn(std::string()), rak::bind_ptr_fn(&apply_encoding_list, c)));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_parser.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/option_parser.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_parser.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/option_parser.cc	2006-05-10 03:50:25.000000000 +0800
@@ -71,23 +71,39 @@
 
 int
 OptionParser::process(int argc, char** argv) {
   int c;
   std::string optString = create_optstring();
 
+  optind = 0;
   opterr = 0;
 
   while ((c = getopt(argc, argv, optString.c_str())) != -1)
     if (c == '?')
       throw std::runtime_error("Invalid/unknown option flag \"-" + std::string(1, (char)optopt) + "\". See rtorrent -h for more information.");
     else
       call(c, optarg ? optarg : "");
 
   return optind;
 }
 
+bool
+OptionParser::has_flag(char flag, int argc, char** argv) {
+  int result;
+  char options[2] = { flag, '\0' };
+
+  optind = 0;
+  opterr = 0;
+
+  while ((result = getopt(argc, argv, options)) != -1)
+    if (result == flag)
+      return true;
+
+  return false;
+}
+
 std::string
 OptionParser::create_optstring() {
   std::string s;
 
   for (Container::iterator itr = m_container.begin(); itr != m_container.end(); ++itr) {
     s += itr->first;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_parser.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/option_parser.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/option_parser.h	2006-05-02 00:29:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/option_parser.h	2006-05-10 03:32:42.000000000 +0800
@@ -58,12 +58,14 @@
   void                insert_option_list(char c, SlotStringPair s);
   void                insert_int_pair(char c, SlotIntPair s);
 
   // Returns the index of the first non-option argument.
   int                 process(int argc, char** argv);
 
+  static bool         has_flag(char flag, int argc, char** argv);
+
 private:
   std::string         create_optstring();
 
   void                call(char c, const std::string& arg);
   static void         call_option_list(SlotStringPair slot, const std::string& arg);
   static void         call_int_pair(SlotIntPair slot, const std::string& arg);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/download_list.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/ui/download_list.cc	2006-05-13 08:00:06.000000000 +0800
@@ -87,13 +87,13 @@
   m_uiArray[DISPLAY_LOG]           = new ElementLogComplete(&m_control->core()->get_log_complete());
   m_windowLog                      = new WLog(&m_control->core()->get_log_important());
 
   receive_change_view("main");
 
   if (m_view == NULL)
-    throw torrent::internal_error("View \"main\" must be present to initialize the main display.");
+    throw torrent::client_error("View \"main\" must be present to initialize the main display.");
 
   m_taskUpdate.set_slot(rak::mem_fn(this, &DownloadList::task_update)),
 
   setup_keys();
   setup_input();
 }
@@ -194,44 +194,44 @@
   m_view->prev_focus();
   m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_start_download() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
   m_control->core()->download_list()->start(*m_view->focus());
   m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_stop_download() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
-  if ((*m_view->focus())->download()->is_active())
+  if ((*m_view->focus())->variable()->get_value("state") == 1)
     m_control->core()->download_list()->stop(*m_view->focus());
   else
     m_control->core()->download_list()->erase(*m_view->focus());
 
   m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_close_download() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
   m_control->core()->download_list()->close(*m_view->focus());
   m_view->set_last_changed();
 }
 
 void
 DownloadList::receive_view_download() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
   if (m_uiDownload != NULL)
     throw std::logic_error("DownloadList::receive_view_download() called but m_uiDownload != NULL");
 
   disable();
@@ -256,29 +256,29 @@
 
   m_control->display()->adjust_layout();
 }
 
 void
 DownloadList::receive_next_priority() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
   (*m_view->focus())->set_priority(((*m_view->focus())->priority() + 1) % 4);
 }
 
 void
 DownloadList::receive_prev_priority() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
   (*m_view->focus())->set_priority(((*m_view->focus())->priority() - 1) % 4);
 }
 
 void
 DownloadList::receive_check_hash() {
-  if (m_view->focus() == m_view->end())
+  if (m_view->focus() == m_view->end_visible())
     return;
 
   // Catch here?
   m_control->core()->download_list()->check_hash(*m_view->focus());
 }
 
@@ -323,13 +323,13 @@
     case INPUT_LOAD_DEFAULT:
     case INPUT_LOAD_MODIFIED:
       m_control->core()->try_create_download_expand(m_windowTextInput->get_input()->str(), type == INPUT_LOAD_DEFAULT);
       break;
 
     case INPUT_CHANGE_DIRECTORY:
-      if (m_view->focus() == m_view->end())
+      if (m_view->focus() == m_view->end_visible())
 	throw torrent::input_error("No download in focus to change root directory.");
 
       (*m_view->focus())->variable()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
       m_control->core()->push_log("New root dir \"" + (*m_view->focus())->variable()->get_string("directory") + "\" for torrent.");
       break;
 
@@ -364,13 +364,13 @@
   disable_display();
   activate_display(d);
 }
 
 void
 DownloadList::receive_download_erased(core::Download* d) {
-  if (m_view->focus() == m_view->end() || *m_view->focus() != d)
+  if (m_view->focus() == m_view->end_visible() || *m_view->focus() != d)
     return;
 
   if (m_uiDownload != NULL)
     receive_exit_download();
 
   receive_next();
@@ -388,13 +388,13 @@
   m_view = *itr;
   m_view->sort();
 
   ElementDownloadList* ui = dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST]);
 
   if (ui == NULL)
-    throw torrent::internal_error("DownloadList::receive_change_view(...) could not cast ui.");
+    throw torrent::client_error("DownloadList::receive_change_view(...) could not cast ui.");
 
   ui->set_view(m_view);
 }
 
 void
 DownloadList::task_update() {
@@ -427,12 +427,13 @@
   (*m_bindings)['1']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "main");
   (*m_bindings)['2']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "name");
   (*m_bindings)['3']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "started");
   (*m_bindings)['4']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "stopped");
   (*m_bindings)['5']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "complete");
   (*m_bindings)['6']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "incomplete");
+  (*m_bindings)['7']           = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change_view), "hashing");
 
   m_uiArray[DISPLAY_LOG]->get_bindings()[' '] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_change), DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::setup_input() {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/ui/element_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_file_list.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/ui/element_file_list.cc	2006-05-13 07:57:50.000000000 +0800
@@ -58,45 +58,45 @@
   m_bindings[KEY_UP] = sigc::mem_fun(*this, &ElementFileList::receive_prev);
 }
 
 void
 ElementFileList::activate(Control* c, MItr mItr) {
   if (m_window != NULL)
-    throw torrent::internal_error("ui::ElementFileList::activate(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementFileList::activate(...) called on an object in the wrong state");
 
   c->input()->push_front(&m_bindings);
 
   *mItr = m_window = new WFileList(m_download, &m_focus);
 }
 
 void
 ElementFileList::disable(Control* c) {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementFileList::disable(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementFileList::disable(...) called on an object in the wrong state");
 
   c->input()->erase(&m_bindings);
 
   delete m_window;
   m_window = NULL;
 }
 
 void
 ElementFileList::receive_next() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementFileList::receive_next(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementFileList::receive_next(...) called on a disabled object");
 
   if (++m_focus >= m_download->download()->file_list().size())
     m_focus = 0;
 
   m_window->mark_dirty();
 }
 
 void
 ElementFileList::receive_prev() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
 
   torrent::FileList fl = m_download->download()->file_list();
 
   if (fl.size() == 0)
     return;
 
@@ -108,13 +108,13 @@
   m_window->mark_dirty();
 }
 
 void
 ElementFileList::receive_priority() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
 
   torrent::FileList fl = m_download->download()->file_list();
 
   if (m_focus >= fl.size())
     return;
 
@@ -126,13 +126,13 @@
   m_window->mark_dirty();
 }
 
 void
 ElementFileList::receive_change_all() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
 
   torrent::FileList fl = m_download->download()->file_list();
 
   if (m_focus >= fl.size())
     return;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/ui/element_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/ui/element_tracker_list.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/ui/element_tracker_list.cc	2006-05-13 07:57:50.000000000 +0800
@@ -59,34 +59,34 @@
   m_bindings['*']      = sigc::mem_fun(*this, &ElementTrackerList::receive_disable);
 }
 
 void
 ElementTrackerList::activate(Control* c, MItr mItr) {
   if (m_window != NULL)
-    throw torrent::internal_error("ui::ElementTrackerList::activate(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementTrackerList::activate(...) called on an object in the wrong state");
 
   c->input()->push_front(&m_bindings);
 
   *mItr = m_window = new WTrackerList(m_download, &m_focus);
 }
 
 void
 ElementTrackerList::disable(Control* c) {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementTrackerList::disable(...) called on an object in the wrong state");
+    throw torrent::client_error("ui::ElementTrackerList::disable(...) called on an object in the wrong state");
 
   c->input()->erase(&m_bindings);
 
   delete m_window;
   m_window = NULL;
 }
 
 void
 ElementTrackerList::receive_disable() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementTrackerList::receive_disable(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementTrackerList::receive_disable(...) called on a disabled object");
 
   torrent::Tracker t = m_download->download()->tracker_list().get(m_focus);
 
   if (t.is_enabled())
     t.disable();
   else
@@ -95,24 +95,24 @@
   m_window->mark_dirty();
 }
 
 void
 ElementTrackerList::receive_next() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementTrackerList::receive_next(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementTrackerList::receive_next(...) called on a disabled object");
 
   if (++m_focus >= m_download->download()->tracker_list().size())
     m_focus = 0;
 
   m_window->mark_dirty();
 }
 
 void
 ElementTrackerList::receive_prev() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementTrackerList::receive_prev(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementTrackerList::receive_prev(...) called on a disabled object");
 
   if (m_download->download()->tracker_list().size() == 0)
     return;
 
   if (m_focus != 0)
     --m_focus;
@@ -122,18 +122,18 @@
   m_window->mark_dirty();
 }
 
 void
 ElementTrackerList::receive_cycle_group() {
   if (m_window == NULL)
-    throw torrent::internal_error("ui::ElementTrackerList::receive_group_cycle(...) called on a disabled object");
+    throw torrent::client_error("ui::ElementTrackerList::receive_group_cycle(...) called on a disabled object");
 
   torrent::TrackerList tl = m_download->download()->tracker_list();
 
   if (m_focus >= tl.size())
-    throw torrent::internal_error("ui::ElementTrackerList::receive_group_cycle(...) called with an invalid focus");
+    throw torrent::client_error("ui::ElementTrackerList::receive_group_cycle(...) called with an invalid focus");
 
   tl.cycle_group(tl.get(m_focus).group());
 
   m_window->mark_dirty();
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/utils/variable_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.1/src/utils/variable_map.cc	2006-05-02 00:30:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.2/src/utils/variable_map.cc	2006-05-13 07:57:50.000000000 +0800
@@ -56,13 +56,13 @@
 
 void
 VariableMap::insert(const std::string& key, Variable* v) {
   iterator itr = base_type::find(key);
 
   if (itr != base_type::end())
-    throw torrent::internal_error("VariableMap::insert(...) tried to insert an already existing key.");
+    throw torrent::client_error("VariableMap::insert(...) tried to insert an already existing key.");
 
   base_type::insert(itr, value_type(key, v));
 }
 
 const VariableMap::mapped_type&
 VariableMap::get(const std::string& key) const {
