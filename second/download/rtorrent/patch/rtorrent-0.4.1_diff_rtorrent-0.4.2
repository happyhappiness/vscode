diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/configure	2005-12-05 03:54:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/configure	2006-01-04 05:03:16.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.4.1.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.4.2.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -266,14 +266,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.4.1'
-PACKAGE_STRING='rtorrent 0.4.1'
+PACKAGE_VERSION='0.4.2'
+PACKAGE_STRING='rtorrent 0.4.2'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM mkdir_p AWK SET_MAKE am__leading_dot AMTAR am__tar am__untar CXX CXXFLAGS LDFLAGS CPPFLAGS ac_ct_CXX EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CXXDEPMODE am__fastdepCXX_TRUE am__fastdepCXX_FALSE RANLIB ac_ct_RANLIB CC CFLAGS ac_ct_CC CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE PKG_CONFIG STUFF_CFLAGS STUFF_LIBS LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -743,13 +743,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.4.1 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.4.2 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -805,13 +805,13 @@
   --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.4.1:";;
+     short | recursive ) echo "Configuration of rtorrent 0.4.2:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -933,13 +933,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.4.1
+rtorrent configure 0.4.2
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -947,13 +947,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.4.1, which was
+It was created by rtorrent $as_me 0.4.2, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1591,13 +1591,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.4.1'
+ VERSION='0.4.2'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -4652,13 +4652,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.4.1, which was
+This file was extended by rtorrent $as_me 0.4.2, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -4715,13 +4715,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.4.1
+rtorrent config.status 0.4.2
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/configure.ac	2005-12-03 08:00:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/configure.ac	2006-01-04 05:01:27.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.4.1, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.4.2, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 sinclude(scripts/checks.m4)
 sinclude(scripts/common.m4)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/doc/rtorrent.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/doc/rtorrent.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/doc/rtorrent.1	2005-12-20 08:54:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/doc/rtorrent.1	2006-01-09 23:34:59.000000000 +0800
@@ -1,12 +1,12 @@
 .\" This manpage has been automatically generated by docbook2man 
 .\" from a DocBook document.  This tool can be found at:
 .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
 .\" Please send any bug reports, improvements, comments, patches, 
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
-.TH "RTORRENT" "1" "20 December 2005" "BitTorrent client for ncurses" ""
+.TH "RTORRENT" "1" "09 January 2006" "BitTorrent client for ncurses" ""
 
 .SH NAME
 rtorrent \- a BitTorrent client for ncurses
 .SH SYNOPSIS
 
 \fBrtorrent\fR [ \fB-h\fR ] [ \fB-o key1=opt1,...\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
@@ -176,18 +176,34 @@
 are attempted in the order they are inserted, if none match
 the torrent default is used.
 .TP
 \fBschedule = \fIid\fB,\fIstart\fB,\fIinterval\fB,\fIcommand\fB\fR
 Call \fBcommand\fR every \fBinterval\fR
 seconds, starting from \fBstart\fR\&. An
-\fBinterval\fR of zero stops the task, while a
+\fBinterval\fR of zero calls the task once, while a
 \fBstart\fR of zero calls it immediately. Currently
 \fBcommand\fR is forwarded to the option handler.
 .TP
 \fBschedule_remove = \fIid\fB\fR
 Delete \fBid\fR from the scheduler.
+.TP
+\fBload = \fIfile\fB\fR
+.TP
+\fBload_start = \fIfile\fB\fR
+Load and possibly start a file, or possibly mutiple files by using the
+wildcard "*". This is meant for use with
+\fBschedule\fR, though ensure that the
+\fBstart\fR is non-zero. The loaded file will be tied
+to the filename provided.
+.TP
+\fBstop_untied =\fR
+.TP
+\fBremove_untied =\fR
+Stop or remove the torrents that are tied to filenames that has been
+deleted, the association is then cleared. Don't use
+\fBremove_untied\fR as it crashes the client.
 .SH "ADVANCED SETTINGS"
 .PP
 This list contains settings users shouldn't need to touch.
 .TP
 \fBhash_read_ahead = \fIMB\fB\fR
 Configure how far ahead we ask the kernel to read when doing
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/doc/rtorrent.1.xml	2005-12-20 09:01:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/doc/rtorrent.1.xml	2006-01-07 05:07:29.000000000 +0800
@@ -433,12 +433,38 @@
 
           Delete <emphasis>id</emphasis> from the scheduler.
 
         </para></listitem>
       </varlistentry>
 
+      <varlistentry>
+        <term>load = <replaceable>file</replaceable></term>
+        <term>load_start = <replaceable>file</replaceable></term>
+        <listitem><para>
+
+Load and possibly start a file, or possibly mutiple files by using the
+wildcard "*". This is meant for use with
+<emphasis>schedule</emphasis>, though ensure that the
+<emphasis>start</emphasis> is non-zero. The loaded file will be tied
+to the filename provided.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>stop_untied =</term>
+        <term>remove_untied =</term>
+        <listitem><para>
+
+Stop or remove the torrents that are tied to filenames that has been
+deleted, the association is then cleared. Don't use
+<emphasis>remove_untied</emphasis> as it crashes the client.
+
+        </para></listitem>
+      </varlistentry>
+
     </variablelist>
 
   </refsect1>
 
 
   <refsect1>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/doc/rtorrent.rc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/doc/rtorrent.rc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/doc/rtorrent.rc	2005-12-20 10:03:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/doc/rtorrent.rc	2006-01-07 05:07:29.000000000 +0800
@@ -1,34 +1,34 @@
 # This is an example resource file for rTorrent. Copy to
 # ~/.rtorrent.rc and enable/modify the options as needed. Remember to
 # uncomment the options you wish to enable.
 
-# Minumum amount of peers to connect per torrent, if available.
+# Maximum and minimum number of peers to connect to per torrent.
 #min_peers = 40
-
-# Minumum amount of peers to connect per torrent.
 #max_peers = 100
 
 # Maximum number of simultanious uploads per torrent.
 #max_uploads = 15
 
-# Global download rate in KiB. "0" for unlimited.
+# Global upload and download rate in KiB. "0" for unlimited.
 #download_rate = 0
-
-# Global upload rate in KiB. "0" for unlimited.
 #upload_rate = 0
 
-# Default directory to save downloaded files. Note it doesn't support
-# space yet.
+# Default directory to save the downloaded torrents.
 #directory = ./
 
 # Default session directory. Make sure you don't run multiple instance
 # of rtorrent using the same session directory. Perhaps using a
 # relative path?
 #session = ./session
 
+# Watch a directory for new torrents, and stop those that have been
+# deleted.
+#schedule = watch_directory,5,5,load_start=./watch/*.torrent
+#schedule = untied_directory,5,5,stop_untied=
+
 # The ip address reported to the tracker.
 #ip = rakshasa
 
 # The ip address the listening socket and outgoing connections is
 # bound to.
 #bind = rakshasa
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/Makefile.am	2005-12-09 00:25:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/Makefile.am	2006-01-10 03:32:31.000000000 +0800
@@ -3,15 +3,17 @@
 	src
 
 EXTRA_DIST= \
 	autogen.sh \
 	rak/algorithm.h \
 	rak/error_number.h \
+	rak/file_stat.h \
 	rak/functional.h \
 	rak/functional_fun.h \
 	rak/priority_queue.h \
 	rak/priority_queue_default.h \
+	rak/regex.h \
 	rak/string_manip.h \
 	rak/timer.h \
 	rak/unordered_vector.h \
 	scripts/checks.m4 \
 	scripts/common.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/Makefile.in	2005-12-16 10:53:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/Makefile.in	2006-01-10 03:32:54.000000000 +0800
@@ -158,16 +158,18 @@
 	src
 
 EXTRA_DIST = \
 	autogen.sh \
 	rak/algorithm.h \
 	rak/error_number.h \
+	rak/file_stat.h \
 	rak/functional.h \
 	rak/functional_fun.h \
 	rak/priority_queue.h \
 	rak/priority_queue_default.h \
+	rak/regex.h \
 	rak/string_manip.h \
 	rak/timer.h \
 	rak/unordered_vector.h \
 	scripts/checks.m4 \
 	scripts/common.m4
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/rak: file_stat.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/rak/priority_queue_default.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/rak/priority_queue_default.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/rak/priority_queue_default.h	2005-12-17 10:18:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/rak/priority_queue_default.h	2006-01-04 05:01:27.000000000 +0800
@@ -83,12 +83,23 @@
 };
 
 typedef std::equal_to<priority_item*> priority_equal;
 typedef priority_queue<priority_item*, priority_compare, priority_equal> priority_queue_default;
 
 inline void
+priority_queue_perform(priority_queue_default* queue, timer t) {
+  while (!queue->empty() && queue->top()->time() <= t) {
+    priority_item* v = queue->top();
+    queue->pop();
+
+    v->clear_time();
+    v->call();
+  }
+}
+
+inline void
 priority_queue_insert(priority_queue_default* queue, priority_item* item, timer t) {
   if (t == timer())
     throw std::logic_error("priority_queue_insert(...) received a bad timer.");
 
   if (!item->is_valid())
     throw std::logic_error("priority_queue_insert(...) called on an invalid item.");
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/rak: regex.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/rak/string_manip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/rak/string_manip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/rak/string_manip.h	2005-11-12 23:31:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/rak/string_manip.h	2006-01-07 05:07:30.000000000 +0800
@@ -34,13 +34,17 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RAK_STRING_MANIP_H
 #define RAK_STRING_MANIP_H
 
+#include <algorithm>
 #include <cctype>
+#include <cstdlib>
+#include <iterator>
+#include <locale>
 
 namespace rak {
 
 // Use these trim functions until n1872 is widely supported.
 
 template <typename Sequence>
@@ -71,9 +75,137 @@
 
 template <typename Sequence>
 Sequence trim(const Sequence& seq) {
   return trim_begin(trim_end(seq));
 }
 
+// Consider rewritting such that m_seq is replaced by first/last.
+template <typename Sequence>
+class split_iterator_t {
+public:
+  typedef typename Sequence::const_iterator const_iterator;
+  typedef typename Sequence::value_type     value_type;
+
+  split_iterator_t() {}
+
+  split_iterator_t(const Sequence& seq, value_type delim) :
+    m_seq(&seq),
+    m_delim(delim),
+    m_pos(seq.begin()),
+    m_next(std::find(seq.begin(), seq.end(), delim)) {
+  }
+
+  Sequence operator * () { return Sequence(m_pos, m_next); }
+
+  split_iterator_t& operator ++ () {
+    m_pos = m_next;
+
+    if (m_pos == m_seq->end())
+      return *this;
+
+    m_pos++;
+    m_next = std::find(m_pos, m_seq->end(), m_delim);
+
+    return *this;
+  }
+
+  bool operator == (const split_iterator_t& itr) const { return m_pos == m_seq->end(); }
+  bool operator != (const split_iterator_t& itr) const { return m_pos != m_seq->end(); }
+
+private:
+  const Sequence* m_seq;
+  value_type      m_delim;
+  const_iterator  m_pos;
+  const_iterator  m_next;
+};
+
+template <typename Sequence>
+inline split_iterator_t<Sequence>
+split_iterator(const Sequence& seq, typename Sequence::value_type delim) {
+  return split_iterator_t<Sequence>(seq, delim);
+}
+
+template <typename Sequence>
+inline split_iterator_t<Sequence>
+split_iterator(const Sequence& seq) {
+  return split_iterator_t<Sequence>();
+}
+
+template <int pos, typename Value>
+inline char
+value_to_hexchar(Value v) {
+  v >>= pos * 4;
+  v &= 0xf;
+
+  if (v < 0xA)
+    return '0' + v;
+  else
+    return 'A' + v - 0xA;
+}
+
+template <typename InputIterator, typename OutputIterator> 
+OutputIterator
+copy_escape_html(InputIterator first, InputIterator last, OutputIterator dest) {
+  while (first != last) {
+    if (std::isalpha(*first) ||
+	std::isdigit(*first) ||
+	*first == '-') {
+      *(dest++) = *first;
+
+    } else {
+      *(dest++) = '%';
+      *(dest++) = value_to_hexchar<1>(*first);
+      *(dest++) = value_to_hexchar<0>(*first);
+    }
+
+    ++first;
+  }
+
+  return dest;
+}
+
+template <typename Sequence>
+Sequence
+copy_escape_html(const Sequence& src) {
+  Sequence dest;
+  copy_escape_html(src.begin(), src.end(), std::back_inserter(dest));
+
+  return dest;
+}
+
+// Consider support for larger than char type.
+template <typename InputIterator, typename OutputIterator> 
+OutputIterator
+transform_hex(InputIterator first, InputIterator last, OutputIterator dest) {
+  while (first != last) {
+    *(dest++) = value_to_hexchar<1>(*first);
+    *(dest++) = value_to_hexchar<0>(*first);
+
+    ++first;
+  }
+
+  return dest;
+}
+
+template <typename Sequence>
+Sequence
+transform_hex(const Sequence& src) {
+  Sequence dest;
+  transform_hex(src.begin(), src.end(), std::back_inserter(dest));
+
+  return dest;
+}
+
+template <typename Sequence>
+Sequence
+generate_random(size_t length) {
+  Sequence s;
+  s.reserve(length);
+
+  std::generate_n(std::back_inserter(s), length, &std::rand);
+
+  return s;
+}
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/scripts/checks.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/scripts/checks.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/scripts/checks.m4	2005-11-12 23:31:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/scripts/checks.m4	2006-01-04 05:01:27.000000000 +0800
@@ -171,13 +171,13 @@
     ])
 ])
 
 
 AC_DEFUN([TORRENT_WITH_POSIX_FALLOCATE], [
   AC_ARG_WITH(posix-fallocate,
-    [  --with-fallocate        Check for posix_fallocate],
+    [  --with-posix-fallocate  Check for and use posix_fallocate to allocate files.],
     [
-      if test "$withval" = "no"; then
+      if test "$withval" = "yes"; then
         TORRENT_CHECK_POSIX_FALLOCATE
       fi
     ])
 ])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/control.cc	2005-12-17 04:11:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/control.cc	2006-01-10 01:02:51.000000000 +0800
@@ -44,52 +44,63 @@
 #include "display/manager.h"
 #include "input/manager.h"
 #include "input/input_event.h"
 #include "ui/root.h"
 
 #include "command_scheduler.h"
+#include "option_handler.h"
 
 #include "control.h"
 
 Control::Control() :
   m_shutdownReceived(false),
 
   m_ui(new ui::Root()),
   m_core(new core::Manager()),
   m_display(new display::Manager()),
   m_input(new input::Manager()),
   m_inputStdin(new input::InputEvent(STDIN_FILENO)),
 
-  m_commandScheduler(new CommandScheduler()) {
+  m_commandScheduler(new CommandScheduler()),
+  m_optionHandler(new OptionHandler()),
+
+  m_tick(0) {
 
   m_inputStdin->slot_pressed(sigc::mem_fun(m_input, &input::Manager::pressed));
 
   m_taskShutdown.set_slot(rak::mem_fn(this, &Control::receive_shutdown));
+
+  m_commandScheduler->set_slot_command(rak::mem_fn(m_optionHandler, &OptionHandler::process_command));
+  m_commandScheduler->set_slot_error_message(rak::mem_fn(m_core, &core::Manager::push_log));
 }
 
 Control::~Control() {
   delete m_inputStdin;
   delete m_input;
 
   delete m_commandScheduler;
+  delete m_optionHandler;
 
   delete m_ui;
   delete m_display;
   delete m_core;
 }
 
 void
 Control::initialize() {
   display::Canvas::initialize();
-  display::Window::slot_adjust(sigc::mem_fun(m_display, &display::Manager::adjust_layout));
+  display::Window::slot_schedule(rak::make_mem_fun(m_display, &display::Manager::schedule));
+  display::Window::slot_unschedule(rak::make_mem_fun(m_display, &display::Manager::unschedule));
+  display::Window::slot_adjust(rak::make_mem_fun(m_display, &display::Manager::adjust_layout));
 
   m_core->get_poll_manager()->signal_interrupted().connect(sigc::mem_fun(*m_inputStdin, &input::InputEvent::event_read));
   m_core->get_poll_manager()->signal_interrupted().connect(sigc::ptr_fun(display::Canvas::do_update));
   m_core->get_poll_manager()->get_http_stack()->set_user_agent(std::string(PACKAGE "/" VERSION "/") + torrent::version());
 
   m_core->initialize_second();
+  m_core->listen_open();
 
   m_ui->init(this);
 
   m_inputStdin->insert(m_core->get_poll_manager()->get_torrent_poll());
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/control.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/control.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/control.h	2005-12-17 04:10:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/control.h	2006-01-10 01:02:39.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_CONTROL_H
 #define RTORRENT_CONTROL_H
 
+#include <inttypes.h>
 #include <torrent/torrent.h>
 
 #include "globals.h"
 
 namespace ui {
   class Root;
@@ -55,12 +56,13 @@
 
 namespace input {
   class InputEvent;
   class Manager;
 }  
 
+class OptionHandler;
 class CommandScheduler;
 
 class Control {
 public:
   Control();
   ~Control();
@@ -77,12 +79,16 @@
   core::Manager*      core()                        { return m_core; }
   display::Manager*   display()                     { return m_display; }
   input::Manager*     input()                       { return m_input; }
   input::InputEvent*  input_stdin()                 { return m_inputStdin; }
 
   CommandScheduler*   command_scheduler()           { return m_commandScheduler; }
+  OptionHandler*      option_handler()              { return m_optionHandler; }
+
+  uint64_t            tick() const                  { return m_tick; }
+  void                inc_tick()                    { m_tick++; }
 
 private:
   Control(const Control&);
   void operator = (const Control&);
 
   bool                m_shutdownReceived;
@@ -91,11 +97,14 @@
   core::Manager*      m_core;
   display::Manager*   m_display;
   input::Manager*     m_input;
   input::InputEvent*  m_inputStdin;
 
   CommandScheduler*   m_commandScheduler;
+  OptionHandler*      m_optionHandler;
+
+  uint64_t            m_tick;
 
   rak::priority_item  m_taskShutdown;
 };
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download.cc	2005-12-20 06:00:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download.cc	2005-12-22 08:38:00.000000000 +0800
@@ -43,16 +43,35 @@
 #include <torrent/exceptions.h>
 
 #include "download.h"
 
 namespace core {
 
-Download::Download() :
+Download::Download(torrent::Download d) :
+  m_download(d),
+
   m_chunksFailed(0),
   m_connectionLeech(torrent::Download::CONNECTION_LEECH),
   m_connectionSeed(torrent::Download::CONNECTION_SEED) {
+
+  m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
+  m_connTrackerFailed = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
+  m_connStorageError = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
+
+  m_download.signal_chunk_failed(sigc::mem_fun(*this, &Download::receive_chunk_failed));
+}
+
+Download::~Download() {
+  if (!m_download.is_valid())
+    return;
+
+  m_connTrackerSucceded.disconnect();
+  m_connTrackerFailed.disconnect();
+  m_connStorageError.disconnect();
+
+  m_download = torrent::Download();
 }
 
 void
 Download::start() {
   if (is_done()) {
     m_download.set_connection_type(m_connectionSeed);
@@ -63,23 +82,12 @@
   }
 
   m_download.start();
 }
 
 void
-Download::set_download(torrent::Download d) {
-  m_download = d;
-
-  m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
-  m_connTrackerFailed = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
-  m_connStorageError = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
-
-  m_download.signal_chunk_failed(sigc::mem_fun(*this, &Download::receive_chunk_failed));
-}
-
-void
 Download::set_root_directory(const std::string& d) {
   m_download.set_root_dir(d +
 			  (!d.empty() && *d.rbegin() != '/' ? "/" : "") +
 			  (m_download.size_file_entries() > 1 ? m_download.name() : ""));
 }
 
@@ -91,24 +99,12 @@
 	m_download.tracker(i).enable();
       else
 	m_download.tracker(i).disable();
 }
 
 void
-Download::release_download() {
-  if (!m_download.is_valid())
-    return;
-
-  m_connTrackerSucceded.disconnect();
-  m_connTrackerFailed.disconnect();
-  m_connStorageError.disconnect();
-
-  m_download = torrent::Download();
-}
-
-void
 Download::receive_finished() {
   m_download.set_connection_type(m_connectionSeed);
   torrent::download_set_priority(m_download, 2);
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_factory.cc	2005-12-16 03:41:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_factory.cc	2006-01-04 05:01:27.000000000 +0800
@@ -37,12 +37,13 @@
 #include "config.h"
 
 #include <fstream>
 #include <sstream>
 #include <stdexcept>
 #include <torrent/bencode.h>
+#include <torrent/exceptions.h>
 
 #include "curl_get.h"
 #include "http_queue.h"
 #include "globals.h"
 #include "manager.h"
 
@@ -55,13 +56,15 @@
   m_stream(NULL),
   m_commited(false),
   m_loaded(false),
 
   m_uri(uri),
   m_session(false),
-  m_start(false) {
+  m_start(false),
+  m_printLog(true),
+  m_tiedToFile(false) {
 
   m_taskLoad.set_slot(rak::mem_fn(this, &DownloadFactory::receive_load));
   m_taskCommit.set_slot(rak::mem_fn(this, &DownloadFactory::receive_commit));
 }  
 
 DownloadFactory::~DownloadFactory() {
@@ -82,22 +85,24 @@
   priority_queue_insert(&taskScheduler, &m_taskCommit, cachedTime);
 }
 
 void
 DownloadFactory::receive_load() {
   if (m_stream)
-    throw std::logic_error("DownloadFactory::load() called on an object with m_stream != NULL");
+    throw torrent::client_error("DownloadFactory::load() called on an object with m_stream != NULL");
 
   if (std::strncmp(m_uri.c_str(), "http://", 7) == 0) {
     // Http handling here.
     m_stream = new std::stringstream;
     HttpQueue::iterator itr = m_manager->get_http_queue().insert(m_uri, m_stream);
 
     (*itr)->signal_done().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_loaded));
     (*itr)->signal_failed().slots().push_front(sigc::mem_fun(*this, &DownloadFactory::receive_failed));
 
+    m_tiedToFile = false;
+
   } else {
     m_stream = new std::fstream(m_uri.c_str(), std::ios::in);
 
     if (m_stream->good())
       receive_loaded();
     else
@@ -121,46 +126,61 @@
     receive_success();
 }
 
 void
 DownloadFactory::receive_success() {
   if (m_stream == NULL)
-    throw std::logic_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
+    throw torrent::client_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
 
-  Manager::DListItr itr = m_manager->insert(m_stream);
+  Manager::DListItr itr = m_manager->insert(m_stream, m_printLog);
 
   if (itr == m_manager->get_download_list().end()) {
     // core::Manager should already have added the error message to
     // the log.
     m_slotFinished();
     return;
   }
 
+  torrent::Bencode& bencode = (*itr)->get_bencode();
+
   if (m_session) {
-    torrent::Bencode& bencode = (*itr)->get_bencode();
-    
+    // Hmm... this safe?
     if (bencode.get_key("rtorrent").get_key("state").as_string() == "started")
-      m_manager->start(*itr);
+      m_manager->start(*itr, m_printLog);
+
+    if (bencode.get_key("rtorrent").has_key("tied") &&
+	bencode.get_key("rtorrent").get_key("tied").is_string())
+      (*itr)->set_tied_to_file(bencode.get_key("rtorrent").get_key("tied").as_string());
 
   } else {
+    // Remove the settings if this isn't a session torrent.
+    //bencode.erase_key("rtorrent");
+
+    if (m_tiedToFile) {
+      (*itr)->set_tied_to_file(m_uri);
+      bencode.get_key("rtorrent").insert_key("tied", m_uri);
+    }
+
     if (m_start)
-      m_manager->start(*itr);
+      m_manager->start(*itr, m_printLog);
 
     m_manager->get_download_store().save(*itr);
   }
 
   m_slotFinished();
 }
 
 void
 DownloadFactory::receive_failed(const std::string& msg) {
   if (m_stream == NULL)
-    throw std::logic_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
+    throw torrent::client_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
 
   // Add message to log.
-  m_manager->get_log_important().push_front(msg + ": \"" + m_uri + "\"");
-  m_manager->get_log_complete().push_front(msg + ": \"" + m_uri + "\"");
+  if (m_printLog) {
+    m_manager->get_log_important().push_front(msg + ": \"" + m_uri + "\"");
+    m_manager->get_log_complete().push_front(msg + ": \"" + m_uri + "\"");
+  }
 
   m_slotFinished();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_factory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_factory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_factory.h	2005-12-09 01:14:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_factory.h	2006-01-04 05:01:27.000000000 +0800
@@ -31,12 +31,16 @@
 //
 // Contact:  Jari Sundell <jaris@ifi.uio.no>
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
+// The DownloadFactory class assures that loading torrents can be done
+// anywhere in the code by queueing the task. The user may change
+// settings while, or even after, the torrent is loading.
+
 #ifndef RTORRENT_CORE_DOWNLOAD_FACTORY_H
 #define RTORRENT_CORE_DOWNLOAD_FACTORY_H
 
 #include <iosfwd>
 #include <sigc++/slot.h>
 #include <rak/priority_queue_default.h>
@@ -64,12 +68,18 @@
   bool                get_session() const   { return m_session; }
   void                set_session(bool v)   { m_session = v; }
 
   bool                get_start() const     { return m_start; }
   void                set_start(bool v)     { m_start = v; }
 
+  bool                print_log() const        { return m_printLog; }
+  void                set_print_log(bool v)    { m_printLog = v; }
+
+  bool                tied_to_file() const     { return m_tiedToFile; }
+  void                set_tied_to_file(bool v) { m_tiedToFile = v; }
+
   void                slot_finished(Slot s) { m_slotFinished = s; }
 
 private:
   void                receive_load();
   void                receive_loaded();
   void                receive_commit();
@@ -82,12 +92,14 @@
   bool                m_commited;
   bool                m_loaded;
 
   std::string         m_uri;
   bool                m_session;
   bool                m_start;
+  bool                m_printLog;
+  bool                m_tiedToFile;
 
   Slot                m_slotFinished;
   rak::priority_item  m_taskLoad;
   rak::priority_item  m_taskCommit;
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download.h	2005-12-20 05:58:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download.h	2006-01-04 05:01:27.000000000 +0800
@@ -44,23 +44,20 @@
 namespace core {
 
 class Download {
 public:
   typedef torrent::Download::ConnectionType ConnType;
 
-  Download();
-  ~Download() { release_download(); }
+  Download(torrent::Download d);
+  ~Download();
 
   bool               is_open()                       { return m_download.is_open(); }
   inline bool        is_done();
 
   void               start();
 
-  void               set_download(torrent::Download d);
-  void               release_download();
-
   torrent::Download& get_download()                  { return m_download; }
   const torrent::Download& get_download() const      { return m_download; }
   std::string        get_hash()                      { return m_download.info_hash(); }
   torrent::Bencode&  get_bencode()                   { return m_download.bencode(); }
   
   const std::string& get_message()                   { return m_message; }
@@ -73,12 +70,15 @@
   ConnType           get_connection_leech() const                  { return m_connectionLeech; }
   ConnType           get_connection_seed() const                   { return m_connectionSeed; }
 
   void               set_connection_leech(const std::string& name) { m_connectionLeech = string_to_connection_type(name); }
   void               set_connection_seed(const std::string& name)  { m_connectionSeed = string_to_connection_type(name); }
 
+  const std::string& tied_to_file() const                          { return m_tiedToFile; }
+  void               set_tied_to_file(const std::string& str)      { m_tiedToFile = str; }
+
   void               enable_udp_trackers(bool state);
 
   // Helper functions for calling functions in torrent::Download
   // through sigc++.
   template <typename Ret, Ret (torrent::Download::*func)()>
   void               call()                                                { (m_download.*func)(); }
@@ -104,12 +104,14 @@
   std::string        m_message;
   uint32_t           m_chunksFailed;
 
   ConnType           m_connectionLeech;
   ConnType           m_connectionSeed;
 
+  std::string        m_tiedToFile;
+
   sigc::connection   m_connTrackerSucceded;
   sigc::connection   m_connTrackerFailed;
   sigc::connection   m_connStorageError;
 };
 
 inline bool
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_list.cc	2005-11-12 23:31:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_list.cc	2005-12-22 08:38:00.000000000 +0800
@@ -48,27 +48,25 @@
 namespace core {
 
 DownloadList::iterator
 DownloadList::insert(std::istream* str) {
   torrent::Download d = torrent::download_add(str);
 
-  iterator itr = Base::insert(end(), new Download);
-  (*itr)->set_download(d);
+  iterator itr = Base::insert(end(), new Download(d));
   (*itr)->get_download().signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::finished), *itr));
 
   m_slotMapInsert.for_each(*itr);
 
   return itr;
 }
 
 DownloadList::iterator
 DownloadList::erase(iterator itr) {
   m_slotMapErase.for_each(*itr);
 
   torrent::download_remove((*itr)->get_download());
-  (*itr)->release_download();
   delete *itr;
 
   return Base::erase(itr);
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/download_store.cc	2005-11-12 23:31:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/download_store.cc	2006-01-07 05:07:29.000000000 +0800
@@ -31,22 +31,24 @@
 //
 // Contact:  Jari Sundell <jaris@ifi.uio.no>
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
+// DownloadStore handles the saving and listing of session torrents.
+
 #include "config.h"
 
 #include <fstream>
-#include <stdexcept>
+#include <stdio.h>
 #include <unistd.h>
+#include <rak/string_manip.h>
 #include <torrent/bencode.h>
+#include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 
-#include "utils/parse.h"
-
 #include "download.h"
 #include "download_store.h"
 
 namespace core {
 
 void
@@ -59,40 +61,44 @@
 
 void
 DownloadStore::save(Download* d) {
   if (!is_active())
     return;
 
-  std::fstream f(create_filename(d).c_str(), std::ios::out | std::ios::trunc);
+  std::fstream f((create_filename(d) + ".new").c_str(), std::ios::out | std::ios::trunc);
 
   if (!f.is_open())
-    throw std::runtime_error("core::DownloadStore::save(...) could not open file");
+    return;
 
   f << d->get_bencode();
 
   if (f.fail())
-    throw std::runtime_error("core::DownloadStore::save(...) could not write torrent");
+    return;
+
+  f.close();
+
+  ::rename((create_filename(d) + ".new").c_str(), create_filename(d).c_str());
 }
 
 void
 DownloadStore::remove(Download* d) {
   if (!is_active())
     return;
 
-  unlink(create_filename(d).c_str());
+  ::unlink(create_filename(d).c_str());
 }
 
 utils::Directory
 DownloadStore::get_formated_entries() {
   if (!is_active())
     return utils::Directory();
 
   utils::Directory d(m_path);
 
   if (!d.update())
-    throw std::runtime_error("core::DownloadStore::update() could not open directory \"" + m_path + "\"");
+    throw torrent::storage_error("core::DownloadStore::update() could not open directory \"" + m_path + "\"");
 
   d.erase(std::remove_if(d.begin(), d.end(), std::not1(std::ptr_fun(&DownloadStore::is_correct_format))), d.end());
 
   return d;
 }
 
@@ -108,10 +114,10 @@
 
   return true;
 }
 
 std::string
 DownloadStore::create_filename(Download* d) {
-  return m_path + utils::string_to_hex(d->get_hash()) + ".torrent";
+  return m_path + rak::transform_hex(d->get_hash()) + ".torrent";
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/log.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/log.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/log.cc	2005-12-05 04:25:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/log.cc	2006-01-04 05:01:27.000000000 +0800
@@ -43,12 +43,15 @@
 #include "log.h"
 
 namespace core {
 
 void
 Log::push_front(const std::string& msg) {
+  if (!m_enabled)
+    return;
+
   Base::push_front(Type(cachedTime, msg));
 
   if (size() > 50)
     Base::pop_back();
 
   m_signalUpdate.emit();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/log.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/log.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/log.h	2005-12-05 04:19:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/log.h	2006-01-04 05:01:27.000000000 +0800
@@ -61,19 +61,28 @@
   using Base::rbegin;
   using Base::rend;
 
   using Base::empty;
   using Base::size;
 
+  Log() : m_enabled(true) {}
+
+  bool      is_enabled() const { return m_enabled; }
+
+  void      enable()           { m_enabled = true; }
+  void      disable()          { m_enabled = false; }
+
   void      push_front(const std::string& msg);
 
   iterator  find_older(rak::timer t);
 
   Signal&   signal_update() { return m_signalUpdate; }
 
 private:
+  bool      m_enabled;
+
   Signal    m_signalUpdate;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/manager.cc	2005-12-20 05:53:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/manager.cc	2006-01-10 02:43:29.000000000 +0800
@@ -40,19 +40,22 @@
 #include <cstdio>
 #include <cstring>
 #include <fstream>
 #include <istream>
 #include <unistd.h>
 #include <sys/select.h>
+#include <rak/regex.h>
+#include <rak/string_manip.h>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 #include <torrent/bencode.h>
 #include <torrent/exceptions.h>
 
 #include "curl_get.h"
 #include "download.h"
+#include "download_factory.h"
 #include "manager.h"
 #include "poll_manager_epoll.h"
 #include "poll_manager_select.h"
 
 namespace core {
 
@@ -68,12 +71,21 @@
 
 static void
 connect_signal_storage_log(Download* d, torrent::Download::SlotString s) {
   d->get_download().signal_storage_error(s);
 }
 
+// Hmm... find some better place for all this.
+static void
+delete_tied(Download* d) {
+  // This should be configurable, need to wait for the variable
+  // thingie to be implemented.
+  if (!d->tied_to_file().empty())
+    ::unlink(d->tied_to_file().c_str());
+}
+
 Manager::Manager() :
   m_pollManager(NULL),
   m_portRandom(false),
   m_portFirst(6890),
   m_portLast(6999),
   m_checkHash(true) {
@@ -95,24 +107,24 @@
 void
 Manager::initialize_second() {
   torrent::Http::set_factory(m_pollManager->get_http_stack()->get_http_factory());
   m_httpQueue.slot_factory(m_pollManager->get_http_stack()->get_http_factory());
 
   CurlStack::global_init();
-  listen_open();
 
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
   m_downloadList.slot_map_insert()["0_initialize_bencode"]  = sigc::mem_fun(*this, &Manager::initialize_bencode);
   m_downloadList.slot_map_insert()["1_connect_network_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
 //   m_downloadList.slot_map_insert()["1_connect_tracker_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   m_downloadList.slot_map_insert()["1_connect_storage_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
   //m_downloadList.slot_map_insert()["1_enable_udp_trackers"] = sigc::bind(sigc::mem_fun(&core::Download::enable_udp_trackers), true);
 
   m_downloadList.slot_map_erase()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
   m_downloadList.slot_map_erase()["1_store_remove"]         = sigc::mem_fun(m_downloadStore, &DownloadStore::remove);
+  m_downloadList.slot_map_erase()["1_delete_tied"]          = sigc::ptr_fun(&delete_tied);
 
   m_downloadList.slot_map_open()["1_download_open"]         = sigc::mem_fun(&Download::call<void, &torrent::Download::open>);
 
   // Currently does not call stop, might want to add a function that
   // checks if we're running, and if so stop?
   m_downloadList.slot_map_close()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
@@ -147,19 +159,21 @@
   else
     std::for_each(m_downloadList.begin(), m_downloadList.end(),
 		  std::bind1st(std::mem_fun(&DownloadList::close), &m_downloadList));
 }
 
 Manager::DListItr
-Manager::insert(std::istream* s) {
+Manager::insert(std::istream* s, bool printLog) {
   try {
     return m_downloadList.insert(s);
 
   } catch (torrent::local_error& e) {
-    m_logImportant.push_front(e.what());
-    m_logComplete.push_front(e.what());
+    if (printLog) {
+      m_logImportant.push_front(e.what());
+      m_logComplete.push_front(e.what());
+    }
 
     return m_downloadList.end();
   }
 }
 
 Manager::DListItr
@@ -171,15 +185,15 @@
 //     throw std::logic_error("core::Manager::erase(...) called on an closed download");
 
   return m_downloadList.erase(itr);
 }  
 
 void
-Manager::start(Download* d) {
+Manager::start(Download* d, bool printLog) {
   try {
-    d->get_bencode().get_key("rtorrent").get_key("state") = "started";
+    d->get_bencode().get_key("rtorrent").insert_key("state", "started");
 
     if (d->get_download().is_active())
       return;
 
     if (!d->get_download().is_open())
       m_downloadList.open(d);
@@ -188,21 +202,23 @@
       m_downloadList.start(d);
     else
       // This can cause infinit loops?
       m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(m_downloadList, &DownloadList::start), d));
 
   } catch (torrent::local_error& e) {
-    m_logImportant.push_front(e.what());
-    m_logComplete.push_front(e.what());
+    if (printLog) {
+      m_logImportant.push_front(e.what());
+      m_logComplete.push_front(e.what());
+    }
   }
 }
 
 void
 Manager::stop(Download* d) {
   try {
-    d->get_bencode().get_key("rtorrent").get_key("state") = "stopped";
+    d->get_bencode().get_key("rtorrent").insert_key("state", "stopped");
 
     m_downloadList.stop(d);
 
   } catch (torrent::local_error& e) {
     m_logImportant.push_front(e.what());
     m_logComplete.push_front(e.what());
@@ -300,7 +316,89 @@
 
   // Don't send if we did a hash check and found incompelete chunks.
   //if (d->is_done())
     d->get_download().tracker_send_completed();
 }
 
+void
+Manager::try_create_download(const std::string& uri, bool start, bool printLog, bool tied) {
+  // Adding download.
+  DownloadFactory* f = new DownloadFactory(uri, this);
+
+  f->set_start(start);
+  f->set_print_log(printLog);
+  f->set_tied_to_file(tied);
+  f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
+  f->load();
+  f->commit();
+}
+
+// Move this somewhere better.
+void
+path_expand(std::vector<std::string>* paths, const std::string& pattern) {
+  std::vector<utils::Directory> currentCache;
+  std::vector<utils::Directory> nextCache;
+
+  rak::split_iterator_t<std::string> first = rak::split_iterator(pattern, '/');
+  rak::split_iterator_t<std::string> last = rak::split_iterator(pattern);
+    
+  if (first == last)
+    return;
+
+  // Check for initial '/' that indicates the root.
+  if ((*first).empty()) {
+    currentCache.push_back(utils::Directory("/"));
+    ++first;
+  } else {
+    currentCache.push_back(utils::Directory("./"));
+  }
+
+  // Might be an idea to use depth-first search instead.
+
+  for (; first != last; ++first) {
+    rak::regex r(*first);
+
+    if (r.pattern().empty())
+      continue;
+
+    // Special case for ".."?
+
+    for (std::vector<utils::Directory>::iterator itr = currentCache.begin(); itr != currentCache.end(); ++itr) {
+      // Only include filenames starting with '.' if the pattern
+      // starts with the same.
+      itr->update(r.pattern()[0] != '.');
+      itr->erase(std::remove_if(itr->begin(), itr->end(), std::not1(r)), itr->end());
+
+      std::transform(itr->begin(), itr->end(), std::back_inserter(nextCache), std::bind1st(std::plus<std::string>(), itr->get_path() + "/"));
+    }
+
+    currentCache.clear();
+    currentCache.swap(nextCache);
+  }
+
+  std::transform(currentCache.begin(), currentCache.end(), std::back_inserter(*paths), std::mem_fun_ref(&utils::Directory::get_path));
+}
+
+void
+Manager::try_create_download_expand(const std::string& uri, bool start, bool printLog, bool tied) {
+  std::vector<std::string> paths;
+  paths.reserve(32);
+
+  path_expand(&paths, uri);
+
+  if (tied)
+    for (std::vector<std::string>::iterator itr = paths.begin(); itr != paths.end(); )
+      if (std::find_if(m_downloadList.begin(), m_downloadList.end(),
+		       rak::equal(*itr, std::mem_fun(&Download::tied_to_file))) != m_downloadList.end())
+	itr = paths.erase(itr);
+      else
+	itr++;
+
+  if (!paths.empty())
+    for (std::vector<std::string>::iterator itr = paths.begin(); itr != paths.end(); ++itr)
+      try_create_download(*itr, start, printLog, tied);
+
+  else
+    try_create_download(uri, start, printLog, tied);
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/core/manager.h	2005-12-19 00:17:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/core/manager.h	2006-01-04 05:01:27.000000000 +0800
@@ -80,22 +80,26 @@
   void                cleanup();
 
   void                listen_open();
 
   void                shutdown(bool force);
 
-  DListItr            insert(std::istream* s);
+  DListItr            insert(std::istream* s, bool printLog = true);
   DListItr            erase(DListItr itr);
 
-  void                start(Download* d);
+  void                start(Download* d, bool printLog = true);
   void                stop(Download* d);
 
   void                check_hash(Download* d);
 
   void                push_log(const std::string& msg)    { m_logImportant.push_front(msg); m_logComplete.push_front(msg); }
 
+  // Temporary, find a better place for this.
+  void                try_create_download(const std::string& uri, bool start, bool printLog = true, bool tied = false);
+  void                try_create_download_expand(const std::string& uri, bool start, bool printLog = true, bool tied = false);
+
 private:
   void                create_http(const std::string& uri);
   void                create_final(std::istream* s);
 
   void                initialize_bencode(Download* d);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/manager.cc	2005-12-16 06:47:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/manager.cc	2006-01-10 00:51:12.000000000 +0800
@@ -44,12 +44,34 @@
 #include "globals.h"
 #include "manager.h"
 #include "window.h"
 
 namespace display {
 
+Manager::Manager() {
+  m_taskUpdate.set_slot(rak::mem_fn(this, &Manager::receive_update));
+}
+
+Manager::~Manager() {
+  priority_queue_erase(&taskScheduler, &m_taskUpdate);
+}
+
+Manager::iterator
+Manager::insert(iterator pos, Window* w) {
+  return Base::insert(pos, w);
+}
+
+// Swap with the function below.
+Manager::iterator
+Manager::erase(iterator pos) {
+  if (pos != end())
+    return erase(*pos);
+  else
+    return end();
+}
+
 Manager::iterator
 Manager::erase(Window* w) {
   iterator itr = std::find(begin(), end(), w);
 
   if (itr == end())
     throw std::logic_error("Manager::erase(...) did not find the window");
@@ -60,12 +82,25 @@
 Manager::iterator
 Manager::find(Window* w) {
   return std::find(begin(), end(), w);
 }
 
 void
+Manager::schedule(Window* w, rak::timer t) {
+  rak::priority_queue_erase(&m_scheduler, w->task_update());
+  rak::priority_queue_insert(&m_scheduler, w->task_update(), t);
+  schedule_update();
+}
+
+void
+Manager::unschedule(Window* w) {
+  rak::priority_queue_erase(&m_scheduler, w->task_update());
+  schedule_update();
+}
+
+void
 Manager::adjust_layout() {
   int staticHeight = std::for_each(begin(), end(),
 				   rak::if_then(std::mem_fun(&Window::is_active),
 						rak::accumulate(0, std::mem_fun(&Window::get_min_height)))).m_then.result;
   int countDynamic = std::for_each(begin(), end(),
 				   rak::if_then(std::mem_fun(&Window::is_active),
@@ -92,31 +127,33 @@
     (*itr)->resize(0, height, Canvas::get_screen_width(), h);
     (*itr)->mark_dirty();
   }
 }
 
 void
-Manager::do_update() {
+Manager::receive_update() {
   Canvas::refresh_std();
 
-//   std::list<rak::priority_item*> workQueue;
+  rak::priority_queue_perform(&m_scheduler, cachedTime);
+  std::for_each(begin(), end(), rak::if_then(std::mem_fun(&Window::is_active), std::mem_fun(&Window::refresh)));
 
-//   std::copy(rak::queue_popper(displayScheduler, rak::bind2nd(std::mem_fun(&rak::priority_item::compare), cachedTime)),
-// 	    rak::queue_popper(displayScheduler, rak::bind2nd(std::mem_fun(&rak::priority_item::compare), rak::timer())),
-// 	    std::back_inserter(workQueue));
-//   std::for_each(workQueue.begin(), workQueue.end(), std::mem_fun(&rak::priority_item::clear_time));
-//   std::for_each(workQueue.begin(), workQueue.end(), std::mem_fun(&rak::priority_item::call));
-
-  while (!displayScheduler.empty() && displayScheduler.top()->time() <= cachedTime) {
-    rak::priority_item* v = displayScheduler.top();
-    displayScheduler.pop();
+  Canvas::do_update();
 
-    v->clear_time();
-    v->call();
-  }
+  m_timeLastUpdate = cachedTime;
+  schedule_update();
+}
 
-  std::for_each(begin(), end(), rak::if_then(std::mem_fun(&Window::is_active), std::mem_fun(&Window::refresh)));
+void
+Manager::schedule_update() {
+  if (m_scheduler.empty()) {
+    rak::priority_queue_erase(&taskScheduler, &m_taskUpdate);
+    return;
+  }
 
-  Canvas::do_update();
+  if (!m_taskUpdate.is_queued() || m_taskUpdate.time() > m_scheduler.top()->time()) {
+    rak::priority_queue_erase(&taskScheduler, &m_taskUpdate);
+    rak::priority_queue_insert(&taskScheduler, &m_taskUpdate,
+			       std::max(m_scheduler.top()->time(), m_timeLastUpdate + 50000));
+  }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/manager.h	2005-11-12 23:31:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/manager.h	2006-01-07 05:07:29.000000000 +0800
@@ -35,12 +35,13 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_DISPLAY_MANAGER_H
 #define RTORRENT_DISPLAY_MANAGER_H
 
 #include <list>
+#include <rak/priority_queue_default.h>
 
 namespace display {
 
 class Window;
 
 class Manager : private std::list<Window*> {
@@ -54,24 +55,37 @@
 
   using Base::begin;
   using Base::end;
   using Base::rbegin;
   using Base::rend;
 
-  using Base::insert;
-  using Base::erase;
   using Base::push_front;
   using Base::push_back;
 
-  iterator       erase(Window* w);
+  Manager();
+  ~Manager();
 
-  iterator       find(Window* w);
+  iterator            insert(iterator pos, Window* w);
+  iterator            erase(iterator pos);
+  iterator            erase(Window* w);
 
-  void           adjust_layout();
-  void           do_update();
+  iterator            find(Window* w);
+
+  void                schedule(Window* w, rak::timer t);
+  void                unschedule(Window* w);
+
+  void                adjust_layout();
 
 private:
+  void                receive_update();
+
+  void                schedule_update();
+
+  rak::timer          m_timeLastUpdate;
+
+  rak::priority_queue_default m_scheduler;
+  rak::priority_item          m_taskUpdate;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/utils.cc	2005-12-20 03:49:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/utils.cc	2005-12-22 08:38:00.000000000 +0800
@@ -63,92 +63,91 @@
 print_hhmmss(char* buf, unsigned int length, time_t t) {
   std::tm *u = std::localtime(&t);
   
   if (u == NULL)
     return "inv_time";
 
-  unsigned int s = snprintf(buf, length, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
+  int s = snprintf(buf, length, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
 
-  return buf + std::min(s, length);
+  return buf + std::max(s, 0);
 }
 
 char*
 print_ddhhmm(char* buf, unsigned int length, time_t t) {
-  unsigned int s;
+  int s;
 
   if (t / (24 * 3600) < 100)
     s = snprintf(buf, length, "%2i:%02i:%02i", (int)t / (24 * 3600), ((int)t / 3600) % 24, ((int)t / 60) % 60);
   else
     s = snprintf(buf, length, "--:--:--");
   
-  return buf + std::min(s, length);
+  return buf + std::max(s, 0);
 }
 
 char*
 print_ddmmyyyy(char* buf, unsigned int length, time_t t) {
   std::tm *u = std::gmtime(&t);
   
   if (u == NULL)
     return "inv_time";
 
-  unsigned int s = snprintf(buf, length, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
+  int s = snprintf(buf, length, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
 
-  return buf + std::min(s, length);
+  return buf + std::max(s, 0);
 }
 
 char*
 print_download_title(char* buf, unsigned int length, core::Download* d) {
-  return buf + std::max(0, snprintf(buf, length, "%s",
-				    d->get_download().name().c_str()));
+  return buf + std::max(snprintf(buf, length, "%s", d->get_download().name().c_str()), 0);
 }
 
 char*
 print_download_info(char* buf, unsigned int length, core::Download* d) {
   char* last = buf + length;
 
-  buf += std::max(0, snprintf(buf, last - buf, "Torrent: "));
+  buf += std::max(snprintf(buf, last - buf, "Torrent: "), 0);
 
   if (!d->get_download().is_open())
-    buf += std::max(0, snprintf(buf, last - buf, "closed            "));
+    buf += std::max(snprintf(buf, last - buf, "closed            "), 0);
   else if (d->is_done())
-    buf += std::max(0, snprintf(buf, last - buf, "done %10.1f MB",
-				(double)d->get_download().bytes_total() / (double)(1 << 20)));
+    buf += std::max(snprintf(buf, last - buf, "done %10.1f MB",
+			     (double)d->get_download().bytes_total() / (double)(1 << 20)), 0);
   else
-    buf += std::max(0, snprintf(buf, last - buf, "%6.1f / %6.1f MB",
-				(double)d->get_download().bytes_done() / (double)(1 << 20),
-				(double)d->get_download().bytes_total() / (double)(1 << 20)));
+    buf += std::max(snprintf(buf, last - buf, "%6.1f / %6.1f MB",
+			     (double)d->get_download().bytes_done() / (double)(1 << 20),
+			     (double)d->get_download().bytes_total() / (double)(1 << 20)), 0);
   
-  buf += std::max(0, snprintf(buf, last - buf, " Rate: %5.1f / %5.1f KB Uploaded: %7.1f MB ",
-			      (double)d->get_download().up_rate()->rate() / (1 << 10),
-			      (double)d->get_download().down_rate()->rate() / (1 << 10),
-			      (double)d->get_download().up_rate()->total() / (1 << 20)));
+  buf += std::max(snprintf(buf, last - buf, " Rate: %5.1f / %5.1f KB Uploaded: %7.1f MB ",
+			   (double)d->get_download().up_rate()->rate() / (1 << 10),
+			   (double)d->get_download().down_rate()->rate() / (1 << 10),
+			   (double)d->get_download().up_rate()->total() / (1 << 20)), 0);
 
   //buf += std::max(0, snprintf(buf, length, " Left: "));
   buf = print_download_time_left(buf, length, d);
 
   return buf;
 }
 
 char*
 print_download_status(char* buf, unsigned int length, core::Download* d) {
   if (!d->get_download().is_active())
-    buf += std::max(0, snprintf(buf, length, "Inactive: "));
+    buf += std::max(snprintf(buf, length, "Inactive: "), 0);
 
   if (d->get_download().is_hash_checking())
-    buf += std::max(0, snprintf(buf, length, "Checking hash [%2i%%]",
-				(d->get_download().chunks_hashed() * 100) / d->get_download().chunks_total()));
+    buf += std::max(snprintf(buf, length, "Checking hash [%2i%%]",
+			     (d->get_download().chunks_hashed() * 100) / d->get_download().chunks_total()), 0);
 
   else if (d->get_download().is_tracker_busy() &&
 	   d->get_download().tracker_focus() < d->get_download().size_trackers())
-    buf += std::max(0, snprintf(buf, length, "Tracker[%i:%i]: Connecting to %s",
-				d->get_download().tracker(d->get_download().tracker_focus()).group(),
-				d->get_download().tracker_focus(),
-				d->get_download().tracker(d->get_download().tracker_focus()).url().c_str()));
+    buf += std::max(snprintf(buf, length, "Tracker[%i:%i]: Connecting to %s",
+			     d->get_download().tracker(d->get_download().tracker_focus()).group(),
+			     d->get_download().tracker_focus(),
+			     d->get_download().tracker(d->get_download().tracker_focus()).url().c_str()), 0);
 
   else if (!d->get_message().empty())
-    buf += std::max(0, snprintf(buf, length, "%s", d->get_message().c_str()));
+    buf += std::max(snprintf(buf, length, "%s", d->get_message().c_str()), 0);
 
   else
     buf[0] = '\0';
 
   return buf;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window.cc	2005-12-16 03:39:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window.cc	2006-01-07 05:07:29.000000000 +0800
@@ -39,34 +39,36 @@
 #include <stdexcept>
 
 #include "window.h"
 
 namespace display {
 
-Window::Slot Window::m_slotAdjust;
+Window::SlotTimer  Window::m_slotSchedule;
+Window::SlotWindow Window::m_slotUnschedule;
+Window::Slot       Window::m_slotAdjust;
 
 Window::Window(Canvas* c, bool d, int h) :
   m_canvas(c),
   m_active(true),
   m_dynamic(d),
   m_minHeight(h) {
 
   m_taskUpdate.set_slot(rak::mem_fn(this, &Window::redraw));
 }
 
 Window::~Window() {
-  priority_queue_erase(&displayScheduler, &m_taskUpdate);
+  m_slotUnschedule(this);
   delete m_canvas;
 }
 
 void
 Window::set_active(bool a) {
   if (a)
     mark_dirty();
   else
-    priority_queue_erase(&displayScheduler, &m_taskUpdate);
+    m_slotUnschedule(this);
 
   m_active = a;
 }
 
 void
 Window::resize(int x, int y, int w, int h) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_download_list.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_download_list.cc	2006-01-07 05:07:29.000000000 +0800
@@ -57,13 +57,13 @@
 WindowDownloadList::~WindowDownloadList() {
   m_connChanged.disconnect();
 }
 
 void
 WindowDownloadList::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
 
   m_canvas->erase();
 
   if (m_list->base().empty() || m_canvas->get_width() < 5)
     return;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_download_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_download_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_download_statusbar.cc	2005-12-20 05:59:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_download_statusbar.cc	2006-01-07 05:07:29.000000000 +0800
@@ -51,13 +51,13 @@
   Window(new Canvas, false, 3),
   m_download(d) {
 }
 
 void
 WindowDownloadStatusbar::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
 
   m_canvas->erase();
 
   char buffer[m_canvas->get_width() - 2];
   char* position;
   char* last = buffer + m_canvas->get_width() - 2;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_file_list.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_file_list.cc	2006-01-07 05:07:29.000000000 +0800
@@ -51,13 +51,13 @@
   m_download(d),
   m_focus(focus) {
 }
 
 void
 WindowFileList::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 10 * 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 10 * 1000000).round_seconds());
   m_canvas->erase();
 
   if (m_download->get_download().size_file_entries() == 0 ||
       m_canvas->get_height() < 2)
     return;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window.h	2005-12-20 01:12:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window.h	2006-01-07 05:07:29.000000000 +0800
@@ -35,68 +35,70 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_WINDOW_BASE_H
 #define RTORRENT_WINDOW_BASE_H
 
 #include <rak/timer.h>
-#include <sigc++/slot.h>
+#include <rak/functional.h>
 
 #include "canvas.h"
 #include "globals.h"
 
 namespace display {
 
 class Canvas;
+class Manager;
 
 class Window {
 public:
-  typedef sigc::slot0<void> Slot;
+  typedef rak::mem_fun0<Manager, void>                      Slot;
+  typedef rak::mem_fun1<Manager, void, Window*>             SlotWindow;
+  typedef rak::mem_fun2<Manager, void, Window*, rak::timer> SlotTimer;
 
   Window(Canvas* c = NULL, bool d = false, int h = 1);
 
   virtual ~Window();
 
   bool                is_active()                          { return m_active; }
   bool                is_dynamic()                         { return m_dynamic; }
   bool                is_dirty()                           { return m_taskUpdate.is_queued(); }
 
-  //utils::rak::timer   get_next_draw()                      { return m_nextDraw; }
-
   int                 get_min_height()                     { return m_minHeight; }
 
   bool                get_active()                         { return m_active; }
   void                set_active(bool a);
 
   void                refresh()                            { m_canvas->refresh(); }
   void                resize(int x, int y, int w, int h);
 
-  void                mark_dirty();
+  void                mark_dirty()                         { m_slotSchedule(this, cachedTime + 1); }
 
   virtual void        redraw() = 0;
 
+  rak::priority_item* task_update()                        { return &m_taskUpdate; }
+
+  // Slot for adjust and refresh.
+  static void         slot_schedule(SlotTimer s)           { m_slotSchedule = s; }
+  static void         slot_unschedule(SlotWindow s)        { m_slotUnschedule = s; }
   static void         slot_adjust(Slot s)                  { m_slotAdjust = s; }
 
 protected:
   Window(const Window&);
   void operator = (const Window&);
 
+  static SlotTimer    m_slotSchedule;
+  static SlotWindow   m_slotUnschedule;
   static Slot         m_slotAdjust;
 
   Canvas*             m_canvas;
 
   bool                m_active;
   bool                m_dynamic;
   int                 m_minHeight;
 
   rak::priority_item  m_taskUpdate;
 };
 
-inline void
-Window::mark_dirty() {
-  priority_queue_erase(&displayScheduler, &m_taskUpdate);
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, cachedTime + 1);
-}
-
 }
 
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_http_queue.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_http_queue.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_http_queue.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_http_queue.cc	2006-01-07 05:07:29.000000000 +0800
@@ -55,13 +55,13 @@
   m_connInsert = m_queue->signal_insert().connect(sigc::mem_fun(*this, &WindowHttpQueue::receive_insert));
   m_connErase  = m_queue->signal_erase().connect(sigc::mem_fun(*this, &WindowHttpQueue::receive_erase));
 }
 
 void
 WindowHttpQueue::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
 
   cleanup_list();
 
   if (m_container.empty()) {
     set_active(false);
     m_slotAdjust();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_peer_info.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_peer_info.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_peer_info.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_peer_info.cc	2006-01-07 05:07:29.000000000 +0800
@@ -34,17 +34,17 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
+#include <rak/string_manip.h>
 #include <torrent/rate.h>
 
 #include "core/download.h"
 
-#include "utils/parse.h"
 #include "canvas.h"
 #include "utils.h"
 #include "window_peer_info.h"
 
 namespace display {
 
@@ -54,20 +54,20 @@
   m_list(l),
   m_focus(f) {
 }
 
 void
 WindowPeerInfo::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
   m_canvas->erase();
 
   int y = 0;
   torrent::Download d = m_download->get_download();
 
-  m_canvas->print(0, y++, "Hash:    %s", utils::string_to_hex(d.info_hash()).c_str());
-  m_canvas->print(0, y++, "Id:      %s", utils::escape_string(d.local_id()).c_str());
+  m_canvas->print(0, y++, "Hash:    %s", rak::transform_hex(d.info_hash()).c_str());
+  m_canvas->print(0, y++, "Id:      %s", rak::copy_escape_html(d.local_id()).c_str());
   m_canvas->print(0, y++, "Chunks:  %u / %u * %u",
 		  d.chunks_done(),
 		  d.chunks_total(),
 		  d.chunks_size());
 
   char buffer[32], *position;
@@ -80,26 +80,28 @@
   y++;
 
   m_canvas->print(0, y++, "Connection Type: %s ( %s / %s )",
 		  core::Download::connection_type_to_string(m_download->get_connection_current()),
 		  core::Download::connection_type_to_string(m_download->get_connection_leech()),
 		  core::Download::connection_type_to_string(m_download->get_connection_seed()));
+  m_canvas->print(0, y++, "Tied to file: %s",
+		  m_download->tied_to_file().c_str());
 
   y++;
 
   if (*m_focus == m_list->end()) {
     m_canvas->print(0, y++, "No peer in focus");
 
     return;
   }
 
   m_canvas->print(0, y++, "*** Peer Info ***");
 
   m_canvas->print(0, y++, "DNS: %s:%hu", (*m_focus)->address().c_str(), (*m_focus)->port());
-  m_canvas->print(0, y++, "Id: %s" , utils::escape_string((*m_focus)->id()).c_str());
-  m_canvas->print(0, y++, "Options: %s" , utils::string_to_hex(std::string((*m_focus)->options(), 8)).c_str());
+  m_canvas->print(0, y++, "Id: %s" , rak::copy_escape_html((*m_focus)->id()).c_str());
+  m_canvas->print(0, y++, "Options: %s" , rak::transform_hex(std::string((*m_focus)->options(), 8)).c_str());
   m_canvas->print(0, y++, "Snubbed: %s", (*m_focus)->is_snubbed() ? "yes" : "no");
   m_canvas->print(0, y++, "Connected: %s", (*m_focus)->is_incoming() ? "remote" : "local");
 
   m_canvas->print(0, y++, "Done: %i%", done_percentage(**m_focus));
 
   m_canvas->print(0, y++, "Rate: %5.1f/%5.1f KB Total: %.1f/%.1f MB",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_peer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_peer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_peer_list.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_peer_list.cc	2006-01-07 05:07:29.000000000 +0800
@@ -53,13 +53,13 @@
   m_list(l),
   m_focus(f) {
 }
 
 void
 WindowPeerList::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
   m_canvas->erase();
 
   int x = 2;
   int y = 0;
 
   m_canvas->print(x, y, "DNS");     x += 16;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_statusbar.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_statusbar.cc	2006-01-10 01:15:39.000000000 +0800
@@ -36,30 +36,27 @@
 
 #include "config.h"
 
 #include <torrent/rate.h>
 #include <torrent/torrent.h>
 
-#include "core/manager.h"
-
+#include "control.h"
 #include "canvas.h"
 #include "window_statusbar.h"
 
-extern uint32_t countTicks;
-
 namespace display {
 
-WindowStatusbar::WindowStatusbar(core::Manager* c) :
+WindowStatusbar::WindowStatusbar(Control* c) :
   Window(new Canvas, false, 1),
-  m_counter(0),
-  m_core(c) {
+  m_lastTick(0),
+  m_control(c) {
 }
 
 void
 WindowStatusbar::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
 
   m_canvas->erase();
 
   // TODO: Make a buffer with size = get_width?
   int pos = 0;
   char buf[128];
@@ -83,22 +80,22 @@
 		  !torrent::bind_address().empty() ? ("  Bind: " + torrent::bind_address()).c_str() : "");
 
 #ifndef USE_EXTRA_DEBUG
   pos = snprintf(buf, 128, "[U %i/%i][S %i/%i/%i][F %i/%i]",
 #else
   pos = snprintf(buf, 128, "%i [U %i/%i][S %i/%i/%i][F %i/%i]",
-		 countTicks,
+		 (int)(m_control->tick() - m_lastTick),
 #endif
 		 torrent::currently_unchoked(),
 		 torrent::max_unchoked(),
 		 torrent::total_handshakes(),
 		 torrent::open_sockets(),
 		 torrent::max_open_sockets(),
 		 torrent::open_files(),
 		 torrent::max_open_files());
 
-  countTicks = 0;
-
   m_canvas->print(m_canvas->get_width() - pos, 0, "%s", buf);
+
+  m_lastTick = m_control->tick();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_statusbar.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_statusbar.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_statusbar.h	2005-11-12 23:31:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_statusbar.h	2006-01-10 01:04:13.000000000 +0800
@@ -34,28 +34,28 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_DISPLAY_WINDOW_STATUSBAR_H
 #define RTORRENT_DISPLAY_WINDOW_STATUSBAR_H
 
+#include <inttypes.h>
+
 #include "window.h"
 
-namespace core {
-  class Manager;
-}
+class Control;
 
 namespace display {
 
 class WindowStatusbar : public Window {
 public:
-  WindowStatusbar(core::Manager* c);
+  WindowStatusbar(Control* c);
 
-  virtual void redraw();
+  virtual void   redraw();
 
 private:
-  int            m_counter;
-  core::Manager* m_core;
+  uint64_t       m_lastTick;
+  Control*       m_control;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_title.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_title.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_title.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_title.cc	2006-01-07 05:07:29.000000000 +0800
@@ -45,13 +45,13 @@
   Window(new Canvas, false, 1),
   m_title(s) {
 }
 
 void
 WindowTitle::redraw() {
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 1000000).round_seconds());
   m_canvas->erase();
 
   m_canvas->print(std::max(0, (m_canvas->get_width() - (int)m_title.size()) / 2 - 4), 0,
 		  "*** %s ***", m_title.c_str());
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/display/window_tracker_list.cc	2005-12-16 03:21:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/display/window_tracker_list.cc	2006-01-07 05:07:29.000000000 +0800
@@ -34,16 +34,16 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
+#include <rak/algorithm.h>
+#include <rak/string_manip.h>
 
 #include "core/download.h"
-#include "rak/algorithm.h"
-#include "utils/parse.h"
 
 #include "window_tracker_list.h"
 
 namespace display {
 
 WindowTrackerList::WindowTrackerList(core::Download* d, unsigned int* focus) :
@@ -52,13 +52,13 @@
   m_focus(focus) {
 }
 
 void
 WindowTrackerList::redraw() {
   // TODO: Make this depend on tracker signal.
-  priority_queue_insert(&displayScheduler, &m_taskUpdate, (cachedTime + 10 * 1000000).round_seconds());
+  m_slotSchedule(this, (cachedTime + 10 * 1000000).round_seconds());
   m_canvas->erase();
 
   int pos = 0;
 
   m_canvas->print( 2, pos, "Trackers:");
 
@@ -84,13 +84,13 @@
 		    range.first == *m_focus ? '*' : ' ',
 		    t.url().c_str());
 
     m_canvas->print(0, pos++, "%c Group: %2i Id: %s Focus: %s Enabled: %s Open: %s",
 		    range.first == *m_focus ? '*' : ' ',
 		    t.group(),
-		    utils::escape_string(t.tracker_id()).c_str(),
+		    rak::copy_escape_html(t.tracker_id()).c_str(),
 		    range.first == m_download->get_download().tracker_focus() ? "yes" : " no",
 		    t.is_enabled() ? "yes" : " no",
 		    t.is_open() ? "yes" : " no");
 
     ++range.first;
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/globals.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/globals.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/globals.cc	2005-12-09 00:57:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/globals.cc	2006-01-07 05:07:29.000000000 +0800
@@ -36,8 +36,7 @@
 
 #include "config.h"
 
 #include "globals.h"
 
 rak::priority_queue_default taskScheduler;
-rak::priority_queue_default displayScheduler;
 rak::timer                  cachedTime;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/globals.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/globals.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/globals.h	2005-12-09 00:57:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/globals.h	2006-01-07 05:07:30.000000000 +0800
@@ -38,10 +38,9 @@
 #define TORRENT_GLOBALS_H
 
 #include <rak/timer.h>
 #include <rak/priority_queue_default.h>
 
 extern rak::priority_queue_default taskScheduler;
-extern rak::priority_queue_default displayScheduler;
 extern rak::timer                  cachedTime;
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/input/path_input.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/input/path_input.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/input/path_input.cc	2005-11-12 23:31:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/input/path_input.cc	2006-01-07 05:07:29.000000000 +0800
@@ -35,15 +35,15 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <functional>
 #include <rak/algorithm.h>
+#include <rak/file_stat.h>
 
 #include "path_input.h"
-#include "utils/file_stat.h"
 
 namespace input {
 
 PathInput::PathInput() :
   m_showNext(false) {
 }
@@ -65,15 +65,15 @@
 }
 
 struct _transform_filename {
   _transform_filename(const std::string& base) : m_base(base) {}
 
   void operator () (std::string& filename) {
-    utils::FileStat fs;
+    rak::file_stat fs;
 
-    if (fs.update((m_base + filename).c_str()))
+    if (!fs.update((m_base + filename)))
       return;
 
     else if (fs.is_directory())
       filename += '/';
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/main.cc	2005-12-17 10:46:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/main.cc	2006-01-10 01:03:41.000000000 +0800
@@ -71,14 +71,12 @@
 #include "option_handler.h"
 #include "option_handler_rules.h"
 #include "option_parser.h"
 #include "command_scheduler.h"
 #include "command_scheduler_item.h"
 
-uint32_t countTicks = 0;
-
 void do_panic(int signum);
 void print_help();
 
 bool
 is_resized() {
   static int x = 0;
@@ -113,50 +111,12 @@
   } catch (torrent::input_error& e) {
     throw std::runtime_error("Failed to parse command line option: " + std::string(e.what()));
   }
 }
 
 void
-initialize_option_handler(Control* c, OptionHandler* optionHandler) {
-  optionHandler->insert("max_peers",           new OptionHandlerInt(c, &apply_download_max_peers));
-  optionHandler->insert("min_peers",           new OptionHandlerInt(c, &apply_download_min_peers));
-  optionHandler->insert("max_uploads",         new OptionHandlerInt(c, &apply_download_max_uploads));
-
-  optionHandler->insert("download_rate",       new OptionHandlerInt(c, &apply_global_download_rate));
-  optionHandler->insert("upload_rate",         new OptionHandlerInt(c, &apply_global_upload_rate));
-
-  optionHandler->insert("bind",                new OptionHandlerString(c, &apply_bind));
-  optionHandler->insert("ip",                  new OptionHandlerString(c, &apply_ip));
-  optionHandler->insert("port_range",          new OptionHandlerString(c, &apply_port_range));
-  optionHandler->insert("port_random",         new OptionHandlerString(c, &apply_port_random));
-
-  optionHandler->insert("check_hash",          new OptionHandlerString(c, &apply_check_hash));
-  optionHandler->insert("directory",           new OptionHandlerString(c, &apply_download_directory));
-
-  optionHandler->insert("hash_read_ahead",     new OptionHandlerInt(c, &apply_hash_read_ahead));
-  optionHandler->insert("hash_interval",       new OptionHandlerInt(c, &apply_hash_interval));
-  optionHandler->insert("hash_max_tries",      new OptionHandlerInt(c, &apply_hash_max_tries));
-  optionHandler->insert("max_open_files",      new OptionHandlerInt(c, &apply_max_open_files));
-  optionHandler->insert("max_open_sockets",    new OptionHandlerInt(c, &apply_max_open_sockets));
-
-  optionHandler->insert("umask",               new OptionHandlerOctal(c, &apply_umask));
-
-  optionHandler->insert("connection_leech",    new OptionHandlerString(c, &apply_connection_leech));
-  optionHandler->insert("connection_seed",     new OptionHandlerString(c, &apply_connection_seed));
-
-  optionHandler->insert("session",             new OptionHandlerString(c, &apply_session_directory));
-  optionHandler->insert("encoding_list",       new OptionHandlerString(c, &apply_encoding_list));
-  optionHandler->insert("tracker_dump",        new OptionHandlerString(c, &apply_tracker_dump));
-  optionHandler->insert("use_udp_trackers",    new OptionHandlerString(c, &apply_use_udp_trackers));
-
-  optionHandler->insert("http_proxy",          new OptionHandlerString(c, &apply_http_proxy));
-  optionHandler->insert("schedule",            new OptionHandlerString(c, &apply_schedule));
-  optionHandler->insert("schedule_remove",     new OptionHandlerString(c, &apply_schedule_remove));
-}
-
-void
 load_session_torrents(Control* c) {
   // Load session torrents.
   std::list<std::string> l = c->core()->get_download_store().get_formated_entries().make_list();
 
   for (std::list<std::string>::iterator first = l.begin(), last = l.end(); first != last; ++first) {
     core::DownloadFactory* f = new core::DownloadFactory(*first, c->core());
@@ -180,98 +140,84 @@
     f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
     f->load();
     f->commit();
   }
 }
 
+rak::timer
+client_next_timeout() {
+  if (taskScheduler.empty())
+    return 60 * 1000000;
+  else if (taskScheduler.top()->time() <= cachedTime)
+    return 0;
+  else
+    return taskScheduler.top()->time() - cachedTime;
+}
+
 int
 main(int argc, char** argv) {
   try {
 
     cachedTime = rak::timer::current();
 
-    OptionHandler optionHandler;
     Control       control;
     
-    control.command_scheduler()->set_slot_command(rak::mem_fn(&optionHandler, &OptionHandler::process_command));
-    control.command_scheduler()->set_slot_error_message(rak::mem_fn(control.core(), &core::Manager::push_log));
-
     srandom(cachedTime.usec());
     srand48(cachedTime.usec());
 
-    initialize_option_handler(&control, &optionHandler);
-
-    OptionFile optionFile;
-    optionFile.slot_option(sigc::mem_fun(optionHandler, &OptionHandler::process));
+    initialize_option_handler(&control);
 
     SignalHandler::set_ignore(SIGPIPE);
     SignalHandler::set_handler(SIGINT,  sigc::mem_fun(control, &Control::receive_shutdown));
     SignalHandler::set_handler(SIGSEGV, sigc::bind(sigc::ptr_fun(&do_panic), SIGSEGV));
     SignalHandler::set_handler(SIGBUS,  sigc::bind(sigc::ptr_fun(&do_panic), SIGBUS));
     SignalHandler::set_handler(SIGFPE,  sigc::bind(sigc::ptr_fun(&do_panic), SIGFPE));
 
     control.core()->initialize_first();
 
+    OptionFile optionFile;
+    optionFile.slot_option(sigc::mem_fun(control.option_handler(), &OptionHandler::process));
+
     if (getenv("HOME") && !optionFile.process_file(getenv("HOME") + std::string("/.rtorrent.rc")))
       control.core()->get_log_important().push_front("Could not load \"~/.rtorrent.rc\".");
 
-    int firstArg = parse_options(&control, &optionHandler, argc, argv);
+    int firstArg = parse_options(&control, control.option_handler(), argc, argv);
 
     control.initialize();
 
     // Just to make sure we did all the stuff on the queue before
     // loading any torrents.
-    while (!taskScheduler.empty() && taskScheduler.top()->time() <= cachedTime) {
-      rak::priority_item* v = taskScheduler.top();
-      taskScheduler.pop();
-
-      v->clear_time();
-      v->call();
-    }
+    //
+    // Remove this?
+    //rak::priority_queue_perform(&taskScheduler, cachedTime);
 
+    // Load session torrents and perform scheduled tasks to ensure
+    // session torrents are loaded before arg torrents.
     load_session_torrents(&control);
+    rak::priority_queue_perform(&taskScheduler, cachedTime);
+
     load_arg_torrents(&control, argv + firstArg, argv + argc);
 
     control.display()->adjust_layout();
 
     while (!control.is_shutdown_completed()) {
-      countTicks++;
+      control.inc_tick();
 
       cachedTime = rak::timer::current();
-
-//       std::list<rak::priority_item*> workQueue;
-
-//       std::copy(rak::queue_popper(taskScheduler, rak::bind2nd(std::mem_fun(&rak::priority_item::compare), cachedTime)),
-// 		rak::queue_popper(taskScheduler, rak::bind2nd(std::mem_fun(&rak::priority_item::compare), rak::timer())),
-// 		std::back_inserter(workQueue));
-//       std::for_each(workQueue.begin(), workQueue.end(), std::mem_fun(&rak::priority_item::clear_time));
-//       std::for_each(workQueue.begin(), workQueue.end(), std::mem_fun(&rak::priority_item::call));
-
-      while (!taskScheduler.empty() && taskScheduler.top()->time() <= cachedTime) {
-	rak::priority_item* v = taskScheduler.top();
-	taskScheduler.pop();
-
-	v->clear_time();
-	v->call();
-      }
-
-      // This needs to be called every second or so. Currently done by
-      // the throttle task in libtorrent.
-      if (!displayScheduler.empty() && displayScheduler.top()->time() <= cachedTime)
-	control.display()->do_update();
+      rak::priority_queue_perform(&taskScheduler, cachedTime);
 
       // Do shutdown check before poll, not after.
-      control.core()->get_poll_manager()->poll(!taskScheduler.empty() ? taskScheduler.top()->time() - cachedTime : 60 * 1000000);
+      control.core()->get_poll_manager()->poll(client_next_timeout());
     }
 
     control.cleanup();
 
   } catch (torrent::base_error& e) {
     display::Canvas::cleanup();
 
-    std::cout << "Caught exception from libtorrent: " << e.what() << std::endl;
+    std::cout << "Caught exception: " << e.what() << std::endl;
     return -1;
 
   } catch (std::exception& e) {
     display::Canvas::cleanup();
 
     std::cout << e.what() << std::endl;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/option_handler_rules.cc	2005-12-19 00:22:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/option_handler_rules.cc	2006-01-07 05:07:29.000000000 +0800
@@ -34,17 +34,21 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <cstdio>
+#include <functional>
 #include <arpa/inet.h>
 #include <netinet/in.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <rak/file_stat.h>
+#include <rak/functional.h>
 #include <rak/string_manip.h>
+#include <torrent/bencode.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
 
 #include "core/manager.h"
 #include "ui/root.h"
 #include "utils/directory.h"
@@ -155,21 +159,20 @@
 apply_max_open_sockets(Control* m, int arg) {
   torrent::set_max_open_sockets(arg);
 }
 
 void
 apply_bind(Control* m, const std::string& arg) {
-  bool reopenListen = torrent::listen_port();
-
-  if (reopenListen)
+  if (torrent::listen_port() != 0) {
     torrent::listen_close();
-
-  torrent::set_bind_address(arg);
-
-  if (reopenListen)
+    torrent::set_bind_address(arg);
     m->core()->listen_open();
+
+  } else {
+    torrent::set_bind_address(arg);
+  }
 }
 
 void
 apply_ip(Control* m, const std::string& arg) {
   torrent::set_local_address(arg);
 }
@@ -217,12 +220,64 @@
 void
 apply_http_proxy(Control* m, const std::string& arg) {
   m->core()->get_poll_manager()->get_http_stack()->set_http_proxy(arg);
 }
 
 void
+apply_load(Control* m, const std::string& arg) {
+  m->core()->try_create_download_expand(arg, false, false, true);
+}
+
+void
+apply_load_start(Control* m, const std::string& arg) {
+  m->core()->try_create_download_expand(arg, true, false, true);
+}
+
+void
+apply_stop_untied(Control* m, const std::string& arg) {
+  core::Manager::DListItr itr = m->core()->get_download_list().begin();
+
+  while ((itr = std::find_if(itr, m->core()->get_download_list().end(),
+			     rak::on(std::mem_fun(&core::Download::tied_to_file), std::not1(std::mem_fun_ref(&std::string::empty)))))
+	 != m->core()->get_download_list().end()) {
+    rak::file_stat fs;
+
+    if (!fs.update((*itr)->tied_to_file())) {
+      (*itr)->set_tied_to_file(std::string());
+      (*itr)->get_bencode().get_key("rtorrent").erase_key("tied");
+
+      m->core()->stop(*itr);
+    }
+
+    ++itr;
+  }
+}
+
+void
+apply_remove_untied(Control* m, const std::string& arg) {
+  core::Manager::DListItr itr = m->core()->get_download_list().begin();
+
+  while ((itr = std::find_if(itr, m->core()->get_download_list().end(),
+			     rak::on(std::mem_fun(&core::Download::tied_to_file), std::not1(std::mem_fun_ref(&std::string::empty)))))
+	 != m->core()->get_download_list().end()) {
+    rak::file_stat fs;
+
+    if (!fs.update((*itr)->tied_to_file())) {
+      (*itr)->set_tied_to_file(std::string());
+      (*itr)->get_bencode().get_key("rtorrent").erase_key("tied");
+
+      m->core()->stop(*itr);
+      itr = m->core()->erase(itr);
+
+    } else {
+      ++itr;
+    }
+  }
+}
+
+void
 apply_session_directory(Control* m, const std::string& arg) {
   m->core()->get_download_store().use(arg);
 }
 
 void
 apply_encoding_list(Control* m, const std::string& arg) {
@@ -248,6 +303,49 @@
 }
 
 void
 apply_schedule_remove(Control* m, const std::string& arg) {
   m->command_scheduler()->erase(m->command_scheduler()->find(rak::trim(arg)));
 }
+
+void
+initialize_option_handler(Control* c) {
+  c->option_handler()->insert("max_peers",           new OptionHandlerInt(c, &apply_download_max_peers));
+  c->option_handler()->insert("min_peers",           new OptionHandlerInt(c, &apply_download_min_peers));
+  c->option_handler()->insert("max_uploads",         new OptionHandlerInt(c, &apply_download_max_uploads));
+
+  c->option_handler()->insert("download_rate",       new OptionHandlerInt(c, &apply_global_download_rate));
+  c->option_handler()->insert("upload_rate",         new OptionHandlerInt(c, &apply_global_upload_rate));
+
+  c->option_handler()->insert("bind",                new OptionHandlerString(c, &apply_bind));
+  c->option_handler()->insert("ip",                  new OptionHandlerString(c, &apply_ip));
+  c->option_handler()->insert("port_range",          new OptionHandlerString(c, &apply_port_range));
+  c->option_handler()->insert("port_random",         new OptionHandlerString(c, &apply_port_random));
+
+  c->option_handler()->insert("check_hash",          new OptionHandlerString(c, &apply_check_hash));
+  c->option_handler()->insert("directory",           new OptionHandlerString(c, &apply_download_directory));
+
+  c->option_handler()->insert("hash_read_ahead",     new OptionHandlerInt(c, &apply_hash_read_ahead));
+  c->option_handler()->insert("hash_interval",       new OptionHandlerInt(c, &apply_hash_interval));
+  c->option_handler()->insert("hash_max_tries",      new OptionHandlerInt(c, &apply_hash_max_tries));
+  c->option_handler()->insert("max_open_files",      new OptionHandlerInt(c, &apply_max_open_files));
+  c->option_handler()->insert("max_open_sockets",    new OptionHandlerInt(c, &apply_max_open_sockets));
+
+  c->option_handler()->insert("umask",               new OptionHandlerOctal(c, &apply_umask));
+
+  c->option_handler()->insert("connection_leech",    new OptionHandlerString(c, &apply_connection_leech));
+  c->option_handler()->insert("connection_seed",     new OptionHandlerString(c, &apply_connection_seed));
+
+  c->option_handler()->insert("load",                new OptionHandlerString(c, &apply_load));
+  c->option_handler()->insert("load_start",          new OptionHandlerString(c, &apply_load_start));
+  c->option_handler()->insert("stop_untied",         new OptionHandlerString(c, &apply_stop_untied));
+  c->option_handler()->insert("remove_untied",       new OptionHandlerString(c, &apply_remove_untied));
+
+  c->option_handler()->insert("session",             new OptionHandlerString(c, &apply_session_directory));
+  c->option_handler()->insert("encoding_list",       new OptionHandlerString(c, &apply_encoding_list));
+  c->option_handler()->insert("tracker_dump",        new OptionHandlerString(c, &apply_tracker_dump));
+  c->option_handler()->insert("use_udp_trackers",    new OptionHandlerString(c, &apply_use_udp_trackers));
+
+  c->option_handler()->insert("http_proxy",          new OptionHandlerString(c, &apply_http_proxy));
+  c->option_handler()->insert("schedule",            new OptionHandlerString(c, &apply_schedule));
+  c->option_handler()->insert("schedule_remove",     new OptionHandlerString(c, &apply_schedule_remove));
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/option_handler_rules.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/option_handler_rules.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/option_handler_rules.h	2005-12-17 07:56:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/option_handler_rules.h	2006-01-07 05:07:29.000000000 +0800
@@ -39,52 +39,16 @@
 
 #include <cstdio>
 #include <stdexcept>
 #include <sigc++/bind.h>
 
 #include "option_handler.h"
-#include "core/download_slot_map.h"
 
 class Control;
 
-// Not pretty, but it is simple and easy to modify.
-
-void apply_download_min_peers(Control* m, int arg);
-void apply_download_max_peers(Control* m, int arg);
-void apply_download_max_uploads(Control* m, int arg);
-void apply_download_directory(Control* m, const std::string& arg);
-
-void apply_connection_leech(Control* m, const std::string& arg);
-void apply_connection_seed(Control* m, const std::string& arg);
-
-void apply_global_download_rate(Control* m, int arg);
-void apply_global_upload_rate(Control* m, int arg);
-
-void apply_umask(Control* m, int arg);
-
-void apply_hash_read_ahead(Control* m, int arg);
-void apply_hash_interval(Control* m, int arg);
-void apply_hash_max_tries(Control* m, int arg);
-void apply_max_open_files(Control* m, int arg);
-void apply_max_open_sockets(Control* m, int arg);
-
-void apply_ip(Control* m, const std::string& arg);
-void apply_bind(Control* m, const std::string& arg);
-void apply_port_range(Control* m, const std::string& arg);
-void apply_port_random(Control* m, const std::string& arg);
-void apply_tracker_dump(Control* m, const std::string& arg);
-void apply_use_udp_trackers(Control* m, const std::string& arg);
-void apply_check_hash(Control* m, const std::string& arg);
-
-void apply_http_proxy(Control* m, const std::string& arg);
-
-void apply_session_directory(Control* m, const std::string& arg);
-void apply_encoding_list(Control* m, const std::string& arg);
-
-void apply_schedule(Control* m, const std::string& arg);
-void apply_schedule_remove(Control* m, const std::string& arg);
+void initialize_option_handler(Control* c);
 
 class OptionHandlerInt : public OptionHandlerBase {
 public:
   typedef void (*Apply)(Control*, int);
 
   OptionHandlerInt(Control* c, Apply a) :
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/ui/download_list.cc	2005-12-20 01:13:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/ui/download_list.cc	2006-01-04 05:01:27.000000000 +0800
@@ -35,18 +35,18 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
 #include <rak/functional.h>
+#include <rak/string_manip.h>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 #include <torrent/torrent.h>
 
 #include "core/download.h"
-#include "core/download_factory.h"
 #include "core/manager.h"
 
 #include "input/bindings.h"
 #include "input/manager.h"
 #include "input/path_input.h"
 
@@ -262,22 +262,15 @@
 DownloadList::receive_exit_input(bool useDefault) {
   if (!m_windowTextInput->get_active())
     return;
 
   m_control->ui()->window_statusbar()->set_active(true);
   m_windowTextInput->set_active(false);
-
   m_control->input()->set_text_input();
 
-  // Adding download.
-  core::DownloadFactory* f = new core::DownloadFactory(m_windowTextInput->get_input()->str(), m_control->core());
-
-  f->set_start(useDefault);
-  f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
-  f->load();
-  f->commit();
+  m_control->core()->try_create_download_expand(m_windowTextInput->get_input()->str(), useDefault);
 
   // Clean up.
   m_windowTextInput->get_input()->clear();
   m_windowTextInput->set_focus(false);
 
   m_bindings->erase('\n');
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/ui/root.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/ui/root.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/ui/root.cc	2005-11-24 22:15:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/ui/root.cc	2006-01-10 01:00:24.000000000 +0800
@@ -61,13 +61,13 @@
   if (m_control != NULL)
     throw std::logic_error("Root::init() called twice on the same object");
 
   m_control = c;
   setup_keys();
 
-  m_windowStatusbar = new WStatusbar(m_control->core());
+  m_windowStatusbar = new WStatusbar(m_control);
   m_downloadList =    new DownloadList(m_control);
 
   m_control->display()->push_back(m_windowStatusbar);
 
   m_downloadList->activate();
   //  m_downloadList->slot_open_uri(sigc::mem_fun(m_control->get_core(), &core::Manager::insert));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/directory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/directory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/directory.cc	2005-11-12 23:31:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/directory.cc	2006-01-04 05:01:27.000000000 +0800
@@ -54,13 +54,13 @@
   closedir(d);
 
   return d;
 }
 
 bool
-Directory::update() {
+Directory::update(bool hideDot) {
   if (m_path.empty())
     throw std::logic_error("Directory::update() tried to open an empty path");
 
   DIR* d = opendir(m_path.c_str());
 
   if (d == NULL)
@@ -68,13 +68,13 @@
 
   struct dirent* ent;
 
   while ((ent = readdir(d)) != NULL) {
     std::string de(ent->d_name);
 
-    if (!de.empty() && de[0] != '.')
+    if (!de.empty() && (!hideDot || de[0] != '.'))
       Base::push_back(ent->d_name);
   }
 
   closedir(d);
   Base::sort(std::less<std::string>());
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/directory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/directory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/directory.h	2005-11-12 23:31:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/directory.h	2006-01-04 05:01:27.000000000 +0800
@@ -63,13 +63,13 @@
 
   Directory() {}
   Directory(const std::string& path) : m_path(path) {}
 
   bool                is_valid() const;
 
-  bool                update();
+  bool                update(bool hideDot = true);
 
   const std::string&  get_path() { return m_path; }
 
   // Make a list with full path names.
   Base                make_list();
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils: file_stat.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils: file_stat.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/Makefile.am	2005-12-09 00:24:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/Makefile.am	2006-01-07 05:07:29.000000000 +0800
@@ -1,12 +1,8 @@
 noinst_LIBRARIES = libsub_utils.a
 
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
-	file_stat.cc \
-	file_stat.h \
-	list_focus.h \
-	parse.cc \
-	parse.h
+	list_focus.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils/Makefile.in	2005-12-16 10:53:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.2/src/utils/Makefile.in	2006-01-10 03:32:54.000000000 +0800
@@ -50,14 +50,13 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 AR = ar
 ARFLAGS = cru
 libsub_utils_a_AR = $(AR) $(ARFLAGS)
 libsub_utils_a_LIBADD =
-am_libsub_utils_a_OBJECTS = directory.$(OBJEXT) file_stat.$(OBJEXT) \
-	parse.$(OBJEXT)
+am_libsub_utils_a_OBJECTS = directory.$(OBJEXT)
 libsub_utils_a_OBJECTS = $(am_libsub_utils_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -154,17 +153,13 @@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 noinst_LIBRARIES = libsub_utils.a
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
-	file_stat.cc \
-	file_stat.h \
-	list_focus.h \
-	parse.cc \
-	parse.h
+	list_focus.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .cc .o .obj
@@ -209,14 +204,12 @@
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directory.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file_stat.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	if $(CXXCOMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCXX_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils: parse.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.1/src/utils: parse.h
