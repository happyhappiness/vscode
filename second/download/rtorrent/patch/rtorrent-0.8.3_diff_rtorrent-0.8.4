diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/configure	2008-09-12 06:26:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/configure	2008-11-19 17:05:40.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.62 for rtorrent 0.8.3.
+# Generated by GNU Autoconf 2.62 for rtorrent 0.8.4.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
@@ -747,14 +747,14 @@
 MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.8.3'
-PACKAGE_STRING='rtorrent 0.8.3'
+PACKAGE_VERSION='0.8.4'
+PACKAGE_STRING='rtorrent 0.8.4'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #ifdef HAVE_SYS_TYPES_H
@@ -1499,13 +1499,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.8.3 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.8.4 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1569,13 +1569,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.8.3:";;
+     short | recursive ) echo "Configuration of rtorrent 0.8.4:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-option-checking  ignore unrecognized --enable/--with options
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
@@ -1697,13 +1697,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.8.3
+rtorrent configure 0.8.4
 generated by GNU Autoconf 2.62
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
@@ -1711,13 +1711,13 @@
   exit
 fi
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.8.3, which was
+It was created by rtorrent $as_me 0.8.4, which was
 generated by GNU Autoconf 2.62.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -2426,13 +2426,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.8.3'
+ VERSION='0.8.4'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -22475,34 +22475,34 @@
 $as_echo_n "checking for libtorrent... " >&6; }
 
 if test -n "$libtorrent_CFLAGS"; then
     pkg_cv_libtorrent_CFLAGS="$libtorrent_CFLAGS"
  elif test -n "$PKG_CONFIG"; then
     if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libtorrent >= 0.12.2\"") >&5
-  ($PKG_CONFIG --exists --print-errors "libtorrent >= 0.12.2") 2>&5
+    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libtorrent >= 0.12.4\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libtorrent >= 0.12.4") 2>&5
   ac_status=$?
   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_libtorrent_CFLAGS=`$PKG_CONFIG --cflags "libtorrent >= 0.12.2" 2>/dev/null`
+  pkg_cv_libtorrent_CFLAGS=`$PKG_CONFIG --cflags "libtorrent >= 0.12.4" 2>/dev/null`
 else
   pkg_failed=yes
 fi
  else
     pkg_failed=untried
 fi
 if test -n "$libtorrent_LIBS"; then
     pkg_cv_libtorrent_LIBS="$libtorrent_LIBS"
  elif test -n "$PKG_CONFIG"; then
     if test -n "$PKG_CONFIG" && \
-    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libtorrent >= 0.12.2\"") >&5
-  ($PKG_CONFIG --exists --print-errors "libtorrent >= 0.12.2") 2>&5
+    { ($as_echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"libtorrent >= 0.12.4\"") >&5
+  ($PKG_CONFIG --exists --print-errors "libtorrent >= 0.12.4") 2>&5
   ac_status=$?
   $as_echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_libtorrent_LIBS=`$PKG_CONFIG --libs "libtorrent >= 0.12.2" 2>/dev/null`
+  pkg_cv_libtorrent_LIBS=`$PKG_CONFIG --libs "libtorrent >= 0.12.4" 2>/dev/null`
 else
   pkg_failed=yes
 fi
  else
     pkg_failed=untried
 fi
@@ -22514,31 +22514,31 @@
 if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
         _pkg_short_errors_supported=yes
 else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        libtorrent_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "libtorrent >= 0.12.2" 2>&1`
+	        libtorrent_PKG_ERRORS=`$PKG_CONFIG --short-errors --print-errors "libtorrent >= 0.12.4" 2>&1`
         else
-	        libtorrent_PKG_ERRORS=`$PKG_CONFIG --print-errors "libtorrent >= 0.12.2" 2>&1`
+	        libtorrent_PKG_ERRORS=`$PKG_CONFIG --print-errors "libtorrent >= 0.12.4" 2>&1`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$libtorrent_PKG_ERRORS" >&5
 
-	{ { $as_echo "$as_me:$LINENO: error: Package requirements (libtorrent >= 0.12.2) were not met:
+	{ { $as_echo "$as_me:$LINENO: error: Package requirements (libtorrent >= 0.12.4) were not met:
 
 $libtorrent_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
 Alternatively, you may set the environment variables libtorrent_CFLAGS
 and libtorrent_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 " >&5
-$as_echo "$as_me: error: Package requirements (libtorrent >= 0.12.2) were not met:
+$as_echo "$as_me: error: Package requirements (libtorrent >= 0.12.4) were not met:
 
 $libtorrent_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
@@ -23211,13 +23211,13 @@
 exec 6>&1
 
 # Save the log message, to keep $[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by rtorrent $as_me 0.8.3, which was
+This file was extended by rtorrent $as_me 0.8.4, which was
 generated by GNU Autoconf 2.62.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -23264,13 +23264,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_version="\\
-rtorrent config.status 0.8.3
+rtorrent config.status 0.8.4
 configured by $0, generated by GNU Autoconf 2.62,
   with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2008 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/configure.ac	2008-09-12 06:21:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/configure.ac	2008-11-19 17:03:45.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.8.3, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.8.4, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 AC_PROG_CXX
 AC_PROG_LIBTOOL
@@ -31,13 +31,13 @@
 		  LIBS="$LIBS $sigc_LIBS")
 
 PKG_CHECK_MODULES(libcurl, libcurl >= 7.15.4,
 	          CXXFLAGS="$CXXFLAGS $libcurl_CFLAGS";
 		  LIBS="$LIBS $libcurl_LIBS")
 
-PKG_CHECK_MODULES(libtorrent, libtorrent >= 0.12.2,
+PKG_CHECK_MODULES(libtorrent, libtorrent >= 0.12.4,
 	          CXXFLAGS="$CXXFLAGS $libtorrent_CFLAGS";
 		  LIBS="$LIBS $libtorrent_LIBS")
 
 AC_LANG_PUSH(C++)
 TORRENT_WITH_XMLRPC_C
 AC_LANG_POP(C++)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/rak/functional_fun.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/rak/functional_fun.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/rak/functional_fun.h	2008-05-07 20:19:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/rak/functional_fun.h	2008-09-23 22:51:26.000000000 +0800
@@ -136,12 +136,32 @@
   Result operator () (Arg1 arg1, Arg2 arg2) { return (*m_base)(arg1, arg2); }
 
 private:
   std::auto_ptr<base_type> m_base;
 };
 
+template <typename Result, typename Arg2>
+class function2<Result, void, Arg2> {
+public:
+  typedef Result                             result_type;
+  typedef function_base1<Result, Arg2>       base_type;
+
+  bool                is_valid() const     { return m_base.get() != NULL; }
+
+  void                set(base_type* base) { m_base = std::auto_ptr<base_type>(base); }
+  base_type*          release()            { return m_base.release(); }
+
+  Result operator () (Arg2 arg2)           { return (*m_base)(arg2); }
+
+  template <typename Discard>
+  Result operator () (Discard discard, Arg2 arg2) { return (*m_base)(arg2); }
+
+private:
+  std::auto_ptr<base_type> m_base;
+};
+
 template <typename Result, typename Arg1, typename Arg2, typename Arg3>
 class function3 {
 public:
   typedef Result                                   result_type;
   typedef function_base3<Result, Arg1, Arg2, Arg3> base_type;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/rak/string_manip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/rak/string_manip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/rak/string_manip.h	2008-05-07 20:19:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/rak/string_manip.h	2008-11-11 00:54:02.000000000 +0800
@@ -299,9 +299,60 @@
 
   std::generate_n(std::back_inserter(s), length, &::random);
 
   return s;
 }
 
+template <typename Iterator>
+inline bool
+is_all_alpha(Iterator first, Iterator last) {
+  while (first != last)
+    if (!std::isalpha(*first++, std::locale::classic()))
+      return false;
+
+  return true;
+}
+
+template <typename Sequence>
+inline bool
+is_all_alpha(const Sequence& src) {
+  return is_all_alpha(src.begin(), src.end());
+}
+
+template <typename Iterator>
+inline bool
+is_all_alnum(Iterator first, Iterator last) {
+  while (first != last)
+    if (!std::isalnum(*first++, std::locale::classic()))
+      return false;
+
+  return true;
+}
+
+template <typename Sequence>
+inline bool
+is_all_alnum(const Sequence& src) {
+  return is_all_alnum(src.begin(), src.end());
+}
+
+template <typename Iterator>
+inline bool
+is_all_name(Iterator first, Iterator last) {
+  while (first != last) {
+    if (!std::isalnum(*first, std::locale::classic()) && *first != '_')
+      return false;
+
+    first++;
+  }
+
+  return true;
+}
+
+template <typename Sequence>
+inline bool
+is_all_name(const Sequence& src) {
+  return is_all_name(src.begin(), src.end());
+}
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_download.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_download.cc	2008-11-20 01:01:20.000000000 +0800
@@ -38,42 +38,45 @@
 
 #include <functional>
 #include <unistd.h>
 #include <rak/file_stat.h>
 #include <rak/error_number.h>
 #include <rak/path.h>
+#include <rak/socket_address.h>
 #include <rak/string_manip.h>
 #include <torrent/rate.h>
 #include <torrent/tracker.h>
+#include <torrent/connection_manager.h>
 #include <torrent/data/file.h>
 #include <torrent/data/file_list.h>
 #include <torrent/peer/connection_list.h>
 #include <torrent/peer/peer_list.h>
 
 #include "core/download.h"
+#include "core/download_store.h"
 #include "core/manager.h"
 #include "rpc/command_variable.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 std::string
 retrieve_d_base_path(core::Download* download) {
   if (download->file_list()->is_multi_file())
-    return download->file_list()->root_dir();
+    return download->file_list()->frozen_root_dir();
   else
-    return download->file_list()->at(0)->frozen_path();
+    return download->file_list()->empty() ? std::string() : download->file_list()->at(0)->frozen_path();
 }
 
 std::string
 retrieve_d_base_filename(core::Download* download) {
   const std::string* base;
 
   if (download->file_list()->is_multi_file())
-    base = &download->file_list()->root_dir();
+    base = &download->file_list()->frozen_root_dir();
   else
     base = &download->file_list()->at(0)->frozen_path();
 
   std::string::size_type split = base->rfind('/');
 
   if (split == std::string::npos)
@@ -258,12 +261,48 @@
   if (!rpc::call_command_string("get_tracker_dump").empty())
     download->download()->signal_tracker_dump(sigc::ptr_fun(&core::receive_tracker_dump));
 
   return torrent::Object();
 }
 
+struct call_add_d_peer_t {
+  call_add_d_peer_t(core::Download* d, int port) : m_download(d), m_port(port) { }
+
+  void operator() (const sockaddr* sa, int err) {
+    if (sa == NULL)
+      control->core()->push_log("Could not resolve host.");
+    else
+      m_download->download()->add_peer(sa, m_port);
+  }
+
+  core::Download* m_download;
+  int m_port;
+};
+
+void
+apply_d_add_peer(core::Download* download, const std::string& arg) {
+  int port, ret;
+  char dummy;
+  char host[1024];
+
+  if (download->download()->is_private())
+    throw torrent::input_error("Download is private.");
+
+  ret = std::sscanf(arg.c_str(), "%1023[^:]:%i%c", host, &port, &dummy);
+
+  if (ret == 1)
+    port = 6881;
+  else if (ret != 2)
+    throw torrent::input_error("Could not parse host.");
+
+  if (port < 1 || port > 65535)
+    throw torrent::input_error("Invalid port number.");
+
+  torrent::connection_manager()->resolver()(host, (int)rak::socket_address::pf_inet, SOCK_STREAM, call_add_d_peer_t(download, port));
+}
+
 torrent::Object
 f_multicall(core::Download* download, const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.empty())
     throw torrent::input_error("Too few arguments.");
@@ -342,12 +381,63 @@
     }
   }
 
   return resultRaw;
 }
 
+inline torrent::Object&
+d_object_wrapper(const std::pair<const char*, const char*> keyPair, core::Download* download) {
+  if (keyPair.first == NULL)
+    return download->bencode()->get_key(keyPair.second);
+  else
+    return download->bencode()->get_key(keyPair.first).get_key(keyPair.second);
+}
+
+torrent::Object
+d_object_get(const std::pair<const char*, const char*> keyPair, core::Download* download, __UNUSED const torrent::Object& rawArgs) {
+  return d_object_wrapper(keyPair, download);
+}
+
+torrent::Object
+d_list_push_back(const std::pair<const char*, const char*> keyPair, core::Download* download, const torrent::Object& rawArgs) {
+  d_object_wrapper(keyPair, download).as_list().push_back(rawArgs);
+
+  return torrent::Object();
+}
+
+torrent::Object
+d_list_push_back_unique(const std::pair<const char*, const char*> keyPair, core::Download* download, const torrent::Object& rawArgs) {
+  const torrent::Object& args = (rawArgs.is_list() && !rawArgs.as_list().empty()) ? rawArgs.as_list().front() : rawArgs;
+  torrent::Object::list_type& list = d_object_wrapper(keyPair, download).as_list();
+
+  if (std::find_if(list.begin(), list.end(),
+                   rak::bind1st(std::ptr_fun(&torrent::object_equal), args)) == list.end())
+    list.push_back(rawArgs);
+
+  return torrent::Object();
+}
+
+torrent::Object
+d_list_has(const std::pair<const char*, const char*> keyPair, core::Download* download, const torrent::Object& rawArgs) {
+  const torrent::Object& args = (rawArgs.is_list() && !rawArgs.as_list().empty()) ? rawArgs.as_list().front() : rawArgs;
+  torrent::Object::list_type& list = d_object_wrapper(keyPair, download).as_list();
+
+  return (int64_t)(std::find_if(list.begin(), list.end(),
+                                rak::bind1st(std::ptr_fun(&torrent::object_equal), args)) != list.end());
+}
+
+torrent::Object
+d_list_remove(const std::pair<const char*, const char*> keyPair, core::Download* download, const torrent::Object& rawArgs) {
+  const torrent::Object& args = (rawArgs.is_list() && !rawArgs.as_list().empty()) ? rawArgs.as_list().front() : rawArgs;
+  torrent::Object::list_type& list = d_object_wrapper(keyPair, download).as_list();
+
+  list.erase(std::remove_if(list.begin(), list.end(), rak::bind1st(std::ptr_fun(&torrent::object_equal), args)), list.end());
+
+  return torrent::Object();
+}
+
 #define ADD_CD_SLOT(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
   rpc::commands.insert_type(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CD_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
@@ -365,12 +455,15 @@
 #define ADD_CD_LIST_OBSOLETE(key, slot) \
   ADD_CD_SLOT_PUBLIC(key, call_list, slot, "i:", "")
 
 #define ADD_CD_LIST(key, slot) \
   ADD_CD_SLOT_PUBLIC("d." key, call_list, slot, "i:", "")
 
+#define ADD_CD_STRING(key, slot) \
+  ADD_CD_SLOT_PUBLIC("d." key, call_string, rpc::object_string_fn<core::Download*>(slot), "i:s", "")
+
 #define ADD_CD_VARIABLE_VALUE(key, firstKey, secondKey) \
   ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
   ADD_CD_SLOT       ("d.set_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
 
 #define ADD_CD_VARIABLE_VALUE_PUBLIC(key, firstKey, secondKey) \
   ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
@@ -431,27 +524,31 @@
   ADD_CD_LIST_OBSOLETE("delete_link",   rak::bind_ptr_fn(&apply_d_change_link, 1));
 
   ADD_CD_LIST("create_link",   rak::bind_ptr_fn(&apply_d_change_link, 0));
   ADD_CD_LIST("delete_link",   rak::bind_ptr_fn(&apply_d_change_link, 1));
   ADD_CD_V_VOID("delete_tied", &apply_d_delete_tied);
 
-  ADD_ANY_NONE("d.start",     rak::bind_ptr_fn(&cmd_call, "d.set_hashing_failed=0 ;d.set_state=1 ;view.set_not_visible=stopped ;view.set_visible=started"));
-  ADD_ANY_NONE("d.stop",      rak::bind_ptr_fn(&cmd_call, "d.set_state=0 ;view.set_visible=stopped ;view.set_not_visible=started"));
-  ADD_ANY_NONE("d.try_start", rak::bind_ptr_fn(&cmd_call, "branch=\"or={d.get_hashing_failed=,d.get_ignore_commands=}\",{},{d.set_state=1,view.set_not_visible=stopped,view.set_visible=started}"));
-  ADD_ANY_NONE("d.try_stop",  rak::bind_ptr_fn(&cmd_call, "branch=d.get_ignore_commands=, {}, {d.set_state=0, view.set_visible=stopped, view.set_not_visible=started}"));
-  ADD_ANY_NONE("d.try_close", rak::bind_ptr_fn(&cmd_call, "branch=d.get_ignore_commands=, {}, {d.set_state=0, view.set_visible=stopped, view.set_not_visible=started, d.close=}"));
+  CMD_FUNC_SINGLE("d.start",     "d.set_hashing_failed=0 ;view.set_visible=started");
+  CMD_FUNC_SINGLE("d.stop",      "view.set_visible=stopped");
+  CMD_FUNC_SINGLE("d.try_start", "branch=\"or={d.get_hashing_failed=,d.get_ignore_commands=}\",{},{view.set_visible=started}");
+  CMD_FUNC_SINGLE("d.try_stop",  "branch=d.get_ignore_commands=, {}, {view.set_visible=stopped}");
+  CMD_FUNC_SINGLE("d.try_close", "branch=d.get_ignore_commands=, {}, {view.set_visible=stopped, d.close=}");
 
   ADD_CD_F_VOID("resume",     rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::resume_default));
   ADD_CD_F_VOID("pause",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::pause_default));
   ADD_CD_F_VOID("open",       rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::open_throw));
   ADD_CD_F_VOID("close",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::close_throw));
   ADD_CD_F_VOID("erase",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::erase_ptr));
   ADD_CD_F_VOID("check_hash", rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::check_hash));
 
+  ADD_CD_F_VOID("save_session",     rak::make_mem_fun(control->core()->download_store(), &core::DownloadStore::save));
+
   ADD_CD_F_VOID("update_priorities", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::update_priorities)));
 
+  ADD_CD_STRING("add_peer",        std::ptr_fun(&apply_d_add_peer));
+
   ADD_CD_VALUE("is_open",          rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_open)));
   ADD_CD_VALUE("is_active",        rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_active)));
   ADD_CD_VALUE("is_hash_checked",  rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_hash_checked)));
   ADD_CD_VALUE("is_hash_checking", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_hash_checking)));
   ADD_CD_VALUE("is_multi_file",    rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::is_multi_file)));
   ADD_CD_VALUE("is_private",       rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_private)));
@@ -498,12 +595,18 @@
   ADD_CD_STRING_BI("connection_current", std::ptr_fun(&apply_d_connection_type), std::ptr_fun(&retrieve_d_connection_type));
   ADD_CD_VARIABLE_STRING("connection_leech",      "rtorrent", "connection_leech");
   ADD_CD_VARIABLE_STRING("connection_seed",       "rtorrent", "connection_seed");
 
   ADD_CD_VALUE_BI("hashing_failed",      std::mem_fun(&core::Download::set_hash_failed), std::mem_fun(&core::Download::is_hash_failed));
 
+  CMD_D("d.views",                  rak::bind_ptr_fn(&d_object_get, std::make_pair("rtorrent", "views")));
+  CMD_D("d.views.has",              rak::bind_ptr_fn(&d_list_has, std::make_pair("rtorrent", "views")));
+  CMD_D("d.views.remove",           rak::bind_ptr_fn(&d_list_remove, std::make_pair("rtorrent", "views")));
+  CMD_D("d.views.push_back",        rak::bind_ptr_fn(&d_list_push_back, std::make_pair("rtorrent", "views")));
+  CMD_D("d.views.push_back_unique", rak::bind_ptr_fn(&d_list_push_back_unique, std::make_pair("rtorrent", "views")));
+
   // This command really needs to be improved, so we have proper
   // logging support.
   ADD_CD_STRING_BI("message",            std::mem_fun(&core::Download::set_message), std::mem_fun(&core::Download::message));
 
   ADD_CD_VALUE_MEM_BI("max_file_size", &core::Download::file_list, &torrent::FileList::set_max_file_size, &torrent::FileList::max_file_size);
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src: command_dynamic.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_events.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_events.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_events.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_events.cc	2008-11-11 18:37:20.000000000 +0800
@@ -56,13 +56,13 @@
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 torrent::Object
-apply_on_state_change(core::DownloadList::slot_map* slotMap, const torrent::Object& rawArgs) {
+apply_on_state_change(const char* name, const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.size() == 0 || args.size() > 2)
     throw torrent::input_error("Wrong number of arguments.");
 
   const std::string& rawKey = args.front().as_string();
@@ -73,65 +73,75 @@
   // If the key starts with '_' then it's supposed to be literal, with
   // the initial '_' removed. This allows us to get proper ordering
   // for internal rtorrent tasks.
   std::string key = rawKey[0] != '_' ? ("1_state_" + rawKey) : rawKey.substr(1);
 
   if (args.size() == 1)
-    slotMap->erase(key);
+    rpc::commands.call("system.method.set_key", rpc::make_target(), rpc::create_object_list(name, key));
   else
-    (*slotMap)[key] = args.back().as_string();
+    rpc::commands.call("system.method.set_key", rpc::make_target(), rpc::create_object_list(name, key, args.back()));
+
+  // Deprecated notice, remove this function in the next minor
+  // version.
+  static bool notify = true;
+
+  if (notify) {
+    control->core()->push_log("Deprecated on_* commands, use 'system.method.set_key = event.download.{inserted, erased, ...}, <key>, <command>' instead.");
+    notify = false;
+  }
 
   return torrent::Object();
 }
 
 torrent::Object
-apply_on_ratio(int action, const torrent::Object& rawArgs) {
-  const torrent::Object::list_type& args = rawArgs.as_list();
+apply_on_ratio(const torrent::Object& rawArgs) {
+  const std::string& groupName = rawArgs.as_string();
 
-  if (args.empty())
-    throw torrent::input_error("Too few arguments.");
+  char buffer[32 + groupName.size()];
+  sprintf(buffer, "group.%s.view", groupName.c_str());
+
+  core::ViewManager::iterator viewItr = control->view_manager()->find(rpc::commands.call(buffer, rpc::make_target()).as_string());
 
-  torrent::Object::list_const_iterator argItr = args.begin();
+  if (viewItr == control->view_manager()->end())
+    throw torrent::input_error("Could not find view.");
+
+  char* bufferStart = buffer + sprintf(buffer, "group.%s.ratio.", groupName.c_str());
 
   // first argument:  minimum ratio to reach
   // second argument: minimum upload amount to reach [optional]
   // third argument:  maximum ratio to reach [optional]
-  int64_t minRatio  = rpc::convert_to_value(*argItr++);
-  int64_t minUpload = argItr != args.end() ? rpc::convert_to_value(*argItr++) : 0;
-  int64_t maxRatio  = argItr != args.end() ? rpc::convert_to_value(*argItr++) : 0;
+  std::strcpy(bufferStart, "min");
+  int64_t minRatio  = rpc::commands.call(buffer, rpc::make_target()).as_value();
+  std::strcpy(bufferStart, "max");
+  int64_t maxRatio  = rpc::commands.call(buffer, rpc::make_target()).as_value();
+  std::strcpy(bufferStart, "upload");
+  int64_t minUpload = rpc::commands.call(buffer, rpc::make_target()).as_value();
 
-  core::DownloadList* downloadList = control->core()->download_list();
+  std::vector<core::Download*> downloads;
 
-  for  (core::Manager::DListItr itr = downloadList->begin();
-        (itr = std::find_if(itr, downloadList->end(), std::mem_fun(&core::Download::is_seeding))) != downloadList->end(); ) {
-    core::Download* current = *itr++;
+  for  (core::View::iterator itr = (*viewItr)->begin_visible(), last = (*viewItr)->end_visible(); itr != last; itr++) {
+    if (!(*itr)->is_seeding() || rpc::call_command_value("d.get_ignore_commands", rpc::make_target(*itr)) != 0)
+      continue;
+
+    //    rpc::parse_command_single(rpc::make_target(*itr), "print={Checked ratio of download.}");
 
-    int64_t totalDone   = current->download()->bytes_done();
-    int64_t totalUpload = current->download()->up_rate()->total();
+    int64_t totalDone   = (*itr)->download()->bytes_done();
+    int64_t totalUpload = (*itr)->download()->up_rate()->total();
 
     if (!(totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) &&
         !(maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio))
       continue;
 
-    bool success = true;
-
-    switch (action) {
-//     case core::DownloadList::SLOTS_CLOSE: success = downloadList->close_try(current); break;
-//     case core::DownloadList::SLOTS_STOP:  success = downloadList->stop_try(current); break;
-    case core::DownloadList::SLOTS_CLOSE: rpc::parse_command_single(rpc::make_target(current), "d.try_close="); break;
-    case core::DownloadList::SLOTS_STOP:  rpc::parse_command_single(rpc::make_target(current), "d.try_stop="); break;
-    default: success = false; break;
-    }
-
-    if (!success)
-      continue;
+    downloads.push_back(*itr);
+  }
 
-    rpc::call_command("d.set_ignore_commands", (int64_t)1, rpc::make_target(current));
+  std::strcpy(bufferStart, "command");
 
-    for (torrent::Object::list_const_iterator itr2 = argItr; itr2 != args.end(); itr2++)
-      rpc::parse_command_object(rpc::make_target(current), *itr2);
+  for (std::vector<core::Download*>::iterator itr = downloads.begin(), last = downloads.end(); itr != last; itr++) {
+    //    rpc::commands.call("print", rpc::make_target(*itr), "Calling ratio command.");
+    rpc::commands.call_catch(buffer, rpc::make_target(*itr), torrent::Object(), "Ratio reached, but command failed: ");
   }
 
   return torrent::Object();
 }
 
 torrent::Object
@@ -336,42 +346,31 @@
     }
   }
 
   return resultRaw;
 }
 
-torrent::Object
-cmd_call(const char* cmd, rpc::target_type target, const torrent::Object& rawArgs) {
-  rpc::parse_command_multiple(target, cmd);
-
-  return torrent::Object();
-}
-
-
 void
 initialize_command_events() {
-  core::DownloadList* downloadList = control->core()->download_list();
-
   ADD_VARIABLE_BOOL("check_hash", true);
 
   ADD_VARIABLE_BOOL("session_lock", true);
   ADD_VARIABLE_BOOL("session_on_completion", true);
 
-  ADD_COMMAND_LIST("on_insert",       rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_insert()));
-  ADD_COMMAND_LIST("on_erase",        rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_erase()));
-  ADD_COMMAND_LIST("on_open",         rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_open()));
-  ADD_COMMAND_LIST("on_close",        rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_close()));
-  ADD_COMMAND_LIST("on_start",        rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_start()));
-  ADD_COMMAND_LIST("on_stop",         rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_stop()));
-  ADD_COMMAND_LIST("on_hash_queued",  rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_queued()));
-  ADD_COMMAND_LIST("on_hash_removed", rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_removed()));
-  ADD_COMMAND_LIST("on_hash_done",    rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_done()));
-  ADD_COMMAND_LIST("on_finished",     rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_finished()));
+  // Deprecated.
+  ADD_COMMAND_LIST("on_insert",       rak::bind_ptr_fn(&apply_on_state_change, "event.download.inserted"));
+  ADD_COMMAND_LIST("on_erase" ,       rak::bind_ptr_fn(&apply_on_state_change, "event.download.erased"));
+  ADD_COMMAND_LIST("on_open",         rak::bind_ptr_fn(&apply_on_state_change, "event.download.opened"));
+  ADD_COMMAND_LIST("on_close",        rak::bind_ptr_fn(&apply_on_state_change, "event.download.closed"));
+  ADD_COMMAND_LIST("on_start",        rak::bind_ptr_fn(&apply_on_state_change, "event.download.resumed"));
+  ADD_COMMAND_LIST("on_stop",         rak::bind_ptr_fn(&apply_on_state_change, "event.download.paused"));
+  ADD_COMMAND_LIST("on_hash_queued",  rak::bind_ptr_fn(&apply_on_state_change, "event.download.hash_queued"));
+  ADD_COMMAND_LIST("on_hash_removed", rak::bind_ptr_fn(&apply_on_state_change, "event.download.hash_removed"));
+  ADD_COMMAND_LIST("on_finished",     rak::bind_ptr_fn(&apply_on_state_change, "event.download.finished"));
 
-  ADD_COMMAND_LIST("stop_on_ratio",   rak::bind_ptr_fn(&apply_on_ratio, (int)core::DownloadList::SLOTS_STOP));
-  ADD_COMMAND_LIST("close_on_ratio",  rak::bind_ptr_fn(&apply_on_ratio, (int)core::DownloadList::SLOTS_CLOSE));
+  ADD_COMMAND_STRING("on_ratio",      rak::ptr_fn(&apply_on_ratio));
 
   ADD_COMMAND_VOID("start_tied",      &apply_start_tied);
   ADD_COMMAND_VOID("stop_untied",     &apply_stop_untied);
   ADD_COMMAND_VOID("close_untied",    &apply_close_untied);
   ADD_COMMAND_VOID("remove_untied",   &apply_remove_untied);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_helpers.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_helpers.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_helpers.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_helpers.cc	2008-11-16 12:28:25.000000000 +0800
@@ -46,12 +46,14 @@
 #include "command_helpers.h"
 
 rpc::CommandSlot<void>    commandSlots[COMMAND_SLOTS_SIZE];
 rpc::CommandSlot<void>*   commandSlotsItr = commandSlots;
 rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
 rpc::CommandVariable*     commandVariablesItr = commandVariables;
+rpc::CommandObjectPtr     commandObjectPtrs[COMMAND_OBJECT_PTR_SIZE];
+rpc::CommandObjectPtr*    commandObjectPtrsItr = commandObjectPtrs;
 rpc::CommandSlot<core::Download*>             commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
 rpc::CommandSlot<core::Download*>*            commandDownloadSlotsItr = commandDownloadSlots;
 rpc::CommandSlot<torrent::File*>              commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
 rpc::CommandSlot<torrent::File*>*             commandFileSlotsItr = commandFileSlots;
 rpc::CommandSlot<torrent::FileListIterator*>  commandFileItrSlots[COMMAND_FILE_ITR_SLOTS_SIZE];
 rpc::CommandSlot<torrent::FileListIterator*>* commandFileItrSlotsItr = commandFileItrSlots;
@@ -59,24 +61,28 @@
 rpc::CommandSlot<torrent::Peer*>*             commandPeerSlotsItr = commandPeerSlots;
 rpc::CommandSlot<torrent::Tracker*>           commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
 rpc::CommandSlot<torrent::Tracker*>*          commandTrackerSlotsItr = commandTrackerSlots;
 rpc::CommandSlot<rpc::target_type>            commandAnySlots[COMMAND_ANY_SLOTS_SIZE];
 rpc::CommandSlot<rpc::target_type>*           commandAnySlotsItr = commandAnySlots;
 
+void initialize_command_object();
+void initialize_command_dynamic();
 void initialize_command_download();
 void initialize_command_events();
 void initialize_command_file();
 void initialize_command_peer();
 void initialize_command_local();
 void initialize_command_network();
 void initialize_command_tracker();
 void initialize_command_scheduler();
 void initialize_command_ui();
 
 void
 initialize_commands() {
+  initialize_command_object();
+  initialize_command_dynamic();
   initialize_command_events();
   initialize_command_network();
   initialize_command_local();
   initialize_command_ui();
   initialize_command_download();
   initialize_command_file();
@@ -84,34 +90,36 @@
   initialize_command_tracker();
   initialize_command_scheduler();
 
 #ifdef ADDING_COMMANDS 
   if (commandSlotsItr > commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr > commandVariables + COMMAND_VARIABLES_SIZE ||
+      commandObjectPtrsItr > commandObjectPtrs + COMMAND_OBJECT_PTR_SIZE ||
       commandDownloadSlotsItr > commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr > commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
       commandFileItrSlotsItr > commandFileItrSlots + COMMAND_FILE_ITR_SLOTS_SIZE ||
       commandPeerSlotsItr > commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
       commandTrackerSlotsItr > commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE ||
       commandAnySlotsItr > commandAnySlots + COMMAND_ANY_SLOTS_SIZE)
 #else
   if (commandSlotsItr != commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr != commandVariables + COMMAND_VARIABLES_SIZE ||
+      commandObjectPtrsItr != commandObjectPtrs + COMMAND_OBJECT_PTR_SIZE ||
       commandDownloadSlotsItr != commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr != commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
       commandFileItrSlotsItr != commandFileItrSlots + COMMAND_FILE_ITR_SLOTS_SIZE ||
       commandPeerSlotsItr != commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
       commandTrackerSlotsItr != commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE ||
       commandAnySlotsItr != commandAnySlots + COMMAND_ANY_SLOTS_SIZE)
 #endif
     throw torrent::internal_error("initialize_commands() static command array size mismatch.");
 }
 
 void
 add_variable(const char* getKey, const char* setKey, const char* defaultSetKey,
-             rpc::Command::generic_slot getSlot, rpc::Command::generic_slot setSlot,
+             rpc::Command::cleaned_slot getSlot, rpc::Command::cleaned_slot setSlot,
              const torrent::Object& defaultObject) {
   rpc::CommandVariable* variable = commandVariablesItr++;
   variable->set_variable(defaultObject);
 
   rpc::commands.insert_type(getKey, variable, getSlot, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, "i:", "");
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_helpers.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_helpers.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_helpers.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_helpers.h	2008-11-16 13:42:21.000000000 +0800
@@ -35,22 +35,25 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UTILS_COMMAND_HELPERS_H
 #define RTORRENT_UTILS_COMMAND_HELPERS_H
 
 #include "rpc/command_slot.h"
+#include "rpc/command_function.h"
 #include "rpc/parse_commands.h"
 
 namespace rpc {
   class CommandVariable;
+  class CommandObjectPtr;
 }
 
 // By using a static array we avoid allocating the variables on the
 // heap. This should reduce memory use and improve cache locality.
 #define COMMAND_SLOTS_SIZE          200
 #define COMMAND_VARIABLES_SIZE      100
+#define COMMAND_OBJECT_PTR_SIZE     20
 #define COMMAND_DOWNLOAD_SLOTS_SIZE 150
 #define COMMAND_FILE_SLOTS_SIZE     30
 #define COMMAND_FILE_ITR_SLOTS_SIZE 10
 #define COMMAND_PEER_SLOTS_SIZE     20
 #define COMMAND_TRACKER_SLOTS_SIZE  15
 #define COMMAND_ANY_SLOTS_SIZE      50
@@ -58,12 +61,14 @@
 #define ADDING_COMMANDS
 
 extern rpc::CommandSlot<void>    commandSlots[COMMAND_SLOTS_SIZE];
 extern rpc::CommandSlot<void>*   commandSlotsItr;
 extern rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
 extern rpc::CommandVariable*     commandVariablesItr;
+extern rpc::CommandObjectPtr     commandObjectPtrs[COMMAND_OBJECT_PTR_SIZE];
+extern rpc::CommandObjectPtr*    commandObjectPtrsItr;
 extern rpc::CommandSlot<core::Download*>             commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
 extern rpc::CommandSlot<core::Download*>*            commandDownloadSlotsItr;
 extern rpc::CommandSlot<torrent::File*>              commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
 extern rpc::CommandSlot<torrent::File*>*             commandFileSlotsItr;
 extern rpc::CommandSlot<torrent::FileListIterator*>  commandFileItrSlots[COMMAND_FILE_ITR_SLOTS_SIZE];
 extern rpc::CommandSlot<torrent::FileListIterator*>* commandFileItrSlotsItr;
@@ -75,17 +80,15 @@
 extern rpc::CommandSlot<rpc::target_type>*           commandAnySlotsItr;
 
 void initialize_commands();
 
 void
 add_variable(const char* getKey, const char* setKey, const char* defaultSetKey,
-             rpc::Command::generic_slot getSlot, rpc::Command::generic_slot setSlot,
+             rpc::Command::cleaned_slot getSlot, rpc::Command::cleaned_slot setSlot,
              const torrent::Object& defaultObject);
 
-extern torrent::Object cmd_call(const char* cmd, rpc::target_type target, const torrent::Object& rawArgs);
-
 #define ADD_VARIABLE_BOOL(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_bool, &rpc::CommandVariable::set_bool, (int64_t)defaultValue);
 
 #define ADD_VARIABLE_VALUE(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_value, &rpc::CommandVariable::set_value, (int64_t)defaultValue);
 
@@ -191,20 +194,45 @@
 #define CMD_G(key, slot) \
   CMD_G_SLOT(key, call_unknown, slot, "i:", "")
 
 #define CMD_G_STRING(key, slot) \
   CMD_G_SLOT(key, call_string, slot, "i:", "")
 
+#define CMD_N_SLOT(key, function, slot, parm, doc)    \
+  commandAnySlotsItr->set_slot(slot); \
+  rpc::commands.insert_type(key, commandAnySlotsItr++, &rpc::CommandSlot<rpc::target_type>::function, \
+                            rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_no_target | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+
+#define CMD_N(key, slot) \
+  CMD_N_SLOT(key, call_unknown, slot, "i:", "")
+
+#define CMD_N_STRING(key, slot) \
+  CMD_N_SLOT(key, call_string, slot, "i:", "")
+
+#define CMD_N_LIST(key, slot) \
+  CMD_N_SLOT(key, call_list, slot, "i:", "")
+
 #define CMD_D_SLOT(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
-  rpc::commands.insert_type(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_type(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, \
+                            rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+
+#define CMD_D(key, slot) \
+  CMD_D_SLOT(key, call_unknown, slot, "i:", "")
 
 #define CMD_D_ANY(key, slot) \
   CMD_D_SLOT(key, call_unknown, slot, "i:", "")
 
 #define CMD_D_STRING(key, slot) \
   CMD_D_SLOT(key, call_string, slot, "i:", "")
 
 #define CMD_D_VOID(key, slot) \
   CMD_D_SLOT(key, call_unknown, rpc::object_fn(slot), "i:", "")
 
+#define CMD_FUNC_SINGLE(key, command) \
+  rpc::commands.insert_type(key, new rpc::CommandFunction(command), &rpc::CommandFunction::call, rpc::CommandMap::flag_public_xmlrpc, NULL, NULL);
+
+#define CMD_OBJ_P(key, function, target) \
+  commandObjectPtrsItr->set_object(target); \
+  rpc::commands.insert_type(key, commandObjectPtrsItr++, &rpc::CommandObjectPtr::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, NULL, NULL);
+
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_local.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_local.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_local.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_local.cc	2008-11-11 01:06:46.000000000 +0800
@@ -45,12 +45,13 @@
 #include <torrent/torrent.h>
 #include <torrent/chunk_manager.h>
 
 #include "core/download_list.h"
 #include "core/download_store.h"
 #include "core/manager.h"
+#include "rak/string_manip.h"
 #include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
 #include "rpc/parse_commands.h"
 #include "utils/file_status_cache.h"
 
 #include "globals.h"
@@ -113,12 +114,48 @@
   if (::chdir(rawArgs.as_string().c_str()) != 0)
     throw torrent::input_error("Could not change current working directory.");
 
   return torrent::Object();
 }
 
+inline torrent::Object::list_const_iterator
+post_increment(torrent::Object::list_const_iterator& itr, const torrent::Object::list_const_iterator& last) {
+  if (itr == last)
+    throw torrent::input_error("Invalid number of arguments.");
+
+  return itr++;
+}
+
+inline const std::string&
+check_name(const std::string& str) {
+  if (!rak::is_all_name(str))
+    throw torrent::input_error("Non-alphanumeric characters found.");
+
+  return str;
+}  
+
+torrent::Object
+group_insert(__UNUSED rpc::target_type target, const torrent::Object& rawArgs) {
+  torrent::Object::list_const_iterator itr = rawArgs.as_list().begin();
+  torrent::Object::list_const_iterator last = rawArgs.as_list().end();
+
+  const std::string& name = check_name(post_increment(itr, last)->as_string());
+  const std::string& view = check_name(post_increment(itr, last)->as_string());
+
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".view", "string", view));
+
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".ratio.enable", "simple", "schedule=group." + name + ".ratio,5,60,on_ratio=" + name));
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".ratio.disable", "simple", "schedule_remove=group." + name + ".ratio"));
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".ratio.command", "simple", "d.try_close= ;d.set_ignore_commands=1"));
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".ratio.min", "value", (int64_t)200));
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".ratio.max", "value", (int64_t)300));
+  rpc::commands.call("system.method.insert", rpc::create_object_list("group." + name + ".ratio.upload", "value", (int64_t)20 << 20));
+
+  return name;
+}
+
 void
 initialize_command_local() {
   torrent::ChunkManager* chunkManager = torrent::chunk_manager();
   core::DownloadList*    dList = control->core()->download_list();
   core::DownloadStore*   dStore = control->core()->download_store();
 
@@ -166,7 +203,18 @@
   ADD_COMMAND_LIST("execute",             rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_throw | rpc::ExecFile::flag_expand_tilde));
   ADD_COMMAND_LIST("execute_nothrow",     rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_expand_tilde));
   ADD_COMMAND_LIST("execute_raw",         rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_throw));
   ADD_COMMAND_LIST("execute_raw_nothrow", rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, 0));
 
   ADD_COMMAND_STRING_UN("execute_log",    std::ptr_fun(&apply_execute_log));
+
+  *rpc::Command::argument(0) = "placeholder.0";
+  *rpc::Command::argument(1) = "placeholder.1";
+  *rpc::Command::argument(2) = "placeholder.2";
+  *rpc::Command::argument(3) = "placeholder.3";
+  CMD_OBJ_P("argument.0", get_generic, rpc::Command::argument(0));
+  CMD_OBJ_P("argument.1", get_generic, rpc::Command::argument(1));
+  CMD_OBJ_P("argument.2", get_generic, rpc::Command::argument(2));
+  CMD_OBJ_P("argument.3", get_generic, rpc::Command::argument(3));
+
+  CMD_N_LIST("group.insert", rak::ptr_fn(&group_insert));
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src: command_object.cc
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_ui.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_ui.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/command_ui.cc	2008-08-27 04:14:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/command_ui.cc	2008-11-16 15:28:51.000000000 +0800
@@ -392,12 +392,34 @@
 torrent::Object
 cmd_view_size_not_visible(__UNUSED rpc::target_type target, const torrent::Object& rawArgs) {
   return (*control->view_manager()->find_throw(rawArgs.as_string()))->size_not_visible();
 }
 
 torrent::Object
+cmd_view_persistent(__UNUSED rpc::target_type target, const torrent::Object& rawArgs) {
+  const std::string& args = rawArgs.as_string();
+  core::View* view = *control->view_manager()->find_throw(args);
+  
+  if (!view->get_filter().empty() || !view->get_event_added().empty() || !view->get_event_removed().empty())
+    throw torrent::input_error("Cannot set modified views as persitent.");
+
+  view->set_filter("d.views.has=" + args);
+  view->set_event_added("d.views.push_back_unique=" + args);
+  view->set_event_removed("d.views.remove=" + args);
+
+  return torrent::Object();
+}
+
+torrent::Object
+cmd_ui_set_view(__UNUSED rpc::target_type target, const torrent::Object& rawArgs) {
+  control->ui()->download_list()->set_current_view(rawArgs.as_string());
+
+  return torrent::Object();
+}
+
+torrent::Object
 cmd_ui_unfocus_download(core::Download* download, const torrent::Object& rawArgs) {
   control->ui()->download_list()->unfocus_download(download);
 
   return torrent::Object();
 }
 
@@ -441,20 +463,23 @@
   ADD_COMMAND_LIST("view.event_removed", rak::bind_ptr_fn(&apply_view_cfilter, &core::ViewManager::set_event_removed));
 
   // Cleanup and add . to view.
 
   CMD_G_STRING("view.size",              rak::ptr_fn(&cmd_view_size));
   CMD_G_STRING("view.size_not_visible",  rak::ptr_fn(&cmd_view_size_not_visible));
+  CMD_G_STRING("view.persistent",        rak::ptr_fn(&cmd_view_persistent));
+
   CMD_D_STRING("view.filter_download",   rak::ptr_fn(&cmd_view_filter_download));
   CMD_D_STRING("view.set_visible",       rak::ptr_fn(&cmd_view_set_visible));
   CMD_D_STRING("view.set_not_visible",   rak::ptr_fn(&cmd_view_set_not_visible));
 
   // Commands that affect the default rtorrent UI.
 
 //   ADD_ANY_NONE("ui.focus",              rak::ptr_fn(&cmd_ui_focus));
-  CMD_D_ANY("ui.unfocus_download",     rak::ptr_fn(&cmd_ui_unfocus_download));
+  CMD_D_ANY("ui.unfocus_download",      rak::ptr_fn(&cmd_ui_unfocus_download));
+  CMD_N_STRING("ui.current_view.set",   rak::ptr_fn(&cmd_ui_set_view));
 
   // Move.
 
   ADD_ANY_NONE("print",                 rak::ptr_fn(&apply_print));
   ADD_ANY_NONE("cat",                   rak::ptr_fn(&apply_cat));
   ADD_ANY_NONE("if",                    rak::bind_ptr_fn(&apply_if, 0));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/control.cc	2008-08-27 16:25:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/control.cc	2008-10-02 20:07:46.000000000 +0800
@@ -40,13 +40,12 @@
 #include <sys/stat.h>
 #include <torrent/connection_manager.h>
 
 #include "core/manager.h"
 #include "core/download_store.h"
 #include "core/view_manager.h"
-#include "core/scheduler.h"
 #include "core/dht_manager.h"
 
 #include "display/canvas.h"
 #include "display/window.h"
 #include "display/manager.h"
 #include "input/manager.h"
@@ -72,13 +71,12 @@
   m_scgi(NULL),
 
   m_tick(0) {
 
   m_core        = new core::Manager();
   m_viewManager = new core::ViewManager();
-  m_scheduler   = new core::Scheduler(m_core->download_list());
   m_dhtManager  = new core::DhtManager();
 
   m_inputStdin->slot_pressed(sigc::mem_fun(m_input, &input::Manager::pressed));
 
   m_taskShutdown.set_slot(rak::mem_fn(this, &Control::handle_shutdown));
 
@@ -93,13 +91,12 @@
 
   delete m_viewManager;
 
   delete m_ui;
   delete m_display;
   delete m_core;
-  delete m_scheduler;
   delete m_dhtManager;
 }
 
 void
 Control::initialize() {
   display::Canvas::initialize();
@@ -111,13 +108,12 @@
 
   m_core->initialize_second();
   m_core->listen_open();
   m_core->download_store()->enable(rpc::call_command_value("get_session_lock"));
 
   m_core->set_hashing_view(*m_viewManager->find_throw("hashing"));
-  m_scheduler->set_view(*m_viewManager->find_throw("scheduler"));
 
   m_ui->init(this);
 
   m_inputStdin->insert(m_core->get_poll_manager()->get_torrent_poll());
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/control.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/control.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/control.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/control.h	2008-10-02 20:07:28.000000000 +0800
@@ -47,13 +47,12 @@
   class Root;
 }
 
 namespace core {
   class Manager;
   class ViewManager;
-  class Scheduler;
   class DhtManager;
 }
 
 namespace display {
   class Manager;
 }
@@ -87,13 +86,12 @@
 
   void                receive_normal_shutdown()     { m_shutdownReceived = true; }
   void                receive_quick_shutdown()      { m_shutdownReceived = true; m_shutdownQuick = true; }
 
   core::Manager*      core()                        { return m_core; }
   core::ViewManager*  view_manager()                { return m_viewManager; }
-  core::Scheduler*    scheduler()                   { return m_scheduler; }
   core::DhtManager*   dht_manager()                 { return m_dhtManager; }
 
   torrent::Poll*      poll();
 
   ui::Root*           ui()                          { return m_ui; }
   display::Manager*   display()                     { return m_display; }
@@ -117,13 +115,12 @@
 
   bool                m_shutdownReceived;
   bool                m_shutdownQuick;
 
   core::Manager*      m_core;
   core::ViewManager*  m_viewManager;
-  core::Scheduler*    m_scheduler;
   core::DhtManager*   m_dhtManager;
 
   ui::Root*           m_ui;
   display::Manager*   m_display;
   input::Manager*     m_input;
   input::InputEvent*  m_inputStdin;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_get.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_get.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_get.cc	2008-09-02 01:43:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_get.cc	2008-10-22 20:58:11.000000000 +0800
@@ -38,12 +38,13 @@
 
 #include <iostream>
 #include <curl/curl.h>
 #include <curl/easy.h>
 #include <torrent/exceptions.h>
 
+#include "globals.h"
 #include "curl_get.h"
 #include "curl_stack.h"
 
 namespace core {
 
 size_t
@@ -70,38 +71,49 @@
 
   curl_easy_setopt(m_handle, CURLOPT_URL,            m_url.c_str());
   curl_easy_setopt(m_handle, CURLOPT_WRITEFUNCTION,  &curl_get_receive_write);
   curl_easy_setopt(m_handle, CURLOPT_WRITEDATA,      this);
 
   if (m_timeout != 0) {
-    curl_easy_setopt(m_handle, CURLOPT_CONNECTTIMEOUT, 60);
-    curl_easy_setopt(m_handle, CURLOPT_TIMEOUT,        m_timeout);
+    curl_easy_setopt(m_handle, CURLOPT_CONNECTTIMEOUT, (long)60);
+    curl_easy_setopt(m_handle, CURLOPT_TIMEOUT,        (long)m_timeout);
+
+    // Normally libcurl should handle the timeout. But sometimes that doesn't
+    // work right so we do a fallback timeout that just aborts the transfer.
+    m_taskTimeout.set_slot(rak::mem_fn(this, &CurlGet::receive_timeout));
+    priority_queue_erase(&taskScheduler, &m_taskTimeout);
+    priority_queue_insert(&taskScheduler, &m_taskTimeout, cachedTime + rak::timer::from_seconds(m_timeout + 5));
   }
 
-  curl_easy_setopt(m_handle, CURLOPT_FORBID_REUSE,   1);
-  curl_easy_setopt(m_handle, CURLOPT_NOSIGNAL,       1);
-  curl_easy_setopt(m_handle, CURLOPT_FOLLOWLOCATION, 1);
-  curl_easy_setopt(m_handle, CURLOPT_MAXREDIRS,      5);
+  curl_easy_setopt(m_handle, CURLOPT_FORBID_REUSE,   (long)1);
+  curl_easy_setopt(m_handle, CURLOPT_NOSIGNAL,       (long)1);
+  curl_easy_setopt(m_handle, CURLOPT_FOLLOWLOCATION, (long)1);
+  curl_easy_setopt(m_handle, CURLOPT_MAXREDIRS,      (long)5);
   curl_easy_setopt(m_handle, CURLOPT_IPRESOLVE,      CURL_IPRESOLVE_V4);
   curl_easy_setopt(m_handle, CURLOPT_ENCODING,       "");
 
   m_stack->add_get(this);
 }
 
 void
 CurlGet::close() {
+  priority_queue_erase(&taskScheduler, &m_taskTimeout);
   if (!is_busy())
     return;
 
   m_stack->remove_get(this);
 
   curl_easy_cleanup(m_handle);
 
   m_handle = NULL;
 }
 
+void
+CurlGet::receive_timeout() {
+  return m_stack->transfer_done(m_handle, "Timed out");
+}
 
 double
 CurlGet::size_done() {
   double d = 0.0;
   curl_easy_getinfo(m_handle, CURLINFO_SIZE_DOWNLOAD, &d);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_get.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_get.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_get.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_get.h	2008-10-22 20:58:11.000000000 +0800
@@ -40,12 +40,14 @@
 #include <iosfwd>
 #include <string>
 #include <curl/curl.h>
 #include <sigc++/signal.h>
 #include <torrent/http.h>
 
+#include "rak/priority_queue_default.h"
+
 namespace core {
 
 class CurlStack;
 
 class CurlGet : public torrent::Http {
 public:
@@ -66,14 +68,18 @@
   CURL*              handle()           { return m_handle; }
 
 private:
   CurlGet(const CurlGet&);
   void operator = (const CurlGet&);
 
+  void               receive_timeout();
+
   bool               m_active;
 
+  rak::priority_item m_taskTimeout;
+  
   CURL*              m_handle;
   CurlStack*         m_stack;
 };
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_stack.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_stack.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_stack.cc	2008-09-02 04:08:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_stack.cc	2008-10-22 20:58:11.000000000 +0800
@@ -52,17 +52,17 @@
   m_handle((void*)curl_multi_init()),
   m_active(0),
   m_maxActive(32) {
 
   m_taskTimeout.set_slot(rak::mem_fn(this, &CurlStack::receive_timeout));
 
-  curl_multi_setopt((CURLM*)m_handle, CURLMOPT_TIMERDATA, this);
-  curl_multi_setopt((CURLM*)m_handle, CURLMOPT_SOCKETDATA, this);
 #if (LIBCURL_VERSION_NUM >= 0x071000)
+  curl_multi_setopt((CURLM*)m_handle, CURLMOPT_TIMERDATA, this);
   curl_multi_setopt((CURLM*)m_handle, CURLMOPT_TIMERFUNCTION, &CurlStack::set_timeout);
 #endif
+  curl_multi_setopt((CURLM*)m_handle, CURLMOPT_SOCKETDATA, this);
   curl_multi_setopt((CURLM*)m_handle, CURLMOPT_SOCKETFUNCTION, &CurlSocket::receive_socket);
 }
 
 CurlStack::~CurlStack() {
   while (!empty())
     front()->close();
@@ -108,31 +108,36 @@
       CURLMsg* msg;
 
       while ((msg = curl_multi_info_read((CURLM*)m_handle, &t)) != NULL) {
         if (msg->msg != CURLMSG_DONE)
           throw torrent::internal_error("CurlStack::receive_action() msg->msg != CURLMSG_DONE.");
 
-        iterator itr = std::find_if(begin(), end(), rak::equal(msg->easy_handle, std::mem_fun(&CurlGet::handle)));
-
-        if (itr == end())
-          throw torrent::internal_error("Could not find CurlGet with the right easy_handle.");
-
-        if (msg->data.result == CURLE_OK)
-          (*itr)->signal_done().emit();
-        else
-          (*itr)->signal_failed().emit(curl_easy_strerror(msg->data.result));
+	transfer_done(msg->easy_handle, msg->data.result == CURLE_OK ? NULL : curl_easy_strerror(msg->data.result));
       }
 
       if (empty())
         priority_queue_erase(&taskScheduler, &m_taskTimeout);
     }
 
   } while (code == CURLM_CALL_MULTI_PERFORM);
 }
 
 void
+CurlStack::transfer_done(void* handle, const char* msg) {
+  iterator itr = std::find_if(begin(), end(), rak::equal(handle, std::mem_fun(&CurlGet::handle)));
+
+  if (itr == end())
+    throw torrent::internal_error("Could not find CurlGet with the right easy_handle.");
+
+  if (msg == NULL)
+    (*itr)->signal_done().emit();
+  else
+    (*itr)->signal_failed().emit(msg);
+}
+
+void
 CurlStack::receive_timeout() {
   receive_action(NULL, 0);
 
   // Sometimes libcurl forgets to reset the timeout. Try to poll the value in that case, or use 10 seconds.
   if (!empty() && !m_taskTimeout.is_queued()) {
     long timeout;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_stack.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_stack.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/curl_stack.h	2008-09-02 04:08:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/curl_stack.h	2008-10-22 20:58:11.000000000 +0800
@@ -108,12 +108,14 @@
   static void         global_cleanup();
 
   void                receive_action(CurlSocket* socket, int type);
 
   static int          set_timeout(void* handle, long timeout_ms, void* userp);
 
+  void                transfer_done(void* handle, const char* msg);
+
  protected:
   void                add_get(CurlGet* get);
   void                remove_get(CurlGet* get);
 
  private:
   CurlStack(const CurlStack&);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/download_factory.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/download_factory.cc	2008-11-16 13:37:50.000000000 +0800
@@ -254,28 +254,17 @@
   try {
     std::for_each(m_commands.begin(), m_commands.end(), rak::bind1st(std::ptr_fun(&rpc::parse_command_d_multiple_std), download));
 
     if (m_manager->download_list()->find(infohash) == m_manager->download_list()->end())
       throw torrent::input_error("The newly created download was removed.");
 
-    // When a download scheduler is implemented, this is handled by
-    // the above insertion into download list.
-    if (m_session) {
-      // This torrent was queued for hashing or hashing when the
-      // session file was saved. Or it was in a started state.
-      if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped ||
-          rpc::call_command_value("d.get_state", rpc::make_target(download)) != 0)
-        m_manager->download_list()->resume(download);
-
-    } else {
-      // Use the state thingie here, move below.
-      if (m_start)
-        rpc::parse_command_single(rpc::make_target(download), "d.start=");
+    if (!m_session)
+       rpc::call_command("d.set_state", (int64_t)m_start, rpc::make_target(download));
 
-      m_manager->download_store()->save(download);
-    }
+    rpc::commands.call_catch(m_session ? "event.download.inserted_session" : "event.download.inserted_new",
+                             rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 
   } catch (torrent::input_error& e) {
     std::string msg = "Command on torrent creation failed: " + std::string(e.what());
 
     if (m_printLog) {
       m_manager->get_log_important().push_front(msg);
@@ -345,12 +334,13 @@
 
   if (rtorrent->has_key_value("chunks_done"))
     download->download()->set_chunks_done(std::min<uint32_t>(rtorrent->get_key_value("chunks_done"),
                                                              download->download()->file_list()->size_chunks()));
 
   rtorrent->insert_preserve_copy("ignore_commands", (int64_t)0);
+  rtorrent->insert_preserve_copy("views", torrent::Object::create_list());
 
   rtorrent->insert_preserve_type("connection_leech", m_variables["connection_leech"]);
   rtorrent->insert_preserve_type("connection_seed", m_variables["connection_seed"]);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/download_list.cc	2008-07-05 19:54:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/download_list.cc	2008-11-18 23:07:15.000000000 +0800
@@ -69,26 +69,12 @@
 #ifdef USE_EXTRA_DEBUG
   if (std::find(begin(), end(), d) == end())
     throw torrent::internal_error("DownloadList::check_contains(...) failed.");
 #endif
 }
 
-struct download_list_call {
-  download_list_call(Download* d) : m_download(d) {}
-
-  void operator () (const DownloadList::slot_map::value_type& s) {
-    try {
-      rpc::parse_command_d_multiple_std(m_download, s.second);
-    } catch (torrent::input_error& e) {
-      control->core()->push_log((std::string("Download event action failed: ") + e.what()).c_str());
-    }
-  }
-
-  Download* m_download;
-};    
-
 void
 DownloadList::clear() {
   std::for_each(begin(), end(), std::bind1st(std::mem_fun(&DownloadList::close), this));
   std::for_each(begin(), end(), rak::call_delete<Download>());
 
   base_type::clear();
@@ -168,13 +154,13 @@
 
     // This needs to be separated into two different calls to ensure
     // the download remains in the view.
     std::for_each(control->view_manager()->begin(), control->view_manager()->end(), std::bind2nd(std::mem_fun(&View::insert), download));
     std::for_each(control->view_manager()->begin(), control->view_manager()->end(), std::bind2nd(std::mem_fun(&View::filter_download), download));
 
-    std::for_each(slot_map_insert().begin(), slot_map_insert().end(), download_list_call(*itr));
+    rpc::commands.call_catch("event.download.inserted", rpc::make_target(*itr), torrent::Object(), "Download event action failed: ");
 
   } catch (torrent::local_error& e) {
     // Should perhaps relax this, just print an error and remove the
     // downloads?
     throw torrent::internal_error("Caught during DownloadList::insert(...): " + std::string(e.what()));
   }
@@ -196,13 +182,13 @@
   (*itr)->set_hash_failed(true);
 
   close(*itr);
 
   control->core()->download_store()->remove(*itr);
 
-  std::for_each(slot_map_erase().begin(), slot_map_erase().end(), download_list_call(*itr));
+  rpc::commands.call_catch("event.download.erased", rpc::make_target(*itr), torrent::Object(), "Download event action failed: ");
   std::for_each(control->view_manager()->begin(), control->view_manager()->end(), std::bind2nd(std::mem_fun(&View::erase), *itr));
 
   torrent::download_remove(*(*itr)->download());
   delete *itr;
 
   return base_type::erase(itr);
@@ -227,14 +213,13 @@
   check_contains(download);
 
   if (download->download()->is_open())
     return;
   
   download->download()->open(download->resume_flags());
-
-  std::for_each(slot_map_open().begin(), slot_map_open().end(), download_list_call(download));
+  rpc::commands.call_catch("event.download.opened", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 }
 
 void
 DownloadList::close(Download* download) {
   try {
 
@@ -246,13 +231,15 @@
 }
 
 void
 DownloadList::close_directly(Download* download) {
   if (download->download()->is_active()) {
     download->download()->stop(torrent::Download::stop_skip_tracker);
-    torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
+
+    if (torrent::resume_check_target_files(*download->download(), download->download()->bencode()->get_key("libtorrent_resume")))
+      torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
   }
 
   if (download->download()->is_open())
     download->download()->close();
 }
 
@@ -291,14 +278,14 @@
 
   download->download()->close();
 
   if (!download->is_hash_failed() && rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped)
     throw torrent::internal_error("DownloadList::close_throw(...) called but we're going into a hashing loop.");
 
-  std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
-  std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
+  rpc::commands.call_catch("event.download.hash_removed", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
+  rpc::commands.call_catch("event.download.closed", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 }
 
 void
 DownloadList::resume(Download* download, int flags) {
   check_contains(download);
 
@@ -325,13 +312,13 @@
       if (download->is_hash_failed())
         return;
 
       if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) == Download::variable_hashing_stopped)
         rpc::call_command("d.set_hashing", Download::variable_hashing_initial, rpc::make_target(download));
 
-      std::for_each(slot_map_hash_queued().begin(), slot_map_hash_queued().end(), download_list_call(download));
+      rpc::commands.call_catch("event.download.hash_queued", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
       return;
     }
 
     // This will never actually do anything due to the above hash check.
     // open_throw(download);
 
@@ -358,13 +345,13 @@
     // seeding/unfinished modifiers.
     download->set_priority(download->priority());
     download->download()->start(download->resume_flags());
 
     download->set_resume_flags(~uint32_t());
 
-    std::for_each(slot_map_start().begin(), slot_map_start().end(), download_list_call(download));
+    rpc::commands.call_catch("event.download.resumed", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
@@ -381,22 +368,25 @@
     // Always clear hashing on pause. When a hashing request is added,
     // it should have cleared the hash resume data.
     if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped) {
       download->download()->hash_stop();
       rpc::call_command_set_value("d.set_hashing", Download::variable_hashing_stopped, rpc::make_target(download));
 
-      std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
+      rpc::commands.call_catch("event.download.hash_removed", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
     }
 
     if (!download->download()->is_active())
       return;
 
     download->download()->stop(flags);
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     
-    std::for_each(slot_map_stop().begin(), slot_map_stop().end(), download_list_call(download));
+    // TODO: This is actually for pause, not stop... And doesn't get
+    // called when the download isn't active, but was in the 'started'
+    // view.
+    rpc::commands.call_catch("event.download.paused", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 
     rpc::call_command("d.set_state_changed", cachedTime.seconds(), rpc::make_target(download));
     rpc::call_command("d.set_state_counter", rpc::call_command_value("d.get_state_counter", rpc::make_target(download)), rpc::make_target(download));
 
     // If initial seeding is complete, don't try it again when restarting.
     if (download->is_done() &&
@@ -435,13 +425,13 @@
   if (download->is_hash_checking() || download->is_active())
     throw torrent::internal_error("DownloadList::hash_done(...) download in invalid state.");
 
   if (!download->is_hash_checked()) {
     download->set_hash_failed(true);
     
-    std::for_each(slot_map_hash_done().begin(), slot_map_hash_done().end(), download_list_call(download));
+    rpc::commands.call_catch("event.download.hash_done", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
     return;
   }
 
   // Need to find some sane conditional here. Can we check the total
   // downloaded to ensure something was transferred, thus we didn't
   // just hash an already completed torrent with lacking session data?
@@ -491,13 +481,13 @@
   default:
     // Either an error or someone wrote to the hashing variable...
     download->set_message("Hash check completed but the \"hashing\" variable is in an invalid state.");
     return;
   }
 
-  std::for_each(slot_map_hash_done().begin(), slot_map_hash_done().end(), download_list_call(download));
+  rpc::commands.call_catch("event.download.hash_done", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 }
 
 void
 DownloadList::hash_queue(Download* download, int type) {
   check_contains(download);
 
@@ -506,41 +496,40 @@
 
 //   close_throw(download);
   // HACK
   if (download->is_open()) {
     pause(download, torrent::Download::stop_skip_tracker);
     download->download()->close();
-    std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
-    std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
+
+    rpc::commands.call_catch("event.download.hash_removed", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
+    rpc::commands.call_catch("event.download.closed", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
   }
 
   torrent::resume_clear_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
 
   download->set_hash_failed(false);
   rpc::call_command_set_value("d.set_hashing", type, rpc::make_target(download));
 
   if (download->is_open())
     throw torrent::internal_error("DownloadList::hash_clear(...) download still open.");
 
   // If any more stuff is added here, make sure resume etc are still
   // correct.
-  std::for_each(slot_map_hash_queued().begin(), slot_map_hash_queued().end(), download_list_call(download));
+  rpc::commands.call_catch("event.download.hash_queued", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 }
 
 void
 DownloadList::received_finished(Download* download) {
   check_contains(download);
 
-  if (rpc::call_command_value("get_check_hash")) {
+  if (rpc::call_command_value("get_check_hash"))
     // Set some 'checking_finished_thingie' variable to make hash_done
     // trigger correctly, also so it can bork on missing data.
     hash_queue(download, Download::variable_hashing_last);
-
-  } else {
+  else
     confirm_finished(download);
-  }
 }
 
 // The download must be open when we call this function.
 void
 DownloadList::confirm_finished(Download* download) {
   check_contains(download);
@@ -555,22 +544,24 @@
 
   if (rpc::call_command_value("d.get_peers_max", rpc::make_target(download)) == rpc::call_command_value("get_max_peers") && rpc::call_command_value("get_max_peers_seed") >= 0)
     rpc::call_command("d.set_peers_max", rpc::call_command_void("get_max_peers_seed"), rpc::make_target(download));
 
   // Do this before the slots are called in case one of them closes
   // the download.
+  //
+  // Obsolete.
   if (!download->is_active() && rpc::call_command_value("get_session_on_completion") != 0) {
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     control->core()->download_store()->save(download);
   }
 
   // Send the completed request before resuming so we don't reset the
   // up/downloaded baseline.
   download->download()->tracker_list()->send_completed();
 
-  std::for_each(slot_map_finished().begin(), slot_map_finished().end(), download_list_call(download));
+  rpc::commands.call_catch("event.download.finished", rpc::make_target(download), torrent::Object(), "Download event action failed: ");
 
   if (download->resume_flags() != ~uint32_t())
     throw torrent::internal_error("DownloadList::confirm_finished(...) download->resume_flags() != ~uint32_t().");
 
   if (!download->is_active() && rpc::call_command_value("d.get_state", rpc::make_target(download)) == 1)
     resume(download, torrent::Download::start_no_create | torrent::Download::start_skip_tracker | torrent::Download::start_keep_baseline);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/download_list.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/download_list.h	2008-10-02 00:00:17.000000000 +0800
@@ -36,15 +36,13 @@
 
 #ifndef RTORRENT_CORE_DOWNLOAD_LIST_H
 #define RTORRENT_CORE_DOWNLOAD_LIST_H
 
 #include <iosfwd>
 #include <list>
-#include <map>
 #include <string>
-#include <sigc++/functors/slot.h>
 
 namespace torrent {
   class HashString;
 }
 
 namespace core {
@@ -57,13 +55,12 @@
 //
 // Fix apply_on_ratio if the base_type is changed.
 
 class DownloadList : private std::list<Download*> {
 public:
   typedef std::list<Download*>               base_type;
-  typedef std::map<std::string, std::string> slot_map;
 
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::reverse_iterator;
   using base_type::const_reverse_iterator;
   using base_type::value_type;
@@ -112,89 +109,60 @@
   void                resume_default(Download* d) { resume(d); }
   void                pause_default(Download* d) { pause(d); }
 
   void                check_hash(Download* d);
 
   enum {
-    SLOTS_INSERT,
-    SLOTS_ERASE,
-    SLOTS_OPEN,
-    SLOTS_CLOSE,
-    SLOTS_START,
-    SLOTS_STOP,
-    SLOTS_HASH_QUEUED,
-    SLOTS_HASH_REMOVED,
-    SLOTS_HASH_DONE,
-    SLOTS_FINISHED,
+    D_SLOTS_INSERT,
+    D_SLOTS_ERASE,
+    D_SLOTS_OPEN,
+    D_SLOTS_CLOSE,
+    D_SLOTS_START,
+    D_SLOTS_STOP,
+    D_SLOTS_HASH_QUEUED,
+    D_SLOTS_HASH_REMOVED,
+    D_SLOTS_HASH_DONE,
+    D_SLOTS_FINISHED,
 
     SLOTS_MAX_SIZE
   };
 
-  slot_map&           slots(int m)                                      { return m_slotMaps[m]; }
-  const slot_map&     slots(int m) const                                { return m_slotMaps[m]; }
-
-  slot_map*           slot_map_begin()                                  { return m_slotMaps; }
-  const slot_map*     slot_map_begin() const                            { return m_slotMaps; }
-  slot_map*           slot_map_end()                                    { return m_slotMaps + SLOTS_MAX_SIZE; }
-  const slot_map*     slot_map_end() const                              { return m_slotMaps + SLOTS_MAX_SIZE; }
-
-  slot_map&           slot_map_insert()                                 { return m_slotMaps[SLOTS_INSERT]; }
-  const slot_map&     slot_map_insert() const                           { return m_slotMaps[SLOTS_INSERT]; }
-  slot_map&           slot_map_erase()                                  { return m_slotMaps[SLOTS_ERASE]; }
-  const slot_map&     slot_map_erase() const                            { return m_slotMaps[SLOTS_ERASE]; }
-  slot_map&           slot_map_open()                                   { return m_slotMaps[SLOTS_OPEN]; }
-  const slot_map&     slot_map_open() const                             { return m_slotMaps[SLOTS_OPEN]; }
-  slot_map&           slot_map_close()                                  { return m_slotMaps[SLOTS_CLOSE]; }
-  const slot_map&     slot_map_close() const                            { return m_slotMaps[SLOTS_CLOSE]; }
-  slot_map&           slot_map_start()                                  { return m_slotMaps[SLOTS_START]; }
-  const slot_map&     slot_map_start() const                            { return m_slotMaps[SLOTS_START]; }
-  slot_map&           slot_map_stop()                                   { return m_slotMaps[SLOTS_STOP]; }
-  const slot_map&     slot_map_stop() const                             { return m_slotMaps[SLOTS_STOP]; }
+  static const char* slot_name(int m) {
+    switch(m) {
+    case D_SLOTS_INSERT: return "event.download.inserted";
+    case D_SLOTS_ERASE: return "event.download.erased";
+    case D_SLOTS_OPEN: return "event.download.opened";
+    case D_SLOTS_CLOSE: return "event.download.closed";
+    case D_SLOTS_START: return "event.download.resumed";
+    case D_SLOTS_STOP: return "event.download.paused";
+    case D_SLOTS_HASH_QUEUED: return "event.download.hash_queued";
+    case D_SLOTS_HASH_REMOVED: return "event.download.hash_removed";
+    case D_SLOTS_HASH_DONE: return "event.download.hash_done";
+    case D_SLOTS_FINISHED: return "event.download.finished";
+    default: return "BORK";
+    }
+  }
 
   // The finished slots will be called when an active download with
   // "finished" == 0 performs a hash check which returns a done
   // torrent.
   //
   // But how to avoid sending 'completed' messages to the tracker?
   // Also we need to handle cases when a hashing torrent starts up
   // after a shutdown.
 
-  slot_map&           slot_map_hash_queued()                            { return m_slotMaps[SLOTS_HASH_QUEUED]; }
-  const slot_map&     slot_map_hash_queued() const                      { return m_slotMaps[SLOTS_HASH_QUEUED]; }
-  slot_map&           slot_map_hash_removed()                           { return m_slotMaps[SLOTS_HASH_REMOVED]; }
-  const slot_map&     slot_map_hash_removed() const                     { return m_slotMaps[SLOTS_HASH_REMOVED]; }
-  slot_map&           slot_map_hash_done()                              { return m_slotMaps[SLOTS_HASH_DONE]; }
-  const slot_map&     slot_map_hash_done() const                        { return m_slotMaps[SLOTS_HASH_DONE]; }
-  slot_map&           slot_map_finished()                               { return m_slotMaps[SLOTS_FINISHED]; }
-  const slot_map&     slot_map_finished() const                         { return m_slotMaps[SLOTS_FINISHED]; }
-
-  bool                has_slot_insert(const std::string& key) const     { return slot_map_insert().find(key) != slot_map_insert().end(); }
-  bool                has_slot_erase(const std::string& key) const      { return slot_map_erase().find(key) != slot_map_erase().end(); }
-  bool                has_slot_open(const std::string& key) const       { return slot_map_open().find(key) != slot_map_open().end(); }
-  bool                has_slot_close(const std::string& key) const      { return slot_map_close().find(key) != slot_map_close().end(); }
-  bool                has_slot_start(const std::string& key) const      { return slot_map_start().find(key) != slot_map_start().end(); }
-  bool                has_slot_stop(const std::string& key) const       { return slot_map_stop().find(key) != slot_map_stop().end(); }
-
-  bool                has_slot_hash_queued(const std::string& key) const{ return slot_map_hash_queued().find(key) != slot_map_hash_queued().end(); }
-  bool                has_slot_hash_done(const std::string& key) const  { return slot_map_hash_done().find(key) != slot_map_hash_done().end(); }
-  bool                has_slot_finished(const std::string& key) const   { return slot_map_finished().find(key) != slot_map_finished().end(); }
-
-  static void         erase_key(slot_map& sm, const std::string& key)   { sm.erase(key); }
-
 private:
   DownloadList(const DownloadList&);
   void operator = (const DownloadList&);
 
   void                hash_done(Download* d);
   void                hash_queue(Download* d, int type);
 
   inline void         check_contains(Download* d);
 
   void                received_finished(Download* d);
   void                confirm_finished(Download* d);
-
-  slot_map            m_slotMaps[SLOTS_MAX_SIZE];
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/http_queue.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/http_queue.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/http_queue.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/http_queue.cc	2008-10-22 20:58:11.000000000 +0800
@@ -51,12 +51,13 @@
 HttpQueue::iterator
 HttpQueue::insert(const std::string& url, std::iostream* s) {
   std::auto_ptr<CurlGet> h(m_slotFactory());
   
   h->set_url(url);
   h->set_stream(s);
+  h->set_timeout(5 * 60);
 
   iterator itr = Base::insert(end(), h.get());
 
   h->signal_done().connect(sigc::bind(sigc::mem_fun(this, &HttpQueue::erase), itr));
   h->signal_failed().connect(sigc::bind<0>(sigc::hide(sigc::mem_fun(this, &HttpQueue::erase)), itr));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/Makefile.am	2008-08-27 16:25:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/Makefile.am	2008-10-02 20:06:54.000000000 +0800
@@ -29,14 +29,12 @@
 	poll_manager_epoll.cc \
 	poll_manager_epoll.h \
 	poll_manager_kqueue.cc \
 	poll_manager_kqueue.h \
 	poll_manager_select.cc \
 	poll_manager_select.h \
-	scheduler.cc \
-	scheduler.h \
 	view.cc \
 	view.h \
 	view_manager.cc \
 	view_manager.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/Makefile.in	2008-09-12 06:26:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/Makefile.in	2008-11-19 17:05:38.000000000 +0800
@@ -50,14 +50,14 @@
 am_libsub_core_a_OBJECTS = curl_get.$(OBJEXT) curl_socket.$(OBJEXT) \
 	curl_stack.$(OBJEXT) dht_manager.$(OBJEXT) download.$(OBJEXT) \
 	download_factory.$(OBJEXT) download_list.$(OBJEXT) \
 	download_store.$(OBJEXT) http_queue.$(OBJEXT) log.$(OBJEXT) \
 	manager.$(OBJEXT) poll_manager.$(OBJEXT) \
 	poll_manager_epoll.$(OBJEXT) poll_manager_kqueue.$(OBJEXT) \
-	poll_manager_select.$(OBJEXT) scheduler.$(OBJEXT) \
-	view.$(OBJEXT) view_manager.$(OBJEXT)
+	poll_manager_select.$(OBJEXT) view.$(OBJEXT) \
+	view_manager.$(OBJEXT)
 libsub_core_a_OBJECTS = $(am_libsub_core_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -228,14 +228,12 @@
 	poll_manager_epoll.cc \
 	poll_manager_epoll.h \
 	poll_manager_kqueue.cc \
 	poll_manager_kqueue.h \
 	poll_manager_select.cc \
 	poll_manager_select.h \
-	scheduler.cc \
-	scheduler.h \
 	view.cc \
 	view.h \
 	view_manager.cc \
 	view_manager.h
 
 INCLUDES = -I$(srcdir) -I$(srcdir)/.. -I$(top_srcdir)
@@ -298,13 +296,12 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/log.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_epoll.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_kqueue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/poll_manager_select.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scheduler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/view.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/view_manager.Po@am__quote@
 
 .cc.o:
 @am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
 @am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/manager.cc	2008-08-27 16:25:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/manager.cc	2008-11-18 23:06:32.000000000 +0800
@@ -208,17 +208,12 @@
 Manager::initialize_second() {
   torrent::Http::set_factory(sigc::mem_fun(m_httpStack, &CurlStack::new_object));
   m_httpQueue->slot_factory(sigc::mem_fun(m_httpStack, &CurlStack::new_object));
 
   CurlStack::global_init();
 
-  // Register slots to be called when a download is inserted/erased,
-  // opened or closed.
-  m_downloadList->slot_map_insert()["1_connect_logs"] = "d.initialize_logs=";
-  m_downloadList->slot_map_erase()["9_delete_tied"]   = "d.delete_tied=";
-
   torrent::connection_manager()->set_signal_handshake_log(sigc::mem_fun(this, &Manager::handshake_log));
 }
 
 void
 Manager::cleanup() {
   // Need to disconnect log signals? Not really since we won't receive
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core: scheduler.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core: scheduler.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/view.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/view.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/view.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/view.cc	2008-10-02 00:29:01.000000000 +0800
@@ -113,32 +113,26 @@
 }
 
 View::~View() {
   if (m_name.empty())
     return;
 
-  std::for_each(control->core()->download_list()->slot_map_begin(), control->core()->download_list()->slot_map_end(),
-                rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
-
+  clear_filter_on();
   priority_queue_erase(&taskScheduler, &m_delayChanged);
 }
 
 void
 View::initialize(const std::string& name) {
   if (!m_name.empty())
     throw torrent::internal_error("View::initialize(...) called on an already initialized view.");
 
   if (name.empty())
     throw torrent::internal_error("View::initialize(...) called with an empty name.");
 
-  std::string key = "0_view_" + name;
   core::DownloadList* dlist = control->core()->download_list();
 
-  if (dlist->has_slot_insert(key) || dlist->has_slot_erase(key))
-    throw torrent::internal_error("View::initialize(...) duplicate key name found in DownloadList.");
-
   m_name = name;
 
   // Urgh, wrong. No filtering being done.
   std::for_each(dlist->begin(), dlist->end(), rak::bind1st(std::mem_fun(&View::push_back), this));
 
   m_size = base_type::size();
@@ -292,25 +286,26 @@
   }
 
   emit_changed();
 }
 
 void
-View::set_filter_on(int event) {
-  if (event == DownloadList::SLOTS_INSERT || event == DownloadList::SLOTS_ERASE || event >= DownloadList::SLOTS_MAX_SIZE)
-    throw torrent::internal_error("View::filter_on(...) invalid event.");
+View::set_filter_on_event(const std::string& event) {
+  if (std::find(m_events.begin(), m_events.end(), event) != m_events.end())
+    return;
 
-  control->core()->download_list()->slots(event)["0_view_" + m_name] = "view.filter_download=" + m_name;
+  rpc::commands.call_catch("system.method.set_key", rpc::make_target(), rpc::create_object_list(event, "!view_" + m_name, "view.filter_download=" + m_name));
+  m_events.push_back(event);
 }
 
 void
 View::clear_filter_on() {
   // Don't clear insert and erase as these are required to keep the
   // View up-to-date with the available downloads.
-  std::for_each(control->core()->download_list()->slot_map_begin() + DownloadList::SLOTS_OPEN, control->core()->download_list()->slot_map_end(),
-                rak::bind2nd(std::ptr_fun(&DownloadList::erase_key), "0_view_" + m_name));
+  for (event_list_type::const_iterator itr = m_events.begin(); itr != m_events.end(); itr++)
+    rpc::commands.call_catch("system.method.set_key", rpc::make_target(), rpc::create_object_list(*itr, "!view_" + m_name));
 }
 
 inline void
 View::insert_visible(Download* d) {
   iterator itr = std::find_if(begin_visible(), end_visible(), std::bind1st(view_downloads_compare(m_sortNew), d));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/view.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/view.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/view.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/view.h	2008-11-16 15:28:38.000000000 +0800
@@ -61,12 +61,13 @@
 
 class Download;
 
 class View : private std::vector<Download*> {
 public:
   typedef std::vector<Download*>         base_type;
+  typedef std::vector<std::string>       event_list_type;
   typedef sigc::signal0<void>            signal_type;
 
   using base_type::iterator;
   using base_type::const_iterator;
   using base_type::reverse_iterator;
   using base_type::const_reverse_iterator;
@@ -118,17 +119,20 @@
   void                set_sort_current(const std::string& s)  { m_sortCurrent = s; }
 
   // Need to explicity trigger filtering.
   void                filter();
   void                filter_download(core::Download* download);
 
+  const std::string&  get_filter() const { return m_filter; }
   void                set_filter(const std::string& s)        { m_filter = s; }
-  void                set_filter_on(int event);
+  void                set_filter_on_event(const std::string& event);
 
   void                clear_filter_on();
 
+  const std::string&  get_event_added() const { return m_eventAdded; }
+  const std::string&  get_event_removed() const { return m_eventRemoved; }
   void                set_event_added(const std::string& cmd)   { m_eventAdded = cmd; }
   void                set_event_removed(const std::string& cmd) { m_eventRemoved = cmd; }
 
   // The time of the last change to the view, semantics of this is
   // user-dependent. Used by f.ex. ViewManager to decide if it should
   // sort and/or filter a view.
@@ -164,12 +168,13 @@
 
   // These should be replaced by a faster non-string command type.
   std::string         m_sortNew;
   std::string         m_sortCurrent;
 
   std::string         m_filter;
+  event_list_type     m_events;
 
   std::string         m_eventAdded;
   std::string         m_eventRemoved;
 
   rak::timer          m_lastChanged;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/view_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/view_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/core/view_manager.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/core/view_manager.cc	2008-10-02 00:38:26.000000000 +0800
@@ -109,33 +109,11 @@
 void
 ViewManager::set_filter_on(const std::string& name, const filter_args& args) {
   iterator viewItr = find_throw(name);
 
   (*viewItr)->clear_filter_on();
 
-  for (filter_args::const_iterator itr = args.begin(); itr != args.end(); ++itr) {
-
-    if (*itr == "start")
-      (*viewItr)->set_filter_on(DownloadList::SLOTS_START);
-
-    else if (*itr == "stop")
-      (*viewItr)->set_filter_on(DownloadList::SLOTS_STOP);
-
-    else if (*itr == "hash_queued")
-      (*viewItr)->set_filter_on(DownloadList::SLOTS_HASH_QUEUED);
-
-    else if (*itr == "hash_removed")
-      (*viewItr)->set_filter_on(DownloadList::SLOTS_HASH_REMOVED);
-
-    else if (*itr == "hash_done")
-      (*viewItr)->set_filter_on(DownloadList::SLOTS_HASH_DONE);
-
-    else if (*itr == "finished")
-      (*viewItr)->set_filter_on(DownloadList::SLOTS_FINISHED);
-
-    else
-      throw torrent::input_error("Invalid filter on identifier.");
-
-  }
+  for (filter_args::const_iterator itr = args.begin(); itr != args.end(); ++itr)
+    (*viewItr)->set_filter_on_event(*itr);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/text_element_string.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/text_element_string.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/text_element_string.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/text_element_string.cc	2008-11-16 17:54:50.000000000 +0800
@@ -119,13 +119,13 @@
     }  
 
     break;
   }
   case torrent::Object::TYPE_VALUE:
   { 
-    first += std::max(snprintf(first, last - first + 1, "%lld", result.as_value()), 0);
+    first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%lld", result.as_value()), 0), last - first + 1);
     break;
   }
   default:
     return first;
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/text_element_value.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/text_element_value.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/text_element_value.cc	2008-08-27 04:14:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/text_element_value.cc	2008-11-16 18:04:41.000000000 +0800
@@ -79,55 +79,55 @@
   // Print the value.
   if (first == last) {
     // Do nothing, but ensure that the last attributes are set.
 
   } else if (m_flags & flag_kb) {
     // Just use a default width of 5 for now.
-    first += std::max(snprintf(first, last - first + 1, "%5.1f", (double)val / (1 << 10)), 0);
+    first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%5.1f", (double)val / (1 << 10)), 0), last - first + 1);
 
   } else if (m_flags & flag_mb) {
     // Just use a default width of 8 for now.
-    first += std::max(snprintf(first, last - first + 1, "%8.1f", (double)val / (1 << 20)), 0);
+    first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%8.1f", (double)val / (1 << 20)), 0), last - first + 1);
 
   } else if (m_flags & flag_xb) {
 
     if (val < (int64_t(1000) << 10))
-      first += std::max(snprintf(first, last - first + 1, "%5.1f KB", (double)val / (int64_t(1) << 10)), 0);
+      first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%5.1f KB", (double)val / (int64_t(1) << 10)), 0), last - first + 1);
     else if (val < (int64_t(1000) << 20))
-      first += std::max(snprintf(first, last - first + 1, "%5.1f MB", (double)val / (int64_t(1) << 20)), 0);
+      first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%5.1f MB", (double)val / (int64_t(1) << 20)), 0), last - first + 1);
     else if (val < (int64_t(1000) << 30))
-      first += std::max(snprintf(first, last - first + 1, "%5.1f GB", (double)val / (int64_t(1) << 30)), 0);
+      first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%5.1f GB", (double)val / (int64_t(1) << 30)), 0), last - first + 1);
     else
-      first += std::max(snprintf(first, last - first + 1, "%5.1f TB", (double)val / (int64_t(1) << 40)), 0);
+      first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%5.1f TB", (double)val / (int64_t(1) << 40)), 0), last - first + 1);
 
   } else if (m_flags & flag_timer) {
     if (val == 0)
-      first += std::max(snprintf(first, last - first + 1, "--:--:--"), 0);
+      first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "--:--:--"), 0), last - first + 1);
     else
-      first += std::max(snprintf(first, last - first + 1, "%2d:%02d:%02d", (int)(val / 3600), (int)((val / 60) % 60), (int)(val % 60)), 0);
+      first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%2d:%02d:%02d", (int)(val / 3600), (int)((val / 60) % 60), (int)(val % 60)), 0), last - first + 1);
 
   } else if (m_flags & flag_date) {
     time_t t = val;
     std::tm *u = std::gmtime(&t);
   
     if (u == NULL)
       return first;
 
-    first += std::max(snprintf(first, last - first + 1, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year)), 0);
+    first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year)), 0), last - first + 1);;
 
   } else if (m_flags & flag_time) {
     time_t t = val;
     std::tm *u = std::gmtime(&t);
   
     if (u == NULL)
       return first;
 
-    first += std::max(snprintf(first, last - first + 1, "%2d:%02d:%02d", u->tm_hour, u->tm_min, u->tm_sec), 0);
+    first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%2d:%02d:%02d", u->tm_hour, u->tm_min, u->tm_sec), 0), last - first + 1);
 
   } else {
-    first += std::max(snprintf(first, last - first + 1, "%lld", val), 0);
+    first += std::min<ptrdiff_t>(std::max(snprintf(first, last - first + 1, "%lld", val), 0), last - first + 1);
   }
 
   push_attribute(attributes, Attributes(first, baseAttribute));
 
   return first;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/window_download_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/window_download_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/window_download_statusbar.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/window_download_statusbar.cc	2008-11-16 18:04:41.000000000 +0800
@@ -65,24 +65,24 @@
   char* position;
   char* last = buffer + m_canvas->width() - 2;
 
   position = print_download_info(buffer, last, m_download);
   m_canvas->print(0, 0, "%s", buffer);
 
-  position = buffer + std::max(snprintf(buffer, last - buffer, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I/C/A: %i/%i/%i/%i Failed: %i",
+  position = buffer + std::min<ptrdiff_t>(std::max(snprintf(buffer, last - buffer, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I/C/A: %i/%i/%i/%i Failed: %i",
                                         (int)m_download->download()->connection_list()->size(),
                                         (int)m_download->download()->peer_list()->available_list_size(),
                                         (int)m_download->download()->connection_list()->min_size(),
                                         (int)m_download->download()->connection_list()->max_size(),
                                         (int)m_download->download()->uploads_max(),
                                         (int)m_download->download()->peers_currently_unchoked(),
                                         (int)m_download->download()->peers_currently_interested(),
                                         (int)m_download->download()->peers_complete(),
                                         (int)m_download->download()->peers_accounted(),
                                         (int)m_download->chunks_failed()),
-                               0);
+                               0), last - buffer);
 
   m_canvas->print(0, 1, "%s", buffer);
 
   position = print_download_status(buffer, last, m_download);
   m_canvas->print(0, 2, "[%c:%i] %s",
                   m_download->tracker_list()->has_active() ? 'C' : ' ',
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/window_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/window_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/display/window_file_list.cc	2008-08-27 04:33:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/display/window_file_list.cc	2008-11-16 23:55:08.000000000 +0800
@@ -65,13 +65,13 @@
   size_t length = std::mbstowcs(result, i_str.c_str(), width);
 
   // If not valid UTF-8 encoding, at least copy the printable characters.
   if (length == (size_t)-1) {
     wchar_t* out = result;
 
-    for (std::string::const_iterator itr = i_str.begin(); itr != i_str.end(); ++itr)
+    for (std::string::const_iterator itr = i_str.begin(); out != result + width && itr != i_str.end(); ++itr)
       if (!std::isprint(*itr, std::locale::classic()))
         *out++ = '?';
       else
         *out++ = *itr;
 
      *out = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/main.cc	2008-07-05 20:11:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/main.cc	2008-11-18 02:18:14.000000000 +0800
@@ -168,14 +168,65 @@
     control->core()->initialize_first();
 
     // Initialize option handlers after libtorrent to ensure
     // torrent::ConnectionManager* are valid etc.
     initialize_commands();
 
-    rpc::parse_command_multiple(rpc::make_target(),
-//       "set_name = $cat={$system.hostname=,:,$system.pid=}\n"
+    rpc::parse_command_multiple
+      (rpc::make_target(),
+//        "system.method.insert = test.value,value\n"
+//        "system.method.insert = test.value2,value,6\n"
+
+//        "system.method.insert = test.string,string,6\n"
+//        "system.method.insert = test.bool,bool,true\n"
+
+       "system.method.insert = test.method.simple,simple,\"print=simple_test_,$argument.0=\"\n"
+
+       "system.method.insert = event.download.inserted,multi\n"
+       "system.method.insert = event.download.inserted_new,multi\n"
+       "system.method.insert = event.download.inserted_session,multi\n"
+       "system.method.insert = event.download.erased,multi\n"
+       "system.method.insert = event.download.opened,multi\n"
+       "system.method.insert = event.download.closed,multi\n"
+       "system.method.insert = event.download.resumed,multi\n"
+       "system.method.insert = event.download.paused,multi\n"
+       
+       "system.method.insert = event.download.finished,multi\n"
+       "system.method.insert = event.download.hash_done,multi\n"
+       "system.method.insert = event.download.hash_removed,multi\n"
+       "system.method.insert = event.download.hash_queued,multi\n"
+
+       "system.method.set_key = event.download.inserted,         1_connect_logs, d.initialize_logs=\n"
+       "system.method.set_key = event.download.inserted_new,     1_prepare, \"branch=d.get_state=,view.set_visible=started,view.set_visible=stopped ;d.save_session=\"\n"
+       "system.method.set_key = event.download.inserted_session, 1_prepare, \"branch=d.get_state=,view.set_visible=started,view.set_visible=stopped\"\n"
+
+       "system.method.set_key = event.download.erased, 0_download_list, ui.unfocus_download=\n"
+       "system.method.set_key = event.download.erased, 9_delete_tied, d.delete_tied=\n"
+
+       "system.method.insert = ratio.enable, simple|static|const,group.seeding.ratio.enable=\n"
+       "system.method.insert = ratio.disable,simple|static|const,group.seeding.ratio.disable=\n"
+       "system.method.insert = ratio.min,    simple|static|const,group.seeding.ratio.min=\n"
+       "system.method.insert = ratio.max,    simple|static|const,group.seeding.ratio.max=\n"
+       "system.method.insert = ratio.upload, simple|static|const,group.seeding.ratio.upload=\n"
+       "system.method.insert = ratio.min.set,   simple|static|const,group.seeding.ratio.min.set=$argument.0=\n"
+       "system.method.insert = ratio.max.set,   simple|static|const,group.seeding.ratio.max.set=$argument.0=\n"
+       "system.method.insert = ratio.upload.set,simple|static|const,group.seeding.ratio.upload.set=$argument.0=\n"
+
+       "system.method.insert = group.insert_persistent_view,simple|static|const,"
+       "view_add=$argument.0=,view.persistent=$argument.0=,\"group.insert=$argument.0=,$argument.0=\"\n"
+
+       // Allow setting 'group.view' as constant, so that we can't
+       // modify the value. And look into the possibility of making
+       // 'const' use non-heap memory, as we know they can't be
+       // erased.
+
+       // TODO: Remember to ensure it doesn't get restarted by watch
+       // dir, etc. Set ignore commands, or something.
+
+       "group.insert = seeding,seeding\n"
+
        "set_name = \"$cat=$system.hostname=,:,$system.pid=\"\n"
 
        // Currently not doing any sorting on main.
        "view_add = main\n"
        "view_add = default\n"
 
@@ -184,57 +235,48 @@
        "view_sort_current = name,less=d.get_name=\n"
 
        "view_add = active\n"
        "view_filter = active,false=\n"
 
        "view_add = started\n"
-       "view_filter = started,d.get_state=\n"
-       "view.event_added = started,scheduler.simple.added=\n"
-       "view.event_removed = started,scheduler.simple.removed=\n"
+       "view_filter = started,false=\n"
+       "view.event_added   = started,\"view.set_not_visible=stopped ;d.set_state=1 ;scheduler.simple.added=\"\n"
+       "view.event_removed = started,\"view.set_visible=stopped ;scheduler.simple.removed=\"\n"
 
        "view_add = stopped\n"
-       "view_filter = stopped,not=$d.get_state=\n"
+       "view_filter = stopped,false=\n"
+       "view.event_added   = stopped,\"view.set_not_visible=started ;d.set_state=0\"\n"
+       "view.event_removed = stopped,view.set_visible=started\n"
 
        "view_add = complete\n"
        "view_filter = complete,d.get_complete=\n"
-       "view_filter_on = complete,hash_done,finished\n"
+       "view_filter_on    = complete,event.download.hash_done,event.download.finished\n"
        "view_sort_new     = complete,less=d.get_state_changed=\n"
        "view_sort_current = complete,less=d.get_state_changed=\n"
 
        "view_add = incomplete\n"
        "view_filter = incomplete,not=$d.get_complete=\n"
-       "view_filter_on = incomplete,hash_done,finished\n"
+       "view_filter_on    = incomplete,event.download.hash_done,event.download.finished\n"
        "view_sort_new     = incomplete,less=d.get_state_changed=\n"
        "view_sort_current = incomplete,less=d.get_state_changed=\n"
 
        // The hashing view does not include stopped torrents.
        "view_add = hashing\n"
        "view_filter = hashing,d.get_hashing=\n"
-       "view_filter_on = hashing,hash_queued,hash_removed,hash_done\n"
+       "view_filter_on = hashing,event.download.hash_queued,event.download.hash_removed,event.download.hash_done\n"
 //        "view_sort_new     = hashing,less=d.get_state_changed=\n"
 //        "view_sort_current = hashing,less=d.get_state_changed=\n"
 
        "view_add = seeding\n"
        "view_filter = seeding,\"and=d.get_state=,d.get_complete=\"\n"
-       "view_filter_on = seeding,start,stop\n"
+       "view_filter_on    = seeding,event.download.resumed,event.download.paused,event.download.finished\n"
        "view_sort_new     = seeding,less=d.get_state_changed=\n"
        "view_sort_current = seeding,less=d.get_state_changed=\n"
 
-       // Changing these will bork the (non-existant) scheduler.
-       "view_add = scheduler\n"
-//        "view_sort_new     = scheduler,less=d.get_state_changed=\n"
-//        "view_sort_current = scheduler,less=d.get_state_changed=\n"
-
-       //    "schedule = scheduler,10,10,download_scheduler=\n"
-
        "schedule = view_main,10,10,\"view_sort=main,20\"\n"
        "schedule = view_name,10,10,\"view_sort=name,20\"\n"
-       //     "schedule = view_started,10,10,view_sort=started,5\n"
-       //     "schedule = view_stopped,10,10,view_sort=stopped,5\n"
-       //     "schedule = view_complete,10,10,view_sort=complete,5\n"
-       //     "schedule = view_incomplete,10,10,view_sort=incomplete,5\n"
 
        "schedule = session_save,1800,1800,session_save=\n"
        "schedule = low_diskspace,5,60,close_low_diskspace=500M\n"
        "schedule = prune_file_status,3600,86400,system.file_status_cache.prune=\n"
 
        "encryption=allow_incoming,prefer_plaintext,enable_retry\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/Makefile.am	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/Makefile.am	2008-11-16 12:29:30.000000000 +0800
@@ -15,18 +15,20 @@
 	$(top_srcdir)/src/input/libsub_input.a \
 	$(top_srcdir)/src/rpc/libsub_rpc.a \
 	$(top_srcdir)/src/utils/libsub_utils.a
 
 rtorrent_SOURCES = \
 	command_download.cc \
+	command_dynamic.cc \
 	command_events.cc \
 	command_file.cc \
 	command_helpers.cc \
 	command_helpers.h \
 	command_local.cc \
 	command_network.cc \
+	command_object.cc \
 	command_peer.cc \
 	command_tracker.cc \
 	command_scheduler.cc \
 	command_ui.cc \
 	control.cc \
 	control.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/Makefile.in	2008-09-12 06:26:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/Makefile.in	2008-11-19 17:05:38.000000000 +0800
@@ -45,15 +45,16 @@
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 am__installdirs = "$(DESTDIR)$(bindir)"
 binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
 PROGRAMS = $(bin_PROGRAMS)
 am_rtorrent_OBJECTS = command_download.$(OBJEXT) \
-	command_events.$(OBJEXT) command_file.$(OBJEXT) \
-	command_helpers.$(OBJEXT) command_local.$(OBJEXT) \
-	command_network.$(OBJEXT) command_peer.$(OBJEXT) \
+	command_dynamic.$(OBJEXT) command_events.$(OBJEXT) \
+	command_file.$(OBJEXT) command_helpers.$(OBJEXT) \
+	command_local.$(OBJEXT) command_network.$(OBJEXT) \
+	command_object.$(OBJEXT) command_peer.$(OBJEXT) \
 	command_tracker.$(OBJEXT) command_scheduler.$(OBJEXT) \
 	command_ui.$(OBJEXT) control.$(OBJEXT) globals.$(OBJEXT) \
 	main.$(OBJEXT) option_parser.$(OBJEXT) \
 	signal_handler.$(OBJEXT)
 rtorrent_OBJECTS = $(am_rtorrent_OBJECTS)
 rtorrent_DEPENDENCIES = $(top_srcdir)/src/ui/libsub_ui.a \
@@ -229,18 +230,20 @@
 	$(top_srcdir)/src/input/libsub_input.a \
 	$(top_srcdir)/src/rpc/libsub_rpc.a \
 	$(top_srcdir)/src/utils/libsub_utils.a
 
 rtorrent_SOURCES = \
 	command_download.cc \
+	command_dynamic.cc \
 	command_events.cc \
 	command_file.cc \
 	command_helpers.cc \
 	command_helpers.h \
 	command_local.cc \
 	command_network.cc \
+	command_object.cc \
 	command_peer.cc \
 	command_tracker.cc \
 	command_scheduler.cc \
 	command_ui.cc \
 	control.cc \
 	control.h \
@@ -321,17 +324,19 @@
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_download.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_dynamic.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_events.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_file.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_helpers.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_local.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_network.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_object.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_peer.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_tracker.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_ui.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/control.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/globals.Po@am__quote@
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc: command_function.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc: command_function.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command.h	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command.h	2008-11-09 18:08:40.000000000 +0800
@@ -49,12 +49,26 @@
   class Peer;
   class Tracker;
 }
 
 namespace rpc {
 
+template <typename Target>
+struct target_wrapper {
+  typedef Target      target_type; 
+  typedef Target      cleaned_type;
+};
+
+template <>
+struct target_wrapper<void> {
+  struct no_type {};
+
+  typedef void        target_type; 
+  typedef no_type*    cleaned_type;
+};
+
 // Since c++0x isn't out yet...
 template <typename T1, typename T2, typename T3>
 struct rt_triple : private std::pair<T1, T2> {
   typedef std::pair<T1, T2> base_type;
   typedef T3                third_type;
 
@@ -92,12 +106,13 @@
   typedef torrent::Object::string_type string_type;
   typedef torrent::Object::list_type   list_type;
   typedef torrent::Object::map_type    map_type;
   typedef torrent::Object::key_type    key_type;
 
   typedef const torrent::Object (*generic_slot)  (Command*, const torrent::Object&);
+  typedef const torrent::Object (*cleaned_slot)  (Command*, target_wrapper<void>::cleaned_type, const torrent::Object&);
   typedef const torrent::Object (*any_slot)      (Command*, target_type, const torrent::Object&);
   typedef const torrent::Object (*download_slot) (Command*, core::Download*, const torrent::Object&);
   typedef const torrent::Object (*file_slot)     (Command*, torrent::File*, const torrent::Object&);
   typedef const torrent::Object (*file_itr_slot) (Command*, torrent::FileListIterator*, const torrent::Object&);
   typedef const torrent::Object (*peer_slot)     (Command*, torrent::Peer*, const torrent::Object&);
   typedef const torrent::Object (*tracker_slot)  (Command*, torrent::Tracker*, const torrent::Object&);
@@ -114,23 +129,33 @@
 
   static const int target_download_pair = 7;
 
   Command() {}
   virtual ~Command() {}
 
+  static torrent::Object* argument(unsigned int index) { return m_arguments + index; }
+
 protected:
   Command(const Command&);
   void operator = (const Command&);
+
+  // For use by functions that need to use placeholders to arguments
+  // within commands. E.d. callable command strings where one of the
+  // arguments within the command needs to be supplied by the caller.
+  static const unsigned int max_arguments = 10;
+
+  static torrent::Object m_arguments[max_arguments];
 };
 
 template <typename T1 = void, typename T2 = void>
 struct target_type_id {
   // Nothing here, so we cause an error.
 };
 
-template <> struct target_type_id<Command::generic_slot>       { static const int value = Command::target_generic; };
+//template <> struct target_type_id<Command::generic_slot>       { static const int value = Command::target_generic; };
+template <> struct target_type_id<Command::cleaned_slot>       { static const int value = Command::target_generic; };
 template <> struct target_type_id<Command::any_slot>           { static const int value = Command::target_any; };
 template <> struct target_type_id<Command::download_slot>      { static const int value = Command::target_download; };
 template <> struct target_type_id<Command::peer_slot>          { static const int value = Command::target_peer; };
 template <> struct target_type_id<Command::tracker_slot>       { static const int value = Command::target_tracker; };
 template <> struct target_type_id<Command::file_slot>          { static const int value = Command::target_file; };
 template <> struct target_type_id<Command::file_itr_slot>      { static const int value = Command::target_file_itr; };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_map.cc	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_map.cc	2008-11-09 18:13:46.000000000 +0800
@@ -33,34 +33,58 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <vector>
 #include <torrent/exceptions.h>
 #include <torrent/object.h>
 #include <torrent/data/file_list_iterator.h>
 
+// Get better logging...
+#include "globals.h"
+#include "control.h"
+#include "core/manager.h"
+
 #include "command.h"
 #include "command_map.h"
 
+// For XMLRPC stuff, clean up.
+#include "xmlrpc.h"
+#include "parse_commands.h"
+
 namespace rpc {
 
+torrent::Object Command::m_arguments[Command::max_arguments];
+
 CommandMap::~CommandMap() {
-  for (iterator itr = base_type::begin(), last = base_type::end(); itr != last; itr++)
+  std::vector<const char*> keys;
+
+  for (iterator itr = base_type::begin(), last = base_type::end(); itr != last; itr++) {
     if (!(itr->second.m_flags & flag_dont_delete))
       delete itr->second.m_variable;
+
+    if (itr->second.m_flags & flag_delete_key)
+      keys.push_back(itr->first);
+  }
+
+  for (std::vector<const char*>::iterator itr = keys.begin(), last = keys.end(); itr != last; itr++)
+    delete [] *itr;
 }
 
 CommandMap::iterator
 CommandMap::insert(key_type key, Command* variable, int flags, const char* parm, const char* doc) {
   iterator itr = base_type::find(key);
 
   if (itr != base_type::end())
     throw torrent::internal_error("CommandMap::insert(...) tried to insert an already existing key.");
 
+  if (rpc::xmlrpc.is_valid())
+    rpc::xmlrpc.insert_command(key, parm, doc);
+
   return base_type::insert(itr, value_type(key, command_map_data_type(variable, flags, parm, doc)));
 }
 
 void
 CommandMap::insert(key_type key, const command_map_data_type src) {
   iterator itr = base_type::find(key);
@@ -72,12 +96,36 @@
 
   // We can assume all the slots are the same size.
   itr->second.m_target      = src.m_target;
   itr->second.m_genericSlot = src.m_genericSlot;
 }
 
+void
+CommandMap::erase(iterator itr) {
+  if (itr == end())
+    return;
+
+  if (!(itr->second.m_flags & flag_dont_delete))
+    delete itr->second.m_variable;
+
+  const char* key = itr->second.m_flags & flag_delete_key ? itr->first : NULL;
+
+  base_type::erase(itr);
+  delete [] key;
+}
+
+const CommandMap::mapped_type
+CommandMap::call_catch(key_type key, target_type target, const mapped_type& args, const char* err) {
+  try {
+    return call_command(key, args, target);
+  } catch (torrent::input_error& e) {
+    control->core()->push_log((err + std::string(e.what())).c_str());
+    return torrent::Object();
+  }
+}
+
 const CommandMap::mapped_type
 CommandMap::call_command(key_type key, const mapped_type& arg, target_type target) {
   const_iterator itr = base_type::find(key);
 
   if (itr == base_type::end())
     throw torrent::input_error("Command \"" + std::string(key) + "\" does not exist.");
@@ -99,20 +147,23 @@
     else
       throw torrent::input_error("Command type mis-match.");
   }
 
   // This _should_ be optimized int just two calls.
   switch (itr->second.m_target) {
-  case Command::target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
-  case Command::target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
-  case Command::target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
-  case Command::target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
-  case Command::target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
-  case Command::target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
-  case Command::target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+  case Command::target_any:      return itr->second.m_anySlot(itr->second.m_variable, target, arg);
 
+  case Command::target_generic:
+  case Command::target_download:
+  case Command::target_peer:
+  case Command::target_tracker:
+  case Command::target_file:
+  case Command::target_file_itr: return itr->second.m_genericSlot(itr->second.m_variable, (target_wrapper<void>::cleaned_type)target.second, arg);
+
+  // This should only allow target_type to be passed or something, in
+  // order to optimize this away.
   case Command::target_download_pair: return itr->second.m_downloadPairSlot(itr->second.m_variable, (core::Download*)target.second, (core::Download*)target.third, arg);
 
   default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
   }
 }
 
@@ -129,19 +180,20 @@
 
   if (itr->second.m_target != target.first && itr->second.m_target > Command::target_any)
     throw torrent::input_error("Command type mis-match.");
 
   // This _should_ be optimized int just two calls.
   switch (itr->second.m_target) {
-  case Command::target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
-  case Command::target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
-  case Command::target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
-  case Command::target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
-  case Command::target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
-  case Command::target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
-  case Command::target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+  case Command::target_any:      return itr->second.m_anySlot(itr->second.m_variable, target, arg);
+
+  case Command::target_generic:
+  case Command::target_download:
+  case Command::target_peer:
+  case Command::target_tracker:
+  case Command::target_file:
+  case Command::target_file_itr: return itr->second.m_genericSlot(itr->second.m_variable, (target_wrapper<void>::cleaned_type)target.second, arg);
 
   case Command::target_download_pair: return itr->second.m_downloadPairSlot(itr->second.m_variable, (core::Download*)target.second, (core::Download*)target.third, arg);
 
   default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
   }
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_map.h	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_map.h	2008-11-11 00:36:27.000000000 +0800
@@ -59,16 +59,16 @@
 
   command_map_data_type(Command* variable, int flags, const char* parm, const char* doc) :
     m_variable(variable), m_flags(flags), m_parm(parm), m_doc(doc) {}
 
   int                 target() const { return m_target; }
 
-  Command*      m_variable;
+  Command*            m_variable;
 
   union {
-    Command::generic_slot  m_genericSlot;
+    Command::cleaned_slot  m_genericSlot;
     Command::any_slot      m_anySlot;
     Command::download_slot m_downloadSlot;
     Command::file_slot     m_fileSlot;
     Command::file_itr_slot m_fileItrSlot;
     Command::peer_slot     m_peerSlot;
     Command::tracker_slot  m_trackerSlot;
@@ -97,32 +97,42 @@
 
   using base_type::begin;
   using base_type::end;
   using base_type::find;
 
   static const int flag_dont_delete   = 0x1;
-  static const int flag_public_xmlrpc = 0x2;
+  static const int flag_delete_key    = 0x2;
+  static const int flag_public_xmlrpc = 0x4;
+  static const int flag_no_target     = 0x8;
+  static const int flag_modifiable    = 0x10;
 
   CommandMap() {}
   ~CommandMap();
 
   bool                has(const char* key) const        { return base_type::find(key) != base_type::end(); }
   bool                has(const std::string& key) const { return has(key.c_str()); }
 
+  bool                is_modifiable(const_iterator itr) { return itr != end() && (itr->second.m_flags & flag_modifiable); }
+
   iterator            insert(key_type key, Command* variable, int flags, const char* parm, const char* doc);
 
   // Make this a wrapper call to insert without extra fluff.
   template <typename T>
   void                insert_type(key_type key, Command* variable, T targetSlot, int flags, const char* parm, const char* doc) {
     iterator itr = insert(key, variable, flags, parm, doc);
 
     itr->second.m_target      = target_type_id<T>::value; 
-    itr->second.m_genericSlot = (Command::generic_slot)targetSlot;
+    itr->second.m_genericSlot = (Command::cleaned_slot)targetSlot;
   }
 
   void                insert(key_type key, const command_map_data_type src);
+  void                erase(iterator itr);
+
+  const mapped_type   call(key_type key, const mapped_type& args = mapped_type());
+  const mapped_type   call(key_type key, target_type target, const mapped_type& args = mapped_type()) { return call_command(key, args, target); }
+  const mapped_type   call_catch(key_type key, target_type target, const mapped_type& args = mapped_type(), const char* err = "Command failed: ");
 
   const mapped_type   call_command  (key_type key,       const mapped_type& arg, target_type target = target_type((int)Command::target_generic, NULL));
   const mapped_type   call_command  (const_iterator itr, const mapped_type& arg, target_type target = target_type((int)Command::target_generic, NULL));
 
   const mapped_type   call_command_d(key_type key, core::Download* download, const mapped_type& arg)  { return call_command(key, arg, target_type((int)Command::target_download, download)); }
   const mapped_type   call_command_p(key_type key, torrent::Peer* peer, const mapped_type& arg)       { return call_command(key, arg, target_type((int)Command::target_peer, peer)); }
@@ -145,9 +155,34 @@
 
 template <typename T>
 inline target_type make_target_pair(T target1, T target2) {
   return target_type((int)target_type_id<T, T>::value, target1, target2);
 }
 
+// TODO: Helper-functions that really should be in the
+// torrent/object.h header.
+
+inline torrent::Object
+create_object_list(const torrent::Object& o1, const torrent::Object& o2) {
+  torrent::Object tmp = torrent::Object::create_list();
+  tmp.as_list().push_back(o1);
+  tmp.as_list().push_back(o2);
+  return tmp;
+}
+
+inline torrent::Object
+create_object_list(const torrent::Object& o1, const torrent::Object& o2, const torrent::Object& o3) {
+  torrent::Object tmp = torrent::Object::create_list();
+  tmp.as_list().push_back(o1);
+  tmp.as_list().push_back(o2);
+  tmp.as_list().push_back(o3);
+  return tmp;
+}
+
+inline const CommandMap::mapped_type
+CommandMap::call(key_type key, const mapped_type& args) {
+  return call_command(key, args, make_target());
+}
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_slot.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_slot.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_slot.cc	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_slot.cc	2008-09-23 23:28:16.000000000 +0800
@@ -41,27 +41,20 @@
 
 #include "command_slot.h"
 
 namespace rpc {
 
 template <typename Target> const torrent::Object
-CommandSlot<Target>::call_unknown(Command* rawCommand, Target target, const torrent::Object& rawArgs) {
+CommandSlot<Target>::call_unknown(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   return command->m_slot(target, rawArgs);
 }
 
-const torrent::Object
-CommandSlot<void>::call_unknown(Command* rawCommand, const torrent::Object& rawArgs) {
-  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
-
-  return command->m_slot(rawArgs);
-}
-
 template <typename Target> const torrent::Object
-CommandSlot<Target>::call_list(Command* rawCommand, Target target, const torrent::Object& rawArgs) {
+CommandSlot<Target>::call_list(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   switch (rawArgs.type()) {
   case torrent::Object::TYPE_LIST:
     return command->m_slot(target, rawArgs);
 
@@ -76,36 +69,14 @@
   }
   default:
     throw torrent::input_error("Not a list.");
   }
 }
 
-const torrent::Object
-CommandSlot<void>::call_list(Command* rawCommand, const torrent::Object& rawArgs) {
-  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
-
-  switch (rawArgs.type()) {
-  case torrent::Object::TYPE_LIST:
-    return command->m_slot(rawArgs);
-
-  case torrent::Object::TYPE_VALUE:
-  case torrent::Object::TYPE_STRING:
-  case torrent::Object::TYPE_NONE:
-  {
-    torrent::Object tmpList = torrent::Object::create_list();
-    tmpList.as_list().push_back(rawArgs);
-
-    return command->m_slot(tmpList);
-  }
-  default:
-    throw torrent::input_error("Not a list.");
-  }
-}
-
 template <typename Target> const torrent::Object
-CommandSlot<Target>::call_value_base(Command* rawCommand, Target target, const torrent::Object& rawArgs, int base, int unit) {
+CommandSlot<Target>::call_value_base(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs, int base, int unit) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
   case torrent::Object::TYPE_VALUE:
@@ -123,39 +94,14 @@
   }
   default:
     throw torrent::input_error("Not a value.");
   }
 }
 
-const torrent::Object
-CommandSlot<void>::call_value_base(Command* rawCommand, const torrent::Object& rawArgs, int base, int unit) {
-  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
-
-  const torrent::Object& arg = convert_to_single_argument(rawArgs);
-
-  switch (arg.type()) {
-  case torrent::Object::TYPE_VALUE:
-    // Should shift this one too, so it gives the right unit.
-    return command->m_slot(arg);
-
-  case torrent::Object::TYPE_STRING:
-  {
-    torrent::Object argValue = torrent::Object::create_value();
-
-    if (!parse_whole_value_nothrow(arg.as_string().c_str(), &argValue.as_value(), base, unit))
-      throw torrent::input_error("Not a value.");
-
-    return command->m_slot(argValue);
-  }
-  default:
-    throw torrent::input_error("Not a value.");
-  }
-}
-
 template <typename Target> const torrent::Object
-CommandSlot<Target>::call_string(Command* rawCommand, Target target, const torrent::Object& rawArgs) {
+CommandSlot<Target>::call_string(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
 //   case torrent::Object::TYPE_VALUE:
@@ -166,31 +112,12 @@
     break;
 
   default:
     throw torrent::input_error("Not a string.");
   }
 }
-
-const torrent::Object
-CommandSlot<void>::call_string(Command* rawCommand, const torrent::Object& rawArgs) {
-  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
-
-  const torrent::Object& arg = convert_to_single_argument(rawArgs);
-
-  switch (arg.type()) {
-//   case torrent::Object::TYPE_VALUE:
-//     break;
-
-  case torrent::Object::TYPE_STRING:
-    return command->m_slot(arg);
-    break;
-
-  default:
-    throw torrent::input_error("Not a string.");
-  }
-}
 
 torrent::Object
 set_variable_d_fn_t::operator () (core::Download* download, const torrent::Object& arg1) {
   if (m_firstKey == NULL)
     download->bencode()->get_key(m_secondKey) = arg1;
   else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_slot.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_slot.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_slot.h	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_slot.h	2008-09-24 19:36:15.000000000 +0800
@@ -58,62 +58,35 @@
 
 namespace rpc {
 
 template <typename Target>
 class CommandSlot : public Command {
 public:
-  typedef rak::function2<torrent::Object, Target, const torrent::Object&> slot_type;
+  typedef typename target_wrapper<Target>::target_type  target_type;
+  typedef typename target_wrapper<Target>::cleaned_type cleaned_type;
+
+  typedef rak::function2<torrent::Object, target_type, const torrent::Object&> slot_type;
 
   CommandSlot() {}
   CommandSlot(typename slot_type::base_type* s) { m_slot.set(s); }
 
   void                         set_slot(typename slot_type::base_type* s) { m_slot.set(s); }
 
-  static const torrent::Object call_unknown(Command* rawCommand, Target target, const torrent::Object& args);
-
-  static const torrent::Object call_list(Command* rawCommand, Target target, const torrent::Object& args);
-  static const torrent::Object call_string(Command* rawCommand, Target target, const torrent::Object& args);
-
-  static const torrent::Object call_value_base(Command* rawCommand, Target target, const torrent::Object& args, int base, int unit);
-
-  static const torrent::Object call_value(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, 0, 1); }
-  static const torrent::Object call_value_kb(Command* rawCommand, Target target, const torrent::Object& args)  { return call_value_base(rawCommand, target, args, 0, 1 << 10); }
-  static const torrent::Object call_value_oct(Command* rawCommand, Target target, const torrent::Object& args) { return call_value_base(rawCommand, target, args, 8, 1); }
-
-  template <int base, int unit>
-  static const torrent::Object call_value_tmpl(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, base, unit); }
-
-//   static const torrent::Object& get_list(Command* rawCommand, const torrent::Object& args);
-
-private:
-  slot_type           m_slot;
-};
-
-template <>
-class CommandSlot<void> : public Command {
-public:
-  typedef rak::function1<torrent::Object, const torrent::Object&> slot_type;
-
-  CommandSlot() {}
-  CommandSlot(slot_type::base_type* s) { m_slot.set(s); }
-
-  void                         set_slot(slot_type::base_type* s) { m_slot.set(s); }
-
-  static const torrent::Object call_unknown(Command* rawCommand, const torrent::Object& args);
+  static const torrent::Object call_unknown(Command* rawCommand, cleaned_type target, const torrent::Object& args);
 
-  static const torrent::Object call_list(Command* rawCommand, const torrent::Object& args);
-  static const torrent::Object call_string(Command* rawCommand, const torrent::Object& args);
+  static const torrent::Object call_list(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+  static const torrent::Object call_string(Command* rawCommand, cleaned_type target, const torrent::Object& args);
 
-  static const torrent::Object call_value_base(Command* rawCommand, const torrent::Object& args, int base, int unit);
+  static const torrent::Object call_value_base(Command* rawCommand, cleaned_type target, const torrent::Object& args, int base, int unit);
 
-  static const torrent::Object call_value(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, 0, 1); }
-  static const torrent::Object call_value_kb(Command* rawCommand, const torrent::Object& args)  { return call_value_base(rawCommand, args, 0, 1 << 10); }
-  static const torrent::Object call_value_oct(Command* rawCommand, const torrent::Object& args) { return call_value_base(rawCommand, args, 8, 1); }
+  static const torrent::Object call_value(Command* rawCommand, cleaned_type target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, 0, 1); }
+  static const torrent::Object call_value_kb(Command* rawCommand, cleaned_type target, const torrent::Object& args)  { return call_value_base(rawCommand, target, args, 0, 1 << 10); }
+  static const torrent::Object call_value_oct(Command* rawCommand, cleaned_type target, const torrent::Object& args) { return call_value_base(rawCommand, target, args, 8, 1); }
 
   template <int base, int unit>
-  static const torrent::Object call_value_tmpl(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, base, unit); }
+  static const torrent::Object call_value_tmpl(Command* rawCommand, cleaned_type target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, base, unit); }
 
 //   static const torrent::Object& get_list(Command* rawCommand, const torrent::Object& args);
 
 private:
   slot_type           m_slot;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_variable.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_variable.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_variable.cc	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_variable.cc	2008-11-09 17:55:36.000000000 +0800
@@ -39,13 +39,13 @@
 #include "parse.h"
 #include "command_variable.h"
 
 namespace rpc {
 
 const torrent::Object
-CommandVariable::set_bool(Command* rawCommand, const torrent::Object& rawArgs) {
+CommandVariable::set_bool(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
   CommandVariable* variable = static_cast<CommandVariable*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
   case torrent::Object::TYPE_VALUE:
@@ -70,20 +70,20 @@
   }
 
   return variable->m_variable;
 }
 
 const torrent::Object
-CommandVariable::get_bool(Command* rawCommand, const torrent::Object& args) {
+CommandVariable::get_bool(Command* rawCommand, cleaned_type target, const torrent::Object& args) {
   CommandVariable* variable = static_cast<CommandVariable*>(rawCommand);
 
   return variable->m_variable;
 }
 
 const torrent::Object
-CommandVariable::set_value(Command* rawCommand, const torrent::Object& rawArgs) {
+CommandVariable::set_value(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
   CommandVariable* variable = static_cast<CommandVariable*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
   case torrent::Object::TYPE_NONE:
@@ -106,27 +106,27 @@
   }
 
   return variable->m_variable;
 }
 
 const torrent::Object
-CommandVariable::get_value(Command* rawCommand, const torrent::Object& args) {
+CommandVariable::get_value(Command* rawCommand, cleaned_type target, const torrent::Object& args) {
   CommandVariable* variable = static_cast<CommandVariable*>(rawCommand);
 
   return variable->m_variable;
 }
 
 const torrent::Object
-CommandVariable::set_string(Command* rawCommand, const torrent::Object& rawArgs) {
+CommandVariable::set_string(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
   CommandVariable* variable = static_cast<CommandVariable*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
   case torrent::Object::TYPE_NONE:
-    variable->m_variable = std::string("");
+    variable->m_variable = std::string();
     break;
 
 //   case torrent::Object::TYPE_VALUE:
 //     variable->m_variable = arg;
 //     break;
 
@@ -139,13 +139,31 @@
   }
 
   return variable->m_variable;
 }
 
 const torrent::Object
-CommandVariable::get_string(Command* rawCommand, const torrent::Object& args) {
+CommandVariable::get_string(Command* rawCommand, cleaned_type target, const torrent::Object& args) {
   CommandVariable* variable = static_cast<CommandVariable*>(rawCommand);
 
   return variable->m_variable;
 }
 
+//
+// ObjectPtr
+//
+
+const torrent::Object
+CommandObjectPtr::set_generic(Command* rawCommand, cleaned_type target, const torrent::Object& rawArgs) {
+  CommandObjectPtr* command = static_cast<CommandObjectPtr*>(rawCommand);
+
+  return (*command->m_object = rawArgs);
+}
+
+const torrent::Object
+CommandObjectPtr::get_generic(Command* rawCommand, cleaned_type target, const torrent::Object& args) {
+  CommandObjectPtr* command = static_cast<CommandObjectPtr*>(rawCommand);
+
+  return *command->m_object;
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_variable.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_variable.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/command_variable.h	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/command_variable.h	2008-11-09 18:10:21.000000000 +0800
@@ -45,27 +45,54 @@
 #include "command.h"
 
 namespace rpc {
 
 class CommandVariable : public Command {
 public:
+  typedef target_wrapper<void>::cleaned_type cleaned_type;
+
   CommandVariable(const torrent::Object& v = torrent::Object()) : m_variable(v) {}
   
   const torrent::Object variable() const                         { return m_variable; }
   void                  set_variable(const torrent::Object& var) { m_variable = var; }
 
-  static const torrent::Object set_bool(Command* rawCommand, const torrent::Object& args);
-  static const torrent::Object get_bool(Command* rawCommand, const torrent::Object& args);
+  static const torrent::Object set_bool(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+  static const torrent::Object get_bool(Command* rawCommand, cleaned_type target, const torrent::Object& args);
 
-  static const torrent::Object set_value(Command* rawCommand, const torrent::Object& args);
-  static const torrent::Object get_value(Command* rawCommand, const torrent::Object& args);
+  static const torrent::Object set_value(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+  static const torrent::Object get_value(Command* rawCommand, cleaned_type target, const torrent::Object& args);
 
-  static const torrent::Object set_string(Command* rawCommand, const torrent::Object& args);
-  static const torrent::Object get_string(Command* rawCommand, const torrent::Object& args);
+  static const torrent::Object set_string(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+  static const torrent::Object get_string(Command* rawCommand, cleaned_type target, const torrent::Object& args);
 
 private:
   torrent::Object    m_variable;
 };
 
+class CommandObjectPtr : public Command {
+public:
+  typedef target_wrapper<void>::cleaned_type cleaned_type;
+
+  CommandObjectPtr(torrent::Object* obj = NULL) : m_object(obj) {}
+  
+  const torrent::Object* object() const                   { return m_object; }
+  void                   set_object(torrent::Object* obj) { m_object = obj; }
+
+  static const torrent::Object set_generic(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+  static const torrent::Object get_generic(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+
+//   static const torrent::Object set_bool(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+//   static const torrent::Object get_bool(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+
+//   static const torrent::Object set_value(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+//   static const torrent::Object get_value(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+
+//   static const torrent::Object set_string(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+//   static const torrent::Object get_string(Command* rawCommand, cleaned_type target, const torrent::Object& args);
+
+private:
+  torrent::Object*    m_object;
+};
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/Makefile.am	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/Makefile.am	2008-09-24 21:33:25.000000000 +0800
@@ -1,10 +1,12 @@
 noinst_LIBRARIES = libsub_rpc.a
 
 libsub_rpc_a_SOURCES = \
 	command.h \
+	command_function.cc \
+	command_function.h \
 	command_map.cc \
 	command_map.h \
 	command_scheduler.cc \
 	command_scheduler.h \
 	command_scheduler_item.cc \
 	command_scheduler_item.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/Makefile.in	2008-09-12 06:26:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/Makefile.in	2008-11-19 17:05:38.000000000 +0800
@@ -44,17 +44,18 @@
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_rpc_a_AR = $(AR) $(ARFLAGS)
 libsub_rpc_a_LIBADD =
-am_libsub_rpc_a_OBJECTS = command_map.$(OBJEXT) \
-	command_scheduler.$(OBJEXT) command_scheduler_item.$(OBJEXT) \
-	command_slot.$(OBJEXT) command_variable.$(OBJEXT) \
-	exec_file.$(OBJEXT) parse.$(OBJEXT) parse_commands.$(OBJEXT) \
-	scgi.$(OBJEXT) scgi_task.$(OBJEXT) xmlrpc.$(OBJEXT)
+am_libsub_rpc_a_OBJECTS = command_function.$(OBJEXT) \
+	command_map.$(OBJEXT) command_scheduler.$(OBJEXT) \
+	command_scheduler_item.$(OBJEXT) command_slot.$(OBJEXT) \
+	command_variable.$(OBJEXT) exec_file.$(OBJEXT) parse.$(OBJEXT) \
+	parse_commands.$(OBJEXT) scgi.$(OBJEXT) scgi_task.$(OBJEXT) \
+	xmlrpc.$(OBJEXT)
 libsub_rpc_a_OBJECTS = $(am_libsub_rpc_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -195,12 +196,14 @@
 top_build_prefix = @top_build_prefix@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 noinst_LIBRARIES = libsub_rpc.a
 libsub_rpc_a_SOURCES = \
 	command.h \
+	command_function.cc \
+	command_function.h \
 	command_map.cc \
 	command_map.h \
 	command_scheduler.cc \
 	command_scheduler.h \
 	command_scheduler_item.cc \
 	command_scheduler_item.h \
@@ -266,12 +269,13 @@
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_function.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_map.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler_item.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_variable.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exec_file.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/xmlrpc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/xmlrpc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/rpc/xmlrpc.cc	2008-05-07 20:19:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/rpc/xmlrpc.cc	2008-10-07 23:13:30.000000000 +0800
@@ -414,13 +414,16 @@
   }
 
   try {
     torrent::Object object;
     rpc::target_type target = rpc::make_target();
 
-    xmlrpc_to_object(env, args, itr->second.target(), &target).swap(object);
+    if (itr->second.m_flags & CommandMap::flag_no_target)
+      xmlrpc_to_object(env, args, XmlRpc::call_generic, &target).swap(object);
+    else
+      xmlrpc_to_object(env, args, itr->second.target(), &target).swap(object);
 
     if (env->fault_occurred)
       return NULL;
 
     return object_to_xmlrpc(env, rpc::commands.call_command(itr, object, target));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/download_list.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/download_list.cc	2008-11-11 02:29:13.000000000 +0800
@@ -95,13 +95,12 @@
   if (is_active())
     throw torrent::internal_error("ui::DownloadList::activate() called on an already activated object");
 
   m_frame = frame;
 
   control->input()->push_back(&m_bindings);
-  control->core()->download_list()->slot_map_erase()["0_download_list"] = "ui.unfocus_download=";
 
   activate_display(DISPLAY_DOWNLOAD_LIST);
 }
 
 void
 DownloadList::disable() {
@@ -118,12 +117,17 @@
 
 core::View*
 DownloadList::current_view() {
   return dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST])->view();
 }
 
+void
+DownloadList::set_current_view(const std::string& name) {
+  return dynamic_cast<ElementDownloadList*>(m_uiArray[DISPLAY_DOWNLOAD_LIST])->receive_change_view(name);
+}
+
 // This should also do focus_next() or something.
 void
 DownloadList::unfocus_download(core::Download* d) {
   if (current_view()->focus() >= current_view()->end_visible() || *current_view()->focus() != d)
     return;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/download_list.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/download_list.h	2008-11-11 02:28:41.000000000 +0800
@@ -98,12 +98,13 @@
   void                activate(display::Frame* frame, bool focus = true);
   void                disable();
 
   void                activate_display(Display d);
 
   core::View*         current_view();
+  void                set_current_view(const std::string& name);
 
   void                slot_open_uri(SlotOpenUri s) { m_slotOpenUri = s; }
 
   void                unfocus_download(core::Download* d);
 
 private:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/element_peer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/element_peer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/element_peer_list.cc	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/element_peer_list.cc	2008-10-22 21:17:34.000000000 +0800
@@ -72,12 +72,13 @@
   m_elementInfo = create_info();
 
   m_elementInfo->slot_exit(sigc::bind(sigc::mem_fun(this, &ElementPeerList::activate_display), DISPLAY_LIST));
 
   m_bindings['k']       = sigc::mem_fun(this, &ElementPeerList::receive_disconnect_peer);
   m_bindings['*']       = sigc::mem_fun(this, &ElementPeerList::receive_snub_peer);
+  m_bindings['B']       = sigc::mem_fun(this, &ElementPeerList::receive_ban_peer);
   m_bindings[KEY_LEFT] = m_bindings['B' - '@']  = sigc::mem_fun(&m_slotExit, &slot_type::operator());  
   m_bindings[KEY_RIGHT] = m_bindings['F' - '@'] = sigc::bind(sigc::mem_fun(this, &ElementPeerList::activate_display), DISPLAY_INFO);
 
   m_bindings[KEY_UP]   = m_bindings['P' - '@'] = sigc::mem_fun(this, &ElementPeerList::receive_prev);
   m_bindings[KEY_DOWN] = m_bindings['N' - '@'] = sigc::mem_fun(this, &ElementPeerList::receive_next);
 }
@@ -242,12 +243,23 @@
   (*m_listItr)->set_snubbed(!(*m_listItr)->is_snubbed());
 
   update_itr();
 }
 
 void
+ElementPeerList::receive_ban_peer() {
+  if (m_listItr == m_list.end())
+    return;
+
+  (*m_listItr)->set_banned();
+  m_download->download()->connection_list()->erase(*m_listItr, torrent::ConnectionList::disconnect_quick);
+
+  update_itr();
+}
+
+void
 ElementPeerList::update_itr() {
   m_windowList->mark_dirty();
   m_elementInfo->set_target(m_listItr != m_list.end() ? rpc::make_target(*m_listItr) : rpc::make_target());
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/element_peer_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/element_peer_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.3/src/ui/element_peer_list.h	2008-05-07 20:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.8.4/src/ui/element_peer_list.h	2008-10-22 21:04:56.000000000 +0800
@@ -72,12 +72,13 @@
   void                receive_disconnect_peer();
 
   void                receive_peer_connected(torrent::Peer* p);
   void                receive_peer_disconnected(torrent::Peer* p);
 
   void                receive_snub_peer();
+  void                receive_ban_peer();
 
   void                update_itr();
 
   core::Download*     m_download;
   
   Display             m_state;
