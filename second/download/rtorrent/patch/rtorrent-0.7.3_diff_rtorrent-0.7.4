diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/configure	2007-03-26 00:38:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/configure	2007-03-30 06:10:23.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.7.3.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.7.4.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -420,14 +420,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.7.3'
-PACKAGE_STRING='rtorrent 0.7.3'
+PACKAGE_VERSION='0.7.4'
+PACKAGE_STRING='rtorrent 0.7.4'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -962,13 +962,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.7.3 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.7.4 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1028,13 +1028,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.7.3:";;
+     short | recursive ) echo "Configuration of rtorrent 0.7.4:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1180,13 +1180,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.7.3
+rtorrent configure 0.7.4
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1194,13 +1194,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.7.3, which was
+It was created by rtorrent $as_me 0.7.4, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1787,13 +1787,13 @@
 echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 # Define the identity of the package.
  PACKAGE=rtorrent
- VERSION=0.7.3
+ VERSION=0.7.4
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -21445,13 +21445,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.7.3, which was
+This file was extended by rtorrent $as_me 0.7.4, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -21508,13 +21508,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.7.3
+rtorrent config.status 0.7.4
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/configure.ac	2007-03-26 00:33:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/configure.ac	2007-03-30 06:04:36.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.7.3, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.7.4, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/command_scheduler.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/command_scheduler.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/command_scheduler.cc	2007-03-26 00:33:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/command_scheduler.cc	2007-03-25 22:37:16.000000000 +0800
@@ -113,27 +113,27 @@
     throw torrent::internal_error("CommandScheduler::call_item(...) tried to schedule a zero interval item.");
 
   item->enable(next);
 }
 
 void
-CommandScheduler::parse(const std::string& arg) {
-  char key[21];
-  char bufAbsolute[21];
-  char bufInterval[21];
-  char command[2048];
+CommandScheduler::parse(const std::string& key, const std::string& bufAbsolute, const std::string& bufInterval, const std::string& command) {
+//   char key[21];
+//   char bufAbsolute[21];
+//   char bufInterval[21];
+//   char command[2048];
 
-  if (std::sscanf(arg.c_str(), "%20[^,],%20[^,],%20[^,],%2047[^\n]", key, bufAbsolute, bufInterval, command) != 4)
-    throw torrent::input_error("Invalid arguments to command.");
+//   if (std::sscanf(arg.c_str(), "%20[^,],%20[^,],%20[^,],%2047[^\n]", key, bufAbsolute, bufInterval, command) != 4)
+//     throw torrent::input_error("Invalid arguments to command.");
 
-  uint32_t absolute = parse_absolute(bufAbsolute);
-  uint32_t interval = parse_interval(bufInterval);
+  uint32_t absolute = parse_absolute(bufAbsolute.c_str());
+  uint32_t interval = parse_interval(bufInterval.c_str());
 
-  CommandSchedulerItem* item = *insert(rak::trim(std::string(key)));
+  CommandSchedulerItem* item = *insert(key);
 
-  item->set_command(rak::trim(std::string(command)));
+  item->set_command(command);
   item->set_interval(interval);
 
   item->enable((cachedTime + rak::timer::from_seconds(absolute)).round_seconds());
 }
 
 uint32_t
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/command_scheduler.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/command_scheduler.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/command_scheduler.h	2007-03-26 00:33:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/command_scheduler.h	2007-03-25 22:33:47.000000000 +0800
@@ -67,13 +67,13 @@
   // If the key already exists then the old item is deleted. It is
   // safe to call erase on end().
   iterator            insert(const std::string& key);
   void                erase(iterator itr);
   void                erase(const std::string& key)                    { erase(find(key)); }
 
-  void                parse(const std::string& arg);
+  void                parse(const std::string& key, const std::string& bufAbsolute, const std::string& bufInterval, const std::string& command);
 
   static uint32_t     parse_absolute(const char* str);
   static uint32_t     parse_interval(const char* str);
 
   static Time         parse_time(const char* str);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/main.cc	2007-03-26 00:33:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/main.cc	2007-03-25 22:40:00.000000000 +0800
@@ -209,14 +209,14 @@
        "view_add = seeding\n"
        "view_filter = seeding,started,complete\n"
        "view_filter_on = seeding,start,stop\n"
        "view_sort_new = seeding,state_changed\n"
        "view_sort_current = seeding,state_changed_reverse\n"
 
-       "schedule = view_main,10,10,view_sort=main,20\n"
-       "schedule = view_name,10,10,view_sort=name,20\n"
+       "schedule = view_main,10,10,\"view_sort=main,20\"\n"
+       "schedule = view_name,10,10,\"view_sort=name,20\"\n"
        //     "schedule = view_started,10,10,view_sort=started,5\n"
        //     "schedule = view_stopped,10,10,view_sort=stopped,5\n"
        //     "schedule = view_complete,10,10,view_sort=complete,5\n"
        //     "schedule = view_incomplete,10,10,view_sort=incomplete,5\n"
 
        //"schedule = scheduler,10,10,download_scheduler=\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/option_handler_rules.cc	2007-03-26 00:33:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/option_handler_rules.cc	2007-03-27 23:35:31.000000000 +0800
@@ -63,12 +63,13 @@
 #include "core/download_store.h"
 #include "core/manager.h"
 #include "core/scheduler.h"
 #include "core/view_manager.h"
 #include "ui/root.h"
 #include "utils/directory.h"
+#include "utils/parse.h"
 #include "utils/variable_generic.h"
 #include "utils/variable_map.h"
 
 #include "globals.h"
 #include "control.h"
 #include "option_handler_rules.h"
@@ -87,52 +88,30 @@
 
 //   if (control->variable()->has(args))
 
 //   variables->insert("tracker_dump",          new utils::VariableAny(std::string()));
 // }
 
-void
-apply_hash_read_ahead(int arg) {
-  torrent::set_hash_read_ahead(arg << 20);
-}
-
-void
-apply_hash_interval(int arg) {
-  torrent::set_hash_interval(arg * 1000);
-}
+void apply_hash_read_ahead(int arg) { torrent::set_hash_read_ahead(arg << 20); }
+void apply_hash_interval(int arg)   { torrent::set_hash_interval(arg * 1000); }
 
 // The arg string *must* have been checked with validate_port_range
 // first.
 void
 apply_port_range(const std::string& arg) {
   int a = 0, b = 0;
     
   std::sscanf(arg.c_str(), "%i-%i", &a, &b);
 
   control->core()->set_port_range(a, b);
 }
 
-void
-apply_load(const std::string& arg) {
-  control->core()->try_create_download_expand(arg, false, false, true);
-}
-
-void
-apply_load_verbose(const std::string& arg) {
-  control->core()->try_create_download_expand(arg, false, true, true);
-}
-
-void
-apply_load_start(const std::string& arg) {
-  control->core()->try_create_download_expand(arg, true, false, true);
-}
-
-void
-apply_load_start_verbose(const std::string& arg) {
-  control->core()->try_create_download_expand(arg, true, true, true);
-}
+void apply_load(const std::string& arg)               { control->core()->try_create_download_expand(arg, false, false, true); }
+void apply_load_verbose(const std::string& arg)       { control->core()->try_create_download_expand(arg, false, true, true); }
+void apply_load_start(const std::string& arg)         { control->core()->try_create_download_expand(arg, true, false, true); }
+void apply_load_start_verbose(const std::string& arg) { control->core()->try_create_download_expand(arg, true, true, true); }
 
 void
 apply_start_tied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
     if ((*itr)->get_value("state") == 1)
       continue;
@@ -197,71 +176,69 @@
 
     ++itr;
   }
 }
 
 void
-apply_stop_on_ratio(const std::string& arg) {
-  int64_t minRatio = 0;  // first argument:  minimum ratio to reach
-  int64_t minUpload = 0; // second argument: minimum upload amount to reach [optional]
-  int64_t maxRatio = 0;  // third argument:  maximum ratio to reach [optional]
-
-  rak::split_iterator_t<std::string> sitr = rak::split_iterator(arg, ',');
-
-  utils::Variable::string_to_value_unit(rak::trim(*sitr).c_str(), &minRatio, 0, 1);
-
-  if (++sitr != rak::split_iterator(arg))
-    utils::Variable::string_to_value_unit(rak::trim(*sitr).c_str(), &minUpload, 0, 1);
-
-  if (++sitr != rak::split_iterator(arg))
-    utils::Variable::string_to_value_unit(rak::trim(*sitr).c_str(), &maxRatio, 0, 1);
+apply_stop_on_ratio(const torrent::Object::list_type& args) {
+  if (args.empty())
+    throw torrent::input_error("Too few arguments.");
+
+  torrent::Object::list_type::const_iterator argItr = args.begin();
+
+  // first argument:  minimum ratio to reach
+  // second argument: minimum upload amount to reach [optional]
+  // third argument:  maximum ratio to reach [optional]
+  int64_t minRatio  = utils::convert_to_value(*argItr++);
+  int64_t minUpload = argItr != args.end() ? utils::convert_to_value(*argItr++) : 0;
+  int64_t maxRatio  = argItr != args.end() ? utils::convert_to_value(*argItr++) : 0;
 
   core::Manager::DListItr itr = control->core()->download_list()->begin();
 
   while ((itr = std::find_if(itr, control->core()->download_list()->end(), std::mem_fun(&core::Download::is_seeding))) != control->core()->download_list()->end()) {
     int64_t totalUpload = (*itr)->download()->up_rate()->total();
     int64_t totalDone = (*itr)->download()->bytes_done();
 
-    if ((totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) || (maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio)) {
+    if ((totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) ||
+        (maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio)) {
       control->core()->download_list()->stop_try(*itr);
       (*itr)->set("ignore_commands", (int64_t)1);
     }
 
     ++itr;
   }
 }
 
 void
-apply_on_state_change(core::DownloadList::slot_map* slotMap, const std::string& arg) {
-  std::string::const_iterator itr = std::find(arg.begin(), arg.end(), ',');
+apply_on_state_change(core::DownloadList::slot_map* slotMap, const torrent::Object::list_type& args) {
+  if (args.size() < 2)
+    throw torrent::input_error("Too few arguments.");
 
-  std::string key   = rak::trim(std::string(arg.begin(), itr));
-  std::string value = rak::trim(std::string(itr != arg.end() ? itr + 1 : itr, arg.end()));
-
-  if (key.empty())
+  if (args.front().as_string().empty())
     throw torrent::input_error("Empty key.");
 
-  if (value.empty())
-    slotMap->erase("1_start_" + key);
+  std::string key = "1_state_" + args.front().as_string();
+
+  if (args.back().as_string().empty())
+    slotMap->erase(key);
   else
-    (*slotMap)["1_start_" + key] = sigc::bind(sigc::mem_fun(control->download_variables(), &utils::VariableMap::process_d_std_single), value);
+    (*slotMap)[key] = sigc::bind(sigc::mem_fun(control->download_variables(), &utils::VariableMap::process_d_std_single),
+                                 utils::convert_list_to_command(++args.begin(), args.end()));
 }
 
 void
 apply_encoding_list(const std::string& arg) {
   torrent::encoding_list()->push_back(arg);
 }
 
 void
-apply_encryption(const std::string& arg) {
-  rak::split_iterator_t<std::string> sitr = rak::split_iterator(arg, ',');
+apply_encryption(const torrent::Object::list_type& args) {
   uint32_t options_mask = torrent::ConnectionManager::encryption_none;
 
-  while (sitr != rak::split_iterator(arg)) {
-    std::string opt = rak::trim(*sitr);
-    ++sitr;
+  for (torrent::Object::list_type::const_iterator itr = args.begin(), last = args.end(); itr != last; itr++) {
+    const std::string& opt = itr->as_string();
 
     if (opt == "none")
       options_mask = torrent::ConnectionManager::encryption_none;
     else if (opt == "allow_incoming")
       options_mask |= torrent::ConnectionManager::encryption_allow_incoming;
     else if (opt == "try_outgoing")
@@ -279,13 +256,13 @@
   }
 
   torrent::connection_manager()->set_encryption_options(options_mask);
 }
 
 void
-apply_enable_trackers(__UNUSED const std::string& arg) {
+apply_enable_trackers(const std::string& arg) {
   bool state = (arg != "no");
 
   for (core::Manager::DListItr itr = control->core()->download_list()->begin(), last = control->core()->download_list()->end(); itr != last; ++itr) {
 
     torrent::TrackerList tl = (*itr)->download()->tracker_list();
 
@@ -324,116 +301,97 @@
     throw torrent::input_error("Invalid TOS identifier.");
 
   cm->set_priority(value);
 }
 
 void
-apply_view_filter(const std::string& arg) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+apply_view_filter(const torrent::Object::list_type& args) {
+  if (args.size() < 1)
+    throw torrent::input_error("Too few arguments.");
 
-  std::string name = rak::trim(*itr);
+  const std::string& name = args.front().as_string();
   
   if (name.empty())
     throw torrent::input_error("First argument must be a string.");
 
   core::ViewManager::filter_args filterArgs;
 
-  while (++itr != rak::split_iterator(arg)) {
-    filterArgs.push_back(rak::trim(*itr));
-
-    if (filterArgs.back().empty())
-      throw torrent::input_error("One of the arguments is empty.");
-  }
+  for (torrent::Object::list_type::const_iterator itr = ++args.begin(), last = args.end(); itr != last; itr++)
+    filterArgs.push_back(itr->as_string());
 
   control->view_manager()->set_filter(name, filterArgs);
 }
 
 void
-apply_view_filter_on(const std::string& arg) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+apply_view_filter_on(const torrent::Object::list_type& args) {
+  if (args.size() < 1)
+    throw torrent::input_error("Too few arguments.");
 
-  std::string name = rak::trim(*itr);
+  const std::string& name = args.front().as_string();
   
   if (name.empty())
     throw torrent::input_error("First argument must be a string.");
 
   core::ViewManager::filter_args filterArgs;
 
-  while (++itr != rak::split_iterator(arg)) {
-    filterArgs.push_back(rak::trim(*itr));
-
-    if (filterArgs.back().empty())
-      throw torrent::input_error("One of the arguments is empty.");
-  }
+  for (torrent::Object::list_type::const_iterator itr = ++args.begin(), last = args.end(); itr != last; itr++)
+    filterArgs.push_back(itr->as_string());
 
   control->view_manager()->set_filter_on(name, filterArgs);
 }
 
 void
-apply_view_sort(const std::string& arg) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+apply_view_sort(const torrent::Object::list_type& args) {
+  if (args.size() <= 0 || args.size() > 2)
+    throw torrent::input_error("Wrong argument count.");
 
-  std::string name = rak::trim(*itr);
-  ++itr;
+  const std::string& name = args.front().as_string();
 
   if (name.empty())
     throw torrent::input_error("First argument must be a string.");
 
-  // Need some generic tools for this, rather than hacking up
-  // something every time...
-  std::string arg1;
   int32_t value = 0;
 
-  if (itr != rak::split_iterator(arg) && !(arg1 = *itr).empty()) {
-    char* endPtr;
+  if (args.size() == 2)
+    value = utils::convert_to_value(args.back());
 
-    if ((value = strtol(arg1.c_str(), &endPtr, 0)) < 0 || *endPtr != '\0')
-      throw torrent::input_error("Second argument must be a value.");
-  }
-      
   control->view_manager()->sort(name, value);
 }
 
 void
-apply_view_sort_current(const std::string& arg) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+apply_view_sort_current(const torrent::Object::list_type& args) {
+  if (args.size() < 1)
+    throw torrent::input_error("Too few arguments.");
 
-  std::string name = rak::trim(*itr);
+  const std::string& name = args.front().as_string();
   
   if (name.empty())
     throw torrent::input_error("First argument must be a string.");
 
   core::ViewManager::sort_args sortArgs;
 
-  while (++itr != rak::split_iterator(arg)) {
-    sortArgs.push_back(rak::trim(*itr));
-
-    if (sortArgs.back().empty())
-      throw torrent::input_error("One of the arguments is empty.");
-  }
+  for (torrent::Object::list_type::const_iterator itr = ++args.begin(), last = args.end(); itr != last; itr++)
+    sortArgs.push_back(itr->as_string());
 
   control->view_manager()->set_sort_current(name, sortArgs);
 }
 
 void
-apply_view_sort_new(const std::string& arg) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(arg, ',');
+apply_view_sort_new(const torrent::Object::list_type& args) {
+  if (args.size() < 1)
+    throw torrent::input_error("Too few arguments.");
 
-  std::string name = rak::trim(*itr);
+  const std::string& name = args.front().as_string();
   
   if (name.empty())
     throw torrent::input_error("First argument must be a string.");
 
   core::ViewManager::sort_args sortArgs;
 
-  while (++itr != rak::split_iterator(arg)) {
-    sortArgs.push_back(rak::trim(*itr));
-
-    if (sortArgs.back().empty())
-      throw torrent::input_error("One of the arguments is empty.");
-  }
+  for (torrent::Object::list_type::const_iterator itr = ++args.begin(), last = args.end(); itr != last; itr++)
+    sortArgs.push_back(itr->as_string());
 
   control->view_manager()->set_sort_new(name, sortArgs);
 }
 
 void
 apply_import(const std::string& path) {
@@ -445,12 +403,26 @@
 apply_try_import(const std::string& path) {
   if (!control->variable()->process_file(path.c_str()))
     control->core()->push_log("Could not read resource file: " + path);
 }
 
 void
+apply_schedule(const torrent::Object::list_type& args) {
+  if (args.size() < 4)
+    throw torrent::input_error("Too few arguments.");
+
+  torrent::Object::list_type::const_iterator itr = args.begin();
+
+  const std::string& arg1 = (itr++)->as_string();
+  const std::string& arg2 = (itr++)->as_string();
+  const std::string& arg3 = (itr++)->as_string();
+
+  control->command_scheduler()->parse(arg1, arg2, arg3, utils::convert_list_to_command(itr, args.end()));
+}
+
+void
 initialize_variables() {
   utils::VariableMap* variables = control->variable();
 
   variables->insert("check_hash",            new utils::VariableBool(true));
   variables->insert("use_udp_trackers",      new utils::VariableBool(true));
   variables->insert("port_open",             new utils::VariableBool(true));
@@ -511,24 +483,23 @@
 
   variables->insert("print",                 new utils::VariableStringSlot(NULL, rak::mem_fn(control->core(), &core::Manager::push_log)));
   variables->insert("import",                new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_import)));
   variables->insert("try_import",            new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_try_import)));
 
   variables->insert("view_add",              new utils::VariableStringSlot(NULL, rak::mem_fn(control->view_manager(), &core::ViewManager::insert_throw)));
-  variables->insert("view_filter",           new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_view_filter)));
-  variables->insert("view_filter_on",        new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_view_filter_on)));
+  variables->insert("view_filter",           new utils::VariableListSlot(rak::ptr_fn(&apply_view_filter)));
+  variables->insert("view_filter_on",        new utils::VariableListSlot(rak::ptr_fn(&apply_view_filter_on)));
 
-  variables->insert("view_sort",             new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_view_sort)));
-  variables->insert("view_sort_new",         new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_view_sort_new)));
-  variables->insert("view_sort_current",     new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_view_sort_current)));
+  variables->insert("view_sort",             new utils::VariableListSlot(rak::ptr_fn(&apply_view_sort)));
+  variables->insert("view_sort_new",         new utils::VariableListSlot(rak::ptr_fn(&apply_view_sort_new)));
+  variables->insert("view_sort_current",     new utils::VariableListSlot(rak::ptr_fn(&apply_view_sort_current)));
 
   variables->insert("key_layout",            new utils::VariableAny(std::string("qwerty")));
 
-  variables->insert("schedule",              new utils::VariableStringSlot(NULL, rak::mem_fn(control->command_scheduler(), &CommandScheduler::parse)));
-  variables->insert("schedule_remove",       new utils::VariableStringSlot(NULL,
-                                                                           rak::mem_fn<const std::string&>(control->command_scheduler(), &CommandScheduler::erase)));
+  variables->insert("schedule",              new utils::VariableListSlot(rak::ptr_fn(&apply_schedule)));
+  variables->insert("schedule_remove",       new utils::VariableStringSlot(NULL, rak::mem_fn<const std::string&>(control->command_scheduler(), &CommandScheduler::erase)));
 
   variables->insert("download_scheduler",    new utils::VariableVoidSlot(rak::mem_fn(control->scheduler(), &core::Scheduler::update)));
 
   variables->insert("send_buffer_size",      new utils::VariableValueSlot(rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::send_buffer_size),
                                                                           rak::mem_fn(torrent::connection_manager(), &torrent::ConnectionManager::set_send_buffer_size)));
   
@@ -578,29 +549,29 @@
   variables->insert("start_tied",            new utils::VariableVoidSlot(rak::ptr_fn(&apply_start_tied)));
   variables->insert("stop_untied",           new utils::VariableVoidSlot(rak::ptr_fn(&apply_stop_untied)));
   variables->insert("close_untied",          new utils::VariableVoidSlot(rak::ptr_fn(&apply_close_untied)));
   variables->insert("remove_untied",         new utils::VariableVoidSlot(rak::ptr_fn(&apply_remove_untied)));
 
   variables->insert("close_low_diskspace",   new utils::VariableValueSlot(rak::value_fn(int64_t()), rak::ptr_fn(&apply_close_low_diskspace)));
-  variables->insert("stop_on_ratio",         new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_stop_on_ratio)));
+  variables->insert("stop_on_ratio",         new utils::VariableListSlot(rak::ptr_fn(&apply_stop_on_ratio)));
 
-  variables->insert("on_insert",             new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_insert())));
-  variables->insert("on_erase",              new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_erase())));
-  variables->insert("on_open",               new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_open())));
-  variables->insert("on_close",              new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_close())));
-  variables->insert("on_start",              new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_start())));
-  variables->insert("on_stop",               new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_stop())));
-  variables->insert("on_hash_queued",        new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_hash_queued())));
-  variables->insert("on_hash_removed",       new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_hash_removed())));
-  variables->insert("on_hash_done",          new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_hash_done())));
-  variables->insert("on_finished",           new utils::VariableStringSlot(NULL, rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_finished())));
+  variables->insert("on_insert",             new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_insert())));
+  variables->insert("on_erase",              new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_erase())));
+  variables->insert("on_open",               new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_open())));
+  variables->insert("on_close",              new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_close())));
+  variables->insert("on_start",              new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_start())));
+  variables->insert("on_stop",               new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_stop())));
+  variables->insert("on_hash_queued",        new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_hash_queued())));
+  variables->insert("on_hash_removed",       new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_hash_removed())));
+  variables->insert("on_hash_done",          new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_hash_done())));
+  variables->insert("on_finished",           new utils::VariableListSlot(rak::bind_ptr_fn(&apply_on_state_change, &control->core()->download_list()->slot_map_finished())));
 
   variables->insert("enable_trackers",       new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_enable_trackers)));
   variables->insert("encoding_list",         new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_encoding_list)));
 
-  variables->insert("encryption",            new utils::VariableStringSlot(NULL, rak::ptr_fn(&apply_encryption)));
+  variables->insert("encryption",            new utils::VariableListSlot(rak::ptr_fn(&apply_encryption)));
   variables->insert("handshake_log",         new utils::VariableBool(false));
 }
 
 template <typename Target, typename GetFunc, typename SetFunc>
 utils::Variable*
 var_d_value(Target target, GetFunc getFunc, SetFunc setFunc) {
@@ -619,18 +590,21 @@
 utils::Variable*
 var_d2_get_value(Target target, GetFunc getFunc) {
   return new utils::VariableDownloadValueSlot(rak::ftor_fn1(rak::on(rak::on(std::mem_fun(&core::Download::download), std::mem_fun(target)), std::mem_fun(getFunc))), NULL);
 }
 
 void
-apply_d_create_link(core::Download* download, const std::string& args) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(args, ',');
-
-  std::string type    = rak::trim(*itr); ++itr;
-  std::string prefix  = rak::trim(*itr); ++itr;
-  std::string postfix = rak::trim(*itr); ++itr;
+apply_d_create_link(core::Download* download, const torrent::Object::list_type& args) {
+  if (args.size() != 3)
+    throw torrent::input_error("Wrong argument count.");
+
+  torrent::Object::list_type::const_iterator itr = args.begin();
+
+  const std::string& type    = (itr++)->as_string();
+  const std::string& prefix  = (itr++)->as_string();
+  const std::string& postfix = (itr++)->as_string();
   
   if (type.empty())
     throw torrent::input_error("Invalid arguments.");
 
   std::string target;
   std::string link;
@@ -660,18 +634,21 @@
 //     control->core()->push_log("create_link failed: " + std::string(rak::error_number::current().c_str()));
 //     control->core()->push_log("create_link failed: " + std::string(rak::error_number::current().c_str()) + " to " + target);
     ; // Disabled.
 }
 
 void
-apply_d_delete_link(core::Download* download, const std::string& args) {
-  rak::split_iterator_t<std::string> itr = rak::split_iterator(args, ',');
-
-  std::string type    = rak::trim(*itr); ++itr;
-  std::string prefix  = rak::trim(*itr); ++itr;
-  std::string postfix = rak::trim(*itr); ++itr;
+apply_d_delete_link(core::Download* download, const torrent::Object::list_type& args) {
+  if (args.size() != 3)
+    throw torrent::input_error("Wrong argument count.");
+
+  torrent::Object::list_type::const_iterator itr = args.begin();
+
+  const std::string& type    = (itr++)->as_string();
+  const std::string& prefix  = (itr++)->as_string();
+  const std::string& postfix = (itr++)->as_string();
   
   if (type.empty())
     throw torrent::input_error("Invalid arguments.");
 
   std::string link;
 
@@ -779,9 +756,9 @@
   variables->insert("tracker_numwant",    var_d_value(&core::Download::tracker_list, &torrent::TrackerList::numwant, &torrent::TrackerList::set_numwant));
 
   variables->insert("ignore_commands",    new utils::VariableObject("rtorrent", "ignore_commands", torrent::Object::TYPE_VALUE));
 
   // Hmm... do we need dupicates?
   variables->insert("print",              new utils::VariableStringSlot(NULL, rak::mem_fn(control->core(), &core::Manager::push_log)));
-  variables->insert("create_link",        new utils::VariableDownloadStringSlot(NULL, rak::ptr_fn(&apply_d_create_link)));
-  variables->insert("delete_link",        new utils::VariableDownloadStringSlot(NULL, rak::ptr_fn(&apply_d_delete_link)));
+  variables->insert("create_link",        new utils::VariableDownloadListSlot(rak::ptr_fn(&apply_d_create_link)));
+  variables->insert("delete_link",        new utils::VariableDownloadListSlot(rak::ptr_fn(&apply_d_delete_link)));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/Makefile.am	2007-03-26 00:33:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/Makefile.am	2007-03-24 08:37:20.000000000 +0800
@@ -3,12 +3,14 @@
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
 	list_focus.h \
 	lockfile.cc \
 	lockfile.h \
+	parse.cc \
+	parse.h \
 	variable.cc \
 	variable.h \
 	variable_generic.cc \
 	variable_generic.h \
 	variable_map.cc \
 	variable_map.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/Makefile.in	2007-03-26 00:38:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/Makefile.in	2007-03-30 06:10:21.000000000 +0800
@@ -97,12 +97,14 @@
 libsub_utils_a_SOURCES = \
 	directory.cc \
 	directory.h \
 	list_focus.h \
 	lockfile.cc \
 	lockfile.h \
+	parse.cc \
+	parse.h \
 	variable.cc \
 	variable.h \
 	variable_generic.cc \
 	variable_generic.h \
 	variable_map.cc \
 	variable_map.h
@@ -115,25 +117,25 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 
 libsub_utils_a_AR = $(AR) cru
 libsub_utils_a_LIBADD =
 am_libsub_utils_a_OBJECTS = directory.$(OBJEXT) lockfile.$(OBJEXT) \
-	variable.$(OBJEXT) variable_generic.$(OBJEXT) \
+	parse.$(OBJEXT) variable.$(OBJEXT) variable_generic.$(OBJEXT) \
 	variable_map.$(OBJEXT)
 libsub_utils_a_OBJECTS = $(am_libsub_utils_a_OBJECTS)
 
 DEFS = @DEFS@
 DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
 CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 @AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/directory.Po ./$(DEPDIR)/lockfile.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/variable.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/parse.Po ./$(DEPDIR)/variable.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/variable_generic.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/variable_map.Po
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
 LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) \
 	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
@@ -176,12 +178,13 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/directory.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lockfile.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable_generic.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/variable_map.Po@am__quote@
 
 distclean-depend:
 	-rm -rf ./$(DEPDIR)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils: parse.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils: parse.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/variable_generic.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/variable_generic.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/variable_generic.cc	2007-03-26 00:33:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/variable_generic.cc	2007-03-26 00:26:36.000000000 +0800
@@ -35,12 +35,13 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdlib.h>
 
+#include "parse.h"
 #include "variable_generic.h"
 
 namespace utils {
 
 const torrent::Object& VariableAny::get() { return m_variable; }
 void VariableAny::set(const torrent::Object& arg) { m_variable = arg; }
@@ -246,12 +247,15 @@
   case torrent::Object::TYPE_STRING:
     m_slotSet(arg.as_string());
     break;
   case torrent::Object::TYPE_NONE:
     m_slotSet(std::string());
     break;
+  case torrent::Object::TYPE_LIST:
+    m_slotSet(convert_list_to_string(arg));
+    break;
   default:
     throw torrent::input_error("Not a string.");
   }
 }
 
 const torrent::Object&
@@ -277,7 +281,33 @@
     break;
   default:
     throw torrent::input_error("Not a string.");
   }
 }
 
+void
+VariableListSlot::set(const torrent::Object& arg) {
+  switch (arg.type()) {
+//   case torrent::Object::TYPE_STRING:
+//     break;
+  case torrent::Object::TYPE_LIST:
+    m_slotSet(arg.as_list());
+    break;
+  default:
+    throw torrent::input_error("Not a list.");
+  }
+}
+
+void
+VariableDownloadListSlot::set_d(core::Download* download, const torrent::Object& arg) {
+  switch (arg.type()) {
+//   case torrent::Object::TYPE_STRING:
+//     break;
+  case torrent::Object::TYPE_LIST:
+    m_slotSet(download, arg.as_list());
+    break;
+  default:
+    throw torrent::input_error("Not a list.");
+  }
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/variable_generic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/variable_generic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/variable_generic.h	2007-03-26 00:33:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/variable_generic.h	2007-03-25 23:54:07.000000000 +0800
@@ -292,9 +292,39 @@
   // Store the cache here to avoid unnessesary copying and such. This
   // should not result in any unresonable memory usage since few
   // strings will be very large.
   torrent::Object     m_cache;
 };
 
+class VariableListSlot : public Variable {
+public:
+  typedef rak::function1<void, const list_type&> slot_set_type;
+
+  template <typename SlotSet>
+  VariableListSlot(SlotSet* slotSet) {
+    m_slotSet.set(slotSet);
+  }
+
+  virtual void        set(const torrent::Object& arg);
+
+private:
+  slot_set_type       m_slotSet;
+};
+
+class VariableDownloadListSlot : public Variable {
+public:
+  typedef rak::function2<void, core::Download*, const list_type&> slot_set_type;
+
+  template <typename SlotSet>
+  VariableDownloadListSlot(SlotSet* slotSet) {
+    m_slotSet.set(slotSet);
+  }
+
+  virtual void        set_d(core::Download* download, const torrent::Object& arg);
+
+private:
+  slot_set_type       m_slotSet;
+};
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/variable_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/variable_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.3/src/utils/variable_map.cc	2007-03-26 00:33:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.4/src/utils/variable_map.cc	2007-03-25 01:47:00.000000000 +0800
@@ -42,12 +42,13 @@
 #include <fstream>
 #include <rak/functional.h>
 #include <rak/path.h>
 #include <torrent/exceptions.h>
 #include <torrent/object.h>
 
+#include "parse.h"
 #include "variable.h"
 #include "variable_map.h"
 
 namespace utils {
 
 VariableMap::~VariableMap() {
@@ -130,49 +131,12 @@
     dest->push_back(*first);
 
   return first;
 }
 
 const char*
-parse_unknown(const char* first, const char* last, VariableMap::mapped_type* dest) {
-  if (*first == '"') {
-    const char* next = std::find_if(++first, last, std::bind2nd(std::equal_to<char>(), '"'));
-    
-    if (first == last || first == next || next == last)
-      throw torrent::input_error("Could not find closing '\"'.");
-
-    *dest = std::string(first, next);
-    return ++next;
-
-  } else {
-    // Add rak::or and check for ','.
-    const char* next = std::find_if(first, last, variable_map_is_space());
-
-    *dest = std::string(first, next);
-    return next;
-  }
-}
-
-const char*
-parse_args(const char* first, const char* last, VariableMap::mapped_type::list_type* dest) {
-  first = std::find_if(first, last, std::not1(variable_map_is_space()));
-
-  while (first != last) {
-    dest->push_back(VariableMap::mapped_type());
-
-    first = parse_unknown(first, last, &dest->back());
-    first = std::find_if(first, last, std::not1(variable_map_is_space()));
-
-    if (first != last && *first != ',')
-      throw torrent::input_error("A string with blanks must be quoted.");
-  }
-
-  return first;
-}
-
-const char*
 VariableMap::process_single(const char* first) {
   // This could be optimized, but dunno if there's any point in doing
   // it.
   return process_single(first, first + std::strlen(first));
 }
 
@@ -187,25 +151,18 @@
   first = parse_name(first, last, &key);
   first = std::find_if(first, last, std::not1(variable_map_is_space()));
   
   if (first == last || *first != '=')
     throw torrent::input_error("Could not find '='.");
 
-  mapped_type args(mapped_type::TYPE_LIST);
-  first = parse_args(first + 1, last, &args.as_list());
-
-  if (args.as_list().empty())
-    set(key.c_str(), mapped_type());
+  mapped_type args;
+  first = parse_whole_list(first + 1, last, &args);
 
-  else if (++args.as_list().begin() == args.as_list().end())
-    set(key.c_str(), *args.as_list().begin());
+  set(key.c_str(), args);
 
-  else
-    set(key.c_str(), args);
-
-  return std::find_if(first, last, std::not1(variable_map_is_space()));
+  return first;
 }
 
 const char*
 VariableMap::process_d_single(core::Download* download, const char* first, const char* last) {
   first = std::find_if(first, last, std::not1(variable_map_is_space()));
 
@@ -216,73 +173,42 @@
   first = parse_name(first, last, &key);
   first = std::find_if(first, last, std::not1(variable_map_is_space()));
   
   if (first == last || *first != '=')
     throw torrent::input_error("Could not find '='.");
 
-  mapped_type args(mapped_type::TYPE_LIST);
-  first = parse_args(first + 1, last, &args.as_list());
-
-  if (args.as_list().empty())
-    set_d(download, key.c_str(), mapped_type());
-
-  else if (++args.as_list().begin() == args.as_list().end())
-    set_d(download, key.c_str(), *args.as_list().begin());
+  mapped_type args;
+  first = parse_whole_list(first + 1, last, &args);
 
-  else
-    set_d(download, key.c_str(), args);
+  set_d(download, key.c_str(), args);
 
-  return std::find_if(first, last, std::not1(variable_map_is_space()));
+  return first;
 }
 
-// void
-// VariableMap::process_command(const std::string& command) {
-//   std::string::const_iterator pos = command.begin();
-//   pos = std::find_if(pos, command.end(), std::not1(variable_map_is_space()));
-
-//   if (pos == command.end() || *pos == '#')
-//     return;
-
-//   // Replace with parse_unknown?
-//   std::string key;
-//   pos = parse_name(pos, command.end(), &key);
-//   pos = std::find_if(pos, command.end(), std::not1(variable_map_is_space()));
-  
-//   if (pos == command.end() || *pos != '=')
-//     throw torrent::input_error("Could not find '='.");
-
-//   mapped_type args(mapped_type::TYPE_LIST);
-//   parse_args(pos + 1, command.end(), &args.as_list());
-
-//   if (args.as_list().empty())
-//     set(key.c_str(), mapped_type());
-
-//   else if (++args.as_list().begin() == args.as_list().end())
-//     set(key.c_str(), *args.as_list().begin());
-
-//   else
-//     set(key.c_str(), args);
-
-
 // Consider what the command scheduler should do.
 
 void
 VariableMap::process_multiple(const char* first) {
-  while (first != '\0') {
-    const char* last = first;
+  try {
+    while (first != '\0') {
+      const char* last = first;
+
+      while (*last != '\n' && *last != '\0') last++;
 
-    while (*last != '\n' && *last != '\0') last++;
+      // Should we check the return value? Probably not necessary as
+      // parse_args throws on unquoted multi-word input.
+      process_single(first, last);
 
-    // Should we check the return value? Probably not necessary as
-    // parse_args throws on unquoted multi-word input.
-    process_single(first, last);
+      if (*last == '\0')
+        return;
 
-    if (*last == '\0')
-      return;
+      first = last + 1;
+    }
 
-    first = last + 1;
+  } catch (torrent::input_error& e) {
+    throw torrent::input_error(std::string("Error parsing multi-line option: ") + e.what());
   }
 }
 
 bool
 VariableMap::process_file(key_type path) {
   std::fstream file(rak::path_expand(path).c_str(), std::ios::in);
