diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/configure	2006-02-12 00:13:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure	2006-04-07 01:38:55.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.59 for rtorrent 0.4.5.
+# Generated by GNU Autoconf 2.59 for rtorrent 0.5.0.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
@@ -420,14 +420,14 @@
 # only ac_max_sed_lines should be used.
 : ${ac_max_here_lines=38}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.4.5'
-PACKAGE_STRING='rtorrent 0.4.5'
+PACKAGE_VERSION='0.5.0'
+PACKAGE_STRING='rtorrent 0.5.0'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -950,13 +950,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.4.5 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.5.0 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1016,13 +1016,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.4.5:";;
+     short | recursive ) echo "Configuration of rtorrent 0.5.0:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1160,13 +1160,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.4.5
+rtorrent configure 0.5.0
 generated by GNU Autoconf 2.59
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1174,13 +1174,13 @@
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.4.5, which was
+It was created by rtorrent $as_me 0.5.0, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
@@ -1818,13 +1818,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.4.5'
+ VERSION='0.5.0'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -20058,37 +20058,37 @@
      echo "*** in your path, or set the PKG_CONFIG environment variable"
      echo "*** to the full path to pkg-config."
      echo "*** Or see http://www.freedesktop.org/software/pkgconfig to get pkg-config."
   else
      PKG_CONFIG_MIN_VERSION=0.9.0
      if $PKG_CONFIG --atleast-pkgconfig-version $PKG_CONFIG_MIN_VERSION; then
-        echo "$as_me:$LINENO: checking for sigc++-2.0 libtorrent >= 0.8.0" >&5
-echo $ECHO_N "checking for sigc++-2.0 libtorrent >= 0.8.0... $ECHO_C" >&6
+        echo "$as_me:$LINENO: checking for sigc++-2.0 libtorrent >= 0.9.0" >&5
+echo $ECHO_N "checking for sigc++-2.0 libtorrent >= 0.9.0... $ECHO_C" >&6
 
-        if $PKG_CONFIG --exists "sigc++-2.0 libtorrent >= 0.8.0" ; then
+        if $PKG_CONFIG --exists "sigc++-2.0 libtorrent >= 0.9.0" ; then
             echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6
             succeeded=yes
 
             echo "$as_me:$LINENO: checking STUFF_CFLAGS" >&5
 echo $ECHO_N "checking STUFF_CFLAGS... $ECHO_C" >&6
-            STUFF_CFLAGS=`$PKG_CONFIG --cflags "sigc++-2.0 libtorrent >= 0.8.0"`
+            STUFF_CFLAGS=`$PKG_CONFIG --cflags "sigc++-2.0 libtorrent >= 0.9.0"`
             echo "$as_me:$LINENO: result: $STUFF_CFLAGS" >&5
 echo "${ECHO_T}$STUFF_CFLAGS" >&6
 
             echo "$as_me:$LINENO: checking STUFF_LIBS" >&5
 echo $ECHO_N "checking STUFF_LIBS... $ECHO_C" >&6
-            STUFF_LIBS=`$PKG_CONFIG --libs "sigc++-2.0 libtorrent >= 0.8.0"`
+            STUFF_LIBS=`$PKG_CONFIG --libs "sigc++-2.0 libtorrent >= 0.9.0"`
             echo "$as_me:$LINENO: result: $STUFF_LIBS" >&5
 echo "${ECHO_T}$STUFF_LIBS" >&6
         else
             STUFF_CFLAGS=""
             STUFF_LIBS=""
             ## If we have a custom action on failure, don't print errors, but
             ## do set a variable so people can do so.
-            STUFF_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sigc++-2.0 libtorrent >= 0.8.0"`
+            STUFF_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sigc++-2.0 libtorrent >= 0.9.0"`
             echo $STUFF_PKG_ERRORS
         fi
 
 
 
      else
@@ -20098,14 +20098,14 @@
   fi
 
   if test $succeeded = yes; then
      CXXFLAGS="$CXXFLAGS $STUFF_CFLAGS $CURL_CFLAGS";
 		  LIBS="$LIBS $STUFF_LIBS $CURL_LIBS"
   else
-     { { echo "$as_me:$LINENO: error: Library requirements (sigc++-2.0 libtorrent >= 0.8.0) not met; consider adjusting the PKG_CONFIG_PATH environment variable if your libraries are in a nonstandard prefix so pkg-config can find them." >&5
-echo "$as_me: error: Library requirements (sigc++-2.0 libtorrent >= 0.8.0) not met; consider adjusting the PKG_CONFIG_PATH environment variable if your libraries are in a nonstandard prefix so pkg-config can find them." >&2;}
+     { { echo "$as_me:$LINENO: error: Library requirements (sigc++-2.0 libtorrent >= 0.9.0) not met; consider adjusting the PKG_CONFIG_PATH environment variable if your libraries are in a nonstandard prefix so pkg-config can find them." >&5
+echo "$as_me: error: Library requirements (sigc++-2.0 libtorrent >= 0.9.0) not met; consider adjusting the PKG_CONFIG_PATH environment variable if your libraries are in a nonstandard prefix so pkg-config can find them." >&2;}
    { (exit 1); exit 1; }; }
   fi
 
 
 
 cat >>confdefs.h <<\_ACEOF
@@ -20562,13 +20562,13 @@
   sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
-This file was extended by rtorrent $as_me 0.4.5, which was
+This file was extended by rtorrent $as_me 0.5.0, which was
 generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -20625,13 +20625,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.4.5
+rtorrent config.status 0.5.0
 configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/configure.ac	2006-02-05 09:18:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/configure.ac	2006-03-18 06:41:31.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.4.5, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.5.0, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
@@ -21,13 +21,13 @@
 TORRENT_CHECK_EXECINFO()
 TORRENT_CHECK_CURL()
 TORRENT_OTFD()
 
 TORRENT_WITHOUT_VARIABLE_FDSET()
 
-PKG_CHECK_MODULES(STUFF, sigc++-2.0 libtorrent >= 0.8.0,
+PKG_CHECK_MODULES(STUFF, sigc++-2.0 libtorrent >= 0.9.0,
 	          CXXFLAGS="$CXXFLAGS $STUFF_CFLAGS $CURL_CFLAGS";
 		  LIBS="$LIBS $STUFF_LIBS $CURL_LIBS")
 
 AC_DEFINE(HAVE_CONFIG_H, 1, true if config.h was included)
 
 CC_ATTRIBUTE_UNUSED(
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/doc/rtorrent.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/doc/rtorrent.1	2006-02-14 00:51:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1	2006-04-06 23:49:42.000000000 +0800
@@ -1,12 +1,12 @@
 .\" This manpage has been automatically generated by docbook2man 
 .\" from a DocBook document.  This tool can be found at:
 .\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
 .\" Please send any bug reports, improvements, comments, patches, 
 .\" etc. to Steve Cheng <steve@ggi-project.org>.
-.TH "RTORRENT" "1" "13 February 2006" "BitTorrent client for ncurses" ""
+.TH "RTORRENT" "1" "06 April 2006" "BitTorrent client for ncurses" ""
 
 .SH NAME
 rtorrent \- a BitTorrent client for ncurses
 .SH SYNOPSIS
 
 \fBrtorrent\fR [ \fB-h\fR ] [ \fB-o key1=opt1,...\fR ] [ \fB-O key=opt\fR ] [ \fBURL | FILE\fR\fI ...\fR ]
@@ -87,27 +87,36 @@
 \fB3 | 4\fR
 Adjust min peers.
 .TP
 \fB5 | 6\fR
 Adjust max peers.
 .TP
+\fBi\fR
+Display chunk rarity.
+.TP
 \fBo\fR
 Display the tracker list. Cycle the trackers in a group
 with the space-bar.
 .TP
 \fBp\fR
 View peer and torrent information.
 .TP
 \fBt | T\fR
-Initiate tracker request. Use capital T to force the
-request, ignoring the "min interval" set by the tracker.
+Initiate tracker request. Use capital T to force the request, ignoring
+the "min interval" set by the tracker.
+.TP
+\fBk\fR
+Disconnect peer.
+.TP
+\fB*\fR
+Choke/Snubb peer.
 .SH "OPTIONS"
 .TP
 \fB-b \fIa.b.c.d\fB\fR
-Bind listening socket and outgoing connections to this
-network interface address.
+Bind listening socket and outgoing connections to this network
+interface address.
 .TP
 \fB-d \fIdirectory\fB\fR
 Set the default download directory. Defaults to "./".
 .TP
 \fB-h\fR
 Display help and exit.
@@ -120,146 +129,158 @@
 \fB-O key=opt\fR
 Set any number of options, see the SETTINGS section. The options given
 here override the resource files. Use capital \fB-O\fR
 to allow comma in the option.
 .TP
 \fB-p \fIa-b\fB\fR
-Try to open a listening port in the range
-\fBa\fR up to and including
-\fBb\fR\&.
+Try to open a listening port in the range \fBa\fR up to
+and including \fBb\fR\&.
 .TP
 \fB-s \fIdirectory\fB\fR
-Session management will be enabled and the torrent files for
-all open downloads will be stored in this directory. Only
-one instance of rtorrent should be used with each session
-directory, though at the moment no locking is done. An empty
-string will disable the session directory.
+Session management will be enabled and the torrent files for all open
+downloads will be stored in this directory. Only one instance of
+rtorrent should be used with each session directory, though at the
+moment no locking is done. An empty string will disable the session
+directory.
 .SH "GENERAL SETTINGS"
 .PP
 .TP
 \fBmax_peers = \fIvalue\fB\fR
 Set the maximum number of peers to allow in each download.
 .TP
 \fBmin_peers = \fIvalue\fB\fR
-Set the minimum number of peers to try to connect to in each
-download.
+Set the minimum number of peers to try to connect to in each download.
 .TP
 \fBmax_uploads = \fIvalue\fB\fR
 Set the maximum number of simultaneous uploads per download.
 .TP
 \fBdownload_rate = \fIKB\fB\fR
 Set the maximum global download rate.
 .TP
 \fBupload_rate = \fIKB\fB\fR
 Set the maximum global upload rate.
 .TP
 \fBbind = \fIa.b.c.d\fB\fR
-Bind listening socket and outgoing connections to this
-network interface address.
+Bind listening socket and outgoing connections to this network
+interface address.
 .TP
 \fBip = \fIa.b.c.d\fB\fR
 Set the address reported to the tracker.
 .TP
 \fBport_range = \fIa-b\fB\fR
-Try to open a listening port in the range
-\fBa\fR up to and including
-\fBb\fR\&.
+Try to open a listening port in the range \fBa\fR up to
+and including \fBb\fR\&.
 .TP
 \fBport_random = \fIyes | no\fB\fR
 Open the listening port at a random position in the port range.
 .TP
 \fBcheck_hash = \fIyes | no\fB\fR
 Perform hash check on finished downloads.
 .TP
 \fBdirectory = \fIdirectory\fB\fR
 Set the default download directory. Defaults to "./".
 .TP
 \fBsession = \fIdirectory\fB\fR
-Session management will be enabled and the torrent files for
-all open downloads will be stored in this directory. Only
-one instance of rtorrent should be used with each session
-directory, though at the moment no locking is done. An empty
-string will disable the session directory.
+Session management will be enabled and the torrent files for all open
+downloads will be stored in this directory. Only one instance of
+rtorrent should be used with each session directory, though at the
+moment no locking is done. An empty string will disable the session
+directory.
 .TP
 \fBhttp_proxy = \fIurl\fB\fR
 Use a http proxy. Use an empty string to disable.
 .TP
 \fBencoding_list = \fIencoding\fB\fR
-Add a preferred filename encoding to the list. The encodings
-are attempted in the order they are inserted, if none match
-the torrent default is used.
+Add a preferred filename encoding to the list. The encodings are
+attempted in the order they are inserted, if none match the torrent
+default is used.
 .TP
 \fBschedule = \fIid\fB,\fIstart\fB,\fIinterval\fB,\fIcommand\fB\fR
 Call \fBcommand\fR every \fBinterval\fR
 seconds, starting from \fBstart\fR\&. An
 \fBinterval\fR of zero calls the task once, while a
 \fBstart\fR of zero calls it immediately. Currently
 \fBcommand\fR is forwarded to the option handler.
 \fBstart\fR and \fBinterval\fR may
 optionally use a time format, \fBdd:hh:mm:ss\fR\&. F.ex to
 start a task every day at \fB18:00\fR, use
-\fB18:00:00\fR\&.
+\fB18:00:00,24:00:00\fR\&.
 .TP
 \fBschedule_remove = \fIid\fB\fR
 Delete \fBid\fR from the scheduler.
 .TP
+\fBstop_untied =\fR
+.TP
+\fBremove_untied =\fR
+Stop or remove the torrents that are tied to filenames that have been
+deleted, the association is then cleared.
+.TP
 \fBload = \fIfile\fB\fR
 .TP
 \fBload_start = \fIfile\fB\fR
 Load and possibly start a file, or possibly mutiple files by using the
 wildcard "*". This is meant for use with
 \fBschedule\fR, though ensure that the
 \fBstart\fR is non-zero. The loaded file will be tied
 to the filename provided.
 .TP
-\fBstop_untied =\fR
+\fBimport = \fIfile\fB\fR
 .TP
-\fBremove_untied =\fR
-Stop or remove the torrents that are tied to filenames that have been
-deleted, the association is then cleared.
+\fBtry_import = \fIfile\fB\fR
+Load a resource file. \fBtry_import\fR does not throw
+torrent::input_error exception on bad input.
 .SH "ADVANCED SETTINGS"
 .PP
 This list contains settings users shouldn't need to touch.
 .TP
 \fBhash_read_ahead = \fIMB\fB\fR
-Configure how far ahead we ask the kernel to read when doing
-hash checking. The hash checker uses madvise(...,
-MADV_WILLNEED) for the requests.
+Configure how far ahead we ask the kernel to read when doing hash
+checking. The hash checker uses madvise(..., MADV_WILLNEED) for the
+requests.
 .TP
 \fBhash_interval = \fIms\fB\fR
-Interval between attempts to check the hash when the chunk
-is not in memory, in milliseconds.
+Interval between attempts to check the hash when the chunk is not in
+memory, in milliseconds.
 .TP
 \fBhash_max_tries = \fItries\fB\fR
-Number of attempts to check the hash while using the mincore
-status, before forcing. Overworked systems might need lower
-values to get a decent hash checking rate.
+Number of attempts to check the hash while using the mincore status,
+before forcing. Overworked systems might need lower values to get a
+decent hash checking rate.
 .TP
 \fBmax_open_files = \fIvalue\fB\fR
-Number of files to simultaneously keep open. Libtorrent
-dynamically opens and closes files when mapping files to
-memory. Defaults to 128.
+Number of files to simultaneously keep open. Libtorrent dynamically
+opens and closes files when mapping files to memory. Defaults to 128.
 .TP
 \fBmax_open_sockets = \fIvalue\fB\fR
-Number of sockets to simultaneously keep open. This value is
-set to be \fBsysconf(_SC_OPEN_MAX) - 256\fR
-at startup. This gives the client 128 sockets to use as it
-wishes.
+Number of sockets to simultaneously keep open. This value is set to be
+\fBsysconf(_SC_OPEN_MAX) - 256\fR at startup. This
+gives the client 128 sockets to use as it wishes.
 .TP
 \fBumask = \fI0644\fB\fR
-Set the umask for this process, which is applied to all
-files created by the program.
+Set the umask for this process, which is applied to all files created
+by the program.
 .TP
 \fBworking_directory = \fIdirectory\fB\fR
 Changes the working directory of the process using
 \fBchdir\fR\&.
 .TP
 \fBsession_on_completion = \fIyes\fB\fR
 Controls whetever the session torrent is updated when a torrent
 finishes. By default on.
 .TP
 \fBsession_lock = \fIyes\fB\fR
 Controls whetever a lock file is created in the session directory.
+.TP
+\fBtracker_dump = \fIfilename\fB\fR
+Dump tracker requests to \fBfilename\fR, disable by
+supplying an empty string. Only torrents loaded while
+\fBtracker_dump\fR contains a non-empty string will be
+logged at the moment, although disabling it will work as expected.
+.TP
+\fBtos = \fIdefault|lowdelay|throughput|reliability|mincost\fB\fR
+Change the TOS of peer connections, by default set to
+\fBthroughput\fR\&. If the option is set to
+\fBdefault\fR then the system default TOS is used.
 .SH "AUTHORS"
 .PP
 
 Jari "Rakshasa" Sundell <jaris@ifi.uio.no>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/doc/rtorrent.1.xml	2006-02-14 00:51:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/doc/rtorrent.1.xml	2006-04-06 23:49:37.000000000 +0800
@@ -216,31 +216,64 @@
 	  <listitem><para>
             Adjust max peers.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
+	  <term>i</term>
+	  <listitem><para>
+
+Display chunk rarity.
+
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
 	  <term>o</term>
 	  <listitem><para>
-            Display the tracker list. Cycle the trackers in a group
+
+Display the tracker list. Cycle the trackers in a group
+
             with the space-bar.
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>p</term>
 	  <listitem><para>
-            View peer and torrent information.
+
+View peer and torrent information.
+
           </para></listitem>
 	</varlistentry>
 
 	<varlistentry>
 	  <term>t | T</term>
 	  <listitem><para>
-            Initiate tracker request. Use capital T to force the
-            request, ignoring the "min interval" set by the tracker.
+
+Initiate tracker request. Use capital T to force the request, ignoring
+the "min interval" set by the tracker.
+
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
+	  <term>k</term>
+	  <listitem><para>
+
+Disconnect peer.
+
+          </para></listitem>
+	</varlistentry>
+
+	<varlistentry>
+	  <term>*</term>
+	  <listitem><para>
+
+Choke/Snubb peer.
+
           </para></listitem>
 	</varlistentry>
 
       </variablelist>
 
     </refsect2>
@@ -253,35 +286,43 @@
 
     <variablelist>
 
       <varlistentry>
         <term>-b <replaceable>a.b.c.d</replaceable></term>
         <listitem><para>
-          Bind listening socket and outgoing connections to this
-          network interface address.
+
+Bind listening socket and outgoing connections to this network
+interface address.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>-d <replaceable>directory</replaceable></term>
         <listitem><para>
-          Set the default download directory. Defaults to "./".
+
+Set the default download directory. Defaults to "./".
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>-h</term>
         <listitem><para>
-          Display help and exit.
+
+Display help and exit.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>-i <replaceable>a.b.c.d</replaceable></term>
         <listitem><para>
-          Set the address reported to the tracker.
+
+Set the address reported to the tracker.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>-o key1=opt1,...</term>
         <term>-O key=opt</term>
@@ -294,26 +335,29 @@
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>-p <replaceable>a-b</replaceable></term>
         <listitem><para>
-          Try to open a listening port in the range
-          <emphasis>a</emphasis> up to and including
-          <emphasis>b</emphasis>.
+
+Try to open a listening port in the range <emphasis>a</emphasis> up to
+and including <emphasis>b</emphasis>.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>-s <replaceable>directory</replaceable></term>
         <listitem><para>
-          Session management will be enabled and the torrent files for
-          all open downloads will be stored in this directory. Only
-          one instance of rtorrent should be used with each session
-          directory, though at the moment no locking is done. An empty
-          string will disable the session directory.
+
+Session management will be enabled and the torrent files for all open
+downloads will be stored in this directory. Only one instance of
+rtorrent should be used with each session directory, though at the
+moment no locking is done. An empty string will disable the session
+directory.
+
         </para></listitem>
       </varlistentry>
 
     </variablelist>
 
   </refsect1>
@@ -326,119 +370,139 @@
 
     <variablelist>
 
       <varlistentry>
         <term>max_peers = <replaceable>value</replaceable></term>
         <listitem><para>
-          Set the maximum number of peers to allow in each download.
+
+Set the maximum number of peers to allow in each download.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>min_peers = <replaceable>value</replaceable></term>
         <listitem><para>
-          Set the minimum number of peers to try to connect to in each
-          download.
+
+Set the minimum number of peers to try to connect to in each download.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>max_uploads = <replaceable>value</replaceable></term>
         <listitem><para>
-          Set the maximum number of simultaneous uploads per download.
+
+Set the maximum number of simultaneous uploads per download.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>download_rate = <replaceable>KB</replaceable></term>
         <listitem><para>
-          Set the maximum global download rate.
+
+Set the maximum global download rate.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>upload_rate = <replaceable>KB</replaceable></term>
         <listitem><para>
-          Set the maximum global upload rate.
+
+Set the maximum global upload rate.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>bind = <replaceable>a.b.c.d</replaceable></term>
         <listitem><para>
-          Bind listening socket and outgoing connections to this
-          network interface address.
+
+Bind listening socket and outgoing connections to this network
+interface address.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>ip = <replaceable>a.b.c.d</replaceable></term>
         <listitem><para>
-          Set the address reported to the tracker.
+
+Set the address reported to the tracker.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>port_range = <replaceable>a-b</replaceable></term>
         <listitem><para>
-          Try to open a listening port in the range
-          <emphasis>a</emphasis> up to and including
-          <emphasis>b</emphasis>.
+
+Try to open a listening port in the range <emphasis>a</emphasis> up to
+and including <emphasis>b</emphasis>.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>port_random = <replaceable>yes | no</replaceable></term>
         <listitem><para>
-          Open the listening port at a random position in the port range.
+
+Open the listening port at a random position in the port range.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>check_hash = <replaceable>yes | no</replaceable></term>
         <listitem><para>
-          Perform hash check on finished downloads.
+
+Perform hash check on finished downloads.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>directory = <replaceable>directory</replaceable></term>
         <listitem><para>
-          Set the default download directory. Defaults to "./".
+
+Set the default download directory. Defaults to "./".
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>session = <replaceable>directory</replaceable></term>
         <listitem><para>
 
-          Session management will be enabled and the torrent files for
-          all open downloads will be stored in this directory. Only
-          one instance of rtorrent should be used with each session
-          directory, though at the moment no locking is done. An empty
-          string will disable the session directory.
+Session management will be enabled and the torrent files for all open
+downloads will be stored in this directory. Only one instance of
+rtorrent should be used with each session directory, though at the
+moment no locking is done. An empty string will disable the session
+directory.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>http_proxy = <replaceable>url</replaceable></term>
         <listitem><para>
 
-          Use a http proxy. Use an empty string to disable.
+Use a http proxy. Use an empty string to disable.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>encoding_list = <replaceable>encoding</replaceable></term>
         <listitem><para>
 
-          Add a preferred filename encoding to the list. The encodings
-          are attempted in the order they are inserted, if none match
-          the torrent default is used.
+Add a preferred filename encoding to the list. The encodings are
+attempted in the order they are inserted, if none match the torrent
+default is used.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>schedule = <replaceable>id</replaceable>,<replaceable>start</replaceable>,<replaceable>interval</replaceable>,<replaceable>command</replaceable></term>
@@ -450,22 +514,33 @@
 <emphasis>start</emphasis> of zero calls it immediately. Currently
 <emphasis>command</emphasis> is forwarded to the option handler.
 
 <emphasis>start</emphasis> and <emphasis>interval</emphasis> may
 optionally use a time format, <emphasis>dd:hh:mm:ss</emphasis>. F.ex to
 start a task every day at <emphasis>18:00</emphasis>, use
-<emphasis>18:00:00</emphasis>.
+<emphasis>18:00:00,24:00:00</emphasis>.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>schedule_remove = <replaceable>id</replaceable></term>
         <listitem><para>
 
-          Delete <emphasis>id</emphasis> from the scheduler.
+Delete <emphasis>id</emphasis> from the scheduler.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>stop_untied =</term>
+        <term>remove_untied =</term>
+        <listitem><para>
+
+Stop or remove the torrents that are tied to filenames that have been
+deleted, the association is then cleared.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>load = <replaceable>file</replaceable></term>
@@ -479,18 +554,18 @@
 to the filename provided.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
-        <term>stop_untied =</term>
-        <term>remove_untied =</term>
+        <term>import = <replaceable>file</replaceable></term>
+        <term>try_import = <replaceable>file</replaceable></term>
         <listitem><para>
 
-Stop or remove the torrents that are tied to filenames that have been
-deleted, the association is then cleared.
+Load a resource file. <emphasis>try_import</emphasis> does not throw
+torrent::input_error exception on bad input.
 
         </para></listitem>
       </varlistentry>
 
     </variablelist>
 
@@ -505,60 +580,68 @@
 
     <variablelist>
 
       <varlistentry>
         <term>hash_read_ahead = <replaceable>MB</replaceable></term>
         <listitem><para>
-          Configure how far ahead we ask the kernel to read when doing
-          hash checking. The hash checker uses madvise(...,
-          MADV_WILLNEED) for the requests.
+
+Configure how far ahead we ask the kernel to read when doing hash
+checking. The hash checker uses madvise(..., MADV_WILLNEED) for the
+requests.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>hash_interval = <replaceable>ms</replaceable></term>
         <listitem><para>
-          Interval between attempts to check the hash when the chunk
-          is not in memory, in milliseconds.
+
+Interval between attempts to check the hash when the chunk is not in
+memory, in milliseconds.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>hash_max_tries = <replaceable>tries</replaceable></term>
         <listitem><para>
-          Number of attempts to check the hash while using the mincore
-	  status, before forcing. Overworked systems might need lower
-	  values to get a decent hash checking rate.
+
+Number of attempts to check the hash while using the mincore status,
+before forcing. Overworked systems might need lower values to get a
+decent hash checking rate.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>max_open_files = <replaceable>value</replaceable></term>
         <listitem><para>
-          Number of files to simultaneously keep open. Libtorrent
-          dynamically opens and closes files when mapping files to
-          memory. Defaults to 128.
+
+Number of files to simultaneously keep open. Libtorrent dynamically
+opens and closes files when mapping files to memory. Defaults to 128.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>max_open_sockets = <replaceable>value</replaceable></term>
         <listitem><para>
-          Number of sockets to simultaneously keep open. This value is
-          set to be <emphasis>sysconf(_SC_OPEN_MAX) - 256</emphasis>
-          at startup. This gives the client 128 sockets to use as it
-          wishes.
+
+Number of sockets to simultaneously keep open. This value is set to be
+<emphasis>sysconf(_SC_OPEN_MAX) - 256</emphasis> at startup. This
+gives the client 128 sockets to use as it wishes.
+
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>umask = <replaceable>0644</replaceable></term>
         <listitem><para>
 
-          Set the umask for this process, which is applied to all
-          files created by the program.
+Set the umask for this process, which is applied to all files created
+by the program.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>working_directory = <replaceable>directory</replaceable></term>
@@ -586,12 +669,35 @@
 
 Controls whetever a lock file is created in the session directory.
 
         </para></listitem>
       </varlistentry>
 
+      <varlistentry>
+        <term>tracker_dump = <replaceable>filename</replaceable></term>
+        <listitem><para>
+
+Dump tracker requests to <emphasis>filename</emphasis>, disable by
+supplying an empty string. Only torrents loaded while
+<emphasis>tracker_dump</emphasis> contains a non-empty string will be
+logged at the moment, although disabling it will work as expected.
+
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
+        <term>tos = <replaceable>default|lowdelay|throughput|reliability|mincost</replaceable></term>
+        <listitem><para>
+
+Change the TOS of peer connections, by default set to
+<emphasis>throughput</emphasis>. If the option is set to
+<emphasis>default</emphasis> then the system default TOS is used.
+
+        </para></listitem>
+      </varlistentry>
+
     </variablelist>
 
   </refsect1>
 
 
   <refsect1>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/Makefile.am	2006-02-11 02:57:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/Makefile.am	2006-04-07 01:42:59.000000000 +0800
@@ -1,21 +1,24 @@
 SUBDIRS = \
 	doc \
 	src
 
 EXTRA_DIST= \
 	autogen.sh \
+	rak/address_info.h \
 	rak/algorithm.h \
 	rak/error_number.h \
 	rak/file_stat.h \
 	rak/functional.h \
 	rak/functional_fun.h \
 	rak/path.h \
+	rak/partial_queue.h \
 	rak/priority_queue.h \
 	rak/priority_queue_default.h \
 	rak/regex.h \
+	rak/socket_address.h \
 	rak/string_manip.h \
 	rak/timer.h \
 	rak/unordered_vector.h \
 	scripts/checks.m4 \
 	scripts/common.m4 \
 	scripts/attributes.m4
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/Makefile.in	2006-02-12 00:13:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/Makefile.in	2006-04-07 01:43:33.000000000 +0800
@@ -176,21 +176,24 @@
 SUBDIRS = \
 	doc \
 	src
 
 EXTRA_DIST = \
 	autogen.sh \
+	rak/address_info.h \
 	rak/algorithm.h \
 	rak/error_number.h \
 	rak/file_stat.h \
 	rak/functional.h \
 	rak/functional_fun.h \
 	rak/path.h \
+	rak/partial_queue.h \
 	rak/priority_queue.h \
 	rak/priority_queue_default.h \
 	rak/regex.h \
+	rak/socket_address.h \
 	rak/string_manip.h \
 	rak/timer.h \
 	rak/unordered_vector.h \
 	scripts/checks.m4 \
 	scripts/common.m4 \
 	scripts/attributes.m4
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak: address_info.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/error_number.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/error_number.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/error_number.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/error_number.h	2006-04-05 05:01:04.000000000 +0800
@@ -41,28 +41,37 @@
 #include <cstring>
 
 namespace rak {
 
 class error_number {
 public:
+  static const int e_access      = EACCES;
+  static const int e_again       = EAGAIN;
+  static const int e_connreset   = ECONNRESET;
+  static const int e_connaborted = ECONNABORTED;
+  static const int e_deadlk      = EDEADLK;
+  static const int e_intr        = EINTR;
+
   error_number() : m_errno(0) {}
   error_number(int e) : m_errno(e) {}
 
   bool                is_valid() const             { return m_errno != 0; }
 
   int                 value() const                { return m_errno; }
   const char*         c_str() const                { return strerror(m_errno); }
 
-  bool                is_blocked_momentary() const { return m_errno == EAGAIN || m_errno == EINTR; }
-  bool                is_blocked_prolonged() const { return m_errno == EDEADLK; }
+  bool                is_blocked_momentary() const { return m_errno == e_again || m_errno == e_intr; }
+  bool                is_blocked_prolonged() const { return m_errno == e_deadlk; }
 
-  bool                is_closed() const            { return m_errno == ECONNRESET || m_errno == ECONNABORTED; }
+  bool                is_closed() const            { return m_errno == e_connreset || m_errno == e_connaborted; }
 
   static error_number current()                    { return errno; }
   static void         clear_global()               { errno = 0; }
 
+  bool operator == (const error_number& e) const   { return m_errno == e.m_errno; }
+
 private:
   int                 m_errno;
 };
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/file_stat.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/file_stat.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/file_stat.h	2006-01-10 08:32:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/file_stat.h	2006-04-06 04:48:00.000000000 +0800
@@ -69,80 +69,6 @@
   struct stat         m_stat;
 };
 
 }
 
 #endif
-// rak - Rakshasa's toolbox
-// Copyright (C) 2005-2006, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
-#ifndef RAK_FILE_STAT_H
-#define RAK_FILE_STAT_H
-
-#include <string>
-#include <inttypes.h>
-#include <sys/stat.h>
-
-namespace rak {
-
-class file_stat {
-public:
-  // Consider storing rak::error_number.
-
-  bool                update(int fd)                        { return fstat(fd, &m_stat) == 0; }
-  bool                update(const char* filename)          { return stat(filename, &m_stat) == 0; }
-  bool                update(const std::string& filename)   { return update(filename.c_str()); }
-
-  bool                is_regular() const                    { return S_ISREG(m_stat.st_mode); }
-  bool                is_directory() const                  { return S_ISDIR(m_stat.st_mode); }
-  bool                is_character() const                  { return S_ISCHR(m_stat.st_mode); }
-  bool                is_block() const                      { return S_ISBLK(m_stat.st_mode); }
-  bool                is_fifo() const                       { return S_ISFIFO(m_stat.st_mode); }
-  bool                is_link() const                       { return S_ISLNK(m_stat.st_mode); }
-  bool                is_socket() const                     { return S_ISSOCK(m_stat.st_mode); }
-
-  off_t               size() const                          { return m_stat.st_size; }
-
-  time_t              access_time() const                   { return m_stat.st_atime; }
-  time_t              change_time() const                   { return m_stat.st_ctime; }
-  time_t              modified_time() const                 { return m_stat.st_mtime; }
-
-private:
-  struct stat         m_stat;
-};
-
-}
-
-#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/functional_fun.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/functional_fun.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/functional_fun.h	2006-01-28 03:17:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/functional_fun.h	2006-03-03 00:24:06.000000000 +0800
@@ -31,13 +31,13 @@
 //
 // Contact:  Jari Sundell <jaris@ifi.uio.no>
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
-// This file contains functors that wrap function points and member
+// This file contains functors that wrap function pointers and member
 // function pointers.
 //
 // 'fn' functors are polymorphic and derives from 'rak::function' and
 // thus is less strict about types, this adds the cost of calling a
 // virtual function.
 //
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/functional.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/functional.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/functional.h	2006-01-19 03:53:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/functional.h	2006-03-16 00:19:18.000000000 +0800
@@ -104,12 +104,33 @@
 inline equal_t<Type, Ftor>
 equal(Type t, Ftor f) {
   return equal_t<Type, Ftor>(t, f);
 }
 
 template <typename Type, typename Ftor>
+struct equal_ptr_t {
+  typedef bool result_type;
+
+  equal_ptr_t(Type* t, Ftor f) : m_t(t), m_f(f) {}
+
+  template <typename Arg>
+  bool operator () (const Arg& a) {
+    return *m_t == *m_f(a);
+  }
+
+  Type* m_t;
+  Ftor  m_f;
+};
+
+template <typename Type, typename Ftor>
+inline equal_ptr_t<Type, Ftor>
+equal_ptr(Type* t, Ftor f) {
+  return equal_ptr_t<Type, Ftor>(t, f);
+}
+
+template <typename Type, typename Ftor>
 struct not_equal_t {
   typedef bool result_type;
 
   not_equal_t(Type t, Ftor f) : m_t(t), m_f(f) {}
 
   template <typename Arg>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak: partial_queue.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/regex.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/regex.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/regex.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/regex.h	2006-04-06 05:11:59.000000000 +0800
@@ -105,116 +105,6 @@
   return std::find(paths.begin(), paths.end(), m_pattern.size() - 1) != paths.end();
 }
 
 }
 
 #endif
-// rak - Rakshasa's toolbox
-// Copyright (C) 2005-2006, Jari Sundell
-//
-// This program is free software; you can redistribute it and/or modify
-// it under the terms of the GNU General Public License as published by
-// the Free Software Foundation; either version 2 of the License, or
-// (at your option) any later version.
-// 
-// This program is distributed in the hope that it will be useful,
-// but WITHOUT ANY WARRANTY; without even the implied warranty of
-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-// GNU General Public License for more details.
-// 
-// You should have received a copy of the GNU General Public License
-// along with this program; if not, write to the Free Software
-// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-//
-// In addition, as a special exception, the copyright holders give
-// permission to link the code of portions of this program with the
-// OpenSSL library under certain conditions as described in each
-// individual source file, and distribute linked combinations
-// including the two.
-//
-// You must obey the GNU General Public License in all respects for
-// all of the code used other than OpenSSL.  If you modify file(s)
-// with this exception, you may extend this exception to your version
-// of the file(s), but you are not obligated to do so.  If you do not
-// wish to do so, delete this exception statement from your version.
-// If you delete this exception statement from all source files in the
-// program, then also delete it here.
-//
-// Contact:  Jari Sundell <jaris@ifi.uio.no>
-//
-//           Skomakerveien 33
-//           3185 Skoppum, NORWAY
-
-// This is a hacked up whole string pattern matching. Replace with
-// TR1's regex when that becomes widely available. It is intended for
-// small strings.
-
-#ifndef RAK_REGEX_H
-#define RAK_REGEX_H
-
-#include <sys/types.h>
-
-#include <functional>
-#include <string>
-#include <list>
-
-namespace rak {
-
-class regex : public std::unary_function<std::string, bool> {
-public:
-  regex() {}
-  regex(const std::string& p) : m_pattern(p) {}
-
-  const std::string& pattern() const { return m_pattern; }
-
-  bool operator () (const std::string& p) const;
-
-private:
-  std::string m_pattern;
-};
-
-// This isn't optimized, or very clean. A simple hack that should work.
-bool
-regex::operator () (const std::string& text) const {
-  if (m_pattern.empty() ||
-      text.empty() ||
-      (m_pattern[0] != '*' && m_pattern[0] != text[0]))
-    return false;
-
-  // Replace with unordered_vector?
-  std::list<unsigned int> paths;
-  paths.push_front(0);
-
-  for (std::string::const_iterator itrText = ++text.begin(), lastText = text.end(); itrText != lastText; ++itrText) {
-    
-    for (std::list<unsigned int>::iterator itrPaths = paths.begin(), lastPaths = paths.end(); itrPaths != lastPaths; ) {
-
-      unsigned int next = *itrPaths + 1;
-
-      if (m_pattern[*itrPaths] != '*')
-	itrPaths = paths.erase(itrPaths);
-      else
-	itrPaths++;
-
-      // When we reach the end of 'm_pattern', we don't have a whole
-      // match of 'text'.
-      if (next == m_pattern.size())
-	continue;
-
-      // Push to the back so that '*' will match zero length strings.
-      if (m_pattern[next] == '*')
-	paths.push_back(next);
-
-      if (m_pattern[next] == *itrText)
-	paths.push_front(next);
-    }
-
-    if (paths.empty())
-      return false;
-  }
-
-  return std::find(paths.begin(), paths.end(), m_pattern.size() - 1) != paths.end();
-}
-
-}
-
-#endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak: socket_address.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/string_manip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/string_manip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/string_manip.h	2006-02-05 08:21:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/string_manip.h	2006-04-06 04:46:21.000000000 +0800
@@ -75,12 +75,43 @@
 
 template <typename Sequence>
 Sequence trim(const Sequence& seq) {
   return trim_begin(trim_end(seq));
 }
 
+template <typename Sequence>
+Sequence trim_begin_classic(const Sequence& seq) {
+  if (seq.empty() || !std::isspace(*seq.begin(), std::locale::classic()))
+    return seq;
+
+  typename Sequence::size_type pos = 0;
+
+  while (pos != seq.length() && std::isspace(seq[pos], std::locale::classic()))
+    pos++;
+
+  return seq.substr(pos, seq.length() - pos);
+}
+
+template <typename Sequence>
+Sequence trim_end_classic(const Sequence& seq) {
+  if (seq.empty() || !std::isspace(*(--seq.end()), std::locale::classic()))
+    return seq;
+
+  typename Sequence::size_type pos = seq.size();
+
+  while (pos != 0 && std::isspace(seq[pos - 1], std::locale::classic()))
+    pos--;
+
+  return seq.substr(0, pos);
+}
+
+template <typename Sequence>
+Sequence trim_classic(const Sequence& seq) {
+  return trim_begin_classic(trim_end_classic(seq));
+}
+
 // Consider rewritting such that m_seq is replaced by first/last.
 template <typename Sequence>
 class split_iterator_t {
 public:
   typedef typename Sequence::const_iterator const_iterator;
   typedef typename Sequence::value_type     value_type;
@@ -127,12 +158,25 @@
 template <typename Sequence>
 inline split_iterator_t<Sequence>
 split_iterator(__UNUSED const Sequence& seq) {
   return split_iterator_t<Sequence>();
 }
 
+// Could optimize this abit.
+inline char
+hexchar_to_value(char c) {
+  if (c >= '0' && c <= '9')
+    return c - '0';
+
+  else if (c >= 'A' && c <= 'F')
+    return 10 + c - 'A';
+    
+  else
+    return 10 + c - 'a';
+}
+
 template <int pos, typename Value>
 inline char
 value_to_hexchar(Value v) {
   v >>= pos * 4;
   v &= 0xf;
 
@@ -143,14 +187,14 @@
 }
 
 template <typename InputIterator, typename OutputIterator> 
 OutputIterator
 copy_escape_html(InputIterator first, InputIterator last, OutputIterator dest) {
   while (first != last) {
-    if (std::isalpha(*first) ||
-	std::isdigit(*first) ||
+    if (std::isalpha(*first, std::locale::classic()) ||
+	std::isdigit(*first, std::locale::classic()) ||
 	*first == '-') {
       *(dest++) = *first;
 
     } else {
       *(dest++) = '%';
       *(dest++) = value_to_hexchar<1>(*first);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/unordered_vector.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/unordered_vector.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/rak/unordered_vector.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/rak/unordered_vector.h	2006-03-03 00:24:06.000000000 +0800
@@ -72,14 +72,18 @@
   using Base::rbegin;
   using Base::rend;
 
   using Base::push_back;
   using Base::pop_back;
 
+  // Use the range erase function, the single element erase gets
+  // overloaded.
+  using Base::erase;
+
   iterator            insert(iterator position, const value_type& x);
-  iterator            erase(iterator position);  
+  iterator            erase(iterator position);
 
 private:
 };
 
 template <typename _Tp>
 typename unordered_vector<_Tp>::iterator
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/scripts/common.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/scripts/common.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/scripts/common.m4	2006-02-12 00:13:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/scripts/common.m4	2006-04-01 04:09:27.000000000 +0800
@@ -91,19 +91,34 @@
         [
           AC_DEFINE(USE_MINCORE, 1, Use mincore)
           AC_DEFINE(USE_MINCORE_UNSIGNED, 0, use char* in mincore)
           AC_MSG_RESULT(signed)
         ],
         [
-          AC_MSG_RESULT(none)
+          AC_MSG_ERROR([failed, do *not* attempt to use --disable-mincore unless you are running Win32.])
       ])
   ])
 
   AC_LANG_POP(C++)
 ])
 
+AC_DEFUN([TORRENT_MINCORE], [
+  AC_ARG_ENABLE(mincore,
+    [  --disable-mincore       disable mincore check [[default=enable]]],
+    [
+      if test "$enableval" = "yes"; then
+        TORRENT_MINCORE_SIGNEDNESS()
+      else
+	AC_MSG_CHECKING(for mincore)
+	AC_MSG_RESULT(disabled)
+      fi
+    ],[
+        TORRENT_MINCORE_SIGNEDNESS()
+    ])
+])
+
 AC_DEFUN([TORRENT_CHECK_MADVISE], [
   AC_MSG_CHECKING(for madvise)
 
   AC_COMPILE_IFELSE(
     [[#include <sys/types.h>
           #include <sys/mman.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/control.cc	2006-02-11 00:12:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.cc	2006-03-29 06:15:17.000000000 +0800
@@ -34,15 +34,17 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <unistd.h>
+#include <torrent/connection_manager.h>
 
 #include "core/manager.h"
 #include "display/canvas.h"
+#include "display/client_info.h"
 #include "display/window.h"
 #include "display/manager.h"
 #include "input/manager.h"
 #include "input/input_event.h"
 #include "ui/root.h"
 #include "utils/variable_map.h"
@@ -61,12 +63,14 @@
   m_input(new input::Manager()),
   m_inputStdin(new input::InputEvent(STDIN_FILENO)),
 
   m_commandScheduler(new CommandScheduler()),
   m_variables(new utils::VariableMap()),
 
+  m_clientInfo(new display::ClientInfo),
+
   m_tick(0) {
 
   m_inputStdin->slot_pressed(sigc::mem_fun(m_input, &input::Manager::pressed));
 
   m_taskShutdown.set_slot(rak::mem_fn(this, &Control::handle_shutdown));
 
@@ -81,12 +85,14 @@
   delete m_commandScheduler;
   delete m_variables;
 
   delete m_ui;
   delete m_display;
   delete m_core;
+
+  delete m_clientInfo;
 }
 
 void
 Control::initialize() {
   display::Canvas::initialize();
   display::Window::slot_schedule(rak::make_mem_fun(m_display, &display::Manager::schedule));
@@ -121,13 +127,13 @@
   display::Canvas::cleanup();
 }
 
 void
 Control::handle_shutdown() {
   if (!m_shutdownQuick) {
-    torrent::listen_close();
+    torrent::connection_manager()->listen_close();
     m_core->shutdown(false);
 
     if (!m_taskShutdown.is_queued())
       priority_queue_insert(&taskScheduler, &m_taskShutdown, cachedTime + rak::timer::from_seconds(5));
 
   } else {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/control.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/control.h	2006-02-11 00:12:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/control.h	2006-04-01 04:48:35.000000000 +0800
@@ -49,12 +49,13 @@
 namespace core {
   class Manager;
 }
 
 namespace display {
   class Manager;
+  class ClientInfo;
 }
 
 namespace input {
   class InputEvent;
   class Manager;
 }  
@@ -85,13 +86,15 @@
   core::Manager*      core()                        { return m_core; }
   display::Manager*   display()                     { return m_display; }
   input::Manager*     input()                       { return m_input; }
   input::InputEvent*  input_stdin()                 { return m_inputStdin; }
 
   CommandScheduler*   command_scheduler()           { return m_commandScheduler; }
-  utils::VariableMap* variables()                   { return m_variables; }
+  utils::VariableMap* variable()                    { return m_variables; }
+
+  display::ClientInfo* client_info()                { return m_clientInfo; }
 
   uint64_t            tick() const                  { return m_tick; }
   void                inc_tick()                    { m_tick++; }
 
 private:
   Control(const Control&);
@@ -106,12 +109,14 @@
   input::Manager*     m_input;
   input::InputEvent*  m_inputStdin;
 
   CommandScheduler*   m_commandScheduler;
   utils::VariableMap* m_variables;
 
+  display::ClientInfo* m_clientInfo;
+
   uint64_t            m_tick;
 
   rak::priority_item  m_taskShutdown;
 };
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/curl_get.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/curl_get.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/curl_get.cc	2006-02-04 07:02:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/curl_get.cc	2006-03-21 22:39:59.000000000 +0800
@@ -45,13 +45,13 @@
 #include "curl_stack.h"
 
 namespace core {
 
 size_t
 curl_get_receive_write(void* data, size_t size, size_t nmemb, void* handle) {
-  if (!((CurlGet*)handle)->stream()->write((char*)data, size * nmemb).fail())
+  if (!((CurlGet*)handle)->stream()->write((const char*)data, size * nmemb).fail())
     return size * nmemb;
   else
     return 0;
 }
 
 CurlGet::CurlGet(CurlStack* s) :
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download.cc	2006-02-11 04:21:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.cc	2006-04-01 05:38:04.000000000 +0800
@@ -40,48 +40,52 @@
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 #include <sigc++/signal.h>
 #include <rak/path.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
+#include <torrent/tracker.h>
+#include <torrent/tracker_list.h>
 
 #include "utils/variable_generic.h"
 
 #include "download.h"
 
 namespace core {
 
-Download::Download(torrent::Download d) :
+Download::Download(download_type d) :
   m_download(d),
+  m_fileList(d.file_list()),
+  m_trackerList(d.tracker_list()),
 
   m_chunksFailed(0) {
 
   m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
   m_connTrackerFailed = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
   m_connStorageError = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
 
   m_download.signal_chunk_failed(sigc::mem_fun(*this, &Download::receive_chunk_failed));
 
   m_variables.insert("connection_current", new utils::VariableSlotString<const char*, const std::string&>(rak::mem_fn(this, &Download::connection_current),
 													  rak::mem_fn(this, &Download::set_connection_current)));
-  m_variables.insert("connection_leech",   new utils::VariableAny(connection_type_to_string(torrent::Download::CONNECTION_LEECH)));
-  m_variables.insert("connection_seed",    new utils::VariableAny(connection_type_to_string(torrent::Download::CONNECTION_SEED)));
-  m_variables.insert("state",              new utils::VariableBencode(&m_download.bencode(), "rtorrent", "state", torrent::Bencode::TYPE_STRING));
-  m_variables.insert("tied_to_file",       new utils::VariableBencode(&m_download.bencode(), "rtorrent", "tied_to_file", torrent::Bencode::TYPE_STRING));
+  m_variables.insert("connection_leech",   new utils::VariableAny(connection_type_to_string(download_type::CONNECTION_LEECH)));
+  m_variables.insert("connection_seed",    new utils::VariableAny(connection_type_to_string(download_type::CONNECTION_SEED)));
+  m_variables.insert("state",              new utils::VariableObject(bencode(), "rtorrent", "state", torrent::Object::TYPE_STRING));
+  m_variables.insert("tied_to_file",       new utils::VariableObject(bencode(), "rtorrent", "tied_to_file", torrent::Object::TYPE_STRING));
 
-  m_variables.insert("directory",          new utils::VariableSlotString<>(rak::mem_fn(&m_download, &torrent::Download::root_dir),
-									   rak::mem_fn(this, &Download::set_root_directory)));
+  m_variables.insert("directory",          new utils::VariableSlotString<const std::string&>(rak::mem_fn(&m_fileList, &torrent::FileList::root_dir),
+											     rak::mem_fn(this, &Download::set_root_directory)));
 
-  m_variables.insert("min_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &torrent::Download::peers_min),
-											    rak::mem_fn(&m_download, &torrent::Download::set_peers_min),
+  m_variables.insert("min_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &download_type::peers_min),
+											    rak::mem_fn(&m_download, &download_type::set_peers_min),
 											    "%u"));
-  m_variables.insert("max_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &torrent::Download::peers_max),
-											    rak::mem_fn(&m_download, &torrent::Download::set_peers_max),
+  m_variables.insert("max_peers",          new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &download_type::peers_max),
+											    rak::mem_fn(&m_download, &download_type::set_peers_max),
 											    "%u"));
-  m_variables.insert("max_uploads",        new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &torrent::Download::uploads_max),
-											    rak::mem_fn(&m_download, &torrent::Download::set_uploads_max),
+  m_variables.insert("max_uploads",        new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(&m_download, &download_type::uploads_max),
+											    rak::mem_fn(&m_download, &download_type::set_uploads_max),
 											    "%u"));
   m_variables.insert("priority",           new utils::VariableSlotValue<uint32_t, uint32_t>(rak::mem_fn(this, &Download::priority),
 											    rak::mem_fn(this, &Download::set_priority),
 											    "%u"));
 }
 
@@ -90,13 +94,13 @@
     return;
 
   m_connTrackerSucceded.disconnect();
   m_connTrackerFailed.disconnect();
   m_connStorageError.disconnect();
 
-  m_download = torrent::Download();
+  m_download = download_type();
 }
 
 void
 Download::start() {
   if (is_done())
     m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_seed").as_string()));
@@ -103,28 +107,36 @@
   else
     m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_leech").as_string()));
 
   // Update the priority to ensure it has the correct
   // seeding/unfinished modifiers.
   set_priority(priority());
+
   m_download.start();
 }
 
 void
+Download::stop() {
+  m_download.stop();
+}
+
+void
 Download::enable_udp_trackers(bool state) {
-  for (int i = 0, last = m_download.size_trackers(); i < last; ++i)
-    if (m_download.tracker(i).tracker_type() == torrent::Tracker::TRACKER_UDP)
+  torrent::TrackerList tl = m_download.tracker_list();
+
+  for (int i = 0, last = tl.size(); i < last; ++i)
+    if (tl.get(i).tracker_type() == torrent::Tracker::TRACKER_UDP)
       if (state)
-	m_download.tracker(i).enable();
+	tl.get(i).enable();
       else
-	m_download.tracker(i).disable();
+	tl.get(i).disable();
 }
 
 uint32_t
 Download::priority() {
-  return get_bencode().get_key("rtorrent").get_key("priority").as_value();
+  return bencode()->get_key("rtorrent").get_key("priority").as_value();
 }
 
 void
 Download::set_priority(uint32_t p) {
   if (p >= 4)
     throw torrent::input_error("Priority out of range.");
@@ -132,13 +144,13 @@
   // Seeding torrents get half the priority of unfinished torrents.
   if (!is_done())
     torrent::download_set_priority(m_download, p * p * 2);
   else
     torrent::download_set_priority(m_download, p * p);
 
-  get_bencode().get_key("rtorrent").insert_key("priority", (int64_t)p);
+  bencode()->get_key("rtorrent").insert_key("priority", (int64_t)p);
 }
 
 void
 Download::receive_finished() {
   m_download.set_connection_type(string_to_connection_type(m_variables.get("connection_seed").as_string()));
   // FIXME
@@ -155,29 +167,29 @@
 
 void
 Download::receive_storage_error(std::string msg) {
   m_message = "Storage error: [" + msg + "]";
 }
 
-torrent::Download::ConnectionType
+Download::download_type::ConnectionType
 Download::string_to_connection_type(const std::string& name) {
   // Return default if the name isn't found.
   if (name == "leech")
-    return torrent::Download::CONNECTION_LEECH;
+    return download_type::CONNECTION_LEECH;
   else if (name == "seed")
-    return torrent::Download::CONNECTION_SEED;
+    return download_type::CONNECTION_SEED;
   else
     throw torrent::input_error("Unknown peer connection type selected: \"" + name + "\"");
 }
 
 const char*
-Download::connection_type_to_string(torrent::Download::ConnectionType t) {
+Download::connection_type_to_string(download_type::ConnectionType t) {
   switch (t) {
-  case torrent::Download::CONNECTION_LEECH:
+  case download_type::CONNECTION_LEECH:
     return "leech";
-  case torrent::Download::CONNECTION_SEED:
+  case download_type::CONNECTION_SEED:
     return "seed";
   default:
     return "unknown";
   }
 }
 
@@ -208,29 +220,51 @@
     return "high";
   default:
     throw torrent::input_error("Priority out of range.");
   }
 }
 
+float
+Download::distributed_copies() const {
+  const uint8_t* avail = m_download.chunks_seen();
+  const uint8_t* end = avail + m_download.chunks_total();
+
+  if (avail == NULL)
+    return 0;
+
+  int minAvail = std::numeric_limits<uint8_t>::max();
+  int num = 0;
+
+  for (; avail < end; ++avail)
+    if (*avail == minAvail) {
+      num++;
+    } else if (*avail < minAvail) {
+      minAvail = *avail;
+      num = 1;
+    }
+
+  return minAvail + 1 - (float)num / m_download.chunks_total();
+}
+
 void
 Download::receive_chunk_failed(__UNUSED uint32_t idx) {
   m_chunksFailed++;
 }
 
 // Clean up.
 void
 Download::set_root_directory(const std::string& path) {
   if (path.empty()) {
-    m_download.set_root_dir("./" + (m_download.size_file_entries() > 1 ? m_download.name() : std::string()));
+    m_fileList.set_root_dir("./" + (m_fileList.size() > 1 ? m_download.name() : std::string()));
 
   } else {
     std::string fullPath = rak::path_expand(path);
 
-    m_download.set_root_dir(fullPath +
+    m_fileList.set_root_dir(fullPath +
 			    (*fullPath.rbegin() != '/' ? "/" : "") +
-			    (m_download.size_file_entries() > 1 ? m_download.name() : ""));
+			    (m_fileList.size() > 1 ? m_download.name() : ""));
   }
 
-  m_download.bencode().get_key("rtorrent").insert_key("directory", path);
+  bencode()->get_key("rtorrent").insert_key("directory", path);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_factory.cc	2006-02-17 01:14:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.cc	2006-04-07 00:34:29.000000000 +0800
@@ -33,18 +33,20 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include <cstdlib>
 #include <fstream>
 #include <sstream>
 #include <stdexcept>
 #include <rak/path.h>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
 #include <torrent/exceptions.h>
+#include <torrent/rate.h>
 
 #include "utils/variable_generic.h"
 
 #include "curl_get.h"
 #include "http_queue.h"
 #include "globals.h"
@@ -66,15 +68,15 @@
   m_start(false),
   m_printLog(true) {
 
   m_taskLoad.set_slot(rak::mem_fn(this, &DownloadFactory::receive_load));
   m_taskCommit.set_slot(rak::mem_fn(this, &DownloadFactory::receive_commit));
 
-  m_variables.insert("connection_leech", new utils::VariableAny(control->variables()->get("connection_leech")));
-  m_variables.insert("connection_seed",  new utils::VariableAny(control->variables()->get("connection_seed")));
-  m_variables.insert("directory",        new utils::VariableAny(control->variables()->get("directory")));
+  m_variables.insert("connection_leech", new utils::VariableAny(control->variable()->get("connection_leech")));
+  m_variables.insert("connection_seed",  new utils::VariableAny(control->variable()->get("connection_seed")));
+  m_variables.insert("directory",        new utils::VariableAny(control->variable()->get("directory")));
   m_variables.insert("tied_to_file",     new utils::VariableBool(false));
 }
 
 DownloadFactory::~DownloadFactory() {
   priority_queue_erase(&taskScheduler, &m_taskLoad);
   priority_queue_erase(&taskScheduler, &m_taskCommit);
@@ -136,80 +138,86 @@
 
 void
 DownloadFactory::receive_success() {
   if (m_stream == NULL)
     throw torrent::client_error("DownloadFactory::receive_success() called on an object with m_stream == NULL");
 
-  Manager::DListItr itr = m_manager->insert(m_stream, m_printLog);
+  DownloadList::iterator itr = m_manager->download_list().insert(m_stream, m_printLog);
 
   if (itr == m_manager->download_list().end()) {
     // core::Manager should already have added the error message to
     // the log.
     m_slotFinished();
     return;
   }
 
-  torrent::Bencode& root = (*itr)->get_bencode();
+  torrent::Object* root = (*itr)->bencode();
 
   if (!m_session) {
     // We only allow session torrents to keep their
     // 'rtorrent/libtorrent' sections.
-    root.erase_key("rtorrent");
-    root.erase_key("libtorrent");
+    root->erase_key("rtorrent");
+    root->erase_key("libtorrent");
   }
 
-  if (!root.has_key("rtorrent") ||
-      !root.get_key("rtorrent").is_map())
-    root.insert_key("rtorrent", torrent::Bencode(torrent::Bencode::TYPE_MAP));
+  if (!root->has_key_map("rtorrent"))
+    root->insert_key("rtorrent", torrent::Object(torrent::Object::TYPE_MAP));
     
-  torrent::Bencode& rtorrent = root.get_key("rtorrent");
+  torrent::Object* rtorrent = &root->get_key("rtorrent");
 
-  if (!rtorrent.has_key("state") ||
-      !rtorrent.get_key("state").is_string() ||
-      (rtorrent.get_key("state").as_string() != "stopped" &&
-       rtorrent.get_key("state").as_string() != "started"))
-    rtorrent.insert_key("state", "stopped");
+  if (!rtorrent->has_key_string("state") ||
+      (rtorrent->get_key("state").as_string() != "stopped" &&
+       rtorrent->get_key("state").as_string() != "started"))
+    rtorrent->insert_key("state", "stopped");
   
-  if (!rtorrent.has_key("tied_to_file") ||
-      !rtorrent.get_key("tied_to_file").is_string())
-    rtorrent.insert_key("tied_to_file", std::string());
-
-  if (rtorrent.has_key("priority") &&
-      rtorrent.get_key("priority").is_value())
-    (*itr)->variables()->set("priority", rtorrent.get_key("priority").as_value() % 4);
+  if (!rtorrent->has_key_string("tied_to_file"))
+    rtorrent->insert_key("tied_to_file", std::string());
+
+  if (rtorrent->has_key_value("priority"))
+    (*itr)->variable()->set("priority", rtorrent->get_key("priority").as_value() % 4);
   else
-    (*itr)->variables()->set("priority", (int64_t)2);
+    (*itr)->variable()->set("priority", (int64_t)2);
 
   // Move to 'rtorrent'.
-  (*itr)->variables()->set("connection_leech", m_variables.get("connection_leech"));
-  (*itr)->variables()->set("connection_seed",  m_variables.get("connection_seed"));
-  (*itr)->variables()->set("min_peers",        control->variables()->get("min_peers"));
-  (*itr)->variables()->set("max_peers",        control->variables()->get("max_peers"));
-  (*itr)->variables()->set("max_uploads",      control->variables()->get("max_uploads"));
+  (*itr)->variable()->set("connection_leech", m_variables.get("connection_leech"));
+  (*itr)->variable()->set("connection_seed",  m_variables.get("connection_seed"));
+  (*itr)->variable()->set("min_peers",        control->variable()->get("min_peers"));
+  (*itr)->variable()->set("max_peers",        control->variable()->get("max_peers"));
+  (*itr)->variable()->set("max_uploads",      control->variable()->get("max_uploads"));
+
+  if (rtorrent->has_key_value("key")) {
+    (*itr)->tracker_list()->set_key(rtorrent->get_key("key").as_value());
+
+  } else {
+    (*itr)->tracker_list()->set_key(rand() % (std::numeric_limits<uint32_t>::max() - 1) + 1);
+    rtorrent->insert_key("key", (*itr)->tracker_list()->key());
+  }
 
-  if (control->variables()->get("use_udp_trackers").as_string() == "no")
+  if (control->variable()->get_string("use_udp_trackers") == "no")
     (*itr)->enable_udp_trackers(false);
 
+  if (rtorrent->has_key_value("total_uploaded"))
+    (*itr)->download()->up_rate()->set_total(rtorrent->get_key("total_uploaded").as_value());
+    
   if (m_session) {
-    if (!rtorrent.has_key("directory") ||
-	!rtorrent.get_key("directory").is_string())
-      (*itr)->variables()->set("directory", m_variables.get("directory"));
+    if (!rtorrent->has_key_string("directory"))
+      (*itr)->variable()->set("directory", m_variables.get("directory"));
     else
-      (*itr)->variables()->set("directory", rtorrent.get_key("directory"));
+      (*itr)->variable()->set("directory", rtorrent->get_key("directory"));
 
-    if ((*itr)->variables()->get_string("state") == "started")
-      m_manager->start(*itr, m_printLog);
+    if ((*itr)->variable()->get_string("state") == "started")
+      m_manager->download_list().resume(*itr);
 
   } else {
-    (*itr)->variables()->set("directory", m_variables.get("directory"));
+    (*itr)->variable()->set("directory", m_variables.get("directory"));
 
     if (m_variables.get("tied_to_file").as_value())
-      (*itr)->variables()->set("tied_to_file", m_uri);
+      (*itr)->variable()->set("tied_to_file", m_uri);
 
     if (m_start)
-      m_manager->start(*itr, m_printLog);
+      m_manager->download_list().start(*itr);
 
     m_manager->download_store().save(*itr);
   }
 
   m_slotFinished();
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_factory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_factory.h	2006-01-18 04:23:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_factory.h	2006-04-01 04:53:08.000000000 +0800
@@ -64,22 +64,22 @@
   // Calling of receive_load() is delayed so you can change whatever
   // you want without fear of the slots being triggered as you call
   // load() or commit().
   void                load();
   void                commit();
 
-  utils::VariableMap* variables()              { return &m_variables; }
+  utils::VariableMap* variable()            { return &m_variables; }
 
   bool                get_session() const   { return m_session; }
   void                set_session(bool v)   { m_session = v; }
 
   bool                get_start() const     { return m_start; }
   void                set_start(bool v)     { m_start = v; }
 
-  bool                print_log() const        { return m_printLog; }
-  void                set_print_log(bool v)    { m_printLog = v; }
+  bool                print_log() const     { return m_printLog; }
+  void                set_print_log(bool v) { m_printLog = v; }
 
   void                slot_finished(Slot s) { m_slotFinished = s; }
 
 private:
   void                receive_load();
   void                receive_loaded();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download.h	2006-02-11 04:19:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download.h	2006-04-01 05:37:25.000000000 +0800
@@ -36,93 +36,105 @@
 
 #ifndef RTORRENT_CORE_DOWNLOAD_H
 #define RTORRENT_CORE_DOWNLOAD_H
 
 #include <sigc++/connection.h>
 #include <torrent/download.h>
+#include <torrent/file_list.h>
+#include <torrent/tracker_list.h>
 #include <torrent/torrent.h>
 
 #include "utils/variable_map.h"
 
 namespace core {
 
 class Download {
 public:
-  typedef torrent::Download::ConnectionType ConnType;
+  typedef torrent::Download             download_type;
+  typedef torrent::FileList             file_list_type;
+  typedef torrent::TrackerList          tracker_list_type;
+  typedef download_type::ConnectionType connection_type;
+  typedef utils::VariableMap            variable_map_type;
 
-  Download(torrent::Download d);
+  Download(download_type d);
   ~Download();
 
-  bool               is_open()                       { return m_download.is_open(); }
-  inline bool        is_done();
+  bool                is_open() const                          { return m_download.is_open(); }
+  inline bool         is_done() const                          { return m_download.chunks_done() == m_download.chunks_total(); }
 
-  void               start();
+  void                start();
+  void                stop();
 
-  utils::VariableMap* variables()                                  { return &m_variables; }
-  std::string        variable_string(const std::string& key)       { return m_variables.get_string(key); }
+  // Add functions like pause/etc.
 
-  torrent::Download& get_download()                  { return m_download; }
-  const torrent::Download& get_download() const      { return m_download; }
-  std::string        get_hash()                      { return m_download.info_hash(); }
-  torrent::Bencode&  get_bencode()                   { return m_download.bencode(); }
-  
-  const std::string& get_message()                   { return m_message; }
+  variable_map_type*  variable()                               { return &m_variables; }
+  std::string         variable_string(const std::string& key)  { return m_variables.get_string(key); }
 
-  uint32_t           chunks_failed() const                         { return m_chunksFailed; }
+  download_type*       download()                              { return &m_download; }
+  const download_type* download() const                        { return &m_download; }
 
-  void               enable_udp_trackers(bool state);
+  torrent::Object*    bencode()                                { return m_download.bencode(); }
+  file_list_type*     file_list()                              { return &m_fileList; }
+  tracker_list_type*  tracker_list()                           { return &m_trackerList; }
 
-  uint32_t           priority();
-  void               set_priority(uint32_t p);
+  const std::string&  info_hash() const                        { return m_download.info_hash(); }
+  const std::string&  message() const                          { return m_message; }
 
-  // Helper functions for calling functions in torrent::Download
+  uint32_t            chunks_failed() const                    { return m_chunksFailed; }
+
+  void                enable_udp_trackers(bool state);
+
+  uint32_t            priority();
+  void                set_priority(uint32_t p);
+
+  // Helper functions for calling functions in download_type
   // through sigc++.
-  template <typename Ret, Ret (torrent::Download::*func)()>
-  void               call()                                                { (m_download.*func)(); }
+  template <typename Ret, Ret (download_type::*func)()>
+  void                call()                                                { (m_download.*func)(); }
 
-  template <typename Ret, typename Arg1, Ret (torrent::Download::*func)(Arg1)>
-  void               call(Arg1 a1)                                         { (m_download.*func)(a1); }
+  template <typename Ret, typename Arg1, Ret (download_type::*func)(Arg1)>
+  void                call(Arg1 a1)                                         { (m_download.*func)(a1); }
 
   bool operator == (const std::string& str)                                { return str == m_download.info_hash(); }
 
-  void               receive_finished();
+  void                receive_finished();
 
-  static ConnType    string_to_connection_type(const std::string& name);
-  static const char* connection_type_to_string(ConnType t);
+  static connection_type string_to_connection_type(const std::string& name);
+  static const char*     connection_type_to_string(connection_type t);
 
-  static uint32_t    string_to_priority(const std::string& name);
-  static const char* priority_to_string(uint32_t p);
+  static uint32_t     string_to_priority(const std::string& name);
+  static const char*  priority_to_string(uint32_t p);
+
+  float               distributed_copies() const;
 
 private:
   Download(const Download&);
   void operator () (const Download&);
 
-  void               receive_tracker_msg(std::string msg);
-  void               receive_storage_error(std::string msg);
+  void                receive_tracker_msg(std::string msg);
+  void                receive_storage_error(std::string msg);
 
-  void               receive_chunk_failed(uint32_t idx);
+  void                receive_chunk_failed(uint32_t idx);
 
-  const char*        connection_current() const                    { return connection_type_to_string(m_download.connection_type()); }
-  void               set_connection_current(const std::string& t)  { return m_download.set_connection_type(string_to_connection_type(t.c_str())); }
+  const char*         connection_current() const                    { return connection_type_to_string(m_download.connection_type()); }
+  void                set_connection_current(const std::string& t)  { return m_download.set_connection_type(string_to_connection_type(t.c_str())); }
 
-  void               set_root_directory(const std::string& path);
+  void                set_root_directory(const std::string& path);
 
-  torrent::Download  m_download;
+  // Store the FileList instance so we can use slots etc on it.
+  download_type       m_download;
+  file_list_type      m_fileList;
+  tracker_list_type   m_trackerList;
 
-  std::string        m_message;
-  uint32_t           m_chunksFailed;
+  std::string         m_message;
+  uint32_t            m_chunksFailed;
 
-  sigc::connection   m_connTrackerSucceded;
-  sigc::connection   m_connTrackerFailed;
-  sigc::connection   m_connStorageError;
+  variable_map_type   m_variables;
 
-  utils::VariableMap  m_variables;
+  sigc::connection    m_connTrackerSucceded;
+  sigc::connection    m_connTrackerFailed;
+  sigc::connection    m_connStorageError;
 };
 
-inline bool
-Download::is_done() {
-  return m_download.chunks_done() == m_download.chunks_total();
-}
-
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_list.cc	2006-02-01 20:41:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.cc	2006-04-01 04:57:29.000000000 +0800
@@ -34,17 +34,24 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <algorithm>
+#include <iostream>
 #include <sigc++/bind.h>
+#include <torrent/exceptions.h>
+#include <torrent/object.h>
+#include <torrent/object_stream.h>
 #include <torrent/torrent.h>
 
 #include "rak/functional.h"
 
+#include "globals.h"
+#include "manager.h"
+
 #include "download.h"
 #include "download_list.h"
 
 namespace core {
 
 struct download_list_call {
@@ -55,66 +62,125 @@
   }
 
   Download* m_download;
 };    
 
 DownloadList::iterator
-DownloadList::insert(std::istream* str) {
-  torrent::Download d = torrent::download_add(str);
+DownloadList::insert(std::istream* str, bool printLog) {
+  torrent::Object* object = new torrent::Object;
+
+  try {
+
+    *str >> *object;
+    
+    // Catch, delete.
+    if (str->fail())
+      throw torrent::input_error("Could not create download, the input is not a valid torrent.");
+
+    torrent::Download d = torrent::download_add(object);
+
+    iterator itr = Base::insert(end(), new Download(d));
+
+    (*itr)->download()->signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::finished), *itr));
+    std::for_each(m_slotMapInsert.begin(), m_slotMapInsert.end(), download_list_call(*itr));
+
+    return itr;
 
-  iterator itr = Base::insert(end(), new Download(d));
-  (*itr)->get_download().signal_download_done(sigc::bind(sigc::mem_fun(*this, &DownloadList::finished), *itr));
+  } catch (torrent::local_error& e) {
+    delete object;
 
-  std::for_each(m_slotMapInsert.begin(), m_slotMapInsert.end(), download_list_call(*itr));
+    if (printLog)
+      control->core()->push_log(e.what());
 
-  return itr;
+    return end();
+  }
 }
 
 DownloadList::iterator
 DownloadList::erase(iterator itr) {
+  // Make safe to erase active downloads.
+
+  if ((*itr)->download()->is_active())
+    throw std::logic_error("DownloadList::erase(...) called on an active download.");
+
   std::for_each(m_slotMapErase.begin(), m_slotMapErase.end(), download_list_call(*itr));
 
-  torrent::download_remove((*itr)->get_download());
+  torrent::download_remove(*(*itr)->download());
   delete *itr;
 
   return Base::erase(itr);
 }
 
 void
 DownloadList::open(Download* d) {
-  if (d->get_download().is_open())
-    return;
+  try {
 
-  std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(d));
+    if (!d->download()->is_open())
+      std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(d));
+
+  } catch (torrent::local_error& e) {
+    control->core()->push_log(e.what());
+  }
 }
 
 void
 DownloadList::close(Download* d) {
-  if (!d->get_download().is_open())
-    return;
+  try {
+
+    if (d->download()->is_active())
+      std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(d));
 
-  stop(d);
-  std::for_each(m_slotMapClose.begin(), m_slotMapClose.end(), download_list_call(d));
+    if (d->download()->is_open())
+      std::for_each(m_slotMapClose.begin(), m_slotMapClose.end(), download_list_call(d));
+
+  } catch (torrent::local_error& e) {
+    control->core()->push_log(e.what());
+  }
 }
 
 void
 DownloadList::start(Download* d) {
-  if (d->get_download().is_active() ||
-      !d->get_download().is_hash_checked())
-    return;
+  d->variable()->set("state", "started");
 
-  open(d);
-  std::for_each(m_slotMapStart.begin(), m_slotMapStart.end(), download_list_call(d));
+  resume(d);
 }
 
 void
 DownloadList::stop(Download* d) {
-  if (!d->get_download().is_active())
-    return;
+  d->variable()->set("state", "stopped");
+
+  pause(d);
+}
 
-  std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(d));
+void
+DownloadList::resume(Download* d) {
+  try {
+    if (!d->download()->is_open())
+      std::for_each(m_slotMapOpen.begin(), m_slotMapOpen.end(), download_list_call(d));
+      
+    if (d->download()->is_hash_checked())
+      std::for_each(m_slotMapStart.begin(), m_slotMapStart.end(), download_list_call(d));
+    else
+      // TODO: This can cause infinit looping?
+      control->core()->hash_queue().insert(d, sigc::bind(sigc::mem_fun(*this, &DownloadList::resume), d));
+
+  } catch (torrent::local_error& e) {
+    control->core()->push_log(e.what());
+  }
+}
+
+void
+DownloadList::pause(Download* d) {
+  try {
+
+    if (d->download()->is_active())
+      std::for_each(m_slotMapStop.begin(), m_slotMapStop.end(), download_list_call(d));
+
+  } catch (torrent::local_error& e) {
+    control->core()->push_log(e.what());
+  }
 }
 
 void
 DownloadList::clear() {
   std::for_each(begin(), end(), rak::call_delete<Download>());
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_list.h	2006-02-01 20:43:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_list.h	2006-03-18 06:16:05.000000000 +0800
@@ -70,21 +70,25 @@
 
   using Base::empty;
   using Base::size;
 
   ~DownloadList() { clear(); }
 
-  iterator            insert(std::istream* str);
+  iterator            insert(std::istream* str, bool printLog);
   iterator            erase(iterator itr);
 
   void                open(Download* d);
   void                close(Download* d);
 
   void                start(Download* d);
   void                stop(Download* d);
 
+  // These do not change the rtorrent:state.
+  void                resume(Download* d);
+  void                pause(Download* d);
+
   SlotMap&            slot_map_insert()     { return m_slotMapInsert; }
   SlotMap&            slot_map_erase()      { return m_slotMapErase; }
   SlotMap&            slot_map_open()       { return m_slotMapOpen; }
   SlotMap&            slot_map_close()      { return m_slotMapClose; }
   SlotMap&            slot_map_start()      { return m_slotMapStart; }
   SlotMap&            slot_map_stop()       { return m_slotMapStop; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_store.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_store.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/download_store.cc	2006-02-11 04:13:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/download_store.cc	2006-04-01 05:46:36.000000000 +0800
@@ -40,15 +40,17 @@
 
 #include <fstream>
 #include <stdio.h>
 #include <unistd.h>
 #include <rak/path.h>
 #include <rak/string_manip.h>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
+#include <torrent/rate.h>
+#include <torrent/object_stream.h>
 
 #include "download.h"
 #include "download_store.h"
 
 namespace core {
 
@@ -95,23 +97,26 @@
 
   std::fstream f((create_filename(d) + ".new").c_str(), std::ios::out | std::ios::trunc);
 
   if (!f.is_open())
     return;
 
-  f << d->get_bencode();
+  // Move this somewhere else.
+  d->bencode()->get_key("rtorrent").insert_key("total_uploaded", d->download()->up_rate()->total());
+
+  f << *d->bencode();
 
   if (!f.good())
     return;
 
   f.close();
 
   // Test the new file, to ensure it is a valid bencode string.
   f.open((create_filename(d) + ".new").c_str(), std::ios::in);
 
-  torrent::Bencode tmp;
+  torrent::Object tmp;
   f >> tmp;
 
   if (!f.good())
     return;
 
   f.close();
@@ -154,10 +159,10 @@
 
   return true;
 }
 
 std::string
 DownloadStore::create_filename(Download* d) {
-  return m_path + rak::transform_hex(d->get_hash()) + ".torrent";
+  return m_path + rak::transform_hex(d->info_hash()) + ".torrent";
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/hash_queue.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/hash_queue.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.cc	2006-04-01 05:01:41.000000000 +0800
@@ -45,50 +45,50 @@
 #include "hash_queue.h"
 
 namespace core {
 
 void
 HashQueue::insert(Download* d, Slot s) {
-  if (d->get_download().is_hash_checking() ||
+  if (d->download()->is_hash_checking() ||
       find(d) != end())
     return;
 
-  if (d->get_download().is_hash_checked()) {
+  if (d->download()->is_hash_checked()) {
     s();
     return;
   }
 
   iterator itr = Base::insert(end(), new HashQueueNode(d, s));
 
-  (*itr)->set_connection(d->get_download().signal_hash_done(sigc::bind(sigc::mem_fun(*this, &HashQueue::receive_hash_done),
-								       (*itr)->get_download())));
+  (*itr)->set_connection(d->download()->signal_hash_done(sigc::bind(sigc::mem_fun(*this, &HashQueue::receive_hash_done),
+								       (*itr)->download())));
 
   fill_queue();
 }
 
 void
 HashQueue::remove(Download* d) {
   iterator itr = find(d);
 
   if (itr == end())
     return;
 
   // We don't do anything if we're already checking, just disconnect.
-//   if ((*itr)->get_download()->get_download().is_hash_checking()) {
+//   if ((*itr)->download()->download()->is_hash_checking()) {
 //     // What do we do if we're already checking?
 //   }
 
   delete *itr;
   Base::erase(itr);
 
   fill_queue();
 }
 
 HashQueue::iterator
 HashQueue::find(Download* d) {
-  return std::find_if(begin(), end(), rak::equal(d, std::mem_fun(&HashQueueNode::get_download)));
+  return std::find_if(begin(), end(), rak::equal(d, std::mem_fun(&HashQueueNode::download)));
 }
 
 void
 HashQueue::receive_hash_done(Download* d) {
   iterator itr = find(d);
 
@@ -104,16 +104,16 @@
   s();
   fill_queue();
 }
 
 void
 HashQueue::fill_queue() {
-  if (empty() || front()->get_download()->get_download().is_hash_checking())
+  if (empty() || front()->download()->download()->is_hash_checking())
     return;
 
-  if (front()->get_download()->get_download().is_hash_checked())
+  if (front()->download()->download()->is_hash_checked())
     throw std::logic_error("core::HashQueue::fill_queue() encountered a checked hash");
   
-  front()->get_download()->get_download().hash_check();
+  front()->download()->download()->hash_check();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/hash_queue.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/hash_queue.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/hash_queue.h	2006-04-01 04:52:38.000000000 +0800
@@ -86,13 +86,13 @@
 public:
   HashQueueNode(Download* d, HashQueue::Slot s) : m_download(d), m_slot(s) {}
   ~HashQueueNode()                                       { disconnect(); }
 
   void                disconnect()                       { m_connection.disconnect(); }
 
-  Download*           get_download()                     { return m_download; }
+  Download*           download()                         { return m_download; }
   HashQueue::Slot     get_slot()                         { return m_slot; }
 
   void                set_connection(sigc::connection c) { m_connection = c; }
 
 private:
   Download*           m_download;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/manager.cc	2006-02-01 21:02:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.cc	2006-04-03 01:59:30.000000000 +0800
@@ -37,21 +37,24 @@
 #include "config.h"
 
 #include <stdexcept>
 #include <cstdio>
 #include <cstring>
 #include <fstream>
-#include <istream>
 #include <unistd.h>
 #include <sys/select.h>
+#include <rak/address_info.h>
+#include <rak/error_number.h>
 #include <rak/regex.h>
 #include <rak/string_manip.h>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
+#include <torrent/connection_manager.h>
 #include <torrent/exceptions.h>
+#include <torrent/tracker_list.h>
 
 #include "utils/variable_map.h"
 
 #include "globals.h"
 #include "curl_get.h"
 #include "download.h"
@@ -60,25 +63,49 @@
 #include "poll_manager_epoll.h"
 #include "poll_manager_select.h"
 
 namespace core {
 
 static void
-connect_signal_network_log(Download* d, torrent::Download::SlotString s) {
-  d->get_download().signal_network_log(s);
+connect_signal_network_log(Download* d, torrent::Download::slot_string_type s) {
+  d->download()->signal_network_log(s);
 }
 
 static void
-connect_signal_storage_log(Download* d, torrent::Download::SlotString s) {
-  d->get_download().signal_storage_error(s);
+connect_signal_storage_log(Download* d, torrent::Download::slot_string_type s) {
+  d->download()->signal_storage_error(s);
+}
+
+// Need a proper logging class for this.
+static void
+connect_signal_tracker_dump(Download* d, torrent::Download::slot_dump_type s) {
+  if (!control->variable()->get_string("tracker_dump").empty())
+    d->download()->signal_tracker_dump(s);
+}
+
+static void
+receive_tracker_dump(const std::string& url, const char* data, size_t size) {
+  const std::string& filename = control->variable()->get_string("tracker_dump");
+
+  if (filename.empty())
+    return;
+
+  std::fstream fstr(filename.c_str(), std::ios::out | std::ios::app);
+
+  if (!fstr.is_open())
+    return;
+
+  fstr << "url: " << url << std::endl << "---" << std::endl;
+  fstr.write(data, size);
+  fstr << std::endl <<"---" << std::endl;
 }
 
 // Hmm... find some better place for all this.
 static void
 delete_tied(Download* d) {
-  const std::string tie = d->variables()->get("tied_to_file").as_string();
+  const std::string tie = d->variable()->get("tied_to_file").as_string();
 
   // This should be configurable, need to wait for the variable
   // thingie to be implemented.
   if (!tie.empty())
     ::unlink(tie.c_str());
 }
@@ -109,14 +136,15 @@
   m_httpQueue.slot_factory(m_pollManager->get_http_stack()->get_http_factory());
 
   CurlStack::global_init();
 
   // Register slots to be called when a download is inserted/erased,
   // opened or closed.
-  m_downloadList.slot_map_insert()["1_connect_network_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
-  m_downloadList.slot_map_insert()["1_connect_storage_log"] = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
+  m_downloadList.slot_map_insert()["1_connect_network_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_network_log), sigc::mem_fun(m_logComplete, &Log::push_front));
+  m_downloadList.slot_map_insert()["1_connect_storage_log"]  = sigc::bind(sigc::ptr_fun(&connect_signal_storage_log), sigc::mem_fun(m_logComplete, &Log::push_front));
+  m_downloadList.slot_map_insert()["1_connect_tracker_dump"] = sigc::bind(sigc::ptr_fun(&connect_signal_tracker_dump), sigc::ptr_fun(&receive_tracker_dump));
 
   m_downloadList.slot_map_erase()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
   m_downloadList.slot_map_erase()["1_store_remove"]         = sigc::mem_fun(m_downloadStore, &DownloadStore::remove);
   m_downloadList.slot_map_erase()["1_delete_tied"]          = sigc::ptr_fun(&delete_tied);
 
   m_downloadList.slot_map_open()["1_download_open"]         = sigc::mem_fun(&Download::call<void, &torrent::Download::open>);
@@ -125,13 +153,13 @@
   // checks if we're running, and if so stop?
   m_downloadList.slot_map_close()["1_hash_queue_remove"]    = sigc::mem_fun(m_hashQueue, &HashQueue::remove);
   m_downloadList.slot_map_close()["2_download_close"]       = sigc::mem_fun(&Download::call<void, &torrent::Download::close>);
 
   m_downloadList.slot_map_start()["1_download_start"]       = sigc::mem_fun(&Download::start);
 
-  m_downloadList.slot_map_stop()["1_download_stop"]         = sigc::mem_fun(&Download::call<void, &torrent::Download::stop>);
+  m_downloadList.slot_map_stop()["1_download_stop"]         = sigc::mem_fun(&Download::stop);
   m_downloadList.slot_map_stop()["2_hash_resume_save"]      = sigc::mem_fun(&Download::call<void, &torrent::Download::hash_resume_save>);
   m_downloadList.slot_map_stop()["3_store_save"]            = sigc::mem_fun(m_downloadStore, &DownloadStore::save);
 
   m_downloadList.slot_map_finished()["1_download_done"]     = sigc::mem_fun(*this, &Manager::receive_download_done);
   m_downloadList.slot_map_finished()["2_receive_finished"]  = sigc::mem_fun(&Download::receive_finished);
 }
@@ -147,104 +175,38 @@
   delete m_pollManager;
 }
 
 void
 Manager::shutdown(bool force) {
   if (!force)
-    std::for_each(m_downloadList.begin(), m_downloadList.end(),
-		  std::bind1st(std::mem_fun(&DownloadList::stop), &m_downloadList));
+    std::for_each(m_downloadList.begin(), m_downloadList.end(), std::bind1st(std::mem_fun(&DownloadList::pause), &m_downloadList));
   else
-    std::for_each(m_downloadList.begin(), m_downloadList.end(),
-		  std::bind1st(std::mem_fun(&DownloadList::close), &m_downloadList));
-}
-
-Manager::DListItr
-Manager::insert(std::istream* s, bool printLog) {
-  try {
-    return m_downloadList.insert(s);
-
-  } catch (torrent::local_error& e) {
-    if (printLog) {
-      m_logImportant.push_front(e.what());
-      m_logComplete.push_front(e.what());
-    }
-
-    return m_downloadList.end();
-  }
-}
-
-Manager::DListItr
-Manager::erase(DListItr itr) {
-  if ((*itr)->get_download().is_active())
-    throw std::logic_error("core::Manager::erase(...) called on an active download");
-
-//   if (!(*itr)->get_download().is_open())
-//     throw std::logic_error("core::Manager::erase(...) called on an closed download");
-
-  return m_downloadList.erase(itr);
-}  
-
-void
-Manager::start(Download* d, bool printLog) {
-  try {
-    d->variables()->set("state", "started");
-
-    if (d->get_download().is_active())
-      return;
-
-    if (!d->get_download().is_open())
-      m_downloadList.open(d);
-
-    if (d->get_download().is_hash_checked())
-      m_downloadList.start(d);
-    else
-      // This can cause infinit loops?
-      m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(m_downloadList, &DownloadList::start), d));
-
-  } catch (torrent::local_error& e) {
-    if (printLog) {
-      m_logImportant.push_front(e.what());
-      m_logComplete.push_front(e.what());
-    }
-  }
-}
-
-void
-Manager::stop(Download* d) {
-  try {
-    d->variables()->set("state", "stopped");
-
-    m_downloadList.stop(d);
-
-  } catch (torrent::local_error& e) {
-    m_logImportant.push_front(e.what());
-    m_logComplete.push_front(e.what());
-  }
+    std::for_each(m_downloadList.begin(), m_downloadList.end(), std::bind1st(std::mem_fun(&DownloadList::close), &m_downloadList));
 }
 
 void
 Manager::check_hash(Download* d) {
-  bool restart = d->get_download().is_active();
+  bool restart = d->download()->is_active();
 
   try {
     prepare_hash_check(d);
 
     if (restart)
-      m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(m_downloadList, &DownloadList::start), d));
+      m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(m_downloadList, &DownloadList::resume), d));
     else
       m_hashQueue.insert(d, sigc::slot0<void>());
 
   } catch (torrent::local_error& e) {
     m_logImportant.push_front(e.what());
     m_logComplete.push_front(e.what());
   }
 }  
 
 void
 Manager::receive_download_done(Download* d) {
-  if (control->variables()->get("check_hash").as_string() == "yes") {
+  if (control->variable()->get("check_hash").as_string() == "yes") {
     // Start the hash checking, send completed to tracker after
     // finishing.
     prepare_hash_check(d);
 
     // TODO: Need to restart the torrent.
     m_hashQueue.insert(d, sigc::bind(sigc::mem_fun(*this, &Manager::receive_download_done_hash_checked), d));
@@ -253,51 +215,91 @@
     receive_download_done_hash_checked(d);
   }
 }
 
 void
 Manager::listen_open() {
+  if (control->variable()->get_string("port_open") != "yes")
+    return;
+
   if (m_portFirst > m_portLast)
     throw torrent::input_error("Invalid port range for listening");
 
-  if (control->variables()->get("port_random").as_string() == "yes") {
+  if (control->variable()->get("port_random").as_string() == "yes") {
     int boundary = m_portFirst + random() % (m_portLast - m_portFirst + 1);
 
-    if (!torrent::listen_open(boundary, m_portLast) &&
-	!torrent::listen_open(m_portFirst, boundary))
-      throw torrent::input_error("Could not open/bind a port for listening.");
+    if (torrent::connection_manager()->listen_open(boundary, m_portLast) ||
+	torrent::connection_manager()->listen_open(m_portFirst, boundary))
+      return;
 
   } else {
-    if (!torrent::listen_open(m_portFirst, m_portLast))
-      throw torrent::input_error("Could not open/bind a port for listening.");
-
+    if (torrent::connection_manager()->listen_open(m_portFirst, m_portLast))
+      return;
   }
+
+  throw torrent::input_error("Could not open/bind a port for listening: " + std::string(rak::error_number::current().c_str()));
 }
 
 void
-Manager::bind(const std::string& addr) {
-  if (torrent::listen_port() != 0) {
-    torrent::listen_close();
-    torrent::set_bind_address(addr);
-    listen_open();
+Manager::set_bind_address(const std::string& addr) {
+  int err;
+  rak::address_info* ai;
 
-  } else {
-    torrent::set_bind_address(addr);
+  if ((err = rak::address_info::get_address_info(addr.c_str(), PF_INET, SOCK_STREAM, &ai)) != 0)
+    throw torrent::input_error("Could not set bind address: " + std::string(rak::address_info::strerror(err)) + ".");
+  
+  try {
+
+    if (torrent::connection_manager()->listen_port() != 0) {
+      torrent::connection_manager()->listen_close();
+      torrent::connection_manager()->set_bind_address(ai->address()->c_sockaddr());
+      listen_open();
+
+    } else {
+      torrent::connection_manager()->set_bind_address(ai->address()->c_sockaddr());
+    }
+
+    rak::address_info::free_address_info(ai);
+
+    m_pollManager->get_http_stack()->set_bind_address(addr);
+
+  } catch (torrent::input_error& e) {
+    rak::address_info::free_address_info(ai);
+    throw e;
   }
+}
+
+void
+Manager::set_local_address(const std::string& addr) {
+  int err;
+  rak::address_info* ai;
+
+  if ((err = rak::address_info::get_address_info(addr.c_str(), PF_INET, SOCK_STREAM, &ai)) != 0)
+    throw torrent::input_error("Could not set local address: " + std::string(rak::address_info::strerror(err)) + ".");
+  
+  try {
+
+    torrent::connection_manager()->set_local_address(ai->address()->c_sockaddr());
+    rak::address_info::free_address_info(ai);
 
-  m_pollManager->get_http_stack()->set_bind_address(torrent::bind_address());
+    m_pollManager->get_http_stack()->set_bind_address(addr);
+
+  } catch (torrent::input_error& e) {
+    rak::address_info::free_address_info(ai);
+    throw e;
+  }
 }
 
 void
 Manager::prepare_hash_check(Download* d) {
   m_downloadList.close(d);
-  d->get_download().hash_resume_clear();
+  d->download()->hash_resume_clear();
   m_downloadList.open(d);
 
-  if (d->get_download().is_hash_checking() ||
-      d->get_download().is_hash_checked())
+  if (d->download()->is_hash_checking() ||
+      d->download()->is_hash_checked())
     throw std::logic_error("Manager::check_hash(...) closed the torrent but is_hash_check{ing,ed}() == true");
 
   if (m_hashQueue.find(d) != m_hashQueue.end())
     throw std::logic_error("Manager::check_hash(...) closed the torrent but it was found in m_hashQueue");
 }
 
@@ -306,29 +308,28 @@
   m_logImportant.push_front("Http download error: \"" + msg + "\"");
   m_logComplete.push_front("Http download error: \"" + msg + "\"");
 }
 
 void
 Manager::receive_download_done_hash_checked(Download* d) {
-  if (!d->get_download().is_active())
-    m_downloadList.start(d);
+  m_downloadList.resume(d);
 
-  if (control->variables()->get_string("session_on_completion") == "yes")
+  if (control->variable()->get_string("session_on_completion") == "yes")
     m_downloadStore.save(d);
 
   // Don't send if we did a hash check and found incompelete chunks.
   if (d->is_done())
-    d->get_download().tracker_send_completed();
+    d->download()->tracker_list().send_completed();
 }
 
 void
 Manager::try_create_download(const std::string& uri, bool start, bool printLog, bool tied) {
   // Adding download.
   DownloadFactory* f = new DownloadFactory(uri, this);
 
-  f->variables()->set("tied_to_file", tied ? "yes" : "no");
+  f->variable()->set("tied_to_file", tied ? "yes" : "no");
 
   f->set_start(start);
   f->set_print_log(printLog);
   f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
   f->load();
   f->commit();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/core/manager.h	2006-02-01 19:43:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/core/manager.h	2006-03-18 04:00:05.000000000 +0800
@@ -75,22 +75,17 @@
   void                initialize_first();
   void                initialize_second();
   void                cleanup();
 
   void                listen_open();
 
-  void                bind(const std::string& addr);
+  void                set_bind_address(const std::string& addr);
+  void                set_local_address(const std::string& addr);
 
   void                shutdown(bool force);
 
-  DListItr            insert(std::istream* s, bool printLog = true);
-  DListItr            erase(DListItr itr);
-
-  void                start(Download* d, bool printLog = true);
-  void                stop(Download* d);
-
   void                check_hash(Download* d);
 
   void                push_log(const std::string& msg)    { m_logImportant.push_front(msg); m_logComplete.push_front(msg); }
 
   // Temporary, find a better place for this.
   void                try_create_download(const std::string& uri, bool start, bool printLog = true, bool tied = false);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/canvas.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/canvas.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/canvas.h	2006-01-21 00:27:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/canvas.h	2006-04-06 01:24:41.000000000 +0800
@@ -108,12 +108,16 @@
                	            A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7)  { mvwprintw(m_window, y, x, str, a1, a2, a3, a4, a5, a6, a7); }
 
   template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
   void                print(int x, int y, char* str,
                	            A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) { mvwprintw(m_window, y, x, str, a1, a2, a3, a4, a5, a6, a7, a8); }
 
+  void                print_char(const chtype ch) { waddch(m_window, ch); }
+
+  void                print_char(int x, int y, const chtype ch) { mvwaddch(m_window, y, x, ch); }
+
   void                set_attr(int x, int y, int n, int attr, int color)      { mvwchgat(m_window, y, x, n, attr, color, NULL); }
 
   // Initialize stdscr.
   static void         initialize();
   static void         cleanup();
 
@@ -130,9 +134,13 @@
 
   static bool         m_isInitialized;
 
   WINDOW*             m_window;
 };
 
+// Undefines 'timeout' that ncurses defines which screws up the global
+// namespace. Idiots; Especially you, ESR.
+#undef timeout
+
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display: client_info.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display: client_info.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/Makefile.am	2005-12-22 08:33:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/Makefile.am	2006-03-23 04:05:14.000000000 +0800
@@ -1,17 +1,21 @@
 noinst_LIBRARIES = libsub_display.a
 
 libsub_display_a_SOURCES = \
 	canvas.cc \
 	canvas.h \
+	client_info.cc \
+	client_info.h \
 	manager.cc \
 	manager.h \
 	utils.cc \
 	utils.h \
 	window.cc \
 	window.h \
+	window_download_chunks_seen.cc \
+	window_download_chunks_seen.h \
 	window_download_list.cc \
 	window_download_list.h \
 	window_download_statusbar.cc \
 	window_download_statusbar.h \
 	window_file_list.cc \
 	window_file_list.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/Makefile.in	2006-02-12 00:13:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/Makefile.in	2006-04-07 01:43:32.000000000 +0800
@@ -50,14 +50,15 @@
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_display_a_AR = $(AR) $(ARFLAGS)
 libsub_display_a_LIBADD =
-am_libsub_display_a_OBJECTS = canvas.$(OBJEXT) manager.$(OBJEXT) \
-	utils.$(OBJEXT) window.$(OBJEXT) \
+am_libsub_display_a_OBJECTS = canvas.$(OBJEXT) client_info.$(OBJEXT) \
+	manager.$(OBJEXT) utils.$(OBJEXT) window.$(OBJEXT) \
+	window_download_chunks_seen.$(OBJEXT) \
 	window_download_list.$(OBJEXT) \
 	window_download_statusbar.$(OBJEXT) window_file_list.$(OBJEXT) \
 	window_http_queue.$(OBJEXT) window_input.$(OBJEXT) \
 	window_log.$(OBJEXT) window_log_complete.$(OBJEXT) \
 	window_peer_info.$(OBJEXT) window_peer_list.$(OBJEXT) \
 	window_statusbar.$(OBJEXT) window_string_list.$(OBJEXT) \
@@ -187,18 +188,22 @@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 noinst_LIBRARIES = libsub_display.a
 libsub_display_a_SOURCES = \
 	canvas.cc \
 	canvas.h \
+	client_info.cc \
+	client_info.h \
 	manager.cc \
 	manager.h \
 	utils.cc \
 	utils.h \
 	window.cc \
 	window.h \
+	window_download_chunks_seen.cc \
+	window_download_chunks_seen.h \
 	window_download_list.cc \
 	window_download_list.h \
 	window_download_statusbar.cc \
 	window_download_statusbar.h \
 	window_file_list.cc \
 	window_file_list.h \
@@ -269,15 +274,17 @@
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/canvas.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/client_info.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/manager.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/utils.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_chunks_seen.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_download_statusbar.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_file_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_http_queue.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_input.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/window_log.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/utils.cc	2006-02-16 22:47:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.cc	2006-04-01 05:41:04.000000000 +0800
@@ -36,78 +36,26 @@
 
 #include "config.h"
 
 #include <cstring>
 #include <sstream>
 #include <iomanip>
+#include <rak/socket_address.h>
+#include <rak/timer.h>
 #include <torrent/exceptions.h>
+#include <torrent/connection_manager.h>
 #include <torrent/rate.h>
 #include <torrent/tracker.h>
+#include <torrent/tracker_list.h>
 
 #include "core/download.h"
-#include <rak/timer.h>
 
 #include "utils.h"
 
 namespace display {
 
-inline char*
-print_buffer(char* first, char* last, const char* format) {
-  if (first >= last)
-    return first;
-
-  int s = snprintf(first, last - first, format);
-
-  if (s < 0)
-    return first;
-  else
-    return std::min(first + s, last);
-}
-
-template <typename Arg1>
-inline char*
-print_buffer(char* first, char* last, const char* format, const Arg1& arg1) {
-  if (first >= last)
-    return first;
-
-  int s = snprintf(first, last - first, format, arg1);
-
-  if (s < 0)
-    return first;
-  else
-    return std::min(first + s, last);
-}
-
-template <typename Arg1, typename Arg2>
-inline char*
-print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2) {
-  if (first >= last)
-    return first;
-
-  int s = snprintf(first, last - first, format, arg1, arg2);
-
-  if (s < 0)
-    return first;
-  else
-    return std::min(first + s, last);
-}
-
-template <typename Arg1, typename Arg2, typename Arg3>
-inline char*
-print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2, const Arg3& arg3) {
-  if (first >= last)
-    return first;
-
-  int s = snprintf(first, last - first, format, arg1, arg2, arg3);
-
-  if (s < 0)
-    return first;
-  else
-    return std::min(first + s, last);
-}
-
 char*
 print_string(char* first, char* last, char* str) {
   // We don't have any nice simple functions for copying strings that
   // return the end address.
   while (first != last && *str != '\0')
     *(first++) = *(str++);
@@ -126,13 +74,13 @@
   return print_buffer(first, last, "%2u:%02u:%02u", u->tm_hour, u->tm_min, u->tm_sec);
 }
 
 char*
 print_ddhhmm(char* first, char* last, time_t t) {
   if (t / (24 * 3600) < 100)
-    return print_buffer(first, last, "%2i:%02i:%02i", (int)t / (24 * 3600), ((int)t / 3600) % 24, ((int)t / 60) % 60);
+    return print_buffer(first, last, "%2id %2i:%02i", (int)t / (24 * 3600), ((int)t / 3600) % 24, ((int)t / 60) % 60);
   else
     return print_buffer(first, last, "--:--:--");
 }
 
 char*
 print_ddmmyyyy(char* first, char* last, time_t t) {
@@ -143,36 +91,49 @@
     throw torrent::internal_error("print_ddmmyyyy(...) failed.");
 
   return print_buffer(first, last, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
 }
 
 char*
+print_address(char* first, char* last, const rak::socket_address* sa) {
+  if (!sa->address_c_str(first, last - first))
+    return first;
+
+  return std::find(first, last, '\0');
+}
+
+inline char*
+print_address(char* first, char* last, const sockaddr* sa) {
+  return print_address(first, last, rak::socket_address::cast_from(sa));
+}
+
+char*
 print_download_title(char* first, char* last, core::Download* d) {
-  return print_buffer(first, last, " %s", d->get_download().name().c_str());
+  return print_buffer(first, last, " %s", d->download()->name().c_str());
 }
 
 char*
 print_download_info(char* first, char* last, core::Download* d) {
   first = print_buffer(first, last, "Torrent: ");
 
-  if (!d->get_download().is_open())
+  if (!d->download()->is_open())
     first = print_buffer(first, last, "closed            ");
 
   else if (d->is_done())
-    first = print_buffer(first, last, "done %10.1f MB", (double)d->get_download().bytes_total() / (double)(1 << 20));
+    first = print_buffer(first, last, "done %10.1f MB", (double)d->download()->bytes_total() / (double)(1 << 20));
   else
     first = print_buffer(first, last, "%6.1f / %6.1f MB",
-		       (double)d->get_download().bytes_done() / (double)(1 << 20),
-		       (double)d->get_download().bytes_total() / (double)(1 << 20));
+		       (double)d->download()->bytes_done() / (double)(1 << 20),
+		       (double)d->download()->bytes_total() / (double)(1 << 20));
   
   first = print_buffer(first, last, " Rate: %5.1f / %5.1f KB Uploaded: %7.1f MB",
-		     (double)d->get_download().up_rate()->rate() / (1 << 10),
-		     (double)d->get_download().down_rate()->rate() / (1 << 10),
-		     (double)d->get_download().up_rate()->total() / (1 << 20));
+		     (double)d->download()->up_rate()->rate() / (1 << 10),
+		     (double)d->download()->down_rate()->rate() / (1 << 10),
+		     (double)d->download()->up_rate()->total() / (1 << 20));
 
-  if (d->get_download().is_active() && !d->is_done()) {
+  if (d->download()->is_active() && !d->is_done()) {
     first = print_buffer(first, last, " ");
     first = print_download_percentage_done(first, last, d);
 
     first = print_buffer(first, last, " ");
     first = print_download_time_left(first, last, d);
   } else {
@@ -187,57 +148,57 @@
 
   return first;
 }
 
 char*
 print_download_status(char* first, char* last, core::Download* d) {
-  if (!d->get_download().is_active())
+  if (!d->download()->is_active())
     first = print_buffer(first, last, "Inactive: ");
 
-  if (d->get_download().is_hash_checking())
+  if (d->download()->is_hash_checking()) {
     first = print_buffer(first, last, "Checking hash [%2i%%]",
-		       (d->get_download().chunks_hashed() * 100) / d->get_download().chunks_total());
+		       (d->download()->chunks_hashed() * 100) / d->download()->chunks_total());
+
+  } else if (d->tracker_list()->is_busy() && d->tracker_list()->focus() < d->tracker_list()->size()) {
+    torrent::TrackerList* tl = d->tracker_list();
 
-  else if (d->get_download().is_tracker_busy() &&
-	   d->get_download().tracker_focus() < d->get_download().size_trackers())
     first = print_buffer(first, last, "Tracker[%i:%i]: Connecting to %s",
-		       d->get_download().tracker(d->get_download().tracker_focus()).group(),
-		       d->get_download().tracker_focus(),
-		       d->get_download().tracker(d->get_download().tracker_focus()).url().c_str());
+			 tl->get(tl->focus()).group(), tl->focus(), tl->get(tl->focus()).url().c_str());
 
-  else if (!d->get_message().empty())
-    first = print_buffer(first, last, "%s", d->get_message().c_str());
+  } else if (!d->message().empty()) {
+    first = print_buffer(first, last, "%s", d->message().c_str());
 
-  else
+  } else {
     *first = '\0';
+  }
 
   if (first > last)
     throw torrent::internal_error("print_download_status(...) wrote past end of the buffer.");
 
   return first;
 }
 
 char*
 print_download_time_left(char* first, char* last, core::Download* d) {
-  uint32_t rate = d->get_download().down_rate()->rate();
+  uint32_t rate = d->download()->down_rate()->rate();
 
   if (rate < 512)
     return print_buffer(first, last, "--:--:--");
   
-  time_t remaining = (d->get_download().bytes_total() - d->get_download().bytes_done()) / (rate & ~(uint32_t)(512 - 1));
+  time_t remaining = (d->download()->bytes_total() - d->download()->bytes_done()) / (rate & ~(uint32_t)(512 - 1));
 
   return print_ddhhmm(first, last, remaining);
 }
 
 char*
 print_download_percentage_done(char* first, char* last, core::Download* d) {
   if (!d->is_open() || d->is_done())
     //return print_buffer(first, last, "[--%%]");
     return print_buffer(first, last, "     ");
   else
-    return print_buffer(first, last, "[%2u%%]", (d->get_download().chunks_done() * 100) / d->get_download().chunks_total());
+    return print_buffer(first, last, "[%2u%%]", (d->download()->chunks_done() * 100) / d->download()->chunks_total());
 }
 
 char*
 print_status_info(char* first, char* last) {
   if (torrent::up_throttle() == 0)
     first = print_buffer(first, last, "[Throttle off");
@@ -250,23 +211,28 @@
     first = print_buffer(first, last, "/%3i KB]", torrent::down_throttle() / 1024);
   
   first = print_buffer(first, last, " [Rate %5.1f/%5.1f KB]",
 		       (double)torrent::up_rate()->rate() / 1024.0,
 		       (double)torrent::down_rate()->rate() / 1024.0);
 
-  first = print_buffer(first, last, " [Listen %s:%u]",
-		       torrent::local_address().c_str(),
-		       (unsigned int)torrent::listen_port());
+  first = print_buffer(first, last, " [Port: %i]", (unsigned int)torrent::connection_manager()->listen_port());
+
+  if (!rak::socket_address::cast_from(torrent::connection_manager()->local_address())->is_address_any()) {
+    first = print_buffer(first, last, " [Local ");
+    first = print_address(first, last, torrent::connection_manager()->local_address());
+    first = print_buffer(first, last, "]");
+  }
   
   if (first > last)
     throw torrent::internal_error("print_status_info(...) wrote past end of the buffer.");
 
-  std::string bindAddress = torrent::bind_address();
-
-  if (!bindAddress.empty())
-    first = print_buffer(first, last, " [Bind %s]", bindAddress.c_str());
+  if (!rak::socket_address::cast_from(torrent::connection_manager()->bind_address())->is_address_any()) {
+    first = print_buffer(first, last, " [Bind ");
+    first = print_address(first, last, torrent::connection_manager()->bind_address());
+    first = print_buffer(first, last, "]");
+  }
 
   return first;
 }
 
 char*
 print_status_extra(char* first, char* last, __UNUSED Control* c) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/utils.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/utils.h	2006-02-02 23:26:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/utils.h	2006-03-02 02:53:47.000000000 +0800
@@ -71,9 +71,106 @@
 char*       print_entry_tags(char* first, char* last);
 char*       print_entry_file(char* first, char* last, const torrent::Entry& entry);
 
 char*       print_status_info(char* first, char* last);
 char*       print_status_extra(char* first, char* last, Control* c);
 
+inline char*
+print_buffer(char* first, char* last, const char* format) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2, typename Arg3>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2, const Arg3& arg3) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2, arg3);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2, typename Arg3, typename Arg4>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2, const Arg3& arg3, const Arg4& arg4) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2, arg3, arg4);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2, const Arg3& arg3, const Arg4& arg4, const Arg5& arg5) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2, arg3, arg4, arg5);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
+template <typename Arg1, typename Arg2, typename Arg3, typename Arg4, typename Arg5, typename Arg6>
+inline char*
+print_buffer(char* first, char* last, const char* format, const Arg1& arg1, const Arg2& arg2, const Arg3& arg3, const Arg4& arg4, const Arg5& arg5, const Arg6& arg6) {
+  if (first >= last)
+    return first;
+
+  int s = snprintf(first, last - first, format, arg1, arg2, arg3, arg4, arg5, arg6);
+
+  if (s < 0)
+    return first;
+  else
+    return std::min(first + s, last);
+}
+
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display: window_download_chunks_seen.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display: window_download_chunks_seen.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_download_statusbar.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_download_statusbar.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_download_statusbar.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_download_statusbar.cc	2006-04-01 05:41:20.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <torrent/rate.h>
+#include <torrent/tracker_list.h>
 
 #include "canvas.h"
 #include "globals.h"
 #include "utils.h"
 #include "window_download_statusbar.h"
 
@@ -62,29 +63,31 @@
   char* position;
   char* last = buffer + m_canvas->get_width() - 2;
 
   position = print_download_info(buffer, last, m_download);
   m_canvas->print(0, 0, "%s", buffer);
 
-  position = buffer + std::max(snprintf(buffer, last - buffer, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I: %i/%i Failed: %i",
-					(int)m_download->get_download().peers_connected(),
-					(int)m_download->get_download().peers_not_connected(),
-					(int)m_download->get_download().peers_min(),
-					(int)m_download->get_download().peers_max(),
-					(int)m_download->get_download().uploads_max(),
-					(int)m_download->get_download().peers_currently_unchoked(),
-					(int)m_download->get_download().peers_currently_interested(),
+  position = buffer + std::max(snprintf(buffer, last - buffer, "Peers: %i(%i) Min/Max: %i/%i Uploads: %i U/I/C/A: %i/%i/%i/%i Failed: %i",
+					(int)m_download->download()->peers_connected(),
+					(int)m_download->download()->peers_not_connected(),
+					(int)m_download->download()->peers_min(),
+					(int)m_download->download()->peers_max(),
+					(int)m_download->download()->uploads_max(),
+					(int)m_download->download()->peers_currently_unchoked(),
+					(int)m_download->download()->peers_currently_interested(),
+					(int)m_download->download()->peers_complete(),
+					(int)m_download->download()->peers_accounted(),
 					(int)m_download->chunks_failed()),
 			       0);
 //   position = buffer + std::max(snprintf(position, last - buffer, " Priority: %s",
-// 					core::Download::priority_to_string(m_download->variables()->get("priority").as_value())),
+// 					core::Download::priority_to_string(m_download->variable()->get("priority").as_value())),
 // 			       0);
   m_canvas->print(0, 1, "%s", buffer);
 
   position = print_download_status(buffer, last, m_download);
   m_canvas->print(0, 2, "[%c:%i] %s",
-		  m_download->get_download().is_tracker_busy() ? 'C' : ' ',
-		  (int)(m_download->get_download().tracker_timeout() / 1000000),
+		  m_download->tracker_list()->is_busy() ? 'C' : ' ',
+		  (int)(m_download->download()->tracker_list().timeout() / 1000000),
 		  buffer);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_file_list.cc	2006-02-12 00:12:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_file_list.cc	2006-04-07 00:52:32.000000000 +0800
@@ -35,12 +35,14 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
 #include <rak/algorithm.h>
+#include <torrent/file.h>
+#include <torrent/file_list.h>
 #include <torrent/path.h>
 
 #include "core/download.h"
 
 #include "window_file_list.h"
 
@@ -71,14 +73,15 @@
 
 void
 WindowFileList::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(10)).round_seconds());
   m_canvas->erase();
 
-  if (m_download->get_download().size_file_entries() == 0 ||
-      m_canvas->get_height() < 2)
+  torrent::FileList fl = m_download->download()->file_list();
+
+  if (fl.size() == 0 || m_canvas->get_height() < 2)
     return;
 
   int pos = 0;
 
   m_canvas->print( 2, pos, "File");
   m_canvas->print(55, pos, "Size");
@@ -86,42 +89,39 @@
   m_canvas->print(68, pos, "Cmpl");
   m_canvas->print(74, pos, "Encoding");
   m_canvas->print(84, pos, "Chunks");
 
   ++pos;
 
-  if (*m_focus >= m_download->get_download().size_file_entries())
+  if (*m_focus >= fl.size())
     throw std::logic_error("WindowFileList::redraw() called on an object with a bad focus value");
 
-  Range range = rak::advance_bidirectional<unsigned int>(0,
-							 *m_focus,
-							 m_download->get_download().size_file_entries(),
-							 m_canvas->get_height() - pos);
+  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, fl.size(), m_canvas->get_height() - pos);
 
   while (range.first != range.second) {
-    torrent::Entry e = m_download->get_download().file_entry(range.first);
+    torrent::File e = fl.get(range.first);
 
     std::string path = e.path_str();
 
     if (path.length() <= 50)
       path = path + std::string(50 - path.length(), ' ');
     else
       path = path.substr(0, 50);
 
     std::string priority;
 
     switch (e.priority()) {
-    case torrent::Entry::OFF:
+    case torrent::File::OFF:
       priority = "off";
       break;
 
-    case torrent::Entry::NORMAL:
+    case torrent::File::NORMAL:
       priority = "   ";
       break;
 
-    case torrent::Entry::HIGH:
+    case torrent::File::HIGH:
       priority = "hig";
       break;
 
     default:
       priority = "BUG";
       break;
@@ -132,24 +132,26 @@
 		    path.c_str(),
 		    (double)e.size_bytes() / (double)(1 << 20),
 		    priority.c_str(),
 		    done_percentage(e),
 		    e.path()->encoding().c_str());
 
-    m_canvas->print(84, pos, "%i - %i",
+    m_canvas->print(84, pos, "%i - %i %c%c",
 		    e.chunk_begin(),
-		    e.chunk_begin() != e.chunk_end() ? (e.chunk_end() - 1) : e.chunk_end());
+		    e.chunk_begin() != e.chunk_end() ? (e.chunk_end() - 1) : e.chunk_end(),
+		    e.is_created() ? 'E' : 'M',
+		    e.is_correct_size() ? 'C' : 'W');
 
     ++range.first;
     ++pos;
   }
 
 }
 
 int
-WindowFileList::done_percentage(torrent::Entry& e) {
+WindowFileList::done_percentage(torrent::File& e) {
   int chunks = e.chunk_end() - e.chunk_begin();
 
   return chunks ? (e.completed_chunks() * 100) / chunks : 100;
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_file_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_file_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_file_list.h	2006-01-10 08:32:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_file_list.h	2006-03-30 22:24:10.000000000 +0800
@@ -39,13 +39,13 @@
 
 #include <list>
 
 #include "window.h"
 
 namespace torrent {
-  class Entry;
+  class File;
 }
 
 namespace core {
   class Download;
 }
 
@@ -57,13 +57,13 @@
 
   WindowFileList(core::Download* d, unsigned int* focus);
 
   virtual void     redraw();
 
 private:
-  int              done_percentage(torrent::Entry& e);
+  int              done_percentage(torrent::File& e);
 
   core::Download*  m_download;
 
   unsigned int*    m_focus;
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_peer_info.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_info.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_peer_info.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_info.cc	2006-04-01 05:06:56.000000000 +0800
@@ -34,18 +34,23 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
+#include <rak/socket_address.h>
 #include <rak/string_manip.h>
 #include <torrent/rate.h>
+#include <torrent/connection_manager.h>
 
 #include "core/download.h"
 
+#include "globals.h"
+
 #include "canvas.h"
+#include "client_info.h"
 #include "utils.h"
 #include "window_peer_info.h"
 
 namespace display {
 
 WindowPeerInfo::WindowPeerInfo(core::Download* d, PList* l, PList::iterator* f) :
@@ -58,51 +63,66 @@
 void
 WindowPeerInfo::redraw() {
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
   m_canvas->erase();
 
   int y = 0;
-  torrent::Download d = m_download->get_download();
+  torrent::Download* d = m_download->download();
 
-  m_canvas->print(0, y++, "Hash:    %s", rak::transform_hex(d.info_hash()).c_str());
-  m_canvas->print(0, y++, "Id:      %s", rak::copy_escape_html(d.local_id()).c_str());
+  m_canvas->print(0, y++, "Hash:    %s", rak::transform_hex(d->info_hash()).c_str());
+  m_canvas->print(0, y++, "Id:      %s", rak::copy_escape_html(d->local_id()).c_str());
   m_canvas->print(0, y++, "Chunks:  %u / %u * %u",
-		  d.chunks_done(),
-		  d.chunks_total(),
-		  d.chunks_size());
+		  d->chunks_done(),
+		  d->chunks_total(),
+		  d->chunks_size());
 
   char buffer[32], *position;
-  position = print_ddmmyyyy(buffer, buffer + 32, static_cast<time_t>(d.creation_date()));
+  position = print_ddmmyyyy(buffer, buffer + 32, static_cast<time_t>(d->creation_date()));
   position = print_string(position, buffer + 32, " ");
-  position = print_hhmmss(position, buffer + 32, static_cast<time_t>(d.creation_date()));
+  position = print_hhmmss(position, buffer + 32, static_cast<time_t>(d->creation_date()));
 
   m_canvas->print(0, y++, "Created: %s", buffer);
 
   y++;
 
   m_canvas->print(0, y++, "Connection Type: %s ( %s / %s )",
-		  m_download->variables()->get("connection_current").as_string().c_str(),
-		  m_download->variables()->get("connection_seed").as_string().c_str(),
-		  m_download->variables()->get("connection_leech").as_string().c_str());
-  m_canvas->print(0, y++, "Priority:        %u", torrent::download_priority(m_download->get_download()));
+		  m_download->variable()->get("connection_current").as_string().c_str(),
+		  m_download->variable()->get("connection_seed").as_string().c_str(),
+		  m_download->variable()->get("connection_leech").as_string().c_str());
+  m_canvas->print(0, y++, "Priority:        %u", torrent::download_priority(*m_download->download()));
 
   m_canvas->print(0, y++, "Directory:       %s", m_download->variable_string("directory").c_str());
   m_canvas->print(0, y++, "Tied to file:    %s", m_download->variable_string("tied_to_file").c_str());
 
   y++;
 
+  // Temporary.
+//   m_canvas->print(0, y++, "SndBuf:          %u", torrent::connection_manager()->send_buffer_size());
+//   m_canvas->print(0, y++, "RcvBuf:          %u", torrent::connection_manager()->receive_buffer_size());
+
+//   y++;
+
   if (*m_focus == m_list->end()) {
     m_canvas->print(0, y++, "No peer in focus");
 
     return;
   }
 
   m_canvas->print(0, y++, "*** Peer Info ***");
 
-  m_canvas->print(0, y++, "DNS: %s:%hu", (*m_focus)->address().c_str(), (*m_focus)->port());
-  m_canvas->print(0, y++, "Id: %s" , rak::copy_escape_html((*m_focus)->id()).c_str());
+  m_canvas->print(0, y++, "IP: %s:%hu",
+		  rak::socket_address::cast_from((*m_focus)->address())->address_str().c_str(),
+		  rak::socket_address::cast_from((*m_focus)->address())->port());
+
+  m_canvas->print(0, y++, "ID: %s" , rak::copy_escape_html((*m_focus)->id()).c_str());
+
+  char buf[128];
+  control->client_info()->print(buf, buf + 128, (*m_focus)->id().c_str());
+
+  m_canvas->print(0, y++, "Client: %s" , buf);
+
   m_canvas->print(0, y++, "Options: %s" , rak::transform_hex(std::string((*m_focus)->options(), 8)).c_str());
   m_canvas->print(0, y++, "Snubbed: %s", (*m_focus)->is_snubbed() ? "yes" : "no");
   m_canvas->print(0, y++, "Connected: %s", (*m_focus)->is_incoming() ? "remote" : "local");
 
   m_canvas->print(0, y++, "Done: %i%", done_percentage(**m_focus));
 
@@ -112,12 +132,12 @@
 		  (double)(*m_focus)->up_rate()->total() / (double)(1 << 20),
 		  (double)(*m_focus)->down_rate()->total() / (double)(1 << 20));
 }
 
 int
 WindowPeerInfo::done_percentage(torrent::Peer& p) {
-  int chunks = m_download->get_download().chunks_total();
+  int chunks = m_download->download()->chunks_total();
 
   return chunks ? (100 * p.chunks_done()) / chunks : 0;
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_peer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_peer_list.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_peer_list.cc	2006-04-06 03:29:50.000000000 +0800
@@ -34,18 +34,21 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
+#include <rak/socket_address.h>
 #include <torrent/rate.h>
+#include <torrent/piece.h>
 
 #include "core/download.h"
 #include "rak/algorithm.h"
 
 #include "canvas.h"
+#include "client_info.h"
 #include "window_peer_list.h"
 
 namespace display {
 
 WindowPeerList::WindowPeerList(core::Download* d, PList* l, PList::iterator* f) :
   Window(new Canvas, true),
@@ -59,13 +62,13 @@
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(1)).round_seconds());
   m_canvas->erase();
 
   int x = 2;
   int y = 0;
 
-  m_canvas->print(x, y, "DNS");     x += 16;
+  m_canvas->print(x, y, "IP");     x += 16;
   m_canvas->print(x, y, "UP");      x += 7;
   m_canvas->print(x, y, "DOWN");    x += 7;
   m_canvas->print(x, y, "PEER");    x += 7;
   m_canvas->print(x, y, "C/RE/LO"); x += 9;
   m_canvas->print(x, y, "QS");      x += 6;
   m_canvas->print(x, y, "DONE");    x += 6;
@@ -81,23 +84,23 @@
 
   Range range = rak::advance_bidirectional(m_list->begin(),
 					   *m_focus != m_list->end() ? *m_focus : m_list->begin(),
 					   m_list->end(),
 					   m_canvas->get_height() - y);
 
-  if (m_download->get_download().chunks_total() <= 0)
+  if (m_download->download()->chunks_total() <= 0)
     throw std::logic_error("WindowPeerList::redraw() m_slotChunksTotal() returned invalid value");
 
   while (range.first != range.second) {
     torrent::Peer& p = *range.first;
 
     x = 0;
 
     m_canvas->print(x, y, "%c %s",
 		    range.first == *m_focus ? '*' : ' ',
-		    p.address().c_str());
+		    rak::socket_address::cast_from(p.address())->address_str().c_str());
     x += 18;
 
     m_canvas->print(x, y, "%.1f", (double)p.up_rate()->rate() / 1024); x += 7;
     m_canvas->print(x, y, "%.1f", (double)p.down_rate()->rate() / 1024); x += 7;
     m_canvas->print(x, y, "%.1f", (double)p.peer_rate()->rate() / 1024); x += 7;
 
@@ -115,26 +118,33 @@
     x += 6;
 
     m_canvas->print(x, y, "%3i", done_percentage(*range.first));
     x += 6;
 
     if (p.incoming_queue_size())
-      m_canvas->print(x, y, "%i", p.incoming_index(0));
+      m_canvas->print(x, y, "%i", p.incoming_queue(0)->index());
 
     x += 6;
 
     if (p.is_snubbed())
       m_canvas->print(x, y, "*");
 
+    x += 5;
+
+    char buf[128];
+    control->client_info()->print(buf, buf + 128, p.id().c_str());
+
+    m_canvas->print(x, y, "%s", buf);
+
     ++y;
     ++range.first;
   }
 }
 
 int
 WindowPeerList::done_percentage(torrent::Peer& p) {
-  int chunks = m_download->get_download().chunks_total();
+  int chunks = m_download->download()->chunks_total();
 
   return chunks ? (100 * p.chunks_done()) / chunks : 0;
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/display/window_tracker_list.cc	2006-02-10 00:21:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/display/window_tracker_list.cc	2006-04-07 00:31:40.000000000 +0800
@@ -36,12 +36,14 @@
 
 #include "config.h"
 
 #include <stdexcept>
 #include <rak/algorithm.h>
 #include <rak/string_manip.h>
+#include <torrent/tracker.h>
+#include <torrent/tracker_list.h>
 
 #include "core/download.h"
 
 #include "window_tracker_list.h"
 
 namespace display {
@@ -56,44 +58,43 @@
 WindowTrackerList::redraw() {
   // TODO: Make this depend on tracker signal.
   m_slotSchedule(this, (cachedTime + rak::timer::from_seconds(10)).round_seconds());
   m_canvas->erase();
 
   int pos = 0;
+  torrent::TrackerList* tl = m_download->tracker_list();
 
-  m_canvas->print( 2, pos, "Trackers:");
-
+  m_canvas->print(2, pos, "Trackers: [Key: %08x]", tl->key());
   ++pos;
 
-  if (m_download->get_download().size_trackers() == 0)
+  if (tl->size() == 0)
     return;
 
-  if (*m_focus >= m_download->get_download().size_trackers())
-    throw std::logic_error("WindowTrackerList::redraw() called on an object with a bad focus value");
+  if (*m_focus >= tl->size())
+    throw std::logic_error("WindowTrackerList::redraw() called on an object with a bad focus value.");
 
   typedef std::pair<unsigned int, unsigned int> Range;
 
-  Range range = rak::advance_bidirectional<unsigned int>(0,
-							 *m_focus,
-							 m_download->get_download().size_trackers(),
-							 (m_canvas->get_height() + 1) / 2);
+  Range range = rak::advance_bidirectional<unsigned int>(0, *m_focus, tl->size(), (m_canvas->get_height() + 1) / 2);
 
   while (range.first != range.second) {
-    torrent::Tracker t = m_download->get_download().tracker(range.first);
+    torrent::Tracker t = tl->get(range.first);
 
     m_canvas->print(0, pos++, "%c %s",
 		    range.first == *m_focus ? '*' : ' ',
 		    t.url().c_str());
 
-    m_canvas->print(0, pos++, "%c Group: %2i Id: %s Focus: %s Enabled: %s Open: %s",
+    m_canvas->print(0, pos++, "%c Group: %2i Id: %s Focus: %s Enabled: %s Open: %s S/L: %u/%u",
 		    range.first == *m_focus ? '*' : ' ',
 		    t.group(),
 		    rak::copy_escape_html(t.tracker_id()).c_str(),
-		    range.first == m_download->get_download().tracker_focus() ? "yes" : " no",
+		    range.first == tl->focus() ? "yes" : " no",
 		    t.is_enabled() ? "yes" : " no",
-		    t.is_open() ? "yes" : " no");
+		    t.is_open() ? "yes" : " no",
+		    t.scrape_complete(),
+		    t.scrape_incomplete());
 
     ++range.first;
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/input/text_input.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/input/text_input.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/input/text_input.cc	2006-01-10 08:33:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/input/text_input.cc	2006-03-15 20:55:42.000000000 +0800
@@ -63,12 +63,13 @@
   } else if (key >= 0x20 && key < 0x7F) {
     Base::insert(m_pos++, 1, key);
 
   } else {
     switch (key) {
     case 0x7F:
+    case 'h' - 'a' + 1: // ^H
     case KEY_BACKSPACE:
       if (m_pos != 0)
 	Base::erase(--m_pos, 1);
 
       break;
 
@@ -89,12 +90,29 @@
     case KEY_RIGHT:
       if (m_pos != size())
 	++m_pos;
 
       break;
 
+    case KEY_HOME:
+      m_pos = 0;
+      break;
+
+    case KEY_END:
+      m_pos = size();
+      break;
+
+    case 'u' - 'a' + 1: // ^U
+      Base::erase(0, m_pos);
+      m_pos = 0;
+      break;
+
+    case 'k' - 'a' + 1: // ^K
+      Base::erase(m_pos, size()-m_pos);
+      break;
+
     case 0x1B:
       m_alt = true;
 
       break;
 
     default:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/main.cc	2006-02-14 00:47:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/main.cc	2006-04-01 04:48:35.000000000 +0800
@@ -75,20 +75,20 @@
   try {
     OptionParser optionParser;
 
     // Converted.
     optionParser.insert_flag('h', sigc::ptr_fun(&print_help));
 
-    optionParser.insert_option('b', sigc::bind<0>(sigc::mem_fun(c->variables(), &utils::VariableMap::set_string), "bind"));
-    optionParser.insert_option('d', sigc::bind<0>(sigc::mem_fun(c->variables(), &utils::VariableMap::set_string), "directory"));
-    optionParser.insert_option('i', sigc::bind<0>(sigc::mem_fun(c->variables(), &utils::VariableMap::set_string), "ip"));
-    optionParser.insert_option('p', sigc::bind<0>(sigc::mem_fun(c->variables(), &utils::VariableMap::set_string), "port_range"));
-    optionParser.insert_option('s', sigc::bind<0>(sigc::mem_fun(c->variables(), &utils::VariableMap::set_string), "session"));
+    optionParser.insert_option('b', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "bind"));
+    optionParser.insert_option('d', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "directory"));
+    optionParser.insert_option('i', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "ip"));
+    optionParser.insert_option('p', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "port_range"));
+    optionParser.insert_option('s', sigc::bind<0>(sigc::mem_fun(c->variable(), &utils::VariableMap::set_string), "session"));
 
-    optionParser.insert_option('O', sigc::mem_fun(c->variables(), &utils::VariableMap::process_command));
-    optionParser.insert_option_list('o', sigc::mem_fun(c->variables(), &utils::VariableMap::set_string));
+    optionParser.insert_option('O', sigc::mem_fun(c->variable(), &utils::VariableMap::process_command));
+    optionParser.insert_option_list('o', sigc::mem_fun(c->variable(), &utils::VariableMap::set_string));
 
     return optionParser.process(argc, argv);
 
   } catch (torrent::input_error& e) {
     throw torrent::input_error("Failed to parse command line option: " + std::string(e.what()));
   }
@@ -145,26 +145,28 @@
 
     control = new Control;
     
     srandom(cachedTime.usec());
     srand48(cachedTime.usec());
 
-    initialize_option_handler(control);
-
     SignalHandler::set_ignore(SIGPIPE);
     SignalHandler::set_handler(SIGINT,   sigc::mem_fun(control, &Control::receive_normal_shutdown));
     SignalHandler::set_handler(SIGTERM,  sigc::mem_fun(control, &Control::receive_quick_shutdown));
     SignalHandler::set_handler(SIGWINCH, sigc::mem_fun(control->display(), &display::Manager::force_redraw));
     SignalHandler::set_handler(SIGSEGV,  sigc::bind(sigc::ptr_fun(&do_panic), SIGSEGV));
     SignalHandler::set_handler(SIGBUS,   sigc::bind(sigc::ptr_fun(&do_panic), SIGBUS));
     SignalHandler::set_handler(SIGFPE,   sigc::bind(sigc::ptr_fun(&do_panic), SIGFPE));
 
     control->core()->initialize_first();
 
+    // Initialize option handlers after libtorrent to ensure
+    // torrent::ConnectionManager* is valid etc.
+    initialize_option_handler(control);
+
     // Move env and go through "try_import".
-    if (!control->variables()->process_file("~/.rtorrent.rc"))
+    if (!control->variable()->process_file("~/.rtorrent.rc"))
       control->core()->get_log_important().push_front("Could not load \"~/.rtorrent.rc\".");
 
     int firstArg = parse_options(control, argc, argv);
 
     control->initialize();
 
@@ -193,24 +195,17 @@
       // Do shutdown check before poll, not after.
       control->core()->get_poll_manager()->poll(client_next_timeout());
     }
 
     control->cleanup();
 
-  } catch (torrent::base_error& e) {
-    display::Canvas::cleanup();
-    delete control;
-
-    std::cout << "Caught exception: " << e.what() << std::endl;
-    return -1;
-
   } catch (std::exception& e) {
     display::Canvas::cleanup();
     delete control;
 
-    std::cout << e.what() << std::endl;
+    std::cout << "rtorrent: " << e.what() << std::endl;
     return -1;
   }
 
   delete control;
 
   return 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/option_handler_rules.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/option_handler_rules.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/option_handler_rules.cc	2006-02-11 04:24:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/option_handler_rules.cc	2006-04-03 22:51:40.000000000 +0800
@@ -41,15 +41,18 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <rak/file_stat.h>
 #include <rak/functional.h>
 #include <rak/path.h>
 #include <rak/string_manip.h>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
+#include <torrent/connection_manager.h>
 #include <torrent/exceptions.h>
 #include <torrent/torrent.h>
+#include <torrent/tracker.h>
+#include <torrent/tracker_list.h>
 
 #include "core/download.h"
 #include "core/manager.h"
 #include "ui/root.h"
 #include "utils/directory.h"
 #include "utils/variable_generic.h"
@@ -115,14 +118,14 @@
 			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
 				     std::not1(std::mem_fun_ref(&std::string::empty)))))
 	 != m->core()->download_list().end()) {
     rak::file_stat fs;
 
     if (!fs.update(rak::path_expand((*itr)->variable_string("tied_to_file")))) {
-      (*itr)->variables()->set("tied_to_file", std::string());
-      m->core()->stop(*itr);
+      (*itr)->variable()->set("tied_to_file", std::string());
+      m->core()->download_list().stop(*itr);
     }
 
     ++itr;
   }
 }
 
@@ -134,15 +137,15 @@
 			     rak::on(rak::bind2nd(std::mem_fun(&core::Download::variable_string), "tied_to_file"),
 				     std::not1(std::mem_fun_ref(&std::string::empty)))))
 	 != m->core()->download_list().end()) {
     rak::file_stat fs;
 
     if (!fs.update(rak::path_expand((*itr)->variable_string("tied_to_file")))) {
-      (*itr)->variables()->set("tied_to_file", std::string());
-      m->core()->stop(*itr);
-      itr = m->core()->erase(itr);
+      (*itr)->variable()->set("tied_to_file", std::string());
+      m->core()->download_list().stop(*itr);
+      itr = m->core()->download_list().erase(itr);
 
     } else {
       ++itr;
     }
   }
 }
@@ -150,49 +153,103 @@
 void
 apply_encoding_list(__UNUSED Control* m, const std::string& arg) {
   torrent::encoding_list()->push_back(arg);
 }
 
 void
+apply_enable_trackers(Control* m, __UNUSED const std::string& arg) {
+  bool state = (arg != "no");
+
+  for (core::Manager::DListItr itr = m->core()->download_list().begin(), last = m->core()->download_list().end(); itr != last; ++itr) {
+
+    torrent::TrackerList tl = (*itr)->download()->tracker_list();
+
+    for (int i = 0, last = tl.size(); i < last; ++i)
+      if (state)
+	tl.get(i).enable();
+      else
+	tl.get(i).disable();
+
+    if (state && control->variable()->get_string("use_udp_trackers") == "no")
+      (*itr)->enable_udp_trackers(false);
+  }    
+}
+
+void
+apply_tos(const std::string& arg) {
+  torrent::ConnectionManager* cm = torrent::connection_manager();
+
+  if (arg == "default")
+    cm->set_priority(torrent::ConnectionManager::iptos_default);
+
+  else if (arg == "lowdelay")
+    cm->set_priority(torrent::ConnectionManager::iptos_lowdelay);
+
+  else if (arg == "throughput")
+    cm->set_priority(torrent::ConnectionManager::iptos_throughput);
+
+  else if (arg == "reliability")
+    cm->set_priority(torrent::ConnectionManager::iptos_reliability);
+
+  else if (arg == "mincost")
+    cm->set_priority(torrent::ConnectionManager::iptos_mincost);
+
+  else 
+    throw torrent::input_error("Invalid TOS identifier.");
+}
+
+void
 initialize_option_handler(Control* c) {
-  utils::VariableMap* variables = control->variables();
+  utils::VariableMap* variables = control->variable();
 
   // Cleaned up.
   variables->insert("check_hash",            new utils::VariableAny("yes"));
   variables->insert("use_udp_trackers",      new utils::VariableAny("yes"));
+  variables->insert("port_open",             new utils::VariableAny("yes"));
   variables->insert("port_random",           new utils::VariableAny("yes"));
+
+  variables->insert("tracker_dump",          new utils::VariableAny(std::string()));
+
   variables->insert("session",               new utils::VariableSlotString<>(NULL, rak::mem_fn(&control->core()->download_store(), &core::DownloadStore::set_path)));
   variables->insert("session_lock",          new utils::VariableAny("yes"));
   variables->insert("session_on_completion", new utils::VariableAny("yes"));
 
-  variables->insert("connection_leech",    new utils::VariableAny("leech"));
-  variables->insert("connection_seed",     new utils::VariableAny("seed"));
-
-  variables->insert("directory",           new utils::VariableAny("./"));
-  variables->insert("working_directory",   new utils::VariableSlotString<>(NULL, rak::ptr_fn(&apply_working_directory)));
-  variables->insert("ip",                  new utils::VariableSlotString<>(NULL, rak::ptr_fn(&torrent::set_local_address)));
-  variables->insert("bind",                new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::bind)));
-
-  variables->insert("min_peers",           new utils::VariableValue(40));
-  variables->insert("max_peers",           new utils::VariableValue(100));
-  variables->insert("max_uploads",         new utils::VariableValue(15));
-
-  variables->insert("download_rate",       new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_down_throttle), "%i"));
-  variables->insert("upload_rate",         new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_up_throttle), "%i"));
-
-  variables->insert("hash_max_tries",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_hash_max_tries), "%i"));
-  variables->insert("max_open_files",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_files), "%i"));
-  variables->insert("max_open_sockets",    new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_sockets), "%i"));
-
-  variables->insert("print",               new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::push_log)));
-  variables->insert("import",              new utils::VariableSlotString<>(NULL, rak::mem_fn(control->variables(), &utils::VariableMap::process_file_throw)));
-  variables->insert("try_import",          new utils::VariableSlotString<>(NULL, rak::mem_fn(control->variables(), &utils::VariableMap::process_file_nothrow)));
-
-  variables->insert("schedule",            new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::parse)));
-  variables->insert("schedule_remove",     new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::erase)));
+  variables->insert("connection_leech",      new utils::VariableAny("leech"));
+  variables->insert("connection_seed",       new utils::VariableAny("seed"));
 
+  variables->insert("directory",             new utils::VariableAny("./"));
+  variables->insert("working_directory",     new utils::VariableSlotString<>(NULL, rak::ptr_fn(&apply_working_directory)));
+  variables->insert("bind",                  new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::set_bind_address)));
+  variables->insert("ip",                    new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::set_local_address)));
+
+  variables->insert("tos",                   new utils::VariableSlotString<>(NULL, rak::ptr_fn(&apply_tos)));
+
+  variables->insert("min_peers",             new utils::VariableValue(40));
+  variables->insert("max_peers",             new utils::VariableValue(100));
+  variables->insert("max_uploads",           new utils::VariableValue(15));
+
+  variables->insert("download_rate",         new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_down_throttle), "%i"));
+  variables->insert("upload_rate",           new utils::VariableSlotValue<uint32_t, unsigned int>(NULL, rak::mem_fn(control->ui(), &ui::Root::set_up_throttle), "%i"));
+
+  variables->insert("hash_max_tries",        new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_hash_max_tries), "%i"));
+  variables->insert("max_open_files",        new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_files), "%i"));
+  variables->insert("max_open_sockets",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::ptr_fn(&torrent::set_max_open_sockets), "%i"));
+
+  variables->insert("print",                 new utils::VariableSlotString<>(NULL, rak::mem_fn(control->core(), &core::Manager::push_log)));
+  variables->insert("import",                new utils::VariableSlotString<>(NULL, rak::mem_fn(control->variable(), &utils::VariableMap::process_file_throw)));
+  variables->insert("try_import",            new utils::VariableSlotString<>(NULL, rak::mem_fn(control->variable(), &utils::VariableMap::process_file_nothrow)));
+
+  variables->insert("schedule",              new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::parse)));
+  variables->insert("schedule_remove",       new utils::VariableSlotString<>(NULL, rak::mem_fn<const std::string&>(c->command_scheduler(), &CommandScheduler::erase)));
+
+  variables->insert("send_buffer_size",      new utils::VariableSlotValue<int, uint32_t>(NULL, rak::mem_fn(torrent::connection_manager(),
+													   &torrent::ConnectionManager::set_send_buffer_size), "%u"));
+  
+  variables->insert("receive_buffer_size",   new utils::VariableSlotValue<int, uint32_t>(NULL, rak::mem_fn(torrent::connection_manager(),
+													   &torrent::ConnectionManager::set_receive_buffer_size), "%u"));
+  
   // Old.
   variables->insert("port_range",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_port_range, c)));
 
   variables->insert("hash_read_ahead",     new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_read_ahead, c), "%i"));
   variables->insert("hash_interval",       new utils::VariableSlotValue<int, int>(NULL, rak::bind_ptr_fn(&apply_hash_interval, c), "%i"));
 
@@ -200,10 +257,12 @@
 
   variables->insert("load",                new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_load, c)));
   variables->insert("load_start",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_load_start, c)));
   variables->insert("stop_untied",         new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_stop_untied, c)));
   variables->insert("remove_untied",       new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_remove_untied, c)));
 
+  variables->insert("enable_trackers",     new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_enable_trackers, c)));
+
   variables->insert("encoding_list",       new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_encoding_list, c)));
 
   variables->insert("http_proxy",          new utils::VariableSlotString<>(NULL, rak::bind_ptr_fn(&apply_http_proxy, c)));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/option_parser.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/option_parser.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/option_parser.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/option_parser.cc	2006-03-07 02:56:40.000000000 +0800
@@ -34,12 +34,13 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <cstdio>
+#include <getopt.h>
 #include <stdexcept>
 #include <unistd.h>
 #include <sigc++/bind.h>
 #include <sigc++/hide.h>
 
 #include "option_parser.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download.cc	2006-01-24 05:43:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download.cc	2006-04-01 05:30:49.000000000 +0800
@@ -35,14 +35,15 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <stdexcept>
 #include <sigc++/bind.h>
-#include <torrent/torrent.h>
 #include <rak/functional.h>
+#include <torrent/torrent.h>
+#include <torrent/tracker_list.h>
 
 #include "core/download.h"
 #include "input/bindings.h"
 #include "input/manager.h"
 #include "display/window_title.h"
 #include "display/window_download_statusbar.h"
@@ -50,20 +51,21 @@
 #include "control.h"
 #include "download.h"
 #include "element_file_list.h"
 #include "element_peer_info.h"
 #include "element_peer_list.h"
 #include "element_tracker_list.h"
+#include "element_chunks_seen.h"
 
 namespace ui {
 
 Download::Download(DPtr d, Control* c) :
   m_download(d),
   m_state(DISPLAY_MAX_SIZE),
 
-  m_windowTitle(new WTitle(d->get_download().name())),
+  m_windowTitle(new WTitle(d->download()->name())),
   m_windowDownloadStatus(new WDownloadStatus(d)),
 
   m_window(c->display()->end()),
 
   m_control(c),
   m_bindings(new input::Bindings) {
@@ -71,19 +73,20 @@
   m_focus = m_peers.end();
 
   m_uiArray[DISPLAY_PEER_LIST]    = new ElementPeerList(d, &m_peers, &m_focus);
   m_uiArray[DISPLAY_PEER_INFO]    = new ElementPeerInfo(d, &m_peers, &m_focus);
   m_uiArray[DISPLAY_FILE_LIST]    = new ElementFileList(d);
   m_uiArray[DISPLAY_TRACKER_LIST] = new ElementTrackerList(d);
+  m_uiArray[DISPLAY_CHUNKS_SEEN]  = new ElementChunksSeen(d);
 
   bind_keys();
 
-  m_download->get_download().peer_list(m_peers);
+  m_download->download()->peer_list(m_peers);
 
-  m_connPeerConnected    = m_download->get_download().signal_peer_connected(sigc::mem_fun(*this, &Download::receive_peer_connected));
-  m_connPeerDisconnected = m_download->get_download().signal_peer_disconnected(sigc::mem_fun(*this, &Download::receive_peer_disconnected));
+  m_connPeerConnected    = m_download->download()->signal_peer_connected(sigc::mem_fun(*this, &Download::receive_peer_connected));
+  m_connPeerDisconnected = m_download->download()->signal_peer_disconnected(sigc::mem_fun(*this, &Download::receive_peer_disconnected));
 }
 
 Download::~Download() {
   if (m_window != m_control->display()->end())
     throw std::logic_error("ui::Download::~Download() called on an active object");
 
@@ -169,12 +172,22 @@
     m_focus = m_peers.end();
 
   mark_dirty();
 }
 
 void
+Download::receive_disconnect_peer() {
+  if (m_focus == m_peers.end())
+    return;
+
+  m_download->download()->disconnect_peer(*m_focus);
+
+  mark_dirty();
+}
+
+void
 Download::receive_peer_connected(torrent::Peer p) {
   m_peers.push_back(p);
 }
 
 void
 Download::receive_peer_disconnected(torrent::Peer p) {
@@ -190,27 +203,27 @@
 }
 
 void
 Download::receive_max_uploads(int t) {
   m_windowDownloadStatus->mark_dirty();
 
-  m_download->get_download().set_uploads_max(std::max(m_download->get_download().uploads_max() + t, (uint32_t)2));
+  m_download->download()->set_uploads_max(std::max(m_download->download()->uploads_max() + t, (uint32_t)2));
 }
 
 void
 Download::receive_min_peers(int t) {
   m_windowDownloadStatus->mark_dirty();
 
-  m_download->get_download().set_peers_min(std::max(m_download->get_download().peers_min() + t, (uint32_t)5));
+  m_download->download()->set_peers_min(std::max(m_download->download()->peers_min() + t, (uint32_t)5));
 }
 
 void
 Download::receive_max_peers(int t) {
   m_windowDownloadStatus->mark_dirty();
 
-  m_download->get_download().set_peers_max(std::max(m_download->get_download().peers_max() + t, (uint32_t)5));
+  m_download->download()->set_peers_max(std::max(m_download->download()->peers_max() + t, (uint32_t)5));
 }
 
 void
 Download::receive_change(Display d) {
   if (d == m_state)
     return;
@@ -238,39 +251,43 @@
 Download::receive_prev_priority() {
   m_download->set_priority((m_download->priority() - 1) % 4);
 }
 
 void
 Download::bind_keys() {
-  (*m_bindings)['1'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_uploads), -1);
-  (*m_bindings)['2'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_uploads), 1);
-  (*m_bindings)['3'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_min_peers), -5);
-  (*m_bindings)['4'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_min_peers), 5);
-  (*m_bindings)['5'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_peers), -5);
-  (*m_bindings)['6'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_max_peers), 5);
-  (*m_bindings)['+'] = sigc::mem_fun(*this, &Download::receive_next_priority);
-  (*m_bindings)['-'] = sigc::mem_fun(*this, &Download::receive_prev_priority);
-
-  (*m_bindings)['t'] = sigc::bind(sigc::mem_fun(m_download->get_download(), &torrent::Download::tracker_manual_request), false);
-  (*m_bindings)['T'] = sigc::bind(sigc::mem_fun(m_download->get_download(), &torrent::Download::tracker_manual_request), true);
-
-  (*m_bindings)['p'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_PEER_INFO);
-  (*m_bindings)['o'] = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_TRACKER_LIST);
+  (*m_bindings)['1'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_uploads), -1);
+  (*m_bindings)['2'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_uploads), 1);
+  (*m_bindings)['3'] = sigc::bind(sigc::mem_fun(this, &Download::receive_min_peers), -5);
+  (*m_bindings)['4'] = sigc::bind(sigc::mem_fun(this, &Download::receive_min_peers), 5);
+  (*m_bindings)['5'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_peers), -5);
+  (*m_bindings)['6'] = sigc::bind(sigc::mem_fun(this, &Download::receive_max_peers), 5);
+  (*m_bindings)['+'] = sigc::mem_fun(this, &Download::receive_next_priority);
+  (*m_bindings)['-'] = sigc::mem_fun(this, &Download::receive_prev_priority);
+
+  (*m_bindings)['k'] = sigc::mem_fun(this, &Download::receive_disconnect_peer);
+
+  (*m_bindings)['t'] = sigc::bind(sigc::mem_fun(m_download->tracker_list(), &torrent::TrackerList::manual_request), false);
+  (*m_bindings)['T'] = sigc::bind(sigc::mem_fun(m_download->tracker_list(), &torrent::TrackerList::manual_request), true);
+
+  (*m_bindings)['p'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_INFO);
+  (*m_bindings)['o'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_TRACKER_LIST);
+  (*m_bindings)['i'] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_CHUNKS_SEEN);
 
-  (*m_bindings)[KEY_UP]   = sigc::mem_fun(*this, &Download::receive_prev);
-  (*m_bindings)[KEY_DOWN] = sigc::mem_fun(*this, &Download::receive_next);
+  (*m_bindings)[KEY_UP]   = sigc::mem_fun(this, &Download::receive_prev);
+  (*m_bindings)[KEY_DOWN] = sigc::mem_fun(this, &Download::receive_next);
 
   // Key bindings for sub-ui's.
-  m_uiArray[DISPLAY_PEER_LIST]->get_bindings()[KEY_RIGHT]   = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_FILE_LIST);
-  m_uiArray[DISPLAY_PEER_INFO]->get_bindings()[KEY_LEFT]    = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_PEER_LIST);
-  m_uiArray[DISPLAY_FILE_LIST]->get_bindings()[KEY_LEFT]    = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_PEER_LIST);
-  m_uiArray[DISPLAY_TRACKER_LIST]->get_bindings()[KEY_LEFT] = sigc::bind(sigc::mem_fun(*this, &Download::receive_change), DISPLAY_PEER_LIST);
+  m_uiArray[DISPLAY_PEER_LIST]->get_bindings()[KEY_RIGHT]   = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_FILE_LIST);
+  m_uiArray[DISPLAY_PEER_INFO]->get_bindings()[KEY_LEFT]    = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
+  m_uiArray[DISPLAY_FILE_LIST]->get_bindings()[KEY_LEFT]    = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
+  m_uiArray[DISPLAY_TRACKER_LIST]->get_bindings()[KEY_LEFT] = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
+  m_uiArray[DISPLAY_CHUNKS_SEEN]->get_bindings()[KEY_LEFT]  = sigc::bind(sigc::mem_fun(this, &Download::receive_change), DISPLAY_PEER_LIST);
 
   // Doesn't belong here.
-  m_uiArray[DISPLAY_PEER_LIST]->get_bindings()['*'] = sigc::mem_fun(*this, &Download::receive_snub_peer);
-  m_uiArray[DISPLAY_PEER_INFO]->get_bindings()['*'] = sigc::mem_fun(*this, &Download::receive_snub_peer);
+  m_uiArray[DISPLAY_PEER_LIST]->get_bindings()['*'] = sigc::mem_fun(this, &Download::receive_snub_peer);
+  m_uiArray[DISPLAY_PEER_INFO]->get_bindings()['*'] = sigc::mem_fun(this, &Download::receive_snub_peer);
 }
 
 void
 Download::mark_dirty() {
   (*m_window)->mark_dirty();
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download.h	2006-01-24 05:45:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download.h	2006-04-01 05:30:51.000000000 +0800
@@ -71,12 +71,13 @@
 
   typedef enum {
     DISPLAY_PEER_LIST,
     DISPLAY_PEER_INFO,
     DISPLAY_FILE_LIST,
     DISPLAY_TRACKER_LIST,
+    DISPLAY_CHUNKS_SEEN,
     DISPLAY_MAX_SIZE
   } Display;
 
   Download(DPtr d, Control* c);
   ~Download();
 
@@ -95,12 +96,14 @@
   Download(const Download&);
   void operator = (const Download&);
 
   void                receive_next();
   void                receive_prev();
 
+  void                receive_disconnect_peer();
+
   void                receive_peer_connected(torrent::Peer p);
   void                receive_peer_disconnected(torrent::Peer p);
 
   void                receive_max_uploads(int t);
   void                receive_min_peers(int t);
   void                receive_max_peers(int t);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download_list.cc	2006-02-10 00:23:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.cc	2006-04-01 04:56:25.000000000 +0800
@@ -189,24 +189,32 @@
 
 void
 DownloadList::receive_start_download() {
   if (m_downloadList.get_focus() == m_downloadList.end())
     return;
 
-  m_control->core()->start(*m_downloadList.get_focus());
+  m_control->core()->download_list().start(*m_downloadList.get_focus());
 }
 
 void
 DownloadList::receive_stop_download() {
   if (m_downloadList.get_focus() == m_downloadList.end())
     return;
 
-  if ((*m_downloadList.get_focus())->get_download().is_active())
-    m_control->core()->stop(*m_downloadList.get_focus());
+  if ((*m_downloadList.get_focus())->download()->is_active())
+    m_control->core()->download_list().stop(*m_downloadList.get_focus());
   else
-    m_downloadList.set_focus(m_control->core()->erase(m_downloadList.get_focus()));
+    m_downloadList.set_focus(m_control->core()->download_list().erase(m_downloadList.get_focus()));
+}
+
+void
+DownloadList::receive_close_download() {
+  if (m_downloadList.get_focus() == m_downloadList.end())
+    return;
+
+  m_control->core()->download_list().close(*m_downloadList.get_focus());
 }
 
 void
 DownloadList::receive_view_download() {
   if (m_downloadList.get_focus() == m_downloadList.end())
     return;
@@ -271,13 +279,13 @@
 
   m_control->input()->set_text_input(m_windowTextInput->get_input());
 
   m_windowTextInput->set_focus(true);
 
   if (type == INPUT_CHANGE_DIRECTORY) {
-    m_windowTextInput->get_input()->str() = m_control->variables()->get_string("directory");
+    m_windowTextInput->get_input()->str() = m_control->variable()->get_string("directory");
     m_windowTextInput->get_input()->set_pos(m_windowTextInput->get_input()->str().length());
   }
 
   (*m_bindings)['\n']      = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
   (*m_bindings)[KEY_ENTER] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), type);
   (*m_bindings)['\x07']    = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_exit_input), INPUT_NONE);
@@ -304,18 +312,18 @@
       break;
 
     case INPUT_CHANGE_DIRECTORY:
       if (m_downloadList.get_focus() == m_downloadList.end())
 	throw torrent::input_error("No download in focus to change root directory.");
 
-      (*m_downloadList.get_focus())->variables()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
-      m_control->core()->push_log("New root dir \"" + (*m_downloadList.get_focus())->variables()->get_string("directory") + "\"");
+      (*m_downloadList.get_focus())->variable()->set("directory", rak::trim(m_windowTextInput->get_input()->str()));
+      m_control->core()->push_log("New root dir \"" + (*m_downloadList.get_focus())->variable()->get_string("directory") + "\" for torrent.");
       break;
 
     case INPUT_COMMAND:
-      m_control->variables()->process_command(m_windowTextInput->get_input()->str());
+      m_control->variable()->process_command(m_windowTextInput->get_input()->str());
       break;
     }
 
   } catch (torrent::input_error& e) {
     m_control->core()->push_log(e.what());
   }
@@ -363,12 +371,13 @@
 }
 
 void
 DownloadList::setup_keys() {
   (*m_bindings)['\x13']        = sigc::mem_fun(*this, &DownloadList::receive_start_download);
   (*m_bindings)['\x04']        = sigc::mem_fun(*this, &DownloadList::receive_stop_download);
+  (*m_bindings)['\x0B']        = sigc::mem_fun(*this, &DownloadList::receive_close_download);
   (*m_bindings)['\x12']        = sigc::mem_fun(*this, &DownloadList::receive_check_hash);
   (*m_bindings)['+']           = sigc::mem_fun(*this, &DownloadList::receive_next_priority);
   (*m_bindings)['-']           = sigc::mem_fun(*this, &DownloadList::receive_prev_priority);
 
   (*m_bindings)['\x7f']        = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
   (*m_bindings)[KEY_BACKSPACE] = sigc::bind(sigc::mem_fun(*this, &DownloadList::receive_view_input), INPUT_LOAD_DEFAULT);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/download_list.h	2006-01-28 03:42:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/download_list.h	2006-03-17 22:27:23.000000000 +0800
@@ -116,12 +116,13 @@
 
   void                receive_next();
   void                receive_prev();
 
   void                receive_start_download();
   void                receive_stop_download();
+  void                receive_close_download();
 
   void                receive_view_download();
   void                receive_exit_download();
 
   void                receive_next_priority();
   void                receive_prev_priority();
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui: element_chunks_seen.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui: element_chunks_seen.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/element_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/element_file_list.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_file_list.cc	2006-04-01 04:56:25.000000000 +0800
@@ -33,13 +33,14 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <torrent/exceptions.h>
+#include <torrent/file_list.h>
 
 #include "display/window_file_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_file_list.h"
@@ -57,102 +58,110 @@
   m_bindings[KEY_UP] = sigc::mem_fun(*this, &ElementFileList::receive_prev);
 }
 
 void
 ElementFileList::activate(Control* c, MItr mItr) {
   if (m_window != NULL)
-    throw std::logic_error("ui::ElementFileList::activate(...) called on an object in the wrong state");
+    throw torrent::internal_error("ui::ElementFileList::activate(...) called on an object in the wrong state");
 
   c->input()->push_front(&m_bindings);
 
   *mItr = m_window = new WFileList(m_download, &m_focus);
 }
 
 void
 ElementFileList::disable(Control* c) {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementFileList::disable(...) called on an object in the wrong state");
+    throw torrent::internal_error("ui::ElementFileList::disable(...) called on an object in the wrong state");
 
   c->input()->erase(&m_bindings);
 
   delete m_window;
   m_window = NULL;
 }
 
 void
 ElementFileList::receive_next() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementFileList::receive_next(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementFileList::receive_next(...) called on a disabled object");
 
-  if (++m_focus >= m_download->get_download().size_file_entries())
+  if (++m_focus >= m_download->download()->file_list().size())
     m_focus = 0;
 
   m_window->mark_dirty();
 }
 
 void
 ElementFileList::receive_prev() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
 
-  if (m_download->get_download().size_file_entries() == 0)
+  torrent::FileList fl = m_download->download()->file_list();
+
+  if (fl.size() == 0)
     return;
 
   if (m_focus != 0)
     --m_focus;
   else 
-    m_focus = m_download->get_download().size_file_entries() - 1;
+    m_focus = fl.size() - 1;
 
   m_window->mark_dirty();
 }
 
 void
 ElementFileList::receive_priority() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+
+  torrent::FileList fl = m_download->download()->file_list();
 
-  if (m_focus >= m_download->get_download().size_file_entries())
+  if (m_focus >= fl.size())
     return;
 
-  torrent::Entry e = m_download->get_download().file_entry(m_focus);
+  torrent::File file = fl.get(m_focus);
 
-  e.set_priority(next_priority(e.priority()));
+  file.set_priority(next_priority(file.priority()));
 
-  m_download->get_download().update_priorities();
+  m_download->download()->update_priorities();
   m_window->mark_dirty();
 }
 
 void
 ElementFileList::receive_change_all() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementFileList::receive_prev(...) called on a disabled object");
 
-  if (m_focus >= m_download->get_download().size_file_entries())
+  torrent::FileList fl = m_download->download()->file_list();
+
+  if (m_focus >= fl.size())
     return;
 
-  Priority p = next_priority(m_download->get_download().file_entry(m_focus).priority());
+  Priority p = next_priority(fl.get(m_focus).priority());
 
-  for (int i = 0, e = m_download->get_download().size_file_entries(); i != e; ++i)
-    m_download->get_download().file_entry(i).set_priority(p);
+  for (int i = 0, last = fl.size(); i != last; ++i)
+    fl.get(i).set_priority(p);
 
-  m_download->get_download().update_priorities();
+  m_download->download()->update_priorities();
   m_window->mark_dirty();
 }
 
 ElementFileList::Priority
 ElementFileList::next_priority(Priority p) {
+  // Ahh... do +1 modulo.
+
   switch(p) {
-  case torrent::Entry::OFF:
-    return torrent::Entry::HIGH;
+  case torrent::File::OFF:
+    return torrent::File::HIGH;
 
-  case torrent::Entry::NORMAL:
-    return torrent::Entry::OFF;
+  case torrent::File::NORMAL:
+    return torrent::File::OFF;
 
-  case torrent::Entry::HIGH:
-    return torrent::Entry::NORMAL;
+  case torrent::File::HIGH:
+    return torrent::File::NORMAL;
 	
   default:
-    return torrent::Entry::NORMAL;
+    return torrent::File::NORMAL;
   };
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/element_file_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_file_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/element_file_list.h	2006-01-10 08:32:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_file_list.h	2006-03-30 22:25:25.000000000 +0800
@@ -34,12 +34,14 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UI_ELEMENT_FILE_LIST_H
 #define RTORRENT_UI_ELEMENT_FILE_LIST_H
 
+#include <torrent/file.h>
+
 #include "core/download.h"
 
 #include "element_base.h"
 
 class Control;
 
@@ -48,13 +50,13 @@
 }
 
 namespace ui {
 
 class ElementFileList : public ElementBase {
 public:
-  typedef torrent::Entry::Priority Priority;
+  typedef torrent::File::Priority Priority;
   typedef display::WindowFileList  WFileList;
 
   ElementFileList(core::Download* d);
 
   void                activate(Control* c, MItr mItr);
   void                disable(Control* c);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/element_tracker_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_tracker_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/element_tracker_list.cc	2006-01-10 08:33:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/element_tracker_list.cc	2006-04-01 04:56:25.000000000 +0800
@@ -33,13 +33,15 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
-#include <stdexcept>
+#include <torrent/exceptions.h>
+#include <torrent/tracker.h>
+#include <torrent/tracker_list.h>
 
 #include "display/window_tracker_list.h"
 #include "input/manager.h"
 
 #include "control.h"
 #include "element_tracker_list.h"
@@ -57,78 +59,82 @@
   m_bindings['*']      = sigc::mem_fun(*this, &ElementTrackerList::receive_disable);
 }
 
 void
 ElementTrackerList::activate(Control* c, MItr mItr) {
   if (m_window != NULL)
-    throw std::logic_error("ui::ElementTrackerList::activate(...) called on an object in the wrong state");
+    throw torrent::internal_error("ui::ElementTrackerList::activate(...) called on an object in the wrong state");
 
   c->input()->push_front(&m_bindings);
 
   *mItr = m_window = new WTrackerList(m_download, &m_focus);
 }
 
 void
 ElementTrackerList::disable(Control* c) {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementTrackerList::disable(...) called on an object in the wrong state");
+    throw torrent::internal_error("ui::ElementTrackerList::disable(...) called on an object in the wrong state");
 
   c->input()->erase(&m_bindings);
 
   delete m_window;
   m_window = NULL;
 }
 
 void
 ElementTrackerList::receive_disable() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementTrackerList::receive_disable(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementTrackerList::receive_disable(...) called on a disabled object");
 
-  if (m_download->get_download().tracker(m_focus).is_enabled())
-    m_download->get_download().tracker(m_focus).disable();
+  torrent::Tracker t = m_download->download()->tracker_list().get(m_focus);
+
+  if (t.is_enabled())
+    t.disable();
   else
-    m_download->get_download().tracker(m_focus).enable();
+    t.enable();
 
   m_window->mark_dirty();
 }
 
 void
 ElementTrackerList::receive_next() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementTrackerList::receive_next(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementTrackerList::receive_next(...) called on a disabled object");
 
-  if (++m_focus >= m_download->get_download().size_trackers())
+  if (++m_focus >= m_download->download()->tracker_list().size())
     m_focus = 0;
 
   m_window->mark_dirty();
 }
 
 void
 ElementTrackerList::receive_prev() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementTrackerList::receive_prev(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementTrackerList::receive_prev(...) called on a disabled object");
 
-  if (m_download->get_download().size_trackers() == 0)
+  if (m_download->download()->tracker_list().size() == 0)
     return;
 
   if (m_focus != 0)
     --m_focus;
   else 
-    m_focus = m_download->get_download().size_trackers() - 1;
+    m_focus = m_download->download()->tracker_list().size() - 1;
 
   m_window->mark_dirty();
 }
 
 void
 ElementTrackerList::receive_cycle_group() {
   if (m_window == NULL)
-    throw std::logic_error("ui::ElementTrackerList::receive_group_cycle(...) called on a disabled object");
+    throw torrent::internal_error("ui::ElementTrackerList::receive_group_cycle(...) called on a disabled object");
+
+  torrent::TrackerList tl = m_download->download()->tracker_list();
 
-  if (m_focus >= m_download->get_download().size_trackers())
-    throw std::logic_error("ui::ElementTrackerList::receive_group_cycle(...) called with an invalid focus");
+  if (m_focus >= tl.size())
+    throw torrent::internal_error("ui::ElementTrackerList::receive_group_cycle(...) called with an invalid focus");
 
-  m_download->get_download().tracker_cycle_group(m_download->get_download().tracker(m_focus).group());
+  tl.cycle_group(tl.get(m_focus).group());
 
   m_window->mark_dirty();
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/Makefile.am	2005-12-22 08:33:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/Makefile.am	2006-03-23 04:04:54.000000000 +0800
@@ -3,12 +3,14 @@
 libsub_ui_a_SOURCES = \
 	download.cc \
 	download.h \
 	download_list.cc \
 	download_list.h \
 	element_base.h \
+	element_chunks_seen.cc \
+	element_chunks_seen.h \
 	element_download_list.cc \
 	element_download_list.h \
 	element_file_list.cc \
 	element_file_list.h \
 	element_log_complete.cc \
 	element_log_complete.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/ui/Makefile.in	2006-02-12 00:13:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/ui/Makefile.in	2006-04-07 01:43:33.000000000 +0800
@@ -51,16 +51,17 @@
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_ui_a_AR = $(AR) $(ARFLAGS)
 libsub_ui_a_LIBADD =
 am_libsub_ui_a_OBJECTS = download.$(OBJEXT) download_list.$(OBJEXT) \
-	element_download_list.$(OBJEXT) element_file_list.$(OBJEXT) \
-	element_log_complete.$(OBJEXT) element_peer_info.$(OBJEXT) \
-	element_peer_list.$(OBJEXT) element_string_list.$(OBJEXT) \
-	element_tracker_list.$(OBJEXT) root.$(OBJEXT)
+	element_chunks_seen.$(OBJEXT) element_download_list.$(OBJEXT) \
+	element_file_list.$(OBJEXT) element_log_complete.$(OBJEXT) \
+	element_peer_info.$(OBJEXT) element_peer_list.$(OBJEXT) \
+	element_string_list.$(OBJEXT) element_tracker_list.$(OBJEXT) \
+	root.$(OBJEXT)
 libsub_ui_a_OBJECTS = $(am_libsub_ui_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
 	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
@@ -186,12 +187,14 @@
 libsub_ui_a_SOURCES = \
 	download.cc \
 	download.h \
 	download_list.cc \
 	download_list.h \
 	element_base.h \
+	element_chunks_seen.cc \
+	element_chunks_seen.h \
 	element_download_list.cc \
 	element_download_list.h \
 	element_file_list.cc \
 	element_file_list.h \
 	element_log_complete.cc \
 	element_log_complete.h \
@@ -253,12 +256,13 @@
 
 distclean-compile:
 	-rm -f *.tab.c
 
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/download_list.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_chunks_seen.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_download_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_file_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_log_complete.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_peer_info.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_peer_list.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/element_string_list.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_generic.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_generic.cc	2006-02-05 03:35:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.cc	2006-03-21 03:31:06.000000000 +0800
@@ -42,46 +42,46 @@
 
 namespace utils {
 
 VariableAny::~VariableAny() {
 }
 
-const torrent::Bencode&
+const torrent::Object&
 VariableAny::get() {
   return m_variable;
 }
 
 void
-VariableAny::set(const torrent::Bencode& arg) {
+VariableAny::set(const torrent::Object& arg) {
   m_variable = arg;
 }
 
 VariableValue::~VariableValue() {
 }
 
-const torrent::Bencode&
+const torrent::Object&
 VariableValue::get() {
   return m_variable;
 }
 
 void
-VariableValue::set(const torrent::Bencode& arg) {
+VariableValue::set(const torrent::Object& arg) {
   uint64_t value;
   const char* first;
   char* last;
 
-  switch (arg.get_type()) {
-  case torrent::Bencode::TYPE_NONE:
+  switch (arg.type()) {
+  case torrent::Object::TYPE_NONE:
     m_variable = (int64_t)0;
     break;
 
-  case torrent::Bencode::TYPE_VALUE:
+  case torrent::Object::TYPE_VALUE:
     m_variable = arg;
     break;
 
-  case torrent::Bencode::TYPE_STRING:
+  case torrent::Object::TYPE_STRING:
     first = arg.as_string().c_str();
     value = strtoll(first, &last, 0);
 
     if (last == first || *last != '\0')
       throw torrent::input_error("Could not convert string to value.");
 
@@ -93,19 +93,19 @@
   }
 }
 
 VariableBool::~VariableBool() {
 }
 
-const torrent::Bencode&
+const torrent::Object&
 VariableBool::get() {
   return m_variable;
 }
 
 void
-VariableBool::set(const torrent::Bencode& arg) {
+VariableBool::set(const torrent::Object& arg) {
   if (arg.is_value()) {
     m_variable = arg.as_value() ? (int64_t)1 : (int64_t)0;
 
   } else if (arg.is_string()) {
 
     if (arg.as_string() == "yes" ||
@@ -121,46 +121,46 @@
 
   } else {
     throw torrent::input_error("Input is not a boolean.");
   }
 }
 
-VariableBencode::~VariableBencode() {
+VariableObject::~VariableObject() {
 }
 
-const torrent::Bencode&
-VariableBencode::get() {
+const torrent::Object&
+VariableObject::get() {
   if (m_root.empty())
     return m_bencode->get_key(m_key);
   else
     return m_bencode->get_key(m_root).get_key(m_key);
 }
 
 void
-VariableBencode::set(const torrent::Bencode& arg) {
+VariableObject::set(const torrent::Object& arg) {
   // Consider removing if TYPE_NONE.
-  torrent::Bencode* root;
+  torrent::Object* root;
 
   if (m_root.empty())
     root = m_bencode;
   else
     root = &m_bencode->get_key(m_root);
 
   switch (m_type) {
-  case torrent::Bencode::TYPE_NONE:
+  case torrent::Object::TYPE_NONE:
     root->insert_key(m_key, arg);
     break;
 
-  case torrent::Bencode::TYPE_STRING:
-    if (arg.get_type() == torrent::Bencode::TYPE_STRING)
+  case torrent::Object::TYPE_STRING:
+    if (arg.type() == torrent::Object::TYPE_STRING)
       root->insert_key(m_key, arg);
     else
-      throw torrent::input_error("VariableBencode could not convert to string.");
+      throw torrent::input_error("VariableObject could not convert to string.");
       
     break;
 
   default:
-    throw torrent::input_error("VariableBencode unsupported type restriction.");
+    throw torrent::input_error("VariableObject unsupported type restriction.");
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_generic.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_generic.h	2006-01-29 07:40:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_generic.h	2006-03-21 03:40:03.000000000 +0800
@@ -32,83 +32,83 @@
 // Contact:  Jari Sundell <jaris@ifi.uio.no>
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 // Parts of this seems ugly in an attempt to avoid copying
-// data. Propably need to rewrite torrent::Bencode.
+// data. Propably need to rewrite torrent::Object.
 
 #ifndef RTORRENT_UTILS_VARIABLE_GENERIC_H
 #define RTORRENT_UTILS_VARIABLE_GENERIC_H
 
 #include <cstdio>
 #include <string>
 #include <limits>
 #include <inttypes.h>
 #include <rak/functional_fun.h>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
 #include <torrent/exceptions.h>
 
 #include "variable.h"
 
 namespace utils {
 
 class VariableAny : public Variable {
 public:
-  VariableAny(const torrent::Bencode& v = torrent::Bencode()) :
+  VariableAny(const torrent::Object& v = torrent::Object()) :
     m_variable(v) {}
   virtual ~VariableAny();
 
-  virtual const torrent::Bencode& get();
-  virtual void                    set(const torrent::Bencode& arg);
+  virtual const torrent::Object&  get();
+  virtual void                    set(const torrent::Object& arg);
 
 private:
-  torrent::Bencode    m_variable;
+  torrent::Object    m_variable;
 };
 
 class VariableValue : public Variable {
 public:
   VariableValue(int64_t v) : m_variable(v) {}
   virtual ~VariableValue();
 
-  virtual const torrent::Bencode& get();
-  virtual void                    set(const torrent::Bencode& arg);
+  virtual const torrent::Object& get();
+  virtual void                    set(const torrent::Object& arg);
 
 private:
-  torrent::Bencode    m_variable;
+  torrent::Object    m_variable;
 };
 
 class VariableBool : public Variable {
 public:
   VariableBool(bool state) : m_variable(state ? (int64_t)1 : (int64_t)0) {}
-  VariableBool(const torrent::Bencode& v = torrent::Bencode((int64_t)0)) { set(v); }
+  VariableBool(const torrent::Object& v = torrent::Object((int64_t)0)) { set(v); }
   virtual ~VariableBool();
 
-  virtual const torrent::Bencode& get();
-  virtual void        set(const torrent::Bencode& arg);
+  virtual const torrent::Object& get();
+  virtual void        set(const torrent::Object& arg);
 
 private:
-  torrent::Bencode    m_variable;
+  torrent::Object    m_variable;
 };
 
-class VariableBencode : public Variable {
+class VariableObject : public Variable {
 public:
-  typedef torrent::Bencode::Type Type;
+  typedef torrent::Object::type_type Type;
 
-  VariableBencode(torrent::Bencode* b,
+  VariableObject(torrent::Object* b,
 		  const std::string& root,
 		  const std::string& key,
-		  Type t = torrent::Bencode::TYPE_NONE) :
+		  Type t = torrent::Object::TYPE_NONE) :
     m_bencode(b), m_root(root), m_key(key), m_type(t) {}
-  virtual ~VariableBencode();
+  virtual ~VariableObject();
 
-  virtual const torrent::Bencode& get();
-  virtual void        set(const torrent::Bencode& arg);
+  virtual const torrent::Object& get();
+  virtual void        set(const torrent::Object& arg);
 
 private:
-  torrent::Bencode*   m_bencode;
+  torrent::Object*   m_bencode;
   std::string         m_root;
   std::string         m_key;
   Type                m_type;
 };
 
 template <typename Get = std::string, typename Set = const std::string&>
@@ -121,27 +121,27 @@
     m_slotGet.set(slotGet);
     m_slotSet.set(slotSet);
   }
 
   virtual ~VariableSlotString() {}
 
-  virtual const torrent::Bencode& get() {
+  virtual const torrent::Object& get() {
     m_cache = m_slotGet();
 
     if (!m_cache.is_string())
       throw torrent::internal_error("VariableSlotString::get() got wrong type.");
 
     return m_cache;
   }
 
-  virtual void set(const torrent::Bencode& arg) {
-    switch (arg.get_type()) {
-    case torrent::Bencode::TYPE_STRING:
+  virtual void set(const torrent::Object& arg) {
+    switch (arg.type()) {
+    case torrent::Object::TYPE_STRING:
       m_slotSet(arg.as_string());
       break;
-    case torrent::Bencode::TYPE_NONE:
+    case torrent::Object::TYPE_NONE:
       m_slotSet("");
       break;
     default:
       throw torrent::internal_error("VariableSlotString::set(...) got wrong type.");
     }    
   }
@@ -150,13 +150,13 @@
   SlotGet             m_slotGet;
   SlotSet             m_slotSet;
 
   // Store the cache here to avoid unnessesary copying and such. This
   // should not result in any unresonable memory usage since few
   // strings will be very large.
-  torrent::Bencode    m_cache;
+  torrent::Object    m_cache;
 };
 
 template <typename Get, typename Set>
 class VariableSlotValue : public Variable {
 public:
   typedef rak::function0<Get>         SlotGet;
@@ -173,23 +173,23 @@
     m_pattern = pattern;
     m_range = range;
   }
 
   virtual ~VariableSlotValue() {}
 
-  virtual const torrent::Bencode& get() {
+  virtual const torrent::Object& get() {
     m_cache = m_slotGet();
 
     // Need this?
     if (!m_cache.is_value())
       throw torrent::internal_error("VariableSlotValue::get() got wrong type.");
 
     return m_cache;
   }
 
-  virtual void set(const torrent::Bencode& arg) {
+  virtual void set(const torrent::Object& arg) {
     if (arg.is_string()) {
       Set v;
 
       if (std::sscanf(arg.as_string().c_str(), m_pattern, &v) != 1)
 	throw torrent::input_error("Not a value.");
       
@@ -210,12 +210,12 @@
   const char*         m_pattern;
   Range               m_range;
 
   // Store the cache here to avoid unnessesary copying and such. This
   // should not result in any unresonable memory usage since few
   // strings will be very large.
-  torrent::Bencode    m_cache;
+  torrent::Object    m_cache;
 };
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable.h	2006-01-29 07:30:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable.h	2006-03-21 03:25:18.000000000 +0800
@@ -37,24 +37,24 @@
 #ifndef RTORRENT_UTILS_VARIABLE_H
 #define RTORRENT_UTILS_VARIABLE_H
 
 #include <string>
 
 namespace torrent {
-  class Bencode;
+  class Object;
 }
 
 namespace utils {
 
 class Variable {
 public:
   Variable() {}
   virtual ~Variable() {}
 
-  virtual const torrent::Bencode& get() = 0;
-  virtual void                    set(const torrent::Bencode& arg) = 0;
+  virtual const torrent::Object& get() = 0;
+  virtual void                    set(const torrent::Object& arg) = 0;
 
 protected:
   Variable(const Variable&);
   void operator = (const Variable&);
 };
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_map.cc	2006-02-11 02:59:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.cc	2006-03-21 03:40:03.000000000 +0800
@@ -40,13 +40,13 @@
 #include <cstdio>
 #include <cctype>
 #include <fstream>
 #include <rak/functional.h>
 #include <rak/path.h>
 #include <torrent/exceptions.h>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
 
 #include "variable.h"
 #include "variable_map.h"
 
 namespace utils {
 
@@ -123,13 +123,13 @@
     *dest = std::string(first, next);
     return next;
   }
 }
 
 std::string::const_iterator
-parse_args(std::string::const_iterator first, std::string::const_iterator last, VariableMap::mapped_type::List* dest) {
+parse_args(std::string::const_iterator first, std::string::const_iterator last, VariableMap::mapped_type::list_type* dest) {
   first = std::find_if(first, last, std::not1(variable_map_is_space()));
 
   while (first != last) {
     dest->push_back(VariableMap::mapped_type());
 
     first = parse_unknown(first, last, &dest->back());
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.4.5/src/utils/variable_map.h	2006-02-11 00:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.5.0/src/utils/variable_map.h	2006-03-21 03:40:03.000000000 +0800
@@ -37,22 +37,22 @@
 #ifndef RTORRENT_UTILS_VARIABLE_MAP_H
 #define RTORRENT_UTILS_VARIABLE_MAP_H
 
 #include <map>
 #include <string>
 #include <iosfwd>
-#include <torrent/bencode.h>
+#include <torrent/object.h>
 
 namespace utils {
 
 class Variable;
 
 class VariableMap : public std::map<std::string, Variable*> {
 public:
   typedef std::map<std::string, Variable*> base_type;
-  typedef torrent::Bencode                 mapped_type;
+  typedef torrent::Object                  mapped_type;
 
   static const int max_size_key = 128;
   static const int max_size_opt = 1024;
   static const int max_size_line = max_size_key + max_size_opt + 64;
 
   using base_type::iterator;
