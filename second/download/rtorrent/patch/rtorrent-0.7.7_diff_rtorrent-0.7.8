diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure	2007-08-14 01:54:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/configure	2007-08-26 19:31:36.000000000 +0800
@@ -1,9 +1,9 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.60 for rtorrent 0.7.7.
+# Generated by GNU Autoconf 2.60 for rtorrent 0.7.8.
 #
 # Report bugs to <jaris@ifi.uio.no>.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
@@ -710,14 +710,14 @@
 MAKEFLAGS=
 SHELL=${CONFIG_SHELL-/bin/sh}
 
 # Identity of this package.
 PACKAGE_NAME='rtorrent'
 PACKAGE_TARNAME='rtorrent'
-PACKAGE_VERSION='0.7.7'
-PACKAGE_STRING='rtorrent 0.7.7'
+PACKAGE_VERSION='0.7.8'
+PACKAGE_STRING='rtorrent 0.7.8'
 PACKAGE_BUGREPORT='jaris@ifi.uio.no'
 
 # Factoring default headers for most tests.
 ac_includes_default="\
 #include <stdio.h>
 #if HAVE_SYS_TYPES_H
@@ -1375,13 +1375,13 @@
 # Report the --help message.
 #
 if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures rtorrent 0.7.7 to adapt to many kinds of systems.
+\`configure' configures rtorrent 0.7.8 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
 To assign environment variables (e.g., CC, CFLAGS...), specify them as
 VAR=VALUE.  See below for descriptions of some of the useful variables.
 
@@ -1445,13 +1445,13 @@
   --host=HOST       cross-compile to build programs to run on HOST [BUILD]
 _ACEOF
 fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of rtorrent 0.7.7:";;
+     short | recursive ) echo "Configuration of rtorrent 0.7.8:";;
    esac
   cat <<\_ACEOF
 
 Optional Features:
   --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
@@ -1562,13 +1562,13 @@
   done
 fi
 
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-rtorrent configure 0.7.7
+rtorrent configure 0.7.8
 generated by GNU Autoconf 2.60
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
@@ -1576,13 +1576,13 @@
   exit
 fi
 cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by rtorrent $as_me 0.7.7, which was
+It was created by rtorrent $as_me 0.7.8, which was
 generated by GNU Autoconf 2.60.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 exec 5>>config.log
@@ -2247,13 +2247,13 @@
   fi
 fi
 
 
 # Define the identity of the package.
  PACKAGE='rtorrent'
- VERSION='0.7.7'
+ VERSION='0.7.8'
 
 
 cat >>confdefs.h <<_ACEOF
 #define PACKAGE "$PACKAGE"
 _ACEOF
 
@@ -22355,36 +22355,36 @@
 
 if test -n "$PKG_CONFIG"; then
     if test -n "$STUFF_CFLAGS"; then
         pkg_cv_STUFF_CFLAGS="$STUFF_CFLAGS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6\"") >&5
-  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8\"") >&5
+  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_STUFF_CFLAGS=`$PKG_CONFIG --cflags "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6" 2>/dev/null`
+  pkg_cv_STUFF_CFLAGS=`$PKG_CONFIG --cflags "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8" 2>/dev/null`
 else
   pkg_failed=yes
 fi
     fi
 else
 	pkg_failed=untried
 fi
 if test -n "$PKG_CONFIG"; then
     if test -n "$STUFF_LIBS"; then
         pkg_cv_STUFF_LIBS="$STUFF_LIBS"
     else
         if test -n "$PKG_CONFIG" && \
-    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6\"") >&5
-  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6") 2>&5
+    { (echo "$as_me:$LINENO: \$PKG_CONFIG --exists --print-errors \"sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8\"") >&5
+  ($PKG_CONFIG --exists --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8") 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
-  pkg_cv_STUFF_LIBS=`$PKG_CONFIG --libs "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6" 2>/dev/null`
+  pkg_cv_STUFF_LIBS=`$PKG_CONFIG --libs "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8" 2>/dev/null`
 else
   pkg_failed=yes
 fi
     fi
 else
 	pkg_failed=untried
@@ -22397,31 +22397,31 @@
 if $PKG_CONFIG --atleast-pkgconfig-version 0.20; then
         _pkg_short_errors_supported=yes
 else
         _pkg_short_errors_supported=no
 fi
         if test $_pkg_short_errors_supported = yes; then
-	        STUFF_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6"`
+	        STUFF_PKG_ERRORS=`$PKG_CONFIG --short-errors --errors-to-stdout --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8"`
         else
-	        STUFF_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6"`
+	        STUFF_PKG_ERRORS=`$PKG_CONFIG --errors-to-stdout --print-errors "sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8"`
         fi
 	# Put the nasty error message in config.log where it belongs
 	echo "$STUFF_PKG_ERRORS" >&5
 
-	{ { echo "$as_me:$LINENO: error: Package requirements (sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6) were not met:
+	{ { echo "$as_me:$LINENO: error: Package requirements (sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8) were not met:
 
 $STUFF_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
 Alternatively, you may set the environment variables STUFF_CFLAGS
 and STUFF_LIBS to avoid the need to call pkg-config.
 See the pkg-config man page for more details.
 " >&5
-echo "$as_me: error: Package requirements (sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6) were not met:
+echo "$as_me: error: Package requirements (sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8) were not met:
 
 $STUFF_PKG_ERRORS
 
 Consider adjusting the PKG_CONFIG_PATH environment variable if you
 installed software in a non-standard prefix.
 
@@ -23080,13 +23080,13 @@
 exec 6>&1
 
 # Save the log message, to keep $[0] and so on meaningful, and to
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by rtorrent $as_me 0.7.7, which was
+This file was extended by rtorrent $as_me 0.7.8, which was
 generated by GNU Autoconf 2.60.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
@@ -23133,13 +23133,13 @@
 
 Report bugs to <bug-autoconf@gnu.org>."
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
-rtorrent config.status 0.7.7
+rtorrent config.status 0.7.8
 configured by $0, generated by GNU Autoconf 2.60,
   with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
 Copyright (C) 2006 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/configure.ac	2007-08-07 04:19:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/configure.ac	2007-08-26 19:31:07.000000000 +0800
@@ -1,7 +1,7 @@
-AC_INIT(rtorrent, 0.7.7, jaris@ifi.uio.no)
+AC_INIT(rtorrent, 0.7.8, jaris@ifi.uio.no)
 
 AM_INIT_AUTOMAKE
 AM_CONFIG_HEADER(config.h)
 
 TORRENT_CHECK_CXXFLAGS()
 TORRENT_ENABLE_DEBUG()
@@ -22,13 +22,13 @@
 
 TORRENT_WITHOUT_VARIABLE_FDSET()
 TORRENT_WITHOUT_NCURSESW()
 TORRENT_WITHOUT_STATVFS()
 TORRENT_WITHOUT_STATFS()
 
-PKG_CHECK_MODULES(STUFF, sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.6,
+PKG_CHECK_MODULES(STUFF, sigc++-2.0 libcurl >= 7.12.0 libtorrent >= 0.11.8,
 	          CXXFLAGS="$CXXFLAGS $STUFF_CFLAGS";
 		  LIBS="$LIBS $STUFF_LIBS")
 
 AC_LANG_PUSH(C++)
 TORRENT_WITH_XMLRPC_C
 AC_LANG_POP(C++)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/doc/rtorrent.1.xml /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/doc/rtorrent.1.xml
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/doc/rtorrent.1.xml	2007-06-21 05:57:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/doc/rtorrent.1.xml	2007-08-31 03:15:06.000000000 +0800
@@ -435,15 +435,14 @@
 
       <varlistentry>
         <term>session = <replaceable>directory</replaceable></term>
         <listitem><para>
 Session management will be enabled and the torrent files for all open
 downloads will be stored in this directory. Only one instance of
-rtorrent should be used with each session directory, though at the
-moment no locking is done. An empty string will disable the session
-directory.
+rtorrent can be used per session directory. An empty string will
+disable the session directory.
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
         <term>http_proxy = <replaceable>url</replaceable></term>
         <listitem><para>
@@ -482,12 +481,19 @@
 between plaintext transmission and RC4 encryption, otherwise RC4 will be used).
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
+        <term>peer_exchange = <replaceable>yes | no</replaceable></term>
+        <listitem><para>
+Enable/disable peer exchange for torrents that aren't marked private. Disabled by default.
+        </para></listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term>schedule = <replaceable>id</replaceable>,<replaceable>start</replaceable>,<replaceable>interval</replaceable>,<replaceable>command</replaceable></term>
         <listitem><para>
 Call <emphasis>command</emphasis> every <emphasis>interval</emphasis>
 seconds, starting from <emphasis>start</emphasis>. An
 <emphasis>interval</emphasis> of zero calls the task once, while a
 <emphasis>start</emphasis> of zero calls it immediately. Currently
@@ -979,13 +985,13 @@
 by the program.
 
         </para></listitem>
       </varlistentry>
 
       <varlistentry>
-        <term>working_directory = <replaceable>directory</replaceable></term>
+        <term>cwd = <replaceable>directory</replaceable></term>
         <listitem><para>
 
 Changes the working directory of the process using
 <emphasis>chdir</emphasis>.
 
         </para></listitem>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/doc/rtorrent.rc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/doc/rtorrent.rc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/doc/rtorrent.rc	2007-02-02 19:09:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/doc/rtorrent.rc	2007-08-31 03:15:06.000000000 +0800
@@ -71,12 +71,16 @@
 # The example value allows incoming encrypted connections, starts unencrypted
 # outgoing connections but retries with encryption if they fail, preferring
 # plaintext to RC4 encryption after the encrypted handshake
 #
 # encryption = allow_incoming,enable_retry,prefer_plaintext
 
+# Enable peer exchange (for torrents not marked private)
+#
+# peer_exchange = yes
+
 #
 # Do not modify the following parameters unless you know what you're doing.
 #
 
 # Hash read-ahead controls how many MB to request the kernel to read
 # ahead. If the value is too low the disk may not be fully utilized,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/socket_address.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/rak/socket_address.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/socket_address.h	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/rak/socket_address.h	2007-08-23 05:22:08.000000000 +0800
@@ -60,19 +60,24 @@
 class socket_address_inet;
 class socket_address_inet6;
 
 class socket_address {
 public:
   static const sa_family_t af_inet   = AF_INET;
+  static const int         pf_inet   = PF_INET;
   static const sa_family_t af_inet6  = AF_INET6;
+  static const int         pf_inet6  = PF_INET6;
   static const sa_family_t af_unspec = AF_UNSPEC;
+  static const int         pf_unspec = PF_UNSPEC;
 
 #ifdef AF_LOCAL
   static const sa_family_t af_local  = AF_LOCAL;
+  static const int         pf_local  = PF_LOCAL;
 #else
   static const sa_family_t af_local  = AF_UNIX;
+  static const int         pf_local  = PF_UNIX;
 #endif
 
   bool                is_valid() const;
   bool                is_bindable() const;
   bool                is_address_any() const;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/string_manip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/rak/string_manip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/rak/string_manip.h	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/rak/string_manip.h	2007-08-30 20:18:11.000000000 +0800
@@ -225,12 +225,21 @@
     ++first1;
   }
 
   return first2;
 }
 
+template <typename Iterator>
+inline std::string
+copy_escape_html(Iterator first, Iterator last) {
+  std::string dest;
+  copy_escape_html(first, last, std::back_inserter(dest));
+
+  return dest;
+}
+
 template <typename Sequence>
 Sequence
 copy_escape_html(const Sequence& src) {
   Sequence dest;
   copy_escape_html(src.begin(), src.end(), std::back_inserter(dest));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_download.cc	2007-08-13 02:25:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_download.cc	2007-09-03 19:59:35.000000000 +0800
@@ -38,21 +38,21 @@
 
 #include <functional>
 #include <unistd.h>
 #include <rak/file_stat.h>
 #include <rak/error_number.h>
 #include <rak/path.h>
+#include <rak/string_manip.h>
 #include <torrent/rate.h>
+#include <torrent/tracker.h>
 #include <torrent/data/file.h>
 #include <torrent/data/file_list.h>
 
 #include "core/download.h"
 #include "core/manager.h"
-#include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
-#include "rpc/command_download_slot.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 std::string
@@ -97,27 +97,27 @@
     throw torrent::input_error("Invalid arguments.");
 
   std::string target;
   std::string link;
 
   if (type == "base_path") {
-    target = rpc::call_command_d_string("d.get_base_path", download);
-    link = rak::path_expand(prefix + rpc::call_command_d_string("d.get_base_path", download) + postfix);
+    target = rpc::call_command_string("d.get_base_path", rpc::make_target(download));
+    link = rak::path_expand(prefix + rpc::call_command_string("d.get_base_path", rpc::make_target(download)) + postfix);
 
   } else if (type == "base_filename") {
-    target = rpc::call_command_d_string("d.get_base_path", download);
-    link = rak::path_expand(prefix + rpc::call_command_d_string("d.get_base_filename", download) + postfix);
+    target = rpc::call_command_string("d.get_base_path", rpc::make_target(download));
+    link = rak::path_expand(prefix + rpc::call_command_string("d.get_base_filename", rpc::make_target(download)) + postfix);
 
   } else if (type == "tied") {
-    link = rak::path_expand(rpc::call_command_d_string("d.get_tied_to_file", download));
+    link = rak::path_expand(rpc::call_command_string("d.get_tied_to_file", rpc::make_target(download)));
 
     if (link.empty())
       return torrent::Object();
 
     link = rak::path_expand(prefix + link + postfix);
-    target = rpc::call_command_d_string("d.get_base_path", download);
+    target = rpc::call_command_string("d.get_base_path", rpc::make_target(download));
 
   } else {
     throw torrent::input_error("Unknown type argument.");
   }
 
   switch (changeType) {
@@ -145,21 +145,21 @@
 
   return torrent::Object();
 }
 
 void
 apply_d_delete_tied(core::Download* download) {
-  const std::string& tie = rpc::call_command_d_string("d.get_tied_to_file", download);
+  const std::string& tie = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(download));
 
   if (tie.empty())
     return;
 
   if (::unlink(rak::path_expand(tie).c_str()) == -1)
     control->core()->push_log_std("Could not unlink tied file: " + std::string(rak::error_number::current().c_str()));
 
-  rpc::call_command_d("d.set_tied_to_file", download, std::string());
+  rpc::call_command("d.set_tied_to_file", std::string(), rpc::make_target(download));
 }
 
 void
 apply_d_connection_type(core::Download* download, const std::string& name) {
   torrent::Download::ConnectionType connType;
 
@@ -199,73 +199,160 @@
   default:
     throw torrent::input_error("Priority out of range.");
   }
 }
 
 torrent::Object
-apply_d_ratio(core::Download* download) {
+retrieve_d_ratio(core::Download* download) {
   if (download->is_hash_checking())
     return int64_t();
 
   int64_t bytesDone = download->download()->bytes_done();
   int64_t upTotal   = download->download()->up_rate()->total();
 
   return bytesDone > 0 ? (1000 * upTotal) / bytesDone : 0;
 }
 
+torrent::Object
+retrieve_d_hash(core::Download* download) {
+  const torrent::HashString* hashString = &download->download()->info_hash();
+
+  return torrent::Object(rak::transform_hex(hashString->begin(), hashString->end()));
+}
+
+torrent::Object
+retrieve_d_local_id(core::Download* download) {
+  const torrent::HashString* hashString = &download->download()->local_id();
+
+  return torrent::Object(rak::transform_hex(hashString->begin(), hashString->end()));
+}
+
+torrent::Object
+retrieve_d_local_id_html(core::Download* download) {
+  const torrent::HashString* hashString = &download->download()->local_id();
+
+  return torrent::Object(rak::copy_escape_html(hashString->begin(), hashString->end()));
+}
+
+torrent::Object
+f_multicall(core::Download* download, const torrent::Object& rawArgs) {
+  const torrent::Object::list_type& args = rawArgs.as_list();
+
+  if (args.empty())
+    throw torrent::input_error("Too few arguments.");
+
+  // We ignore the first arg for now, but it will be used for
+  // selecting what files to include.
+
+  // Add some pre-parsing of the commands, so we don't spend time
+  // parsing and searching command map for every single call.
+  torrent::Object             resultRaw(torrent::Object::TYPE_LIST);
+  torrent::Object::list_type& result = resultRaw.as_list();
+
+  for (torrent::FileList::const_iterator itr = download->file_list()->begin(), last = download->file_list()->end(); itr != last; itr++) {
+    torrent::Object::list_type& row = result.insert(result.end(), torrent::Object(torrent::Object::TYPE_LIST))->as_list();
+
+    for (torrent::Object::list_type::const_iterator cItr = ++args.begin(), cLast = args.end(); cItr != args.end(); cItr++) {
+      const std::string& cmd = cItr->as_string();
+      row.push_back(rpc::parse_command(rpc::make_target(*itr), cmd.c_str(), cmd.c_str() + cmd.size()).first);
+    }
+  }
+
+  return resultRaw;
+}
+
+torrent::Object
+t_multicall(core::Download* download, const torrent::Object& rawArgs) {
+  const torrent::Object::list_type& args = rawArgs.as_list();
+
+  if (args.empty())
+    throw torrent::input_error("Too few arguments.");
+
+  // We ignore the first arg for now, but it will be used for
+  // selecting what files to include.
+
+  // Add some pre-parsing of the commands, so we don't spend time
+  // parsing and searching command map for every single call.
+  torrent::Object             resultRaw(torrent::Object::TYPE_LIST);
+  torrent::Object::list_type& result = resultRaw.as_list();
+
+  for (int itr = 0, last = download->tracker_list()->size(); itr != last; itr++) {
+    torrent::Object::list_type& row = result.insert(result.end(), torrent::Object(torrent::Object::TYPE_LIST))->as_list();
+
+    for (torrent::Object::list_type::const_iterator cItr = ++args.begin(), cLast = args.end(); cItr != args.end(); cItr++) {
+      const std::string& cmd = cItr->as_string();
+      torrent::Tracker t = download->tracker_list()->get(itr);
+
+      row.push_back(rpc::parse_command(rpc::make_target(&t), cmd.c_str(), cmd.c_str() + cmd.size()).first);
+    }
+  }
+
+  return resultRaw;
+}
+
 #define ADD_CD_SLOT(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
-  rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandDownloadSlot::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CD_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandDownloadSlotsItr->set_slot(slot); \
-  rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandDownloadSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_download(key, commandDownloadSlotsItr++, &rpc::CommandSlot<core::Download*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CD_VOID(key, slot) \
-  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_d_fn(slot), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CD_V_VOID(key, slot) \
-  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_d_fn(slot), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CD_F_VOID(key, slot) \
-  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_void_d_fn(slot), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_void_fn<core::Download*>(slot), "i:", "")
 
-#define ADD_CD_LIST(key, slot) \
+#define ADD_CD_LIST_OBSOLETE(key, slot) \
   ADD_CD_SLOT_PUBLIC(key, call_list, slot, "i:", "")
 
+#define ADD_CD_LIST(key, slot) \
+  ADD_CD_SLOT_PUBLIC("d." key, call_list, slot, "i:", "")
+
 #define ADD_CD_VARIABLE_VALUE(key, firstKey, secondKey) \
   ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
   ADD_CD_SLOT("d.set_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
 
 #define ADD_CD_VARIABLE_VALUE_PUBLIC(key, firstKey, secondKey) \
   ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
   ADD_CD_SLOT_PUBLIC("d.set_" key, call_value,   rpc::set_variable_d_fn(firstKey, secondKey), "i:i", "");
 
 #define ADD_CD_VARIABLE_STRING(key, firstKey, secondKey) \
   ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
   ADD_CD_SLOT("d.set_" key, call_string,  rpc::set_variable_d_fn(firstKey, secondKey), "i:s", "");
 
+#define ADD_CD_VARIABLE_STRING_PUBLIC(key, firstKey, secondKey) \
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::get_variable_d_fn(firstKey, secondKey), "i:", ""); \
+  ADD_CD_SLOT_PUBLIC("d.set_" key, call_string,  rpc::set_variable_d_fn(firstKey, secondKey), "i:s", "");
+
+#define ADD_CD_VALUE(key, get) \
+  ADD_CD_SLOT_PUBLIC("d." key, call_unknown, rpc::object_void_fn<core::Download*>(get), "i:", "")
+
 #define ADD_CD_VALUE_UNI(key, get) \
-  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_fn<core::Download*>(get), "i:", "")
 
 #define ADD_CD_VALUE_BI(key, set, get) \
-  ADD_CD_SLOT_PUBLIC("d.set_" key, call_value, rpc::object_value_d_fn(set), "i:i", "") \
-  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "i:", "")
+  ADD_CD_SLOT_PUBLIC("d.set_" key, call_value, rpc::object_value_fn<core::Download*>(set), "i:i", "") \
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_fn<core::Download*>(get), "i:", "")
 
 #define ADD_CD_VALUE_MEM_BI(key, target, set, get) \
   ADD_CD_VALUE_BI(key, rak::on2(std::mem_fun(target), std::mem_fun(set)), rak::on(std::mem_fun(target), std::mem_fun(get)));
 
 #define ADD_CD_VALUE_MEM_UNI(key, target, get) \
-  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(rak::on(rak::on(std::mem_fun(&core::Download::download), std::mem_fun(target)), std::mem_fun(get))), "i:", "");
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_fn<core::Download*>(rak::on(rak::on(std::mem_fun(&core::Download::download), std::mem_fun(target)), std::mem_fun(get))), "i:", "");
 
 #define ADD_CD_STRING_UNI(key, get) \
-  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "s:", "")
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_fn<core::Download*>(get), "s:", "")
 
 #define ADD_CD_STRING_BI(key, set, get) \
-  ADD_CD_SLOT_PUBLIC("d.set_" key, call_string, rpc::object_string_d_fn(set), "i:s", "") \
-  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_d_fn(get), "s:", "")
+  ADD_CD_SLOT_PUBLIC("d.set_" key, call_string,  rpc::object_string_fn<core::Download*>(set), "i:s", "") \
+  ADD_CD_SLOT_PUBLIC("d.get_" key, call_unknown, rpc::object_void_fn<core::Download*>(get), "s:", "")
 
 void
 add_copy_to_download(const char* src, const char* dest) {
   rpc::CommandMap::iterator itr = rpc::commands.find(src);
 
   if (itr == rpc::commands.end())
@@ -273,16 +360,22 @@
 
   rpc::commands.insert(dest, itr->second);
 }
 
 void
 initialize_command_download() {
+  ADD_CD_VOID("hash",          &retrieve_d_hash);
+  ADD_CD_VOID("local_id",      &retrieve_d_local_id);
+  ADD_CD_VOID("local_id_html", &retrieve_d_local_id_html);
   ADD_CD_VOID("base_path",     &retrieve_d_base_path);
   ADD_CD_VOID("base_filename", &retrieve_d_base_filename);
   ADD_CD_STRING_UNI("name",    rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::name)));
 
+  ADD_CD_LIST_OBSOLETE("create_link",   rak::bind_ptr_fn(&apply_d_change_link, 0));
+  ADD_CD_LIST_OBSOLETE("delete_link",   rak::bind_ptr_fn(&apply_d_change_link, 1));
+
   ADD_CD_LIST("create_link",   rak::bind_ptr_fn(&apply_d_change_link, 0));
   ADD_CD_LIST("delete_link",   rak::bind_ptr_fn(&apply_d_change_link, 1));
   ADD_CD_V_VOID("delete_tied", &apply_d_delete_tied);
 
   ADD_CD_F_VOID("start",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::start_normal));
   ADD_CD_F_VOID("stop",       rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::stop_normal));
@@ -290,17 +383,24 @@
   ADD_CD_F_VOID("close",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::close_throw));
   ADD_CD_F_VOID("erase",      rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::erase_ptr));
   ADD_CD_F_VOID("check_hash", rak::make_mem_fun(control->core()->download_list(), &core::DownloadList::check_hash));
 
   ADD_CD_F_VOID("update_priorities", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::update_priorities)));
 
-  ADD_CD_VALUE_UNI("is_open",          rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_open)));
-  ADD_CD_VALUE_UNI("is_active",        rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_active)));
-  ADD_CD_VALUE_UNI("is_hash_checked",  rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_hash_checked)));
-  ADD_CD_VALUE_UNI("is_hash_checking", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_hash_checking)));
-  ADD_CD_VALUE_UNI("is_multi_file",    rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::is_multi_file)));
+  ADD_CD_VALUE("is_open",          rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_open)));
+  ADD_CD_VALUE("is_active",        rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_active)));
+  ADD_CD_VALUE("is_hash_checked",  rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_hash_checked)));
+  ADD_CD_VALUE("is_hash_checking", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_hash_checking)));
+  ADD_CD_VALUE("is_multi_file",    rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::is_multi_file)));
+  ADD_CD_VALUE("is_private",       rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::is_private)));
+
+  ADD_CD_VARIABLE_STRING_PUBLIC("custom1", "rtorrent", "custom1");
+  ADD_CD_VARIABLE_STRING_PUBLIC("custom2", "rtorrent", "custom2");
+  ADD_CD_VARIABLE_STRING_PUBLIC("custom3", "rtorrent", "custom3");
+  ADD_CD_VARIABLE_STRING_PUBLIC("custom4", "rtorrent", "custom4");
+  ADD_CD_VARIABLE_STRING_PUBLIC("custom5", "rtorrent", "custom5");
 
   // 0 - stopped
   // 1 - started
   ADD_CD_VARIABLE_VALUE("state", "rtorrent", "state");
   ADD_CD_VARIABLE_VALUE("complete", "rtorrent", "complete");
 
@@ -310,23 +410,28 @@
   // 2 forced on
   ADD_CD_VARIABLE_VALUE("mode", "rtorrent", "mode");
 
   // 0 - Not hashing
   // 1 - Normal hashing
   // 2 - Download finished, hashing
+  // 3 - Rehashing
   ADD_CD_VARIABLE_VALUE("hashing", "rtorrent", "hashing");
   ADD_CD_VARIABLE_STRING("tied_to_file", "rtorrent", "tied_to_file");
 
   // The "state_changed" variable is required to be a valid unix time
   // value, it indicates the last time the torrent changed its state,
   // resume/pause.
   ADD_CD_VARIABLE_VALUE("state_changed", "rtorrent", "state_changed");
   ADD_CD_VARIABLE_VALUE_PUBLIC("ignore_commands", "rtorrent", "ignore_commands");
 
   ADD_CD_STRING_BI("connection_current", std::ptr_fun(&apply_d_connection_type), std::ptr_fun(&retrieve_d_connection_type));
 
+  // This command really needs to be improved, so we have proper
+  // logging support.
+  ADD_CD_STRING_BI("message",            std::mem_fun(&core::Download::set_message), std::mem_fun(&core::Download::message));
+
   add_copy_to_download("get_connection_leech", "d.get_connection_leech");
   add_copy_to_download("set_connection_leech", "d.set_connection_leech");
   add_copy_to_download("get_connection_seed", "d.get_connection_seed");
   add_copy_to_download("set_connection_seed", "d.set_connection_seed");
 
   ADD_CD_VALUE_MEM_BI("max_file_size", &core::Download::file_list, &torrent::FileList::set_max_file_size, &torrent::FileList::max_file_size);
@@ -341,36 +446,42 @@
   ADD_CD_VALUE_MEM_BI("uploads_max",      &core::Download::download, &torrent::Download::set_uploads_max, &torrent::Download::uploads_max);
   ADD_CD_VALUE_UNI("peers_connected",     rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::peers_connected)));
   ADD_CD_VALUE_UNI("peers_not_connected", rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::peers_not_connected)));
   ADD_CD_VALUE_UNI("peers_complete",      rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::peers_complete)));
   ADD_CD_VALUE_UNI("peers_accounted",     rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::peers_accounted)));
 
+  ADD_CD_VALUE_MEM_BI("peer_exchange", &core::Download::download, &torrent::Download::set_pex_enabled, &torrent::Download::is_pex_enabled);
+
   ADD_CD_VALUE_MEM_UNI("up_rate",      &torrent::Download::mutable_up_rate, &torrent::Rate::rate);
   ADD_CD_VALUE_MEM_UNI("up_total",     &torrent::Download::mutable_up_rate, &torrent::Rate::total);
   ADD_CD_VALUE_MEM_UNI("down_rate",    &torrent::Download::mutable_down_rate, &torrent::Rate::rate);
   ADD_CD_VALUE_MEM_UNI("down_total",   &torrent::Download::mutable_down_rate, &torrent::Rate::total);
   ADD_CD_VALUE_MEM_UNI("skip_rate",    &torrent::Download::mutable_skip_rate, &torrent::Rate::rate);
   ADD_CD_VALUE_MEM_UNI("skip_total",   &torrent::Download::mutable_skip_rate, &torrent::Rate::total);
 
-  ADD_CD_VALUE_UNI("bytes_done",       rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::bytes_done)));
-  ADD_CD_VALUE_UNI("ratio",            std::ptr_fun(&apply_d_ratio));
-  ADD_CD_VALUE_UNI("chunks_hashed",    rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::chunks_hashed)));
-  ADD_CD_VALUE_UNI("free_diskspace",   rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::free_diskspace)));
-
-  ADD_CD_VALUE_UNI("size_files",       rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::size_files)));
-  ADD_CD_VALUE_UNI("size_bytes",       rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::size_bytes)));
-  ADD_CD_VALUE_UNI("size_chunks",      rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::size_chunks)));
-
-  ADD_CD_VALUE_UNI("completed_bytes",  rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::completed_bytes)));
-  ADD_CD_VALUE_UNI("completed_chunks", rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::completed_chunks)));
-  ADD_CD_VALUE_UNI("left_bytes",       rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::left_bytes)));
+  ADD_CD_VALUE_UNI("creation_date",       rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::creation_date)));
+  ADD_CD_VALUE_UNI("bytes_done",          rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::bytes_done)));
+  ADD_CD_VALUE_UNI("ratio",               std::ptr_fun(&retrieve_d_ratio));
+  ADD_CD_VALUE_UNI("chunks_hashed",       rak::on(std::mem_fun(&core::Download::download), std::mem_fun(&torrent::Download::chunks_hashed)));
+  ADD_CD_VALUE_UNI("free_diskspace",      rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::free_diskspace)));
+
+  ADD_CD_VALUE_UNI("size_files",          rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::size_files)));
+  ADD_CD_VALUE_UNI("size_bytes",          rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::size_bytes)));
+  ADD_CD_VALUE_UNI("size_chunks",         rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::size_chunks)));
+
+  ADD_CD_VALUE_UNI("completed_bytes",     rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::completed_bytes)));
+  ADD_CD_VALUE_UNI("completed_chunks",    rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::completed_chunks)));
+  ADD_CD_VALUE_UNI("left_bytes",          rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::left_bytes)));
 
-  ADD_CD_VALUE_UNI("chunk_size",       rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::chunk_size)));
+  ADD_CD_VALUE_UNI("chunk_size",          rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::chunk_size)));
 
   ADD_CD_VALUE_MEM_BI("tracker_numwant", &core::Download::tracker_list, &torrent::TrackerList::set_numwant, &torrent::TrackerList::numwant);
   ADD_CD_VALUE_UNI("tracker_focus",      rak::on(std::mem_fun(&core::Download::tracker_list), std::mem_fun(&torrent::TrackerList::focus)));
   ADD_CD_VALUE_UNI("tracker_size",       rak::on(std::mem_fun(&core::Download::tracker_list), std::mem_fun(&torrent::TrackerList::size)));
 
   ADD_CD_STRING_BI("directory",        std::mem_fun(&core::Download::set_root_directory), rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(&torrent::FileList::root_dir)));
   ADD_CD_VALUE_BI("priority",          std::mem_fun(&core::Download::set_priority), std::mem_fun(&core::Download::priority));
   ADD_CD_STRING_UNI("priority_str",    std::ptr_fun(&retrieve_d_priority_str));
+
+  ADD_CD_SLOT_PUBLIC("f.multicall",    call_list, rak::ptr_fn(&f_multicall), "i:", "")
+  ADD_CD_SLOT_PUBLIC("t.multicall",    call_list, rak::ptr_fn(&t_multicall), "i:", "")
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_events.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_events.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_events.cc	2007-08-16 05:33:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_events.cc	2007-09-07 07:33:48.000000000 +0800
@@ -76,13 +76,13 @@
     (*slotMap)[key] = sigc::bind(sigc::ptr_fun(&rpc::parse_command_d_multiple_std), args.back().as_string());
 
   return torrent::Object();
 }
 
 torrent::Object
-apply_stop_on_ratio(const torrent::Object& rawArgs) {
+apply_on_ratio(int action, const torrent::Object& rawArgs) {
   const torrent::Object::list_type& args = rawArgs.as_list();
 
   if (args.empty())
     throw torrent::input_error("Too few arguments.");
 
   torrent::Object::list_type::const_iterator argItr = args.begin();
@@ -92,85 +92,97 @@
   // third argument:  maximum ratio to reach [optional]
   int64_t minRatio  = rpc::convert_to_value(*argItr++);
   int64_t minUpload = argItr != args.end() ? rpc::convert_to_value(*argItr++) : 0;
   int64_t maxRatio  = argItr != args.end() ? rpc::convert_to_value(*argItr++) : 0;
 
   core::DownloadList* downloadList = control->core()->download_list();
-  core::Manager::DListItr itr = downloadList->begin();
 
-  while ((itr = std::find_if(itr, downloadList->end(), std::mem_fun(&core::Download::is_seeding)))
-         != downloadList->end()) {
+  for  (core::Manager::DListItr itr = downloadList->begin();
+        (itr = std::find_if(itr, downloadList->end(), std::mem_fun(&core::Download::is_seeding))) != downloadList->end();
+        itr++) {
     int64_t totalDone   = (*itr)->download()->bytes_done();
     int64_t totalUpload = (*itr)->download()->up_rate()->total();
 
-    if ((totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) ||
-        (maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio)) {
-      downloadList->stop_try(*itr);
-      rpc::call_command_d("d.set_ignore_commands", *itr, (int64_t)1);
+    if (!(totalUpload >= minUpload && totalUpload * 100 >= totalDone * minRatio) &&
+        !(maxRatio > 0 && totalUpload * 100 > totalDone * maxRatio))
+      continue;
+
+    bool success;
+
+    switch (action) {
+    case core::DownloadList::SLOTS_CLOSE: success = downloadList->close_try(*itr); break;
+    case core::DownloadList::SLOTS_STOP:  success = downloadList->stop_try(*itr); break;
+    default: success = false; break;
     }
 
-    ++itr;
+    if (!success)
+      continue;
+
+    rpc::call_command("d.set_ignore_commands", (int64_t)1, rpc::make_target(*itr));
+
+    for (torrent::Object::list_type::const_iterator itr2 = argItr; itr2 != args.end(); itr2++)
+      rpc::parse_command_object(rpc::make_target(*itr), *itr2);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_start_tied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
-    if (rpc::call_command_d_value("d.get_state", *itr) == 1)
+    if (rpc::call_command_value("d.get_state", rpc::make_target(*itr)) == 1)
       continue;
 
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
     if (!tiedToFile.empty() && fs.update(rak::path_expand(tiedToFile)))
       control->core()->download_list()->start_try(*itr);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_stop_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
-    if (rpc::call_command_d_value("d.get_state", *itr) == 0)
+    if (rpc::call_command_value("d.get_state", rpc::make_target(*itr)) == 0)
       continue;
 
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
     if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)))
       control->core()->download_list()->stop_try(*itr);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_close_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ++itr) {
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
-    if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)) && control->core()->download_list()->stop_try(*itr))
+    if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(*itr)) == 0 && !tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile)))
       control->core()->download_list()->close(*itr);
   }
 
   return torrent::Object();
 }
 
 torrent::Object
 apply_remove_untied() {
   for (core::DownloadList::iterator itr = control->core()->download_list()->begin(); itr != control->core()->download_list()->end(); ) {
     rak::file_stat fs;
-    const std::string& tiedToFile = rpc::call_command_d_string("d.get_tied_to_file", *itr);
+    const std::string& tiedToFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*itr));
 
     if (!tiedToFile.empty() && !fs.update(rak::path_expand(tiedToFile))) {
       // Need to clear tied_to_file so it doesn't try to delete it.
-      rpc::call_command_d("d.set_tied_to_file", *itr, std::string());
+      rpc::call_command("d.set_tied_to_file", std::string(), rpc::make_target(*itr));
 
       itr = control->core()->download_list()->erase(itr);
 
     } else {
       ++itr;
     }
@@ -265,13 +277,13 @@
   }
 
   return result;
 }
 
 torrent::Object
-apply_call_download(const torrent::Object& rawArgs) {
+d_multicall(const torrent::Object& rawArgs) {
   const torrent::Object::list_type&          args = rawArgs.as_list();
 
   if (args.empty())
     throw torrent::input_error("Too few arguments.");
 
 //   const torrent::Object::string_type& infoHash = args.begin()->as_string();
@@ -303,13 +315,13 @@
 
   for (core::View::const_iterator vItr = (*viewItr)->begin_visible(), vLast = (*viewItr)->end_visible(); vItr != vLast; vItr++) {
     torrent::Object::list_type& row = result.insert(result.end(), torrent::Object(torrent::Object::TYPE_LIST))->as_list();
 
     for (torrent::Object::list_type::const_iterator cItr = ++args.begin(), cLast = args.end(); cItr != args.end(); cItr++) {
       const std::string& cmd = cItr->as_string();
-      row.push_back(rpc::parse_command_d_single(*vItr, cmd.c_str(), cmd.c_str() + cmd.size()));
+      row.push_back(rpc::parse_command(rpc::make_target(*vItr), cmd.c_str(), cmd.c_str() + cmd.size()).first);
     }
   }
 
   return resultRaw;
 }
 
@@ -319,40 +331,45 @@
 
   ADD_VARIABLE_BOOL("check_hash", true);
 
   ADD_VARIABLE_BOOL("session_lock", true);
   ADD_VARIABLE_BOOL("session_on_completion", true);
 
-  ADD_COMMAND_SLOT_PRIVATE("on_insert",       call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_insert()));
-  ADD_COMMAND_SLOT_PRIVATE("on_erase",        call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_erase()));
-  ADD_COMMAND_SLOT_PRIVATE("on_open",         call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_open()));
-  ADD_COMMAND_SLOT_PRIVATE("on_close",        call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_close()));
-  ADD_COMMAND_SLOT_PRIVATE("on_start",        call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_start()));
-  ADD_COMMAND_SLOT_PRIVATE("on_stop",         call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_stop()));
-  ADD_COMMAND_SLOT_PRIVATE("on_hash_queued",  call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_queued()));
-  ADD_COMMAND_SLOT_PRIVATE("on_hash_removed", call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_removed()));
-  ADD_COMMAND_SLOT_PRIVATE("on_hash_done",    call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_done()));
-  ADD_COMMAND_SLOT_PRIVATE("on_finished",     call_list, rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_finished()));
-
-  ADD_COMMAND_SLOT_PRIVATE("stop_on_ratio",   call_list, rak::ptr_fn(&apply_stop_on_ratio));
-
-  ADD_COMMAND_SLOT_PRIVATE("start_tied",      call_string, rpc::object_fn(&apply_start_tied));
-  ADD_COMMAND_SLOT_PRIVATE("stop_untied",     call_string, rpc::object_fn(&apply_stop_untied));
-  ADD_COMMAND_SLOT_PRIVATE("close_untied",    call_string, rpc::object_fn(&apply_close_untied));
-  ADD_COMMAND_SLOT_PRIVATE("remove_untied",   call_string, rpc::object_fn(&apply_remove_untied));
+  ADD_COMMAND_LIST("on_insert",       rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_insert()));
+  ADD_COMMAND_LIST("on_erase",        rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_erase()));
+  ADD_COMMAND_LIST("on_open",         rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_open()));
+  ADD_COMMAND_LIST("on_close",        rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_close()));
+  ADD_COMMAND_LIST("on_start",        rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_start()));
+  ADD_COMMAND_LIST("on_stop",         rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_stop()));
+  ADD_COMMAND_LIST("on_hash_queued",  rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_queued()));
+  ADD_COMMAND_LIST("on_hash_removed", rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_removed()));
+  ADD_COMMAND_LIST("on_hash_done",    rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_hash_done()));
+  ADD_COMMAND_LIST("on_finished",     rak::bind_ptr_fn(&apply_on_state_change, &downloadList->slot_map_finished()));
+
+  ADD_COMMAND_LIST("stop_on_ratio",   rak::bind_ptr_fn(&apply_on_ratio, (int)core::DownloadList::SLOTS_STOP));
+  ADD_COMMAND_LIST("close_on_ratio",  rak::bind_ptr_fn(&apply_on_ratio, (int)core::DownloadList::SLOTS_CLOSE));
+
+  ADD_COMMAND_VOID("start_tied",      &apply_start_tied);
+  ADD_COMMAND_VOID("stop_untied",     &apply_stop_untied);
+  ADD_COMMAND_VOID("close_untied",    &apply_close_untied);
+  ADD_COMMAND_VOID("remove_untied",   &apply_remove_untied);
 
   ADD_COMMAND_LIST("schedule",                rak::ptr_fn(&apply_schedule));
   ADD_COMMAND_STRING_UN("schedule_remove",    rak::make_mem_fun(control->command_scheduler(), &rpc::CommandScheduler::erase_str));
 
   ADD_COMMAND_STRING_UN("import",             std::ptr_fun(&apply_import));
   ADD_COMMAND_STRING_UN("try_import",         std::ptr_fun(&apply_try_import));
 
   ADD_COMMAND_LIST("load",                    rak::bind_ptr_fn(&apply_load, core::Manager::create_quiet | core::Manager::create_tied));
   ADD_COMMAND_LIST("load_verbose",            rak::bind_ptr_fn(&apply_load, core::Manager::create_tied));
   ADD_COMMAND_LIST("load_start",              rak::bind_ptr_fn(&apply_load, core::Manager::create_quiet | core::Manager::create_tied | core::Manager::create_start));
-  ADD_COMMAND_LIST("load_start_verbose",      rak::bind_ptr_fn(&apply_load, core::Manager::create_tied | core::Manager::create_start));
+  ADD_COMMAND_LIST("load_start_verbose",      rak::bind_ptr_fn(&apply_load, core::Manager::create_tied  | core::Manager::create_start));
+  ADD_COMMAND_LIST("load_raw",                rak::bind_ptr_fn(&apply_load, core::Manager::create_quiet | core::Manager::create_raw_data));
+  ADD_COMMAND_LIST("load_raw_verbose",        rak::bind_ptr_fn(&apply_load, core::Manager::create_raw_data));
+  ADD_COMMAND_LIST("load_raw_start",          rak::bind_ptr_fn(&apply_load, core::Manager::create_quiet | core::Manager::create_start | core::Manager::create_raw_data));
 
   ADD_COMMAND_VALUE_UN("close_low_diskspace", std::ptr_fun(&apply_close_low_diskspace));
 
   ADD_COMMAND_LIST("download_list",           rak::ptr_fn(&apply_download_list));
-  ADD_COMMAND_LIST("call_download",           rak::ptr_fn(&apply_call_download));
+  ADD_COMMAND_LIST("d.multicall",             rak::ptr_fn(&d_multicall));
+  ADD_COMMAND_COPY("call_download",           call_list, "i:", "");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_file.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_file.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_file.cc	2007-08-13 02:25:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_file.cc	2007-09-01 21:35:07.000000000 +0800
@@ -39,14 +39,12 @@
 #include <rak/error_number.h>
 #include <rak/path.h>
 #include <torrent/data/file.h>
 #include <torrent/data/file_list.h>
 
 #include "core/manager.h"
-#include "rpc/command_slot.h"
-#include "rpc/command_file_slot.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 void
@@ -86,30 +84,30 @@
 apply_f_path_depth(torrent::File* file) {
   return (int64_t)file->path()->size();
 }
 
 #define ADD_CF_SLOT(key, function, slot, parm, doc)    \
   commandFileSlotsItr->set_slot(slot); \
-  rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandFileSlot::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandSlot<torrent::File*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CF_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandFileSlotsItr->set_slot(slot); \
-  rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandFileSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_file(key, commandFileSlotsItr++, &rpc::CommandSlot<torrent::File*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CF_VOID(key, slot) \
-  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_f_fn(slot), "i:", "")
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CF_VALUE_UNI(key, get) \
-  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_fn<torrent::File*>(get), "i:", "")
 
 #define ADD_CF_VALUE_BI(key, set, get) \
-  ADD_CF_SLOT_PUBLIC("f.set_" key, call_value, rpc::object_value_f_fn(set), "i:i", "") \
-  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
+  ADD_CF_SLOT_PUBLIC("f.set_" key, call_value,   rpc::object_value_fn<torrent::File*>(set), "i:i", "") \
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_fn<torrent::File*>(get), "i:", "")
 
 #define ADD_CF_STRING_UNI(key, get) \
-  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_f_fn(get), "s:", "")
+  ADD_CF_SLOT_PUBLIC("f.get_" key, call_unknown, rpc::object_void_fn<torrent::File*>(get), "s:", "")
 
 void
 initialize_command_file() {
   ADD_CF_VALUE_UNI("is_created",       std::mem_fun(&torrent::File::is_created));
   ADD_CF_VALUE_UNI("is_open",          std::mem_fun(&torrent::File::is_open));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_helpers.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.cc	2007-08-17 01:06:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_helpers.cc	2007-09-01 21:56:38.000000000 +0800
@@ -37,33 +37,33 @@
 #include "config.h"
 
 #include <torrent/exceptions.h>
 
 #include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
-#include "rpc/command_download_slot.h"
-#include "rpc/command_file_slot.h"
-#include "rpc/command_peer_slot.h"
-#include "rpc/command_tracker_slot.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
-rpc::CommandSlot          commandSlots[COMMAND_SLOTS_SIZE];
-rpc::CommandSlot*         commandSlotsItr = commandSlots;
+rpc::CommandSlot<void>    commandSlots[COMMAND_SLOTS_SIZE];
+rpc::CommandSlot<void>*   commandSlotsItr = commandSlots;
 rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
 rpc::CommandVariable*     commandVariablesItr = commandVariables;
-rpc::CommandDownloadSlot  commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
-rpc::CommandDownloadSlot* commandDownloadSlotsItr = commandDownloadSlots;
-rpc::CommandFileSlot      commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
-rpc::CommandFileSlot*     commandFileSlotsItr = commandFileSlots;
-rpc::CommandPeerSlot      commandPeerSlots[COMMAND_PEER_SLOTS_SIZE];
-rpc::CommandPeerSlot*     commandPeerSlotsItr = commandPeerSlots;
-rpc::CommandTrackerSlot   commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
-rpc::CommandTrackerSlot*  commandTrackerSlotsItr = commandTrackerSlots;
+rpc::CommandSlot<core::Download*>             commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
+rpc::CommandSlot<core::Download*>*            commandDownloadSlotsItr = commandDownloadSlots;
+rpc::CommandSlot<torrent::File*>              commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
+rpc::CommandSlot<torrent::File*>*             commandFileSlotsItr = commandFileSlots;
+rpc::CommandSlot<torrent::FileListIterator*>  commandFileItrSlots[COMMAND_FILE_ITR_SLOTS_SIZE];
+rpc::CommandSlot<torrent::FileListIterator*>* commandFileItrSlotsItr = commandFileItrSlots;
+rpc::CommandSlot<torrent::Peer*>              commandPeerSlots[COMMAND_PEER_SLOTS_SIZE];
+rpc::CommandSlot<torrent::Peer*>*             commandPeerSlotsItr = commandPeerSlots;
+rpc::CommandSlot<torrent::Tracker*>           commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
+rpc::CommandSlot<torrent::Tracker*>*          commandTrackerSlotsItr = commandTrackerSlots;
+rpc::CommandSlot<rpc::target_type>            commandAnySlots[COMMAND_ANY_SLOTS_SIZE];
+rpc::CommandSlot<rpc::target_type>*           commandAnySlotsItr = commandAnySlots;
 
 void initialize_command_download();
 void initialize_command_events();
 void initialize_command_file();
 void initialize_command_peer();
 void initialize_command_local();
@@ -85,20 +85,22 @@
 #ifdef ADDING_COMMANDS 
   if (commandSlotsItr > commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr > commandVariables + COMMAND_VARIABLES_SIZE ||
       commandDownloadSlotsItr > commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr > commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
       commandPeerSlotsItr > commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
-      commandTrackerSlotsItr > commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE)
+      commandTrackerSlotsItr > commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE ||
+      commandAnySlotsItr > commandAnySlots + COMMAND_ANY_SLOTS_SIZE)
 #else
   if (commandSlotsItr != commandSlots + COMMAND_SLOTS_SIZE ||
       commandVariablesItr != commandVariables + COMMAND_VARIABLES_SIZE ||
       commandDownloadSlotsItr != commandDownloadSlots + COMMAND_DOWNLOAD_SLOTS_SIZE ||
       commandFileSlotsItr != commandFileSlots + COMMAND_FILE_SLOTS_SIZE ||
       commandPeerSlotsItr != commandPeerSlots + COMMAND_PEER_SLOTS_SIZE ||
-      commandTrackerSlotsItr != commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE)
+      commandTrackerSlotsItr != commandTrackerSlots + COMMAND_TRACKER_SLOTS_SIZE ||
+      commandAnySlotsItr != commandAnySlots + COMMAND_ANY_SLOTS_SIZE)
 #endif
     throw torrent::internal_error("initialize_commands() static command array size mismatch.");
 }
 
 void
 add_variable(const char* getKey, const char* setKey, const char* defaultSetKey,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_helpers.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_helpers.h	2007-08-17 00:25:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_helpers.h	2007-09-03 03:47:38.000000000 +0800
@@ -34,46 +34,48 @@
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_UTILS_COMMAND_HELPERS_H
 #define RTORRENT_UTILS_COMMAND_HELPERS_H
 
+#include "rpc/command_slot.h"
 #include "rpc/parse_commands.h"
 
 namespace rpc {
-  class CommandSlot;
   class CommandVariable;
-  class CommandDownloadSlot;
-  class CommandFileSlot;
-  class CommandPeerSlot;
-  class CommandTrackerSlot;
 }
 
 // By using a static array we avoid allocating the variables on the
 // heap. This should reduce memory use and improve cache locality.
-#define COMMAND_SLOTS_SIZE          100
+#define COMMAND_SLOTS_SIZE          150
 #define COMMAND_VARIABLES_SIZE      100
-#define COMMAND_DOWNLOAD_SLOTS_SIZE 100
+#define COMMAND_DOWNLOAD_SLOTS_SIZE 150
 #define COMMAND_FILE_SLOTS_SIZE     20
+#define COMMAND_FILE_ITR_SLOTS_SIZE 10
 #define COMMAND_PEER_SLOTS_SIZE     20
 #define COMMAND_TRACKER_SLOTS_SIZE  15
+#define COMMAND_ANY_SLOTS_SIZE      20
 
 #define ADDING_COMMANDS
 
-extern rpc::CommandSlot          commandSlots[COMMAND_SLOTS_SIZE];
-extern rpc::CommandSlot*         commandSlotsItr;
+extern rpc::CommandSlot<void>    commandSlots[COMMAND_SLOTS_SIZE];
+extern rpc::CommandSlot<void>*   commandSlotsItr;
 extern rpc::CommandVariable      commandVariables[COMMAND_VARIABLES_SIZE];
 extern rpc::CommandVariable*     commandVariablesItr;
-extern rpc::CommandDownloadSlot  commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
-extern rpc::CommandDownloadSlot* commandDownloadSlotsItr;
-extern rpc::CommandFileSlot      commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
-extern rpc::CommandFileSlot*     commandFileSlotsItr;
-extern rpc::CommandPeerSlot      commandPeerSlots[COMMAND_PEER_SLOTS_SIZE];
-extern rpc::CommandPeerSlot*     commandPeerSlotsItr;
-extern rpc::CommandTrackerSlot   commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
-extern rpc::CommandTrackerSlot*  commandTrackerSlotsItr;
+extern rpc::CommandSlot<core::Download*>             commandDownloadSlots[COMMAND_DOWNLOAD_SLOTS_SIZE];
+extern rpc::CommandSlot<core::Download*>*            commandDownloadSlotsItr;
+extern rpc::CommandSlot<torrent::File*>              commandFileSlots[COMMAND_FILE_SLOTS_SIZE];
+extern rpc::CommandSlot<torrent::File*>*             commandFileSlotsItr;
+extern rpc::CommandSlot<torrent::FileListIterator*>  commandFileItrSlots[COMMAND_FILE_ITR_SLOTS_SIZE];
+extern rpc::CommandSlot<torrent::FileListIterator*>* commandFileItrSlotsItr;
+extern rpc::CommandSlot<torrent::Peer*>              commandPeerSlots[COMMAND_PEER_SLOTS_SIZE];
+extern rpc::CommandSlot<torrent::Peer*>*             commandPeerSlotsItr;
+extern rpc::CommandSlot<torrent::Tracker*>           commandTrackerSlots[COMMAND_TRACKER_SLOTS_SIZE];
+extern rpc::CommandSlot<torrent::Tracker*>*          commandTrackerSlotsItr;
+extern rpc::CommandSlot<rpc::target_type>            commandAnySlots[COMMAND_ANY_SLOTS_SIZE];
+extern rpc::CommandSlot<rpc::target_type>*           commandAnySlotsItr;
 
 void initialize_commands();
 
 void
 add_variable(const char* getKey, const char* setKey, const char* defaultSetKey,
              rpc::CommandMap::generic_slot getSlot, rpc::CommandMap::generic_slot setSlot,
@@ -85,65 +87,85 @@
 #define ADD_VARIABLE_VALUE(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_value, &rpc::CommandVariable::set_value, (int64_t)defaultValue);
 
 #define ADD_VARIABLE_STRING(key, defaultValue) \
 add_variable("get_" key, "set_" key, key, &rpc::CommandVariable::get_string, &rpc::CommandVariable::set_string, std::string(defaultValue));
 
-#define ADD_VARIABLE_C_STRING(key, defaultValue) \
-add_variable("get_" key, NULL, NULL, &rpc::CommandVariable::get_string, NULL, std::string(defaultValue));
+#define ADD_C_STRING(key, defaultValue) \
+add_variable(key, NULL, NULL, &rpc::CommandVariable::get_string, NULL, std::string(defaultValue));
 
 #define ADD_COMMAND_SLOT(key, function, slot, parm, doc)    \
   commandSlotsItr->set_slot(slot); \
-  rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+
+#define ADD_ANY_SLOT(key, function, slot, parm, doc)    \
+  commandAnySlotsItr->set_slot(slot); \
+  rpc::commands.insert_any(key, commandAnySlotsItr++, &rpc::CommandSlot<rpc::target_type>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_COMMAND_SLOT_PRIVATE(key, function, slot) \
   commandSlotsItr->set_slot(slot); \
-  rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
+  rpc::commands.insert_generic(key, commandSlotsItr++, &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
 
 #define ADD_COMMAND_COPY(key, function, parm, doc) \
-  rpc::commands.insert_generic(key, (commandSlotsItr - 1), &rpc::CommandSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_generic(key, (commandSlotsItr - 1), &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_COMMAND_COPY_PRIVATE(key, function) \
-  rpc::commands.insert_generic(key, (commandSlotsItr - 1), &rpc::CommandSlot::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
+  rpc::commands.insert_generic(key, (commandSlotsItr - 1), &rpc::CommandSlot<void>::function, rpc::CommandMap::flag_dont_delete, NULL, NULL);
 
 #define ADD_COMMAND_VALUE_TRI(key, set, get) \
   ADD_COMMAND_SLOT_PRIVATE(key, call_value, rpc::object_value_fn(set))      \
   ADD_COMMAND_COPY("set_" key,  call_value, "i:i", "")                      \
   ADD_COMMAND_SLOT("get_" key,  call_unknown, rpc::object_void_fn(get), "i:", "")
 
 #define ADD_COMMAND_VALUE_TRI_KB(key, set, get) \
   ADD_COMMAND_SLOT_PRIVATE(key, call_value_kb, rpc::object_value_fn(set)) \
   ADD_COMMAND_COPY("set_" key,  call_value, "i:i", "")                      \
   ADD_COMMAND_SLOT("get_" key,  call_unknown, rpc::object_void_fn(get), "i:", "")
 
-#define ADD_COMMAND_VALUE_TRI_OCT(key, set, get) \
+#define ADD_COMMAND_VALUE_SET_OCT(prefix, key, set)                 \
   ADD_COMMAND_SLOT_PRIVATE(key, call_value_oct, rpc::object_value_fn(set)) \
-  ADD_COMMAND_COPY("set_" key,  call_value, "i:i", "")                      \
-  ADD_COMMAND_SLOT("get_" key,  call_unknown, rpc::object_void_fn(get), "i:", "")
+  ADD_COMMAND_COPY(prefix "set_" key,  call_value, "i:i", "")
+
+#define ADD_COMMAND_VALUE_TRI_OCT(prefix, key, set, get)                 \
+  ADD_COMMAND_SLOT_PRIVATE(key, call_value_oct, rpc::object_value_fn(set)) \
+  ADD_COMMAND_COPY(prefix "set_" key,  call_value, "i:i", "")                      \
+  ADD_COMMAND_SLOT(prefix "get_" key,  call_unknown, rpc::object_void_fn(get), "i:", "")
 
-#define ADD_COMMAND_STRING_TRI(key, set, get) \
+#define ADD_COMMAND_STRING_PREFIX(prefix, key, set, get) \
   ADD_COMMAND_SLOT_PRIVATE(key, call_string, rpc::object_string_fn(set))      \
-  ADD_COMMAND_COPY("set_" key,  call_string, "i:s", "") \
-  ADD_COMMAND_SLOT("get_" key,  call_unknown, rpc::object_void_fn(get), "s:", "")
+  ADD_COMMAND_COPY(prefix "set_" key,  call_string, "i:s", "") \
+  ADD_COMMAND_SLOT(prefix "get_" key,  call_unknown, rpc::object_void_fn(get), "s:", "")
+
+#define ADD_COMMAND_STRING_TRI(key, set, get)                    \
+  ADD_COMMAND_STRING_PREFIX("", key, set, get)
 
 #define ADD_COMMAND_VOID(key, slot) \
   ADD_COMMAND_SLOT(key, call_unknown, rpc::object_void_fn(slot), "i:", "")
 
 #define ADD_COMMAND_VALUE(key, slot) \
   ADD_COMMAND_SLOT(key, call_value, slot, "i:i", "")
 
+#define ADD_ANY_VALUE(key, slot) \
+  ADD_ANY_SLOT(key, call_value, slot, "i:i", "")
+
 #define ADD_COMMAND_VALUE_UN(key, slot) \
   ADD_COMMAND_SLOT(key, call_value, rpc::object_value_fn(slot), "i:i", "")
 
 #define ADD_COMMAND_STRING(key, slot) \
   ADD_COMMAND_SLOT(key, call_string, slot, "i:s", "")
 
 #define ADD_COMMAND_STRING_UN(key, slot) \
   ADD_COMMAND_SLOT(key, call_string, rpc::object_string_fn(slot), "i:s", "")
 
 #define ADD_COMMAND_LIST(key, slot) \
   ADD_COMMAND_SLOT(key, call_list, slot, "i:", "")
 
+#define ADD_COMMAND_NONE(key, slot) \
+  ADD_COMMAND_SLOT(key, call_unknown, slot, "i:", "")
+
+#define ADD_ANY_NONE(key, slot) \
+  ADD_ANY_SLOT(key, call_unknown, slot, "i:", "")
+
 #define ADD_COMMAND_NONE_L(key, slot) \
   ADD_COMMAND_SLOT(key, call_unknown, slot, "A:", "")
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_local.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_local.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_local.cc	2007-08-17 04:42:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_local.cc	2007-08-30 23:19:00.000000000 +0800
@@ -37,12 +37,14 @@
 #include "config.h"
 
 #include <fcntl.h>
 #include <functional>
 #include <unistd.h>
 #include <rak/path.h>
+#include <sys/types.h>
+#include <sys/stat.h>
 #include <torrent/torrent.h>
 #include <torrent/chunk_manager.h>
 
 #include "core/download_list.h"
 #include "core/download_store.h"
 #include "core/manager.h"
@@ -76,42 +78,86 @@
     control->core()->push_log("Closed execute log file.");
   }
 
   return torrent::Object();
 }
 
+torrent::Object
+system_hostname() {
+  char buffer[1024];
+
+  if (gethostname(buffer, 1023) == -1)
+    throw torrent::input_error("Unable to read hostname.");
+
+//   if (shorten)
+//     *std::find(buffer, buffer + 1023, '.') = '\0';
+
+  return std::string(buffer);
+}
+
+torrent::Object
+system_get_cwd() {
+  char* buffer = getcwd(NULL, 0);
+
+  if (buffer == NULL)
+    throw torrent::input_error("Unable to read cwd.");
+
+  torrent::Object result = torrent::Object(std::string(buffer));
+  free(buffer);
+
+  return result;
+}
+
+torrent::Object
+system_set_cwd(const torrent::Object& rawArgs) {
+  if (::chdir(rawArgs.as_string().c_str()) != 0)
+    throw torrent::input_error("Could not change current working directory.");
+
+  return torrent::Object();
+}
+
 void
 initialize_command_local() {
   torrent::ChunkManager* chunkManager = torrent::chunk_manager();
   core::DownloadList*    dList = control->core()->download_list();
   core::DownloadStore*   dStore = control->core()->download_store();
 
-  ADD_VARIABLE_C_STRING("client_version",  PACKAGE_VERSION);
-  ADD_VARIABLE_C_STRING("library_version", torrent::version());
+  ADD_C_STRING("system.client_version",          PACKAGE_VERSION);
+  ADD_C_STRING("system.library_version",         torrent::version());
+
+  ADD_COMMAND_VOID("system.hostname",            rak::ptr_fun(&system_hostname));
+  ADD_COMMAND_VOID("system.pid",                 rak::ptr_fun(&getpid));
+
+  ADD_COMMAND_VALUE_SET_OCT("system.", "umask",  std::ptr_fun(&umask));
+  ADD_COMMAND_STRING_PREFIX("system.", "cwd",    std::ptr_fun(system_set_cwd), rak::ptr_fun(&system_get_cwd));
+
+  ADD_VARIABLE_STRING("name",            "");
 
   ADD_VARIABLE_VALUE("max_file_size", -1);
   ADD_VARIABLE_VALUE("split_file_size", -1);
   ADD_VARIABLE_STRING("split_suffix", ".part");
 
+  ADD_COMMAND_VOID("get_memory_usage",           rak::make_mem_fun(chunkManager, &CM_t::memory_usage));
   ADD_COMMAND_VALUE_TRI("max_memory_usage",      rak::make_mem_fun(chunkManager, &CM_t::set_max_memory_usage), rak::make_mem_fun(chunkManager, &CM_t::max_memory_usage));
   ADD_COMMAND_VALUE_TRI("safe_sync",             rak::make_mem_fun(chunkManager, &CM_t::set_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::safe_sync));
+  ADD_COMMAND_VOID("get_safe_free_diskspace",    rak::make_mem_fun(chunkManager, &CM_t::safe_free_diskspace));
   ADD_COMMAND_VALUE_TRI("timeout_sync",          rak::make_mem_fun(chunkManager, &CM_t::set_timeout_sync), rak::make_mem_fun(chunkManager, &CM_t::timeout_sync));
   ADD_COMMAND_VALUE_TRI("timeout_safe_sync",     rak::make_mem_fun(chunkManager, &CM_t::set_timeout_safe_sync), rak::make_mem_fun(chunkManager, &CM_t::timeout_safe_sync));
 
   ADD_COMMAND_VALUE_TRI("preload_type",          rak::make_mem_fun(chunkManager, &CM_t::set_preload_type), rak::make_mem_fun(chunkManager, &CM_t::preload_type));
   ADD_COMMAND_VALUE_TRI("preload_min_size",      rak::make_mem_fun(chunkManager, &CM_t::set_preload_min_size), rak::make_mem_fun(chunkManager, &CM_t::preload_min_size));
   ADD_COMMAND_VALUE_TRI_KB("preload_required_rate", rak::make_mem_fun(chunkManager, &CM_t::set_preload_required_rate), rak::make_mem_fun(chunkManager, &CM_t::preload_required_rate));
 
+  ADD_COMMAND_VOID("get_stats_preloaded",        rak::make_mem_fun(chunkManager, &CM_t::stats_preloaded));
+  ADD_COMMAND_VOID("get_stats_not_preloaded",    rak::make_mem_fun(chunkManager, &CM_t::stats_not_preloaded));
+
   ADD_VARIABLE_STRING("directory", "./");
 
   ADD_COMMAND_STRING_TRI("session",            rak::make_mem_fun(dStore, &core::DownloadStore::set_path), rak::make_mem_fun(dStore, &core::DownloadStore::path));
   ADD_COMMAND_VOID("session_save",             rak::make_mem_fun(dList, &core::DownloadList::session_save));
 
-  ADD_COMMAND_VALUE_TRI_OCT("umask",           rak::make_mem_fun(control, &Control::set_umask), rak::make_mem_fun(control, &Control::umask));
-  ADD_COMMAND_STRING_TRI("working_directory",  rak::make_mem_fun(control, &Control::set_working_directory), rak::make_mem_fun(control, &Control::working_directory));
-
   ADD_COMMAND_LIST("execute",             rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_throw | rpc::ExecFile::flag_expand_tilde));
   ADD_COMMAND_LIST("execute_nothrow",     rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_expand_tilde));
   ADD_COMMAND_LIST("execute_raw",         rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, rpc::ExecFile::flag_throw));
   ADD_COMMAND_LIST("execute_raw_nothrow", rak::bind2_mem_fn(&rpc::execFile, &rpc::ExecFile::execute_object, 0));
 
   ADD_COMMAND_STRING_UN("execute_log",    std::ptr_fun(&apply_execute_log));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_network.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_network.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_network.cc	2007-08-03 03:36:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_network.cc	2007-09-04 01:16:11.000000000 +0800
@@ -162,25 +162,17 @@
   rpc::xmlrpc.set_slot_find_download(rak::mem_fn(control->core()->download_list(), &core::DownloadList::find_hex_ptr));
   rpc::xmlrpc.set_slot_find_file(rak::ptr_fn(&xmlrpc_find_file));
   rpc::xmlrpc.set_slot_find_tracker(rak::ptr_fn(&xmlrpc_find_tracker));
 
   unsigned int count = 0;
 
-  for (rpc::CommandMap::const_iterator itr = rpc::commands.begin(), last = rpc::commands.end(); itr != last; itr++) {
+  for (rpc::CommandMap::const_iterator itr = rpc::commands.begin(), last = rpc::commands.end(); itr != last; itr++, count++) {
     if (!(itr->second.m_flags & rpc::CommandMap::flag_public_xmlrpc))
       continue;
 
-    switch (itr->second.m_target) {
-    case rpc::CommandMap::target_generic:  rpc::xmlrpc.insert_command(itr->first, itr->second.m_parm, itr->second.m_doc, rpc::XmlRpc::call_generic); break;
-    case rpc::CommandMap::target_download: rpc::xmlrpc.insert_command(itr->first, itr->second.m_parm, itr->second.m_doc, rpc::XmlRpc::call_download); break;
-    case rpc::CommandMap::target_file:     rpc::xmlrpc.insert_command(itr->first, itr->second.m_parm, itr->second.m_doc, rpc::XmlRpc::call_file); break;
-    case rpc::CommandMap::target_tracker:  rpc::xmlrpc.insert_command(itr->first, itr->second.m_parm, itr->second.m_doc, rpc::XmlRpc::call_tracker); break;
-    default: throw torrent::internal_error("XMLRPC: Bad entry.");
-    }
-
-    count++;
+    rpc::xmlrpc.insert_command(itr->first, itr->second.m_parm, itr->second.m_doc);
   }
 
   char buffer[128];
   sprintf(buffer, "XMLRPC initialized with %u functions.", count);
 
   control->core()->push_log(buffer);
@@ -209,18 +201,22 @@
     switch (type) {
     case 1:
       if (std::sscanf(arg.c_str(), ":%i%c", &port, &dummy) == 1) {
         sa.sa_inet()->clear();
         saPtr = &sa;
 
+        control->core()->push_log("The SCGI socket has not been bound to any address and likely poses a security risk.");
+
       } else if (std::sscanf(arg.c_str(), "%1023[^:]:%i%c", address, &port, &dummy) == 2) {
         if ((err = rak::address_info::get_address_info(address, PF_INET, SOCK_STREAM, &ai)) != 0)
           throw torrent::input_error("Could not bind address: " + std::string(rak::address_info::strerror(err)) + ".");
 
         saPtr = ai->address();
 
+        control->core()->push_log("The SCGI socket is bound to a specific network device yet may still pose a security risk, consider using 'scgi_local'.");
+
       } else {
         throw torrent::input_error("Could not parse address.");
       }
 
       if (port <= 0 || port >= (1 << 16))
         throw torrent::input_error("Invalid port number.");
@@ -267,12 +263,13 @@
 initialize_command_network() {
   torrent::ConnectionManager* cm = torrent::connection_manager();
   core::CurlStack* httpStack = control->core()->get_poll_manager()->get_http_stack();
 
   ADD_VARIABLE_BOOL("use_udp_trackers", true);
 
+  // Isn't port_open used?
   ADD_VARIABLE_BOOL("port_open", true);
   ADD_VARIABLE_BOOL("port_random", true);
   ADD_VARIABLE_STRING("port_range", "6881-6999");
 
   ADD_VARIABLE_STRING("connection_leech", "leech");
   ADD_VARIABLE_STRING("connection_seed", "seed");
@@ -324,10 +321,12 @@
   ADD_COMMAND_VALUE_TRI("hash_read_ahead",      std::ptr_fun(&apply_hash_read_ahead), rak::ptr_fun(torrent::hash_read_ahead));
   ADD_COMMAND_VALUE_TRI("hash_interval",        std::ptr_fun(&apply_hash_interval), rak::ptr_fun(torrent::hash_interval));
 
   ADD_COMMAND_VALUE_UN("enable_trackers",       std::ptr_fun(&apply_enable_trackers));
   ADD_COMMAND_STRING_UN("encoding_list",        std::ptr_fun(&apply_encoding_list));
 
+  ADD_VARIABLE_BOOL("peer_exchange", false);
+
   // Not really network stuff:
   ADD_VARIABLE_BOOL("handshake_log", false);
   ADD_VARIABLE_STRING("tracker_dump", "");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_peer.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_peer.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_peer.cc	2007-08-17 03:28:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_peer.cc	2007-09-01 21:34:58.000000000 +0800
@@ -38,14 +38,12 @@
 
 #include <rak/error_number.h>
 #include <rak/path.h>
 #include <torrent/peer/peer.h>
 
 #include "core/manager.h"
-#include "rpc/command_slot.h"
-#include "rpc/command_peer_slot.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 // void
@@ -85,30 +83,30 @@
 // apply_f_path_depth(torrent::File* file) {
 //   return (int64_t)file->path()->size();
 // }
 
 #define ADD_CP_SLOT(key, function, slot, parm, doc)    \
   commandPeerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_peer(key, commandPeerSlotsItr++, &rpc::CommandPeerSlot::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_peer(key, commandPeerSlotsItr++, &rpc::CommandSlot<torrent::Peer*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CP_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandPeerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_peer(key, commandPeerSlotsItr++, &rpc::CommandPeerSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_peer(key, commandPeerSlotsItr++, &rpc::CommandSlot<torrent::Peer*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CP_VOID(key, slot) \
-  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_f_fn(slot), "i:", "")
+  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_fn(slot), "i:", "")
 
 #define ADD_CP_VALUE_UNI(key, get) \
-  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
+  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_void_fn<torrent::Peer*>(get), "i:", "")
 
 #define ADD_CP_VALUE_BI(key, set, get) \
-  ADD_CP_SLOT_PUBLIC("p.set_" key, call_value, rpc::object_value_f_fn(set), "i:i", "") \
-  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_void_f_fn(get), "i:", "")
+  ADD_CP_SLOT_PUBLIC("p.set_" key, call_value, rpc::object_value_fn<torrent::Peer*>(set), "i:i", "") \
+  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_void_fn<torrent::Peer*>(get), "i:", "")
 
 #define ADD_CP_STRING_UNI(key, get) \
-  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_void_f_fn(get), "s:", "")
+  ADD_CP_SLOT_PUBLIC("p.get_" key, call_unknown, rpc::object_void_fn<torrent::Peer*>(get), "s:", "")
 
 void
 initialize_command_peer() {
 //   ADD_CP_VALUE_UNI("is_created",       std::mem_fun(&torrent::Peer::is_created));
 //   ADD_CP_VALUE_UNI("is_open",          std::mem_fun(&torrent::Peer::is_open));
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_tracker.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_tracker.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_tracker.cc	2007-08-13 02:25:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_tracker.cc	2007-09-05 15:30:54.000000000 +0800
@@ -37,14 +37,12 @@
 #include "config.h"
 
 #include <rak/error_number.h>
 #include <torrent/tracker.h>
 
 #include "core/manager.h"
-#include "rpc/command_slot.h"
-#include "rpc/command_tracker_slot.h"
 
 #include "globals.h"
 #include "control.h"
 #include "command_helpers.h"
 
 void
@@ -54,44 +52,50 @@
   else
     tracker->disable();
 }
 
 #define ADD_CT_SLOT(key, function, slot, parm, doc)    \
   commandTrackerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandTrackerSlot::function, rpc::CommandMap::flag_dont_delete, parm, doc);
+  rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandSlot<torrent::Tracker*>::function, rpc::CommandMap::flag_dont_delete, parm, doc);
 
 #define ADD_CT_SLOT_PUBLIC(key, function, slot, parm, doc)    \
   commandTrackerSlotsItr->set_slot(slot); \
-  rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandTrackerSlot::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
+  rpc::commands.insert_tracker(key, commandTrackerSlotsItr++, &rpc::CommandSlot<torrent::Tracker*>::function, rpc::CommandMap::flag_dont_delete | rpc::CommandMap::flag_public_xmlrpc, parm, doc);
 
 #define ADD_CT_VOID(key, slot) \
-  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_t_fn(slot), "i:", "")
+  ADD_CT_SLOT_PUBLIC("t." key, call_unknown,     rpc::object_void_fn<torrent::Tracker*>(slot), "i:", "")
+
+#define ADD_CT_VOID_UNI(key, get) \
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_fn<torrent::Tracker*>(get), "i:", "")
 
 #define ADD_CT_VALUE_UNI(key, get) \
-  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_t_fn(get), "i:", "")
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_fn<torrent::Tracker*>(get), "i:", "")
 
 #define ADD_CT_VALUE_BI(key, set, get) \
-  ADD_CT_SLOT_PUBLIC("t.set_" key, call_value, rpc::object_value_t_fn(set), "i:i", "") \
-  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_t_fn(get), "i:", "")
+  ADD_CT_SLOT_PUBLIC("t.set_" key, call_value,   rpc::object_value_fn<torrent::Tracker*>(set), "i:i", "") \
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_fn<torrent::Tracker*>(get), "i:", "")
+
+#define ADD_CT_BOOL(key, set, get) \
+  ADD_CT_SLOT_PUBLIC("t.set_" key, call_value,   rpc::object_value_fn<torrent::Tracker*>(set), "i:i", "") \
+  ADD_CT_SLOT_PUBLIC("t.is_" key, call_unknown,  rpc::object_void_fn<torrent::Tracker*>(get), "i:", "")
 
 #define ADD_CT_STRING_UNI(key, get) \
-  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_t_fn(get), "s:", "")
+  ADD_CT_SLOT_PUBLIC("t.get_" key, call_unknown, rpc::object_void_fn<torrent::Tracker*>(get), "s:", "")
 
 void
 initialize_command_tracker() {
-  ADD_CT_STRING_UNI("url",              std::mem_fun(&torrent::Tracker::url));
-  ADD_CT_VALUE_UNI("group",             std::mem_fun(&torrent::Tracker::group));
-  ADD_CT_VALUE_UNI("type",              std::mem_fun(&torrent::Tracker::tracker_type));
-  ADD_CT_STRING_UNI("id",               std::mem_fun(&torrent::Tracker::tracker_id));
-
-  ADD_CT_VALUE_BI("enabled",            std::ptr_fun(&apply_t_set_enabled), std::mem_fun(&torrent::Tracker::is_enabled));
-
-  ADD_CT_VALUE_UNI("is_open",           std::mem_fun(&torrent::Tracker::is_open));
-
-  ADD_CT_VALUE_UNI("normal_interval",   std::mem_fun(&torrent::Tracker::normal_interval));
-  ADD_CT_VALUE_UNI("min_interval",      std::mem_fun(&torrent::Tracker::min_interval));
-
-  ADD_CT_VALUE_UNI("scrape_time_last",  std::mem_fun(&torrent::Tracker::scrape_time_last));
-  ADD_CT_VALUE_UNI("scrape_complete",   std::mem_fun(&torrent::Tracker::scrape_complete));
-  ADD_CT_VALUE_UNI("scrape_incomplete", std::mem_fun(&torrent::Tracker::scrape_incomplete));
-  ADD_CT_VALUE_UNI("scrape_downloaded", std::mem_fun(&torrent::Tracker::scrape_downloaded));
+  ADD_CT_STRING_UNI("url",             std::mem_fun(&torrent::Tracker::url));
+  ADD_CT_VOID_UNI("group",             std::mem_fun(&torrent::Tracker::group));
+  ADD_CT_VOID_UNI("type",              std::mem_fun(&torrent::Tracker::tracker_type));
+  ADD_CT_STRING_UNI("id",              std::mem_fun(&torrent::Tracker::tracker_id));
+
+  ADD_CT_VOID("is_open",               std::mem_fun(&torrent::Tracker::is_open));
+  ADD_CT_BOOL("enabled",               std::ptr_fun(&apply_t_set_enabled), std::mem_fun(&torrent::Tracker::is_enabled));
+  
+  ADD_CT_VOID_UNI("normal_interval",   std::mem_fun(&torrent::Tracker::normal_interval));
+  ADD_CT_VOID_UNI("min_interval",      std::mem_fun(&torrent::Tracker::min_interval));
+
+  ADD_CT_VOID_UNI("scrape_time_last",  std::mem_fun(&torrent::Tracker::scrape_time_last));
+  ADD_CT_VOID_UNI("scrape_complete",   std::mem_fun(&torrent::Tracker::scrape_complete));
+  ADD_CT_VOID_UNI("scrape_incomplete", std::mem_fun(&torrent::Tracker::scrape_incomplete));
+  ADD_CT_VOID_UNI("scrape_downloaded", std::mem_fun(&torrent::Tracker::scrape_downloaded));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_ui.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_ui.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/command_ui.cc	2007-08-11 18:28:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/command_ui.cc	2007-09-03 08:57:35.000000000 +0800
@@ -37,13 +37,12 @@
 #include "config.h"
 
 #include <rak/functional.h>
 #include <rak/functional_fun.h>
 #include <sigc++/bind.h>
 
-// #include "core/download_list.h"
 #include "core/manager.h"
 #include "core/view_manager.h"
 #include "rpc/command_slot.h"
 #include "rpc/command_variable.h"
 #include "rpc/parse.h"
 
@@ -106,20 +105,152 @@
     result.push_back((*itr)->name());
 
   return rawResult;
 }
 
 torrent::Object
-apply_print(const torrent::Object& rawArgs) {
+apply_print(rpc::target_type target, const torrent::Object& rawArgs) {
   char buffer[1024];
   rpc::print_object(buffer, buffer + 1024, &rawArgs, 0);
 
   control->core()->push_log(buffer);
   return torrent::Object();
 }
 
+torrent::Object
+apply_cat(rpc::target_type target, const torrent::Object& rawArgs) {
+  std::string result;
+
+  rpc::print_object_std(&result, &rawArgs, 0);
+  return result;
+}
+
+torrent::Object
+apply_to_date(const torrent::Object& rawArgs) {
+  time_t t = (uint64_t)rawArgs.as_value();
+  std::tm *u = std::gmtime(&t);
+  
+  if (u == NULL)
+    return torrent::Object();
+
+  char buffer[11];
+  snprintf(buffer, 11, "%02u/%02u/%04u", u->tm_mday, (u->tm_mon + 1), (1900 + u->tm_year));
+  
+  return std::string(buffer);
+}
+
+torrent::Object
+apply_to_time(const torrent::Object& rawArgs) {
+  time_t t = (uint64_t)rawArgs.as_value();
+  std::tm *u = std::gmtime(&t);
+  
+  if (u == NULL)
+    return torrent::Object();
+
+  char buffer[9];
+  snprintf(buffer, 9, "%2d:%02d:%02d", u->tm_hour, u->tm_min, u->tm_sec);
+
+  return std::string(buffer);
+}
+
+torrent::Object
+apply_to_elapsed_time(const torrent::Object& rawArgs) {
+  uint64_t arg = cachedTime.seconds() - rawArgs.as_value();
+
+  char buffer[48];
+  snprintf(buffer, 48, "%2d:%02d:%02d", (int)(arg / 3600), (int)((arg / 60) % 60), (int)(arg % 60));
+
+  return std::string(buffer);
+}
+
+torrent::Object
+apply_to_kb(const torrent::Object& rawArgs) {
+  char buffer[32];
+  snprintf(buffer, 32, "%5.1f", (double)rawArgs.as_value() / (1 << 10));
+
+  return std::string(buffer);
+}
+
+torrent::Object
+apply_to_mb(const torrent::Object& rawArgs) {
+  char buffer[32];
+  snprintf(buffer, 32, "%8.1f", (double)rawArgs.as_value() / (1 << 20));
+
+  return std::string(buffer);
+}
+
+torrent::Object
+apply_to_xb(const torrent::Object& rawArgs) {
+  char buffer[48];
+  int64_t arg = rawArgs.as_value();  
+
+  if (arg < (int64_t(1000) << 10))
+    snprintf(buffer, 48, "%5.1f KB", (double)arg / (int64_t(1) << 10));
+  else if (arg < (int64_t(1000) << 20))
+    snprintf(buffer, 48, "%5.1f MB", (double)arg / (int64_t(1) << 20));
+  else if (arg < (int64_t(1000) << 30))
+    snprintf(buffer, 48, "%5.1f GB", (double)arg / (int64_t(1) << 30));
+  else
+    snprintf(buffer, 48, "%5.1f TB", (double)arg / (int64_t(1) << 40));
+
+  return std::string(buffer);
+}
+
+// A series of if/else statements. Every even arguments are
+// conditionals and odd arguments are branches to be executed, except
+// the last one which is always a branch.
+//
+// if (cond1) { branch1 }
+// <cond1>,<branch1>
+//
+// if (cond1) { branch1 } else if (cond2) { branch2 } else { branch3 }
+// <cond1>,<branch1>,<cond2>,<branch2>,<branch3>
+torrent::Object
+apply_if(rpc::target_type target, const torrent::Object& rawArgs) {
+  const torrent::Object::list_type& args = rawArgs.as_list();
+  torrent::Object::list_type::const_iterator itr = args.begin();
+
+  while (itr != args.end() && itr != --args.end()) {
+    torrent::Object tmp;
+    const torrent::Object* conditional;
+
+    if (itr->is_string() && *itr->as_string().c_str() == '$')
+      conditional = &(tmp = rpc::parse_command(target, itr->as_string().c_str() + 1, itr->as_string().c_str() + itr->as_string().size()).first);
+    else
+      conditional = &*itr;
+
+    bool result;
+
+    switch (conditional->type()) {
+    case torrent::Object::TYPE_STRING:
+      result = !conditional->as_string().empty();
+      break;
+    case torrent::Object::TYPE_VALUE:
+      result = conditional->as_value();
+      break;
+    default:
+      throw torrent::input_error("Type not supported by 'if'.");
+    };
+
+    itr++;
+
+    if (result)
+      break;
+
+    itr++;
+  }
+
+  if (itr == args.end())
+    return torrent::Object();
+
+  if (itr->is_string() && *itr->as_string().c_str() == '$')
+    return rpc::parse_command(target, itr->as_string().c_str() + 1, itr->as_string().c_str() + itr->as_string().size()).first;
+  else
+    return *itr;
+}
+
 void
 initialize_command_ui() {
   ADD_VARIABLE_STRING("key_layout", "qwerty");
 
   ADD_COMMAND_STRING("view_add",        rpc::object_string_fn(rak::make_mem_fun(control->view_manager(), &core::ViewManager::insert_throw)));
   ADD_COMMAND_NONE_L("view_list",       rak::ptr_fn(&apply_view_list));
@@ -130,8 +261,17 @@
   ADD_COMMAND_LIST("view_sort",         rak::ptr_fn(&apply_view_sort));
   ADD_COMMAND_LIST("view_sort_new",     rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_sort_new));
   ADD_COMMAND_LIST("view_sort_current", rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_sort_current));
 
 //   ADD_COMMAND_LIST("view_sort_current", rak::bind_ptr_fn(&apply_view_filter, &core::ViewManager::set_sort_current));
 
-  ADD_COMMAND_LIST("print",             rak::ptr_fn(&apply_print));
+  ADD_ANY_NONE("print",             rak::ptr_fn(&apply_print));
+  ADD_ANY_NONE("cat",               rak::ptr_fn(&apply_cat));
+  ADD_ANY_NONE("if",                rak::ptr_fn(&apply_if));
+
+  ADD_COMMAND_VALUE("to_date",          rak::ptr_fn(&apply_to_date));
+  ADD_COMMAND_VALUE("to_time",          rak::ptr_fn(&apply_to_time));
+  ADD_COMMAND_VALUE("to_elapsed_time",  rak::ptr_fn(&apply_to_elapsed_time));
+  ADD_COMMAND_VALUE("to_kb",            rak::ptr_fn(&apply_to_kb));
+  ADD_COMMAND_VALUE("to_mb",            rak::ptr_fn(&apply_to_mb));
+  ADD_COMMAND_VALUE("to_xb",            rak::ptr_fn(&apply_to_xb));
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/control.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/control.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/control.cc	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/control.cc	2007-08-24 02:25:34.000000000 +0800
@@ -156,19 +156,6 @@
 }
 
 torrent::Poll*
 Control::poll() {
   return m_core->get_poll_manager()->get_torrent_poll();
 }
-
-void
-Control::set_umask(mode_t m) {
-  ::umask(m);
-
-  m_umask = m;
-}
-
-void
-Control::set_working_directory(const std::string& dir) {
-  if (::chdir(dir.c_str()) != 0)
-    throw torrent::input_error("Could not change working directory.");
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/control.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/control.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/control.h	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/control.h	2007-08-23 22:40:53.000000000 +0800
@@ -102,15 +102,12 @@
   rpc::SCgi*          scgi()                        { return m_scgi; }
   void                set_scgi(rpc::SCgi* f)        { m_scgi = f; }
 
   uint64_t            tick() const                  { return m_tick; }
   void                inc_tick()                    { m_tick++; }
 
-  mode_t              umask() const                 { return m_umask; }
-  void                set_umask(mode_t m);
-
   const std::string&  working_directory() const     { return m_workingDirectory; }
   void                set_working_directory(const std::string& dir);
 
 private:
   Control(const Control&);
   void operator = (const Control&);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download.cc	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download.cc	2007-09-06 01:09:06.000000000 +0800
@@ -49,22 +49,24 @@
 #include <torrent/data/file_list.h>
 
 #include "rpc/parse_commands.h"
 
 #include "control.h"
 #include "download.h"
+#include "manager.h"
 
 namespace core {
 
 Download::Download(download_type d) :
   m_download(d),
   m_trackerList(d.tracker_list()),
 
   m_hashFailed(false),
 
-  m_chunksFailed(0) {
+  m_chunksFailed(0),
+  m_resumeFlags(~uint32_t()) {
 
   m_connTrackerSucceded = m_download.signal_tracker_succeded(sigc::bind(sigc::mem_fun(*this, &Download::receive_tracker_msg), ""));
   m_connTrackerFailed   = m_download.signal_tracker_failed(sigc::mem_fun(*this, &Download::receive_tracker_msg));
   m_connStorageError    = m_download.signal_storage_error(sigc::mem_fun(*this, &Download::receive_storage_error));
 
   m_download.signal_chunk_failed(sigc::mem_fun(*this, &Download::receive_chunk_failed));
@@ -154,12 +156,14 @@
 
 // Clean up.
 void
 Download::set_root_directory(const std::string& path) {
   torrent::FileList* fileList = m_download.file_list();
 
+  control->core()->download_list()->close_directly(this);
+
   if (path.empty()) {
     fileList->set_root_dir("./" + (fileList->is_multi_file() ? m_download.name() : std::string()));
 
   } else {
     std::string fullPath = rak::path_expand(path);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_factory.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_factory.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_factory.cc	2007-08-16 22:58:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_factory.cc	2007-08-31 03:15:06.000000000 +0800
@@ -58,19 +58,18 @@
 #include "download.h"
 #include "download_factory.h"
 #include "download_store.h"
 
 namespace core {
 
-DownloadFactory::DownloadFactory(const std::string& uri, Manager* m) :
+DownloadFactory::DownloadFactory(Manager* m) :
   m_manager(m),
   m_stream(NULL),
   m_commited(false),
   m_loaded(false),
 
-  m_uri(uri),
   m_session(false),
   m_start(false),
   m_printLog(true) {
 
   m_taskLoad.set_slot(rak::mem_fn(this, &DownloadFactory::receive_load));
   m_taskCommit.set_slot(rak::mem_fn(this, &DownloadFactory::receive_commit));
@@ -87,25 +86,36 @@
 
   delete m_stream;
   m_stream = NULL;
 }
 
 void
-DownloadFactory::load() {
+DownloadFactory::load(const std::string& uri) {
+  m_uri = uri;
   priority_queue_insert(&taskScheduler, &m_taskLoad, cachedTime);
 }
 
+// This function must be called before DownloadFactory::commit().
+void
+DownloadFactory::load_raw_data(const std::string& input) {
+  if (m_stream)
+    throw torrent::internal_error("DownloadFactory::load*() called on an object with m_stream != NULL");
+
+  m_stream = new std::stringstream(input);
+  m_loaded = true;
+}
+
 void
 DownloadFactory::commit() {
   priority_queue_insert(&taskScheduler, &m_taskCommit, cachedTime);
 }
 
 void
 DownloadFactory::receive_load() {
   if (m_stream)
-    throw torrent::internal_error("DownloadFactory::load() called on an object with m_stream != NULL");
+    throw torrent::internal_error("DownloadFactory::load*() called on an object with m_stream != NULL");
 
   if (std::strncmp(m_uri.c_str(), "http://", 7) == 0 ||
       std::strncmp(m_uri.c_str(), "https://", 8) == 0 ||
       std::strncmp(m_uri.c_str(), "ftp://", 6) == 0) {
     // Http handling here.
     m_stream = new std::stringstream;
@@ -171,51 +181,59 @@
     root->insert_key("rtorrent", torrent::Object(torrent::Object::TYPE_MAP));
     
   torrent::Object* rtorrent = &root->get_key("rtorrent");
 
   initialize_rtorrent(download, rtorrent);
 
+  if (!rtorrent->has_key_string("custom1")) rtorrent->insert_key("custom1", std::string());
+  if (!rtorrent->has_key_string("custom2")) rtorrent->insert_key("custom2", std::string());
+  if (!rtorrent->has_key_string("custom3")) rtorrent->insert_key("custom3", std::string());
+  if (!rtorrent->has_key_string("custom4")) rtorrent->insert_key("custom4", std::string());
+  if (!rtorrent->has_key_string("custom5")) rtorrent->insert_key("custom5", std::string());
+
   // Move to 'rtorrent'.
-  rpc::call_command_d("d.set_connection_leech", download, m_variables["connection_leech"]);
-  rpc::call_command_d("d.set_connection_seed", download,  m_variables["connection_seed"]);
+  rpc::call_command("d.set_connection_leech", m_variables["connection_leech"], rpc::make_target(download));
+  rpc::call_command("d.set_connection_seed",  m_variables["connection_seed"], rpc::make_target(download));
 
-  rpc::call_command_d("d.set_max_uploads", download,      rpc::call_command_void("get_max_uploads"));
-  rpc::call_command_d("d.set_min_peers", download,        rpc::call_command_void("get_min_peers"));
-  rpc::call_command_d("d.set_max_peers", download,        rpc::call_command_void("get_max_peers"));
-  rpc::call_command_d("d.set_tracker_numwant", download,  rpc::call_command_void("get_tracker_numwant"));
+  rpc::call_command("d.set_max_uploads",      rpc::call_command_void("get_max_uploads"), rpc::make_target(download));
+  rpc::call_command("d.set_min_peers",        rpc::call_command_void("get_min_peers"), rpc::make_target(download));
+  rpc::call_command("d.set_max_peers",        rpc::call_command_void("get_max_peers"), rpc::make_target(download));
+  rpc::call_command("d.set_tracker_numwant",  rpc::call_command_void("get_tracker_numwant"), rpc::make_target(download));
 
-  if (rpc::call_command_d_value("d.get_complete", download) != 0) {
+  if (rpc::call_command_value("d.get_complete", rpc::make_target(download)) != 0) {
     if (rpc::call_command_value("get_min_peers_seed") >= 0)
-      rpc::call_command_d("d.set_min_peers", download, rpc::call_command_void("get_min_peers_seed"));
+      rpc::call_command("d.set_min_peers", rpc::call_command_void("get_min_peers_seed"), rpc::make_target(download));
 
     if (rpc::call_command_value("get_max_peers_seed") >= 0)
-      rpc::call_command_d("d.set_max_peers", download, rpc::call_command_void("get_max_peers_seed"));
+      rpc::call_command("d.set_max_peers", rpc::call_command_void("get_max_peers_seed"), rpc::make_target(download));
   }
 
   if (!rpc::call_command_value("get_use_udp_trackers"))
     download->enable_udp_trackers(false);
 
   if (rpc::call_command_value("get_max_file_size") > 0)
-    rpc::call_command_d("d.set_max_file_size", download, rpc::call_command_void("get_max_file_size"));
+    rpc::call_command("d.set_max_file_size", rpc::call_command_void("get_max_file_size"), rpc::make_target(download));
 
   // Check first if we already have these values set in the session
   // torrent, so that it is safe to change the values.
   //
   // Need to also catch the exceptions.
   if (rpc::call_command_value("get_split_file_size") >= 0)
     torrent::file_split_all(download->download()->file_list(),
                             rpc::call_command_value("get_split_file_size"),
                             rpc::call_command_string("split_suffix"));
 
   if (!rtorrent->has_key_string("directory"))
-    rpc::call_command_d("d.set_directory", download, m_variables["directory"]);
+    rpc::call_command("d.set_directory", m_variables["directory"], rpc::make_target(download));
   else
-    rpc::call_command_d("d.set_directory", download, rtorrent->get_key("directory"));
+    rpc::call_command("d.set_directory", rtorrent->get_key("directory"), rpc::make_target(download));
 
   if (!m_session && m_variables["tied_to_file"].as_value())
-    rpc::call_command_d("d.set_tied_to_file", download, m_uri);
+    rpc::call_command("d.set_tied_to_file", m_uri, rpc::make_target(download));
+
+  rpc::call_command("d.set_peer_exchange", rpc::call_command_value("get_peer_exchange"), rpc::make_target(download));
 
   torrent::Object& resumeObject = root->has_key_map("libtorrent_resume")
     ? root->get_key("libtorrent_resume")
     : root->insert_key("libtorrent_resume", torrent::Object(torrent::Object::TYPE_MAP));
 
   torrent::resume_load_addresses(*download->download(), resumeObject);
@@ -261,14 +279,14 @@
 
   // When a download scheduler is implemented, this is handled by the
   // above insertion into download list.
   if (m_session) {
     // This torrent was queued for hashing or hashing when the session
     // file was saved. Or it was in a started state.
-    if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped ||
-        rpc::call_command_d_value("d.get_state", download) != 0)
+    if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped ||
+        rpc::call_command_value("d.get_state", rpc::make_target(download)) != 0)
       m_manager->download_list()->resume(download);
 
   } else {
     // Use the state thingie here, move below.
     if (m_start)
       m_manager->download_list()->start_normal(download);
@@ -311,15 +329,15 @@
     rtorrent->insert_key("hashing", (int64_t)Download::variable_hashing_stopped);
 
   if (!rtorrent->has_key_string("tied_to_file"))
     rtorrent->insert_key("tied_to_file", std::string());
 
   if (rtorrent->has_key_value("priority"))
-    rpc::call_command_d("d.set_priority", download, rtorrent->get_key_value("priority") % 4);
+    rpc::call_command("d.set_priority", rtorrent->get_key_value("priority") % 4, rpc::make_target(download));
   else
-    rpc::call_command_d("d.set_priority", download, (int64_t)2);
+    rpc::call_command("d.set_priority", (int64_t)2, rpc::make_target(download));
 
   if (rtorrent->has_key_value("key")) {
     download->tracker_list()->set_key(rtorrent->get_key_value("key"));
 
   } else {
     download->tracker_list()->set_key(random() % (std::numeric_limits<uint32_t>::max() - 1) + 1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_factory.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_factory.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_factory.h	2007-07-21 06:31:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_factory.h	2007-08-24 20:05:52.000000000 +0800
@@ -55,19 +55,20 @@
 class DownloadFactory {
 public:
   typedef sigc::slot<void> Slot;
   typedef std::vector<std::string> command_list_type;
 
   // Do not destroy this object while it is in a HttpQueue.
-  DownloadFactory(const std::string& uri, Manager* m);
+  DownloadFactory(Manager* m);
   ~DownloadFactory();
 
   // Calling of receive_load() is delayed so you can change whatever
   // you want without fear of the slots being triggered as you call
   // load() or commit().
-  void                load();
+  void                load(const std::string& uri);
+  void                load_raw_data(const std::string& input);
   void                commit();
 
   command_list_type&         commands()     { return m_commands; }
   torrent::Object::map_type& variables()    { return m_variables; }
 
   bool                get_session() const   { return m_session; }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download.h	2007-07-20 05:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download.h	2007-08-26 07:33:17.000000000 +0800
@@ -97,12 +97,15 @@
 
   void                enable_udp_trackers(bool state);
 
   uint32_t            priority();
   void                set_priority(uint32_t p);
 
+  uint32_t            resume_flags()                           { return m_resumeFlags; }
+  void                set_resume_flags(uint32_t flags)         { m_resumeFlags = flags; }
+
   void                set_root_directory(const std::string& path);
 
   bool                operator == (const std::string& str) const;
 
   float               distributed_copies() const;
 
@@ -121,12 +124,14 @@
 
   bool                m_hashFailed;
 
   std::string         m_message;
   uint32_t            m_chunksFailed;
 
+  uint32_t            m_resumeFlags;
+
   sigc::connection    m_connTrackerSucceded;
   sigc::connection    m_connTrackerFailed;
   sigc::connection    m_connStorageError;
 };
 
 inline bool
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_list.cc	2007-08-13 02:25:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_list.cc	2007-09-07 02:05:15.000000000 +0800
@@ -231,12 +231,39 @@
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
+bool
+DownloadList::close_try(Download* download) {
+  try {
+    if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(download)) != 0)
+      return false;
+
+    rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
+    close_throw(download);
+    return true;
+
+  } catch (torrent::local_error& e) {
+    control->core()->push_log(e.what());
+    return false;
+  }
+}
+
+void
+DownloadList::close_directly(Download* download) {
+  if (download->download()->is_active()) {
+    download->download()->stop2(torrent::Download::stop_skip_tracker);
+    torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
+  }
+
+  if (download->download()->is_open())
+    download->download()->close();
+}
+
 void
 DownloadList::close_quick(Download* download) {
   close(download);
   
   // Make sure we cancel any tracker requests. This should rather be
   // handled by some parameter to the close function, or some other
@@ -266,13 +293,13 @@
   //
   // Reconsider this save. Should be done explicitly when shutting down.
   //control->core()->download_store()->save(download);
 
   download->download()->close();
 
-  if (!download->is_hash_failed() && rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped)
+  if (!download->is_hash_failed() && rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped)
     throw torrent::internal_error("DownloadList::close_throw(...) called but we're going into a hashing loop.");
 
   std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
   std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
 }
 
@@ -280,137 +307,146 @@
 DownloadList::start_normal(Download* download) {
   check_contains(download);
 
   // Clear hash failed as we're doing a manual start and want to try
   // hashing again.
   download->set_hash_failed(false);
-  rpc::call_command_d("d.set_state", download, (int64_t)1);
+  rpc::call_command("d.set_state", (int64_t)1, rpc::make_target(download));
 
   resume(download);
 }
 
 bool
 DownloadList::start_try(Download* download) {
   check_contains(download);
 
   // Also don't start if the state is one of those that indicate we
   // were manually stopped?
 
-  if (download->is_hash_failed() || rpc::call_command_d_value("d.get_ignore_commands", download) != 0)
+  if (download->is_hash_failed() || rpc::call_command_value("d.get_ignore_commands", rpc::make_target(download)) != 0)
     return false;
 
   // Don't clear the hash failed as this function is used by scripts,
   // etc.
-  rpc::call_command_d("d.set_state", download, (int64_t)1);
+  rpc::call_command("d.set_state", (int64_t)1, rpc::make_target(download));
 
   resume(download);
   return true;
 }
 
 void
 DownloadList::stop_normal(Download* download) {
   check_contains(download);
 
-  rpc::call_command_d("d.set_state", download, (int64_t)0);
+  rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
 
   pause(download);
 }
 
 bool
 DownloadList::stop_try(Download* download) {
   check_contains(download);
 
-  if (rpc::call_command_d_value("d.get_ignore_commands", download) != 0)
+  if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(download)) != 0)
     return false;
 
-  rpc::call_command_d("d.set_state", download, (int64_t)0);
+  rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
 
   pause(download);
   return true;
 }
 
 void
-DownloadList::resume(Download* download) {
+DownloadList::resume(Download* download, int flags) {
   check_contains(download);
 
   try {
 
     if (download->download()->is_active())
       return;
 
+    // We need to make sure the flags aren't reset if someone decideds
+    // to call resume() while it is hashing, etc.
+    if (download->resume_flags() == ~uint32_t())
+      download->set_resume_flags(flags);
+
     // Manual or end-of-download rehashing clears the resume data so
     // we can just start the hashing again without clearing it again.
     //
     // It is also assumed the is_hash_checked flag gets cleared when
     // 'hashing' was set.
     if (!download->is_hash_checked()) {
       // If the hash failed flag wasn't cleared then hashing won't be
       // initiated.
       if (download->is_hash_failed())
         return;
 
-      if (rpc::call_command_d_value("d.get_hashing", download) == Download::variable_hashing_stopped)
-        rpc::call_command_d("d.set_hashing", download, Download::variable_hashing_initial);
+      if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) == Download::variable_hashing_stopped)
+        rpc::call_command("d.set_hashing", Download::variable_hashing_initial, rpc::make_target(download));
 
       std::for_each(slot_map_hash_queued().begin(), slot_map_hash_queued().end(), download_list_call(download));
       return;
     }
 
     // This will never actually do anything due to the above hash check.
     // open_throw(download);
 
-    rpc::call_command_d("d.set_state_changed", download, cachedTime.seconds());
+    rpc::call_command("d.set_state_changed", cachedTime.seconds(), rpc::make_target(download));
 
     if (download->is_done()) {
-      rpc::call_command_d("d.set_connection_current", download, rpc::call_command_d_void("d.get_connection_seed", download));
+      rpc::call_command("d.set_connection_current", rpc::call_command_void("d.get_connection_seed", rpc::make_target(download)), rpc::make_target(download));
     } else {
-      rpc::call_command_d("d.set_connection_current", download, rpc::call_command_d_void("d.get_connection_leech", download));
+      rpc::call_command("d.set_connection_current", rpc::call_command_void("d.get_connection_leech", rpc::make_target(download)), rpc::make_target(download));
 
       // For the moment, clear the resume data so we force hash-check
       // on non-complete downloads after a crash. This shouldn't be
       // needed, but for some reason linux 2.6 is very lazy about
       // updating mtime.
       torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"), true);
     }
 
     // Update the priority to ensure it has the correct
     // seeding/unfinished modifiers.
     download->set_priority(download->priority());
-    download->download()->start();
+    download->download()->start2(download->resume_flags());
+
+    download->set_resume_flags(~uint32_t());
 
     std::for_each(slot_map_start().begin(), slot_map_start().end(), download_list_call(download));
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
   }
 }
 
 void
-DownloadList::pause(Download* download) {
+DownloadList::pause(Download* download, int flags) {
   check_contains(download);
 
   try {
 
+    download->set_resume_flags(~uint32_t());
+
     // Always clear hashing on pause. When a hashing request is added,
     // it should have cleared the hash resume data.
-    if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped) {
+    if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped) {
       download->download()->hash_stop();
-      rpc::call_command_d_set_value("d.set_hashing", download, Download::variable_hashing_stopped);
+      rpc::call_command_set_value("d.set_hashing", Download::variable_hashing_stopped, rpc::make_target(download));
 
       std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
     }
 
     if (!download->download()->is_active())
       return;
 
-    download->download()->stop();
+    download->download()->stop2(flags);
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     
     std::for_each(slot_map_stop().begin(), slot_map_stop().end(), download_list_call(download));
 
-    rpc::call_command_d("d.set_state_changed", download, cachedTime.seconds());
+    rpc::call_command("d.set_state_changed", cachedTime.seconds(), rpc::make_target(download));
 
     // Save the state after all the slots, etc have been called so we
     // include the modifications they may make.
     //control->core()->download_store()->save(download);
 
   } catch (torrent::local_error& e) {
@@ -421,13 +457,13 @@
 void
 DownloadList::check_hash(Download* download) {
   check_contains(download);
 
   try {
 
-    if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped)
+    if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped)
       return;
 
     hash_queue(download, Download::variable_hashing_rehash);
 
   } catch (torrent::local_error& e) {
     control->core()->push_log(e.what());
@@ -454,33 +490,33 @@
   //
   // Perhaps we should use a seperate variable or state, and check
   // that. Thus we can bork the download if the hash check doesn't
   // confirm all the data, avoiding large BW usage on f.ex. the
   // ReiserFS bug with >4GB files.
 
-  int64_t hashing = rpc::call_command_d_value("d.get_hashing", download);
-  rpc::call_command_d_set_value("d.set_hashing", download, Download::variable_hashing_stopped);
+  int64_t hashing = rpc::call_command_value("d.get_hashing", rpc::make_target(download));
+  rpc::call_command_set_value("d.set_hashing", Download::variable_hashing_stopped, rpc::make_target(download));
 
   switch (hashing) {
   case Download::variable_hashing_initial:
   case Download::variable_hashing_rehash:
     // Normal re/hashing.
 
     // If the download was previously completed but the files were
     // f.ex deleted, then we clear the state and complete.
-    if (rpc::call_command_d_value("d.get_complete", download) && !download->is_done()) {
-      rpc::call_command_d("d.set_state", download, (int64_t)0);
+    if (rpc::call_command_value("d.get_complete", rpc::make_target(download)) && !download->is_done()) {
+      rpc::call_command("d.set_state", (int64_t)0, rpc::make_target(download));
       download->set_message("Download registered as completed, but hash check returned unfinished chunks.");
     }
 
     // Save resume data so we update time-stamps and priorities if
     // they were invalid/changed while loading/hashing.
-    rpc::call_command_d("d.set_complete", download, (int64_t)download->is_done());
+    rpc::call_command("d.set_complete", (int64_t)download->is_done(), rpc::make_target(download));
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
 
-    if (rpc::call_command_d_value("d.get_state", download) == 1)
+    if (rpc::call_command_value("d.get_state", rpc::make_target(download)) == 1)
       resume(download);
 
     break;
 
   case Download::variable_hashing_last:
 
@@ -504,20 +540,28 @@
 }
 
 void
 DownloadList::hash_queue(Download* download, int type) {
   check_contains(download);
 
-  if (rpc::call_command_d_value("d.get_hashing", download) != Download::variable_hashing_stopped)
+  if (rpc::call_command_value("d.get_hashing", rpc::make_target(download)) != Download::variable_hashing_stopped)
     throw torrent::internal_error("DownloadList::hash_queue(...) hashing already queued.");
 
-  close_throw(download);
+//   close_throw(download);
+  // HACK
+  if (download->is_open()) {
+    pause(download, torrent::Download::stop_skip_tracker);
+    download->download()->close();
+    std::for_each(slot_map_hash_removed().begin(), slot_map_hash_removed().end(), download_list_call(download));
+    std::for_each(slot_map_close().begin(), slot_map_close().end(), download_list_call(download));
+  }
+
   torrent::resume_clear_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
 
   download->set_hash_failed(false);
-  rpc::call_command_d_set_value("d.set_hashing", download, type);
+  rpc::call_command_set_value("d.set_hashing", type, rpc::make_target(download));
 
   if (download->is_open())
     throw torrent::internal_error("DownloadList::hash_clear(...) download still open.");
 
   // If any more stuff is added here, make sure resume etc are still
   // correct.
@@ -540,38 +584,38 @@
 
 // The download must be open when we call this function.
 void
 DownloadList::confirm_finished(Download* download) {
   check_contains(download);
 
-  rpc::call_command_d("d.set_complete", download, (int64_t)1);
+  rpc::call_command("d.set_complete", (int64_t)1, rpc::make_target(download));
 
-  rpc::call_command_d("d.set_connection_current", download, rpc::call_command_d_void("d.get_connection_seed", download));
+  rpc::call_command("d.set_connection_current", rpc::call_command_void("d.get_connection_seed", rpc::make_target(download)), rpc::make_target(download));
   download->set_priority(download->priority());
 
-  if (rpc::call_command_d_value("d.get_min_peers", download) == rpc::call_command_value("get_min_peers") && rpc::call_command_value("get_min_peers_seed") >= 0)
-    rpc::call_command_d("d.set_min_peers", download, rpc::call_command_void("get_min_peers_seed"));
+  if (rpc::call_command_value("d.get_min_peers", rpc::make_target(download)) == rpc::call_command_value("get_min_peers") && rpc::call_command_value("get_min_peers_seed") >= 0)
+    rpc::call_command("d.set_min_peers", rpc::call_command_void("get_min_peers_seed"), rpc::make_target(download));
 
-  if (rpc::call_command_d_value("d.get_max_peers", download) == rpc::call_command_value("get_max_peers") && rpc::call_command_value("get_max_peers_seed") >= 0)
-    rpc::call_command_d("d.set_max_peers", download, rpc::call_command_void("get_max_peers_seed"));
+  if (rpc::call_command_value("d.get_max_peers", rpc::make_target(download)) == rpc::call_command_value("get_max_peers") && rpc::call_command_value("get_max_peers_seed") >= 0)
+    rpc::call_command("d.set_max_peers", rpc::call_command_void("get_max_peers_seed"), rpc::make_target(download));
 
   // Do this before the slots are called in case one of them closes
   // the download.
   if (!download->is_active() && rpc::call_command_value("get_session_on_completion") != 0) {
     torrent::resume_save_progress(*download->download(), download->download()->bencode()->get_key("libtorrent_resume"));
     control->core()->download_store()->save(download);
   }
 
   // Send the completed request before resuming so we don't reset the
   // up/downloaded baseline.
   download->download()->tracker_list().send_completed();
 
-  // Close before calling on_finished to ensure the user can do stuff
-  // like change move the downloaded files and change the directory.
-  close_throw(download);
   std::for_each(slot_map_finished().begin(), slot_map_finished().end(), download_list_call(download));
 
-  if (!download->is_active() && rpc::call_command_d_value("d.get_state", download) == 1)
-    resume(download);
+  if (download->resume_flags() != ~uint32_t())
+    throw torrent::internal_error("DownloadList::confirm_finished(...) download->resume_flags() != ~uint32_t().");
+
+  if (!download->is_active() && rpc::call_command_value("d.get_state", rpc::make_target(download)) == 1)
+    resume(download, torrent::Download::start_skip_tracker | torrent::Download::start_keep_baseline);
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/download_list.h	2007-07-25 02:32:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/download_list.h	2007-09-07 02:04:15.000000000 +0800
@@ -98,23 +98,27 @@
   //void                save(Download* d);
 
   bool                open(Download* d);
   void                open_throw(Download* d);
 
   void                close(Download* d);
+  bool                close_try(Download* d);
+  void                close_directly(Download* d);
   void                close_quick(Download* d);
   void                close_throw(Download* d);
 
   void                start_normal(Download* d);
   bool                start_try(Download* d);
 
   void                stop_normal(Download* d);
   bool                stop_try(Download* d);
 
-  void                resume(Download* d);
-  void                pause(Download* d);
+  void                resume(Download* d, int flags = 0);
+  void                pause(Download* d, int flags = 0);
+
+  void                pause_default(Download* d) { pause(d); }
 
   void                check_hash(Download* d);
 
   enum {
     SLOTS_INSERT,
     SLOTS_ERASE,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/manager.cc	2007-08-13 02:25:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/manager.cc	2007-08-28 06:30:15.000000000 +0800
@@ -248,13 +248,13 @@
   delete m_pollManager;
 }
 
 void
 Manager::shutdown(bool force) {
   if (!force)
-    std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::pause), m_downloadList));
+    std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::pause_default), m_downloadList));
   else
     std::for_each(m_downloadList->begin(), m_downloadList->end(), std::bind1st(std::mem_fun(&DownloadList::close_quick), m_downloadList));
 }
 
 void
 Manager::listen_open() {
@@ -394,21 +394,26 @@
   m_logComplete.push_front("Http download error: \"" + msg + "\"");
 }
 
 void
 Manager::try_create_download(const std::string& uri, int flags, const command_list_type& commands) {
   // Adding download.
-  DownloadFactory* f = new DownloadFactory(uri, this);
+  DownloadFactory* f = new DownloadFactory(this);
 
   f->variables()["tied_to_file"] = (int64_t)(bool)(flags & create_tied);
   f->commands().insert(f->commands().end(), commands.begin(), commands.end());
 
   f->set_start(flags & create_start);
   f->set_print_log(!(flags & create_quiet));
   f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
-  f->load();
+
+  if (flags & create_raw_data)
+    f->load_raw_data(uri);
+  else
+    f->load(uri);
+
   f->commit();
 }
 
 // Move this somewhere better.
 void
 path_expand(std::vector<std::string>* paths, const std::string& pattern) {
@@ -457,17 +462,22 @@
 
   std::transform(currentCache.begin(), currentCache.end(), std::back_inserter(*paths), std::mem_fun_ref(&utils::Directory::get_path));
 }
 
 bool
 manager_equal_tied(const std::string& path, Download* download) {
-  return path == rpc::call_command_d_string("d.get_tied_to_file", download);
+  return path == rpc::call_command_string("d.get_tied_to_file", rpc::make_target(download));
 }
 
 void
 Manager::try_create_download_expand(const std::string& uri, int flags, command_list_type commands) {
+  if (flags & create_raw_data) {
+    try_create_download(uri, flags, commands);
+    return;
+  }
+
   std::vector<std::string> paths;
   paths.reserve(256);
 
   path_expand(&paths, uri);
 
   if (flags & create_tied)
@@ -501,13 +511,13 @@
       throw torrent::internal_error("core::Manager::receive_hashing_changed() (*itr)->is_hash_checked().");
   
     if ((*itr)->is_hash_checking() || (*itr)->is_hash_failed())
       continue;
 
     bool tryQuick =
-      rpc::call_command_d_value("d.get_hashing", *itr) == Download::variable_hashing_initial &&
+      rpc::call_command_value("d.get_hashing", rpc::make_target(*itr)) == Download::variable_hashing_initial &&
       (*itr)->download()->file_list()->bitfield()->empty();
 
     if (!tryQuick && foundHashing)
       continue;
 
     try {
@@ -524,24 +534,24 @@
         if ((*itr)->download()->hash_check(true))
           continue;
 
         (*itr)->download()->hash_stop();
 
         if (foundHashing) {
-          rpc::call_command_d_set_value("d.set_hashing", *itr, Download::variable_hashing_rehash);
+          rpc::call_command_set_value("d.set_hashing", Download::variable_hashing_rehash, rpc::make_target(*itr));
           continue;
         }
       }
 
       (*itr)->download()->hash_check(false);
       foundHashing = true;
 
     } catch (torrent::local_error& e) {
       if (tryQuick) {
         // Make sure we don't repeat the quick hashing.
-        rpc::call_command_d_set_value("d.set_hashing", *itr, Download::variable_hashing_rehash);
+        rpc::call_command_set_value("d.set_hashing", Download::variable_hashing_rehash, rpc::make_target(*itr));
 
       } else {
         (*itr)->set_hash_failed(true);
         push_log(e.what());
       }
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/manager.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/manager.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/manager.h	2007-07-21 07:03:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/manager.h	2007-08-24 20:26:36.000000000 +0800
@@ -96,15 +96,16 @@
 
   void                push_log(const char* msg);
   void                push_log_std(const std::string& msg) { m_logImportant.push_front(msg); m_logComplete.push_front(msg); }
 
   void                handshake_log(const sockaddr* sa, int msg, int err, const torrent::HashString* hash);
 
-  static const int create_start = 0x1;
-  static const int create_tied  = 0x2;
-  static const int create_quiet = 0x4;
+  static const int create_start    = 0x1;
+  static const int create_tied     = 0x2;
+  static const int create_quiet    = 0x4;
+  static const int create_raw_data = 0x8;
 
   typedef std::vector<std::string> command_list_type;
 
   // Temporary, find a better place for this.
   void                try_create_download(const std::string& uri, int flags, const command_list_type& commands);
   void                try_create_download_expand(const std::string& uri, int flags, command_list_type commands = command_list_type());
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/view_manager.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/view_manager.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/core/view_manager.cc	2007-08-13 02:25:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/core/view_manager.cc	2007-08-28 06:18:17.000000000 +0800
@@ -70,14 +70,14 @@
 class ViewSortVariable : public ViewSort {
 public:
   ViewSortVariable(const char* name, const char* value) : m_name(name), m_value(value) {}
 
   virtual bool operator () (Download* d1, Download* d2) const {
     return
-      rpc::call_command_d_string(m_name, d1) == m_value &&
-      rpc::call_command_d_string(m_name, d2) != m_value;
+      rpc::call_command_string(m_name, rpc::make_target(d1)) == m_value &&
+      rpc::call_command_string(m_name, rpc::make_target(d2)) != m_value;
   }
 
 private:
   const char* m_name;
   const char* m_value;
 };
@@ -85,15 +85,15 @@
 class ViewSortVariableValue : public ViewSort {
 public:
   ViewSortVariableValue(const char* name, bool reverse = false) : m_name(name), m_reverse(reverse) {}
 
   virtual bool operator () (Download* d1, Download* d2) const {
     if (m_reverse)
-      return rpc::call_command_d_value(m_name, d2) < rpc::call_command_d_value(m_name, d1);
+      return rpc::call_command_value(m_name, rpc::make_target(d2)) < rpc::call_command_value(m_name, rpc::make_target(d1));
     else
-      return rpc::call_command_d_value(m_name, d1) < rpc::call_command_d_value(m_name, d2);
+      return rpc::call_command_value(m_name, rpc::make_target(d1)) < rpc::call_command_value(m_name, rpc::make_target(d2));
   }
 
 private:
   const char* m_name;
   bool        m_reverse;
 };
@@ -114,13 +114,13 @@
 class ViewFilterVariableValue : public ViewFilter {
 public:
   ViewFilterVariableValue(const char* name, torrent::Object::value_type v, bool inverse = false) :
     m_name(name), m_value(v), m_inverse(inverse) {}
 
   virtual bool operator () (Download* d1) const {
-    return (rpc::call_command_d_value(m_name, d1) == m_value) != m_inverse;
+    return (rpc::call_command_value(m_name, rpc::make_target(d1)) == m_value) != m_inverse;
   }
 
 private:
   const char*                 m_name;
   torrent::Object::value_type m_value;
   bool                        m_inverse;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element.h	2007-08-28 21:06:09.000000000 +0800
@@ -38,12 +38,13 @@
 #define RTORRENT_DISPLAY_TEXT_ELEMENT_H
 
 #include <vector>
 #include <inttypes.h>
 
 #include "display/canvas.h"
+#include "rpc/command_map.h"
 
 namespace display {
 
 class TextElement {
 public:
   typedef uint32_t extent_type;
@@ -53,13 +54,13 @@
   TextElement() {}
   virtual ~TextElement() {}
 
   // The last element must point to a valid memory location into which
   // the caller must write a '\0' to terminate the c string. The
   // attributes must contain at least one attribute.
-  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, void* object) = 0;
+  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) = 0;
 
   virtual extent_type max_length() = 0;
 
   static void         push_attribute(Canvas::attributes_list* attributes, Attributes value);
 
 private:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_helpers.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_helpers.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_helpers.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_helpers.h	2007-09-03 03:13:04.000000000 +0800
@@ -49,12 +49,21 @@
 #include "text_element_lambda.h"
 #include "text_element_string.h"
 #include "text_element_value.h"
 
 namespace display { namespace helpers {
 
+// All we're ever going to need:
+
+inline TextElementCommand*
+te_command(const char* command, int flags = TextElementCommand::flag_normal, int attributes = Attributes::a_invalid) {
+  return new TextElementCommand(command, flags, attributes, TextElementCommand::extent_full);
+}
+
+// End All we're ever going to need.
+
 typedef TextElementStringBase string_base;
 typedef TextElementValueBase  value_base;
 
 // String stuff:
 
 inline TextElementStringBase*
@@ -89,15 +98,19 @@
 template <typename Return>
 inline TextElementStringBase*
 te_string(Return (torrent::FileList::*fptr)() const, int flags = TextElementStringBase::flag_normal, int attributes = Attributes::a_invalid) {
   return text_element_string_slot(rak::on(std::mem_fun(&core::Download::file_list), std::mem_fun(fptr)), flags, attributes);
 }
 
+// TMP HACK
+inline std::string  te_call_command_d_string(const char* key, core::Download* download) { return rpc::commands.call_command(key, torrent::Object(), rpc::make_target(download)).as_string(); }
+inline int64_t      te_call_command_d_value(const char* key, core::Download* download) { return rpc::commands.call_command(key, torrent::Object(), rpc::make_target(download)).as_value(); }
+
 inline TextElementStringBase*
 te_variable_string(const char* variable, int flags = TextElementStringBase::flag_normal, int attributes = Attributes::a_invalid) {
-  return text_element_string_slot(rak::bind1st(std::ptr_fun(&rpc::call_command_d_string), variable), flags, attributes);
+  return text_element_string_slot(rak::bind1st(std::ptr_fun(&te_call_command_d_string), variable), flags, attributes);
 }
 
 // Value stuff:
 
 template <typename Return>
 inline TextElementValueBase*
@@ -116,13 +129,13 @@
 te_value(Return (torrent::File::*fptr)() const, int flags = TextElementValueBase::flag_normal, int attributes = Attributes::a_invalid) {
   return text_element_value_slot(rak::on(std::mem_fun(&torrent::FileListIterator::file), std::mem_fun(fptr)), flags, attributes);
 }
 
 inline TextElementValueBase*
 te_variable_value(const char* variable, int flags = TextElementValueBase::flag_normal, int attributes = Attributes::a_invalid) {
-  return text_element_value_slot(rak::bind1st(std::ptr_fun(&rpc::call_command_d_value), variable), flags, attributes);
+  return text_element_value_slot(rak::bind1st(std::ptr_fun(&te_call_command_d_value), variable), flags, attributes);
 }
 
 template <typename Return>
 inline TextElementValueBase*
 te_value(Return (torrent::ChunkManager::*fptr)() const, int flags = TextElementValueBase::flag_normal, int attributes = Attributes::a_invalid) {
   return text_element_value_void(rak::make_mem_fun(torrent::chunk_manager(), fptr), flags, attributes);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_lambda.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_lambda.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_lambda.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_lambda.h	2007-08-28 21:37:01.000000000 +0800
@@ -47,17 +47,17 @@
   typedef typename slot_type::result_type   result_type;
   
   TextElementBranchVoid(const slot_type& slot, TextElement* branch1, TextElement* branch2) :
     m_slot(slot), m_branch1(branch1), m_branch2(branch2) {}
   ~TextElementBranchVoid() { delete m_branch1; delete m_branch2; }
 
-  virtual char* print(char* first, char* last, Canvas::attributes_list* attributes, void* object) {
+  virtual char* print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
     if (m_slot())
-      return m_branch1 != NULL ? m_branch1->print(first, last, attributes, object) : first;
+      return m_branch1 != NULL ? m_branch1->print(first, last, attributes, target) : first;
     else
-      return m_branch2 != NULL ? m_branch2->print(first, last, attributes, object) : first;
+      return m_branch2 != NULL ? m_branch2->print(first, last, attributes, target) : first;
   }
 
   virtual extent_type max_length() {
     return std::max(m_branch1 != NULL ? m_branch1->max_length() : 0,
                     m_branch2 != NULL ? m_branch2->max_length() : 0);
   }
@@ -76,20 +76,20 @@
   typedef typename slot_type::result_type   result_type;
   
   TextElementBranch(const slot_type& slot, TextElement* branch1, TextElement* branch2) :
     m_slot(slot), m_branch1(branch1), m_branch2(branch2) {}
   ~TextElementBranch() { delete m_branch1; delete m_branch2; }
 
-  virtual char* print(char* first, char* last, Canvas::attributes_list* attributes, void* object) {
-    if (object == NULL)
+  virtual char* print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
+    if (target.second == NULL)
       return first;
 
-    if (m_slot(reinterpret_cast<arg1_type>(object)))
-      return m_branch1 != NULL ? m_branch1->print(first, last, attributes, object) : first;
+    if (m_slot(reinterpret_cast<arg1_type>(target.second)))
+      return m_branch1 != NULL ? m_branch1->print(first, last, attributes, target) : first;
     else
-      return m_branch2 != NULL ? m_branch2->print(first, last, attributes, object) : first;
+      return m_branch2 != NULL ? m_branch2->print(first, last, attributes, target) : first;
   }
 
   virtual extent_type max_length() {
     return std::max(m_branch1 != NULL ? m_branch1->max_length() : 0,
                     m_branch2 != NULL ? m_branch2->max_length() : 0);
   }
@@ -108,22 +108,22 @@
   typedef typename slot_type::result_type   result_type;
   
   TextElementBranch3(const slot_type& slot1, TextElement* branch1, const slot_type& slot2, TextElement* branch2, TextElement* branch3) :
     m_slot1(slot1), m_slot2(slot2), m_branch1(branch1), m_branch2(branch2), m_branch3(branch3) {}
   ~TextElementBranch3() { delete m_branch1; delete m_branch2; delete m_branch3; }
 
-  virtual char* print(char* first, char* last, Canvas::attributes_list* attributes, void* object) {
-    if (object == NULL)
+  virtual char* print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
+    if (target.second == NULL)
       return first;
 
-    if (m_slot1(reinterpret_cast<arg1_type>(object)))
-      return m_branch1 != NULL ? m_branch1->print(first, last, attributes, object) : first;
-    else if (m_slot2(reinterpret_cast<arg1_type>(object)))
-      return m_branch2 != NULL ? m_branch2->print(first, last, attributes, object) : first;
+    if (m_slot1(reinterpret_cast<arg1_type>(target.second)))
+      return m_branch1 != NULL ? m_branch1->print(first, last, attributes, target) : first;
+    else if (m_slot2(reinterpret_cast<arg1_type>(target.second)))
+      return m_branch2 != NULL ? m_branch2->print(first, last, attributes, target) : first;
     else
-      return m_branch3 != NULL ? m_branch3->print(first, last, attributes, object) : first;
+      return m_branch3 != NULL ? m_branch3->print(first, last, attributes, target) : first;
   }
 
   virtual extent_type max_length() {
     return std::max(m_branch1 != NULL ? m_branch1->max_length() : 0,
                     std::max(m_branch2 != NULL ? m_branch2->max_length() : 0,
                              m_branch3 != NULL ? m_branch3->max_length() : 0));
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_list.cc	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_list.cc	2007-08-28 21:11:43.000000000 +0800
@@ -48,34 +48,34 @@
 TextElementList::clear() {
   std::for_each(begin(), end(), rak::call_delete<TextElement>());
   base_type::clear();
 }
 
 char*
-TextElementList::print(char* first, char* last, Canvas::attributes_list* attributes, void* object) {
+TextElementList::print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
   int column = m_columnWidth != NULL ? m_column : 0;
 
   // Call print for each element even if first == last so that any
   // attributes gets added to the list.
   for (iterator itr = begin(); itr != end(); ++itr)
     if (column-- > 0) {
       char* columnEnd = std::min(last, first + *m_columnWidth);
 
       if (columnEnd < first || columnEnd > last)
         throw torrent::internal_error("TextElementList::print(...) columnEnd < first || columnEnd > last.");
 
-      first = (*itr)->print(first, columnEnd, attributes, object);
+      first = (*itr)->print(first, columnEnd, attributes, target);
 
       if (first > columnEnd)
         throw torrent::internal_error("TextElementList::print(...) first > columnEnd.");
 
       std::memset(first, ' ', columnEnd - first);
       first = columnEnd;
 
     } else {
-      first = (*itr)->print(first, last, attributes, object);
+      first = (*itr)->print(first, last, attributes, target);
     }
 
   return first;
 }
 
 TextElementList::extent_type
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_list.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_list.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_list.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_list.h	2007-08-28 21:08:44.000000000 +0800
@@ -66,13 +66,13 @@
 
   void                clear();
 
   void                set_column(unsigned int column)      { m_column = column; }
   void                set_column_width(extent_type* width) { m_columnWidth = width; }
 
-  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, void* object);
+  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target);
 
   virtual extent_type max_length();
 
 private:
   unsigned int        m_column;
   extent_type*        m_columnWidth;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_string.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_string.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_string.cc	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_string.cc	2007-09-03 04:00:56.000000000 +0800
@@ -35,58 +35,102 @@
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
 #include <rak/string_manip.h>
 
+#include "rpc/parse_commands.h"
 #include "text_element_string.h"
 
 namespace display {
 
 char*
-TextElementStringBase::print(char* first, char* last, Canvas::attributes_list* attributes, void* object) {
+TextElementStringBase::print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
   Attributes baseAttribute = attributes->back();
   push_attribute(attributes, Attributes(first, m_attributes, Attributes::color_invalid));
 
   if (first == last)
     return first;
 
   if (m_flags & flag_escape_hex) {
     char buffer[last - first];
-    char* bufferLast = copy_string(buffer, buffer + (last - first), object);
+    char* bufferLast = copy_string(buffer, buffer + (last - first), target);
 
     first = rak::transform_hex(buffer, bufferLast, first, last);
 
   } else if (m_flags & flag_escape_html) {
     char buffer[last - first];
-    char* bufferLast = copy_string(buffer, buffer + (last - first), object);
+    char* bufferLast = copy_string(buffer, buffer + (last - first), target);
 
     first = rak::copy_escape_html(buffer, bufferLast, first, last);
 
   } else {
-    first = copy_string(first, last, object);
+    first = copy_string(first, last, target);
   }  
 
   push_attribute(attributes, Attributes(first, baseAttribute));
 
   return first;
 }
 
 char*
-TextElementString::copy_string(char* first, char* last, void* object) {
+TextElementString::copy_string(char* first, char* last, rpc::target_type target) {
   extent_type length = std::min<extent_type>(last - first, m_string.size());
   
   std::memcpy(first, m_string.c_str(), length);
 
   return first + length;
 }
 
 char*
-TextElementCString::copy_string(char* first, char* last, void* object) {
+TextElementCString::copy_string(char* first, char* last, rpc::target_type target) {
   extent_type length = std::min<extent_type>(last - first, m_length);
 
   std::memcpy(first, m_string, length);
 
   return first + length;
 }
 
+char*
+TextElementCommand::print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
+  Attributes baseAttribute = attributes->back();
+  push_attribute(attributes, Attributes(first, m_attributes, Attributes::color_invalid));
+
+  torrent::Object result = rpc::parse_command(target, m_command, m_commandEnd).first;
+
+  if (first == last)
+    return first;
+
+  switch (result.type()) {
+  case torrent::Object::TYPE_STRING:
+  {
+    const std::string& str = result.as_string();
+
+    if (m_flags & flag_escape_hex) {
+      first = rak::transform_hex(str.c_str(), str.c_str() + str.size(), first, last);
+
+    } else if (m_flags & flag_escape_html) {
+      first = rak::copy_escape_html(str.c_str(), str.c_str() + str.size(), first, last);
+
+    } else {
+      size_t length = std::min<size_t>(str.size(), std::distance(first, last));
+
+      std::memcpy(first, str.c_str(), length);
+      first += std::min<size_t>(str.size(), length);
+    }  
+
+    break;
+  }
+  case torrent::Object::TYPE_VALUE:
+  { 
+    first += std::max(snprintf(first, last - first + 1, "%lld", result.as_value()), 0);
+    break;
+  }
+  default:
+    return first;
+  }
+
+  push_attribute(attributes, Attributes(first, baseAttribute));
+  return first;
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_string.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_string.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_string.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_string.h	2007-09-03 03:12:49.000000000 +0800
@@ -56,16 +56,16 @@
   int                 flags() const                 { return m_flags; }
   void                set_flags(int flags)          { m_flags = flags; }
 
   int                 attributes() const            { return m_attributes; }
   void                set_attributes(int a)         { m_attributes = a; }
 
-  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, void* object);
+  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target);
 
 protected:
-  virtual char*       copy_string(char* first, char* last, void* object) = 0;
+  virtual char*       copy_string(char* first, char* last, rpc::target_type target) = 0;
 
   int                 m_flags;
   int                 m_attributes;
 };
 
 class TextElementString : public TextElementStringBase {
@@ -78,13 +78,13 @@
   const std::string&  str() const                   { return m_string; }
   void                set_str(const std::string& s) { m_string = s; }
 
   virtual extent_type max_length()                  { return m_string.size(); }
 
 private:
-  virtual char*       copy_string(char* first, char* last, void* object);
+  virtual char*       copy_string(char* first, char* last, rpc::target_type target);
 
   std::string         m_string;
 };
 
 class TextElementCString : public TextElementStringBase {
 public:
@@ -93,13 +93,13 @@
     m_attributes = attributes;
   }
 
   virtual extent_type max_length()                  { return m_length; }
 
 private:
-  virtual char*       copy_string(char* first, char* last, void* object);
+  virtual char*       copy_string(char* first, char* last, rpc::target_type target);
 
   extent_type         m_length;
   const char*         m_string;
 };
 
 template <typename slot_type>
@@ -113,17 +113,17 @@
     m_attributes = attributes;
   }
 
   virtual extent_type max_length()                  { return m_length; }
 
 private:
-  virtual char* copy_string(char* first, char* last, void* object) {
-    if (object == NULL)
+  virtual char* copy_string(char* first, char* last, rpc::target_type target) {
+    if (target.second == NULL)
       return first;
 
-    result_type result = m_slot(reinterpret_cast<arg1_type>(object));
+    result_type result = m_slot(reinterpret_cast<arg1_type>(target.second));
     extent_type length = std::min<extent_type>(result_length(&result), last - first);
 
     std::memcpy(first, result_buffer(&result), length);
 
     return first + length;
   }
@@ -152,9 +152,47 @@
                          int flags = TextElementStringBase::flag_normal,
                          int attributes = Attributes::a_invalid,
                          TextElement::extent_type length = TextElement::extent_full) {
   return new TextElementStringSlot<slot_type>(slot, flags, attributes, length);
 }
 
+//
+// New TE's for calling commands directly. Move to a better place.
+//
+
+class TextElementCommand : public TextElement {
+public:
+  static const int flag_normal      = 0;
+  static const int flag_escape_hex  = (1 << 0);
+  static const int flag_escape_html = (1 << 1);
+
+  static const int flag_fixed_width = (1 << 8);
+
+  TextElementCommand(const char* command, int flags, int attributes, extent_type length) :
+    m_flags(flags),
+    m_attributes(attributes),
+    m_length(length),
+    m_command(command),
+    m_commandEnd(command + std::strlen(command)) {}
+
+  int                 flags() const                 { return m_flags; }
+  void                set_flags(int flags)          { m_flags = flags; }
+
+  int                 attributes() const            { return m_attributes; }
+  void                set_attributes(int a)         { m_attributes = a; }
+
+  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target);
+
+  virtual extent_type max_length()                  { return m_length; }
+
+protected:
+  int                 m_flags;
+  int                 m_attributes;
+  extent_type         m_length;
+
+  const char*         m_command;
+  const char*         m_commandEnd;
+};
+
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_value.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_value.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_value.cc	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_value.cc	2007-08-28 21:09:34.000000000 +0800
@@ -56,17 +56,17 @@
     attributes->back() = value;
   else if (base.colors() != value.colors() || base.attributes() != value.attributes())
     attributes->push_back(value);
 }
 
 char*
-TextElementValueBase::print(char* first, char* last, Canvas::attributes_list* attributes, void* object) {
+TextElementValueBase::print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target) {
   Attributes baseAttribute = attributes->back();
   push_attribute(attributes, Attributes(first, m_attributes, Attributes::color_invalid));
 
-  int64_t val = value(object);
+  int64_t val = value(target.second);
 
   // Transform the value if needed.
   if (m_flags & flag_elapsed)
     val = cachedTime.seconds() - val;
   else if (m_flags & flag_remaining)
     val = val - cachedTime.seconds();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_value.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_value.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/text_element_value.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/text_element_value.h	2007-08-28 21:09:16.000000000 +0800
@@ -62,13 +62,13 @@
   int                 flags() const                 { return m_flags; }
   void                set_flags(int flags)          { m_flags = flags; }
 
   int                 attributes() const            { return m_attributes; }
   void                set_attributes(int a)         { m_attributes = a; }
 
-  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, void* object);
+  virtual char*       print(char* first, char* last, Canvas::attributes_list* attributes, rpc::target_type target);
 
 protected:
   virtual int64_t     value(void* object) = 0;
 
   int                 m_flags;
   int                 m_attributes;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/utils.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/utils.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/utils.cc	2007-08-13 02:25:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/utils.cc	2007-08-28 06:18:17.000000000 +0800
@@ -157,18 +157,18 @@
     first = print_download_time_left(first, last, d);
   } else {
     first = print_buffer(first, last, "                ");
   }
 
   first = print_buffer(first, last, " [%c%c R: %4.2f",
-                       rpc::call_command_d_string("d.get_tied_to_file", d).empty() ? ' ' : 'T',
-                       rpc::call_command_d_value("d.get_ignore_commands", d) == 0 ? ' ' : 'I',
-                       (double)rpc::call_command_d_value("d.get_ratio", d) / 1000.0);
+                       rpc::call_command_string("d.get_tied_to_file", rpc::make_target(d)).empty() ? ' ' : 'T',
+                       rpc::call_command_value("d.get_ignore_commands", rpc::make_target(d)) == 0 ? ' ' : 'I',
+                       (double)rpc::call_command_value("d.get_ratio", rpc::make_target(d)) / 1000.0);
 
   if (d->priority() != 2)
-    first = print_buffer(first, last, " %s]", rpc::call_command_d_string("d.get_priority_str", d).c_str());
+    first = print_buffer(first, last, " %s]", rpc::call_command_string("d.get_priority_str", rpc::make_target(d)).c_str());
   else
     first = print_buffer(first, last, "]");
 
   if (first > last)
     throw torrent::internal_error("print_download_info(...) wrote past end of the buffer.");
 
@@ -176,13 +176,13 @@
 }
 
 char*
 print_download_status(char* first, char* last, core::Download* d) {
   if (d->is_active())
     ;
-  else if (rpc::call_command_d_value("d.get_hashing", d) != 0)
+  else if (rpc::call_command_value("d.get_hashing", rpc::make_target(d)) != 0)
     first = print_buffer(first, last, "Hashing: ");
   else if (!d->is_active())
     first = print_buffer(first, last, "Inactive: ");
 
   if (d->is_hash_checking()) {
     first = print_buffer(first, last, "Checking hash [%2i%%]",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/window_text.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/window_text.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/window_text.cc	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/window_text.cc	2007-08-28 21:17:51.000000000 +0800
@@ -42,15 +42,15 @@
 #include "canvas.h"
 #include "utils.h"
 #include "window_text.h"
 
 namespace display {
 
-WindowText::WindowText(void* object, extent_type margin) :
+WindowText::WindowText(rpc::target_type target, extent_type margin) :
   Window(new Canvas, 0, 0, 0, extent_static, extent_static),
-  m_object(object),
+  m_target(target),
   m_margin(margin),
   m_interval(0) {
 }
 
 void
 WindowText::clear() {
@@ -92,13 +92,13 @@
 
     char buffer[m_canvas->width() + 1];
 
     Canvas::attributes_list attributes;
     attributes.push_back(Attributes(buffer, Attributes::a_normal, Attributes::color_default));
 
-    char* last = (*itr)->print(buffer, buffer + m_canvas->width(), &attributes, m_object);
+    char* last = (*itr)->print(buffer, buffer + m_canvas->width(), &attributes, m_target);
 
     m_canvas->print_attributes(0, position, buffer, last, &attributes);
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/window_text.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/window_text.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/display/window_text.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/display/window_text.h	2007-08-28 21:22:33.000000000 +0800
@@ -59,29 +59,29 @@
 
   using base_type::begin;
   using base_type::end;
   using base_type::rbegin;
   using base_type::rend;
 
-  WindowText(void* object = NULL, extent_type margin = 0);
+  WindowText(rpc::target_type target = rpc::make_target(), extent_type margin = 0);
   ~WindowText() { clear(); }
 
   void                clear();
 
-  void*               object() const           { return m_object; }
-  void                set_object(void* object) { m_object = object; }
+  rpc::target_type    target() const                      { return m_target; }
+  void                set_target(rpc::target_type target) { m_target = target; }
 
   uint32_t            interval() const         { return m_interval; }
   void                set_interval(uint32_t i) { m_interval = i; }
 
   void                push_back(TextElement* element);
 
   virtual void        redraw();
 
 private:
-  void*               m_object;
+  rpc::target_type    m_target;
 
   extent_type         m_margin;
   uint32_t            m_interval;
 };
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/main.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/main.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/main.cc	2007-08-12 03:05:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/main.cc	2007-09-08 04:56:16.000000000 +0800
@@ -100,32 +100,32 @@
 void
 load_session_torrents(Control* c) {
   // Load session torrents.
   std::list<std::string> l = c->core()->download_store()->get_formated_entries().make_list();
 
   for (std::list<std::string>::iterator first = l.begin(), last = l.end(); first != last; ++first) {
-    core::DownloadFactory* f = new core::DownloadFactory(*first, c->core());
+    core::DownloadFactory* f = new core::DownloadFactory(c->core());
 
     // Replace with session torrent flag.
     f->set_session(true);
     f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
-    f->load();
+    f->load(*first);
     f->commit();
   }
 }
 
 void
 load_arg_torrents(Control* c, char** first, char** last) {
   //std::for_each(begin, end, std::bind1st(std::mem_fun(&core::Manager::insert), &c->get_core()));
   for (; first != last; ++first) {
-    core::DownloadFactory* f = new core::DownloadFactory(*first, c->core());
+    core::DownloadFactory* f = new core::DownloadFactory(c->core());
 
     // Replace with session torrent flag.
     f->set_start(true);
     f->slot_finished(sigc::bind(sigc::ptr_fun(&rak::call_delete_func<core::DownloadFactory>), f));
-    f->load();
+    f->load(*first);
     f->commit();
   }
 }
 
 static inline rak::timer
 client_next_timeout(Control* c) {
@@ -162,13 +162,16 @@
     control->core()->initialize_first();
 
     // Initialize option handlers after libtorrent to ensure
     // torrent::ConnectionManager* are valid etc.
     initialize_commands();
 
-    rpc::parse_command_multiple(
+    rpc::parse_command_multiple(rpc::make_target(),
+//       "set_name = $cat={$system.hostname=,:,$system.pid=}\n"
+       "set_name = \"$cat=$system.hostname=,:,$system.pid=\"\n"
+
        // Currently not doing any sorting on main.
        "view_add = main\n"
        "view_add = default\n"
 
        "view_add = name\n"
        "view_sort_new = name,name\n"
@@ -208,35 +211,36 @@
        "view_add = seeding\n"
        "view_filter = seeding,started,complete\n"
        "view_filter_on = seeding,start,stop\n"
        "view_sort_new = seeding,state_changed\n"
        "view_sort_current = seeding,state_changed_reverse\n"
 
+       // Changing these will bork the (non-existant) scheduler.
+       "view_add = scheduler\n"
+       "view_sort_new = scheduler,state_changed\n" // add started?
+       "view_sort_current = scheduler,state_changed\n"
+
+       //    "schedule = scheduler,10,10,download_scheduler=\n"
+
        "schedule = view_main,10,10,\"view_sort=main,20\"\n"
        "schedule = view_name,10,10,\"view_sort=name,20\"\n"
        //     "schedule = view_started,10,10,view_sort=started,5\n"
        //     "schedule = view_stopped,10,10,view_sort=stopped,5\n"
        //     "schedule = view_complete,10,10,view_sort=complete,5\n"
        //     "schedule = view_incomplete,10,10,view_sort=incomplete,5\n"
 
-       //"schedule = scheduler,10,10,download_scheduler=\n"
        "schedule = session_save,1800,1800,session_save=\n"
        "schedule = low_diskspace,5,60,close_low_diskspace=500M\n"
 
-       // Changing these will bork the (non-existant) scheduler.
-       "view_add = scheduler\n"
-       "view_sort_new = scheduler,state_changed\n" // add started?
-       "view_sort_current = scheduler,state_changed\n"
-
-       //    "schedule = scheduler,10,10,download_scheduler=\n"
+       "encryption=allow_incoming,prefer_plaintext,enable_retry\n"
     );
 
     if (OptionParser::has_flag('n', argc, argv))
       control->core()->push_log("Ignoring ~/.rtorrent.rc.");
     else
-      rpc::parse_command_single("try_import = ~/.rtorrent.rc");
+      rpc::parse_command_single(rpc::make_target(), "try_import = ~/.rtorrent.rc");
 
     int firstArg = parse_options(control, argc, argv);
 
     control->initialize();
 
     // Load session torrents and perform scheduled tasks to ensure
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_download_slot.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_download_slot.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_file_slot.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_file_slot.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command.h	2007-07-20 05:23:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command.h	2007-08-31 18:52:14.000000000 +0800
@@ -38,12 +38,16 @@
 #define RTORRENT_RPC_VARIABLE_H
 
 #include <torrent/object.h>
 
 namespace rpc {
 
+// Since it gets used so many places we might as well put it in the
+// rpc namespace.
+typedef std::pair<int, void*> target_type;
+
 class Command {
 public:
   typedef torrent::Object::value_type  value_type;
   typedef torrent::Object::string_type string_type;
   typedef torrent::Object::list_type   list_type;
   typedef torrent::Object::map_type    map_type;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_map.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.cc	2007-08-17 00:23:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_map.cc	2007-09-02 15:45:13.000000000 +0800
@@ -57,34 +57,35 @@
   if (itr != base_type::end())
     throw torrent::internal_error("CommandMap::insert(...) tried to insert an already existing key.");
 
   return base_type::insert(itr, value_type(key, command_map_data_type(variable, flags, parm, doc)));
 }
 
+// The functions below should be reduced to just one.
 void
 CommandMap::insert_generic(key_type key, Command* variable, generic_slot targetSlot, int flags, const char* parm, const char* doc) {
   iterator itr = insert(key, variable, flags, parm, doc);
 
   itr->second.m_target      = target_generic;
   itr->second.m_genericSlot = targetSlot;
 }
 
 void
-CommandMap::insert_download(key_type key, Command* variable, download_slot targetSlot, int flags, const char* parm, const char* doc) {
+CommandMap::insert_any(key_type key, Command* variable, any_slot targetSlot, int flags, const char* parm, const char* doc) {
   iterator itr = insert(key, variable, flags, parm, doc);
 
-  itr->second.m_target       = target_download;
-  itr->second.m_downloadSlot = targetSlot;
+  itr->second.m_target      = target_any;
+  itr->second.m_anySlot = targetSlot;
 }
 
 void
-CommandMap::insert_file(key_type key, Command* variable, file_slot targetSlot, int flags, const char* parm, const char* doc) {
+CommandMap::insert_download(key_type key, Command* variable, download_slot targetSlot, int flags, const char* parm, const char* doc) {
   iterator itr = insert(key, variable, flags, parm, doc);
 
-  itr->second.m_target   = target_file;
-  itr->second.m_fileSlot = targetSlot;
+  itr->second.m_target       = target_download;
+  itr->second.m_downloadSlot = targetSlot;
 }
 
 void
 CommandMap::insert_peer(key_type key, Command* variable, peer_slot targetSlot, int flags, const char* parm, const char* doc) {
   iterator itr = insert(key, variable, flags, parm, doc);
 
@@ -98,12 +99,28 @@
 
   itr->second.m_target      = target_tracker;
   itr->second.m_trackerSlot = targetSlot;
 }
 
 void
+CommandMap::insert_file(key_type key, Command* variable, file_slot targetSlot, int flags, const char* parm, const char* doc) {
+  iterator itr = insert(key, variable, flags, parm, doc);
+
+  itr->second.m_target   = target_file;
+  itr->second.m_fileSlot = targetSlot;
+}
+
+void
+CommandMap::insert_file_itr(key_type key, Command* variable, file_itr_slot targetSlot, int flags, const char* parm, const char* doc) {
+  iterator itr = insert(key, variable, flags, parm, doc);
+
+  itr->second.m_target      = target_file_itr;
+  itr->second.m_fileItrSlot = targetSlot;
+}
+
+void
 CommandMap::insert(key_type key, const command_map_data_type src) {
   iterator itr = base_type::find(key);
 
   if (itr != base_type::end())
     throw torrent::internal_error("CommandMap::insert(...) tried to insert an already existing key.");
 
@@ -111,12 +128,13 @@
 
   itr->second.m_target       = src.m_target;
 
   // This _should_ be optimized int just one assignment.
   switch (itr->second.m_target) {
   case target_generic:  itr->second.m_genericSlot  = src.m_genericSlot; break;
+  case target_any:      itr->second.m_anySlot      = src.m_anySlot; break;
   case target_download: itr->second.m_downloadSlot = src.m_downloadSlot; break;
   case target_file:     itr->second.m_fileSlot     = src.m_fileSlot; break;
   case target_peer:     itr->second.m_peerSlot     = src.m_peerSlot; break;
   case target_tracker:  itr->second.m_trackerSlot  = src.m_trackerSlot; break;
   default: throw torrent::internal_error("CommandMap::insert(...) Invalid target.");
   }
@@ -126,22 +144,43 @@
 CommandMap::call_command(key_type key, const mapped_type& arg, target_type target) {
   const_iterator itr = base_type::find(key);
 
   if (itr == base_type::end())
     throw torrent::input_error("Command \"" + std::string(key) + "\" does not exist.");
 
-  if ((itr->second.m_target != target.first && itr->second.m_target != target_generic) ||
-      (itr->second.m_target != target_generic && target.second == NULL))
+  if ((itr->second.m_target != target.first && itr->second.m_target > target_any) ||
+      (target.second == NULL && itr->second.m_target != target_generic && !(itr->second.m_target == target_any && target.first == target_generic)))
+    throw torrent::input_error("Command type mis-match.");
+
+  // This _should_ be optimized int just two calls.
+  switch (itr->second.m_target) {
+  case target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
+  case target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
+  case target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
+  case target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
+  case target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
+  case target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
+  case target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
+  default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
+  }
+}
+
+const CommandMap::mapped_type
+CommandMap::call_command(const_iterator itr, const mapped_type& arg, target_type target) {
+  if ((itr->second.m_target != target.first && itr->second.m_target > target_any) ||
+      (target.second == NULL && itr->second.m_target != target_generic && !(itr->second.m_target == target_any && target.first == target_generic)))
     throw torrent::input_error("Command type mis-match.");
 
   // This _should_ be optimized int just two calls.
   switch (itr->second.m_target) {
-  case target_generic:  return itr->second.m_genericSlot(itr->second.m_variable, arg);
+  case target_generic:  return itr->second.m_genericSlot (itr->second.m_variable, arg);
+  case target_any:      return itr->second.m_anySlot     (itr->second.m_variable, target, arg);
   case target_download: return itr->second.m_downloadSlot(itr->second.m_variable, (core::Download*)target.second, arg);
-  case target_file:     return itr->second.m_fileSlot(itr->second.m_variable, (torrent::File*)target.second, arg);
-  case target_peer:     return itr->second.m_peerSlot(itr->second.m_variable, (torrent::Peer*)target.second, arg);
-  case target_tracker:  return itr->second.m_trackerSlot(itr->second.m_variable, (torrent::Tracker*)target.second, arg);
+  case target_peer:     return itr->second.m_peerSlot    (itr->second.m_variable, (torrent::Peer*)target.second, arg);
+  case target_tracker:  return itr->second.m_trackerSlot (itr->second.m_variable, (torrent::Tracker*)target.second, arg);
+  case target_file:     return itr->second.m_fileSlot    (itr->second.m_variable, (torrent::File*)target.second, arg);
+  case target_file_itr: return itr->second.m_fileItrSlot (itr->second.m_variable, (torrent::FileListIterator*)target.second, arg);
   default: throw torrent::internal_error("CommandMap::call_command(...) Invalid target.");
   }
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_map.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_map.h	2007-08-17 00:50:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_map.h	2007-08-31 18:52:18.000000000 +0800
@@ -39,49 +39,58 @@
 
 #include <map>
 #include <string>
 #include <cstring>
 #include <torrent/object.h>
 
+#include "command.h"
+
 namespace core {
   class Download;
 }
 
 namespace torrent {
   class File;
+  class FileListIterator;
   class Peer;
   class Tracker;
 }
 
 namespace rpc {
 
-class Command;
-
 struct command_map_comp : public std::binary_function<const char*, const char*, bool> {
   bool operator () (const char* arg1, const char* arg2) const { return std::strcmp(arg1, arg2) < 0; }
 };
 
 struct command_map_data_type {
   // Some commands will need to share data, like get/set a variable. So
   // instead of using a single virtual member function, each command
   // will register a member function pointer to be used instead.
-  typedef const torrent::Object (*generic_slot) (Command*, const torrent::Object&);
-  typedef const torrent::Object (*download_slot)(Command*, core::Download*, const torrent::Object&);
-  typedef const torrent::Object (*file_slot)    (Command*, torrent::File*, const torrent::Object&);
-  typedef const torrent::Object (*peer_slot)    (Command*, torrent::Peer*, const torrent::Object&);
-  typedef const torrent::Object (*tracker_slot) (Command*, torrent::Tracker*, const torrent::Object&);
+  //
+  // The any_slot should perhaps replace generic_slot?
+  typedef const torrent::Object (*generic_slot)  (Command*, const torrent::Object&);
+  typedef const torrent::Object (*any_slot)      (Command*, target_type, const torrent::Object&);
+  typedef const torrent::Object (*download_slot) (Command*, core::Download*, const torrent::Object&);
+  typedef const torrent::Object (*file_slot)     (Command*, torrent::File*, const torrent::Object&);
+  typedef const torrent::Object (*file_itr_slot) (Command*, torrent::FileListIterator*, const torrent::Object&);
+  typedef const torrent::Object (*peer_slot)     (Command*, torrent::Peer*, const torrent::Object&);
+  typedef const torrent::Object (*tracker_slot)  (Command*, torrent::Tracker*, const torrent::Object&);
 
   command_map_data_type(Command* variable, int flags, const char* parm, const char* doc) :
     m_variable(variable), m_flags(flags), m_parm(parm), m_doc(doc) {}
 
+  int                 target() const { return m_target; }
+
   Command*      m_variable;
 
   union {
     generic_slot  m_genericSlot;
+    any_slot      m_anySlot;
     download_slot m_downloadSlot;
     file_slot     m_fileSlot;
+    file_itr_slot m_fileItrSlot;
     peer_slot     m_peerSlot;
     tracker_slot  m_trackerSlot;
   };
 
   int           m_flags;
   int           m_target;
@@ -92,35 +101,38 @@
 
 class CommandMap : public std::map<const char*, command_map_data_type, command_map_comp> {
 public:
   typedef std::map<const char*, command_map_data_type, command_map_comp> base_type;
 
   typedef command_map_data_type::generic_slot  generic_slot;
+  typedef command_map_data_type::any_slot      any_slot;
   typedef command_map_data_type::download_slot download_slot;
   typedef command_map_data_type::file_slot     file_slot;
+  typedef command_map_data_type::file_itr_slot file_itr_slot;
   typedef command_map_data_type::peer_slot     peer_slot;
   typedef command_map_data_type::tracker_slot  tracker_slot;
 
   typedef torrent::Object         mapped_type;
   typedef mapped_type::value_type mapped_value_type;
 
   using base_type::iterator;
+  using base_type::const_iterator;
   using base_type::key_type;
   using base_type::value_type;
 
   using base_type::begin;
   using base_type::end;
   using base_type::find;
 
-  typedef std::pair<int, void*> target_type;
-
   static const int target_generic  = 0;
-  static const int target_download = 1;
-  static const int target_file     = 2;
+  static const int target_any      = 1;
+  static const int target_download = 2;
   static const int target_peer     = 3;
   static const int target_tracker  = 4;
+  static const int target_file     = 5;
+  static const int target_file_itr = 6;
 
   static const int flag_dont_delete   = 0x1;
   static const int flag_public_xmlrpc = 0x2;
 
   CommandMap() {}
   ~CommandMap();
@@ -128,27 +140,39 @@
   bool                has(const char* key) const        { return base_type::find(key) != base_type::end(); }
   bool                has(const std::string& key) const { return has(key.c_str()); }
 
   iterator            insert(key_type key, Command* variable, int flags, const char* parm, const char* doc);
 
   void                insert_generic (key_type key, Command* variable, generic_slot targetSlot,  int flags, const char* parm, const char* doc);
+  void                insert_any     (key_type key, Command* variable, any_slot     targetSlot,  int flags, const char* parm, const char* doc);
   void                insert_download(key_type key, Command* variable, download_slot targetSlot, int flags, const char* parm, const char* doc);
-  void                insert_file    (key_type key, Command* variable, file_slot targetSlot,     int flags, const char* parm, const char* doc);
   void                insert_peer    (key_type key, Command* variable, peer_slot targetSlot,     int flags, const char* parm, const char* doc);
   void                insert_tracker (key_type key, Command* variable, tracker_slot targetSlot,  int flags, const char* parm, const char* doc);
+  void                insert_file    (key_type key, Command* variable, file_slot targetSlot,     int flags, const char* parm, const char* doc);
+  void                insert_file_itr(key_type key, Command* variable, file_itr_slot targetSlot, int flags, const char* parm, const char* doc);
 
   void                insert(key_type key, const command_map_data_type src);
 
-  const mapped_type   call_command(key_type key, const mapped_type& arg, target_type target = target_type((int)target_generic, NULL));
+  const mapped_type   call_command  (key_type key,       const mapped_type& arg, target_type target = target_type((int)target_generic, NULL));
+  const mapped_type   call_command  (const_iterator itr, const mapped_type& arg, target_type target = target_type((int)target_generic, NULL));
+
   const mapped_type   call_command_d(key_type key, core::Download* download, const mapped_type& arg)  { return call_command(key, arg, target_type((int)target_download, download)); }
-  const mapped_type   call_command_f(key_type key, torrent::File* file, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_file, file)); }
   const mapped_type   call_command_p(key_type key, torrent::Peer* peer, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_peer, peer)); }
   const mapped_type   call_command_t(key_type key, torrent::Tracker* tracker, const mapped_type& arg) { return call_command(key, arg, target_type((int)target_tracker, tracker)); }
+  const mapped_type   call_command_f(key_type key, torrent::File* file, const mapped_type& arg)       { return call_command(key, arg, target_type((int)target_file, file)); }
 
 private:
   CommandMap(const CommandMap&);
   void operator = (const CommandMap&);
 };
 
+inline target_type make_target()                                  { return target_type((int)CommandMap::target_generic, NULL); }
+inline target_type make_target(core::Download* target)            { return target_type((int)CommandMap::target_download, target); }
+inline target_type make_target(torrent::Peer* target)             { return target_type((int)CommandMap::target_peer, target); }
+inline target_type make_target(torrent::Tracker* target)          { return target_type((int)CommandMap::target_tracker, target); }
+inline target_type make_target(torrent::File* target)             { return target_type((int)CommandMap::target_file, target); }
+inline target_type make_target(torrent::FileListIterator* target) { return target_type((int)CommandMap::target_file_itr, target); }
+inline target_type make_target(int type, void* target)            { return target_type(type, target); }
+
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_peer_slot.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_peer_slot.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_slot.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_slot.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_slot.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_slot.cc	2007-09-01 21:40:55.000000000 +0800
@@ -33,48 +33,104 @@
 //
 //           Skomakerveien 33
 //           3185 Skoppum, NORWAY
 
 #include "config.h"
 
+#include "core/download.h"
 #include "parse.h"
 
 #include "command_slot.h"
 
 namespace rpc {
 
+template <typename Target> const torrent::Object
+CommandSlot<Target>::call_unknown(Command* rawCommand, Target target, const torrent::Object& rawArgs) {
+  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
+
+  return command->m_slot(target, rawArgs);
+}
+
 const torrent::Object
-CommandSlot::call_unknown(Command* rawCommand, const torrent::Object& rawArgs) {
+CommandSlot<void>::call_unknown(Command* rawCommand, const torrent::Object& rawArgs) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   return command->m_slot(rawArgs);
 }
 
+template <typename Target> const torrent::Object
+CommandSlot<Target>::call_list(Command* rawCommand, Target target, const torrent::Object& rawArgs) {
+  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
+
+  switch (rawArgs.type()) {
+  case torrent::Object::TYPE_LIST:
+    return command->m_slot(target, rawArgs);
+
+  case torrent::Object::TYPE_VALUE:
+  case torrent::Object::TYPE_STRING:
+  case torrent::Object::TYPE_NONE:
+  {
+    torrent::Object tmpList(torrent::Object::TYPE_LIST);
+    tmpList.as_list().push_back(rawArgs);
+
+    return command->m_slot(target, tmpList);
+  }
+  default:
+    throw torrent::input_error("Not a list.");
+  }
+}
+
 const torrent::Object
-CommandSlot::call_list(Command* rawCommand, const torrent::Object& rawArgs) {
+CommandSlot<void>::call_list(Command* rawCommand, const torrent::Object& rawArgs) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   switch (rawArgs.type()) {
   case torrent::Object::TYPE_LIST:
     return command->m_slot(rawArgs);
 
   case torrent::Object::TYPE_VALUE:
   case torrent::Object::TYPE_STRING:
+  case torrent::Object::TYPE_NONE:
   {
     torrent::Object tmpList(torrent::Object::TYPE_LIST);
     tmpList.as_list().push_back(rawArgs);
 
     return command->m_slot(tmpList);
   }
   default:
     throw torrent::input_error("Not a list.");
   }
 }
 
+template <typename Target> const torrent::Object
+CommandSlot<Target>::call_value_base(Command* rawCommand, Target target, const torrent::Object& rawArgs, int base, int unit) {
+  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
+
+  const torrent::Object& arg = convert_to_single_argument(rawArgs);
+
+  switch (arg.type()) {
+  case torrent::Object::TYPE_VALUE:
+    // Should shift this one too, so it gives the right unit.
+    return command->m_slot(target, arg);
+
+  case torrent::Object::TYPE_STRING:
+  {
+    torrent::Object argValue(torrent::Object::TYPE_VALUE);
+
+    if (!parse_whole_value_nothrow(arg.as_string().c_str(), &argValue.as_value(), base, unit))
+      throw torrent::input_error("Not a value.");
+
+    return command->m_slot(target, argValue);
+  }
+  default:
+    throw torrent::input_error("Not a value.");
+  }
+}
+
 const torrent::Object
-CommandSlot::call_value_base(Command* rawCommand, const torrent::Object& rawArgs, int base, int unit) {
+CommandSlot<void>::call_value_base(Command* rawCommand, const torrent::Object& rawArgs, int base, int unit) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
   case torrent::Object::TYPE_VALUE:
@@ -92,14 +148,33 @@
   }
   default:
     throw torrent::input_error("Not a value.");
   }
 }
 
+template <typename Target> const torrent::Object
+CommandSlot<Target>::call_string(Command* rawCommand, Target target, const torrent::Object& rawArgs) {
+  CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
+
+  const torrent::Object& arg = convert_to_single_argument(rawArgs);
+
+  switch (arg.type()) {
+//   case torrent::Object::TYPE_VALUE:
+//     break;
+
+  case torrent::Object::TYPE_STRING:
+    return command->m_slot(target, arg);
+    break;
+
+  default:
+    throw torrent::input_error("Not a string.");
+  }
+}
+
 const torrent::Object
-CommandSlot::call_string(Command* rawCommand, const torrent::Object& rawArgs) {
+CommandSlot<void>::call_string(Command* rawCommand, const torrent::Object& rawArgs) {
   CommandSlot* command = static_cast<CommandSlot*>(rawCommand);
 
   const torrent::Object& arg = convert_to_single_argument(rawArgs);
 
   switch (arg.type()) {
 //   case torrent::Object::TYPE_VALUE:
@@ -111,7 +186,34 @@
 
   default:
     throw torrent::input_error("Not a string.");
   }
 }
 
+torrent::Object
+set_variable_d_fn_t::operator () (core::Download* download, const torrent::Object& arg1) {
+  if (m_firstKey == NULL)
+    download->bencode()->get_key(m_secondKey) = arg1;
+  else
+    download->bencode()->get_key(m_firstKey).get_key(m_secondKey) = arg1;
+
+  return torrent::Object();
+}
+
+torrent::Object
+get_variable_d_fn_t::operator () (core::Download* download, const torrent::Object& arg1) {
+  if (m_firstKey == NULL)
+    return download->bencode()->get_key(m_secondKey);
+  else
+    return download->bencode()->get_key(m_firstKey).get_key(m_secondKey);
+}
+
+// Initialize the necessary template classes.
+template class CommandSlot<void>;
+template class CommandSlot<target_type>;
+template class CommandSlot<core::Download*>;
+template class CommandSlot<torrent::File*>;
+template class CommandSlot<torrent::FileListIterator*>;
+template class CommandSlot<torrent::Peer*>;
+template class CommandSlot<torrent::Tracker*>;
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_slot.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_slot.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/command_slot.h	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/command_slot.h	2007-09-07 03:16:34.000000000 +0800
@@ -42,30 +42,64 @@
 #include <inttypes.h>
 #include <torrent/object.h>
 #include <rak/functional_fun.h>
 
 #include "command.h"
 
+namespace core {
+  class Download;
+}
+
+namespace torrent {
+  class File;
+  class FileListIterator;
+  class Peer;
+  class Tracker;
+}
+
 namespace rpc {
 
+template <typename Target>
 class CommandSlot : public Command {
 public:
-  typedef rak::function1<torrent::Object, const torrent::Object&> slot_type;
+  typedef rak::function2<torrent::Object, Target, const torrent::Object&> slot_type;
 
-//   template <typename SlotSet>
-//   CommandSlot(SlotSet* slotSet) {
-//     m_slotSet.set(slotSet);
-//   }
-  
   CommandSlot() {}
+  CommandSlot(typename slot_type::base_type* s) { m_slot.set(s); }
+
+  void                         set_slot(typename slot_type::base_type* s) { m_slot.set(s); }
+
+  static const torrent::Object call_unknown(Command* rawCommand, Target target, const torrent::Object& args);
+
+  static const torrent::Object call_list(Command* rawCommand, Target target, const torrent::Object& args);
+  static const torrent::Object call_string(Command* rawCommand, Target target, const torrent::Object& args);
+
+  static const torrent::Object call_value_base(Command* rawCommand, Target target, const torrent::Object& args, int base, int unit);
+
+  static const torrent::Object call_value(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, 0, 1); }
+  static const torrent::Object call_value_kb(Command* rawCommand, Target target, const torrent::Object& args)  { return call_value_base(rawCommand, target, args, 0, 1 << 10); }
+  static const torrent::Object call_value_oct(Command* rawCommand, Target target, const torrent::Object& args) { return call_value_base(rawCommand, target, args, 8, 1); }
+
+  template <int base, int unit>
+  static const torrent::Object call_value(Command* rawCommand, Target target, const torrent::Object& args)     { return call_value_base(rawCommand, target, args, base, unit); }
+
+//   static const torrent::Object& get_list(Command* rawCommand, const torrent::Object& args);
+
+private:
+  slot_type           m_slot;
+};
+
+template <>
+class CommandSlot<void> : public Command {
+public:
+  typedef rak::function1<torrent::Object, const torrent::Object&> slot_type;
 
-  CommandSlot(slot_type::base_type* s) {
-    m_slot.set(s);
-  }
+  CommandSlot() {}
+  CommandSlot(slot_type::base_type* s) { m_slot.set(s); }
 
-  void                set_slot(slot_type::base_type* s) { m_slot.set(s); }
+  void                         set_slot(slot_type::base_type* s) { m_slot.set(s); }
 
   static const torrent::Object call_unknown(Command* rawCommand, const torrent::Object& args);
 
   static const torrent::Object call_list(Command* rawCommand, const torrent::Object& args);
   static const torrent::Object call_string(Command* rawCommand, const torrent::Object& args);
 
@@ -73,104 +107,197 @@
 
   static const torrent::Object call_value(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, 0, 1); }
   static const torrent::Object call_value_kb(Command* rawCommand, const torrent::Object& args)  { return call_value_base(rawCommand, args, 0, 1 << 10); }
   static const torrent::Object call_value_oct(Command* rawCommand, const torrent::Object& args) { return call_value_base(rawCommand, args, 8, 1); }
 
   template <int base, int unit>
-  static const torrent::Object call_value(Command* rawCommand, const torrent::Object& args)  { return call_value_base(rawCommand, args, base, unit); }
+  static const torrent::Object call_value(Command* rawCommand, const torrent::Object& args)     { return call_value_base(rawCommand, args, base, unit); }
 
 //   static const torrent::Object& get_list(Command* rawCommand, const torrent::Object& args);
 
 private:
   slot_type           m_slot;
 };
 
 // Some slots that convert torrent::Object arguments to proper
 // function calls.
 
-template <typename Func, typename Result = typename Func::result_type>
-class object_void_fn_t : public rak::function_base1<torrent::Object, const torrent::Object&> {
+template <typename Target, typename Func, typename Result = typename Func::result_type>
+class object_void_fn_t : public rak::function_base2<torrent::Object, Target, const torrent::Object&> {
+public:
+  object_void_fn_t(Func func) : m_func(func) {}
+  
+  virtual torrent::Object operator () (Target target, const torrent::Object& arg1) { return torrent::Object(m_func(target)); }
+
+private:
+  Func m_func;
+};
+
+template <typename Target, typename Func>
+class object_void_fn_t<Target, Func, void> : public rak::function_base2<torrent::Object, Target, const torrent::Object&> {
+public:
+  object_void_fn_t(Func func) : m_func(func) {}
+  
+  virtual torrent::Object operator () (Target target, const torrent::Object& arg1) { m_func(target); return torrent::Object(); }
+
+private:
+  Func m_func;
+};
+
+template <typename Func, typename Result>
+class object_void_fn_t<void, Func, Result> : public rak::function_base1<torrent::Object, const torrent::Object&> {
 public:
   object_void_fn_t(Func func) : m_func(func) {}
   
   virtual torrent::Object operator () (const torrent::Object& arg1) { return torrent::Object(m_func()); }
 
 private:
   Func m_func;
 };
 
 template <typename Func>
-class object_void_fn_t<Func, void> : public rak::function_base1<torrent::Object, const torrent::Object&> {
+class object_void_fn_t<void, Func, void> : public rak::function_base1<torrent::Object, const torrent::Object&> {
 public:
   object_void_fn_t(Func func) : m_func(func) {}
   
-  virtual torrent::Object operator () (const torrent::Object& arg1) {
-    m_func();
-    return torrent::Object();
-  }
+  virtual torrent::Object operator () (const torrent::Object& arg1) { m_func(); return torrent::Object(); }
 
 private:
   Func m_func;
 };
 
-template <typename Func, typename Result = typename Func::result_type>
-class object_value_fn1_t : public rak::function_base1<torrent::Object, const torrent::Object&> {
+template <typename Target, typename Func, typename Result = typename Func::result_type>
+class object_value_fn_t : public rak::function_base2<torrent::Object, Target, const torrent::Object&> {
 public:
-  object_value_fn1_t(Func func) : m_func(func) {}
+  object_value_fn_t(Func func) : m_func(func) {}
+  
+  virtual torrent::Object operator () (Target target, const torrent::Object& arg1) { return torrent::Object((int64_t)m_func(target, arg1.as_value())); }
+
+private:
+  Func m_func;
+};
+
+template <typename Target, typename Func>
+class object_value_fn_t<Target, Func, void> : public rak::function_base2<torrent::Object, Target, const torrent::Object&> {
+public:
+  object_value_fn_t(Func func) : m_func(func) {}
+  
+  virtual torrent::Object operator () (Target target, const torrent::Object& arg1) { m_func(target, arg1.as_value()); return torrent::Object(); }
+
+private:
+  Func m_func;
+};
+
+template <typename Func, typename Result>
+class object_value_fn_t<void, Func, Result> : public rak::function_base1<torrent::Object, const torrent::Object&> {
+public:
+  object_value_fn_t(Func func) : m_func(func) {}
   
   virtual torrent::Object operator () (const torrent::Object& arg1) { return torrent::Object((int64_t)m_func(arg1.as_value())); }
 
 private:
   Func m_func;
 };
 
 template <typename Func>
-class object_value_fn1_t<Func, void> : public rak::function_base1<torrent::Object, const torrent::Object&> {
+class object_value_fn_t<void, Func, void> : public rak::function_base1<torrent::Object, const torrent::Object&> {
 public:
-  object_value_fn1_t(Func func) : m_func(func) {}
+  object_value_fn_t(Func func) : m_func(func) {}
   
-  virtual torrent::Object operator () (const torrent::Object& arg1) {
-    m_func(arg1.as_value());
+  virtual torrent::Object operator () (const torrent::Object& arg1) { m_func(arg1.as_value()); return torrent::Object(); }
+
+private:
+  Func m_func;
+};
 
-    return torrent::Object();
-  }
+template <typename Target, typename Func, typename Result = typename Func::result_type>
+class object_string_fn_t : public rak::function_base2<torrent::Object, Target, const torrent::Object&> {
+public:
+  object_string_fn_t(Func func) : m_func(func) {}
+  
+  virtual torrent::Object operator () (Target target, const torrent::Object& arg1) { return torrent::Object(m_func(target, arg1.as_string())); }
 
 private:
   Func m_func;
 };
 
-template <typename Func, typename Result = typename Func::result_type>
-class object_string_fn1_t : public rak::function_base1<torrent::Object, const torrent::Object&> {
+template <typename Target, typename Func>
+class object_string_fn_t<Target, Func, void> : public rak::function_base2<torrent::Object, Target, const torrent::Object&> {
 public:
-  object_string_fn1_t(Func func) : m_func(func) {}
+  object_string_fn_t(Func func) : m_func(func) {}
+  
+  virtual torrent::Object operator () (Target target, const torrent::Object& arg1) { m_func(target, arg1.as_string()); return torrent::Object(); }
+
+private:
+  Func m_func;
+};
+
+template <typename Func, typename Result>
+class object_string_fn_t<void, Func, Result> : public rak::function_base1<torrent::Object, const torrent::Object&> {
+public:
+  object_string_fn_t(Func func) : m_func(func) {}
   
   virtual torrent::Object operator () (const torrent::Object& arg1) { return torrent::Object(m_func(arg1.as_string())); }
 
 private:
   Func m_func;
 };
 
 template <typename Func>
-class object_string_fn1_t<Func, void> : public rak::function_base1<torrent::Object, const torrent::Object&> {
+class object_string_fn_t<void, Func, void> : public rak::function_base1<torrent::Object, const torrent::Object&> {
 public:
-  object_string_fn1_t(Func func) : m_func(func) {}
+  object_string_fn_t(Func func) : m_func(func) {}
   
-  virtual torrent::Object operator () (const torrent::Object& arg1) {
-    m_func(arg1.as_string());
-
-    return torrent::Object();
-  }
+  virtual torrent::Object operator () (const torrent::Object& arg1) { m_func(arg1.as_string()); return torrent::Object(); }
 
 private:
   Func m_func;
 };
 
-template <typename Return> object_void_fn_t<Return (*)(void), Return>* object_fn(Return (*func)(void)) { return new object_void_fn_t<Return (*)(void), Return>(func); }
+// Add more of these helpers.
+template <typename Target, typename Return> object_void_fn_t<Target, Return (*)(Target), Return>*
+object_fn(Return (*func)(Target)) { return new object_void_fn_t<Target, Return (*)(Target), Return>(func); }
+template <typename Return> object_void_fn_t<void, Return (*)(), Return>*
+object_fn(Return (*func)()) { return new object_void_fn_t<void, Return (*)(), Return>(func); }
+
+template <typename Target, typename Return> object_void_fn_t<Target, Return (*)(Target), Return>*
+object_void_fn(Return (*func)(Target)) { return new object_void_fn_t<Target, Return (*)(Target), Return>(func); }
+template <typename Return> object_void_fn_t<void, Return (*)(), Return>*
+object_void_fn(Return (*func)()) { return new object_void_fn_t<void, Return (*)(), Return>(func); }
+
+template <typename Func>                  object_void_fn_t<void, Func>*      object_void_fn(Func func)    { return new object_void_fn_t<void, Func>(func); }
+template <typename Target, typename Func> object_void_fn_t<Target, Func>*    object_void_fn(Func func)    { return new object_void_fn_t<Target, Func>(func); }
+template <typename Func>                  object_value_fn_t<void, Func>*     object_value_fn(Func func)   { return new object_value_fn_t<void, Func>(func); }
+template <typename Target, typename Func> object_value_fn_t<Target, Func>*   object_value_fn(Func func)   { return new object_value_fn_t<Target, Func>(func); }
+template <typename Func>                  object_string_fn_t<void, Func>*    object_string_fn(Func func)  { return new object_string_fn_t<void, Func>(func); }
+template <typename Target, typename Func> object_string_fn_t<Target, Func>*  object_string_fn(Func func)  { return new object_string_fn_t<Target, Func>(func); }
+
+class set_variable_d_fn_t : public rak::function_base2<torrent::Object, core::Download*, const torrent::Object&> {
+public:
+  set_variable_d_fn_t(const char* firstKey, const char* secondKey) : m_firstKey(firstKey), m_secondKey(secondKey) {}
+  
+  virtual torrent::Object operator () (core::Download* download, const torrent::Object& arg1);
+
+private:
+  const char*         m_firstKey;
+  const char*         m_secondKey;
+};
+
+class get_variable_d_fn_t : public rak::function_base2<torrent::Object, core::Download*, const torrent::Object&> {
+public:
+  get_variable_d_fn_t(const char* firstKey, const char* secondKey) : m_firstKey(firstKey), m_secondKey(secondKey) {}
+  
+  virtual torrent::Object operator () (core::Download* download, const torrent::Object& arg1);
+
+private:
+  const char*         m_firstKey;
+  const char*         m_secondKey;
+};
 
-template <typename Func> object_void_fn_t<Func>*    object_void_fn(Func func)       { return new object_void_fn_t<Func>(func); }
-  //template <typename Func> object_void_fn_t<Func>*    object_void_value_fn(Func func) { return new object_void_fn_t<Func, int64_t>(func); }
-template <typename Func> object_value_fn1_t<Func>*  object_value_fn(Func func)      { return new object_value_fn1_t<Func>(func); }
-template <typename Func> object_string_fn1_t<Func>* object_string_fn(Func func)     { return new object_string_fn1_t<Func>(func); }
+inline set_variable_d_fn_t*
+set_variable_d_fn(const char* firstKey, const char* secondKey) { return new set_variable_d_fn_t(firstKey, secondKey); }
+inline get_variable_d_fn_t*
+get_variable_d_fn(const char* firstKey, const char* secondKey) { return new get_variable_d_fn_t(firstKey, secondKey); }
 
 }
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_tracker_slot.cc
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc: command_tracker_slot.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.am	2007-08-17 01:14:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/Makefile.am	2007-09-01 21:28:34.000000000 +0800
@@ -1,18 +1,10 @@
 noinst_LIBRARIES = libsub_rpc.a
 
 libsub_rpc_a_SOURCES = \
 	command.h \
-	command_download_slot.cc \
-	command_download_slot.h \
-	command_file_slot.cc \
-	command_file_slot.h \
-	command_peer_slot.cc \
-	command_peer_slot.h \
-	command_tracker_slot.cc \
-	command_tracker_slot.h \
 	command_map.cc \
 	command_map.h \
 	command_scheduler.cc \
 	command_scheduler.h \
 	command_scheduler_item.cc \
 	command_scheduler_item.h \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/Makefile.in	2007-08-17 01:14:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/Makefile.in	2007-09-01 21:28:45.000000000 +0800
@@ -48,15 +48,13 @@
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 libsub_rpc_a_AR = $(AR) $(ARFLAGS)
 libsub_rpc_a_LIBADD =
-am_libsub_rpc_a_OBJECTS = command_download_slot.$(OBJEXT) \
-	command_file_slot.$(OBJEXT) command_peer_slot.$(OBJEXT) \
-	command_tracker_slot.$(OBJEXT) command_map.$(OBJEXT) \
+am_libsub_rpc_a_OBJECTS = command_map.$(OBJEXT) \
 	command_scheduler.$(OBJEXT) command_scheduler_item.$(OBJEXT) \
 	command_slot.$(OBJEXT) command_variable.$(OBJEXT) \
 	exec_file.$(OBJEXT) parse.$(OBJEXT) parse_commands.$(OBJEXT) \
 	scgi.$(OBJEXT) scgi_task.$(OBJEXT) xmlrpc.$(OBJEXT)
 libsub_rpc_a_OBJECTS = $(am_libsub_rpc_a_OBJECTS)
 DEFAULT_INCLUDES = -I. -I$(srcdir) -I$(top_builddir)
@@ -187,20 +185,12 @@
 sharedstatedir = @sharedstatedir@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 noinst_LIBRARIES = libsub_rpc.a
 libsub_rpc_a_SOURCES = \
 	command.h \
-	command_download_slot.cc \
-	command_download_slot.h \
-	command_file_slot.cc \
-	command_file_slot.h \
-	command_peer_slot.cc \
-	command_peer_slot.h \
-	command_tracker_slot.cc \
-	command_tracker_slot.h \
 	command_map.cc \
 	command_map.h \
 	command_scheduler.cc \
 	command_scheduler.h \
 	command_scheduler_item.cc \
 	command_scheduler_item.h \
@@ -266,20 +256,16 @@
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
 
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_download_slot.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_file_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_map.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_peer_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_scheduler_item.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_slot.Po@am__quote@
-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_tracker_slot.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/command_variable.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/exec_file.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parse_commands.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scgi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/scgi_task.Po@am__quote@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.cc	2007-08-11 19:56:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse.cc	2007-08-20 09:21:03.000000000 +0800
@@ -386,7 +386,44 @@
 
   default:
     throw torrent::input_error("Invalid type.");
   }
 }
 
+void
+print_object_std(std::string* dest, const torrent::Object* src, int flags) {
+  switch (src->type()) {
+  case torrent::Object::TYPE_STRING:
+  {
+    const std::string& str = src->as_string();
+
+    if ((flags & print_expand_tilde) && *str.c_str() == '~')
+      *dest += rak::path_expand(str);
+    else
+      *dest += str;
+
+    return;
+  }
+  case torrent::Object::TYPE_VALUE:
+  {
+    char buffer[64];
+    snprintf(buffer, 64, "%lli", src->as_value());
+
+    *dest += buffer;
+    return;
+  }
+  case torrent::Object::TYPE_LIST:
+    for (torrent::Object::list_type::const_iterator itr = src->as_list().begin(), itrEnd = src->as_list().end(); itr != itrEnd; itr++) {
+      print_object_std(dest, &*itr, flags);
+
+      // Don't expand tilde after the first element in the list.
+      flags &= ~print_expand_tilde;
+    }
+
+    return;
+
+  default:
+    throw torrent::input_error("Invalid type.");
+  }
+}
+
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse_commands.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.cc	2007-08-13 03:47:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse_commands.cc	2007-09-07 04:13:33.000000000 +0800
@@ -79,28 +79,34 @@
 
 // Replace any strings starting with '$' with the result of the
 // result of the command.
 //
 // Find a better name.
 void
-parse_command_execute(core::Download* download, torrent::Object* object) {
+parse_command_execute(target_type target, torrent::Object* object) {
   if (object->is_list()) {
-    for (torrent::Object::list_type::iterator itr = object->as_list().begin(), last = object->as_list().end(); itr != last; itr++)
-      parse_command_execute(download, &*itr);
+    // For now, until we can flag the lists we want executed and those
+    // we can't, disable recursion completely.
+    for (torrent::Object::list_type::iterator itr = object->as_list().begin(), last = object->as_list().end(); itr != last; itr++) {
+      if (itr->is_list())
+        continue;
+
+      parse_command_execute(target, &*itr);
+    }
 
   } else if (*object->as_string().c_str() == '$') {
     const std::string& str = object->as_string();
 
-    *object = parse_command_d_single(download, str.c_str() + 1, str.c_str() + str.size());
+    *object = parse_command(target, str.c_str() + 1, str.c_str() + str.size()).first;
   }
 }
 
 // Set 'download' to NULL to call the generic functions, thus reusing
 // the code below for both cases.
-std::pair<torrent::Object, const char*>
-parse_command(core::Download* download, const char* first, const char* last) {
+parse_command_type
+parse_command(target_type target, const char* first, const char* last) {
   first = std::find_if(first, last, std::not1(command_map_is_space()));
 
   if (first == last || *first == '#')
     return std::make_pair(torrent::Object(), first);
   
   std::string key;
@@ -124,36 +130,31 @@
 
     first++;
   }
 
   // Replace any strings starting with '$' with the result of the
   // following command.
-  parse_command_execute(download, &args);
-
-  return std::make_pair(commands.call_command_d(key.c_str(), download, args), first);
-}
+  parse_command_execute(target, &args);
 
-void
-parse_command_single(const char* first) {
-  parse_command(NULL, first, first + std::strlen(first));
+  return std::make_pair(commands.call_command(key.c_str(), args, target), first);
 }
 
 void
-parse_command_multiple(core::Download* download, const char* first, const char* last) {
+parse_command_multiple(target_type target, const char* first, const char* last) {
   while (first != last) {
     // Should we check the return value? Probably not necessary as
     // parse_args throws on unquoted multi-word input.
-    std::pair<torrent::Object, const char*> result = parse_command(download, first, last);
+    parse_command_type result = parse_command(target, first, last);
 
     first = result.second;
   }
 }
 
-void
-parse_command_d_multiple(core::Download* download, const char* first) {
-  parse_command_multiple(download, first, first + std::strlen(first));
+parse_command_type
+parse_command_object(target_type target, const torrent::Object& object) {
+  return parse_command(target, object.as_string().c_str(), object.as_string().c_str() + object.as_string().size());
 }
 
 bool
 parse_command_file(const std::string& path) {
   std::fstream file(rak::path_expand(path).c_str(), std::ios::in);
 
@@ -163,32 +164,40 @@
   unsigned int lineNumber = 0;
   char buffer[4096];
 
   try {
     unsigned int getCount = 0;
 
-    while (file.getline(buffer + getCount, 4096 - getCount).good()) {
+    while (file.good()
+           && !file.getline(buffer + getCount, 4096 - getCount).fail()) {
+      
       if (file.gcount() == 0)
         throw torrent::internal_error("parse_command_file(...) file.gcount() == 0.");
-
-      int escaped = parse_count_escaped(buffer + getCount, buffer + getCount + file.gcount() - 1);
+      int lineLength = file.gcount() - 1;
+      // In case we are at the end of the file and the last character is
+      // not a line feed, we'll just increase the read character count so 
+      // that the last would also be included in option line.
+      if (file.eof() && file.get() != '\n')
+        lineLength++;
+      
+      int escaped = parse_count_escaped(buffer + getCount, buffer + getCount + lineLength);
 
       lineNumber++;
-      getCount += file.gcount() - 1;
+      getCount += lineLength;
 
       if (getCount == 4096 - 1)
-        throw torrent::input_error("Exceeded max line lenght.");
+        throw torrent::input_error("Exceeded max line length.");
       
       if (escaped & 0x1) {
         // Remove the escape characters and continue reading.
         getCount -= escaped;
         continue;
       }
 
       // Would be nice to make this zero-copy.
-      parse_command(NULL, buffer, buffer + getCount);
+      parse_command(make_target(), buffer, buffer + getCount);
       getCount = 0;
     }
 
   } catch (torrent::input_error& e) {
     snprintf(buffer, 2048, "Error in option file: %s:%u: %s", path.c_str(), lineNumber, e.what());
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse_commands.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse_commands.h	2007-08-17 04:05:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse_commands.h	2007-09-07 04:12:43.000000000 +0800
@@ -35,12 +35,13 @@
 //           3185 Skoppum, NORWAY
 
 #ifndef RTORRENT_RPC_PARSE_COMMANDS_H
 #define RTORRENT_RPC_PARSE_COMMANDS_H
 
 #include <string>
+#include <cstring>
 
 #include "command_map.h"
 #include "exec_file.h"
 #include "xmlrpc.h"
 
 namespace core {
@@ -51,60 +52,60 @@
 
 // Move to another file?
 extern CommandMap commands;
 extern XmlRpc     xmlrpc;
 extern ExecFile   execFile;
 
+typedef std::pair<torrent::Object, const char*> parse_command_type;
+
 // The generic parse command function, used by the rest. At some point
 // the 'download' parameter should be replaced by a more generic one.
-std::pair<torrent::Object, const char*> parse_command(core::Download* download, const char* first, const char* last);
-
-void                   parse_command_single(const char* first);
-inline torrent::Object parse_command_single(const char* first, const char* last)                             { return parse_command(NULL, first, last).first; }
-inline torrent::Object parse_command_d_single(core::Download* download, const char* first, const char* last) { return parse_command(download, first, last).first; }
+parse_command_type     parse_command(target_type target, const char* first, const char* last);
+void                   parse_command_multiple(target_type target, const char* first, const char* last);
 
-void                   parse_command_multiple(core::Download* download, const char* first, const char* last);
+// Make this take care of lists too.
+parse_command_type     parse_command_object(target_type target, const torrent::Object& object);
 
-void                   parse_command_d_multiple(core::Download* download, const char* first);
-inline void            parse_command_d_multiple_std(core::Download* download, const std::string& cmd) { parse_command_multiple(download, cmd.c_str(), cmd.c_str() + cmd.size()); }
-inline void            parse_command_multiple(const char* first)                                      { parse_command_d_multiple(NULL, first); }
+inline void            parse_command_single(target_type target, const char* first)   { parse_command(target, first, first + std::strlen(first)); }
+inline void            parse_command_multiple(target_type target, const char* first) { parse_command_multiple(target, first, first + std::strlen(first)); }
 
 bool                   parse_command_file(const std::string& path);
 const char*            parse_command_name(const char* first, const char* last, std::string* dest);
 
 inline void
 parse_command_single_std(const std::string& cmd) {
-  parse_command_single(cmd.c_str(), cmd.c_str() + cmd.size());
+  parse_command(make_target(), cmd.c_str(), cmd.c_str() + cmd.size());
 }
 
 inline void
 parse_command_d_single_std(core::Download* download, const std::string& cmd) {
-  parse_command_d_single(download, cmd.c_str(), cmd.c_str() + cmd.size());
+  parse_command(make_target(download), cmd.c_str(), cmd.c_str() + cmd.size());
 }
 
 inline void
 parse_command_multiple_std(const std::string& cmd) {
-  parse_command_multiple(NULL, cmd.c_str(), cmd.c_str() + cmd.size());
+  parse_command_multiple(make_target(), cmd.c_str(), cmd.c_str() + cmd.size());
+}
+
+inline void
+parse_command_d_multiple_std(core::Download* download, const std::string& cmd) {
+  parse_command_multiple(make_target(download), cmd.c_str(), cmd.c_str() + cmd.size());
 }
 
-inline torrent::Object call_command(const char* key, const torrent::Object& obj) { return commands.call_command(key, obj); }
-inline torrent::Object call_command_void(const char* key)   { return commands.call_command(key, torrent::Object()); }
-inline std::string     call_command_string(const char* key) { return commands.call_command(key, torrent::Object()).as_string(); }
-inline int64_t         call_command_value(const char* key)  { return commands.call_command(key, torrent::Object()).as_value(); }
+// inline torrent::Object call_command(const char* key, const torrent::Object& obj, target_type target = target_type((int)CommandMap::target_generic, NULL)) { return commands.call_command(key, obj); }
+inline torrent::Object call_command       (const char* key, const torrent::Object& obj, target_type target = make_target()) { return commands.call_command(key, obj, target); }
+inline torrent::Object call_command_void  (const char* key, target_type target = make_target()) { return commands.call_command(key, torrent::Object(), target); }
+inline std::string     call_command_string(const char* key, target_type target = make_target()) { return commands.call_command(key, torrent::Object(), target).as_string(); }
+inline int64_t         call_command_value (const char* key, target_type target = make_target()) { return commands.call_command(key, torrent::Object(), target).as_value(); }
 
 inline void            call_command_set_string(const char* key, const std::string& arg)            { commands.call_command(key, torrent::Object(arg)); }
 inline void            call_command_set_std_string(const std::string& key, const std::string& arg) { commands.call_command(key.c_str(), torrent::Object(arg)); }
 
-inline torrent::Object call_command_d(const char* key, core::Download* download, const torrent::Object& obj) { return commands.call_command_d(key, download, obj); }
-inline torrent::Object call_command_d_void(const char* key, core::Download* download)   { return commands.call_command_d(key, download, torrent::Object()); }
-inline std::string     call_command_d_string(const char* key, core::Download* download) { return commands.call_command_d(key, download, torrent::Object()).as_string(); }
-inline int64_t         call_command_d_value(const char* key, core::Download* download)  { return commands.call_command_d(key, download, torrent::Object()).as_value(); }
-
 inline void            call_command_d_v_void(const char* key, core::Download* download) { commands.call_command_d(key, download, torrent::Object()); }
 
-inline void            call_command_d_set_value(const char* key, core::Download* download, int64_t arg)                        { commands.call_command_d(key, download, torrent::Object(arg)); }
+inline void            call_command_set_value(const char* key, int64_t arg, target_type target = make_target())                { commands.call_command(key, torrent::Object(arg), target); }
 inline void            call_command_d_set_string(const char* key, core::Download* download, const std::string& arg)            { commands.call_command_d(key, download, torrent::Object(arg)); }
 inline void            call_command_d_set_std_string(const std::string& key, core::Download* download, const std::string& arg) { commands.call_command_d(key.c_str(), download, torrent::Object(arg)); }
 
 inline torrent::Object
 call_command_d_range(const char* key, core::Download* download, torrent::Object::list_type::const_iterator first, torrent::Object::list_type::const_iterator last) {
   // Change to using range ctor.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/parse.h	2007-08-11 19:53:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/parse.h	2007-08-25 04:55:40.000000000 +0800
@@ -88,10 +88,11 @@
     return args;
 }
 
 static const int print_expand_tilde = 0x1;
 
 char*       print_object(char* first, char* last, const torrent::Object* src, int flags);
+void        print_object_std(std::string* dest, const torrent::Object* src, int flags);
 
 }
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/scgi_task.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.cc	2007-08-16 03:43:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/scgi_task.cc	2007-08-27 21:24:13.000000000 +0800
@@ -94,14 +94,14 @@
 }
 
 void
 SCgiTask::event_read() {
   int bytes = ::recv(m_fileDesc, m_position, m_bufferSize - (m_position - m_buffer), 0);
 
-  if (bytes == -1) {
-    if (!rak::error_number::current().is_blocked_momentary())
+  if (bytes <= 0) {
+    if (bytes == 0 || !rak::error_number::current().is_blocked_momentary())
       close();
 
     return;
   }
 
   // The buffer has space to nul-terminate to ease the parsing below.
@@ -113,16 +113,18 @@
     // receive all the data we need the first time.
     char* current;
 
     int contentSize;
     int headerSize = strtol(m_buffer, &current, 0);
 
-    if (current == m_buffer || current == m_position)
+    if (current == m_position)
       return;
 
-    if (*current != ':' || headerSize < 17 || headerSize > max_header_size)
+    // If the request doesn't start with an integer or if it didn't
+    // end in ':', then close the connection.
+    if (current == m_buffer || *current != ':' || headerSize < 17 || headerSize > max_header_size)
       goto event_read_failed;
 
     if (std::distance(++current, m_position) < headerSize + 1)
       return;
 
     if (std::memcmp(current, "CONTENT_LENGTH", 15) != 0)
@@ -168,13 +170,14 @@
   if (!m_parent->receive_call(this, m_body, m_bufferSize - std::distance(m_buffer, m_body)))
     close();
 
   return;
 
  event_read_failed:
-  throw torrent::internal_error("SCgiTask::event_read() fault not handled.");
+//   throw torrent::internal_error("SCgiTask::event_read() fault not handled.");
+  close();
 }
 
 void
 SCgiTask::event_write() {
   int bytes = ::send(m_fileDesc, m_position, m_bufferSize, 0);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/scgi_task.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/scgi_task.h	2007-08-16 03:35:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/scgi_task.h	2007-08-27 20:54:16.000000000 +0800
@@ -48,13 +48,13 @@
 class SCgi;
 
 class SCgiTask : public torrent::Event {
 public:
   static const unsigned int default_buffer_size = 2047;
   static const          int max_header_size     = 2000;
-  static const          int max_content_size    = (128 << 10);
+  static const          int max_content_size    = (2 << 20);
 
   SCgiTask() { m_fileDesc = -1; }
 
   bool                is_open() const      { return m_fileDesc != -1; }
   bool                is_available() const { return m_fileDesc == -1; }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/xmlrpc.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/xmlrpc.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/xmlrpc.cc	2007-08-17 04:06:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/xmlrpc.cc	2007-08-28 05:10:43.000000000 +0800
@@ -84,13 +84,29 @@
 
     // Urgh, seriously?
     ::free((void*)valueString);
     return result;
   }
 
-    //     case XMLRPC_TYPE_BASE64:
+  case XMLRPC_TYPE_BASE64:
+  {
+    size_t      valueSize;
+    const char* valueString;
+
+    xmlrpc_read_base64(env, value, &valueSize, (const unsigned char**)&valueString);
+
+    if (env->fault_occurred)
+      return torrent::Object();
+
+    torrent::Object result = torrent::Object(std::string(valueString, valueSize));
+
+    // Urgh, seriously?
+    ::free((void*)valueString);
+    return result;
+  }
+
   case XMLRPC_TYPE_ARRAY:
   {
     torrent::Object result(torrent::Object::TYPE_LIST);
     torrent::Object::list_type& listRef = result.as_list();
 
     unsigned int last = xmlrpc_array_size(env, value);
@@ -272,13 +288,13 @@
       if (env->fault_occurred)
         break;
     }
 
     torrent::Object result;
 
-    if (current + 1 > last) {
+    if (current + 1 < last) {
       result = torrent::Object(torrent::Object::TYPE_LIST);
       torrent::Object::list_type& listRef = result.as_list();
 
       // Move this into a helper function?
       while (current != last) {
         xmlrpc_value* tmp;
@@ -354,70 +370,28 @@
     return xmlrpc_int_new(env, 0);
   }
 }
 
 xmlrpc_value*
 xmlrpc_call_command(xmlrpc_env* env, xmlrpc_value* args, void* voidServerInfo) {
-  torrent::Object object = xmlrpc_to_object(env, args);
-
-  if (env->fault_occurred)
-    return NULL;
-
-  try {
-    return object_to_xmlrpc(env, rpc::call_command((const char*)voidServerInfo, object));
+  CommandMap::const_iterator itr = commands.find((const char*)voidServerInfo);
 
-  } catch (torrent::local_error& e) {
-    xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
+  if (itr == commands.end()) {
+    xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, ("Command \"" + std::string((const char*)voidServerInfo) + "\" does not exist.").c_str());
     return NULL;
   }
-}
 
-xmlrpc_value*
-xmlrpc_call_command_d(xmlrpc_env* env, xmlrpc_value* args, void* voidServerInfo) {
-  core::Download* download = NULL;
-  torrent::Object object = xmlrpc_to_object_target(env, args, XmlRpc::call_download, (void**)&download);
+  int   type = itr->second.target();
+  void* target = NULL;
+  torrent::Object object = (type == 0) ? xmlrpc_to_object(env, args) : xmlrpc_to_object_target(env, args, type, &target);
 
   if (env->fault_occurred)
     return NULL;
 
   try {
-    return object_to_xmlrpc(env, rpc::call_command_d((const char*)voidServerInfo, download, object));
-
-  } catch (torrent::local_error& e) {
-    xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
-    return NULL;
-  }
-}
-
-xmlrpc_value*
-xmlrpc_call_command_f(xmlrpc_env* env, xmlrpc_value* args, void* voidServerInfo) {
-  torrent::File*  file = NULL;
-  torrent::Object object = xmlrpc_to_object_target(env, args, XmlRpc::call_file, (void**)&file);
-
-  if (env->fault_occurred)
-    return NULL;
-
-  try {
-    return object_to_xmlrpc(env, rpc::commands.call_command_f((const char*)voidServerInfo, file, object));
-
-  } catch (torrent::local_error& e) {
-    xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
-    return NULL;
-  }
-}
-
-xmlrpc_value*
-xmlrpc_call_command_t(xmlrpc_env* env, xmlrpc_value* args, void* voidServerInfo) {
-  torrent::Tracker* tracker = NULL;
-  torrent::Object   object = xmlrpc_to_object_target(env, args, XmlRpc::call_tracker, (void**)&tracker);
-
-  if (env->fault_occurred)
-    return NULL;
-
-  try {
-    return object_to_xmlrpc(env, rpc::commands.call_command_t((const char*)voidServerInfo, tracker, object));
+    return object_to_xmlrpc(env, rpc::commands.call_command(itr, object, rpc::make_target(type, target)));
 
   } catch (torrent::local_error& e) {
     xmlrpc_env_set_fault(env, XMLRPC_PARSE_ERROR, e.what());
     return NULL;
   }
 }
@@ -457,27 +431,18 @@
   xmlrpc_mem_block_free(memblock);
   xmlrpc_env_clean(&localEnv);
   return result;
 }
 
 void
-XmlRpc::insert_command(const char* name, const char* parm, const char* doc, int call) {
+XmlRpc::insert_command(const char* name, const char* parm, const char* doc) {
   xmlrpc_env localEnv;
   xmlrpc_env_init(&localEnv);
 
-  xmlrpc_value* (*callSlot)(xmlrpc_env*, xmlrpc_value*, void*);
-
-  switch (call) {
-  case call_download: callSlot = &xmlrpc_call_command_d; break;
-  case call_file:     callSlot = &xmlrpc_call_command_f; break;
-  case call_tracker:  callSlot = &xmlrpc_call_command_t; break;
-  default:            callSlot = &xmlrpc_call_command; break;
-  }
-
   xmlrpc_registry_add_method_w_doc(&localEnv, (xmlrpc_registry*)m_registry, NULL, name,
-                                   callSlot, const_cast<char*>(name), parm, doc);
+                                   &xmlrpc_call_command, const_cast<char*>(name), parm, doc);
 
   if (localEnv.fault_occurred)
     throw torrent::internal_error("Fault occured while inserting xmlrpc call.");
 
   xmlrpc_env_clean(&localEnv);
 }
@@ -520,13 +485,13 @@
 
 #else
 
 void XmlRpc::initialize() { throw torrent::resource_error("XMLRPC not supported."); }
 void XmlRpc::cleanup() {}
 
-void XmlRpc::insert_command(__UNUSED const char* name, __UNUSED const char* parm, __UNUSED const char* doc, __UNUSED int call) {}
+void XmlRpc::insert_command(__UNUSED const char* name, __UNUSED const char* parm, __UNUSED const char* doc) {}
 void XmlRpc::set_dialect(__UNUSED int dialect) {}
 
 bool XmlRpc::process(__UNUSED const char* inBuffer, __UNUSED uint32_t length, __UNUSED slot_write slotWrite) { return false; }
 
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/xmlrpc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/xmlrpc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/rpc/xmlrpc.h	2007-07-26 06:39:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/rpc/xmlrpc.h	2007-08-31 19:37:43.000000000 +0800
@@ -59,27 +59,31 @@
   typedef rak::function2<bool, const char*, uint32_t>                  slot_write;
 
   static const int dialect_generic = 0;
   static const int dialect_i8      = 1;
   static const int dialect_apache  = 2;
 
+  // These need to match CommandMap type values.
   static const int call_generic    = 0;
-  static const int call_download   = 1;
-  static const int call_file       = 2;
-  static const int call_tracker    = 3;
+  static const int call_any        = 1;
+  static const int call_download   = 2;
+  static const int call_peer       = 3;
+  static const int call_tracker    = 4;
+  static const int call_file       = 5;
+  static const int call_file_itr   = 6;
 
   XmlRpc() : m_env(NULL), m_registry(NULL), m_dialect(dialect_i8) {}
 
   bool                is_valid() const { return m_env != NULL; }
 
   void                initialize();
   void                cleanup();
 
   bool                process(const char* inBuffer, uint32_t length, slot_write slotWrite);
 
-  void                insert_command(const char* name, const char* parm, const char* doc, int call);
+  void                insert_command(const char* name, const char* parm, const char* doc);
 
   int                 dialect() { return m_dialect; }
   void                set_dialect(int dialect);
 
   slot_find_download& get_slot_find_download()                                    { return m_slotFindDownload; }
   void                set_slot_find_download(slot_find_download::base_type* slot) { m_slotFindDownload.set(slot); }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/download.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download.cc	2007-08-13 02:25:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/download.cc	2007-09-03 08:59:01.000000000 +0800
@@ -137,54 +137,53 @@
 }
 
 inline ElementBase*
 Download::create_info() {
   using namespace display::helpers;
 
-  ElementText* element = new ElementText(m_download);
+  ElementText* element = new ElementText(rpc::make_target(m_download));
 
   element->set_column(1);
   element->set_interval(1);
 
   // Get these bindings with some kind of string map.
 
-  element->push_column("Name:",             te_string(&torrent::Download::name));
-  element->push_column("Local id:",         te_string(&torrent::Download::local_id, string_base::flag_escape_html));
-  element->push_column("Info hash:",        te_string(&torrent::Download::info_hash, string_base::flag_escape_hex));
-  element->push_column("Created:",          te_value(&torrent::Download::creation_date, value_base::flag_date), " ", te_value(&torrent::Download::creation_date, value_base::flag_time));
+  element->push_column("Name:",             te_command("d.get_name="));
+  element->push_column("Local id:",         te_command("d.get_local_id_html="));
+  element->push_column("Info hash:",        te_command("d.get_hash="));
+  element->push_column("Created:",          te_command("cat=$to_date=$d.get_creation_date=,\" \",$to_time=$d.get_creation_date="));
 
   element->push_back("");
-  element->push_column("Directory:",        te_string(&torrent::FileList::root_dir));
-  element->push_column("Tied to file:",     te_variable_string("d.get_tied_to_file"));
-  element->push_column("File stats:",
-                       te_branch(&core::Download::c_file_list, &torrent::FileList::is_multi_file, te_string("multi"), te_string("single")),
-                       " ", te_value(&torrent::FileList::size_files), " files");
+  element->push_column("Directory:",        te_command("d.get_base_path="));
+  element->push_column("Tied to file:",     te_command("d.get_tied_to_file="));
+  element->push_column("File stats:",       te_command("cat=$if=$d.is_multi_file=\\,multi\\,single,\" \",$d.get_size_files=,\" files\""));
 
   element->push_back("");
-  element->push_column("Chunks:",           te_value(&torrent::FileList::completed_chunks), " / ", te_value(&torrent::FileList::size_chunks), " * ", te_value(&torrent::FileList::chunk_size));
-  element->push_column("Priority:",         te_variable_value("d.get_priority"));
+  element->push_column("Chunks:",           te_command("cat=$d.get_completed_chunks=,\" / \",$d.get_size_chunks=,\" * \",$d.get_chunk_size="));
+  element->push_column("Priority:",         te_command("d.get_priority="));
+  element->push_column("Peer exchange:",    te_command("if=$d.get_peer_exchange=,enabled,disabled"));
 
-  element->push_column("State changed:",    te_variable_value("d.get_state_changed", value_base::flag_timer | value_base::flag_elapsed));
+  element->push_column("State changed:",    te_command("to_elapsed_time=$d.get_state_changed="));
 
   element->push_back("");
-  element->push_column("Memory usage:",     te_value(&torrent::ChunkManager::memory_usage, value_base::flag_mb), " MB");
-  element->push_column("Max memory usage:", te_value(&torrent::ChunkManager::max_memory_usage, value_base::flag_mb), " MB");
-  element->push_column("Free diskspace:",   te_value(&torrent::FileList::free_diskspace, value_base::flag_mb), " MB");
-  element->push_column("Safe diskspace:",   te_value(&torrent::ChunkManager::safe_free_diskspace, value_base::flag_mb), " MB");
+  element->push_column("Memory usage:",     te_command("cat=$to_mb=$get_memory_usage=,\" MB\""));
+  element->push_column("Max memory usage:", te_command("cat=$to_mb=$get_max_memory_usage=,\" MB\""));
+  element->push_column("Free diskspace:",   te_command("cat=$to_mb=$d.get_free_diskspace=,\" MB\""));
+  element->push_column("Safe diskspace:",   te_command("cat=$to_mb=$get_safe_free_diskspace=,\" MB\""));
 
   element->push_back("");
-  element->push_column("Connection type:",  te_variable_string("d.get_connection_current"));
-  element->push_column("Safe sync:",        te_branch(&torrent::ChunkManager::safe_sync, torrent::chunk_manager(), te_string("yes"), te_string("no")));
-  element->push_column("Send buffer:",      te_value(&torrent::ConnectionManager::send_buffer_size, value_base::flag_kb), " KB");
-  element->push_column("Receive buffer:",   te_value(&torrent::ConnectionManager::receive_buffer_size, value_base::flag_kb), " KB");
+  element->push_column("Connection type:",  te_command("d.get_connection_current="));
+  element->push_column("Safe sync:",        te_command("if=$get_safe_sync=,yes,no"));
+  element->push_column("Send buffer:",      te_command("cat=$to_mb=$get_send_buffer_size=,\" KB\""));
+  element->push_column("Receive buffer:",   te_command("cat=$to_mb=$get_receive_buffer_size=,\" KB\""));
 
   element->push_back("");
-  element->push_column("Upload:",           te_variable_value("d.get_up_rate", value_base::flag_kb), " KB / ", te_variable_value("d.get_up_total", value_base::flag_xb));
-  element->push_column("Download:",         te_variable_value("d.get_down_rate", value_base::flag_kb), " KB / ", te_variable_value("d.get_down_total", value_base::flag_xb));
-  element->push_column("Skipped:",          te_variable_value("d.get_skip_rate", value_base::flag_kb), " KB / ", te_variable_value("d.get_skip_total", value_base::flag_xb));
-  element->push_column("Preload:",          te_value(&torrent::ChunkManager::preload_type), " / ", te_value(&torrent::ChunkManager::stats_preloaded), " / ", te_value(&torrent::ChunkManager::stats_not_preloaded));
+  element->push_column("Upload:",           te_command("cat=$to_kb=$d.get_up_rate=,\" KB / \",$to_xb=$d.get_up_total="));
+  element->push_column("Download:",         te_command("cat=$to_kb=$d.get_down_rate=,\" KB / \",$to_xb=$d.get_down_total="));
+  element->push_column("Skipped:",          te_command("cat=$to_kb=$d.get_skip_rate=,\" KB / \",$to_xb=$d.get_skip_total="));
+  element->push_column("Preload:",          te_command("cat=$get_preload_type=,\" / \",$get_stats_preloaded=,\" / \",$get_stats_not_preloaded="));
 
   element->set_column_width(element->column_width() + 1);
 
   return element;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/download_list.cc	2007-08-13 02:25:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/download_list.cc	2007-09-06 01:10:12.000000000 +0800
@@ -200,14 +200,18 @@
   default:
     break;
   }
 
   // Set title.
   switch (displayType) {
-  case DISPLAY_DOWNLOAD_LIST: control->ui()->window_title()->set_title("rTorrent " VERSION " - libTorrent " + std::string(torrent::version())); break;
-  case DISPLAY_LOG:           control->ui()->window_title()->set_title("Log"); break;
+  case DISPLAY_DOWNLOAD_LIST:
+    control->ui()->window_title()->set_title("rTorrent " VERSION "/" + std::string(torrent::version()) + " - " + rpc::call_command_string("get_name"));
+    break;
+  case DISPLAY_LOG:
+    control->ui()->window_title()->set_title("Log");
+    break;
   default: break;
   }
 
   control->display()->adjust_layout();
 }
 
@@ -285,14 +289,17 @@
       break;
 
     case INPUT_CHANGE_DIRECTORY:
       if (current_view()->focus() == current_view()->end_visible())
         throw torrent::input_error("No download in focus to change root directory.");
 
-      rpc::call_command_d("d.set_directory", *current_view()->focus(), rak::trim(input->str()));
-      control->core()->push_log_std("New root directory \"" + rpc::call_command_d_string("d.get_directory", *current_view()->focus()) + "\" for torrent.");
+      if ((*current_view()->focus())->is_open())
+        throw torrent::input_error("Cannot change root directory on an open download.");
+
+      rpc::call_command("d.set_directory", rak::trim(input->str()), rpc::make_target(*current_view()->focus()));
+      control->core()->push_log_std("New root directory \"" + rpc::call_command_string("d.get_directory", rpc::make_target(*current_view()->focus())) + "\" for torrent.");
       break;
 
     case INPUT_COMMAND:
       rpc::parse_command_d_single_std(current_view()->focus() != current_view()->end_visible() ? *current_view()->focus() : NULL, input->str());
       break;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_download_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_download_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_download_list.cc	2007-08-13 02:25:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_download_list.cc	2007-08-28 06:45:01.000000000 +0800
@@ -149,13 +149,13 @@
 
 void
 ElementDownloadList::receive_stop_download() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  if (rpc::call_command_d_value("d.get_state", *m_view->focus()) == 1)
+  if (rpc::call_command_value("d.get_state", rpc::make_target(*m_view->focus())) == 1)
     control->core()->download_list()->stop_normal(*m_view->focus());
   else
     control->core()->download_list()->erase_ptr(*m_view->focus());
 
   m_view->set_last_changed();
 }
@@ -164,13 +164,13 @@
 ElementDownloadList::receive_close_download() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
   core::Download* download = *m_view->focus();
 
-  rpc::call_command_d("d.set_ignore_commands", download, (int64_t)1);
+  rpc::call_command("d.set_ignore_commands", (int64_t)1, rpc::make_target(download));
 
   control->core()->download_list()->stop_normal(download);
   control->core()->download_list()->close(download);
   m_view->set_last_changed();
 }
 
@@ -203,30 +203,30 @@
 
 void
 ElementDownloadList::receive_ignore_ratio() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  if (rpc::call_command_d_value("d.get_ignore_commands", *m_view->focus()) != 0) {
-    rpc::call_command_d_set_value("d.set_ignore_commands", *m_view->focus(), (int64_t)0);
+  if (rpc::call_command_value("d.get_ignore_commands", rpc::make_target(*m_view->focus())) != 0) {
+    rpc::call_command_set_value("d.set_ignore_commands", (int64_t)0, rpc::make_target(*m_view->focus()));
     control->core()->push_log("Torrent set to heed commands.");
   } else {
-    rpc::call_command_d_set_value("d.set_ignore_commands", *m_view->focus(), (int64_t)1);
+    rpc::call_command_set_value("d.set_ignore_commands", (int64_t)1, rpc::make_target(*m_view->focus()));
     control->core()->push_log("Torrent set to ignore commands.");
   }
 }
 
 void
 ElementDownloadList::receive_clear_tied() {
   if (m_view->focus() == m_view->end_visible())
     return;
 
-  const std::string& tiedFile = rpc::call_command_d_string("d.get_tied_to_file", *m_view->focus());
+  const std::string& tiedFile = rpc::call_command_string("d.get_tied_to_file", rpc::make_target(*m_view->focus()));
 
   if (!tiedFile.empty()) {
-    rpc::call_command_d_void("d.delete_tied", *m_view->focus());
+    rpc::call_command_void("d.delete_tied", rpc::make_target(*m_view->focus()));
 
     control->core()->push_log("Cleared tied to file association for the selected download.");
   }
 }
 
 void
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_file_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_file_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_file_list.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_file_list.cc	2007-08-29 05:12:42.000000000 +0800
@@ -90,13 +90,13 @@
 }
 
 inline ElementText*
 element_file_list_create_info() {
   using namespace display::helpers;
 
-  ElementText* element = new ElementText(NULL);
+  ElementText* element = new ElementText(rpc::make_target());
 
   element->set_column(1);
   element->set_interval(1);
 
   element->push_back("File info:");
   element->push_back("");
@@ -124,13 +124,13 @@
   m_window = new WFileList(this);
   m_window->set_active(true);
   m_window->set_focused(focus);
 
   m_elementInfo = element_file_list_create_info();
   m_elementInfo->slot_exit(sigc::bind(sigc::mem_fun(this, &ElementFileList::activate_display), DISPLAY_LIST));
-  m_elementInfo->set_object(&m_selected);
+  m_elementInfo->set_target(rpc::make_target(&m_selected));
 
   m_frame = frame;
 
   activate_display(DISPLAY_LIST);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_menu.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_menu.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_menu.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_menu.cc	2007-08-28 21:26:09.000000000 +0800
@@ -65,13 +65,13 @@
     return;
 
   base_type::operator[](idx).m_element->set_attributes(display::Attributes::a_normal);
 }
 
 ElementMenu::ElementMenu() :
-  m_window(new WindowText(NULL, 2)),
+  m_window(new WindowText(rpc::make_target(), 2)),
   m_entry(entry_invalid) {
 
   // Move bindings into a function that defines default bindings.
   m_bindings[KEY_LEFT] = m_bindings['B' - '@']  = sigc::mem_fun(&m_slotExit, &slot_type::operator());  
   m_bindings[KEY_RIGHT] = m_bindings['F' - '@'] = sigc::mem_fun(this, &ElementMenu::entry_select);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_peer_list.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_peer_list.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_peer_list.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_peer_list.cc	2007-08-28 21:31:50.000000000 +0800
@@ -98,13 +98,13 @@
 }
 
 inline ElementText*
 ElementPeerList::create_info() {
   using namespace display::helpers;
 
-  ElementText* element = new ElementText(NULL);
+  ElementText* element = new ElementText(rpc::make_target());
 
   element->set_column(1);
   element->set_interval(1);
 
   // Get these bindings with some kind of string map.
 
@@ -260,10 +260,10 @@
   update_itr();
 }
 
 void
 ElementPeerList::update_itr() {
   m_windowList->mark_dirty();
-  m_elementInfo->set_object(m_listItr != m_list.end() ? &*m_listItr : NULL);
+  m_elementInfo->set_target(m_listItr != m_list.end() ? rpc::make_target(&*m_listItr) : rpc::make_target());
 }
 
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_text.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_text.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_text.cc	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_text.cc	2007-08-28 21:25:10.000000000 +0800
@@ -45,14 +45,14 @@
 
 #include "control.h"
 #include "element_text.h"
 
 namespace ui {
 
-ElementText::ElementText(void *object) :
-  m_window(new WindowText(object)),
+ElementText::ElementText(rpc::target_type target) :
+  m_window(new WindowText(target)),
   m_column(0),
   m_columnWidth(0) {
 
   // Move bindings into a function that defines default bindings.
   m_bindings[KEY_LEFT] = m_bindings['B' - '@'] = sigc::mem_fun(&m_slotExit, &slot_type::operator());  
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_text.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_text.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/ui/element_text.h	2007-07-20 05:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/ui/element_text.h	2007-08-28 21:24:47.000000000 +0800
@@ -57,17 +57,17 @@
 public:
   typedef display::WindowText         WindowText;
 
   typedef uint32_t                    size_type;
   typedef uint32_t                    extent_type;
 
-  ElementText(void *object);
+  ElementText(rpc::target_type target);
   ~ElementText();
 
-  void*               object() const           { return m_window->object(); }
-  void                set_object(void* object) { m_window->set_object(object); m_window->mark_dirty(); }
+  rpc::target_type    target() const                      { return m_window->target(); }
+  void                set_target(rpc::target_type target) { m_window->set_target(target); m_window->mark_dirty(); }
 
   uint32_t            interval() const         { return m_window->interval(); }
   void                set_interval(uint32_t i) { m_window->set_interval(i); m_window->mark_dirty(); }
 
   void                activate(display::Frame* frame, bool focus = false);
   void                disable();
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/utils/socket_fd.cc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/utils/socket_fd.cc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.7/src/utils/socket_fd.cc	2007-08-07 21:46:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rtorrent/repos/rtorrent-0.7.8/src/utils/socket_fd.cc	2007-08-21 21:24:20.000000000 +0800
@@ -127,23 +127,23 @@
 
   return err;
 }
 
 bool
 SocketFd::open_stream() {
-  return (m_fd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) != -1;
+  return (m_fd = socket(rak::socket_address::pf_inet, SOCK_STREAM, IPPROTO_TCP)) != -1;
 }
 
 bool
 SocketFd::open_datagram() {
-  return (m_fd = socket(PF_INET, SOCK_DGRAM, 0)) != -1;
+  return (m_fd = socket(rak::socket_address::pf_inet, SOCK_DGRAM, 0)) != -1;
 }
 
 bool
 SocketFd::open_local() {
-  return (m_fd = socket(PF_LOCAL, SOCK_DGRAM, 0)) != -1;
+  return (m_fd = socket(rak::socket_address::pf_local, SOCK_STREAM, 0)) != -1;
 }
 
 void
 SocketFd::close() {
   if (::close(m_fd) && errno == EBADF)
     throw torrent::internal_error("SocketFd::close() called on an invalid file descriptor");
