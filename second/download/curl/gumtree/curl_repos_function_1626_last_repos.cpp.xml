<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:pos="http://www.srcML.org/srcML/position" revision="0.9.5" language="C++" filename="usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/gumtree/curl_repos_function_1626_last_repos.cpp" pos:tabs="8"><function><specifier pos:line="1" pos:column="1">static<pos:position pos:line="1" pos:column="7"/></specifier> <type><name pos:line="1" pos:column="8">CURLMcode<pos:position pos:line="1" pos:column="17"/></name></type> <name pos:line="1" pos:column="18">multi_socket<pos:position pos:line="1" pos:column="30"/></name><parameter_list pos:line="1" pos:column="30">(<parameter><decl><type><name><name pos:line="1" pos:column="31">struct<pos:position pos:line="1" pos:column="37"/></name> <name pos:line="1" pos:column="38">Curl_multi<pos:position pos:line="1" pos:column="48"/></name></name> <modifier pos:line="1" pos:column="49">*<pos:position pos:line="1" pos:column="50"/></modifier></type><name pos:line="1" pos:column="50">multi<pos:position pos:line="1" pos:column="55"/></name></decl></parameter>,
                              <parameter><decl><type><name pos:line="2" pos:column="31">bool<pos:position pos:line="2" pos:column="35"/></name></type> <name pos:line="2" pos:column="36">checkall<pos:position pos:line="2" pos:column="44"/></name></decl></parameter>,
                              <parameter><decl><type><name pos:line="3" pos:column="31">curl_socket_t<pos:position pos:line="3" pos:column="44"/></name></type> <name pos:line="3" pos:column="45">s<pos:position pos:line="3" pos:column="46"/></name></decl></parameter>,
                              <parameter><decl><type><name pos:line="4" pos:column="31">int<pos:position pos:line="4" pos:column="34"/></name></type> <name pos:line="4" pos:column="35">ev_bitmask<pos:position pos:line="4" pos:column="45"/></name></decl></parameter>,
                              <parameter><decl><type><name pos:line="5" pos:column="31">int<pos:position pos:line="5" pos:column="34"/></name> <modifier pos:line="5" pos:column="35">*<pos:position pos:line="5" pos:column="36"/></modifier></type><name pos:line="5" pos:column="36">running_handles<pos:position pos:line="5" pos:column="51"/></name></decl></parameter>)<pos:position pos:line="5" pos:column="52"/></parameter_list>
<block pos:line="6" pos:column="1">{
  <decl_stmt><decl><type><name pos:line="7" pos:column="3">CURLMcode<pos:position pos:line="7" pos:column="12"/></name></type> <name pos:line="7" pos:column="13">result<pos:position pos:line="7" pos:column="19"/></name> <init pos:line="7" pos:column="20">= <expr><name pos:line="7" pos:column="22">CURLM_OK<pos:position pos:line="7" pos:column="30"/></name></expr></init></decl>;<pos:position pos:line="7" pos:column="31"/></decl_stmt>
  <decl_stmt><decl><type><name><name pos:line="8" pos:column="3">struct<pos:position pos:line="8" pos:column="9"/></name> <name pos:line="8" pos:column="10">Curl_easy<pos:position pos:line="8" pos:column="19"/></name></name> <modifier pos:line="8" pos:column="20">*<pos:position pos:line="8" pos:column="21"/></modifier></type><name pos:line="8" pos:column="21">data<pos:position pos:line="8" pos:column="25"/></name> <init pos:line="8" pos:column="26">= <expr><name pos:line="8" pos:column="28">NULL<pos:position pos:line="8" pos:column="32"/></name></expr></init></decl>;<pos:position pos:line="8" pos:column="33"/></decl_stmt>
  <decl_stmt><decl><type><name><name pos:line="9" pos:column="3">struct<pos:position pos:line="9" pos:column="9"/></name> <name pos:line="9" pos:column="10">Curl_tree<pos:position pos:line="9" pos:column="19"/></name></name> <modifier pos:line="9" pos:column="20">*<pos:position pos:line="9" pos:column="21"/></modifier></type><name pos:line="9" pos:column="21">t<pos:position pos:line="9" pos:column="22"/></name></decl>;<pos:position pos:line="9" pos:column="23"/></decl_stmt>
  <decl_stmt><decl><type><name><name pos:line="10" pos:column="3">struct<pos:position pos:line="10" pos:column="9"/></name> <name pos:line="10" pos:column="10">curltime<pos:position pos:line="10" pos:column="18"/></name></name></type> <name pos:line="10" pos:column="19">now<pos:position pos:line="10" pos:column="22"/></name> <init pos:line="10" pos:column="23">= <expr><call><name pos:line="10" pos:column="25">Curl_tvnow<pos:position pos:line="10" pos:column="35"/></name><argument_list pos:line="10" pos:column="35">()<pos:position pos:line="10" pos:column="37"/></argument_list></call></expr></init></decl>;<pos:position pos:line="10" pos:column="38"/></decl_stmt>

  <if pos:line="12" pos:column="3">if<condition pos:line="12" pos:column="5">(<expr><name pos:line="12" pos:column="6">checkall<pos:position pos:line="12" pos:column="14"/></name></expr>)<pos:position pos:line="12" pos:column="15"/></condition><then pos:line="12" pos:column="15"> <block pos:line="12" pos:column="16">{
    <comment type="block" pos:line="13" pos:column="5">/* *perform() deals with running_handles on its own */</comment>
    <expr_stmt><expr><name pos:line="14" pos:column="5">result<pos:position pos:line="14" pos:column="11"/></name> <operator pos:line="14" pos:column="12">=<pos:position pos:line="14" pos:column="13"/></operator> <call><name pos:line="14" pos:column="14">curl_multi_perform<pos:position pos:line="14" pos:column="32"/></name><argument_list pos:line="14" pos:column="32">(<argument><expr><name pos:line="14" pos:column="33">multi<pos:position pos:line="14" pos:column="38"/></name></expr></argument>, <argument><expr><name pos:line="14" pos:column="40">running_handles<pos:position pos:line="14" pos:column="55"/></name></expr></argument>)<pos:position pos:line="14" pos:column="56"/></argument_list></call></expr>;<pos:position pos:line="14" pos:column="57"/></expr_stmt>

    <comment type="block" pos:line="16" pos:column="5">/* walk through each easy handle and do the socket state change magic
       and callbacks */</comment>
    <if pos:line="18" pos:column="5">if<condition pos:line="18" pos:column="7">(<expr><name pos:line="18" pos:column="8">result<pos:position pos:line="18" pos:column="14"/></name> <operator pos:line="18" pos:column="15">!=<pos:position pos:line="18" pos:column="17"/></operator> <name pos:line="18" pos:column="18">CURLM_BAD_HANDLE<pos:position pos:line="18" pos:column="34"/></name></expr>)<pos:position pos:line="18" pos:column="35"/></condition><then pos:line="18" pos:column="35"> <block pos:line="18" pos:column="36">{
      <expr_stmt><expr><name pos:line="19" pos:column="7">data<pos:position pos:line="19" pos:column="11"/></name> <operator pos:line="19" pos:column="12">=<pos:position pos:line="19" pos:column="13"/></operator> <name><name pos:line="19" pos:column="14">multi<pos:position pos:line="19" pos:column="19"/></name><operator pos:line="19" pos:column="19">-&gt;<pos:position pos:line="19" pos:column="24"/></operator><name pos:line="19" pos:column="21">easyp<pos:position pos:line="19" pos:column="26"/></name></name></expr>;<pos:position pos:line="19" pos:column="27"/></expr_stmt>
      <while pos:line="20" pos:column="7">while<condition pos:line="20" pos:column="12">(<expr><name pos:line="20" pos:column="13">data<pos:position pos:line="20" pos:column="17"/></name></expr>)<pos:position pos:line="20" pos:column="18"/></condition> <block pos:line="20" pos:column="19">{
        <expr_stmt><expr><call><name pos:line="21" pos:column="9">singlesocket<pos:position pos:line="21" pos:column="21"/></name><argument_list pos:line="21" pos:column="21">(<argument><expr><name pos:line="21" pos:column="22">multi<pos:position pos:line="21" pos:column="27"/></name></expr></argument>, <argument><expr><name pos:line="21" pos:column="29">data<pos:position pos:line="21" pos:column="33"/></name></expr></argument>)<pos:position pos:line="21" pos:column="34"/></argument_list></call></expr>;<pos:position pos:line="21" pos:column="35"/></expr_stmt>
        <expr_stmt><expr><name pos:line="22" pos:column="9">data<pos:position pos:line="22" pos:column="13"/></name> <operator pos:line="22" pos:column="14">=<pos:position pos:line="22" pos:column="15"/></operator> <name><name pos:line="22" pos:column="16">data<pos:position pos:line="22" pos:column="20"/></name><operator pos:line="22" pos:column="20">-&gt;<pos:position pos:line="22" pos:column="25"/></operator><name pos:line="22" pos:column="22">next<pos:position pos:line="22" pos:column="26"/></name></name></expr>;<pos:position pos:line="22" pos:column="27"/></expr_stmt>
      }<pos:position pos:line="23" pos:column="8"/></block></while>
    }<pos:position pos:line="24" pos:column="6"/></block></then></if>

    <comment type="block" pos:line="26" pos:column="5">/* or should we fall-through and do the timer-based stuff? */</comment>
    <return pos:line="27" pos:column="5">return <expr><name pos:line="27" pos:column="12">result<pos:position pos:line="27" pos:column="18"/></name></expr>;<pos:position pos:line="27" pos:column="19"/></return>
  }<pos:position pos:line="28" pos:column="4"/></block></then></if>
  <if pos:line="29" pos:column="3">if<condition pos:line="29" pos:column="5">(<expr><name pos:line="29" pos:column="6">s<pos:position pos:line="29" pos:column="7"/></name> <operator pos:line="29" pos:column="8">!=<pos:position pos:line="29" pos:column="10"/></operator> <name pos:line="29" pos:column="11">CURL_SOCKET_TIMEOUT<pos:position pos:line="29" pos:column="30"/></name></expr>)<pos:position pos:line="29" pos:column="31"/></condition><then pos:line="29" pos:column="31"> <block pos:line="29" pos:column="32">{

    <decl_stmt><decl><type><name><name pos:line="31" pos:column="5">struct<pos:position pos:line="31" pos:column="11"/></name> <name pos:line="31" pos:column="12">Curl_sh_entry<pos:position pos:line="31" pos:column="25"/></name></name> <modifier pos:line="31" pos:column="26">*<pos:position pos:line="31" pos:column="27"/></modifier></type><name pos:line="31" pos:column="27">entry<pos:position pos:line="31" pos:column="32"/></name> <init pos:line="31" pos:column="33">= <expr><call><name pos:line="31" pos:column="35">sh_getentry<pos:position pos:line="31" pos:column="46"/></name><argument_list pos:line="31" pos:column="46">(<argument><expr><operator pos:line="31" pos:column="47">&amp;<pos:position pos:line="31" pos:column="52"/></operator><name><name pos:line="31" pos:column="48">multi<pos:position pos:line="31" pos:column="53"/></name><operator pos:line="31" pos:column="53">-&gt;<pos:position pos:line="31" pos:column="58"/></operator><name pos:line="31" pos:column="55">sockhash<pos:position pos:line="31" pos:column="63"/></name></name></expr></argument>, <argument><expr><name pos:line="31" pos:column="65">s<pos:position pos:line="31" pos:column="66"/></name></expr></argument>)<pos:position pos:line="31" pos:column="67"/></argument_list></call></expr></init></decl>;<pos:position pos:line="31" pos:column="68"/></decl_stmt>

    <if pos:line="33" pos:column="5">if<condition pos:line="33" pos:column="7">(<expr><operator pos:line="33" pos:column="8">!<pos:position pos:line="33" pos:column="9"/></operator><name pos:line="33" pos:column="9">entry<pos:position pos:line="33" pos:column="14"/></name></expr>)<pos:position pos:line="33" pos:column="15"/></condition><then pos:line="33" pos:column="15">
      <comment type="block" pos:line="34" pos:column="7">/* Unmatched socket, we can't act on it but we ignore this fact.  In
         real-world tests it has been proved that libevent can in fact give
         the application actions even though the socket was just previously
         asked to get removed, so thus we better survive stray socket actions
         and just move on. */</comment>
      <block type="pseudo"><empty_stmt pos:line="39" pos:column="7">;<pos:position pos:line="39" pos:column="8"/></empty_stmt></block></then>
    <else pos:line="40" pos:column="5">else <block pos:line="40" pos:column="10">{
      <expr_stmt><expr><call><name pos:line="41" pos:column="7">SIGPIPE_VARIABLE<pos:position pos:line="41" pos:column="23"/></name><argument_list pos:line="41" pos:column="23">(<argument><expr><name pos:line="41" pos:column="24">pipe_st<pos:position pos:line="41" pos:column="31"/></name></expr></argument>)<pos:position pos:line="41" pos:column="32"/></argument_list></call></expr>;<pos:position pos:line="41" pos:column="33"/></expr_stmt>

      <expr_stmt><expr><name pos:line="43" pos:column="7">data<pos:position pos:line="43" pos:column="11"/></name> <operator pos:line="43" pos:column="12">=<pos:position pos:line="43" pos:column="13"/></operator> <name><name pos:line="43" pos:column="14">entry<pos:position pos:line="43" pos:column="19"/></name><operator pos:line="43" pos:column="19">-&gt;<pos:position pos:line="43" pos:column="24"/></operator><name pos:line="43" pos:column="21">easy<pos:position pos:line="43" pos:column="25"/></name></name></expr>;<pos:position pos:line="43" pos:column="26"/></expr_stmt>

      <if pos:line="45" pos:column="7">if<condition pos:line="45" pos:column="9">(<expr><name><name pos:line="45" pos:column="10">data<pos:position pos:line="45" pos:column="14"/></name><operator pos:line="45" pos:column="14">-&gt;<pos:position pos:line="45" pos:column="19"/></operator><name pos:line="45" pos:column="16">magic<pos:position pos:line="45" pos:column="21"/></name></name> <operator pos:line="45" pos:column="22">!=<pos:position pos:line="45" pos:column="24"/></operator> <name pos:line="45" pos:column="25">CURLEASY_MAGIC_NUMBER<pos:position pos:line="45" pos:column="46"/></name></expr>)<pos:position pos:line="45" pos:column="47"/></condition><then pos:line="45" pos:column="47">
        <comment type="block" pos:line="46" pos:column="9">/* bad bad bad bad bad bad bad */</comment>
        <block type="pseudo"><return pos:line="47" pos:column="9">return <expr><name pos:line="47" pos:column="16">CURLM_INTERNAL_ERROR<pos:position pos:line="47" pos:column="36"/></name></expr>;<pos:position pos:line="47" pos:column="37"/></return></block></then></if>

      <comment type="block" pos:line="49" pos:column="7">/* If the pipeline is enabled, take the handle which is in the head of
         the pipeline. If we should write into the socket, take the send_pipe
         head.  If we should read from the socket, take the recv_pipe head. */</comment>
      <if pos:line="52" pos:column="7">if<condition pos:line="52" pos:column="9">(<expr><name><name pos:line="52" pos:column="10">data<pos:position pos:line="52" pos:column="14"/></name><operator pos:line="52" pos:column="14">-&gt;<pos:position pos:line="52" pos:column="19"/></operator><name pos:line="52" pos:column="16">easy_conn<pos:position pos:line="52" pos:column="25"/></name></name></expr>)<pos:position pos:line="52" pos:column="26"/></condition><then pos:line="52" pos:column="26"> <block pos:line="52" pos:column="27">{
        <if pos:line="53" pos:column="9">if<condition pos:line="53" pos:column="11">(<expr><operator pos:line="53" pos:column="12">(<pos:position pos:line="53" pos:column="13"/></operator><name pos:line="53" pos:column="13">ev_bitmask<pos:position pos:line="53" pos:column="23"/></name> <operator pos:line="53" pos:column="24">&amp;<pos:position pos:line="53" pos:column="29"/></operator> <name pos:line="53" pos:column="26">CURL_POLL_OUT<pos:position pos:line="53" pos:column="39"/></name><operator pos:line="53" pos:column="39">)<pos:position pos:line="53" pos:column="40"/></operator> <operator pos:line="53" pos:column="41">&amp;&amp;<pos:position pos:line="53" pos:column="51"/></operator>
           <name><name pos:line="54" pos:column="12">data<pos:position pos:line="54" pos:column="16"/></name><operator pos:line="54" pos:column="16">-&gt;<pos:position pos:line="54" pos:column="21"/></operator><name pos:line="54" pos:column="18">easy_conn<pos:position pos:line="54" pos:column="27"/></name><operator pos:line="54" pos:column="27">-&gt;<pos:position pos:line="54" pos:column="32"/></operator><name pos:line="54" pos:column="29">send_pipe<pos:position pos:line="54" pos:column="38"/></name><operator pos:line="54" pos:column="38">.<pos:position pos:line="54" pos:column="39"/></operator><name pos:line="54" pos:column="39">head<pos:position pos:line="54" pos:column="43"/></name></name></expr>)<pos:position pos:line="54" pos:column="44"/></condition><then pos:line="54" pos:column="44">
          <block type="pseudo"><expr_stmt><expr><name pos:line="55" pos:column="11">data<pos:position pos:line="55" pos:column="15"/></name> <operator pos:line="55" pos:column="16">=<pos:position pos:line="55" pos:column="17"/></operator> <name><name pos:line="55" pos:column="18">data<pos:position pos:line="55" pos:column="22"/></name><operator pos:line="55" pos:column="22">-&gt;<pos:position pos:line="55" pos:column="27"/></operator><name pos:line="55" pos:column="24">easy_conn<pos:position pos:line="55" pos:column="33"/></name><operator pos:line="55" pos:column="33">-&gt;<pos:position pos:line="55" pos:column="38"/></operator><name pos:line="55" pos:column="35">send_pipe<pos:position pos:line="55" pos:column="44"/></name><operator pos:line="55" pos:column="44">.<pos:position pos:line="55" pos:column="45"/></operator><name pos:line="55" pos:column="45">head<pos:position pos:line="55" pos:column="49"/></name><operator pos:line="55" pos:column="49">-&gt;<pos:position pos:line="55" pos:column="54"/></operator><name pos:line="55" pos:column="51">ptr<pos:position pos:line="55" pos:column="54"/></name></name></expr>;<pos:position pos:line="55" pos:column="55"/></expr_stmt></block></then>
        <elseif pos:line="56" pos:column="9">else <if pos:line="56" pos:column="14">if<condition pos:line="56" pos:column="16">(<expr><operator pos:line="56" pos:column="17">(<pos:position pos:line="56" pos:column="18"/></operator><name pos:line="56" pos:column="18">ev_bitmask<pos:position pos:line="56" pos:column="28"/></name> <operator pos:line="56" pos:column="29">&amp;<pos:position pos:line="56" pos:column="34"/></operator> <name pos:line="56" pos:column="31">CURL_POLL_IN<pos:position pos:line="56" pos:column="43"/></name><operator pos:line="56" pos:column="43">)<pos:position pos:line="56" pos:column="44"/></operator> <operator pos:line="56" pos:column="45">&amp;&amp;<pos:position pos:line="56" pos:column="55"/></operator>
                <name><name pos:line="57" pos:column="17">data<pos:position pos:line="57" pos:column="21"/></name><operator pos:line="57" pos:column="21">-&gt;<pos:position pos:line="57" pos:column="26"/></operator><name pos:line="57" pos:column="23">easy_conn<pos:position pos:line="57" pos:column="32"/></name><operator pos:line="57" pos:column="32">-&gt;<pos:position pos:line="57" pos:column="37"/></operator><name pos:line="57" pos:column="34">recv_pipe<pos:position pos:line="57" pos:column="43"/></name><operator pos:line="57" pos:column="43">.<pos:position pos:line="57" pos:column="44"/></operator><name pos:line="57" pos:column="44">head<pos:position pos:line="57" pos:column="48"/></name></name></expr>)<pos:position pos:line="57" pos:column="49"/></condition><then pos:line="57" pos:column="49">
          <block type="pseudo"><expr_stmt><expr><name pos:line="58" pos:column="11">data<pos:position pos:line="58" pos:column="15"/></name> <operator pos:line="58" pos:column="16">=<pos:position pos:line="58" pos:column="17"/></operator> <name><name pos:line="58" pos:column="18">data<pos:position pos:line="58" pos:column="22"/></name><operator pos:line="58" pos:column="22">-&gt;<pos:position pos:line="58" pos:column="27"/></operator><name pos:line="58" pos:column="24">easy_conn<pos:position pos:line="58" pos:column="33"/></name><operator pos:line="58" pos:column="33">-&gt;<pos:position pos:line="58" pos:column="38"/></operator><name pos:line="58" pos:column="35">recv_pipe<pos:position pos:line="58" pos:column="44"/></name><operator pos:line="58" pos:column="44">.<pos:position pos:line="58" pos:column="45"/></operator><name pos:line="58" pos:column="45">head<pos:position pos:line="58" pos:column="49"/></name><operator pos:line="58" pos:column="49">-&gt;<pos:position pos:line="58" pos:column="54"/></operator><name pos:line="58" pos:column="51">ptr<pos:position pos:line="58" pos:column="54"/></name></name></expr>;<pos:position pos:line="58" pos:column="55"/></expr_stmt></block></then></if></elseif></if>
      }<pos:position pos:line="59" pos:column="8"/></block></then></if>

      <if pos:line="61" pos:column="7">if<condition pos:line="61" pos:column="9">(<expr><name><name pos:line="61" pos:column="10">data<pos:position pos:line="61" pos:column="14"/></name><operator pos:line="61" pos:column="14">-&gt;<pos:position pos:line="61" pos:column="19"/></operator><name pos:line="61" pos:column="16">easy_conn<pos:position pos:line="61" pos:column="25"/></name></name> <operator pos:line="61" pos:column="26">&amp;&amp;<pos:position pos:line="61" pos:column="36"/></operator>
         <operator pos:line="62" pos:column="10">!<pos:position pos:line="62" pos:column="11"/></operator><operator pos:line="62" pos:column="11">(<pos:position pos:line="62" pos:column="12"/></operator><name><name pos:line="62" pos:column="12">data<pos:position pos:line="62" pos:column="16"/></name><operator pos:line="62" pos:column="16">-&gt;<pos:position pos:line="62" pos:column="21"/></operator><name pos:line="62" pos:column="18">easy_conn<pos:position pos:line="62" pos:column="27"/></name><operator pos:line="62" pos:column="27">-&gt;<pos:position pos:line="62" pos:column="32"/></operator><name pos:line="62" pos:column="29">handler<pos:position pos:line="62" pos:column="36"/></name><operator pos:line="62" pos:column="36">-&gt;<pos:position pos:line="62" pos:column="41"/></operator><name pos:line="62" pos:column="38">flags<pos:position pos:line="62" pos:column="43"/></name></name> <operator pos:line="62" pos:column="44">&amp;<pos:position pos:line="62" pos:column="49"/></operator> <name pos:line="62" pos:column="46">PROTOPT_DIRLOCK<pos:position pos:line="62" pos:column="61"/></name><operator pos:line="62" pos:column="61">)<pos:position pos:line="62" pos:column="62"/></operator></expr>)<pos:position pos:line="62" pos:column="63"/></condition><then pos:line="62" pos:column="63">
        <comment type="block" pos:line="63" pos:column="9">/* set socket event bitmask if they're not locked */</comment>
        <block type="pseudo"><expr_stmt><expr><name><name pos:line="64" pos:column="9">data<pos:position pos:line="64" pos:column="13"/></name><operator pos:line="64" pos:column="13">-&gt;<pos:position pos:line="64" pos:column="18"/></operator><name pos:line="64" pos:column="15">easy_conn<pos:position pos:line="64" pos:column="24"/></name><operator pos:line="64" pos:column="24">-&gt;<pos:position pos:line="64" pos:column="29"/></operator><name pos:line="64" pos:column="26">cselect_bits<pos:position pos:line="64" pos:column="38"/></name></name> <operator pos:line="64" pos:column="39">=<pos:position pos:line="64" pos:column="40"/></operator> <name pos:line="64" pos:column="41">ev_bitmask<pos:position pos:line="64" pos:column="51"/></name></expr>;<pos:position pos:line="64" pos:column="52"/></expr_stmt></block></then></if>

      <expr_stmt><expr><call><name pos:line="66" pos:column="7">sigpipe_ignore<pos:position pos:line="66" pos:column="21"/></name><argument_list pos:line="66" pos:column="21">(<argument><expr><name pos:line="66" pos:column="22">data<pos:position pos:line="66" pos:column="26"/></name></expr></argument>, <argument><expr><operator pos:line="66" pos:column="28">&amp;<pos:position pos:line="66" pos:column="33"/></operator><name pos:line="66" pos:column="29">pipe_st<pos:position pos:line="66" pos:column="36"/></name></expr></argument>)<pos:position pos:line="66" pos:column="37"/></argument_list></call></expr>;<pos:position pos:line="66" pos:column="38"/></expr_stmt>
      <expr_stmt><expr><name pos:line="67" pos:column="7">result<pos:position pos:line="67" pos:column="13"/></name> <operator pos:line="67" pos:column="14">=<pos:position pos:line="67" pos:column="15"/></operator> <call><name pos:line="67" pos:column="16">multi_runsingle<pos:position pos:line="67" pos:column="31"/></name><argument_list pos:line="67" pos:column="31">(<argument><expr><name pos:line="67" pos:column="32">multi<pos:position pos:line="67" pos:column="37"/></name></expr></argument>, <argument><expr><name pos:line="67" pos:column="39">now<pos:position pos:line="67" pos:column="42"/></name></expr></argument>, <argument><expr><name pos:line="67" pos:column="44">data<pos:position pos:line="67" pos:column="48"/></name></expr></argument>)<pos:position pos:line="67" pos:column="49"/></argument_list></call></expr>;<pos:position pos:line="67" pos:column="50"/></expr_stmt>
      <expr_stmt><expr><call><name pos:line="68" pos:column="7">sigpipe_restore<pos:position pos:line="68" pos:column="22"/></name><argument_list pos:line="68" pos:column="22">(<argument><expr><operator pos:line="68" pos:column="23">&amp;<pos:position pos:line="68" pos:column="28"/></operator><name pos:line="68" pos:column="24">pipe_st<pos:position pos:line="68" pos:column="31"/></name></expr></argument>)<pos:position pos:line="68" pos:column="32"/></argument_list></call></expr>;<pos:position pos:line="68" pos:column="33"/></expr_stmt>

      <if pos:line="70" pos:column="7">if<condition pos:line="70" pos:column="9">(<expr><name><name pos:line="70" pos:column="10">data<pos:position pos:line="70" pos:column="14"/></name><operator pos:line="70" pos:column="14">-&gt;<pos:position pos:line="70" pos:column="19"/></operator><name pos:line="70" pos:column="16">easy_conn<pos:position pos:line="70" pos:column="25"/></name></name> <operator pos:line="70" pos:column="26">&amp;&amp;<pos:position pos:line="70" pos:column="36"/></operator>
         <operator pos:line="71" pos:column="10">!<pos:position pos:line="71" pos:column="11"/></operator><operator pos:line="71" pos:column="11">(<pos:position pos:line="71" pos:column="12"/></operator><name><name pos:line="71" pos:column="12">data<pos:position pos:line="71" pos:column="16"/></name><operator pos:line="71" pos:column="16">-&gt;<pos:position pos:line="71" pos:column="21"/></operator><name pos:line="71" pos:column="18">easy_conn<pos:position pos:line="71" pos:column="27"/></name><operator pos:line="71" pos:column="27">-&gt;<pos:position pos:line="71" pos:column="32"/></operator><name pos:line="71" pos:column="29">handler<pos:position pos:line="71" pos:column="36"/></name><operator pos:line="71" pos:column="36">-&gt;<pos:position pos:line="71" pos:column="41"/></operator><name pos:line="71" pos:column="38">flags<pos:position pos:line="71" pos:column="43"/></name></name> <operator pos:line="71" pos:column="44">&amp;<pos:position pos:line="71" pos:column="49"/></operator> <name pos:line="71" pos:column="46">PROTOPT_DIRLOCK<pos:position pos:line="71" pos:column="61"/></name><operator pos:line="71" pos:column="61">)<pos:position pos:line="71" pos:column="62"/></operator></expr>)<pos:position pos:line="71" pos:column="63"/></condition><then pos:line="71" pos:column="63">
        <comment type="block" pos:line="72" pos:column="9">/* clear the bitmask only if not locked */</comment>
        <block type="pseudo"><expr_stmt><expr><name><name pos:line="73" pos:column="9">data<pos:position pos:line="73" pos:column="13"/></name><operator pos:line="73" pos:column="13">-&gt;<pos:position pos:line="73" pos:column="18"/></operator><name pos:line="73" pos:column="15">easy_conn<pos:position pos:line="73" pos:column="24"/></name><operator pos:line="73" pos:column="24">-&gt;<pos:position pos:line="73" pos:column="29"/></operator><name pos:line="73" pos:column="26">cselect_bits<pos:position pos:line="73" pos:column="38"/></name></name> <operator pos:line="73" pos:column="39">=<pos:position pos:line="73" pos:column="40"/></operator> <literal type="number" pos:line="73" pos:column="41">0<pos:position pos:line="73" pos:column="42"/></literal></expr>;<pos:position pos:line="73" pos:column="43"/></expr_stmt></block></then></if>

      <if pos:line="75" pos:column="7">if<condition pos:line="75" pos:column="9">(<expr><name pos:line="75" pos:column="10">CURLM_OK<pos:position pos:line="75" pos:column="18"/></name> <operator pos:line="75" pos:column="19">&gt;=<pos:position pos:line="75" pos:column="24"/></operator> <name pos:line="75" pos:column="22">result<pos:position pos:line="75" pos:column="28"/></name></expr>)<pos:position pos:line="75" pos:column="29"/></condition><then pos:line="75" pos:column="29">
        <comment type="block" pos:line="76" pos:column="9">/* get the socket(s) and check if the state has been changed since
           last */</comment>
        <block type="pseudo"><expr_stmt><expr><call><name pos:line="78" pos:column="9">singlesocket<pos:position pos:line="78" pos:column="21"/></name><argument_list pos:line="78" pos:column="21">(<argument><expr><name pos:line="78" pos:column="22">multi<pos:position pos:line="78" pos:column="27"/></name></expr></argument>, <argument><expr><name pos:line="78" pos:column="29">data<pos:position pos:line="78" pos:column="33"/></name></expr></argument>)<pos:position pos:line="78" pos:column="34"/></argument_list></call></expr>;<pos:position pos:line="78" pos:column="35"/></expr_stmt></block></then></if>

      <comment type="block" pos:line="80" pos:column="7">/* Now we fall-through and do the timer-based stuff, since we don't want
         to force the user to have to deal with timeouts as long as at least
         one connection in fact has traffic. */</comment>

      <expr_stmt><expr><name pos:line="84" pos:column="7">data<pos:position pos:line="84" pos:column="11"/></name> <operator pos:line="84" pos:column="12">=<pos:position pos:line="84" pos:column="13"/></operator> <name pos:line="84" pos:column="14">NULL<pos:position pos:line="84" pos:column="18"/></name></expr>;<pos:position pos:line="84" pos:column="19"/></expr_stmt> <comment type="block" pos:line="84" pos:column="20">/* set data to NULL again to avoid calling
                      multi_runsingle() in case there's no need to */</comment>
      <expr_stmt><expr><name pos:line="86" pos:column="7">now<pos:position pos:line="86" pos:column="10"/></name> <operator pos:line="86" pos:column="11">=<pos:position pos:line="86" pos:column="12"/></operator> <call><name pos:line="86" pos:column="13">Curl_tvnow<pos:position pos:line="86" pos:column="23"/></name><argument_list pos:line="86" pos:column="23">()<pos:position pos:line="86" pos:column="25"/></argument_list></call></expr>;<pos:position pos:line="86" pos:column="26"/></expr_stmt> <comment type="block" pos:line="86" pos:column="27">/* get a newer time since the multi_runsingle() loop
                             may have taken some time */</comment>
    }<pos:position pos:line="88" pos:column="6"/></block></else></if>
  }<pos:position pos:line="89" pos:column="4"/></block></then>
  <else pos:line="90" pos:column="3">else <block pos:line="90" pos:column="8">{
    <comment type="block" pos:line="91" pos:column="5">/* Asked to run due to time-out. Clear the 'lastcall' variable to force
       update_timer() to trigger a callback to the app again even if the same
       timeout is still the one to run after this call. That handles the case
       when the application asks libcurl to run the timeout prematurely. */</comment>
    <expr_stmt><expr><call><name pos:line="95" pos:column="5">memset<pos:position pos:line="95" pos:column="11"/></name><argument_list pos:line="95" pos:column="11">(<argument><expr><operator pos:line="95" pos:column="12">&amp;<pos:position pos:line="95" pos:column="17"/></operator><name><name pos:line="95" pos:column="13">multi<pos:position pos:line="95" pos:column="18"/></name><operator pos:line="95" pos:column="18">-&gt;<pos:position pos:line="95" pos:column="23"/></operator><name pos:line="95" pos:column="20">timer_lastcall<pos:position pos:line="95" pos:column="34"/></name></name></expr></argument>, <argument><expr><literal type="number" pos:line="95" pos:column="36">0<pos:position pos:line="95" pos:column="37"/></literal></expr></argument>, <argument><expr><sizeof pos:line="95" pos:column="39">sizeof<argument_list pos:line="95" pos:column="45">(<argument><expr><name><name pos:line="95" pos:column="46">multi<pos:position pos:line="95" pos:column="51"/></name><operator pos:line="95" pos:column="51">-&gt;<pos:position pos:line="95" pos:column="56"/></operator><name pos:line="95" pos:column="53">timer_lastcall<pos:position pos:line="95" pos:column="67"/></name></name></expr></argument>)<pos:position pos:line="95" pos:column="68"/></argument_list></sizeof></expr></argument>)<pos:position pos:line="95" pos:column="69"/></argument_list></call></expr>;<pos:position pos:line="95" pos:column="70"/></expr_stmt>
  }<pos:position pos:line="96" pos:column="4"/></block></else></if>

  <comment type="block" pos:line="98" pos:column="3">/*
   * The loop following here will go on as long as there are expire-times left
   * to process in the splay and 'data' will be re-assigned for every expired
   * handle we deal with.
   */</comment>
  <do pos:line="103" pos:column="3">do <block pos:line="103" pos:column="6">{
    <comment type="block" pos:line="104" pos:column="5">/* the first loop lap 'data' can be NULL */</comment>
    <if pos:line="105" pos:column="5">if<condition pos:line="105" pos:column="7">(<expr><name pos:line="105" pos:column="8">data<pos:position pos:line="105" pos:column="12"/></name></expr>)<pos:position pos:line="105" pos:column="13"/></condition><then pos:line="105" pos:column="13"> <block pos:line="105" pos:column="14">{
      <expr_stmt><expr><call><name pos:line="106" pos:column="7">SIGPIPE_VARIABLE<pos:position pos:line="106" pos:column="23"/></name><argument_list pos:line="106" pos:column="23">(<argument><expr><name pos:line="106" pos:column="24">pipe_st<pos:position pos:line="106" pos:column="31"/></name></expr></argument>)<pos:position pos:line="106" pos:column="32"/></argument_list></call></expr>;<pos:position pos:line="106" pos:column="33"/></expr_stmt>

      <expr_stmt><expr><call><name pos:line="108" pos:column="7">sigpipe_ignore<pos:position pos:line="108" pos:column="21"/></name><argument_list pos:line="108" pos:column="21">(<argument><expr><name pos:line="108" pos:column="22">data<pos:position pos:line="108" pos:column="26"/></name></expr></argument>, <argument><expr><operator pos:line="108" pos:column="28">&amp;<pos:position pos:line="108" pos:column="33"/></operator><name pos:line="108" pos:column="29">pipe_st<pos:position pos:line="108" pos:column="36"/></name></expr></argument>)<pos:position pos:line="108" pos:column="37"/></argument_list></call></expr>;<pos:position pos:line="108" pos:column="38"/></expr_stmt>
      <expr_stmt><expr><name pos:line="109" pos:column="7">result<pos:position pos:line="109" pos:column="13"/></name> <operator pos:line="109" pos:column="14">=<pos:position pos:line="109" pos:column="15"/></operator> <call><name pos:line="109" pos:column="16">multi_runsingle<pos:position pos:line="109" pos:column="31"/></name><argument_list pos:line="109" pos:column="31">(<argument><expr><name pos:line="109" pos:column="32">multi<pos:position pos:line="109" pos:column="37"/></name></expr></argument>, <argument><expr><name pos:line="109" pos:column="39">now<pos:position pos:line="109" pos:column="42"/></name></expr></argument>, <argument><expr><name pos:line="109" pos:column="44">data<pos:position pos:line="109" pos:column="48"/></name></expr></argument>)<pos:position pos:line="109" pos:column="49"/></argument_list></call></expr>;<pos:position pos:line="109" pos:column="50"/></expr_stmt>
      <expr_stmt><expr><call><name pos:line="110" pos:column="7">sigpipe_restore<pos:position pos:line="110" pos:column="22"/></name><argument_list pos:line="110" pos:column="22">(<argument><expr><operator pos:line="110" pos:column="23">&amp;<pos:position pos:line="110" pos:column="28"/></operator><name pos:line="110" pos:column="24">pipe_st<pos:position pos:line="110" pos:column="31"/></name></expr></argument>)<pos:position pos:line="110" pos:column="32"/></argument_list></call></expr>;<pos:position pos:line="110" pos:column="33"/></expr_stmt>

      <if pos:line="112" pos:column="7">if<condition pos:line="112" pos:column="9">(<expr><name pos:line="112" pos:column="10">CURLM_OK<pos:position pos:line="112" pos:column="18"/></name> <operator pos:line="112" pos:column="19">&gt;=<pos:position pos:line="112" pos:column="24"/></operator> <name pos:line="112" pos:column="22">result<pos:position pos:line="112" pos:column="28"/></name></expr>)<pos:position pos:line="112" pos:column="29"/></condition><then pos:line="112" pos:column="29">
        <comment type="block" pos:line="113" pos:column="9">/* get the socket(s) and check if the state has been changed since
           last */</comment>
        <block type="pseudo"><expr_stmt><expr><call><name pos:line="115" pos:column="9">singlesocket<pos:position pos:line="115" pos:column="21"/></name><argument_list pos:line="115" pos:column="21">(<argument><expr><name pos:line="115" pos:column="22">multi<pos:position pos:line="115" pos:column="27"/></name></expr></argument>, <argument><expr><name pos:line="115" pos:column="29">data<pos:position pos:line="115" pos:column="33"/></name></expr></argument>)<pos:position pos:line="115" pos:column="34"/></argument_list></call></expr>;<pos:position pos:line="115" pos:column="35"/></expr_stmt></block></then></if>
    }<pos:position pos:line="116" pos:column="6"/></block></then></if>

    <comment type="block" pos:line="118" pos:column="5">/* Check if there's one (more) expired timer to deal with! This function
       extracts a matching node if there is one */</comment>

    <expr_stmt><expr><name><name pos:line="121" pos:column="5">multi<pos:position pos:line="121" pos:column="10"/></name><operator pos:line="121" pos:column="10">-&gt;<pos:position pos:line="121" pos:column="15"/></operator><name pos:line="121" pos:column="12">timetree<pos:position pos:line="121" pos:column="20"/></name></name> <operator pos:line="121" pos:column="21">=<pos:position pos:line="121" pos:column="22"/></operator> <call><name pos:line="121" pos:column="23">Curl_splaygetbest<pos:position pos:line="121" pos:column="40"/></name><argument_list pos:line="121" pos:column="40">(<argument><expr><name pos:line="121" pos:column="41">now<pos:position pos:line="121" pos:column="44"/></name></expr></argument>, <argument><expr><name><name pos:line="121" pos:column="46">multi<pos:position pos:line="121" pos:column="51"/></name><operator pos:line="121" pos:column="51">-&gt;<pos:position pos:line="121" pos:column="56"/></operator><name pos:line="121" pos:column="53">timetree<pos:position pos:line="121" pos:column="61"/></name></name></expr></argument>, <argument><expr><operator pos:line="121" pos:column="63">&amp;<pos:position pos:line="121" pos:column="68"/></operator><name pos:line="121" pos:column="64">t<pos:position pos:line="121" pos:column="65"/></name></expr></argument>)<pos:position pos:line="121" pos:column="66"/></argument_list></call></expr>;<pos:position pos:line="121" pos:column="67"/></expr_stmt>
    <if pos:line="122" pos:column="5">if<condition pos:line="122" pos:column="7">(<expr><name pos:line="122" pos:column="8">t<pos:position pos:line="122" pos:column="9"/></name></expr>)<pos:position pos:line="122" pos:column="10"/></condition><then pos:line="122" pos:column="10"> <block pos:line="122" pos:column="11">{
      <expr_stmt><expr><name pos:line="123" pos:column="7">data<pos:position pos:line="123" pos:column="11"/></name> <operator pos:line="123" pos:column="12">=<pos:position pos:line="123" pos:column="13"/></operator> <name><name pos:line="123" pos:column="14">t<pos:position pos:line="123" pos:column="15"/></name><operator pos:line="123" pos:column="15">-&gt;<pos:position pos:line="123" pos:column="20"/></operator><name pos:line="123" pos:column="17">payload<pos:position pos:line="123" pos:column="24"/></name></name></expr>;<pos:position pos:line="123" pos:column="25"/></expr_stmt> <comment type="block" pos:line="123" pos:column="26">/* assign this for next loop */</comment>
      <expr_stmt><expr><operator pos:line="124" pos:column="7">(<pos:position pos:line="124" pos:column="8"/></operator><name pos:line="124" pos:column="8">void<pos:position pos:line="124" pos:column="12"/></name><operator pos:line="124" pos:column="12">)<pos:position pos:line="124" pos:column="13"/></operator><call><name pos:line="124" pos:column="13">add_next_timeout<pos:position pos:line="124" pos:column="29"/></name><argument_list pos:line="124" pos:column="29">(<argument><expr><name pos:line="124" pos:column="30">now<pos:position pos:line="124" pos:column="33"/></name></expr></argument>, <argument><expr><name pos:line="124" pos:column="35">multi<pos:position pos:line="124" pos:column="40"/></name></expr></argument>, <argument><expr><name><name pos:line="124" pos:column="42">t<pos:position pos:line="124" pos:column="43"/></name><operator pos:line="124" pos:column="43">-&gt;<pos:position pos:line="124" pos:column="48"/></operator><name pos:line="124" pos:column="45">payload<pos:position pos:line="124" pos:column="52"/></name></name></expr></argument>)<pos:position pos:line="124" pos:column="53"/></argument_list></call></expr>;<pos:position pos:line="124" pos:column="54"/></expr_stmt>
    }<pos:position pos:line="125" pos:column="6"/></block></then></if>

  }<pos:position pos:line="127" pos:column="4"/></block> while<condition pos:line="127" pos:column="10">(<expr><name pos:line="127" pos:column="11">t<pos:position pos:line="127" pos:column="12"/></name></expr>)<pos:position pos:line="127" pos:column="13"/></condition>;<pos:position pos:line="127" pos:column="14"/></do>

  <expr_stmt><expr><operator pos:line="129" pos:column="3">*<pos:position pos:line="129" pos:column="4"/></operator><name pos:line="129" pos:column="4">running_handles<pos:position pos:line="129" pos:column="19"/></name> <operator pos:line="129" pos:column="20">=<pos:position pos:line="129" pos:column="21"/></operator> <name><name pos:line="129" pos:column="22">multi<pos:position pos:line="129" pos:column="27"/></name><operator pos:line="129" pos:column="27">-&gt;<pos:position pos:line="129" pos:column="32"/></operator><name pos:line="129" pos:column="29">num_alive<pos:position pos:line="129" pos:column="38"/></name></name></expr>;<pos:position pos:line="129" pos:column="39"/></expr_stmt>
  <return pos:line="130" pos:column="3">return <expr><name pos:line="130" pos:column="10">result<pos:position pos:line="130" pos:column="16"/></name></expr>;<pos:position pos:line="130" pos:column="17"/></return>
}<pos:position pos:line="131" pos:column="2"/></block></function></unit>
