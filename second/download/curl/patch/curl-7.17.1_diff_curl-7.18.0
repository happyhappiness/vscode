diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/aclocal.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/aclocal.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/aclocal.m4	2007-10-27 06:25:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/aclocal.m4	2008-01-28 19:59:45.000000000 +0800
@@ -10,13 +10,13 @@
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 # libtool.m4 - Configure libtool for the host system. -*-Autoconf-*-
 
-# serial 51 Debian 1.5.24-1 AC_PROG_LIBTOOL
+# serial 51 Debian 1.5.24-2 AC_PROG_LIBTOOL
 
 
 # AC_PROVIDE_IFELSE(MACRO-NAME, IF-PROVIDED, IF-NOT-PROVIDED)
 # -----------------------------------------------------------
 # If this macro is not defined by Autoconf, define it here.
 m4_ifdef([AC_PROVIDE_IFELSE],
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/CHANGES	2007-10-29 18:15:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/CHANGES	2008-01-29 00:10:37.000000000 +0800
@@ -3,12 +3,442 @@
                              / __| | | | |_) | |
                             | (__| |_| |  _ <| |___
                              \___|\___/|_| \_\_____|
 
                                   Changelog
 
+Version 7.18.0 (28 January 2008)
+
+Daniel S (27 Jan 2008)
+- Dmitry Kurochkin: In "real world" testing I found more bugs in
+  pipelining. Broken connection is not restored and we get into infinite
+  loop. It happens because of wrong is_in_pipeline values.
+
+Daniel S (26 Jan 2008)
+- Kevin Reed filed bug report #1879375
+  (http://curl.haxx.se/bug/view.cgi?id=1879375) which describes how libcurl
+  got lost in this scenario: proxy tunnel (or HTTPS over proxy), ask to do any
+  proxy authentication and the proxy replies with an auth (like NTLM) and then
+  closes the connection after that initial informational response.
+
+  libcurl would not properly re-initialize the connection to the proxy and
+  continue the auth negotiation like supposed. It does now however, as it will
+  now detect if one or more authentication methods were available and asked
+  for, and will thus retry the connection and continue from there.
+
+- I made the progress callback get called properly during proxy CONNECT.
+
+Daniel S (23 Jan 2008)
+- Igor Franchuk pointed out that CURLOPT_COOKIELIST set to "ALL" leaked
+  memory, and so did "SESS". Fixed now.
+
+Yang Tse (22 Jan 2008)
+- Check poll.h at configuration time, and use it when sys/poll.h unavailable
+
+Daniel S (22 Jan 2008)
+- Dmitry Kurochkin removed the cancelled state for pipelining, as we agreed
+  that it is bad anyway. Starting now, removing a handle that is in used in a
+  pipeline will break the pipeline - it'll be set back up again but still...
+
+Yang Tse (21 Jan 2008)
+- Disable ldap support for cygwin builds, since it breaks whole build process.
+  Fixing it will affect other platforms, so it is postponed for another release.
+
+Daniel S (18 Jan 2008)
+- Lau Hang Kin found and fixed a problem with the multi interface when doing
+  CONNECT over a proxy. curl_multi_fdset() didn't report back the socket
+  properly during that state, due to a missing case in the switch in the
+  multi_getsock() function.
+
+Yang Tse (17 Jan 2008)
+- Don't abort tests 518 and 537 when unable to raise the open-file soft limit.
+
+Daniel S (16 Jan 2008)
+- Nathan Coulter's patch that makes runtests.pl respect the PATH when figuring
+  out what valgrind to run.
+
+Yang Tse (16 Jan 2008)
+- Improved handling of out of memory in the command line tool that afected
+  data url encoded HTTP POSTs when reading it from a file.
+
+Daniel S (16 Jan 2008)
+- Dmitry Kurochkin worked a lot on improving the HTTP Pipelining support that
+  previously had a number of flaws, perhaps most notably when an application
+  fired up N transfers at once as then they wouldn't pipeline at all that
+  nicely as anyone would think... Test case 530 was also updated to take the
+  improved functionality into account.
+
+- Calls to Curl_failf() are not supposed to provide a trailing newline as the
+  function itself adds that. Fixed on 50 or something strings!
+
+Daniel S (15 Jan 2008)
+- I made the torture test on test 530 go through. This was actually due to
+  silly code left from when we switched to let the multi handle "hold" the dns
+  cache when using the multi interface... Of course this only triggered when a
+  certain function call returned error at the correct moment.
+
+Daniel S (14 Jan 2008)
+- Joe Malicki filed bug report #1871269
+  (http://curl.haxx.se/bug/view.cgi?id=1871269) and we could fix his hang-
+  problem that occurred when doing a large HTTP POST request with the
+  response-body read from a callback.
+
+Daniel S (12 Jan 2008)
+- I re-arranged the curl --help output. All the options are now sorted on
+  their long option names and all descriptions are one-liners.
+
+- Eric Landes provided the patch (edited by me) that introduces the
+  --keepalive-time to curl to set the keepalive probe interval. I also took
+  the opportunity to rename the recently added no-keep-alive option to
+  no-keepalive to keep a consistent naming and to avoid getting two dashes in
+  these option names. Eric also provided an update to the man page for the new
+  option.
+
+Daniel S (11 Jan 2008)
+- Daniel Egger made CURLOPT_RANGE work on file:// URLs the very same way it
+  already worked for FTP:// URLs.
+
+- I made the curl tool switch from using CURLOPT_IOCTLFUNCTION to now use the
+  spanking new CURLOPT_SEEKFUNCTION simply to take advantage of the improved
+  performance for the upload resume cases where you want to upload the last
+  few bytes of a very large file. To implement this decently, I had to switch
+  the client code for uploading from fopen()/fread() to plain open()/read() so
+  that we can use lseek() to do >32bit seeks (as fseek() doesn't allow that)
+  on systems that offer support for that.
+
+Daniel S (10 Jan 2008)
+- Michal Marek made curl-config --libs not include /usr/lib64 in the output
+  (it already before skipped /usr/lib).  /usr/lib64 is the default library
+  directory on many 64bit systems and it's unlikely that anyone would use the
+  path privately on systems where it's not.
+
+- Georg Lippitsch brought CURLOPT_SEEKFUNCTION and CURLOPT_SEEKDATA to allow
+  libcurl to seek in a given input stream. This is particularly important when
+  doing upload resumes when there's already a huge part of the file present
+  remotely. Before, and still if this callback isn't used, libcurl will read
+  and through away the entire file up to the point to where the resuming
+  begins (which of course can be a slow opereration depending on file size,
+  I/O bandwidth and more). This new function will also be preferred to get
+  used instead of the CURLOPT_IOCTLFUNCTION for seeking back in a stream when
+  doing multi-stage HTTP auth with POST/PUT.
+
+- Nikitinskit Dmitriy filed bug report #1868255
+  (http://curl.haxx.se/bug/view.cgi?id=1868255) with a patch. It identifies
+  and fixes a problem with parsing WWW-Authenticate: headers with additional
+  spaces in the line that the parser wasn't written to deal with.
+
+Daniel S (8 Jan 2008)
+- Introducing curl_easy_pause() and new magic return codes for both the read
+  and the write callbacks that now can make a connection's reading and/or
+  writing get paused.
+
+Daniel S (6 Jan 2008)
+- Jeff Johnson filed bug report #1863171
+  (http://curl.haxx.se/bug/view.cgi?id=1863171) where he pointed out that
+  libcurl's date parser didn't accept a +1300 time zone which actually is used
+  fairly often (like New Zealand's Dailight Savings Time), so I modified the
+  parser to now accept up to and including -1400 to +1400.
+
+Daniel S (5 Jan 2008)
+- Based on further discussion on curl-library, I reverted yesterday's SOCKS5
+  code to instead introduce support for a new proxy type called
+  CURLPROXY_SOCKS5_HOSTNAME that is used to send the host name to the proxy
+  instead of IP address and there's thus no longer any need for a new
+  curl_easy_setopt() option.
+
+  The default SOCKS5 proxy is again back to sending the IP address to the
+  proxy.  The new curl command line option for enabling sending host name to a
+  SOCKS5 proxy is now --socks5-hostname.
+
+Daniel S (4 Jan 2008)
+- Based on Maxim Perenesenko's patch, we now do SOCKS5 operations and let the
+  proxy do the host name resolving and only if --socks5ip (or
+  CURLOPT_SOCKS5_RESOLVE_LOCAL) is used we resolve the host name locally and
+  pass on the IP address only to the proxy.
+
+Yang Tse (3 Jan 2008)
+- Modified test harness to allow SCP, SFTP and SOCKS4 tests to run with
+  OpenSSH 2.9.9, SunSSH 1.0 or later versions. SOCKS5 tests need OpenSSH
+  3.7, SunSSH 1.0 or later.
+
+Daniel S (2 Jan 2008)
+- I fixed two cases of missing return code checks when handling chunked
+  decoding where a write error (or abort return from a callback) didn't stop
+  libcurl's processing.
+
+- I removed the socklen_t use from the public curl/curl.h header and instead
+  made it an unsigned int. The type was only used in the curl_sockaddr struct
+  definition (only used by the curl_opensocket_callback). On all platforms I
+  could find information about, socklen_t is 32 unsigned bits large so I don't
+  think this will break the API or ABI. The main reason for this change is of
+  course for all the platforms that don't have a socklen_t definition in their
+  headers to build fine again. Providing our own configure magic and custom
+  definition of socklen_t on those systems proved to work but was a lot of
+  cruft, code and extra magic needed - when this very small change of type
+  seems harmless and still solves the missing socklen_t problem.
+
+- Richard Atterer brought a patch that added support for SOCKS4a proxies,
+  which is an inofficial PROXY4 variant that sends the hostname to the proxy
+  instead of the resolved address (which is already supported by SOCKS5).
+  --socks4a is the curl command line option for it and CURLOPT_PROXYTYPE can
+  now be set to CURLPROXY_SOCKS4A as well.
+
+Daniel S (1 Jan 2008)
+- Mohun Biswas pointed out that --libcurl generated a source code with an int
+  function but without a return statement. While fixing that, I also took care
+  about adding some better comments for the generated code.
+
+Daniel S (27 Dec 2007)
+- Dmitry Kurochkin mentioned a flaw
+  (http://curl.haxx.se/mail/lib-2007-12/0252.html) in detect_proxy() which
+  failed to set the bits.proxy variable properly when an environment variable
+  told libcurl to use a http proxy.
+
+Daniel S (26 Dec 2007)
+- In an attempt to repeat the problem in bug report #1850730
+  (http://curl.haxx.se/bug/view.cgi?id=1850730) I wrote up test case 552. The
+  test is doing a 70K POST with a read callback and an ioctl callback over a
+  proxy requiring Digest auth. The test case code is more or less identical to
+  the test recipe code provided by Spacen Jasset (who submitted the bug
+  report).
+
+Daniel S (25 Dec 2007)
+- Gary Maxwell filed bug report #1856628
+  (http://curl.haxx.se/bug/view.cgi?id=1856628) and provided a fix for the
+  (small) memory leak in the SSL session ID caching code. It happened when a
+  previous entry in the cache was re-used.
+
+Daniel Fandrich (19 Dec 2007)
+- Ensure that nroff doesn't put anything but ASCII characters into the
+  --manual text.
+
+Yang Tse (18 Dec 2007)
+- MSVC 9.0 (VS2008) does not support Windows build targets prior to WinXP,
+  and makes wrong asumptions of build target when it isn't specified. So,
+  if no build target has been defined we will target WinXP when building
+  curl/libcurl with MSVC 9.0 (VS2008).
+
+- (http://curl.haxx.se/mail/archive-2007-12/0039.html) reported and fixed
+  a file truncation problem on Windows build targets triggered when retrying
+  a download with curl.
+
+Daniel S (17 Dec 2007)
+- Mateusz Loskot pointed out that MSVC 9.0 (VS2008) has the pollfd struct and
+  defines in winsock2.h somehow differently than previous versions and that
+  curl 7.17.1 would fail to compile out of the box.
+
+Daniel S (13 Dec 2007)
+- David Wright filed bug report #1849764
+  (http://curl.haxx.se/bug/view.cgi?id=1849764) with an included fix. He
+  identified a problem for re-used connections that previously had sent
+  Expect: 100-continue and in some situations the subsequent POST (that didn't
+  use Expect:) still had the internal flag set for its use. David's fix (that
+  makes the setting of the flag in every single request unconditionally) is
+  fine and is now used!
+
+Daniel S (12 Dec 2007)
+- Gilles Blanc made the curl tool enable SO_KEEPALIVE for the connections and
+  added the --no-keep-alive option that can disable that on demand.
+
+Daniel S (9 Dec 2007)
+- Andrew Moise filed bug report #1847501
+  (http://curl.haxx.se/bug/view.cgi?id=1847501) and pointed out a memcpy()
+  that should be memmove() in the convert_lineends() function.
+
+Daniel S (8 Dec 2007)
+- Renamed all internal static functions that had Curl_ prefixes to no longer
+  have them. The Curl_ prefix is exclusively used for library internal global
+  symbols. Static functions can be named anything, except for using Curl_ or
+  curl_ prefixes. This is for consistency and for easier maintainance and
+  overview.
+
+- Cleaned up and reformatted the TODO document to look like the FAQ and
+  CONTRIBUTE, which makes nicer web pages
+
+- Added test cases 549 and 550 that test CURLOPT_PROXY_TRANSFER_MODE.
+
+- Added keywords on a bunch of test cases
+
+- Fixed an OOM problem in the curl code that would lead to fclose on a bad
+  handle and crash
+
+Daniel S (5 Dec 2007)
+- Spacen Jasset reported a problem with doing POST (with data read with a
+  callback) over a proxy when NTLM is used as auth with the proxy. The bug
+  also concerned Digest and was limited to using callback only. Spacen worked
+  with us to provide a useful patch. I added the test case 547 and 548 to
+  verify two variations of POST over proxy with NTLM.
+
+Daniel S (3 Dec 2007)
+- Ray Pekowski filed bug report #1842029
+  (http://curl.haxx.se/bug/view.cgi?id=1842029) in which he identified a
+  problem with SSL session caching that prevent it from working, and provided
+  the associated fix!
+
+- Now libcurl (built with OpenSSL) doesn't return error anymore if the remote
+  SSL-based server doesn't present a certificate when the request is told to
+  ignore certificate verification anyway.
+
+- Michal Marek introduced CURLOPT_PROXY_TRANSFER_MODE which is used to control
+  the appending of the "type=" thing on FTP URLs when they are passed to a
+  HTTP proxy. Some proxies just don't like that appending (which is done
+  unconditionally in 7.17.1), and some proxies treat binary/ascii transfers
+  better with the appending done!
+
+Daniel S (29 Nov 2007)
+- A bug report on the curl-library list showed a HTTP Digest session going on
+  with a 700+ letter nonce. Previously libcurl only support 127 letter ones
+  and now I bumped it to 1023.
+
+- Fixed the resumed FTP upload loop to not require that the read callback
+  returns a full buffer on each invoke.
+
+Daniel S (25 Nov 2007)
+- Added test case 1015 that tests --data-urlencode in multiple ways
+
+- Fixed --data-urlencode for when no @ or = are used
+
+- Extended the user-agent buffer curl uses, since we can hit the 128 byte
+  border with plenty development libraries used. Like my current set: "curl
+  7.17.2-CVS (i686-pc-linux-gnu) libcurl/7.17.2-CVS OpenSSL/0.9.8g
+  zlib/1.2.3.3 c-ares/1.5.2-CVS libidn/1.1 libssh2/0.19.0-CVS"
+
+Daniel S (24 Nov 2007)
+- Internal rearrangements, so that the previous struct HandleData is no more.
+  It is now known as SingleRequest and the Curl_transfer_keeper struct within
+  that was remove entirely. This has the upside that there are less duplicate
+  struct members that made it hard to see and remember what struct that was
+  used to store what data. The transfer_keeper thing was once stored on a
+  per-connection basis and then it made sense to have the duplicate info but
+  since it was moved to the SessionHandle (in 7.16.0) it just added weirdness.
+  The SingleRequest struct is used by data that only is valid for this single
+  request.
+
+Yang Tse (22 Nov 2007)
+- Provide a socklen_t definition in curl.h for Win32 API build targets
+  which don't have one.
+
+Daniel S (22 Nov 2007)
+- Alessandro Vesely helped me improve the --data-urlencode's syntax, parser
+  and documentation.
+
+Daniel S (21 Nov 2007)
+- While inspecting the Negotiate code, I noticed how the proxy auth was using
+  the same state struct as the host auth, so both could never be used at the
+  same time! I fixed it (without being able to check) to use two separate
+  structs to allow authentication using Negotiate on host and proxy
+  simultaneously.
+
+Daniel S (20 Nov 2007)
+- Emil Romanus pointed out a bug that made an easy handle get the cookie
+  engine activated when set to use a share (even if the share doesn't share
+  cookies). I fixed it.
+
+- Fixed a very long-lasting mprintf() bug that occurred when we did "%.*s%s",
+  since the second %s would then wrongly used the numerical precision argument
+  instead and crash.
+
+- Introduced --data-urlencode to the curl tool for easier url encoding of the
+  data sent in a post.
+
+Daniel S (18 Nov 2007)
+- Rob Crittenden fixed SSL connections with NSS done with the multi-interface
+
+Daniel S (17 Nov 2007)
+- Michal Marek made the test suite remember what test servers that fail to
+  start so that subsequent tries are simply skipped.
+
+- Andres Garcia made the examples build fine on Windows (mingw + msys) when
+  the lib was built staticly.
+
+Daniel S (16 Nov 2007)
+- Ates Goral identified a problem in http.c:add_buffer_send() when a debug
+  callback was used, as it could wrongly pass on a bad size for the outgoing
+  HTTP header. The bad size would be a very large value as it was a wrapped
+  size_t content. This happened when the whole HTTP request failed to get sent
+  in one single send.  http://curl.haxx.se/mail/lib-2007-11/0165.html
+
+Daniel S (15 Nov 2007)
+- Fixed yet another remaining problem with doing SFTP directory listings on a
+  re-used persistent connection. Mentioned by Immanuel Gregoire on the mailing
+  list.
+
+- Michal Marek fixed the test suite to better deal with the case when the HTTP
+  ipv6 server can't run.
+
+Yang Tse (14 Nov 2007)
+- Fix a variable potential wrapping in add_buffer() when using absolutely
+  huge send buffer sizes.
+
+Daniel S (13 Nov 2007)
+- Fixed a remaining problem with doing SFTP directory listings on a re-used
+  persistent connection. Mentioned by Immanuel Gregoire on the mailing list.
+
+Daniel S (12 Nov 2007)
+- Bug report #1830637 (http://curl.haxx.se/bug/view.cgi?id=1830637), which was
+  forwarded from the Gentoo bug tracker by Daniel Black and was originally
+  submitted by Robin Johnson, pointed out that libcurl would do bad memory
+  references when it failed and bailed out before the handler thing was
+  setup. My fix is not done like the provided patch does it, but instead I
+  make sure that there's never any chance for a NULL pointer in that struct
+  member.
+
+Yang Tse (10 Nov 2007)
+- Vikram Saxena (http://curl.haxx.se/mail/lib-2007-11/0096.html) pointed out
+  that the pollfd struct was being multi defined when using VS2008. This is
+  now fixed in /curl/lib/select.h
+
+Daniel S (8 Nov 2007)
+- Bug report #1823487 (http://curl.haxx.se/bug/view.cgi?id=1823487) pointed
+  out that SFTP requests didn't use persistent connections. Neither did SCP
+  ones.  I gave the SSH code a good beating and now both SCP and SFTP should
+  use persistent connections fine. I also did a bunch of indent changes as
+  well as a bug fix for the "keyboard interactive" auth.
+
+Dan F (6 Nov 2007)
+- Improved telnet support by drastically reducing the number of write
+  callbacks needed to pass a buffer to the user.  Instead one per byte it
+  is now as little as one per segment.
+
+Yang Tse (6 Nov 2007)
+- Bug report #1824894 (http://curl.haxx.se/bug/view.cgi?id=1824894) pointed
+  out a problem in curl.h when building C++ apps with MSVC. To fix it, the
+  inclusion of header files in curl.h is moved outside of the C++ extern "C"
+  linkage block.
+
+Daniel S (1 Nov 2007)
+- Toby Peterson patched a memory problem in the command line tool that
+  happened when a user had a home dir as an empty string. curl would then do
+  free() on a wrong area.
+
+Dan F (1 Nov 2007)
+- Fixed curl-config --features to not display libz when it wasn't used
+  due to a missing header file.
+
+Dan F (31 October 2007)
+- Fixed the output of curl-config --protocols which showed SCP and SFTP
+  always, except when --without-libssh2 was given
+
+- Added test cases 1013 and 1014 to check that curl-config --protocols and
+  curl-config --features matches the output of curl --version
+
+Dan F (30 October 2007)
+- Fixed an OOM problem with file: URLs
+
+- Moved Curl_file_connect into the protocol handler struct
+
+Dan F (29 October 2007)
+- Added test case 546 to check that subsequent FTP transfers work after a
+  failed one using the multi interface
+
+Daniel S (29 October 2007)
+- Based on one of those bug reports that are intercepted by a distro's bug
+  tracker (https://bugzilla.redhat.com/show_bug.cgi?id=316191), I now made
+  curl-config --features and --protocols show the correct output when built
+  with NSS.
+
 Version 7.17.1 (29 October 2007)
 
 Dan F (25 October 2007)
 - Added the --static-libs option to curl-config
 
 Daniel S (25 October 2007)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/configure	2007-10-27 06:25:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/configure	2008-01-28 19:59:49.000000000 +0800
@@ -6,13 +6,13 @@
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 # 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 #
-# Copyright (c) 1998 - 2006 Daniel Stenberg, <daniel@haxx.se>
+# Copyright (c) 1998 - 2008 Daniel Stenberg, <daniel@haxx.se>
 # This configure script may be copied, distributed and modified under the
 # terms of the curl license; see COPYING for more details
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
@@ -872,12 +872,14 @@
 OBJDUMP
 LIBTOOL
 NO_UNDEFINED_TRUE
 NO_UNDEFINED_FALSE
 MIMPURE_TRUE
 MIMPURE_FALSE
+STATICLIB_TRUE
+STATICLIB_FALSE
 REQUIRE_LIB_DEPS
 CURL_DISABLE_HTTP
 CURL_DISABLE_FTP
 CURL_DISABLE_FILE
 CURL_DISABLE_LDAP
 CURL_DISABLE_LDAPS
@@ -892,12 +894,13 @@
 HAVE_LIBZ_FALSE
 USE_LIBSSH2
 RANDOM_FILE
 USE_GNUTLS
 HAVE_PK11_CREATEGENERICOBJECT
 USE_NSS
+SSL_ENABLED
 CURL_CA_BUNDLE
 CABUNDLE_TRUE
 CABUNDLE_FALSE
 IDN_ENABLED
 IPV6_ENABLED
 PERL
@@ -1677,13 +1680,13 @@
 
 Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 
-Copyright (c) 1998 - 2006 Daniel Stenberg, <daniel@haxx.se>
+Copyright (c) 1998 - 2008 Daniel Stenberg, <daniel@haxx.se>
 This configure script may be copied, distributed and modified under the
 terms of the curl license; see COPYING for more details
 _ACEOF
   exit
 fi
 cat >config.log <<_ACEOF
@@ -6058,13 +6061,13 @@
     esac
   fi
   rm -rf conftest*
   ;;
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 6064 "configure"' > conftest.$ac_ext
+  echo '#line 6067 "configure"' > conftest.$ac_ext
   if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
    if test "$lt_cv_prog_gnu_ld" = yes; then
@@ -7904,17 +7907,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:7910: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:7913: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:7914: \$? = $ac_status" >&5
+   echo "$as_me:7917: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -8194,17 +8197,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8200: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8203: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:8204: \$? = $ac_status" >&5
+   echo "$as_me:8207: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -8298,17 +8301,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:8304: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:8307: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:8308: \$? = $ac_status" >&5
+   echo "$as_me:8311: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
      $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
@@ -10660,13 +10663,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 10666 "configure"
+#line 10669 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -10760,13 +10763,13 @@
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self_static=cross
 else
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 10766 "configure"
+#line 10769 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -13180,17 +13183,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13186: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13189: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:13190: \$? = $ac_status" >&5
+   echo "$as_me:13193: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -13284,17 +13287,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:13290: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:13293: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:13294: \$? = $ac_status" >&5
+   echo "$as_me:13297: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
      $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
@@ -14861,17 +14864,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:14867: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:14870: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:14871: \$? = $ac_status" >&5
+   echo "$as_me:14874: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -14965,17 +14968,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:14971: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:14974: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:14975: \$? = $ac_status" >&5
+   echo "$as_me:14978: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
      $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
@@ -17165,17 +17168,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17171: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17174: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17175: \$? = $ac_status" >&5
+   echo "$as_me:17178: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -17455,17 +17458,17 @@
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    # The option is referenced via a variable to avoid confusing sed.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17461: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17464: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>conftest.err)
    ac_status=$?
    cat conftest.err >&5
-   echo "$as_me:17465: \$? = $ac_status" >&5
+   echo "$as_me:17468: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s "$ac_outfile"; then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings other than the usual output.
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' >conftest.exp
      $SED '/^$/d; /^ *+/d' conftest.err >conftest.er2
      if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
@@ -17559,17 +17562,17 @@
    # Note that $ac_compile itself does not contain backslashes and begins
    # with a dollar sign (not a hyphen), so the echo should work correctly.
    lt_compile=`echo "$ac_compile" | $SED \
    -e 's:.*FLAGS}\{0,1\} :&$lt_compiler_flag :; t' \
    -e 's: [^ ]*conftest\.: $lt_compiler_flag&:; t' \
    -e 's:$: $lt_compiler_flag:'`
-   (eval echo "\"\$as_me:17565: $lt_compile\"" >&5)
+   (eval echo "\"\$as_me:17568: $lt_compile\"" >&5)
    (eval "$lt_compile" 2>out/conftest.err)
    ac_status=$?
    cat out/conftest.err >&5
-   echo "$as_me:17569: \$? = $ac_status" >&5
+   echo "$as_me:17572: \$? = $ac_status" >&5
    if (exit $ac_status) && test -s out/conftest2.$ac_objext
    then
      # The compiler can only warn and ignore the option if not recognized
      # So say no if there are warnings
      $echo "X$_lt_compiler_boilerplate" | $Xsed -e '/^$/d' > out/conftest.exp
      $SED '/^$/d; /^ *+/d' out/conftest.err >out/conftest.er2
@@ -20262,12 +20265,22 @@
 else
   MIMPURE_TRUE='#'
   MIMPURE_FALSE=
 fi
 
 
+
+if false; then
+  STATICLIB_TRUE=
+  STATICLIB_FALSE='#'
+else
+  STATICLIB_TRUE='#'
+  STATICLIB_FALSE=
+fi
+
+
 { echo "$as_me:$LINENO: checking if we need BUILDING_LIBCURL" >&5
 echo $ECHO_N "checking if we need BUILDING_LIBCURL... $ECHO_C" >&6; }
 case $host in
   *-*-mingw*)
 
 cat >>confdefs.h <<\_ACEOF
@@ -20284,12 +20297,22 @@
 cat >>confdefs.h <<\_ACEOF
 #define CURL_STATICLIB 1
 _ACEOF
 
       { echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6; }
+
+
+if true; then
+  STATICLIB_TRUE=
+  STATICLIB_FALSE='#'
+else
+  STATICLIB_TRUE='#'
+  STATICLIB_FALSE=
+fi
+
     else
       { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
     fi
     ;;
   *)
@@ -21066,19 +21089,51 @@
 #define CURL_DISABLE_LDAP 1
 _ACEOF
 
        CURL_DISABLE_LDAP=1
 
        ;;
-  *)   { echo "$as_me:$LINENO: result: yes" >&5
+  *)
+       case $host in
+         *-*-cygwin*)
+           # Force no ldap. config/build process is broken for cygwin
+
+cat >>confdefs.h <<\_ACEOF
+#define CURL_DISABLE_LDAP 1
+_ACEOF
+
+           CURL_DISABLE_LDAP=1
+
+           { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+           ;;
+         *)
+           { echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6; }
+       esac
        ;;
   esac
 else
-  { echo "$as_me:$LINENO: result: yes" >&5
+
+       case $host in
+         *-*-cygwin*)
+           # Force no ldap. config/build process is broken for cygwin
+
+cat >>confdefs.h <<\_ACEOF
+#define CURL_DISABLE_LDAP 1
+_ACEOF
+
+           CURL_DISABLE_LDAP=1
+
+           { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+           ;;
+         *)
+           { echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6; }
+       esac
 
 fi
 
 { echo "$as_me:$LINENO: checking whether to support ldaps" >&5
 echo $ECHO_N "checking whether to support ldaps... $ECHO_C" >&6; }
 # Check whether --enable-ldaps was given.
@@ -24944,12 +24999,14 @@
   { echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6; }
 fi
 
 
 
+GSSAPI_ROOT="/usr"
+
 # Check whether --with-gssapi-includes was given.
 if test "${with_gssapi_includes+set}" = set; then
   withval=$with_gssapi_includes;  GSSAPI_INCS="-I$withval"
     want_gss="yes"
 
 fi
@@ -24968,12 +25025,15 @@
 # Check whether --with-gssapi was given.
 if test "${with_gssapi+set}" = set; then
   withval=$with_gssapi;
   GSSAPI_ROOT="$withval"
   if test x"$GSSAPI_ROOT" != xno; then
     want_gss="yes"
+    if test x"$GSSAPI_ROOT" = xyes; then
+            GSSAPI_ROOT="/usr"
+    fi
   fi
 
 fi
 
 
 save_CPPFLAGS="$CPPFLAGS"
@@ -24983,17 +25043,21 @@
   { echo "$as_me:$LINENO: result: yes" >&5
 echo "${ECHO_T}yes" >&6; }
 
   if test -z "$GSSAPI_INCS"; then
      if test -f "$GSSAPI_ROOT/bin/krb5-config"; then
         GSSAPI_INCS=`$GSSAPI_ROOT/bin/krb5-config --cflags gssapi`
+        GSSAPI_LIBS=`$GSSAPI_ROOT/bin/krb5-config --libs gssapi`
      elif test "$GSSAPI_ROOT" != "yes"; then
         GSSAPI_INCS="-I$GSSAPI_ROOT/include"
+        GSSAPI_LIBS="-lgssapi"
      fi
   fi
+
   CPPFLAGS="$CPPFLAGS $GSSAPI_INCS"
+  LIBS="$LIBS $GSSAPI_LIBS"
 
   if test "${ac_cv_header_gss_h+set}" = set; then
   { echo "$as_me:$LINENO: checking for gss.h" >&5
 echo $ECHO_N "checking for gss.h... $ECHO_C" >&6; }
 if test "${ac_cv_header_gss_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -27246,12 +27310,13 @@
 
 
   if test "$HAVE_LIBZ" = "1" && test "$HAVE_ZLIB_H" != "1"
   then
     { echo "$as_me:$LINENO: WARNING: configure found only the libz lib, not the header file!" >&5
 echo "$as_me: WARNING: configure found only the libz lib, not the header file!" >&2;}
+    HAVE_LIBZ=""
   elif test "$HAVE_LIBZ" != "1" && test "$HAVE_ZLIB_H" = "1"
   then
     { echo "$as_me:$LINENO: WARNING: configure found only the libz header file, not the lib!" >&5
 echo "$as_me: WARNING: configure found only the libz header file, not the lib!" >&2;}
   elif test "$HAVE_LIBZ" = "1" && test "$HAVE_ZLIB_H" = "1"
   then
@@ -27534,18 +27599,19 @@
     LIBSSH2_ENABLED=1
 
 cat >>confdefs.h <<\_ACEOF
 #define USE_LIBSSH2 1
 _ACEOF
 
+    USE_LIBSSH2=1
+
+
 fi
 
 done
 
-    USE_LIBSSH2=1
-
 
   if test X"$OPT_LIBSSH2" != Xoff &&
      test "$LIBSSH2_ENABLED" != "1"; then
     { { echo "$as_me:$LINENO: error: libSSH2 libs and/or directories were not found where specified!" >&5
 echo "$as_me: error: libSSH2 libs and/or directories were not found where specified!" >&2;}
    { (exit 1); exit 1; }; }
@@ -27783,15 +27849,15 @@
       addlib="-lssl3 -lsmime3 -lnss3 -lplds4 -lplc4 -lnspr4 -lpthread -ldl"
       addcflags="-I$OPT_NSS/include"
       version="unknown"
       gtlsprefix=$OPT_GNUTLS
     fi
 
-            { echo "$as_me:$LINENO: checking for PK11_CreateGenericObject-d in -lnss3" >&5
-echo $ECHO_N "checking for PK11_CreateGenericObject-d in -lnss3... $ECHO_C" >&6; }
-if test "${ac_cv_lib_nss3_PK11_CreateGenericObject_d+set}" = set; then
+            { echo "$as_me:$LINENO: checking for PK11_CreateGenericObject in -lnss3" >&5
+echo $ECHO_N "checking for PK11_CreateGenericObject in -lnss3... $ECHO_C" >&6; }
+if test "${ac_cv_lib_nss3_PK11_CreateGenericObject+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnss3  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
@@ -27803,17 +27869,17 @@
 /* Override any GCC internal prototype to avoid an error.
    Use char because int might match the return type of a GCC
    builtin and then its argument prototype would still apply.  */
 #ifdef __cplusplus
 extern "C"
 #endif
-char PK11_CreateGenericObject-d ();
+char PK11_CreateGenericObject ();
 int
 main ()
 {
-return PK11_CreateGenericObject-d ();
+return PK11_CreateGenericObject ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (ac_try="$ac_link"
@@ -27830,27 +27896,27 @@
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } && {
 	 test -z "$ac_c_werror_flag" ||
 	 test ! -s conftest.err
        } && test -s conftest$ac_exeext &&
        $as_test_x conftest$ac_exeext; then
-  ac_cv_lib_nss3_PK11_CreateGenericObject_d=yes
+  ac_cv_lib_nss3_PK11_CreateGenericObject=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-	ac_cv_lib_nss3_PK11_CreateGenericObject_d=no
+	ac_cv_lib_nss3_PK11_CreateGenericObject=no
 fi
 
 rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
       conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_nss3_PK11_CreateGenericObject_d" >&5
-echo "${ECHO_T}$ac_cv_lib_nss3_PK11_CreateGenericObject_d" >&6; }
-if test $ac_cv_lib_nss3_PK11_CreateGenericObject_d = yes; then
+{ echo "$as_me:$LINENO: result: $ac_cv_lib_nss3_PK11_CreateGenericObject" >&5
+echo "${ECHO_T}$ac_cv_lib_nss3_PK11_CreateGenericObject" >&6; }
+if test $ac_cv_lib_nss3_PK11_CreateGenericObject = yes; then
 
 
 cat >>confdefs.h <<\_ACEOF
 #define HAVE_PK11_CREATEGENERICOBJECT 1
 _ACEOF
 
@@ -27968,16 +28034,20 @@
 fi
 if test "x$OPENSSL_ENABLED$GNUTLS_ENABLED$NSS_ENABLED" = "x"; then
   { echo "$as_me:$LINENO: WARNING: SSL disabled, you will not be able to use HTTPS, FTPS, NTLM and more." >&5
 echo "$as_me: WARNING: SSL disabled, you will not be able to use HTTPS, FTPS, NTLM and more." >&2;}
   { echo "$as_me:$LINENO: WARNING: Use --with-ssl, --with-gnutls or --with-nss to address this." >&5
 echo "$as_me: WARNING: Use --with-ssl, --with-gnutls or --with-nss to address this." >&2;}
+else
+  # SSL is enabled, genericly
+
+  SSL_ENABLED="1"
 fi
 
 
-if test X"$USE_NSS$USE_GNUTLS$OPENSSL_ENABLED" != "X"; then
+if test X"$SSL_ENABLED" != "X"; then
 
   { echo "$as_me:$LINENO: checking CA cert bundle install path" >&5
 echo $ECHO_N "checking CA cert bundle install path... $ECHO_C" >&6; }
 
 
 # Check whether --with-ca-bundle was given.
@@ -30566,12 +30637,13 @@
         time.h \
         io.h \
         pwd.h \
         utime.h \
         sys/utime.h \
         sys/poll.h \
+        poll.h \
         sys/resource.h \
         libgen.h \
         locale.h \
         errno.h \
         stdbool.h \
         arpa/tftp.h \
@@ -33000,12 +33072,417 @@
 
 cat >>confdefs.h <<_ACEOF
 #define SIZEOF_TIME_T $ac_cv_sizeof_time_t
 _ACEOF
 
 
+{ echo "$as_me:$LINENO: checking for off_t" >&5
+echo $ECHO_N "checking for off_t... $ECHO_C" >&6; }
+if test "${ac_cv_type_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+typedef off_t ac__type_new_;
+int
+main ()
+{
+if ((ac__type_new_ *) 0)
+  return 0;
+if (sizeof (ac__type_new_))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_cv_type_off_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_cv_type_off_t=no
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
+echo "${ECHO_T}$ac_cv_type_off_t" >&6; }
+
+# The cast to long int works around a bug in the HP C Compiler
+# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+# This bug is HP SR number 8606223364.
+{ echo "$as_me:$LINENO: checking size of off_t" >&5
+echo $ECHO_N "checking size of off_t... $ECHO_C" >&6; }
+if test "${ac_cv_sizeof_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  # Depending upon the size, compute the lo and hi bounds.
+cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+   typedef off_t ac__type_sizeof_;
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_lo=0 ac_mid=0
+  while :; do
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+   typedef off_t ac__type_sizeof_;
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_hi=$ac_mid; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo=`expr $ac_mid + 1`
+			if test $ac_lo -le $ac_mid; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			ac_mid=`expr 2 '*' $ac_mid + 1`
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+   typedef off_t ac__type_sizeof_;
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_hi=-1 ac_mid=-1
+  while :; do
+    cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+   typedef off_t ac__type_sizeof_;
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_lo=$ac_mid; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_hi=`expr '(' $ac_mid ')' - 1`
+			if test $ac_mid -le $ac_hi; then
+			  ac_lo= ac_hi=
+			  break
+			fi
+			ac_mid=`expr 2 '*' $ac_mid`
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+  done
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo= ac_hi=
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+# Binary search between lo and hi bounds.
+while test "x$ac_lo" != "x$ac_hi"; do
+  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+   typedef off_t ac__type_sizeof_;
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+  ac_hi=$ac_mid
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_lo=`expr '(' $ac_mid ')' + 1`
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+done
+case $ac_lo in
+?*) ac_cv_sizeof_off_t=$ac_lo;;
+'') if test "$ac_cv_type_off_t" = yes; then
+     { { echo "$as_me:$LINENO: error: cannot compute sizeof (off_t)
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (off_t)
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+   else
+     ac_cv_sizeof_off_t=0
+   fi ;;
+esac
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+   typedef off_t ac__type_sizeof_;
+static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
+static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
+#include <stdio.h>
+#include <stdlib.h>
+int
+main ()
+{
+
+  FILE *f = fopen ("conftest.val", "w");
+  if (! f)
+    return 1;
+  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
+    {
+      long int i = longval ();
+      if (i != ((long int) (sizeof (ac__type_sizeof_))))
+	return 1;
+      fprintf (f, "%ld\n", i);
+    }
+  else
+    {
+      unsigned long int i = ulongval ();
+      if (i != ((long int) (sizeof (ac__type_sizeof_))))
+	return 1;
+      fprintf (f, "%lu\n", i);
+    }
+  return ferror (f) || fclose (f) != 0;
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (ac_try="$ac_link"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_link") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_try") 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_sizeof_off_t=`cat conftest.val`
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+if test "$ac_cv_type_off_t" = yes; then
+     { { echo "$as_me:$LINENO: error: cannot compute sizeof (off_t)
+See \`config.log' for more details." >&5
+echo "$as_me: error: cannot compute sizeof (off_t)
+See \`config.log' for more details." >&2;}
+   { (exit 77); exit 77; }; }
+   else
+     ac_cv_sizeof_off_t=0
+   fi
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.val
+fi
+{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_off_t" >&5
+echo "${ECHO_T}$ac_cv_sizeof_off_t" >&6; }
+
+
+
+cat >>confdefs.h <<_ACEOF
+#define SIZEOF_OFF_T $ac_cv_sizeof_off_t
+_ACEOF
+
+
 
 { echo "$as_me:$LINENO: checking for long long" >&5
 echo $ECHO_N "checking for long long... $ECHO_C" >&6; }
 if test "${ac_cv_type_long_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
@@ -36861,12 +37338,14 @@
 
 else
   cat >conftest.$ac_ext <<_ACEOF
 
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
+#elif defined(HAVE_POLL_H)
+#include <poll.h>
 #endif
 
   int main(void)
   {
     /* make this return 0 == timeout since there's nothing to read from */
     return poll((void *)0, 0, 10 /*ms*/);
@@ -37724,12 +38203,26 @@
   { { echo "$as_me:$LINENO: error: conditional \"MIMPURE\" was never defined.
 Usually this means the macro was only invoked conditionally." >&5
 echo "$as_me: error: conditional \"MIMPURE\" was never defined.
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
 fi
+if test -z "${STATICLIB_TRUE}" && test -z "${STATICLIB_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"STATICLIB\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"STATICLIB\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
+if test -z "${STATICLIB_TRUE}" && test -z "${STATICLIB_FALSE}"; then
+  { { echo "$as_me:$LINENO: error: conditional \"STATICLIB\" was never defined.
+Usually this means the macro was only invoked conditionally." >&5
+echo "$as_me: error: conditional \"STATICLIB\" was never defined.
+Usually this means the macro was only invoked conditionally." >&2;}
+   { (exit 1); exit 1; }; }
+fi
 if test -z "${HAVE_LIBZ_TRUE}" && test -z "${HAVE_LIBZ_FALSE}"; then
   { { echo "$as_me:$LINENO: error: conditional \"HAVE_LIBZ\" was never defined.
 Usually this means the macro was only invoked conditionally." >&5
 echo "$as_me: error: conditional \"HAVE_LIBZ\" was never defined.
 Usually this means the macro was only invoked conditionally." >&2;}
    { (exit 1); exit 1; }; }
@@ -38459,12 +38952,14 @@
 OBJDUMP!$OBJDUMP$ac_delim
 LIBTOOL!$LIBTOOL$ac_delim
 NO_UNDEFINED_TRUE!$NO_UNDEFINED_TRUE$ac_delim
 NO_UNDEFINED_FALSE!$NO_UNDEFINED_FALSE$ac_delim
 MIMPURE_TRUE!$MIMPURE_TRUE$ac_delim
 MIMPURE_FALSE!$MIMPURE_FALSE$ac_delim
+STATICLIB_TRUE!$STATICLIB_TRUE$ac_delim
+STATICLIB_FALSE!$STATICLIB_FALSE$ac_delim
 REQUIRE_LIB_DEPS!$REQUIRE_LIB_DEPS$ac_delim
 CURL_DISABLE_HTTP!$CURL_DISABLE_HTTP$ac_delim
 CURL_DISABLE_FTP!$CURL_DISABLE_FTP$ac_delim
 CURL_DISABLE_FILE!$CURL_DISABLE_FILE$ac_delim
 CURL_DISABLE_LDAP!$CURL_DISABLE_LDAP$ac_delim
 CURL_DISABLE_LDAPS!$CURL_DISABLE_LDAPS$ac_delim
@@ -38479,12 +38974,13 @@
 HAVE_LIBZ_FALSE!$HAVE_LIBZ_FALSE$ac_delim
 USE_LIBSSH2!$USE_LIBSSH2$ac_delim
 RANDOM_FILE!$RANDOM_FILE$ac_delim
 USE_GNUTLS!$USE_GNUTLS$ac_delim
 HAVE_PK11_CREATEGENERICOBJECT!$HAVE_PK11_CREATEGENERICOBJECT$ac_delim
 USE_NSS!$USE_NSS$ac_delim
+SSL_ENABLED!$SSL_ENABLED$ac_delim
 CURL_CA_BUNDLE!$CURL_CA_BUNDLE$ac_delim
 CABUNDLE_TRUE!$CABUNDLE_TRUE$ac_delim
 CABUNDLE_FALSE!$CABUNDLE_FALSE$ac_delim
 IDN_ENABLED!$IDN_ENABLED$ac_delim
 IPV6_ENABLED!$IPV6_ENABLED$ac_delim
 PERL!$PERL$ac_delim
@@ -38501,13 +38997,13 @@
 CROSSCOMPILING_TRUE!$CROSSCOMPILING_TRUE$ac_delim
 CROSSCOMPILING_FALSE!$CROSSCOMPILING_FALSE$ac_delim
 LIBOBJS!$LIBOBJS$ac_delim
 LTLIBOBJS!$LTLIBOBJS$ac_delim
 _ACEOF
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 49; then
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 52; then
     break
   elif $ac_last_try; then
     { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
 echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
    { (exit 1); exit 1; }; }
   else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/configure.ac /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/configure.ac
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/configure.ac	2007-10-27 06:25:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/configure.ac	2008-01-28 19:48:41.000000000 +0800
@@ -2,36 +2,36 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: configure.ac,v 1.262 2007-10-25 22:30:35 danf Exp $
+# $Id: configure.ac,v 1.273 2008-01-28 11:48:41 bagder Exp $
 ###########################################################################
 dnl Process this file with autoconf to produce a configure script.
 
 AC_PREREQ(2.57)
 
-dnl We don't know the version number "staticly" so we use a dash here
+dnl We don't know the version number "statically" so we use a dash here
 AC_INIT(curl, [-], [a suitable curl mailing list => http://curl.haxx.se/mail/])
 
 dnl configure script copyright
-AC_COPYRIGHT([Copyright (c) 1998 - 2006 Daniel Stenberg, <daniel@haxx.se>
+AC_COPYRIGHT([Copyright (c) 1998 - 2008 Daniel Stenberg, <daniel@haxx.se>
 This configure script may be copied, distributed and modified under the
 terms of the curl license; see COPYING for more details])
 
 AC_CONFIG_SRCDIR([lib/urldata.h])
 AM_CONFIG_HEADER(lib/config.h src/config.h)
 AM_MAINTAINER_MODE
@@ -171,23 +171,25 @@
     ;;
   *)
     ;;
 esac
 AC_MSG_RESULT($mimpure)
 AM_CONDITIONAL(MIMPURE, test x$mimpure = xyes)
+AM_CONDITIONAL(STATICLIB, false)
 
 AC_MSG_CHECKING([if we need BUILDING_LIBCURL])
 case $host in
   *-*-mingw*)
     AC_DEFINE(BUILDING_LIBCURL, 1, [when building libcurl itself])
     AC_MSG_RESULT(yes)
     AC_MSG_CHECKING([if we need CURL_STATICLIB])
     if test "X$enable_shared" = "Xno"
     then
       AC_DEFINE(CURL_STATICLIB, 1, [when not building a shared library])
       AC_MSG_RESULT(yes)
+      AM_CONDITIONAL(STATICLIB, true)
     else
       AC_MSG_RESULT(no)
     fi
     ;;
   *)
     AC_MSG_RESULT(no)
@@ -318,16 +320,35 @@
 [ case "$enableval" in
   no)
        AC_MSG_RESULT(no)
        AC_DEFINE(CURL_DISABLE_LDAP, 1, [to disable LDAP])
        AC_SUBST(CURL_DISABLE_LDAP, [1])
        ;;
-  *)   AC_MSG_RESULT(yes)
-       ;;
-  esac ],
-       AC_MSG_RESULT(yes)
+  *)
+       case $host in
+         *-*-cygwin*)
+           # Force no ldap. config/build process is broken for cygwin
+           AC_DEFINE(CURL_DISABLE_LDAP, 1, [to disable LDAP])
+           AC_SUBST(CURL_DISABLE_LDAP, [1])
+           AC_MSG_RESULT(no)
+           ;;
+         *)
+           AC_MSG_RESULT(yes)
+       esac
+       ;;
+  esac ],[
+       case $host in
+         *-*-cygwin*)
+           # Force no ldap. config/build process is broken for cygwin
+           AC_DEFINE(CURL_DISABLE_LDAP, 1, [to disable LDAP])
+           AC_SUBST(CURL_DISABLE_LDAP, [1])
+           AC_MSG_RESULT(no)
+           ;;
+         *)
+           AC_MSG_RESULT(yes)
+       esac ]
 )
 AC_MSG_CHECKING([whether to support ldaps])
 AC_ARG_ENABLE(ldaps,
 AC_HELP_STRING([--enable-ldaps],[Enable LDAPS support])
 AC_HELP_STRING([--disable-ldaps],[Disable LDAPS support]),
 [ case "$enableval" in
@@ -898,12 +919,15 @@
 fi
 
 dnl **********************************************************************
 dnl Check for GSS-API libraries
 dnl **********************************************************************
 
+dnl check for gss stuff in the /usr as default
+
+GSSAPI_ROOT="/usr"
 AC_ARG_WITH(gssapi-includes,
   AC_HELP_STRING([--with-gssapi-includes=DIR],
                  [Specify location of GSSAPI header]),
   [ GSSAPI_INCS="-I$withval"
     want_gss="yes" ]
 )
@@ -918,28 +942,36 @@
 AC_ARG_WITH(gssapi,
   AC_HELP_STRING([--with-gssapi=DIR],
                  [Where to look for GSSAPI]), [
   GSSAPI_ROOT="$withval"
   if test x"$GSSAPI_ROOT" != xno; then
     want_gss="yes"
+    if test x"$GSSAPI_ROOT" = xyes; then
+      dnl if yes, then use default root
+      GSSAPI_ROOT="/usr"
+    fi
   fi
 ])
 
 save_CPPFLAGS="$CPPFLAGS"
 AC_MSG_CHECKING([if GSSAPI support is requested])
 if test x"$want_gss" = xyes; then
   AC_MSG_RESULT(yes)
 
   if test -z "$GSSAPI_INCS"; then
      if test -f "$GSSAPI_ROOT/bin/krb5-config"; then
         GSSAPI_INCS=`$GSSAPI_ROOT/bin/krb5-config --cflags gssapi`
+        GSSAPI_LIBS=`$GSSAPI_ROOT/bin/krb5-config --libs gssapi`
      elif test "$GSSAPI_ROOT" != "yes"; then
         GSSAPI_INCS="-I$GSSAPI_ROOT/include"
+        GSSAPI_LIBS="-lgssapi"
      fi
   fi
+
   CPPFLAGS="$CPPFLAGS $GSSAPI_INCS"
+  LIBS="$LIBS $GSSAPI_LIBS"
 
   AC_CHECK_HEADER(gss.h,
     [
       dnl found in the given dirs
       AC_DEFINE(HAVE_GSSGNU, 1, [if you have the GNU gssapi libraries])
       gnu_gss=yes
@@ -1289,12 +1321,13 @@
       LDFLAGS=$_ldflags]
     )
 
   if test "$HAVE_LIBZ" = "1" && test "$HAVE_ZLIB_H" != "1"
   then
     AC_MSG_WARN([configure found only the libz lib, not the header file!])
+    HAVE_LIBZ=""
   elif test "$HAVE_LIBZ" != "1" && test "$HAVE_ZLIB_H" = "1"
   then
     AC_MSG_WARN([configure found only the libz header file, not the lib!])
   elif test "$HAVE_LIBZ" = "1" && test "$HAVE_ZLIB_H" = "1"
   then
     dnl both header and lib were found!
@@ -1353,14 +1386,15 @@
 
   AC_CHECK_LIB(ssh2, libssh2_channel_open_ex)
 
   AC_CHECK_HEADERS(libssh2.h,
     curl_ssh_msg="enabled (libSSH2)"
     LIBSSH2_ENABLED=1
-    AC_DEFINE(USE_LIBSSH2, 1, [if libSSH2 is in use]))
+    AC_DEFINE(USE_LIBSSH2, 1, [if libSSH2 is in use])
     AC_SUBST(USE_LIBSSH2, [1])
+  )
 
   if test X"$OPT_LIBSSH2" != Xoff &&
      test "$LIBSSH2_ENABLED" != "1"; then
     AC_MSG_ERROR([libSSH2 libs and/or directories were not found where specified!])
   fi
 
@@ -1513,13 +1547,13 @@
       version="unknown"
       gtlsprefix=$OPT_GNUTLS
     fi
 
     dnl Check for functionPK11_CreateGenericObject
     dnl this is needed for using the PEM PKCS#11 module
-    AC_CHECK_LIB(nss3, PK11_CreateGenericObject-d,
+    AC_CHECK_LIB(nss3, PK11_CreateGenericObject,
      [
      AC_DEFINE(HAVE_PK11_CREATEGENERICOBJECT, 1, [if you have the function PK11_CreateGenericObject])
      AC_SUBST(HAVE_PK11_CREATEGENERICOBJECT, [1])
      ])
     if test -n "$addlib"; then
 
@@ -1563,19 +1597,23 @@
 
 fi dnl OPENSSL != 1 -a GNUTLS_ENABLED != 1
 
 if test "x$OPENSSL_ENABLED$GNUTLS_ENABLED$NSS_ENABLED" = "x"; then
   AC_MSG_WARN([SSL disabled, you will not be able to use HTTPS, FTPS, NTLM and more.])
   AC_MSG_WARN([Use --with-ssl, --with-gnutls or --with-nss to address this.])
+else
+  # SSL is enabled, genericly
+  AC_SUBST(SSL_ENABLED)
+  SSL_ENABLED="1"
 fi
 
 dnl **********************************************************************
 dnl Check for the CA bundle
 dnl **********************************************************************
 
-if test X"$USE_NSS$USE_GNUTLS$OPENSSL_ENABLED" != "X"; then
+if test X"$SSL_ENABLED" != "X"; then
 
   AC_MSG_CHECKING([CA cert bundle install path])
 
   AC_ARG_WITH(ca-bundle,
 AC_HELP_STRING([--with-ca-bundle=FILE], [File name to install the CA bundle as])
 AC_HELP_STRING([--without-ca-bundle], [Don't install the CA bundle]),
@@ -1779,13 +1817,13 @@
     ,
     dnl not invoked when crosscompiling)
      echo "hej"
     )
   fi
 else
-  dnl and for crosscompilings
+  dnl and for crosscompiling
   AC_CHECK_FUNCS(gmtime_r)
 fi
 
 
 dnl **********************************************************************
 dnl Back to "normal" configuring
@@ -1824,12 +1862,13 @@
         time.h \
         io.h \
         pwd.h \
         utime.h \
         sys/utime.h \
         sys/poll.h \
+        poll.h \
         sys/resource.h \
         libgen.h \
         locale.h \
         errno.h \
         stdbool.h \
         arpa/tftp.h \
@@ -1871,12 +1910,13 @@
 #include <stdio.h>
 #include "$srcdir/include/curl/curl.h"
 ])
 AC_CHECK_SIZEOF(size_t)
 AC_CHECK_SIZEOF(long)
 AC_CHECK_SIZEOF(time_t)
+AC_CHECK_SIZEOF(off_t)
 
 AC_CHECK_TYPE(long long,
    [AC_DEFINE(HAVE_LONGLONG, 1, [if your compiler supports long long])]
    longlong="yes"
 )
 
@@ -2085,12 +2125,14 @@
   dnl to find out we make an extra check here!
   if test "$ac_cv_func_poll" = "yes"; then
     AC_MSG_CHECKING([if poll works with NULL inputs])
     AC_RUN_IFELSE([
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
+#elif defined(HAVE_POLL_H)
+#include <poll.h>
 #endif
 
   int main(void)
   {
     /* make this return 0 == timeout since there's nothing to read from */
     return poll((void *)0, 0, 10 /*ms*/);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/COPYING /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/COPYING
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/COPYING	2007-01-04 06:22:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/COPYING	2008-01-12 05:23:41.000000000 +0800
@@ -1,9 +1,9 @@
 COPYRIGHT AND PERMISSION NOTICE
 
-Copyright (c) 1996 - 2007, Daniel Stenberg, <daniel@haxx.se>.
+Copyright (c) 1996 - 2008, Daniel Stenberg, <daniel@haxx.se>.
 
 All rights reserved.
 
 Permission to use, copy, modify, and distribute this software for any purpose
 with or without fee is hereby granted, provided that the above copyright
 notice and this permission notice appear in all copies.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/curl-config.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/curl-config.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/curl-config.in	2007-10-27 06:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/curl-config.in	2008-01-11 06:14:02.000000000 +0800
@@ -3,26 +3,26 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 2001 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 2001 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: curl-config.in,v 1.30 2007-10-25 22:30:35 danf Exp $
+# $Id: curl-config.in,v 1.32 2008-01-10 22:14:02 bagder Exp $
 ###########################################################################
 #
 # The idea to this kind of setup info script was stolen from numerous
 # other packages, such as neon, libxml and gnome.
 #
 prefix=@prefix@
@@ -80,13 +80,13 @@
 	;;
 
     --feature|--features)
 	if test "@USE_SSLEAY@" = "1"; then
           echo "SSL"
           NTLM=1 # OpenSSL implies NTLM
-        elif test -n "@USE_GNUTLS@"; then
+        elif test -n "@SSL_ENABLED@"; then
           echo "SSL"
         fi
 	if test "@KRB4_ENABLED@" = "1"; then
           echo "KRB4"
         fi
 	if test "@IPV6_ENABLED@" = "1"; then
@@ -110,19 +110,19 @@
         fi
 	;;
 
     --protocols)
 	if test "@CURL_DISABLE_HTTP@" != "1"; then
           echo "HTTP"
-	  if test "@USE_SSLEAY@" = "1"; then
+	  if test "@SSL_ENABLED@" = "1"; then
             echo "HTTPS"
           fi
         fi
 	if test "@CURL_DISABLE_FTP@" != "1"; then
           echo "FTP"
-	  if test "@USE_SSLEAY@" = "1"; then
+	  if test "@SSL_ENABLED@" = "1"; then
             echo "FTPS"
           fi
         fi
 	if test "@CURL_DISABLE_FILE@" != "1"; then
           echo "FILE"
         fi
@@ -186,13 +186,13 @@
         else
           echo "-I@includedir@"
         fi
        	;;
 
     --libs)
-	if test "X@libdir@" != "X/usr/lib"; then
+	if test "X@libdir@" != "X/usr/lib" -a "X@libdir@" != "X/usr/lib64"; then
 	   CURLLIBDIR="-L@libdir@ "
 	else
 	   CURLLIBDIR=""
 	fi
 	if test "X@REQUIRE_LIB_DEPS@" = "Xyes"; then
 	  echo ${CURLLIBDIR}-lcurl @LDFLAGS@ @LIBCURL_LIBS@ @LIBS@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/BINDINGS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/BINDINGS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/BINDINGS	2007-09-26 20:51:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/BINDINGS	2008-01-18 05:46:03.000000000 +0800
@@ -69,13 +69,13 @@
 glib/GTK+
   Written by Richard Atterer
   http://atterer.net/glibcurl/
 
 Java
 
-  Maintained by Vic Hanson
+  Maintained by [blank]
   http://curl.haxx.se/libcurl/java/
 
 Lisp
 
   Written by Liam Healy
   http://common-lisp.net/project/cl-curl/
@@ -140,17 +140,26 @@
 
 Rexx
 
   Written Mark Hessling
   http://rexxcurl.sourceforge.net/
 
+RPG
+
+  Support for ILE/RPG on OS/400 is included in source distribution
+  http://curl.haxx.se/libcurl/
+  See packages/OS400/README.OS400 and packages/OS400/curl.inc.in
+
 Ruby
 
-  Written by Ross Bamford
+  curb - written by Ross Bamford
   http://curb.rubyforge.org/
 
+  ruby-curl-multi - written by Kristjan Petursson and Keith Rarick
+  http://curl-multi.rubyforge.org/
+
 Scheme
 
   Bigloo binding by Kirill Lisovsky
   http://curl.haxx.se/libcurl/scheme/
 
 S-Lang
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/CONTRIBUTE /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/CONTRIBUTE
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/CONTRIBUTE	2007-09-21 05:50:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/CONTRIBUTE	2007-11-05 17:27:21.000000000 +0800
@@ -99,12 +99,14 @@
  other code already does. It makes the source code a lot easier to follow if
  all of it is written using the same style. We don't ask you to like it, we
  just ask you to follow the tradition! ;-) This mainly means: 2-level indents,
  using spaces only (no tabs) and having the opening brace ({) on the same line
  as the if() or while().
 
+ Also note that we use if() and while() with no space before the parenthesis.
+
 2.3 Commenting
 
  Comment your source code extensively using C comments (/* comment */), DO NOT
  use C++ comments (// this style). Commented code is quality code and enables
  future modifications much more. Uncommented code risk having to be completely
  replaced when someone wants to extend things, since other persons' source
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/curl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/curl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/curl.1	2007-10-14 04:49:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/curl.1	2008-01-26 06:35:06.000000000 +0800
@@ -2,29 +2,29 @@
 .\" *                                  _   _ ____  _
 .\" *  Project                     ___| | | |  _ \| |
 .\" *                             / __| | | | |_) | |
 .\" *                            | (__| |_| |  _ <| |___
 .\" *                             \___|\___/|_| \_\_____|
 .\" *
-.\" * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+.\" * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 .\" *
 .\" * This software is licensed as described in the file COPYING, which
 .\" * you should have received as part of this distribution. The terms
 .\" * are also available at http://curl.haxx.se/docs/copyright.html.
 .\" *
 .\" * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 .\" * copies of the Software, and permit persons to whom the Software is
 .\" * furnished to do so, under the terms of the COPYING file.
 .\" *
 .\" * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 .\" * KIND, either express or implied.
 .\" *
-.\" * $Id: curl.1,v 1.229 2007-10-13 20:49:51 bagder Exp $
+.\" * $Id: curl.1,v 1.243 2008-01-25 22:35:06 bagder Exp $
 .\" **************************************************************************
 .\"
-.TH curl 1 "21 Sep 2007" "Curl 7.17.1" "Curl Manual"
+.TH curl 1 "5 Jan 2008" "Curl 7.18.0" "Curl Manual"
 .SH NAME
 curl \- transfer a URL
 .SH SYNOPSIS
 .B curl [options]
 .I [URL...]
 .SH DESCRIPTION
@@ -79,13 +79,13 @@
 getting many files from the same server will not do multiple connects /
 handshakes. This improves speed. Of course this is only done on files
 specified on a single command line and cannot be used between separate curl
 invokes.
 .SH "PROGRESS METER"
 curl normally displays a progress meter during operations, indicating amount
-of transfered data, transfer speeds and estimated time left etc.
+of transferred data, transfer speeds and estimated time left etc.
 
 However, since curl displays data to the terminal by default, if you invoke
 curl to do an operation and it is about to write data to the terminal, it
 \fIdisables\fP the progress meter as otherwise it would mess up the output
 mixing progress meter and response data.
 
@@ -112,16 +112,16 @@
 
 If this option is set more than once, the last one will be the one that's
 used.
 .IP "--anyauth"
 (HTTP) Tells curl to figure out authentication method by itself, and use the
 most secure one the remote site claims it supports. This is done by first
-doing a request and checking the response-headers, thus inducing an extra
-network round-trip. This is used instead of setting a specific authentication
-method, which you can do with \fI--basic\fP, \fI--digest\fP, \fI--ntlm\fP, and
-\fI--negotiate\fP.
+doing a request and checking the response-headers, thus possibly inducing an
+extra network round-trip. This is used instead of setting a specific
+authentication method, which you can do with \fI--basic\fP, \fI--digest\fP,
+\fI--ntlm\fP, and \fI--negotiate\fP.
 
 Note that using --anyauth is not recommended if you do uploads from stdin,
 since it may require data to be sent twice and then the client must be able to
 rewind. If the need should arise when uploading from stdin, the upload
 operation will fail.
 
@@ -221,49 +221,69 @@
 .IP "--crlf"
 (FTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).
 
 If this option is used several times, the following occurrences make no
 difference.
 .IP "-d/--data <data>"
-(HTTP) Sends the specified data in a POST request to the HTTP server, in a way
-that can emulate as if a user has filled in a HTML form and pressed the submit
-button. Note that the data is sent exactly as specified with no extra
-processing (with all newlines cut off).  The data is expected to be
-\&"url-encoded". This will cause curl to pass the data to the server using the
-content-type application/x-www-form-urlencoded. Compare to \fI-F/--form\fP. If
-this option is used more than once on the same command line, the data pieces
-specified will be merged together with a separating &-letter. Thus, using '-d
-name=daniel -d skill=lousy' would generate a post chunk that looks like
-\&'name=daniel&skill=lousy'.
+(HTTP) Sends the specified data in a POST request to the HTTP server, in the
+same way that a browser does when a user has filled in an HTML form and
+presses the submit button. This will cause curl to pass the data to the server
+using the content-type application/x-www-form-urlencoded.  Compare to
+\fI-F/--form\fP.
+
+\fI-d/--data\fP is the same as \fI--data-ascii\fP. To post data purely binary,
+you should instead use the \fI--data-binary\fP option. To URL encode the value
+of a form field you may use \fI--data-urlencode\fP.
+
+If any of these options is used more than once on the same command line, the
+data pieces specified will be merged together with a separating
+&-letter. Thus, using '-d name=daniel -d skill=lousy' would generate a post
+chunk that looks like \&'name=daniel&skill=lousy'.
 
 If you start the data with the letter @, the rest should be a file name to
 read the data from, or - if you want curl to read the data from stdin.  The
 contents of the file must already be url-encoded. Multiple files can also be
 specified. Posting data from a file named 'foobar' would thus be done with
-\fI--data\fP @foobar".
-
-To post data purely binary, you should instead use the \fI--data-binary\fP
-option.
-
-\fI-d/--data\fP is the same as \fI--data-ascii\fP.
-
-If this option is used several times, the ones following the first will
-append data.
-.IP "--data-ascii <data>"
-(HTTP) This is an alias for the \fI-d/--data\fP option.
-
-If this option is used several times, the ones following the first will
-append data.
+\fI--data @foobar\fP.
 .IP "--data-binary <data>"
-(HTTP) This posts data in a similar manner as \fI--data-ascii\fP does,
-although when using this option the entire context of the posted data is kept
-as-is. If you want to post a binary file without the strip-newlines feature of
-the \fI--data-ascii\fP option, this is for you.
+(HTTP) This posts data exactly as specified with no extra processing
+whatsoever.
 
-If this option is used several times, the ones following the first will
-append data.
+If you start the data with the letter @, the rest should be a filename.  Data
+is posted in a similar manner as \fI--data-ascii\fP does, except that newlines
+are preserved and conversions are never done.
+
+If this option is used several times, the ones following the first will append
+data. As described in \fI-d/--data\fP.
+.IP "--data-urlencode <data>"
+(HTTP) This posts data, similar to the other --data options with the exception
+that this performs URL encoding. (Added in 7.18.0)
+
+To be CGI compliant, the <data> part should begin with a \fIname\fP followed
+by a separator and a content specification. The <data> part can be passed to
+curl using one of the following syntaxes:
+.RS
+.IP "content"
+This will make curl URL encode the content and pass that on. Just be careful
+so that the content doesn't contain any = or @ letters, as that will then make
+the syntax match one of the other cases below!
+.IP "=content"
+This will make curl URL encode the content and pass that on. The preceding =
+letter is not included in the data.
+.IP "name=content"
+This will make curl URL encode the content part and pass that on. Note that
+the name part is expected to be URL encoded already.
+.IP "@filename"
+This will make curl load data from the given file (including any newlines),
+URL encode that data and pass it on in the POST.
+.IP "name@filename"
+This will make curl load data from the given file (including any newlines),
+URL encode that data and pass it on in the POST. The name part gets an equal
+sign appended, resulting in \fIname=urlencoded-file-content\fP. Note that the
+name is expected to be URL encoded already.
+.RE
 .IP "--digest"
 (HTTP) Enables HTTP Digest authentication. This is a authentication that
 prevents the password from being sent over the wire in clear text. Use this in
 combination with the normal \fI-u/--user\fP option to set user name and
 password. See also \fI--ntlm\fP, \fI--negotiate\fP and \fI--anyauth\fP for
 related options.
@@ -543,13 +563,13 @@
 
 See also the \fI-A/--user-agent\fP and \fI-e/--referer\fP options.
 
 This option can be used multiple times to add/replace/remove multiple headers.
 .IP "--hostpubmd5"
 Pass a string containing 32 hexadecimal digits. The string should be the 128
-bit MD5 cheksum of the remote host's public key, curl will refuse the
+bit MD5 checksum of the remote host's public key, curl will refuse the
 connection with the host unless the md5sums match. This option is only for SCP
 and SFTP transfers. (Added in 7.17.1)
 .IP "--ignore-content-length"
 (HTTP)
 Ignore the Content-Length header. This is particularly useful for servers
 running Apache 1.x, which will report incorrect Content-Length for files
@@ -589,12 +609,20 @@
 considered "insecure" to fail unless \fI-k/--insecure\fP is used.
 
 See this online resource for further details:
 \fBhttp://curl.haxx.se/docs/sslcerts.html\fP
 
 If this option is used twice, the second time will again disable it.
+.IP "--keepalive-time <seconds>"
+This option sets the time a connection needs to remain idle before sending
+keepalive probes and the time between individual keepalive probes. It is
+currently effective on operating systems offering the TCP_KEEPIDLE and
+TCP_KEEPINTVL socket options (meaning Linux, recent AIX, HP-UX and more). This
+option has no effect if \fI--no-keepalive\fP is used. (Added in 7.18.0)
+
+If this option is used multiple times, the last occurrence sets the amount.
 .IP "--key <key>"
 (SSL/SSH) Private key file name. Allows you to provide your private key in this
 separate file.
 
 If this option is used several times, the last one will be used.
 .IP "--key-type <type>"
@@ -614,14 +642,18 @@
 
 If this option is used several times, the last one will be used.
 .IP "-K/--config <config file>"
 Specify which config file to read curl arguments from. The config file is a
 text file in which command line arguments can be written which then will be
 used as if they were written on the actual command line. Options and their
-parameters must be specified on the same config file line. If the parameter is
-to contain white spaces, the parameter must be enclosed within quotes.  If the
+parameters must be specified on the same config file line, separated by
+white space, colon, the equals sign or any combination thereof (however,
+the preferred separator is the equals sign). If the parameter is to contain
+white spaces, the parameter must be enclosed within quotes. Within double
+quotes, the following escape sequences are available: \\\\, \\", \\t, \\n,
+\\r and \\v. A backlash preceding any other letter is  ignored. If the
 first column of a config line is a '#' character, the rest of the line will be
 treated as a comment. Only write one option per physical line in the config
 file.
 
 Specify the filename to -K/--config as '-' to make curl read the file from
 stdin.
@@ -670,13 +702,14 @@
 operation of what your command line operation does!
 
 NOTE: this does not properly support -F and the sending of multipart
 formposts, so in those cases the output program will be missing necessary
 calls to \fIcurl_formadd(3)\fP, and possibly more.
 
-If this option is used several times, the last given file name will be used.
+If this option is used several times, the last given file name will be
+used. (Added in 7.16.1)
 .IP "--limit-rate <speed>"
 Specify the maximum transfer rate you want curl to use. This feature is useful
 if you have a limited pipe and you'd like your transfer not use your entire
 bandwidth.
 
 The given speed is measured in bytes/second, unless a suffix is appended.
@@ -796,12 +829,17 @@
 Disables the buffering of the output stream. In normal work situations, curl
 will use a standard buffered output stream that will have the effect that it
 will output the data in chunks, not necessarily exactly when the data arrives.
 Using this option will disable that buffering.
 
 If this option is used twice, the second will again switch on buffering.
+.IP "--no-keepalive"
+Disables the use of keepalive messages on the TCP connection, as by default
+curl enables them.
+
+If this option is used twice, the second will again enable keepalive.
 .IP "--no-sessionid"
 (SSL) Disable curl's use of SSL session-ID caching.  By default all transfers
 are done using the cache. Note that while nothing ever should get hurt by
 attempting to reuse SSL session-IDs, there seem to be broken SSL
 implementations in the wild that may require you to disable this in order for
 you to succeed. (Added in 7.16.0)
@@ -858,13 +896,13 @@
 in web browsers, so curl does the conversion by default to maintain
 consistency. However, a server may requires a POST to remain a POST after such
 a redirection. This option is meaningful only when using \fI-L/--location\fP
 (Added in 7.17.1)
 .IP "--proxy-anyauth"
 Tells curl to pick a suitable authentication method when communicating with
-the given proxy. This will cause an extra request/response round-trip. (Added
+the given proxy. This might cause an extra request/response round-trip. (Added
 in 7.13.2)
 
 If this option is used twice, the second will again disable the proxy use-any
 authentication.
 .IP "--proxy-basic"
 Tells curl to use HTTP Basic authentication when communicating with the given
@@ -945,15 +983,15 @@
 This option can be used multiple times.
 .IP "--random-file <file>"
 (SSL) Specify the path name to file containing what will be considered as
 random data. The data is used to seed the random engine for SSL connections.
 See also the \fI--egd-file\fP option.
 .IP "-r/--range <range>"
-(HTTP/FTP)
-Retrieve a byte range (i.e a partial document) from a HTTP/1.1 or FTP
-server. Ranges can be specified in a number of ways.
+(HTTP/FTP/FILE) Retrieve a byte range (i.e a partial document) from a
+HTTP/1.1, FTP server or a local FILE. Ranges can be specified in a number of
+ways.
 .RS
 .TP 10
 .B 0-499
 specifies the first 500 bytes
 .TP
 .B 500-999
@@ -1046,15 +1084,34 @@
 assumed at port 1080. (Added in 7.15.2)
 
 This option overrides any previous use of \fI-x/--proxy\fP, as they are
 mutually exclusive.
 
 If this option is used several times, the last one will be used.
+.IP "--socks4a <host[:port]>"
+Use the specified SOCKS4a proxy. If the port number is not specified, it is
+assumed at port 1080. (Added in 7.18.0)
+
+This option overrides any previous use of \fI-x/--proxy\fP, as they are
+mutually exclusive.
+
+If this option is used several times, the last one will be used.
+.IP "--socks5-hostname <host[:port]>"
+Use the specified SOCKS5 proxy (and let the proxy resolve the host name). If
+the port number is not specified, it is assumed at port 1080. (Added in
+7.18.0)
+
+This option overrides any previous use of \fI-x/--proxy\fP, as they are
+mutually exclusive.
+
+If this option is used several times, the last one will be used. (This option
+was previously wrongly documented and used as --socks without the number
+appended.)
 .IP "--socks5 <host[:port]>"
-Use the specified SOCKS5 proxy. If the port number is not specified, it is
-assumed at port 1080. (Added in 7.11.1)
+Use the specified SOCKS5 proxy - but resolve the host name locally. If the
+port number is not specified, it is assumed at port 1080.
 
 This option overrides any previous use of \fI-x/--proxy\fP, as they are
 mutually exclusive.
 
 If this option is used several times, the last one will be used. (This option
 was previously wrongly documented and used as --socks without the number
@@ -1125,12 +1182,15 @@
 
 If this option is used several times, each occurrence will toggle it on/off.
 .IP "-u/--user <user:password>"
 Specify user and password to use for server authentication. Overrides
 \fI-n/--netrc\fP and \fI--netrc-optional\fP.
 
+If you just give the user name (without entering a colon) curl will prompt for
+a password.
+
 If you use an SSPI-enabled curl binary and do NTLM authentication, you can
 force curl to pick up the user name and password from your environment by
 simply specifying a single colon with this option: "-u :".
 
 If this option is used several times, the last one will be used.
 .IP "-U/--proxy-user <user:password>"
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/curl-config.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/curl-config.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/curl.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/curl.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/curl.html	2007-10-24 17:24:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/curl.html	2008-01-28 19:31:58.000000000 +0800
@@ -58,26 +58,26 @@
 <p class="level0">&nbsp;<a href="http://any.org/archive">http://any.org/archive</a>[1996-1999]/vol[1-4]/part{a,b,c}.html 
 <p class="level0">You can specify any amount of URLs on the command line. They will be fetched in a sequential manner in the specified order. 
 <p class="level0">Since curl 7.15.1 you can also specify step counter for the ranges, so that you can get every Nth number or letter: 
 <p class="level0">&nbsp;<a href="http://www.numericals.com/file">http://www.numericals.com/file</a>[1-100:10].txt &nbsp;<a href="http://www.letters.com/file">http://www.letters.com/file</a>[a-z:2].txt 
 <p class="level0">If you specify URL without protocol:// prefix, curl will attempt to guess what protocol you might want. It will then default to HTTP but try other protocols based on often-used host name prefixes. For example, for host names starting with "ftp." curl will assume you want to speak FTP. 
 <p class="level0">Curl will attempt to re-use connections for multiple file transfers, so that getting many files from the same server will not do multiple connects / handshakes. This improves speed. Of course this is only done on files specified on a single command line and cannot be used between separate curl invokes. <a name="PROGRESS"></a><h2 class="nroffsh">PROGRESS METER</h2>
-<p class="level0">curl normally displays a progress meter during operations, indicating amount of transfered data, transfer speeds and estimated time left etc. 
+<p class="level0">curl normally displays a progress meter during operations, indicating amount of transferred data, transfer speeds and estimated time left etc. 
 <p class="level0">However, since curl displays data to the terminal by default, if you invoke curl to do an operation and it is about to write data to the terminal, it <span Class="emphasis">disables</span> the progress meter as otherwise it would mess up the output mixing progress meter and response data. 
 <p class="level0">If you want a progress meter for HTTP POST or PUT requests, you need to redirect the response output to a file, using shell redirect (&gt;), -o [file] or similar. 
 <p class="level0">It is not the same case for FTP upload as that operation is not spitting out any response data to the terminal. 
 <p class="level0">If you prefer a progress "bar" instead of the regular meter, <a class="emphasis" href="#-">-#</a> is your friend. <a name="OPTIONS"></a><h2 class="nroffsh">OPTIONS</h2>
 <p class="level0">
 <p class="level0"><a name="-a--append"></a><span class="nroffip">-a/--append</span> 
 <p class="level1">(FTP) When used in an FTP upload, this will tell curl to append to the target file instead of overwriting it. If the file doesn't exist, it will be created. 
 <p class="level1">If this option is used twice, the second one will disable append mode again. 
 <p class="level0"><a name="-A--user-agent"></a><span class="nroffip">-A/--user-agent &lt;agent string&gt;</span> 
 <p class="level1">(HTTP) Specify the User-Agent string to send to the HTTP server. Some badly done CGIs fail if this field isn't set to "Mozilla/4.0". To encode blanks in the string, surround the string with single quote marks. This can also be set with the <a class="emphasis" href="#-H--header">-H/--header</a> option of course. 
 <p class="level1">If this option is set more than once, the last one will be the one that's used. 
 <p class="level0"><a name="--anyauth"></a><span class="nroffip">--anyauth</span> 
-<p class="level1">(HTTP) Tells curl to figure out authentication method by itself, and use the most secure one the remote site claims it supports. This is done by first doing a request and checking the response-headers, thus inducing an extra network round-trip. This is used instead of setting a specific authentication method, which you can do with <a class="emphasis" href="#--basic">--basic</a>, <a class="emphasis" href="#--digest">--digest</a>, <a class="emphasis" href="#--ntlm">--ntlm</a>, and <a class="emphasis" href="#--negotiate">--negotiate</a>. 
+<p class="level1">(HTTP) Tells curl to figure out authentication method by itself, and use the most secure one the remote site claims it supports. This is done by first doing a request and checking the response-headers, thus possibly inducing an extra network round-trip. This is used instead of setting a specific authentication method, which you can do with <a class="emphasis" href="#--basic">--basic</a>, <a class="emphasis" href="#--digest">--digest</a>, <a class="emphasis" href="#--ntlm">--ntlm</a>, and <a class="emphasis" href="#--negotiate">--negotiate</a>. 
 <p class="level1">Note that using --anyauth is not recommended if you do uploads from stdin, since it may require data to be sent twice and then the client must be able to rewind. If the need should arise when uploading from stdin, the upload operation will fail. 
 <p class="level1">If this option is used several times, the following occurrences make no difference. 
 <p class="level0"><a name="-b--cookie"></a><span class="nroffip">-b/--cookie &lt;name=data&gt;</span> 
 <p class="level1">(HTTP) Pass the data to the HTTP server as a cookie. It is supposedly the data previously received from the server in a "Set-Cookie:" line. The data should be in the format "NAME1=VALUE1; NAME2=VALUE2". 
 <p class="level1">If no '=' letter is used in the line, it is treated as a filename to use to read previously stored cookie lines from, which should be used in this session if they match. Using this method also activates the "cookie parser" which will make curl record incoming cookies too, which may be handy if you're using this in combination with the <a class="emphasis" href="#-L--location">-L/--location</a> option. The file format of the file to read cookies from should be plain HTTP headers or the Netscape/Mozilla cookie file format. 
 <p class="level1"><span Class="bold">NOTE</span> that the file specified with <a class="emphasis" href="#-b--cookie">-b/--cookie</a> is only used as input. No cookies will be stored in the file. To store cookies, use the <a class="emphasis" href="#-c--cookie-jar">-c/--cookie-jar</a> option or you could even save the HTTP headers to a file using <a class="emphasis" href="#-D--dump-header">-D/--dump-header</a>! 
@@ -110,23 +110,35 @@
 <p class="level1">When used in conjunction with the -o option, curl will create the necessary local directory hierarchy as needed. This option creates the dirs mentioned with the -o option, nothing else. If the -o file name uses no dir or if the dirs it mentions already exist, no dir will be created. 
 <p class="level1">To create remote directories when using FTP or SFTP, try  <a class="emphasis" href="#--ftp-create-dirs">--ftp-create-dirs</a>. 
 <p class="level0"><a name="--crlf"></a><span class="nroffip">--crlf</span> 
 <p class="level1">(FTP) Convert LF to CRLF in upload. Useful for MVS (OS/390). 
 <p class="level1">If this option is used several times, the following occurrences make no difference. 
 <p class="level0"><a name="-d--data"></a><span class="nroffip">-d/--data &lt;data&gt;</span> 
-<p class="level1">(HTTP) Sends the specified data in a POST request to the HTTP server, in a way that can emulate as if a user has filled in a HTML form and pressed the submit button. Note that the data is sent exactly as specified with no extra processing (with all newlines cut off).  The data is expected to be "url-encoded". This will cause curl to pass the data to the server using the content-type application/x-www-form-urlencoded. Compare to <a class="emphasis" href="#-F--form">-F/--form</a>. If this option is used more than once on the same command line, the data pieces specified will be merged together with a separating &-letter. Thus, using '-d name=daniel -d skill=lousy' would generate a post chunk that looks like 'name=daniel&skill=lousy'. 
-<p class="level1">If you start the data with the letter @, the rest should be a file name to read the data from, or - if you want curl to read the data from stdin.  The contents of the file must already be url-encoded. Multiple files can also be specified. Posting data from a file named 'foobar' would thus be done with <span Class="emphasis">--data</span> @foobar". 
-<p class="level1">To post data purely binary, you should instead use the <a class="emphasis" href="#--data-binary">--data-binary</a> option. 
-<p class="level1"><a class="emphasis" href="#-d--data">-d/--data</a> is the same as <a class="emphasis" href="#--data-ascii">--data-ascii</a>. 
-<p class="level1">If this option is used several times, the ones following the first will append data. 
-<p class="level0"><a name="--data-ascii"></a><span class="nroffip">--data-ascii &lt;data&gt;</span> 
-<p class="level1">(HTTP) This is an alias for the <a class="emphasis" href="#-d--data">-d/--data</a> option. 
-<p class="level1">If this option is used several times, the ones following the first will append data. 
+<p class="level1">(HTTP) Sends the specified data in a POST request to the HTTP server, in the same way that a browser does when a user has filled in an HTML form and presses the submit button. This will cause curl to pass the data to the server using the content-type application/x-www-form-urlencoded.  Compare to <a class="emphasis" href="#-F--form">-F/--form</a>. 
+<p class="level1"><a class="emphasis" href="#-d--data">-d/--data</a> is the same as <span Class="emphasis">--data-ascii</span>. To post data purely binary, you should instead use the <a class="emphasis" href="#--data-binary">--data-binary</a> option. To URL encode the value of a form field you may use <a class="emphasis" href="#--data-urlencode">--data-urlencode</a>. 
+<p class="level1">If any of these options is used more than once on the same command line, the data pieces specified will be merged together with a separating &-letter. Thus, using '-d name=daniel -d skill=lousy' would generate a post chunk that looks like 'name=daniel&skill=lousy'. 
+<p class="level1">If you start the data with the letter @, the rest should be a file name to read the data from, or - if you want curl to read the data from stdin.  The contents of the file must already be url-encoded. Multiple files can also be specified. Posting data from a file named 'foobar' would thus be done with <span Class="emphasis">--data @foobar</span>. 
 <p class="level0"><a name="--data-binary"></a><span class="nroffip">--data-binary &lt;data&gt;</span> 
-<p class="level1">(HTTP) This posts data in a similar manner as <a class="emphasis" href="#--data-ascii">--data-ascii</a> does, although when using this option the entire context of the posted data is kept as-is. If you want to post a binary file without the strip-newlines feature of the <a class="emphasis" href="#--data-ascii">--data-ascii</a> option, this is for you. 
-<p class="level1">If this option is used several times, the ones following the first will append data. 
+<p class="level1">(HTTP) This posts data exactly as specified with no extra processing whatsoever. 
+<p class="level1">If you start the data with the letter @, the rest should be a filename.  Data is posted in a similar manner as <span Class="emphasis">--data-ascii</span> does, except that newlines are preserved and conversions are never done. 
+<p class="level1">If this option is used several times, the ones following the first will append data. As described in <a class="emphasis" href="#-d--data">-d/--data</a>. 
+<p class="level0"><a name="--data-urlencode"></a><span class="nroffip">--data-urlencode &lt;data&gt;</span> 
+<p class="level1">(HTTP) This posts data, similar to the other --data options with the exception that this performs URL encoding. (Added in 7.18.0) 
+<p class="level1">To be CGI compliant, the &lt;data&gt; part should begin with a <span Class="emphasis">name</span> followed by a separator and a content specification. The &lt;data&gt; part can be passed to curl using one of the following syntaxes: 
+<p class="level2">
+<p class="level1"><a name="content"></a><span class="nroffip">content</span> 
+<p class="level2">This will make curl URL encode the content and pass that on. Just be careful so that the content doesn't contain any = or @ letters, as that will then make the syntax match one of the other cases below! 
+<p class="level1"><a name="content"></a><span class="nroffip">=content</span> 
+<p class="level2">This will make curl URL encode the content and pass that on. The preceding = letter is not included in the data. 
+<p class="level1"><a name="namecontent"></a><span class="nroffip">name=content</span> 
+<p class="level2">This will make curl URL encode the content part and pass that on. Note that the name part is expected to be URL encoded already. 
+<p class="level1"><a name="filename"></a><span class="nroffip">@filename</span> 
+<p class="level2">This will make curl load data from the given file (including any newlines), URL encode that data and pass it on in the POST. 
+<p class="level1"><a name="namefilename"></a><span class="nroffip">name@filename</span> 
+<p class="level2">This will make curl load data from the given file (including any newlines), URL encode that data and pass it on in the POST. The name part gets an equal sign appended, resulting in <span Class="emphasis">name=urlencoded-file-content</span>. Note that the name is expected to be URL encoded already. 
+<p class="level1">
 <p class="level0"><a name="--digest"></a><span class="nroffip">--digest</span> 
 <p class="level1">(HTTP) Enables HTTP Digest authentication. This is a authentication that prevents the password from being sent over the wire in clear text. Use this in combination with the normal <a class="emphasis" href="#-u--user">-u/--user</a> option to set user name and password. See also <a class="emphasis" href="#--ntlm">--ntlm</a>, <a class="emphasis" href="#--negotiate">--negotiate</a> and <a class="emphasis" href="#--anyauth">--anyauth</a> for related options. 
 <p class="level1">If this option is used several times, the following occurrences make no difference. 
 <p class="level0"><a name="--disable-eprt"></a><span class="nroffip">--disable-eprt</span> 
 <p class="level1">(FTP) Tell curl to disable the use of the EPRT and LPRT commands when doing active FTP transfers. Curl will normally always first attempt to use EPRT, then LPRT before using PORT, but with this option, it will use PORT right away. EPRT and LPRT are extensions to the original FTP protocol, may not work on all servers but enable more functionality in a better way than the traditional PORT command. 
 <p class="level1">If this option is used several times, each occurrence will toggle this on/off. 
@@ -233,13 +245,13 @@
 <p class="level0"><a name="-H--header"></a><span class="nroffip">-H/--header &lt;header&gt;</span> 
 <p class="level1">(HTTP) Extra header to use when getting a web page. You may specify any number of extra headers. Note that if you should add a custom header that has the same name as one of the internal ones curl would use, your externally set header will be used instead of the internal one. This allows you to make even trickier stuff than curl would normally do. You should not replace internally set headers without knowing perfectly well what you're doing. Remove an internal header by giving a replacement without content on the right side of the colon, as in: -H "Host:". 
 <p class="level1">curl will make sure that each header you add/replace get sent with the proper end of line marker, you should thus <span Class="bold">not</span> add that as a part of the header content: do not add newlines or carriage returns they will only mess things up for you. 
 <p class="level1">See also the <a class="emphasis" href="#-A--user-agent">-A/--user-agent</a> and <a class="emphasis" href="#-e--referer">-e/--referer</a> options. 
 <p class="level1">This option can be used multiple times to add/replace/remove multiple headers. 
 <p class="level0"><a name="--hostpubmd5"></a><span class="nroffip">--hostpubmd5</span> 
-<p class="level1">Pass a string containing 32 hexadecimal digits. The string should be the 128 bit MD5 cheksum of the remote host's public key, curl will refuse the connection with the host unless the md5sums match. This option is only for SCP and SFTP transfers. (Added in 7.17.1) 
+<p class="level1">Pass a string containing 32 hexadecimal digits. The string should be the 128 bit MD5 checksum of the remote host's public key, curl will refuse the connection with the host unless the md5sums match. This option is only for SCP and SFTP transfers. (Added in 7.17.1) 
 <p class="level0"><a name="--ignore-content-length"></a><span class="nroffip">--ignore-content-length</span> 
 <p class="level1">(HTTP) Ignore the Content-Length header. This is particularly useful for servers running Apache 1.x, which will report incorrect Content-Length for files larger than 2 gigabytes. 
 <p class="level0"><a name="-i--include"></a><span class="nroffip">-i/--include</span> 
 <p class="level1">(HTTP) Include the HTTP-header in the output. The HTTP-header includes things like server-name, date of the document, HTTP-version and more... 
 <p class="level1">If this option is used twice, the second will again disable header include. 
 <p class="level0"><a name="--interface"></a><span class="nroffip">--interface &lt;name&gt;</span> 
@@ -253,24 +265,27 @@
 <p class="level1">(HTTP) When curl is told to read cookies from a given file, this option will make it discard all "session cookies". This will basically have the same effect as if a new session is started. Typical browsers always discard session cookies when they're closed down. 
 <p class="level1">If this option is used several times, each occurrence will toggle this on/off. 
 <p class="level0"><a name="-k--insecure"></a><span class="nroffip">-k/--insecure</span> 
 <p class="level1">(SSL) This option explicitly allows curl to perform "insecure" SSL connections and transfers. All SSL connections are attempted to be made secure by using the CA certificate bundle installed by default. This makes all connections considered "insecure" to fail unless <a class="emphasis" href="#-k--insecure">-k/--insecure</a> is used. 
 <p class="level1">See this online resource for further details: <span Class="bold"><a href="http://curl.haxx.se/docs/sslcerts.html">http://curl.haxx.se/docs/sslcerts.html</a></span> 
 <p class="level1">If this option is used twice, the second time will again disable it. 
+<p class="level0"><a name="--keepalive-time"></a><span class="nroffip">--keepalive-time &lt;seconds&gt;</span> 
+<p class="level1">This option sets the time a connection needs to remain idle before sending keepalive probes and the time between individual keepalive probes. It is currently effective on operating systems offering the TCP_KEEPIDLE and TCP_KEEPINTVL socket options (meaning Linux, recent AIX, HP-UX and more). This option has no effect if <a class="emphasis" href="#--no-keepalive">--no-keepalive</a> is used. (Added in 7.18.0) 
+<p class="level1">If this option is used multiple times, the last occurrence sets the amount. 
 <p class="level0"><a name="--key"></a><span class="nroffip">--key &lt;key&gt;</span> 
 <p class="level1">(SSL/SSH) Private key file name. Allows you to provide your private key in this separate file. 
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="--key-type"></a><span class="nroffip">--key-type &lt;type&gt;</span> 
 <p class="level1">(SSL) Private key file type. Specify which type your <a class="emphasis" href="#--key">--key</a> provided private key is. DER, PEM and ENG are supported. If not specified, PEM is assumed. 
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="--krb"></a><span class="nroffip">--krb &lt;level&gt;</span> 
 <p class="level1">(FTP) Enable Kerberos authentication and use. The level must be entered and should be one of 'clear', 'safe', 'confidential' or 'private'. Should you use a level that is not one of these, 'private' will instead be used. 
 <p class="level1">This option requires that the library was built with kerberos4 or GSSAPI (GSS-Negotiate) support. This is not very common. Use <a class="emphasis" href="#-V--version">-V/--version</a> to see if your curl supports it. 
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="-K--config"></a><span class="nroffip">-K/--config &lt;config file&gt;</span> 
-<p class="level1">Specify which config file to read curl arguments from. The config file is a text file in which command line arguments can be written which then will be used as if they were written on the actual command line. Options and their parameters must be specified on the same config file line. If the parameter is to contain white spaces, the parameter must be enclosed within quotes.  If the first column of a config line is a '#' character, the rest of the line will be treated as a comment. Only write one option per physical line in the config file. 
+<p class="level1">Specify which config file to read curl arguments from. The config file is a text file in which command line arguments can be written which then will be used as if they were written on the actual command line. Options and their parameters must be specified on the same config file line, separated by white space, colon, the equals sign or any combination thereof (however, the preferred separator is the equals sign). If the parameter is to contain white spaces, the parameter must be enclosed within quotes. Within double quotes, the following escape sequences are available: \\, \", \t, \n, \r and \v. A backlash preceding any other letter is  ignored. If the first column of a config line is a '#' character, the rest of the line will be treated as a comment. Only write one option per physical line in the config file. 
 <p class="level1">Specify the filename to -K/--config as '-' to make curl read the file from stdin. 
 <p class="level1">Note that to be able to specify a URL in the config file, you need to specify it using the <a class="emphasis" href="#--url">--url</a> option, and not by simply writing the URL on its own line. So, it could look similar to this: 
 <p class="level1">url = "<a href="http://curl.haxx.se/docs/">http://curl.haxx.se/docs/</a>" 
 <p class="level1">Long option names can optionally be given in the config file without the initial double dashes. 
 <p class="level1">When curl is invoked, it always (unless <a class="emphasis" href="#-q">-q</a> is used) checks for a default config file and uses it if found. The default config file is checked for in the following places in this order: 
 <p class="level1">1) curl tries to find the "home dir": It first checks for the CURL_HOME and then the HOME environment variables. Failing that, it uses getpwuid() on unix-like systems (which returns the home dir given the current user in your system). On Windows, it then checks for the APPDATA variable, or as a last resort the '%USERPROFILE%Application Data'. 
@@ -290,13 +305,13 @@
 
 <p class="level1">
 <p class="level1">This option can be used multiple times to load multiple config files. 
 <p class="level0"><a name="--libcurl"></a><span class="nroffip">--libcurl &lt;file&gt;</span> 
 <p class="level1">Append this option to any ordinary curl command line, and you will get a libcurl-using source code written to the file that does the equivalent operation of what your command line operation does! 
 <p class="level1">NOTE: this does not properly support -F and the sending of multipart formposts, so in those cases the output program will be missing necessary calls to <span Class="emphasis">curl_formadd(3)</span>, and possibly more. 
-<p class="level1">If this option is used several times, the last given file name will be used. 
+<p class="level1">If this option is used several times, the last given file name will be used. (Added in 7.16.1) 
 <p class="level0"><a name="--limit-rate"></a><span class="nroffip">--limit-rate &lt;speed&gt;</span> 
 <p class="level1">Specify the maximum transfer rate you want curl to use. This feature is useful if you have a limited pipe and you'd like your transfer not use your entire bandwidth. 
 <p class="level1">The given speed is measured in bytes/second, unless a suffix is appended. Appending 'k' or 'K' will count the number as kilobytes, 'm' or M' makes it megabytes while 'g' or 'G' makes it gigabytes. Examples: 200K, 3m and 1G. 
 <p class="level1">The given rate is the average speed, counted during the entire transfer. It means that curl might use higher transfer speeds in short bursts, but over time it uses no more than the given rate. 
 <p class="level1">If you are also using the <a class="emphasis" href="#-Y--speed-limit">-Y/--speed-limit</a> option, that option will take precedence and might cripple the rate-limiting slightly, to help keeping the speed-limit logic working. 
 <p class="level1">If this option is used several times, the last one will be used. 
@@ -334,12 +349,15 @@
 <p class="level1">This option requires that the library was built with GSSAPI support. This is not very common. Use <a class="emphasis" href="#-V--version">-V/--version</a> to see if your version supports GSS-Negotiate. 
 <p class="level1">When using this option, you must also provide a fake -u/--user option to activate the authentication code properly. Sending a '-u :' is enough as the user name and password from the -u option aren't actually used. 
 <p class="level1">If this option is used several times, the following occurrences make no difference. 
 <p class="level0"><a name="-N--no-buffer"></a><span class="nroffip">-N/--no-buffer</span> 
 <p class="level1">Disables the buffering of the output stream. In normal work situations, curl will use a standard buffered output stream that will have the effect that it will output the data in chunks, not necessarily exactly when the data arrives. Using this option will disable that buffering. 
 <p class="level1">If this option is used twice, the second will again switch on buffering. 
+<p class="level0"><a name="--no-keepalive"></a><span class="nroffip">--no-keepalive</span> 
+<p class="level1">Disables the use of keepalive messages on the TCP connection, as by default curl enables them. 
+<p class="level1">If this option is used twice, the second will again enable keepalive. 
 <p class="level0"><a name="--no-sessionid"></a><span class="nroffip">--no-sessionid</span> 
 <p class="level1">(SSL) Disable curl's use of SSL session-ID caching.  By default all transfers are done using the cache. Note that while nothing ever should get hurt by attempting to reuse SSL session-IDs, there seem to be broken SSL implementations in the wild that may require you to disable this in order for you to succeed. (Added in 7.16.0) 
 <p class="level1">If this option is used twice, the second will again switch on use of the session cache. 
 <p class="level0"><a name="--ntlm"></a><span class="nroffip">--ntlm</span> 
 <p class="level1">(HTTP) Enables NTLM authentication. The NTLM authentication method was designed by Microsoft and is used by IIS web servers. It is a proprietary protocol, reversed engineered by clever people and implemented in curl based on their efforts. This kind of behavior should not be endorsed, you should encourage everyone who uses NTLM to switch to a public and documented authentication method instead. Such as Digest. 
 <p class="level1">If you want to enable NTLM for your proxy authentication, then use <a class="emphasis" href="#--proxy-ntlm">--proxy-ntlm</a>. 
@@ -359,13 +377,13 @@
 <p class="level0"><a name="--pass"></a><span class="nroffip">--pass &lt;phrase&gt;</span> 
 <p class="level1">(SSL/SSH) Pass phrase for the private key 
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="--post301"></a><span class="nroffip">--post301</span> 
 <p class="level1">Tells curl to respect RFC 2616/10.3.2 and not convert POST requests into GET requests when following a 301 redirection. The non-RFC behaviour is ubiquitous in web browsers, so curl does the conversion by default to maintain consistency. However, a server may requires a POST to remain a POST after such a redirection. This option is meaningful only when using <a class="emphasis" href="#-L--location">-L/--location</a> (Added in 7.17.1) 
 <p class="level0"><a name="--proxy-anyauth"></a><span class="nroffip">--proxy-anyauth</span> 
-<p class="level1">Tells curl to pick a suitable authentication method when communicating with the given proxy. This will cause an extra request/response round-trip. (Added in 7.13.2) 
+<p class="level1">Tells curl to pick a suitable authentication method when communicating with the given proxy. This might cause an extra request/response round-trip. (Added in 7.13.2) 
 <p class="level1">If this option is used twice, the second will again disable the proxy use-any authentication. 
 <p class="level0"><a name="--proxy-basic"></a><span class="nroffip">--proxy-basic</span> 
 <p class="level1">Tells curl to use HTTP Basic authentication when communicating with the given proxy. Use <a class="emphasis" href="#--basic">--basic</a> for enabling HTTP Basic with a remote host. Basic is the default authentication method curl uses with proxies. 
 <p class="level1">If this option is used twice, the second will again disable proxy HTTP Basic authentication. 
 <p class="level0"><a name="--proxy-digest"></a><span class="nroffip">--proxy-digest</span> 
 <p class="level1">Tells curl to use HTTP Digest authentication when communicating with the given proxy. Use <a class="emphasis" href="#--digest">--digest</a> for enabling HTTP Digest with a remote host. 
@@ -400,13 +418,13 @@
 <p class="level0"><a name="-Q--quote"></a><span class="nroffip">-Q/--quote &lt;command&gt;</span> 
 <p class="level1">(FTP/SFTP) Send an arbitrary command to the remote FTP or SFTP server. Quote commands are sent BEFORE the transfer is taking place (just after the initial PWD command in an FTP transfer, to be exact). To make commands take place after a successful transfer, prefix them with a dash '-'. To make commands get sent after libcurl has changed working directory, just before the transfer command(s), prefix the command with '+' (this is only supported for FTP). You may specify any number of commands. If the server returns failure for one of the commands, the entire operation will be aborted. You must send syntactically correct FTP commands as RFC959 defines to FTP servers, or one of the following commands (with appropriate arguments) to SFTP servers: chgrp, chmod, chown, ln, mkdir, pwd, rename, rm, rmdir, symlink. 
 <p class="level1">This option can be used multiple times. 
 <p class="level0"><a name="--random-file"></a><span class="nroffip">--random-file &lt;file&gt;</span> 
 <p class="level1">(SSL) Specify the path name to file containing what will be considered as random data. The data is used to seed the random engine for SSL connections. See also the <a class="emphasis" href="#--egd-file">--egd-file</a> option. 
 <p class="level0"><a name="-r--range"></a><span class="nroffip">-r/--range &lt;range&gt;</span> 
-<p class="level1">(HTTP/FTP) Retrieve a byte range (i.e a partial document) from a HTTP/1.1 or FTP server. Ranges can be specified in a number of ways. 
+<p class="level1">(HTTP/FTP/FILE) Retrieve a byte range (i.e a partial document) from a HTTP/1.1, FTP server or a local FILE. Ranges can be specified in a number of ways. 
 <p class="level2">
 <p class="level2"><span Class="bold">0-499</span> specifies the first 500 bytes 
 <p class="level2"><span Class="bold">500-999</span> specifies the second 500 bytes 
 <p class="level2"><span Class="bold">-500</span> specifies the last 500 bytes 
 <p class="level2"><span Class="bold">9500-</span> specifies the bytes from offset 9500 and forward 
 <p class="level2"><span Class="bold">0-0,-1</span> specifies the first and last byte only(*)(H) 
@@ -441,14 +459,22 @@
 <p class="level1">When used with -s it makes curl show error message if it fails. 
 <p class="level1">If this option is used twice, the second will again disable show error. 
 <p class="level0"><a name="--socks4"></a><span class="nroffip">--socks4 &lt;host[:port]&gt;</span> 
 <p class="level1">Use the specified SOCKS4 proxy. If the port number is not specified, it is assumed at port 1080. (Added in 7.15.2) 
 <p class="level1">This option overrides any previous use of <a class="emphasis" href="#-x--proxy">-x/--proxy</a>, as they are mutually exclusive. 
 <p class="level1">If this option is used several times, the last one will be used. 
+<p class="level0"><a name="--socks4a"></a><span class="nroffip">--socks4a &lt;host[:port]&gt;</span> 
+<p class="level1">Use the specified SOCKS4a proxy. If the port number is not specified, it is assumed at port 1080. (Added in 7.18.0) 
+<p class="level1">This option overrides any previous use of <a class="emphasis" href="#-x--proxy">-x/--proxy</a>, as they are mutually exclusive. 
+<p class="level1">If this option is used several times, the last one will be used. 
+<p class="level0"><a name="--socks5-hostname"></a><span class="nroffip">--socks5-hostname &lt;host[:port]&gt;</span> 
+<p class="level1">Use the specified SOCKS5 proxy (and let the proxy resolve the host name). If the port number is not specified, it is assumed at port 1080. (Added in 7.18.0) 
+<p class="level1">This option overrides any previous use of <a class="emphasis" href="#-x--proxy">-x/--proxy</a>, as they are mutually exclusive. 
+<p class="level1">If this option is used several times, the last one will be used. (This option was previously wrongly documented and used as --socks without the number appended.) 
 <p class="level0"><a name="--socks5"></a><span class="nroffip">--socks5 &lt;host[:port]&gt;</span> 
-<p class="level1">Use the specified SOCKS5 proxy. If the port number is not specified, it is assumed at port 1080. (Added in 7.11.1) 
+<p class="level1">Use the specified SOCKS5 proxy - but resolve the host name locally. If the port number is not specified, it is assumed at port 1080. 
 <p class="level1">This option overrides any previous use of <a class="emphasis" href="#-x--proxy">-x/--proxy</a>, as they are mutually exclusive. 
 <p class="level1">If this option is used several times, the last one will be used. (This option was previously wrongly documented and used as --socks without the number appended.) 
 <p class="level0"><a name="--stderr"></a><span class="nroffip">--stderr &lt;file&gt;</span> 
 <p class="level1">Redirect all writes to stderr to the specified file instead. If the file name is a plain '-', it is instead written to stdout. This option has no point when you're using a shell with decent redirecting capabilities. 
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="--tcp-nodelay"></a><span class="nroffip">--tcp-nodelay</span> 
@@ -477,12 +503,13 @@
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="--trace-time"></a><span class="nroffip">--trace-time</span> 
 <p class="level1">Prepends a time stamp to each trace or verbose line that curl displays. (Added in 7.14.0) 
 <p class="level1">If this option is used several times, each occurrence will toggle it on/off. 
 <p class="level0"><a name="-u--user"></a><span class="nroffip">-u/--user &lt;user:password&gt;</span> 
 <p class="level1">Specify user and password to use for server authentication. Overrides <a class="emphasis" href="#-n--netrc">-n/--netrc</a> and <a class="emphasis" href="#--netrc-optional">--netrc-optional</a>. 
+<p class="level1">If you just give the user name (without entering a colon) curl will prompt for a password. 
 <p class="level1">If you use an SSPI-enabled curl binary and do NTLM authentication, you can force curl to pick up the user name and password from your environment by simply specifying a single colon with this option: "-u :". 
 <p class="level1">If this option is used several times, the last one will be used. 
 <p class="level0"><a name="-U--proxy-user"></a><span class="nroffip">-U/--proxy-user &lt;user:password&gt;</span> 
 <p class="level1">Specify user and password to use for proxy authentication. 
 <p class="level1">If you use an SSPI-enabled curl binary and do NTLM authentication, you can force curl to pick up the user name and password from your environment by simply specifying a single colon with this option: "-U :". 
 <p class="level1">If this option is used several times, the last one will be used. 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/curl.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/curl.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/10-at-a-time.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/10-at-a-time.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/10-at-a-time.c	2007-06-28 05:35:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/10-at-a-time.c	2007-11-05 18:07:34.000000000 +0800
@@ -2,25 +2,28 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: 10-at-a-time.c,v 1.4 2007-06-27 21:35:17 bagder Exp $
+ * $Id: 10-at-a-time.c,v 1.5 2007-11-05 10:07:34 bagder Exp $
  *
  * Example application source code using the multi interface to download many
  * files, but with a capped maximum amount of simultaneous transfers.
  *
  * Written by Michael Wallner
  */
 
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 #include <unistd.h>
 #include <curl/multi.h>
+#ifdef WIN32
+#include <windows.h>
+#endif
 
 static const char *urls[] = {
   "http://www.microsoft.com",
   "http://www.opensource.org",
   "http://www.google.com",
   "http://www.yahoo.com",
@@ -135,13 +138,17 @@
         return EXIT_FAILURE;
       }
       if (L == -1)
         L = 100;
 
       if (M == -1) {
+#ifdef WIN32
+        Sleep(L);
+#else
         sleep(L / 1000);
+#endif
       } else {
         T.tv_sec = L/1000;
         T.tv_usec = (L%1000)*1000;
 
         if (0 > select(M+1, &R, &W, &E, &T)) {
           fprintf(stderr, "E: select(%i,,,,%li): %i: %s\n",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/getinmemory.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/getinmemory.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/getinmemory.c	2007-07-20 05:32:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/getinmemory.c	2007-11-07 17:02:02.000000000 +0800
@@ -2,13 +2,13 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: getinmemory.c,v 1.11 2007-07-16 21:22:12 danf Exp $
+ * $Id: getinmemory.c,v 1.12 2007-11-07 04:53:37 danf Exp $
  *
  * Example source code to show how the callback function can be used to
  * download data into a chunk of memory instead of storing it in a file.
  *
  * This exact source code has not been verified to work.
  */
@@ -95,8 +95,11 @@
    * you're done with it, you should free() it as a nice application.
    */
 
   if(chunk.memory)
     free(chunk.memory);
 
+  /* we're done with libcurl, so clean it up */
+  curl_global_cleanup();
+
   return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/Makefile.am	2007-09-15 04:23:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/Makefile.am	2007-11-17 18:22:45.000000000 +0800
@@ -1,18 +1,24 @@
 #
-# $Id: Makefile.am,v 1.46 2007-09-13 22:20:35 danf Exp $
+# $Id: Makefile.am,v 1.47 2007-11-17 10:22:45 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign nostdinc
 
 EXTRA_DIST = README Makefile.example makefile.dj $(COMPLICATED_EXAMPLES)
 
 INCLUDES = -I$(top_srcdir)/include
 
 LIBDIR = $(top_builddir)/lib
-CPPFLAGS = -DCURL_NO_OLDIES
+
+if STATICLIB
+# we need this define when building with a static lib on Windows
+STATICCPPFLAGS = -DCURL_STATICLIB
+endif
+
+CPPFLAGS = -DCURL_NO_OLDIES $(STATICCPPFLAGS)
 
 # Dependencies
 LDADD = $(LIBDIR)/libcurl.la
 
 # These are all libcurl example programs to be test compiled
 noinst_PROGRAMS = 10-at-a-time anyauthput cookie_interface \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/examples/Makefile.in	2007-10-27 06:25:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/examples/Makefile.in	2008-01-28 19:59:49.000000000 +0800
@@ -12,13 +12,13 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.46 2007-09-13 22:20:35 danf Exp $
+# $Id: Makefile.am,v 1.47 2007-11-17 10:22:45 bagder Exp $
 #
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
@@ -205,13 +205,13 @@
 CABUNDLE_FALSE = @CABUNDLE_FALSE@
 CABUNDLE_TRUE = @CABUNDLE_TRUE@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
-CPPFLAGS = -DCURL_NO_OLDIES
+CPPFLAGS = -DCURL_NO_OLDIES $(STATICCPPFLAGS)
 CROSSCOMPILING_FALSE = @CROSSCOMPILING_FALSE@
 CROSSCOMPILING_TRUE = @CROSSCOMPILING_TRUE@
 CURL_CA_BUNDLE = @CURL_CA_BUNDLE@
 CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
 CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
 CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
@@ -278,12 +278,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
@@ -339,12 +342,15 @@
 target_alias = @target_alias@
 AUTOMAKE_OPTIONS = foreign nostdinc
 EXTRA_DIST = README Makefile.example makefile.dj $(COMPLICATED_EXAMPLES)
 INCLUDES = -I$(top_srcdir)/include
 LIBDIR = $(top_builddir)/lib
 
+# we need this define when building with a static lib on Windows
+@STATICLIB_TRUE@STATICCPPFLAGS = -DCURL_STATICLIB
+
 # Dependencies
 LDADD = $(LIBDIR)/libcurl.la
 
 # These examples require external dependencies that may not be commonly
 # available on POSIX systems, so don't bother attempting to compile them here.
 COMPLICATED_EXAMPLES = \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/FAQ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/FAQ
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/FAQ	2007-07-30 06:16:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/FAQ	2007-12-10 19:33:17.000000000 +0800
@@ -1,7 +1,7 @@
-Updated: July 30, 2007 (http://curl.haxx.se/docs/faq.html)
+Updated: Dec 10, 2007 (http://curl.haxx.se/docs/faq.html)
                                   _   _ ____  _
                               ___| | | |  _ \| |
                              / __| | | | |_) | |
                             | (__| |_| |  _ <| |___
                              \___|\___/|_| \_\_____|
 
@@ -80,12 +80,13 @@
   5.7 Link errors when building libcurl on Windows!
   5.8 libcurl.so.3: open failed: No such file or directory
   5.9 How does libcurl resolve host names?
   5.10 How do I prevent libcurl from writing the response to stdout?
   5.11 How do I make libcurl not receive the whole HTTP response?
   5.12 Can I make libcurl fake or hide my real IP address?
+  5.13 How do I stop an ongoing transfer?
 
  6. License Issues
   6.1 I have a GPL program, can I use the libcurl library?
   6.2 I have a closed-source program, can I use the libcurl library?
   6.3 I have a BSD licensed program, can I use the libcurl library?
   6.4 I have a program that uses LGPL libraries, can I use libcurl?
@@ -211,14 +212,13 @@
   curl and libcurl are not made by any single individual. Daniel Stenberg is
   project leader and main developer, but other persons' submissions are
   important and crucial. Anyone can contribute and post their changes and
   improvements and have them inserted in the main sources (of course on the
   condition that developers agree on that the fixes are good).
 
-  The full list of the more than 530 contributors is found in the docs/THANKS
-  file.
+  The full list of all contributors is found in the docs/THANKS file.
 
   curl is developed by a community, with Daniel at the wheel.
 
   1.6 What do you get for making curl?
 
   Project cURL is entirely free and open. No person gets paid for developing
@@ -1030,12 +1030,24 @@
   IP address but instead the address of the proxy.
 
   Also note that on many networks NATs or other IP-munging techniques are used
   that makes you see and use a different IP address locally than what the
   remote server will see you coming from.
 
+  5.13 How do I stop an ongoing transfer?
+
+  There are several ways, but none of them are instant. There is no function
+  you can call from another thread or similar that will stop it immediately.
+  Instead you need to make sure that one of the callbacks you use return an
+  appropriate value that will stop the transfer.
+
+  Suitable callbacks that you can do this with include the progress callback,
+  the read callback and the write callback.
+
+  If you're using the multi interface, you also stop a transfer by removing
+  the particular easy handle from the multi stack.
 
 6. License Issues
 
   Curl and libcurl are released under a MIT/X derivate license. The license is
   very liberal and should not impose a problem for your project. This section
   is just a brief summary for the cases we get the most questions. (Parts of
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/INSTALL	2007-10-22 22:30:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/INSTALL	2008-01-26 06:08:33.000000000 +0800
@@ -185,13 +185,13 @@
    If you have any problems linking libraries or finding header files, be sure
    to verify that the provided "Makefile.m32" files use the proper paths, and
    adjust as necessary. It is also possible to override these paths with 
    environment variables, for example:
 
      set ZLIB_PATH=c:\zlib-1.2.3
-     set OPENSSL_PATH=c:\openssl-0.9.8e
+     set OPENSSL_PATH=c:\openssl-0.9.8g
      set LIBSSH2_PATH=c:\libssh2-0.17
 
    ATTENTION: if you want to build with libssh2 support you have to use latest
    version 0.17 - previous versions will NOT work with 7.17.0 and later!
    Use 'mingw32-make mingw32-ssh2-ssl-zlib' to build with SSH2 and SSL enabled.
 
@@ -254,13 +254,13 @@
    the OpenSSL home directory.  OpenSSL static libraries (libeay32.lib,
    ssleay32.lib, RSAglue.lib) are created in the out32 subdirectory.
 
    Before running nmake define the OPENSSL_PATH environment variable with
    the root/base directory of OpenSSL, for example:
 
-     set OPENSSL_PATH=c:\openssl-0.9.8e
+     set OPENSSL_PATH=c:\openssl-0.9.8g
 
    Then run 'nmake vc-ssl' or 'nmake vc-ssl-dll' in curl's root
    directory.  'nmake vc-ssl' will create a libcurl static and dynamic
    libraries in the lib subdirectory, as well as a statically linked
    version of curl.exe in the src subdirectory.  This statically linked
    version is a standalone executable not requiring any DLL at
@@ -518,13 +518,13 @@
      http://www.gknw.net/mirror/zlib/
    - optional OpenSSL sources (version 0.9.8 or later build with BSD sockets);
      you can find precompiled packages at:
      http://www.gknw.net/development/ossl/netware/
      for CLIB-based builds OpenSSL needs to be patched to build with BSD
      sockets (currently only a winsock-based CLIB build is supported):
-     http://www.gknw.net/development/ossl/netware/patches/v_0.9.8e/openssl-0.9.8e.diff
+     http://www.gknw.net/development/ossl/netware/patches/v_0.9.8g/openssl-0.9.8g.diff
    - optional SSH2 sources (version 0.17 or later);
 
    Set a search path to your compiler, linker and tools; on Linux make
    sure that the var OSTYPE contains the string 'linux'; set the var
    NDKBASE to point to the base of your Novell NDK; and then type
    'make netware' from the top source directory; other targets available
@@ -805,16 +805,18 @@
         - i386 Windows 95, 98, ME, NT, 2000, XP, 2003
         - i386 QNX 6
         - i486 ncr-sysv4.3.03 (NCR MP-RAS)
         - ia64 Linux 2.3.99
         - m68k AmigaOS 3
         - m68k Linux
+        - m68k uClinux
         - m68k OpenBSD
         - m88k dg-dgux5.4R3.00
         - s390 Linux
         - XScale/PXA250 Linux 2.4
+        - Nios II uClinux
 
 Useful URLs
 ===========
 
 OpenSSL   http://www.openssl.org
 MingW     http://www.mingw.org
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/INTERNALS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/INTERNALS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/INTERNALS	2007-09-21 05:50:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/INTERNALS	2007-11-28 06:48:36.000000000 +0800
@@ -94,13 +94,15 @@
  Curl_connect() to connect to the remote site.
 
  o Curl_connect()
 
    ... analyzes the URL, it separates the different components and connects to
    the remote host. This may involve using a proxy and/or using SSL. The
-   Curl_gethost() function in lib/hostip.c is used for looking up host names.
+   Curl_resolv() function in lib/hostip.c is used for looking up host names
+   (it does then use the proper underlying method, which may vary between
+   platforms and builds).
 
    When Curl_connect is done, we are connected to the remote site. Then it is
    time to tell the server to get a document/file. Curl_do() arranges this.
 
    This function makes sure there's an allocated and initiated 'connectdata'
    struct that is used for this particular connection only (although there may
@@ -119,23 +121,26 @@
    negotiations and setup. They have access to the Curl_sendf() (from
    lib/sendf.c) function to send printf-style formatted data to the remote
    host and when they're ready to make the actual file transfer they call the
    Curl_Transfer() function (in lib/transfer.c) to setup the transfer and
    returns.
 
-   Starting in 7.9.1, if this DO function fails and the connection is being
-   re-used, libcurl will then close this connection, setup a new connection
-   and re-issue the DO request on that. This is because there is no way to be
-   perfectly sure that we have discovered a dead connection before the DO
-   function and thus we might wrongly be re-using a connection that was closed
-   by the remote peer.
+   If this DO function fails and the connection is being re-used, libcurl will
+   then close this connection, setup a new connection and re-issue the DO
+   request on that. This is because there is no way to be perfectly sure that
+   we have discovered a dead connection before the DO function and thus we
+   might wrongly be re-using a connection that was closed by the remote peer.
+
+   Some time during the DO function, the Curl_setup_transfer() function must
+   be called with some basic info about the upcoming transfer: what socket(s)
+   to read/write and the expected file tranfer sizes (if known).
 
  o Transfer()
 
-   Curl_perform() then calls Transfer() in lib/transfer.c that performs
-   the entire file transfer.
+   Curl_perform() then calls Transfer() in lib/transfer.c that performs the
+   entire file transfer.
 
    During transfer, the progress functions in lib/progress.c are called at a
    frequent interval (or at the user's choice, a specified callback might get
    called). The speedcheck functions in lib/speedcheck.c are also used to
    verify that the transfer is as fast as required.
 
@@ -233,15 +238,14 @@
 
  GENERAL
 
  URL encoding and decoding, called escaping and unescaping in the source code,
  is found in lib/escape.c.
 
- While transfering data in Transfer() a few functions might get
- used. curl_getdate() in lib/getdate.c is for HTTP date comparisons (and
- more).
+ While transfering data in Transfer() a few functions might get used.
+ curl_getdate() in lib/parsedate.c is for HTTP date comparisons (and more).
 
  lib/getenv.c offers curl_getenv() which is for reading environment variables
  in a neat platform independent way. That's used in the client, but also in
  lib/url.c when checking the proxy environment variables. Note that contrary
  to the normal unix getenv(), this returns an allocated buffer that must be
  free()ed after use.
@@ -251,44 +255,77 @@
  lib/timeval.c features replacement functions for systems that don't have
  gettimeofday() and a few support functions for timeval convertions.
  
  A function named curl_version() that returns the full curl version string is
  found in lib/version.c.
 
- If authentication is requested but no password is given, a getpass_r() clone
- exists in lib/getpass.c. libcurl offers a custom callback that can be used
- instead of this, but it doesn't change much to us.
-
 Persistent Connections
 ======================
 
  The persistent connection support in libcurl requires some considerations on
  how to do things inside of the library.
 
  o The 'SessionHandle' struct returned in the curl_easy_init() call must never
    hold connection-oriented data. It is meant to hold the root data as well as
    all the options etc that the library-user may choose.
  o The 'SessionHandle' struct holds the "connection cache" (an array of
    pointers to 'connectdata' structs). There's one connectdata struct
-   allocated for each connection that libcurl knows about.
- o This also enables the 'curl handle' to be reused on subsequent transfers,
-   something that was illegal before libcurl 7.7.
+   allocated for each connection that libcurl knows about. Note that when you
+   use the multi interface, the multi handle will hold the connection cache
+   and not the particular easy handle. This of course to allow all easy handles
+   in a multi stack to be able to share and re-use connections.
+ o This enables the 'curl handle' to be reused on subsequent transfers.
  o When we are about to perform a transfer with curl_easy_perform(), we first
    check for an already existing connection in the cache that we can use,
    otherwise we create a new one and add to the cache. If the cache is full
    already when we add a new connection, we close one of the present ones. We
    select which one to close dependent on the close policy that may have been
    previously set.
  o When the transfer operation is complete, we try to leave the connection
    open. Particular options may tell us not to, and protocols may signal
    closure on connections and then we don't keep it open of course.
- o When curl_easy_cleanup() is called, we close all still opened connections.
+ o When curl_easy_cleanup() is called, we close all still opened connections,
+   unless of course the multi interface "owns" the connections.
 
  You do realize that the curl handle must be re-used in order for the
  persistent connections to work.
 
+multi interface/non-blocking
+============================
+
+ We make an effort to provide a non-blocking interface to the library, the
+ multi interface. To make that interface work as good as possible, no
+ low-level functions within libcurl must be written to work in a blocking
+ manner.
+
+ One of the primary reasons we introduced c-ares support was to allow the name
+ resolve phase to be perfectly non-blocking as well.
+
+ The ultimate goal is to provide the easy interface simply by wrapping the
+ multi interface functions and thus treat everything internally as the multi
+ interface is the single interface we have.
+
+ The FTP and the SFTP/SCP protocols are thus perfect examples of how we adapt
+ and adjust the code to allow non-blocking operations even on multi-stage
+ protocols. The DICT, TELNET and TFTP are crappy examples and they are subject
+ for rewrite in the future to better fit the libcurl protocol family.
+
+SSL libraries
+=============
+
+ Originally libcurl supported SSLeay for SSL/TLS transports, but that was then
+ extended to its successor OpenSSL but has since also been extended to several
+ other SSL/TLS libraries and we expect and hope to further extend the support
+ in future libcurl versions.
+
+ To deal with this internally in the best way possible, we have a generic SSL
+ function API as provided by the sslgen.[ch] system, and they are the only SSL
+ functions we must use from within libcurl. sslgen is then crafted to use the
+ appropriate lower-level function calls to whatever SSL library that is in
+ use.
+
 Library Symbols
 ===============
  
  All symbols used internally in libcurl must use a 'Curl_' prefix if they're
  used in more than a single file. Single-file symbols must be made static.
  Public ("exported") symbols must use a 'curl_' prefix. (There are exceptions,
@@ -306,12 +343,19 @@
  In aiding the user to understand what's happening and to debug curl usage, we
  must supply a fair amount of informational messages by using the Curl_infof()
  function. Those messages are only displayed when the user explicitly asks for
  them. They are best used when revealing information that isn't otherwise
  obvious.
 
+API/ABI
+=======
+
+ We make an effort to not export or show internals or how internals work, as
+ that makes it easier to keep a solid API/ABI over time. See docs/libcurl/ABI
+ for our promise to users.
+
 Client
 ======
 
  main() resides in src/main.c together with most of the client code.
 
  src/hugehelp.c is automatically generated by the mkhelp.pl perl script to
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/KNOWN_BUGS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/KNOWN_BUGS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/KNOWN_BUGS	2007-10-07 16:24:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/KNOWN_BUGS	2008-01-29 00:09:18.000000000 +0800
@@ -1,11 +1,29 @@
 These are problems known to exist at the time of this release. Feel free to
 join in and help us correct one or more of these! Also be sure to check the
 changelog of the current development status, as one or more of these problems
 may have been fixed since this was written!
 
+52. Gautam Kachroo's issue that identifies a problem with the multi interface
+  where a connection can be re-used without actually being properly
+  SSL-negoatiated:
+  http://curl.haxx.se/mail/lib-2008-01/0277.html
+
+51.Kevin Reed's reported problem with a proxy when doing CONNECT and it
+  wants NTLM and close the connection to the initial CONNECT response:
+  http://curl.haxx.se/bug/view.cgi?id=1879375
+
+50. Curl_done() and pipelning aren't totally cool together:
+  http://curl.haxx.se/mail/lib-2008-01/0330.html
+
+49. If using --retry and the transfer timeouts (possibly due to using -m or
+  -y/-Y) the next attempt doesn't resume the transfer properly from what was
+  downloaded in the previous attempt but will truncate and restart at the
+  original position where it was at before the previous failed attempt. See
+  http://curl.haxx.se/mail/lib-2008-01/0080.html
+
 48. If a CONNECT response-headers are larger than BUFSIZE (16KB) when the
   connection is meant to be kept alive (like for NTLM proxy auth), the
   function will return prematurely and will confuse the rest of the HTTP
   protocol code. This should be very rare.
 
 45. libcurl built to support ipv6 uses getaddrinfo() to resolve host names.
@@ -40,29 +58,15 @@
   bad when used with the multi interface.
 
 34. The SOCKS4 connection codes don't properly acknowledge (connect) timeouts.
   Also see #12. According to bug #1556528, even the SOCKS5 connect code does
   not do it right: http://curl.haxx.se/bug/view.cgi?id=1556528,
 
-33. Doing multi-pass HTTP authentication on a non-default port does not work.
-  This happens because the multi-pass code abuses the redirect following code
-  for doing multiple requests, and when we following redirects to an absolute
-  URL we must use the newly specified port and not the one specified in the
-  original URL. A proper fix to this would need to separate the negotiation
-  "redirect" from an actual redirect.
-
-32. (At least on Windows) If libcurl is built with c-ares and there's no DNS
-  server configured in the system, the ares_init() call fails and thus
-  curl_easy_init() fails as well. This causes weird effects for people who use
-  numerical IP addresses only.
-
 31. "curl-config --libs" will include details set in LDFLAGS when configure is
-  run that might be needed only for building libcurl. Similarly, it might
-  include options that perhaps aren't suitable both for static and dynamic
-  linking. Further, curl-config --cflags suffers from the same effects with
-  CFLAGS/CPPFLAGS.
+  run that might be needed only for building libcurl. Further, curl-config
+  --cflags suffers from the same effects with CFLAGS/CPPFLAGS.
 
 30. You need to use -g to the command line tool in order to use RFC2732-style
   IPv6 numerical addresses in URLs.
 
 29. IPv6 URLs with zone ID is not supported.
   http://www.ietf.org/internet-drafts/draft-fenner-literal-zone-02.txt (expired)
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_cleanup.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_cleanup.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_duphandle.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_duphandle.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_escape.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_escape.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_getinfo.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_getinfo.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_init.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_init.pdf differ
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl: curl_easy_pause.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl: curl_easy_pause.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl: curl_easy_pause.pdf
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_perform.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_perform.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_reset.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_reset.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_setopt.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_setopt.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_setopt.3	2007-10-22 22:30:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_setopt.3	2008-01-11 22:20:41.000000000 +0800
@@ -2,29 +2,29 @@
 .\" *                                  _   _ ____  _
 .\" *  Project                     ___| | | |  _ \| |
 .\" *                             / __| | | | |_) | |
 .\" *                            | (__| |_| |  _ <| |___
 .\" *                             \___|\___/|_| \_\_____|
 .\" *
-.\" * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+.\" * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 .\" *
 .\" * This software is licensed as described in the file COPYING, which
 .\" * you should have received as part of this distribution. The terms
 .\" * are also available at http://curl.haxx.se/docs/copyright.html.
 .\" *
 .\" * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 .\" * copies of the Software, and permit persons to whom the Software is
 .\" * furnished to do so, under the terms of the COPYING file.
 .\" *
 .\" * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 .\" * KIND, either express or implied.
 .\" *
-.\" * $Id: curl_easy_setopt.3,v 1.202 2007-10-15 21:19:40 danf Exp $
+.\" * $Id: curl_easy_setopt.3,v 1.211 2008-01-11 14:20:41 bagder Exp $
 .\" **************************************************************************
 .\"
-.TH curl_easy_setopt 3 "30 Aug 2007" "libcurl 7.17.0" "libcurl Manual"
+.TH curl_easy_setopt 3 "5 Jan 2008" "libcurl 7.18.0" "libcurl Manual"
 .SH NAME
 curl_easy_setopt \- set options for a curl easy handle
 .SH SYNOPSIS
 #include <curl/curl.h>
 
 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);
@@ -92,12 +92,16 @@
 to be saved. The size of the data pointed to by \fIptr\fP is \fIsize\fP
 multiplied with \fInmemb\fP, it will not be zero terminated. Return the number
 of bytes actually taken care of. If that amount differs from the amount passed
 to your function, it'll signal an error to the library and it will abort the
 transfer and return \fICURLE_WRITE_ERROR\fP.
 
+From 7.18.0, the function can return CURL_WRITEFUNC_PAUSE which then will
+cause writing to this connection to become paused. See
+\fIcurl_easy_pause(3)\fP for further details.
+
 This function may be called with zero bytes data if the transfered file is
 empty.
 
 Set this option to NULL to get the internal default function. The internal
 default function will write the data to the FILE * given with
 \fICURLOPT_WRITEDATA\fP.
@@ -139,12 +143,16 @@
 for the rest of the data that won't come.
 
 The read callback may return \fICURL_READFUNC_ABORT\fP to stop the current
 operation immediately, resulting in a \fICURLE_ABORTED_BY_CALLBACK\fP error
 code from the transfer (Added in 7.12.1)
 
+From 7.18.0, the function can return CURL_READFUNC_PAUSE which then will cause
+reading from this connection to become paused. See \fIcurl_easy_pause(3)\fP
+for further details.
+
 If you set the callback pointer to NULL, or doesn't set it at all, the default
 internal read function will be used. It is simply doing an fread() on the FILE
 * stream set with \fICURLOPT_READDATA\fP.
 .IP CURLOPT_READDATA
 Data pointer to pass to the file read function. If you use the
 \fICURLOPT_READFUNCTION\fP option, this is the pointer you'll get as input. If
@@ -160,17 +168,38 @@
 Function pointer that should match the \fIcurl_ioctl_callback\fP prototype
 found in \fI<curl/curl.h>\fP. This function gets called by libcurl when
 something special I/O-related needs to be done that the library can't do by
 itself. For now, rewinding the read data stream is the only action it can
 request. The rewinding of the read data stream may be necessary when doing a
 HTTP PUT or POST with a multi-pass authentication method.  (Option added in
-7.12.3)
+7.12.3).
+
+Use \fICURLOPT_SEEKFUNCTION\fP instead to provide seeking!
 .IP CURLOPT_IOCTLDATA
 Pass a pointer that will be untouched by libcurl and passed as the 3rd
 argument in the ioctl callback set with \fICURLOPT_IOCTLFUNCTION\fP.  (Option
 added in 7.12.3)
+.IP CURLOPT_SEEKFUNCTION
+Function pointer that should match the following prototype: \fIint
+function(void *instream, curl_off_t offset, int origin);\fP This function gets
+called by libcurl to seek to a certain position in the input stream and can be
+used to fast forward a file in a resumed upload (instead of reading all
+uploaded bytes with the normal read function/callback). It is also called to
+rewind a stream when doing a HTTP PUT or POST with a multi-pass authentication
+method. The function shall work like "fseek" or "lseek" and accepted SEEK_SET,
+SEEK_CUR and SEEK_END as argument for origin, although (in 7.18.0) libcurl
+only passes SEEK_SET. The callback must return 0 on success as returning
+non-zero will cause the upload operation to fail.
+
+If you forward the input arguments directly to "fseek" or "lseek", note that
+the data type for \fIoffset\fP is not the same as defined for curl_off_t on
+many systems! (Option added in 7.18.0)
+.IP CURLOPT_SEEKDATA
+Data pointer to pass to the file read function. If you use the
+\fICURLOPT_SEEKFUNCTION\fP option, this is the pointer you'll get as input. If
+you don't specify a seek callback, NULL is passed. (Option added in 7.18.0)
 .IP CURLOPT_SOCKOPTFUNCTION
 Function pointer that should match the \fIcurl_sockopt_callback\fP prototype
 found in \fI<curl/curl.h>\fP. This function gets called by libcurl after the
 socket() call but before the connect() call. The callback's \fIpurpose\fP
 argument identifies the exact purpose for this particular socket, and
 currently only one value is supported: \fICURLSOCKTYPE_IPCXN\fP for the
@@ -427,19 +456,27 @@
 include protocol prefix (http://) and embedded user + password.
 .IP CURLOPT_PROXYPORT
 Pass a long with this option to set the proxy port to connect to unless it is
 specified in the proxy string \fICURLOPT_PROXY\fP.
 .IP CURLOPT_PROXYTYPE
 Pass a long with this option to set type of the proxy. Available options for
-this are \fICURLPROXY_HTTP\fP, \fICURLPROXY_SOCKS4\fP (added in 7.15.2)
-\fICURLPROXY_SOCKS5\fP. The HTTP type is default. (Added in 7.10)
+this are \fICURLPROXY_HTTP\fP, \fICURLPROXY_SOCKS4\fP (added in 7.15.2),
+\fICURLPROXY_SOCKS5\fP, \fICURLPROXY_SOCKS4A\fP (added in 7.18.0) and
+\fICURLPROXY_SOCKS5_HOSTNAME\fP (added in 7.18.0). The HTTP type is
+default. (Added in 7.10)
 .IP CURLOPT_HTTPPROXYTUNNEL
 Set the parameter to non-zero to get the library to tunnel all operations
 through a given HTTP proxy. There is a big difference between using a proxy
 and to tunnel through it. If you don't know what this means, you probably
 don't want this tunneling option.
+.IP CURLOPT_SOCKS5_RESOLVE_LOCAL
+Set the parameter to 1 to get the library to resolve the host name locally
+instead of passing it to the proxy to resolve, when using a SOCKS5 proxy.
+
+Note that libcurl before 7.18.0 always resolved the host name locally even
+when SOCKS5 was used. (Added in 7.18.0)
 .IP CURLOPT_INTERFACE
 Pass a char * as parameter. This set the interface name to use as outgoing
 network interface. The name can be an interface name, an IP address or a host
 name.
 .IP CURLOPT_LOCALPORT
 Pass a long. This sets the local port number of the socket used for
@@ -667,13 +704,15 @@
 
 Optionally, you can provide data to POST using the \fICURLOPT_READFUNCTION\fP
 and \fICURLOPT_READDATA\fP options but then you must make sure to not set
 \fICURLOPT_POSTFIELDS\fP to anything but NULL. When providing data with a
 callback, you must transmit it using chunked transfer-encoding or you must set
 the size of the data with the \fICURLOPT_POSTFIELDSIZE\fP or
-\fICURLOPT_POSTFIELDSIZE_LARGE\fP option.
+\fICURLOPT_POSTFIELDSIZE_LARGE\fP option. To enable chunked encoding, you
+simply pass in the appropriate Transfer-Encoding header, see the
+post-callback.c example.
 
 You can override the default POST Content-Type: header by setting your own
 with \fICURLOPT_HTTPHEADER\fP.
 
 Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header.
 You can disable this header with \fICURLOPT_HTTPHEADER\fP as usual.
@@ -1061,21 +1100,30 @@
 between systems with different views on certain characters, such as newlines
 or similar.
 
 libcurl does not do a complete ASCII conversion when doing ASCII transfers
 over FTP. This is a known limitation/flaw that nobody has rectified. libcurl
 simply sets the mode to ascii and performs a standard transfer.
+.IP CURLOPT_PROXY_TRANSFER_MODE
+Pass a long. If the value is set to 1 (one), it tells libcurl to set the
+transfer mode (binary or ASCII) for FTP transfers done via an HTTP proxy, by
+appending ;type=a or ;type=i to the URL. Without this setting, or it being
+set to 0 (zero, the default), \fICURLOPT_TRANSFERTEXT\fP has no effect when
+doing FTP via a proxy. Beware that not all proxies support this feature.
+(Added in 7.18.0)
 .IP CURLOPT_CRLF
 Convert Unix newlines to CRLF newlines on transfers.
 .IP CURLOPT_RANGE
 Pass a char * as parameter, which should contain the specified range you
 want. It should be in the format "X-Y", where X or Y may be left out. HTTP
 transfers also support several intervals, separated with commas as in
 \fI"X-Y,N-M"\fP. Using this kind of multiple intervals will cause the HTTP
 server to send the response document in pieces (using standard MIME separation
 techniques). Pass a NULL to this option to disable the use of ranges.
+
+Ranges work on HTTP, FTP and FILE (since 7.18.0) transfers only.
 .IP CURLOPT_RESUME_FROM
 Pass a long as parameter. It contains the offset in number of bytes that you
 want the transfer to start from. Set this option to 0 to make the transfer
 start from the beginning (effectively disabling resume). For FTP, set this
 option to -1 to make the transfer start from the end of the target file
 (useful to continue an interrupted upload).
@@ -1488,12 +1536,20 @@
 Pass a share handle as a parameter. The share handle must have been created by
 a previous call to \fIcurl_share_init(3)\fP. Setting this option, will make
 this curl handle use the data from the shared handle instead of keeping the
 data to itself. This enables several curl handles to share data. If the curl
 handles are used simultaneously, you \fBMUST\fP use the locking methods in the
 share handle. See \fIcurl_share_setopt(3)\fP for details.
+
+If you add a share that is set to share cookies, your easy handle will use
+that cookie cache and get the cookie engine enabled. If you unshare an object
+that were using cookies (or change to another object that doesn't share
+cookies), the easy handle will get its cookie engine disabled.
+
+Data that the share object is not set to share will be dealt with the usual
+way, as if no share was used.
 .IP CURLOPT_NEW_FILE_PERMS
 Pass a long as a parameter, containing the value of the permissions that will
 be assigned to newly created files on the remote server.  The default value is
 \fI0644\fP, but any valid value can be used.  The only protocols that can use
 this are \fIsftp://\fP, \fIscp://\fP and \fIfile://\fP. (Added in 7.16.4)
 .IP CURLOPT_NEW_DIRECTORY_PERMS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_setopt.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_setopt.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_setopt.html	2007-10-24 17:24:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_setopt.html	2008-01-28 19:31:59.000000000 +0800
@@ -65,12 +65,13 @@
 <p class="level1">Pass a long. If it is non-zero, libcurl will not use any functions that install signal handlers or any functions that cause signals to be sent to the process. This option is mainly here to allow multi-threaded unix applications to still set/use all timeout options etc, without risking getting signals. (Added in 7.10) 
 <p class="level1">Consider building libcurl with ares support to enable asynchronous DNS lookups. It enables nice timeouts for name resolves without signals. 
 <p class="level1"><a name="CALLBACK"></a><h2 class="nroffsh">CALLBACK OPTIONS</h2>
 <p class="level0">
 <p class="level0"><a name="CURLOPTWRITEFUNCTION"></a><span class="nroffip">CURLOPT_WRITEFUNCTION</span> 
 <p class="level1">Function pointer that should match the following prototype: <span class="bold">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span> This function gets called by libcurl as soon as there is data received that needs to be saved. The size of the data pointed to by <span Class="emphasis">ptr</span> is <span Class="emphasis">size</span> multiplied with <span Class="emphasis">nmemb</span>, it will not be zero terminated. Return the number of bytes actually taken care of. If that amount differs from the amount passed to your function, it'll signal an error to the library and it will abort the transfer and return <span Class="emphasis">CURLE_WRITE_ERROR</span>. 
+<p class="level1">From 7.18.0, the function can return CURL_WRITEFUNC_PAUSE which then will cause writing to this connection to become paused. See <a class="emphasis" href="./curl_easy_pause.html">curl_easy_pause(3)</a> for further details. 
 <p class="level1">This function may be called with zero bytes data if the transfered file is empty. 
 <p class="level1">Set this option to NULL to get the internal default function. The internal default function will write the data to the FILE * given with <a class="emphasis" href="#CURLOPTWRITEDATA">CURLOPT_WRITEDATA</a>. 
 <p class="level1">Set the <span Class="emphasis">stream</span> argument with the <a class="emphasis" href="#CURLOPTWRITEDATA">CURLOPT_WRITEDATA</a> option. 
 <p class="level1">The callback function will be passed as much data as possible in all invokes, but you cannot possibly make any assumptions. It may be one byte, it may be thousands. The maximum amount of data that can be passed to the write callback is defined in the curl.h header file: CURL_MAX_WRITE_SIZE. 
 <p class="level0"><a name="CURLOPTWRITEDATA"></a><span class="nroffip">CURLOPT_WRITEDATA</span> 
 <p class="level1">Data pointer to pass to the file write function. If you use the <a class="emphasis" href="#CURLOPTWRITEFUNCTION">CURLOPT_WRITEFUNCTION</a> option, this is the pointer you'll get as input. If you don't use a callback, you must pass a 'FILE *' as libcurl will pass this to fwrite() when writing data. 
@@ -78,21 +79,28 @@
 <p class="level1">If you're using libcurl as a win32 DLL, you <span Class="bold">MUST</span> use the <a class="emphasis" href="#CURLOPTWRITEFUNCTION">CURLOPT_WRITEFUNCTION</a> if you set this option or you will experience crashes. 
 <p class="level1">This option is also known with the older name <span Class="emphasis">CURLOPT_FILE</span>, the name <a class="emphasis" href="#CURLOPTWRITEDATA">CURLOPT_WRITEDATA</a> was introduced in 7.9.7. 
 <p class="level0"><a name="CURLOPTREADFUNCTION"></a><span class="nroffip">CURLOPT_READFUNCTION</span> 
 <p class="level1">Function pointer that should match the following prototype: <span class="bold">size_t function( void *ptr, size_t size, size_t nmemb, void *stream);</span> This function gets called by libcurl as soon as it needs to read data in order to send it to the peer. The data area pointed at by the pointer <span Class="emphasis">ptr</span> may be filled with at most <span Class="emphasis">size</span> multiplied with <span Class="emphasis">nmemb</span> number of bytes. Your function must return the actual number of bytes that you stored in that memory area. Returning 0 will signal end-of-file to the library and cause it to stop the current transfer. 
 <p class="level1">If you stop the current transfer by returning 0 "pre-maturely" (i.e before the server expected it, like when you've told you will upload N bytes and you upload less than N bytes), you may experience that the server "hangs" waiting for the rest of the data that won't come. 
 <p class="level1">The read callback may return <span Class="emphasis">CURL_READFUNC_ABORT</span> to stop the current operation immediately, resulting in a <span Class="emphasis">CURLE_ABORTED_BY_CALLBACK</span> error code from the transfer (Added in 7.12.1) 
+<p class="level1">From 7.18.0, the function can return CURL_READFUNC_PAUSE which then will cause reading from this connection to become paused. See <a class="emphasis" href="./curl_easy_pause.html">curl_easy_pause(3)</a> for further details. 
 <p class="level1">If you set the callback pointer to NULL, or doesn't set it at all, the default internal read function will be used. It is simply doing an fread() on the FILE * stream set with <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a>. 
 <p class="level0"><a name="CURLOPTREADDATA"></a><span class="nroffip">CURLOPT_READDATA</span> 
 <p class="level1">Data pointer to pass to the file read function. If you use the <a class="emphasis" href="#CURLOPTREADFUNCTION">CURLOPT_READFUNCTION</a> option, this is the pointer you'll get as input. If you don't specify a read callback but instead rely on the default internal read function, this data must be a valid readable FILE *. 
 <p class="level1">If you're using libcurl as a win32 DLL, you MUST use a <a class="emphasis" href="#CURLOPTREADFUNCTION">CURLOPT_READFUNCTION</a> if you set this option. 
 <p class="level1">This option is also known with the older name <span Class="emphasis">CURLOPT_INFILE</span>, the name <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> was introduced in 7.9.7. 
 <p class="level0"><a name="CURLOPTIOCTLFUNCTION"></a><span class="nroffip">CURLOPT_IOCTLFUNCTION</span> 
-<p class="level1">Function pointer that should match the <span Class="emphasis">curl_ioctl_callback</span> prototype found in <span Class="emphasis">&lt;curl/curl.h&gt;</span>. This function gets called by libcurl when something special I/O-related needs to be done that the library can't do by itself. For now, rewinding the read data stream is the only action it can request. The rewinding of the read data stream may be necessary when doing a HTTP PUT or POST with a multi-pass authentication method.  (Option added in 7.12.3) 
+<p class="level1">Function pointer that should match the <span Class="emphasis">curl_ioctl_callback</span> prototype found in <span Class="emphasis">&lt;curl/curl.h&gt;</span>. This function gets called by libcurl when something special I/O-related needs to be done that the library can't do by itself. For now, rewinding the read data stream is the only action it can request. The rewinding of the read data stream may be necessary when doing a HTTP PUT or POST with a multi-pass authentication method.  (Option added in 7.12.3). 
+<p class="level1">Use <a class="emphasis" href="#CURLOPTSEEKFUNCTION">CURLOPT_SEEKFUNCTION</a> instead to provide seeking! 
 <p class="level0"><a name="CURLOPTIOCTLDATA"></a><span class="nroffip">CURLOPT_IOCTLDATA</span> 
 <p class="level1">Pass a pointer that will be untouched by libcurl and passed as the 3rd argument in the ioctl callback set with <a class="emphasis" href="#CURLOPTIOCTLFUNCTION">CURLOPT_IOCTLFUNCTION</a>.  (Option added in 7.12.3) 
+<p class="level0"><a name="CURLOPTSEEKFUNCTION"></a><span class="nroffip">CURLOPT_SEEKFUNCTION</span> 
+<p class="level1">Function pointer that should match the following prototype: <span class="emphasis">int function(void *instream, curl_off_t offset, int origin);</span> This function gets called by libcurl to seek to a certain position in the input stream and can be used to fast forward a file in a resumed upload (instead of reading all uploaded bytes with the normal read function/callback). It is also called to rewind a stream when doing a HTTP PUT or POST with a multi-pass authentication method. The function shall work like "fseek" or "lseek" and accepted SEEK_SET, SEEK_CUR and SEEK_END as argument for origin, although (in 7.18.0) libcurl only passes SEEK_SET. The callback must return 0 on success as returning non-zero will cause the upload operation to fail. 
+<p class="level1">If you forward the input arguments directly to "fseek" or "lseek", note that the data type for <span Class="emphasis">offset</span> is not the same as defined for curl_off_t on many systems! (Option added in 7.18.0) 
+<p class="level0"><a name="CURLOPTSEEKDATA"></a><span class="nroffip">CURLOPT_SEEKDATA</span> 
+<p class="level1">Data pointer to pass to the file read function. If you use the <a class="emphasis" href="#CURLOPTSEEKFUNCTION">CURLOPT_SEEKFUNCTION</a> option, this is the pointer you'll get as input. If you don't specify a seek callback, NULL is passed. (Option added in 7.18.0) 
 <p class="level0"><a name="CURLOPTSOCKOPTFUNCTION"></a><span class="nroffip">CURLOPT_SOCKOPTFUNCTION</span> 
 <p class="level1">Function pointer that should match the <span Class="emphasis">curl_sockopt_callback</span> prototype found in <span Class="emphasis">&lt;curl/curl.h&gt;</span>. This function gets called by libcurl after the socket() call but before the connect() call. The callback's <span Class="emphasis">purpose</span> argument identifies the exact purpose for this particular socket, and currently only one value is supported: <span Class="emphasis">CURLSOCKTYPE_IPCXN</span> for the primary connection (meaning the control connection in the FTP case). Future versions of libcurl may support more purposes. It passes the newly created socket descriptor so additional setsockopt() calls can be done at the user's discretion.  A non-zero return code from the callback function will signal an unrecoverable error to the library and it will close the socket and return <span Class="emphasis">CURLE_COULDNT_CONNECT</span>.  (Option added in 7.15.6.) 
 <p class="level0"><a name="CURLOPTSOCKOPTDATA"></a><span class="nroffip">CURLOPT_SOCKOPTDATA</span> 
 <p class="level1">Pass a pointer that will be untouched by libcurl and passed as the first argument in the sockopt callback set with <a class="emphasis" href="#CURLOPTSOCKOPTFUNCTION">CURLOPT_SOCKOPTFUNCTION</a>. (Option added in 7.15.6.) 
 <p class="level0"><a name="CURLOPTOPENSOCKETFUNCTION"></a><span class="nroffip">CURLOPT_OPENSOCKETFUNCTION</span> 
 <p class="level1">Function pointer that should match the <span Class="emphasis">curl_opensocket_callback</span> prototype found in <span Class="emphasis">&lt;curl/curl.h&gt;</span>. This function gets called by libcurl instead of the <span Class="emphasis">socket(2)</span> call. The callback's <span Class="emphasis">purpose</span> argument identifies the exact purpose for this particular socket, and currently only one value is supported: <span Class="emphasis">CURLSOCKTYPE_IPCXN</span> for the primary connection (meaning the control connection in the FTP case). Future versions of libcurl may support more purposes. It passes the resolved peer address as a <span Class="emphasis">address</span> argument so the callback can modify the address or refuse to connect at all. The callback function should return the socket or <span Class="emphasis">CURL_SOCKET_BAD</span> in case no connection should be established or any error detected. Any additional <span Class="emphasis">setsockopt(2)</span> calls can be done on the socket at the user's discretion.  <span Class="emphasis">CURL_SOCKET_BAD</span> return value from the callback function will signal an unrecoverable error to the library and it will return <span Class="emphasis">CURLE_COULDNT_CONNECT</span>.  This return code can be used for IP address blacklisting.  The default behavior is: 
@@ -175,15 +183,18 @@
 <p class="level1">libcurl respects the environment variables <span Class="bold">http_proxy</span>, <span Class="bold">ftp_proxy</span>, <span Class="bold">all_proxy</span> etc, if any of those is set. The <a class="emphasis" href="#CURLOPTPROXY">CURLOPT_PROXY</a> option does however override any possibly set environment variables. 
 <p class="level1">Setting the proxy string to "" (an empty string) will explicitly disable the use of a proxy, even if there is an environment variable set for it. 
 <p class="level1">Since 7.14.1, the proxy host string given in environment variables can be specified the exact same way as the proxy can be set with <a class="emphasis" href="#CURLOPTPROXY">CURLOPT_PROXY</a>, include protocol prefix (http://) and embedded user + password. 
 <p class="level0"><a name="CURLOPTPROXYPORT"></a><span class="nroffip">CURLOPT_PROXYPORT</span> 
 <p class="level1">Pass a long with this option to set the proxy port to connect to unless it is specified in the proxy string <a class="emphasis" href="#CURLOPTPROXY">CURLOPT_PROXY</a>. 
 <p class="level0"><a name="CURLOPTPROXYTYPE"></a><span class="nroffip">CURLOPT_PROXYTYPE</span> 
-<p class="level1">Pass a long with this option to set type of the proxy. Available options for this are <span Class="emphasis">CURLPROXY_HTTP</span>, <span Class="emphasis">CURLPROXY_SOCKS4</span> (added in 7.15.2) <span Class="emphasis">CURLPROXY_SOCKS5</span>. The HTTP type is default. (Added in 7.10) 
+<p class="level1">Pass a long with this option to set type of the proxy. Available options for this are <span Class="emphasis">CURLPROXY_HTTP</span>, <span Class="emphasis">CURLPROXY_SOCKS4</span> (added in 7.15.2), <span Class="emphasis">CURLPROXY_SOCKS5</span>, <span Class="emphasis">CURLPROXY_SOCKS4A</span> (added in 7.18.0) and <span Class="emphasis">CURLPROXY_SOCKS5_HOSTNAME</span> (added in 7.18.0). The HTTP type is default. (Added in 7.10) 
 <p class="level0"><a name="CURLOPTHTTPPROXYTUNNEL"></a><span class="nroffip">CURLOPT_HTTPPROXYTUNNEL</span> 
 <p class="level1">Set the parameter to non-zero to get the library to tunnel all operations through a given HTTP proxy. There is a big difference between using a proxy and to tunnel through it. If you don't know what this means, you probably don't want this tunneling option. 
+<p class="level0"><a name="CURLOPTSOCKS5RESOLVELOCAL"></a><span class="nroffip">CURLOPT_SOCKS5_RESOLVE_LOCAL</span> 
+<p class="level1">Set the parameter to 1 to get the library to resolve the host name locally instead of passing it to the proxy to resolve, when using a SOCKS5 proxy. 
+<p class="level1">Note that libcurl before 7.18.0 always resolved the host name locally even when SOCKS5 was used. (Added in 7.18.0) 
 <p class="level0"><a name="CURLOPTINTERFACE"></a><span class="nroffip">CURLOPT_INTERFACE</span> 
 <p class="level1">Pass a char * as parameter. This set the interface name to use as outgoing network interface. The name can be an interface name, an IP address or a host name. 
 <p class="level0"><a name="CURLOPTLOCALPORT"></a><span class="nroffip">CURLOPT_LOCALPORT</span> 
 <p class="level1">Pass a long. This sets the local port number of the socket used for connection. This can be used in combination with <a class="emphasis" href="#CURLOPTINTERFACE">CURLOPT_INTERFACE</a> and you are recommended to use <a class="emphasis" href="#CURLOPTLOCALPORTRANGE">CURLOPT_LOCALPORTRANGE</a> as well when this is set. Note that port numbers are only valid 1 - 65535. (Added in 7.15.2) 
 <p class="level0"><a name="CURLOPTLOCALPORTRANGE"></a><span class="nroffip">CURLOPT_LOCALPORTRANGE</span> 
 <p class="level1">Pass a long. This is the number of attempts libcurl should do to find a working local port number. It starts with the given <a class="emphasis" href="#CURLOPTLOCALPORT">CURLOPT_LOCALPORT</a> and adds one to the number for each retry. Setting this value to 1 or below will make libcurl do only one try for exact port number. Note that port numbers by nature is a scarce resource that will be busy at times so setting this value to something too low might cause unnecessary connection setup failures. (Added in 7.15.2) 
@@ -263,13 +274,13 @@
 <p class="level0"><a name="CURLOPTPUT"></a><span class="nroffip">CURLOPT_PUT</span> 
 <p class="level1">A non-zero parameter tells the library to use HTTP PUT to transfer data. The data should be set with <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> and <a class="emphasis" href="#CURLOPTINFILESIZE">CURLOPT_INFILESIZE</a>. 
 <p class="level1">This option is deprecated and starting with version 7.12.1 you should instead use <a class="emphasis" href="#CURLOPTUPLOAD">CURLOPT_UPLOAD</a>. 
 <p class="level0"><a name="CURLOPTPOST"></a><span class="nroffip">CURLOPT_POST</span> 
 <p class="level1">A non-zero parameter tells the library to do a regular HTTP post. This will also make the library use the a "Content-Type: application/x-www-form-urlencoded" header. (This is by far the most commonly used POST method). 
 <p class="level1">Use one of <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> or <a class="emphasis" href="#CURLOPTCOPYPOSTFIELDS">CURLOPT_COPYPOSTFIELDS</a> options to specify what data to post and <a class="emphasis" href="#CURLOPTPOSTFIELDSIZE">CURLOPT_POSTFIELDSIZE</a> or <a class="emphasis" href="#CURLOPTPOSTFIELDSIZELARGE">CURLOPT_POSTFIELDSIZE_LARGE</a> to set the data size. 
-<p class="level1">Optionally, you can provide data to POST using the <a class="emphasis" href="#CURLOPTREADFUNCTION">CURLOPT_READFUNCTION</a> and <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> options but then you must make sure to not set <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> to anything but NULL. When providing data with a callback, you must transmit it using chunked transfer-encoding or you must set the size of the data with the <a class="emphasis" href="#CURLOPTPOSTFIELDSIZE">CURLOPT_POSTFIELDSIZE</a> or <a class="emphasis" href="#CURLOPTPOSTFIELDSIZELARGE">CURLOPT_POSTFIELDSIZE_LARGE</a> option. 
+<p class="level1">Optionally, you can provide data to POST using the <a class="emphasis" href="#CURLOPTREADFUNCTION">CURLOPT_READFUNCTION</a> and <a class="emphasis" href="#CURLOPTREADDATA">CURLOPT_READDATA</a> options but then you must make sure to not set <a class="emphasis" href="#CURLOPTPOSTFIELDS">CURLOPT_POSTFIELDS</a> to anything but NULL. When providing data with a callback, you must transmit it using chunked transfer-encoding or you must set the size of the data with the <a class="emphasis" href="#CURLOPTPOSTFIELDSIZE">CURLOPT_POSTFIELDSIZE</a> or <a class="emphasis" href="#CURLOPTPOSTFIELDSIZELARGE">CURLOPT_POSTFIELDSIZE_LARGE</a> option. To enable chunked encoding, you simply pass in the appropriate Transfer-Encoding header, see the post-callback.c example. 
 <p class="level1">You can override the default POST Content-Type: header by setting your own with <a class="emphasis" href="#CURLOPTHTTPHEADER">CURLOPT_HTTPHEADER</a>. 
 <p class="level1">Using POST with HTTP 1.1 implies the use of a "Expect: 100-continue" header. You can disable this header with <a class="emphasis" href="#CURLOPTHTTPHEADER">CURLOPT_HTTPHEADER</a> as usual. 
 <p class="level1">If you use POST to a HTTP 1.1 server, you can send data without knowing the size before starting the POST if you use chunked encoding. You enable this by adding a header like "Transfer-Encoding: chunked" with <a class="emphasis" href="#CURLOPTHTTPHEADER">CURLOPT_HTTPHEADER</a>. With HTTP 1.0 or without chunked transfer, you must specify the size in the request. 
 <p class="level1">When setting <a class="emphasis" href="#CURLOPTPOST">CURLOPT_POST</a> to a non-zero value, it will automatically set <a class="emphasis" href="#CURLOPTNOBODY">CURLOPT_NOBODY</a> to 0 (since 7.14.1). 
 <p class="level1">If you issue a POST request and then want to make a HEAD or GET using the same re-used handle, you must explicitly set the new request type using <a class="emphasis" href="#CURLOPTNOBODY">CURLOPT_NOBODY</a> or <a class="emphasis" href="#CURLOPTHTTPGET">CURLOPT_HTTPGET</a> or similar. 
 <p class="level0"><a name="CURLOPTPOSTFIELDS"></a><span class="nroffip">CURLOPT_POSTFIELDS</span> 
@@ -417,16 +428,19 @@
 <p class="level2">libcurl does one CWD with the full target directory and then operates on the file "normally" (like in the multicwd case). This is somewhat more standards compliant than 'nocwd' but without the full penalty of 'multicwd'. 
 <p class="level1"><a name="PROTOCOL"></a><h2 class="nroffsh">PROTOCOL OPTIONS</h2>
 <p class="level0">
 <p class="level0"><a name="CURLOPTTRANSFERTEXT"></a><span class="nroffip">CURLOPT_TRANSFERTEXT</span> 
 <p class="level1">A non-zero parameter tells the library to use ASCII mode for ftp transfers, instead of the default binary transfer. For win32 systems it does not set the stdout to binary mode. This option can be usable when transferring text data between systems with different views on certain characters, such as newlines or similar. 
 <p class="level1">libcurl does not do a complete ASCII conversion when doing ASCII transfers over FTP. This is a known limitation/flaw that nobody has rectified. libcurl simply sets the mode to ascii and performs a standard transfer. 
+<p class="level0"><a name="CURLOPTPROXYTRANSFERMODE"></a><span class="nroffip">CURLOPT_PROXY_TRANSFER_MODE</span> 
+<p class="level1">Pass a long. If the value is set to 1 (one), it tells libcurl to set the transfer mode (binary or ASCII) for FTP transfers done via an HTTP proxy, by appending ;type=a or ;type=i to the URL. Without this setting, or it being set to 0 (zero, the default), <a class="emphasis" href="#CURLOPTTRANSFERTEXT">CURLOPT_TRANSFERTEXT</a> has no effect when doing FTP via a proxy. Beware that not all proxies support this feature. (Added in 7.18.0) 
 <p class="level0"><a name="CURLOPTCRLF"></a><span class="nroffip">CURLOPT_CRLF</span> 
 <p class="level1">Convert Unix newlines to CRLF newlines on transfers. 
 <p class="level0"><a name="CURLOPTRANGE"></a><span class="nroffip">CURLOPT_RANGE</span> 
 <p class="level1">Pass a char * as parameter, which should contain the specified range you want. It should be in the format "X-Y", where X or Y may be left out. HTTP transfers also support several intervals, separated with commas as in <span Class="emphasis">"X-Y,N-M"</span>. Using this kind of multiple intervals will cause the HTTP server to send the response document in pieces (using standard MIME separation techniques). Pass a NULL to this option to disable the use of ranges. 
+<p class="level1">Ranges work on HTTP, FTP and FILE (since 7.18.0) transfers only. 
 <p class="level0"><a name="CURLOPTRESUMEFROM"></a><span class="nroffip">CURLOPT_RESUME_FROM</span> 
 <p class="level1">Pass a long as parameter. It contains the offset in number of bytes that you want the transfer to start from. Set this option to 0 to make the transfer start from the beginning (effectively disabling resume). For FTP, set this option to -1 to make the transfer start from the end of the target file (useful to continue an interrupted upload). 
 <p class="level0"><a name="CURLOPTRESUMEFROMLARGE"></a><span class="nroffip">CURLOPT_RESUME_FROM_LARGE</span> 
 <p class="level1">Pass a curl_off_t as parameter. It contains the offset in number of bytes that you want the transfer to start from. (Added in 7.11.0) 
 <p class="level0"><a name="CURLOPTCUSTOMREQUEST"></a><span class="nroffip">CURLOPT_CUSTOMREQUEST</span> 
 <p class="level1">Pass a pointer to a zero terminated string as parameter. It will be used instead of GET or HEAD when doing an HTTP request, or instead of LIST or NLST when doing an ftp directory listing. This is useful for doing DELETE or other more or less obscure HTTP requests. Don't do this at will, make sure your server supports the command first. 
@@ -585,12 +599,14 @@
 <p class="level1">Pass a char * pointing to a file name for your private key. If not used, libcurl defaults to using <span Class="bold">~/.ssh/id_dsa</span>. If the file is password-protected, set the password with <a class="emphasis" href="#CURLOPTKEYPASSWD">CURLOPT_KEYPASSWD</a>. (Added in 7.16.1) <a name="OTHER"></a><h2 class="nroffsh">OTHER OPTIONS</h2>
 <p class="level0">
 <p class="level0"><a name="CURLOPTPRIVATE"></a><span class="nroffip">CURLOPT_PRIVATE</span> 
 <p class="level1">Pass a void * as parameter, pointing to data that should be associated with this curl handle.  The pointer can subsequently be retrieved using <a class="emphasis" href="./curl_easy_getinfo.html">curl_easy_getinfo(3)</a> with the CURLINFO_PRIVATE option. libcurl itself does nothing with this data. (Added in 7.10.3) 
 <p class="level0"><a name="CURLOPTSHARE"></a><span class="nroffip">CURLOPT_SHARE</span> 
 <p class="level1">Pass a share handle as a parameter. The share handle must have been created by a previous call to <a class="emphasis" href="./curl_share_init.html">curl_share_init(3)</a>. Setting this option, will make this curl handle use the data from the shared handle instead of keeping the data to itself. This enables several curl handles to share data. If the curl handles are used simultaneously, you <span Class="bold">MUST</span> use the locking methods in the share handle. See <a class="emphasis" href="./curl_share_setopt.html">curl_share_setopt(3)</a> for details. 
+<p class="level1">If you add a share that is set to share cookies, your easy handle will use that cookie cache and get the cookie engine enabled. If you unshare an object that were using cookies (or change to another object that doesn't share cookies), the easy handle will get its cookie engine disabled. 
+<p class="level1">Data that the share object is not set to share will be dealt with the usual way, as if no share was used. 
 <p class="level0"><a name="CURLOPTNEWFILEPERMS"></a><span class="nroffip">CURLOPT_NEW_FILE_PERMS</span> 
 <p class="level1">Pass a long as a parameter, containing the value of the permissions that will be assigned to newly created files on the remote server.  The default value is <span Class="emphasis">0644</span>, but any valid value can be used.  The only protocols that can use this are <span Class="emphasis">sftp://</span>, <span Class="emphasis">scp://</span> and <span Class="emphasis">file://</span>. (Added in 7.16.4) 
 <p class="level0"><a name="CURLOPTNEWDIRECTORYPERMS"></a><span class="nroffip">CURLOPT_NEW_DIRECTORY_PERMS</span> 
 <p class="level1">Pass a long as a parameter, containing the value of the permissions that will be assigned to newly created directories on the remote server.  The default value is <span Class="emphasis">0755</span>, but any valid value can be used.  The only protocols that can use this are <span Class="emphasis">sftp://</span>, <span Class="emphasis">scp://</span> and <span Class="emphasis">file://</span>. (Added in 7.16.4) <a name="TELNET"></a><h2 class="nroffsh">TELNET OPTIONS</h2>
 <p class="level0">
 <p class="level0"><a name="CURLOPTTELNETOPTIONS"></a><span class="nroffip">CURLOPT_TELNETOPTIONS</span> 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_setopt.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_setopt.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_strerror.pdf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_strerror.pdf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_strerror.pdf	2007-10-24 17:24:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_strerror.pdf	2008-01-28 19:32:10.000000000 +0800
@@ -57,37 +57,37 @@
 8 0 obj
 <</BaseFont/Times-Roman/Type/Font
 /Subtype/Type1>>
 endobj
 13 0 obj
 <</Type/Metadata
-/Subtype/XML/Length 1293>>stream
+/Subtype/XML/Length 1287>>stream
 <?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'?>
 <?adobe-xap-filters esc="CRLF"?>
 <x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='XMP toolkit 2.9.1-13, framework 1.6'>
 <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:iX='http://ns.adobe.com/iX/1.0/'>
-<rdf:Description rdf:about='83958212-ba2f-11e7-0000-1db77fb63b0c' xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='GPL Ghostscript SVN PRE-RELEASE 8.61'/>
-<rdf:Description rdf:about='83958212-ba2f-11e7-0000-1db77fb63b0c' xmlns:xap='http://ns.adobe.com/xap/1.0/' xap:ModifyDate='2007-10-24T09:24:48Z' xap:CreateDate='2007-10-24T09:24:48Z'><xap:CreatorTool>UnknownApplication</xap:CreatorTool></rdf:Description>
-<rdf:Description rdf:about='83958212-ba2f-11e7-0000-1db77fb63b0c' xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='83958212-ba2f-11e7-0000-1db77fb63b0c'/>
-<rdf:Description rdf:about='83958212-ba2f-11e7-0000-1db77fb63b0c' xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'><dc:title><rdf:Alt><rdf:li xml:lang='x-default'>Untitled</rdf:li></rdf:Alt></dc:title></rdf:Description>
+<rdf:Description rdf:about='363b6f5f-05b1-11e8-0000-1db77fb63b0c' xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='GPL Ghostscript 8.61'/>
+<rdf:Description rdf:about='363b6f5f-05b1-11e8-0000-1db77fb63b0c' xmlns:xap='http://ns.adobe.com/xap/1.0/' xap:ModifyDate='2008-01-28T12:32:10+01:00' xap:CreateDate='2008-01-28T12:32:10+01:00'><xap:CreatorTool>UnknownApplication</xap:CreatorTool></rdf:Description>
+<rdf:Description rdf:about='363b6f5f-05b1-11e8-0000-1db77fb63b0c' xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='363b6f5f-05b1-11e8-0000-1db77fb63b0c'/>
+<rdf:Description rdf:about='363b6f5f-05b1-11e8-0000-1db77fb63b0c' xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'><dc:title><rdf:Alt><rdf:li xml:lang='x-default'>Untitled</rdf:li></rdf:Alt></dc:title></rdf:Description>
 </rdf:RDF>
 </x:xmpmeta>
                                                                         
                                                                         
 <?xpacket end='w'?>
 endstream
 endobj
 2 0 obj
-<</Producer(GPL Ghostscript SVN PRE-RELEASE 8.61)
-/CreationDate(D:20071024092448Z)
-/ModDate(D:20071024092448Z)>>endobj
+<</Producer(GPL Ghostscript 8.61)
+/CreationDate(D:20080128123210+01'00')
+/ModDate(D:20080128123210+01'00')>>endobj
 xref
 0 14
 0000000000 65535 f 
 0000001044 00000 n 
-0000002799 00000 n 
+0000002793 00000 n 
 0000000985 00000 n 
 0000000825 00000 n 
 0000000015 00000 n 
 0000000806 00000 n 
 0000001109 00000 n 
 0000001363 00000 n 
@@ -95,11 +95,11 @@
 0000001230 00000 n 
 0000001150 00000 n 
 0000001180 00000 n 
 0000001429 00000 n 
 trailer
 << /Size 14 /Root 1 0 R /Info 2 0 R
-/ID [<6F6CEEC3B18DA945F637119CA3D7BD84><6F6CEEC3B18DA945F637119CA3D7BD84>]
+/ID [<996DF8F04E0F30180BB8CDAF8B5A5AE4><996DF8F04E0F30180BB8CDAF8B5A5AE4>]
 >>
 startxref
-2926
+2916
 %%EOF
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_easy_unescape.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_easy_unescape.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_escape.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_escape.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_formadd.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_formadd.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_formfree.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_formfree.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_formget.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_formget.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_free.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_free.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_getdate.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_getdate.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_getenv.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_getenv.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_global_cleanup.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_global_cleanup.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_global_init_mem.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_global_init_mem.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_global_init.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_global_init.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_mprintf.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_mprintf.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_add_handle.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_add_handle.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_assign.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_assign.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_cleanup.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_cleanup.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_fdset.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_fdset.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_info_read.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_info_read.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_init.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_init.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_perform.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_perform.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_remove_handle.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_remove_handle.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_setopt.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_setopt.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_setopt.3	2007-05-31 04:04:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_setopt.3	2007-12-12 05:19:38.000000000 +0800
@@ -1,7 +1,7 @@
-.\" $Id: curl_multi_setopt.3,v 1.6 2007-05-30 20:04:44 bagder Exp $
+.\" $Id: curl_multi_setopt.3,v 1.7 2007-12-11 21:19:38 bagder Exp $
 .\"
 .TH curl_multi_setopt 3 "10 Oct 2006" "libcurl 7.16.0" "libcurl Manual"
 .SH NAME
 curl_multi_setopt \- set options for a curl multi handle
 .SH SYNOPSIS
 #include <curl/curl.h>
@@ -44,16 +44,17 @@
 Pass a pointer to a function matching the \fBcurl_multi_timer_callback\fP
 prototype.  This function will then be called when the timeout value
 changes. The timeout value is at what latest time the application should call
 one of the \&"performing" functions of the multi interface
 (\fIcurl_multi_socket(3)\fP, \fIcurl_multi_socket_all(3)\fP and
 \fIcurl_multi_perform(3)\fP) - to allow libcurl to keep timeouts and retries
-etc to work. Libcurl attempts to limit calling this only when the fixed future
-timeout time actually change. See also \fICURLMOPT_TIMERDATA\fP. This callback
-can be used instead of, or in addition to, \fIcurl_multi_timeout(3)\fP. (Added
-in 7.16.0)
+etc to work. A timeout value of -1 means that there is no timeout at all, and
+0 means that the timeout is already reached. Libcurl attempts to limit calling
+this only when the fixed future timeout time actually change. See also
+\fICURLMOPT_TIMERDATA\fP. This callback can be used instead of, or in addition
+to, \fIcurl_multi_timeout(3)\fP. (Added in 7.16.0)
 .IP CURLMOPT_TIMERDATA
 Pass a pointer to whatever you want passed to the
 \fBcurl_multi_timer_callback\fP's third argument, the userp pointer.  This is
 not used by libcurl but only passed-thru as-is. Set the callback pointer with
 \fICURLMOPT_TIMERFUNCTION\fP. (Added in 7.16.0)
 .IP CURLMOPT_MAXCONNECTS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_setopt.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_setopt.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_setopt.html	2007-10-24 17:24:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_setopt.html	2008-01-28 19:31:59.000000000 +0800
@@ -54,13 +54,13 @@
 <p class="level1">Pass a pointer to a function matching the <span Class="bold">curl_socket_callback</span> prototype. The <a class="emphasis" href="./curl_multi_socket.html">curl_multi_socket(3)</a> functions inform the application about updates in the socket (file descriptor) status by doing none, one or multiple calls to the curl_socket_callback given in the <span Class="bold">param</span> argument. They update the status with changes since the previous time a <a class="emphasis" href="./curl_multi_socket.html">curl_multi_socket(3)</a> function was called. If the given callback pointer is NULL, no callback will be called. Set the callback's <span Class="bold">userp</span> argument with <a class="emphasis" href="#CURLMOPTSOCKETDATA">CURLMOPT_SOCKETDATA</a>.  See <a class="emphasis" href="./curl_multi_socket.html">curl_multi_socket(3)</a> for more callback details. 
 <p class="level0"><a name="CURLMOPTSOCKETDATA"></a><span class="nroffip">CURLMOPT_SOCKETDATA</span> 
 <p class="level1">Pass a pointer to whatever you want passed to the <span Class="bold">curl_socket_callback</span>'s forth argument, the userp pointer. This is not used by libcurl but only passed-thru as-is. Set the callback pointer with <a class="emphasis" href="#CURLMOPTSOCKETFUNCTION">CURLMOPT_SOCKETFUNCTION</a>. 
 <p class="level0"><a name="CURLMOPTPIPELINING"></a><span class="nroffip">CURLMOPT_PIPELINING</span> 
 <p class="level1">Pass a long set to 1 to enable or 0 to disable. Enabling pipelining on a multi handle will make it attempt to perform HTTP Pipelining as far as possible for transfers using this handle. This means that if you add a second request that can use an already existing connection, the second request will be "piped" on the same connection rather than being executed in parallell. (Added in 7.16.0) 
 <p class="level0"><a name="CURLMOPTTIMERFUNCTION"></a><span class="nroffip">CURLMOPT_TIMERFUNCTION</span> 
-<p class="level1">Pass a pointer to a function matching the <span Class="bold">curl_multi_timer_callback</span> prototype.  This function will then be called when the timeout value changes. The timeout value is at what latest time the application should call one of the "performing" functions of the multi interface (<a class="emphasis" href="./curl_multi_socket.html">curl_multi_socket(3)</a>, <a class="emphasis" href="./curl_multi_socket_all.html">curl_multi_socket_all(3)</a> and <a class="emphasis" href="./curl_multi_perform.html">curl_multi_perform(3)</a>) - to allow libcurl to keep timeouts and retries etc to work. Libcurl attempts to limit calling this only when the fixed future timeout time actually change. See also <a class="emphasis" href="#CURLMOPTTIMERDATA">CURLMOPT_TIMERDATA</a>. This callback can be used instead of, or in addition to, <a class="emphasis" href="./curl_multi_timeout.html">curl_multi_timeout(3)</a>. (Added in 7.16.0) 
+<p class="level1">Pass a pointer to a function matching the <span Class="bold">curl_multi_timer_callback</span> prototype.  This function will then be called when the timeout value changes. The timeout value is at what latest time the application should call one of the "performing" functions of the multi interface (<a class="emphasis" href="./curl_multi_socket.html">curl_multi_socket(3)</a>, <a class="emphasis" href="./curl_multi_socket_all.html">curl_multi_socket_all(3)</a> and <a class="emphasis" href="./curl_multi_perform.html">curl_multi_perform(3)</a>) - to allow libcurl to keep timeouts and retries etc to work. A timeout value of -1 means that there is no timeout at all, and 0 means that the timeout is already reached. Libcurl attempts to limit calling this only when the fixed future timeout time actually change. See also <a class="emphasis" href="#CURLMOPTTIMERDATA">CURLMOPT_TIMERDATA</a>. This callback can be used instead of, or in addition to, <a class="emphasis" href="./curl_multi_timeout.html">curl_multi_timeout(3)</a>. (Added in 7.16.0) 
 <p class="level0"><a name="CURLMOPTTIMERDATA"></a><span class="nroffip">CURLMOPT_TIMERDATA</span> 
 <p class="level1">Pass a pointer to whatever you want passed to the <span Class="bold">curl_multi_timer_callback</span>'s third argument, the userp pointer.  This is not used by libcurl but only passed-thru as-is. Set the callback pointer with <a class="emphasis" href="#CURLMOPTTIMERFUNCTION">CURLMOPT_TIMERFUNCTION</a>. (Added in 7.16.0) 
 <p class="level0"><a name="CURLMOPTMAXCONNECTS"></a><span class="nroffip">CURLMOPT_MAXCONNECTS</span> 
 <p class="level1">Pass a long. The set number will be used as the maximum amount of simultaneously open connections that libcurl may cache. Default is 10, and libcurl will enlarge the size for each added easy handle to make it fit 4 times the number of added easy handles. 
 <p class="level1">By setting this option, you can prevent the cache size to grow beyond the limit set by you. 
 <p class="level1">When the cache is full, curl closes the oldest one in the cache to prevent the number of open connections to increase. 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_setopt.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_setopt.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_socket.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_socket.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_strerror.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_strerror.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_timeout.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_timeout.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_timeout.3	2006-06-25 05:49:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_timeout.3	2007-12-07 06:36:52.000000000 +0800
@@ -1,7 +1,7 @@
-.\" $Id: curl_multi_timeout.3,v 1.3 2006-06-24 21:49:40 bagder Exp $
+.\" $Id: curl_multi_timeout.3,v 1.4 2007-12-06 22:36:52 bagder Exp $
 .\"
 .TH curl_multi_timeout 3 "2 Jan 2006" "libcurl 7.16.0" "libcurl Manual"
 .SH NAME
 curl_multi_timeout \- how long to wait for action before proceeding
 .SH SYNOPSIS
 #include <curl/curl.h>
@@ -20,12 +20,16 @@
 older multi interface approach.
 
 The timeout value returned in the long \fBtimeout\fP points to, is in number
 of milliseconds at this very moment. If 0, it means you should proceed
 immediately without waiting for anything. If it returns -1, there's no timeout
 at all set.
+
+Note: if libcurl returns a -1 timeout here, it just means that libcurl
+currently has no stored timeout value. You must not wait too long (more than a
+few seconds perhaps) before you call curl_multi_perform() again.
 .SH "RETURN VALUE"
 The standard CURLMcode for multi interface error codes.
 .SH "TYPICAL USAGE"
 Call \fBcurl_multi_timeout(3)\fP, then wait for action on the sockets. You
 figure out which sockets to wait for by calling \fBcurl_multi_fdset(3)\fP or
 by a previous call to \fBcurl_multi_socket(3)\fP.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_timeout.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_timeout.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_timeout.html	2007-10-24 17:24:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_timeout.html	2008-01-28 19:31:59.000000000 +0800
@@ -47,13 +47,14 @@
 <p class="level0">curl_multi_timeout - how long to wait for action before proceeding <a name="SYNOPSIS"></a><h2 class="nroffsh">SYNOPSIS</h2>
 <p class="level0">#include &lt;curl/curl.h&gt; 
 <p class="level0">CURLMcode curl_multi_timeout(CURLM *multi_handle, long *timeout); <a name="DESCRIPTION"></a><h2 class="nroffsh">DESCRIPTION</h2>
 <p class="level0">
 <p class="level0">An application using the libcurl multi interface should call <a class="bold" href="./curl_multi_timeout.html">curl_multi_timeout(3)</a> to figure out how long it should wait for socket actions - at most - before proceeding. 
 <p class="level0">Proceeding means either doing the socket-style timeout action: call the <a class="bold" href="./curl_multi_socket.html">curl_multi_socket(3)</a> function with the <span Class="bold">sockfd</span> argument set to CURL_SOCKET_TIMEOUT and the <span Class="bold">easy</span> argument set to CURL_EASY_TIMEOUT, or simply calling <a class="bold" href="./curl_multi_perform.html">curl_multi_perform(3)</a> if you're using the simpler and older multi interface approach. 
-<p class="level0">The timeout value returned in the long <span Class="bold">timeout</span> points to, is in number of milliseconds at this very moment. If 0, it means you should proceed immediately without waiting for anything. If it returns -1, there's no timeout at all set. <a name="RETURN"></a><h2 class="nroffsh">RETURN VALUE</h2>
+<p class="level0">The timeout value returned in the long <span Class="bold">timeout</span> points to, is in number of milliseconds at this very moment. If 0, it means you should proceed immediately without waiting for anything. If it returns -1, there's no timeout at all set. 
+<p class="level0">Note: if libcurl returns a -1 timeout here, it just means that libcurl currently has no stored timeout value. You must not wait too long (more than a few seconds perhaps) before you call curl_multi_perform() again. <a name="RETURN"></a><h2 class="nroffsh">RETURN VALUE</h2>
 <p class="level0">The standard CURLMcode for multi interface error codes. <a name="TYPICAL"></a><h2 class="nroffsh">TYPICAL USAGE</h2>
 <p class="level0">Call <a class="bold" href="./curl_multi_timeout.html">curl_multi_timeout(3)</a>, then wait for action on the sockets. You figure out which sockets to wait for by calling <a class="bold" href="./curl_multi_fdset.html">curl_multi_fdset(3)</a> or by a previous call to <a class="bold" href="./curl_multi_socket.html">curl_multi_socket(3)</a>. <a name="AVAILABILITY"></a><h2 class="nroffsh">AVAILABILITY</h2>
 <p class="level0">This function was added in libcurl 7.15.4, although not deemed stable yet. <a name="SEE"></a><h2 class="nroffsh">SEE ALSO</h2>
 <p class="level0"><a class="manpage" href="./curl_multi_cleanup.html">curl_multi_cleanup (3)</a> <a class="manpage" href="./curl_multi_init.html">  curl_multi_init (3)</a> <span Class="manpage"> </span> <a class="manpage" href="./curl_multi_fdset.html">curl_multi_fdset (3)</a> <a class="manpage" href="./curl_multi_info_read.html">  curl_multi_info_read (3)</a> <span Class="manpage"> </span> <a class="manpage" href="./curl_multi_socket.html">curl_multi_socket (3) </a> 
 <p class="level0"><p class="roffit">
  This HTML page was made with <a href="http://daniel.haxx.se/projects/roffit/">roffit</a>.
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_multi_timeout.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_multi_timeout.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_share_cleanup.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_share_cleanup.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_share_init.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_share_init.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_share_setopt.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_share_setopt.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_share_strerror.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_share_strerror.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_slist_append.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_slist_append.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_slist_free_all.pdf /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_slist_free_all.pdf
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_slist_free_all.pdf	2007-10-24 17:24:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_slist_free_all.pdf	2008-01-28 19:32:04.000000000 +0800
@@ -56,37 +56,37 @@
 8 0 obj
 <</BaseFont/Times-Roman/Type/Font
 /Subtype/Type1>>
 endobj
 13 0 obj
 <</Type/Metadata
-/Subtype/XML/Length 1293>>stream
+/Subtype/XML/Length 1287>>stream
 <?xpacket begin='' id='W5M0MpCehiHzreSzNTczkc9d'?>
 <?adobe-xap-filters esc="CRLF"?>
 <x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='XMP toolkit 2.9.1-13, framework 1.6'>
 <rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#' xmlns:iX='http://ns.adobe.com/iX/1.0/'>
-<rdf:Description rdf:about='8001fb12-ba2f-11e7-0000-0d90648fa894' xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='GPL Ghostscript SVN PRE-RELEASE 8.61'/>
-<rdf:Description rdf:about='8001fb12-ba2f-11e7-0000-0d90648fa894' xmlns:xap='http://ns.adobe.com/xap/1.0/' xap:ModifyDate='2007-10-24T09:24:42Z' xap:CreateDate='2007-10-24T09:24:42Z'><xap:CreatorTool>UnknownApplication</xap:CreatorTool></rdf:Description>
-<rdf:Description rdf:about='8001fb12-ba2f-11e7-0000-0d90648fa894' xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='8001fb12-ba2f-11e7-0000-0d90648fa894'/>
-<rdf:Description rdf:about='8001fb12-ba2f-11e7-0000-0d90648fa894' xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'><dc:title><rdf:Alt><rdf:li xml:lang='x-default'>Untitled</rdf:li></rdf:Alt></dc:title></rdf:Description>
+<rdf:Description rdf:about='32a7e85f-05b1-11e8-0000-0d90648fa894' xmlns:pdf='http://ns.adobe.com/pdf/1.3/' pdf:Producer='GPL Ghostscript 8.61'/>
+<rdf:Description rdf:about='32a7e85f-05b1-11e8-0000-0d90648fa894' xmlns:xap='http://ns.adobe.com/xap/1.0/' xap:ModifyDate='2008-01-28T12:32:04+01:00' xap:CreateDate='2008-01-28T12:32:04+01:00'><xap:CreatorTool>UnknownApplication</xap:CreatorTool></rdf:Description>
+<rdf:Description rdf:about='32a7e85f-05b1-11e8-0000-0d90648fa894' xmlns:xapMM='http://ns.adobe.com/xap/1.0/mm/' xapMM:DocumentID='32a7e85f-05b1-11e8-0000-0d90648fa894'/>
+<rdf:Description rdf:about='32a7e85f-05b1-11e8-0000-0d90648fa894' xmlns:dc='http://purl.org/dc/elements/1.1/' dc:format='application/pdf'><dc:title><rdf:Alt><rdf:li xml:lang='x-default'>Untitled</rdf:li></rdf:Alt></dc:title></rdf:Description>
 </rdf:RDF>
 </x:xmpmeta>
                                                                         
                                                                         
 <?xpacket end='w'?>
 endstream
 endobj
 2 0 obj
-<</Producer(GPL Ghostscript SVN PRE-RELEASE 8.61)
-/CreationDate(D:20071024092442Z)
-/ModDate(D:20071024092442Z)>>endobj
+<</Producer(GPL Ghostscript 8.61)
+/CreationDate(D:20080128123204+01'00')
+/ModDate(D:20080128123204+01'00')>>endobj
 xref
 0 14
 0000000000 65535 f 
 0000000870 00000 n 
-0000002625 00000 n 
+0000002619 00000 n 
 0000000811 00000 n 
 0000000651 00000 n 
 0000000015 00000 n 
 0000000632 00000 n 
 0000000935 00000 n 
 0000001189 00000 n 
@@ -94,11 +94,11 @@
 0000001056 00000 n 
 0000000976 00000 n 
 0000001006 00000 n 
 0000001255 00000 n 
 trailer
 << /Size 14 /Root 1 0 R /Info 2 0 R
-/ID [<766577ACA0E698C854E8E994F9D59638><766577ACA0E698C854E8E994F9D59638>]
+/ID [<4FB36C80024A87DABB853B6C0AC0FAC8><4FB36C80024A87DABB853B6C0AC0FAC8>]
 >>
 startxref
-2752
+2742
 %%EOF
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_strequal.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_strequal.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_unescape.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_unescape.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_version_info.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_version_info.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/curl_version.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/curl_version.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/libcurl-easy.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/libcurl-easy.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/libcurl-errors.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/libcurl-errors.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/libcurl-multi.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/libcurl-multi.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/libcurl.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/libcurl.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/libcurl-share.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/libcurl-share.pdf differ
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/libcurl-tutorial.pdf and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/libcurl-tutorial.pdf differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/Makefile.am	2007-10-05 06:05:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/Makefile.am	2008-01-08 22:54:23.000000000 +0800
@@ -1,8 +1,8 @@
 #
-# $Id: Makefile.am,v 1.26 2007-10-04 22:05:25 bagder Exp $
+# $Id: Makefile.am,v 1.27 2008-01-08 14:52:07 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 man_MANS = curl_easy_cleanup.3 curl_easy_getinfo.3 curl_easy_init.3	 \
  curl_easy_perform.3 curl_easy_setopt.3 curl_easy_duphandle.3		 \
@@ -15,13 +15,14 @@
  curl_multi_remove_handle.3 curl_share_cleanup.3 curl_share_init.3	 \
  curl_share_setopt.3 libcurl.3 libcurl-easy.3 libcurl-multi.3		 \
  libcurl-share.3 libcurl-errors.3 curl_easy_strerror.3			 \
  curl_multi_strerror.3 curl_share_strerror.3 curl_global_init_mem.3	 \
  libcurl-tutorial.3 curl_easy_reset.3 curl_easy_escape.3		 \
  curl_easy_unescape.3 curl_multi_setopt.3 curl_multi_socket.3		 \
- curl_multi_timeout.3 curl_formget.3 curl_multi_assign.3
+ curl_multi_timeout.3 curl_formget.3 curl_multi_assign.3		 \
+ curl_easy_pause.3
 
 HTMLPAGES = curl_easy_cleanup.html curl_easy_getinfo.html		  \
  curl_easy_init.html curl_easy_perform.html curl_easy_setopt.html	  \
  curl_easy_duphandle.html curl_formadd.html curl_formfree.html		  \
  curl_getdate.html curl_getenv.html curl_slist_append.html		  \
  curl_slist_free_all.html curl_version.html curl_version_info.html	  \
@@ -33,13 +34,13 @@
  curl_share_init.html curl_share_setopt.html libcurl.html		  \
  libcurl-multi.html libcurl-easy.html libcurl-share.html		  \
  libcurl-errors.html curl_easy_strerror.html curl_multi_strerror.html	  \
  curl_share_strerror.html curl_global_init_mem.html libcurl-tutorial.html \
  curl_easy_reset.html curl_easy_escape.html curl_easy_unescape.html	  \
  curl_multi_setopt.html curl_multi_socket.html curl_multi_timeout.html	  \
- curl_formget.html curl_multi_assign.html
+ curl_formget.html curl_multi_assign.html curl_easy_pause.html
 
 PDFPAGES = curl_easy_cleanup.pdf curl_easy_getinfo.pdf curl_easy_init.pdf \
  curl_easy_perform.pdf curl_easy_setopt.pdf curl_easy_duphandle.pdf	  \
  curl_formadd.pdf curl_formfree.pdf curl_getdate.pdf curl_getenv.pdf	  \
  curl_slist_append.pdf curl_slist_free_all.pdf curl_version.pdf		  \
  curl_version_info.pdf curl_escape.pdf curl_unescape.pdf curl_free.pdf	  \
@@ -50,13 +51,13 @@
  curl_share_cleanup.pdf curl_share_init.pdf curl_share_setopt.pdf	  \
  libcurl.pdf libcurl-multi.pdf libcurl-easy.pdf libcurl-share.pdf	  \
  libcurl-errors.pdf curl_easy_strerror.pdf curl_multi_strerror.pdf	  \
  curl_share_strerror.pdf curl_global_init_mem.pdf libcurl-tutorial.pdf	  \
  curl_easy_reset.pdf curl_easy_escape.pdf curl_easy_unescape.pdf	  \
  curl_multi_setopt.pdf curl_multi_socket.pdf curl_multi_timeout.pdf	  \
- curl_formget.pdf curl_multi_assign.pdf
+ curl_formget.pdf curl_multi_assign.pdf curl_easy_pause.pdf
 
 CLEANFILES = $(HTMLPAGES) $(PDFPAGES)
 
 EXTRA_DIST = $(man_MANS) $(HTMLPAGES) index.html $(PDFPAGES) libcurl.m4 ABI
 
 MAN2HTML= roffit --mandir=. < $< >$@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/libcurl/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/libcurl/Makefile.in	2008-01-28 19:59:49.000000000 +0800
@@ -12,13 +12,13 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.26 2007-10-04 22:05:25 bagder Exp $
+# $Id: Makefile.am,v 1.27 2008-01-08 14:52:07 bagder Exp $
 #
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -144,12 +144,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
@@ -215,13 +218,14 @@
  curl_multi_remove_handle.3 curl_share_cleanup.3 curl_share_init.3	 \
  curl_share_setopt.3 libcurl.3 libcurl-easy.3 libcurl-multi.3		 \
  libcurl-share.3 libcurl-errors.3 curl_easy_strerror.3			 \
  curl_multi_strerror.3 curl_share_strerror.3 curl_global_init_mem.3	 \
  libcurl-tutorial.3 curl_easy_reset.3 curl_easy_escape.3		 \
  curl_easy_unescape.3 curl_multi_setopt.3 curl_multi_socket.3		 \
- curl_multi_timeout.3 curl_formget.3 curl_multi_assign.3
+ curl_multi_timeout.3 curl_formget.3 curl_multi_assign.3		 \
+ curl_easy_pause.3
 
 HTMLPAGES = curl_easy_cleanup.html curl_easy_getinfo.html		  \
  curl_easy_init.html curl_easy_perform.html curl_easy_setopt.html	  \
  curl_easy_duphandle.html curl_formadd.html curl_formfree.html		  \
  curl_getdate.html curl_getenv.html curl_slist_append.html		  \
  curl_slist_free_all.html curl_version.html curl_version_info.html	  \
@@ -233,13 +237,13 @@
  curl_share_init.html curl_share_setopt.html libcurl.html		  \
  libcurl-multi.html libcurl-easy.html libcurl-share.html		  \
  libcurl-errors.html curl_easy_strerror.html curl_multi_strerror.html	  \
  curl_share_strerror.html curl_global_init_mem.html libcurl-tutorial.html \
  curl_easy_reset.html curl_easy_escape.html curl_easy_unescape.html	  \
  curl_multi_setopt.html curl_multi_socket.html curl_multi_timeout.html	  \
- curl_formget.html curl_multi_assign.html
+ curl_formget.html curl_multi_assign.html curl_easy_pause.html
 
 PDFPAGES = curl_easy_cleanup.pdf curl_easy_getinfo.pdf curl_easy_init.pdf \
  curl_easy_perform.pdf curl_easy_setopt.pdf curl_easy_duphandle.pdf	  \
  curl_formadd.pdf curl_formfree.pdf curl_getdate.pdf curl_getenv.pdf	  \
  curl_slist_append.pdf curl_slist_free_all.pdf curl_version.pdf		  \
  curl_version_info.pdf curl_escape.pdf curl_unescape.pdf curl_free.pdf	  \
@@ -250,13 +254,13 @@
  curl_share_cleanup.pdf curl_share_init.pdf curl_share_setopt.pdf	  \
  libcurl.pdf libcurl-multi.pdf libcurl-easy.pdf libcurl-share.pdf	  \
  libcurl-errors.pdf curl_easy_strerror.pdf curl_multi_strerror.pdf	  \
  curl_share_strerror.pdf curl_global_init_mem.pdf libcurl-tutorial.pdf	  \
  curl_easy_reset.pdf curl_easy_escape.pdf curl_easy_unescape.pdf	  \
  curl_multi_setopt.pdf curl_multi_socket.pdf curl_multi_timeout.pdf	  \
- curl_formget.pdf curl_multi_assign.pdf
+ curl_formget.pdf curl_multi_assign.pdf curl_easy_pause.pdf
 
 CLEANFILES = $(HTMLPAGES) $(PDFPAGES)
 EXTRA_DIST = $(man_MANS) $(HTMLPAGES) index.html $(PDFPAGES) libcurl.m4 ABI
 MAN2HTML = roffit --mandir=. < $< >$@
 SUFFIXES = .3 .html
 all: all-am
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/Makefile.in	2007-10-27 06:25:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/Makefile.in	2008-01-28 19:59:49.000000000 +0800
@@ -154,12 +154,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/THANKS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/THANKS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/THANKS	2007-10-03 16:50:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/THANKS	2007-10-31 06:46:11.000000000 +0800
@@ -9,19 +9,21 @@
 Adrian Schuur
 Alan Pinstein
 Albert Chin-A-Young
 Albert Choy
 Ale Vesely
 Aleksandar Milivojevic
+Alex Fishman
 Alex Neblett
 Alex Suykov
 Alex aka WindEagle
 Alexander Kourakos
 Alexander Krasnostavsky
 Alexander Lazic
 Alexander Zhuravlev
+Alexey Pesternikov
 Alexey Simak
 Alexis Carvalho
 Allen Pulsifer
 Amol Pattekar
 Anders Gustafsson
 Andi Jahja
@@ -226,12 +228,13 @@
 Ian Turner
 Ian Wilkes
 Ignacio Vazquez-Abrams
 Igor Polyakov
 Ilguiz Latypov
 Ilja van Sprundel
+Immanuel Gregoire
 Ingmar Runge
 Ingo Ralf Blum
 Ingo Wilken
 Jacky Lam
 Jacob Meuser
 James Bursa
@@ -271,12 +274,13 @@
 Johan Nilsson
 John Crow
 John Janssen
 John Kelly
 John Lask
 John McGowan
+Johnny Luong
 Jon Grubbs
 Jon Travis
 Jon Turner
 Jonas Forsman
 Jonatan Lander
 Jonathan Hseu
@@ -305,12 +309,13 @@
 Ken Hirsch
 Ken Rastatter
 Kent Boortz
 Kevin Fisk
 Kevin Lussier
 Kevin Roth
+Kim Rinnewitz
 Kimmo Kinnunen
 Kjell Ericson
 Kjetil Jacobsen
 Klevtsov Vadim
 Kris Kennaway
 Krishnendu Majumdar
@@ -345,12 +350,13 @@
 Marcelo Juchem 
 Marcin Konicki
 Marco G. Salvagno
 Marcus Webster
 Mario Schroeder
 Mark Butler
+Mark Davies
 Mark Eichin
 Mark Lentczner
 Markus Koetter
 Markus Moeller
 Markus Oberhumer
 Martijn Koster
@@ -365,12 +371,13 @@
 Matt Kraai
 Matt Veenstra
 Matt Witherspoon
 Matthew Blain
 Matthew Clarke
 Maurice Barnum
+Max Katsev
 Mekonikum
 Mettgut Jamalla
 Michael Benedict
 Michael Curtis
 Michael Jahn
 Michael Jerris
@@ -437,12 +444,13 @@
 Peter Todd
 Peter Verhas
 Peter Wullinger
 Peteris Krumins
 Phil Karn
 Philip Gladstone
+Philip Langdale
 Philippe Hameau
 Philippe Raoult
 Philippe Vaucher
 Pierre
 Puneet Pawaia
 Quagmire
@@ -572,12 +580,13 @@
 Venkat Akella
 Victor Snezhko
 Vilmos Nebehaj
 Vincent Bronner
 Vincent Penquerc'h
 Vincent Sanders
+Vladimir Lazarenko
 Vojtech Janota
 Vojtech Minarik
 Walter J. Mack
 Wayne Haigh
 Werner Koch
 Wesley Laxton
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/docs/TODO	2007-09-14 04:18:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/docs/TODO	2008-01-16 06:44:26.000000000 +0800
@@ -1,349 +1,572 @@
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
-TODO
+                Things that could be nice to do in the future
 
  Things to do in project cURL. Please tell us what you think, contribute and
- send us patches that improve things! Also check the http://curl.haxx.se/dev
- web section for various technical development notes.
+ send us patches that improve things!
 
  All bugs documented in the KNOWN_BUGS document are subject for fixing!
 
- LIBCURL
+ 1. libcurl
+ 1.1 Zero-copy interface
+ 1.2 More data sharing
+ 1.3 struct lifreq
+ 1.4 Get IP address
+ 1.5 c-ares ipv6
+ 1.6 configure-based info in public headers
 
- * Introduce another callback interface for upload/download that makes one
-   less copy of data and thus a faster operation.
-   [http://curl.haxx.se/dev/no_copy_callbacks.txt]
+ 2. libcurl - multi interface
+ 2.1 More non-blocking
+ 2.2 Pause transfers
+ 2.3 Remove easy interface internally
+ 2.4 Avoid having to remove/readd handles
 
- * More data sharing. curl_share_* functions already exist and work, and they
-   can be extended to share more. For example, enable sharing of the ares
-   channel and the connection cache.
+ 3. Documentation
+ 3.1  More and better
 
- * Introduce a new error code indicating authentication problems (for proxy
-   CONNECT error 407 for example). This cannot be an error code, we must not
-   return informational stuff as errors, consider a new info returned by
-   curl_easy_getinfo() http://curl.haxx.se/bug/view.cgi?id=845941
+ 4. FTP
+ 4.1 PRET
+ 4.2 Alter passive/active on failure and retry
+ 4.3 Earlier bad letter detection
+ 4.4 REST for large files
+ 4.5 FTP proxy support
+ 4.6 PORT port range
+ 4.7 ASCII support
 
- * Use 'struct lifreq' and SIOCGLIFADDR instead of 'struct ifreq' and
-   SIOCGIFADDR on newer Solaris versions as they claim the latter is obsolete.
-   To support ipv6 interface addresses properly.
+ 5. HTTP
+ 5.1 Other HTTP versions with CONNECT
+ 5.2 Better persistancy for HTTP 1.0
+ 5.3 support FF3 sqlite cookie files
 
- * Add the following to curl_easy_getinfo(): GET_HTTP_IP, GET_FTP_IP and
-   GET_FTP_DATA_IP. Return a string with the used IP. Suggested by Alan.
+ 6. TELNET
+ 6.1 ditch stdin
+ 6.2 ditch telnet-specific select
 
- * Add option that changes the interval in which the progress callback is
-   called at most.
+ 7. SSL
+ 7.1 Disable specific versions
+ 7.2 Provide mytex locking API
+ 7.3 dumpcert
+ 7.4 Evaluate SSL patches
+ 7.5 Cache OpenSSL contexts
+ 7.6 Export session ids
+ 7.7 Provide callback for cert verfication
+ 7.8 Support other SSL libraries
+ 7.9  Support SRP on the TLS layer
+ 7.10 improve configure --with-ssl
 
- * Make libcurl built with c-ares use c-ares' IPv6 abilities. They weren't
-   present when we first added c-ares support but they have been added since!
-   When this is done and works, we can actually start considering making c-ares
-   powered libcurl the default build (which of course would require that we'd
-   bundle the c-ares source code in the libcurl source code releases).
+ 8. GnuTLS
+ 8.1 Make NTLM work without OpenSSL functions
+ 8.2 SSl engine stuff
+ 8.3 SRP
+ 8.4 non-blocking
+ 8.5 check connection
 
- * Make the curl/*.h headers include the proper system includes based on what
-   was present at the time when configure was run. Currently, the sys/select.h
-   header is for example included by curl/multi.h only on specific platforms
-   we know MUST have it. This is error-prone. We therefore want the header
-   files to adapt to configure results. Those results must be stored in a new
-   header and they must use a curl name space, i.e not be HAVE_* prefix (as
-   that would risk collide with other apps that use libcurl and that runs
-   configure).
+ 9. LDAP
+ 9.1 ditch ldap-specific select
 
-   Work on this has been started but hasn't been finished, and the initial
-   patch and some details are found here:
-   http://curl.haxx.se/mail/lib-2006-12/0084.html
+ 10. New protocols
+ 10.1 RTSP
+ 10.2 RSYNC
+ 10.3 RTMP
 
- LIBCURL - multi interface
+ 11. Client
+ 11.1 Content-Disposition
+ 11.2 sync
+ 11.3 glob posts
+ 11.4 prevent file overwriting
+ 11.5 ftp wildcard download
+ 11.6 simultaneous parallel transfers
+ 11.7 provide formpost headers
+ 11.8 url-specific options
 
- * Make sure we don't ever loop because of non-blocking sockets return
-   EWOULDBLOCK or similar. The GnuTLS connection etc.
+ 12. Build
+ 12.1 roffit
 
- * Make transfers treated more carefully. We need a way to tell libcurl we
-   have data to write, as the current system expects us to upload data each
-   time the socket is writable and there is no way to say that we want to
-   upload data soon just not right now, without that aborting the upload. The
-   opposite situation should be possible as well, that we tell libcurl we're
-   ready to accept read data. Today libcurl feeds the data as soon as it is
-   available for reading, no matter what.
+ 13. Test suite
+ 13.1 SSL tunnel
+ 13.2 nicer lacking perl message
+ 13.3 more protocols supported
+ 13.4 more platforms supported
 
- * Make curl_easy_perform() a wrapper-function that simply creates a multi
-   handle, adds the easy handle to it, runs curl_multi_perform() until the
-   transfer is done, then detach the easy handle, destroy the multi handle and
-   return the easy handle's return code. This will thus make everything
-   internally use and assume the multi interface. The select()-loop should use
-   curl_multi_socket().
+ 14. Next SONAME bump
+ 14.1 http-style HEAD output for ftp
+ 14.2 combine error codes
+ 14.3 extend CURLOPT_SOCKOPTFUNCTION prototype
 
- * curl_multi_handle_control() - this can control the easy handle (while)
-   added to a multi handle in various ways:
-   o RESTART, unconditionally restart this easy handle's transfer from the
-     start, re-init the state
-   o RESTART_COMPLETED, restart this easy handle's transfer but only if the
-     existing transfer has already completed and it is in a "finished state".
-   o STOP, just stop this transfer and consider it completed
-   o PAUSE?
-   o RESUME?
+ 15. Next major release
+ 15.1 cleanup return codes
+ 15.2 remove obsolete defines
+ 15.3 size_t
+ 15.4 remove several functions
+ 15.5 remove CURLOPT_FAILONERROR
+ 15.6 remove CURLOPT_DNS_USE_GLOBAL_CACHE
 
- DOCUMENTATION
+==============================================================================
 
- * More and better
+1. libcurl
 
- FTP
+1.1 Zero-copy interface
 
- * PRET is a command that primarily "drftpd" supports, which could be useful
-   when using libcurl against such a server. It is a non-standard and a rather
-   oddly designed command, but...
-   http://curl.haxx.se/bug/feature.cgi?id=1729967
+ Introdue another callback interface for upload/download that makes one less
+ copy of data and thus a faster operation.
+ [http://curl.haxx.se/dev/no_copy_callbacks.txt]
 
- * When trying to connect passively to a server which only supports active
-   connections, libcurl returns CURLE_FTP_WEIRD_PASV_REPLY and closes the
-   connection. There could be a way to fallback to an active connection (and
-   vice versa). http://curl.haxx.se/bug/feature.cgi?id=1754793
+1.2 More data sharing
 
- * Make the detection of (bad) %0d and %0a codes in FTP url parts earlier in
-   the process to avoid doing a resolve and connect in vain.
+ curl_share_* functions already exist and work, and they can be extended to
+ share more. For example, enable sharing of the ares channel and the
+ connection cache.
 
- * REST fix for servers not behaving well on >2GB requests. This should fail
-   if the server doesn't set the pointer to the requested index. The tricky
-   (impossible?) part is to figure out if the server did the right thing or
-   not.
+1.3 struct lifreq
 
- * Support the most common FTP proxies, Philip Newton provided a list
-   allegedly from ncftp:
-   http://curl.haxx.se/mail/archive-2003-04/0126.html
+ Use 'struct lifreq' and SIOCGLIFADDR instead of 'struct ifreq' and
+ SIOCGIFADDR on newer Solaris versions as they claim the latter is obsolete.
+ To support ipv6 interface addresses for network interfaces properly.
 
- * Make CURLOPT_FTPPORT support an additional port number on the IP/if/name,
-   like "blabla:[port]" or possibly even "blabla:[portfirst]-[portsecond]".
-   http://curl.haxx.se/bug/feature.cgi?id=1505166
+1.4 Get IP address
 
- * FTP ASCII transfers do not follow RFC959. They don't convert the data
-   accordingly.
+ Add the following to curl_easy_getinfo(): GET_HTTP_IP, GET_FTP_IP and
+ GET_FTP_DATA_IP. Return a string with the used IP.
 
- * Since USERPWD always override the user and password specified in URLs, we
-   might need another way to specify user+password for anonymous ftp logins.
+1.5 c-ares ipv6
 
- * The FTP code should get a way of returning errors that is known to still
-   have the control connection alive and sound. Currently, a returned error
-   from within ftp-functions does not tell if the control connection is still
-   OK to use or not. This causes libcurl to fail to re-use connections
-   slightly too often.
+ Make libcurl built with c-ares use c-ares' IPv6 abilities. They weren't
+ present when we first added c-ares support but they have been added since!
+ When this is done and works, we can actually start considering making c-ares
+ powered libcurl the default build (which of course would require that we'd
+ bundle the c-ares source code in the libcurl source code releases).
 
- HTTP
+1.6 configure-based info in public headers
 
- * When doing CONNECT to a HTTP proxy, libcurl always uses HTTP/1.0. This has
-   never been reported as causing trouble to anyone, but should be considered
-   to use the HTTP version the user has chosen.
+ Make the public headers include the proper system includes based on what was
+ present at the time when configure was run. Currently, the sys/select.h
+ header is for example included by curl/multi.h only on specific platforms we
+ know MUST have it. This is error-prone. We therefore want the header files to
+ adapt to configure results. Those results must be stored in a new header and
+ they must use a curl name space, i.e not be HAVE_* prefix (as that would risk
+ collide with other apps that use libcurl and that runs configure).
 
- * "Better" support for persistent connections over HTTP 1.0
-   http://curl.haxx.se/bug/feature.cgi?id=1089001
+ Work on this has been started but hasn't been finished, and the initial patch
+ and some details are found here:
+ http://curl.haxx.se/mail/lib-2006-12/0084.html
 
- TELNET
+ The remaining problems to solve involve the platforms that can't run
+ configure.
 
- * Reading input (to send to the remote server) on stdin is a crappy solution
-   for library purposes. We need to invent a good way for the application to
-   be able to provide the data to send.
+2. libcurl - multi interface
 
- * Move the telnet support's network select() loop go away and merge the code
-   into the main transfer loop. Until this is done, the multi interface won't
-   work for telnet.
+2.1 More non-blocking
 
- SSL
+ Make sure we don't ever loop because of non-blocking sockets return
+ EWOULDBLOCK or similar. The GnuTLS connection etc.
 
- * Provide an option that allows for disabling specific SSL versions, such as
-   SSLv2 http://curl.haxx.se/bug/feature.cgi?id=1767276
+2.2 Pause transfers
 
- * Provide a libcurl API for setting mutex callbacks in the underlying SSL
-   library, so that the same application code can use mutex-locking
-   independently of OpenSSL or GnutTLS being used.
+ Make transfers treated more carefully. We need a way to tell libcurl we have
+ data to write, as the current system expects us to upload data each time the
+ socket is writable and there is no way to say that we want to upload data
+ soon just not right now, without that aborting the upload. The opposite
+ situation should be possible as well, that we tell libcurl we're ready to
+ accept read data. Today libcurl feeds the data as soon as it is available for
+ reading, no matter what.
 
- * Anton Fedorov's "dumpcert" patch:
-   http://curl.haxx.se/mail/lib-2004-03/0088.html
+2.3 Remove easy interface internally
 
- * Evaluate/apply Gertjan van Wingerde's SSL patches:
-   http://curl.haxx.se/mail/lib-2004-03/0087.html
+ Make curl_easy_perform() a wrapper-function that simply creates a multi
+ handle, adds the easy handle to it, runs curl_multi_perform() until the
+ transfer is done, then detach the easy handle, destroy the multi handle and
+ return the easy handle's return code. This will thus make everything
+ internally use and assume the multi interface. The select()-loop should use
+ curl_multi_socket().
 
- * "Look at SSL cafile - quick traces look to me like these are done on every
-   request as well, when they should only be necessary once per ssl context
-   (or once per handle)". The major improvement we can rather easily do is to
-   make sure we don't create and kill a new SSL "context" for every request,
-   but instead make one for every connection and re-use that SSL context in
-   the same style connections are re-used. It will make us use slightly more
-   memory but it will libcurl do less creations and deletions of SSL contexts.
+2.4 Avoid having to remove/readd handles
 
- * Add an interface to libcurl that enables "session IDs" to get
-   exported/imported. Cris Bailiff said: "OpenSSL has functions which can
-   serialise the current SSL state to a buffer of your choice, and
-   recover/reset the state from such a buffer at a later date - this is used
-   by mod_ssl for apache to implement and SSL session ID cache".
+ curl_multi_handle_control() - this can control the easy handle (while) added
+ to a multi handle in various ways:
 
- * OpenSSL supports a callback for customised verification of the peer
-   certificate, but this doesn't seem to be exposed in the libcurl APIs. Could
-   it be? There's so much that could be done if it were! (brought by Chris
-   Clark)
+ o RESTART, unconditionally restart this easy handle's transfer from the
+   start, re-init the state
 
- * Make curl's SSL layer capable of using other free SSL libraries.  Such as
-   MatrixSSL (http://www.matrixssl.org/).
+ o RESTART_COMPLETED, restart this easy handle's transfer but only if the
+   existing transfer has already completed and it is in a "finished state".
 
- * Peter Sylvester's patch for SRP on the TLS layer.
-   Awaits OpenSSL support for this, no need to support this in libcurl before
-   there's an OpenSSL release that does it.
+ o STOP, just stop this transfer and consider it completed
 
- * make the configure --with-ssl option first check for OpenSSL, then GnuTLS,
-   then NSS...
+ o PAUSE?
 
- GnuTLS
+ o RESUME?
 
- * Get NTLM working using the functions provided by libgcrypt, since GnuTLS
-   already depends on that to function. Not strictly SSL/TLS related, but
-   hey... Another option is to get available DES and MD4 source code from the
-   cryptopp library. They are fine license-wise, but are C++.
+3. Documentation
 
- * SSL engine stuff?
+3.1  More and better
 
- * Work out a common method with Peter Sylvester's OpenSSL-patch for SRP
-   on the TLS to provide name and password
+ Exactly
 
- * Fix the connection phase to be non-blocking when multi interface is used
+4. FTP
 
- * Add a way to check if the connection seems to be alive, to correspond to
-   the SSL_peak() way we use with OpenSSL.
+4.1 PRET
 
- LDAP
+ PRET is a command that primarily "drftpd" supports, which could be useful
+ when using libcurl against such a server. It is a non-standard and a rather
+ oddly designed command, but...
+ http://curl.haxx.se/bug/feature.cgi?id=1729967
+
+4.2 Alter passive/active on failure and retry
+
+ When trying to connect passively to a server which only supports active
+ connections, libcurl returns CURLE_FTP_WEIRD_PASV_REPLY and closes the
+ connection. There could be a way to fallback to an active connection (and
+ vice versa). http://curl.haxx.se/bug/feature.cgi?id=1754793
+
+4.3 Earlier bad letter detection
+
+ Make the detection of (bad) %0d and %0a codes in FTP url parts earlier in the
+ process to avoid doing a resolve and connect in vain.
+
+4.4 REST for large files
+
+ REST fix for servers not behaving well on >2GB requests. This should fail if
+ the server doesn't set the pointer to the requested index. The tricky
+ (impossible?) part is to figure out if the server did the right thing or not.
+
+4.5 FTP proxy support
+
+ Support the most common FTP proxies, Philip Newton provided a list allegedly
+ from ncftp. This is not a subject without debate, and is probably not really
+ suitable for libcurl.  http://curl.haxx.se/mail/archive-2003-04/0126.html
+
+4.6 PORT port range
+
+ Make CURLOPT_FTPPORT support an additional port number on the IP/if/name,
+ like "blabla:[port]" or possibly even "blabla:[portfirst]-[portsecond]".
+ http://curl.haxx.se/bug/feature.cgi?id=1505166
+
+4.7 ASCII support
+
+ FTP ASCII transfers do not follow RFC959. They don't convert the data
+ accordingly.
+
+5. HTTP
+
+5.1 Other HTTP versions with CONNECT
+
+ When doing CONNECT to a HTTP proxy, libcurl always uses HTTP/1.0. This has
+ never been reported as causing trouble to anyone, but should be considered to
+ use the HTTP version the user has chosen.
+
+5.2 Better persistancy for HTTP 1.0
+
+ "Better" support for persistent connections over HTTP 1.0
+ http://curl.haxx.se/bug/feature.cgi?id=1089001
+
+5.3 support FF3 sqlite cookie files
+
+ Firefox 3 is changing from its former format to a a sqlite database instead.
+ We should consider how (lib)curl can/should support this.
+ http://curl.haxx.se/bug/feature.cgi?id=1871388
+
+6. TELNET
+
+6.1 ditch stdin
+
+Reading input (to send to the remote server) on stdin is a crappy solution for
+library purposes. We need to invent a good way for the application to be able
+to provide the data to send.
+
+6.2 ditch telnet-specific select
+
+ Move the telnet support's network select() loop go away and merge the code
+ into the main transfer loop. Until this is done, the multi interface won't
+ work for telnet.
+
+7. SSL
+
+7.1 Disable specific versions
+
+ Provide an option that allows for disabling specific SSL versions, such as
+ SSLv2 http://curl.haxx.se/bug/feature.cgi?id=1767276
+
+7.2 Provide mytex locking API
+
+ Provide a libcurl API for setting mutex callbacks in the underlying SSL
+ library, so that the same application code can use mutex-locking
+ independently of OpenSSL or GnutTLS being used.
+
+7.3 dumpcert
+
+ Anton Fedorov's "dumpcert" patch:
+ http://curl.haxx.se/mail/lib-2004-03/0088.html
+
+7.4 Evaluate SSL patches
+
+ Evaluate/apply Gertjan van Wingerde's SSL patches:
+ http://curl.haxx.se/mail/lib-2004-03/0087.html
+
+7.5 Cache OpenSSL contexts
+
+ "Look at SSL cafile - quick traces look to me like these are done on every
+ request as well, when they should only be necessary once per ssl context (or
+ once per handle)". The major improvement we can rather easily do is to make
+ sure we don't create and kill a new SSL "context" for every request, but
+ instead make one for every connection and re-use that SSL context in the same
+ style connections are re-used. It will make us use slightly more memory but
+ it will libcurl do less creations and deletions of SSL contexts.
+
+7.6 Export session ids
+
+ Add an interface to libcurl that enables "session IDs" to get
+ exported/imported. Cris Bailiff said: "OpenSSL has functions which can
+ serialise the current SSL state to a buffer of your choice, and recover/reset
+ the state from such a buffer at a later date - this is used by mod_ssl for
+ apache to implement and SSL session ID cache".
+
+7.7 Provide callback for cert verfication
+
+ OpenSSL supports a callback for customised verification of the peer
+ certificate, but this doesn't seem to be exposed in the libcurl APIs. Could
+ it be? There's so much that could be done if it were!
+
+7.8 Support other SSL libraries
+
+ Make curl's SSL layer capable of using other free SSL libraries.  Such as
+ MatrixSSL (http://www.matrixssl.org/).
+
+7.9  Support SRP on the TLS layer
+
+ Peter Sylvester's patch for SRP on the TLS layer.  Awaits OpenSSL support for
+ this, no need to support this in libcurl before there's an OpenSSL release
+ that does it.
+
+7.10 improve configure --with-ssl
+
+ make the configure --with-ssl option first check for OpenSSL, then GnuTLS,
+ then NSS...
+
+8. GnuTLS
+
+8.1 Make NTLM work without OpenSSL functions
+
+ Get NTLM working using the functions provided by libgcrypt, since GnuTLS
+ already depends on that to function. Not strictly SSL/TLS related, but
+ hey... Another option is to get available DES and MD4 source code from the
+ cryptopp library. They are fine license-wise, but are C++.
+
+8.2 SSl engine stuff
+
+ Is this even possible?
+
+8.3 SRP
+
+ Work out a common method with Peter Sylvester's OpenSSL-patch for SRP on the
+ TLS to provide name and password. GnuTLS already supports it...
+
+8.4 non-blocking
+
+ Fix the connection phase to be non-blocking when multi interface is used
+
+8.5 check connection
+
+ Add a way to check if the connection seems to be alive, to correspond to the
+ SSL_peak() way we use with OpenSSL.
+
+9. LDAP
+
+9.1 ditch ldap-specific select
 
  * Look over the implementation. The looping will have to "go away" from the
    lib/ldap.c source file and get moved to the main network code so that the
    multi interface and friends will work for LDAP as well.
 
- NEW PROTOCOLS
+10. New protocols
+
+10.1 RTSP
+
+ RFC2326 (protocol - very HTTP-like, also contains URL description)
+
+10.2 RSYNC
+
+ There's no RFC for protocol nor URI/URL format.  An implementation should
+ most probably use an existing rsync library, such as librsync.
+
+10.3 RTMP
+
+ There exists a patch that claims to introduce this protocol:
+ http://osdir.com/ml/gnu.gnash.devel2/2006-11/msg00278.html, further details
+ in the feature-request: http://curl.haxx.se/bug/feature.cgi?id=1843469
+
+11. Client
+
+11.1 Content-Disposition
+
+ Add option that is similar to -O but that takes the output file name from the
+ Content-Disposition: header, and/or uses the local file name used in
+ redirections for the cases the server bounces the request further to a
+ different file (name): http://curl.haxx.se/bug/feature.cgi?id=1364676
+
+11.2 sync
+
+ "curl --sync http://example.com/feed[1-100].rss" or
+ "curl --sync http://example.net/{index,calendar,history}.html"
+
+ Downloads a range or set of URLs using the remote name, but only if the
+ remote file is newer than the local file. A Last-Modified HTTP date header
+ should also be used to set the mod date on the downloaded file.
+
+11.3 glob posts
+
+ Globbing support for -d and -F, as in 'curl -d "name=foo[0-9]" URL'.
+ This is easily scripted though.
+
+11.4 prevent file overwriting
+
+ Add an option that prevents cURL from overwriting existing local files. When
+ used, and there already is an existing file with the target file name
+ (either -O or -o), a number should be appended (and increased if already
+ existing). So that index.html becomes first index.html.1 and then
+ index.html.2 etc.
+
+11.5 ftp wildcard download
+
+ "curl ftp://site.com/*.txt"
+
+11.6 simultaneous parallel transfers
+
+ The client could be told to use maximum N simultaneous parallel transfers and
+ then just make sure that happens. It should of course not make more than one
+ connection to the same remote host. This would require the client to use the
+ multi interface. http://curl.haxx.se/bug/feature.cgi?id=1558595
+
+11.7 provide formpost headers
+
+ Extending the capabilities of the multipart formposting. How about leaving
+ the ';type=foo' syntax as it is and adding an extra tag (headers) which
+ works like this: curl -F "coolfiles=@fil1.txt;headers=@fil1.hdr" where
+ fil1.hdr contains extra headers like
+
+   Content-Type: text/plain; charset=KOI8-R"
+   Content-Transfer-Encoding: base64
+   X-User-Comment: Please don't use browser specific HTML code
+
+ which should overwrite the program reasonable defaults (plain/text,
+ 8bit...)
+
+11.8 url-specific options
+
+ Provide a way to make options bound to a specific URL among several on the
+ command line. Possibly by letting ':' separate options between URLs,
+ similar to this:
+
+    curl --data foo --url url.com : \
+        --url url2.com : \
+        --url url3.com --data foo3
+
+ (More details: http://curl.haxx.se/mail/archive-2004-07/0133.html)
+
+ The example would do a POST-GET-POST combination on a single command line.
+
+12. Build
 
- * RTSP - RFC2326 (protocol - very HTTP-like, also contains URL description)
+12.1 roffit
 
- * RSYNC (no RFCs for protocol nor URI/URL format).  An implementation should
-   most probably use an existing rsync library, such as librsync.
+ Consider extending 'roffit' to produce decent ASCII output, and use that
+ instead of (g)nroff when building src/hugehelp.c
 
- CLIENT
+13. Test suite
 
- * Add option that is similar to -O but that takes the output file name from
-   the Content-Disposition: header, and/or uses the local file name used in
-   redirections for the cases the server bounces the request further to a
-   different file (name): http://curl.haxx.se/bug/feature.cgi?id=1364676 
+13.1 SSL tunnel
 
- * "curl --sync http://example.com/feed[1-100].rss" or
-   "curl --sync http://example.net/{index,calendar,history}.html"
+ Make our own version of stunnel for simple port forwarding to enable HTTPS
+ and FTP-SSL tests without the stunnel dependency, and it could allow us to
+ provide test tools built with either OpenSSL or GnuTLS
 
-   Downloads a range or set of URLs using the remote name, but only if the
-   remote file is newer than the local file. A Last-Modified HTTP date header
-   should also be used to set the mod date on the downloaded file.
-   (idea from "Brianiac")
+13.2 nicer lacking perl message
 
- * Globbing support for -d and -F, as in 'curl -d "name=foo[0-9]" URL'.
-   Requested by Dane Jensen and others. This is easily scripted though.
+ If perl wasn't found by the configure script, don't attempt to run the tests
+ but explain something nice why it doesn't.
 
- * Add an option that prevents cURL from overwriting existing local files. When
-   used, and there already is an existing file with the target file name
-   (either -O or -o), a number should be appended (and increased if already
-   existing). So that index.html becomes first index.html.1 and then
-   index.html.2 etc. Jeff Pohlmeyer suggested.
+13.3 more protocols supported
 
- * "curl ftp://site.com/*.txt"
+ Extend the test suite to include more protocols. The telnet could just do ftp
+ or http operations (for which we have test servers).
 
- * The client could be told to use maximum N simultaneous parallel transfers
-   and then just make sure that happens. It should of course not make more
-   than one connection to the same remote host. This would require the client
-   to use the multi interface. http://curl.haxx.se/bug/feature.cgi?id=1558595
+13.4 more platforms supported
 
- * Extending the capabilities of the multipart formposting. How about leaving
-   the ';type=foo' syntax as it is and adding an extra tag (headers) which
-   works like this: curl -F "coolfiles=@fil1.txt;headers=@fil1.hdr" where
-   fil1.hdr contains extra headers like
+ Make the test suite work on more platforms. OpenBSD and Mac OS. Remove
+ fork()s and it should become even more portable.
 
-     Content-Type: text/plain; charset=KOI8-R"
-     Content-Transfer-Encoding: base64
-     X-User-Comment: Please don't use browser specific HTML code
+14. Next SONAME bump
 
-   which should overwrite the program reasonable defaults (plain/text,
-   8bit...) (Idea brough to us by kromJx)
+14.1 http-style HEAD output for ftp
 
- * ability to specify the classic computing suffixes on the range
-   specifications. For example, to download the first 500 Kilobytes of a file,
-   be able to specify the following for the -r option: "-r 0-500K" or for the
-   first 2 Megabytes of a file: "-r 0-2M". (Mark Smith suggested)
+ #undef CURL_FTP_HTTPSTYLE_HEAD in lib/ftp.c to remove the HTTP-style headers
+ from being output in NOBODY requests over ftp
 
- * --data-encode that URL encodes the data before posting
-   http://curl.haxx.se/mail/archive-2003-11/0091.html (Kevin Roth suggested)
+14.2 combine error codes
 
- * Provide a way to make options bound to a specific URL among several on the
-   command line. Possibly by letting ':' separate options between URLs,
-   similar to this:
+ Combine some of the error codes to remove duplicates.  The original
+ numbering should not be changed, and the old identifiers would be
+ macroed to the new ones in an CURL_NO_OLDIES section to help with
+ backward compatibility.
 
-      curl --data foo --url url.com : \
-          --url url2.com : \
-          --url url3.com --data foo3
+ Candidates for removal and their replacements:
 
-   (More details: http://curl.haxx.se/mail/archive-2004-07/0133.html)
+    CURLE_FILE_COULDNT_READ_FILE => CURLE_REMOTE_FILE_NOT_FOUND
+    CURLE_FTP_COULDNT_RETR_FILE => CURLE_REMOTE_FILE_NOT_FOUND
+    CURLE_FTP_COULDNT_USE_REST => CURLE_RANGE_ERROR
+    CURLE_FUNCTION_NOT_FOUND => CURLE_FAILED_INIT
+    CURLE_LDAP_INVALID_URL => CURLE_URL_MALFORMAT
+    CURLE_TFTP_NOSUCHUSER => CURLE_TFTP_ILLEGAL
+    CURLE_TFTP_NOTFOUND => CURLE_REMOTE_FILE_NOT_FOUND
+    CURLE_TFTP_PERM => CURLE_REMOTE_ACCESS_DENIED
 
-   The example would do a POST-GET-POST combination on a single command line.
+14.3 extend CURLOPT_SOCKOPTFUNCTION prototype
 
- BUILD
+ The current prototype only provides 'purpose' that tells what the
+ connection/socket is for, but not any protocol or similar. It makes it hard
+ for applications to differentiate on TCP vs UDP and even HTTP vs FTP and
+ similar.
 
- * Consider extending 'roffit' to produce decent ASCII output, and use that
-   instead of (g)nroff when building src/hugehelp.c
+15. Next major release
 
- TEST SUITE
+15.1 cleanup return codes
 
- * Make our own version of stunnel for simple port forwarding to enable HTTPS
-   and FTP-SSL tests without the stunnel dependency, and it could allow us to
-   provide test tools built with either OpenSSL or GnuTLS
+ curl_easy_cleanup() returns void, but curl_multi_cleanup() returns a
+ CURLMcode. These should be changed to be the same.
 
- * If perl wasn't found by the configure script, don't attempt to run the
-   tests but explain something nice why it doesn't.
+15.2 remove obsolete defines
 
- * Extend the test suite to include more protocols. The telnet could just do
-   ftp or http operations (for which we have test servers).
+ remove obsolete defines from curl/curl.h
 
- * Make the test suite work on more platforms. OpenBSD and Mac OS. Remove
-   fork()s and it should become even more portable.
+15.3 size_t
 
- NEXT soname bump
+ make several functions use size_t instead of int in their APIs
 
- * #undef CURL_FTP_HTTPSTYLE_HEAD in lib/ftp.c to remove the HTTP-style headers
-   from being output in NOBODY requests over ftp
+15.4 remove several functions
 
- * Combine some of the error codes to remove duplicates.  The original
-   numbering should not be changed, and the old identifiers would be
-   macroed to the new ones in an CURL_NO_OLDIES section to help with
-   backward compatibility.
+ remove the following functions from the public API:
 
-   Candidates for removal and their replacements:
+ curl_getenv
 
-      CURLE_FILE_COULDNT_READ_FILE => CURLE_REMOTE_FILE_NOT_FOUND
-      CURLE_FTP_COULDNT_RETR_FILE => CURLE_REMOTE_FILE_NOT_FOUND
-      CURLE_FTP_COULDNT_USE_REST => CURLE_RANGE_ERROR
-      CURLE_FUNCTION_NOT_FOUND => CURLE_FAILED_INIT
-      CURLE_LDAP_INVALID_URL => CURLE_URL_MALFORMAT
-      CURLE_TFTP_NOSUCHUSER => CURLE_TFTP_ILLEGAL
-      CURLE_TFTP_NOTFOUND => CURLE_REMOTE_FILE_NOT_FOUND
-      CURLE_TFTP_PERM => CURLE_REMOTE_ACCESS_DENIED
+ curl_mprintf (and variations)
 
- NEXT MAJOR RELEASE
+ curl_strequal
 
- * curl_easy_cleanup() returns void, but curl_multi_cleanup() returns a
-   CURLMcode. These should be changed to be the same.
+ curl_strnequal
 
- * remove obsolete defines from curl/curl.h
+ They will instead become curlx_ - alternatives. That makes the curl app
+ still capable of building with them from source.
 
- * make several functions use size_t instead of int in their APIs
+15.5 remove CURLOPT_FAILONERROR
 
- * remove the following functions from the public API:
-   curl_getenv
-   curl_mprintf (and variations)
-   curl_strequal
-   curl_strnequal
+ Remove support for CURLOPT_FAILONERROR, it has gotten too kludgy and weird
+ internally. Let the app judge success or not for itself.
 
-   They will instead become curlx_ - alternatives. That makes the curl app
-   still capable of building with them from source.
+15.6 remove CURLOPT_DNS_USE_GLOBAL_CACHE
 
- * Remove support for CURLOPT_FAILONERROR, it has gotten too kludgy and weird
-   internally. Let the app judge success or not for itself.
+ Remove support for a global DNS cache. Anything global is silly, and we
+ already offer the share interface for the same functionality but done
+ "right".
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/curl/curl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/curl/curl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/curl/curl.h	2007-10-22 22:30:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/curl/curl.h	2008-01-10 18:30:20.000000000 +0800
@@ -4,52 +4,90 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curl.h,v 1.331 2007-10-15 18:32:01 patrickm Exp $
+ * $Id: curl.h,v 1.341 2008-01-10 10:30:20 bagder Exp $
  ***************************************************************************/
 
 /* If you have problems, all libcurl docs and details are found here:
    http://curl.haxx.se/libcurl/
 */
 
 #include "curlver.h" /* the libcurl version defines */
 
+/*
+ * Define WIN32 when build target is Win32 API
+ */
+
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
+#define WIN32
+#endif
+
 #include <stdio.h>
 #include <limits.h>
 
 /* The include stuff here below is mainly for time_t! */
 #ifdef vms
 # include <types.h>
 # include <time.h>
 #else
 # include <sys/types.h>
 # include <time.h>
 #endif /* defined (vms) */
 
-typedef void CURL;
+#if defined(WIN32) && !defined(_WIN32_WCE) && !defined(__GNUC__) && \
+  !defined(__CYGWIN__) || defined(__MINGW32__)
+#if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H))
+/* The check above prevents the winsock2 inclusion if winsock.h already was
+   included, since they can't co-exist without problems */
+#include <winsock2.h>
+#include <ws2tcpip.h>
+#endif
+#else
+
+/* HP-UX systems version 9, 10 and 11 lack sys/select.h and so does oldish
+   libc5-based Linux systems. Only include it on system that are known to
+   require it! */
+#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || defined(__minix)
+#include <sys/select.h>
+#endif
+
+#ifndef _WIN32_WCE
+#include <sys/socket.h>
+#endif
+#ifndef __WATCOMC__
+#include <sys/time.h>
+#endif
+#include <sys/types.h>
+#endif
+
+#ifdef __BEOS__
+#include <support/SupportDefs.h>
+#endif
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
+typedef void CURL;
+
 /*
  * Decorate exportable functions for Win32 DLL linking.
  * This avoids using a .def file for building libcurl.dll.
  */
 #if (defined(WIN32) || defined(_WIN32)) && !defined(CURL_STATICLIB)
 #if defined(BUILDING_LIBCURL)
@@ -136,44 +174,12 @@
 
 #ifdef UNDEF_FILESIZEBITS
 /* this was defined above for our checks, undefine it again */
 #undef FILESIZEBITS
 #endif
 
-#if defined(_WIN32) && !defined(WIN32)
-/* Chris Lewis mentioned that he doesn't get WIN32 defined, only _WIN32 so we
-   make this adjustment to catch this. */
-#define WIN32 1
-#endif
-
-#if defined(WIN32) && !defined(_WIN32_WCE) && !defined(__GNUC__) && \
-  !defined(__CYGWIN__) || defined(__MINGW32__)
-#if !(defined(_WINSOCKAPI_) || defined(_WINSOCK_H))
-/* The check above prevents the winsock2 inclusion if winsock.h already was
-   included, since they can't co-exist without problems */
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#endif
-#else
-
-/* HP-UX systems version 9, 10 and 11 lack sys/select.h and so does oldish
-   libc5-based Linux systems. Only include it on system that are known to
-   require it! */
-#if defined(_AIX) || defined(__NOVELL_LIBC__) || defined(__NetBSD__) || defined(__minix)
-#include <sys/select.h>
-#endif
-
-#ifndef _WIN32_WCE
-#include <sys/socket.h>
-#endif
-#ifndef __WATCOMC__
-#include <sys/time.h>
-#endif
-#include <sys/types.h>
-#endif
-
 #ifndef curl_socket_typedef
 /* socket typedef */
 #ifdef WIN32
 typedef SOCKET curl_socket_t;
 #define CURL_SOCKET_BAD INVALID_SOCKET
 #else
@@ -221,21 +227,30 @@
   /* Tests have proven that 20K is a very bad buffer size for uploads on
      Windows, while 16K for some odd reason performed a lot better.
      We do the ifndef check to allow this value to easier be changed at build
      time for those who feel adventurous. */
 #define CURL_MAX_WRITE_SIZE 16384
 #endif
-
+/* This is a magic return code for the write callback that, when returned,
+   will signal libcurl to pause receving on the current transfer. */
+#define CURL_WRITEFUNC_PAUSE 0x10000001
 typedef size_t (*curl_write_callback)(char *buffer,
                                       size_t size,
                                       size_t nitems,
                                       void *outstream);
 
 /* This is a return code for the read callback that, when returned, will
    signal libcurl to immediately abort the current transfer. */
 #define CURL_READFUNC_ABORT 0x10000000
+/* This is a return code for the read callback that, when returned, will
+   signal libcurl to pause sending data on the current transfer. */
+#define CURL_READFUNC_PAUSE 0x10000001
+typedef int (*curl_seek_callback)(void *instream,
+                                  curl_off_t offset,
+				  int origin); /* 'whence' */
+
 typedef size_t (*curl_read_callback)(char *buffer,
                                       size_t size,
                                       size_t nitems,
                                       void *instream);
 
 typedef enum  {
@@ -248,13 +263,15 @@
                                      curlsocktype purpose);
 
 struct curl_sockaddr {
   int family;
   int socktype;
   int protocol;
-  socklen_t addrlen;
+  unsigned int addrlen; /* addrlen was a socklen_t type before 7.18.0 but it
+                           turned really ugly and painful on the systems that
+                           lack this type */
   struct sockaddr addr;
 };
 
 typedef curl_socket_t
 (*curl_opensocket_callback)(void *clientp,
                             curlsocktype purpose,
@@ -484,16 +501,21 @@
 typedef CURLcode (*curl_ssl_ctx_callback)(CURL *curl,    /* easy handle */
                                           void *ssl_ctx, /* actually an
                                                             OpenSSL SSL_CTX */
                                           void *userptr);
 
 typedef enum {
-  CURLPROXY_HTTP = 0,
-  CURLPROXY_SOCKS4 = 4,
-  CURLPROXY_SOCKS5 = 5
-} curl_proxytype;
+  CURLPROXY_HTTP = 0,   /* added in 7.10 */
+  CURLPROXY_SOCKS4 = 4, /* support added in 7.15.2, enum existed already
+                           in 7.10 */
+  CURLPROXY_SOCKS5 = 5, /* added in 7.10 */
+  CURLPROXY_SOCKS4A = 6, /* added in 7.18.0 */
+  CURLPROXY_SOCKS5_HOSTNAME = 7 /* Use the SOCKS5 protocol but pass along the
+                                   host name rather than the IP address. added
+                                   in 7.18.0 */
+} curl_proxytype;  /* this enum was added in 7.10 */
 
 #define CURLAUTH_NONE         0       /* nothing */
 #define CURLAUTH_BASIC        (1<<0)  /* Basic (default) */
 #define CURLAUTH_DIGEST       (1<<1)  /* Digest */
 #define CURLAUTH_GSSNEGOTIATE (1<<2)  /* GSS-Negotiate */
 #define CURLAUTH_NTLM         (1<<3)  /* NTLM */
@@ -932,13 +954,13 @@
   CINIT(NOSIGNAL, LONG, 99),
 
   /* Provide a CURLShare for mutexing non-ts data */
   CINIT(SHARE, OBJECTPOINT, 100),
 
   /* indicates type of proxy. accepted values are CURLPROXY_HTTP (default),
-     CURLPROXY_SOCKS4 and CURLPROXY_SOCKS5. */
+     CURLPROXY_SOCKS4, CURLPROXY_SOCKS4A and CURLPROXY_SOCKS5. */
   CINIT(PROXYTYPE, LONG, 101),
 
   /* Set the Accept-Encoding string. Use this to tell a server you would like
      the response to be compressed. */
   CINIT(ENCODING, OBJECTPOINT, 102),
 
@@ -1156,12 +1178,19 @@
   CINIT(OPENSOCKETFUNCTION, FUNCTIONPOINT, 163),
   CINIT(OPENSOCKETDATA, OBJECTPOINT, 164),
 
   /* POST volatile input fields. */
   CINIT(COPYPOSTFIELDS, OBJECTPOINT, 165),
 
+  /* set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy */
+  CINIT(PROXY_TRANSFER_MODE, LONG, 166),
+
+  /* Callback function for seeking in the input stream */
+  CINIT(SEEKFUNCTION, FUNCTIONPOINT, 167),
+  CINIT(SEEKDATA, OBJECTPOINT, 168),
+
   CURLOPT_LASTENTRY /* the last unused */
 } CURLoption;
 
 #ifndef CURL_NO_OLDIES /* define this to test if your app builds with all
                           the obsolete stuff removed! */
 
@@ -1238,16 +1267,12 @@
   CURL_TIMECOND_IFUNMODSINCE,
   CURL_TIMECOND_LASTMOD,
 
   CURL_TIMECOND_LAST
 } curl_TimeCond;
 
-#ifdef __BEOS__
-#include <support/SupportDefs.h>
-#endif
-
 
 /* curl_strequal() and curl_strnequal() are subject for removal in a future
    libcurl, see lib/README.curlx for details */
 CURL_EXTERN int (curl_strequal)(const char *s1, const char *s2);
 CURL_EXTERN int (curl_strnequal)(const char *s1, const char *s2, size_t n);
 
@@ -1734,12 +1759,32 @@
  * The curl_share_strerror function may be used to turn a CURLSHcode value
  * into the equivalent human readable error string.  This is useful
  * for printing meaningful error messages.
  */
 CURL_EXTERN const char *curl_share_strerror(CURLSHcode);
 
+/*
+ * NAME curl_easy_pause()
+ *
+ * DESCRIPTION
+ *
+ * The curl_easy_pause function pauses or unpauses transfers. Select the new
+ * state by setting the bitmask, use the convenience defines below.
+ *
+ */
+CURL_EXTERN CURLcode curl_easy_pause(CURL *handle, int bitmask);
+
+#define CURLPAUSE_RECV      (1<<0)
+#define CURLPAUSE_RECV_CONT (0)
+
+#define CURLPAUSE_SEND      (1<<2)
+#define CURLPAUSE_SEND_CONT (0)
+
+#define CURLPAUSE_ALL       (CURLPAUSE_RECV|CURLPAUSE_SEND)
+#define CURLPAUSE_CONT      (CURLPAUSE_RECV_CONT|CURLPAUSE_SEND_CONT)
+
 #ifdef  __cplusplus
 }
 #endif
 
 /* unfortunately, the easy.h and multi.h include files need options and info
   stuff before they can be included! */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/curl/curlver.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/curl/curlver.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/curl/curlver.h	2007-10-29 22:49:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/curl/curlver.h	2008-01-29 01:29:23.000000000 +0800
@@ -4,40 +4,43 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curlver.h,v 1.32 2007-09-13 21:06:19 bagder Exp $
+ * $Id: curlver.h,v 1.35 2008-01-24 14:05:56 gknauf Exp $
  ***************************************************************************/
 
 /* This header file contains nothing but libcurl version info, generated by
    a script at release-time. This was made its own header file in 7.11.2 */
 
+/* This is the global package copyright */
+#define LIBCURL_COPYRIGHT "1996 - 2008 Daniel Stenberg, <daniel@haxx.se>."
+
 /* This is the version number of the libcurl package from which this header
    file origins: */
-#define LIBCURL_VERSION "7.17.1"
+#define LIBCURL_VERSION "7.18.0"
 
 /* The numeric version number is also available "in parts" by using these
    defines: */
 #define LIBCURL_VERSION_MAJOR 7
-#define LIBCURL_VERSION_MINOR 17
-#define LIBCURL_VERSION_PATCH 1
+#define LIBCURL_VERSION_MINOR 18
+#define LIBCURL_VERSION_PATCH 0
 
 /* This is the numeric version of the libcurl version number, meant for easier
    parsing and comparions by programs. The LIBCURL_VERSION_NUM define will
    always follow this syntax:
 
          0xXXYYZZ
@@ -48,20 +51,20 @@
    appears as "0x090b07".
 
    This 6-digit (24 bits) hexadecimal number does not show pre-release number,
    and it is always a greater number in a more recent release. It makes
    comparisons with greater than and less than work.
 */
-#define LIBCURL_VERSION_NUM 0x071101
+#define LIBCURL_VERSION_NUM 0x071200
 
 /*
  * This is the date and time when the full source package was created. The
  * timestamp is not stored in CVS, as the timestamp is properly set in the
  * tarballs by the maketgz script.
  *
  * The format of the date should follow this template:
  *
  * "Mon Feb 12 11:35:33 UTC 2007"
  */
-#define LIBCURL_TIMESTAMP "Mon Oct 29 14:49:22 UTC 2007"
+#define LIBCURL_TIMESTAMP "Mon Jan 28 17:28:54 UTC 2008"
 
 #endif /* __CURL_CURLVER_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/curl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/curl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/curl/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/curl/Makefile.in	2008-01-28 19:59:49.000000000 +0800
@@ -148,12 +148,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/include/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/include/Makefile.in	2008-01-28 19:59:49.000000000 +0800
@@ -146,12 +146,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/base64.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/base64.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/base64.c	2007-09-03 05:53:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/base64.c	2007-11-05 17:45:09.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: base64.c,v 1.44 2007-08-30 20:34:57 danf Exp $
+ * $Id: base64.c,v 1.45 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 
 /* Base64 encoding/decoding
  *
  * Test harnesses down the bottom - compile with -DTEST_ENCODE for
  * a program that will read in raw data from stdin and write out
@@ -98,13 +98,13 @@
     if(src[length+equalsTerm] == '=')
       equalsTerm++;
   }
   numQuantums = (length + equalsTerm) / 4;
 
   /* Don't allocate a buffer if the decoded length is 0 */
-  if (numQuantums <= 0)
+  if(numQuantums <= 0)
     return 0;
 
   rawlen = (numQuantums * 3) - equalsTerm;
 
   /* The buffer must be large enough to make room for the last quantum
   (which may be partially thrown out) and the zero terminator. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/config.h.in	2007-10-27 06:26:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/config.h.in	2008-01-28 20:00:15.000000000 +0800
@@ -369,12 +369,15 @@
 /* Define to 1 if you have the `poll' function. */
 #undef HAVE_POLL
 
 /* If you have a fine poll */
 #undef HAVE_POLL_FINE
 
+/* Define to 1 if you have the <poll.h> header file. */
+#undef HAVE_POLL_H
+
 /* we have a POSIX-style strerror_r() */
 #undef HAVE_POSIX_STRERROR_R
 
 /* Define to 1 if you have the <pwd.h> header file. */
 #undef HAVE_PWD_H
 
@@ -690,12 +693,15 @@
 /* The size of `curl_off_t', as computed by sizeof. */
 #undef SIZEOF_CURL_OFF_T
 
 /* The size of `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
+/* The size of `off_t', as computed by sizeof. */
+#undef SIZEOF_OFF_T
+
 /* The size of `size_t', as computed by sizeof. */
 #undef SIZEOF_SIZE_T
 
 /* The size of `time_t', as computed by sizeof. */
 #undef SIZEOF_TIME_T
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/config-win32ce.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/config-win32ce.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/config-win32ce.h	2007-10-25 04:08:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/config-win32ce.h	2007-11-08 05:32:47.000000000 +0800
@@ -305,28 +305,30 @@
 /*                        COMPILER SPECIFIC                         */
 /* ---------------------------------------------------------------- */
 
 /* Undef keyword 'const' if it does not work.  */
 /* #undef const */
 
+/* Define to avoid VS2005 complaining about portable C functions */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#define _CRT_SECURE_NO_DEPRECATE 1
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#endif
+
 /* ---------------------------------------------------------------- */
 /*                           LDAP SUPPORT                           */
 /* ---------------------------------------------------------------- */
 
 #define CURL_LDAP_WIN 1
 #undef CURL_LDAP_HYBRID
 #undef HAVE_LDAP_URL_PARSE
 
 /* ---------------------------------------------------------------- */
 /*                       ADDITIONAL DEFINITIONS                     */
 /* ---------------------------------------------------------------- */
 
-/* Defines set for VS2005 to _not_ deprecate a few functions we use. */
-#define _CRT_SECURE_NO_DEPRECATE 1
-#define _CRT_NONSTDC_NO_DEPRECATE 1
-
 /* Define cpu-machine-OS */
 #undef OS
 #define OS "i386-pc-win32ce"
 
 /* Name of package */
 #define PACKAGE "curl"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/config-win32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/config-win32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/config-win32.h	2007-10-25 04:08:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/config-win32.h	2007-12-20 06:10:42.000000000 +0800
@@ -344,12 +344,32 @@
 
 /* Define if the compiler supports LONGLONG. */
 #if defined(__MINGW32__) || defined(__WATCOMC__)
 #define HAVE_LONGLONG 1
 #endif
 
+/* Define to avoid VS2005 complaining about portable C functions */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#define _CRT_SECURE_NO_DEPRECATE 1
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#endif
+
+/* VS2008 does not support Windows build targets prior to WinXP, */
+/* so, if no build target has been defined we will target WinXP. */
+#if defined(_MSC_VER) && (_MSC_VER >= 1500)
+#  ifndef _WIN32_WINNT
+#    define _WIN32_WINNT 0x0501
+#  endif
+#  ifndef WINVER
+#    define WINVER 0x0501
+#  endif
+#  if (_WIN32_WINNT < 0x0501) || (WINVER < 0x0501)
+#    error VS2008 does not support Windows build targets prior to WinXP
+#  endif
+#endif
+
 /* ---------------------------------------------------------------- */
 /*                           LDAP SUPPORT                           */
 /* ---------------------------------------------------------------- */
 
 #if defined(CURL_HAS_NOVELL_LDAPSDK) || defined(CURL_HAS_MOZILLA_LDAPSDK)
 #undef CURL_LDAP_HYBRID
@@ -367,16 +387,12 @@
 #endif
 
 /* ---------------------------------------------------------------- */
 /*                       ADDITIONAL DEFINITIONS                     */
 /* ---------------------------------------------------------------- */
 
-/* Defines set for VS2005 to _not_ deprecate a few functions we use. */
-#define _CRT_SECURE_NO_DEPRECATE 1
-#define _CRT_NONSTDC_NO_DEPRECATE 1
-
 /* Define cpu-machine-OS */
 #undef OS
 #if defined(_M_IX86) || defined(__i386__) /* x86 (MSVC or gcc) */
 #define OS "i386-pc-win32"
 #elif defined(_M_IA64) /* Itanium */
 #define OS "ia64-pc-win32"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/connect.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/connect.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/connect.c	2007-10-22 22:30:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/connect.c	2008-01-22 07:47:28.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: connect.c,v 1.184 2007-10-17 00:44:48 yangtse Exp $
+ * $Id: connect.c,v 1.186 2008-01-08 01:05:50 yangtse Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef WIN32
 /* headers for non-win32 */
@@ -113,13 +113,13 @@
 #define SETBLOCK 0
 #ifdef HAVE_O_NONBLOCK
   /* most recent unix versions */
   int flags;
 
   flags = fcntl(sockfd, F_GETFL, 0);
-  if (FALSE != nonblock)
+  if(FALSE != nonblock)
     return fcntl(sockfd, F_SETFL, flags | O_NONBLOCK);
   else
     return fcntl(sockfd, F_SETFL, flags & (~O_NONBLOCK));
 #undef SETBLOCK
 #define SETBLOCK 1
 #endif
@@ -162,13 +162,13 @@
 #ifdef HAVE_DISABLED_NONBLOCKING
   return 0; /* returns success */
 #undef SETBLOCK
 #define SETBLOCK 6
 #endif
 
-#if (SETBLOCK == 0)
+#if(SETBLOCK == 0)
 #error "no non-blocking method was found/used/set"
 #endif
 }
 
 /*
  * waitconnect() waits for a TCP connect on the given socket for the specified
@@ -230,13 +230,13 @@
   int portnum = data->set.localportrange;
   const char *dev = data->set.str[STRING_DEVICE];
 
   /*************************************************************
    * Select device to bind socket to
    *************************************************************/
-  if (dev && (strlen(dev)<255) ) {
+  if(dev && (strlen(dev)<255) ) {
     struct Curl_dns_entry *h=NULL;
     char myhost[256] = "";
     in_addr_t in;
     int rc;
     bool was_iface = FALSE;
     int in6 = -1;
@@ -300,17 +300,17 @@
      *
      * This feature allows one to tightly bind the local socket to a
      * particular interface.  This will force even requests to other local
      * interfaces to go out the external interface.
      *
      */
-    if (was_iface) {
+    if(was_iface) {
       /* Only bind to the interface when specified as interface, not just as a
        * hostname or ip address.
        */
-      if (setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
+      if(setsockopt(sockfd, SOL_SOCKET, SO_BINDTODEVICE,
                      dev, strlen(dev)+1) != 0) {
         /* printf("Failed to BINDTODEVICE, socket: %d  device: %s error: %s\n",
            sockfd, dev, Curl_strerror(SOCKERRNO)); */
         infof(data, "SO_BINDTODEVICE %s failed\n", dev);
         /* This is typically "errno 1, error: Operation not permitted" if
            you're not running as root or another suitable privileged user */
@@ -320,18 +320,18 @@
 
     in=inet_addr(myhost);
 
 #ifdef ENABLE_IPV6
     in6 = Curl_inet_pton (AF_INET6, myhost, (void *)&ipv6_addr);
 #endif
-    if (CURL_INADDR_NONE == in && -1 == in6) {
+    if(CURL_INADDR_NONE == in && -1 == in6) {
       failf(data,"couldn't find my own IP address (%s)", myhost);
       return CURLE_INTERFACE_FAILED;
     } /* end of inet_addr */
 
-    if ( h ) {
+    if( h ) {
       Curl_addrinfo *addr = h->addr;
       sock = addr->ai_addr;
       socksize = addr->ai_addrlen;
     }
     else
       return CURLE_INTERFACE_FAILED;
@@ -430,39 +430,39 @@
 #else
   SleepEx(0, FALSE);
 #endif
 
 #endif
 
-  if (0 != getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void *)&err, &errSize))
+  if(0 != getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void *)&err, &errSize))
     err = SOCKERRNO;
 #ifdef _WIN32_WCE
   /* Old WinCE versions don't support SO_ERROR */
-  if (WSAENOPROTOOPT == err) {
+  if(WSAENOPROTOOPT == err) {
     SET_SOCKERRNO(0);
     err = 0;
   }
 #endif
 #ifdef __minix
   /* Minix 3.1.x doesn't support getsockopt on UDP sockets */
-  if (EBADIOCTL == err) {
+  if(EBADIOCTL == err) {
     SET_SOCKERRNO(0);
     err = 0;
   }
 #endif
-  if ((0 == err) || (EISCONN == err))
+  if((0 == err) || (EISCONN == err))
     /* we are connected, awesome! */
     rc = TRUE;
   else
     /* This wasn't a successful connect */
     rc = FALSE;
-  if (error)
+  if(error)
     *error = err;
 #else
   (void)sockfd;
-  if (error)
+  if(error)
     *error = SOCKERRNO;
 #endif
   return rc;
 }
 
 CURLcode Curl_store_ip_addr(struct connectdata *conn)
@@ -501,13 +501,13 @@
   if(sockindex != FIRSTSOCKET)
     return TRUE; /* no next */
 
   /* try the next address */
   ai = conn->ip_addr->ai_next;
 
-  while (ai) {
+  while(ai) {
     sockfd = singleipconnect(conn, ai, 0L, connected);
     if(sockfd != CURL_SOCKET_BAD) {
       /* store the new socket descriptor */
       conn->sock[sockindex] = sockfd;
       conn->ip_addr = ai;
 
@@ -542,13 +542,13 @@
 
   /* Evaluate in milliseconds how much time that has passed */
   has_passed = Curl_tvdiff(Curl_tvnow(), data->progress.t_startsingle);
 
   /* subtract the most strict timeout of the ones */
   if(data->set.timeout && data->set.connecttimeout) {
-    if (data->set.timeout < data->set.connecttimeout)
+    if(data->set.timeout < data->set.connecttimeout)
       allow_total = allow = data->set.timeout;
     else
       allow = data->set.connecttimeout;
   }
   else if(data->set.timeout) {
     allow_total = allow = data->set.timeout;
@@ -573,13 +573,13 @@
 
   /* check for connect without timeout as we want to return immediately */
   rc = waitconnect(sockfd, 0);
 
   if(WAITCONN_CONNECTED == rc) {
     int error;
-    if (verifyconnect(sockfd, &error)) {
+    if(verifyconnect(sockfd, &error)) {
       /* we are connected, awesome! */
       *connected = TRUE;
       return CURLE_OK;
     }
     /* nope, not connected for real */
     data->state.os_errno = error;
@@ -591,13 +591,13 @@
     }
   }
   else if(WAITCONN_TIMEOUT != rc) {
     int error = 0;
 
     /* nope, not connected  */
-    if (WAITCONN_FDSET_ERROR == rc) {
+    if(WAITCONN_FDSET_ERROR == rc) {
       (void)verifyconnect(sockfd, &error);
       data->state.os_errno = error;
       infof(data, "%s\n",Curl_strerror(conn,error));
     }
     else
       infof(data, "Connection failed\n");
@@ -625,13 +625,13 @@
   struct SessionHandle *data= conn->data;
   socklen_t onoff = (socklen_t) data->set.tcp_nodelay;
   int proto = IPPROTO_TCP;
 
 #ifdef HAVE_GETPROTOBYNAME
   struct protoent *pe = getprotobyname("tcp");
-  if (pe)
+  if(pe)
     proto = pe->p_proto;
 #endif
 
   if(setsockopt(sockfd, proto, TCP_NODELAY, (void *)&onoff,
                 sizeof(onoff)) < 0)
     infof(data, "Could not set TCP_NODELAY: %s\n",
@@ -691,22 +691,22 @@
 
   addr->family=ai->ai_family;
   addr->socktype=conn->socktype;
   addr->protocol=ai->ai_protocol;
   addr->addrlen =
     (ai->ai_addrlen < (socklen_t)sizeof(struct Curl_sockaddr_storage)) ?
-     ai->ai_addrlen : (socklen_t)sizeof(struct Curl_sockaddr_storage);
+     (unsigned int)ai->ai_addrlen : sizeof(struct Curl_sockaddr_storage);
   memcpy(&addr->addr, ai->ai_addr, addr->addrlen);
 
   /* If set, use opensocket callback to get the socket */
   if(data->set.fopensocket)
     sockfd = data->set.fopensocket(data->set.opensocket_client,
                                    CURLSOCKTYPE_IPCXN, addr);
   else
     sockfd = socket(addr->family, addr->socktype, addr->protocol);
-  if (sockfd == CURL_SOCKET_BAD)
+  if(sockfd == CURL_SOCKET_BAD)
     return CURL_SOCKET_BAD;
 
   *connected = FALSE; /* default is not connected */
 
   /* FIXME: do we have Curl_printable_address-like with struct sockaddr* as
      argument? */
@@ -725,13 +725,13 @@
 
   if(data->set.fsockopt) {
     /* activate callback for setting socket options */
     error = data->set.fsockopt(data->set.sockopt_client,
                                sockfd,
                                CURLSOCKTYPE_IPCXN);
-    if (error) {
+    if(error) {
       sclose(sockfd); /* close the socket and bail out */
       return CURL_SOCKET_BAD;
     }
   }
 
   /* possibly bind the local end to an IP, interface or port */
@@ -833,36 +833,36 @@
   long timeout_per_addr;
 
   *connected = FALSE; /* default to not connected */
 
   /* if a timeout is set, use the most restrictive one */
 
-  if (data->set.timeout > 0)
+  if(data->set.timeout > 0)
     timeout_set += 1;
-  if (data->set.connecttimeout > 0)
+  if(data->set.connecttimeout > 0)
     timeout_set += 2;
 
   switch (timeout_set) {
   case 1:
     timeout_ms = data->set.timeout;
     break;
   case 2:
     timeout_ms = data->set.connecttimeout;
     break;
   case 3:
-    if (data->set.timeout < data->set.connecttimeout)
+    if(data->set.timeout < data->set.connecttimeout)
       timeout_ms = data->set.timeout;
     else
       timeout_ms = data->set.connecttimeout;
     break;
   default:
     timeout_ms = DEFAULT_CONNECT_TIMEOUT;
     break;
   }
 
-  if (timeout_set > 0) {
+  if(timeout_set > 0) {
     /* if a timeout was already set, substract elapsed time */
     timeout_ms -= Curl_tvdiff(before, data->progress.t_startsingle);
     if(timeout_ms < 0) {
       /* a precaution, no need to continue if time already is up */
       failf(data, "Connection time-out");
       return CURLE_OPERATION_TIMEDOUT;
@@ -903,13 +903,13 @@
       failf(data, "connect() timed out!");
       return CURLE_OPERATION_TIMEDOUT;
     }
     before = after;
   }  /* end of connect-to-each-address loop */
 
-  if (sockfd == CURL_SOCKET_BAD) {
+  if(sockfd == CURL_SOCKET_BAD) {
     /* no good connect was made */
     *sockconn = CURL_SOCKET_BAD;
     failf(data, "couldn't connect to host");
     return CURLE_COULDNT_CONNECT;
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/content_encoding.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/content_encoding.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/content_encoding.c	2007-08-09 04:55:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/content_encoding.c	2007-11-25 07:16:55.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: content_encoding.c,v 1.25 2007-08-08 17:51:40 danf Exp $
+ * $Id: content_encoding.c,v 1.27 2007-11-24 23:16:55 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifdef HAVE_LIBZ
 
@@ -54,13 +54,13 @@
 #define RESERVED     0xE0 /* bits 5..7: reserved */
 
 static CURLcode
 process_zlib_error(struct connectdata *conn, z_stream *z)
 {
   struct SessionHandle *data = conn->data;
-  if (z->msg)
+  if(z->msg)
     failf (data, "Error while processing content unencoding: %s",
            z->msg);
   else
     failf (data, "Error while processing content unencoding: "
            "Unknown failure within decompression software.");
 
@@ -74,70 +74,70 @@
   *zlib_init = ZLIB_UNINIT;
   return result;
 }
 
 static CURLcode
 inflate_stream(struct connectdata *conn,
-               struct Curl_transfer_keeper *k)
+               struct SingleRequest *k)
 {
   int allow_restart = 1;
   z_stream *z = &k->z;          /* zlib state structure */
   uInt nread = z->avail_in;
   Bytef *orig_in = z->next_in;
   int status;                   /* zlib status */
   CURLcode result = CURLE_OK;   /* Curl_client_write status */
   char *decomp;                 /* Put the decompressed data here. */
 
   /* Dynamically allocate a buffer for decompression because it's uncommonly
      large to hold on the stack */
   decomp = (char*)malloc(DSIZ);
-  if (decomp == NULL) {
+  if(decomp == NULL) {
     return exit_zlib(z, &k->zlib_init, CURLE_OUT_OF_MEMORY);
   }
 
   /* because the buffer size is fixed, iteratively decompress and transfer to
      the client via client_write. */
   for (;;) {
     /* (re)set buffer for decompressed output for every iteration */
     z->next_out = (Bytef *)decomp;
     z->avail_out = DSIZ;
 
     status = inflate(z, Z_SYNC_FLUSH);
-    if (status == Z_OK || status == Z_STREAM_END) {
+    if(status == Z_OK || status == Z_STREAM_END) {
       allow_restart = 0;
       if(DSIZ - z->avail_out) {
         result = Curl_client_write(conn, CLIENTWRITE_BODY, decomp,
                                    DSIZ - z->avail_out);
         /* if !CURLE_OK, clean up, return */
-        if (result) {
+        if(result) {
           free(decomp);
           return exit_zlib(z, &k->zlib_init, result);
         }
       }
 
       /* Done? clean up, return */
-      if (status == Z_STREAM_END) {
+      if(status == Z_STREAM_END) {
         free(decomp);
-        if (inflateEnd(z) == Z_OK)
+        if(inflateEnd(z) == Z_OK)
           return exit_zlib(z, &k->zlib_init, result);
         else
           return exit_zlib(z, &k->zlib_init, process_zlib_error(conn, z));
       }
 
       /* Done with these bytes, exit */
-      if (status == Z_OK && z->avail_in == 0) {
+      if(status == Z_OK && z->avail_in == 0) {
         free(decomp);
         return result;
       }
     }
-    else if (allow_restart && status == Z_DATA_ERROR) {
+    else if(allow_restart && status == Z_DATA_ERROR) {
       /* some servers seem to not generate zlib headers, so this is an attempt
          to fix and continue anyway */
 
       (void) inflateEnd(z);	/* don't care about the return code */
-      if (inflateInit2(z, -MAX_WBITS) != Z_OK) {
+      if(inflateInit2(z, -MAX_WBITS) != Z_OK) {
         return process_zlib_error(conn, z);
       }
       z->next_in = orig_in;
       z->avail_in = nread;
       allow_restart = 0;
       continue;
@@ -149,25 +149,25 @@
   }
   /* Will never get here */
 }
 
 CURLcode
 Curl_unencode_deflate_write(struct connectdata *conn,
-                            struct Curl_transfer_keeper *k,
+                            struct SingleRequest *k,
                             ssize_t nread)
 {
   z_stream *z = &k->z;          /* zlib state structure */
 
   /* Initialize zlib? */
-  if (k->zlib_init == ZLIB_UNINIT) {
+  if(k->zlib_init == ZLIB_UNINIT) {
     z->zalloc = (alloc_func)Z_NULL;
     z->zfree = (free_func)Z_NULL;
     z->opaque = 0;
     z->next_in = NULL;
     z->avail_in = 0;
-    if (inflateInit(z) != Z_OK)
+    if(inflateInit(z) != Z_OK)
       return process_zlib_error(conn, z);
     k->zlib_init = ZLIB_INIT;
   }
 
   /* Set the compressed input when this function is called */
   z->next_in = (Bytef *)k->str;
@@ -186,75 +186,75 @@
 } check_gzip_header(unsigned char const *data, ssize_t len, ssize_t *headerlen)
 {
   int method, flags;
   const ssize_t totallen = len;
 
   /* The shortest header is 10 bytes */
-  if (len < 10)
+  if(len < 10)
     return GZIP_UNDERFLOW;
 
-  if ((data[0] != GZIP_MAGIC_0) || (data[1] != GZIP_MAGIC_1))
+  if((data[0] != GZIP_MAGIC_0) || (data[1] != GZIP_MAGIC_1))
     return GZIP_BAD;
 
   method = data[2];
   flags = data[3];
 
-  if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
+  if(method != Z_DEFLATED || (flags & RESERVED) != 0) {
     /* Can't handle this compression method or unknown flag */
     return GZIP_BAD;
   }
 
   /* Skip over time, xflags, OS code and all previous bytes */
   len -= 10;
   data += 10;
 
-  if (flags & EXTRA_FIELD) {
+  if(flags & EXTRA_FIELD) {
     ssize_t extra_len;
 
-    if (len < 2)
+    if(len < 2)
       return GZIP_UNDERFLOW;
 
     extra_len = (data[1] << 8) | data[0];
 
-    if (len < (extra_len+2))
+    if(len < (extra_len+2))
       return GZIP_UNDERFLOW;
 
     len -= (extra_len + 2);
     data += (extra_len + 2);
   }
 
-  if (flags & ORIG_NAME) {
+  if(flags & ORIG_NAME) {
     /* Skip over NUL-terminated file name */
-    while (len && *data) {
+    while(len && *data) {
       --len;
       ++data;
     }
-    if (!len || *data)
+    if(!len || *data)
       return GZIP_UNDERFLOW;
 
     /* Skip over the NUL */
     --len;
     ++data;
   }
 
-  if (flags & COMMENT) {
+  if(flags & COMMENT) {
     /* Skip over NUL-terminated comment */
-    while (len && *data) {
+    while(len && *data) {
       --len;
       ++data;
     }
-    if (!len || *data)
+    if(!len || *data)
       return GZIP_UNDERFLOW;
 
     /* Skip over the NUL */
     --len;
     ++data;
   }
 
-  if (flags & HEAD_CRC) {
-    if (len < 2)
+  if(flags & HEAD_CRC) {
+    if(len < 2)
       return GZIP_UNDERFLOW;
 
     len -= 2;
     data += 2;
   }
 
@@ -262,42 +262,42 @@
   return GZIP_OK;
 }
 #endif
 
 CURLcode
 Curl_unencode_gzip_write(struct connectdata *conn,
-                         struct Curl_transfer_keeper *k,
+                         struct SingleRequest *k,
                          ssize_t nread)
 {
   z_stream *z = &k->z;          /* zlib state structure */
 
   /* Initialize zlib? */
-  if (k->zlib_init == ZLIB_UNINIT) {
+  if(k->zlib_init == ZLIB_UNINIT) {
     z->zalloc = (alloc_func)Z_NULL;
     z->zfree = (free_func)Z_NULL;
     z->opaque = 0;
     z->next_in = NULL;
     z->avail_in = 0;
 
-    if (strcmp(zlibVersion(), "1.2.0.4") >= 0) {
+    if(strcmp(zlibVersion(), "1.2.0.4") >= 0) {
         /* zlib ver. >= 1.2.0.4 supports transparent gzip decompressing */
-        if (inflateInit2(z, MAX_WBITS+32) != Z_OK) {
+        if(inflateInit2(z, MAX_WBITS+32) != Z_OK) {
           return process_zlib_error(conn, z);
         }
         k->zlib_init = ZLIB_INIT_GZIP; /* Transparent gzip decompress state */
 
     } else {
         /* we must parse the gzip header ourselves */
-        if (inflateInit2(z, -MAX_WBITS) != Z_OK) {
+        if(inflateInit2(z, -MAX_WBITS) != Z_OK) {
           return process_zlib_error(conn, z);
         }
         k->zlib_init = ZLIB_INIT;   /* Initial call state */
     }
   }
 
-  if (k->zlib_init == ZLIB_INIT_GZIP) {
+  if(k->zlib_init == ZLIB_INIT_GZIP) {
      /* Let zlib handle the gzip decompression entirely */
      z->next_in = (Bytef *)k->str;
      z->avail_in = (uInt)nread;
      /* Now uncompress the data */
      return inflate_stream(conn, k);
   }
@@ -339,13 +339,13 @@
        * that circumstances will be right for this code path to be followed in
        * the first place, and it's even more unlikely for a transfer to fail
        * immediately afterwards, it should seldom be a problem.
        */
       z->avail_in = (uInt)nread;
       z->next_in = malloc(z->avail_in);
-      if (z->next_in == NULL) {
+      if(z->next_in == NULL) {
         return exit_zlib(z, &k->zlib_init, CURLE_OUT_OF_MEMORY);
       }
       memcpy(z->next_in, k->str, z->avail_in);
       k->zlib_init = ZLIB_GZIP_HEADER;   /* Need more gzip header data state */
       /* We don't have any data to inflate yet */
       return CURLE_OK;
@@ -363,13 +363,13 @@
     /* Need more gzip header data state */
     ssize_t hlen;
     unsigned char *oldblock = z->next_in;
 
     z->avail_in += nread;
     z->next_in = realloc(z->next_in, z->avail_in);
-    if (z->next_in == NULL) {
+    if(z->next_in == NULL) {
       free(oldblock);
       return exit_zlib(z, &k->zlib_init, CURLE_OUT_OF_MEMORY);
     }
     /* Append the new block of data to the previous one */
     memcpy(z->next_in + z->avail_in - nread, k->str, nread);
 
@@ -401,13 +401,13 @@
     /* Inflating stream state */
     z->next_in = (Bytef *)k->str;
     z->avail_in = (uInt)nread;
     break;
   }
 
-  if (z->avail_in == 0) {
+  if(z->avail_in == 0) {
     /* We don't have any data to inflate; wait until next time */
     return CURLE_OK;
   }
 
   /* We've parsed the header, now uncompress the data */
   return inflate_stream(conn, k);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/content_encoding.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/content_encoding.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/content_encoding.h	2006-08-20 05:18:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/content_encoding.h	2007-11-25 07:16:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: content_encoding.h,v 1.9 2006-08-19 21:18:37 bagder Exp $
+ * $Id: content_encoding.h,v 1.10 2007-11-24 23:16:55 bagder Exp $
  ***************************************************************************/
 #include "setup.h"
 
 /*
  * Comma-separated list all supported Content-Encodings ('identity' is implied)
  */
@@ -29,13 +29,13 @@
 #define ALL_CONTENT_ENCODINGS "deflate, gzip"
 #else
 #define ALL_CONTENT_ENCODINGS "identity"
 #endif
 
 CURLcode Curl_unencode_deflate_write(struct connectdata *conn,
-                                     struct Curl_transfer_keeper *k,
+                                     struct SingleRequest *req,
                                      ssize_t nread);
 
 CURLcode
 Curl_unencode_gzip_write(struct connectdata *conn,
-                         struct Curl_transfer_keeper *k,
+                         struct SingleRequest *k,
                          ssize_t nread);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/cookie.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/cookie.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/cookie.c	2007-09-03 05:53:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/cookie.c	2008-01-24 06:22:12.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: cookie.c,v 1.84 2007-08-29 05:36:53 danf Exp $
+ * $Id: cookie.c,v 1.86 2008-01-23 22:22:12 bagder Exp $
  ***************************************************************************/
 
 /***
 
 
 RECEIVING COOKIE INFORMATION
@@ -480,13 +480,13 @@
         co->tailmatch=(bool)strequal(ptr, "TRUE"); /* store information */
         break;
       case 2:
         /* It turns out, that sometimes the file format allows the path
            field to remain not filled in, we try to detect this and work
            around it! Andrs Garca made us aware of this... */
-        if (strcmp("TRUE", ptr) && strcmp("FALSE", ptr)) {
+        if(strcmp("TRUE", ptr) && strcmp("FALSE", ptr)) {
           /* only if the path doesn't look like a boolean option! */
           co->path = strdup(ptr);
           if(!co->path)
             badcookie = TRUE;
           break;
         }
@@ -809,34 +809,40 @@
  * Clear all existing cookies and reset the counter.
  *
  ****************************************************************************/
 void Curl_cookie_clearall(struct CookieInfo *cookies)
 {
   if(cookies) {
-    Curl_cookie_freelist(cookies->cookies);
+    Curl_cookie_freelist(cookies->cookies, TRUE);
     cookies->cookies = NULL;
     cookies->numcookies = 0;
   }
 }
 
 /*****************************************************************************
  *
  * Curl_cookie_freelist()
  *
  * Free a list of cookies previously returned by Curl_cookie_getlist();
  *
+ * The 'cookiestoo' argument tells this function whether to just free the
+ * list or actually also free all cookies within the list as well.
+ *
  ****************************************************************************/
 
-void Curl_cookie_freelist(struct Cookie *co)
+void Curl_cookie_freelist(struct Cookie *co, bool cookiestoo)
 {
   struct Cookie *next;
   if(co) {
     while(co) {
       next = co->next;
-      free(co); /* we only free the struct since the "members" are all
-                      just copied! */
+      if(cookiestoo)
+        freecookie(co);
+      else
+        free(co); /* we only free the struct since the "members" are all just
+                     pointed out in the main cookie list! */
       co = next;
     }
   }
 }
 
 
@@ -864,13 +870,13 @@
 
       if(prev == curr)
         prev = next;
       else
         prev->next = next;
 
-      free(curr);
+      freecookie(curr);
       cookies->numcookies--;
     }
     else
       prev = curr;
   }
 
@@ -969,13 +975,13 @@
           "# This file was generated by libcurl! Edit at your own risk.\n\n",
           out);
     co = c->cookies;
 
     while(co) {
       format_ptr = get_netscape_format(co);
-      if (format_ptr == NULL) {
+      if(format_ptr == NULL) {
         fprintf(out, "#\n# Fatal libcurl error\n");
         fclose(out);
         return 1;
       }
       fprintf(out, "%s\n", format_ptr);
       free(format_ptr);
@@ -993,33 +999,33 @@
 {
   struct curl_slist *list = NULL;
   struct curl_slist *beg;
   struct Cookie *c;
   char *line;
 
-  if ((data->cookies == NULL) ||
+  if((data->cookies == NULL) ||
       (data->cookies->numcookies == 0))
     return NULL;
 
   c = data->cookies->cookies;
 
   beg = list;
-  while (c) {
+  while(c) {
     /* fill the list with _all_ the cookies we know */
     line = get_netscape_format(c);
-    if (line == NULL) {
+    if(line == NULL) {
       curl_slist_free_all(beg);
       return NULL;
     }
     list = curl_slist_append(list, line);
     free(line);
-    if (list == NULL) {
+    if(list == NULL) {
       curl_slist_free_all(beg);
       return NULL;
     }
-    else if (beg == NULL) {
+    else if(beg == NULL) {
       beg = list;
     }
     c = c->next;
   }
 
   return list;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/cookie.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/cookie.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/cookie.h	2007-09-03 05:53:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/cookie.h	2008-01-24 06:22:12.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: cookie.h,v 1.25 2007-08-29 05:36:53 danf Exp $
+ * $Id: cookie.h,v 1.26 2008-01-23 22:22:12 bagder Exp $
  ***************************************************************************/
 
 #include <stdio.h>
 #if defined(WIN32)
 #include <time.h>
 #else
@@ -88,13 +88,13 @@
                                const char *domain, const char *path);
 
 struct CookieInfo *Curl_cookie_init(struct SessionHandle *data,
                                     const char *, struct CookieInfo *, bool);
 struct Cookie *Curl_cookie_getlist(struct CookieInfo *, const char *,
 		                   const char *, bool);
-void Curl_cookie_freelist(struct Cookie *);
+void Curl_cookie_freelist(struct Cookie *cookies, bool cookiestoo);
 void Curl_cookie_clearall(struct CookieInfo *cookies);
 void Curl_cookie_clearsess(struct CookieInfo *cookies);
 void Curl_cookie_cleanup(struct CookieInfo *);
 int Curl_cookie_output(struct CookieInfo *, const char *);
 
 #if defined(CURL_DISABLE_HTTP) || defined(CURL_DISABLE_COOKIES)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/dict.c	2007-10-22 22:30:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/dict.c	2007-12-09 07:03:52.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: dict.c,v 1.52 2007-10-17 16:58:32 yangtse Exp $
+ * $Id: dict.c,v 1.55 2007-12-08 22:50:55 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_DICT
 
@@ -84,22 +84,22 @@
 
 
 /*
  * Forward declarations.
  */
 
-static CURLcode Curl_dict(struct connectdata *conn, bool *done);
+static CURLcode dict_do(struct connectdata *conn, bool *done);
 
 /*
  * DICT protocol handler.
  */
 
 const struct Curl_handler Curl_handler_dict = {
   "DICT",                               /* scheme */
   ZERO_NULL,                            /* setup_connection */
-  Curl_dict,                            /* do_it */
+  dict_do,                              /* do_it */
   ZERO_NULL,                            /* done */
   ZERO_NULL,                            /* do_more */
   ZERO_NULL,                            /* connect_it */
   ZERO_NULL,                            /* connecting */
   ZERO_NULL,                            /* doing */
   ZERO_NULL,                            /* proto_getsock */
@@ -126,76 +126,76 @@
   if(dictp) {
     /* According to RFC2229 section 2.2, these letters need to be escaped with
        \[letter] */
     for(ptr = newp;
         (byte = *ptr) != 0;
         ptr++) {
-      if ((byte <= 32) || (byte == 127) ||
+      if((byte <= 32) || (byte == 127) ||
           (byte == '\'') || (byte == '\"') || (byte == '\\')) {
         dictp[olen++] = '\\';
       }
       dictp[olen++] = byte;
     }
     dictp[olen]=0;
 
     free(newp);
   }
   return dictp;
 }
 
-static CURLcode Curl_dict(struct connectdata *conn, bool *done)
+static CURLcode dict_do(struct connectdata *conn, bool *done)
 {
   char *word;
   char *eword;
   char *ppath;
   char *database = NULL;
   char *strategy = NULL;
   char *nthdef = NULL; /* This is not part of the protocol, but required
                           by RFC 2229 */
   CURLcode result=CURLE_OK;
   struct SessionHandle *data=conn->data;
   curl_socket_t sockfd = conn->sock[FIRSTSOCKET];
 
-  char *path = data->reqdata.path;
-  curl_off_t *bytecount = &data->reqdata.keep.bytecount;
+  char *path = data->state.path;
+  curl_off_t *bytecount = &data->req.bytecount;
 
   *done = TRUE; /* unconditionally */
 
   if(conn->bits.user_passwd) {
     /* AUTH is missing */
   }
 
-  if (strnequal(path, DICT_MATCH, sizeof(DICT_MATCH)-1) ||
+  if(strnequal(path, DICT_MATCH, sizeof(DICT_MATCH)-1) ||
       strnequal(path, DICT_MATCH2, sizeof(DICT_MATCH2)-1) ||
       strnequal(path, DICT_MATCH3, sizeof(DICT_MATCH3)-1)) {
 
     word = strchr(path, ':');
-    if (word) {
+    if(word) {
       word++;
       database = strchr(word, ':');
-      if (database) {
+      if(database) {
         *database++ = (char)0;
         strategy = strchr(database, ':');
-        if (strategy) {
+        if(strategy) {
           *strategy++ = (char)0;
           nthdef = strchr(strategy, ':');
-          if (nthdef) {
+          if(nthdef) {
             *nthdef++ = (char)0;
           }
         }
       }
     }
 
-    if ((word == NULL) || (*word == (char)0)) {
+    if((word == NULL) || (*word == (char)0)) {
       infof(data, "lookup word is missing");
       word=(char *)"default";
     }
-    if ((database == NULL) || (*database == (char)0)) {
+    if((database == NULL) || (*database == (char)0)) {
       database = (char *)"!";
     }
-    if ((strategy == NULL) || (*strategy == (char)0)) {
+    if((strategy == NULL) || (*strategy == (char)0)) {
       strategy = (char *)".";
     }
 
     eword = unescape_word(data, word);
     if(!eword)
       return CURLE_OUT_OF_MEMORY;
@@ -220,34 +220,34 @@
     else
       result = Curl_setup_transfer(conn, FIRSTSOCKET, -1, FALSE, bytecount,
                                    -1, NULL); /* no upload */
     if(result)
       return result;
   }
-  else if (strnequal(path, DICT_DEFINE, sizeof(DICT_DEFINE)-1) ||
+  else if(strnequal(path, DICT_DEFINE, sizeof(DICT_DEFINE)-1) ||
            strnequal(path, DICT_DEFINE2, sizeof(DICT_DEFINE2)-1) ||
            strnequal(path, DICT_DEFINE3, sizeof(DICT_DEFINE3)-1)) {
 
     word = strchr(path, ':');
-    if (word) {
+    if(word) {
       word++;
       database = strchr(word, ':');
-      if (database) {
+      if(database) {
         *database++ = (char)0;
         nthdef = strchr(database, ':');
-        if (nthdef) {
+        if(nthdef) {
           *nthdef++ = (char)0;
         }
       }
     }
 
-    if ((word == NULL) || (*word == (char)0)) {
+    if((word == NULL) || (*word == (char)0)) {
       infof(data, "lookup word is missing");
       word=(char *)"default";
     }
-    if ((database == NULL) || (*database == (char)0)) {
+    if((database == NULL) || (*database == (char)0)) {
       database = (char *)"!";
     }
 
     eword = unescape_word(data, word);
     if(!eword)
       return CURLE_OUT_OF_MEMORY;
@@ -273,18 +273,18 @@
       return result;
 
   }
   else {
 
     ppath = strchr(path, '/');
-    if (ppath) {
+    if(ppath) {
       int i;
 
       ppath++;
       for (i = 0; ppath[i]; i++) {
-        if (ppath[i] == ':')
+        if(ppath[i] == ':')
           ppath[i] = ' ';
       }
       result = Curl_sendf(sockfd, conn,
                           "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\r\n"
                           "%s\r\n"
                           "QUIT\r\n", ppath);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/easy.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/easy.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/easy.c	2007-10-22 22:43:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/easy.c	2008-01-16 06:44:26.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: easy.c,v 1.108 2007-08-26 05:53:26 danf Exp $
+ * $Id: easy.c,v 1.113 2008-01-15 22:44:12 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -124,24 +124,24 @@
 #endif
 
   wVersionRequested = MAKEWORD(USE_WINSOCK, USE_WINSOCK);
 
   err = WSAStartup(wVersionRequested, &wsaData);
 
-  if (err != 0)
+  if(err != 0)
     /* Tell the user that we couldn't find a useable */
     /* winsock.dll.     */
     return CURLE_FAILED_INIT;
 
   /* Confirm that the Windows Sockets DLL supports what we need.*/
   /* Note that if the DLL supports versions greater */
   /* than wVersionRequested, it will still return */
   /* wVersionRequested in wVersion. wHighVersion contains the */
   /* highest supported version. */
 
-  if ( LOBYTE( wsaData.wVersion ) != LOBYTE(wVersionRequested) ||
+  if( LOBYTE( wsaData.wVersion ) != LOBYTE(wVersionRequested) ||
        HIBYTE( wsaData.wVersion ) != HIBYTE(wVersionRequested) ) {
     /* Tell the user that we couldn't find a useable */
 
     /* winsock.dll. */
     WSACleanup();
     return CURLE_FAILED_INIT;
@@ -165,13 +165,13 @@
 static void idna_init (void)
 {
 #ifdef WIN32
   char buf[60];
   UINT cp = GetACP();
 
-  if (!getenv("CHARSET") && cp > 0) {
+  if(!getenv("CHARSET") && cp > 0) {
     snprintf(buf, sizeof(buf), "CHARSET=cp%u", cp);
     putenv(buf);
   }
 #else
   /* to do? */
 #endif
@@ -209,30 +209,30 @@
 /**
  * curl_global_init() globally initializes cURL given a bitwise set of the
  * different features of what to initialize.
  */
 CURLcode curl_global_init(long flags)
 {
-  if (initialized++)
+  if(initialized++)
     return CURLE_OK;
 
   /* Setup the default memory functions here (again) */
   Curl_cmalloc = (curl_malloc_callback)malloc;
   Curl_cfree = (curl_free_callback)free;
   Curl_crealloc = (curl_realloc_callback)realloc;
   Curl_cstrdup = (curl_strdup_callback)system_strdup;
   Curl_ccalloc = (curl_calloc_callback)calloc;
 
-  if (flags & CURL_GLOBAL_SSL)
-    if (!Curl_ssl_init()) {
+  if(flags & CURL_GLOBAL_SSL)
+    if(!Curl_ssl_init()) {
       DEBUGF(fprintf(stderr, "Error: Curl_ssl_init failed\n"));
       return CURLE_FAILED_INIT;
     }
 
-  if (flags & CURL_GLOBAL_WIN32)
-    if (win32_init() != CURLE_OK) {
+  if(flags & CURL_GLOBAL_WIN32)
+    if(win32_init() != CURLE_OK) {
       DEBUGF(fprintf(stderr, "Error: win32_init failed\n"));
       return CURLE_FAILED_INIT;
     }
 
 #ifdef __AMIGA__
   if(!amiga_init()) {
@@ -264,22 +264,22 @@
                               curl_free_callback f, curl_realloc_callback r,
                               curl_strdup_callback s, curl_calloc_callback c)
 {
   CURLcode code = CURLE_OK;
 
   /* Invalid input, return immediately */
-  if (!m || !f || !r || !s || !c)
+  if(!m || !f || !r || !s || !c)
     return CURLE_FAILED_INIT;
 
   /* Already initialized, don't do it again */
-  if ( initialized )
+  if( initialized )
     return CURLE_OK;
 
   /* Call the actual init function first */
   code = curl_global_init(flags);
-  if (code == CURLE_OK) {
+  if(code == CURLE_OK) {
     Curl_cmalloc = m;
     Curl_cfree = f;
     Curl_cstrdup = s;
     Curl_crealloc = r;
     Curl_ccalloc = c;
   }
@@ -290,24 +290,24 @@
 /**
  * curl_global_cleanup() globally cleanups cURL, uses the value of
  * "init_flags" to determine what needs to be cleaned up and what doesn't.
  */
 void curl_global_cleanup(void)
 {
-  if (!initialized)
+  if(!initialized)
     return;
 
-  if (--initialized)
+  if(--initialized)
     return;
 
   Curl_global_host_cache_dtor();
 
-  if (init_flags & CURL_GLOBAL_SSL)
+  if(init_flags & CURL_GLOBAL_SSL)
     Curl_ssl_cleanup();
 
-  if (init_flags & CURL_GLOBAL_WIN32)
+  if(init_flags & CURL_GLOBAL_WIN32)
     win32_cleanup();
 
 #ifdef __AMIGA__
   amiga_cleanup();
 #endif
 
@@ -321,13 +321,13 @@
 CURL *curl_easy_init(void)
 {
   CURLcode res;
   struct SessionHandle *data;
 
   /* Make sure we inited the global SSL stuff */
-  if (!initialized) {
+  if(!initialized) {
     res = curl_global_init(CURL_GLOBAL_DEFAULT);
     if(res) {
       /* something in the global init failed, return nothing */
       DEBUGF(fprintf(stderr, "Error: curl_global_init failed\n"));
       return NULL;
     }
@@ -462,23 +462,33 @@
 {
   struct SessionHandle *data = (struct SessionHandle *)curl;
 
   if(!data)
     return CURLE_BAD_FUNCTION_ARGUMENT;
 
-  if ( ! (data->share && data->share->hostcache) ) {
+  if( ! (data->share && data->share->hostcache) ) {
+    /* this handle is not using a shared dns cache */
 
-    if (Curl_global_host_cache_use(data) &&
-        (data->dns.hostcachetype != HCACHE_GLOBAL)) {
-      if (data->dns.hostcachetype == HCACHE_PRIVATE)
+    if(data->set.global_dns_cache &&
+       (data->dns.hostcachetype != HCACHE_GLOBAL)) {
+      /* global dns cache was requested but still isn't */
+      struct curl_hash *ptr;
+
+      if(data->dns.hostcachetype == HCACHE_PRIVATE)
+        /* if the current cache is private, kill it first */
         Curl_hash_destroy(data->dns.hostcache);
-      data->dns.hostcache = Curl_global_host_cache_get();
-      data->dns.hostcachetype = HCACHE_GLOBAL;
+
+      ptr = Curl_global_host_cache_init();
+      if(ptr) {
+        /* only do this if the global cache init works */
+        data->dns.hostcache = ptr;
+        data->dns.hostcachetype = HCACHE_GLOBAL;
+      }
     }
 
-    if (!data->dns.hostcache) {
+    if(!data->dns.hostcache) {
       data->dns.hostcachetype = HCACHE_PRIVATE;
       data->dns.hostcache = Curl_mk_dnscache();
 
       if(!data->dns.hostcache)
         /* While we possibly could survive and do good without a host cache,
            the fact that creating it failed indicates that things are truly
@@ -517,23 +527,23 @@
  * Store a pointed to the multi handle within the easy handle's data struct.
  */
 void Curl_easy_addmulti(struct SessionHandle *data,
                         void *multi)
 {
   data->multi = multi;
-  if (multi == NULL)
+  if(multi == NULL)
     /* the association is cleared, mark the easy handle as not used by an
        interface */
     data->state.used_interface = Curl_if_none;
 }
 
 void Curl_easy_initHandleData(struct SessionHandle *data)
 {
-    memset(&data->reqdata, 0, sizeof(struct HandleData));
+    memset(&data->req, 0, sizeof(struct SingleRequest));
 
-    data->reqdata.maxdownload = -1;
+    data->req.maxdownload = -1;
 }
 
 /*
  * curl_easy_getinfo() is an external interface that allows an app to retrieve
  * information from a performed transfer and similar.
  */
@@ -576,13 +586,13 @@
     if(!outcurl->state.headerbuff) {
       break;
     }
     outcurl->state.headersize=HEADERSIZE;
 
     /* copy all userdefined values */
-    if (Curl_dupset(outcurl, data) != CURLE_OK)
+    if(Curl_dupset(outcurl, data) != CURLE_OK)
       break;
 
     if(data->state.used_interface == Curl_if_multi)
       outcurl->state.connc = data->state.connc;
     else
       outcurl->state.connc = Curl_mk_connc(CONNCACHE_PRIVATE, -1);
@@ -597,15 +607,15 @@
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
     if(data->cookies) {
       /* If cookies are enabled in the parent handle, we enable them
          in the clone as well! */
       outcurl->cookies = Curl_cookie_init(data,
-                                            data->cookies->filename,
-                                            outcurl->cookies,
-                                            data->set.cookiesession);
+                                          data->cookies->filename,
+                                          outcurl->cookies,
+                                          data->set.cookiesession);
       if(!outcurl->cookies) {
         break;
       }
     }
 #endif   /* CURL_DISABLE_HTTP */
 
@@ -673,17 +683,17 @@
  * initialize a session handle to the default values.
  */
 void curl_easy_reset(CURL *curl)
 {
   struct SessionHandle *data = (struct SessionHandle *)curl;
 
-  Curl_safefree(data->reqdata.pathbuffer);
-  data->reqdata.pathbuffer=NULL;
+  Curl_safefree(data->state.pathbuffer);
+  data->state.pathbuffer=NULL;
 
-  Curl_safefree(data->reqdata.proto.generic);
-  data->reqdata.proto.generic=NULL;
+  Curl_safefree(data->state.proto.generic);
+  data->state.proto.generic=NULL;
 
   /* zero out UserDefined data: */
   Curl_freeset(data);
   memset(&data->set, 0, sizeof(struct UserDefined));
 
   /* zero out Progress data: */
@@ -741,12 +751,113 @@
   data->set.ssh_auth_types = CURLSSH_AUTH_DEFAULT; /* defaults to any auth
                                                       type */
   data->set.new_file_perms = 0644;    /* Default permissions */
   data->set.new_directory_perms = 0755; /* Default permissions */
 }
 
+/*
+ * curl_easy_pause() allows an application to pause or unpause a specific
+ * transfer and direction. This function sets the full new state for the
+ * current connection this easy handle operates on.
+ *
+ * NOTE: if you have the receiving paused and you call this function to remove
+ * the pausing, you may get your write callback called at this point.
+ *
+ * Action is a bitmask consisting of CURLPAUSE_* bits in curl/curl.h
+ */
+CURLcode curl_easy_pause(CURL *curl, int action)
+{
+  struct SessionHandle *data = (struct SessionHandle *)curl;
+  struct SingleRequest *k = &data->req;
+  CURLcode result = CURLE_OK;
+
+  /* first switch off both pause bits */
+  int newstate = k->keepon &~ (KEEP_READ_PAUSE| KEEP_WRITE_PAUSE);
+
+  /* set the new desired pause bits */
+  newstate |= ((action & CURLPAUSE_RECV)?KEEP_READ_PAUSE:0) |
+    ((action & CURLPAUSE_SEND)?KEEP_WRITE_PAUSE:0);
+
+  /* put it back in the keepon */
+  k->keepon = newstate;
+
+  if(!(newstate & KEEP_READ_PAUSE) && data->state.tempwrite) {
+    /* we have a buffer for writing that we now seem to be able to deliver since
+       the receive pausing is lifted! */
+
+    /* get the pointer, type and length in local copies since the function may
+       return PAUSE again and then we'll get a new copy allocted and stored in
+       the tempwrite variables */
+    char *tempwrite = data->state.tempwrite;
+    size_t tempsize = data->state.tempwritesize;
+    int temptype = data->state.tempwritetype;
+    size_t chunklen;
+
+    /* clear tempwrite here just to make sure it gets cleared if there's no
+       further use of it, and make sure we don't clear it after the function
+       invoke as it may have been set to a new value by then */
+    data->state.tempwrite = NULL;
+
+    /* since the write callback API is define to never exceed
+       CURL_MAX_WRITE_SIZE bytes in a single call, and since we may in fact
+       have more data than that in our buffer here, we must loop sending the
+       data in multiple calls until there's no data left or we get another
+       pause returned.
+
+       A tricky part is that the function we call will "buffer" the data
+       itself when it pauses on a particular buffer, so we may need to do some
+       extra trickery if we get a pause return here.
+    */
+    do {
+      chunklen = (tempsize > CURL_MAX_WRITE_SIZE)?CURL_MAX_WRITE_SIZE:tempsize;
+
+      result = Curl_client_write(data->state.current_conn,
+                                 temptype, tempwrite, chunklen);
+      if(!result)
+        /* failures abort the loop at once */
+        break;
+
+      if(data->state.tempwrite && (tempsize - chunklen)) {
+        /* Ouch, the reading is again paused and the block we send is now
+           "cached". If this is the final chunk we can leave it like this, but
+           if we have more chunks that is cached after this, we need to free
+           the newly cached one and put back a version that is truly the entire
+           contents that is saved for later
+        */
+        char *newptr;
+
+        free(data->state.tempwrite); /* free the one just cached as it isn't
+                                        enough */
+
+        /* note that tempsize is still the size as before the callback was
+           used, and thus the whole piece of data to keep */
+        newptr = malloc(tempsize);
+        if(!newptr) {
+          result = CURLE_OUT_OF_MEMORY;
+          /* tempwrite will be freed further down */
+          break;
+        }
+        data->state.tempwrite = newptr; /* store new pointer */
+        memcpy(newptr, tempwrite, tempsize);
+        data->state.tempwritesize = tempsize; /* store new size */
+        /* tempwrite will be freed further down */
+        break; /* go back to pausing until further notice */
+      }
+      else {
+        tempsize -= chunklen;  /* left after the call above */
+        tempwrite += chunklen; /* advance the pointer */
+      }
+
+    } while((result == CURLE_OK) && tempsize);
+
+    free(tempwrite); /* this is unconditionally no longer used */
+  }
+
+  return result;
+}
+
 #ifdef CURL_DOES_CONVERSIONS
 /*
  * Curl_convert_to_network() is an internal function
  * for performing ASCII conversions on non-ASCII platforms.
  */
 CURLcode Curl_convert_to_network(struct SessionHandle *data,
@@ -786,13 +897,13 @@
     }
     /* call iconv */
     input_ptr = output_ptr = buffer;
     in_bytes = out_bytes = length;
     rc = iconv(data->outbound_cd, (const char**)&input_ptr, &in_bytes,
                &output_ptr, &out_bytes);
-    if ((rc == ICONV_ERROR) || (in_bytes != 0)) {
+    if((rc == ICONV_ERROR) || (in_bytes != 0)) {
       error = ERRNO;
       failf(data,
         "The Curl_convert_to_network iconv call failed with errno %i: %s",
              error, strerror(error));
       return CURLE_CONV_FAILED;
     }
@@ -846,13 +957,13 @@
     }
     /* call iconv */
     input_ptr = output_ptr = buffer;
     in_bytes = out_bytes = length;
     rc = iconv(data->inbound_cd, (const char **)&input_ptr, &in_bytes,
                &output_ptr, &out_bytes);
-    if ((rc == ICONV_ERROR) || (in_bytes != 0)) {
+    if((rc == ICONV_ERROR) || (in_bytes != 0)) {
       error = ERRNO;
       failf(data,
         "The Curl_convert_from_network iconv call failed with errno %i: %s",
              error, strerror(error));
       return CURLE_CONV_FAILED;
     }
@@ -907,20 +1018,20 @@
     }
     /* call iconv */
     input_ptr = output_ptr = buffer;
     in_bytes = out_bytes = length;
     rc = iconv(data->utf8_cd, &input_ptr, &in_bytes,
                &output_ptr, &out_bytes);
-    if ((rc == ICONV_ERROR) || (in_bytes != 0)) {
+    if((rc == ICONV_ERROR) || (in_bytes != 0)) {
       error = ERRNO;
       failf(data,
         "The Curl_convert_from_utf8 iconv call failed with errno %i: %s",
              error, strerror(error));
       return CURLE_CONV_FAILED;
     }
-    if (output_ptr < input_ptr) {
+    if(output_ptr < input_ptr) {
       /* null terminate the now shorter output string */
       *output_ptr = 0x00;
     }
 #else
     failf(data, "CURLOPT_CONV_FROM_UTF8_FUNCTION callback required");
     return CURLE_CONV_REQD;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/escape.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/escape.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/escape.c	2007-10-01 07:01:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/escape.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: escape.c,v 1.41 2007-09-30 22:40:24 bagder Exp $
+ * $Id: escape.c,v 1.42 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 /* Escape and unescape URL encoding in strings. The functions return a new
  * allocated string or NULL if an error occurred.  */
 
 #include "setup.h"
@@ -109,13 +109,13 @@
           ns = testing_ptr;
         }
       }
 
 #ifdef CURL_DOES_CONVERSIONS
 /* escape sequences are always in ASCII so convert them on non-ASCII hosts */
-      if (!handle ||
+      if(!handle ||
           (Curl_convert_to_network(handle, &in, 1) != CURLE_OK)) {
         /* Curl_convert_to_network calls failf if unsuccessful */
         free(ns);
         return NULL;
       }
 #endif /* CURL_DOES_CONVERSIONS */
@@ -160,13 +160,13 @@
       hex = strtol(hexstr, &ptr, 16);
 
       in = (unsigned char)hex; /* this long is never bigger than 255 anyway */
 
 #ifdef CURL_DOES_CONVERSIONS
 /* escape sequences are always in ASCII so convert them on non-ASCII hosts */
-      if (!handle ||
+      if(!handle ||
           (Curl_convert_from_network(handle, &in, 1) != CURLE_OK)) {
         /* Curl_convert_from_network calls failf if unsuccessful */
         free(ns);
         return NULL;
       }
 #endif /* CURL_DOES_CONVERSIONS */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/file.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/file.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/file.c	2007-10-24 04:02:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/file.c	2008-01-12 05:59:57.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.c,v 1.98 2007-10-23 15:16:46 yangtse Exp $
+ * $Id: file.c,v 1.105 2008-01-11 16:49:35 yangtse Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_FILE
 /* -- WIN32 approved -- */
@@ -67,12 +67,13 @@
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #endif
 
+#include "strtoofft.h"
 #include "urldata.h"
 #include <curl/curl.h>
 #include "progress.h"
 #include "sendf.h"
 #include "escape.h"
 #include "file.h"
@@ -91,45 +92,101 @@
 
 
 /*
  * Forward declarations.
  */
 
-static CURLcode Curl_file(struct connectdata *, bool *done);
-static CURLcode Curl_file_done(struct connectdata *conn,
-                               CURLcode status, bool premature);
+static CURLcode file_do(struct connectdata *, bool *done);
+static CURLcode file_done(struct connectdata *conn,
+                          CURLcode status, bool premature);
+static CURLcode file_connect(struct connectdata *conn, bool *done);
 
 /*
  * FILE scheme handler.
  */
 
 const struct Curl_handler Curl_handler_file = {
   "FILE",                               /* scheme */
   ZERO_NULL,                            /* setup_connection */
-  Curl_file,                            /* do_it */
-  Curl_file_done,                       /* done */
+  file_do,                              /* do_it */
+  file_done,                            /* done */
   ZERO_NULL,                            /* do_more */
-  ZERO_NULL,                            /* connect_it */
+  file_connect,                         /* connect_it */
   ZERO_NULL,                            /* connecting */
   ZERO_NULL,                            /* doing */
   ZERO_NULL,                            /* proto_getsock */
   ZERO_NULL,                            /* doing_getsock */
   ZERO_NULL,                            /* disconnect */
   0,                                    /* defport */
   PROT_FILE                             /* protocol */
 };
 
+
+ /*
+  Check if this is a range download, and if so, set the internal variables
+  properly. This code is copied from the FTP implementation and might as
+  well be factored out.
+ */
+static CURLcode file_range(struct connectdata *conn)
+{
+  curl_off_t from, to;
+  curl_off_t totalsize=-1;
+  char *ptr;
+  char *ptr2;
+  struct SessionHandle *data = conn->data;
+
+  if(data->state.use_range && data->state.range) {
+    from=curlx_strtoofft(data->state.range, &ptr, 0);
+    while(ptr && *ptr && (isspace((int)*ptr) || (*ptr=='-')))
+      ptr++;
+    to=curlx_strtoofft(ptr, &ptr2, 0);
+    if(ptr == ptr2) {
+      /* we didn't get any digit */
+      to=-1;
+    }
+    if((-1 == to) && (from>=0)) {
+      /* X - */
+      data->state.resume_from = from;
+      DEBUGF(infof(data, "RANGE %" FORMAT_OFF_T " to end of file\n",
+                   from));
+    }
+    else if(from < 0) {
+      /* -Y */
+      totalsize = -from;
+      data->req.maxdownload = -from;
+      data->state.resume_from = from;
+      DEBUGF(infof(data, "RANGE the last %" FORMAT_OFF_T " bytes\n",
+                   totalsize));
+    }
+    else {
+      /* X-Y */
+      totalsize = to-from;
+      data->req.maxdownload = totalsize+1; /* include last byte */
+      data->state.resume_from = from;
+      DEBUGF(infof(data, "RANGE from %" FORMAT_OFF_T
+                   " getting %" FORMAT_OFF_T " bytes\n",
+                   from, data->req.maxdownload));
+    }
+    DEBUGF(infof(data, "range-download from %" FORMAT_OFF_T
+                 " to %" FORMAT_OFF_T ", totally %" FORMAT_OFF_T " bytes\n",
+                 from, to, data->req.maxdownload));
+  }
+  else
+    data->req.maxdownload = -1;
+  return CURLE_OK;
+}
+
 /*
- * Curl_file_connect() gets called from Curl_protocol_connect() to allow us to
+ * file_connect() gets called from Curl_protocol_connect() to allow us to
  * do protocol-specific actions at connect-time.  We emulate a
  * connect-then-transfer protocol and "connect" to the file here
  */
-CURLcode Curl_file_connect(struct connectdata *conn)
+static CURLcode file_connect(struct connectdata *conn, bool *done)
 {
   struct SessionHandle *data = conn->data;
-  char *real_path = curl_easy_unescape(data, data->reqdata.path, 0, NULL);
+  char *real_path = curl_easy_unescape(data, data->state.path, 0, NULL);
   struct FILEPROTO *file;
   int fd;
 #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
   int i;
   char *actual_path;
 #endif
@@ -138,23 +195,23 @@
     return CURLE_OUT_OF_MEMORY;
 
   /* If there already is a protocol-specific struct allocated for this
      sessionhandle, deal with it */
   Curl_reset_reqproto(conn);
 
-  if (!data->reqdata.proto.file) {
+  if(!data->state.proto.file) {
     file = (struct FILEPROTO *)calloc(sizeof(struct FILEPROTO), 1);
     if(!file) {
       free(real_path);
       return CURLE_OUT_OF_MEMORY;
     }
-    data->reqdata.proto.file = file;
+    data->state.proto.file = file;
   }
   else {
     /* file is not a protocol that can deal with "persistancy" */
-    file = data->reqdata.proto.file;
+    file = data->state.proto.file;
     Curl_safefree(file->freepath);
     if(file->fd != -1)
       close(file->fd);
     file->path = NULL;
     file->freepath = NULL;
     file->fd = -1;
@@ -173,69 +230,67 @@
 
      On other platforms, we need the slash to indicate an
      absolute pathname.  On Windows, absolute paths start
      with a drive letter.
   */
   actual_path = real_path;
-  if ((actual_path[0] == '/') &&
+  if((actual_path[0] == '/') &&
       actual_path[1] &&
       (actual_path[2] == ':' || actual_path[2] == '|'))
   {
     actual_path[2] = ':';
     actual_path++;
   }
 
   /* change path separators from '/' to '\\' for DOS, Windows and OS/2 */
   for (i=0; actual_path[i] != '\0'; ++i)
-    if (actual_path[i] == '/')
+    if(actual_path[i] == '/')
       actual_path[i] = '\\';
 
   fd = open(actual_path, O_RDONLY | O_BINARY);  /* no CR/LF translation! */
   file->path = actual_path;
 #else
   fd = open(real_path, O_RDONLY);
   file->path = real_path;
 #endif
   file->freepath = real_path; /* free this when done */
 
   file->fd = fd;
   if(!data->set.upload && (fd == -1)) {
-    failf(data, "Couldn't open file %s", data->reqdata.path);
-    Curl_file_done(conn, CURLE_FILE_COULDNT_READ_FILE, FALSE);
+    failf(data, "Couldn't open file %s", data->state.path);
+    file_done(conn, CURLE_FILE_COULDNT_READ_FILE, FALSE);
     return CURLE_FILE_COULDNT_READ_FILE;
   }
+  *done = TRUE;
 
   return CURLE_OK;
 }
 
-static CURLcode Curl_file_done(struct connectdata *conn,
+static CURLcode file_done(struct connectdata *conn,
                                CURLcode status, bool premature)
 {
-  struct FILEPROTO *file = conn->data->reqdata.proto.file;
+  struct FILEPROTO *file = conn->data->state.proto.file;
   (void)status; /* not used */
   (void)premature; /* not used */
   Curl_safefree(file->freepath);
 
   if(file->fd != -1)
     close(file->fd);
 
-  free(file);
-  conn->data->reqdata.proto.file= NULL; /* clear it! */
-
   return CURLE_OK;
 }
 
 #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
 #define DIRSEP '\\'
 #else
 #define DIRSEP '/'
 #endif
 
 static CURLcode file_upload(struct connectdata *conn)
 {
-  struct FILEPROTO *file = conn->data->reqdata.proto.file;
+  struct FILEPROTO *file = conn->data->state.proto.file;
   const char *dir = strchr(file->path, DIRSEP);
   FILE *fp;
   CURLcode res=CURLE_OK;
   struct SessionHandle *data = conn->data;
   char *buf = data->state.buffer;
   size_t nread;
@@ -248,33 +303,33 @@
   /*
    * Since FILE: doesn't do the full init, we need to provide some extra
    * assignments here.
    */
   conn->fread_func = data->set.fread_func;
   conn->fread_in = data->set.in;
-  conn->data->reqdata.upload_fromhere = buf;
+  conn->data->req.upload_fromhere = buf;
 
   if(!dir)
     return CURLE_FILE_COULDNT_READ_FILE; /* fix: better error code */
 
   if(!dir[1])
      return CURLE_FILE_COULDNT_READ_FILE; /* fix: better error code */
 
-  if(data->reqdata.resume_from)
+  if(data->state.resume_from)
     fp = fopen( file->path, "ab" );
   else {
     int fd;
 
 #if defined(WIN32) || defined(MSDOS) || defined(__EMX__)
     fd = open(file->path, O_WRONLY|O_CREAT|O_TRUNC|O_BINARY,
               conn->data->set.new_file_perms);
 #else /* !(WIN32 || MSDOS || __EMX__) */
     fd = open(file->path, O_WRONLY|O_CREAT|O_TRUNC,
               conn->data->set.new_file_perms);
 #endif /* !(WIN32 || MSDOS || __EMX__) */
-    if (fd < 0) {
+    if(fd < 0) {
       failf(data, "Can't open %s for writing", file->path);
       return CURLE_WRITE_ERROR;
     }
     fp = fdopen(fd, "wb");
   }
 
@@ -285,44 +340,44 @@
 
   if(-1 != data->set.infilesize)
     /* known size of data to "upload" */
     Curl_pgrsSetUploadSize(data, data->set.infilesize);
 
   /* treat the negative resume offset value as the case of "-" */
-  if(data->reqdata.resume_from < 0){
-    if(stat(file->path, &file_stat)){
+  if(data->state.resume_from < 0) {
+    if(stat(file->path, &file_stat)) {
       fclose(fp);
       failf(data, "Can't get the size of %s", file->path);
       return CURLE_WRITE_ERROR;
     }
     else
-      data->reqdata.resume_from = (curl_off_t)file_stat.st_size;
+      data->state.resume_from = (curl_off_t)file_stat.st_size;
   }
 
-  while (res == CURLE_OK) {
+  while(res == CURLE_OK) {
     int readcount;
     res = Curl_fillreadbuffer(conn, BUFSIZE, &readcount);
     if(res)
       break;
 
-    if (readcount <= 0)  /* fix questionable compare error. curlvms */
+    if(readcount <= 0)  /* fix questionable compare error. curlvms */
       break;
 
     nread = (size_t)readcount;
 
     /*skip bytes before resume point*/
-    if(data->reqdata.resume_from) {
-      if( (curl_off_t)nread <= data->reqdata.resume_from ) {
-        data->reqdata.resume_from -= nread;
+    if(data->state.resume_from) {
+      if( (curl_off_t)nread <= data->state.resume_from ) {
+        data->state.resume_from -= nread;
         nread = 0;
         buf2 = buf;
       }
       else {
-        buf2 = buf + data->reqdata.resume_from;
-        nread -= data->reqdata.resume_from;
-        data->reqdata.resume_from = 0;
+        buf2 = buf + data->state.resume_from;
+        nread -= (size_t)data->state.resume_from;
+        data->state.resume_from = 0;
       }
     }
     else
       buf2 = buf;
 
     /* write the data to the target */
@@ -347,20 +402,20 @@
   fclose(fp);
 
   return res;
 }
 
 /*
- * Curl_file() is the protocol-specific function for the do-phase, separated
+ * file_do() is the protocol-specific function for the do-phase, separated
  * from the connect-phase above. Other protocols merely setup the transfer in
  * the do-phase, to have it done in the main transfer loop but since some
  * platforms we support don't allow select()ing etc on file handles (as
  * opposed to sockets) we instead perform the whole do-operation in this
  * function.
  */
-static CURLcode Curl_file(struct connectdata *conn, bool *done)
+static CURLcode file_do(struct connectdata *conn, bool *done)
 {
   /* This implementation ignores the host name in conformance with
      RFC 1738. Only local files (reachable via the standard file system)
      are supported. This means that files on remotely mounted directories
      (via NFS, Samba, NT sharing) can be accessed through a file:// URL
   */
@@ -368,29 +423,29 @@
   struct_stat statbuf; /* struct_stat instead of struct stat just to allow the
                           Windows version to have a different struct without
                           having to redefine the simple word 'stat' */
   curl_off_t expected_size=0;
   bool fstated=FALSE;
   ssize_t nread;
+  size_t bytestoread;
   struct SessionHandle *data = conn->data;
   char *buf = data->state.buffer;
   curl_off_t bytecount = 0;
   int fd;
   struct timeval now = Curl_tvnow();
 
   *done = TRUE; /* unconditionally */
 
-  Curl_readwrite_init(conn);
   Curl_initinfo(data);
   Curl_pgrsStartNow(data);
 
   if(data->set.upload)
     return file_upload(conn);
 
   /* get the fd from the connection phase */
-  fd = conn->data->reqdata.proto.file->fd;
+  fd = conn->data->state.proto.file->fd;
 
   /* VMS: This only works reliable for STREAMLF files */
   if( -1 != fstat(fd, &statbuf)) {
     /* we could stat it, then read out the size */
     expected_size = statbuf.st_size;
     fstated = TRUE;
@@ -433,47 +488,68 @@
                tm->tm_sec);
       result = Curl_client_write(conn, CLIENTWRITE_BOTH, buf, 0);
     }
     return result;
   }
 
-  if (data->reqdata.resume_from <= expected_size)
-    expected_size -= data->reqdata.resume_from;
+  /* Check whether file range has been specified */
+  file_range(conn);
+
+  /* Adjust the start offset in case we want to get the N last bytes
+   * of the stream iff the filesize could be determined */
+  if(data->state.resume_from < 0) {
+    if(!fstated) {
+      failf(data, "Can't get the size of file.");
+      return CURLE_READ_ERROR;
+    }
+    else
+      data->state.resume_from += (curl_off_t)statbuf.st_size;
+  }
+
+  if(data->state.resume_from <= expected_size)
+    expected_size -= data->state.resume_from;
   else {
     failf(data, "failed to resume file:// transfer");
     return CURLE_BAD_DOWNLOAD_RESUME;
   }
 
-  if (fstated && (expected_size == 0))
+  /* A high water mark has been specified so we obey... */
+  if (data->req.maxdownload > 0)
+    expected_size = data->req.maxdownload;
+
+  if(fstated && (expected_size == 0))
     return CURLE_OK;
 
   /* The following is a shortcut implementation of file reading
      this is both more efficient than the former call to download() and
      it avoids problems with select() and recv() on file descriptors
      in Winsock */
   if(fstated)
     Curl_pgrsSetDownloadSize(data, expected_size);
 
-  if(data->reqdata.resume_from) {
-    if(data->reqdata.resume_from !=
-       lseek(fd, data->reqdata.resume_from, SEEK_SET))
+  if(data->state.resume_from) {
+    if(data->state.resume_from !=
+       lseek(fd, data->state.resume_from, SEEK_SET))
       return CURLE_BAD_DOWNLOAD_RESUME;
   }
 
   Curl_pgrsTime(data, TIMER_STARTTRANSFER);
 
-  while (res == CURLE_OK) {
-    nread = read(fd, buf, BUFSIZE-1);
+  while(res == CURLE_OK) {
+    /* Don't fill a whole buffer if we want less than all data */
+    bytestoread = (expected_size < BUFSIZE-1)?(size_t)expected_size:BUFSIZE-1;
+    nread = read(fd, buf, bytestoread);
 
-    if ( nread > 0)
+    if( nread > 0)
       buf[nread] = 0;
 
-    if (nread <= 0)
+    if (nread <= 0 || expected_size == 0)
       break;
 
     bytecount += nread;
+    expected_size -= nread;
 
     res = Curl_client_write(conn, CLIENTWRITE_BODY, buf, nread);
     if(res)
       return res;
 
     Curl_pgrsSetDownloadCounter(data, bytecount);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/file.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/file.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/file.h	2007-10-22 22:30:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/file.h	2007-10-31 18:11:58.000000000 +0800
@@ -18,14 +18,12 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.h,v 1.16 2007-10-13 00:47:53 danf Exp $
+ * $Id: file.h,v 1.17 2007-10-30 23:00:40 danf Exp $
  ***************************************************************************/
 #ifndef CURL_DISABLE_FILE
 extern const struct Curl_handler Curl_handler_file;
-
-CURLcode Curl_file_connect(struct connectdata *);
 #endif
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/formdata.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/formdata.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/formdata.c	2007-09-27 19:38:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/formdata.c	2007-11-05 17:45:09.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: formdata.c,v 1.102 2007-09-27 01:45:23 danf Exp $
+ * $Id: formdata.c,v 1.103 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 
 /*
   Debug the form generator stand-alone by compiling this source file with:
 
   gcc -DHAVE_CONFIG_H -I../ -g -D_FORM_DEBUG -DCURLDEBUG -o formdata \
@@ -184,13 +184,13 @@
     post->showfilename = showfilename;
     post->flags = flags;
   }
   else
     return NULL;
 
-  if (parent_post) {
+  if(parent_post) {
     /* now, point our 'more' to the original 'more' */
     post->more = parent_post->more;
 
     /* then move the original 'more' to point to ourselves */
     parent_post->more = post;
   }
@@ -221,22 +221,22 @@
                               FormInfo *parent_form_info)
 {
   FormInfo *form_info;
   form_info = (FormInfo *)malloc(sizeof(FormInfo));
   if(form_info) {
     memset(form_info, 0, sizeof(FormInfo));
-    if (value)
+    if(value)
       form_info->value = value;
-    if (contenttype)
+    if(contenttype)
       form_info->contenttype = contenttype;
     form_info->flags = HTTPPOST_FILENAME;
   }
   else
     return NULL;
 
-  if (parent_form_info) {
+  if(parent_form_info) {
     /* now, point our 'more' to the original 'more' */
     form_info->more = parent_form_info->more;
 
     /* then move the original 'more' to point to ourselves */
     parent_form_info->more = form_info;
   }
@@ -313,30 +313,30 @@
 static char *memdup(const char *src, size_t buffer_length)
 {
   size_t length;
   bool add = FALSE;
   char *buffer;
 
-  if (buffer_length)
+  if(buffer_length)
     length = buffer_length;
   else if(src) {
     length = strlen(src);
     add = TRUE;
   }
   else
     /* no length and a NULL src pointer! */
     return strdup((char *)"");
 
   buffer = (char*)malloc(length+add);
-  if (!buffer)
+  if(!buffer)
     return NULL; /* fail */
 
   memcpy(buffer, src, length);
 
   /* if length unknown do null termination */
-  if (add)
+  if(add)
     buffer[length] = '\0';
 
   return buffer;
 }
 
 /***************************************************************************
@@ -415,42 +415,42 @@
 
   current_form = first_form;
 
   /*
    * Loop through all the options set. Break if we have an error to report.
    */
-  while (return_value == CURL_FORMADD_OK) {
+  while(return_value == CURL_FORMADD_OK) {
 
     /* first see if we have more parts of the array param */
-    if ( array_state ) {
+    if( array_state ) {
       /* get the upcoming option from the given array */
       option = forms->option;
       array_value = (char *)forms->value;
 
       forms++; /* advance this to next entry */
-      if (CURLFORM_END == option) {
+      if(CURLFORM_END == option) {
         /* end of array state */
         array_state = FALSE;
         continue;
       }
     }
     else {
       /* This is not array-state, get next option */
       option = va_arg(params, CURLformoption);
-      if (CURLFORM_END == option)
+      if(CURLFORM_END == option)
         break;
     }
 
     switch (option) {
     case CURLFORM_ARRAY:
       if(array_state)
         /* we don't support an array from within an array */
         return_value = CURL_FORMADD_ILLEGAL_ARRAY;
       else {
         forms = va_arg(params, struct curl_forms *);
-        if (forms)
+        if(forms)
           array_state = TRUE;
         else
           return_value = CURL_FORMADD_NULL;
       }
       break;
 
@@ -462,64 +462,64 @@
       /* treat CURLFORM_PTR like CURLFORM_COPYNAME so we'll
          have safe memory for the eventual conversion */
 #else
       current_form->flags |= HTTPPOST_PTRNAME; /* fall through */
 #endif
     case CURLFORM_COPYNAME:
-      if (current_form->name)
+      if(current_form->name)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else {
         char *name = array_state?
           array_value:va_arg(params, char *);
-        if (name)
+        if(name)
           current_form->name = name; /* store for the moment */
         else
           return_value = CURL_FORMADD_NULL;
       }
       break;
     case CURLFORM_NAMELENGTH:
-      if (current_form->namelength)
+      if(current_form->namelength)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else
         current_form->namelength =
           array_state?(size_t)array_value:(size_t)va_arg(params, long);
       break;
 
       /*
        * Set the contents property.
        */
     case CURLFORM_PTRCONTENTS:
       current_form->flags |= HTTPPOST_PTRCONTENTS; /* fall through */
     case CURLFORM_COPYCONTENTS:
-      if (current_form->value)
+      if(current_form->value)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else {
         char *value =
           array_state?array_value:va_arg(params, char *);
-        if (value)
+        if(value)
           current_form->value = value; /* store for the moment */
         else
           return_value = CURL_FORMADD_NULL;
       }
       break;
     case CURLFORM_CONTENTSLENGTH:
-      if (current_form->contentslength)
+      if(current_form->contentslength)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else
         current_form->contentslength =
           array_state?(size_t)array_value:(size_t)va_arg(params, long);
       break;
 
       /* Get contents from a given file name */
     case CURLFORM_FILECONTENT:
-      if (current_form->flags != 0)
+      if(current_form->flags != 0)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else {
         const char *filename = array_state?
           array_value:va_arg(params, char *);
-        if (filename) {
+        if(filename) {
           current_form->value = strdup(filename);
           if(!current_form->value)
             return_value = CURL_FORMADD_MEMORY;
           else {
             current_form->flags |= HTTPPOST_READFILE;
             current_form->value_alloc = TRUE;
@@ -533,27 +533,27 @@
       /* We upload a file */
     case CURLFORM_FILE:
       {
         const char *filename = array_state?array_value:
           va_arg(params, char *);
 
-        if (current_form->value) {
-          if (current_form->flags & HTTPPOST_FILENAME) {
-            if (filename) {
-              if ((current_form = AddFormInfo(strdup(filename),
+        if(current_form->value) {
+          if(current_form->flags & HTTPPOST_FILENAME) {
+            if(filename) {
+              if((current_form = AddFormInfo(strdup(filename),
                                               NULL, current_form)) == NULL)
                 return_value = CURL_FORMADD_MEMORY;
             }
             else
               return_value = CURL_FORMADD_NULL;
           }
           else
             return_value = CURL_FORMADD_OPTION_TWICE;
         }
         else {
-          if (filename) {
+          if(filename) {
             current_form->value = strdup(filename);
             if(!current_form->value)
               return_value = CURL_FORMADD_MEMORY;
             else {
               current_form->flags |= HTTPPOST_FILENAME;
               current_form->value_alloc = TRUE;
@@ -567,27 +567,27 @@
 
     case CURLFORM_BUFFER:
       {
         const char *filename = array_state?array_value:
           va_arg(params, char *);
 
-        if (current_form->value) {
-          if (current_form->flags & HTTPPOST_BUFFER) {
-            if (filename) {
-              if ((current_form = AddFormInfo(strdup(filename),
+        if(current_form->value) {
+          if(current_form->flags & HTTPPOST_BUFFER) {
+            if(filename) {
+              if((current_form = AddFormInfo(strdup(filename),
                                               NULL, current_form)) == NULL)
                 return_value = CURL_FORMADD_MEMORY;
             }
             else
               return_value = CURL_FORMADD_NULL;
           }
           else
             return_value = CURL_FORMADD_OPTION_TWICE;
         }
         else {
-          if (filename) {
+          if(filename) {
             current_form->value = strdup(filename);
             if(!current_form->value)
               return_value = CURL_FORMADD_MEMORY;
           }
           else
             return_value = CURL_FORMADD_NULL;
@@ -595,52 +595,52 @@
         }
         break;
       }
 
     case CURLFORM_BUFFERPTR:
         current_form->flags |= HTTPPOST_PTRBUFFER;
-      if (current_form->buffer)
+      if(current_form->buffer)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else {
         char *buffer =
           array_state?array_value:va_arg(params, char *);
-        if (buffer)
+        if(buffer)
           current_form->buffer = buffer; /* store for the moment */
         else
           return_value = CURL_FORMADD_NULL;
       }
       break;
 
     case CURLFORM_BUFFERLENGTH:
-      if (current_form->bufferlength)
+      if(current_form->bufferlength)
         return_value = CURL_FORMADD_OPTION_TWICE;
       else
         current_form->bufferlength =
           array_state?(size_t)array_value:(size_t)va_arg(params, long);
       break;
 
     case CURLFORM_CONTENTTYPE:
       {
         const char *contenttype =
           array_state?array_value:va_arg(params, char *);
-        if (current_form->contenttype) {
-          if (current_form->flags & HTTPPOST_FILENAME) {
-            if (contenttype) {
-              if ((current_form = AddFormInfo(NULL,
+        if(current_form->contenttype) {
+          if(current_form->flags & HTTPPOST_FILENAME) {
+            if(contenttype) {
+              if((current_form = AddFormInfo(NULL,
                                               strdup(contenttype),
                                               current_form)) == NULL)
                 return_value = CURL_FORMADD_MEMORY;
             }
             else
               return_value = CURL_FORMADD_NULL;
           }
           else
             return_value = CURL_FORMADD_OPTION_TWICE;
         }
         else {
-          if (contenttype) {
+          if(contenttype) {
             current_form->contenttype = strdup(contenttype);
             if(!current_form->contenttype)
               return_value = CURL_FORMADD_MEMORY;
             else
               current_form->contenttype_alloc = TRUE;
           }
@@ -689,13 +689,13 @@
      * alright add the HttpPost item otherwise set return_value accordingly */
 
     post = NULL;
     for(form = first_form;
         form != NULL;
         form = form->more) {
-      if ( ((!form->name || !form->value) && !post) ||
+      if( ((!form->name || !form->value) && !post) ||
            ( (form->contentslength) &&
              (form->flags & HTTPPOST_FILENAME) ) ||
            ( (form->flags & HTTPPOST_FILENAME) &&
              (form->flags & HTTPPOST_PTRCONTENTS) ) ||
 
            ( (!form->buffer) &&
@@ -706,41 +706,41 @@
              (form->flags & HTTPPOST_PTRCONTENTS) )
            ) {
         return_value = CURL_FORMADD_INCOMPLETE;
         break;
       }
       else {
-        if ( ((form->flags & HTTPPOST_FILENAME) ||
+        if( ((form->flags & HTTPPOST_FILENAME) ||
               (form->flags & HTTPPOST_BUFFER)) &&
              !form->contenttype ) {
           /* our contenttype is missing */
           form->contenttype
             = strdup(ContentTypeForFilename(form->value, prevtype));
           if(!form->contenttype) {
             return_value = CURL_FORMADD_MEMORY;
             break;
           }
           form->contenttype_alloc = TRUE;
         }
-        if ( !(form->flags & HTTPPOST_PTRNAME) &&
+        if( !(form->flags & HTTPPOST_PTRNAME) &&
              (form == first_form) ) {
           /* copy name (without strdup; possibly contains null characters) */
           form->name = memdup(form->name, form->namelength);
-          if (!form->name) {
+          if(!form->name) {
             return_value = CURL_FORMADD_MEMORY;
             break;
           }
           form->name_alloc = TRUE;
         }
-        if ( !(form->flags & HTTPPOST_FILENAME) &&
+        if( !(form->flags & HTTPPOST_FILENAME) &&
              !(form->flags & HTTPPOST_READFILE) &&
              !(form->flags & HTTPPOST_PTRCONTENTS) &&
              !(form->flags & HTTPPOST_PTRBUFFER) ) {
           /* copy value (without strdup; possibly contains null characters) */
           form->value = memdup(form->value, form->contentslength);
-          if (!form->value) {
+          if(!form->value) {
             return_value = CURL_FORMADD_MEMORY;
             break;
           }
           form->value_alloc = TRUE;
         }
         post = AddHttpPost(form->name, form->namelength,
@@ -753,13 +753,13 @@
 
         if(!post) {
           return_value = CURL_FORMADD_MEMORY;
           break;
         }
 
-        if (form->contenttype)
+        if(form->contenttype)
           prevtype = form->contenttype;
       }
     }
   }
 
   if(return_value) {
@@ -777,13 +777,13 @@
         free(form->showfilename);
     }
   }
 
   /* always delete the allocated memory before returning */
   form = first_form;
-  while (form != NULL) {
+  while(form != NULL) {
     FormInfo *delete_form;
 
     delete_form = form;
     form = form->more;
     free (delete_form);
   }
@@ -817,22 +817,22 @@
                             const void *line,
                             size_t length,
                             curl_off_t *size)
 {
   struct FormData *newform = (struct FormData *)
     malloc(sizeof(struct FormData));
-  if (!newform)
+  if(!newform)
     return CURLE_OUT_OF_MEMORY;
   newform->next = NULL;
 
   /* we make it easier for plain strings: */
   if(!length)
     length = strlen((char *)line);
 
   newform->line = (char *)malloc(length+1);
-  if (!newform->line) {
+  if(!newform->line) {
     free(newform);
     return CURLE_OUT_OF_MEMORY;
   }
   memcpy(newform->line, line, length);
   newform->length = length;
   newform->line[length]=0; /* zero terminate for easier debugging */
@@ -842,13 +842,13 @@
     (*formp)->next = newform;
     *formp = newform;
   }
   else
     *formp = newform;
 
-  if (size) {
+  if(size) {
     if((type == FORM_DATA) || (type == FORM_CONTENT))
       *size += length;
     else {
       /* Since this is a file to be uploaded here, add the size of the actual
          file */
       if(!strequal("-", newform->line)) {
@@ -893,13 +893,13 @@
 
   do {
     next=form->next;  /* the following form line */
     free(form->line); /* free the line */
     free(form);       /* free the struct */
 
-  } while ((form = next) != NULL); /* continue */
+  } while((form = next) != NULL); /* continue */
 
   *form_ptr = NULL;
 }
 
 #ifdef CURL_DOES_CONVERSIONS
 /*
@@ -917,19 +917,19 @@
 
   if(!data)
     return CURLE_BAD_FUNCTION_ARGUMENT;
 
   do {
     next=form->next;  /* the following form line */
-    if (form->type == FORM_DATA) {
+    if(form->type == FORM_DATA) {
       rc = Curl_convert_to_network(data, form->line, form->length);
       /* Curl_convert_to_network calls failf if unsuccessful */
-      if (rc != CURLE_OK)
+      if(rc != CURLE_OK)
         return rc;
     }
-  } while ((form = next) != NULL); /* continue */
+  } while((form = next) != NULL); /* continue */
   return CURLE_OK;
 }
 #endif /* CURL_DOES_CONVERSIONS */
 
 /*
  * curl_formget()
@@ -941,35 +941,35 @@
 {
   CURLcode rc;
   curl_off_t size;
   struct FormData *data, *ptr;
 
   rc = Curl_getFormData(&data, form, NULL, &size);
-  if (rc != CURLE_OK)
+  if(rc != CURLE_OK)
     return (int)rc;
 
   for (ptr = data; ptr; ptr = ptr->next) {
-    if (ptr->type == FORM_FILE) {
+    if(ptr->type == FORM_FILE) {
       char buffer[8192];
       size_t nread;
       struct Form temp;
 
       Curl_FormInit(&temp, ptr);
 
       do {
         nread = readfromfile(&temp, buffer, sizeof(buffer));
-        if ((nread == (size_t) -1) || (nread != append(arg, buffer, nread))) {
-          if (temp.fp) {
+        if((nread == (size_t) -1) || (nread != append(arg, buffer, nread))) {
+          if(temp.fp) {
             fclose(temp.fp);
           }
           Curl_formclean(&data);
           return -1;
         }
-      } while (nread == sizeof(buffer));
+      } while(nread == sizeof(buffer));
     } else {
-      if (ptr->length != append(arg, ptr->line, ptr->length)) {
+      if(ptr->length != append(arg, ptr->line, ptr->length)) {
         Curl_formclean(&data);
         return -1;
       }
     }
   }
   Curl_formclean(&data);
@@ -1002,13 +1002,13 @@
     if(form->contenttype)
       free(form->contenttype); /* free the content type */
     if(form->showfilename)
       free(form->showfilename); /* free the faked file name */
     free(form);       /* free the struct */
 
-  } while ((form = next) != NULL); /* continue */
+  } while((form = next) != NULL); /* continue */
 }
 
 #ifndef HAVE_BASENAME
 /*
   (Quote from The Open Group Base Specifications Issue 6 IEEE Std 1003.1, 2004
   Edition)
@@ -1107,63 +1107,63 @@
   result = AddFormDataf(&form, NULL,
                         "%s; boundary=%s\r\n",
                         custom_content_type?custom_content_type:
                         "Content-Type: multipart/form-data",
                         boundary);
 
-  if (result) {
+  if(result) {
     free(boundary);
     return result;
   }
   /* we DO NOT include that line in the total size of the POST, since it'll be
      part of the header! */
 
   firstform = form;
 
   do {
 
     if(size) {
       result = AddFormDataf(&form, &size, "\r\n");
-      if (result)
+      if(result)
         break;
     }
 
     /* boundary */
     result = AddFormDataf(&form, &size, "--%s\r\n", boundary);
-    if (result)
+    if(result)
       break;
 
     /* Maybe later this should be disabled when a custom_content_type is
        passed, since Content-Disposition is not meaningful for all multipart
        types.
     */
     result = AddFormDataf(&form, &size,
                           "Content-Disposition: form-data; name=\"");
-    if (result)
+    if(result)
       break;
 
     result = AddFormData(&form, FORM_DATA, post->name, post->namelength,
                          &size);
-    if (result)
+    if(result)
       break;
 
     result = AddFormDataf(&form, &size, "\"");
-    if (result)
+    if(result)
       break;
 
     if(post->more) {
       /* If used, this is a link to more file names, we must then do
          the magic to include several files with the same field name */
 
       fileboundary = Curl_FormBoundary();
 
       result = AddFormDataf(&form, &size,
                             "\r\nContent-Type: multipart/mixed,"
                             " boundary=%s\r\n",
                             fileboundary);
-      if (result)
+      if(result)
         break;
     }
 
     file = post;
 
     do {
@@ -1180,52 +1180,52 @@
         result = AddFormDataf(&form, &size,
                               "\r\n--%s\r\nContent-Disposition: "
                               "attachment; filename=\"%s\"",
                               fileboundary,
                               (file->showfilename?file->showfilename:
                                filebasename));
-        if (filebasename)
+        if(filebasename)
           free(filebasename);
-        if (result)
+        if(result)
           break;
       }
       else if((post->flags & HTTPPOST_FILENAME) ||
               (post->flags & HTTPPOST_BUFFER)) {
 
         char *filebasename=
           (!post->showfilename)?strippath(post->contents):NULL;
 
         result = AddFormDataf(&form, &size,
                               "; filename=\"%s\"",
                               (post->showfilename?post->showfilename:
                                filebasename));
-        if (filebasename)
+        if(filebasename)
           free(filebasename);
 
-        if (result)
+        if(result)
           break;
       }
 
       if(file->contenttype) {
         /* we have a specified type */
         result = AddFormDataf(&form, &size,
                               "\r\nContent-Type: %s",
                               file->contenttype);
-        if (result)
+        if(result)
           break;
       }
 
       curList = file->contentheader;
       while( curList ) {
         /* Process the additional headers specified for this form */
         result = AddFormDataf( &form, &size, "\r\n%s", curList->data );
-        if (result)
+        if(result)
           break;
         curList = curList->next;
       }
-      if (result) {
+      if(result) {
         Curl_formclean(&firstform);
         free(boundary);
         return result;
       }
 
 #if 0
@@ -1237,19 +1237,19 @@
 
       if(file->contenttype &&
          !checkprefix("text/", file->contenttype)) {
         /* this is not a text content, mention our binary encoding */
         result = AddFormDataf(&form, &size,
                               "\r\nContent-Transfer-Encoding: binary");
-        if (result)
+        if(result)
           break;
       }
 #endif
 
       result = AddFormDataf(&form, &size, "\r\n\r\n");
-      if (result)
+      if(result)
         break;
 
       if((post->flags & HTTPPOST_FILENAME) ||
          (post->flags & HTTPPOST_READFILE)) {
         /* we should include the contents from the specified file */
         FILE *fileread;
@@ -1275,20 +1275,20 @@
              * thus must read the full file as before. We *could* use chunked
              * transfer-encoding, but that only works for HTTP 1.1 and we
              * can't be sure we work with such a server.
              */
             size_t nread;
             char buffer[512];
-            while ((nread = fread(buffer, 1, sizeof(buffer), fileread)) != 0) {
+            while((nread = fread(buffer, 1, sizeof(buffer), fileread)) != 0) {
               result = AddFormData(&form, FORM_CONTENT, buffer, nread, &size);
-              if (result)
+              if(result)
                 break;
             }
           }
 
-          if (result) {
+          if(result) {
             Curl_formclean(&firstform);
             free(boundary);
             return result;
           }
 
         }
@@ -1302,57 +1302,57 @@
           free(boundary);
           *finalform = NULL;
           return CURLE_READ_ERROR;
         }
 
       }
-      else if (post->flags & HTTPPOST_BUFFER) {
+      else if(post->flags & HTTPPOST_BUFFER) {
         /* include contents of buffer */
         result = AddFormData(&form, FORM_CONTENT, post->buffer,
                              post->bufferlength, &size);
-          if (result)
+          if(result)
             break;
       }
 
       else {
         /* include the contents we got */
         result = AddFormData(&form, FORM_CONTENT, post->contents,
                              post->contentslength, &size);
-        if (result)
+        if(result)
           break;
       }
-    } while ((file = file->more) != NULL); /* for each specified file for this field */
-    if (result) {
+    } while((file = file->more) != NULL); /* for each specified file for this field */
+    if(result) {
       Curl_formclean(&firstform);
       free(boundary);
       return result;
     }
 
     if(post->more) {
       /* this was a multiple-file inclusion, make a termination file
          boundary: */
       result = AddFormDataf(&form, &size,
                            "\r\n--%s--",
                            fileboundary);
       free(fileboundary);
-      if (result)
+      if(result)
         break;
     }
 
-  } while ((post = post->next) != NULL); /* for each field */
-  if (result) {
+  } while((post = post->next) != NULL); /* for each field */
+  if(result) {
     Curl_formclean(&firstform);
     free(boundary);
     return result;
   }
 
   /* end-boundary for everything */
   result = AddFormDataf(&form, &size,
                        "\r\n--%s--\r\n",
                        boundary);
-  if (result) {
+  if(result) {
     Curl_formclean(&firstform);
     free(boundary);
     return result;
   }
 
   *sizep = size;
@@ -1485,13 +1485,13 @@
                  struct curl_httppost **last_post,
                  ...)
 {
   int result;
   va_list arg;
   va_start(arg, last_post);
-  if ((result = FormAdd(httppost, last_post, arg)))
+  if((result = FormAdd(httppost, last_post, arg)))
     fprintf (stderr, "ERROR doing FormAdd ret: %d action: %s\n", result,
              errormsg);
   va_end(arg);
   return result;
 }
 
@@ -1536,74 +1536,74 @@
   struct FormData *form;
   struct Form formread;
 
   (void) argc;
   (void) argv;
 
-  if (FormAddTest("simple COPYCONTENTS test", &httppost, &last_post,
+  if(FormAddTest("simple COPYCONTENTS test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name1, CURLFORM_COPYCONTENTS, value1,
                   CURLFORM_END))
     ++errors;
-  if (FormAddTest("COPYCONTENTS  + CONTENTTYPE test", &httppost, &last_post,
+  if(FormAddTest("COPYCONTENTS  + CONTENTTYPE test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name2, CURLFORM_COPYCONTENTS, value2,
                   CURLFORM_CONTENTTYPE, type2, CURLFORM_END))
     ++errors;
   /* make null character at start to check that contentslength works
      correctly */
   name3[1] = '\0';
   value3[1] = '\0';
-  if (FormAddTest("PTRNAME + NAMELENGTH + COPYNAME + CONTENTSLENGTH test",
+  if(FormAddTest("PTRNAME + NAMELENGTH + COPYNAME + CONTENTSLENGTH test",
                   &httppost, &last_post,
                   CURLFORM_PTRNAME, name3, CURLFORM_COPYCONTENTS, value3,
                   CURLFORM_CONTENTSLENGTH, value3length,
                   CURLFORM_NAMELENGTH, name3length, CURLFORM_END))
     ++errors;
-  if (FormAddTest("simple PTRCONTENTS test", &httppost, &last_post,
+  if(FormAddTest("simple PTRCONTENTS test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name4, CURLFORM_PTRCONTENTS, value4,
                   CURLFORM_END))
     ++errors;
   /* make null character at start to check that contentslength works
      correctly */
   value5[1] = '\0';
-  if (FormAddTest("PTRCONTENTS + CONTENTSLENGTH test", &httppost, &last_post,
+  if(FormAddTest("PTRCONTENTS + CONTENTSLENGTH test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name5, CURLFORM_PTRCONTENTS, value5,
                   CURLFORM_CONTENTSLENGTH, value5length, CURLFORM_END))
     ++errors;
   /* make null character at start to check that contentslength works
      correctly */
   value6[1] = '\0';
-  if (FormAddTest("PTRCONTENTS + CONTENTSLENGTH + CONTENTTYPE test",
+  if(FormAddTest("PTRCONTENTS + CONTENTSLENGTH + CONTENTTYPE test",
                   &httppost, &last_post,
                   CURLFORM_COPYNAME, name6, CURLFORM_PTRCONTENTS, value6,
                   CURLFORM_CONTENTSLENGTH, value6length,
                   CURLFORM_CONTENTTYPE, type6, CURLFORM_END))
     ++errors;
-  if (FormAddTest("FILE + CONTENTTYPE test", &httppost, &last_post,
+  if(FormAddTest("FILE + CONTENTTYPE test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name7, CURLFORM_FILE, value7,
                   CURLFORM_CONTENTTYPE, type7, CURLFORM_END))
     ++errors;
-  if (FormAddTest("FILE1 + FILE2 test", &httppost, &last_post,
+  if(FormAddTest("FILE1 + FILE2 test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name8, CURLFORM_FILE, value7,
                   CURLFORM_FILE, value8, CURLFORM_END))
     ++errors;
-  if (FormAddTest("FILE1 + FILE2 + FILE3 test", &httppost, &last_post,
+  if(FormAddTest("FILE1 + FILE2 + FILE3 test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name9, CURLFORM_FILE, value7,
                   CURLFORM_FILE, value8, CURLFORM_FILE, value7, CURLFORM_END))
     ++errors;
   forms[0].option = CURLFORM_FILE;
   forms[0].value  = value7;
   forms[1].option = CURLFORM_FILE;
   forms[1].value  = value8;
   forms[2].option = CURLFORM_FILE;
   forms[2].value  = value7;
   forms[3].option  = CURLFORM_END;
-  if (FormAddTest("FILE1 + FILE2 + FILE3 ARRAY test", &httppost, &last_post,
+  if(FormAddTest("FILE1 + FILE2 + FILE3 ARRAY test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name10, CURLFORM_ARRAY, forms,
                   CURLFORM_END))
     ++errors;
-  if (FormAddTest("FILECONTENT test", &httppost, &last_post,
+  if(FormAddTest("FILECONTENT test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name11, CURLFORM_FILECONTENT, value7,
                   CURLFORM_END))
     ++errors;
 
   rc = Curl_getFormData(&form, httppost, NULL, &size);
   if(rc != CURLE_OK) {
@@ -1625,13 +1625,13 @@
     fwrite(buffer, nread, 1, stdout);
   } while(1);
 
   fprintf(stdout, "size: ");
   fprintf(stdout, CURL_FORMAT_OFF_T, size);
   fprintf(stdout, "\n");
-  if (errors)
+  if(errors)
     fprintf(stdout, "\n==> %d Test(s) failed!\n", errors);
   else
     fprintf(stdout, "\nAll Tests seem to have worked (please check output)\n");
 
   return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ftp.c	2007-10-27 06:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ftp.c	2008-01-26 07:56:20.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.c,v 1.450 2007-10-26 19:26:41 danf Exp $
+ * $Id: ftp.c,v 1.464 2008-01-15 23:19:02 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_FTP
 #include <stdio.h>
@@ -108,13 +108,13 @@
 #define NIFLAGS NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID
 #else
 #define NIFLAGS NI_NUMERICHOST | NI_NUMERICSERV
 #endif
 
 #ifdef CURL_DISABLE_VERBOSE_STRINGS
-#define ftp_pasv_verbose(a,b,c,d)  do { } while (0)
+#define ftp_pasv_verbose(a,b,c,d)  do { } while(0)
 #endif
 
 /* Local API functions */
 static CURLcode ftp_sendquote(struct connectdata *conn,
                               struct curl_slist *quote);
 static CURLcode ftp_quit(struct connectdata *conn);
@@ -131,74 +131,74 @@
 static CURLcode ftp_state_quote(struct connectdata *conn,
                                 bool init, ftpstate instate);
 static CURLcode ftp_nb_type(struct connectdata *conn,
                             bool ascii, ftpstate newstate);
 static int ftp_need_type(struct connectdata *conn,
                          bool ascii);
-static CURLcode Curl_ftp(struct connectdata *conn, bool *done);
-static CURLcode Curl_ftp_done(struct connectdata *conn,
+static CURLcode ftp_do(struct connectdata *conn, bool *done);
+static CURLcode ftp_done(struct connectdata *conn,
                               CURLcode, bool premature);
-static CURLcode Curl_ftp_connect(struct connectdata *conn, bool *done);
-static CURLcode Curl_ftp_disconnect(struct connectdata *conn);
-static CURLcode Curl_ftp_nextconnect(struct connectdata *conn);
-static CURLcode Curl_ftp_multi_statemach(struct connectdata *conn, bool *done);
-static int Curl_ftp_getsock(struct connectdata *conn,
+static CURLcode ftp_connect(struct connectdata *conn, bool *done);
+static CURLcode ftp_disconnect(struct connectdata *conn);
+static CURLcode ftp_nextconnect(struct connectdata *conn);
+static CURLcode ftp_multi_statemach(struct connectdata *conn, bool *done);
+static int ftp_getsock(struct connectdata *conn,
                             curl_socket_t *socks,
                             int numsocks);
-static CURLcode Curl_ftp_doing(struct connectdata *conn,
+static CURLcode ftp_doing(struct connectdata *conn,
                                bool *dophase_done);
-static CURLcode Curl_ftp_setup_connection(struct connectdata * conn);
+static CURLcode ftp_setup_connection(struct connectdata * conn);
 #ifdef USE_SSL
-static CURLcode Curl_ftps_setup_connection(struct connectdata * conn);
+static CURLcode ftps_setup_connection(struct connectdata * conn);
 #endif
 
 /* easy-to-use macro: */
-#define FTPSENDF(x,y,z)    if ((result = Curl_ftpsendf(x,y,z)) != CURLE_OK) \
+#define FTPSENDF(x,y,z)    if((result = Curl_ftpsendf(x,y,z)) != CURLE_OK) \
                               return result
-#define NBFTPSENDF(x,y,z)  if ((result = Curl_nbftpsendf(x,y,z)) != CURLE_OK) \
+#define NBFTPSENDF(x,y,z)  if((result = Curl_nbftpsendf(x,y,z)) != CURLE_OK) \
                               return result
 
 
 /*
  * FTP protocol handler.
  */
 
 const struct Curl_handler Curl_handler_ftp = {
   "FTP",                                /* scheme */
-  Curl_ftp_setup_connection,            /* setup_connection */
-  Curl_ftp,                             /* do_it */
-  Curl_ftp_done,                        /* done */
-  Curl_ftp_nextconnect,                 /* do_more */
-  Curl_ftp_connect,                     /* connect_it */
-  Curl_ftp_multi_statemach,             /* connecting */
-  Curl_ftp_doing,                       /* doing */
-  Curl_ftp_getsock,                     /* proto_getsock */
-  Curl_ftp_getsock,                     /* doing_getsock */
-  Curl_ftp_disconnect,                  /* disconnect */
+  ftp_setup_connection,            /* setup_connection */
+  ftp_do,                          /* do_it */
+  ftp_done,                        /* done */
+  ftp_nextconnect,                 /* do_more */
+  ftp_connect,                     /* connect_it */
+  ftp_multi_statemach,             /* connecting */
+  ftp_doing,                       /* doing */
+  ftp_getsock,                     /* proto_getsock */
+  ftp_getsock,                     /* doing_getsock */
+  ftp_disconnect,                  /* disconnect */
   PORT_FTP,                             /* defport */
   PROT_FTP                              /* protocol */
 };
 
 
 #ifdef USE_SSL
 /*
  * FTPS protocol handler.
  */
 
 const struct Curl_handler Curl_handler_ftps = {
   "FTPS",                               /* scheme */
-  Curl_ftps_setup_connection,           /* setup_connection */
-  Curl_ftp,                             /* do_it */
-  Curl_ftp_done,                        /* done */
-  Curl_ftp_nextconnect,                 /* do_more */
-  Curl_ftp_connect,                     /* connect_it */
-  Curl_ftp_multi_statemach,             /* connecting */
-  Curl_ftp_doing,                       /* doing */
-  Curl_ftp_getsock,                     /* proto_getsock */
-  Curl_ftp_getsock,                     /* doing_getsock */
-  Curl_ftp_disconnect,                  /* disconnect */
+  ftps_setup_connection,           /* setup_connection */
+  ftp_do,                          /* do_it */
+  ftp_done,                        /* done */
+  ftp_nextconnect,                 /* do_more */
+  ftp_connect,                     /* connect_it */
+  ftp_multi_statemach,             /* connecting */
+  ftp_doing,                       /* doing */
+  ftp_getsock,                     /* proto_getsock */
+  ftp_getsock,                     /* doing_getsock */
+  ftp_disconnect,                  /* disconnect */
   PORT_FTPS,                            /* defport */
   PROT_FTP | PROT_FTPS | PROT_SSL       /* protocol */
 };
 #endif
 
 #ifndef CURL_DISABLE_HTTP
@@ -304,36 +304,36 @@
   struct SessionHandle *data = conn->data;
   curl_socket_t sock = conn->sock[SECONDARYSOCKET];
   int timeout_set = 0;
 
   /* if a timeout is set, use the most restrictive one */
 
-  if (data->set.timeout > 0)
+  if(data->set.timeout > 0)
     timeout_set += 1;
-  if (data->set.connecttimeout > 0)
+  if(data->set.connecttimeout > 0)
     timeout_set += 2;
 
   switch (timeout_set) {
   case 1:
     timeout_ms = data->set.timeout;
     break;
   case 2:
     timeout_ms = data->set.connecttimeout;
     break;
   case 3:
-    if (data->set.timeout < data->set.connecttimeout)
+    if(data->set.timeout < data->set.connecttimeout)
       timeout_ms = data->set.timeout;
     else
       timeout_ms = data->set.connecttimeout;
     break;
   default:
     timeout_ms = 60000; /* 60 seconds default timeout */
     break;
   }
 
-  if (timeout_set > 0) {
+  if(timeout_set > 0) {
     /* if a timeout was already set, substract elapsed time */
     timeout_ms -= Curl_tvdiff(Curl_tvnow(), conn->now);
     if(timeout_ms < 0) {
       failf(data, "Timed out before server could connect to us");
       return CURLE_OPERATION_TIMEDOUT;
     }
@@ -363,13 +363,13 @@
         size = sizeof(add);
 
         s=accept(sock, (struct sockaddr *) &add, &size);
       }
       sclose(sock); /* close the first socket */
 
-      if (CURL_SOCKET_BAD == s) {
+      if(CURL_SOCKET_BAD == s) {
         /* DIE! */
         failf(data, "Error accept()ing server connect");
         return CURLE_FTP_PORT_FAILED;
       }
       infof(data, "Connection accepted from server\n");
 
@@ -400,13 +400,13 @@
 
 static CURLcode ftp_readresp(curl_socket_t sockfd,
                              struct connectdata *conn,
                              int *ftpcode, /* return the ftp-code if done */
                              size_t *size) /* size of the response */
 {
-  int perline; /* count bytes per line */
+  ssize_t perline; /* count bytes per line */
   bool keepon=TRUE;
   ssize_t gotbytes;
   char *ptr;
   struct SessionHandle *data = conn->data;
   char *buf = data->state.buffer;
   CURLcode result = CURLE_OK;
@@ -415,14 +415,15 @@
 
   *ftpcode = 0; /* 0 for errors or not done */
   *size = 0;
 
   ptr=buf + ftpc->nread_resp;
 
-  perline= (int)(ptr-ftpc->linestart_resp); /* number of bytes in the current
-                                              line, so far */
+  /* number of bytes in the current line, so far */
+  perline = (ssize_t)(ptr-ftpc->linestart_resp);
+
   keepon=TRUE;
 
   while((ftpc->nread_resp<BUFSIZE) && (keepon && !result)) {
 
     if(ftpc->cache) {
       /* we had data in the "cache", copy that instead of doing an actual
@@ -476,16 +477,16 @@
     }
     else {
       /* we got a whole chunk of data, which can be anything from one
        * byte to a set of lines and possible just a piece of the last
        * line */
       ssize_t i;
-      int clipamount = 0;
+      ssize_t clipamount = 0;
       bool restart = FALSE;
 
-      data->reqdata.keep.headerbytecount += gotbytes;
+      data->req.headerbytecount += gotbytes;
 
       ftpc->nread_resp += gotbytes;
       for(i = 0; i < gotbytes; ptr++, i++) {
         perline++;
         if(*ptr=='\n') {
           /* a newline is CRLF in ftp-talk, so the CR is ignored as
@@ -640,13 +641,13 @@
   CURLcode result = CURLE_OK;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   struct timeval now = Curl_tvnow();
   size_t nread;
   int cache_skip=0;
 
-  if (ftpcode)
+  if(ftpcode)
     *ftpcode = 0; /* 0 for errors */
 
   *nreadp=0;
 
   while(!*ftpcode && !result) {
     /* check and reset timeout value every lap */
@@ -785,13 +786,13 @@
   ftpc->state = newstate;
 }
 
 static CURLcode ftp_state_user(struct connectdata *conn)
 {
   CURLcode result;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   /* send USER */
   NBFTPSENDF(conn, "USER %s", ftp->user?ftp->user:"");
 
   state(conn, FTP_USER);
   conn->data->state.ftp_trying_alternative = FALSE;
 
@@ -807,13 +808,13 @@
   state(conn, FTP_PWD);
 
   return CURLE_OK;
 }
 
 /* For the FTP "protocol connect" and "doing" phases only */
-static int Curl_ftp_getsock(struct connectdata *conn,
+static int ftp_getsock(struct connectdata *conn,
                             curl_socket_t *socks,
                             int numsocks)
 {
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   if(!numsocks)
@@ -843,13 +844,13 @@
 
   if(ftpc->cwddone)
     /* already done and fine */
     result = ftp_state_post_cwd(conn);
   else {
     ftpc->count2 = 0;
-    if (conn->bits.reuse && ftpc->entrypath) {
+    if(conn->bits.reuse && ftpc->entrypath) {
       /* This is a re-used connection. Since we change directory to where the
          transfer is taking place, we must first get back to the original dir
          where we ended up after login: */
       ftpc->count1 = 0; /* we count this as the first path, then we add one
                           for all upcoming ones in the ftp->dirs[] array */
       NBFTPSENDF(conn, "CWD %s", ftpc->entrypath);
@@ -919,24 +920,24 @@
 
   if(!host) {
     /* not an interface and not a host name, get default by extracting
        the IP from the control connection */
 
     sslen = sizeof(ss);
-    if (getsockname(conn->sock[FIRSTSOCKET], (struct sockaddr *)&ss, &sslen)) {
+    if(getsockname(conn->sock[FIRSTSOCKET], (struct sockaddr *)&ss, &sslen)) {
       failf(data, "getsockname() failed: %s",
           Curl_strerror(conn, SOCKERRNO) );
       return CURLE_FTP_PORT_FAILED;
     }
 
-    if (sslen > (socklen_t)sizeof(ss))
+    if(sslen > (socklen_t)sizeof(ss))
       sslen = sizeof(ss);
     rc = getnameinfo((struct sockaddr *)&ss, sslen, hbuf, sizeof(hbuf), NULL,
                      0, NIFLAGS);
     if(rc) {
-      failf(data, "getnameinfo() returned %d \n", rc);
+      failf(data, "getnameinfo() returned %d", rc);
       return CURLE_FTP_PORT_FAILED;
     }
     host = hbuf; /* use this host name */
   }
 
   rc = Curl_resolv(conn, host, 0, &h);
@@ -957,17 +958,17 @@
   portsock = CURL_SOCKET_BAD;
   error = 0;
   for (ai = res; ai; ai = ai->ai_next) {
     /*
      * Workaround for AIX5 getaddrinfo() problem (it doesn't set ai_socktype):
      */
-    if (ai->ai_socktype == 0)
+    if(ai->ai_socktype == 0)
       ai->ai_socktype = conn->socktype;
 
     portsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
-    if (portsock == CURL_SOCKET_BAD) {
+    if(portsock == CURL_SOCKET_BAD) {
       error = SOCKERRNO;
       continue;
     }
     break;
   }
   if(!ai) {
@@ -975,17 +976,17 @@
     return CURLE_FTP_PORT_FAILED;
   }
 
   /* step 3, bind to a suitable local address */
 
   /* Try binding the given address. */
-  if (bind(portsock, ai->ai_addr, ai->ai_addrlen)) {
+  if(bind(portsock, ai->ai_addr, ai->ai_addrlen)) {
 
     /* It failed. Bind the address used for the control connection instead */
     sslen = sizeof(ss);
-    if (getsockname(conn->sock[FIRSTSOCKET],
+    if(getsockname(conn->sock[FIRSTSOCKET],
                     (struct sockaddr *)sa, &sslen)) {
       failf(data, "getsockname() failed: %s",
           Curl_strerror(conn, SOCKERRNO) );
       sclose(portsock);
       return CURLE_FTP_PORT_FAILED;
     }
@@ -993,13 +994,13 @@
     /* set port number to zero to make bind() pick "any" */
     if(((struct sockaddr *)sa)->sa_family == AF_INET)
       ((struct sockaddr_in *)sa)->sin_port=0;
     else
       ((struct sockaddr_in6 *)sa)->sin6_port =0;
 
-    if (sslen > (socklen_t)sizeof(ss))
+    if(sslen > (socklen_t)sizeof(ss))
       sslen = sizeof(ss);
 
     if(bind(portsock, (struct sockaddr *)sa, sslen)) {
       failf(data, "bind failed: %s", Curl_strerror(conn, SOCKERRNO));
       sclose(portsock);
       return CURLE_FTP_PORT_FAILED;
@@ -1015,13 +1016,13 @@
     sclose(portsock);
     return CURLE_FTP_PORT_FAILED;
   }
 
   /* step 4, listen on the socket */
 
-  if (listen(portsock, 1)) {
+  if(listen(portsock, 1)) {
     failf(data, "socket failure: %s", Curl_strerror(conn, SOCKERRNO));
     sclose(portsock);
     return CURLE_FTP_PORT_FAILED;
   }
 
   /* step 5, send the proper FTP command */
@@ -1051,13 +1052,13 @@
       port = ntohs(((struct sockaddr_in6 *)sa)->sin6_port);
       break;
     default:
       break;
     }
 
-    if (EPRT == fcmd) {
+    if(EPRT == fcmd) {
       /*
        * Two fine examples from RFC2428;
        *
        * EPRT |1|132.235.1.2|6275|
        *
        * EPRT |2|1080::8:800:200C:417A|5282|
@@ -1067,17 +1068,17 @@
                                ai->ai_family == AF_INET?1:2,
                                myhost, port);
       if(result)
         return result;
       break;
     }
-    else if (PORT == fcmd) {
+    else if(PORT == fcmd) {
       char *source = myhost;
       char *dest = tmp;
 
-      if ((PORT == fcmd) && ai->ai_family != AF_INET)
+      if((PORT == fcmd) && ai->ai_family != AF_INET)
         continue;
 
       /* translate x.x.x.x to x,x,x,x */
       while(source && *source) {
         if(*source == '.')
           *dest=',';
@@ -1158,25 +1159,25 @@
     } /* CURL_INADDR_NONE */
   } /* ftpportstr */
 
   if(!addr) {
     /* pick a suitable default here */
 
-    if (getsockname(conn->sock[FIRSTSOCKET],
+    if(getsockname(conn->sock[FIRSTSOCKET],
                     (struct sockaddr *)&sa, &sslen)) {
       failf(data, "getsockname() failed: %s",
           Curl_strerror(conn, SOCKERRNO) );
       return CURLE_FTP_PORT_FAILED;
     }
-    if (sslen > (socklen_t)sizeof(sa))
+    if(sslen > (socklen_t)sizeof(sa))
       sslen = sizeof(sa);
 
     sa_filled_in = TRUE; /* the sa struct is filled in */
   }
 
-  if (addr || sa_filled_in) {
+  if(addr || sa_filled_in) {
     portsock = socket(AF_INET, SOCK_STREAM, 0);
     if(CURL_SOCKET_BAD != portsock) {
 
       /* we set the secondary socket variable to this for now, it
          is only so that the cleanup function will close it in case
          we fail before the true secondary stuff is made */
@@ -1202,13 +1203,13 @@
           failf(data, "getsockname() failed: %s",
             Curl_strerror(conn, SOCKERRNO) );
           return CURLE_FTP_PORT_FAILED;
         }
         porttouse = ntohs(add.sin_port);
 
-        if ( listen(portsock, 1) < 0 ) {
+        if( listen(portsock, 1) < 0 ) {
           failf(data, "listen(2) failed on socket");
           return CURLE_FTP_PORT_FAILED;
         }
       }
       else {
         failf(data, "bind(2) failed on socket");
@@ -1310,13 +1311,13 @@
 /* REST is the last command in the chain of commands when a "head"-like
    request is made. Thus, if an actual transfer is to be made this is where
    we take off for real. */
 static CURLcode ftp_state_post_rest(struct connectdata *conn)
 {
   CURLcode result = CURLE_OK;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   struct SessionHandle *data = conn->data;
 
   if(ftp->transfer != FTPTRANSFER_BODY) {
     /* doesn't transfer any data */
 
     /* still possibly do PRE QUOTE jobs */
@@ -1334,13 +1335,13 @@
   return result;
 }
 
 static CURLcode ftp_state_post_size(struct connectdata *conn)
 {
   CURLcode result = CURLE_OK;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   if((ftp->transfer != FTPTRANSFER_BODY) && ftpc->file) {
     /* if a "head"-like request is being made (on a file) */
 
     /* Determine if server can respond to REST command and therefore
@@ -1355,13 +1356,13 @@
   return result;
 }
 
 static CURLcode ftp_state_post_type(struct connectdata *conn)
 {
   CURLcode result = CURLE_OK;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   if((ftp->transfer == FTPTRANSFER_INFO) && ftpc->file) {
     /* if a "head"-like request is being made (on a file) */
 
     /* we know ftpc->file is a valid pointer to a file name */
@@ -1395,17 +1396,17 @@
      then just do LIST (in that case: nothing to do here)
   */
   char *cmd,*lstArg,*slashPos;
 
   lstArg = NULL;
   if((data->set.ftp_filemethod == FTPFILE_NOCWD) &&
-     data->reqdata.path &&
-     data->reqdata.path[0] &&
-     strchr(data->reqdata.path,'/')) {
+     data->state.path &&
+     data->state.path[0] &&
+     strchr(data->state.path,'/')) {
 
-    lstArg = strdup(data->reqdata.path);
+    lstArg = strdup(data->state.path);
     if(!lstArg)
       return CURLE_OUT_OF_MEMORY;
 
     /* Check if path does not end with /, as then we cut off the file part */
     if(lstArg[strlen(lstArg) - 1] != '/')  {
 
@@ -1462,13 +1463,13 @@
   return result;
 }
 
 static CURLcode ftp_state_post_mdtm(struct connectdata *conn)
 {
   CURLcode result = CURLE_OK;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   struct SessionHandle *data = conn->data;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   /* If we have selected NOBODY and HEADER, it means that we only want file
      information. Which in FTP can't be much more than the file size and
      date. */
@@ -1481,13 +1482,13 @@
     ftp->transfer = FTPTRANSFER_INFO;
     /* this means no actual transfer will be made */
 
     /* Some servers return different sizes for different modes, and thus we
        must set the proper type before we check the size */
     result = ftp_nb_type(conn, data->set.prefer_ascii, FTP_TYPE);
-    if (result)
+    if(result)
       return result;
   }
   else
     result = ftp_state_post_type(conn);
 
   return result;
@@ -1519,19 +1520,18 @@
 
 /* This is called after the TYPE and possible quote commands have been sent */
 static CURLcode ftp_state_ul_setup(struct connectdata *conn,
                                    bool sizechecked)
 {
   CURLcode result = CURLE_OK;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   struct SessionHandle *data = conn->data;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
-  curl_off_t passed=0;
 
-  if((data->reqdata.resume_from && !sizechecked) ||
-     ((data->reqdata.resume_from > 0) && sizechecked)) {
+  if((data->state.resume_from && !sizechecked) ||
+     ((data->state.resume_from > 0) && sizechecked)) {
     /* we're about to continue the uploading of a file */
     /* 1. get already existing file's size. We use the SIZE command for this
        which may not exist in the server!  The SIZE command is not in
        RFC959. */
 
     /* 2. This used to set REST. But since we can do append, we
@@ -1539,59 +1539,68 @@
        offset and then we APPEND the rest on the file instead */
 
     /* 3. pass file-size number of bytes in the source file */
     /* 4. lower the infilesize counter */
     /* => transfer as usual */
 
-    if(data->reqdata.resume_from < 0 ) {
+    if(data->state.resume_from < 0 ) {
       /* Got no given size to start from, figure it out */
       NBFTPSENDF(conn, "SIZE %s", ftpc->file);
       state(conn, FTP_STOR_SIZE);
       return result;
     }
 
     /* enable append */
     data->set.ftp_append = TRUE;
 
-    /* Let's read off the proper amount of bytes from the input. If we knew it
-       was a proper file we could've just fseek()ed but we only have a stream
-       here */
-
-    /* TODO: allow the ioctlfunction to provide a fast forward function that
-       can be used here and use this method only as a fallback! */
-    do {
-      curl_off_t readthisamountnow = (data->reqdata.resume_from - passed);
-      curl_off_t actuallyread;
-
-      if(readthisamountnow > BUFSIZE)
-        readthisamountnow = BUFSIZE;
-
-      actuallyread = (curl_off_t)
-        conn->fread_func(data->state.buffer, 1, (size_t)readthisamountnow,
-                    conn->fread_in);
-
-      passed += actuallyread;
-      if(actuallyread != readthisamountnow) {
-        failf(data, "Could only read %" FORMAT_OFF_T
-              " bytes from the input", passed);
+    /* Let's read off the proper amount of bytes from the input. */
+    if(conn->seek_func) {
+      curl_off_t readthisamountnow = data->state.resume_from;
+
+      if(conn->seek_func(conn->seek_client,
+			 readthisamountnow, SEEK_SET) != 0) {
+        failf(data, "Could not seek stream");
         return CURLE_FTP_COULDNT_USE_REST;
       }
-    } while(passed != data->reqdata.resume_from);
+    }
+
+    else {
+      curl_off_t passed=0;
+      do {
+        curl_off_t readthisamountnow = (data->state.resume_from - passed);
+        curl_off_t actuallyread;
+
+        if(readthisamountnow > BUFSIZE)
+          readthisamountnow = BUFSIZE;
+
+        actuallyread = (curl_off_t)
+          conn->fread_func(data->state.buffer, 1, (size_t)readthisamountnow,
+                      conn->fread_in);
+
+        passed += actuallyread;
+        if((actuallyread <= 0) || (actuallyread > readthisamountnow)) {
+          /* this checks for greater-than only to make sure that the
+             CURL_READFUNC_ABORT return code still aborts */
+          failf(data, "Failed to read data");
+          return CURLE_FTP_COULDNT_USE_REST;
+        }
+      } while(passed < data->state.resume_from);
+    }
 
     /* now, decrease the size of the read */
     if(data->set.infilesize>0) {
-      data->set.infilesize -= data->reqdata.resume_from;
+      data->set.infilesize -= data->state.resume_from;
 
       if(data->set.infilesize <= 0) {
         infof(data, "File already completely uploaded\n");
 
         /* no data to transfer */
         result=Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
 
         /* Set ->transfer so that we won't get any error in
-         * Curl_ftp_done() because we didn't transfer anything! */
+         * ftp_done() because we didn't transfer anything! */
         ftp->transfer = FTPTRANSFER_NONE;
 
         state(conn, FTP_STOP);
         return CURLE_OK;
       }
     }
@@ -1609,13 +1618,13 @@
 static CURLcode ftp_state_quote(struct connectdata *conn,
                                 bool init,
                                 ftpstate instate)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data = conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   bool quote=FALSE;
   struct curl_slist *item;
 
   switch(instate) {
   case FTP_QUOTE:
@@ -1656,13 +1665,13 @@
     switch(instate) {
     case FTP_QUOTE:
     default:
       result = ftp_state_cwd(conn);
       break;
     case FTP_RETR_PREQUOTE:
-      if (ftp->transfer != FTPTRANSFER_BODY)
+      if(ftp->transfer != FTPTRANSFER_BODY)
         state(conn, FTP_STOP);
       else {
         NBFTPSENDF(conn, "SIZE %s", ftpc->file);
         state(conn, FTP_RETR_SIZE);
       }
       break;
@@ -1721,15 +1730,17 @@
             break;
           }
         }
         if(ptr) {
           newport = (unsigned short)(num & 0xffff);
 
-          if (conn->bits.tunnel_proxy ||
-              data->set.proxytype == CURLPROXY_SOCKS5 ||
-              data->set.proxytype == CURLPROXY_SOCKS4)
+          if(conn->bits.tunnel_proxy ||
+             data->set.proxytype == CURLPROXY_SOCKS5 ||
+             data->set.proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
+             data->set.proxytype == CURLPROXY_SOCKS4 ||
+             data->set.proxytype == CURLPROXY_SOCKS4A)
             /* proxy tunnel -> use other host info because ip_addr_str is the
                proxy address not the ftp host */
             snprintf(newhost, sizeof(newhost), "%s", conn->host.name);
           else
             /* use the same IP we are already connected to */
             snprintf(newhost, NEWHOST_BUFSIZE, "%s", conn->ip_addr_str);
@@ -1756,13 +1767,13 @@
      * Found reply-strings include:
      * "227 Entering Passive Mode (127,0,0,1,4,51)"
      * "227 Data transfer will passively listen to 127,0,0,1,4,51"
      * "227 Entering passive mode. 127,0,0,1,4,51"
      */
     while(*str) {
-      if (6 == sscanf(str, "%d,%d,%d,%d,%d,%d",
+      if(6 == sscanf(str, "%d,%d,%d,%d,%d,%d",
                       &ip[0], &ip[1], &ip[2], &ip[3],
                       &port[0], &port[1]))
         break;
       str++;
     }
 
@@ -1775,15 +1786,17 @@
     if(data->set.ftp_skip_ip) {
       /* told to ignore the remotely given IP but instead use the one we used
          for the control connection */
       infof(data, "Skips %d.%d.%d.%d for data connection, uses %s instead\n",
             ip[0], ip[1], ip[2], ip[3],
             conn->ip_addr_str);
-      if (conn->bits.tunnel_proxy ||
+      if(conn->bits.tunnel_proxy ||
           data->set.proxytype == CURLPROXY_SOCKS5 ||
-          data->set.proxytype == CURLPROXY_SOCKS4)
+          data->set.proxytype == CURLPROXY_SOCKS5_HOSTNAME ||
+          data->set.proxytype == CURLPROXY_SOCKS4 ||
+          data->set.proxytype == CURLPROXY_SOCKS4A)
         /* proxy tunnel -> use other host info because ip_addr_str is the
            proxy address not the ftp host */
         snprintf(newhost, sizeof(newhost), "%s", conn->host.name);
       else
         snprintf(newhost, sizeof(newhost), "%s", conn->ip_addr_str);
     }
@@ -1845,13 +1858,13 @@
                             &conn->sock[SECONDARYSOCKET],
                             &conninfo,
                             &connected);
 
   Curl_resolv_unlock(data, addr); /* we're done using this address */
 
-  if (result && ftpc->count1 == 0 && ftpcode == 229) {
+  if(result && ftpc->count1 == 0 && ftpcode == 229) {
     infof(data, "got positive EPSV response, but can't connect. "
           "Disabling EPSV\n");
     /* disable it for next transfer */
     conn->bits.ftp_use_epsv = FALSE;
     data->state.errorbuf = FALSE; /* allow error message to get rewritten */
     NBFTPSENDF(conn, "PASV", NULL);
@@ -1874,21 +1887,26 @@
   if(data->set.verbose)
     /* this just dumps information about this second connection */
     ftp_pasv_verbose(conn, conninfo, newhost, connectport);
 
   switch(data->set.proxytype) {
   case CURLPROXY_SOCKS5:
+  case CURLPROXY_SOCKS5_HOSTNAME:
     result = Curl_SOCKS5(conn->proxyuser, conn->proxypasswd, newhost, newport,
                          SECONDARYSOCKET, conn);
     break;
   case CURLPROXY_HTTP:
     /* do nothing here. handled later. */
     break;
   case CURLPROXY_SOCKS4:
     result = Curl_SOCKS4(conn->proxyuser, newhost, newport,
-                         SECONDARYSOCKET, conn);
+                         SECONDARYSOCKET, conn, FALSE);
+    break;
+  case CURLPROXY_SOCKS4A:
+    result = Curl_SOCKS4(conn->proxyuser, newhost, newport,
+                         SECONDARYSOCKET, conn, TRUE);
     break;
   default:
     failf(data, "unknown proxytype option given");
     result = CURLE_COULDNT_CONNECT;
     break;
   }
@@ -1904,19 +1922,19 @@
      * conn->proto.http; we want FTP through HTTP and we have to change the
      * member temporarily for connecting to the HTTP proxy. After
      * Curl_proxyCONNECT we have to set back the member to the original struct
      * FTP pointer
      */
     struct HTTP http_proxy;
-    struct FTP *ftp_save = data->reqdata.proto.ftp;
+    struct FTP *ftp_save = data->state.proto.ftp;
     memset(&http_proxy, 0, sizeof(http_proxy));
-    data->reqdata.proto.http = &http_proxy;
+    data->state.proto.http = &http_proxy;
 
     result = Curl_proxyCONNECT(conn, SECONDARYSOCKET, newhost, newport);
 
-    data->reqdata.proto.ftp = ftp_save;
+    data->state.proto.ftp = ftp_save;
 
     if(CURLE_OK != result)
       return result;
   }
 #endif   /* CURL_DISABLE_HTTP */
 
@@ -1933,13 +1951,13 @@
   ftpport fcmd = (ftpport)ftpc->count1;
   CURLcode result = CURLE_OK;
 
   if(ftpcode != 200) {
     /* the command failed */
 
-    if (EPRT == fcmd) {
+    if(EPRT == fcmd) {
       infof(data, "disabling EPRT usage\n");
       conn->bits.ftp_use_eprt = FALSE;
     }
     fcmd++;
 
     if(fcmd == DONE) {
@@ -1960,13 +1978,13 @@
 
 static CURLcode ftp_state_mdtm_resp(struct connectdata *conn,
                                     int ftpcode)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data=conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   switch(ftpcode) {
   case 213:
     {
       /* we got a time. Format should be: "YYYYMMDDHHMMSS[.sss]" where the
@@ -2092,76 +2110,76 @@
 
 static CURLcode ftp_state_post_retr_size(struct connectdata *conn,
                                          curl_off_t filesize)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data=conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
-  if (data->set.max_filesize && (filesize > data->set.max_filesize)) {
+  if(data->set.max_filesize && (filesize > data->set.max_filesize)) {
     failf(data, "Maximum file size exceeded");
     return CURLE_FILESIZE_EXCEEDED;
   }
   ftp->downloadsize = filesize;
 
-  if(data->reqdata.resume_from) {
+  if(data->state.resume_from) {
     /* We always (attempt to) get the size of downloads, so it is done before
        this even when not doing resumes. */
     if(filesize == -1) {
       infof(data, "ftp server doesn't support SIZE\n");
       /* We couldn't get the size and therefore we can't know if there really
          is a part of the file left to get, although the server will just
          close the connection when we start the connection so it won't cause
          us any harm, just not make us exit as nicely. */
     }
     else {
       /* We got a file size report, so we check that there actually is a
          part of the file left to get, or else we go home.  */
-      if(data->reqdata.resume_from< 0) {
+      if(data->state.resume_from< 0) {
         /* We're supposed to download the last abs(from) bytes */
-        if(filesize < -data->reqdata.resume_from) {
+        if(filesize < -data->state.resume_from) {
           failf(data, "Offset (%" FORMAT_OFF_T
                 ") was beyond file size (%" FORMAT_OFF_T ")",
-                data->reqdata.resume_from, filesize);
+                data->state.resume_from, filesize);
           return CURLE_BAD_DOWNLOAD_RESUME;
         }
         /* convert to size to download */
-        ftp->downloadsize = -data->reqdata.resume_from;
+        ftp->downloadsize = -data->state.resume_from;
         /* download from where? */
-        data->reqdata.resume_from = filesize - ftp->downloadsize;
+        data->state.resume_from = filesize - ftp->downloadsize;
       }
       else {
-        if(filesize < data->reqdata.resume_from) {
+        if(filesize < data->state.resume_from) {
           failf(data, "Offset (%" FORMAT_OFF_T
                 ") was beyond file size (%" FORMAT_OFF_T ")",
-                data->reqdata.resume_from, filesize);
+                data->state.resume_from, filesize);
           return CURLE_BAD_DOWNLOAD_RESUME;
         }
         /* Now store the number of bytes we are expected to download */
-        ftp->downloadsize = filesize-data->reqdata.resume_from;
+        ftp->downloadsize = filesize-data->state.resume_from;
       }
     }
 
     if(ftp->downloadsize == 0) {
       /* no data to transfer */
       result = Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
       infof(data, "File already completely downloaded\n");
 
-      /* Set ->transfer so that we won't get any error in Curl_ftp_done()
+      /* Set ->transfer so that we won't get any error in ftp_done()
        * because we didn't transfer the any file */
       ftp->transfer = FTPTRANSFER_NONE;
       state(conn, FTP_STOP);
       return CURLE_OK;
     }
 
     /* Set resume file transfer offset */
     infof(data, "Instructs server to resume from offset %" FORMAT_OFF_T
-          "\n", data->reqdata.resume_from);
+          "\n", data->state.resume_from);
 
-    NBFTPSENDF(conn, "REST %" FORMAT_OFF_T, data->reqdata.resume_from);
+    NBFTPSENDF(conn, "REST %" FORMAT_OFF_T, data->state.resume_from);
 
     state(conn, FTP_RETR_REST);
 
   }
   else {
     /* no resume */
@@ -2199,13 +2217,13 @@
   }
   else if(instate == FTP_RETR_SIZE) {
     Curl_pgrsSetDownloadSize(data, filesize);
     result = ftp_state_post_retr_size(conn, filesize);
   }
   else if(instate == FTP_STOR_SIZE) {
-    data->reqdata.resume_from = filesize;
+    data->state.resume_from = filesize;
     result = ftp_state_ul_setup(conn, TRUE);
   }
 
   return result;
 }
 
@@ -2217,24 +2235,24 @@
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   switch(instate) {
   case FTP_REST:
   default:
 #ifdef CURL_FTP_HTTPSTYLE_HEAD
-    if (ftpcode == 350) {
+    if(ftpcode == 350) {
       char buffer[24]= { "Accept-ranges: bytes\r\n" };
       result = Curl_client_write(conn, CLIENTWRITE_BOTH, buffer, 0);
       if(result)
         return result;
     }
 #endif
     result = ftp_state_post_rest(conn);
     break;
 
   case FTP_RETR_REST:
-    if (ftpcode != 350) {
+    if(ftpcode != 350) {
       failf(conn->data, "Couldn't use REST");
       result = CURLE_FTP_COULDNT_USE_REST;
     }
     else {
       NBFTPSENDF(conn, "RETR %s", ftpc->file);
       state(conn, FTP_RETR);
@@ -2247,13 +2265,13 @@
 
 static CURLcode ftp_state_stor_resp(struct connectdata *conn,
                                     int ftpcode)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data = conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
 
   if(ftpcode>=400) {
     failf(data, "Failed FTP upload: %0d", ftpcode);
     /* oops, we never close the sockets! */
     return CURLE_UPLOAD_FAILED;
   }
@@ -2294,13 +2312,13 @@
 static CURLcode ftp_state_get_resp(struct connectdata *conn,
                                     int ftpcode,
                                     ftpstate instate)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data = conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   char *buf = data->state.buffer;
 
   if((ftpcode == 150) || (ftpcode == 125)) {
 
     /*
       A;
@@ -2381,16 +2399,16 @@
       infof(data, "Doing the SSL/TLS handshake on the data stream\n");
       result = Curl_ssl_connect(conn, SECONDARYSOCKET);
       if(result)
         return result;
     }
 
-    if(size > data->reqdata.maxdownload && data->reqdata.maxdownload > 0)
-      size = data->reqdata.size = data->reqdata.maxdownload;
+    if(size > data->req.maxdownload && data->req.maxdownload > 0)
+      size = data->req.size = data->req.maxdownload;
 
-    infof(data, "Maxdownload = %" FORMAT_OFF_T "\n", data->reqdata.maxdownload);
+    infof(data, "Maxdownload = %" FORMAT_OFF_T "\n", data->req.maxdownload);
 
     if(instate != FTP_LIST)
       infof(data, "Getting file with size: %" FORMAT_OFF_T "\n", size);
 
     /* FTP download: */
     result=Curl_setup_transfer(conn, SECONDARYSOCKET, size, FALSE,
@@ -2462,13 +2480,13 @@
 static CURLcode ftp_state_user_resp(struct connectdata *conn,
                                     int ftpcode,
                                     ftpstate instate)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data = conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   (void)instate; /* no use for this yet */
 
   /* some need password anyway, and others just return 2xx ignored */
   if((ftpcode == 331) && (ftpc->state == FTP_USER)) {
     /* 331 Password required for ...
@@ -2494,13 +2512,13 @@
   else {
     /* All other response codes, like:
 
     530 User ... access denied
     (the server denies to log the specified user) */
 
-    if (conn->data->set.str[STRING_FTP_ALTERNATIVE_TO_USER] &&
+    if(conn->data->set.str[STRING_FTP_ALTERNATIVE_TO_USER] &&
         !conn->data->state.ftp_trying_alternative) {
       /* Ok, USER failed.  Let's try the supplied command. */
       NBFTPSENDF(conn, "%s",
                  conn->data->set.str[STRING_FTP_ALTERNATIVE_TO_USER]);
       conn->data->state.ftp_trying_alternative = TRUE;
       state(conn, FTP_USER);
@@ -2609,13 +2627,13 @@
           break;
         case CURLFTPAUTH_TLS:
           ftpc->count2 = -1; /* subtract one to get next */
           ftpc->count1 = 1;
           break;
         default:
-          failf(data, "unsupported parameter to CURLOPT_FTPSSLAUTH: %d\n",
+          failf(data, "unsupported parameter to CURLOPT_FTPSSLAUTH: %d",
                 data->set.ftpsslauth);
           return CURLE_FAILED_INIT; /* we don't know what to do */
         }
         NBFTPSENDF(conn, "AUTH %s", ftpauth[ftpc->count1]);
         state(conn, FTP_AUTH);
       }
@@ -2718,13 +2736,13 @@
         if(result)
           return result;
       }
       break;
 
     case FTP_CCC:
-      if (ftpcode < 500) {
+      if(ftpcode < 500) {
         /* First shut down the SSL layer (note: this call will block) */
         result = Curl_ssl_shutdown(conn, FIRSTSOCKET);
 
         if(result) {
           failf(conn->data, "Failed to clear the command channel (CCC)");
           return result;
@@ -2926,13 +2944,13 @@
 
   return timeout_ms;
 }
 
 
 /* called repeatedly until done from multi.c */
-static CURLcode Curl_ftp_multi_statemach(struct connectdata *conn,
+static CURLcode ftp_multi_statemach(struct connectdata *conn,
                                          bool *done)
 {
   curl_socket_t sock = conn->sock[FIRSTSOCKET];
   int rc;
   struct SessionHandle *data=conn->data;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
@@ -2944,14 +2962,14 @@
   if(timeout_ms <= 0) {
     failf(data, "FTP response timeout");
     return CURLE_OPERATION_TIMEDOUT;
   }
 
   rc = Curl_socket_ready(ftpc->sendleft?CURL_SOCKET_BAD:sock, /* reading */
-                   ftpc->sendleft?sock:CURL_SOCKET_BAD, /* writing */
-                   0);
+                         ftpc->sendleft?sock:CURL_SOCKET_BAD, /* writing */
+                         0);
 
   if(rc == -1) {
     failf(data, "select/poll error");
     return CURLE_OUT_OF_MEMORY;
   }
   else if(rc != 0) {
@@ -2977,14 +2995,14 @@
     if(timeout_ms <=0 ) {
       failf(data, "FTP response timeout");
       return CURLE_OPERATION_TIMEDOUT; /* already too little time */
     }
 
     rc = Curl_socket_ready(ftpc->sendleft?CURL_SOCKET_BAD:sock, /* reading */
-                     ftpc->sendleft?sock:CURL_SOCKET_BAD, /* writing */
-                     (int)timeout_ms);
+                           ftpc->sendleft?sock:CURL_SOCKET_BAD, /* writing */
+                           (int)timeout_ms);
 
     if(rc == -1) {
       failf(data, "select/poll error");
       return CURLE_OUT_OF_MEMORY;
     }
     else if(rc == 0) {
@@ -3006,42 +3024,42 @@
  * need be.
  */
 static CURLcode ftp_init(struct connectdata *conn)
 {
   struct SessionHandle *data = conn->data;
   struct FTP *ftp;
-  if(data->reqdata.proto.ftp)
+  if(data->state.proto.ftp)
     return CURLE_OK;
 
   ftp = (struct FTP *)calloc(sizeof(struct FTP), 1);
   if(!ftp)
     return CURLE_OUT_OF_MEMORY;
 
-  data->reqdata.proto.ftp = ftp;
+  data->state.proto.ftp = ftp;
 
   /* get some initial data into the ftp struct */
-  ftp->bytecountp = &data->reqdata.keep.bytecount;
+  ftp->bytecountp = &data->req.bytecount;
 
   /* no need to duplicate them, this connectdata struct won't change */
   ftp->user = conn->user;
   ftp->passwd = conn->passwd;
-  if (isBadFtpString(ftp->user) || isBadFtpString(ftp->passwd))
+  if(isBadFtpString(ftp->user) || isBadFtpString(ftp->passwd))
     return CURLE_URL_MALFORMAT;
 
   return CURLE_OK;
 }
 
 /*
- * Curl_ftp_connect() should do everything that is to be considered a part of
+ * ftp_connect() should do everything that is to be considered a part of
  * the connection phase.
  *
  * The variable 'done' points to will be TRUE if the protocol-layer connect
  * phase is done when this function returns, or FALSE is not. When called as
  * a part of the easy interface, it will always be TRUE.
  */
-static CURLcode Curl_ftp_connect(struct connectdata *conn,
+static CURLcode ftp_connect(struct connectdata *conn,
                                  bool *done) /* see description above */
 {
   CURLcode result;
 #ifndef CURL_DISABLE_HTTP
   /* for FTP over HTTP proxy */
   struct HTTP http_proxy;
@@ -3063,30 +3081,30 @@
   /* We always support persistant connections on ftp */
   conn->bits.close = FALSE;
 
   ftpc->response_time = 3600000; /* set default response time-out */
 
 #ifndef CURL_DISABLE_HTTP
-  if (conn->bits.tunnel_proxy && conn->bits.httpproxy) {
+  if(conn->bits.tunnel_proxy && conn->bits.httpproxy) {
     /* BLOCKING */
     /* We want "seamless" FTP operations through HTTP proxy tunnel */
 
     /* Curl_proxyCONNECT is based on a pointer to a struct HTTP at the member
      * conn->proto.http; we want FTP through HTTP and we have to change the
      * member temporarily for connecting to the HTTP proxy. After
      * Curl_proxyCONNECT we have to set back the member to the original struct
      * FTP pointer
      */
-    ftp_save = data->reqdata.proto.ftp;
+    ftp_save = data->state.proto.ftp;
     memset(&http_proxy, 0, sizeof(http_proxy));
-    data->reqdata.proto.http = &http_proxy;
+    data->state.proto.http = &http_proxy;
 
     result = Curl_proxyCONNECT(conn, FIRSTSOCKET,
                                conn->host.name, conn->remote_port);
 
-    data->reqdata.proto.ftp = ftp_save;
+    data->state.proto.ftp = ftp_save;
 
     if(CURLE_OK != result)
       return result;
   }
 #endif   /* CURL_DISABLE_HTTP */
 
@@ -3103,44 +3121,43 @@
      response */
   ftp_respinit(conn); /* init the response reader stuff */
   state(conn, FTP_WAIT220);
   ftpc->response = Curl_tvnow(); /* start response time-out now! */
 
   if(data->state.used_interface == Curl_if_multi)
-    result = Curl_ftp_multi_statemach(conn, done);
+    result = ftp_multi_statemach(conn, done);
   else {
     result = ftp_easy_statemach(conn);
     if(!result)
       *done = TRUE;
   }
 
   return result;
 }
 
 /***********************************************************************
  *
- * Curl_ftp_done()
+ * ftp_done()
  *
  * The DONE function. This does what needs to be done after a single DO has
  * performed.
  *
  * Input argument is already checked for validity.
  */
-static CURLcode Curl_ftp_done(struct connectdata *conn, CURLcode status,
+static CURLcode ftp_done(struct connectdata *conn, CURLcode status,
                               bool premature)
 {
   struct SessionHandle *data = conn->data;
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   ssize_t nread;
   int ftpcode;
   CURLcode result=CURLE_OK;
   bool was_ctl_valid = ftpc->ctl_valid;
   char *path;
-  char *path_to_use = data->reqdata.path;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  char *path_to_use = data->state.path;
 
   if(!ftp)
     /* When the easy handle is removed from the multi while libcurl is still
      * trying to resolve the host name, it seems that the ftp struct is not
      * yet initialized, but the removal action calls Curl_done() which calls
      * this function. So we simply return success if no ftp pointer is set.
@@ -3156,13 +3173,13 @@
   case CURLE_UPLOAD_FAILED:
   case CURLE_REMOTE_ACCESS_DENIED:
   case CURLE_FILESIZE_EXCEEDED:
     /* the connection stays alive fine even though this happened */
     /* fall-through */
   case CURLE_OK: /* doesn't affect the control connection's status */
-    if (!premature) {
+    if(!premature) {
       ftpc->ctl_valid = was_ctl_valid;
       break;
     }
     /* until we cope better with prematurely ended requests, let them
      * fallback as if in complete failure */
   default:       /* by default, an error means the control connection is
@@ -3278,28 +3295,30 @@
             " out of %" FORMAT_OFF_T " bytes)",
             *ftp->bytecountp, data->set.infilesize);
       result = CURLE_PARTIAL_FILE;
     }
   }
   else {
-    if((-1 != k->size) && (k->size != *ftp->bytecountp) &&
+    if((-1 != data->req.size) &&
+       (data->req.size != *ftp->bytecountp) &&
 #ifdef CURL_DO_LINEEND_CONV
        /* Most FTP servers don't adjust their file SIZE response for CRLFs, so
         * we'll check to see if the discrepancy can be explained by the number
         * of CRLFs we've changed to LFs.
         */
-       ((k->size + data->state.crlf_conversions) != *ftp->bytecountp) &&
+       ((data->req.size + data->state.crlf_conversions) !=
+        *ftp->bytecountp) &&
 #endif /* CURL_DO_LINEEND_CONV */
-       (k->maxdownload != *ftp->bytecountp)) {
+       (data->req.maxdownload != *ftp->bytecountp)) {
       failf(data, "Received only partial file: %" FORMAT_OFF_T " bytes",
             *ftp->bytecountp);
       result = CURLE_PARTIAL_FILE;
     }
     else if(!ftpc->dont_check &&
             !*ftp->bytecountp &&
-            (k->size>0)) {
+            (data->req.size>0)) {
       failf(data, "No data was received!");
       result = CURLE_FTP_COULDNT_RETR_FILE;
     }
   }
 
   /* clear these for next connection */
@@ -3327,21 +3346,21 @@
   struct curl_slist *item;
   ssize_t nread;
   int ftpcode;
   CURLcode result;
 
   item = quote;
-  while (item) {
-    if (item->data) {
+  while(item) {
+    if(item->data) {
       FTPSENDF(conn, "%s", item->data);
 
       result = Curl_GetFTPResponse(&nread, conn, &ftpcode);
-      if (result)
+      if(result)
         return result;
 
-      if (ftpcode >= 400) {
+      if(ftpcode >= 400) {
         failf(conn->data, "QUOT string not accepted: %s", item->data);
         return CURLE_QUOTE_ERROR;
       }
     }
 
     item = item->next;
@@ -3374,13 +3393,13 @@
                             bool ascii, ftpstate newstate)
 {
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   CURLcode result;
   char want = (char)(ascii?'A':'I');
 
-  if (ftpc->transfertype == want) {
+  if(ftpc->transfertype == want) {
     state(conn, newstate);
     return ftp_state_type_resp(conn, 200, newstate);
   }
 
   NBFTPSENDF(conn, "TYPE %c", want);
   state(conn, newstate);
@@ -3423,80 +3442,80 @@
   curl_off_t totalsize=-1;
   char *ptr;
   char *ptr2;
   struct SessionHandle *data = conn->data;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
-  if(data->reqdata.use_range && data->reqdata.range) {
-    from=curlx_strtoofft(data->reqdata.range, &ptr, 0);
+  if(data->state.use_range && data->state.range) {
+    from=curlx_strtoofft(data->state.range, &ptr, 0);
     while(ptr && *ptr && (ISSPACE(*ptr) || (*ptr=='-')))
       ptr++;
     to=curlx_strtoofft(ptr, &ptr2, 0);
     if(ptr == ptr2) {
       /* we didn't get any digit */
       to=-1;
     }
     if((-1 == to) && (from>=0)) {
       /* X - */
-      data->reqdata.resume_from = from;
+      data->state.resume_from = from;
       DEBUGF(infof(conn->data, "FTP RANGE %" FORMAT_OFF_T " to end of file\n",
                    from));
     }
     else if(from < 0) {
       /* -Y */
       totalsize = -from;
-      data->reqdata.maxdownload = -from;
-      data->reqdata.resume_from = from;
+      data->req.maxdownload = -from;
+      data->state.resume_from = from;
       DEBUGF(infof(conn->data, "FTP RANGE the last %" FORMAT_OFF_T " bytes\n",
                    totalsize));
     }
     else {
       /* X-Y */
       totalsize = to-from;
-      data->reqdata.maxdownload = totalsize+1; /* include last byte */
-      data->reqdata.resume_from = from;
+      data->req.maxdownload = totalsize+1; /* include last byte */
+      data->state.resume_from = from;
       DEBUGF(infof(conn->data, "FTP RANGE from %" FORMAT_OFF_T
                    " getting %" FORMAT_OFF_T " bytes\n",
-                   from, data->reqdata.maxdownload));
+                   from, data->req.maxdownload));
     }
     DEBUGF(infof(conn->data, "range-download from %" FORMAT_OFF_T
                  " to %" FORMAT_OFF_T ", totally %" FORMAT_OFF_T " bytes\n",
-                 from, to, data->reqdata.maxdownload));
+                 from, to, data->req.maxdownload));
     ftpc->dont_check = TRUE; /* dont check for successful transfer */
   }
   else
-    data->reqdata.maxdownload = -1;
+    data->req.maxdownload = -1;
   return CURLE_OK;
 }
 
 
 /*
- * Curl_ftp_nextconnect()
+ * ftp_nextconnect()
  *
  * This function shall be called when the second FTP (data) connection is
  * connected.
  */
 
-static CURLcode Curl_ftp_nextconnect(struct connectdata *conn)
+static CURLcode ftp_nextconnect(struct connectdata *conn)
 {
   struct SessionHandle *data=conn->data;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   CURLcode result = CURLE_OK;
 
-  /* the ftp struct is inited in Curl_ftp_connect() */
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  /* the ftp struct is inited in ftp_connect() */
+  struct FTP *ftp = data->state.proto.ftp;
 
   DEBUGF(infof(data, "DO-MORE phase starts\n"));
 
   if(ftp->transfer <= FTPTRANSFER_INFO) {
     /* a transfer is about to take place, or if not a file name was given
        so we'll do a SIZE on it later and then we need the right TYPE first */
 
     if(data->set.upload) {
       result = ftp_nb_type(conn, data->set.prefer_ascii, FTP_STOR_TYPE);
-      if (result)
+      if(result)
         return result;
     }
     else {
       /* download */
       ftp->downloadsize = -1; /* unknown as of yet */
 
@@ -3508,30 +3527,30 @@
            is a directory that is requested, use LIST. But before that we
            need to set ASCII transfer mode. */
 
         /* But only if a body transfer was requested. */
         if(ftp->transfer == FTPTRANSFER_BODY) {
           result = ftp_nb_type(conn, 1, FTP_LIST_TYPE);
-          if (result)
+          if(result)
             return result;
         }
         /* otherwise just fall through */
       }
       else {
         result = ftp_nb_type(conn, data->set.prefer_ascii, FTP_RETR_TYPE);
-        if (result)
+        if(result)
           return result;
       }
     }
     result = ftp_easy_statemach(conn);
   }
 
-  if(ftp->transfer != FTPTRANSFER_BODY)
+  if((result == CURLE_OK) && (ftp->transfer != FTPTRANSFER_BODY))
     /* no data to transfer. FIX: it feels like a kludge to have this here
        too! */
-    result=Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
+    result = Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
 
   /* end of transfer */
   DEBUGF(infof(data, "DO-MORE phase ends with %d\n", result));
 
   return result;
 }
@@ -3555,13 +3574,13 @@
   CURLcode result=CURLE_OK;
 
   DEBUGF(infof(conn->data, "DO phase starts\n"));
 
   if(conn->bits.no_body) {
     /* requested no body means no transfer... */
-    struct FTP *ftp = conn->data->reqdata.proto.ftp;
+    struct FTP *ftp = conn->data->state.proto.ftp;
     ftp->transfer = FTPTRANSFER_INFO;
   }
 
 
   *dophase_done = FALSE; /* not done yet */
 
@@ -3569,13 +3588,13 @@
   result = ftp_state_quote(conn, TRUE, FTP_QUOTE);
   if(result)
     return result;
 
   /* run the state-machine */
   if(conn->data->state.used_interface == Curl_if_multi)
-    result = Curl_ftp_multi_statemach(conn, dophase_done);
+    result = ftp_multi_statemach(conn, dophase_done);
   else {
     result = ftp_easy_statemach(conn);
     *dophase_done = TRUE; /* with the easy interface we are done here */
   }
   *connected = conn->bits.tcpconnect;
 
@@ -3584,38 +3603,38 @@
 
   return result;
 }
 
 /***********************************************************************
  *
- * Curl_ftp()
+ * ftp_do()
  *
  * This function is registered as 'curl_do' function. It decodes the path
  * parts etc as a wrapper to the actual DO function (ftp_perform).
  *
  * The input argument is already checked for validity.
  */
-static CURLcode Curl_ftp(struct connectdata *conn, bool *done)
+static CURLcode ftp_do(struct connectdata *conn, bool *done)
 {
   CURLcode retcode = CURLE_OK;
 
   *done = FALSE; /* default to false */
 
   /*
     Since connections can be re-used between SessionHandles, this might be a
     connection already existing but on a fresh SessionHandle struct so we must
     make sure we have a good 'struct FTP' to play with. For new connections,
-    the struct FTP is allocated and setup in the Curl_ftp_connect() function.
+    the struct FTP is allocated and setup in the ftp_connect() function.
   */
   Curl_reset_reqproto(conn);
   retcode = ftp_init(conn);
   if(retcode)
     return retcode;
 
   retcode = ftp_parse_url_path(conn);
-  if (retcode)
+  if(retcode)
     return retcode;
 
   retcode = ftp_regular_transfer(conn, done);
 
   return retcode;
 }
@@ -3784,18 +3803,18 @@
 
   return result;
 }
 
 /***********************************************************************
  *
- * Curl_ftp_disconnect()
+ * ftp_disconnect()
  *
  * Disconnect from an FTP server. Cleanup protocol-specific per-connection
  * resources. BLOCKING.
  */
-static CURLcode Curl_ftp_disconnect(struct connectdata *conn)
+static CURLcode ftp_disconnect(struct connectdata *conn)
 {
   struct ftp_conn *ftpc= &conn->proto.ftpc;
 
   /* We cannot send quit unconditionally. If this connection is stale or
      bad in any way, sending quit and waiting around here will make the
      disconnect wait in vain and cause more problems than we need to.
@@ -3806,13 +3825,13 @@
 
   /* The FTP session may or may not have been allocated/setup at this point! */
   (void)ftp_quit(conn); /* ignore errors on the QUIT */
 
   if(ftpc->entrypath) {
     struct SessionHandle *data = conn->data;
-    if (data->state.most_recent_ftp_entrypath == ftpc->entrypath) {
+    if(data->state.most_recent_ftp_entrypath == ftpc->entrypath) {
       data->state.most_recent_ftp_entrypath = NULL;
     }
     free(ftpc->entrypath);
     ftpc->entrypath = NULL;
   }
   if(ftpc->cache) {
@@ -3837,17 +3856,17 @@
  */
 static
 CURLcode ftp_parse_url_path(struct connectdata *conn)
 {
   struct SessionHandle *data = conn->data;
   /* the ftp struct is already inited in ftp_connect() */
-  struct FTP *ftp = data->reqdata.proto.ftp;
+  struct FTP *ftp = data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
   size_t dlen;
   char *slash_pos;  /* position of the first '/' char in curpos */
-  char *path_to_use = data->reqdata.path;
+  char *path_to_use = data->state.path;
   char *cur_pos;
 
   cur_pos = path_to_use; /* current position in path. point at the begin
                             of next path component */
 
   ftpc->ctl_valid = FALSE;
@@ -3861,16 +3880,16 @@
       The best time to check whether the path is a file or directory is right
       here. so:
 
       the first condition in the if() right here, is there just in case
       someone decides to set path to NULL one day
    */
-    if(data->reqdata.path &&
-       data->reqdata.path[0] &&
-       (data->reqdata.path[strlen(data->reqdata.path) - 1] != '/') )
-      ftpc->file = data->reqdata.path;  /* this is a full file path */
+    if(data->state.path &&
+       data->state.path[0] &&
+       (data->state.path[strlen(data->state.path) - 1] != '/') )
+      ftpc->file = data->state.path;  /* this is a full file path */
     else
       ftpc->file = NULL;
       /*
         ftpc->file is not used anywhere other than for operations on a file.
         In other words, never for directory operations.
         So we can safely set it to NULL here and use it as a
@@ -3919,31 +3938,31 @@
       cur_pos++; /* make it point to the zero byte */
       ftpc->dirs[0] = strdup("/");
       ftpc->dirdepth++;
     }
     else {
       /* parse the URL path into separate path components */
-      while ((slash_pos = strchr(cur_pos, '/')) != NULL) {
+      while((slash_pos = strchr(cur_pos, '/')) != NULL) {
         /* 1 or 0 to indicate absolute directory */
-        bool absolute_dir = (bool)((cur_pos - data->reqdata.path > 0) &&
+        bool absolute_dir = (bool)((cur_pos - data->state.path > 0) &&
                                    (ftpc->dirdepth == 0));
 
         /* seek out the next path component */
-        if (slash_pos-cur_pos) {
+        if(slash_pos-cur_pos) {
           /* we skip empty path components, like "x//y" since the FTP command
              CWD requires a parameter and a non-existant parameter a) doesn't
              work on many servers and b) has no effect on the others. */
           int len = (int)(slash_pos - cur_pos + absolute_dir);
           ftpc->dirs[ftpc->dirdepth] =
             curl_easy_unescape(conn->data, cur_pos - absolute_dir, len, NULL);
-          if (!ftpc->dirs[ftpc->dirdepth]) { /* run out of memory ... */
+          if(!ftpc->dirs[ftpc->dirdepth]) { /* run out of memory ... */
             failf(data, "no memory");
             freedirs(ftpc);
             return CURLE_OUT_OF_MEMORY;
           }
-          if (isBadFtpString(ftpc->dirs[ftpc->dirdepth])) {
+          if(isBadFtpString(ftpc->dirs[ftpc->dirdepth])) {
             free(ftpc->dirs[ftpc->dirdepth]);
             freedirs(ftpc);
             return CURLE_URL_MALFORMAT;
           }
         }
         else {
@@ -3972,13 +3991,13 @@
     ftpc->file = curl_easy_unescape(conn->data, ftpc->file, 0, NULL);
     if(NULL == ftpc->file) {
       freedirs(ftpc);
       failf(data, "no memory");
       return CURLE_OUT_OF_MEMORY;
     }
-    if (isBadFtpString(ftpc->file)) {
+    if(isBadFtpString(ftpc->file)) {
       freedirs(ftpc);
       return CURLE_URL_MALFORMAT;
     }
   }
   else
     ftpc->file=NULL; /* instead of point to a zero byte, we make it a NULL
@@ -3992,13 +4011,13 @@
 
   ftpc->cwddone = FALSE; /* default to not done */
 
   if(ftpc->prevpath) {
     /* prevpath is "raw" so we convert the input path before we compare the
        strings */
-    char *path = curl_easy_unescape(conn->data, data->reqdata.path, 0, NULL);
+    char *path = curl_easy_unescape(conn->data, data->state.path, 0, NULL);
     if(!path) {
       freedirs(ftpc);
       return CURLE_OUT_OF_MEMORY;
     }
 
     dlen = strlen(path) - (ftpc->file?strlen(ftpc->file):0);
@@ -4015,17 +4034,17 @@
 
 /* call this when the DO phase has completed */
 static CURLcode ftp_dophase_done(struct connectdata *conn,
                                  bool connected)
 {
   CURLcode result = CURLE_OK;
-  struct FTP *ftp = conn->data->reqdata.proto.ftp;
+  struct FTP *ftp = conn->data->state.proto.ftp;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
 
   if(connected)
-    result = Curl_ftp_nextconnect(conn);
+    result = ftp_nextconnect(conn);
 
   if(result && (conn->sock[SECONDARYSOCKET] != CURL_SOCKET_BAD)) {
     /* Failure detected, close the second socket if it was created already */
     sclose(conn->sock[SECONDARYSOCKET]);
     conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD;
     return result;
@@ -4041,17 +4060,17 @@
   ftpc->ctl_valid = TRUE; /* seems good */
 
   return result;
 }
 
 /* called from multi.c while DOing */
-static CURLcode Curl_ftp_doing(struct connectdata *conn,
+static CURLcode ftp_doing(struct connectdata *conn,
                                bool *dophase_done)
 {
   CURLcode result;
-  result = Curl_ftp_multi_statemach(conn, dophase_done);
+  result = ftp_multi_statemach(conn, dophase_done);
 
   if(*dophase_done) {
     result = ftp_dophase_done(conn, FALSE /* not connected */);
 
     DEBUGF(infof(conn->data, "DO phase is complete\n"));
   }
@@ -4065,23 +4084,23 @@
  * The input argument is already checked for validity.
  *
  * Performs all commands done before a regular transfer between a local and a
  * remote host.
  *
  * ftp->ctl_valid starts out as FALSE, and gets set to TRUE if we reach the
- * Curl_ftp_done() function without finding any major problem.
+ * ftp_done() function without finding any major problem.
  */
 static
 CURLcode ftp_regular_transfer(struct connectdata *conn,
                               bool *dophase_done)
 {
   CURLcode result=CURLE_OK;
   bool connected=0;
   struct SessionHandle *data = conn->data;
   struct ftp_conn *ftpc = &conn->proto.ftpc;
-  data->reqdata.size = -1; /* make sure this is unknown at this point */
+  data->req.size = -1; /* make sure this is unknown at this point */
 
   Curl_pgrsSetUploadCounter(data, 0);
   Curl_pgrsSetDownloadCounter(data, 0);
   Curl_pgrsSetUploadSize(data, 0);
   Curl_pgrsSetDownloadSize(data, 0);
 
@@ -4104,23 +4123,23 @@
   else
     freedirs(ftpc);
 
   return result;
 }
 
-static CURLcode Curl_ftp_setup_connection(struct connectdata * conn)
+static CURLcode ftp_setup_connection(struct connectdata * conn)
 {
   struct SessionHandle *data = conn->data;
   char * type;
   char command;
 
   if(conn->bits.httpproxy && !data->set.tunnel_thru_httpproxy) {
     /* Unless we have asked to tunnel ftp operations through the proxy, we
        switch and use HTTP operations only */
 #ifndef CURL_DISABLE_HTTP
-    if (conn->handler == &Curl_handler_ftp)
+    if(conn->handler == &Curl_handler_ftp)
       conn->handler = &Curl_handler_ftp_proxy;
     else {
 #ifdef USE_SSL
       conn->handler = &Curl_handler_ftps_proxy;
 #else
       failf(data, "FTPS not supported!");
@@ -4131,22 +4150,22 @@
 #else
     failf(data, "FTP over http proxy requires HTTP support built-in!");
     return CURLE_UNSUPPORTED_PROTOCOL;
 #endif
   }
 
-  data->reqdata.path++;   /* don't include the initial slash */
+  data->state.path++;   /* don't include the initial slash */
 
   /* FTP URLs support an extension like ";type=<typecode>" that
    * we'll try to get now! */
-  type = strstr(data->reqdata.path, ";type=");
+  type = strstr(data->state.path, ";type=");
 
-  if (!type)
+  if(!type)
     type = strstr(conn->host.rawalloc, ";type=");
 
-  if (type) {
+  if(type) {
     *type = 0;                     /* it was in the middle of the hostname */
     command = (char) toupper((int) type[6]);
 
     switch (command) {
     case 'A': /* ASCII mode */
       data->set.prefer_ascii = TRUE;
@@ -4165,16 +4184,16 @@
   }
 
   return CURLE_OK;
 }
 
 #ifdef USE_SSL
-static CURLcode Curl_ftps_setup_connection(struct connectdata * conn)
+static CURLcode ftps_setup_connection(struct connectdata * conn)
 {
   struct SessionHandle *data = conn->data;
 
   conn->ssl[SECONDARYSOCKET].use = data->set.ftp_ssl != CURLUSESSL_CONTROL;
-  return Curl_ftp_setup_connection(conn);
+  return ftp_setup_connection(conn);
 }
 #endif
 
 #endif /* CURL_DISABLE_FTP */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/getenv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/getenv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/getenv.c	2007-09-29 04:21:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/getenv.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getenv.c,v 1.30 2007-09-27 18:39:10 danf Exp $
+ * $Id: getenv.c,v 1.31 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -43,19 +43,19 @@
   return NULL;
 #else
 #ifdef WIN32
   char env[MAX_PATH]; /* MAX_PATH is from windef.h */
   char *temp = getenv(variable);
   env[0] = '\0';
-  if (temp != NULL)
+  if(temp != NULL)
     ExpandEnvironmentStrings(temp, env, sizeof(env));
   return (env[0] != '\0')?strdup(env):NULL;
 #else
   char *env = getenv(variable);
 #ifdef VMS
-  if (env && strcmp("HOME",variable) == 0)
+  if(env && strcmp("HOME",variable) == 0)
     env = decc$translate_vms(env);
 #endif
   return (env && env[0])?strdup(env):NULL;
 #endif
 #endif
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/getinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/getinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/getinfo.c	2007-08-02 05:20:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/getinfo.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getinfo.c,v 1.58 2007-08-01 21:20:01 bagder Exp $
+ * $Id: getinfo.c,v 1.59 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
@@ -55,13 +55,13 @@
   pro->t_redirect = 0;
 
   info->httpcode = 0;
   info->httpversion=0;
   info->filetime=-1; /* -1 is an illegal time and thus means unknown */
 
-  if (info->contenttype)
+  if(info->contenttype)
     free(info->contenttype);
   info->contenttype = NULL;
 
   info->header_size = 0;
   info->request_size = 0;
   info->numconnects = 0;
@@ -211,13 +211,13 @@
         [data->state.lastconnect];
       *param_longp = c->sock[FIRSTSOCKET];
       /* we have a socket connected, let's determine if the server shut down */
       /* determine if ssl */
       if(c->ssl[FIRSTSOCKET].use) {
         /* use the SSL context */
-        if (!Curl_ssl_check_cxn(c))
+        if(!Curl_ssl_check_cxn(c))
           *param_longp = -1;   /* FIN received */
       }
 /* Minix 3.1 doesn't support any flags on recv; just assume socket is OK */
 #ifdef MSG_PEEK
       else {
         /* use the socket */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/gtls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/gtls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/gtls.c	2007-10-03 16:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/gtls.c	2008-01-28 06:41:56.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: gtls.c,v 1.34 2007-10-03 08:07:50 bagder Exp $
+ * $Id: gtls.c,v 1.35 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 /*
  * Source file for all GnuTLS-specific code for the TLS/SSL layer. No code
  * but sslgen.c should ever call or use these functions.
  *
@@ -94,26 +94,26 @@
   return 1;
 }
 
 static int _Curl_gtls_init(void)
 {
   int ret = 1;
-  if (!gtls_inited) {
+  if(!gtls_inited) {
     ret = gnutls_global_init()?0:1;
 #ifdef GTLSDEBUG
     gnutls_global_set_log_function(tls_log_func);
     gnutls_global_set_log_level(2);
 #endif
     gtls_inited = TRUE;
   }
   return ret;
 }
 
 int Curl_gtls_cleanup(void)
 {
-  if (gtls_inited)
+  if(gtls_inited)
     gnutls_global_deinit();
   return 1;
 }
 
 static void showtime(struct SessionHandle *data,
                      const char *text,
@@ -145,13 +145,13 @@
                           gnutls_session session,
                           int sockindex,
                           bool duringconnect)
 {
   struct SessionHandle *data = conn->data;
   int rc;
-  if (!gtls_inited)
+  if(!gtls_inited)
     _Curl_gtls_init();
   do {
     rc = gnutls_handshake(session);
 
     if((rc == GNUTLS_E_AGAIN) || (rc == GNUTLS_E_INTERRUPTED)) {
       long timeout_ms = DEFAULT_CONNECT_TIMEOUT;
@@ -195,13 +195,13 @@
       }
     }
     else
       break;
   } while(1);
 
-  if (rc < 0) {
+  if(rc < 0) {
     failf(data, "gnutls_handshake() failed: %s", gnutls_strerror(rc));
     return CURLE_SSL_CONNECT_ERROR;
   }
 
   return CURLE_OK;
 }
@@ -241,13 +241,13 @@
   unsigned int bits;
   time_t clock;
   const char *ptr;
   void *ssl_sessionid;
   size_t ssl_idsize;
 
-  if (!gtls_inited) _Curl_gtls_init();
+  if(!gtls_inited) _Curl_gtls_init();
   /* GnuTLS only supports TLSv1 (and SSLv3?) */
   if(data->set.ssl.version == CURL_SSLVERSION_SSLv2) {
     failf(data, "GnuTLS does not support SSLv2");
     return CURLE_SSL_CONNECT_ERROR;
   }
 
@@ -266,13 +266,13 @@
     rc = gnutls_certificate_set_x509_trust_file(conn->ssl[sockindex].cred,
                                                 data->set.ssl.CAfile,
                                                 GNUTLS_X509_FMT_PEM);
     if(rc < 0) {
       infof(data, "error reading ca cert file %s (%s)\n",
             data->set.ssl.CAfile, gnutls_strerror(rc));
-      if (data->set.ssl.verifypeer)
+      if(data->set.ssl.verifypeer)
         return CURLE_SSL_CACERT_BADFILE;
     }
     else
       infof(data, "found %d certificates in %s\n",
             rc, data->set.ssl.CAfile);
   }
@@ -362,20 +362,20 @@
      of the gnutls_certificate_status_t enumerated elements bitwise or'd. To
      avoid denial of service attacks some default upper limits regarding the
      certificate key size and chain size are set. To override them use
      gnutls_certificate_set_verify_limits(). */
 
   rc = gnutls_certificate_verify_peers2(session, &verify_status);
-  if (rc < 0) {
+  if(rc < 0) {
     failf(data, "server cert verify failed: %d", rc);
     return CURLE_SSL_CONNECT_ERROR;
   }
 
   /* verify_status is a bitmask of gnutls_certificate_status bits */
   if(verify_status & GNUTLS_CERT_INVALID) {
-    if (data->set.ssl.verifypeer) {
+    if(data->set.ssl.verifypeer) {
       failf(data, "server certificate verification failed. CAfile: %s",
             data->set.ssl.CAfile?data->set.ssl.CAfile:"none");
       return CURLE_SSL_CACERT;
     }
     else
       infof(data, "\t server certificate verification FAILED\n");
@@ -406,13 +406,13 @@
      in RFC2818 (HTTPS), which takes into account wildcards, and the subject
      alternative name PKIX extension. Returns non zero on success, and zero on
      failure. */
   rc = gnutls_x509_crt_check_hostname(x509_cert, conn->host.name);
 
   if(!rc) {
-    if (data->set.ssl.verifyhost > 1) {
+    if(data->set.ssl.verifyhost > 1) {
       failf(data, "SSL: certificate subject name (%s) does not match "
             "target host name '%s'", certbuf, conn->host.dispname);
       gnutls_x509_crt_deinit(x509_cert);
       return CURLE_PEER_FAILED_VERIFICATION;
     }
     else
@@ -428,13 +428,13 @@
   if(clock == (time_t)-1) {
     failf(data, "server cert expiration date verify failed");
     return CURLE_SSL_CONNECT_ERROR;
   }
 
   if(clock < time(NULL)) {
-    if (data->set.ssl.verifypeer) {
+    if(data->set.ssl.verifypeer) {
       failf(data, "server certificate expiration date has passed.");
       return CURLE_PEER_FAILED_VERIFICATION;
     }
     else
       infof(data, "\t server certificate expiration date FAILED\n");
   }
@@ -446,13 +446,13 @@
   if(clock == (time_t)-1) {
     failf(data, "server cert activation date verify failed");
     return CURLE_SSL_CONNECT_ERROR;
   }
 
   if(clock > time(NULL)) {
-    if (data->set.ssl.verifypeer) {
+    if(data->set.ssl.verifypeer) {
       failf(data, "server certificate not activated yet.");
       return CURLE_PEER_FAILED_VERIFICATION;
     }
     else
       infof(data, "\t server certificate activation date FAILED\n");
   }
@@ -667,18 +667,18 @@
       return rc;
     *wouldblock = TRUE; /* then return as if this was a wouldblock */
     return -1;
   }
 
   *wouldblock = FALSE;
-  if (!ret) {
+  if(!ret) {
     failf(conn->data, "Peer closed the TLS connection");
     return -1;
   }
 
-  if (ret < 0) {
+  if(ret < 0) {
     failf(conn->data, "GnuTLS recv error (%d): %s",
           (int)ret, gnutls_strerror(ret));
     return -1;
   }
 
   return ret;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hash.c	2007-09-29 04:21:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hash.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hash.c,v 1.31 2007-09-27 18:12:03 danf Exp $
+ * $Id: hash.c,v 1.32 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -36,13 +36,13 @@
 static void
 hash_element_dtor(void *user, void *element)
 {
   struct curl_hash *h = (struct curl_hash *) user;
   struct curl_hash_element *e = (struct curl_hash_element *) element;
 
-  if (e->key)
+  if(e->key)
     free(e->key);
 
   h->dtor(e->ptr);
 
   free(e);
 }
@@ -54,13 +54,13 @@
                hash_function hfunc,
                comp_function comparator,
                curl_hash_dtor dtor)
 {
   int i;
 
-  if (!slots || !hfunc || !comparator ||!dtor) {
+  if(!slots || !hfunc || !comparator ||!dtor) {
     return 1; /* failure */
   }
 
   h->hash_func = hfunc;
   h->comp_func = comparator;
   h->dtor = dtor;
@@ -89,18 +89,18 @@
                 hash_function hfunc,
                 comp_function comparator,
                 curl_hash_dtor dtor)
 {
   struct curl_hash *h;
 
-  if (!slots || !hfunc || !comparator ||!dtor) {
+  if(!slots || !hfunc || !comparator ||!dtor) {
     return NULL; /* failure */
   }
 
   h = (struct curl_hash *) malloc(sizeof(struct curl_hash));
-  if (h) {
+  if(h) {
     if(Curl_hash_init(h, slots, hfunc, comparator, dtor)) {
       /* failure */
       free(h);
       h = NULL;
     }
   }
@@ -145,20 +145,20 @@
   struct curl_hash_element  *he;
   struct curl_llist_element *le;
   struct curl_llist *l = FETCH_LIST (h, key, key_len);
 
   for (le = l->head; le; le = le->next) {
     he = (struct curl_hash_element *) le->ptr;
-    if (h->comp_func(he->key, he->key_len, key, key_len)) {
+    if(h->comp_func(he->key, he->key_len, key, key_len)) {
       h->dtor(p);     /* remove the NEW entry */
       return he->ptr; /* return the EXISTING entry */
     }
   }
 
   he = mk_hash_element(key, key_len, p);
-  if (he) {
+  if(he) {
     if(Curl_llist_insert_next(l, l->tail, he)) {
       ++h->size;
       return p; /* return the new entry */
     }
     /*
      * Couldn't insert it, destroy the 'he' element and the key again. We
@@ -179,13 +179,13 @@
   struct curl_llist_element *le;
   struct curl_hash_element  *he;
   struct curl_llist *l = FETCH_LIST(h, key, key_len);
 
   for (le = l->head; le; le = le->next) {
     he = le->ptr;
-    if (h->comp_func(he->key, he->key_len, key, key_len)) {
+    if(h->comp_func(he->key, he->key_len, key, key_len)) {
       Curl_llist_remove(l, le, (void *) h);
       return 0;
     }
   }
   return 1;
 }
@@ -196,13 +196,13 @@
   struct curl_llist_element *le;
   struct curl_hash_element  *he;
   struct curl_llist *l = FETCH_LIST(h, key, key_len);
 
   for (le = l->head; le; le = le->next) {
     he = le->ptr;
-    if (h->comp_func(he->key, he->key_len, key, key_len)) {
+    if(h->comp_func(he->key, he->key_len, key, key_len)) {
       return he->ptr;
     }
   }
 
   return NULL;
 }
@@ -251,51 +251,51 @@
     list = h->table[i];
     le = list->head; /* get first list entry */
     while(le) {
       struct curl_hash_element *he = le->ptr;
       lnext = le->next;
       /* ask the callback function if we shall remove this entry or not */
-      if (comp(user, he->ptr)) {
+      if(comp(user, he->ptr)) {
         Curl_llist_remove(list, le, (void *) h);
         --h->size; /* one less entry in the hash now */
       }
       le = lnext;
     }
   }
 }
 
 void
 Curl_hash_destroy(struct curl_hash *h)
 {
-  if (!h)
+  if(!h)
     return;
 
   Curl_hash_clean(h);
   free(h);
 }
 
 size_t Curl_hash_str(void* key, size_t key_length, size_t slots_num)
 {
   const char* key_str = (const char *) key;
   const char *end = key_str + key_length;
   unsigned long h = 5381;
 
-  while (key_str < end) {
+  while(key_str < end) {
     h += h << 5;
     h ^= (unsigned long) *key_str++;
   }
 
   return (h % slots_num);
 }
 
 size_t Curl_str_key_compare(void*k1, size_t key1_len, void*k2, size_t key2_len)
 {
   char *key1 = (char *)k1;
   char *key2 = (char *)k2;
 
-  if (key1_len == key2_len &&
+  if(key1_len == key2_len &&
       *key1 == *key2 &&
       memcmp(key1, key2, key1_len) == 0) {
     return 1;
   }
 
   return 0;
@@ -306,13 +306,13 @@
                      void (*func)(void *))
 {
   int i;
   struct curl_llist_element *le;
   struct curl_llist *list;
   struct curl_hash_element  *he;
-  if (!h)
+  if(!h)
     return;
 
   fprintf(stderr, "=Hash dump=\n");
 
   for (i = 0; i < h->slots; i++) {
     list = h->table[i];
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostares.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostares.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostares.c	2007-10-22 22:30:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostares.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostares.c,v 1.35 2007-10-20 15:11:51 yangtse Exp $
+ * $Id: hostares.c,v 1.36 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
@@ -241,13 +241,13 @@
   else if(conn->data->set.timeout)
     timeout = conn->data->set.timeout;
   else
     timeout = CURL_TIMEOUT_RESOLVE * 1000; /* default name resolve timeout */
 
   /* Wait for the name resolve query to complete. */
-  while (1) {
+  while(1) {
     struct timeval *tvp, tv, store;
     struct timeval now = Curl_tvnow();
     long timediff;
 
     store.tv_sec = (int)timeout/1000;
     store.tv_usec = (timeout%1000)*1000;
@@ -259,13 +259,13 @@
 
     if(conn->async.done)
       break;
 
     timediff = Curl_tvdiff(Curl_tvnow(), now); /* spent time */
     timeout -= timediff?timediff:1; /* always deduct at least 1 */
-    if (timeout < 0) {
+    if(timeout < 0) {
       /* our timeout, so we cancel the ares operation */
       ares_cancel(data->state.areschannel);
       break;
     }
   }
 
@@ -313,13 +313,13 @@
   char *bufp;
   struct SessionHandle *data = conn->data;
   in_addr_t in = inet_addr(hostname);
 
   *waitp = FALSE;
 
-  if (in != CURL_INADDR_NONE) {
+  if(in != CURL_INADDR_NONE) {
     /* This is a dotted IP address 123.123.123.123-style */
     return Curl_ip2addr(in, hostname, port);
   }
 
   bufp = strdup(hostname);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip4.c	2007-07-12 05:52:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip4.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip4.c,v 1.41 2007-07-11 21:47:31 gknauf Exp $
+ * $Id: hostip4.c,v 1.42 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <errno.h>
@@ -286,21 +286,21 @@
   else {
 #if (defined(NETWARE) && !defined(__NOVELL_LIBC__))
     h = gethostbyname((char*)hostname);
 #else
     h = gethostbyname(hostname);
 #endif
-    if (!h)
+    if(!h)
       infof(conn->data, "gethostbyname(2) failed for %s\n", hostname);
 #endif /*HAVE_GETHOSTBYNAME_R */
   }
 
   if(h) {
     ai = Curl_he2ai(h, port);
 
-    if (buf) /* used a *_r() function */
+    if(buf) /* used a *_r() function */
       free(buf);
   }
 
   return ai;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip6.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip6.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip6.c	2007-07-02 06:01:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip6.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip6.c,v 1.40 2007-07-01 22:01:19 bagder Exp $
+ * $Id: hostip6.c,v 1.41 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
@@ -182,13 +182,13 @@
  */
 bool Curl_ipvalid(struct SessionHandle *data)
 {
   if(data->set.ip_version == CURL_IPRESOLVE_V6) {
     /* see if we have an IPv6 stack */
     curl_socket_t s = socket(PF_INET6, SOCK_DGRAM, 0);
-    if (s == CURL_SOCKET_BAD)
+    if(s == CURL_SOCKET_BAD)
       /* an ipv6 address was requested and we can't get/use one */
       return FALSE;
     sclose(s);
   }
   return TRUE;
 }
@@ -201,13 +201,13 @@
   printf("dump_addrinfo:\n");
   for ( ; ai; ai = ai->ai_next) {
     char  buf[INET6_ADDRSTRLEN];
 
     printf("    fam %2d, CNAME %s, ",
            ai->ai_family, ai->ai_canonname ? ai->ai_canonname : "<none>");
-    if (Curl_printable_address(ai, buf, sizeof(buf)))
+    if(Curl_printable_address(ai, buf, sizeof(buf)))
       printf("%s\n", buf);
     else
       printf("failed; %s\n", Curl_strerror(conn, SOCKERRNO));
   }
 }
 #else
@@ -238,13 +238,13 @@
   struct SessionHandle *data = conn->data;
 
   *waitp=0; /* don't wait, we have the response now */
 
   /* see if we have an IPv6 stack */
   s = socket(PF_INET6, SOCK_DGRAM, 0);
-  if (s == CURL_SOCKET_BAD) {
+  if(s == CURL_SOCKET_BAD) {
     /* Some non-IPv6 stacks have been found to make very slow name resolves
      * when PF_UNSPEC is used, so thus we switch to a mere PF_INET lookup if
      * the stack seems to be a non-ipv6 one. */
 
     pf = PF_INET;
   }
@@ -287,13 +287,13 @@
 
   if(port) {
     snprintf(sbuf, sizeof(sbuf), "%d", port);
     sbufptr=sbuf;
   }
   error = getaddrinfo(hostname, sbufptr, &hints, &res);
-  if (error) {
+  if(error) {
     infof(data, "getaddrinfo(3) failed for %s:%d\n", hostname, port);
     return NULL;
   }
 
   dump_addrinfo(conn, res);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip.c	2007-09-29 04:21:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip.c	2008-01-16 06:44:26.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip.c,v 1.187 2007-09-28 18:47:59 danf Exp $
+ * $Id: hostip.c,v 1.190 2008-01-15 22:44:12 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
@@ -124,36 +124,33 @@
 static void freednsentry(void *freethis);
 
 /*
  * Curl_global_host_cache_init() initializes and sets up a global DNS cache.
  * Global DNS cache is general badness. Do not use. This will be removed in
  * a future version. Use the share interface instead!
+ *
+ * Returns a struct curl_hash pointer on success, NULL on failure.
  */
-void Curl_global_host_cache_init(void)
+struct curl_hash *Curl_global_host_cache_init(void)
 {
-  if (!host_cache_initialized) {
-    Curl_hash_init(&hostname_cache, 7, Curl_hash_str, Curl_str_key_compare,
-                   freednsentry);
-    host_cache_initialized = 1;
+  int rc = 0;
+  if(!host_cache_initialized) {
+    rc = Curl_hash_init(&hostname_cache, 7, Curl_hash_str,
+                        Curl_str_key_compare, freednsentry);
+    if(!rc)
+      host_cache_initialized = 1;
   }
-}
-
-/*
- * Return a pointer to the global cache
- */
-struct curl_hash *Curl_global_host_cache_get(void)
-{
-  return &hostname_cache;
+  return rc?NULL:&hostname_cache;
 }
 
 /*
  * Destroy and cleanup the global DNS cache
  */
 void Curl_global_host_cache_dtor(void)
 {
-  if (host_cache_initialized) {
+  if(host_cache_initialized) {
     Curl_hash_clean(&hostname_cache);
     host_cache_initialized = 0;
   }
 }
 
 /*
@@ -215,13 +212,13 @@
 hostcache_timestamp_remove(void *datap, void *hc)
 {
   struct hostcache_prune_data *data =
     (struct hostcache_prune_data *) datap;
   struct Curl_dns_entry *c = (struct Curl_dns_entry *) hc;
 
-  if ((data->now - c->timestamp < data->cache_timeout) ||
+  if((data->now - c->timestamp < data->cache_timeout) ||
       c->inuse) {
     /* please don't remove */
     return 0;
   }
 
   /* fine, remove */
@@ -281,13 +278,13 @@
        we can't do it */
     return 0;
 
   time(&user.now);
   user.cache_timeout = data->set.dns_cache_timeout;
 
-  if ( !hostcache_timestamp_remove(&user,dns) )
+  if( !hostcache_timestamp_remove(&user,dns) )
     return 0;
 
   /* ok, we do need to clear the cache. although we need to remove just a
      single entry we clean the entire hash, as no explicit delete function
      is provided */
   if(data->share)
@@ -333,19 +330,19 @@
   struct Curl_dns_entry *dns2;
   time_t now;
 
   /* Create an entry id, based upon the hostname and port */
   entry_id = create_hostcache_id(hostname, port);
   /* If we can't create the entry id, fail */
-  if (!entry_id)
+  if(!entry_id)
     return NULL;
   entry_len = strlen(entry_id);
 
   /* Create a new cache entry */
   dns = (struct Curl_dns_entry *) calloc(sizeof(struct Curl_dns_entry), 1);
-  if (!dns) {
+  if(!dns) {
     free(entry_id);
     return NULL;
   }
 
   dns->inuse = 0;   /* init to not used */
   dns->addr = addr; /* this is the address(es) */
@@ -404,24 +401,24 @@
   *entry = NULL;
 
 #ifdef HAVE_SIGSETJMP
   /* this allows us to time-out from the name resolver, as the timeout
      will generate a signal and we will siglongjmp() from that here */
   if(!data->set.no_signal) {
-    if (sigsetjmp(curl_jmpenv, 1)) {
+    if(sigsetjmp(curl_jmpenv, 1)) {
       /* this is coming from a siglongjmp() */
       failf(data, "name lookup timed out");
       return CURLRESOLV_ERROR;
     }
   }
 #endif
 
   /* Create an entry id, based upon the hostname and port */
   entry_id = create_hostcache_id(hostname, port);
   /* If we can't create the entry id, fail */
-  if (!entry_id)
+  if(!entry_id)
     return CURLRESOLV_ERROR;
 
   entry_len = strlen(entry_id);
 
   if(data->share)
     Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE);
@@ -434,18 +431,18 @@
 
   /* free the allocated entry_id again */
   free(entry_id);
 
   /* See whether the returned entry is stale. Deliberately done after the
      locked block */
-  if ( remove_entry_if_stale(data,dns) )
+  if( remove_entry_if_stale(data,dns) )
     dns = NULL; /* the memory deallocation is being handled by the hash */
 
   rc = CURLRESOLV_ERROR; /* default to failure */
 
-  if (!dns) {
+  if(!dns) {
     /* The entry was not in the cache. Resolve it to IP address */
 
     Curl_addrinfo *addr;
     int respwait;
 
     /* Check what IP specifics the app has requested and if we can provide it.
@@ -455,13 +452,13 @@
 
     /* If Curl_getaddrinfo() returns NULL, 'respwait' might be set to a
        non-zero value indicating that we need to wait for the response to the
        resolve call */
     addr = Curl_getaddrinfo(conn, hostname, port, &respwait);
 
-    if (!addr) {
+    if(!addr) {
       if(respwait) {
         /* the response to our resolve call will come asynchronously at
            a later time, good or bad */
         /* First, check that we haven't received the info by now */
         result = Curl_is_resolved(conn, &dns);
         if(result) /* error detected */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostip.h	2007-09-29 05:48:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostip.h	2008-01-16 06:44:26.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip.h,v 1.59 2007-09-28 21:48:28 bagder Exp $
+ * $Id: hostip.h,v 1.61 2008-01-15 22:44:12 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 #include "hash.h"
 
 #ifdef NETWARE
@@ -122,17 +122,21 @@
 
 struct addrinfo;
 struct hostent;
 struct SessionHandle;
 struct connectdata;
 
-void Curl_global_host_cache_init(void);
+/*
+ * Curl_global_host_cache_init() initializes and sets up a global DNS cache.
+ * Global DNS cache is general badness. Do not use. This will be removed in
+ * a future version. Use the share interface instead!
+ *
+ * Returns a struct curl_hash pointer on success, NULL on failure.
+ */
+struct curl_hash *Curl_global_host_cache_init(void);
 void Curl_global_host_cache_dtor(void);
-struct curl_hash *Curl_global_host_cache_get(void);
-
-#define Curl_global_host_cache_use(__p) ((__p)->set.global_dns_cache)
 
 struct Curl_dns_entry {
   Curl_addrinfo *addr;
   time_t timestamp;
   long inuse;      /* use-counter, make very sure you decrease this
                       when you're done using the address you received */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostthre.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostthre.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/hostthre.c	2007-06-11 20:56:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/hostthre.c	2007-11-05 17:45:09.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostthre.c,v 1.49 2007-06-11 04:33:21 giva Exp $
+ * $Id: hostthre.c,v 1.50 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <errno.h>
@@ -107,24 +107,24 @@
 #endif
 
 #if defined(DEBUG_THREADING_GETHOSTBYNAME) || \
     defined(DEBUG_THREADING_GETADDRINFO)
 /* If this is defined, provide tracing */
 #define TRACE(args)  \
- do { trace_it("%u: ", __LINE__); trace_it args; } while (0)
+ do { trace_it("%u: ", __LINE__); trace_it args; } while(0)
 
 static void trace_it (const char *fmt, ...)
 {
   static int do_trace = -1;
   va_list args;
 
-  if (do_trace == -1) {
+  if(do_trace == -1) {
     const char *env = getenv("CURL_TRACE");
     do_trace = (env && atoi(env) > 0);
   }
-  if (!do_trace)
+  if(!do_trace)
     return;
   va_start (args, fmt);
   vfprintf (stderr, fmt, args);
   fflush (stderr);
   va_end (args);
 }
@@ -138,13 +138,13 @@
   TRACE(("dump_addrinfo:\n"));
   for ( ; ai; ai = ai->ai_next) {
     char  buf [INET6_ADDRSTRLEN];
 
     trace_it("    fam %2d, CNAME %s, ",
              ai->ai_family, ai->ai_canonname ? ai->ai_canonname : "<none>");
-    if (Curl_printable_address(ai, buf, sizeof(buf)))
+    if(Curl_printable_address(ai, buf, sizeof(buf)))
       trace_it("%s\n", buf);
     else
       trace_it("failed; %s\n", Curl_strerror(conn, SOCKERRNO));
   }
 }
 #endif
@@ -176,19 +176,19 @@
 };
 
 /* Destroy resolver thread synchronization data */
 static
 void destroy_thread_sync_data(struct thread_sync_data * tsd)
 {
-  if (tsd->hostname)
+  if(tsd->hostname)
     free(tsd->hostname);
-  if (tsd->event_terminate)
+  if(tsd->event_terminate)
     CloseHandle(tsd->event_terminate);
-  if (tsd->mutex_terminate)
+  if(tsd->mutex_terminate)
     CloseHandle(tsd->mutex_terminate);
-  if (tsd->mutex_waiting)
+  if(tsd->mutex_waiting)
     CloseHandle(tsd->mutex_waiting);
   memset(tsd,0,sizeof(*tsd));
 }
 
 /* Initialize resolver thread synchronization data */
 static
@@ -196,59 +196,59 @@
                            const char * hostname,
                            struct thread_sync_data * tsd)
 {
   HANDLE curr_proc = GetCurrentProcess();
 
   memset(tsd, 0, sizeof(*tsd));
-  if (!DuplicateHandle(curr_proc, td->mutex_waiting,
+  if(!DuplicateHandle(curr_proc, td->mutex_waiting,
                        curr_proc, &tsd->mutex_waiting, 0, FALSE,
                        DUPLICATE_SAME_ACCESS)) {
     /* failed to duplicate the mutex, no point in continuing */
     destroy_thread_sync_data(tsd);
     return FALSE;
   }
-  if (!DuplicateHandle(curr_proc, td->mutex_terminate,
+  if(!DuplicateHandle(curr_proc, td->mutex_terminate,
                        curr_proc, &tsd->mutex_terminate, 0, FALSE,
                        DUPLICATE_SAME_ACCESS)) {
     /* failed to duplicate the mutex, no point in continuing */
     destroy_thread_sync_data(tsd);
     return FALSE;
   }
-  if (!DuplicateHandle(curr_proc, td->event_terminate,
+  if(!DuplicateHandle(curr_proc, td->event_terminate,
                        curr_proc, &tsd->event_terminate, 0, FALSE,
                        DUPLICATE_SAME_ACCESS)) {
     /* failed to duplicate the event, no point in continuing */
     destroy_thread_sync_data(tsd);
     return FALSE;
   }
   /* Copying hostname string because original can be destroyed by parent
    * thread during gethostbyname execution.
    */
   tsd->hostname = strdup(hostname);
-  if (!tsd->hostname) {
+  if(!tsd->hostname) {
     /* Memory allocation failed */
     destroy_thread_sync_data(tsd);
     return FALSE;
   }
   return TRUE;
 }
 
 /* acquire resolver thread synchronization */
 static
 BOOL acquire_thread_sync(struct thread_sync_data * tsd)
 {
   /* is the thread initiator still waiting for us ? */
-  if (WaitForSingleObject(tsd->mutex_waiting, 0) == WAIT_TIMEOUT) {
+  if(WaitForSingleObject(tsd->mutex_waiting, 0) == WAIT_TIMEOUT) {
     /* yes, it is */
 
     /* Waiting access to event_terminate */
-    if (WaitForSingleObject(tsd->mutex_terminate, INFINITE) != WAIT_OBJECT_0) {
+    if(WaitForSingleObject(tsd->mutex_terminate, INFINITE) != WAIT_OBJECT_0) {
       /* Something went wrong - now just ignoring */
     }
     else {
-      if (WaitForSingleObject(tsd->event_terminate, 0) != WAIT_TIMEOUT) {
+      if(WaitForSingleObject(tsd->event_terminate, 0) != WAIT_TIMEOUT) {
         /* Parent thread signaled us to terminate.
          * This means that all data in conn->async is now destroyed
          * and we cannot use it.
          */
       }
       else {
@@ -284,13 +284,13 @@
   /* Duplicate the passed mutex and event handles.
    * This allows us to use it even after the container gets destroyed
    * due to a resolver timeout.
    */
   struct thread_sync_data tsd = { 0,0,0,NULL };
 
-  if (!init_thread_sync_data(td, conn->async.hostname, &tsd)) {
+  if(!init_thread_sync_data(td, conn->async.hostname, &tsd)) {
     /* thread synchronization data initialization failed */
     return (unsigned)-1;
   }
 
   conn->async.status = NO_DATA;  /* pending status */
   SET_SOCKERRNO(conn->async.status);
@@ -299,17 +299,17 @@
      need */
   SetEvent(td->event_thread_started);
 
   he = gethostbyname (tsd.hostname);
 
   /* is parent thread waiting for us and are we able to access conn members? */
-  if (acquire_thread_sync(&tsd)) {
+  if(acquire_thread_sync(&tsd)) {
     /* Mark that we have obtained the information, and that we are calling
      * back with it. */
     SetEvent(td->event_resolved);
-    if (he) {
+    if(he) {
       rc = Curl_addrinfo4_callback(conn, CURL_ASYNC_SUCCESS, he);
     }
     else {
       rc = Curl_addrinfo4_callback(conn, SOCKERRNO, NULL);
     }
     TRACE(("Winsock-error %d, addr %s\n", conn->async.status,
@@ -345,13 +345,13 @@
   /* Duplicate the passed mutex handle.
    * This allows us to use it even after the container gets destroyed
    * due to a resolver timeout.
    */
   struct thread_sync_data tsd = { 0,0,0,NULL };
 
-  if (!init_thread_sync_data(td, conn->async.hostname, &tsd)) {
+  if(!init_thread_sync_data(td, conn->async.hostname, &tsd)) {
     /* thread synchronization data initialization failed */
     return -1;
   }
 
   itoa(conn->async.port, service, 10);
 
@@ -362,18 +362,18 @@
      need */
   SetEvent(td->event_thread_started);
 
   rc = getaddrinfo(tsd.hostname, service, &hints, &res);
 
   /* is parent thread waiting for us and are we able to access conn members? */
-  if (acquire_thread_sync(&tsd)) {
+  if(acquire_thread_sync(&tsd)) {
     /* Mark that we have obtained the information, and that we are calling
        back with it. */
     SetEvent(td->event_resolved);
 
-    if (rc == 0) {
+    if(rc == 0) {
 #ifdef DEBUG_THREADING_GETADDRINFO
       dump_addrinfo (conn, res);
 #endif
       rc = Curl_addrinfo6_callback(conn, CURL_ASYNC_SUCCESS, res);
     }
     else {
@@ -394,48 +394,48 @@
 /*
  * Curl_destroy_thread_data() cleans up async resolver data and thread handle.
  * Complementary of ares_destroy.
  */
 void Curl_destroy_thread_data (struct Curl_async *async)
 {
-  if (async->hostname)
+  if(async->hostname)
     free(async->hostname);
 
-  if (async->os_specific) {
+  if(async->os_specific) {
     struct thread_data *td = (struct thread_data*) async->os_specific;
     curl_socket_t sock = td->dummy_sock;
 
-    if (td->mutex_terminate && td->event_terminate) {
+    if(td->mutex_terminate && td->event_terminate) {
       /* Signaling resolver thread to terminate */
-      if (WaitForSingleObject(td->mutex_terminate, INFINITE) == WAIT_OBJECT_0) {
+      if(WaitForSingleObject(td->mutex_terminate, INFINITE) == WAIT_OBJECT_0) {
         SetEvent(td->event_terminate);
         ReleaseMutex(td->mutex_terminate);
       }
       else {
         /* Something went wrong - just ignoring it */
       }
     }
 
-    if (td->mutex_terminate)
+    if(td->mutex_terminate)
       CloseHandle(td->mutex_terminate);
-    if (td->event_terminate)
+    if(td->event_terminate)
       CloseHandle(td->event_terminate);
-    if (td->event_thread_started)
+    if(td->event_thread_started)
       CloseHandle(td->event_thread_started);
 
-    if (sock != CURL_SOCKET_BAD)
+    if(sock != CURL_SOCKET_BAD)
       sclose(sock);
 
     /* destroy the synchronization objects */
-    if (td->mutex_waiting)
+    if(td->mutex_waiting)
       CloseHandle(td->mutex_waiting);
     td->mutex_waiting = NULL;
-    if (td->event_resolved)
+    if(td->event_resolved)
       CloseHandle(td->event_resolved);
 
-    if (td->thread_hnd)
+    if(td->thread_hnd)
       CloseHandle(td->thread_hnd);
 
     free(async->os_specific);
   }
   async->hostname = NULL;
   async->os_specific = NULL;
@@ -451,20 +451,20 @@
                                  const char *hostname, int port,
                                  const Curl_addrinfo *hints)
 {
   struct thread_data *td = calloc(sizeof(*td), 1);
   HANDLE thread_and_event[2] = {0};
 
-  if (!td) {
+  if(!td) {
     SET_ERRNO(ENOMEM);
     return FALSE;
   }
 
   Curl_safefree(conn->async.hostname);
   conn->async.hostname = strdup(hostname);
-  if (!conn->async.hostname) {
+  if(!conn->async.hostname) {
     free(td);
     SET_ERRNO(ENOMEM);
     return FALSE;
   }
 
   conn->async.port = port;
@@ -475,48 +475,48 @@
   td->dummy_sock = CURL_SOCKET_BAD;
 
   /* Create the mutex used to inform the resolver thread that we're
    * still waiting, and take initial ownership.
    */
   td->mutex_waiting = CreateMutex(NULL, TRUE, NULL);
-  if (td->mutex_waiting == NULL) {
+  if(td->mutex_waiting == NULL) {
     Curl_destroy_thread_data(&conn->async);
     SET_ERRNO(EAGAIN);
     return FALSE;
   }
 
   /* Create the event that the thread uses to inform us that it's
    * done resolving. Do not signal it.
    */
   td->event_resolved = CreateEvent(NULL, TRUE, FALSE, NULL);
-  if (td->event_resolved == NULL) {
+  if(td->event_resolved == NULL) {
     Curl_destroy_thread_data(&conn->async);
     SET_ERRNO(EAGAIN);
     return FALSE;
   }
   /* Create the mutex used to serialize access to event_terminated
    * between us and resolver thread.
    */
   td->mutex_terminate = CreateMutex(NULL, FALSE, NULL);
-  if (td->mutex_terminate == NULL) {
+  if(td->mutex_terminate == NULL) {
     Curl_destroy_thread_data(&conn->async);
     SET_ERRNO(EAGAIN);
     return FALSE;
   }
   /* Create the event used to signal thread that it should terminate.
    */
   td->event_terminate = CreateEvent(NULL, TRUE, FALSE, NULL);
-  if (td->event_terminate == NULL) {
+  if(td->event_terminate == NULL) {
     Curl_destroy_thread_data(&conn->async);
     SET_ERRNO(EAGAIN);
     return FALSE;
   }
   /* Create the event used by thread to inform it has initialized its own data.
    */
   td->event_thread_started = CreateEvent(NULL, TRUE, FALSE, NULL);
-  if (td->event_thread_started == NULL) {
+  if(td->event_thread_started == NULL) {
     Curl_destroy_thread_data(&conn->async);
     SET_ERRNO(EAGAIN);
     return FALSE;
   }
 
 #ifdef _WIN32_WCE
@@ -532,13 +532,13 @@
   DEBUGASSERT(hints);
   td->hints = *hints;
 #else
   (void) hints;
 #endif
 
-  if (!td->thread_hnd) {
+  if(!td->thread_hnd) {
 #ifdef _WIN32_WCE
      TRACE(("CreateThread() failed; %s\n", Curl_strerror(conn, ERRNO)));
 #else
      SET_ERRNO(errno);
      TRACE(("_beginthreadex() failed; %s\n", Curl_strerror(conn, ERRNO)));
 #endif
@@ -546,13 +546,13 @@
      return FALSE;
   }
   /* Waiting until the thread will initialize its data or it will exit due errors.
    */
   thread_and_event[0] = td->thread_hnd;
   thread_and_event[1] = td->event_thread_started;
-  if (WaitForMultipleObjects(sizeof(thread_and_event) /
+  if(WaitForMultipleObjects(sizeof(thread_and_event) /
                              sizeof(thread_and_event[0]),
                              (const HANDLE*)thread_and_event, FALSE,
                              INFINITE) == WAIT_FAILED) {
     /* The resolver thread has been created,
      * most probably it works now - ignoring this "minor" error
      */
@@ -605,15 +605,15 @@
 
   /* close the event handle, it's useless now */
   CloseHandle(td->event_resolved);
   td->event_resolved = NULL;
 
   /* has the resolver thread succeeded in resolving our query ? */
-  if (status == WAIT_OBJECT_0) {
+  if(status == WAIT_OBJECT_0) {
     /* wait for the thread to exit, it's in the callback sequence */
-    if (WaitForSingleObject(td->thread_hnd, 5000) == WAIT_TIMEOUT) {
+    if(WaitForSingleObject(td->thread_hnd, 5000) == WAIT_TIMEOUT) {
       TerminateThread(td->thread_hnd, 0);
       conn->async.done = TRUE;
       td->thread_status = (DWORD)-1;
       TRACE(("%s() thread stuck?!, ", THREAD_NAME));
     }
     else {
@@ -637,15 +637,15 @@
 
   if(entry)
     *entry = conn->async.dns;
 
   rc = CURLE_OK;
 
-  if (!conn->async.dns) {
+  if(!conn->async.dns) {
     /* a name was not resolved */
-    if (td->thread_status == CURLE_OUT_OF_MEMORY) {
+    if(td->thread_status == CURLE_OUT_OF_MEMORY) {
       rc = CURLE_OUT_OF_MEMORY;
       failf(data, "Could not resolve host: %s", curl_easy_strerror(rc));
     }
     else if(conn->async.done) {
       if(conn->bits.httpproxy) {
         failf(data, "Could not resolve proxy: %s; %s",
@@ -655,13 +655,13 @@
       else {
         failf(data, "Could not resolve host: %s; %s",
               conn->host.name, Curl_strerror(conn, conn->async.status));
         rc = CURLE_COULDNT_RESOLVE_HOST;
       }
     }
-    else if (td->thread_status == (DWORD)-1 || conn->async.status == NO_DATA) {
+    else if(td->thread_status == (DWORD)-1 || conn->async.status == NO_DATA) {
       failf(data, "Resolving host timed out: %s", conn->host.name);
       rc = CURLE_OPERATION_TIMEDOUT;
     }
     else
       rc = CURLE_OPERATION_TIMEDOUT;
   }
@@ -681,16 +681,16 @@
  */
 CURLcode Curl_is_resolved(struct connectdata *conn,
                           struct Curl_dns_entry **entry)
 {
   *entry = NULL;
 
-  if (conn->async.done) {
+  if(conn->async.done) {
     /* we're done */
     Curl_destroy_thread_data(&conn->async);
-    if (!conn->async.dns) {
+    if(!conn->async.dns) {
       TRACE(("Curl_is_resolved(): CURLE_COULDNT_RESOLVE_HOST\n"));
       return CURLE_COULDNT_RESOLVE_HOST;
     }
     *entry = conn->async.dns;
     TRACE(("resolved okay, dns %p\n", *entry));
   }
@@ -701,13 +701,13 @@
                         curl_socket_t *socks,
                         int numsocks)
 {
   const struct thread_data *td =
     (const struct thread_data *) conn->async.os_specific;
 
-  if (td && td->dummy_sock != CURL_SOCKET_BAD) {
+  if(td && td->dummy_sock != CURL_SOCKET_BAD) {
     if(numsocks) {
       /* return one socket waiting for writable, even though this is just
          a dummy */
       socks[0] = td->dummy_sock;
       return GETSOCK_WRITESOCK(0);
     }
@@ -728,28 +728,28 @@
   struct SessionHandle *data = conn->data;
   in_addr_t in;
 
   *waitp = 0; /* don't wait, we act synchronously */
 
   in = inet_addr(hostname);
-  if (in != CURL_INADDR_NONE)
+  if(in != CURL_INADDR_NONE)
     /* This is a dotted IP address 123.123.123.123-style */
     return Curl_ip2addr(in, hostname, port);
 
   /* fire up a new resolver thread! */
-  if (init_resolve_thread(conn, hostname, port, NULL)) {
+  if(init_resolve_thread(conn, hostname, port, NULL)) {
     *waitp = TRUE;  /* please wait for the response */
     return NULL;
   }
 
   /* fall-back to blocking version */
   infof(data, "init_resolve_thread() failed for %s; %s\n",
         hostname, Curl_strerror(conn, ERRNO));
 
   h = gethostbyname(hostname);
-  if (!h) {
+  if(!h) {
     infof(data, "gethostbyname(2) failed for %s:%d; %s\n",
           hostname, port, Curl_strerror(conn, SOCKERRNO));
     return NULL;
   }
   return Curl_he2ai(h, port);
 }
@@ -772,13 +772,13 @@
   struct SessionHandle *data = conn->data;
 
   *waitp = FALSE; /* default to synch response */
 
   /* see if we have an IPv6 stack */
   s = socket(PF_INET6, SOCK_DGRAM, 0);
-  if (s == CURL_SOCKET_BAD) {
+  if(s == CURL_SOCKET_BAD) {
     /* Some non-IPv6 stacks have been found to make very slow name resolves
      * when PF_UNSPEC is used, so thus we switch to a mere PF_INET lookup if
      * the stack seems to be a non-ipv6 one. */
 
     pf = PF_INET;
   }
@@ -810,23 +810,23 @@
 #if 0 /* removed nov 8 2005 before 7.15.1 */
   hints.ai_flags = AI_CANONNAME;
 #endif
   itoa(port, sbuf, 10);
 
   /* fire up a new resolver thread! */
-  if (init_resolve_thread(conn, hostname, port, &hints)) {
+  if(init_resolve_thread(conn, hostname, port, &hints)) {
     *waitp = TRUE;  /* please wait for the response */
     return NULL;
   }
 
   /* fall-back to blocking version */
   infof(data, "init_resolve_thread() failed for %s; %s\n",
         hostname, Curl_strerror(conn, ERRNO));
 
   error = getaddrinfo(hostname, sbuf, &hints, &res);
-  if (error) {
+  if(error) {
     infof(data, "getaddrinfo() failed for %s:%d; %s\n",
           hostname, port, Curl_strerror(conn, SOCKERRNO));
     return NULL;
   }
   return res;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http.c	2007-10-23 22:43:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http.c	2008-01-26 07:33:45.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.c,v 1.344 2007-10-23 10:14:24 yangtse Exp $
+ * $Id: http.c,v 1.359 2008-01-25 23:33:45 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_HTTP
 /* -- WIN32 approved -- */
@@ -106,15 +106,15 @@
 
 
 /*
  * Forward declarations.
  */
 
-static CURLcode Curl_https_connecting(struct connectdata *conn, bool *done);
+static CURLcode https_connecting(struct connectdata *conn, bool *done);
 #ifdef USE_SSL
-static int Curl_https_getsock(struct connectdata *conn,
+static int https_getsock(struct connectdata *conn,
                               curl_socket_t *socks,
                               int numsocks);
 #endif
 
 /*
  * HTTP handler interface.
@@ -143,15 +143,15 @@
   "HTTPS",                              /* scheme */
   ZERO_NULL,                            /* setup_connection */
   Curl_http,                            /* do_it */
   Curl_http_done,                       /* done */
   ZERO_NULL,                            /* do_more */
   Curl_http_connect,                    /* connect_it */
-  Curl_https_connecting,                /* connecting */
+  https_connecting,                /* connecting */
   ZERO_NULL,                            /* doing */
-  Curl_https_getsock,                   /* proto_getsock */
+  https_getsock,                   /* proto_getsock */
   ZERO_NULL,                            /* doing_getsock */
   ZERO_NULL,                            /* disconnect */
   PORT_HTTPS,                           /* defport */
   PROT_HTTP | PROT_HTTPS | PROT_SSL     /* protocol */
 };
 #endif
@@ -173,18 +173,18 @@
       return head->data;
   }
   return NULL;
 }
 
 /*
- * Curl_output_basic() sets up an Authorization: header (or the proxy version)
+ * http_output_basic() sets up an Authorization: header (or the proxy version)
  * for HTTP Basic authentication.
  *
  * Returns CURLcode.
  */
-static CURLcode Curl_output_basic(struct connectdata *conn, bool proxy)
+static CURLcode http_output_basic(struct connectdata *conn, bool proxy)
 {
   char *authorization;
   struct SessionHandle *data=conn->data;
   char **userp;
   char *user;
   char *pwd;
@@ -272,14 +272,13 @@
  *   }
  * }
  */
 static CURLcode perhapsrewind(struct connectdata *conn)
 {
   struct SessionHandle *data = conn->data;
-  struct HTTP *http = data->reqdata.proto.http;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct HTTP *http = data->state.proto.http;
   curl_off_t bytessent;
   curl_off_t expectsend = -1; /* default is unknown */
 
   if(!http)
     /* If this is still NULL, we have not reach very far and we can
        safely skip this rewinding stuff */
@@ -335,13 +334,13 @@
             " bytes\n", (curl_off_t)(expectsend - bytessent));
     }
 
     /* This is not NTLM or NTLM with many bytes left to send: close
      */
     conn->bits.close = TRUE;
-    k->size = 0; /* don't download any more than 0 bytes */
+    data->req.size = 0; /* don't download any more than 0 bytes */
   }
 
   if(bytessent)
     return Curl_readrewind(conn);
 
   return CURLE_OK;
@@ -358,66 +357,66 @@
 {
   struct SessionHandle *data = conn->data;
   bool pickhost = FALSE;
   bool pickproxy = FALSE;
   CURLcode code = CURLE_OK;
 
-  if(100 == data->reqdata.keep.httpcode)
+  if(100 == data->req.httpcode)
     /* this is a transient response code, ignore */
     return CURLE_OK;
 
   if(data->state.authproblem)
     return data->set.http_fail_on_error?CURLE_HTTP_RETURNED_ERROR:CURLE_OK;
 
   if(conn->bits.user_passwd &&
-     ((data->reqdata.keep.httpcode == 401) ||
-      (conn->bits.authneg && data->reqdata.keep.httpcode < 300))) {
+     ((data->req.httpcode == 401) ||
+      (conn->bits.authneg && data->req.httpcode < 300))) {
     pickhost = pickoneauth(&data->state.authhost);
     if(!pickhost)
       data->state.authproblem = TRUE;
   }
   if(conn->bits.proxy_user_passwd &&
-     ((data->reqdata.keep.httpcode == 407) ||
-      (conn->bits.authneg && data->reqdata.keep.httpcode < 300))) {
+     ((data->req.httpcode == 407) ||
+      (conn->bits.authneg && data->req.httpcode < 300))) {
     pickproxy = pickoneauth(&data->state.authproxy);
     if(!pickproxy)
       data->state.authproblem = TRUE;
   }
 
   if(pickhost || pickproxy) {
-    data->reqdata.newurl = strdup(data->change.url); /* clone URL */
-    if (!data->reqdata.newurl)
+    data->req.newurl = strdup(data->change.url); /* clone URL */
+    if(!data->req.newurl)
       return CURLE_OUT_OF_MEMORY;
 
     if((data->set.httpreq != HTTPREQ_GET) &&
        (data->set.httpreq != HTTPREQ_HEAD) &&
        !conn->bits.rewindaftersend) {
       code = perhapsrewind(conn);
       if(code)
         return code;
     }
   }
 
-  else if((data->reqdata.keep.httpcode < 300) &&
+  else if((data->req.httpcode < 300) &&
           (!data->state.authhost.done) &&
           conn->bits.authneg) {
     /* no (known) authentication available,
        authentication is not "done" yet and
        no authentication seems to be required and
        we didn't try HEAD or GET */
     if((data->set.httpreq != HTTPREQ_GET) &&
        (data->set.httpreq != HTTPREQ_HEAD)) {
-      data->reqdata.newurl = strdup(data->change.url); /* clone URL */
-      if (!data->reqdata.newurl)
+      data->req.newurl = strdup(data->change.url); /* clone URL */
+      if(!data->req.newurl)
         return CURLE_OUT_OF_MEMORY;
       data->state.authhost.done = TRUE;
     }
   }
-  if (Curl_http_should_fail(conn)) {
+  if(Curl_http_should_fail(conn)) {
     failf (data, "The requested URL returned error: %d",
-           data->reqdata.keep.httpcode);
+           data->req.httpcode);
     code = CURLE_HTTP_RETURNED_ERROR;
   }
 
   return code;
 }
 
@@ -433,17 +432,17 @@
  * @param proxytunnel boolean if this is the request setting up a "proxy
  * tunnel"
  *
  * @returns CURLcode
  */
 static CURLcode
-Curl_http_output_auth(struct connectdata *conn,
-                      const char *request,
-                      const char *path,
-                      bool proxytunnel) /* TRUE if this is the request setting
-                                           up the proxy tunnel */
+http_output_auth(struct connectdata *conn,
+                 const char *request,
+                 const char *path,
+                 bool proxytunnel) /* TRUE if this is the request setting
+                                      up the proxy tunnel */
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data = conn->data;
   const char *auth=NULL;
   struct auth *authhost;
   struct auth *authproxy;
@@ -472,21 +471,21 @@
     /* The app has selected one or more methods, but none has been picked so
        far by a proxy round-trip. Then we set the picked one to the want one,
        and if this is one single bit it'll be used instantly. */
     authproxy->picked = authproxy->want;
 
   /* Send proxy authentication header if needed */
-  if (conn->bits.httpproxy &&
+  if(conn->bits.httpproxy &&
       (conn->bits.tunnel_proxy == proxytunnel)) {
 #ifdef HAVE_GSSAPI
     if((authproxy->picked == CURLAUTH_GSSNEGOTIATE) &&
        data->state.negotiate.context &&
        !GSS_ERROR(data->state.negotiate.status)) {
       auth="GSS-Negotiate";
       result = Curl_output_negotiate(conn, TRUE);
-      if (result)
+      if(result)
         return result;
       authproxy->done = TRUE;
     } 
     else
 #endif
 #ifdef USE_NTLM
@@ -500,17 +499,17 @@
 #endif
       if(authproxy->picked == CURLAUTH_BASIC) {
         /* Basic */
         if(conn->bits.proxy_user_passwd &&
            !checkheaders(data, "Proxy-authorization:")) {
           auth="Basic";
-          result = Curl_output_basic(conn, TRUE);
+          result = http_output_basic(conn, TRUE);
           if(result)
             return result;
         }
-        /* NOTE: Curl_output_basic() should set 'done' TRUE, as the other auth
+        /* NOTE: http_output_basic() should set 'done' TRUE, as the other auth
            functions work that way */
         authproxy->done = TRUE;
       }
 #ifndef CURL_DISABLE_CRYPTO_AUTH
       else if(authproxy->picked == CURLAUTH_DIGEST) {
         auth="Digest";
@@ -549,13 +548,13 @@
 #ifdef HAVE_GSSAPI
       if((authhost->picked == CURLAUTH_GSSNEGOTIATE) &&
          data->state.negotiate.context &&
          !GSS_ERROR(data->state.negotiate.status)) {
         auth="GSS-Negotiate";
         result = Curl_output_negotiate(conn, FALSE);
-        if (result)
+        if(result)
           return result;
         authhost->done = TRUE;
       }
       else
 #endif
 #ifdef USE_NTLM
@@ -580,13 +579,13 @@
         } else
 #endif
         if(authhost->picked == CURLAUTH_BASIC) {
           if(conn->bits.user_passwd &&
              !checkheaders(data, "Authorization:")) {
             auth="Basic";
-            result = Curl_output_basic(conn, FALSE);
+            result = http_output_basic(conn, FALSE);
             if(result)
               return result;
           }
           /* basic is always ready */
           authhost->done = TRUE;
         }
@@ -624,13 +623,13 @@
   struct SessionHandle *data = conn->data;
 
   long *availp;
   const char *start;
   struct auth *authp;
 
-  if (httpcode == 407) {
+  if(httpcode == 407) {
     start = header+strlen("Proxy-authenticate:");
     availp = &data->info.proxyauthavail;
     authp = &data->state.authproxy;
   }
   else {
     start = header+strlen("WWW-Authenticate:");
@@ -649,22 +648,22 @@
    * If the provided authentication is wanted as one out of several accepted
    * types (using &), we OR this authentication type to the authavail
    * variable.
    */
 
 #ifdef HAVE_GSSAPI
-  if (checkprefix("GSS-Negotiate", start) ||
+  if(checkprefix("GSS-Negotiate", start) ||
       checkprefix("Negotiate", start)) {
     *availp |= CURLAUTH_GSSNEGOTIATE;
     authp->avail |= CURLAUTH_GSSNEGOTIATE;
     if(authp->picked == CURLAUTH_GSSNEGOTIATE) {
       /* if exactly this is wanted, go */
       int neg = Curl_input_negotiate(conn, (bool)(httpcode == 407), start);
-      if (neg == 0) {
-        data->reqdata.newurl = strdup(data->change.url);
-        data->state.authproblem = (data->reqdata.newurl == NULL);
+      if(neg == 0) {
+        data->req.newurl = strdup(data->change.url);
+        data->state.authproblem = (data->req.newurl == NULL);
       }
       else {
         infof(data, "Authentication problem. Ignoring this.\n");
         data->state.authproblem = TRUE;
       }
     }
@@ -740,56 +739,53 @@
  *
  * @retval 1 communications should not continue
  */
 int Curl_http_should_fail(struct connectdata *conn)
 {
   struct SessionHandle *data;
-  struct Curl_transfer_keeper *k;
+  int httpcode;
 
   DEBUGASSERT(conn);
   data = conn->data;
   DEBUGASSERT(data);
 
-  /*
-  ** For readability
-  */
-  k = &data->reqdata.keep;
+  httpcode = data->req.httpcode;
 
   /*
   ** If we haven't been asked to fail on error,
   ** don't fail.
   */
-  if (!data->set.http_fail_on_error)
+  if(!data->set.http_fail_on_error)
     return 0;
 
   /*
   ** Any code < 400 is never terminal.
   */
-  if (k->httpcode < 400)
+  if(httpcode < 400)
     return 0;
 
-  if (data->reqdata.resume_from &&
-      (data->set.httpreq==HTTPREQ_GET) &&
-      (k->httpcode == 416)) {
+  if(data->state.resume_from &&
+     (data->set.httpreq==HTTPREQ_GET) &&
+     (httpcode == 416)) {
     /* "Requested Range Not Satisfiable", just proceed and
        pretend this is no error */
     return 0;
   }
 
   /*
   ** Any code >= 400 that's not 401 or 407 is always
   ** a terminal error
   */
-  if ((k->httpcode != 401) &&
-      (k->httpcode != 407))
+  if((httpcode != 401) &&
+      (httpcode != 407))
     return 1;
 
   /*
   ** All we have left to deal with is 401 and 407
   */
-  DEBUGASSERT((k->httpcode == 401) || (k->httpcode == 407));
+  DEBUGASSERT((httpcode == 401) || (httpcode == 407));
 
   /*
   ** Examine the current authentication state to see if this
   ** is an error.  The idea is for this function to get
   ** called after processing all the headers in a response
   ** message.  So, if we've been to asked to authenticate a
@@ -804,23 +800,24 @@
 #if 0 /* set to 1 when debugging this functionality */
   infof(data,"%s: authstage = %d\n",__FUNCTION__,data->state.authstage);
   infof(data,"%s: authwant = 0x%08x\n",__FUNCTION__,data->state.authwant);
   infof(data,"%s: authavail = 0x%08x\n",__FUNCTION__,data->state.authavail);
   infof(data,"%s: httpcode = %d\n",__FUNCTION__,k->httpcode);
   infof(data,"%s: authdone = %d\n",__FUNCTION__,data->state.authdone);
-  infof(data,"%s: newurl = %s\n",__FUNCTION__,data->reqdata.newurl ? data->reqdata.newurl : "(null)");
+  infof(data,"%s: newurl = %s\n",__FUNCTION__,data->req.newurl ?
+        data->req.newurl : "(null)");
   infof(data,"%s: authproblem = %d\n",__FUNCTION__,data->state.authproblem);
 #endif
 
   /*
   ** Either we're not authenticating, or we're supposed to
   ** be authenticating something else.  This is an error.
   */
-  if((k->httpcode == 401) && !conn->bits.user_passwd)
+  if((httpcode == 401) && !conn->bits.user_passwd)
     return TRUE;
-  if((k->httpcode == 407) && !conn->bits.proxy_user_passwd)
+  if((httpcode == 407) && !conn->bits.proxy_user_passwd)
     return TRUE;
 
   return data->state.authproblem;
 }
 
 /*
@@ -834,13 +831,13 @@
 static size_t readmoredata(char *buffer,
                            size_t size,
                            size_t nitems,
                            void *userp)
 {
   struct connectdata *conn = (struct connectdata *)userp;
-  struct HTTP *http = conn->data->reqdata.proto.http;
+  struct HTTP *http = conn->data->state.proto.http;
   size_t fullsize = size * nitems;
 
   if(0 == http->postsize)
     /* nothing to return */
     return 0;
 
@@ -926,37 +923,41 @@
 
 {
   ssize_t amount;
   CURLcode res;
   char *ptr;
   size_t size;
-  struct HTTP *http = conn->data->reqdata.proto.http;
+  struct HTTP *http = conn->data->state.proto.http;
   size_t sendsize;
   curl_socket_t sockfd;
+  size_t headersize;
 
   DEBUGASSERT(socketindex <= SECONDARYSOCKET);
 
   sockfd = conn->sock[socketindex];
 
   /* The looping below is required since we use non-blocking sockets, but due
      to the circumstances we will just loop and try again and again etc */
 
   ptr = in->buffer;
   size = in->size_used;
 
+  headersize = size - included_body_bytes; /* the initial part that isn't body
+                                              is header */
+
+  DEBUGASSERT(size > included_body_bytes);
+
 #ifdef CURL_DOES_CONVERSIONS
-  if(size - included_body_bytes > 0) {
-    res = Curl_convert_to_network(conn->data, ptr, size - included_body_bytes);
-    /* Curl_convert_to_network calls failf if unsuccessful */
-    if(res != CURLE_OK) {
-      /* conversion failed, free memory and return to the caller */
-      if(in->buffer)
-        free(in->buffer);
-      free(in);
-      return res;
-    }
+  res = Curl_convert_to_network(conn->data, ptr, headersize);
+  /* Curl_convert_to_network calls failf if unsuccessful */
+  if(res != CURLE_OK) {
+    /* conversion failed, free memory and return to the caller */
+    if(in->buffer)
+      free(in->buffer);
+    free(in);
+    return res;
   }
 #endif /* CURL_DOES_CONVERSIONS */
 
   if(conn->protocol & PROT_HTTPS) {
     /* We never send more than CURL_MAX_WRITE_SIZE bytes in one single chunk
        when we speak HTTPS, as if only a fraction of it is sent now, this data
@@ -978,26 +979,35 @@
   else
     sendsize = size;
 
   res = Curl_write(conn, sockfd, ptr, sendsize, &amount);
 
   if(CURLE_OK == res) {
+    /*
+     * Note that we may not send the entire chunk at once, and we have a set
+     * number of data bytes at the end of the big buffer (out of which we may
+     * only send away a part).
+     */
+    /* how much of the header that was sent */
+    size_t headlen = (size_t)amount>headersize?headersize:(size_t)amount;
+    size_t bodylen = amount - headlen;
 
     if(conn->data->set.verbose) {
       /* this data _may_ contain binary stuff */
-      Curl_debug(conn->data, CURLINFO_HEADER_OUT, ptr,
-                 (size_t)(amount-included_body_bytes), conn);
-      if (included_body_bytes)
+      Curl_debug(conn->data, CURLINFO_HEADER_OUT, ptr, headlen, conn);
+      if((size_t)amount > headlen) {
+        /* there was body data sent beyond the initial header part, pass that
+           on to the debug callback too */
         Curl_debug(conn->data, CURLINFO_DATA_OUT,
-                   ptr+amount-included_body_bytes,
-                   (size_t)included_body_bytes, conn);
+                   ptr+headlen, bodylen, conn);
+      }
     }
-    if (included_body_bytes)
+    if(bodylen)
       /* since we sent a piece of the body here, up the byte counter for it
          accordingly */
-      http->writebytecount = included_body_bytes;
+      http->writebytecount += bodylen;
 
     *bytes_written += amount;
 
     if(http) {
       if((size_t)amount != size) {
         /* The whole request could not be sent in one system call. We must
@@ -1080,15 +1090,34 @@
 static
 CURLcode add_buffer(send_buffer *in, const void *inptr, size_t size)
 {
   char *new_rb;
   size_t new_size;
 
+  if(~size < in->size_used) {
+    /* If resulting used size of send buffer would wrap size_t, cleanup
+       the whole buffer and return error. Otherwise the required buffer
+       size will fit into a single allocatable memory chunk */
+    Curl_safefree(in->buffer);
+    free(in);
+    return CURLE_OUT_OF_MEMORY;
+  }
+
   if(!in->buffer ||
      ((in->size_used + size) > (in->size_max - 1))) {
-    new_size = (in->size_used+size)*2;
+
+    /* If current buffer size isn't enough to hold the result, use a
+       buffer size that doubles the required size. If this new size
+       would wrap size_t, then just use the largest possible one */
+
+    if((size > (size_t)-1/2) || (in->size_used > (size_t)-1/2) ||
+       (~(size*2) < (in->size_used*2)))
+      new_size = (size_t)-1;
+    else
+      new_size = (in->size_used+size)*2;
+
     if(in->buffer)
       /* we have a buffer, enlarge the existing one */
       new_rb = (char *)realloc(in->buffer, new_size);
     else
       /* create a new buffer */
       new_rb = (char *)malloc(new_size);
@@ -1185,13 +1214,13 @@
                            int sockindex,
                            const char *hostname,
                            unsigned short remote_port)
 {
   int subversion=0;
   struct SessionHandle *data=conn->data;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct SingleRequest *k = &data->req;
   CURLcode result;
   int res;
   long timeout =
     data->set.timeout?data->set.timeout:3600000; /* in milliseconds */
   curl_socket_t tunnelsocket = conn->sock[sockindex];
   curl_off_t cl=0;
@@ -1204,25 +1233,25 @@
 #define SELECT_TIMEOUT 2
   int error = SELECT_OK;
 
   conn->bits.proxy_connect_closed = FALSE;
 
   do {
-    if (!conn->bits.tunnel_connecting) { /* BEGIN CONNECT PHASE */
+    if(!conn->bits.tunnel_connecting) { /* BEGIN CONNECT PHASE */
       char *host_port;
       send_buffer *req_buffer;
 
       infof(data, "Establish HTTP proxy tunnel to %s:%d\n",
             hostname, remote_port);
 
-      if(data->reqdata.newurl) {
+      if(data->req.newurl) {
         /* This only happens if we've looped here due to authentication
            reasons, and we don't really use the newly cloned URL here
            then. Just free() it. */
-        free(data->reqdata.newurl);
-        data->reqdata.newurl = NULL;
+        free(data->req.newurl);
+        data->req.newurl = NULL;
       }
 
       /* initialize a dynamic send-buffer */
       req_buffer = add_buffer_init();
 
       if(!req_buffer)
@@ -1232,13 +1261,13 @@
       if(!host_port) {
         free(req_buffer);
         return CURLE_OUT_OF_MEMORY;
       }
 
       /* Setup the proxy-authorization header, if any */
-      result = Curl_http_output_auth(conn, (char *)"CONNECT", host_port, TRUE);
+      result = http_output_auth(conn, (char *)"CONNECT", host_port, TRUE);
 
       if(CURLE_OK == result) {
         char *host=(char *)"";
         const char *proxyconn="";
         const char *useragent="";
 
@@ -1311,14 +1340,14 @@
       failf(data, "Proxy CONNECT aborted due to timeout");
       error = SELECT_TIMEOUT; /* already too little time */
       break;
     }
 
     /* if we're in multi-mode and we would block, return instead for a retry */
-    if (Curl_if_multi == data->state.used_interface) {
-      if (0 == Curl_socket_ready(tunnelsocket, CURL_SOCKET_BAD, 0))
+    if(Curl_if_multi == data->state.used_interface) {
+      if(0 == Curl_socket_ready(tunnelsocket, CURL_SOCKET_BAD, 0))
         /* return so we'll be called again polling-style */
         return CURLE_OK;
       else {
         DEBUGF(infof(data,
                      "Multi mode finished polling for response from "
                      "proxy CONNECT."));
@@ -1377,14 +1406,21 @@
             /* EWOULDBLOCK */
             continue; /* go loop yourself */
           else if(res)
             keepon = FALSE;
           else if(gotbytes <= 0) {
             keepon = FALSE;
-            error = SELECT_ERROR;
-            failf(data, "Proxy CONNECT aborted");
+            if(data->set.proxyauth && data->state.authproxy.avail) {
+              /* proxy auth was requested and there was proxy auth available,
+                 then deem this as "mere" proxy disconnect */
+              conn->bits.proxy_connect_closed = TRUE;
+            }
+            else {
+              error = SELECT_ERROR;
+              failf(data, "Proxy CONNECT aborted");
+            }
           }
           else {
             /*
              * We got a whole chunk of data, which can be anything from one
              * byte to a set of lines and possibly just a piece of the last
              * line.
@@ -1558,36 +1594,38 @@
                   line_start = ptr+1; /* this skips the zero byte we wrote */
                 }
               }
           }
           break;
         } /* switch */
+        if(Curl_pgrsUpdate(conn))
+          return CURLE_ABORTED_BY_CALLBACK;
       } /* while there's buffer left and loop is requested */
 
       if(error)
         return CURLE_RECV_ERROR;
 
       if(data->info.httpproxycode != 200)
         /* Deal with the possibly already received authenticate
            headers. 'newurl' is set to a new URL if we must loop. */
         Curl_http_auth_act(conn);
 
-      if (closeConnection && data->reqdata.newurl) {
+      if(closeConnection && data->req.newurl) {
         /* Connection closed by server. Don't use it anymore */
         sclose(conn->sock[sockindex]);
         conn->sock[sockindex] = CURL_SOCKET_BAD;
         break;
       }
     } /* END NEGOTIATION PHASE */
-  } while(data->reqdata.newurl);
+  } while(data->req.newurl);
 
-  if(200 != k->httpcode) {
+  if(200 != data->req.httpcode) {
     failf(data, "Received HTTP code %d from proxy after CONNECT",
-          k->httpcode);
+          data->req.httpcode);
 
-    if (closeConnection && data->reqdata.newurl)
+    if(closeConnection && data->req.newurl)
       conn->bits.proxy_connect_closed = TRUE;
 
     return CURLE_RECV_ERROR;
   }
 
   /* If a proxy-authorization header was used for the proxy, then we should
@@ -1596,13 +1634,13 @@
   Curl_safefree(conn->allocptr.proxyuserpwd);
   conn->allocptr.proxyuserpwd = NULL;
 
   data->state.authproxy.done = TRUE;
 
   infof (data, "Proxy replied OK to CONNECT request\n");
-  k->ignorebody = FALSE; /* put it (back) to non-ignore state */
+  data->req.ignorebody = FALSE; /* put it (back) to non-ignore state */
   return CURLE_OK;
 }
 
 /*
  * Curl_http_connect() performs HTTP stuff to do at connect-time, called from
  * the generic Curl_connect().
@@ -1631,32 +1669,32 @@
                                conn->host.name,
                                conn->remote_port);
     if(CURLE_OK != result)
       return result;
   }
 
-  if (conn->bits.tunnel_connecting) {
+  if(conn->bits.tunnel_connecting) {
     /* nothing else to do except wait right now - we're not done here. */
     return CURLE_OK;
   }
 
   if(!data->state.this_is_a_follow) {
     /* this is not a followed location, get the original host name */
-    if (data->state.first_host)
+    if(data->state.first_host)
       /* Free to avoid leaking memory on multiple requests*/
       free(data->state.first_host);
 
     data->state.first_host = strdup(conn->host.name);
     if(!data->state.first_host)
       return CURLE_OUT_OF_MEMORY;
   }
 
   if(conn->protocol & PROT_HTTPS) {
     /* perform SSL initialization */
     if(data->state.used_interface == Curl_if_multi) {
-      result = Curl_https_connecting(conn, done);
+      result = https_connecting(conn, done);
       if(result)
         return result;
     }
     else {
       /* BLOCKING */
       result = Curl_ssl_connect(conn, FIRSTSOCKET);
@@ -1669,13 +1707,13 @@
     *done = TRUE;
   }
 
   return CURLE_OK;
 }
 
-static CURLcode Curl_https_connecting(struct connectdata *conn, bool *done)
+static CURLcode https_connecting(struct connectdata *conn, bool *done)
 {
   CURLcode result;
   DEBUGASSERT((conn) && (conn->protocol & PROT_HTTPS));
 
   /* perform SSL initialization for this socket */
   result = Curl_ssl_connect_nonblocking(conn, FIRSTSOCKET, done);
@@ -1685,60 +1723,60 @@
   return CURLE_OK;
 }
 
 #ifdef USE_SSLEAY
 /* This function is OpenSSL-specific. It should be made to query the generic
    SSL layer instead. */
-static int Curl_https_getsock(struct connectdata *conn,
+static int https_getsock(struct connectdata *conn,
                               curl_socket_t *socks,
                               int numsocks)
 {
-  if (conn->protocol & PROT_HTTPS) {
+  if(conn->protocol & PROT_HTTPS) {
     struct ssl_connect_data *connssl = &conn->ssl[FIRSTSOCKET];
 
     if(!numsocks)
       return GETSOCK_BLANK;
 
-    if (connssl->connecting_state == ssl_connect_2_writing) {
+    if(connssl->connecting_state == ssl_connect_2_writing) {
       /* write mode */
       socks[0] = conn->sock[FIRSTSOCKET];
       return GETSOCK_WRITESOCK(0);
     }
-    else if (connssl->connecting_state == ssl_connect_2_reading) {
+    else if(connssl->connecting_state == ssl_connect_2_reading) {
       /* read mode */
       socks[0] = conn->sock[FIRSTSOCKET];
       return GETSOCK_READSOCK(0);
     }
   }
   return CURLE_OK;
 }
 #else
 #ifdef USE_GNUTLS
-int Curl_https_getsock(struct connectdata *conn,
+int https_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
 {
   (void)conn;
   (void)socks;
   (void)numsocks;
   return GETSOCK_BLANK;
 }
 #else
 #ifdef USE_NSS
-int Curl_https_getsock(struct connectdata *conn,
+int https_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
 {
   (void)conn;
   (void)socks;
   (void)numsocks;
   return GETSOCK_BLANK;
 }
 #else
 #ifdef USE_QSOSSL
-int Curl_https_getsock(struct connectdata *conn,
+int https_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
 {
   (void)conn;
   (void)socks;
   (void)numsocks;
@@ -1755,51 +1793,52 @@
  */
 
 CURLcode Curl_http_done(struct connectdata *conn,
                         CURLcode status, bool premature)
 {
   struct SessionHandle *data = conn->data;
-  struct HTTP *http =data->reqdata.proto.http;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct HTTP *http =data->state.proto.http;
   (void)premature; /* not used */
 
   /* set the proper values (possibly modified on POST) */
   conn->fread_func = data->set.fread_func; /* restore */
   conn->fread_in = data->set.in; /* restore */
+  conn->seek_func = data->set.seek_func; /* restore */
+  conn->seek_client = data->set.seek_client; /* restore */
 
-  if (http == NULL)
+  if(http == NULL)
     return CURLE_OK;
 
   if(http->send_buffer) {
     send_buffer *buff = http->send_buffer;
 
     free(buff->buffer);
     free(buff);
     http->send_buffer = NULL; /* clear the pointer */
   }
 
   if(HTTPREQ_POST_FORM == data->set.httpreq) {
-    k->bytecount = http->readbytecount + http->writebytecount;
+    data->req.bytecount = http->readbytecount + http->writebytecount;
 
     Curl_formclean(&http->sendit); /* Now free that whole lot */
     if(http->form.fp) {
       /* a file being uploaded was left opened, close it! */
       fclose(http->form.fp);
       http->form.fp = NULL;
     }
   }
   else if(HTTPREQ_PUT == data->set.httpreq)
-    k->bytecount = http->readbytecount + http->writebytecount;
+    data->req.bytecount = http->readbytecount + http->writebytecount;
 
-  if (status != CURLE_OK)
+  if(status != CURLE_OK)
     return (status);
 
   if(!conn->bits.retry &&
      ((http->readbytecount +
-       data->reqdata.keep.headerbytecount -
-       data->reqdata.keep.deductheadercount)) <= 0) {
+       data->req.headerbytecount -
+       data->req.deductheadercount)) <= 0) {
     /* If this connection isn't simply closed to be retried, AND nothing was
        read from the HTTP server (that counts), this can't be right so we
        return an error here */
     failf(data, "Empty reply from server");
     return CURLE_GOT_NOTHING;
   }
@@ -1876,13 +1915,13 @@
 CURLcode Curl_http(struct connectdata *conn, bool *done)
 {
   struct SessionHandle *data=conn->data;
   char *buf = data->state.buffer; /* this is a short cut to the buffer */
   CURLcode result=CURLE_OK;
   struct HTTP *http;
-  char *ppath = data->reqdata.path;
+  char *ppath = data->state.path;
   char ftp_typecode[sizeof(";type=?")] = "";
   char *host = conn->host.name;
   const char *te = ""; /* transfer-encoding */
   char *ptr;
   char *request;
   Curl_HttpReq httpreq = data->set.httpreq;
@@ -1895,24 +1934,24 @@
   *done = TRUE;
 
   /* If there already is a protocol-specific struct allocated for this
      sessionhandle, deal with it */
   Curl_reset_reqproto(conn);
 
-  if(!data->reqdata.proto.http) {
+  if(!data->state.proto.http) {
     /* Only allocate this struct if we don't already have it! */
 
     http = (struct HTTP *)calloc(sizeof(struct HTTP), 1);
     if(!http)
       return CURLE_OUT_OF_MEMORY;
-    data->reqdata.proto.http = http;
+    data->state.proto.http = http;
   }
   else
-    http = data->reqdata.proto.http;
+    http = data->state.proto.http;
 
-  if ( (conn->protocol&(PROT_HTTP|PROT_FTP)) &&
+  if( (conn->protocol&(PROT_HTTP|PROT_FTP)) &&
        data->set.upload) {
     httpreq = HTTPREQ_PUT;
   }
 
   /* Now set the 'request' pointer to the proper request string */
   if(data->set.str[STRING_CUSTOMREQUEST])
@@ -1948,13 +1987,13 @@
   if(checkheaders(data, "User-Agent:") && conn->allocptr.uagent) {
     free(conn->allocptr.uagent);
     conn->allocptr.uagent=NULL;
   }
 
   /* setup the authentication headers */
-  result = Curl_http_output_auth(conn, request, ppath, FALSE);
+  result = http_output_auth(conn, request, ppath, FALSE);
   if(result)
     return result;
 
   if((data->state.authhost.multi || data->state.authproxy.multi) &&
      (httpreq != HTTPREQ_GET) &&
      (httpreq != HTTPREQ_HEAD)) {
@@ -1987,13 +2026,13 @@
   if(ptr) {
     /* Some kind of TE is requested, check if 'chunked' is chosen */
     conn->bits.upload_chunky =
       Curl_compareheader(ptr, "Transfer-Encoding:", "chunked");
   }
   else {
-    if (httpreq == HTTPREQ_GET)
+    if(httpreq == HTTPREQ_GET)
       conn->bits.upload_chunky = FALSE;
     if(conn->bits.upload_chunky)
       te = "Transfer-Encoding: chunked\r\n";
   }
 
   Curl_safefree(conn->allocptr.host);
@@ -2032,13 +2071,13 @@
   else {
     /* When building Host: headers, we must put the host name within
        [brackets] if the host name is a plain IPv6-address. RFC2732-style. */
 
     if(((conn->protocol&PROT_HTTPS) && (conn->remote_port == PORT_HTTPS)) ||
        (!(conn->protocol&PROT_HTTPS) && (conn->remote_port == PORT_HTTP)) )
-      /* If (HTTPS on port 443) OR (non-HTTPS on port 80) then don't include
+      /* if(HTTPS on port 443) OR (non-HTTPS on port 80) then don't include
          the port number in the host string */
       conn->allocptr.host = aprintf("Host: %s%s%s\r\n",
                                     conn->bits.ipv6_ip?"[":"",
                                     host,
                                     conn->bits.ipv6_ip?"]":"");
     else
@@ -2050,13 +2089,13 @@
 
     if(!conn->allocptr.host)
       /* without Host: we can't make a nice request */
       return CURLE_OUT_OF_MEMORY;
   }
 
-  if (conn->bits.httpproxy && !conn->bits.tunnel_proxy)  {
+  if(conn->bits.httpproxy && !conn->bits.tunnel_proxy)  {
     /* Using a proxy but does not tunnel through it */
 
     /* The path sent to the proxy is in fact the entire URL. But if the remote
        host is a IDN-name, we must make sure that the request we produce only
        uses the encoded host name! */
     if(conn->host.dispname != conn->host.name) {
@@ -2091,28 +2130,30 @@
         }
         else
           return CURLE_OUT_OF_MEMORY;
       }
     }
     ppath = data->change.url;
-    /* when doing ftp, append ;type=<a|i> if not present */
-    if (checkprefix("ftp://", ppath) || checkprefix("ftps://", ppath)) {
-      char *p = strstr(ppath, ";type=");
-      if (p && p[6] && p[7] == 0) {
-        switch (toupper((int)((unsigned char)p[6]))) {
-        case 'A':
-        case 'D':
-        case 'I':
-          break;
-        default:
-          p = NULL;
+    if (data->set.proxy_transfer_mode) {
+      /* when doing ftp, append ;type=<a|i> if not present */
+      if(checkprefix("ftp://", ppath) || checkprefix("ftps://", ppath)) {
+        char *p = strstr(ppath, ";type=");
+        if(p && p[6] && p[7] == 0) {
+          switch (toupper((int)((unsigned char)p[6]))) {
+          case 'A':
+          case 'D':
+          case 'I':
+            break;
+          default:
+            p = NULL;
+          }
         }
+        if(!p)
+          snprintf(ftp_typecode, sizeof(ftp_typecode), ";type=%c",
+                   data->set.prefer_ascii ? 'a' : 'i');
       }
-      if (!p)
-        snprintf(ftp_typecode, sizeof(ftp_typecode), ";type=%c",
-                 data->set.prefer_ascii ? 'a' : 'i');
     }
   }
   if(HTTPREQ_POST_FORM == httpreq) {
     /* we must build the whole darned post sequence first, so that we have
        a size of the whole shebang before we start to send it */
      result = Curl_getFormData(&http->sendit, data->set.httppost,
@@ -2134,105 +2175,116 @@
   if(!checkheaders(data, "Accept:"))
     http->p_accept = "Accept: */*\r\n";
 
   if(( (HTTPREQ_POST == httpreq) ||
        (HTTPREQ_POST_FORM == httpreq) ||
        (HTTPREQ_PUT == httpreq) ) &&
-     data->reqdata.resume_from) {
+     data->state.resume_from) {
     /**********************************************************************
      * Resuming upload in HTTP means that we PUT or POST and that we have
      * got a resume_from value set. The resume value has already created
      * a Range: header that will be passed along. We need to "fast forward"
      * the file the given number of bytes and decrease the assume upload
      * file size before we continue this venture in the dark lands of HTTP.
      *********************************************************************/
 
-    if(data->reqdata.resume_from < 0 ) {
+    if(data->state.resume_from < 0 ) {
       /*
        * This is meant to get the size of the present remote-file by itself.
        * We don't support this now. Bail out!
        */
-       data->reqdata.resume_from = 0;
+       data->state.resume_from = 0;
     }
 
-    if(data->reqdata.resume_from && !data->state.this_is_a_follow) {
+    if(data->state.resume_from && !data->state.this_is_a_follow) {
       /* do we still game? */
-      curl_off_t passed=0;
 
       /* Now, let's read off the proper amount of bytes from the
-         input. If we knew it was a proper file we could've just
-         fseek()ed but we only have a stream here */
-      do {
-        size_t readthisamountnow = (size_t)(data->reqdata.resume_from - passed);
-        size_t actuallyread;
-
-        if(readthisamountnow > BUFSIZE)
-          readthisamountnow = BUFSIZE;
-
-        actuallyread =
-          data->set.fread_func(data->state.buffer, 1, (size_t)readthisamountnow,
-                          data->set.in);
-
-        passed += actuallyread;
-        if(actuallyread != readthisamountnow) {
-          failf(data, "Could only read %" FORMAT_OFF_T
-                " bytes from the input",
-                passed);
+         input. */
+      if(conn->seek_func) {
+        curl_off_t readthisamountnow = data->state.resume_from;
+
+        if(conn->seek_func(conn->seek_client,
+			   readthisamountnow, SEEK_SET) != 0) {
+          failf(data, "Could not seek stream");
           return CURLE_READ_ERROR;
         }
-      } while(passed != data->reqdata.resume_from); /* loop until done */
+      }
+      else {
+	curl_off_t passed=0;
+
+        do {
+	  size_t readthisamountnow = (size_t)(data->state.resume_from - passed);
+          size_t actuallyread;
+
+          if(readthisamountnow > BUFSIZE)
+            readthisamountnow = BUFSIZE;
+
+          actuallyread = data->set.fread_func(data->state.buffer, 1,
+                                              (size_t)readthisamountnow,
+                                              data->set.in);
+
+          passed += actuallyread;
+          if(actuallyread != readthisamountnow) {
+            failf(data, "Could only read %" FORMAT_OFF_T
+                  " bytes from the input",
+                  passed);
+            return CURLE_READ_ERROR;
+          }
+        } while(passed != data->state.resume_from); /* loop until done */
+      }
 
       /* now, decrease the size of the read */
       if(data->set.infilesize>0) {
-        data->set.infilesize -= data->reqdata.resume_from;
+        data->set.infilesize -= data->state.resume_from;
 
         if(data->set.infilesize <= 0) {
           failf(data, "File already completely uploaded");
           return CURLE_PARTIAL_FILE;
         }
       }
       /* we've passed, proceed as normal */
     }
   }
-  if(data->reqdata.use_range) {
+  if(data->state.use_range) {
     /*
      * A range is selected. We use different headers whether we're downloading
      * or uploading and we always let customized headers override our internal
      * ones if any such are specified.
      */
     if((httpreq == HTTPREQ_GET) &&
        !checkheaders(data, "Range:")) {
       /* if a line like this was already allocated, free the previous one */
       if(conn->allocptr.rangeline)
         free(conn->allocptr.rangeline);
       conn->allocptr.rangeline = aprintf("Range: bytes=%s\r\n",
-                                         data->reqdata.range);
+                                         data->state.range);
     }
     else if((httpreq != HTTPREQ_GET) &&
             !checkheaders(data, "Content-Range:")) {
 
       /* if a line like this was already allocated, free the previous one */
       if(conn->allocptr.rangeline)
         free(conn->allocptr.rangeline);
 
-      if(data->reqdata.resume_from) {
+      if(data->state.resume_from) {
         /* This is because "resume" was selected */
         curl_off_t total_expected_size=
-          data->reqdata.resume_from + data->set.infilesize;
+          data->state.resume_from + data->set.infilesize;
         conn->allocptr.rangeline =
             aprintf("Content-Range: bytes %s%" FORMAT_OFF_T
                     "/%" FORMAT_OFF_T "\r\n",
-                    data->reqdata.range, total_expected_size-1,
+                    data->state.range, total_expected_size-1,
                     total_expected_size);
       }
       else {
         /* Range was selected and then we just pass the incoming range and
            append total size */
         conn->allocptr.rangeline =
             aprintf("Content-Range: bytes %s/%" FORMAT_OFF_T "\r\n",
-                    data->reqdata.range, data->set.infilesize);
+                    data->state.range, data->set.infilesize);
       }
       if(!conn->allocptr.rangeline)
         return CURLE_OUT_OF_MEMORY;
     }
   }
 
@@ -2271,13 +2323,13 @@
                 ppath,
                 ftp_typecode,
                 httpstring,
                 conn->allocptr.proxyuserpwd?
                 conn->allocptr.proxyuserpwd:"",
                 conn->allocptr.userpwd?conn->allocptr.userpwd:"",
-                (data->reqdata.use_range && conn->allocptr.rangeline)?
+                (data->state.use_range && conn->allocptr.rangeline)?
                 conn->allocptr.rangeline:"",
                 (data->set.str[STRING_USERAGENT] &&
                  *data->set.str[STRING_USERAGENT] && conn->allocptr.uagent)?
                 conn->allocptr.uagent:"",
                 (conn->allocptr.host?conn->allocptr.host:""), /* Host: host */
                 http->p_pragma?http->p_pragma:"",
@@ -2304,13 +2356,14 @@
       int count=0;
 
       if(data->cookies) {
         Curl_share_lock(data, CURL_LOCK_DATA_COOKIE, CURL_LOCK_ACCESS_SINGLE);
         co = Curl_cookie_getlist(data->cookies,
                                  conn->allocptr.cookiehost?
-                                 conn->allocptr.cookiehost:host, data->reqdata.path,
+                                 conn->allocptr.cookiehost:host,
+                                 data->state.path,
                                  (bool)(conn->protocol&PROT_HTTPS?TRUE:FALSE));
         Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
       }
       if(co) {
         struct Cookie *store=co;
         /* now loop through all cookies that matched */
@@ -2327,13 +2380,13 @@
             if(result)
               break;
             count++;
           }
           co = co->next; /* next cookie please */
         }
-        Curl_cookie_freelist(store); /* free the cookie list */
+        Curl_cookie_freelist(store, FALSE); /* free the cookie list */
       }
       if(addcookies && (CURLE_OK == result)) {
         if(!count)
           result = add_bufferf(req_buffer, "Cookie: ");
         if(CURLE_OK == result) {
           result = add_bufferf(req_buffer, "%s%s",
@@ -2579,23 +2632,25 @@
         result = add_bufferf(req_buffer,
                              "Content-Type: application/x-www-form-urlencoded\r\n");
         if(result)
           return result;
       }
 
-      if(data->set.postfields) {
+      /* For really small posts we don't use Expect: headers at all, and for
+         the somewhat bigger ones we allow the app to disable it. Just make
+         sure that the expect100header is always set to the preferred value
+         here. */
+      if(postsize > TINY_INITIAL_POST_SIZE) {
+        result = expect100(data, req_buffer);
+        if(result)
+          return result;
+      }
+      else
+        data->state.expect100header = FALSE;
 
-        /* for really small posts we don't use Expect: headers at all, and for
-           the somewhat bigger ones we allow the app to disable it */
-        if(postsize > TINY_INITIAL_POST_SIZE) {
-          result = expect100(data, req_buffer);
-          if(result)
-            return result;
-        }
-        else
-          data->state.expect100header = FALSE;
+      if(data->set.postfields) {
 
         if(!data->state.expect100header &&
            (postsize < MAX_INITIAL_POST_SIZE))  {
           /* if we don't use expect: 100  AND
              postsize is less than MAX_INITIAL_POST_SIZE
 
@@ -2653,15 +2708,19 @@
           return result;
 
         if(data->set.postfieldsize) {
           /* set the upload size to the progress meter */
           Curl_pgrsSetUploadSize(data, postsize?postsize:-1);
 
-          /* set the pointer to mark that we will send the post body using
-             the read callback */
-          http->postdata = (char *)&http->postdata;
+          /* set the pointer to mark that we will send the post body using the
+             read callback, but only if we're not in authenticate
+             negotiation  */
+          if(!conn->bits.authneg) {
+            http->postdata = (char *)&http->postdata;
+            http->postsize = postsize;
+          }
         }
       }
       /* issue the request */
       result = add_buffer_send(req_buffer, conn, &data->info.request_size,
                                (size_t)included_body, FIRSTSOCKET);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_chunks.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_chunks.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_chunks.c	2007-10-02 18:21:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_chunks.c	2008-01-03 06:33:19.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http_chunks.c,v 1.38 2007-10-02 10:21:36 bagder Exp $
+ * $Id: http_chunks.c,v 1.42 2008-01-02 22:30:34 bagder Exp $
  ***************************************************************************/
 #include "setup.h"
 
 #ifndef CURL_DISABLE_HTTP
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -106,23 +106,26 @@
                               ssize_t datalen,
                               ssize_t *wrotep)
 {
   CURLcode result=CURLE_OK;
   struct SessionHandle *data = conn->data;
   struct Curl_chunker *ch = &conn->chunk;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct SingleRequest *k = &data->req;
   size_t piece;
   size_t length = (size_t)datalen;
   size_t *wrote = (size_t *)wrotep;
 
   *wrote = 0; /* nothing's written yet */
 
   /* the original data is written to the client, but we go on with the
      chunk read process, to properly calculate the content length*/
-  if (data->set.http_te_skip && !k->ignorebody)
-    Curl_client_write(conn, CLIENTWRITE_BODY, datap,datalen);
+  if(data->set.http_te_skip && !k->ignorebody) {
+    result = Curl_client_write(conn, CLIENTWRITE_BODY, datap, datalen);
+    if(result)
+      return CHUNKE_WRITE_ERROR;
+  }
 
   while(length) {
     switch(ch->state) {
     case CHUNK_HEX:
       /* Check for an ASCII hex digit.
          We avoid the use of isxdigit to accommodate non-ASCII hosts. */
@@ -175,13 +178,13 @@
 
     case CHUNK_CR:
       /* waiting for the LF */
       if(*datap == 0x0a) {
         /* we're now expecting data to come, unless size was zero! */
         if(0 == ch->datasize) {
-          if (conn->bits.trailerHdrPresent!=TRUE) {
+          if(conn->bits.trailerhdrpresent!=TRUE) {
             /* No Trailer: header found - revert to original Curl processing */
             ch->state = CHUNK_STOPCR;
 
             /* We need to increment the datap here since we bypass the
                increment below with the immediate break */
             length--;
@@ -214,36 +217,36 @@
       */
       piece = (ch->datasize >= length)?length:ch->datasize;
 
       /* Write the data portion available */
 #ifdef HAVE_LIBZ
       switch (conn->data->set.http_ce_skip?
-              IDENTITY : data->reqdata.keep.content_encoding) {
+              IDENTITY : data->req.content_encoding) {
       case IDENTITY:
 #endif
         if(!k->ignorebody) {
-          if ( !data->set.http_te_skip )
+          if( !data->set.http_te_skip )
             result = Curl_client_write(conn, CLIENTWRITE_BODY, datap,
                                        piece);
           else
             result = CURLE_OK;
         }
 #ifdef HAVE_LIBZ
         break;
 
       case DEFLATE:
-        /* update data->reqdata.keep.str to point to the chunk data. */
-        data->reqdata.keep.str = datap;
-        result = Curl_unencode_deflate_write(conn, &data->reqdata.keep,
+        /* update data->req.keep.str to point to the chunk data. */
+        data->req.str = datap;
+        result = Curl_unencode_deflate_write(conn, &data->req,
                                              (ssize_t)piece);
         break;
 
       case GZIP:
-        /* update data->reqdata.keep.str to point to the chunk data. */
-        data->reqdata.keep.str = datap;
-        result = Curl_unencode_gzip_write(conn, &data->reqdata.keep,
+        /* update data->req.keep.str to point to the chunk data. */
+        data->req.str = datap;
+        result = Curl_unencode_gzip_write(conn, &data->req,
                                           (ssize_t)piece);
         break;
 
       case COMPRESS:
       default:
         failf (conn->data,
@@ -295,13 +298,13 @@
 
       break;
 
     case CHUNK_TRAILER:
       /* conn->trailer is assumed to be freed in url.c on a
          connection basis */
-      if (conn->trlPos >= conn->trlMax) {
+      if(conn->trlPos >= conn->trlMax) {
         char *ptr;
         if(conn->trlMax) {
           conn->trlMax *= 2;
           ptr = (char*)realloc(conn->trailer,conn->trlMax);
         }
         else {
@@ -330,16 +333,16 @@
       }
       else
         return CHUNKE_BAD_CHUNK;
       break;
 
     case CHUNK_TRAILER_POSTCR:
-      if (*datap == 0x0a) {
+      if(*datap == 0x0a) {
         conn->trailer[conn->trlPos++]=0x0a;
         conn->trailer[conn->trlPos]=0;
-        if (conn->trlPos==2) {
+        if(conn->trlPos==2) {
           ch->state = CHUNK_STOP;
           datap++;
           length--;
 
           /*
            * Note that this case skips over the final STOP states since we've
@@ -359,15 +362,18 @@
           if(result != CURLE_OK) {
             /* Curl_convert_from_network calls failf if unsuccessful */
             /* Treat it as a bad chunk */
             return(CHUNKE_BAD_CHUNK);
           }
 #endif /* CURL_DOES_CONVERSIONS */
-          if ( !data->set.http_te_skip )
-            Curl_client_write(conn, CLIENTWRITE_HEADER,
-                              conn->trailer, conn->trlPos);
+          if(!data->set.http_te_skip) {
+            result = Curl_client_write(conn, CLIENTWRITE_HEADER,
+                                       conn->trailer, conn->trlPos);
+            if(result)
+              return CHUNKE_WRITE_ERROR;
+          }
         }
         ch->state = CHUNK_TRAILER;
         conn->trlPos=0;
         datap++;
         length--;
       }
@@ -386,13 +392,13 @@
       else {
         return CHUNKE_BAD_CHUNK;
       }
       break;
 
     case CHUNK_STOP:
-      if (*datap == 0x0a) {
+      if(*datap == 0x0a) {
         datap++;
         length--;
 
         /* Record the length of any data left in the end of the buffer
            even if there's no more chunks to read */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_digest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_digest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_digest.c	2007-08-27 21:01:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_digest.c	2008-01-10 18:01:48.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http_digest.c,v 1.31 2007-08-27 06:31:28 danf Exp $
+ * $Id: http_digest.c,v 1.34 2008-01-10 09:17:07 bagder Exp $
  ***************************************************************************/
 #include "setup.h"
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_CRYPTO_AUTH)
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -87,25 +87,25 @@
       before = TRUE;
 
     /* clear off any former leftovers and init to defaults */
     Curl_digest_cleanup_one(d);
 
     while(more) {
-      char value[32];
-      char content[128];
+      char value[256];
+      char content[1024];
       size_t totlen=0;
 
       while(*header && ISSPACE(*header))
         header++;
 
       /* how big can these strings be? */
-      if((2 == sscanf(header, "%31[^=]=\"%127[^\"]\"",
+      if((2 == sscanf(header, "%255[^=]=\"%1023[^\"]\"",
                       value, content)) ||
          /* try the same scan but without quotes around the content but don't
             include the possibly trailing comma, newline or carriage return */
-         (2 ==  sscanf(header, "%31[^=]=%127[^\r\n,]",
+         (2 ==  sscanf(header, "%255[^=]=%1023[^\r\n,]",
                        value, content)) ) {
         if(strequal(value, "nonce")) {
           d->nonce = strdup(content);
           if(!d->nonce)
             return CURLDIGEST_NOMEM;
         }
@@ -130,29 +130,29 @@
           /* tokenize the list and choose auth if possible, use a temporary
              clone of the buffer since strtok_r() ruins it */
           tmp = strdup(content);
           if(!tmp)
             return CURLDIGEST_NOMEM;
           token = strtok_r(tmp, ",", &tok_buf);
-          while (token != NULL) {
-            if (strequal(token, "auth")) {
+          while(token != NULL) {
+            if(strequal(token, "auth")) {
               foundAuth = TRUE;
             }
-            else if (strequal(token, "auth-int")) {
+            else if(strequal(token, "auth-int")) {
               foundAuthInt = TRUE;
             }
             token = strtok_r(NULL, ",", &tok_buf);
           }
           free(tmp);
           /*select only auth o auth-int. Otherwise, ignore*/
-          if (foundAuth) {
+          if(foundAuth) {
             d->qop = strdup("auth");
             if(!d->qop)
               return CURLDIGEST_NOMEM;
           }
-          else if (foundAuthInt) {
+          else if(foundAuthInt) {
             d->qop = strdup("auth-int");
             if(!d->qop)
               return CURLDIGEST_NOMEM;
           }
         }
         else if(strequal(value, "algorithm")) {
@@ -177,12 +177,15 @@
           totlen += 2;
       }
       else
         break; /* we're done here */
 
       header += totlen;
+      /* pass all additional spaces here */
+      while(*header && ISSPACE(*header))
+        header++;
       if(',' == *header)
         /* allow the list to be comma-separated */
         header++;
     }
     /* We had a nonce since before, and we got another one now without
        'stale=true'. This means we provided bad credentials in the previous
@@ -240,13 +243,13 @@
 /* The CURL_OUTPUT_DIGEST_CONV macro below is for non-ASCII machines.
    It converts digest text to ASCII so the MD5 will be correct for 
    what ultimately goes over the network.
 */
 #define CURL_OUTPUT_DIGEST_CONV(a, b) \
   rc = Curl_convert_to_network(a, (char *)b, strlen((const char*)b)); \
-  if (rc != CURLE_OK) { \
+  if(rc != CURLE_OK) { \
     free(b); \
     return rc; \
   }
 #else
 #define CURL_OUTPUT_DIGEST_CONV(a, b)
 #endif /* CURL_DOES_CONVERSIONS */
@@ -263,13 +266,13 @@
     allocuserpwd = &conn->allocptr.userpwd;
     userp = conn->user;
     passwdp = conn->passwd;
     authp = &data->state.authhost;
   }
 
-  if (*allocuserpwd) {
+  if(*allocuserpwd) {
     Curl_safefree(*allocuserpwd);
     *allocuserpwd = NULL;
   }
 
   /* not set means empty */
   if(!userp)
@@ -350,23 +353,23 @@
   md5this = (unsigned char *)aprintf("%s:%s", request, uripath);
   if(!md5this) {
     free(ha1);
     return CURLE_OUT_OF_MEMORY;
   }
 
-  if (d->qop && strequal(d->qop, "auth-int")) {
+  if(d->qop && strequal(d->qop, "auth-int")) {
     /* We don't support auth-int at the moment. I can't see a easy way to get
        entity-body here */
     /* TODO: Append H(entity-body)*/
   }
   CURL_OUTPUT_DIGEST_CONV(data, md5this); /* convert on non-ASCII machines */
   Curl_md5it(md5buf, md5this);
   free(md5this); /* free this again */
   md5_to_ascii(md5buf, ha2);
 
-  if (d->qop) {
+  if(d->qop) {
     md5this = (unsigned char *)aprintf("%s:%s:%08x:%s:%s:%s",
                                        ha1,
                                        d->nonce,
                                        d->nc,
                                        d->cnonce,
                                        d->qop,
@@ -390,13 +393,13 @@
   /* for test case 64 (snooped from a Mozilla 1.3a request)
 
     Authorization: Digest username="testuser", realm="testrealm", \
     nonce="1053604145", uri="/64", response="c55f7f30d83d774a3d2dcacf725abaca"
   */
 
-  if (d->qop) {
+  if(d->qop) {
     *allocuserpwd =
       aprintf( "%sAuthorization: Digest "
                "username=\"%s\", "
                "realm=\"%s\", "
                "nonce=\"%s\", "
                "uri=\"%s\", "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_negotiate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_negotiate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_negotiate.c	2007-09-21 19:18:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_negotiate.c	2007-11-21 07:17:08.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http_negotiate.c,v 1.21 2007-09-21 11:05:31 bagder Exp $
+ * $Id: http_negotiate.c,v 1.24 2007-11-20 23:17:08 bagder Exp $
  ***************************************************************************/
 #include "setup.h"
 
 #ifdef HAVE_GSSAPI
 #ifdef HAVE_GSSMIT
 #define GSS_C_NT_HOSTBASED_SERVICE gss_nt_service_name
@@ -48,35 +48,38 @@
 /* The last #include file should be: */
 #include "memdebug.h"
 
 static int
 get_gss_name(struct connectdata *conn, bool proxy, gss_name_t *server)
 {
-  struct negotiatedata *neg_ctx = &conn->data->state.negotiate;
+  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
+    &conn->data->state.negotiate;
   OM_uint32 major_status, minor_status;
   gss_buffer_desc token = GSS_C_EMPTY_BUFFER;
   char name[2048];
   const char* service;
 
   /* GSSAPI implementation by Globus (known as GSI) requires the name to be
      of form "<service>/<fqdn>" instead of <service>@<fqdn> (ie. slash instead
      of at-sign). Also GSI servers are often identified as 'host' not 'khttp'.
      Change following lines if you want to use GSI */
 
   /* IIS uses the <service>@<fqdn> form but uses 'http' as the service name */
 
-  if (neg_ctx->gss)
+  if(neg_ctx->gss)
     service = "KHTTP";
   else
     service = "HTTP";
 
-  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name : conn->host.name) + 1;
-  if (token.length + 1 > sizeof(name))
+  token.length = strlen(service) + 1 + strlen(proxy ? conn->proxy.name :
+                                              conn->host.name) + 1;
+  if(token.length + 1 > sizeof(name))
     return EMSGSIZE;
 
-  snprintf(name, sizeof(name), "%s@%s", service, proxy ? conn->proxy.name : conn->host.name);
+  snprintf(name, sizeof(name), "%s@%s", service, proxy ? conn->proxy.name :
+           conn->host.name);
 
   token.value = (void *) name;
   major_status = gss_import_name(&minor_status,
                                  &token,
                                  GSS_C_NT_HOSTBASED_SERVICE,
                                  server);
@@ -93,32 +96,34 @@
   char buf[1024];
   size_t len;
 
   snprintf(buf, sizeof(buf), "%s", prefix);
   len = strlen(buf);
   do {
-    maj_stat = gss_display_status (&min_stat,
-                                   error_status,
-                                   GSS_C_MECH_CODE,
-                                   GSS_C_NO_OID,
-                                   &msg_ctx,
-                                   &status_string);
-      if (sizeof(buf) > len + status_string.length + 1) {
+    maj_stat = gss_display_status(&min_stat,
+                                  error_status,
+                                  GSS_C_MECH_CODE,
+                                  GSS_C_NO_OID,
+                                  &msg_ctx,
+                                  &status_string);
+      if(sizeof(buf) > len + status_string.length + 1) {
         snprintf(buf + len, sizeof(buf) - len,
                  ": %s", (char*) status_string.value);
       len += status_string.length;
     }
     gss_release_buffer(&min_stat, &status_string);
-  } while (!GSS_ERROR(maj_stat) && msg_ctx != 0);
+  } while(!GSS_ERROR(maj_stat) && msg_ctx != 0);
 
   infof(conn->data, "%s", buf);
 }
 
-int Curl_input_negotiate(struct connectdata *conn, bool proxy, const char *header)
+int Curl_input_negotiate(struct connectdata *conn, bool proxy,
+                         const char *header)
 {
-  struct negotiatedata *neg_ctx = &conn->data->state.negotiate;
+  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
+    &conn->data->state.negotiate;
   OM_uint32 major_status, minor_status, minor_status2;
   gss_buffer_desc input_token = GSS_C_EMPTY_BUFFER;
   gss_buffer_desc output_token = GSS_C_EMPTY_BUFFER;
   int ret;
   size_t len;
   bool gss;
@@ -127,68 +132,69 @@
   while(*header && ISSPACE(*header))
     header++;
   if(checkprefix("GSS-Negotiate", header)) {
     protocol = "GSS-Negotiate";
     gss = TRUE;
   }
-  else if (checkprefix("Negotiate", header)) {
+  else if(checkprefix("Negotiate", header)) {
     protocol = "Negotiate";
     gss = FALSE;
   }
   else
     return -1;
 
-  if (neg_ctx->context) {
-    if (neg_ctx->gss != gss) {
+  if(neg_ctx->context) {
+    if(neg_ctx->gss != gss) {
       return -1;
     }
   }
   else {
     neg_ctx->protocol = protocol;
     neg_ctx->gss = gss;
   }
 
-  if (neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
+  if(neg_ctx->context && neg_ctx->status == GSS_S_COMPLETE) {
     /* We finished succesfully our part of authentication, but server
      * rejected it (since we're again here). Exit with an error since we
      * can't invent anything better */
     Curl_cleanup_negotiate(conn->data);
     return -1;
   }
 
-  if (neg_ctx->server_name == NULL &&
+  if(neg_ctx->server_name == NULL &&
       (ret = get_gss_name(conn, proxy, &neg_ctx->server_name)))
     return ret;
 
   header += strlen(neg_ctx->protocol);
   while(*header && ISSPACE(*header))
     header++;
 
   len = strlen(header);
-  if (len > 0) {
-    int rawlen = Curl_base64_decode(header, (unsigned char **)&input_token.value);
-    if (rawlen < 0)
+  if(len > 0) {
+    int rawlen = Curl_base64_decode(header,
+                                    (unsigned char **)&input_token.value);
+    if(rawlen < 0)
       return -1;
     input_token.length = rawlen;
 
 #ifdef HAVE_SPNEGO /* Handle SPNEGO */
-    if (checkprefix("Negotiate", header)) {
+    if(checkprefix("Negotiate", header)) {
         ASN1_OBJECT *   object            = NULL;
         int             rc                = 1;
         unsigned char * spnegoToken       = NULL;
         size_t          spnegoTokenLength = 0;
         unsigned char * mechToken         = NULL;
         size_t          mechTokenLength   = 0;
 
         spnegoToken = malloc(input_token.length);
-        if (input_token.value == NULL)
+        if(input_token.value == NULL)
           return ENOMEM;
         spnegoTokenLength = input_token.length;
 
         object = OBJ_txt2obj ("1.2.840.113554.1.2.2", 1);
-        if (!parseSpnegoTargetToken(spnegoToken,
+        if(!parseSpnegoTargetToken(spnegoToken,
                                     spnegoTokenLength,
                                     NULL,
                                     NULL,
                                     &mechToken,
                                     &mechTokenLength,
                                     NULL,
@@ -221,58 +227,59 @@
                                       GSS_C_NO_CHANNEL_BINDINGS,
                                       &input_token,
                                       NULL,
                                       &output_token,
                                       NULL,
                                       NULL);
-  if (input_token.length > 0)
+  if(input_token.length > 0)
     gss_release_buffer(&minor_status2, &input_token);
   neg_ctx->status = major_status;
-  if (GSS_ERROR(major_status)) {
+  if(GSS_ERROR(major_status)) {
     /* Curl_cleanup_negotiate(conn->data) ??? */
     log_gss_error(conn, minor_status,
                   (char *)"gss_init_sec_context() failed: ");
     return -1;
   }
 
-  if (output_token.length == 0) {
+  if(output_token.length == 0) {
     return -1;
   }
 
   neg_ctx->output_token = output_token;
   /* conn->bits.close = FALSE; */
 
   return 0;
 }
 
 
 CURLcode Curl_output_negotiate(struct connectdata *conn, bool proxy)
 {
-  struct negotiatedata *neg_ctx = &conn->data->state.negotiate;
+  struct negotiatedata *neg_ctx = proxy?&conn->data->state.proxyneg:
+    &conn->data->state.negotiate;
   OM_uint32 minor_status;
   char *encoded = NULL;
   int len;
 
 #ifdef HAVE_SPNEGO /* Handle SPNEGO */
-  if (checkprefix("Negotiate",neg_ctx->protocol)) {
+  if(checkprefix("Negotiate", neg_ctx->protocol)) {
     ASN1_OBJECT *   object            = NULL;
     int             rc                = 1;
     unsigned char * spnegoToken       = NULL;
     size_t          spnegoTokenLength = 0;
     unsigned char * responseToken       = NULL;
     size_t          responseTokenLength = 0;
 
     responseToken = malloc(neg_ctx->output_token.length);
-    if ( responseToken == NULL)
+    if( responseToken == NULL)
       return CURLE_OUT_OF_MEMORY;
     memcpy(responseToken, neg_ctx->output_token.value,
            neg_ctx->output_token.length);
     responseTokenLength = neg_ctx->output_token.length;
 
     object=OBJ_txt2obj ("1.2.840.113554.1.2.2", 1);
-    if (!makeSpnegoInitialToken (object,
+    if(!makeSpnegoInitialToken (object,
                                  responseToken,
                                  responseTokenLength,
                                  &spnegoToken,
                                  &spnegoTokenLength)) {
       free(responseToken);
       responseToken = NULL;
@@ -292,36 +299,41 @@
 #endif
   len = Curl_base64_encode(conn->data,
                            neg_ctx->output_token.value,
                            neg_ctx->output_token.length,
                            &encoded);
 
-  if (len == 0)
+  if(len == 0)
     return CURLE_OUT_OF_MEMORY;
 
   conn->allocptr.userpwd =
-    aprintf("%sAuthorization: %s %s\r\n", proxy ? "Proxy-" : "", neg_ctx->protocol, encoded);
+    aprintf("%sAuthorization: %s %s\r\n", proxy ? "Proxy-" : "",
+            neg_ctx->protocol, encoded);
   free(encoded);
   gss_release_buffer(&minor_status, &neg_ctx->output_token);
   return (conn->allocptr.userpwd == NULL) ? CURLE_OUT_OF_MEMORY : CURLE_OK;
 }
 
-void Curl_cleanup_negotiate(struct SessionHandle *data)
+static void cleanup(struct negotiatedata *neg_ctx)
 {
   OM_uint32 minor_status;
-  struct negotiatedata *neg_ctx = &data->state.negotiate;
-
-  if (neg_ctx->context != GSS_C_NO_CONTEXT)
+  if(neg_ctx->context != GSS_C_NO_CONTEXT)
     gss_delete_sec_context(&minor_status, &neg_ctx->context, GSS_C_NO_BUFFER);
 
-  if (neg_ctx->output_token.length != 0)
+  if(neg_ctx->output_token.length != 0)
     gss_release_buffer(&minor_status, &neg_ctx->output_token);
 
-  if (neg_ctx->server_name != GSS_C_NO_NAME)
+  if(neg_ctx->server_name != GSS_C_NO_NAME)
     gss_release_name(&minor_status, &neg_ctx->server_name);
 
   memset(neg_ctx, 0, sizeof(*neg_ctx));
 }
 
+void Curl_cleanup_negotiate(struct SessionHandle *data)
+{
+  cleanup(&data->state.negotiate);
+  cleanup(&data->state.proxyneg);
+}
+
 
 #endif
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_ntlm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_ntlm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/http_ntlm.c	2007-09-27 19:38:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/http_ntlm.c	2007-11-05 17:45:09.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http_ntlm.c,v 1.67 2007-09-27 01:45:23 danf Exp $
+ * $Id: http_ntlm.c,v 1.68 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 #include "setup.h"
 
 /* NTLM details:
 
    http://davenport.sourceforge.net/ntlm.html
@@ -195,13 +195,13 @@
 }
 
 static void print_hex(FILE *handle, const char *buf, size_t len)
 {
   const char *p = buf;
   fprintf(stderr, "0x");
-  while (len-- > 0)
+  while(len-- > 0)
     fprintf(stderr, "%02.2x", (unsigned int)*p++);
 }
 #else
 # define DEBUG_OUT(x)
 #endif
 
@@ -260,13 +260,13 @@
         return CURLNTLM_BAD;
 
       ntlm->state = NTLMSTATE_TYPE2; /* we got a type-2 */
 
 #ifdef USE_WINDOWS_SSPI
       ntlm->type_2 = malloc(size+1);
-      if (ntlm->type_2 == NULL) {
+      if(ntlm->type_2 == NULL) {
         free(buffer);
         return CURLE_OUT_OF_MEMORY;
       }
       ntlm->n_type_2 = size;
       memcpy(ntlm->type_2, buffer, size);
 #else
@@ -365,13 +365,13 @@
   static const unsigned char magic[] = {
     0x4B, 0x47, 0x53, 0x21, 0x40, 0x23, 0x24, 0x25 /* i.e. KGS!@#$% */
   };
   unsigned int i;
   size_t len = strlen(password);
 
-  if (len > 14)
+  if(len > 14)
     len = 14;
 
   for (i=0; i<len; i++)
     pw[i] = (unsigned char)toupper(password[i]);
 
   for (; i<14; i++)
@@ -422,13 +422,13 @@
 static CURLcode mk_nt_hash(struct SessionHandle *data,
                            char *password,
                            unsigned char *ntbuffer /* 21 bytes */)
 {
   size_t len = strlen(password);
   unsigned char *pw = malloc(len*2);
-  if (!pw)
+  if(!pw)
     return CURLE_OUT_OF_MEMORY;
 
   utf8_to_unicode_le(pw, password, len);
 
 #ifdef CURL_DOES_CONVERSIONS
   /*
@@ -462,25 +462,25 @@
 
 #ifdef USE_WINDOWS_SSPI
 
 static void
 ntlm_sspi_cleanup(struct ntlmdata *ntlm)
 {
-  if (ntlm->type_2) {
+  if(ntlm->type_2) {
     free(ntlm->type_2);
     ntlm->type_2 = NULL;
   }
-  if (ntlm->has_handles) {
+  if(ntlm->has_handles) {
     s_pSecFn->DeleteSecurityContext(&ntlm->c_handle);
     s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
     ntlm->has_handles = 0;
   }
-  if (ntlm->p_identity) {
-    if (ntlm->identity.User) free(ntlm->identity.User);
-    if (ntlm->identity.Password) free(ntlm->identity.Password);
-    if (ntlm->identity.Domain) free(ntlm->identity.Domain);
+  if(ntlm->p_identity) {
+    if(ntlm->identity.User) free(ntlm->identity.User);
+    if(ntlm->identity.Password) free(ntlm->identity.Password);
+    if(ntlm->identity.Domain) free(ntlm->identity.Domain);
     ntlm->p_identity = NULL;
   }
 }
 
 #endif
 
@@ -543,36 +543,36 @@
 
   if(!passwdp)
     passwdp=(char *)"";
 
 #ifdef USE_WINDOWS_SSPI
   /* If security interface is not yet initialized try to do this */
-  if (s_hSecDll == NULL) {
+  if(s_hSecDll == NULL) {
     /* Determine Windows version. Security functions are located in
      * security.dll on WinNT 4.0 and in secur32.dll on Win9x. Win2K and XP
      * contain both these DLLs (security.dll just forwards calls to
      * secur32.dll)
      */
     OSVERSIONINFO osver;
     osver.dwOSVersionInfoSize = sizeof(osver);
     GetVersionEx(&osver);
-    if (osver.dwPlatformId == VER_PLATFORM_WIN32_NT
+    if(osver.dwPlatformId == VER_PLATFORM_WIN32_NT
       && osver.dwMajorVersion == 4)
       s_hSecDll = LoadLibrary("security.dll");
     else
       s_hSecDll = LoadLibrary("secur32.dll");
-    if (s_hSecDll != NULL) {
+    if(s_hSecDll != NULL) {
       INIT_SECURITY_INTERFACE pInitSecurityInterface;
       pInitSecurityInterface =
         (INIT_SECURITY_INTERFACE)GetProcAddress(s_hSecDll,
                                                 "InitSecurityInterfaceA");
-      if (pInitSecurityInterface != NULL)
+      if(pInitSecurityInterface != NULL)
         s_pSecFn = pInitSecurityInterface();
     }
   }
-  if (s_pSecFn == NULL)
+  if(s_pSecFn == NULL)
     return CURLE_RECV_ERROR;
 #endif
 
   switch(ntlm->state) {
   case NTLMSTATE_TYPE1:
   default: /* for the weird cases we (re)start here */
@@ -586,50 +586,50 @@
     int domlen;
     TimeStamp tsDummy; /* For Windows 9x compatibility of SPPI calls */
 
     ntlm_sspi_cleanup(ntlm);
 
     user = strchr(userp, '\\');
-    if (!user)
+    if(!user)
       user = strchr(userp, '/');
 
-    if (user) {
+    if(user) {
       domain = userp;
       domlen = user - userp;
       user++;
     }
     else {
       user = userp;
       domain = "";
       domlen = 0;
     }
 
-    if (user && *user) {
+    if(user && *user) {
       /* note: initialize all of this before doing the mallocs so that
        * it can be cleaned up later without leaking memory.
        */
       ntlm->p_identity = &ntlm->identity;
       memset(ntlm->p_identity, 0, sizeof(*ntlm->p_identity));
-      if ((ntlm->identity.User = (unsigned char *)strdup(user)) == NULL)
+      if((ntlm->identity.User = (unsigned char *)strdup(user)) == NULL)
         return CURLE_OUT_OF_MEMORY;
       ntlm->identity.UserLength = strlen(user);
-      if ((ntlm->identity.Password = (unsigned char *)strdup(passwdp)) == NULL)
+      if((ntlm->identity.Password = (unsigned char *)strdup(passwdp)) == NULL)
         return CURLE_OUT_OF_MEMORY;
       ntlm->identity.PasswordLength = strlen(passwdp);
-      if ((ntlm->identity.Domain = malloc(domlen+1)) == NULL)
+      if((ntlm->identity.Domain = malloc(domlen+1)) == NULL)
         return CURLE_OUT_OF_MEMORY;
       strncpy((char *)ntlm->identity.Domain, domain, domlen);
       ntlm->identity.Domain[domlen] = '\0';
       ntlm->identity.DomainLength = domlen;
       ntlm->identity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
     }
     else {
       ntlm->p_identity = NULL;
     }
 
-    if (s_pSecFn->AcquireCredentialsHandle(
+    if(s_pSecFn->AcquireCredentialsHandle(
           NULL, (char *)"NTLM", SECPKG_CRED_OUTBOUND, NULL, ntlm->p_identity,
           NULL, NULL, &ntlm->handle, &tsDummy
           ) != SEC_E_OK) {
       return CURLE_OUT_OF_MEMORY;
     }
 
@@ -647,17 +647,17 @@
                                                  ISC_REQ_CONNECTION,
                                                  0, SECURITY_NETWORK_DREP,
                                                  NULL, 0,
                                                  &ntlm->c_handle, &desc,
                                                  &attrs, &tsDummy);
 
-    if (status == SEC_I_COMPLETE_AND_CONTINUE ||
+    if(status == SEC_I_COMPLETE_AND_CONTINUE ||
         status == SEC_I_CONTINUE_NEEDED) {
       s_pSecFn->CompleteAuthToken(&ntlm->c_handle, &desc);
     }
-    else if (status != SEC_E_OK) {
+    else if(status != SEC_E_OK) {
       s_pSecFn->FreeCredentialsHandle(&ntlm->handle);
       return CURLE_RECV_ERROR;
     }
 
     ntlm->has_handles = 1;
     size = buf.cbBuffer;
@@ -802,13 +802,13 @@
                                        ISC_REQ_REPLAY_DETECT |
                                        ISC_REQ_CONNECTION,
                                        0, SECURITY_NETWORK_DREP, &type_2_desc,
                                        0, &ntlm->c_handle, &type_3_desc,
                                        &attrs, &tsDummy);
 
-    if (status != SEC_E_OK)
+    if(status != SEC_E_OK)
       return CURLE_RECV_ERROR;
 
     size = type_3.cbBuffer;
 
     ntlm_sspi_cleanup(ntlm);
 
@@ -824,39 +824,39 @@
     size_t userlen;
 
     user = strchr(userp, '\\');
     if(!user)
       user = strchr(userp, '/');
 
-    if (user) {
+    if(user) {
       domain = userp;
       domlen = (user - domain);
       user++;
     }
     else
       user = userp;
     userlen = strlen(user);
 
-    if (gethostname(host, HOSTNAME_MAX)) {
+    if(gethostname(host, HOSTNAME_MAX)) {
       infof(conn->data, "gethostname() failed, continuing without!");
       hostlen = 0;
     }
     else {
       /* If the workstation if configured with a full DNS name (i.e.
        * workstation.somewhere.net) gethostname() returns the fully qualified
        * name, which NTLM doesn't like.
        */
       char *dot = strchr(host, '.');
-      if (dot)
+      if(dot)
         *dot = '\0';
       hostlen = strlen(host);
     }
 
 #if USE_NTLM2SESSION
     /* We don't support NTLM2 if we don't have USE_NTRESPONSES */
-    if (ntlm->flags & NTLMFLAG_NEGOTIATE_NTLM2_KEY) {
+    if(ntlm->flags & NTLMFLAG_NEGOTIATE_NTLM2_KEY) {
       unsigned char ntbuffer[0x18];
       unsigned char tmp[0x18];
       unsigned char md5sum[MD5_DIGEST_LENGTH];
       MD5_CTX MD5pw;
       unsigned char entropy[8];
 
@@ -875,13 +875,13 @@
 
       MD5_Init(&MD5pw);
       MD5_Update(&MD5pw, tmp, 16);
       MD5_Final(md5sum, &MD5pw);
       /* We shall only use the first 8 bytes of md5sum,
          but the des code in lm_resp only encrypt the first 8 bytes */
-      if (mk_nt_hash(conn->data, passwdp, ntbuffer) == CURLE_OUT_OF_MEMORY)
+      if(mk_nt_hash(conn->data, passwdp, ntbuffer) == CURLE_OUT_OF_MEMORY)
         return CURLE_OUT_OF_MEMORY;
       lm_resp(ntbuffer, md5sum, ntresp);
 
       /* End of NTLM2 Session code */
     }
     else {
@@ -890,13 +890,13 @@
 #if USE_NTRESPONSES
       unsigned char ntbuffer[0x18];
 #endif
       unsigned char lmbuffer[0x18];
 
 #if USE_NTRESPONSES
-      if (mk_nt_hash(conn->data, passwdp, ntbuffer) == CURLE_OUT_OF_MEMORY)
+      if(mk_nt_hash(conn->data, passwdp, ntbuffer) == CURLE_OUT_OF_MEMORY)
         return CURLE_OUT_OF_MEMORY;
       lm_resp(ntbuffer, &ntlm->nonce[0], ntresp);
 #endif
 
       mk_lm_hash(conn->data, passwdp, lmbuffer);
       lm_resp(lmbuffer, &ntlm->nonce[0], lmresp);
@@ -1110,13 +1110,13 @@
 void
 Curl_ntlm_cleanup(struct connectdata *conn)
 {
 #ifdef USE_WINDOWS_SSPI
   ntlm_sspi_cleanup(&conn->ntlm);
   ntlm_sspi_cleanup(&conn->proxyntlm);
-  if (s_hSecDll != NULL) {
+  if(s_hSecDll != NULL) {
     FreeLibrary(s_hSecDll);
     s_hSecDll = NULL;
     s_pSecFn = NULL;
   }
 #else
   (void)conn;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/if2ip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/if2ip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/if2ip.c	2007-04-13 04:09:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/if2ip.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: if2ip.c,v 1.51 2007-04-12 20:09:19 bagder Exp $
+ * $Id: if2ip.c,v 1.52 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -88,13 +88,13 @@
   char *ip=NULL;
 
   if(!interface)
     return NULL;
 
   dummy = socket(AF_INET, SOCK_STREAM, 0);
-  if (SYS_ERROR == dummy) {
+  if(SYS_ERROR == dummy) {
     return NULL;
   }
   else {
     struct ifreq req;
     size_t len = strlen(interface);
     memset(&req, 0, sizeof(req));
@@ -102,15 +102,15 @@
       sclose(dummy);
       return NULL; /* this can't be a fine interface name */
     }
     memcpy(req.ifr_name, interface, len+1);
     req.ifr_addr.sa_family = AF_INET;
 #ifdef IOCTL_3_ARGS
-    if (SYS_ERROR == ioctl(dummy, SIOCGIFADDR, &req)) {
+    if(SYS_ERROR == ioctl(dummy, SIOCGIFADDR, &req)) {
 #else
-    if (SYS_ERROR == ioctl(dummy, SIOCGIFADDR, &req, sizeof(req))) {
+    if(SYS_ERROR == ioctl(dummy, SIOCGIFADDR, &req, sizeof(req))) {
 #endif
       sclose(dummy);
       return NULL;
     }
     else {
       struct in_addr in;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/inet_ntop.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/inet_ntop.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/inet_ntop.c	2007-08-23 22:35:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/inet_ntop.c	2007-11-07 17:05:34.000000000 +0800
@@ -76,13 +76,13 @@
   return inet_ntoa_r(*(struct in_addr*)src, dst, size);
 #endif
 
 #else
   const char *addr = inet_ntoa(*(struct in_addr*)src);
 
-  if (strlen(addr) >= size)
+  if(strlen(addr) >= size)
   {
     SET_ERRNO(ENOSPC);
     return (NULL);
   }
   return strcpy(dst, addr);
 #endif
@@ -122,75 +122,75 @@
   cur.base  = -1;
   best.len = 0;
   cur.len = 0;
 
   for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++)
   {
-    if (words[i] == 0)
+    if(words[i] == 0)
     {
-      if (cur.base == -1)
+      if(cur.base == -1)
         cur.base = i, cur.len = 1;
       else
         cur.len++;
     }
-    else if (cur.base != -1)
+    else if(cur.base != -1)
     {
-      if (best.base == -1 || cur.len > best.len)
+      if(best.base == -1 || cur.len > best.len)
          best = cur;
       cur.base = -1;
     }
   }
-  if ((cur.base != -1) && (best.base == -1 || cur.len > best.len))
+  if((cur.base != -1) && (best.base == -1 || cur.len > best.len))
      best = cur;
-  if (best.base != -1 && best.len < 2)
+  if(best.base != -1 && best.len < 2)
      best.base = -1;
 
   /* Format the result.
    */
   tp = tmp;
   for (i = 0; i < (IN6ADDRSZ / INT16SZ); i++)
   {
     /* Are we inside the best run of 0x00's?
      */
-    if (best.base != -1 && i >= best.base && i < (best.base + best.len))
+    if(best.base != -1 && i >= best.base && i < (best.base + best.len))
     {
-      if (i == best.base)
+      if(i == best.base)
          *tp++ = ':';
       continue;
     }
 
     /* Are we following an initial run of 0x00s or any real hex?
      */
-    if (i != 0)
+    if(i != 0)
        *tp++ = ':';
 
     /* Is this address an encapsulated IPv4?
      */
-    if (i == 6 && best.base == 0 &&
+    if(i == 6 && best.base == 0 &&
         (best.len == 6 || (best.len == 5 && words[5] == 0xffff)))
     {
-      if (!inet_ntop4(src+12, tp, sizeof(tmp) - (tp - tmp)))
+      if(!inet_ntop4(src+12, tp, sizeof(tmp) - (tp - tmp)))
       {
         SET_ERRNO(ENOSPC);
         return (NULL);
       }
       tp += strlen(tp);
       break;
     }
     tp += snprintf(tp, 5, "%lx", words[i]);
   }
 
   /* Was it a trailing run of 0x00's?
    */
-  if (best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ))
+  if(best.base != -1 && (best.base + best.len) == (IN6ADDRSZ / INT16SZ))
      *tp++ = ':';
   *tp++ = '\0';
 
   /* Check for overflow, copy, and we're done.
    */
-  if ((size_t)(tp - tmp) > size)
+  if((size_t)(tp - tmp) > size)
   {
     SET_ERRNO(ENOSPC);
     return (NULL);
   }
   return strcpy (dst, tmp);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/inet_pton.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/inet_pton.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/inet_pton.c	2007-04-14 06:07:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/inet_pton.c	2007-11-07 17:17:19.000000000 +0800
@@ -105,35 +105,37 @@
   unsigned char tmp[INADDRSZ], *tp;
 
   saw_digit = 0;
   octets = 0;
   tp = tmp;
   *tp = 0;
-  while ((ch = *src++) != '\0') {
+  while((ch = *src++) != '\0') {
     const char *pch;
 
-    if ((pch = strchr(digits, ch)) != NULL) {
+    if((pch = strchr(digits, ch)) != NULL) {
       unsigned int val = *tp * 10 + (unsigned int)(pch - digits);
 
-      if (val > 255)
+      if(val > 255)
         return (0);
       *tp = (unsigned char)val;
-      if (! saw_digit) {
-        if (++octets > 4)
+      if(! saw_digit) {
+        if(++octets > 4)
           return (0);
         saw_digit = 1;
       }
-    } else if (ch == '.' && saw_digit) {
-      if (octets == 4)
+    }
+    else if(ch == '.' && saw_digit) {
+      if(octets == 4)
         return (0);
       *++tp = 0;
       saw_digit = 0;
-    } else
+    }
+    else
       return (0);
   }
-  if (octets < 4)
+  if(octets < 4)
     return (0);
   /* bcopy(tmp, dst, INADDRSZ); */
   memcpy(dst, tmp, INADDRSZ);
   return (1);
 }
 
@@ -162,62 +164,62 @@
   unsigned int val;
 
   memset((tp = tmp), 0, IN6ADDRSZ);
   endp = tp + IN6ADDRSZ;
   colonp = NULL;
   /* Leading :: requires some special handling. */
-  if (*src == ':')
-    if (*++src != ':')
+  if(*src == ':')
+    if(*++src != ':')
       return (0);
   curtok = src;
   saw_xdigit = 0;
   val = 0;
-  while ((ch = *src++) != '\0') {
+  while((ch = *src++) != '\0') {
     const char *pch;
 
-    if ((pch = strchr((xdigits = xdigits_l), ch)) == NULL)
+    if((pch = strchr((xdigits = xdigits_l), ch)) == NULL)
       pch = strchr((xdigits = xdigits_u), ch);
-    if (pch != NULL) {
+    if(pch != NULL) {
       val <<= 4;
       val |= (pch - xdigits);
-      if (val > 0xffff)
+      if(val > 0xffff)
         return (0);
       saw_xdigit = 1;
       continue;
     }
-    if (ch == ':') {
+    if(ch == ':') {
       curtok = src;
-      if (!saw_xdigit) {
-        if (colonp)
+      if(!saw_xdigit) {
+        if(colonp)
           return (0);
         colonp = tp;
         continue;
       }
-      if (tp + INT16SZ > endp)
+      if(tp + INT16SZ > endp)
         return (0);
       *tp++ = (unsigned char) (val >> 8) & 0xff;
       *tp++ = (unsigned char) val & 0xff;
       saw_xdigit = 0;
       val = 0;
       continue;
     }
-    if (ch == '.' && ((tp + INADDRSZ) <= endp) &&
+    if(ch == '.' && ((tp + INADDRSZ) <= endp) &&
         inet_pton4(curtok, tp) > 0) {
       tp += INADDRSZ;
       saw_xdigit = 0;
       break;    /* '\0' was seen by inet_pton4(). */
     }
     return (0);
   }
-  if (saw_xdigit) {
-    if (tp + INT16SZ > endp)
+  if(saw_xdigit) {
+    if(tp + INT16SZ > endp)
       return (0);
     *tp++ = (unsigned char) (val >> 8) & 0xff;
     *tp++ = (unsigned char) val & 0xff;
   }
-  if (colonp != NULL) {
+  if(colonp != NULL) {
     /*
      * Since some memmove()'s erroneously fail to handle
      * overlapping regions, we'll do the shift by hand.
      */
     const int n = tp - colonp;
     int i;
@@ -225,13 +227,13 @@
     for (i = 1; i <= n; i++) {
       endp[- i] = colonp[n - i];
       colonp[n - i] = 0;
     }
     tp = endp;
   }
-  if (tp != endp)
+  if(tp != endp)
     return (0);
   /* bcopy(tmp, dst, IN6ADDRSZ); */
   memcpy(dst, tmp, IN6ADDRSZ);
   return (1);
 }
 #endif /* ENABLE_IPV6 */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/krb4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/krb4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/krb4.c	2007-01-04 07:04:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/krb4.c	2008-01-16 07:50:17.000000000 +0800
@@ -4,13 +4,13 @@
  * It has since been patched away like a madman by Daniel Stenberg to make it
  * better applied to curl conditions, and to make it not use globals, pollute
  * name space and more.
  *
  * Copyright (c) 1995, 1996, 1997, 1998, 1999 Kungliga Tekniska Hgskolan
  * (Royal Institute of Technology, Stockholm, Sweden).
- * Copyright (c) 2004 - 2007 Daniel Stenberg
+ * Copyright (c) 2004 - 2008 Daniel Stenberg
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -34,13 +34,13 @@
  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $Id: krb4.c,v 1.45 2007-01-03 23:04:43 bagder Exp $
+ * $Id: krb4.c,v 1.47 2008-01-15 23:19:02 bagder Exp $
  */
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_FTP
 #ifdef HAVE_KRB4
@@ -94,13 +94,13 @@
 
   for (p = dst, n = 0;
        n + 1 < dst_sz && *src != '\0';
        ++p, ++src, ++n)
     *p = *src;
   *p = '\0';
-  if (*src == '\0')
+  if(*src == '\0')
     return n;
   else
     return n + strlen (src);
 }
 #else
 size_t strlcpy (char *dst, const char *src, size_t dst_sz);
@@ -225,23 +225,23 @@
   if(ret) {
     infof(data, "%s\n", krb_get_err_text(ret));
     return AUTH_CONTINUE;
   }
 
 #ifdef HAVE_KRB_GET_OUR_IP_FOR_REALM
-  if (krb_get_config_bool("nat_in_use")) {
+  if(krb_get_config_bool("nat_in_use")) {
     struct sockaddr_in *localaddr  = (struct sockaddr_in *)LOCAL_ADDR;
     struct in_addr natAddr;
 
-    if (krb_get_our_ip_for_realm(krb_realmofhost(host),
+    if(krb_get_our_ip_for_realm(krb_realmofhost(host),
                                  &natAddr) != KSUCCESS
         && krb_get_our_ip_for_realm(NULL, &natAddr) != KSUCCESS)
       infof(data, "Can't get address for realm %s\n",
                  krb_realmofhost(host));
     else {
-      if (natAddr.s_addr != localaddr->sin_addr.s_addr) {
+      if(natAddr.s_addr != localaddr->sin_addr.s_addr) {
 #ifdef HAVE_INET_NTOA_R
         char ntoa_buf[64];
         char *ip = (char *)inet_ntoa_r(natAddr, ntoa_buf, sizeof(ntoa_buf));
 #else
         char *ip = (char *)inet_ntoa(natAddr);
 #endif
@@ -359,13 +359,13 @@
   tmp = Curl_base64_decode(p, &ptr);
   if(tmp >= sizeof(tkt.dat)) {
     free(ptr);
     tmp=0;
   }
   if(!tmp || !ptr) {
-    Curl_failf(conn->data, "Failed to decode base64 in reply.\n");
+    Curl_failf(conn->data, "Failed to decode base64 in reply");
     Curl_set_command_prot(conn, save);
     return CURLE_FTP_WEIRD_SERVER_REPLY;
   }
   memcpy((char *)tkt.dat, ptr, tmp);
   free(ptr);
   tkt.length = tmp;
@@ -384,13 +384,13 @@
   des_string_to_key (conn->passwd, &key);
   des_key_sched(&key, schedule);
 
   des_pcbc_encrypt((void *)tkt.dat, (void *)tktcopy.dat,
                    tkt.length,
                    schedule, &key, DES_DECRYPT);
-  if (strcmp ((char*)tktcopy.dat + 8,
+  if(strcmp ((char*)tktcopy.dat + 8,
               KRB_TICKET_GRANTING_TICKET) != 0) {
     afs_string_to_key(passwd,
                       krb_realmofhost(conn->host.name),
                       &key);
     des_key_sched(&key, schedule);
     des_pcbc_encrypt((void *)tkt.dat, (void *)tktcopy.dat,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ldap.c	2007-10-22 22:30:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ldap.c	2007-11-25 07:18:21.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ldap.c,v 1.88 2007-10-17 16:58:32 yangtse Exp $
+ * $Id: ldap.c,v 1.90 2007-11-24 23:18:21 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_LDAP
 /* -- WIN32 approved -- */
@@ -107,13 +107,13 @@
 #endif
 
 #ifdef DEBUG_LDAP
   #define LDAP_TRACE(x)   do { \
                             _ldap_trace ("%u: ", __LINE__); \
                             _ldap_trace x; \
-                          } while (0)
+                          } while(0)
 
   static void _ldap_trace (const char *fmt, ...);
 #else
   #define LDAP_TRACE(x)   ((void)0)
 #endif
 
@@ -188,137 +188,137 @@
 
 #ifdef HAVE_LDAP_URL_PARSE
   rc = ldap_url_parse(data->change.url, &ludp);
 #else
   rc = _ldap_url_parse(conn, &ludp);
 #endif
-  if (rc != 0) {
+  if(rc != 0) {
     failf(data, "LDAP local: %s", ldap_err2string(rc));
     status = CURLE_LDAP_INVALID_URL;
     goto quit;
   }
 
   /* Get the URL scheme ( either ldap or ldaps ) */
-  if (strequal(conn->protostr, "LDAPS"))
+  if(strequal(conn->protostr, "LDAPS"))
     ldap_ssl = 1;
   infof(data, "LDAP local: trying to establish %s connection\n",
           ldap_ssl ? "encrypted" : "cleartext");
 
 #ifdef LDAP_OPT_NETWORK_TIMEOUT
   ldap_set_option(NULL, LDAP_OPT_NETWORK_TIMEOUT, &ldap_timeout);
 #endif
   ldap_set_option(NULL, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);
 
-  if (ldap_ssl) {
+  if(ldap_ssl) {
 #ifdef HAVE_LDAP_SSL
 #ifdef CURL_LDAP_WIN
     /* Win32 LDAP SDK doesnt support insecure mode without CA! */
     server = ldap_sslinit(conn->host.name, (int)conn->port, 1);
     ldap_set_option(server, LDAP_OPT_SSL, LDAP_OPT_ON);
 #else
     int ldap_option;
     char* ldap_ca = data->set.str[STRING_SSL_CAFILE];
 #if defined(CURL_HAS_NOVELL_LDAPSDK)
     rc = ldapssl_client_init(NULL, NULL);
-    if (rc != LDAP_SUCCESS) {
+    if(rc != LDAP_SUCCESS) {
       failf(data, "LDAP local: ldapssl_client_init %s", ldap_err2string(rc));
       status = CURLE_SSL_CERTPROBLEM;
       goto quit;
     }
-    if (data->set.ssl.verifypeer) {
+    if(data->set.ssl.verifypeer) {
       /* Novell SDK supports DER or BASE64 files. */
       int cert_type = LDAPSSL_CERT_FILETYPE_B64;
-      if ((data->set.str[STRING_CERT_TYPE]) &&
+      if((data->set.str[STRING_CERT_TYPE]) &&
               (strequal(data->set.str[STRING_CERT_TYPE], "DER")))
         cert_type = LDAPSSL_CERT_FILETYPE_DER;
-      if (!ldap_ca) {
+      if(!ldap_ca) {
         failf(data, "LDAP local: ERROR %s CA cert not set!",
               (cert_type == LDAPSSL_CERT_FILETYPE_DER ? "DER" : "PEM"));
         status = CURLE_SSL_CERTPROBLEM;
         goto quit;
       }
       infof(data, "LDAP local: using %s CA cert '%s'\n",
               (cert_type == LDAPSSL_CERT_FILETYPE_DER ? "DER" : "PEM"),
               ldap_ca);
       rc = ldapssl_add_trusted_cert(ldap_ca, cert_type);
-      if (rc != LDAP_SUCCESS) {
+      if(rc != LDAP_SUCCESS) {
         failf(data, "LDAP local: ERROR setting %s CA cert: %s",
                 (cert_type == LDAPSSL_CERT_FILETYPE_DER ? "DER" : "PEM"),
                 ldap_err2string(rc));
         status = CURLE_SSL_CERTPROBLEM;
         goto quit;
       }
       ldap_option = LDAPSSL_VERIFY_SERVER;
     } else {
       ldap_option = LDAPSSL_VERIFY_NONE;
     }
     rc = ldapssl_set_verify_mode(ldap_option);
-    if (rc != LDAP_SUCCESS) {
+    if(rc != LDAP_SUCCESS) {
       failf(data, "LDAP local: ERROR setting cert verify mode: %s",
               ldap_err2string(rc));
       status = CURLE_SSL_CERTPROBLEM;
       goto quit;
     }
     server = ldapssl_init(conn->host.name, (int)conn->port, 1);
-    if (server == NULL) {
+    if(server == NULL) {
       failf(data, "LDAP local: Cannot connect to %s:%d",
               conn->host.name, conn->port);
       status = CURLE_COULDNT_CONNECT;
       goto quit;
     }
 #elif defined(LDAP_OPT_X_TLS)
-    if (data->set.ssl.verifypeer) {
+    if(data->set.ssl.verifypeer) {
       /* OpenLDAP SDK supports BASE64 files. */
-      if ((data->set.str[STRING_CERT_TYPE]) &&
+      if((data->set.str[STRING_CERT_TYPE]) &&
               (!strequal(data->set.str[STRING_CERT_TYPE], "PEM"))) {
         failf(data, "LDAP local: ERROR OpenLDAP does only support PEM cert-type!");
         status = CURLE_SSL_CERTPROBLEM;
         goto quit;
       }
-      if (!ldap_ca) {
+      if(!ldap_ca) {
         failf(data, "LDAP local: ERROR PEM CA cert not set!");
         status = CURLE_SSL_CERTPROBLEM;
         goto quit;
       }
       infof(data, "LDAP local: using PEM CA cert: %s\n", ldap_ca);
       rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_CACERTFILE, ldap_ca);
-      if (rc != LDAP_SUCCESS) {
+      if(rc != LDAP_SUCCESS) {
         failf(data, "LDAP local: ERROR setting PEM CA cert: %s",
                 ldap_err2string(rc));
         status = CURLE_SSL_CERTPROBLEM;
         goto quit;
       }
       ldap_option = LDAP_OPT_X_TLS_DEMAND;
     } else {
       ldap_option = LDAP_OPT_X_TLS_NEVER;
     }
     rc = ldap_set_option(NULL, LDAP_OPT_X_TLS_REQUIRE_CERT, &ldap_option);
-    if (rc != LDAP_SUCCESS) {
+    if(rc != LDAP_SUCCESS) {
       failf(data, "LDAP local: ERROR setting cert verify mode: %s",
               ldap_err2string(rc));
       status = CURLE_SSL_CERTPROBLEM;
       goto quit;
     }
     server = ldap_init(conn->host.name, (int)conn->port);
-    if (server == NULL) {
+    if(server == NULL) {
       failf(data, "LDAP local: Cannot connect to %s:%d",
               conn->host.name, conn->port);
       status = CURLE_COULDNT_CONNECT;
       goto quit;
     }
     ldap_option = LDAP_OPT_X_TLS_HARD;
     rc = ldap_set_option(server, LDAP_OPT_X_TLS, &ldap_option);
-    if (rc != LDAP_SUCCESS) {
+    if(rc != LDAP_SUCCESS) {
       failf(data, "LDAP local: ERROR setting SSL/TLS mode: %s",
               ldap_err2string(rc));
       status = CURLE_SSL_CERTPROBLEM;
       goto quit;
     }
 /*
     rc = ldap_start_tls_s(server, NULL, NULL);
-    if (rc != LDAP_SUCCESS) {
+    if(rc != LDAP_SUCCESS) {
       failf(data, "LDAP local: ERROR starting SSL/TLS mode: %s",
               ldap_err2string(rc));
       status = CURLE_SSL_CERTPROBLEM;
       goto quit;
     }
 */
@@ -331,13 +331,13 @@
     goto quit;
 #endif
 #endif
 #endif /* CURL_LDAP_USE_SSL */
   } else {
     server = ldap_init(conn->host.name, (int)conn->port);
-    if (server == NULL) {
+    if(server == NULL) {
       failf(data, "LDAP local: Cannot connect to %s:%d",
               conn->host.name, conn->port);
       status = CURLE_COULDNT_CONNECT;
       goto quit;
     }
   }
@@ -345,29 +345,29 @@
   ldap_set_option(server, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);
 #endif
 
   rc = ldap_simple_bind_s(server,
                           conn->bits.user_passwd ? conn->user : NULL,
                           conn->bits.user_passwd ? conn->passwd : NULL);
-  if (!ldap_ssl && rc != 0) {
+  if(!ldap_ssl && rc != 0) {
     ldap_proto = LDAP_VERSION2;
     ldap_set_option(server, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);
     rc = ldap_simple_bind_s(server,
                             conn->bits.user_passwd ? conn->user : NULL,
                             conn->bits.user_passwd ? conn->passwd : NULL);
   }
-  if (rc != 0) {
+  if(rc != 0) {
      failf(data, "LDAP local: ldap_simple_bind_s %s", ldap_err2string(rc));
      status = CURLE_LDAP_CANNOT_BIND;
      goto quit;
   }
 
   rc = ldap_search_s(server, ludp->lud_dn, ludp->lud_scope,
                      ludp->lud_filter, ludp->lud_attrs, 0, &result);
 
-  if (rc != 0 && rc != LDAP_SIZELIMIT_EXCEEDED) {
+  if(rc != 0 && rc != LDAP_SIZELIMIT_EXCEEDED) {
     failf(data, "LDAP remote: %s", ldap_err2string(rc));
     status = CURLE_LDAP_SEARCH_FAILED;
     goto quit;
   }
 
   for(num = 0, entryIterator = ldap_first_entry(server, result);
@@ -386,29 +386,29 @@
     for (attribute = ldap_first_attribute(server, entryIterator, &ber);
          attribute;
          attribute = ldap_next_attribute(server, entryIterator, ber))
     {
       BerValue **vals = ldap_get_values_len(server, entryIterator, attribute);
 
-      if (vals != NULL)
+      if(vals != NULL)
       {
         for (i = 0; (vals[i] != NULL); i++)
         {
           Curl_client_write(conn, CLIENTWRITE_BODY, (char *)"\t", 1);
           Curl_client_write(conn, CLIENTWRITE_BODY, (char *) attribute, 0);
           Curl_client_write(conn, CLIENTWRITE_BODY, (char *)": ", 2);
-          if ((strlen(attribute) > 7) &&
+          if((strlen(attribute) > 7) &&
               (strcmp(";binary",
                       (char *)attribute +
                       (strlen((char *)attribute) - 7)) == 0)) {
             /* Binary attribute, encode to base64. */
             val_b64_sz = Curl_base64_encode(conn->data,
                                             vals[i]->bv_val,
                                             vals[i]->bv_len,
                                             &val_b64);
-            if (val_b64_sz > 0) {
+            if(val_b64_sz > 0) {
               Curl_client_write(conn, CLIENTWRITE_BODY, val_b64, val_b64_sz);
               free(val_b64);
             }
           } else
             Curl_client_write(conn, CLIENTWRITE_BODY, vals[i]->bv_val,
                               vals[i]->bv_len);
@@ -420,29 +420,29 @@
       }
       Curl_client_write(conn, CLIENTWRITE_BODY, (char *)"\n", 1);
 
       ldap_memfree(attribute);
     }
     ldap_memfree(dn);
-    if (ber)
+    if(ber)
        ber_free(ber, 0);
   }
 
 quit:
-  if (result) {
+  if(result) {
     ldap_msgfree(result);
     LDAP_TRACE (("Received %d entries\n", num));
   }
-  if (rc == LDAP_SIZELIMIT_EXCEEDED)
+  if(rc == LDAP_SIZELIMIT_EXCEEDED)
     infof(data, "There are more than %d entries\n", num);
-  if (ludp)
+  if(ludp)
     ldap_free_urldesc(ludp);
-  if (server)
+  if(server)
     ldap_unbind_s(server);
 #if defined(HAVE_LDAP_SSL) && defined(CURL_HAS_NOVELL_LDAPSDK)
-  if (ldap_ssl)
+  if(ldap_ssl)
     ldapssl_client_deinit();
 #endif /* HAVE_LDAP_SSL && CURL_HAS_NOVELL_LDAPSDK */
 
   /* no data to transfer */
   Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
   conn->bits.close = TRUE;
@@ -453,17 +453,17 @@
 #ifdef DEBUG_LDAP
 static void _ldap_trace (const char *fmt, ...)
 {
   static int do_trace = -1;
   va_list args;
 
-  if (do_trace == -1) {
+  if(do_trace == -1) {
     const char *env = getenv("CURL_TRACE");
     do_trace = (env && atoi(env) > 0);
   }
-  if (!do_trace)
+  if(!do_trace)
     return;
 
   va_start (args, fmt);
   vfprintf (stderr, fmt, args);
   va_end (args);
 }
@@ -473,21 +473,21 @@
 
 /*
  * Return scope-value for a scope-string.
  */
 static int str2scope (const char *p)
 {
-  if (!stricmp(p, "one"))
+  if(!stricmp(p, "one"))
      return LDAP_SCOPE_ONELEVEL;
-  if (!stricmp(p, "onetree"))
+  if(!stricmp(p, "onetree"))
      return LDAP_SCOPE_ONELEVEL;
-  if (!stricmp(p, "base"))
+  if(!stricmp(p, "base"))
      return LDAP_SCOPE_BASE;
-  if (!stricmp(p, "sub"))
+  if(!stricmp(p, "sub"))
      return LDAP_SCOPE_SUBTREE;
-  if (!stricmp( p, "subtree"))
+  if(!stricmp( p, "subtree"))
      return LDAP_SCOPE_SUBTREE;
   return (-1);
 }
 
 /*
  * Split 'str' into strings separated by commas.
@@ -499,13 +499,13 @@
   int  i;
 
   for (i = 2, s = strchr(str,','); s; i++)
      s = strchr(++s,',');
 
   res = calloc(i, sizeof(char*));
-  if (!res)
+  if(!res)
     return NULL;
 
   for (i = 0, s = strtok_r(str, ",", &lasts); s;
        s = strtok_r(NULL, ",", &lasts), i++)
     res[i] = s;
   return res;
@@ -515,191 +515,191 @@
  * Unescape the LDAP-URL components
  */
 static bool unescape_elements (void *data, LDAPURLDesc *ludp)
 {
   int i;
 
-  if (ludp->lud_filter) {
+  if(ludp->lud_filter) {
     ludp->lud_filter = curl_easy_unescape(data, ludp->lud_filter, 0, NULL);
-    if (!ludp->lud_filter)
+    if(!ludp->lud_filter)
        return (FALSE);
   }
 
   for (i = 0; ludp->lud_attrs && ludp->lud_attrs[i]; i++) {
     ludp->lud_attrs[i] = curl_easy_unescape(data, ludp->lud_attrs[i], 0, NULL);
-    if (!ludp->lud_attrs[i])
+    if(!ludp->lud_attrs[i])
        return (FALSE);
   }
 
   for (i = 0; ludp->lud_exts && ludp->lud_exts[i]; i++) {
     ludp->lud_exts[i] = curl_easy_unescape(data, ludp->lud_exts[i], 0, NULL);
-    if (!ludp->lud_exts[i])
+    if(!ludp->lud_exts[i])
        return (FALSE);
   }
 
-  if (ludp->lud_dn) {
+  if(ludp->lud_dn) {
     char *dn = ludp->lud_dn;
     char *new_dn = curl_easy_unescape(data, dn, 0, NULL);
 
     free(dn);
     ludp->lud_dn = new_dn;
-    if (!new_dn)
+    if(!new_dn)
        return (FALSE);
   }
   return (TRUE);
 }
 
 /*
  * Break apart the pieces of an LDAP URL.
  * Syntax:
  *   ldap://<hostname>:<port>/<base_dn>?<attributes>?<scope>?<filter>?<ext>
  *
  * <hostname> already known from 'conn->host.name'.
  * <port>     already known from 'conn->remote_port'.
- * extract the rest from 'conn->data->reqdata.path+1'. All fields are optional.
+ * extract the rest from 'conn->data->state.path+1'. All fields are optional.
  * e.g.
  *   ldap://<hostname>:<port>/?<attributes>?<scope>?<filter>
  * yields ludp->lud_dn = "".
  *
  * Ref. http://developer.netscape.com/docs/manuals/dirsdk/csdk30/url.htm#2831915
  */
 static int _ldap_url_parse2 (const struct connectdata *conn, LDAPURLDesc *ludp)
 {
   char *p, *q;
   int i;
 
-  if (!conn->data ||
-      !conn->data->reqdata.path ||
-      conn->data->reqdata.path[0] != '/' ||
+  if(!conn->data ||
+      !conn->data->state.path ||
+      conn->data->state.path[0] != '/' ||
       !checkprefix(conn->protostr, conn->data->change.url))
     return LDAP_INVALID_SYNTAX;
 
   ludp->lud_scope = LDAP_SCOPE_BASE;
   ludp->lud_port  = conn->remote_port;
   ludp->lud_host  = conn->host.name;
 
   /* parse DN (Distinguished Name).
    */
-  ludp->lud_dn = strdup(conn->data->reqdata.path+1);
-  if (!ludp->lud_dn)
+  ludp->lud_dn = strdup(conn->data->state.path+1);
+  if(!ludp->lud_dn)
     return LDAP_NO_MEMORY;
 
   p = strchr(ludp->lud_dn, '?');
   LDAP_TRACE (("DN '%.*s'\n", p ? (size_t)(p-ludp->lud_dn) :
                strlen(ludp->lud_dn), ludp->lud_dn));
 
-  if (!p)
+  if(!p)
     goto success;
 
   *p++ = '\0';
 
   /* parse attributes. skip "??".
    */
   q = strchr(p, '?');
-  if (q)
+  if(q)
     *q++ = '\0';
 
-  if (*p && *p != '?') {
+  if(*p && *p != '?') {
     ludp->lud_attrs = split_str(p);
-    if (!ludp->lud_attrs)
+    if(!ludp->lud_attrs)
       return LDAP_NO_MEMORY;
 
     for (i = 0; ludp->lud_attrs[i]; i++)
       LDAP_TRACE (("attr[%d] '%s'\n", i, ludp->lud_attrs[i]));
   }
 
   p = q;
-  if (!p)
+  if(!p)
     goto success;
 
   /* parse scope. skip "??"
    */
   q = strchr(p, '?');
-  if (q)
+  if(q)
     *q++ = '\0';
 
-  if (*p && *p != '?') {
+  if(*p && *p != '?') {
     ludp->lud_scope = str2scope(p);
-    if (ludp->lud_scope == -1)
+    if(ludp->lud_scope == -1)
       return LDAP_INVALID_SYNTAX;
     LDAP_TRACE (("scope %d\n", ludp->lud_scope));
   }
 
   p = q;
-  if (!p)
+  if(!p)
     goto success;
 
   /* parse filter
    */
   q = strchr(p, '?');
-  if (q)
+  if(q)
     *q++ = '\0';
-  if (!*p)
+  if(!*p)
     return LDAP_INVALID_SYNTAX;
 
   ludp->lud_filter = p;
   LDAP_TRACE (("filter '%s'\n", ludp->lud_filter));
 
   p = q;
-  if (!p)
+  if(!p)
     goto success;
 
   /* parse extensions
    */
   ludp->lud_exts = split_str(p);
-  if (!ludp->lud_exts)
+  if(!ludp->lud_exts)
     return LDAP_NO_MEMORY;
 
   for (i = 0; ludp->lud_exts[i]; i++)
     LDAP_TRACE (("exts[%d] '%s'\n", i, ludp->lud_exts[i]));
 
   success:
-  if (!unescape_elements(conn->data, ludp))
+  if(!unescape_elements(conn->data, ludp))
     return LDAP_NO_MEMORY;
   return LDAP_SUCCESS;
 }
 
 static int _ldap_url_parse (const struct connectdata *conn,
                             LDAPURLDesc **ludpp)
 {
   LDAPURLDesc *ludp = calloc(sizeof(*ludp), 1);
   int rc;
 
   *ludpp = NULL;
-  if (!ludp)
+  if(!ludp)
      return LDAP_NO_MEMORY;
 
   rc = _ldap_url_parse2 (conn, ludp);
-  if (rc != LDAP_SUCCESS) {
+  if(rc != LDAP_SUCCESS) {
     _ldap_free_urldesc(ludp);
     ludp = NULL;
   }
   *ludpp = ludp;
   return (rc);
 }
 
 static void _ldap_free_urldesc (LDAPURLDesc *ludp)
 {
   int i;
 
-  if (!ludp)
+  if(!ludp)
      return;
 
-  if (ludp->lud_dn)
+  if(ludp->lud_dn)
      free(ludp->lud_dn);
 
-  if (ludp->lud_filter)
+  if(ludp->lud_filter)
      free(ludp->lud_filter);
 
-  if (ludp->lud_attrs) {
+  if(ludp->lud_attrs) {
     for (i = 0; ludp->lud_attrs[i]; i++)
        free(ludp->lud_attrs[i]);
     free(ludp->lud_attrs);
   }
 
-  if (ludp->lud_exts) {
+  if(ludp->lud_exts) {
     for (i = 0; ludp->lud_exts[i]; i++)
        free(ludp->lud_exts[i]);
     free(ludp->lud_exts);
   }
   free (ludp);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/libcurl.plist /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/libcurl.plist
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/libcurl.plist	2007-10-29 22:49:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/libcurl.plist	2008-01-29 01:29:23.000000000 +0800
@@ -12,24 +12,24 @@
 	<string>curl</string>
 	
 	<key>CFBundleIdentifier</key>
 	<string>com.libcurl.libcurl</string>
 	
 	<key>CFBundleVersion</key>
-	<string>7.17.1</string>
+	<string>7.18.0</string>
 
 	<key>CFBundleName</key>
 	<string>libcurl</string>
 
 	<key>CFBundlePackageType</key>
 	<string>FMWK</string>	
 	 
 	<key>CFBundleSignature</key>
 	<string>????</string>	
 	
 	<key>CFBundleShortVersionString</key>
-	<string>libcurl 7.17.1</string>
+	<string>libcurl 7.18.0</string>
 	
 	<key>CFBundleGetInfoString</key>
-	<string>libcurl.plist 7.17.1</string>
+	<string>libcurl.plist 7.18.0</string>
 </dict>
 </plist>
\ No newline at end of file
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/libcurl.rc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/libcurl.rc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/libcurl.rc	2007-04-14 06:07:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/libcurl.rc	2008-01-26 06:11:15.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: libcurl.rc,v 1.7 2007-04-13 08:22:56 yangtse Exp $
+ * $Id: libcurl.rc,v 1.9 2008-01-24 14:10:59 gknauf Exp $
  ***************************************************************************/
 #include <winver.h>
 #include "../include/curl/curlver.h"
 
 LANGUAGE  0x09,0x01
 
@@ -49,13 +49,14 @@
       VALUE "FileDescription",  "libcurl Shared Library\0"
       VALUE "FileVersion",      LIBCURL_VERSION "\0"
       VALUE "InternalName",     "libcurl\0"
       VALUE "OriginalFilename", "libcurl.dll\0"
       VALUE "ProductName",      "The cURL library\0"
       VALUE "ProductVersion",   LIBCURL_VERSION "\0"
-      VALUE "LegalCopyright",   "Copyright 1996-2007 by Daniel Stenberg. http://curl.haxx.se/docs/copyright.html\0"
+      VALUE "LegalCopyright",   " " LIBCURL_COPYRIGHT "\0"
+      VALUE "License",          "http://curl.haxx.se/docs/copyright.html\0"
     END
   END
 
   BLOCK "VarFileInfo"
   BEGIN
     VALUE "Translation", 0x409, 1200
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/llist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/llist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/llist.c	2006-10-25 15:19:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/llist.c	2008-01-16 20:24:00.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: llist.c,v 1.18 2006-10-25 07:19:45 bagder Exp $
+ * $Id: llist.c,v 1.20 2008-01-16 12:24:00 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <stdlib.h>
@@ -65,22 +65,22 @@
   struct curl_llist_element *ne =
     (struct curl_llist_element *) malloc(sizeof(struct curl_llist_element));
   if(!ne)
     return 0;
 
   ne->ptr = (void *) p;
-  if (list->size == 0) {
+  if(list->size == 0) {
     list->head = ne;
     list->head->prev = NULL;
     list->head->next = NULL;
     list->tail = ne;
   }
   else {
     ne->next = e->next;
     ne->prev = e;
-    if (e->next) {
+    if(e->next) {
       e->next->prev = ne;
     }
     else {
       list->tail = ne;
     }
     e->next = ne;
@@ -92,25 +92,25 @@
 }
 
 int
 Curl_llist_remove(struct curl_llist *list, struct curl_llist_element *e,
                   void *user)
 {
-  if (e == NULL || list->size == 0)
+  if(e == NULL || list->size == 0)
     return 1;
 
-  if (e == list->head) {
+  if(e == list->head) {
     list->head = e->next;
 
-    if (list->head == NULL)
+    if(list->head == NULL)
       list->tail = NULL;
     else
       e->next->prev = NULL;
   } else {
     e->prev->next = e->next;
-    if (!e->next)
+    if(!e->next)
       list->tail = e->prev;
     else
       e->next->prev = e->prev;
   }
 
   list->dtor(user, e->ptr);
@@ -121,18 +121,67 @@
 }
 
 void
 Curl_llist_destroy(struct curl_llist *list, void *user)
 {
   if(list) {
-    while (list->size > 0)
+    while(list->size > 0)
       Curl_llist_remove(list, list->tail, user);
 
     free(list);
   }
 }
 
 size_t
 Curl_llist_count(struct curl_llist *list)
 {
   return list->size;
 }
+
+int Curl_llist_move(struct curl_llist *list, struct curl_llist_element *e,
+                    struct curl_llist *to_list, struct curl_llist_element *to_e)
+{
+  /* Remove element from list */
+  if(e == NULL || list->size == 0)
+    return 0;
+
+  if(e == list->head) {
+    list->head = e->next;
+
+    if(list->head == NULL)
+      list->tail = NULL;
+    else
+      e->next->prev = NULL;
+  }
+  else {
+    e->prev->next = e->next;
+    if(!e->next)
+      list->tail = e->prev;
+    else
+      e->next->prev = e->prev;
+  }
+
+  --list->size;
+
+  /* Add element to to_list after to_e */
+  if(to_list->size == 0) {
+    to_list->head = e;
+    to_list->head->prev = NULL;
+    to_list->head->next = NULL;
+    to_list->tail = e;
+  }
+  else {
+    e->next = to_e->next;
+    e->prev = to_e;
+    if(to_e->next) {
+      to_e->next->prev = e;
+    }
+    else {
+      to_list->tail = e;
+    }
+    to_e->next = e;
+  }
+
+  ++to_list->size;
+
+  return 1;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/llist.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/llist.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/llist.h	2005-01-25 08:06:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/llist.h	2008-01-16 20:24:00.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2005, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: llist.h,v 1.8 2005/01/25 00:06:29 bagder Exp $
+ * $Id: llist.h,v 1.9 2008-01-16 12:24:00 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 #include <stddef.h>
 
 typedef void (*curl_llist_dtor)(void *, void *);
@@ -53,8 +53,10 @@
 int Curl_llist_remove(struct curl_llist *, struct curl_llist_element *,
                       void *);
 int Curl_llist_remove_next(struct curl_llist *, struct curl_llist_element *,
                            void *);
 size_t Curl_llist_count(struct curl_llist *);
 void Curl_llist_destroy(struct curl_llist *, void *);
+int Curl_llist_move(struct curl_llist *, struct curl_llist_element *,
+                    struct curl_llist *, struct curl_llist_element *);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.in	2007-10-29 18:19:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -176,12 +176,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.m32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.m32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.m32	2007-08-27 21:01:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.m32	2008-01-17 17:22:36.000000000 +0800
@@ -1,8 +1,8 @@
 #########################################################################
-# $Id: Makefile.m32,v 1.50 2007-08-25 12:08:38 gknauf Exp $
+# $Id: Makefile.m32,v 1.51 2008-01-17 01:25:46 gknauf Exp $
 #
 ## Makefile for building libcurl.a with MingW32 (GCC-3.2) and
 ## optionally OpenSSL (0.9.8), libssh2 (0.17), zlib (1.2.3)
 ##
 ## Usage:
 ## mingw32-make -f Makefile.m32 [SSL=1] [SSH2=1] [ZLIB=1] [SSPI=1] [IPV6=1] [DYN=1]
@@ -18,17 +18,17 @@
 # Edit the path below to point to the base of your Zlib sources.
 ifndef ZLIB_PATH
 ZLIB_PATH = ../../zlib-1.2.3
 endif
 # Edit the path below to point to the base of your OpenSSL package.
 ifndef OPENSSL_PATH
-OPENSSL_PATH = ../../openssl-0.9.8e
+OPENSSL_PATH = ../../openssl-0.9.8g
 endif
 # Edit the path below to point to the base of your LibSSH2 package.
 ifndef LIBSSH2_PATH
-LIBSSH2_PATH = ../../libssh2-0.17
+LIBSSH2_PATH = ../../libssh2-0.18
 endif
 # Edit the path below to point to the base of your Novell LDAP NDK.
 ifndef LDAP_SDK
 LDAP_SDK = c:/novell/ndk/cldapsdk/win32
 endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.netware /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.netware
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.netware	2007-10-12 16:15:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.netware	2008-01-26 06:11:15.000000000 +0800
@@ -1,8 +1,8 @@
 #################################################################
-# $Id: Makefile.netware,v 1.69 2007-10-09 20:15:27 gknauf Exp $
+# $Id: Makefile.netware,v 1.73 2008-01-24 15:28:47 gknauf Exp $
 #
 ## Makefile for building libcurl.nlm (NetWare version - gnu make)
 ## Use: make -f Makefile.netware
 ##
 ## Comments to: Guenter Knauf http://www.gknw.de/phpbb
 #
@@ -17,28 +17,28 @@
 ifndef ZLIB_PATH
 ZLIB_PATH = ../../zlib-1.2.3
 endif
 
 # Edit the path below to point to the base of your OpenSSL package.
 ifndef OPENSSL_PATH
-OPENSSL_PATH = ../../openssl-0.9.8e
+OPENSSL_PATH = ../../openssl-0.9.8g
 endif
 
 # Edit the path below to point to the base of your LibSSH2 package.
 ifndef LIBSSH2_PATH
-LIBSSH2_PATH = ../../libssh2-0.16
+LIBSSH2_PATH = ../../libssh2-0.18
 endif
 
 ifndef INSTDIR
 INSTDIR	= ..$(DS)curl-$(LIBCURL_VERSION_STR)-bin-nw
 endif
 
 # Edit the vars below to change NLM target settings.
 TARGET  = libcurl
 VERSION	= $(LIBCURL_VERSION)
-COPYR	= Copyright (C) 1996 - 2007, Daniel Stenberg, <daniel@haxx.se>
+COPYR	= Copyright (C) $(LIBCURL_COPYRIGHT_STR)
 DESCR	= cURL libcurl $(LIBCURL_VERSION_STR) ($(LIBARCH)) - http://curl.haxx.se
 MTSAFE	= YES
 STACK	= 64000
 SCREEN	= none
 EXPORTS	= @libcurl.imp
 
@@ -69,13 +69,13 @@
 	MWCW_PATH = $(subst \,/,$(METROWERKS))/Novell Support/Metrowerks Support
 	CC = mwccnlm
 else
 	CC = gcc
 endif
 # a native win32 awk can be downloaded from here:
-# http://www.gknw.net/development/prgtools/awk-20050424.zip
+# http://www.gknw.net/development/prgtools/awk-20070501.zip
 AWK	= awk
 YACC	= bison -y
 CP	= cp -afv
 # RM	= rm -f
 # if you want to mark the target as MTSAFE you will need a tool for
 # generating the xdc data for the linker; here's a minimal tool:
@@ -333,15 +333,15 @@
 ifdef EXPORTS
 	@echo $(DL)export $(EXPORTS)$(DL) >> $@
 endif
 ifdef IMPORTS
 	@echo $(DL)import $(IMPORTS)$(DL) >> $@
 endif
-ifeq ($(LD),nlmconv)
-	@echo $(DL)input $(OBJL)$(DL) >> $@
+ifeq ($(findstring nlmconv,$(LD)),nlmconv)
 	@echo $(DL)input $(PRELUDE)$(DL) >> $@
+	@echo $(DL)input $(OBJL)$(DL) >> $@
 #ifdef LDLIBS
 #	@echo $(DL)input $(LDLIBS)$(DL) >> $@
 #endif
 	@echo $(DL)output $(TARGET).nlm$(DL) >> $@
 endif
 
@@ -369,13 +369,12 @@
 	@echo $(DL)#define SEND_TYPE_ARG1 int$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_ARG2 char *$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_ARG3 int$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_ARG4 int$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_RETV int$(DL) >> $@
 	@echo $(DL)#define socklen_t int$(DL) >> $@
-	@echo $(DL)#define DL_LDAP_FILE "ldapsdk.nlm"$(DL) >> $@
 else
 	@echo $(DL)#define OS "i586-pc-libc-NetWare"$(DL) >> $@
 	@echo $(DL)#define HAVE_FTRUNCATE 1$(DL) >> $@
 	@echo $(DL)#define HAVE_GETTIMEOFDAY 1$(DL) >> $@
 	@echo $(DL)#define HAVE_INET_PTON 1$(DL) >> $@
 	@echo $(DL)#define HAVE_INTTYPES_H 1$(DL) >> $@
@@ -402,13 +401,12 @@
 	@echo $(DL)#define SEND_TYPE_ARG1 int$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_ARG2 void *$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_ARG3 size_t$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_ARG4 int$(DL) >> $@
 	@echo $(DL)#define SEND_TYPE_RETV ssize_t$(DL) >> $@
 	@echo $(DL)#define SIZEOF_STRUCT_IN6_ADDR 16$(DL) >> $@
-	@echo $(DL)#define DL_LDAP_FILE "lldapsdk.nlm"$(DL) >> $@
 ifdef ENABLE_IPV6
 	@echo $(DL)#define ENABLE_IPV6 1$(DL) >> $@
 endif
 endif
 	@echo $(DL)#define HAVE_ARPA_INET_H 1$(DL) >> $@
 	@echo $(DL)#define HAVE_ASSERT_H 1$(DL) >> $@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.vc6	2007-09-16 05:11:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.vc6	2008-01-24 06:20:22.000000000 +0800
@@ -32,13 +32,13 @@
 # Stem for DLL import libs
 #
 IMPLIB_NAME       = libcurl_imp
 IMPLIB_NAME_DEBUG = libcurld_imp
 
 !IFNDEF OPENSSL_PATH
-OPENSSL_PATH   = ../../openssl-0.9.8e
+OPENSSL_PATH   = ../../openssl-0.9.8g
 !ENDIF
 
 !IFNDEF ZLIB_PATH
 ZLIB_PATH  = ../../zlib-1.2.3
 !ENDIF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.vc8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.vc8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.vc8	2007-10-29 22:49:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.vc8	2008-01-29 01:29:23.000000000 +0800
@@ -32,13 +32,13 @@
 # Stem for DLL import libs
 #
 IMPLIB_NAME       = libcurl_imp
 IMPLIB_NAME_DEBUG = libcurld_imp
 
 !IFNDEF OPENSSL_PATH
-OPENSSL_PATH   = ../../openssl-0.9.8e
+OPENSSL_PATH   = ../../openssl-0.9.8g
 !ENDIF
 
 !IFNDEF ZLIB_PATH
 ZLIB_PATH  = ../../zlib-1.2.3
 !ENDIF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.Watcom /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.Watcom
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/Makefile.Watcom	2007-10-29 16:31:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/Makefile.Watcom	2007-12-09 18:52:32.000000000 +0800
@@ -1,24 +1,35 @@
 #
 #  Watcom / OpenWatcom / Win32 makefile for libcurl.
-#  G. Vanem <giva@bgnett.no>
+#  G. Vanem <gvanem@broadpark.no>
 #
-# $Id: Makefile.Watcom,v 1.13 2007-10-28 12:02:20 giva Exp $
+# $Id: Makefile.Watcom,v 1.16 2007-12-09 09:44:05 giva Exp $
 
-TARGETS = ca-bundle.h libcurl_wc.lib libcurl_wc.dll libcurl_wc_imp.lib
+TARGETS = ca-bundle.h libcurl_wc.dll libcurl_wc_imp.lib
 
 CC = wcc386
 
-CFLAGS = -3r -mf -d3 -hc -zff -zgf -zq -zm -zc -s -fr=con -w2 -fpi -oilrtfm -bt=nt -bd &
-         -d+ -dWIN32 -dCURL_CA_BUNDLE=getenv("CURL_CA_BUNDLE")                     &
+CFLAGS = -3r -mf -d3 -hc -zff -zgf -zq -zm -zc -s -fr=con -w2 -fpi -oilrtfm -bt=nt &
+         -bd -d+ -dWIN32 -dCURL_CA_BUNDLE=getenv("CURL_CA_BUNDLE")                 &
          -dBUILDING_LIBCURL -dWITHOUT_MM_LIB -dHAVE_SPNEGO=1 -dENABLE_IPV6         &
          -dDEBUG_THREADING_GETADDRINFO -dDEBUG=1 -dCURLDEBUG -d_WIN32_WINNT=0x0501 &
-         -I. -I..\include -dCURL_DISABLE_LDAP
+         -dWINBERAPI=__declspec(cdecl) -dWINLDAPAPI=__declspec(cdecl)              &
+         -I. -I..\include
 
-OBJ_DIR  = Watcom_obj
-LIB_ARG  = $(OBJ_DIR)\wlib.arg
+#
+# Change to suite.
+#
+ZLIB_ROOT = ..\..\..\zlib-1.2.3
+USE_ZLIB  = 0
+
+!ifeq USE_ZLIB 1
+CFLAGS += -dHAVE_ZLIB_H -dHAVE_LIBZ -I$(ZLIB_ROOT)
+!endif
+
+OBJ_DIR  = WC_Win32.obj
+C_ARG    = $(OBJ_DIR)\wcc386.arg
 LINK_ARG = $(OBJ_DIR)\wlink.arg
 
 OBJS = $(OBJ_DIR)\base64.obj           $(OBJ_DIR)\connect.obj     &
        $(OBJ_DIR)\content_encoding.obj $(OBJ_DIR)\cookie.obj      &
        $(OBJ_DIR)\dict.obj             $(OBJ_DIR)\easy.obj        &
        $(OBJ_DIR)\escape.obj           $(OBJ_DIR)\file.obj        &
@@ -47,54 +58,53 @@
        $(OBJ_DIR)\telnet.obj           $(OBJ_DIR)\tftp.obj        &
        $(OBJ_DIR)\timeval.obj          $(OBJ_DIR)\transfer.obj    &
        $(OBJ_DIR)\url.obj              $(OBJ_DIR)\version.obj
 
 RESOURCE = $(OBJ_DIR)\libcurl.res
 
-all: $(OBJ_DIR) $(TARGETS) .SYMBOLIC
+all: $(OBJ_DIR) $(C_ARG) $(TARGETS) .SYMBOLIC
 	@echo Welcome to libcurl
 
 $(OBJ_DIR):
 	mkdir $(OBJ_DIR)
 
 ca-bundle.h:
 	@echo /* dummy ca-bundle.h. Not used */ > $@
 
-libcurl_wc.lib: $(OBJS) $(LIB_ARG)
-	wlib -q -b -c $@ @$(LIB_ARG)
-
-libcurl_wc.dll: $(OBJS) $(RESOURCE) $(LINK_ARG)
+libcurl_wc.dll libcurl_wc_imp.lib: $(OBJS) $(RESOURCE) $(LINK_ARG)
 	wlink name libcurl_wc.dll @$(LINK_ARG)
 
 clean: .SYMBOLIC
 	- rm -f $(OBJS) $(RESOURCE)
 
 vclean realclean: clean .SYMBOLIC
-	- rm -f $(TARGETS) $(LIB_ARG) $(LINK_ARG) libcurl_wc.map
+	- rm -f $(TARGETS) $(C_ARG) $(LINK_ARG) libcurl_wc.map
 	- rmdir $(OBJ_DIR)
 
 .ERASE
 $(RESOURCE): libcurl.rc
         wrc -dCURLDEBUG=1 -q -r -zm -I..\include -fo=$@ libcurl.rc
 
 .ERASE
 .c{$(OBJ_DIR)}.obj:
-	$(CC) $[@ $(CFLAGS) -fo=$@
-	@echo .
+	$(CC) $[@ @$(C_ARG) -fo=$@
 
-$(LIB_ARG): $(__MAKEFILES__)
+$(C_ARG): $(__MAKEFILES__)
 	%create $^@
-	for %f in ($(OBJS)) do @%append $^@ +- %f
+	%append $^@ $(CFLAGS)
 
 $(LINK_ARG): $(__MAKEFILES__)
 	%create $^@
 	@%append $^@ system nt dll
 	@%append $^@ file { $(OBJS) }
 	@%append $^@ option quiet, map, caseexact, eliminate, implib=libcurl_wc_imp.lib,
 	@%append $^@ res=$(RESOURCE) libpath $(%watcom)\lib386;$(%watcom)\lib386\nt
-	@%append $^@ library clib3r.lib, ws2_32.lib
+	@%append $^@ library clib3r.lib, wldap32.lib, ws2_32.lib
+!ifeq USE_ZLIB 1
+	@%append $^@ library $(ZLIB_ROOT)\zlib.lib
+!endif
 
 #
 # Dependencies based on "gcc -MM .."
 #
 $(OBJ_DIR)\file.obj: file.c setup.h config-win32.h setup_once.h urldata.h cookie.h &
   ..\include\curl\curl.h ..\include\curl\curlver.h ..\include\curl\easy.h &
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/md5.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/md5.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/md5.c	2005-05-02 22:33:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/md5.c	2007-11-07 17:21:35.000000000 +0800
@@ -1,27 +1,27 @@
 /***************************************************************************
- *                                  _   _ ____  _     
- *  Project                     ___| | | |  _ \| |    
- *                             / __| | | | |_) | |    
- *                            | (__| |_| |  _ <| |___ 
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2005, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
- * 
+ *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: md5.c,v 1.11 2005/05/02 14:33:07 bagder Exp $
+ * $Id: md5.c,v 1.12 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_CRYPTO_AUTH
 
@@ -158,27 +158,27 @@
   unsigned int i, bufindex, partLen;
 
   /* Compute number of bytes mod 64 */
   bufindex = (unsigned int)((context->count[0] >> 3) & 0x3F);
 
   /* Update number of bits */
-  if ((context->count[0] += ((UINT4)inputLen << 3))
+  if((context->count[0] += ((UINT4)inputLen << 3))
       < ((UINT4)inputLen << 3))
     context->count[1]++;
   context->count[1] += ((UINT4)inputLen >> 29);
-  
+
   partLen = 64 - bufindex;
 
   /* Transform as many times as possible. */
-  if (inputLen >= partLen) {
+  if(inputLen >= partLen) {
     memcpy((void *)&context->buffer[bufindex], (void *)input, partLen);
     MD5Transform(context->state, context->buffer);
-    
+
     for (i = partLen; i + 63 < inputLen; i += 64)
       MD5Transform(context->state, &input[i]);
-    
+
     bufindex = 0;
   }
   else
     i = 0;
 
   /* Buffer remaining input */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/memdebug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/memdebug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/memdebug.c	2007-08-08 18:38:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/memdebug.c	2007-11-07 17:21:35.000000000 +0800
@@ -16,13 +16,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: memdebug.c,v 1.54 2007-08-08 10:37:07 patrickm Exp $
+ * $Id: memdebug.c,v 1.55 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
@@ -68,13 +68,13 @@
 static bool memlimit = FALSE; /* enable memory limit */
 static long memsize = 0;  /* set number of mallocs allowed */
 
 /* this sets the log file name */
 void curl_memdebug(const char *logname)
 {
-  if (!logfile) {
+  if(!logfile) {
     if(logname)
       logfile = fopen(logname, "w");
     else
       logfile = stderr;
 #ifdef MEMDEBUG_LOG_SYNC
     /* Flush the log file after every line so the log isn't lost in a crash */
@@ -84,13 +84,13 @@
 }
 
 /* This function sets the number of malloc() calls that should return
    successfully! */
 void curl_memlimit(long limit)
 {
-  if (!memlimit) {
+  if(!memlimit) {
     memlimit = TRUE;
     memsize = limit;
   }
 }
 
 /* returns TRUE if this isn't allowed! */
@@ -182,14 +182,14 @@
   if(countcheck("strdup", line, source))
     return NULL;
 
   len=strlen(str)+1;
 
   mem=curl_domalloc(len, 0, NULL); /* NULL prevents logging */
-  if (mem)
-  memcpy(mem, str, len);
+  if(mem)
+    memcpy(mem, str, len);
 
   if(logfile)
     fprintf(logfile, "MEM %s:%d strdup(%p) (%zd) = %p\n",
             source, line, str, len, mem);
 
   return mem;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/mprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/mprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/mprintf.c	2007-08-10 22:22:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/mprintf.c	2007-11-20 18:03:33.000000000 +0800
@@ -1,9 +1,9 @@
 /****************************************************************************
  *
- * $Id: mprintf.c,v 1.59 2007-08-09 21:05:05 gknauf Exp $
+ * $Id: mprintf.c,v 1.61 2007-11-20 10:03:33 bagder Exp $
  *
  *************************************************************************
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -305,31 +305,31 @@
   long width;
   long precision;
   int flags;
   long max_param=0;
   long i;
 
-  while (*fmt) {
-    if (*fmt++ == '%') {
-      if (*fmt == '%') {
+  while(*fmt) {
+    if(*fmt++ == '%') {
+      if(*fmt == '%') {
         fmt++;
         continue; /* while */
       }
 
       flags = FLAGS_NEW;
 
       /* Handle the positional case (N$) */
 
       param_num++;
 
       this_param = dprintf_DollarString(fmt, &fmt);
-      if (0 == this_param)
+      if(0 == this_param)
         /* we got no positional, get the next counter */
         this_param = param_num;
 
-      if (this_param > max_param)
+      if(this_param > max_param)
         max_param = this_param;
 
       /*
        * The parameter with number 'i' should be used. Next, we need
        * to get SIZE and TYPE of the parameter. Add the information
        * to our array.
@@ -337,13 +337,13 @@
 
       width = 0;
       precision = 0;
 
       /* Handle the flags */
 
-      while (dprintf_IsQualifierNoDollar(*fmt)) {
+      while(dprintf_IsQualifierNoDollar(*fmt)) {
         switch (*fmt++) {
         case ' ':
           flags |= FLAGS_SPACE;
           break;
         case '+':
           flags |= FLAGS_SHOWSIGN;
@@ -354,38 +354,38 @@
           break;
         case '#':
           flags |= FLAGS_ALT;
           break;
         case '.':
           flags |= FLAGS_PREC;
-          if ('*' == *fmt) {
+          if('*' == *fmt) {
             /* The precision is picked from a specified parameter */
 
             flags |= FLAGS_PRECPARAM;
             fmt++;
             param_num++;
 
             i = dprintf_DollarString(fmt, &fmt);
-            if (i)
+            if(i)
               precision = i;
             else
               precision = param_num;
 
-            if (precision > max_param)
+            if(precision > max_param)
               max_param = precision;
           }
           else {
             flags |= FLAGS_PREC;
             precision = strtol(fmt, &fmt, 10);
           }
           break;
         case 'h':
           flags |= FLAGS_SHORT;
           break;
         case 'l':
-          if (flags & FLAGS_LONG)
+          if(flags & FLAGS_LONG)
             flags |= FLAGS_LONGLONG;
           else
             flags |= FLAGS_LONG;
           break;
         case 'L':
           flags |= FLAGS_LONGDOUBLE;
@@ -407,13 +407,13 @@
           flags |= FLAGS_LONGLONG;
 #else
           flags |= FLAGS_LONG;
 #endif
           break;
         case '0':
-          if (!(flags & FLAGS_LEFT))
+          if(!(flags & FLAGS_LEFT))
             flags |= FLAGS_PAD_NIL;
           /* FALLTHROUGH */
         case '1': case '2': case '3': case '4':
         case '5': case '6': case '7': case '8': case '9':
           flags |= FLAGS_WIDTH;
           width = strtol(fmt-1, &fmt, 10);
@@ -500,23 +500,23 @@
       } /* switch */
 
       vto[i].flags = flags;
       vto[i].width = width;
       vto[i].precision = precision;
 
-      if (flags & FLAGS_WIDTHPARAM) {
+      if(flags & FLAGS_WIDTHPARAM) {
         /* we have the width specified from a parameter, so we make that
            parameter's info setup properly */
         vto[i].width = width - 1;
         i = width - 1;
         vto[i].type = FORMAT_WIDTH;
         vto[i].flags = FLAGS_NEW;
         vto[i].precision = vto[i].width = 0; /* can't use width or precision
                                                 of width! */
       }
-      if (flags & FLAGS_PRECPARAM) {
+      if(flags & FLAGS_PRECPARAM) {
         /* we have the precision specified from a parameter, so we make that
            parameter's info setup properly */
         vto[i].precision = precision - 1;
         i = precision - 1;
         vto[i].type = FORMAT_WIDTH;
         vto[i].flags = FLAGS_NEW;
@@ -530,13 +530,13 @@
 #ifdef DPRINTF_DEBUG2
   dprintf_Pass1Report(vto, max_param);
 #endif
 
   /* Read the arg list parameters into our data list */
   for (i=0; i<max_param; i++) {
-    if ((i + 1 < max_param) && (vto[i + 1].type == FORMAT_WIDTH))
+    if((i + 1 < max_param) && (vto[i + 1].type == FORMAT_WIDTH))
       {
         /* Width/precision arguments must be read before the main argument
          * they are attached to
          */
         vto[i + 1].data.num = va_arg(arglist, int);
       }
@@ -617,13 +617,13 @@
   dprintf_Pass1(format, vto, endpos, ap_save);
 
   end = &endpos[0]; /* the initial end-position from the list dprintf_Pass1()
                        created for us */
 
   f = (char *)format;
-  while (*f != '\0') {
+  while(*f != '\0') {
     /* Format spec modifiers.  */
     char alt;
 
     /* Width of a field.  */
     long width;
 
@@ -641,13 +641,13 @@
     unsigned LONG_LONG num;
 #else
     unsigned long num;
 #endif
     long signed_num;
 
-    if (*f != '%') {
+    if(*f != '%') {
       /* This isn't a format spec, so write everything out until the next one
          OR end of string is reached.  */
       do {
         OUTCHAR(*f);
       } while(*++f && ('%' != *f));
       continue;
@@ -656,13 +656,13 @@
     ++f;
 
     /* Check for "%%".  Note that although the ANSI standard lists
        '%' as a conversion specifier, it says "The complete format
        specification shall be `%%'," so we can avoid all the width
        and precision processing.  */
-    if (*f == '%') {
+    if(*f == '%') {
       ++f;
       OUTCHAR('%');
       continue;
     }
 
     /* If this is a positional parameter, the position must follow imediately
@@ -683,32 +683,35 @@
     if(p->flags & FLAGS_WIDTHPARAM)
       width = vto[p->width].data.num;
     else
       width = p->width;
 
     /* pick up the specified precision */
-    if(p->flags & FLAGS_PRECPARAM)
+    if(p->flags & FLAGS_PRECPARAM) {
       prec = vto[p->precision].data.num;
+      param_num++; /* since the precision is extraced from a parameter, we
+                      must skip that to get to the next one properly */
+    }
     else if(p->flags & FLAGS_PREC)
       prec = p->precision;
     else
       prec = -1;
 
     alt = (char)((p->flags & FLAGS_ALT)?TRUE:FALSE);
 
     switch (p->type) {
     case FORMAT_INT:
       num = p->data.num;
       if(p->flags & FLAGS_CHAR) {
         /* Character.  */
-        if (!(p->flags & FLAGS_LEFT))
-          while (--width > 0)
+        if(!(p->flags & FLAGS_LEFT))
+          while(--width > 0)
             OUTCHAR(' ');
         OUTCHAR((char) num);
-        if (p->flags & FLAGS_LEFT)
-          while (--width > 0)
+        if(p->flags & FLAGS_LEFT)
+          while(--width > 0)
             OUTCHAR(' ');
         break;
       }
       if(p->flags & FLAGS_UNSIGNED) {
         /* Decimal unsigned integer.  */
         base = 10;
@@ -753,86 +756,86 @@
       /* Number of base BASE.  */
       {
         char *workend = &work[sizeof(work) - 1];
         char *w;
 
         /* Supply a default precision if none was given.  */
-        if (prec == -1)
+        if(prec == -1)
           prec = 1;
 
         /* Put the number in WORK.  */
         w = workend;
-        while (num > 0) {
+        while(num > 0) {
           *w-- = digits[num % base];
           num /= base;
         }
         width -= (long)(workend - w);
         prec -= (long)(workend - w);
 
-        if (alt && base == 8 && prec <= 0) {
+        if(alt && base == 8 && prec <= 0) {
           *w-- = '0';
           --width;
         }
 
-        if (prec > 0) {
+        if(prec > 0) {
           width -= prec;
-          while (prec-- > 0)
+          while(prec-- > 0)
             *w-- = '0';
         }
 
-        if (alt && base == 16)
+        if(alt && base == 16)
           width -= 2;
 
-        if (is_neg || (p->flags & FLAGS_SHOWSIGN) || (p->flags & FLAGS_SPACE))
+        if(is_neg || (p->flags & FLAGS_SHOWSIGN) || (p->flags & FLAGS_SPACE))
           --width;
 
-        if (!(p->flags & FLAGS_LEFT) && !(p->flags & FLAGS_PAD_NIL))
-          while (width-- > 0)
+        if(!(p->flags & FLAGS_LEFT) && !(p->flags & FLAGS_PAD_NIL))
+          while(width-- > 0)
             OUTCHAR(' ');
 
-        if (is_neg)
+        if(is_neg)
           OUTCHAR('-');
-        else if (p->flags & FLAGS_SHOWSIGN)
+        else if(p->flags & FLAGS_SHOWSIGN)
           OUTCHAR('+');
-        else if (p->flags & FLAGS_SPACE)
+        else if(p->flags & FLAGS_SPACE)
           OUTCHAR(' ');
 
-        if (alt && base == 16) {
+        if(alt && base == 16) {
           OUTCHAR('0');
           if(p->flags & FLAGS_UPPER)
             OUTCHAR('X');
           else
             OUTCHAR('x');
         }
 
-        if (!(p->flags & FLAGS_LEFT) && (p->flags & FLAGS_PAD_NIL))
-          while (width-- > 0)
+        if(!(p->flags & FLAGS_LEFT) && (p->flags & FLAGS_PAD_NIL))
+          while(width-- > 0)
             OUTCHAR('0');
 
         /* Write the number.  */
-        while (++w <= workend) {
+        while(++w <= workend) {
           OUTCHAR(*w);
         }
 
-        if (p->flags & FLAGS_LEFT)
-          while (width-- > 0)
+        if(p->flags & FLAGS_LEFT)
+          while(width-- > 0)
             OUTCHAR(' ');
       }
       break;
 
     case FORMAT_STRING:
             /* String.  */
       {
         static const char null[] = "(nil)";
         const char *str;
         size_t len;
 
         str = (char *) p->data.str;
-        if ( str == NULL) {
+        if( str == NULL) {
           /* Write null[] if there's space.  */
-          if (prec == -1 || prec >= (long) sizeof(null) - 1) {
+          if(prec == -1 || prec >= (long) sizeof(null) - 1) {
             str = null;
             len = sizeof(null) - 1;
             /* Disable quotes around (nil) */
             p->flags &= (~FLAGS_ALT);
           }
           else {
@@ -840,40 +843,40 @@
             len = 0;
           }
         }
         else
           len = strlen(str);
 
-        if (prec != -1 && (size_t) prec < len)
+        if(prec != -1 && (size_t) prec < len)
           len = prec;
         width -= (long)len;
 
-        if (p->flags & FLAGS_ALT)
+        if(p->flags & FLAGS_ALT)
           OUTCHAR('"');
 
-        if (!(p->flags&FLAGS_LEFT))
-          while (width-- > 0)
+        if(!(p->flags&FLAGS_LEFT))
+          while(width-- > 0)
             OUTCHAR(' ');
 
-        while (len-- > 0)
+        while(len-- > 0)
           OUTCHAR(*str++);
-        if (p->flags&FLAGS_LEFT)
-          while (width-- > 0)
+        if(p->flags&FLAGS_LEFT)
+          while(width-- > 0)
             OUTCHAR(' ');
 
-        if (p->flags & FLAGS_ALT)
+        if(p->flags & FLAGS_ALT)
           OUTCHAR('"');
       }
       break;
 
     case FORMAT_PTR:
       /* Generic pointer.  */
       {
         void *ptr;
         ptr = (void *) p->data.ptr;
-        if (ptr != NULL) {
+        if(ptr != NULL) {
           /* If the pointer is not NULL, write it as a %#x spec.  */
           base = 16;
           digits = (p->flags & FLAGS_UPPER)? upper_digits : lower_digits;
           alt = 1;
           num = (size_t) ptr;
           is_neg = 0;
@@ -882,19 +885,19 @@
         else {
           /* Write "(nil)" for a nil pointer.  */
           static const char strnil[] = "(nil)";
           const char *point;
 
           width -= sizeof(strnil) - 1;
-          if (p->flags & FLAGS_LEFT)
-            while (width-- > 0)
+          if(p->flags & FLAGS_LEFT)
+            while(width-- > 0)
               OUTCHAR(' ');
           for (point = strnil; *point != '\0'; ++point)
             OUTCHAR(*point);
-          if (! (p->flags & FLAGS_LEFT))
-            while (width-- > 0)
+          if(! (p->flags & FLAGS_LEFT))
+            while(width-- > 0)
               OUTCHAR(' ');
         }
       }
       break;
 
     case FORMAT_DOUBLE:
@@ -902,30 +905,30 @@
         char formatbuf[32]="%";
         char *fptr;
         size_t left = sizeof(formatbuf)-strlen(formatbuf);
         int len;
 
         width = -1;
-        if (p->flags & FLAGS_WIDTH)
+        if(p->flags & FLAGS_WIDTH)
           width = p->width;
-        else if (p->flags & FLAGS_WIDTHPARAM)
+        else if(p->flags & FLAGS_WIDTHPARAM)
           width = vto[p->width].data.num;
 
         prec = -1;
-        if (p->flags & FLAGS_PREC)
+        if(p->flags & FLAGS_PREC)
           prec = p->precision;
-        else if (p->flags & FLAGS_PRECPARAM)
+        else if(p->flags & FLAGS_PRECPARAM)
           prec = vto[p->precision].data.num;
 
-        if (p->flags & FLAGS_LEFT)
+        if(p->flags & FLAGS_LEFT)
           strcat(formatbuf, "-");
-        if (p->flags & FLAGS_SHOWSIGN)
+        if(p->flags & FLAGS_SHOWSIGN)
           strcat(formatbuf, "+");
-        if (p->flags & FLAGS_SPACE)
+        if(p->flags & FLAGS_SPACE)
           strcat(formatbuf, " ");
-        if (p->flags & FLAGS_ALT)
+        if(p->flags & FLAGS_ALT)
           strcat(formatbuf, "#");
 
         fptr=&formatbuf[strlen(formatbuf)];
 
         if(width >= 0) {
           /* RECURSIVE USAGE */
@@ -936,18 +939,18 @@
         if(prec >= 0) {
           /* RECURSIVE USAGE */
           len = curl_msnprintf(fptr, left, ".%ld", prec);
           fptr += len;
           left -= len;
         }
-        if (p->flags & FLAGS_LONG)
+        if(p->flags & FLAGS_LONG)
           *fptr++ = 'l';
 
-        if (p->flags & FLAGS_FLOATE)
+        if(p->flags & FLAGS_FLOATE)
           *fptr++ = (char)((p->flags & FLAGS_UPPER) ? 'E':'e');
-        else if (p->flags & FLAGS_FLOATG)
+        else if(p->flags & FLAGS_FLOATG)
           *fptr++ = (char)((p->flags & FLAGS_UPPER) ? 'G' : 'g');
         else
           *fptr++ = 'f';
 
         *fptr = 0; /* and a final zero termination */
 
@@ -960,19 +963,19 @@
       }
       break;
 
     case FORMAT_INTPTR:
       /* Answer the count of characters written.  */
 #ifdef ENABLE_64BIT
-      if (p->flags & FLAGS_LONGLONG)
+      if(p->flags & FLAGS_LONGLONG)
         *(LONG_LONG *) p->data.ptr = (LONG_LONG)done;
       else
 #endif
-        if (p->flags & FLAGS_LONG)
+        if(p->flags & FLAGS_LONG)
           *(long *) p->data.ptr = (long)done;
-      else if (!(p->flags & FLAGS_SHORT))
+      else if(!(p->flags & FLAGS_SHORT))
         *(int *) p->data.ptr = (int)done;
       else
         *(short *) p->data.ptr = (short)done;
       break;
 
     default:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/multi.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/multi.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/multi.c	2007-09-27 19:38:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/multi.c	2008-01-28 06:53:10.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: multi.c,v 1.152 2007-09-27 01:45:23 danf Exp $
+ * $Id: multi.c,v 1.163 2008-01-27 22:53:10 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdlib.h>
 #include <string.h>
@@ -82,13 +82,12 @@
   CURLM_STATE_DO_DONE,     /* done sending off request */
   CURLM_STATE_WAITPERFORM, /* wait for our turn to read the response */
   CURLM_STATE_PERFORM,     /* transfer data */
   CURLM_STATE_TOOFAST,     /* wait because limit-rate exceeded */
   CURLM_STATE_DONE,        /* post data transfer operation */
   CURLM_STATE_COMPLETED,   /* operation complete */
-  CURLM_STATE_CANCELLED,   /* cancelled */
 
   CURLM_STATE_LAST /* not a true state, never use this */
 } CURLMstate;
 
 /* we support N sockets per easy handle. Set the corresponding bit to what
    action we should wait for */
@@ -187,12 +186,20 @@
 static void singlesocket(struct Curl_multi *multi,
                          struct Curl_one_easy *easy);
 static void add_closure(struct Curl_multi *multi,
                         struct SessionHandle *data);
 static int update_timer(struct Curl_multi *multi);
 
+static CURLcode addHandleToSendOrPendPipeline(struct SessionHandle *handle,
+                                              struct connectdata *conn);
+static int checkPendPipeline(struct connectdata *conn);
+static int moveHandleFromSendToRecvPipeline(struct SessionHandle *habdle,
+                                            struct connectdata *conn);
+static bool isHandleAtHead(struct SessionHandle *handle,
+                           struct curl_llist *pipeline);
+
 #ifdef CURLDEBUG
 static const char * const statename[]={
   "INIT",
   "CONNECT",
   "WAITRESOLVE",
   "WAITCONNECT",
@@ -205,13 +212,12 @@
   "DO_DONE",
   "WAITPERFORM",
   "PERFORM",
   "TOOFAST",
   "DONE",
   "COMPLETED",
-  "CANCELLED"
 };
 
 void curl_multi_dump(CURLM *multi_handle);
 #endif
 
 /* always use this function to change state, to make debugging easier */
@@ -443,20 +449,20 @@
 
   /* set the back pointer to one_easy to assist in removal */
   easy->easy_handle->multi_pos =  easy;
 
   /* for multi interface connections, we share DNS cache automatically if the
      easy handle's one is currently private. */
-  if (easy->easy_handle->dns.hostcache &&
+  if(easy->easy_handle->dns.hostcache &&
       (easy->easy_handle->dns.hostcachetype == HCACHE_PRIVATE)) {
     Curl_hash_destroy(easy->easy_handle->dns.hostcache);
     easy->easy_handle->dns.hostcache = NULL;
     easy->easy_handle->dns.hostcachetype = HCACHE_NONE;
   }
 
-  if (!easy->easy_handle->dns.hostcache ||
+  if(!easy->easy_handle->dns.hostcache ||
       (easy->easy_handle->dns.hostcachetype == HCACHE_NONE)) {
     easy->easy_handle->dns.hostcache = multi->hostcache;
     easy->easy_handle->dns.hostcachetype = HCACHE_MULTI;
   }
 
   if(easy->easy_handle->state.connc) {
@@ -575,21 +581,23 @@
        nice to put the easy_handle in a good known state when this returns. */
     if(premature)
       /* this handle is "alive" so we need to count down the total number of
          alive connections when this is removed */
       multi->num_alive--;
 
-    if (easy->easy_handle->state.is_in_pipeline &&
-        easy->state > CURLM_STATE_DO &&
+    if(easy->easy_conn &&
+        easy->easy_handle->state.is_in_pipeline &&
+        easy->state > CURLM_STATE_WAITDO &&
         easy->state < CURLM_STATE_COMPLETED) {
-      /* If the handle is in a pipeline and has finished sending off its
-         request but not received its reponse yet, we need to remember the
-         fact that we want to remove this handle but do the actual removal at
-         a later time */
-      easy->easy_handle->state.cancelled = TRUE;
-      return CURLM_OK;
+      /* If the handle is in a pipeline and has started sending off its
+         request but not received its reponse yet, we need to close
+         connection. */
+      easy->easy_conn->bits.close = TRUE;
+      /* Set connection owner so that Curl_done() closes it.
+         We can sefely do this here since connection is killed. */
+      easy->easy_conn->data = easy->easy_handle;
     }
 
     /* The timer must be shut down before easy->multi is set to NULL,
        else the timenode will remain in the splay tree after
        curl_easy_cleanup is called. */
     Curl_expire(easy->easy_handle, 0);
@@ -676,13 +684,13 @@
 
     /* Null the position in the controlling structure */
     easy->easy_handle->multi_pos = NULL;
 
     /* NOTE NOTE NOTE
        We do not touch the easy handle here! */
-    if (easy->msg)
+    if(easy->msg)
       free(easy->msg);
     free(easy);
 
     multi->num_easy--; /* one less to care about now */
 
     update_timer(multi);
@@ -698,13 +706,13 @@
 }
 
 void Curl_multi_handlePipeBreak(struct SessionHandle *data)
 {
   struct Curl_one_easy *one_easy = data->set.one_easy;
 
-  if (one_easy)
+  if(one_easy)
     one_easy->easy_conn = NULL;
 }
 
 static int waitconnect_getsock(struct connectdata *conn,
                                curl_socket_t *sock,
                                int numsocks)
@@ -742,18 +750,18 @@
   /* If the pipe broke, or if there's no connection left for this easy handle,
      then we MUST bail out now with no bitmask set. The no connection case can
      happen when this is called from curl_multi_remove_handle() =>
      singlesocket() => multi_getsock().
   */
 
-  if (easy->easy_handle->state.pipe_broke ||
+  if(easy->easy_handle->state.pipe_broke ||
       !easy->easy_conn) {
     return 0;
   }
 
-  if (easy->state > CURLM_STATE_CONNECT &&
+  if(easy->state > CURLM_STATE_CONNECT &&
       easy->state < CURLM_STATE_COMPLETED) {
     /* Set up ownership correctly */
     easy->easy_conn->data = easy->easy_handle;
   }
 
   switch(easy->state) {
@@ -769,12 +777,13 @@
   case CURLM_STATE_PROTOCONNECT:
     return Curl_protocol_getsock(easy->easy_conn, socks, numsocks);
 
   case CURLM_STATE_DOING:
     return Curl_doing_getsock(easy->easy_conn, socks, numsocks);
 
+  case CURLM_STATE_WAITPROXYCONNECT:
   case CURLM_STATE_WAITCONNECT:
     return waitconnect_getsock(easy->easy_conn, socks, numsocks);
 
   case CURLM_STATE_DO_MORE:
     return domore_getsock(easy->easy_conn, socks, numsocks);
 
@@ -842,29 +851,30 @@
   bool connected;
   bool async;
   bool protocol_connect = FALSE;
   bool dophase_done;
   bool done;
   CURLMcode result = CURLM_OK;
-  struct Curl_transfer_keeper *k;
+  struct SingleRequest *k;
 
   do {
     bool disconnect_conn = FALSE;
 
     if(!GOOD_EASY_HANDLE(easy->easy_handle))
       return CURLM_BAD_EASY_HANDLE;
 
     /* Handle the case when the pipe breaks, i.e., the connection
        we're using gets cleaned up and we're left with nothing. */
-    if (easy->easy_handle->state.pipe_broke) {
+    if(easy->easy_handle->state.pipe_broke) {
       infof(easy->easy_handle, "Pipe broke: handle 0x%x, url = %s\n",
-            easy, easy->easy_handle->reqdata.path);
+            easy, easy->easy_handle->state.path);
 
       if(easy->easy_handle->state.is_in_pipeline) {
         /* Head back to the CONNECT state */
         multistate(easy, CURLM_STATE_CONNECT);
+        easy->easy_handle->state.is_in_pipeline = FALSE;
         result = CURLM_CALL_MULTI_PERFORM;
         easy->result = CURLE_OK;
       }
       else {
         easy->result = CURLE_COULDNT_CONNECT;
         multistate(easy, CURLM_STATE_COMPLETED);
@@ -872,19 +882,19 @@
 
       easy->easy_handle->state.pipe_broke = FALSE;
       easy->easy_conn = NULL;
       break;
     }
 
-    if (easy->state > CURLM_STATE_CONNECT &&
+    if(easy->state > CURLM_STATE_CONNECT &&
         easy->state < CURLM_STATE_COMPLETED) {
       /* Make sure we set the connection's current owner */
       easy->easy_conn->data = easy->easy_handle;
     }
 
-    if (CURLM_STATE_WAITCONNECT <= easy->state &&
+    if(CURLM_STATE_WAITCONNECT <= easy->state &&
         easy->state <= CURLM_STATE_DO &&
         easy->easy_handle->change.url_changed) {
       char *gotourl;
       Curl_posttransfer(easy->easy_handle);
 
       easy->result = Curl_done(&easy->easy_conn, CURLE_OK, FALSE);
@@ -929,34 +939,42 @@
       /* Connect. We get a connection identifier filled in. */
       Curl_pgrsTime(easy->easy_handle, TIMER_STARTSINGLE);
       easy->result = Curl_connect(easy->easy_handle, &easy->easy_conn,
                                   &async, &protocol_connect);
 
       if(CURLE_OK == easy->result) {
-        /* Add this handle to the send pipeline */
-        easy->result = Curl_addHandleToPipeline(easy->easy_handle,
-                                                easy->easy_conn->send_pipe);
+        /* Add this handle to the send or pend pipeline */
+        easy->result = addHandleToSendOrPendPipeline(easy->easy_handle,
+                                                     easy->easy_conn);
 	if(CURLE_OK == easy->result) {
-	  if(async)
-	    /* We're now waiting for an asynchronous name lookup */
-	    multistate(easy, CURLM_STATE_WAITRESOLVE);
+          if (easy->easy_handle->state.is_in_pipeline) {
+            multistate(easy, CURLM_STATE_WAITDO);
+            if(isHandleAtHead(easy->easy_handle,
+                              easy->easy_conn->send_pipe))
+              result = CURLM_CALL_MULTI_PERFORM;
+          }
 	  else {
-	    /* after the connect has been sent off, go WAITCONNECT unless the
-	       protocol connect is already done and we can go directly to
-	       WAITDO! */
-	    result = CURLM_CALL_MULTI_PERFORM;
-
-	    if(protocol_connect)
-	      multistate(easy, CURLM_STATE_WAITDO);
+            if(async)
+              /* We're now waiting for an asynchronous name lookup */
+              multistate(easy, CURLM_STATE_WAITRESOLVE);
 	    else {
+              /* after the connect has been sent off, go WAITCONNECT unless the
+                 protocol connect is already done and we can go directly to
+                 WAITDO! */
+              result = CURLM_CALL_MULTI_PERFORM;
+
+              if(protocol_connect)
+                multistate(easy, CURLM_STATE_WAITDO);
+              else {
 #ifndef CURL_DISABLE_HTTP
-	      if (easy->easy_conn->bits.tunnel_connecting)
-		multistate(easy, CURLM_STATE_WAITPROXYCONNECT);
-	      else
+                if(easy->easy_conn->bits.tunnel_connecting)
+                  multistate(easy, CURLM_STATE_WAITPROXYCONNECT);
+                else
 #endif
-		multistate(easy, CURLM_STATE_WAITCONNECT);
+                  multistate(easy, CURLM_STATE_WAITCONNECT);
+              }
 	    }
 	  }
 	}
       }
       break;
 
@@ -982,13 +1000,13 @@
           /* call again please so that we get the next socket setup */
           result = CURLM_CALL_MULTI_PERFORM;
           if(protocol_connect)
             multistate(easy, CURLM_STATE_WAITDO);
           else {
 #ifndef CURL_DISABLE_HTTP
-            if (easy->easy_conn->bits.tunnel_connecting)
+            if(easy->easy_conn->bits.tunnel_connecting)
               multistate(easy, CURLM_STATE_WAITPROXYCONNECT);
             else
 #endif
               multistate(easy, CURLM_STATE_WAITCONNECT);
           }
         }
@@ -1005,13 +1023,13 @@
 #ifndef CURL_DISABLE_HTTP
     case CURLM_STATE_WAITPROXYCONNECT:
       /* this is HTTP-specific, but sending CONNECT to a proxy is HTTP... */
       easy->result = Curl_http_connect(easy->easy_conn, &protocol_connect);
 
       if(CURLE_OK == easy->result) {
-        if (!easy->easy_conn->bits.tunnel_connecting)
+        if(!easy->easy_conn->bits.tunnel_connecting)
           multistate(easy, CURLM_STATE_WAITCONNECT);
       }
       break;
 #endif
 
     case CURLM_STATE_WAITCONNECT:
@@ -1035,13 +1053,13 @@
           /* We have a TCP connection, but 'protocol_connect' may be false
              and then we continue to 'STATE_PROTOCONNECT'. If protocol
              connect is TRUE, we move on to STATE_DO.
              BUT if we are using a proxy we must change to WAITPROXYCONNECT
              */
 #ifndef CURL_DISABLE_HTTP
-          if (easy->easy_conn->bits.tunnel_connecting)
+          if(easy->easy_conn->bits.tunnel_connecting)
             multistate(easy, CURLM_STATE_WAITPROXYCONNECT);
           else
 #endif
             multistate(easy, CURLM_STATE_PROTOCONNECT);
         }
         else {
@@ -1054,13 +1072,13 @@
       break;
 
     case CURLM_STATE_PROTOCONNECT:
       /* protocol-specific connect phase */
       easy->result = Curl_protocol_connecting(easy->easy_conn,
                                               &protocol_connect);
-      if(protocol_connect) {
+      if((easy->result == CURLE_OK) && protocol_connect) {
         /* after the connect has completed, go WAITDO */
         multistate(easy, CURLM_STATE_WAITDO);
         result = CURLM_CALL_MULTI_PERFORM;
       }
       else if(easy->result) {
         /* failure detected */
@@ -1074,18 +1092,18 @@
       /* Wait for our turn to DO when we're pipelining requests */
 #ifdef CURLDEBUG
       infof(easy->easy_handle, "Conn %d send pipe %d inuse %d athead %d\n",
             easy->easy_conn->connectindex,
             easy->easy_conn->send_pipe->size,
             easy->easy_conn->writechannel_inuse,
-            Curl_isHandleAtHead(easy->easy_handle,
-                                easy->easy_conn->send_pipe));
+            isHandleAtHead(easy->easy_handle,
+                           easy->easy_conn->send_pipe));
 #endif
-      if (!easy->easy_conn->writechannel_inuse &&
-          Curl_isHandleAtHead(easy->easy_handle,
-                              easy->easy_conn->send_pipe)) {
+      if(!easy->easy_conn->writechannel_inuse &&
+         isHandleAtHead(easy->easy_handle,
+                        easy->easy_conn->send_pipe)) {
         /* Grab the channel */
         easy->easy_conn->writechannel_inuse = TRUE;
         multistate(easy, CURLM_STATE_DO);
         result = CURLM_CALL_MULTI_PERFORM;
       }
       break;
@@ -1118,17 +1136,14 @@
                and wait a little while first */
             multistate(easy, CURLM_STATE_DO_MORE);
             result = CURLM_OK;
           }
           else {
             /* we're done with the DO, now DO_DONE */
-            easy->result = Curl_readwrite_init(easy->easy_conn);
-            if(CURLE_OK == easy->result) {
-              multistate(easy, CURLM_STATE_DO_DONE);
-              result = CURLM_CALL_MULTI_PERFORM;
-            }
+            multistate(easy, CURLM_STATE_DO_DONE);
+            result = CURLM_CALL_MULTI_PERFORM;
           }
         }
         else {
           /* failure detected */
           Curl_posttransfer(easy->easy_handle);
           Curl_done(&easy->easy_conn, easy->result, FALSE);
@@ -1149,17 +1164,14 @@
                and wait a little while first */
             multistate(easy, CURLM_STATE_DO_MORE);
             result = CURLM_OK;
           }
           else {
             /* we're done with the DO, now DO_DONE */
-            easy->result = Curl_readwrite_init(easy->easy_conn);
-            if(CURLE_OK == easy->result) {
-              multistate(easy, CURLM_STATE_DO_DONE);
-              result = CURLM_CALL_MULTI_PERFORM;
-            }
+            multistate(easy, CURLM_STATE_DO_DONE);
+            result = CURLM_CALL_MULTI_PERFORM;
           }
         } /* dophase_done */
       }
       else {
         /* failure detected */
         Curl_posttransfer(easy->easy_handle);
@@ -1176,76 +1188,73 @@
       if(connected) {
         /*
          * When we are connected, DO MORE and then go DO_DONE
          */
         easy->result = Curl_do_more(easy->easy_conn);
 
-        if(CURLE_OK == easy->result)
-          easy->result = Curl_readwrite_init(easy->easy_conn);
-        else
-          /* Remove ourselves from the send pipeline */
-          Curl_removeHandleFromPipeline(easy->easy_handle,
-                                        easy->easy_conn->send_pipe);
+        /* No need to remove ourselves from the send pipeline here since that
+           is done for us in Curl_done() */
 
         if(CURLE_OK == easy->result) {
           multistate(easy, CURLM_STATE_DO_DONE);
           result = CURLM_CALL_MULTI_PERFORM;
         }
+        else {
+          /* failure detected */
+          Curl_posttransfer(easy->easy_handle);
+          Curl_done(&easy->easy_conn, easy->result, FALSE);
+          disconnect_conn = TRUE;
+        }
       }
       break;
 
     case CURLM_STATE_DO_DONE:
-      /* Remove ourselves from the send pipeline */
-      Curl_removeHandleFromPipeline(easy->easy_handle,
-                                    easy->easy_conn->send_pipe);
-      /* Add ourselves to the recv pipeline */
-      easy->result = Curl_addHandleToPipeline(easy->easy_handle,
-                                              easy->easy_conn->recv_pipe);
+      /* Move ourselves from the send to recv pipeline */
+      moveHandleFromSendToRecvPipeline(easy->easy_handle, easy->easy_conn);
+      /* Check if we can move pending requests to send pipe */
+      checkPendPipeline(easy->easy_conn);
       multistate(easy, CURLM_STATE_WAITPERFORM);
       result = CURLM_CALL_MULTI_PERFORM;
-
-      Curl_pre_readwrite(easy->easy_conn);
-
       break;
 
     case CURLM_STATE_WAITPERFORM:
 #ifdef CURLDEBUG
       infof(easy->easy_handle, "Conn %d recv pipe %d inuse %d athead %d\n",
             easy->easy_conn->connectindex,
             easy->easy_conn->recv_pipe->size,
             easy->easy_conn->readchannel_inuse,
-            Curl_isHandleAtHead(easy->easy_handle,
-                                easy->easy_conn->recv_pipe));
+            isHandleAtHead(easy->easy_handle,
+                           easy->easy_conn->recv_pipe));
 #endif
       /* Wait for our turn to PERFORM */
-      if (!easy->easy_conn->readchannel_inuse &&
-          Curl_isHandleAtHead(easy->easy_handle,
-                              easy->easy_conn->recv_pipe)) {
+      if(!easy->easy_conn->readchannel_inuse &&
+         isHandleAtHead(easy->easy_handle,
+                        easy->easy_conn->recv_pipe)) {
         /* Grab the channel */
         easy->easy_conn->readchannel_inuse = TRUE;
         multistate(easy, CURLM_STATE_PERFORM);
         result = CURLM_CALL_MULTI_PERFORM;
       }
       break;
 
     case CURLM_STATE_TOOFAST: /* limit-rate exceeded in either direction */
       /* if both rates are within spec, resume transfer */
       Curl_pgrsUpdate(easy->easy_conn);
-      if ( ( ( easy->easy_handle->set.max_send_speed == 0 ) ||
+      if( ( ( easy->easy_handle->set.max_send_speed == 0 ) ||
              ( easy->easy_handle->progress.ulspeed <
                easy->easy_handle->set.max_send_speed ) )  &&
            ( ( easy->easy_handle->set.max_recv_speed == 0 ) ||
              ( easy->easy_handle->progress.dlspeed <
                easy->easy_handle->set.max_recv_speed ) )
         )
       multistate(easy, CURLM_STATE_PERFORM);
       break;
 
     case CURLM_STATE_PERFORM:
       /* check if over speed */
-      if ( (  ( easy->easy_handle->set.max_send_speed > 0 ) &&
+      if( (  ( easy->easy_handle->set.max_send_speed > 0 ) &&
               ( easy->easy_handle->progress.ulspeed >
                 easy->easy_handle->set.max_send_speed ) )  ||
            (  ( easy->easy_handle->set.max_recv_speed > 0 ) &&
               ( easy->easy_handle->progress.dlspeed >
                 easy->easy_handle->set.max_recv_speed ) )
         ) {
@@ -1256,31 +1265,32 @@
         break;
       }
 
       /* read/write data if it is ready to do so */
       easy->result = Curl_readwrite(easy->easy_conn, &done);
 
-      k = &easy->easy_handle->reqdata.keep;
+      k = &easy->easy_handle->req;
 
-      if (!(k->keepon & KEEP_READ)) {
-          /* We're done reading */
-          easy->easy_conn->readchannel_inuse = FALSE;
+      if(!(k->keepon & KEEP_READ)) {
+        /* We're done reading */
+        easy->easy_conn->readchannel_inuse = FALSE;
       }
 
-      if (!(k->keepon & KEEP_WRITE)) {
-          /* We're done writing */
-          easy->easy_conn->writechannel_inuse = FALSE;
+      if(!(k->keepon & KEEP_WRITE)) {
+        /* We're done writing */
+        easy->easy_conn->writechannel_inuse = FALSE;
       }
 
       if(easy->result)  {
         /* The transfer phase returned error, we mark the connection to get
          * closed to prevent being re-used. This is because we can't
          * possibly know if the connection is in a good shape or not now. */
         easy->easy_conn->bits.close = TRUE;
         Curl_removeHandleFromPipeline(easy->easy_handle,
                                       easy->easy_conn->recv_pipe);
+        easy->easy_handle->state.is_in_pipeline = FALSE;
 
         if(CURL_SOCKET_BAD != easy->easy_conn->sock[SECONDARYSOCKET]) {
           /* if we failed anywhere, we must clean up the secondary socket if
              it was used */
           sclose(easy->easy_conn->sock[SECONDARYSOCKET]);
           easy->easy_conn->sock[SECONDARYSOCKET] = CURL_SOCKET_BAD;
@@ -1293,20 +1303,23 @@
         bool retry = Curl_retry_request(easy->easy_conn, &newurl);
 
         /* call this even if the readwrite function returned error */
         Curl_posttransfer(easy->easy_handle);
 
         /* When we follow redirects, must to go back to the CONNECT state */
-        if(easy->easy_handle->reqdata.newurl || retry) {
+        if(easy->easy_handle->req.newurl || retry) {
           Curl_removeHandleFromPipeline(easy->easy_handle,
                                         easy->easy_conn->recv_pipe);
+          /* Check if we can move pending requests to send pipe */
+          checkPendPipeline(easy->easy_conn);
+          easy->easy_handle->state.is_in_pipeline = FALSE;
           if(!retry) {
             /* if the URL is a follow-location and not just a retried request
                then figure out the URL here */
-            newurl = easy->easy_handle->reqdata.newurl;
-            easy->easy_handle->reqdata.newurl = NULL;
+            newurl = easy->easy_handle->req.newurl;
+            easy->easy_handle->req.newurl = NULL;
           }
           easy->result = Curl_done(&easy->easy_conn, CURLE_OK, FALSE);
           if(easy->result == CURLE_OK)
             easy->result = Curl_follow(easy->easy_handle, newurl, retry);
           if(CURLE_OK == easy->result) {
             multistate(easy, CURLM_STATE_CONNECT);
@@ -1327,54 +1340,43 @@
       break;
 
     case CURLM_STATE_DONE:
       /* Remove ourselves from the receive pipeline */
       Curl_removeHandleFromPipeline(easy->easy_handle,
                                     easy->easy_conn->recv_pipe);
+      /* Check if we can move pending requests to send pipe */
+      checkPendPipeline(easy->easy_conn);
       easy->easy_handle->state.is_in_pipeline = FALSE;
 
-      if (easy->easy_conn->bits.stream_was_rewound) {
+      if(easy->easy_conn->bits.stream_was_rewound) {
           /* This request read past its response boundary so we quickly
              let the other requests consume those bytes since there is no
              guarantee that the socket will become active again */
           result = CURLM_CALL_MULTI_PERFORM;
       }
 
-      if (!easy->easy_handle->state.cancelled) {
-        /* post-transfer command */
-        easy->result = Curl_done(&easy->easy_conn, CURLE_OK, FALSE);
+      /* post-transfer command */
+      easy->result = Curl_done(&easy->easy_conn, CURLE_OK, FALSE);
 
-        /* after we have DONE what we're supposed to do, go COMPLETED, and
-           it doesn't matter what the Curl_done() returned! */
-        multistate(easy, CURLM_STATE_COMPLETED);
-      }
+      /* after we have DONE what we're supposed to do, go COMPLETED, and
+         it doesn't matter what the Curl_done() returned! */
+      multistate(easy, CURLM_STATE_COMPLETED);
 
       break;
 
     case CURLM_STATE_COMPLETED:
-      if (easy->easy_handle->state.cancelled)
-        /* Go into the CANCELLED state if we were cancelled */
-        multistate(easy, CURLM_STATE_CANCELLED);
-
       /* this is a completed transfer, it is likely to still be connected */
 
       /* This node should be delinked from the list now and we should post
          an information message that we are complete. */
 
       /* Important: reset the conn pointer so that we don't point to memory
          that could be freed anytime */
       easy->easy_conn = NULL;
       break;
 
-    case CURLM_STATE_CANCELLED:
-      /* Cancelled transfer, wait to be cleaned up */
-
-      /* Reset the conn pointer so we don't leave it dangling */
-      easy->easy_conn = NULL;
-      break;
-
     default:
       return CURLM_INTERNAL_ERROR;
     }
 
     if(CURLM_STATE_COMPLETED != easy->state) {
       if(CURLE_OK != easy->result) {
@@ -1394,30 +1396,32 @@
           easy->easy_conn->writechannel_inuse = FALSE;
           easy->easy_conn->readchannel_inuse = FALSE;
           Curl_removeHandleFromPipeline(easy->easy_handle,
                                         easy->easy_conn->send_pipe);
           Curl_removeHandleFromPipeline(easy->easy_handle,
                                         easy->easy_conn->recv_pipe);
+          /* Check if we can move pending requests to send pipe */
+          checkPendPipeline(easy->easy_conn);
         }
 
-        if (disconnect_conn) {
+        if(disconnect_conn) {
           Curl_disconnect(easy->easy_conn); /* disconnect properly */
 
           /* This is where we make sure that the easy_conn pointer is reset.
              We don't have to do this in every case block above where a
              failure is detected */
           easy->easy_conn = NULL;
         }
 
         multistate(easy, CURLM_STATE_COMPLETED);
       }
     }
 
-  } while (easy->easy_handle->change.url_changed);
+  } while(easy->easy_handle->change.url_changed);
 
-  if ((CURLM_STATE_COMPLETED == easy->state) && !easy->msg) {
+  if((CURLM_STATE_COMPLETED == easy->state) && !easy->msg) {
     if(easy->easy_handle->dns.hostcachetype == HCACHE_MULTI) {
       /* clear out the usage of the shared DNS cache */
       easy->easy_handle->dns.hostcache = NULL;
       easy->easy_handle->dns.hostcachetype = HCACHE_NONE;
     }
 
@@ -1464,21 +1468,12 @@
     return CURLM_BAD_HANDLE;
 
   easy=multi->easy.next;
   while(easy != &multi->easy) {
     CURLMcode result;
 
-    if (easy->easy_handle->state.cancelled &&
-        easy->state == CURLM_STATE_CANCELLED) {
-      /* Remove cancelled handles once it's safe to do so */
-      Curl_multi_rmeasy(multi_handle, easy->easy_handle);
-      easy->easy_handle = NULL;
-      easy = easy->next;
-      continue;
-    }
-
     result = multi_runsingle(multi, easy);
     if(result)
       returncode = result;
 
     easy = easy->next; /* operate on next handle */
   }
@@ -1490,13 +1485,13 @@
    */
   do {
     struct timeval now = Curl_tvnow();
     int key = now.tv_sec; /* drop the usec part */
 
     multi->timetree = Curl_splaygetbest(key, multi->timetree, &t);
-    if (t) {
+    if(t) {
       struct SessionHandle *d = t->payload;
       struct timeval* tv = &d->state.expiretime;
 
       /* clear the expire times within the handles that we remove from the
          splay tree */
       tv->tv_sec = 0;
@@ -1504,13 +1499,13 @@
     }
 
   } while(t);
 
   *running_handles = multi->num_alive;
 
-  if ( CURLM_OK >= returncode )
+  if( CURLM_OK >= returncode )
     update_timer(multi);
   return returncode;
 }
 
 /* This is called when an easy handle is cleanup'ed that is part of a multi
    handle */
@@ -1570,13 +1565,13 @@
 
       /* Clear the pointer to the connection cache */
       easy->easy_handle->state.connc = NULL;
 
       Curl_easy_addmulti(easy->easy_handle, NULL); /* clear the association */
 
-      if (easy->msg)
+      if(easy->msg)
         free(easy->msg);
       free(easy);
       easy = nexteasy;
     }
 
     free(multi);
@@ -1745,13 +1740,13 @@
       easyp = easyp->next;
     }
 
     /* or should we fall-through and do the timer-based stuff? */
     return result;
   }
-  else if (s != CURL_SOCKET_TIMEOUT) {
+  else if(s != CURL_SOCKET_TIMEOUT) {
 
     struct Curl_sh_entry *entry =
       Curl_hash_pick(multi->sockhash, (char *)&s, sizeof(s));
 
     if(!entry)
       /* unmatched socket, major problemo! */
@@ -1760,18 +1755,18 @@
     data = entry->easy;
 
     if(data->magic != CURLEASY_MAGIC_NUMBER)
       /* bad bad bad bad bad bad bad */
       return CURLM_INTERNAL_ERROR;
 
-    if (data->set.one_easy->easy_conn)  /* set socket event bitmask */
+    if(data->set.one_easy->easy_conn)  /* set socket event bitmask */
       data->set.one_easy->easy_conn->cselect_bits = ev_bitmask;
 
     result = multi_runsingle(multi, data->set.one_easy);
 
-    if (data->set.one_easy->easy_conn)
+    if(data->set.one_easy->easy_conn)
       data->set.one_easy->easy_conn->cselect_bits = 0;
 
     if(CURLM_OK >= result)
       /* get the socket(s) and check if the state has been changed since
          last */
       singlesocket(multi, data->set.one_easy);
@@ -1870,33 +1865,33 @@
 
 CURLMcode curl_multi_socket(CURLM *multi_handle, curl_socket_t s,
                             int *running_handles)
 {
   CURLMcode result = multi_socket((struct Curl_multi *)multi_handle, FALSE, s,
                                   0, running_handles);
-  if (CURLM_OK >= result)
+  if(CURLM_OK >= result)
     update_timer((struct Curl_multi *)multi_handle);
   return result;
 }
 
 CURLMcode curl_multi_socket_action(CURLM *multi_handle, curl_socket_t s,
                                      int ev_bitmask, int *running_handles)
 {
   CURLMcode result = multi_socket((struct Curl_multi *)multi_handle, FALSE, s,
                                   ev_bitmask, running_handles);
-  if (CURLM_OK >= result)
+  if(CURLM_OK >= result)
     update_timer((struct Curl_multi *)multi_handle);
   return result;
 }
 
 CURLMcode curl_multi_socket_all(CURLM *multi_handle, int *running_handles)
 
 {
   CURLMcode result = multi_socket((struct Curl_multi *)multi_handle,
                                   TRUE, CURL_SOCKET_BAD, 0, running_handles);
-  if (CURLM_OK >= result)
+  if(CURLM_OK >= result)
     update_timer((struct Curl_multi *)multi_handle);
   return result;
 }
 
 static CURLMcode multi_timeout(struct Curl_multi *multi,
                                long *timeout_ms)
@@ -1937,17 +1932,17 @@
  * Tell the application it should update its timers, if it subscribes to the
  * update timer callback.
  */
 static int update_timer(struct Curl_multi *multi)
 {
   long timeout_ms;
-  if (!multi->timer_cb)
+  if(!multi->timer_cb)
     return 0;
-  if ( multi_timeout(multi, &timeout_ms) != CURLM_OK )
+  if( multi_timeout(multi, &timeout_ms) != CURLM_OK )
     return -1;
-  if ( timeout_ms < 0 )
+  if( timeout_ms < 0 )
     return 0;
 
   /* When multi_timeout() is done, multi->timetree points to the node with the
    * timeout we got the (relative) time-out time for. We can thus easily check
    * if this is the same (fixed) time as we got in a previous call and then
    * avoid calling the callback again. */
@@ -1956,12 +1951,83 @@
 
   multi->timer_lastcall = multi->timetree->key;
 
   return multi->timer_cb((CURLM*)multi, timeout_ms, multi->timer_userp);
 }
 
+static CURLcode addHandleToSendOrPendPipeline(struct SessionHandle *handle,
+                                              struct connectdata *conn)
+{
+  size_t pipeLen = conn->send_pipe->size + conn->recv_pipe->size;
+  struct curl_llist *pipeline;
+
+  if(!Curl_isPipeliningEnabled(handle) ||
+     pipeLen == 0)
+    pipeline = conn->send_pipe;
+  else {
+    if(conn->server_supports_pipelining &&
+       pipeLen < MAX_PIPELINE_LENGTH)
+      pipeline = conn->send_pipe;
+    else
+      pipeline = conn->pend_pipe;
+  }
+
+  return Curl_addHandleToPipeline(handle, pipeline);
+}
+
+static int checkPendPipeline(struct connectdata *conn)
+{
+  int result = 0;
+
+  if (conn->server_supports_pipelining) {
+    size_t pipeLen = conn->send_pipe->size + conn->recv_pipe->size;
+    struct curl_llist_element *curr = conn->pend_pipe->head;
+
+    while(pipeLen < MAX_PIPELINE_LENGTH && curr) {
+      Curl_llist_move(conn->pend_pipe, curr,
+                      conn->send_pipe, conn->send_pipe->tail);
+      Curl_pgrsTime(curr->ptr, TIMER_CONNECT);
+      ++result; /* count how many handles we moved */
+      curr = conn->pend_pipe->head;
+      ++pipeLen;
+    }
+    if (result > 0)
+      conn->now = Curl_tvnow();
+  }
+
+  return result;
+}
+
+static int moveHandleFromSendToRecvPipeline(struct SessionHandle *handle,
+                                            struct connectdata *conn)
+{
+  struct curl_llist_element *curr;
+
+  curr = conn->send_pipe->head;
+  while(curr) {
+    if(curr->ptr == handle) {
+      Curl_llist_move(conn->send_pipe, curr,
+                      conn->recv_pipe, conn->recv_pipe->tail);
+      return 1; /* we moved a handle */
+    }
+    curr = curr->next;
+  }
+
+  return 0;
+}
+
+static bool isHandleAtHead(struct SessionHandle *handle,
+                           struct curl_llist *pipeline)
+{
+  struct curl_llist_element *curr = pipeline->head;
+  if(curr)
+    return (bool)(curr->ptr == handle);
+
+  return FALSE;
+}
+
 /* given a number of milliseconds from now to use to set the 'act before
    this'-time for the transfer, to be extracted by curl_multi_timeout() */
 void Curl_expire(struct SessionHandle *data, long milli)
 {
   struct Curl_multi *multi = data->multi;
   struct timeval *nowp = &data->state.expiretime;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/netrc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/netrc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/netrc.c	2007-04-26 04:13:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/netrc.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: netrc.c,v 1.37 2007-04-25 03:00:10 yangtse Exp $
+ * $Id: netrc.c,v 1.38 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -96,13 +96,13 @@
     /* This is a hack to allow testing.
      * If compiled with --enable-debug and CURL_DEBUG_NETRC is defined,
      * then it's the path to a substitute .netrc for testing purposes *only* */
 
     char *override = curl_getenv("CURL_DEBUG_NETRC");
 
-    if (override) {
+    if(override) {
       fprintf(stderr, "NETRC: overridden " NETRC " file: %s\n", override);
       netrcfile = override;
       netrc_alloc = TRUE;
     }
   }
 #endif /* CURLDEBUG */
@@ -112,13 +112,13 @@
       home_alloc = TRUE;
 #if defined(HAVE_GETPWUID) && defined(HAVE_GETEUID)
     }
     else {
       struct passwd *pw;
       pw= getpwuid(geteuid());
-      if (pw) {
+      if(pw) {
 #ifdef  VMS
         home = decc$translate_vms(pw->pw_dir);
 #else
         home = pw->pw_dir;
 #endif
       }
@@ -145,13 +145,13 @@
     char netrcbuffer[256];
 
     while(!done && fgets(netrcbuffer, sizeof(netrcbuffer), file)) {
       tok=strtok_r(netrcbuffer, " \t\n", &tok_buf);
       while(!done && tok) {
 
-        if (login[0] && password[0]) {
+        if(login[0] && password[0]) {
           done=TRUE;
           break;
         }
 
         switch(state) {
         case NOTHING:
@@ -176,25 +176,25 @@
             /* not our host */
             state=NOTHING;
           break;
         case HOSTVALID:
           /* we are now parsing sub-keywords concerning "our" host */
           if(state_login) {
-            if (specific_login) {
+            if(specific_login) {
               state_our_login = strequal(login, tok);
             }
             else {
               strncpy(login, tok, LOGINSIZE-1);
 #ifdef _NETRC_DEBUG
               fprintf(stderr, "LOGIN: %s\n", login);
 #endif
             }
             state_login=0;
           }
           else if(state_password) {
-            if (state_our_login || !specific_login) {
+            if(state_our_login || !specific_login) {
               strncpy(password, tok, PASSWORDSIZE-1);
 #ifdef _NETRC_DEBUG
               fprintf(stderr, "PASSWORD: %s\n", password);
 #endif
             }
             state_password=0;
@@ -209,13 +209,13 @@
             state_our_login = FALSE;
           }
           break;
         } /* switch (state) */
 
         tok = strtok_r(NULL, " \t\n", &tok_buf);
-      } /* while (tok) */
+      } /* while(tok) */
     } /* while fgets() */
 
     fclose(file);
   }
 
   if(home_alloc)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/nss.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/nss.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/nss.c	2007-10-26 05:14:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/nss.c	2008-01-28 06:41:56.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: nss.c,v 1.13 2007-10-25 21:08:55 bagder Exp $
+ * $Id: nss.c,v 1.15 2008-01-15 23:19:02 bagder Exp $
  ***************************************************************************/
 
 /*
  * Source file for all NSS-specific code for the TLS/SSL layer. No code
  * but sslgen.c should ever call or use these functions.
  */
@@ -280,48 +280,48 @@
       n++;
     if(!mod)
       return 1;
   }
   else {
     /* A nickname from the NSS internal database */
-    if (cacert)
+    if(cacert)
       return 0; /* You can't specify an NSS CA nickname this way */
     nickname = strdup(filename);
     goto done;
   }
 
 #ifdef HAVE_PK11_CREATEGENERICOBJECT
   attrs = theTemplate;
 
   /* All CA and trust objects go into slot 0. Other slots are used
    * for storing certificates. With each new user certificate we increment
    * the slot count. We only support 1 user certificate right now.
    */
-  if (cacert)
+  if(cacert)
     slotID = 0;
   else
     slotID = 1;
 
   slotname = (char *)malloc(SLOTSIZE);
   nickname = (char *)malloc(PATH_MAX);
   snprintf(slotname, SLOTSIZE, "PEM Token #%ld", slotID);
   snprintf(nickname, PATH_MAX, "PEM Token #%ld:%s", slotID, n);
 
   slot = PK11_FindSlotByName(slotname);
 
-  if (!slot) {
+  if(!slot) {
     free(slotname);
     free(nickname);
     return 0;
   }
 
   PK11_SETATTRS(attrs, CKA_CLASS, &objClass, sizeof(objClass) ); attrs++;
   PK11_SETATTRS(attrs, CKA_TOKEN, &cktrue, sizeof(CK_BBOOL) ); attrs++;
   PK11_SETATTRS(attrs, CKA_LABEL, (unsigned char *)filename,
                 strlen(filename)+1); attrs++;
-  if (cacert) {
+  if(cacert) {
     PK11_SETATTRS(attrs, CKA_TRUST, &cktrue, sizeof(CK_BBOOL) ); attrs++;
   }
   else {
     PK11_SETATTRS(attrs, CKA_TRUST, &ckfalse, sizeof(CK_BBOOL) ); attrs++;
   }
 
@@ -345,17 +345,17 @@
 #endif
 
 done:
   /* Double-check that the certificate or nickname requested exists in
    * either the token or the NSS certificate database.
    */
-  if (!cacert) {
+  if(!cacert) {
     cert = PK11_FindCertFromNickname((char *)nickname, NULL);
 
     /* An invalid nickname was passed in */
-    if (cert == NULL) {
+    if(cert == NULL) {
       free(nickname);
       PR_SetError(SEC_ERROR_UNKNOWN_CERT, 0);
       return 0;
     }
 
     CERT_DestroyCertificate(cert);
@@ -433,16 +433,16 @@
 
 static int display_error(struct connectdata *conn, PRInt32 err,
                          const char *filename)
 {
   switch(err) {
   case SEC_ERROR_BAD_PASSWORD:
-    failf(conn->data, "Unable to load client key: Incorrect password\n");
+    failf(conn->data, "Unable to load client key: Incorrect password");
     return 1;
   case SEC_ERROR_UNKNOWN_CERT:
-    failf(conn->data, "Unable to load certificate %s\n", filename);
+    failf(conn->data, "Unable to load certificate %s", filename);
     return 1;
   default:
     break;
   }
   return 0; /* The caller will print a generic error */
 }
@@ -518,25 +518,25 @@
   for(listEntry = PK11_GetFirstSafe(slotList);
       listEntry; listEntry = listEntry->next) {
     PK11SlotInfo *slot = listEntry->slot;
 
     if(PK11_NeedLogin(slot) && PK11_NeedUserInit(slot)) {
       if(slot == PK11_GetInternalKeySlot()) {
-        failf(conn->data, "The NSS database has not been initialized.\n");
+        failf(conn->data, "The NSS database has not been initialized");
       }
       else {
-        failf(conn->data, "The token %s has not been initialized.",
+        failf(conn->data, "The token %s has not been initialized",
               PK11_GetTokenName(slot));
       }
       PK11_FreeSlot(slot);
       continue;
     }
 
     ret = PK11_Authenticate(slot, PR_TRUE, parg);
     if(SECSuccess != ret) {
-      if (PR_GetError() == SEC_ERROR_BAD_PASSWORD)
+      if(PR_GetError() == SEC_ERROR_BAD_PASSWORD)
         infof(conn->data, "The password for token '%s' is incorrect\n",
               PK11_GetTokenName(slot));
       status = SECFailure;
       break;
     }
     parg->retryCount = 0; /* reset counter to 0 for the next token */
@@ -553,52 +553,52 @@
   SECStatus success = SECSuccess;
   struct connectdata *conn = (struct connectdata *)arg;
   PRErrorCode err = PR_GetError();
   CERTCertificate *cert = NULL;
   char *subject, *issuer;
 
-  if (conn->data->set.ssl.certverifyresult!=0)
+  if(conn->data->set.ssl.certverifyresult!=0)
     return success;
 
   conn->data->set.ssl.certverifyresult=err;
   cert = SSL_PeerCertificate(sock);
   subject = CERT_NameToAscii(&cert->subject);
   issuer = CERT_NameToAscii(&cert->issuer);
   CERT_DestroyCertificate(cert);
 
   switch(err) {
   case SEC_ERROR_CA_CERT_INVALID:
     infof(conn->data, "Issuer certificate is invalid: '%s'\n", issuer);
-    if (conn->data->set.ssl.verifypeer)
+    if(conn->data->set.ssl.verifypeer)
       success = SECFailure;
     break;
   case SEC_ERROR_UNTRUSTED_ISSUER:
-    if (conn->data->set.ssl.verifypeer)
+    if(conn->data->set.ssl.verifypeer)
       success = SECFailure;
     infof(conn->data, "Certificate is signed by an untrusted issuer: '%s'\n",
           issuer);
     break;
   case SSL_ERROR_BAD_CERT_DOMAIN:
-    if (conn->data->set.ssl.verifypeer)
+    if(conn->data->set.ssl.verifypeer)
       success = SECFailure;
     infof(conn->data, "common name: %s (does not match '%s')\n",
           subject, conn->host.dispname);
     break;
   case SEC_ERROR_EXPIRED_CERTIFICATE:
-    if (conn->data->set.ssl.verifypeer)
+    if(conn->data->set.ssl.verifypeer)
       success = SECFailure;
     infof(conn->data, "Remote Certificate has expired.\n");
     break;
   default:
-    if (conn->data->set.ssl.verifypeer)
+    if(conn->data->set.ssl.verifypeer)
       success = SECFailure;
     infof(conn->data, "Bad certificate received. Subject = '%s', "
           "Issuer = '%s'\n", subject, issuer);
     break;
   }
-  if (success == SECSuccess)
+  if(success == SECSuccess)
     infof(conn->data, "SSL certificate verify ok.\n");
   PR_Free(subject);
   PR_Free(issuer);
 
   return success;
 }
@@ -620,16 +620,16 @@
   CERTCertificate *cert;
   char *subject, *issuer, *common_name;
   PRExplodedTime printableTime;
   char timeString[256];
   PRTime notBefore, notAfter;
 
-  if (SSL_GetChannelInfo(sock, &channel, sizeof channel) ==
+  if(SSL_GetChannelInfo(sock, &channel, sizeof channel) ==
     SECSuccess && channel.length == sizeof channel &&
     channel.cipherSuite) {
-    if (SSL_GetCipherSuiteInfo(channel.cipherSuite,
+    if(SSL_GetCipherSuiteInfo(channel.cipherSuite,
       &suite, sizeof suite) == SECSuccess) {
       infof(conn->data, "SSL connection using %s\n", suite.cipherSuiteName);
     }
   }
 
   infof(conn->data, "Server certificate:\n");
@@ -675,13 +675,13 @@
   SECStatus secStatus = SECFailure;
   PK11SlotInfo *slot;
   (void)caNames;
 
   proto_win = SSL_RevealPinArg(sock);
 
-  if (!nickname)
+  if(!nickname)
     return secStatus;
 
   cert = PK11_FindCertFromNickname(nickname, proto_win);
   if(cert) {
 
     if(!strncmp(nickname, "PEM Token", 9)) {
@@ -705,13 +705,13 @@
 
   if(secStatus == SECSuccess) {
     *pRetCert = cert;
     *pRetKey = privKey;
   }
   else {
-    if (cert)
+    if(cert)
       CERT_DestroyCertificate(cert);
   }
 
   return secStatus;
 }
 
@@ -811,17 +811,17 @@
   /* FIXME. NSS doesn't support multiple databases open at the same time. */
   if(!initialized) {
     initialized = 1;
 
     certDir = getenv("SSL_DIR"); /* Look in $SSL_DIR */
 
-    if (!certDir) {
+    if(!certDir) {
       struct stat st;
 
-      if (stat(SSL_DIR, &st) == 0)
-        if (S_ISDIR(st.st_mode)) {
+      if(stat(SSL_DIR, &st) == 0)
+        if(S_ISDIR(st.st_mode)) {
           certDir = (char *)SSL_DIR;
         }
     }
 
     if(!certDir) {
       rv = NSS_NoDB_Init(NULL);
@@ -842,14 +842,14 @@
     configstring = (char *)malloc(PATH_MAX);
 
     PR_snprintf(configstring, PATH_MAX, "library=%s name=PEM", pem_library);
 
     mod = SECMOD_LoadUserModule(configstring, NULL, PR_FALSE);
     free(configstring);
-    if (!mod || !mod->loaded) {
-      if (mod) {
+    if(!mod || !mod->loaded) {
+      if(mod) {
         SECMOD_DestroyModule(mod);
         mod = NULL;
       }
       infof(data, "WARNING: failed to load NSS PEM library %s. Using OpenSSL "
             "PEM certificates will not work.\n", pem_library);
     }
@@ -909,47 +909,47 @@
                            NULL) != SECSuccess)
     goto error;
 
   if(!data->set.ssl.verifypeer)
     /* skip the verifying of the peer */
     ;
-  else if (data->set.ssl.CAfile) {
+  else if(data->set.ssl.CAfile) {
     int rc = nss_load_cert(data->set.ssl.CAfile, PR_TRUE);
-    if (!rc) {
+    if(!rc) {
       curlerr = CURLE_SSL_CACERT_BADFILE;
       goto error;
     }
   }
-  else if (data->set.ssl.CApath) {
+  else if(data->set.ssl.CApath) {
     struct stat st;
     PRDir      *dir;
     PRDirEntry *entry;
 
-    if (stat(data->set.ssl.CApath, &st) == -1) {
+    if(stat(data->set.ssl.CApath, &st) == -1) {
       curlerr = CURLE_SSL_CACERT_BADFILE;
       goto error;
     }
 
-    if (S_ISDIR(st.st_mode)) {
+    if(S_ISDIR(st.st_mode)) {
       int rc;
 
       dir = PR_OpenDir(data->set.ssl.CApath);
       do {
         entry = PR_ReadDir(dir, PR_SKIP_BOTH | PR_SKIP_HIDDEN);
 
-        if (entry) {
+        if(entry) {
           char fullpath[PATH_MAX];
 
           snprintf(fullpath, sizeof(fullpath), "%s/%s", data->set.ssl.CApath,
                    entry->name);
           rc = nss_load_cert(fullpath, PR_TRUE);
           /* FIXME: check this return value! */
         }
       /* This is purposefully tolerant of errors so non-PEM files
        * can be in the same directory */
-      } while (entry != NULL);
+      } while(entry != NULL);
       PR_CloseDir(dir);
     }
   }
   infof(data,
         "  CAfile: %s\n"
         "  CApath: %s\n",
@@ -960,25 +960,25 @@
     char *n;
     char *nickname;
 
     nickname = (char *)malloc(PATH_MAX);
     if(is_file(data->set.str[STRING_CERT])) {
       n = strrchr(data->set.str[STRING_CERT], '/');
-      if (n) {
+      if(n) {
         n++; /* skip last slash */
         snprintf(nickname, PATH_MAX, "PEM Token #%ld:%s", 1, n);
       }
     }
     else {
       strncpy(nickname, data->set.str[STRING_CERT], PATH_MAX);
     }
     if(nss_Init_Tokens(conn) != SECSuccess) {
       free(nickname);
       goto error;
     }
-    if (!cert_stuff(conn, data->set.str[STRING_CERT],
+    if(!cert_stuff(conn, data->set.str[STRING_CERT],
                     data->set.str[STRING_KEY])) {
       /* failf() is already done in cert_stuff() */
       free(nickname);
       return CURLE_SSL_CERTPROBLEM;
     }
 
@@ -1008,16 +1008,16 @@
   /* Force handshake on next I/O */
   SSL_ResetHandshake(connssl->handle, /* asServer */ PR_FALSE);
 
   SSL_SetURL(connssl->handle, conn->host.name);
 
   /* Force the handshake now */
-  if (SSL_ForceHandshakeWithTimeout(connssl->handle,
+  if(SSL_ForceHandshakeWithTimeout(connssl->handle,
                                     PR_SecondsToInterval(HANDSHAKE_TIMEOUT))
       != SECSuccess) {
-    if (conn->data->set.ssl.certverifyresult!=0)
+    if(conn->data->set.ssl.certverifyresult!=0)
       curlerr = CURLE_SSL_CACERT;
     goto error;
   }
 
   display_conn_info(conn, connssl->handle);
 
@@ -1054,13 +1054,13 @@
 
     if(err == PR_IO_TIMEOUT_ERROR) {
       failf(data, "SSL connection timeout");
       return CURLE_OPERATION_TIMEDOUT;
     }
 
-    failf(conn->data, "SSL write: error %d\n", err);
+    failf(conn->data, "SSL write: error %d", err);
     return -1;
   }
   return rc; /* number of bytes */
 }
 
 /*
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/nwlib.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/nwlib.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/nwlib.c	2007-07-12 05:52:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/nwlib.c	2008-01-24 06:20:22.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: nwlib.c,v 1.8 2007-07-11 21:47:31 gknauf Exp $
+ * $Id: nwlib.c,v 1.11 2008-01-23 02:12:13 gknauf Exp $
  ***************************************************************************/
 
 #ifdef NETWARE /* Novell NetWare */
 
 #include <stdlib.h>
 
@@ -32,14 +32,12 @@
 #include <library.h>
 #include <netware.h>
 #include <screen.h>
 #include <nks/thread.h>
 #include <nks/synch.h>
 
-#include "memory.h"
-#include "memdebug.h"
 
 typedef struct
 {
   int     _errno;
   void    *twentybytes;
 } libthreaddata_t;
@@ -79,13 +77,13 @@
                   size_t      customDataOffset,
                   size_t      customDataSize,
                   int         messageCount,
                   const char  **messages )
 {
   NX_LOCK_INFO_ALLOC(liblock, "Per-Application Data Lock", 0);
-  
+
 #ifndef __GNUC__
 #pragma unused(cmdLine)
 #pragma unused(loadDirPath)
 #pragma unused(uninitializedDataLength)
 #pragma unused(NLMFileHandle)
 #pragma unused(readRoutineP)
@@ -102,30 +100,30 @@
 ** Loader will leave us up, otherwise we fail to load and get dumped.
 */
   gAllocTag = AllocateResourceTag(NLMHandle,
                                   "<library-name> memory allocations",
                                   AllocSignature);
 
-  if (!gAllocTag) {
+  if(!gAllocTag) {
     OutputToScreen(errorScreen, "Unable to allocate resource tag for "
                    "library memory allocations.\n");
     return -1;
   }
 
   gLibId = register_library(DisposeLibraryData);
 
-  if (gLibId < -1) {
+  if(gLibId < -1) {
     OutputToScreen(errorScreen, "Unable to register library with kernel.\n");
     return -1;
   }
 
   gLibHandle = NLMHandle;
 
   gLibLock = NXMutexAlloc(0, 0, &liblock);
-  
-  if (!gLibLock) {
+
+  if(!gLibLock) {
     OutputToScreen(errorScreen, "Unable to allocate library data lock.\n");
     return -1;
   }
 
   return 0;
 }
@@ -172,150 +170,150 @@
 ** Attempt to get our data for the application calling us. This is where we
 ** store whatever application-specific information we need to carry in support
 ** of calling applications.
 */
   app_data = (libdata_t *) get_app_data(id);
 
-  if (!app_data) {
+  if(!app_data) {
 /*
 ** This application hasn't called us before; set up application AND per-thread
 ** data. Of course, just in case a thread from this same application is calling
 ** us simultaneously, we better lock our application data-creation mutex. We
 ** also need to recheck for data after we acquire the lock because WE might be
 ** that other thread that was too late to create the data and the first thread
 ** in will have created it.
 */
     NXLock(gLibLock);
 
-    if (!(app_data = (libdata_t *) get_app_data(id))) {
+    if(!(app_data = (libdata_t *) get_app_data(id))) {
       app_data = (libdata_t *) malloc(sizeof(libdata_t));
 
-      if (app_data) {
+      if(app_data) {
         memset(app_data, 0, sizeof(libdata_t));
-        
+
         app_data->tenbytes = malloc(10);
         app_data->lock     = NXMutexAlloc(0, 0, &liblock);
-        
-        if (!app_data->tenbytes || !app_data->lock) {
-          if (app_data->lock)
+
+        if(!app_data->tenbytes || !app_data->lock) {
+          if(app_data->lock)
             NXMutexFree(app_data->lock);
-          
+
           free(app_data);
           app_data = (libdata_t *) NULL;
           err      = ENOMEM;
         }
-        
-        if (app_data) {
+
+        if(app_data) {
 /*
 ** Here we burn in the application data that we were trying to get by calling
 ** get_app_data(). Next time we call the first function, we'll get this data
 ** we're just now setting. We also go on here to establish the per-thread data
 ** for the calling thread, something we'll have to do on each application
 ** thread the first time it calls us.
 */
           err = set_app_data(gLibId, app_data);
-          
-          if (err) {
+
+          if(err) {
             free(app_data);
             app_data = (libdata_t *) NULL;
             err      = ENOMEM;
           }
           else {
             /* create key for thread-specific data... */
             err = NXKeyCreate(DisposeThreadData, (void *) NULL, &key);
-            
-            if (err)                /* (no more keys left?) */
+
+            if(err)                /* (no more keys left?) */
               key = -1;
-            
+
             app_data->perthreadkey = key;
           }
         }
       }
     }
-    
+
     NXUnlock(gLibLock);
   }
 
-  if (app_data) {
+  if(app_data) {
     key = app_data->perthreadkey;
-    
-    if (key != -1 /* couldn't create a key? no thread data */
+
+    if(key != -1 /* couldn't create a key? no thread data */
         && !(err = NXKeyGetValue(key, (void **) &thread_data))
         && !thread_data) {
 /*
 ** Allocate the per-thread data for the calling thread. Regardless of whether
 ** there was already application data or not, this may be the first call by a
 ** a new thread. The fact that we allocation 20 bytes on a pointer is not very
 ** important, this just helps to demonstrate that we can have arbitrarily
 ** complex per-thread data.
 */
       thread_data = (libthreaddata_t *) malloc(sizeof(libthreaddata_t));
-      
-      if (thread_data) {
+
+      if(thread_data) {
         thread_data->_errno      = 0;
         thread_data->twentybytes = malloc(20);
-          
-        if (!thread_data->twentybytes) {
+
+        if(!thread_data->twentybytes) {
           free(thread_data);
           thread_data = (libthreaddata_t *) NULL;
           err         = ENOMEM;
         }
-        
-        if ((err = NXKeySetValue(key, thread_data))) {
+
+        if((err = NXKeySetValue(key, thread_data))) {
           free(thread_data->twentybytes);
           free(thread_data);
           thread_data = (libthreaddata_t *) NULL;
         }
       }
     }
   }
 
-  if (appData)
+  if(appData)
     *appData = app_data;
 
-  if (threadData)
+  if(threadData)
     *threadData = thread_data;
 
   return err;
 }
 
 int DisposeLibraryData( void *data )
 {
-  if (data) {
+  if(data) {
     void *tenbytes = ((libdata_t *) data)->tenbytes;
-    
-    if (tenbytes)
+
+    if(tenbytes)
       free(tenbytes);
-    
+
     free(data);
   }
 
   return 0;
 }
 
 void DisposeThreadData( void *data )
 {
-  if (data) {
+  if(data) {
     void *twentybytes = ((libthreaddata_t *) data)->twentybytes;
-    
-    if (twentybytes)
+
+    if(twentybytes)
       free(twentybytes);
-    
+
     free(data);
   }
 }
 
 #else /* __NOVELL_LIBC__ */
 /* For native CLib-based NLM seems we can do a bit more simple. */
 #include <nwthread.h>
 
 int main ( void )
 {
     /* initialize any globals here... */
 
-    /* do this if any global initializing was done 
+    /* do this if any global initializing was done
     SynchronizeStart();
     */
     ExitThread (TSR_THREAD, 0);
     return 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/nwos.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/nwos.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/nwos.c	2007-08-10 22:22:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/nwos.c	2007-11-07 17:21:35.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: nwos.c,v 1.3 2007-08-09 22:33:49 gknauf Exp $
+ * $Id: nwos.c,v 1.4 2007-11-07 09:21:35 bagder Exp $
  ***************************************************************************/
 
 #ifdef NETWARE /* Novell NetWare */
 
 #include <stdlib.h>
 
@@ -54,23 +54,23 @@
     /* import UnAugmentAsterisk dynamically for NW4.x compatibility */
     void (*pUnAugmentAsterisk)(int) = (void(*)(int))
             ImportSymbol(myHandle, "UnAugmentAsterisk");
     /* import UseAccurateCaseForPaths dynamically for NW3.x compatibility */
     void (*pUseAccurateCaseForPaths)(int) = (void(*)(int))
             ImportSymbol(myHandle, "UseAccurateCaseForPaths");
-    if (pUnAugmentAsterisk)
+    if(pUnAugmentAsterisk)
         pUnAugmentAsterisk(1);
-    if (pUseAccurateCaseForPaths)
+    if(pUseAccurateCaseForPaths)
         pUseAccurateCaseForPaths(1);
     UnimportSymbol(myHandle, "UnAugmentAsterisk");
     UnimportSymbol(myHandle, "UseAccurateCaseForPaths");
     /* set long name space */
-    if ((SetCurrentNameSpace(4) == 255)) {
+    if((SetCurrentNameSpace(4) == 255)) {
         rc = 1;
     }
-    if ((SetTargetNameSpace(4) == 255)) {
+    if((SetTargetNameSpace(4) == 255)) {
         rc = rc + 2;
     }
     return rc;
 }
 
 /* dummy function to satisfy newer prelude */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/parsedate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/parsedate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/parsedate.c	2006-12-05 22:57:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/parsedate.c	2008-01-06 18:50:57.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: parsedate.c,v 1.23 2006-12-05 14:57:43 bagder Exp $
+ * $Id: parsedate.c,v 1.27 2008-01-06 10:50:57 bagder Exp $
  ***************************************************************************/
 /*
   A brief summary of the date string formats this parser groks:
 
   RFC 2616 3.3.1
 
@@ -81,13 +81,13 @@
 #ifdef HAVE_STDLIB_H
 #include <stdlib.h> /* for strtol() */
 #endif
 
 #include <curl/curl.h>
 
-static time_t Curl_parsedate(const char *date);
+static time_t parsedate(const char *date);
 
 const char * const Curl_wkday[] =
 {"Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"};
 static const char * const weekday[] =
 { "Monday", "Tuesday", "Wednesday", "Thursday",
   "Friday", "Saturday", "Sunday" };
@@ -151,13 +151,13 @@
 
 /* returns:
    -1 no day
    0 monday - 6 sunday
 */
 
-static int checkday(char *check, size_t len)
+static int checkday(const char *check, size_t len)
 {
   int i;
   const char * const *what;
   bool found= FALSE;
   if(len > 3)
     what = &weekday[0];
@@ -170,13 +170,13 @@
     }
     what++;
   }
   return found?i:-1;
 }
 
-static int checkmonth(char *check)
+static int checkmonth(const char *check)
 {
   int i;
   const char * const *what;
   bool found= FALSE;
 
   what = &Curl_month[0];
@@ -190,13 +190,13 @@
   return found?i:-1; /* return the offset or -1, no real offset is -1 */
 }
 
 /* return the time zone offset between GMT and the input one, in number
    of seconds or -1 if the timezone wasn't found/legal */
 
-static int checktz(char *check)
+static int checktz(const char *check)
 {
   unsigned int i;
   const struct tzinfo *what;
   bool found= FALSE;
 
   what = tz;
@@ -220,13 +220,13 @@
 enum assume {
   DATE_MDAY,
   DATE_YEAR,
   DATE_TIME
 };
 
-static time_t Curl_parsedate(const char *date)
+static time_t parsedate(const char *date)
 {
   time_t t = 0;
   int wdaynum=-1;  /* day of the week number, 0-6 (mon-sun) */
   int monnum=-1;   /* month of the year number, 0-11 */
   int mdaynum=-1; /* day of month, 1 - 31 */
   int hournum=-1;
@@ -286,17 +286,23 @@
       }
       else {
         val = (int)strtol(date, &end, 10);
 
         if((tzoff == -1) &&
            ((end - date) == 4) &&
-           (val < 1300) &&
+           (val <= 1400) &&
            (indate< date) &&
            ((date[-1] == '+' || date[-1] == '-'))) {
-          /* four digits and a value less than 1300 and it is preceeded with
-             a plus or minus. This is a time zone indication. */
+          /* four digits and a value less than or equal to 1400 (to take into
+             account all sorts of funny time zone diffs) and it is preceeded
+             with a plus or minus. This is a time zone indication.  1400 is
+             picked since +1300 is frequently used and +1400 is mentioned as
+             an edge number in the document "ISO C 200X Proposal: Timezone
+             Functions" at http://david.tribble.com/text/c0xtimezone.html If
+             anyone has a more authoritative source for the exact maximum time
+             zone offsets, please speak up! */
           found = TRUE;
           tzoff = (val/100 * 60 + val%100)*60;
 
           /* the + and - prefix indicates the local time compared to GMT,
              this we need ther reversed math to get what we want */
           tzoff = date[-1]=='+'?-tzoff:tzoff;
@@ -322,13 +328,13 @@
         }
 
         if(!found && (dignext == DATE_YEAR) && (yearnum == -1)) {
           yearnum = val;
           found = TRUE;
           if(yearnum < 1900) {
-            if (yearnum > 70)
+            if(yearnum > 70)
               yearnum += 1900;
             else
               yearnum += 2000;
           }
           if(mdaynum == -1)
             dignext = DATE_MDAY;
@@ -418,8 +424,8 @@
   return t;
 }
 
 time_t curl_getdate(const char *p, const time_t *now)
 {
   (void)now;
-  return Curl_parsedate(p);
+  return parsedate(p);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/progress.c	2007-04-19 04:02:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/progress.c	2007-11-25 07:16:55.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: progress.c,v 1.84 2007-04-18 20:02:41 bagder Exp $
+ * $Id: progress.c,v 1.85 2007-11-24 23:16:55 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <time.h>
@@ -353,17 +353,16 @@
       return 0;
 
     /* If there's no external callback set, use internal code to show
        progress */
 
     if(!(data->progress.flags & PGRS_HEADERS_OUT)) {
-      if(data->reqdata.resume_from) {
+      if(data->state.resume_from) {
         fprintf(data->set.err,
-                "** Resuming transfer from byte position %" FORMAT_OFF_T
-                "\n",
-                data->reqdata.resume_from);
+                "** Resuming transfer from byte position %" FORMAT_OFF_T "\n",
+                data->state.resume_from);
       }
       fprintf(data->set.err,
               "  %% Total    %% Received %% Xferd  Average Speed   Time    Time     Time  Current\n"
               "                                 Dload  Upload   Total   Spent    Left  Speed\n");
       data->progress.flags |= PGRS_HEADERS_OUT; /* headers are shown */
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/qssl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/qssl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/qssl.c	2007-10-03 16:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/qssl.c	2008-01-28 06:41:56.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: qssl.c,v 1.5 2007-10-03 08:07:50 bagder Exp $
+ * $Id: qssl.c,v 1.7 2008-01-15 23:19:02 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifdef USE_QSOSSL
 #include <qsossl.h>
@@ -77,27 +77,27 @@
    *  keyring in certificate file.
    * We first try to SSL_Init_Application(), then SSL_Init() if it failed.
    */
 
   certname = data->set.str[STRING_CERT];
 
-  if (!certname) {
+  if(!certname) {
     certname = data->set.str[STRING_SSL_CAFILE];
 
-    if (!certname)
+    if(!certname)
       return CURLE_OK;          /* Use previous setup. */
     }
 
   memset((char *) &initappstr, 0, sizeof initappstr);
   initappstr.applicationID = certname;
   initappstr.applicationIDLen = strlen(certname);
   initappstr.protocol = SSL_VERSION_CURRENT;
   initappstr.sessionType = SSL_REGISTERED_AS_CLIENT;
   rc = SSL_Init_Application(&initappstr);
 
-  if (rc == SSL_ERROR_NOT_REGISTERED) {
+  if(rc == SSL_ERROR_NOT_REGISTERED) {
     initstr.keyringFileName = certname;
     initstr.keyringPassword = data->set.str[STRING_KEY];
     initstr.cipherSuiteList = NULL;    /* Use default. */
     initstr.cipherSuiteListLen = 0;
     rc = SSL_Init(&initstr);
     }
@@ -105,13 +105,13 @@
   switch (rc) {
 
   case 0:                             /* No error. */
     break;
 
   case SSL_ERROR_IO:
-    failf(data, "SSL_Init() I/O error: %s\n", strerror(errno));
+    failf(data, "SSL_Init() I/O error: %s", strerror(errno));
     return CURLE_SSL_CONNECT_ERROR;
 
   case SSL_ERROR_BAD_CIPHER_SUITE:
     return CURLE_SSL_CIPHER;
 
   case SSL_ERROR_KEYPASSWORD_EXPIRED:
@@ -122,13 +122,13 @@
     return CURLE_SSL_CACERT;
 
   case SSL_ERROR_CERT_EXPIRED:
     return CURLE_SSL_CERTPROBLEM;
 
   default:
-    failf(data, "SSL_Init(): %s\n", SSL_Strerror(rc, NULL));
+    failf(data, "SSL_Init(): %s", SSL_Strerror(rc, NULL));
     return CURLE_SSL_CONNECT_ERROR;
   }
 
   return CURLE_OK;
 }
 
@@ -138,16 +138,16 @@
 {
   SSLHandle * h;
   struct ssl_connect_data * connssl = &conn->ssl[sockindex];
 
   h = SSL_Create(conn->sock[sockindex], SSL_ENCRYPT);
 
-  if (!h) {
-    failf(conn->data, "SSL_Create() I/O error: %s\n", strerror(errno));
+  if(!h) {
+    failf(conn->data, "SSL_Create() I/O error: %s", strerror(errno));
     return CURLE_SSL_CONNECT_ERROR;
-    }
+  }
 
   connssl->handle = h;
   return CURLE_OK;
 }
 
 
@@ -166,23 +166,23 @@
   struct ssl_connect_data * connssl = &conn->ssl[sockindex];
   SSLHandle * h = connssl->handle;
   long timeout_ms;
 
   h->exitPgm = NULL;
 
-  if (!data->set.ssl.verifyhost)
+  if(!data->set.ssl.verifyhost)
     h->exitPgm = Curl_qsossl_trap_cert;
 
-  if (data->set.connecttimeout) {
+  if(data->set.connecttimeout) {
     timeout_ms = data->set.connecttimeout;
 
-    if (data->set.timeout)
-      if (timeout_ms > data->set.timeout)
+    if(data->set.timeout)
+      if(timeout_ms > data->set.timeout)
         timeout_ms = data->set.timeout;
     }
-  else if (data->set.timeout)
+  else if(data->set.timeout)
     timeout_ms = data->set.timeout;
   else
     timeout_ms = DEFAULT_CONNECT_TIMEOUT;
 
   /* SSL_Handshake() timeout resolution is second, so round up. */
 
@@ -229,17 +229,17 @@
   case SSL_ERROR_CERTIFICATE_REJECTED:
   case SSL_ERROR_CERT_EXPIRED:
   case SSL_ERROR_NO_CERTIFICATE:
     return CURLE_SSL_CERTPROBLEM;
 
   case SSL_ERROR_IO:
-    failf(data, "SSL_Handshake(): %s\n", SSL_Strerror(rc, NULL));
+    failf(data, "SSL_Handshake(): %s", SSL_Strerror(rc, NULL));
     return CURLE_SSL_CONNECT_ERROR;
 
   default:
-    failf(data, "SSL_Init(): %s\n", SSL_Strerror(rc, NULL));
+    failf(data, "SSL_Init(): %s", SSL_Strerror(rc, NULL));
     return CURLE_SSL_CONNECT_ERROR;
   }
 
   return CURLE_OK;
 }
 
@@ -250,16 +250,16 @@
   struct SessionHandle * data = conn->data;
   struct ssl_connect_data * connssl = &conn->ssl[sockindex];
   int rc;
 
   rc = Curl_qsossl_init_session(data);
 
-  if (rc == CURLE_OK) {
+  if(rc == CURLE_OK) {
     rc = Curl_qsossl_create(conn, sockindex);
 
-    if (rc == CURLE_OK)
+    if(rc == CURLE_OK)
       rc = Curl_qsossl_handshake(conn, sockindex);
     else {
       SSL_Destroy(connssl->handle);
       connssl->handle = NULL;
       connssl->use = FALSE;
     }
@@ -278,19 +278,19 @@
   if(!conn->handle)
     return 0;
 
   rc = SSL_Destroy(conn->handle);
 
   if(rc) {
-    if (rc == SSL_ERROR_IO) {
-      failf(data, "SSL_Destroy() I/O error: %s\n", strerror(errno));
+    if(rc == SSL_ERROR_IO) {
+      failf(data, "SSL_Destroy() I/O error: %s", strerror(errno));
       return -1;
     }
 
     /* An SSL error. */
-    failf(data, "SSL_Destroy() returned error %d\n", SSL_Strerror(rc, NULL));
+    failf(data, "SSL_Destroy() returned error %d", SSL_Strerror(rc, NULL));
     return -1;
   }
 
   conn->handle = NULL;
   return 0;
 }
@@ -323,50 +323,50 @@
   struct SessionHandle *data = conn->data;
   ssize_t nread;
   int what;
   int rc;
   char buf[120];
 
-  if (!connssl->handle)
+  if(!connssl->handle)
     return 0;
 
-  if (data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)
+  if(data->set.ftp_ccc != CURLFTPSSL_CCC_ACTIVE)
     return 0;
 
-  if (Curl_qsossl_close_one(connssl, data))
+  if(Curl_qsossl_close_one(connssl, data))
     return -1;
 
   rc = 0;
 
   what = Curl_socket_ready(conn->sock[sockindex],
                            CURL_SOCKET_BAD, SSL_SHUTDOWN_TIMEOUT);
 
   for (;;) {
-    if (what < 0) {
+    if(what < 0) {
       /* anything that gets here is fatally bad */
       failf(data, "select/poll on SSL socket, errno: %d", SOCKERRNO);
       rc = -1;
       break;
     }
 
-    if (!what) {                                /* timeout */
+    if(!what) {                                /* timeout */
       failf(data, "SSL shutdown timeout");
       break;
     }
 
     /* Something to read, let's do it and hope that it is the close
        notify alert from the server. No way to SSL_Read now, so use read(). */
 
     nread = read(conn->sock[sockindex], buf, sizeof(buf));
 
-    if (nread < 0) {
-      failf(data, "read: %s\n", strerror(errno));
+    if(nread < 0) {
+      failf(data, "read: %s", strerror(errno));
       rc = -1;
     }
 
-    if (nread <= 0)
+    if(nread <= 0)
       break;
 
     what = Curl_socket_ready(conn->sock[sockindex], CURL_SOCKET_BAD, 0);
   }
 
   return rc;
@@ -396,18 +396,18 @@
       switch (errno) {
       case EWOULDBLOCK:
       case EINTR:
         return 0;
         }
 
-      failf(conn->data, "SSL_Write() I/O error: %s\n", strerror(errno));
+      failf(conn->data, "SSL_Write() I/O error: %s", strerror(errno));
       return -1;
     }
 
     /* An SSL error. */
-    failf(conn->data, "SSL_Write() returned error %d\n",
+    failf(conn->data, "SSL_Write() returned error %d",
           SSL_Strerror(rc, NULL));
     return -1;
   }
 
   return (ssize_t) rc; /* number of bytes */
 }
@@ -439,17 +439,17 @@
       switch (errno) {
       case EWOULDBLOCK:
 	*wouldblock = TRUE;
         return -1;
         }
 
-      failf(conn->data, "SSL_Read() I/O error: %s\n", strerror(errno));
+      failf(conn->data, "SSL_Read() I/O error: %s", strerror(errno));
       return -1;
 
     default:
-      failf(conn->data, "SSL read error: %s\n", SSL_Strerror(nread, NULL));
+      failf(conn->data, "SSL read error: %s", SSL_Strerror(nread, NULL));
       return -1;
     }
   }
   return (ssize_t) nread;
 }
 
@@ -467,19 +467,19 @@
 {
   int err;
   int errlen;
 
   /* The only thing that can be tested here is at the socket level. */
 
-  if (!cxn->ssl[FIRSTSOCKET].handle)
+  if(!cxn->ssl[FIRSTSOCKET].handle)
     return 0; /* connection has been closed */
 
   err = 0;
   errlen = sizeof err;
 
-  if (getsockopt(cxn->sock[FIRSTSOCKET], SOL_SOCKET, SO_ERROR,
+  if(getsockopt(cxn->sock[FIRSTSOCKET], SOL_SOCKET, SO_ERROR,
                  (unsigned char *) &err, &errlen) ||
       errlen != sizeof err || err)
     return 0; /* connection has been closed */
 
   return -1;  /* connection status unknown */
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/security.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/security.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/security.c	2007-07-07 06:13:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/security.c	2007-11-07 17:12:26.000000000 +0800
@@ -6,12 +6,15 @@
  * it not use globals, pollute name space and more. This source code awaits a
  * rewrite to work around the paragraph 2 in the BSD licenses as explained
  * below.
  *
  * Copyright (c) 1998, 1999 Kungliga Tekniska Hgskolan
  * (Royal Institute of Technology, Stockholm, Sweden).
+ *
+ * Copyright (C) 2001 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  *
@@ -64,19 +67,19 @@
 /* The last #include file should be: */
 #include "memdebug.h"
 
 #define min(a, b)   ((a) < (b) ? (a) : (b))
 
 static const struct {
-    enum protection_level level;
-    const char *name;
+  enum protection_level level;
+  const char *name;
 } level_names[] = {
-    { prot_clear, "clear" },
-    { prot_safe, "safe" },
-    { prot_confidential, "confidential" },
-    { prot_private, "private" }
+  { prot_clear, "clear" },
+  { prot_safe, "safe" },
+  { prot_confidential, "confidential" },
+  { prot_private, "private" }
 };
 
 static enum protection_level
 name_to_level(const char *name)
 {
   int i;
@@ -85,18 +88,18 @@
       return level_names[i].level;
   return (enum protection_level)-1;
 }
 
 static const struct Curl_sec_client_mech * const mechs[] = {
 #ifdef HAVE_GSSAPI
-    &Curl_krb5_client_mech,
+  &Curl_krb5_client_mech,
 #endif
 #ifdef HAVE_KRB4
-    &Curl_krb4_client_mech,
+  &Curl_krb4_client_mech,
 #endif
-    NULL
+  NULL
 };
 
 int
 Curl_sec_getc(struct connectdata *conn, FILE *F)
 {
   if(conn->sec_complete && conn->data_prot) {
@@ -113,17 +116,17 @@
 block_read(int fd, void *buf, size_t len)
 {
   unsigned char *p = buf;
   int b;
   while(len) {
     b = read(fd, p, len);
-    if (b == 0)
+    if(b == 0)
       return 0;
-    else if (b < 0 && (errno == EINTR || errno == EAGAIN))
+    else if(b < 0 && (errno == EINTR || errno == EAGAIN))
       continue;
-    else if (b < 0)
+    else if(b < 0)
       return -1;
     len -= b;
     p += b;
   }
   return p - (unsigned char*)buf;
 }
@@ -132,13 +135,13 @@
 block_write(int fd, const void *buf, size_t len)
 {
   const unsigned char *p = buf;
   int b;
   while(len) {
     b = write(fd, p, len);
-    if (b < 0 && (errno == EINTR || errno == EAGAIN))
+    if(b < 0 && (errno == EINTR || errno == EAGAIN))
       continue;
     else if(b < 0)
       return -1;
     len -= b;
     p += b;
   }
@@ -150,90 +153,90 @@
              int fd, struct krb4buffer *buf)
 {
   int len;
   int b;
 
   b = block_read(fd, &len, sizeof(len));
-  if (b == 0)
+  if(b == 0)
     return 0;
-  else if (b < 0)
+  else if(b < 0)
     return -1;
   len = ntohl(len);
   buf->data = realloc(buf->data, len);
   b = buf->data ? block_read(fd, buf->data, len) : -1;
-  if (b == 0)
+  if(b == 0)
     return 0;
-  else if (b < 0)
+  else if(b < 0)
     return -1;
   buf->size = (conn->mech->decode)(conn->app_data, buf->data, len,
                                    conn->data_prot, conn);
   buf->index = 0;
   return 0;
 }
 
 static size_t
 buffer_read(struct krb4buffer *buf, void *data, size_t len)
 {
-    len = min(len, buf->size - buf->index);
-    memcpy(data, (char*)buf->data + buf->index, len);
-    buf->index += len;
-    return len;
+  len = min(len, buf->size - buf->index);
+  memcpy(data, (char*)buf->data + buf->index, len);
+  buf->index += len;
+  return len;
 }
 
 static size_t
 buffer_write(struct krb4buffer *buf, void *data, size_t len)
 {
-    if(buf->index + len > buf->size) {
-        void *tmp;
-        if(buf->data == NULL)
-            tmp = malloc(1024);
-        else
-            tmp = realloc(buf->data, buf->index + len);
-        if(tmp == NULL)
-            return -1;
-        buf->data = tmp;
-        buf->size = buf->index + len;
-    }
-    memcpy((char*)buf->data + buf->index, data, len);
-    buf->index += len;
-    return len;
+  if(buf->index + len > buf->size) {
+    void *tmp;
+    if(buf->data == NULL)
+      tmp = malloc(1024);
+    else
+      tmp = realloc(buf->data, buf->index + len);
+    if(tmp == NULL)
+      return -1;
+    buf->data = tmp;
+    buf->size = buf->index + len;
+  }
+  memcpy((char*)buf->data + buf->index, data, len);
+  buf->index += len;
+  return len;
 }
 
 int
 Curl_sec_read(struct connectdata *conn, int fd, void *buffer, int length)
 {
-    size_t len;
-    int rx = 0;
+  size_t len;
+  int rx = 0;
 
-    if(conn->sec_complete == 0 || conn->data_prot == 0)
-      return read(fd, buffer, length);
+  if(conn->sec_complete == 0 || conn->data_prot == 0)
+    return read(fd, buffer, length);
 
-    if(conn->in_buffer.eof_flag){
-      conn->in_buffer.eof_flag = 0;
-      return 0;
-    }
+  if(conn->in_buffer.eof_flag){
+    conn->in_buffer.eof_flag = 0;
+    return 0;
+  }
+
+  len = buffer_read(&conn->in_buffer, buffer, length);
+  length -= len;
+  rx += len;
+  buffer = (char*)buffer + len;
 
+  while(length) {
+    if(sec_get_data(conn, fd, &conn->in_buffer) < 0)
+      return -1;
+    if(conn->in_buffer.size == 0) {
+      if(rx)
+        conn->in_buffer.eof_flag = 1;
+      return rx;
+    }
     len = buffer_read(&conn->in_buffer, buffer, length);
     length -= len;
     rx += len;
     buffer = (char*)buffer + len;
-
-    while(length) {
-      if(sec_get_data(conn, fd, &conn->in_buffer) < 0)
-        return -1;
-      if(conn->in_buffer.size == 0) {
-        if(rx)
-          conn->in_buffer.eof_flag = 1;
-        return rx;
-      }
-      len = buffer_read(&conn->in_buffer, buffer, length);
-      length -= len;
-      rx += len;
-      buffer = (char*)buffer + len;
-    }
-    return rx;
+  }
+  return rx;
 }
 
 static int
 sec_send(struct connectdata *conn, int fd, char *from, int length)
 {
   int bytes;
@@ -257,16 +260,18 @@
       if(protlevel == prot_private)
 	block_write(fd, "ENC ", 4);
       else
 	block_write(fd, "MIC ", 4);
       block_write(fd, cmdbuf, bytes);
       block_write(fd, "\r\n", 2);
-      Curl_infof(conn->data, "%s %s\n", protlevel == prot_private ? "ENC" : "MIC", cmdbuf);
+      Curl_infof(conn->data, "%s %s\n",
+                 protlevel == prot_private ? "ENC" : "MIC", cmdbuf);
       free(cmdbuf);
     }
-  } else {
+  }
+  else {
     bytes = htonl(bytes);
     block_write(fd, &bytes, sizeof(bytes));
     block_write(fd, buf, ntohl(bytes));
   }
   free(buf);
   return length;
@@ -275,13 +280,13 @@
 int
 Curl_sec_fflush_fd(struct connectdata *conn, int fd)
 {
   if(conn->data_prot != prot_clear) {
     if(conn->out_buffer.index > 0){
       Curl_sec_write(conn, fd,
-                conn->out_buffer.data, conn->out_buffer.index);
+                     conn->out_buffer.data, conn->out_buffer.index);
       conn->out_buffer.index = 0;
     }
     sec_send(conn, fd, NULL, 0);
   }
   return 0;
 }
@@ -454,13 +459,13 @@
   int ftpcode;
 
   for(m = mechs; *m && (*m)->name; m++) {
     void *tmp;
 
     tmp = realloc(conn->app_data, (*m)->size);
-    if (tmp == NULL) {
+    if(tmp == NULL) {
       failf (data, "realloc %u failed", (*m)->size);
       return -1;
     }
     conn->app_data = tmp;
 
     if((*m)->init && (*(*m)->init)(conn->app_data) != 0) {
@@ -515,13 +520,13 @@
   return *m == NULL;
 }
 
 void
 Curl_sec_end(struct connectdata *conn)
 {
-  if (conn->mech != NULL) {
+  if(conn->mech != NULL) {
     if(conn->mech->end)
       (conn->mech->end)(conn->app_data);
     memset(conn->app_data, 0, conn->mech->size);
     free(conn->app_data);
     conn->app_data = NULL;
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/select.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/select.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/select.c	2007-10-04 04:25:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/select.c	2007-11-05 17:45:09.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: select.c,v 1.48 2007-10-03 16:58:10 yangtse Exp $
+ * $Id: select.c,v 1.49 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifdef HAVE_SYS_SELECT_H
 #include <sys/select.h>
@@ -49,13 +49,13 @@
 #include "connect.h"
 #include "select.h"
 
 /* Winsock and TPF sockets are not in range [0..FD_SETSIZE-1] */
 
 #if defined(USE_WINSOCK) || defined(TPF)
-#define VERIFY_SOCK(x) do { } while (0)
+#define VERIFY_SOCK(x) do { } while(0)
 #else
 #define VALID_SOCK(s) (((s) >= 0) && ((s) < FD_SETSIZE))
 #define VERIFY_SOCK(x) do { \
   if(!VALID_SOCK(x)) { \
     SET_SOCKERRNO(EINVAL); \
     return -1; \
@@ -102,15 +102,15 @@
   struct timeval initial_tv;
   int pending_ms;
   int error;
 #endif
   int r = 0;
 
-  if (!timeout_ms)
+  if(!timeout_ms)
     return 0;
-  if (timeout_ms < 0) {
+  if(timeout_ms < 0) {
     SET_SOCKERRNO(EINVAL);
     return -1;
   }
 #if defined(MSDOS)
   delay(timeout_ms);
 #elif defined(USE_WINSOCK)
@@ -123,23 +123,23 @@
     r = poll(NULL, 0, pending_ms);
 #else
     pending_tv.tv_sec = pending_ms / 1000;
     pending_tv.tv_usec = (pending_ms % 1000) * 1000;
     r = select(0, NULL, NULL, NULL, &pending_tv);
 #endif /* HAVE_POLL_FINE */
-    if (r != -1)
+    if(r != -1)
       break;
     error = SOCKERRNO;
-    if ((error == EINVAL) || error_is_EINTR)
+    if((error == EINVAL) || error_is_EINTR)
       break;
     pending_ms = timeout_ms - elapsed_ms;
-    if (pending_ms <= 0)
+    if(pending_ms <= 0)
       break;
-  } while (r == -1);
+  } while(r == -1);
 #endif /* USE_WINSOCK */
-  if (r)
+  if(r)
     r = -1;
   return r;
 }
 
 /*
  * This is an internal function used for waiting for read or write
@@ -186,136 +186,136 @@
 
   /* Avoid initial timestamp, avoid gettimeofday() call, when elapsed
      time in this function does not need to be measured. This happens
      when function is called with a zero timeout or a negative timeout
      value indicating a blocking call should be performed. */
 
-  if (timeout_ms > 0) {
+  if(timeout_ms > 0) {
     pending_ms = timeout_ms;
     initial_tv = curlx_tvnow();
   }
 
 #ifdef HAVE_POLL_FINE
 
   num = 0;
-  if (readfd != CURL_SOCKET_BAD) {
+  if(readfd != CURL_SOCKET_BAD) {
     pfd[num].fd = readfd;
     pfd[num].events = POLLRDNORM|POLLIN|POLLRDBAND|POLLPRI;
     pfd[num].revents = 0;
     num++;
   }
-  if (writefd != CURL_SOCKET_BAD) {
+  if(writefd != CURL_SOCKET_BAD) {
     pfd[num].fd = writefd;
     pfd[num].events = POLLWRNORM|POLLOUT;
     pfd[num].revents = 0;
     num++;
   }
 
   do {
-    if (timeout_ms < 0)
+    if(timeout_ms < 0)
       pending_ms = -1;
-    else if (!timeout_ms)
+    else if(!timeout_ms)
       pending_ms = 0;
     r = poll(pfd, num, pending_ms);
-    if (r != -1)
+    if(r != -1)
       break;
     error = SOCKERRNO;
-    if ((error == EINVAL) || error_is_EINTR)
+    if((error == EINVAL) || error_is_EINTR)
       break;
-    if (timeout_ms > 0) {
+    if(timeout_ms > 0) {
       pending_ms = timeout_ms - elapsed_ms;
-      if (pending_ms <= 0)
+      if(pending_ms <= 0)
         break;
     }
-  } while (r == -1);
+  } while(r == -1);
 
-  if (r < 0)
+  if(r < 0)
     return -1;
-  if (r == 0)
+  if(r == 0)
     return 0;
 
   ret = 0;
   num = 0;
-  if (readfd != CURL_SOCKET_BAD) {
-    if (pfd[num].revents & (POLLRDNORM|POLLIN|POLLERR|POLLHUP))
+  if(readfd != CURL_SOCKET_BAD) {
+    if(pfd[num].revents & (POLLRDNORM|POLLIN|POLLERR|POLLHUP))
       ret |= CURL_CSELECT_IN;
-    if (pfd[num].revents & (POLLRDBAND|POLLPRI|POLLNVAL))
+    if(pfd[num].revents & (POLLRDBAND|POLLPRI|POLLNVAL))
       ret |= CURL_CSELECT_ERR;
     num++;
   }
-  if (writefd != CURL_SOCKET_BAD) {
-    if (pfd[num].revents & (POLLWRNORM|POLLOUT))
+  if(writefd != CURL_SOCKET_BAD) {
+    if(pfd[num].revents & (POLLWRNORM|POLLOUT))
       ret |= CURL_CSELECT_OUT;
-    if (pfd[num].revents & (POLLERR|POLLHUP|POLLNVAL))
+    if(pfd[num].revents & (POLLERR|POLLHUP|POLLNVAL))
       ret |= CURL_CSELECT_ERR;
   }
 
   return ret;
 
 #else  /* HAVE_POLL_FINE */
 
   FD_ZERO(&fds_err);
   maxfd = (curl_socket_t)-1;
 
   FD_ZERO(&fds_read);
-  if (readfd != CURL_SOCKET_BAD) {
+  if(readfd != CURL_SOCKET_BAD) {
     VERIFY_SOCK(readfd);
     FD_SET(readfd, &fds_read);
     FD_SET(readfd, &fds_err);
     maxfd = readfd;
   }
 
   FD_ZERO(&fds_write);
-  if (writefd != CURL_SOCKET_BAD) {
+  if(writefd != CURL_SOCKET_BAD) {
     VERIFY_SOCK(writefd);
     FD_SET(writefd, &fds_write);
     FD_SET(writefd, &fds_err);
-    if (writefd > maxfd)
+    if(writefd > maxfd)
       maxfd = writefd;
   }
 
   ptimeout = (timeout_ms < 0) ? NULL : &pending_tv;
 
   do {
-    if (timeout_ms > 0) {
+    if(timeout_ms > 0) {
       pending_tv.tv_sec = pending_ms / 1000;
       pending_tv.tv_usec = (pending_ms % 1000) * 1000;
     }
-    else if (!timeout_ms) {
+    else if(!timeout_ms) {
       pending_tv.tv_sec = 0;
       pending_tv.tv_usec = 0;
     }
     r = select((int)maxfd + 1, &fds_read, &fds_write, &fds_err, ptimeout);
-    if (r != -1)
+    if(r != -1)
       break;
     error = SOCKERRNO;
-    if ((error == EINVAL) || (error == EBADF) || error_is_EINTR)
+    if((error == EINVAL) || (error == EBADF) || error_is_EINTR)
       break;
-    if (timeout_ms > 0) {
+    if(timeout_ms > 0) {
       pending_ms = timeout_ms - elapsed_ms;
-      if (pending_ms <= 0)
+      if(pending_ms <= 0)
         break;
     }
-  } while (r == -1);
+  } while(r == -1);
 
-  if (r < 0)
+  if(r < 0)
     return -1;
-  if (r == 0)
+  if(r == 0)
     return 0;
 
   ret = 0;
-  if (readfd != CURL_SOCKET_BAD) {
-    if (FD_ISSET(readfd, &fds_read))
+  if(readfd != CURL_SOCKET_BAD) {
+    if(FD_ISSET(readfd, &fds_read))
       ret |= CURL_CSELECT_IN;
-    if (FD_ISSET(readfd, &fds_err))
+    if(FD_ISSET(readfd, &fds_err))
       ret |= CURL_CSELECT_ERR;
   }
-  if (writefd != CURL_SOCKET_BAD) {
-    if (FD_ISSET(writefd, &fds_write))
+  if(writefd != CURL_SOCKET_BAD) {
+    if(FD_ISSET(writefd, &fds_write))
       ret |= CURL_CSELECT_OUT;
-    if (FD_ISSET(writefd, &fds_err))
+    if(FD_ISSET(writefd, &fds_err))
       ret |= CURL_CSELECT_ERR;
   }
 
   return ret;
 
 #endif  /* HAVE_POLL_FINE */
@@ -352,121 +352,121 @@
   bool fds_none = TRUE;
   unsigned int i;
   int pending_ms = 0;
   int error;
   int r;
 
-  if (ufds) {
+  if(ufds) {
     for (i = 0; i < nfds; i++) {
-      if (ufds[i].fd != CURL_SOCKET_BAD) {
+      if(ufds[i].fd != CURL_SOCKET_BAD) {
         fds_none = FALSE;
         break;
       }
     }
   }
-  if (fds_none) {
+  if(fds_none) {
     r = wait_ms(timeout_ms);
     return r;
   }
 
   /* Avoid initial timestamp, avoid gettimeofday() call, when elapsed
      time in this function does not need to be measured. This happens
      when function is called with a zero timeout or a negative timeout
      value indicating a blocking call should be performed. */
 
-  if (timeout_ms > 0) {
+  if(timeout_ms > 0) {
     pending_ms = timeout_ms;
     initial_tv = curlx_tvnow();
   }
 
 #ifdef HAVE_POLL_FINE
 
   do {
-    if (timeout_ms < 0)
+    if(timeout_ms < 0)
       pending_ms = -1;
-    else if (!timeout_ms)
+    else if(!timeout_ms)
       pending_ms = 0;
     r = poll(ufds, nfds, pending_ms);
-    if (r != -1)
+    if(r != -1)
       break;
     error = SOCKERRNO;
-    if ((error == EINVAL) || error_is_EINTR)
+    if((error == EINVAL) || error_is_EINTR)
       break;
-    if (timeout_ms > 0) {
+    if(timeout_ms > 0) {
       pending_ms = timeout_ms - elapsed_ms;
-      if (pending_ms <= 0)
+      if(pending_ms <= 0)
         break;
     }
-  } while (r == -1);
+  } while(r == -1);
 
 #else  /* HAVE_POLL_FINE */
 
   FD_ZERO(&fds_read);
   FD_ZERO(&fds_write);
   FD_ZERO(&fds_err);
   maxfd = (curl_socket_t)-1;
 
   for (i = 0; i < nfds; i++) {
     ufds[i].revents = 0;
-    if (ufds[i].fd == CURL_SOCKET_BAD)
+    if(ufds[i].fd == CURL_SOCKET_BAD)
       continue;
     VERIFY_SOCK(ufds[i].fd);
-    if (ufds[i].events & (POLLIN|POLLOUT|POLLPRI|
+    if(ufds[i].events & (POLLIN|POLLOUT|POLLPRI|
                           POLLRDNORM|POLLWRNORM|POLLRDBAND)) {
-      if (ufds[i].fd > maxfd)
+      if(ufds[i].fd > maxfd)
         maxfd = ufds[i].fd;
-      if (ufds[i].events & (POLLRDNORM|POLLIN))
+      if(ufds[i].events & (POLLRDNORM|POLLIN))
         FD_SET(ufds[i].fd, &fds_read);
-      if (ufds[i].events & (POLLWRNORM|POLLOUT))
+      if(ufds[i].events & (POLLWRNORM|POLLOUT))
         FD_SET(ufds[i].fd, &fds_write);
-      if (ufds[i].events & (POLLRDBAND|POLLPRI))
+      if(ufds[i].events & (POLLRDBAND|POLLPRI))
         FD_SET(ufds[i].fd, &fds_err);
     }
   }
 
   ptimeout = (timeout_ms < 0) ? NULL : &pending_tv;
 
   do {
-    if (timeout_ms > 0) {
+    if(timeout_ms > 0) {
       pending_tv.tv_sec = pending_ms / 1000;
       pending_tv.tv_usec = (pending_ms % 1000) * 1000;
     }
-    else if (!timeout_ms) {
+    else if(!timeout_ms) {
       pending_tv.tv_sec = 0;
       pending_tv.tv_usec = 0;
     }
     r = select((int)maxfd + 1, &fds_read, &fds_write, &fds_err, ptimeout);
-    if (r != -1)
+    if(r != -1)
       break;
     error = SOCKERRNO;
-    if ((error == EINVAL) || (error == EBADF) || error_is_EINTR)
+    if((error == EINVAL) || (error == EBADF) || error_is_EINTR)
       break;
-    if (timeout_ms > 0) {
+    if(timeout_ms > 0) {
       pending_ms = timeout_ms - elapsed_ms;
-      if (pending_ms <= 0)
+      if(pending_ms <= 0)
         break;
     }
-  } while (r == -1);
+  } while(r == -1);
 
-  if (r < 0)
+  if(r < 0)
     return -1;
-  if (r == 0)
+  if(r == 0)
     return 0;
 
   r = 0;
   for (i = 0; i < nfds; i++) {
     ufds[i].revents = 0;
-    if (ufds[i].fd == CURL_SOCKET_BAD)
+    if(ufds[i].fd == CURL_SOCKET_BAD)
       continue;
-    if (FD_ISSET(ufds[i].fd, &fds_read))
+    if(FD_ISSET(ufds[i].fd, &fds_read))
       ufds[i].revents |= POLLIN;
-    if (FD_ISSET(ufds[i].fd, &fds_write))
+    if(FD_ISSET(ufds[i].fd, &fds_write))
       ufds[i].revents |= POLLOUT;
-    if (FD_ISSET(ufds[i].fd, &fds_err))
+    if(FD_ISSET(ufds[i].fd, &fds_err))
       ufds[i].revents |= POLLPRI;
-    if (ufds[i].revents != 0)
+    if(ufds[i].revents != 0)
       r++;
   }
 
 #endif  /* HAVE_POLL_FINE */
 
   return r;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/select.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/select.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/select.h	2007-06-14 19:21:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/select.h	2008-01-24 06:20:22.000000000 +0800
@@ -4,32 +4,34 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: select.h,v 1.13 2007-06-14 11:21:48 bagder Exp $
+ * $Id: select.h,v 1.15 2008-01-22 14:52:54 yangtse Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
+#elif defined(HAVE_POLL_H)
+#include <poll.h>
 #endif
 
 /*
  * poll() function on Windows Vista and later is called WSAPoll()
  */
 
@@ -37,19 +39,24 @@
     defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0600)
 #undef  HAVE_POLL
 #define HAVE_POLL 1
 #undef  HAVE_POLL_FINE
 #define HAVE_POLL_FINE 1
 #define poll(x,y,z) WSAPoll((x),(y),(z))
+#if defined(_MSC_VER) && defined(POLLRDNORM)
+#define HAVE_STRUCT_POLLFD 1
+#endif
 #endif
 
 /*
  * Definition of pollfd struct and constants for platforms lacking them.
  */
 
-#ifndef HAVE_SYS_POLL_H
+#if !defined(HAVE_STRUCT_POLLFD) && \
+    !defined(HAVE_SYS_POLL_H) && \
+    !defined(HAVE_POLL_H)
 
 #define POLLIN      0x01
 #define POLLPRI     0x02
 #define POLLOUT     0x04
 #define POLLERR     0x08
 #define POLLHUP     0x10
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/sendf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/sendf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/sendf.c	2007-09-27 19:38:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/sendf.c	2008-01-28 19:56:13.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.c,v 1.132 2007-09-27 01:45:23 danf Exp $
+ * $Id: sendf.c,v 1.140 2008-01-28 11:56:13 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -64,18 +64,18 @@
 /* returns last node in linked list */
 static struct curl_slist *slist_get_last(struct curl_slist *list)
 {
   struct curl_slist     *item;
 
   /* if caller passed us a NULL, return now */
-  if (!list)
+  if(!list)
     return NULL;
 
   /* loop through to find the last item */
   item = list;
-  while (item->next) {
+  while(item->next) {
     item = item->next;
   }
   return item;
 }
 
 /*
@@ -89,13 +89,13 @@
                                      const char *data)
 {
   struct curl_slist     *last;
   struct curl_slist     *new_item;
 
   new_item = (struct curl_slist *) malloc(sizeof(struct curl_slist));
-  if (new_item) {
+  if(new_item) {
     char *dupdata = strdup(data);
     if(dupdata) {
       new_item->next = NULL;
       new_item->data = dupdata;
     }
     else {
@@ -103,13 +103,13 @@
       return NULL;
     }
   }
   else
     return NULL;
 
-  if (list) {
+  if(list) {
     last = slist_get_last(list);
     last->next = new_item;
     return list;
   }
 
   /* if this is the first item, then new_item *is* the list */
@@ -119,25 +119,25 @@
 /* be nice and clean up resources */
 void curl_slist_free_all(struct curl_slist *list)
 {
   struct curl_slist     *next;
   struct curl_slist     *item;
 
-  if (!list)
+  if(!list)
     return;
 
   item = list;
   do {
     next = item->next;
 
-    if (item->data) {
+    if(item->data) {
       free(item->data);
     }
     free(item);
     item = next;
-  } while (next);
+  } while(next);
 }
 
 #ifdef CURL_DO_LINEEND_CONV
 /*
  * convert_lineends() changes CRLF (\r\n) end-of-line markers to a single LF
  * (\n), with special processing for CRLF sequences that are split between two
@@ -147,73 +147,73 @@
 static size_t convert_lineends(struct SessionHandle *data,
                                char *startPtr, size_t size)
 {
   char *inPtr, *outPtr;
 
   /* sanity check */
-  if ((startPtr == NULL) || (size < 1)) {
+  if((startPtr == NULL) || (size < 1)) {
     return(size);
   }
 
-  if (data->state.prev_block_had_trailing_cr == TRUE) {
+  if(data->state.prev_block_had_trailing_cr == TRUE) {
     /* The previous block of incoming data
        had a trailing CR, which was turned into a LF. */
-    if (*startPtr == '\n') {
+    if(*startPtr == '\n') {
       /* This block of incoming data starts with the
          previous block's LF so get rid of it */
-      memcpy(startPtr, startPtr+1, size-1);
+      memmove(startPtr, startPtr+1, size-1);
       size--;
       /* and it wasn't a bare CR but a CRLF conversion instead */
       data->state.crlf_conversions++;
     }
     data->state.prev_block_had_trailing_cr = FALSE; /* reset the flag */
   }
 
   /* find 1st CR, if any */
   inPtr = outPtr = memchr(startPtr, '\r', size);
-  if (inPtr) {
+  if(inPtr) {
     /* at least one CR, now look for CRLF */
-    while (inPtr < (startPtr+size-1)) {
+    while(inPtr < (startPtr+size-1)) {
       /* note that it's size-1, so we'll never look past the last byte */
-      if (memcmp(inPtr, "\r\n", 2) == 0) {
+      if(memcmp(inPtr, "\r\n", 2) == 0) {
         /* CRLF found, bump past the CR and copy the NL */
         inPtr++;
         *outPtr = *inPtr;
         /* keep track of how many CRLFs we converted */
         data->state.crlf_conversions++;
       }
       else {
-        if (*inPtr == '\r') {
+        if(*inPtr == '\r') {
           /* lone CR, move LF instead */
           *outPtr = '\n';
         }
         else {
           /* not a CRLF nor a CR, just copy whatever it is */
           *outPtr = *inPtr;
         }
       }
       outPtr++;
       inPtr++;
     } /* end of while loop */
 
-    if (inPtr < startPtr+size) {
+    if(inPtr < startPtr+size) {
       /* handle last byte */
-      if (*inPtr == '\r') {
+      if(*inPtr == '\r') {
         /* deal with a CR at the end of the buffer */
         *outPtr = '\n'; /* copy a NL instead */
         /* note that a CRLF might be split across two blocks */
         data->state.prev_block_had_trailing_cr = TRUE;
       }
       else {
         /* copy last byte */
         *outPtr = *inPtr;
       }
       outPtr++;
       inPtr++;
     }
-    if (outPtr < startPtr+size) {
+    if(outPtr < startPtr+size) {
       /* tidy up by null terminating the now shorter data */
       *outPtr = '\0';
     }
     return(outPtr - startPtr);
   }
   return(size);
@@ -282,13 +282,13 @@
     return CURLE_OUT_OF_MEMORY; /* failure */
 
   bytes_written=0;
   write_len = strlen(s);
   sptr = s;
 
-  while (1) {
+  while(1) {
     /* Write the buffer to the socket */
     res = Curl_write(conn, sockfd, sptr, write_len, &bytes_written);
 
     if(CURLE_OK != res)
       break;
 
@@ -307,16 +307,16 @@
 
   free(s); /* free the output string */
 
   return res;
 }
 
-static ssize_t Curl_plain_send(struct connectdata *conn,
-                               int num,
-                               void *mem,
-                               size_t len)
+static ssize_t send_plain(struct connectdata *conn,
+                          int num,
+                          void *mem,
+                          size_t len)
 {
   curl_socket_t sockfd = conn->sock[num];
   ssize_t bytes_written = swrite(sockfd, mem, len);
 
   if(-1 == bytes_written) {
     int err = SOCKERRNO;
@@ -352,33 +352,63 @@
                     ssize_t *written)
 {
   ssize_t bytes_written;
   CURLcode retcode;
   int num = (sockfd == conn->sock[SECONDARYSOCKET]);
 
-  if (conn->ssl[num].use)
+  if(conn->ssl[num].use)
     /* only TRUE if SSL enabled */
     bytes_written = Curl_ssl_send(conn, num, mem, len);
 #ifdef USE_LIBSSH2
-  else if (conn->protocol & PROT_SCP)
+  else if(conn->protocol & PROT_SCP)
     bytes_written = Curl_scp_send(conn, num, mem, len);
-  else if (conn->protocol & PROT_SFTP)
+  else if(conn->protocol & PROT_SFTP)
     bytes_written = Curl_sftp_send(conn, num, mem, len);
 #endif /* !USE_LIBSSH2 */
   else if(conn->sec_complete)
     /* only TRUE if krb enabled */
     bytes_written = Curl_sec_send(conn, num, mem, len);
   else
-    bytes_written = Curl_plain_send(conn, num, mem, len);
+    bytes_written = send_plain(conn, num, mem, len);
 
   *written = bytes_written;
   retcode = (-1 != bytes_written)?CURLE_OK:CURLE_SEND_ERROR;
 
   return retcode;
 }
 
+static CURLcode pausewrite(struct SessionHandle *data,
+                           int type, /* what type of data */
+                           char *ptr,
+                           size_t len)
+{
+  /* signalled to pause sending on this connection, but since we have data
+     we want to send we need to dup it to save a copy for when the sending
+     is again enabled */
+  struct SingleRequest *k = &data->req;
+  char *dupl = malloc(len);
+  if(!dupl)
+    return CURLE_OUT_OF_MEMORY;
+
+  memcpy(dupl, ptr, len);
+
+  /* store this information in the state struct for later use */
+  data->state.tempwrite = dupl;
+  data->state.tempwritesize = len;
+  data->state.tempwritetype = type;
+
+  /* mark the connection as RECV paused */
+  k->keepon |= KEEP_READ_PAUSE;
+
+  DEBUGF(infof(data, "Pausing with %d bytes in buffer for type %02x\n",
+               (int)len, type));
+
+  return CURLE_OK;
+}
+
+
 /* client_write() sends data to the write callback(s)
 
    The bit pattern defines to what "streams" to write to. Body and/or header.
    The defines are in sendf.h of course.
  */
 CURLcode Curl_client_write(struct connectdata *conn,
@@ -386,15 +416,39 @@
                            char *ptr,
                            size_t len)
 {
   struct SessionHandle *data = conn->data;
   size_t wrote;
 
-  if (data->state.cancelled) {
-      /* We just suck everything into a black hole */
-      return CURLE_OK;
+  /* If reading is actually paused, we're forced to append this chunk of data
+     to the already held data, but only if it is the same type as otherwise it
+     can't work and it'll return error instead. */
+  if(data->req.keepon & KEEP_READ_PAUSE) {
+    size_t newlen;
+    char *newptr;
+    if(type != data->state.tempwritetype)
+      /* major internal confusion */
+      return CURLE_RECV_ERROR;
+
+    /* figure out the new size of the data to save */
+    newlen = len + data->state.tempwritesize;
+    /* allocate the new memory area */
+    newptr = malloc(newlen);
+    if(!newptr)
+      return CURLE_OUT_OF_MEMORY;
+    /* copy the previously held data to the new area */
+    memcpy(newptr, data->state.tempwrite, data->state.tempwritesize);
+    /* copy the new data to the end of the new area */
+    memcpy(newptr + data->state.tempwritesize, ptr, len);
+    /* free the old data */
+    free(data->state.tempwrite);
+    /* update the pointer and the size */
+    data->state.tempwrite = newptr;
+    data->state.tempwritesize = newlen;
+
+    return CURLE_OK;
   }
 
   if(0 == len)
     len = strlen(ptr);
 
   if(type & CLIENTWRITE_BODY) {
@@ -412,21 +466,24 @@
       /* convert end-of-line markers */
       len = convert_lineends(data, ptr, len);
 #endif /* CURL_DO_LINEEND_CONV */
     }
     /* If the previous block of data ended with CR and this block of data is
        just a NL, then the length might be zero */
-    if (len) {
+    if(len) {
       wrote = data->set.fwrite_func(ptr, 1, len, data->set.out);
     }
     else {
       wrote = len;
     }
 
+    if(CURL_WRITEFUNC_PAUSE == wrote)
+      return pausewrite(data, type, ptr, len);
+
     if(wrote != len) {
-      failf (data, "Failed writing body");
+      failf(data, "Failed writing body (%d != %d)", (int)wrote, (int)len);
       return CURLE_WRITE_ERROR;
     }
   }
 
   if((type & CLIENTWRITE_HEADER) &&
      (data->set.fwrite_header || data->set.writeheader) ) {
@@ -438,12 +495,18 @@
       data->set.fwrite_header?data->set.fwrite_header:data->set.fwrite_func;
 
     /* Note: The header is in the host encoding
        regardless of the ftp transfer mode (ASCII/Image) */
 
     wrote = writeit(ptr, 1, len, data->set.writeheader);
+    if(CURL_WRITEFUNC_PAUSE == wrote)
+      /* here we pass in the HEADER bit only since if this was body as well
+         then it was passed already and clearly that didn't trigger the pause,
+         so this is saved for later with the HEADER bit only */
+      return pausewrite(data, CLIENTWRITE_HEADER, ptr, len);
+
     if(wrote != len) {
       failf (data, "Failed writing header");
       return CURLE_WRITE_ERROR;
     }
   }
 
@@ -482,13 +545,13 @@
 
   /* If session can pipeline, check connection buffer  */
   if(pipelining) {
     size_t bytestocopy = MIN(conn->buf_len - conn->read_pos, sizerequested);
 
     /* Copy from our master buffer first if we have some unread data there*/
-    if (bytestocopy > 0) {
+    if(bytestocopy > 0) {
       memcpy(buf, conn->master_buffer + conn->read_pos, bytestocopy);
       conn->read_pos += bytestocopy;
       conn->bits.stream_was_rewound = FALSE;
 
       *n = (ssize_t)bytestocopy;
       return CURLE_OK;
@@ -509,16 +572,16 @@
 
     if(nread == -1) {
       return -1; /* -1 from Curl_ssl_recv() means EWOULDBLOCK */
     }
   }
 #ifdef USE_LIBSSH2
-  else if (conn->protocol & (PROT_SCP|PROT_SFTP)) {
+  else if(conn->protocol & (PROT_SCP|PROT_SFTP)) {
     if(conn->protocol & PROT_SCP)
       nread = Curl_scp_recv(conn, num, buffertofill, bytesfromsocket);
-    else if (conn->protocol & PROT_SFTP)
+    else if(conn->protocol & PROT_SFTP)
       nread = Curl_sftp_recv(conn, num, buffertofill, bytesfromsocket);
 #ifdef LIBSSH2CHANNEL_EAGAIN
     if((nread == LIBSSH2CHANNEL_EAGAIN) || (nread == 0))
       /* EWOULDBLOCK */
       return -1;
 #endif
@@ -542,13 +605,13 @@
       if((EWOULDBLOCK == err) || (EAGAIN == err) || (EINTR == err))
 #endif
         return -1;
     }
   }
 
-  if (nread >= 0) {
+  if(nread >= 0) {
     if(pipelining) {
       memcpy(buf, conn->master_buffer, nread);
       conn->buf_len = nread;
       conn->read_pos = nread;
     }
 
@@ -570,13 +633,13 @@
   size_t conv_size = 0;
 
   switch(type) {
   case CURLINFO_HEADER_OUT:
     /* assume output headers are ASCII */
     /* copy the data into my buffer so the original is unchanged */
-    if (size > BUFSIZE) {
+    if(size > BUFSIZE) {
       size = BUFSIZE; /* truncate if necessary */
       buf[BUFSIZE] = '\0';
     }
     conv_size = size;
     memcpy(buf, ptr, size);
     /* Special processing is needed for this block if it
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/sendf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/sendf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/sendf.h	2007-03-28 05:14:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/sendf.h	2007-10-30 06:03:51.000000000 +0800
@@ -17,13 +17,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.h,v 1.40 2007-03-27 04:17:26 yangtse Exp $
+ * $Id: sendf.h,v 1.42 2007-10-29 20:57:03 danf Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 CURLcode Curl_sendf(curl_socket_t sockfd, struct connectdata *,
                     const char *fmt, ...);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/setup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/setup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/setup.h	2007-08-23 22:35:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/setup.h	2007-11-10 21:16:23.000000000 +0800
@@ -17,31 +17,29 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: setup.h,v 1.135 2007-08-23 14:30:24 patrickm Exp $
+ * $Id: setup.h,v 1.136 2007-11-08 18:13:55 yangtse Exp $
  ***************************************************************************/
 
 #ifdef HTTP_ONLY
 #define CURL_DISABLE_TFTP
 #define CURL_DISABLE_FTP
 #define CURL_DISABLE_LDAP
 #define CURL_DISABLE_TELNET
 #define CURL_DISABLE_DICT
 #define CURL_DISABLE_FILE
 #endif /* HTTP_ONLY */
 
-#if !defined(WIN32) && defined(__WIN32__)
-/* Borland fix */
-#define WIN32
-#endif
+/*
+ * Define WIN32 when build target is Win32 API
+ */
 
-#if !defined(WIN32) && defined(_WIN32)
-/* VS2005 on x64 fix */
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
 #define WIN32
 #endif
 
 /*
  * Include configuration script results or hand-crafted
  * configuration file for platforms which lack config tool.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/share.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/share.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/share.c	2007-08-21 04:44:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/share.c	2007-11-07 17:21:36.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2004, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: share.c,v 1.22 2004-12-05 23:59:32 bagder Exp $
+ * $Id: share.c,v 1.23 2007-11-07 09:21:36 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 #include <stdarg.h>
 #include <stdlib.h>
 #include <string.h>
@@ -35,13 +35,13 @@
 
 CURLSH *
 curl_share_init(void)
 {
   struct Curl_share *share =
     (struct Curl_share *)malloc(sizeof(struct Curl_share));
-  if (share) {
+  if(share) {
     memset (share, 0, sizeof(struct Curl_share));
     share->specifier |= (1<<CURL_LOCK_DATA_SHARE);
   }
 
   return share;
 }
@@ -53,13 +53,13 @@
   va_list param;
   int type;
   curl_lock_function lockfunc;
   curl_unlock_function unlockfunc;
   void *ptr;
 
-  if (share->dirty)
+  if(share->dirty)
     /* don't allow setting options while one or more handles are already
        using this share */
     return CURLSHE_IN_USE;
 
   va_start(param, option);
 
@@ -67,22 +67,22 @@
   case CURLSHOPT_SHARE:
     /* this is a type this share will share */
     type = va_arg(param, int);
     share->specifier |= (1<<type);
     switch( type ) {
     case CURL_LOCK_DATA_DNS:
-      if (!share->hostcache) {
+      if(!share->hostcache) {
         share->hostcache = Curl_mk_dnscache();
         if(!share->hostcache)
           return CURLSHE_NOMEM;
       }
       break;
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
     case CURL_LOCK_DATA_COOKIE:
-      if (!share->cookies) {
+      if(!share->cookies) {
         share->cookies = Curl_cookie_init(NULL, NULL, NULL, TRUE );
         if(!share->cookies)
           return CURLSHE_NOMEM;
       }
       break;
 #endif   /* CURL_DISABLE_HTTP */
@@ -99,21 +99,21 @@
     /* this is a type this share will no longer share */
     type = va_arg(param, int);
     share->specifier &= ~(1<<type);
     switch( type )
     {
       case CURL_LOCK_DATA_DNS:
-        if (share->hostcache) {
+        if(share->hostcache) {
           Curl_hash_destroy(share->hostcache);
           share->hostcache = NULL;
         }
         break;
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
       case CURL_LOCK_DATA_COOKIE:
-        if (share->cookies) {
+        if(share->cookies) {
           Curl_cookie_cleanup(share->cookies);
           share->cookies = NULL;
         }
         break;
 #endif   /* CURL_DISABLE_HTTP */
 
@@ -152,20 +152,20 @@
 
 CURLSHcode
 curl_share_cleanup(CURLSH *sh)
 {
   struct Curl_share *share = (struct Curl_share *)sh;
 
-  if (share == NULL)
+  if(share == NULL)
     return CURLSHE_INVALID;
 
   if(share->lockfunc)
     share->lockfunc(NULL, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE,
                     share->clientdata);
 
-  if (share->dirty) {
+  if(share->dirty) {
     if(share->unlockfunc)
       share->unlockfunc(NULL, CURL_LOCK_DATA_SHARE, share->clientdata);
     return CURLSHE_IN_USE;
   }
 
   if(share->hostcache)
@@ -187,13 +187,13 @@
 CURLSHcode
 Curl_share_lock(struct SessionHandle *data, curl_lock_data type,
                 curl_lock_access accesstype)
 {
   struct Curl_share *share = data->share;
 
-  if (share == NULL)
+  if(share == NULL)
     return CURLSHE_INVALID;
 
   if(share->specifier & (1<<type)) {
     if(share->lockfunc) /* only call this if set! */
       share->lockfunc(data, type, accesstype, share->clientdata);
   }
@@ -204,13 +204,13 @@
 
 CURLSHcode
 Curl_share_unlock(struct SessionHandle *data, curl_lock_data type)
 {
   struct Curl_share *share = data->share;
 
-  if (share == NULL)
+  if(share == NULL)
     return CURLSHE_INVALID;
 
   if(share->specifier & (1<<type)) {
     if(share->unlockfunc) /* only call this if set! */
       share->unlockfunc (data, type, share->clientdata);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/socks.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/socks.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/socks.c	2007-08-27 21:01:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/socks.c	2008-01-22 07:47:28.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: socks.c,v 1.15 2007-08-27 06:31:28 danf Exp $
+ * $Id: socks.c,v 1.22 2008-01-14 19:40:10 yangtse Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
@@ -115,31 +115,34 @@
 * destination server.
 *
 * Reference :
 *   http://socks.permeo.com/protocol/socks4.protocol
 *
 * Note :
-*   Nonsupport "SOCKS 4A (Simple Extension to SOCKS 4 Protocol)"
+*   Set protocol4a=true for  "SOCKS 4A (Simple Extension to SOCKS 4 Protocol)"
 *   Nonsupport "Identification Protocol (RFC1413)"
 */
 CURLcode Curl_SOCKS4(const char *proxy_name,
                      const char *hostname,
                      int remote_port,
                      int sockindex,
-                     struct connectdata *conn)
+                     struct connectdata *conn,
+                     bool protocol4a)
 {
-  unsigned char socksreq[262]; /* room for SOCKS4 request incl. user id */
+#define SOCKS4REQLEN 262
+  unsigned char socksreq[SOCKS4REQLEN]; /* room for SOCKS4 request incl. user
+                                           id */
   int result;
   CURLcode code;
   curl_socket_t sock = conn->sock[sockindex];
   long timeout;
   struct SessionHandle *data = conn->data;
 
   /* get timeout */
   if(data->set.timeout && data->set.connecttimeout) {
-    if (data->set.timeout < data->set.connecttimeout)
+    if(data->set.timeout < data->set.connecttimeout)
       timeout = data->set.timeout;
     else
       timeout = data->set.connecttimeout;
   }
   else if(data->set.timeout)
     timeout = data->set.timeout;
@@ -162,14 +165,14 @@
    */
 
   socksreq[0] = 4; /* version (SOCKS4) */
   socksreq[1] = 1; /* connect */
   *((unsigned short*)&socksreq[2]) = htons((unsigned short)remote_port);
 
-  /* DNS resolve */
-  {
+  /* DNS resolve only for SOCKS4, not SOCKS4a */
+  if (!protocol4a) {
     struct Curl_dns_entry *dns;
     Curl_addrinfo *hp=NULL;
     int rc;
 
     rc = Curl_resolv(conn, hostname, remote_port, &dns);
 
@@ -183,13 +186,13 @@
     /*
      * We cannot use 'hostent' as a struct that Curl_resolv() returns.  It
      * returns a Curl_addrinfo pointer that may not always look the same.
      */
     if(dns)
       hp=dns->addr;
-    if (hp) {
+    if(hp) {
       char buf[64];
       unsigned short ip[4];
       Curl_printable_address(hp, buf, sizeof(buf));
 
       if(4 == sscanf( buf, "%hu.%hu.%hu.%hu",
                       &ip[0], &ip[1], &ip[2], &ip[3])) {
@@ -213,37 +216,62 @@
   }
 
   /*
    * This is currently not supporting "Identification Protocol (RFC1413)".
    */
   socksreq[8] = 0; /* ensure empty userid is NUL-terminated */
-  if (proxy_name)
+  if(proxy_name)
     strlcat((char*)socksreq + 8, proxy_name, sizeof(socksreq) - 8);
 
   /*
    * Make connection
    */
   {
     ssize_t actualread;
     ssize_t written;
+    ssize_t hostnamelen = 0;
     int packetsize = 9 +
       (int)strlen((char*)socksreq + 8); /* size including NUL */
 
+    /* If SOCKS4a, set special invalid IP address 0.0.0.x */
+    if (protocol4a) {
+      socksreq[4] = 0;
+      socksreq[5] = 0;
+      socksreq[6] = 0;
+      socksreq[7] = 1;
+      /* If still enough room in buffer, also append hostname */
+      hostnamelen = (ssize_t)strlen(hostname) + 1; /* length including NUL */
+      if (packetsize + hostnamelen <= SOCKS4REQLEN)
+        strcpy((char*)socksreq + packetsize, hostname);
+      else
+        hostnamelen = 0; /* Flag: hostname did not fit in buffer */
+    }
+
     /* Send request */
-    code = Curl_write(conn, sock, (char *)socksreq, packetsize, &written);
-    if ((code != CURLE_OK) || (written != packetsize)) {
+    code = Curl_write(conn, sock, (char *)socksreq, packetsize + hostnamelen,
+                      &written);
+    if((code != CURLE_OK) || (written != packetsize + hostnamelen)) {
       failf(data, "Failed to send SOCKS4 connect request.");
       return CURLE_COULDNT_CONNECT;
     }
+    if (protocol4a && hostnamelen == 0) {
+      /* SOCKS4a with very long hostname - send that name separately */
+      hostnamelen = (ssize_t)strlen(hostname) + 1;
+      code = Curl_write(conn, sock, (char *)hostname, hostnamelen, &written);
+      if((code != CURLE_OK) || (written != hostnamelen)) {
+        failf(data, "Failed to send SOCKS4 connect request.");
+        return CURLE_COULDNT_CONNECT;
+      }
+    }
 
     packetsize = 8; /* receive data size */
 
     /* Receive response */
     result = blockread_all(conn, sock, (char *)socksreq, packetsize,
                            &actualread, timeout);
-    if ((result != CURLE_OK) || (actualread != packetsize)) {
+    if((result != CURLE_OK) || (actualread != packetsize)) {
       failf(data, "Failed to receive SOCKS4 connect request ack.");
       return CURLE_COULDNT_CONNECT;
     }
 
     /*
      * Response format
@@ -262,23 +290,26 @@
      *     identd on the client
      * 93: request rejected because the client program and identd
      *     report different user-ids
      */
 
     /* wrong version ? */
-    if (socksreq[0] != 0) {
+    if(socksreq[0] != 0) {
       failf(data,
             "SOCKS4 reply has wrong version, version should be 4.");
       return CURLE_COULDNT_CONNECT;
     }
 
     /* Result */
     switch(socksreq[1])
     {
     case 90:
-      infof(data, "SOCKS4 request granted.\n");
+      if (protocol4a)
+        infof(data, "SOCKS4a request granted.\n");
+      else
+        infof(data, "SOCKS4 request granted.\n");
       break;
     case 91:
       failf(data,
             "Can't complete SOCKS4 connection to %d.%d.%d.%d:%d. (%d)"
             ", request rejected or failed.",
             (unsigned char)socksreq[4], (unsigned char)socksreq[5],
@@ -356,16 +387,27 @@
   ssize_t written;
   int result;
   CURLcode code;
   curl_socket_t sock = conn->sock[sockindex];
   struct SessionHandle *data = conn->data;
   long timeout;
+  bool socks5_resolve_local = (bool)(data->set.proxytype == CURLPROXY_SOCKS5);
+  const size_t hostname_len = strlen(hostname);
+  ssize_t packetsize = 0;
+
+  /* RFC1928 chapter 5 specifies max 255 chars for domain name in packet */
+  if(!socks5_resolve_local && hostname_len > 255)
+  {
+    infof(conn->data,"SOCKS5: server resolving disabled for hostnames of "
+          "length > 255 [actual len=%d]\n", hostname_len);
+    socks5_resolve_local = TRUE;
+  }
 
   /* get timeout */
   if(data->set.timeout && data->set.connecttimeout) {
-    if (data->set.timeout < data->set.connecttimeout)
+    if(data->set.timeout < data->set.connecttimeout)
       timeout = data->set.timeout;
     else
       timeout = data->set.connecttimeout;
   }
   else if(data->set.timeout)
     timeout = data->set.timeout;
@@ -399,13 +441,13 @@
   socksreq[3] = 2; /* username/password */
 
   Curl_nonblock(sock, FALSE);
 
   code = Curl_write(conn, sock, (char *)socksreq, (2 + (int)socksreq[1]),
                       &written);
-  if ((code != CURLE_OK) || (written != (2 + (int)socksreq[1]))) {
+  if((code != CURLE_OK) || (written != (2 + (int)socksreq[1]))) {
     failf(data, "Unable to send initial SOCKS5 request.");
     return CURLE_COULDNT_CONNECT;
   }
 
   Curl_nonblock(sock, TRUE);
 
@@ -425,26 +467,26 @@
     return CURLE_RECV_ERROR;
   }
 
   Curl_nonblock(sock, FALSE);
 
   result=blockread_all(conn, sock, (char *)socksreq, 2, &actualread, timeout);
-  if ((result != CURLE_OK) || (actualread != 2)) {
+  if((result != CURLE_OK) || (actualread != 2)) {
     failf(data, "Unable to receive initial SOCKS5 response.");
     return CURLE_COULDNT_CONNECT;
   }
 
-  if (socksreq[0] != 5) {
+  if(socksreq[0] != 5) {
     failf(data, "Received invalid version in initial SOCKS5 response.");
     return CURLE_COULDNT_CONNECT;
   }
-  if (socksreq[1] == 0) {
+  if(socksreq[1] == 0) {
     /* Nothing to do, no authentication needed */
     ;
   }
-  else if (socksreq[1] == 2) {
+  else if(socksreq[1] == 2) {
     /* Needs user name and password */
     size_t userlen, pwlen;
     int len;
     if(proxy_name && proxy_password) {
       userlen = strlen(proxy_name);
       pwlen = strlen(proxy_password);
@@ -468,42 +510,42 @@
     len += userlen;
     socksreq[len++] = (char) pwlen;
     memcpy(socksreq + len, proxy_password, (int) pwlen);
     len += pwlen;
 
     code = Curl_write(conn, sock, (char *)socksreq, len, &written);
-    if ((code != CURLE_OK) || (len != written)) {
+    if((code != CURLE_OK) || (len != written)) {
       failf(data, "Failed to send SOCKS5 sub-negotiation request.");
       return CURLE_COULDNT_CONNECT;
     }
 
     result=blockread_all(conn, sock, (char *)socksreq, 2, &actualread,
                          timeout);
-    if ((result != CURLE_OK) || (actualread != 2)) {
+    if((result != CURLE_OK) || (actualread != 2)) {
       failf(data, "Unable to receive SOCKS5 sub-negotiation response.");
       return CURLE_COULDNT_CONNECT;
     }
 
     /* ignore the first (VER) byte */
-    if (socksreq[1] != 0) { /* status */
+    if(socksreq[1] != 0) { /* status */
       failf(data, "User was rejected by the SOCKS5 server (%d %d).",
             socksreq[0], socksreq[1]);
       return CURLE_COULDNT_CONNECT;
     }
 
     /* Everything is good so far, user was authenticated! */
   }
   else {
     /* error */
-    if (socksreq[1] == 1) {
+    if(socksreq[1] == 1) {
       failf(data,
             "SOCKS5 GSSAPI per-message authentication is not supported.");
       return CURLE_COULDNT_CONNECT;
     }
-    else if (socksreq[1] == 255) {
-      if (!proxy_name || !*proxy_name) {
+    else if(socksreq[1] == 255) {
+      if(!proxy_name || !*proxy_name) {
         failf(data,
               "No authentication method was acceptable. (It is quite likely"
               " that the SOCKS5 server wanted a username/password, since none"
               " was supplied to the server on this connection.)");
       }
       else {
@@ -519,19 +561,32 @@
   }
 
   /* Authentication is complete, now specify destination to the proxy */
   socksreq[0] = 5; /* version (SOCKS5) */
   socksreq[1] = 1; /* connect */
   socksreq[2] = 0; /* must be zero */
-  socksreq[3] = 1; /* IPv4 = 1 */
 
-  {
+  if(!socks5_resolve_local) {
+    packetsize = (ssize_t)(5 + hostname_len + 2);
+
+    socksreq[3] = 3; /* ATYP: domain name = 3 */
+    socksreq[4] = (char) hostname_len; /* address length */
+    memcpy(&socksreq[5], hostname, hostname_len); /* address bytes w/o NULL */
+
+    *((unsigned short*)&socksreq[hostname_len+5]) =
+      htons((unsigned short)remote_port);
+  }
+  else {
     struct Curl_dns_entry *dns;
     Curl_addrinfo *hp=NULL;
     int rc = Curl_resolv(conn, hostname, remote_port, &dns);
 
+    packetsize = 10;
+
+    socksreq[3] = 1; /* IPv4 = 1 */
+
     if(rc == CURLRESOLV_ERROR)
       return CURLE_COULDNT_RESOLVE_HOST;
 
     if(rc == CURLRESOLV_PENDING)
       /* this requires that we're in "wait for resolve" state */
       rc = Curl_wait_for_resolv(conn, &dns);
@@ -539,13 +594,13 @@
     /*
      * We cannot use 'hostent' as a struct that Curl_resolv() returns.  It
      * returns a Curl_addrinfo pointer that may not always look the same.
      */
     if(dns)
       hp=dns->addr;
-    if (hp) {
+    if(hp) {
       char buf[64];
       unsigned short ip[4];
       Curl_printable_address(hp, buf, sizeof(buf));
 
       if(4 == sscanf( buf, "%hu.%hu.%hu.%hu",
                       &ip[0], &ip[1], &ip[2], &ip[3])) {
@@ -561,45 +616,81 @@
     }
     if(!hp) {
       failf(data, "Failed to resolve \"%s\" for SOCKS5 connect.",
             hostname);
       return CURLE_COULDNT_RESOLVE_HOST;
     }
+
+    *((unsigned short*)&socksreq[8]) = htons((unsigned short)remote_port);
   }
 
-  *((unsigned short*)&socksreq[8]) = htons((unsigned short)remote_port);
+  code = Curl_write(conn, sock, (char *)socksreq, packetsize, &written);
+  if((code != CURLE_OK) || (written != packetsize)) {
+    failf(data, "Failed to send SOCKS5 connect request.");
+    return CURLE_COULDNT_CONNECT;
+  }
 
-  {
-    const int packetsize = 10;
+  packetsize = 10; /* minimum packet size is 10 */
 
-    code = Curl_write(conn, sock, (char *)socksreq, packetsize, &written);
-    if ((code != CURLE_OK) || (written != packetsize)) {
-      failf(data, "Failed to send SOCKS5 connect request.");
+  result = blockread_all(conn, sock, (char *)socksreq, packetsize,
+                           &actualread, timeout);
+  if((result != CURLE_OK) || (actualread != packetsize)) {
+    failf(data, "Failed to receive SOCKS5 connect request ack.");
+    return CURLE_COULDNT_CONNECT;
+  }
+
+  if(socksreq[0] != 5) { /* version */
+    failf(data,
+          "SOCKS5 reply has wrong version, version should be 5.");
+    return CURLE_COULDNT_CONNECT;
+  }
+  if(socksreq[1] != 0) { /* Anything besides 0 is an error */
+      failf(data,
+            "Can't complete SOCKS5 connection to %d.%d.%d.%d:%d. (%d)",
+            (unsigned char)socksreq[4], (unsigned char)socksreq[5],
+            (unsigned char)socksreq[6], (unsigned char)socksreq[7],
+            (unsigned int)ntohs(*(unsigned short*)(&socksreq[8])),
+            socksreq[1]);
       return CURLE_COULDNT_CONNECT;
-    }
+  }
 
-    result = blockread_all(conn, sock, (char *)socksreq, packetsize,
+  /* Fix: in general, returned BND.ADDR is variable length parameter by RFC
+     1928, so the reply packet should be read until the end to avoid errors at
+     subsequent protocol level.
+
+    +----+-----+-------+------+----------+----------+
+    |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
+    +----+-----+-------+------+----------+----------+
+    | 1  |  1  | X'00' |  1   | Variable |    2     |
+    +----+-----+-------+------+----------+----------+
+
+     ATYP:
+     o  IP v4 address: X'01', BND.ADDR = 4 byte
+     o  domain name:  X'03', BND.ADDR = [ 1 byte length, string ]
+     o  IP v6 address: X'04', BND.ADDR = 16 byte
+     */
+
+  /* Calculate real packet size */
+  if(socksreq[3] == 3) {
+    /* domain name */
+    int addrlen = (int) socksreq[4];
+    packetsize = 5 + addrlen + 2;
+  }
+  else if(socksreq[3] == 4) {
+    /* IPv6 */
+    packetsize = 4 + 16 + 2;
+  }
+
+  /* At this point we already read first 10 bytes */
+  if(packetsize > 10) {
+    packetsize -= 10;
+    result = blockread_all(conn, sock, (char *)&socksreq[10], packetsize,
                            &actualread, timeout);
-    if ((result != CURLE_OK) || (actualread != packetsize)) {
+    if((result != CURLE_OK) || (actualread != packetsize)) {
       failf(data, "Failed to receive SOCKS5 connect request ack.");
       return CURLE_COULDNT_CONNECT;
     }
-
-    if (socksreq[0] != 5) { /* version */
-      failf(data,
-            "SOCKS5 reply has wrong version, version should be 5.");
-      return CURLE_COULDNT_CONNECT;
-    }
-    if (socksreq[1] != 0) { /* Anything besides 0 is an error */
-        failf(data,
-              "Can't complete SOCKS5 connection to %d.%d.%d.%d:%d. (%d)",
-              (unsigned char)socksreq[4], (unsigned char)socksreq[5],
-              (unsigned char)socksreq[6], (unsigned char)socksreq[7],
-              (unsigned int)ntohs(*(unsigned short*)(&socksreq[8])),
-              socksreq[1]);
-        return CURLE_COULDNT_CONNECT;
-    }
   }
 
   Curl_nonblock(sock, TRUE);
   return CURLE_OK; /* Proxy was successful! */
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/socks.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/socks.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/socks.h	2007-08-27 21:01:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/socks.h	2008-01-03 05:40:12.000000000 +0800
@@ -4,37 +4,38 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: socks.h,v 1.5 2007-08-27 06:31:28 danf Exp $
+ * $Id: socks.h,v 1.6 2008-01-02 21:40:12 bagder Exp $
  ***************************************************************************/
 
 /*
- * This function logs in to a SOCKS4 proxy and sends the specifics to the
+ * This function logs in to a SOCKS4(a) proxy and sends the specifics to the
  * final destination server.
  */
 CURLcode Curl_SOCKS4(const char *proxy_name,
                      const char *hostname,
                      int remote_port,
                      int sockindex,
-                     struct connectdata *conn);
+                     struct connectdata *conn,
+                     bool protocol4a);
 
 /*
  * This function logs in to a SOCKS5 proxy and sends the specifics to the
  * final destination server.
  */
 CURLcode Curl_SOCKS5(const char *proxy_name,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/splay.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/splay.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/splay.c	2007-09-27 19:38:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/splay.c	2007-11-05 17:45:09.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1997 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1997 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: splay.c,v 1.7 2007-09-27 01:45:23 danf Exp $
+ * $Id: splay.c,v 1.8 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -39,43 +39,43 @@
  */
 struct Curl_tree *Curl_splay(int i, struct Curl_tree *t)
 {
   struct Curl_tree N, *l, *r, *y;
   int comp;
 
-  if (t == NULL)
+  if(t == NULL)
     return t;
   N.smaller = N.larger = NULL;
   l = r = &N;
 
   for (;;) {
     comp = compare(i, t->key);
-    if (comp < 0) {
-      if (t->smaller == NULL)
+    if(comp < 0) {
+      if(t->smaller == NULL)
         break;
-      if (compare(i, t->smaller->key) < 0) {
+      if(compare(i, t->smaller->key) < 0) {
         y = t->smaller;                           /* rotate smaller */
         t->smaller = y->larger;
         y->larger = t;
         t = y;
-        if (t->smaller == NULL)
+        if(t->smaller == NULL)
           break;
       }
       r->smaller = t;                               /* link smaller */
       r = t;
       t = t->smaller;
     }
-    else if (comp > 0) {
-      if (t->larger == NULL)
+    else if(comp > 0) {
+      if(t->larger == NULL)
         break;
-      if (compare(i, t->larger->key) > 0) {
+      if(compare(i, t->larger->key) > 0) {
         y = t->larger;                          /* rotate larger */
         t->larger = y->smaller;
         y->smaller = t;
         t = y;
-        if (t->larger == NULL)
+        if(t->larger == NULL)
           break;
       }
       l->larger = t;                              /* link larger */
       l = t;
       t = t->larger;
     }
@@ -94,18 +94,18 @@
 /* Insert key i into the tree t.  Return a pointer to the resulting tree or
    NULL if something went wrong. */
 struct Curl_tree *Curl_splayinsert(int i,
                                    struct Curl_tree *t,
                                    struct Curl_tree *node)
 {
-  if (node == NULL)
+  if(node == NULL)
     return t;
 
-  if (t != NULL) {
+  if(t != NULL) {
     t = Curl_splay(i,t);
-    if (compare(i, t->key)==0) {
+    if(compare(i, t->key)==0) {
       /* There already exists a node in the tree with the very same key. Build
          a linked list of nodes. We make the new 'node' struct the new master
          node and make the previous node the first one in the 'same' list. */
 
       node->same = t;
       node->key = i;
@@ -120,16 +120,16 @@
                                to quickly identify this node as a subnode */
 
       return node; /* new root node */
     }
   }
 
-  if (t == NULL) {
+  if(t == NULL) {
     node->smaller = node->larger = NULL;
   }
-  else if (compare(i, t->key) < 0) {
+  else if(compare(i, t->key) < 0) {
     node->smaller = t->smaller;
     node->larger = t;
     t->smaller = NULL;
 
   }
   else {
@@ -153,17 +153,17 @@
                                    struct Curl_tree **removed)
 {
   struct Curl_tree *x;
 
   *removed = NULL; /* default to no removed */
 
-  if (t==NULL)
+  if(t==NULL)
     return NULL;
 
   t = Curl_splay(i,t);
-  if (compare(i, t->key) == 0) {               /* found it */
+  if(compare(i, t->key) == 0) {               /* found it */
 
     /* FIRST! Check if there is a list with identical sizes */
     if((x = t->same)) {
       /* there is, pick one from the list */
 
       /* 'x' is the new root node */
@@ -173,13 +173,13 @@
       x->smaller = t->smaller;
 
       *removed = t;
       return x; /* new root */
     }
 
-    if (t->smaller == NULL) {
+    if(t->smaller == NULL) {
       x = t->larger;
     }
     else {
       x = Curl_splay(i, t->smaller);
       x->larger = t->larger;
     }
@@ -196,13 +196,13 @@
    resulting tree.  best-fit means the node with the given or lower number */
 struct Curl_tree *Curl_splaygetbest(int i, struct Curl_tree *t,
                                     struct Curl_tree **removed)
 {
   struct Curl_tree *x;
 
-  if (!t) {
+  if(!t) {
     *removed = NULL; /* none removed since there was no root */
     return NULL;
   }
 
   t = Curl_splay(i,t);
   if(compare(i, t->key) < 0) {
@@ -213,13 +213,13 @@
       /* fail */
       *removed = NULL;
       return t;
     }
   }
 
-  if (compare(i, t->key) >= 0) {               /* found it */
+  if(compare(i, t->key) >= 0) {               /* found it */
     /* FIRST! Check if there is a list with identical sizes */
     x = t->same;
     if(x) {
       /* there is, pick one from the list */
 
       /* 'x' is the new root node */
@@ -229,13 +229,13 @@
       x->smaller = t->smaller;
 
       *removed = t;
       return x; /* new root */
     }
 
-    if (t->smaller == NULL) {
+    if(t->smaller == NULL) {
       x = t->larger;
     }
     else {
       x = Curl_splay(i, t->smaller);
       x->larger = t->larger;
     }
@@ -262,20 +262,20 @@
 int Curl_splayremovebyaddr(struct Curl_tree *t,
                            struct Curl_tree *removenode,
                            struct Curl_tree **newroot)
 {
   struct Curl_tree *x;
 
-  if (!t || !removenode)
+  if(!t || !removenode)
     return 1;
 
   if(KEY_NOTUSED == removenode->key) {
     /* Key set to NOTUSED means it is a subnode within a 'same' linked list
        and thus we can unlink it easily. The 'smaller' link of a subnode
        links to the parent node. */
-    if (removenode->smaller == NULL)
+    if(removenode->smaller == NULL)
       return 3;
 
     removenode->smaller->same = removenode->same;
     if(removenode->same)
       removenode->same->smaller = removenode->smaller;
 
@@ -309,13 +309,13 @@
     x->key = t->key;
     x->larger = t->larger;
     x->smaller = t->smaller;
   }
   else {
     /* Remove the root node */
-    if (t->smaller == NULL)
+    if(t->smaller == NULL)
       x = t->larger;
     else {
       x = Curl_splay(removenode->key, t->smaller);
       x->larger = t->larger;
     }
   }
@@ -329,13 +329,13 @@
 
 void Curl_splayprint(struct Curl_tree * t, int d, char output)
 {
   struct Curl_tree *node;
   int i;
   int count;
-  if (t == NULL)
+  if(t == NULL)
     return;
 
   Curl_splayprint(t->larger, d+1, output);
   for (i=0; i<d; i++)
     if(output)
       printf("  ");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ssh.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ssh.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ssh.c	2007-10-22 23:05:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ssh.c	2008-01-24 06:20:22.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssh.c,v 1.80 2007-10-22 15:05:35 bagder Exp $
+ * $Id: ssh.c,v 1.90 2008-01-22 17:26:42 yangtse Exp $
  ***************************************************************************/
 
 /* #define CURL_LIBSSH2_DEBUG */
 
 #include "setup.h"
 
@@ -131,77 +131,85 @@
 static LIBSSH2_ALLOC_FUNC(libssh2_malloc);
 static LIBSSH2_REALLOC_FUNC(libssh2_realloc);
 static LIBSSH2_FREE_FUNC(libssh2_free);
 
 static int get_pathname(const char **cpp, char **path);
 
-static CURLcode Curl_ssh_connect(struct connectdata *conn, bool *done);
-static CURLcode Curl_ssh_multi_statemach(struct connectdata *conn, bool *done);
-
-static CURLcode Curl_scp_do(struct connectdata *conn, bool *done);
-static CURLcode Curl_scp_done(struct connectdata *conn,
-                              CURLcode, bool premature);
-static CURLcode Curl_scp_doing(struct connectdata *conn,
-                               bool *dophase_done);
-
-static CURLcode Curl_sftp_do(struct connectdata *conn, bool *done);
-static CURLcode Curl_sftp_done(struct connectdata *conn,
-                               CURLcode, bool premature);
-static CURLcode Curl_sftp_doing(struct connectdata *conn,
-                                bool *dophase_done);
-
+static CURLcode ssh_connect(struct connectdata *conn, bool *done);
+static CURLcode ssh_multi_statemach(struct connectdata *conn, bool *done);
+static CURLcode ssh_do(struct connectdata *conn, bool *done);
+
+static CURLcode ssh_getworkingpath(struct connectdata *conn,
+                                   char *homedir, /* when SFTP is used */
+                                   char **path);
+
+static CURLcode scp_done(struct connectdata *conn,
+                         CURLcode, bool premature);
+static CURLcode scp_doing(struct connectdata *conn,
+                          bool *dophase_done);
+static CURLcode scp_disconnect(struct connectdata *conn);
+
+static CURLcode sftp_done(struct connectdata *conn,
+                          CURLcode, bool premature);
+static CURLcode sftp_doing(struct connectdata *conn,
+                           bool *dophase_done);
+static CURLcode sftp_disconnect(struct connectdata *conn);
+static
+CURLcode sftp_perform(struct connectdata *conn,
+                      bool *connected,
+                      bool *dophase_done);
 /*
  * SCP protocol handler.
  */
 
 const struct Curl_handler Curl_handler_scp = {
   "SCP",                                /* scheme */
   ZERO_NULL,                            /* setup_connection */
-  Curl_scp_do,                          /* do_it */
-  Curl_scp_done,                        /* done */
+  ssh_do,                               /* do_it */
+  scp_done,                             /* done */
   ZERO_NULL,                            /* do_more */
-  Curl_ssh_connect,                     /* connect_it */
-  Curl_ssh_multi_statemach,             /* connecting */
-  Curl_scp_doing,                       /* doing */
+  ssh_connect,                          /* connect_it */
+  ssh_multi_statemach,                  /* connecting */
+  scp_doing,                            /* doing */
   ZERO_NULL,                            /* proto_getsock */
   ZERO_NULL,                            /* doing_getsock */
-  ZERO_NULL,                            /* disconnect */
+  scp_disconnect,                       /* disconnect */
   PORT_SSH,                             /* defport */
   PROT_SCP                              /* protocol */
 };
 
 
 /*
  * SFTP protocol handler.
  */
 
 const struct Curl_handler Curl_handler_sftp = {
   "SFTP",                               /* scheme */
   ZERO_NULL,                            /* setup_connection */
-  Curl_sftp_do,                         /* do_it */
-  Curl_sftp_done,                       /* done */
+  ssh_do,                               /* do_it */
+  sftp_done,                            /* done */
   ZERO_NULL,                            /* do_more */
-  Curl_ssh_connect,                     /* connect_it */
-  Curl_ssh_multi_statemach,             /* connecting */
-  Curl_sftp_doing,                      /* doing */
+  ssh_connect,                          /* connect_it */
+  ssh_multi_statemach,                  /* connecting */
+  sftp_doing,                           /* doing */
   ZERO_NULL,                            /* proto_getsock */
   ZERO_NULL,                            /* doing_getsock */
-  ZERO_NULL,                            /* disconnect */
+  sftp_disconnect,                      /* disconnect */
   PORT_SSH,                             /* defport */
   PROT_SFTP                             /* protocol */
 };
 
 
 static void
 kbd_callback(const char *name, int name_len, const char *instruction,
              int instruction_len, int num_prompts,
              const LIBSSH2_USERAUTH_KBDINT_PROMPT *prompts,
              LIBSSH2_USERAUTH_KBDINT_RESPONSE *responses,
              void **abstract)
 {
-  struct SSHPROTO *ssh = (struct SSHPROTO *)*abstract;
+  struct connectdata *conn = (struct connectdata *)*abstract;
 
 #ifdef CURL_LIBSSH2_DEBUG
   fprintf(stderr, "name=%s\n", name);
   fprintf(stderr, "name_len=%d\n", name_len);
   fprintf(stderr, "instruction=%s\n", instruction);
   fprintf(stderr, "instruction_len=%d\n", instruction_len);
@@ -209,15 +217,15 @@
 #else
   (void)name;
   (void)name_len;
   (void)instruction;
   (void)instruction_len;
 #endif  /* CURL_LIBSSH2_DEBUG */
-  if (num_prompts == 1) {
-    responses[0].text = strdup(ssh->passwd);
-    responses[0].length = strlen(ssh->passwd);
+  if(num_prompts == 1) {
+    responses[0].text = strdup(conn->passwd);
+    responses[0].length = strlen(conn->passwd);
   }
   (void)prompts;
   (void)abstract;
 } /* kbd_callback */
 
 static CURLcode sftp_libssh2_error_to_CURLE(unsigned long err)
@@ -251,13 +259,13 @@
 
   return CURLE_SSH;
 }
 
 static CURLcode libssh2_session_error_to_CURLE(int err)
 {
-  if (err == LIBSSH2_ERROR_ALLOC)
+  if(err == LIBSSH2_ERROR_ALLOC)
     return CURLE_OUT_OF_MEMORY;
 
   /* TODO: map some more of the libssh2 errors to the more appropriate CURLcode
      error code, and possibly add a few new SSH-related one. We must however
      not return or even depend on libssh2 errors in the public libcurl API */
 
@@ -302,13 +310,12 @@
     "SSH_AUTH_HOST",
     "SSH_AUTH_KEY_INIT",
     "SSH_AUTH_KEY",
     "SSH_AUTH_DONE",
     "SSH_SFTP_INIT",
     "SSH_SFTP_REALPATH",
-    "SSH_GET_WORKINGPATH",
     "SSH_SFTP_QUOTE_INIT",
     "SSH_SFTP_POSTQUOTE_INIT",
     "SSH_SFTP_QUOTE",
     "SSH_SFTP_NEXT_QUOTE",
     "SSH_SFTP_QUOTE_STAT",
     "SSH_SFTP_QUOTE_SETSTAT",
@@ -336,1450 +343,1491 @@
     "SSH_SCP_DOWNLOAD_INIT",
     "SSH_SCP_DONE",
     "SSH_SCP_SEND_EOF",
     "SSH_SCP_WAIT_EOF",
     "SSH_SCP_WAIT_CLOSE",
     "SSH_SCP_CHANNEL_FREE",
-    "SSH_CHANNEL_CLOSE",
-    "SSH_SESSION_DISCONECT",
+    "SSH_SESSION_DISCONNECT",
     "SSH_SESSION_FREE",
     "QUIT"
   };
 #endif
   struct ssh_conn *sshc = &conn->proto.sshc;
 
 #if defined(CURLDEBUG) && !defined(CURL_DISABLE_VERBOSE_STRINGS)
-  if (sshc->state != nowstate) {
+  if(sshc->state != nowstate) {
     infof(conn->data, "SFTP %p state change from %s to %s\n",
           sshc, names[sshc->state], names[nowstate]);
   }
 #endif
 
   sshc->state = nowstate;
 }
 
+/* figure out the path to work with in this particular request */
+static CURLcode ssh_getworkingpath(struct connectdata *conn,
+                                   char *homedir,  /* when SFTP is used */
+                                   char **path) /* returns the  allocated
+                                                   real path to work with */
+{
+  struct SessionHandle *data = conn->data;
+  char *real_path = NULL;
+  char *working_path;
+  int working_path_len;
+
+  working_path = curl_easy_unescape(data, data->state.path, 0,
+                                    &working_path_len);
+  if(!working_path)
+    return CURLE_OUT_OF_MEMORY;
+
+  /* Check for /~/ , indicating relative to the user's home directory */
+  if(conn->protocol & PROT_SCP) {
+    real_path = (char *)malloc(working_path_len+1);
+    if(real_path == NULL) {
+      free(working_path);
+      return CURLE_OUT_OF_MEMORY;
+    }
+    if((working_path_len > 1) && (working_path[1] == '~'))
+      /* It is referenced to the home directory, so strip the leading '/' */
+      memcpy(real_path, working_path+1, 1 + working_path_len-1);
+    else
+      memcpy(real_path, working_path, 1 + working_path_len);
+  }
+  else if(conn->protocol & PROT_SFTP) {
+    if((working_path_len > 1) && (working_path[1] == '~')) {
+      size_t homelen = strlen(homedir);
+      real_path = (char *)malloc(homelen + working_path_len + 1);
+      if(real_path == NULL) {
+        free(working_path);
+        return CURLE_OUT_OF_MEMORY;
+      }
+      /* It is referenced to the home directory, so strip the
+         leading '/' */
+      memcpy(real_path, homedir, homelen);
+      real_path[homelen] = '/';
+      real_path[homelen+1] = '\0';
+      if(working_path_len > 3) {
+        memcpy(real_path+homelen+1, working_path + 3,
+               1 + working_path_len -3);
+      }
+    }
+    else {
+      real_path = (char *)malloc(working_path_len+1);
+      if(real_path == NULL) {
+        free(working_path);
+        return CURLE_OUT_OF_MEMORY;
+      }
+      memcpy(real_path, working_path, 1+working_path_len);
+    }
+  }
+
+  free(working_path);
+
+  /* store the pointer for the caller to receive */
+  *path = real_path;
+
+  return CURLE_OK;
+}
+
 static CURLcode ssh_statemach_act(struct connectdata *conn)
 {
   CURLcode result = CURLE_OK;
   struct SessionHandle *data = conn->data;
-  struct SSHPROTO *sftp_scp = data->reqdata.proto.ssh;
+  struct SSHPROTO *sftp_scp = data->state.proto.ssh;
   struct ssh_conn *sshc = &conn->proto.sshc;
   curl_socket_t sock = conn->sock[FIRSTSOCKET];
 #ifdef CURL_LIBSSH2_DEBUG
   const char *fingerprint;
 #endif /* CURL_LIBSSH2_DEBUG */
   const char *host_public_key_md5;
   int rc,i;
-  long err;
+  int err;
 
   switch(sshc->state) {
-    case SSH_S_STARTUP:
-      sshc->secondCreateDirs = 0;
-      sshc->nextState = SSH_NO_STATE;
-      sshc->actualCode = CURLE_OK;
+  case SSH_S_STARTUP:
+    sshc->secondCreateDirs = 0;
+    sshc->nextstate = SSH_NO_STATE;
+    sshc->actualcode = CURLE_OK;
 
-      rc = libssh2_session_startup(sftp_scp->ssh_session, sock);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      }
-      else if (rc) {
-        failf(data, "Failure establishing ssh session");
-        state(conn, SSH_SESSION_FREE);
-        sshc->actualCode = CURLE_FAILED_INIT;
-        break;
-      }
+    rc = libssh2_session_startup(sshc->ssh_session, sock);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc) {
+      failf(data, "Failure establishing ssh session");
+      state(conn, SSH_SESSION_FREE);
+      sshc->actualcode = CURLE_FAILED_INIT;
+      break;
+    }
 
-      /* Set libssh2 to non-blocking, since cURL is all non-blocking */
-      libssh2_session_set_blocking(sftp_scp->ssh_session, 0);
+    /* Set libssh2 to non-blocking, since cURL is all non-blocking */
+    libssh2_session_set_blocking(sshc->ssh_session, 0);
 
 #ifdef CURL_LIBSSH2_DEBUG
-      /*
-       * Before we authenticate we should check the hostkey's fingerprint
-       * against our known hosts. How that is handled (reading from file,
-       * whatever) is up to us. As for know not much is implemented, besides
-       * showing how to get the fingerprint.
-       */
-      fingerprint = libssh2_hostkey_hash(sftp_scp->ssh_session,
-                                         LIBSSH2_HOSTKEY_HASH_MD5);
-
-      /* The fingerprint points to static storage (!), don't free() it. */
-      infof(data, "Fingerprint: ");
-      for (rc = 0; rc < 16; rc++) {
-        infof(data, "%02X ", (unsigned char) fingerprint[rc]);
-      }
-      infof(data, "\n");
+    /*
+     * Before we authenticate we should check the hostkey's fingerprint
+     * against our known hosts. How that is handled (reading from file,
+     * whatever) is up to us. As for know not much is implemented, besides
+     * showing how to get the fingerprint.
+     */
+    fingerprint = libssh2_hostkey_hash(sshc->ssh_session,
+                                       LIBSSH2_HOSTKEY_HASH_MD5);
+
+    /* The fingerprint points to static storage (!), don't free() it. */
+    infof(data, "Fingerprint: ");
+    for (rc = 0; rc < 16; rc++) {
+      infof(data, "%02X ", (unsigned char) fingerprint[rc]);
+    }
+    infof(data, "\n");
 #endif /* CURL_LIBSSH2_DEBUG */
 
-      /* Before we authenticate we check the hostkey's MD5 fingerprint
-       * against a known fingerprint, if available.  This implementation pulls
-       * it from the curl option.
-       */
-      if (data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5] &&
-          strlen(data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]) == 32)
-      {
-        char buf[33];
-        host_public_key_md5 = libssh2_hostkey_hash(sftp_scp->ssh_session,
-                                                   LIBSSH2_HOSTKEY_HASH_MD5);
-        for (i = 0; i < 16; i++)
-          snprintf(&buf[i*2], 3, "%02x",
-                   (unsigned char) host_public_key_md5[i]);
-        if(!strequal(buf, data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5])) {
-          failf(data,
-                "Denied establishing ssh session: mismatch md5 fingerprint. "
-                "Remote %s is not equal to %s",
-                buf, data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]);
-          state(conn, SSH_SESSION_FREE);
-          sshc->actualCode = CURLE_PEER_FAILED_VERIFICATION;
-          break;
-        }
+    /* Before we authenticate we check the hostkey's MD5 fingerprint
+     * against a known fingerprint, if available.  This implementation pulls
+     * it from the curl option.
+     */
+    if(data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5] &&
+       strlen(data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]) == 32) {
+      char buf[33];
+      host_public_key_md5 = libssh2_hostkey_hash(sshc->ssh_session,
+                                                 LIBSSH2_HOSTKEY_HASH_MD5);
+      for (i = 0; i < 16; i++)
+        snprintf(&buf[i*2], 3, "%02x",
+                 (unsigned char) host_public_key_md5[i]);
+      if(!strequal(buf, data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5])) {
+        failf(data,
+              "Denied establishing ssh session: mismatch md5 fingerprint. "
+              "Remote %s is not equal to %s",
+              buf, data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5]);
+        state(conn, SSH_SESSION_FREE);
+        sshc->actualcode = CURLE_PEER_FAILED_VERIFICATION;
+        break;
       }
+    }
 
-      state(conn, SSH_AUTHLIST);
-      break;
+    state(conn, SSH_AUTHLIST);
+    break;
 
-    case SSH_AUTHLIST:
-      /* TBD - methods to check the host keys need to be done */
+  case SSH_AUTHLIST:
+    /* TBD - methods to check the host keys need to be done */
 
-      /*
-       * Figure out authentication methods
-       * NB: As soon as we have provided a username to an openssh server we
-       * must never change it later. Thus, always specify the correct username
-       * here, even though the libssh2 docs kind of indicate that it should be
-       * possible to get a 'generic' list (not user-specific) of authentication
-       * methods, presumably with a blank username. That won't work in my
-       * experience.
-       * So always specify it here.
-       */
-      sshc->authlist = libssh2_userauth_list(sftp_scp->ssh_session,
-                                             sftp_scp->user,
-                                             strlen(sftp_scp->user));
-
-      if (!sshc->authlist) {
-        if ((err = libssh2_session_last_errno(sftp_scp->ssh_session)) ==
-                        LIBSSH2_ERROR_EAGAIN) {
-          break;
-        } else {
-          state(conn, SSH_SESSION_FREE);
-          sshc->actualCode = libssh2_session_error_to_CURLE(err);
-          break;
-        }
+    /*
+     * Figure out authentication methods
+     * NB: As soon as we have provided a username to an openssh server we
+     * must never change it later. Thus, always specify the correct username
+     * here, even though the libssh2 docs kind of indicate that it should be
+     * possible to get a 'generic' list (not user-specific) of authentication
+     * methods, presumably with a blank username. That won't work in my
+     * experience.
+     * So always specify it here.
+     */
+    sshc->authlist = libssh2_userauth_list(sshc->ssh_session,
+                                           conn->user,
+                                           strlen(conn->user));
+
+    if(!sshc->authlist) {
+      if((err = libssh2_session_last_errno(sshc->ssh_session)) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
-      infof(data, "SSH authentication methods available: %s\n", sshc->authlist);
-
-      state(conn, SSH_AUTH_PKEY_INIT);
-      break;
-
-    case SSH_AUTH_PKEY_INIT:
-      /*
-       * Check the supported auth types in the order I feel is most secure
-       * with the requested type of authentication
-       */
-      sshc->authed = FALSE;
-
-      if ((data->set.ssh_auth_types & CURLSSH_AUTH_PUBLICKEY) &&
-          (strstr(sshc->authlist, "publickey") != NULL)) {
-        char *home;
-
-        sshc->rsa_pub = sshc->rsa = NULL;
-
-        /* To ponder about: should really the lib be messing about with the
-           HOME environment variable etc? */
-        home = curl_getenv("HOME");
-
-        if (data->set.str[STRING_SSH_PUBLIC_KEY])
-          sshc->rsa_pub = aprintf("%s", data->set.str[STRING_SSH_PUBLIC_KEY]);
-        else if (home)
-          sshc->rsa_pub = aprintf("%s/.ssh/id_dsa.pub", home);
-        else
-          /* as a final resort, try current dir! */
-          sshc->rsa_pub = strdup("id_dsa.pub");
-
-        if (sshc->rsa_pub == NULL) {
-          Curl_safefree(home);
-          home = NULL;
-          state(conn, SSH_SESSION_FREE);
-          sshc->actualCode = CURLE_OUT_OF_MEMORY;
-          break;
-        }
-
-        if (data->set.str[STRING_SSH_PRIVATE_KEY])
-          sshc->rsa = aprintf("%s", data->set.str[STRING_SSH_PRIVATE_KEY]);
-        else if (home)
-          sshc->rsa = aprintf("%s/.ssh/id_dsa", home);
-        else
-          /* as a final resort, try current dir! */
-          sshc->rsa = strdup("id_dsa");
+      else {
+        state(conn, SSH_SESSION_FREE);
+        sshc->actualcode = libssh2_session_error_to_CURLE(err);
+        break;
+      }
+    }
+    infof(data, "SSH authentication methods available: %s\n", sshc->authlist);
 
-        if (sshc->rsa == NULL) {
-          Curl_safefree(home);
-          home = NULL;
-          Curl_safefree(sshc->rsa_pub);
-          sshc->rsa_pub = NULL;
-          state(conn, SSH_SESSION_FREE);
-          sshc->actualCode = CURLE_OUT_OF_MEMORY;
-          break;
-        }
+    state(conn, SSH_AUTH_PKEY_INIT);
+    break;
 
-        sshc->passphrase = data->set.str[STRING_KEY_PASSWD];
-        if (!sshc->passphrase)
-          sshc->passphrase = "";
+  case SSH_AUTH_PKEY_INIT:
+    /*
+     * Check the supported auth types in the order I feel is most secure
+     * with the requested type of authentication
+     */
+    sshc->authed = FALSE;
+
+    if((data->set.ssh_auth_types & CURLSSH_AUTH_PUBLICKEY) &&
+       (strstr(sshc->authlist, "publickey") != NULL)) {
+      char *home;
+
+      sshc->rsa_pub = sshc->rsa = NULL;
+
+      /* To ponder about: should really the lib be messing about with the
+         HOME environment variable etc? */
+      home = curl_getenv("HOME");
+
+      if(data->set.str[STRING_SSH_PUBLIC_KEY])
+        sshc->rsa_pub = aprintf("%s", data->set.str[STRING_SSH_PUBLIC_KEY]);
+      else if(home)
+        sshc->rsa_pub = aprintf("%s/.ssh/id_dsa.pub", home);
+      else
+        /* as a final resort, try current dir! */
+        sshc->rsa_pub = strdup("id_dsa.pub");
 
+      if(sshc->rsa_pub == NULL) {
         Curl_safefree(home);
         home = NULL;
-
-        infof(data, "Using ssh public key file %s\n", sshc->rsa_pub);
-        infof(data, "Using ssh private key file %s\n", sshc->rsa);
-
-        state(conn, SSH_AUTH_PKEY);
-      } else {
-        state(conn, SSH_AUTH_PASS_INIT);
-      }
-      break;
-
-    case SSH_AUTH_PKEY:
-      /* The function below checks if the files exists, no need to stat() here.
-       */
-      rc = libssh2_userauth_publickey_fromfile(sftp_scp->ssh_session,
-                                               sftp_scp->user, sshc->rsa_pub,
-                                               sshc->rsa, sshc->passphrase);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
+        state(conn, SSH_SESSION_FREE);
+        sshc->actualcode = CURLE_OUT_OF_MEMORY;
         break;
       }
 
-      Curl_safefree(sshc->rsa_pub);
-      sshc->rsa_pub = NULL;
-      Curl_safefree(sshc->rsa);
-      sshc->rsa = NULL;
+      if(data->set.str[STRING_SSH_PRIVATE_KEY])
+        sshc->rsa = aprintf("%s", data->set.str[STRING_SSH_PRIVATE_KEY]);
+      else if(home)
+        sshc->rsa = aprintf("%s/.ssh/id_dsa", home);
+      else
+        /* as a final resort, try current dir! */
+        sshc->rsa = strdup("id_dsa");
 
-      if (rc == 0) {
-        sshc->authed = TRUE;
-        infof(data, "Initialized SSH public key authentication\n");
-        state(conn, SSH_AUTH_DONE);
-      } else {
-        state(conn, SSH_AUTH_PASS_INIT);
+      if(sshc->rsa == NULL) {
+        Curl_safefree(home);
+        home = NULL;
+        Curl_safefree(sshc->rsa_pub);
+        sshc->rsa_pub = NULL;
+        state(conn, SSH_SESSION_FREE);
+        sshc->actualcode = CURLE_OUT_OF_MEMORY;
+        break;
       }
-      break;
 
-    case SSH_AUTH_PASS_INIT:
-      if ((data->set.ssh_auth_types & CURLSSH_AUTH_PASSWORD) &&
-          (strstr(sshc->authlist, "password") != NULL)) {
-        state(conn, SSH_AUTH_PASS);
-      } else {
-        state(conn, SSH_AUTH_HOST_INIT);
-      }
-      break;
+      sshc->passphrase = data->set.str[STRING_KEY_PASSWD];
+      if(!sshc->passphrase)
+        sshc->passphrase = "";
 
-    case SSH_AUTH_PASS:
-      rc = libssh2_userauth_password(sftp_scp->ssh_session, sftp_scp->user,
-                                     sftp_scp->passwd);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      }
-      else if (rc == 0) {
-        sshc->authed = TRUE;
-        infof(data, "Initialized password authentication\n");
-        state(conn, SSH_AUTH_DONE);
-      } else {
-        state(conn, SSH_AUTH_HOST_INIT);
-      }
-      break;
+      Curl_safefree(home);
+      home = NULL;
 
-    case SSH_AUTH_HOST_INIT:
-      if ((data->set.ssh_auth_types & CURLSSH_AUTH_HOST) &&
-          (strstr(sshc->authlist, "hostbased") != NULL)) {
-        state(conn, SSH_AUTH_HOST);
-      } else {
-        state(conn, SSH_AUTH_KEY_INIT);
-      }
-      break;
+      infof(data, "Using ssh public key file %s\n", sshc->rsa_pub);
+      infof(data, "Using ssh private key file %s\n", sshc->rsa);
 
-    case SSH_AUTH_HOST:
-      state(conn, SSH_AUTH_KEY_INIT);
-      break;
+      state(conn, SSH_AUTH_PKEY);
+    }
+    else {
+      state(conn, SSH_AUTH_PASS_INIT);
+    }
+    break;
 
-    case SSH_AUTH_KEY_INIT:
-      if ((data->set.ssh_auth_types & CURLSSH_AUTH_KEYBOARD)
-          && (strstr(sshc->authlist, "keyboard-interactive") != NULL)) {
-        state(conn, SSH_AUTH_KEY);
-      } else {
-        state(conn, SSH_AUTH_DONE);
-      }
+  case SSH_AUTH_PKEY:
+    /* The function below checks if the files exists, no need to stat() here.
+     */
+    rc = libssh2_userauth_publickey_fromfile(sshc->ssh_session,
+                                             conn->user, sshc->rsa_pub,
+                                             sshc->rsa, sshc->passphrase);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
       break;
+    }
 
-    case SSH_AUTH_KEY:
-      /* Authentication failed. Continue with keyboard-interactive now. */
-      rc = libssh2_userauth_keyboard_interactive_ex(sftp_scp->ssh_session,
-                                                    sftp_scp->user,
-                                                    strlen(sftp_scp->user),
-                                                    &kbd_callback);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      }
-      else if (rc == 0) {
-        sshc->authed = TRUE;
-        infof(data, "Initialized keyboard interactive authentication\n");
-      }
+    Curl_safefree(sshc->rsa_pub);
+    sshc->rsa_pub = NULL;
+    Curl_safefree(sshc->rsa);
+    sshc->rsa = NULL;
+
+    if(rc == 0) {
+      sshc->authed = TRUE;
+      infof(data, "Initialized SSH public key authentication\n");
       state(conn, SSH_AUTH_DONE);
-      break;
+    }
+    else {
+      state(conn, SSH_AUTH_PASS_INIT);
+    }
+    break;
 
-    case SSH_AUTH_DONE:
-      if (!sshc->authed) {
-        failf(data, "Authentication failure");
-        state(conn, SSH_SESSION_FREE);
-        sshc->actualCode = CURLE_LOGIN_DENIED;
-        break;
-      }
+  case SSH_AUTH_PASS_INIT:
+    if((data->set.ssh_auth_types & CURLSSH_AUTH_PASSWORD) &&
+       (strstr(sshc->authlist, "password") != NULL)) {
+      state(conn, SSH_AUTH_PASS);
+    }
+    else {
+      state(conn, SSH_AUTH_HOST_INIT);
+    }
+    break;
 
-      /*
-       * At this point we have an authenticated ssh session.
-       */
-      infof(data, "Authentication complete\n");
+  case SSH_AUTH_PASS:
+    rc = libssh2_userauth_password(sshc->ssh_session, conn->user,
+                                   conn->passwd);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc == 0) {
+      sshc->authed = TRUE;
+      infof(data, "Initialized password authentication\n");
+      state(conn, SSH_AUTH_DONE);
+    }
+    else {
+      state(conn, SSH_AUTH_HOST_INIT);
+    }
+    break;
 
-      conn->sockfd = sock;
-      conn->writesockfd = CURL_SOCKET_BAD;
+  case SSH_AUTH_HOST_INIT:
+    if((data->set.ssh_auth_types & CURLSSH_AUTH_HOST) &&
+       (strstr(sshc->authlist, "hostbased") != NULL)) {
+      state(conn, SSH_AUTH_HOST);
+    }
+    else {
+      state(conn, SSH_AUTH_KEY_INIT);
+    }
+    break;
 
-      if (conn->protocol == PROT_SFTP) {
-        state(conn, SSH_SFTP_INIT);
-        break;
-      }
-      state(conn, SSH_GET_WORKINGPATH);
-      break;
+  case SSH_AUTH_HOST:
+    state(conn, SSH_AUTH_KEY_INIT);
+    break;
+
+  case SSH_AUTH_KEY_INIT:
+    if((data->set.ssh_auth_types & CURLSSH_AUTH_KEYBOARD)
+       && (strstr(sshc->authlist, "keyboard-interactive") != NULL)) {
+      state(conn, SSH_AUTH_KEY);
+    }
+    else {
+      state(conn, SSH_AUTH_DONE);
+    }
+    break;
 
-    case SSH_SFTP_INIT:
-      /*
-       * Start the libssh2 sftp session
-       */
-      sftp_scp->sftp_session = libssh2_sftp_init(sftp_scp->ssh_session);
-      if (!sftp_scp->sftp_session) {
-        if (libssh2_session_last_errno(sftp_scp->ssh_session) ==
-            LIBSSH2_ERROR_EAGAIN) {
-          break;
-        } else {
-          failf(data, "Failure initialising sftp session\n");
-          state(conn, SSH_SESSION_FREE);
-          sshc->actualCode = CURLE_FAILED_INIT;
-          break;
-        }
-      }
-      state(conn, SSH_SFTP_REALPATH);
+  case SSH_AUTH_KEY:
+    /* Authentication failed. Continue with keyboard-interactive now. */
+    rc = libssh2_userauth_keyboard_interactive_ex(sshc->ssh_session,
+                                                  conn->user,
+                                                  strlen(conn->user),
+                                                  &kbd_callback);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
       break;
+    }
+    else if(rc == 0) {
+      sshc->authed = TRUE;
+      infof(data, "Initialized keyboard interactive authentication\n");
+    }
+    state(conn, SSH_AUTH_DONE);
+    break;
 
-    case SSH_SFTP_REALPATH:
-      {
-        char tempHome[PATH_MAX];
-
-        /*
-         * Get the "home" directory
-         */
-        rc = libssh2_sftp_realpath(sftp_scp->sftp_session, ".",
-                                   tempHome, PATH_MAX-1);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc > 0) {
-          /* It seems that this string is not always NULL terminated */
-          tempHome[rc] = '\0';
-          sftp_scp->homedir = (char *)strdup(tempHome);
-          if (!sftp_scp->homedir) {
-            state(conn, SSH_SFTP_CLOSE);
-            sshc->actualCode = CURLE_OUT_OF_MEMORY;
-            break;
-          }
-        } else {
-          /* Return the error type */
-          result = libssh2_sftp_last_error(sftp_scp->sftp_session);
-          DEBUGF(infof(data, "error = %d\n", result));
-          state(conn, SSH_STOP);
-          break;
-        }
-        state(conn, SSH_GET_WORKINGPATH);
-      }
+  case SSH_AUTH_DONE:
+    if(!sshc->authed) {
+      failf(data, "Authentication failure");
+      state(conn, SSH_SESSION_FREE);
+      sshc->actualcode = CURLE_LOGIN_DENIED;
       break;
+    }
 
-    case SSH_GET_WORKINGPATH:
-      {
-        char *real_path;
-        char *working_path;
-        int working_path_len;
+    /*
+     * At this point we have an authenticated ssh session.
+     */
+    infof(data, "Authentication complete\n");
 
-        working_path = curl_easy_unescape(data, data->reqdata.path, 0,
-                                          &working_path_len);
-        if (!working_path) {
-          result = CURLE_OUT_OF_MEMORY;
-          state(conn, SSH_STOP);
-          break;
-        }
+    conn->sockfd = sock;
+    conn->writesockfd = CURL_SOCKET_BAD;
 
-        /* Check for /~/ , indicating relative to the user's home directory */
-        if (conn->protocol == PROT_SCP) {
-          real_path = (char *)malloc(working_path_len+1);
-          if (real_path == NULL) {
-            Curl_safefree(working_path);
-            working_path = NULL;
-            state(conn, SSH_SESSION_FREE);
-            sshc->actualCode = CURLE_OUT_OF_MEMORY;
-            break;
-          }
-          if (working_path[1] == '~')
-            /* It is referenced to the home directory, so strip the
-               leading '/' */
-            memcpy(real_path, working_path+1, 1 + working_path_len-1);
-          else
-            memcpy(real_path, working_path, 1 + working_path_len);
-        }
-        else if (conn->protocol == PROT_SFTP) {
-          if (working_path[1] == '~') {
-            real_path = (char *)malloc(strlen(sftp_scp->homedir) +
-                                       working_path_len + 1);
-            if (real_path == NULL) {
-              Curl_safefree(sftp_scp->homedir);
-              sftp_scp->homedir = NULL;
-              Curl_safefree(working_path);
-              working_path = NULL;
-              state(conn, SSH_SFTP_CLOSE);
-              sshc->actualCode = CURLE_OUT_OF_MEMORY;
-              break;
-            }
-            /* It is referenced to the home directory, so strip the
-               leading '/' */
-            memcpy(real_path, sftp_scp->homedir, strlen(sftp_scp->homedir));
-            real_path[strlen(sftp_scp->homedir)] = '/';
-            real_path[strlen(sftp_scp->homedir)+1] = '\0';
-            if (working_path_len > 3) {
-              memcpy(real_path+strlen(sftp_scp->homedir)+1, working_path + 3,
-                     1 + working_path_len -3);
-            }
-          }
-          else {
-            real_path = (char *)malloc(working_path_len+1);
-            if (real_path == NULL) {
-              Curl_safefree(sftp_scp->homedir);
-              sftp_scp->homedir = NULL;
-              Curl_safefree(working_path);
-              working_path = NULL;
-              state(conn, SSH_SFTP_CLOSE);
-              sshc->actualCode = CURLE_OUT_OF_MEMORY;
-              break;
-            }
-            memcpy(real_path, working_path, 1+working_path_len);
-          }
-        }
-        else {
-          Curl_safefree(working_path);
-          working_path = NULL;
-          state(conn, SSH_SESSION_FREE);
-          sshc->actualCode = CURLE_FAILED_INIT;
-          break;
-        }
-
-        Curl_safefree(working_path);
-        working_path = NULL;
-        sftp_scp->path = real_path;
-
-        /* Connect is all done */
-        state(conn, SSH_STOP);
-      }
+    if(conn->protocol == PROT_SFTP) {
+      state(conn, SSH_SFTP_INIT);
       break;
-
-    case SSH_SFTP_QUOTE_INIT:
-      if (data->set.quote) {
-        infof(data, "Sending quote commands\n");
-        sshc->quote_item = data->set.quote;
-        state(conn, SSH_SFTP_QUOTE);
-      } else {
-        state(conn, SSH_SFTP_TRANS_INIT);
+    }
+    infof(data, "SSH CONNECT phase done\n");
+    state(conn, SSH_STOP);
+    break;
+
+  case SSH_SFTP_INIT:
+    /*
+     * Start the libssh2 sftp session
+     */
+    sshc->sftp_session = libssh2_sftp_init(sshc->ssh_session);
+    if(!sshc->sftp_session) {
+      if(libssh2_session_last_errno(sshc->ssh_session) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else {
+        char *err_msg;
+
+        (void)libssh2_session_last_error(sshc->ssh_session,
+                                         &err_msg, NULL, 0);
+        failf(data, "Failure initializing sftp session: %s", err_msg);
+        state(conn, SSH_SESSION_FREE);
+        sshc->actualcode = CURLE_FAILED_INIT;
+        break;
       }
-      break;
+    }
+    state(conn, SSH_SFTP_REALPATH);
+    break;
 
-    case SSH_SFTP_POSTQUOTE_INIT:
-      if (data->set.postquote) {
-        infof(data, "Sending quote commands\n");
-        sshc->quote_item = data->set.postquote;
-        state(conn, SSH_SFTP_QUOTE);
-      } else {
-        state(conn, SSH_STOP);
-      }
+  case SSH_SFTP_REALPATH:
+  {
+    char tempHome[PATH_MAX];
+
+    /*
+     * Get the "home" directory
+     */
+    rc = libssh2_sftp_realpath(sshc->sftp_session, ".",
+                               tempHome, PATH_MAX-1);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
       break;
-
-    case SSH_SFTP_QUOTE:
-      /* Send any quote commands */
-      {
-        const char *cp;
-
-        /*
-         * Support some of the "FTP" commands
-         */
-        if (curl_strnequal(sshc->quote_item->data, "PWD", 3)) {
-          /* output debug output if that is requested */
-          if (data->set.verbose) {
-            char tmp[PATH_MAX+1];
-
-            Curl_debug(data, CURLINFO_HEADER_OUT, (char *)"PWD\n", 4, conn);
-            snprintf(tmp, PATH_MAX, "257 \"%s\" is current directory.\n",
-                     sftp_scp->path);
-            Curl_debug(data, CURLINFO_HEADER_IN, tmp, strlen(tmp), conn);
-          }
-          state(conn, SSH_SFTP_NEXT_QUOTE);
-          break;
-        }
-        else if (sshc->quote_item->data) {
-          fprintf(stderr, "data: %s\n", sshc->quote_item->data);
-          /*
-           * the arguments following the command must be separated from the
-           * command with a space so we can check for it unconditionally
-           */
-          cp = strchr(sshc->quote_item->data, ' ');
-          if (cp == NULL) {
-            failf(data, "Syntax error in SFTP command. Supply parameter(s)!");
-            state(conn, SSH_SFTP_CLOSE);
-            sshc->actualCode = CURLE_QUOTE_ERROR;
-            break;
-          }
-
-          /*
-           * also, every command takes at least one argument so we get that
-           * first argument right now
-           */
-          err = get_pathname(&cp, &sshc->quote_path1);
-          if (err) {
-            if (err == CURLE_OUT_OF_MEMORY)
-              failf(data, "Out of memory");
-            else
-              failf(data, "Syntax error: Bad first parameter");
-            state(conn, SSH_SFTP_CLOSE);
-            sshc->actualCode = err;
-            break;
-          }
-
-          /*
-           * SFTP is a binary protocol, so we don't send text commands to
-           * the server. Instead, we scan for commands for commands used by
-           * OpenSSH's sftp program and call the appropriate libssh2
-           * functions.
-           */
-          if (curl_strnequal(sshc->quote_item->data, "chgrp ", 6) ||
-              curl_strnequal(sshc->quote_item->data, "chmod ", 6) ||
-              curl_strnequal(sshc->quote_item->data, "chown ", 6) ) {
-            /* attribute change */
-
-            /* sshc->quote_path1 contains the mode to set */
-            /* get the destination */
-            err = get_pathname(&cp, &sshc->quote_path2);
-            if (err) {
-              if (err == CURLE_OUT_OF_MEMORY)
-                failf(data, "Out of memory");
-              else
-                failf(data, "Syntax error in chgrp/chmod/chown: "
-                      "Bad second parameter");
-              Curl_safefree(sshc->quote_path1);
-              sshc->quote_path1 = NULL;
-              state(conn, SSH_SFTP_CLOSE);
-              sshc->actualCode = err;
-              break;
-            }
-            memset(&sshc->quote_attrs, 0, sizeof(LIBSSH2_SFTP_ATTRIBUTES));
-            state(conn, SSH_SFTP_QUOTE_STAT);
-            break;
-          }
-          else if (curl_strnequal(sshc->quote_item->data, "ln ", 3) ||
-                   curl_strnequal(sshc->quote_item->data, "symlink ", 8)) {
-            /* symbolic linking */
-            /* sshc->quote_path1 is the source */
-            /* get the destination */
-            err = get_pathname(&cp, &sshc->quote_path2);
-            if (err) {
-              if (err == CURLE_OUT_OF_MEMORY)
-                failf(data, "Out of memory");
-              else
-                failf(data,
-                      "Syntax error in ln/symlink: Bad second parameter");
-              Curl_safefree(sshc->quote_path1);
-              sshc->quote_path1 = NULL;
-              state(conn, SSH_SFTP_CLOSE);
-              sshc->actualCode = err;
-              break;
-            }
-            state(conn, SSH_SFTP_QUOTE_SYMLINK);
-            break;
-          }
-          else if (curl_strnequal(sshc->quote_item->data, "mkdir ", 6)) {
-            /* create dir */
-            state(conn, SSH_SFTP_QUOTE_MKDIR);
-            break;
-          }
-          else if (curl_strnequal(sshc->quote_item->data, "rename ", 7)) {
-            /* rename file */
-            /* first param is the source path */
-            /* second param is the dest. path */
-            err = get_pathname(&cp, &sshc->quote_path2);
-            if (err) {
-              if (err == CURLE_OUT_OF_MEMORY)
-                failf(data, "Out of memory");
-              else
-                failf(data, "Syntax error in rename: Bad second parameter");
-              Curl_safefree(sshc->quote_path1);
-              sshc->quote_path1 = NULL;
-              state(conn, SSH_SFTP_CLOSE);
-              sshc->actualCode = err;
-              break;
-            }
-            state(conn, SSH_SFTP_QUOTE_RENAME);
-            break;
-          }
-          else if (curl_strnequal(sshc->quote_item->data, "rmdir ", 6)) {
-            /* delete dir */
-            state(conn, SSH_SFTP_QUOTE_RMDIR);
-            break;
-          }
-          else if (curl_strnequal(sshc->quote_item->data, "rm ", 3)) {
-            state(conn, SSH_SFTP_QUOTE_UNLINK);
-            break;
-          }
-
-          if (sshc->quote_path1) {
-            Curl_safefree(sshc->quote_path1);
-            sshc->quote_path1 = NULL;
-          }
-          if (sshc->quote_path2) {
-            Curl_safefree(sshc->quote_path2);
-            sshc->quote_path2 = NULL;
-          }
-        }
-      }
-      if (!sshc->quote_item) {
-        state(conn, SSH_SFTP_TRANS_INIT);
+    }
+    else if(rc > 0) {
+      /* It seems that this string is not always NULL terminated */
+      tempHome[rc] = '\0';
+      sshc->homedir = (char *)strdup(tempHome);
+      if(!sshc->homedir) {
+        state(conn, SSH_SFTP_CLOSE);
+        sshc->actualcode = CURLE_OUT_OF_MEMORY;
+        break;
       }
+    }
+    else {
+      /* Return the error type */
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      result = sftp_libssh2_error_to_CURLE(err);
+      DEBUGF(infof(data, "error = %d makes libcurl = %d\n", err, result));
+      state(conn, SSH_STOP);
       break;
+    }
+  }
+  /* This is the last step in the SFTP connect phase. Do note that while
+     we get the homedir here, we get the "workingpath" in the DO action
+     since the homedir will remain the same between request but the
+     working path will not. */
+  DEBUGF(infof(data, "SSH CONNECT phase done\n"));
+  state(conn, SSH_STOP);
+  break;
+
+  case SSH_SFTP_QUOTE_INIT:
+
+    result = ssh_getworkingpath(conn, sshc->homedir, &sftp_scp->path);
+    if(result) {
+      sshc->actualcode = result;
+      state(conn, SSH_STOP);
+      break;
+    }
 
-    case SSH_SFTP_NEXT_QUOTE:
-      if (sshc->quote_path1) {
-        Curl_safefree(sshc->quote_path1);
-        sshc->quote_path1 = NULL;
-      }
-      if (sshc->quote_path2) {
-        Curl_safefree(sshc->quote_path2);
-        sshc->quote_path2 = NULL;
-      }
+    if(data->set.quote) {
+      infof(data, "Sending quote commands\n");
+      sshc->quote_item = data->set.quote;
+      state(conn, SSH_SFTP_QUOTE);
+    }
+    else {
+      state(conn, SSH_SFTP_TRANS_INIT);
+    }
+    break;
 
-      sshc->quote_item = sshc->quote_item->next;
+  case SSH_SFTP_POSTQUOTE_INIT:
+    if(data->set.postquote) {
+      infof(data, "Sending quote commands\n");
+      sshc->quote_item = data->set.postquote;
+      state(conn, SSH_SFTP_QUOTE);
+    }
+    else {
+      state(conn, SSH_STOP);
+    }
+    break;
 
-      if (sshc->quote_item) {
-        state(conn, SSH_SFTP_QUOTE);
-      } else {
-        if (sshc->nextState != SSH_NO_STATE) {
-          state(conn, sshc->nextState);
-          sshc->nextState = SSH_NO_STATE;
-        } else {
-          state(conn, SSH_SFTP_TRANS_INIT);
-        }
+  case SSH_SFTP_QUOTE:
+    /* Send any quote commands */
+  {
+    const char *cp;
+
+    /*
+     * Support some of the "FTP" commands
+     */
+    if(curl_strnequal(sshc->quote_item->data, "PWD", 3)) {
+      /* output debug output if that is requested */
+      if(data->set.verbose) {
+        char tmp[PATH_MAX+1];
+
+        Curl_debug(data, CURLINFO_HEADER_OUT, (char *)"PWD\n", 4, conn);
+        snprintf(tmp, PATH_MAX, "257 \"%s\" is current directory.\n",
+                 sftp_scp->path);
+        Curl_debug(data, CURLINFO_HEADER_IN, tmp, strlen(tmp), conn);
       }
+      state(conn, SSH_SFTP_NEXT_QUOTE);
       break;
-
-    case SSH_SFTP_QUOTE_STAT:
-      rc = libssh2_sftp_stat(sftp_scp->sftp_session, sshc->quote_path2,
-                             &sshc->quote_attrs);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
+    }
+    else if(sshc->quote_item->data) {
+      fprintf(stderr, "data: %s\n", sshc->quote_item->data);
+      /*
+       * the arguments following the command must be separated from the
+       * command with a space so we can check for it unconditionally
+       */
+      cp = strchr(sshc->quote_item->data, ' ');
+      if(cp == NULL) {
+        failf(data, "Syntax error in SFTP command. Supply parameter(s)!");
+        state(conn, SSH_SFTP_CLOSE);
+        sshc->actualcode = CURLE_QUOTE_ERROR;
         break;
       }
-      else if (rc != 0) { /* get those attributes */
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-        Curl_safefree(sshc->quote_path1);
-        sshc->quote_path1 = NULL;
-        Curl_safefree(sshc->quote_path2);
-        sshc->quote_path2 = NULL;
-        failf(data, "Attempt to get SFTP stats failed: %s",
-              sftp_libssh2_strerror(err));
+
+      /*
+       * also, every command takes at least one argument so we get that
+       * first argument right now
+       */
+      err = get_pathname(&cp, &sshc->quote_path1);
+      if(err) {
+        if(err == CURLE_OUT_OF_MEMORY)
+          failf(data, "Out of memory");
+        else
+          failf(data, "Syntax error: Bad first parameter");
         state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
+        sshc->actualcode = err;
         break;
       }
 
-      /* Now set the new attributes... */
-      if (curl_strnequal(sshc->quote_item->data, "chgrp", 5)) {
-        sshc->quote_attrs.gid = strtol(sshc->quote_path1, NULL, 10);
-        if (sshc->quote_attrs.gid == 0 && !ISDIGIT(sshc->quote_path1[0])) {
+      /*
+       * SFTP is a binary protocol, so we don't send text commands to
+       * the server. Instead, we scan for commands for commands used by
+       * OpenSSH's sftp program and call the appropriate libssh2
+       * functions.
+       */
+      if(curl_strnequal(sshc->quote_item->data, "chgrp ", 6) ||
+         curl_strnequal(sshc->quote_item->data, "chmod ", 6) ||
+         curl_strnequal(sshc->quote_item->data, "chown ", 6) ) {
+        /* attribute change */
+
+        /* sshc->quote_path1 contains the mode to set */
+        /* get the destination */
+        err = get_pathname(&cp, &sshc->quote_path2);
+        if(err) {
+          if(err == CURLE_OUT_OF_MEMORY)
+            failf(data, "Out of memory");
+          else
+            failf(data, "Syntax error in chgrp/chmod/chown: "
+                  "Bad second parameter");
           Curl_safefree(sshc->quote_path1);
           sshc->quote_path1 = NULL;
-          Curl_safefree(sshc->quote_path2);
-          sshc->quote_path2 = NULL;
-          failf(data, "Syntax error: chgrp gid not a number");
           state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = CURLE_QUOTE_ERROR;
+          sshc->actualcode = err;
           break;
         }
+        memset(&sshc->quote_attrs, 0, sizeof(LIBSSH2_SFTP_ATTRIBUTES));
+        state(conn, SSH_SFTP_QUOTE_STAT);
+        break;
       }
-      else if (curl_strnequal(sshc->quote_item->data, "chmod", 5)) {
-        sshc->quote_attrs.permissions = strtol(sshc->quote_path1, NULL, 8);
-        /* permissions are octal */
-        if (sshc->quote_attrs.permissions == 0 &&
-            !ISDIGIT(sshc->quote_path1[0])) {
+      else if(curl_strnequal(sshc->quote_item->data, "ln ", 3) ||
+              curl_strnequal(sshc->quote_item->data, "symlink ", 8)) {
+        /* symbolic linking */
+        /* sshc->quote_path1 is the source */
+        /* get the destination */
+        err = get_pathname(&cp, &sshc->quote_path2);
+        if(err) {
+          if(err == CURLE_OUT_OF_MEMORY)
+            failf(data, "Out of memory");
+          else
+            failf(data,
+                  "Syntax error in ln/symlink: Bad second parameter");
           Curl_safefree(sshc->quote_path1);
           sshc->quote_path1 = NULL;
-          Curl_safefree(sshc->quote_path2);
-          sshc->quote_path2 = NULL;
-          failf(data, "Syntax error: chmod permissions not a number");
           state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = CURLE_QUOTE_ERROR;
+          sshc->actualcode = err;
           break;
         }
+        state(conn, SSH_SFTP_QUOTE_SYMLINK);
+        break;
       }
-      else if (curl_strnequal(sshc->quote_item->data, "chown", 5)) {
-        sshc->quote_attrs.uid = strtol(sshc->quote_path1, NULL, 10);
-        if (sshc->quote_attrs.uid == 0 && !ISDIGIT(sshc->quote_path1[0])) {
+      else if(curl_strnequal(sshc->quote_item->data, "mkdir ", 6)) {
+        /* create dir */
+        state(conn, SSH_SFTP_QUOTE_MKDIR);
+        break;
+      }
+      else if(curl_strnequal(sshc->quote_item->data, "rename ", 7)) {
+        /* rename file */
+        /* first param is the source path */
+        /* second param is the dest. path */
+        err = get_pathname(&cp, &sshc->quote_path2);
+        if(err) {
+          if(err == CURLE_OUT_OF_MEMORY)
+            failf(data, "Out of memory");
+          else
+            failf(data, "Syntax error in rename: Bad second parameter");
           Curl_safefree(sshc->quote_path1);
           sshc->quote_path1 = NULL;
-          Curl_safefree(sshc->quote_path2);
-          sshc->quote_path2 = NULL;
-          failf(data, "Syntax error: chown uid not a number");
           state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = CURLE_QUOTE_ERROR;
+          sshc->actualcode = err;
           break;
         }
-      }
-
-      /* Now send the completed structure... */
-      state(conn, SSH_SFTP_QUOTE_SETSTAT);
-      break;
-
-    case SSH_SFTP_QUOTE_SETSTAT:
-      rc = libssh2_sftp_setstat(sftp_scp->sftp_session, sshc->quote_path2,
-                                &sshc->quote_attrs);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
+        state(conn, SSH_SFTP_QUOTE_RENAME);
         break;
-      } else if (rc != 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-        Curl_safefree(sshc->quote_path1);
-        sshc->quote_path1 = NULL;
-        Curl_safefree(sshc->quote_path2);
-        sshc->quote_path2 = NULL;
-        failf(data, "Attempt to set SFTP stats failed: %s",
-              sftp_libssh2_strerror(err));
-        state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
+      }
+      else if(curl_strnequal(sshc->quote_item->data, "rmdir ", 6)) {
+        /* delete dir */
+        state(conn, SSH_SFTP_QUOTE_RMDIR);
         break;
       }
-      state(conn, SSH_SFTP_NEXT_QUOTE);
-      break;
-
-    case SSH_SFTP_QUOTE_SYMLINK:
-      rc = libssh2_sftp_symlink(sftp_scp->sftp_session, sshc->quote_path1,
-                                sshc->quote_path2);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
+      else if(curl_strnequal(sshc->quote_item->data, "rm ", 3)) {
+        state(conn, SSH_SFTP_QUOTE_UNLINK);
         break;
       }
-      else if (rc != 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
+
+      if(sshc->quote_path1) {
         Curl_safefree(sshc->quote_path1);
         sshc->quote_path1 = NULL;
+      }
+      if(sshc->quote_path2) {
         Curl_safefree(sshc->quote_path2);
         sshc->quote_path2 = NULL;
-        failf(data, "symlink command failed: %s",
-              sftp_libssh2_strerror(err));
-        state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
-        break;
       }
-      state(conn, SSH_SFTP_NEXT_QUOTE);
-      break;
+    }
+  }
+  if(!sshc->quote_item) {
+    state(conn, SSH_SFTP_TRANS_INIT);
+  }
+  break;
 
-    case SSH_SFTP_QUOTE_MKDIR:
-      rc = libssh2_sftp_mkdir(sftp_scp->sftp_session, sshc->quote_path1, 0755);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
-        break;
+  case SSH_SFTP_NEXT_QUOTE:
+    if(sshc->quote_path1) {
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+    }
+    if(sshc->quote_path2) {
+      Curl_safefree(sshc->quote_path2);
+      sshc->quote_path2 = NULL;
+    }
+
+    sshc->quote_item = sshc->quote_item->next;
+
+    if(sshc->quote_item) {
+      state(conn, SSH_SFTP_QUOTE);
+    }
+    else {
+      if(sshc->nextstate != SSH_NO_STATE) {
+        state(conn, sshc->nextstate);
+        sshc->nextstate = SSH_NO_STATE;
       }
-      else if (rc != 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-        Curl_safefree(sshc->quote_path1);
-        sshc->quote_path1 = NULL;
-        failf(data, "mkdir command failed: %s", sftp_libssh2_strerror(err));
-        state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
-        break;
+      else {
+        state(conn, SSH_SFTP_TRANS_INIT);
       }
-      state(conn, SSH_SFTP_NEXT_QUOTE);
+    }
+    break;
+
+  case SSH_SFTP_QUOTE_STAT:
+    rc = libssh2_sftp_stat(sshc->sftp_session, sshc->quote_path2,
+                           &sshc->quote_attrs);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc != 0) { /* get those attributes */
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      Curl_safefree(sshc->quote_path2);
+      sshc->quote_path2 = NULL;
+      failf(data, "Attempt to get SFTP stats failed: %s",
+            sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
       break;
+    }
 
-    case SSH_SFTP_QUOTE_RENAME:
-      rc = libssh2_sftp_rename(sftp_scp->sftp_session, sshc->quote_path1,
-                               sshc->quote_path2);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      } else if (rc != 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
+    /* Now set the new attributes... */
+    if(curl_strnequal(sshc->quote_item->data, "chgrp", 5)) {
+      sshc->quote_attrs.gid = strtol(sshc->quote_path1, NULL, 10);
+      if(sshc->quote_attrs.gid == 0 && !ISDIGIT(sshc->quote_path1[0])) {
         Curl_safefree(sshc->quote_path1);
         sshc->quote_path1 = NULL;
         Curl_safefree(sshc->quote_path2);
         sshc->quote_path2 = NULL;
-        failf(data, "rename command failed: %s", sftp_libssh2_strerror(err));
+        failf(data, "Syntax error: chgrp gid not a number");
         state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
-        break;
-      }
-      state(conn, SSH_SFTP_NEXT_QUOTE);
-      break;
-
-    case SSH_SFTP_QUOTE_RMDIR:
-      rc = libssh2_sftp_rmdir(sftp_scp->sftp_session, sshc->quote_path1);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
+        sshc->actualcode = CURLE_QUOTE_ERROR;
         break;
       }
-      else if (rc != 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
+    }
+    else if(curl_strnequal(sshc->quote_item->data, "chmod", 5)) {
+      sshc->quote_attrs.permissions = strtol(sshc->quote_path1, NULL, 8);
+      /* permissions are octal */
+      if(sshc->quote_attrs.permissions == 0 &&
+         !ISDIGIT(sshc->quote_path1[0])) {
         Curl_safefree(sshc->quote_path1);
         sshc->quote_path1 = NULL;
-        failf(data, "rmdir command failed: %s", sftp_libssh2_strerror(err));
+        Curl_safefree(sshc->quote_path2);
+        sshc->quote_path2 = NULL;
+        failf(data, "Syntax error: chmod permissions not a number");
         state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
-        break;
-      }
-      state(conn, SSH_SFTP_NEXT_QUOTE);
-      break;
-
-    case SSH_SFTP_QUOTE_UNLINK:
-      rc = libssh2_sftp_unlink(sftp_scp->sftp_session, sshc->quote_path1);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
+        sshc->actualcode = CURLE_QUOTE_ERROR;
         break;
       }
-      else if (rc != 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
+    }
+    else if(curl_strnequal(sshc->quote_item->data, "chown", 5)) {
+      sshc->quote_attrs.uid = strtol(sshc->quote_path1, NULL, 10);
+      if(sshc->quote_attrs.uid == 0 && !ISDIGIT(sshc->quote_path1[0])) {
         Curl_safefree(sshc->quote_path1);
         sshc->quote_path1 = NULL;
-        failf(data, "rm command failed: %s", sftp_libssh2_strerror(err));
+        Curl_safefree(sshc->quote_path2);
+        sshc->quote_path2 = NULL;
+        failf(data, "Syntax error: chown uid not a number");
         state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_QUOTE_ERROR;
+        sshc->actualcode = CURLE_QUOTE_ERROR;
         break;
       }
-      state(conn, SSH_SFTP_NEXT_QUOTE);
-      break;
+    }
 
-    case SSH_SFTP_TRANS_INIT:
-      if (data->set.upload) {
-        state(conn, SSH_SFTP_UPLOAD_INIT);
-        break;
-      } else {
-        if (sftp_scp->path[strlen(sftp_scp->path)-1] == '/') {
-          state(conn, SSH_SFTP_READDIR_INIT);
-          break;
-        } else {
-          state(conn, SSH_SFTP_DOWNLOAD_INIT);
-          break;
-        }
-      }
+    /* Now send the completed structure... */
+    state(conn, SSH_SFTP_QUOTE_SETSTAT);
+    break;
+
+  case SSH_SFTP_QUOTE_SETSTAT:
+    rc = libssh2_sftp_setstat(sshc->sftp_session, sshc->quote_path2,
+                              &sshc->quote_attrs);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
       break;
+    }
+    else if(rc != 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      Curl_safefree(sshc->quote_path2);
+      sshc->quote_path2 = NULL;
+      failf(data, "Attempt to set SFTP stats failed: %s",
+            sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
+      break;
+    }
+    state(conn, SSH_SFTP_NEXT_QUOTE);
+    break;
 
-    case SSH_SFTP_UPLOAD_INIT:
-      /*
-       * NOTE!!!  libssh2 requires that the destination path is a full path
-       *          that includes the destination file and name OR ends in a "/"
-       *          If this is not done the destination file will be named the
-       *          same name as the last directory in the path.
-       */
-      sftp_scp->sftp_handle =
-        libssh2_sftp_open(sftp_scp->sftp_session, sftp_scp->path,
-                          LIBSSH2_FXF_WRITE|LIBSSH2_FXF_CREAT|LIBSSH2_FXF_TRUNC,
-                          data->set.new_file_perms);
-      if (!sftp_scp->sftp_handle) {
-        if (libssh2_session_last_errno(sftp_scp->ssh_session) ==
-            LIBSSH2_ERROR_EAGAIN) {
-          break;
-        } else {
-          err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-          failf(data, "Upload failed: %s", sftp_libssh2_strerror(err));
-          if (sshc->secondCreateDirs) {
-            state(conn, SSH_SFTP_CLOSE);
-            sshc->actualCode = err;
-            break;
-          }
-          else if (((err == LIBSSH2_FX_NO_SUCH_FILE) ||
-                    (err == LIBSSH2_FX_FAILURE) ||
-                    (err == LIBSSH2_FX_NO_SUCH_PATH)) &&
-                   (data->set.ftp_create_missing_dirs &&
-                    (strlen(sftp_scp->path) > 1))) {
-            /* try to create the path remotely */
-            sshc->secondCreateDirs = 1;
-            state(conn, SSH_SFTP_CREATE_DIRS_INIT);
-            break;
-          }
-          state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = sftp_libssh2_error_to_CURLE(err);
-          break;
-        }
-      }
-
-      /* upload data */
-      result = Curl_setup_transfer(conn, -1, -1, FALSE, NULL,
-                                   FIRSTSOCKET, NULL);
+  case SSH_SFTP_QUOTE_SYMLINK:
+    rc = libssh2_sftp_symlink(sshc->sftp_session, sshc->quote_path1,
+                              sshc->quote_path2);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc != 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      Curl_safefree(sshc->quote_path2);
+      sshc->quote_path2 = NULL;
+      failf(data, "symlink command failed: %s",
+            sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
+      break;
+    }
+    state(conn, SSH_SFTP_NEXT_QUOTE);
+    break;
 
-      if (result) {
-        state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = result;
-      } else {
-        state(conn, SSH_STOP);
-      }
+  case SSH_SFTP_QUOTE_MKDIR:
+    rc = libssh2_sftp_mkdir(sshc->sftp_session, sshc->quote_path1, 0755);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
       break;
+    }
+    else if(rc != 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      failf(data, "mkdir command failed: %s", sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
+      break;
+    }
+    state(conn, SSH_SFTP_NEXT_QUOTE);
+    break;
 
-    case SSH_SFTP_CREATE_DIRS_INIT:
-      if (strlen(sftp_scp->path) > 1) {
-        sshc->slash_pos = sftp_scp->path + 1; /* ignore the leading '/' */
-        state(conn, SSH_SFTP_CREATE_DIRS);
-      } else {
-        state(conn, SSH_SFTP_UPLOAD_INIT);
-      }
+  case SSH_SFTP_QUOTE_RENAME:
+    rc = libssh2_sftp_rename(sshc->sftp_session, sshc->quote_path1,
+                             sshc->quote_path2);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc != 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      Curl_safefree(sshc->quote_path2);
+      sshc->quote_path2 = NULL;
+      failf(data, "rename command failed: %s", sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
       break;
+    }
+    state(conn, SSH_SFTP_NEXT_QUOTE);
+    break;
 
-    case SSH_SFTP_CREATE_DIRS:
-      if ((sshc->slash_pos = strchr(sshc->slash_pos, '/')) != NULL) {
-        *sshc->slash_pos = 0;
+  case SSH_SFTP_QUOTE_RMDIR:
+    rc = libssh2_sftp_rmdir(sshc->sftp_session, sshc->quote_path1);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc != 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      failf(data, "rmdir command failed: %s", sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
+      break;
+    }
+    state(conn, SSH_SFTP_NEXT_QUOTE);
+    break;
 
-        infof(data, "Creating directory '%s'\n", sftp_scp->path);
-        state(conn, SSH_SFTP_CREATE_DIRS_MKDIR);
-        break;
-      } else {
-        state(conn, SSH_SFTP_UPLOAD_INIT);
-      }
+  case SSH_SFTP_QUOTE_UNLINK:
+    rc = libssh2_sftp_unlink(sshc->sftp_session, sshc->quote_path1);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc != 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      Curl_safefree(sshc->quote_path1);
+      sshc->quote_path1 = NULL;
+      failf(data, "rm command failed: %s", sftp_libssh2_strerror(err));
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_QUOTE_ERROR;
       break;
+    }
+    state(conn, SSH_SFTP_NEXT_QUOTE);
+    break;
 
-    case SSH_SFTP_CREATE_DIRS_MKDIR:
-      /* 'mode' - parameter is preliminary - default to 0644 */
-      rc = libssh2_sftp_mkdir(sftp_scp->sftp_session, sftp_scp->path,
-                              data->set.new_directory_perms);
-      if (rc == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      }
-      *sshc->slash_pos = '/';
-      ++sshc->slash_pos;
-      if (rc == -1) {
-        unsigned int sftp_err = 0;
-        /*
-         * abort if failure wasn't that the dir already exists or the
-         * permission was denied (creation might succeed further
-         * down the path) - retry on unspecific FAILURE also
-         */
-        sftp_err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-        if ((sftp_err != LIBSSH2_FX_FILE_ALREADY_EXISTS) &&
-            (sftp_err != LIBSSH2_FX_FAILURE) &&
-            (sftp_err != LIBSSH2_FX_PERMISSION_DENIED)) {
-          result = sftp_libssh2_error_to_CURLE(sftp_err);
+  case SSH_SFTP_TRANS_INIT:
+    if(data->set.upload)
+      state(conn, SSH_SFTP_UPLOAD_INIT);
+    else {
+      if(sftp_scp->path[strlen(sftp_scp->path)-1] == '/')
+        state(conn, SSH_SFTP_READDIR_INIT);
+      else
+        state(conn, SSH_SFTP_DOWNLOAD_INIT);
+    }
+    break;
+
+  case SSH_SFTP_UPLOAD_INIT:
+    /*
+     * NOTE!!!  libssh2 requires that the destination path is a full path
+     *          that includes the destination file and name OR ends in a "/"
+     *          If this is not done the destination file will be named the
+     *          same name as the last directory in the path.
+     */
+    sshc->sftp_handle =
+      libssh2_sftp_open(sshc->sftp_session, sftp_scp->path,
+                        LIBSSH2_FXF_WRITE|LIBSSH2_FXF_CREAT|LIBSSH2_FXF_TRUNC,
+                        data->set.new_file_perms);
+    if(!sshc->sftp_handle) {
+      if(libssh2_session_last_errno(sshc->ssh_session) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else {
+        err = libssh2_sftp_last_error(sshc->sftp_session);
+        failf(data, "Upload failed: %s", sftp_libssh2_strerror(err));
+        if(sshc->secondCreateDirs) {
           state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = result;
+          sshc->actualcode = err;
           break;
         }
+        else if(((err == LIBSSH2_FX_NO_SUCH_FILE) ||
+                 (err == LIBSSH2_FX_FAILURE) ||
+                 (err == LIBSSH2_FX_NO_SUCH_PATH)) &&
+                (data->set.ftp_create_missing_dirs &&
+                 (strlen(sftp_scp->path) > 1))) {
+          /* try to create the path remotely */
+          sshc->secondCreateDirs = 1;
+          state(conn, SSH_SFTP_CREATE_DIRS_INIT);
+          break;
+        }
+        state(conn, SSH_SFTP_CLOSE);
+        sshc->actualcode = sftp_libssh2_error_to_CURLE(err);
+        break;
       }
+    }
+
+    /* upload data */
+    result = Curl_setup_transfer(conn, -1, -1, FALSE, NULL,
+                                 FIRSTSOCKET, NULL);
+
+    if(result) {
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = result;
+    }
+    else {
+      state(conn, SSH_STOP);
+    }
+    break;
+
+  case SSH_SFTP_CREATE_DIRS_INIT:
+    if(strlen(sftp_scp->path) > 1) {
+      sshc->slash_pos = sftp_scp->path + 1; /* ignore the leading '/' */
       state(conn, SSH_SFTP_CREATE_DIRS);
+    }
+    else {
+      state(conn, SSH_SFTP_UPLOAD_INIT);
+    }
+    break;
+
+  case SSH_SFTP_CREATE_DIRS:
+    if((sshc->slash_pos = strchr(sshc->slash_pos, '/')) != NULL) {
+      *sshc->slash_pos = 0;
+
+      infof(data, "Creating directory '%s'\n", sftp_scp->path);
+      state(conn, SSH_SFTP_CREATE_DIRS_MKDIR);
       break;
+    }
+    else {
+      state(conn, SSH_SFTP_UPLOAD_INIT);
+    }
+    break;
 
-    case SSH_SFTP_READDIR_INIT:
+  case SSH_SFTP_CREATE_DIRS_MKDIR:
+    /* 'mode' - parameter is preliminary - default to 0644 */
+    rc = libssh2_sftp_mkdir(sshc->sftp_session, sftp_scp->path,
+                            data->set.new_directory_perms);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    *sshc->slash_pos = '/';
+    ++sshc->slash_pos;
+    if(rc == -1) {
+      unsigned int sftp_err = 0;
       /*
-       * This is a directory that we are trying to get, so produce a
-       * directory listing
+       * abort if failure wasn't that the dir already exists or the
+       * permission was denied (creation might succeed further
+       * down the path) - retry on unspecific FAILURE also
        */
-      sftp_scp->sftp_handle = libssh2_sftp_opendir(sftp_scp->sftp_session,
-                                                   sftp_scp->path);
-      if (!sftp_scp->sftp_handle) {
-        if (libssh2_session_last_errno(sftp_scp->ssh_session) ==
-            LIBSSH2_ERROR_EAGAIN) {
-          break;
-        } else {
-          err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-          failf(data, "Could not open directory for reading: %s",
-                sftp_libssh2_strerror(err));
-          state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = sftp_libssh2_error_to_CURLE(err);
-          break;
-        }
-      }
-      if ((sshc->readdir_filename = (char *)malloc(PATH_MAX+1)) == NULL) {
+      sftp_err = libssh2_sftp_last_error(sshc->sftp_session);
+      if((sftp_err != LIBSSH2_FX_FILE_ALREADY_EXISTS) &&
+         (sftp_err != LIBSSH2_FX_FAILURE) &&
+         (sftp_err != LIBSSH2_FX_PERMISSION_DENIED)) {
+        result = sftp_libssh2_error_to_CURLE(sftp_err);
         state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_OUT_OF_MEMORY;
+        sshc->actualcode = result;
         break;
       }
-      if ((sshc->readdir_longentry = (char *)malloc(PATH_MAX+1)) == NULL) {
-        Curl_safefree(sshc->readdir_filename);
-        sshc->readdir_filename = NULL;
+    }
+    state(conn, SSH_SFTP_CREATE_DIRS);
+    break;
+
+  case SSH_SFTP_READDIR_INIT:
+    /*
+     * This is a directory that we are trying to get, so produce a
+     * directory listing
+     */
+    sshc->sftp_handle = libssh2_sftp_opendir(sshc->sftp_session,
+                                             sftp_scp->path);
+    if(!sshc->sftp_handle) {
+      if(libssh2_session_last_errno(sshc->ssh_session) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else {
+        err = libssh2_sftp_last_error(sshc->sftp_session);
+        failf(data, "Could not open directory for reading: %s",
+              sftp_libssh2_strerror(err));
         state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_OUT_OF_MEMORY;
+        sshc->actualcode = sftp_libssh2_error_to_CURLE(err);
         break;
       }
-      state(conn, SSH_SFTP_READDIR);
+    }
+    if((sshc->readdir_filename = (char *)malloc(PATH_MAX+1)) == NULL) {
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_OUT_OF_MEMORY;
       break;
+    }
+    if((sshc->readdir_longentry = (char *)malloc(PATH_MAX+1)) == NULL) {
+      Curl_safefree(sshc->readdir_filename);
+      sshc->readdir_filename = NULL;
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_OUT_OF_MEMORY;
+      break;
+    }
+    state(conn, SSH_SFTP_READDIR);
+    break;
 
-    case SSH_SFTP_READDIR:
-      sshc->readdir_len = libssh2_sftp_readdir_ex(sftp_scp->sftp_handle,
-                                                  sshc->readdir_filename,
-                                                  PATH_MAX,
-                                                  sshc->readdir_longentry,
-                                                  PATH_MAX,
-                                                  &sshc->readdir_attrs);
-      if (sshc->readdir_len == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      }
-      if (sshc->readdir_len > 0) {
-        sshc->readdir_filename[sshc->readdir_len] = '\0';
+  case SSH_SFTP_READDIR:
+    sshc->readdir_len = libssh2_sftp_readdir_ex(sshc->sftp_handle,
+                                                sshc->readdir_filename,
+                                                PATH_MAX,
+                                                sshc->readdir_longentry,
+                                                PATH_MAX,
+                                                &sshc->readdir_attrs);
+    if(sshc->readdir_len == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    if(sshc->readdir_len > 0) {
+      sshc->readdir_filename[sshc->readdir_len] = '\0';
+
+      if(data->set.ftp_list_only) {
+        char *tmpLine;
 
-        if (data->set.ftp_list_only) {
-          char *tmpLine;
+        tmpLine = aprintf("%s\n", sshc->readdir_filename);
+        if(tmpLine == NULL) {
+          state(conn, SSH_SFTP_CLOSE);
+          sshc->actualcode = CURLE_OUT_OF_MEMORY;
+          break;
+        }
+        result = Curl_client_write(conn, CLIENTWRITE_BODY,
+                                   tmpLine, sshc->readdir_len+1);
+        Curl_safefree(tmpLine);
 
-          tmpLine = aprintf("%s\n", sshc->readdir_filename);
-          if (tmpLine == NULL) {
-            state(conn, SSH_SFTP_CLOSE);
-            sshc->actualCode = CURLE_OUT_OF_MEMORY;
-            break;
-          }
-          result = Curl_client_write(conn, CLIENTWRITE_BODY, tmpLine, 0);
-          Curl_safefree(tmpLine);
+        if(result) {
+          state(conn, SSH_STOP);
+          break;
+        }
+        /* since this counts what we send to the client, we include the newline
+           in this counter */
+        data->req.bytecount += sshc->readdir_len+1;
+
+        /* output debug output if that is requested */
+        if(data->set.verbose) {
+          Curl_debug(data, CURLINFO_DATA_OUT, sshc->readdir_filename,
+                     sshc->readdir_len, conn);
+        }
+      }
+      else {
+        sshc->readdir_currLen = strlen(sshc->readdir_longentry);
+        sshc->readdir_totalLen = 80 + sshc->readdir_currLen;
+        sshc->readdir_line = (char *)calloc(sshc->readdir_totalLen, 1);
+        if(!sshc->readdir_line) {
+          Curl_safefree(sshc->readdir_filename);
+          sshc->readdir_filename = NULL;
+          Curl_safefree(sshc->readdir_longentry);
+          sshc->readdir_longentry = NULL;
+          state(conn, SSH_SFTP_CLOSE);
+          sshc->actualcode = CURLE_OUT_OF_MEMORY;
+          break;
+        }
 
-          /* output debug output if that is requested */
-          if (data->set.verbose) {
-            Curl_debug(data, CURLINFO_DATA_OUT, sshc->readdir_filename,
-                       sshc->readdir_len, conn);
-          }
-        } else {
-          sshc->readdir_currLen = strlen(sshc->readdir_longentry);
-          sshc->readdir_totalLen = 80 + sshc->readdir_currLen;
-          sshc->readdir_line = (char *)calloc(sshc->readdir_totalLen, 1);
-          if (!sshc->readdir_line) {
+        memcpy(sshc->readdir_line, sshc->readdir_longentry,
+               sshc->readdir_currLen);
+        if((sshc->readdir_attrs.flags & LIBSSH2_SFTP_ATTR_PERMISSIONS) &&
+           ((sshc->readdir_attrs.permissions & LIBSSH2_SFTP_S_IFMT) ==
+            LIBSSH2_SFTP_S_IFLNK)) {
+          sshc->readdir_linkPath = (char *)malloc(PATH_MAX + 1);
+          if(sshc->readdir_linkPath == NULL) {
             Curl_safefree(sshc->readdir_filename);
             sshc->readdir_filename = NULL;
             Curl_safefree(sshc->readdir_longentry);
             sshc->readdir_longentry = NULL;
             state(conn, SSH_SFTP_CLOSE);
-            sshc->actualCode = CURLE_OUT_OF_MEMORY;
+            sshc->actualcode = CURLE_OUT_OF_MEMORY;
             break;
           }
 
-          memcpy(sshc->readdir_line, sshc->readdir_longentry,
-                 sshc->readdir_currLen);
-          if ((sshc->readdir_attrs.flags & LIBSSH2_SFTP_ATTR_PERMISSIONS) &&
-              ((sshc->readdir_attrs.permissions & LIBSSH2_SFTP_S_IFMT) ==
-               LIBSSH2_SFTP_S_IFLNK)) {
-            sshc->readdir_linkPath = (char *)malloc(PATH_MAX + 1);
-            if (sshc->readdir_linkPath == NULL) {
-              Curl_safefree(sshc->readdir_filename);
-              sshc->readdir_filename = NULL;
-              Curl_safefree(sshc->readdir_longentry);
-              sshc->readdir_longentry = NULL;
-              state(conn, SSH_SFTP_CLOSE);
-              sshc->actualCode = CURLE_OUT_OF_MEMORY;
-              break;
-            }
-
-            snprintf(sshc->readdir_linkPath, PATH_MAX, "%s%s", sftp_scp->path,
-                     sshc->readdir_filename);
-            state(conn, SSH_SFTP_READDIR_LINK);
-            break;
-          }
-          state(conn, SSH_SFTP_READDIR_BOTTOM);
+          snprintf(sshc->readdir_linkPath, PATH_MAX, "%s%s", sftp_scp->path,
+                   sshc->readdir_filename);
+          state(conn, SSH_SFTP_READDIR_LINK);
           break;
         }
-      }
-      else if (sshc->readdir_len == 0) {
-        Curl_safefree(sshc->readdir_filename);
-        sshc->readdir_filename = NULL;
-        Curl_safefree(sshc->readdir_longentry);
-        sshc->readdir_longentry = NULL;
-        state(conn, SSH_SFTP_READDIR_DONE);
-        break;
-      }
-      else if (sshc->readdir_len <= 0) {
-        err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-        sshc->actualCode = err;
-        failf(data, "Could not open remote file for reading: %s :: %d",
-              sftp_libssh2_strerror(err),
-              libssh2_session_last_errno(sftp_scp->ssh_session));
-        Curl_safefree(sshc->readdir_filename);
-        sshc->readdir_filename = NULL;
-        Curl_safefree(sshc->readdir_longentry);
-        sshc->readdir_longentry = NULL;
-        state(conn, SSH_SFTP_CLOSE);
+        state(conn, SSH_SFTP_READDIR_BOTTOM);
         break;
       }
+    }
+    else if(sshc->readdir_len == 0) {
+      Curl_safefree(sshc->readdir_filename);
+      sshc->readdir_filename = NULL;
+      Curl_safefree(sshc->readdir_longentry);
+      sshc->readdir_longentry = NULL;
+      state(conn, SSH_SFTP_READDIR_DONE);
       break;
+    }
+    else if(sshc->readdir_len <= 0) {
+      err = libssh2_sftp_last_error(sshc->sftp_session);
+      sshc->actualcode = err;
+      failf(data, "Could not open remote file for reading: %s :: %d",
+            sftp_libssh2_strerror(err),
+            libssh2_session_last_errno(sshc->ssh_session));
+      Curl_safefree(sshc->readdir_filename);
+      sshc->readdir_filename = NULL;
+      Curl_safefree(sshc->readdir_longentry);
+      sshc->readdir_longentry = NULL;
+      state(conn, SSH_SFTP_CLOSE);
+      break;
+    }
+    break;
 
-    case SSH_SFTP_READDIR_LINK:
-      sshc->readdir_len = libssh2_sftp_readlink(sftp_scp->sftp_session,
-                                                sshc->readdir_linkPath,
-                                                sshc->readdir_filename,
-                                                PATH_MAX);
-      if (sshc->readdir_len == LIBSSH2_ERROR_EAGAIN) {
-        break;
-      }
-      Curl_safefree(sshc->readdir_linkPath);
-      sshc->readdir_linkPath = NULL;
-      sshc->readdir_line = realloc(sshc->readdir_line,
-                                   sshc->readdir_totalLen + 4 +
-                                   sshc->readdir_len);
-      if (!sshc->readdir_line) {
-        Curl_safefree(sshc->readdir_filename);
-        sshc->readdir_filename = NULL;
-        Curl_safefree(sshc->readdir_longentry);
-        sshc->readdir_longentry = NULL;
-        state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = CURLE_OUT_OF_MEMORY;
-        break;
-      }
-
-      sshc->readdir_currLen += snprintf(sshc->readdir_line +
-                                        sshc->readdir_currLen,
-                                        sshc->readdir_totalLen -
-                                        sshc->readdir_currLen,
-                                        " -> %s",
-                                        sshc->readdir_filename);
-
-      state(conn, SSH_SFTP_READDIR_BOTTOM);
+  case SSH_SFTP_READDIR_LINK:
+    sshc->readdir_len = libssh2_sftp_readlink(sshc->sftp_session,
+                                              sshc->readdir_linkPath,
+                                              sshc->readdir_filename,
+                                              PATH_MAX);
+    if(sshc->readdir_len == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    Curl_safefree(sshc->readdir_linkPath);
+    sshc->readdir_linkPath = NULL;
+    sshc->readdir_line = realloc(sshc->readdir_line,
+                                 sshc->readdir_totalLen + 4 +
+                                 sshc->readdir_len);
+    if(!sshc->readdir_line) {
+      Curl_safefree(sshc->readdir_filename);
+      sshc->readdir_filename = NULL;
+      Curl_safefree(sshc->readdir_longentry);
+      sshc->readdir_longentry = NULL;
+      state(conn, SSH_SFTP_CLOSE);
+      sshc->actualcode = CURLE_OUT_OF_MEMORY;
       break;
+    }
 
-    case SSH_SFTP_READDIR_BOTTOM:
-      sshc->readdir_currLen += snprintf(sshc->readdir_line +
-                                        sshc->readdir_currLen,
-                                        sshc->readdir_totalLen -
-                                        sshc->readdir_currLen, "\n");
-      result = Curl_client_write(conn, CLIENTWRITE_BODY,
-                                 sshc->readdir_line, 0);
+    sshc->readdir_currLen += snprintf(sshc->readdir_line +
+                                      sshc->readdir_currLen,
+                                      sshc->readdir_totalLen -
+                                      sshc->readdir_currLen,
+                                      " -> %s",
+                                      sshc->readdir_filename);
+
+    state(conn, SSH_SFTP_READDIR_BOTTOM);
+    break;
+
+  case SSH_SFTP_READDIR_BOTTOM:
+    sshc->readdir_currLen += snprintf(sshc->readdir_line +
+                                      sshc->readdir_currLen,
+                                      sshc->readdir_totalLen -
+                                      sshc->readdir_currLen, "\n");
+    result = Curl_client_write(conn, CLIENTWRITE_BODY,
+                               sshc->readdir_line,
+                               sshc->readdir_currLen);
+
+    if(result == CURLE_OK) {
 
       /* output debug output if that is requested */
-      if (data->set.verbose) {
+      if(data->set.verbose) {
         Curl_debug(data, CURLINFO_DATA_OUT, sshc->readdir_line,
                    sshc->readdir_currLen, conn);
       }
-      Curl_safefree(sshc->readdir_line);
-      sshc->readdir_line = NULL;
+      data->req.bytecount += sshc->readdir_currLen;
+    }
+    Curl_safefree(sshc->readdir_line);
+    sshc->readdir_line = NULL;
+    if(result) {
+      state(conn, SSH_STOP);
+    }
+    else
       state(conn, SSH_SFTP_READDIR);
-      break;
+    break;
 
-    case SSH_SFTP_READDIR_DONE:
-      if (libssh2_sftp_closedir(sftp_scp->sftp_handle) ==
-          LIBSSH2_ERROR_EAGAIN) {
+  case SSH_SFTP_READDIR_DONE:
+    if(libssh2_sftp_closedir(sshc->sftp_handle) ==
+       LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    sshc->sftp_handle = NULL;
+    Curl_safefree(sshc->readdir_filename);
+    sshc->readdir_filename = NULL;
+    Curl_safefree(sshc->readdir_longentry);
+    sshc->readdir_longentry = NULL;
+
+    /* no data to transfer */
+    result = Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
+    state(conn, SSH_STOP);
+    break;
+
+  case SSH_SFTP_DOWNLOAD_INIT:
+    /*
+     * Work on getting the specified file
+     */
+    sshc->sftp_handle =
+      libssh2_sftp_open(sshc->sftp_session, sftp_scp->path,
+                        LIBSSH2_FXF_READ, data->set.new_file_perms);
+    if(!sshc->sftp_handle) {
+      if(libssh2_session_last_errno(sshc->ssh_session) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else {
+        err = libssh2_sftp_last_error(sshc->sftp_session);
+        failf(data, "Could not open remote file for reading: %s",
+              sftp_libssh2_strerror(err));
+        state(conn, SSH_SFTP_CLOSE);
+        sshc->actualcode = sftp_libssh2_error_to_CURLE(err);
         break;
       }
-      sftp_scp->sftp_handle = NULL;
-      Curl_safefree(sshc->readdir_filename);
-      sshc->readdir_filename = NULL;
-      Curl_safefree(sshc->readdir_longentry);
-      sshc->readdir_longentry = NULL;
+    }
+    state(conn, SSH_SFTP_DOWNLOAD_STAT);
+    break;
 
-      /* no data to transfer */
-      result = Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
-      state(conn, SSH_STOP);
-      break;
+  case SSH_SFTP_DOWNLOAD_STAT:
+  {
+    LIBSSH2_SFTP_ATTRIBUTES attrs;
 
-    case SSH_SFTP_DOWNLOAD_INIT:
+    rc = libssh2_sftp_stat(sshc->sftp_session, sftp_scp->path, &attrs);
+    if(rc == LIBSSH2_ERROR_EAGAIN) {
+      break;
+    }
+    else if(rc) {
       /*
-       * Work on getting the specified file
+       * libssh2_sftp_open() didn't return an error, so maybe the server
+       * just doesn't support stat()
        */
-      sftp_scp->sftp_handle =
-        libssh2_sftp_open(sftp_scp->sftp_session, sftp_scp->path,
-                          LIBSSH2_FXF_READ, data->set.new_file_perms);
-      if (!sftp_scp->sftp_handle) {
-        if (libssh2_session_last_errno(sftp_scp->ssh_session) ==
-             LIBSSH2_ERROR_EAGAIN) {
-          break;
-        } else {
-          err = libssh2_sftp_last_error(sftp_scp->sftp_session);
-          failf(data, "Could not open remote file for reading: %s",
-                sftp_libssh2_strerror(err));
-          state(conn, SSH_SFTP_CLOSE);
-          sshc->actualCode = sftp_libssh2_error_to_CURLE(err);
-          break;
-        }
-      }
-      state(conn, SSH_SFTP_DOWNLOAD_STAT);
-      break;
+      data->req.size = -1;
+      data->req.maxdownload = -1;
+    }
+    else {
+      data->req.size = attrs.filesize;
+      data->req.maxdownload = attrs.filesize;
+      Curl_pgrsSetDownloadSize(data, attrs.filesize);
+    }
+  }
 
-    case SSH_SFTP_DOWNLOAD_STAT:
-      {
-        LIBSSH2_SFTP_ATTRIBUTES attrs;
+  /* Setup the actual download */
+  result = Curl_setup_transfer(conn, FIRSTSOCKET, data->req.size,
+                               FALSE, NULL, -1, NULL);
+  if(result) {
+    state(conn, SSH_SFTP_CLOSE);
+    sshc->actualcode = result;
+  }
+  else {
+    state(conn, SSH_STOP);
+  }
+  break;
 
-        rc = libssh2_sftp_stat(sftp_scp->sftp_session, sftp_scp->path, &attrs);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc) {
-          /*
-           * libssh2_sftp_open() didn't return an error, so maybe the server
-           * just doesn't support stat()
-           */
-          data->reqdata.size = -1;
-          data->reqdata.maxdownload = -1;
-        } else {
-          data->reqdata.size = attrs.filesize;
-          data->reqdata.maxdownload = attrs.filesize;
-          Curl_pgrsSetDownloadSize(data, attrs.filesize);
-        }
+  case SSH_SFTP_CLOSE:
+    if(sshc->sftp_handle) {
+      rc = libssh2_sftp_close(sshc->sftp_handle);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
-
-      /* Setup the actual download */
-      result = Curl_setup_transfer(conn, FIRSTSOCKET, data->reqdata.size,
-                                   FALSE, NULL, -1, NULL);
-      if (result) {
-        state(conn, SSH_SFTP_CLOSE);
-        sshc->actualCode = result;
-      } else {
-        state(conn, SSH_STOP);
+      else if(rc < 0) {
+        infof(data, "Failed to close libssh2 file\n");
       }
-      break;
+      sshc->sftp_handle = NULL;
+    }
+    Curl_safefree(sftp_scp->path);
+    sftp_scp->path = NULL;
 
-    case SSH_SFTP_CLOSE:
-      if (sftp_scp->sftp_handle) {
-        rc = libssh2_sftp_close(sftp_scp->sftp_handle);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc < 0) {
-          infof(data, "Failed to close libssh2 file\n");
-        }
-        sftp_scp->sftp_handle = NULL;
-      }
-      state(conn, SSH_SFTP_SHUTDOWN);
-      break;
+    DEBUGF(infof(data, "SFTP DONE done\n"));
+#if 0 /* PREV */
+    state(conn, SSH_SFTP_SHUTDOWN);
+#endif
+    state(conn, SSH_STOP);
+    result = sshc->actualcode;
+    break;
 
-    case SSH_SFTP_SHUTDOWN:
-      if (sftp_scp->sftp_session) {
-        rc = libssh2_sftp_shutdown(sftp_scp->sftp_session);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc < 0) {
-          infof(data, "Failed to stop libssh2 sftp subsystem\n");
-        }
-        sftp_scp->sftp_session = NULL;
+  case SSH_SFTP_SHUTDOWN:
+    if(sshc->sftp_session) {
+      rc = libssh2_sftp_shutdown(sshc->sftp_session);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
+      else if(rc < 0) {
+        infof(data, "Failed to stop libssh2 sftp subsystem\n");
+      }
+      sshc->sftp_session = NULL;
+    }
 
-      Curl_safefree(sftp_scp->path);
-      sftp_scp->path = NULL;
-
-      Curl_safefree(sftp_scp->homedir);
-      sftp_scp->homedir = NULL;
+    Curl_safefree(sshc->homedir);
+    sshc->homedir = NULL;
 
-      state(conn, SSH_CHANNEL_CLOSE);
-      break;
+    state(conn, SSH_SESSION_DISCONNECT);
+    break;
 
-    case SSH_SCP_TRANS_INIT:
-      if (data->set.upload) {
-        if (data->set.infilesize < 0) {
-          failf(data, "SCP requires a known file size for upload");
-          sshc->actualCode = CURLE_UPLOAD_FAILED;
-          state(conn, SSH_SCP_CHANNEL_FREE);
-          break;
-        }
-        state(conn, SSH_SCP_UPLOAD_INIT);
-      } else {
-        state(conn, SSH_SCP_DOWNLOAD_INIT);
-      }
+  case SSH_SCP_TRANS_INIT:
+    result = ssh_getworkingpath(conn, sshc->homedir, &sftp_scp->path);
+    if(result) {
+      sshc->actualcode = result;
+      state(conn, SSH_STOP);
       break;
+    }
 
-    case SSH_SCP_UPLOAD_INIT:
-      /*
-       * libssh2 requires that the destination path is a full path that
-       * includes the destination file and name OR ends in a "/" .  If this is
-       * not done the destination file will be named the same name as the last
-       * directory in the path.
-       */
-      sftp_scp->ssh_channel =
-                  libssh2_scp_send_ex(sftp_scp->ssh_session, sftp_scp->path,
-                                      data->set.new_file_perms,
-                                      data->set.infilesize, 0, 0);
-      if (!sftp_scp->ssh_channel) {
-        if (libssh2_session_last_errno(sftp_scp->ssh_session) ==
-            LIBSSH2_ERROR_EAGAIN) {
-          break;
-        } else {
-          int ssh_err;
-          char *err_msg;
-
-          ssh_err = libssh2_session_last_error(sftp_scp->ssh_session,
-                                               &err_msg, NULL, 0);
-          err = libssh2_session_error_to_CURLE(ssh_err);
-          failf(conn->data, "%s", err_msg);
-          state(conn, SSH_SCP_CHANNEL_FREE);
-          sshc->actualCode = err;
-          break;
-        }
+    if(data->set.upload) {
+      if(data->set.infilesize < 0) {
+        failf(data, "SCP requires a known file size for upload");
+        sshc->actualcode = CURLE_UPLOAD_FAILED;
+        state(conn, SSH_SCP_CHANNEL_FREE);
+        break;
       }
+      state(conn, SSH_SCP_UPLOAD_INIT);
+    }
+    else {
+      state(conn, SSH_SCP_DOWNLOAD_INIT);
+    }
+    break;
 
-      /* upload data */
-      result = Curl_setup_transfer(conn, -1, data->reqdata.size, FALSE, NULL,
-                                   FIRSTSOCKET, NULL);
-
-      if (result) {
+  case SSH_SCP_UPLOAD_INIT:
+    /*
+     * libssh2 requires that the destination path is a full path that
+     * includes the destination file and name OR ends in a "/" .  If this is
+     * not done the destination file will be named the same name as the last
+     * directory in the path.
+     */
+    sshc->ssh_channel =
+      libssh2_scp_send_ex(sshc->ssh_session, sftp_scp->path,
+                          data->set.new_file_perms,
+                          data->set.infilesize, 0, 0);
+    if(!sshc->ssh_channel) {
+      if(libssh2_session_last_errno(sshc->ssh_session) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else {
+        int ssh_err;
+        char *err_msg;
+
+        ssh_err = libssh2_session_last_error(sshc->ssh_session,
+                                             &err_msg, NULL, 0);
+        err = libssh2_session_error_to_CURLE(ssh_err);
+        failf(conn->data, "%s", err_msg);
         state(conn, SSH_SCP_CHANNEL_FREE);
-        sshc->actualCode = result;
-      } else {
-        state(conn, SSH_STOP);
+        sshc->actualcode = err;
+        break;
       }
-      break;
+    }
 
-    case SSH_SCP_DOWNLOAD_INIT:
-      {
-        /*
-         * We must check the remote file; if it is a directory no values will
-         * be set in sb
-         */
-        struct stat sb;
-        curl_off_t bytecount;
-
-        memset(&sb, 0, sizeof(struct stat));
-        sftp_scp->ssh_channel = libssh2_scp_recv(sftp_scp->ssh_session,
-                                                 sftp_scp->path, &sb);
-        if (!sftp_scp->ssh_channel) {
-          if (libssh2_session_last_errno(sftp_scp->ssh_session) ==
-             LIBSSH2_ERROR_EAGAIN) {
-            break;
-          } else {
-            int ssh_err;
-            char *err_msg;
-
-            ssh_err = libssh2_session_last_error(sftp_scp->ssh_session,
-                                                 &err_msg, NULL, 0);
-            err = libssh2_session_error_to_CURLE(ssh_err);
-            failf(conn->data, "%s", err_msg);
-            state(conn, SSH_SCP_CHANNEL_FREE);
-            sshc->actualCode = err;
-            break;
-          }
-        }
+    /* upload data */
+    result = Curl_setup_transfer(conn, -1, data->req.size, FALSE, NULL,
+                                 FIRSTSOCKET, NULL);
 
-        /* download data */
-        bytecount = (curl_off_t)sb.st_size;
-        data->reqdata.maxdownload =  (curl_off_t)sb.st_size;
-        result = Curl_setup_transfer(conn, FIRSTSOCKET,
-                                     bytecount, FALSE, NULL, -1, NULL);
-
-        if (result) {
-          state(conn, SSH_SCP_CHANNEL_FREE);
-          sshc->actualCode = result;
-        } else {
-          state(conn, SSH_STOP);
-        }
-      }
-      break;
+    if(result) {
+      state(conn, SSH_SCP_CHANNEL_FREE);
+      sshc->actualcode = result;
+    }
+    else {
+      state(conn, SSH_STOP);
+    }
+    break;
 
-    case SSH_SCP_DONE:
-      if (data->set.upload) {
-        state(conn, SSH_SCP_SEND_EOF);
-      } else {
+  case SSH_SCP_DOWNLOAD_INIT:
+  {
+    /*
+     * We must check the remote file; if it is a directory no values will
+     * be set in sb
+     */
+    struct stat sb;
+    curl_off_t bytecount;
+
+    /* clear the struct scp recv will fill in */
+    memset(&sb, 0, sizeof(struct stat));
+
+    /* get a fresh new channel from the ssh layer */
+    sshc->ssh_channel = libssh2_scp_recv(sshc->ssh_session,
+                                         sftp_scp->path, &sb);
+    if(!sshc->ssh_channel) {
+      if(libssh2_session_last_errno(sshc->ssh_session) ==
+         LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else {
+        int ssh_err;
+        char *err_msg;
+
+        ssh_err = libssh2_session_last_error(sshc->ssh_session,
+                                             &err_msg, NULL, 0);
+        err = libssh2_session_error_to_CURLE(ssh_err);
+        failf(conn->data, "%s", err_msg);
         state(conn, SSH_SCP_CHANNEL_FREE);
+        sshc->actualcode = err;
+        break;
       }
-      break;
+    }
 
-    case SSH_SCP_SEND_EOF:
-      if (sftp_scp->ssh_channel) {
-        rc = libssh2_channel_send_eof(sftp_scp->ssh_channel);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc) {
-          infof(data, "Failed to send libssh2 channel EOF\n");
-        }
-      }
-      state(conn, SSH_SCP_WAIT_EOF);
-      break;
+    /* download data */
+    bytecount = (curl_off_t)sb.st_size;
+    data->req.maxdownload =  (curl_off_t)sb.st_size;
+    result = Curl_setup_transfer(conn, FIRSTSOCKET,
+                                 bytecount, FALSE, NULL, -1, NULL);
 
-    case SSH_SCP_WAIT_EOF:
-      if (sftp_scp->ssh_channel) {
-        rc = libssh2_channel_wait_eof(sftp_scp->ssh_channel);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc) {
-          infof(data, "Failed to get channel EOF\n");
-        }
-      }
-      state(conn, SSH_SCP_WAIT_CLOSE);
-      break;
+    if(result) {
+      state(conn, SSH_SCP_CHANNEL_FREE);
+      sshc->actualcode = result;
+    }
+    else
+      state(conn, SSH_STOP);
+  }
+  break;
 
-    case SSH_SCP_WAIT_CLOSE:
-      if (sftp_scp->ssh_channel) {
-        rc = libssh2_channel_wait_closed(sftp_scp->ssh_channel);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc) {
-          infof(data, "Channel failed to close\n");
-        }
-      }
+  case SSH_SCP_DONE:
+    if(data->set.upload)
+      state(conn, SSH_SCP_SEND_EOF);
+    else
       state(conn, SSH_SCP_CHANNEL_FREE);
-      break;
+    break;
 
-    case SSH_SCP_CHANNEL_FREE:
-      if (sftp_scp->ssh_channel) {
-        rc = libssh2_channel_free(sftp_scp->ssh_channel);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc < 0) {
-          infof(data, "Failed to free libssh2 scp subsystem\n");
-        }
-        sftp_scp->ssh_channel = NULL;
+  case SSH_SCP_SEND_EOF:
+    if(sshc->ssh_channel) {
+      rc = libssh2_channel_send_eof(sshc->ssh_channel);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
-      state(conn, SSH_SESSION_DISCONECT);
-      break;
+      else if(rc) {
+        infof(data, "Failed to send libssh2 channel EOF\n");
+      }
+    }
+    state(conn, SSH_SCP_WAIT_EOF);
+    break;
 
-    case SSH_CHANNEL_CLOSE:
-      if (sftp_scp->ssh_channel) {
-        rc = libssh2_channel_close(sftp_scp->ssh_channel);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc < 0) {
-          infof(data, "Failed to stop libssh2 channel subsystem\n");
-        }
-        sftp_scp->ssh_channel = NULL;
+  case SSH_SCP_WAIT_EOF:
+    if(sshc->ssh_channel) {
+      rc = libssh2_channel_wait_eof(sshc->ssh_channel);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
-      state(conn, SSH_SESSION_DISCONECT);
-      break;
+      else if(rc) {
+        infof(data, "Failed to get channel EOF: %d\n", rc);
+      }
+    }
+    state(conn, SSH_SCP_WAIT_CLOSE);
+    break;
 
-    case SSH_SESSION_DISCONECT:
-      if (sftp_scp->ssh_session) {
-        rc = libssh2_session_disconnect(sftp_scp->ssh_session, "Shutdown");
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc < 0) {
-          infof(data, "Failed to disconnect libssh2 session\n");
-        }
+  case SSH_SCP_WAIT_CLOSE:
+    if(sshc->ssh_channel) {
+      rc = libssh2_channel_wait_closed(sshc->ssh_channel);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
+      else if(rc) {
+        infof(data, "Channel failed to close: %d\n", rc);
+      }
+    }
+    state(conn, SSH_SCP_CHANNEL_FREE);
+    break;
 
-      Curl_safefree(sftp_scp->path);
-      sftp_scp->path = NULL;
+  case SSH_SCP_CHANNEL_FREE:
+    if(sshc->ssh_channel) {
+      rc = libssh2_channel_free(sshc->ssh_channel);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else if(rc < 0) {
+        infof(data, "Failed to free libssh2 scp subsystem\n");
+      }
+      sshc->ssh_channel = NULL;
+    }
+    DEBUGF(infof(data, "SCP DONE phase complete\n"));
+#if 0 /* PREV */
+    state(conn, SSH_SESSION_DISCONNECT);
+#endif
+    state(conn, SSH_STOP);
+    result = sshc->actualcode;
+    break;
+
+  case SSH_SESSION_DISCONNECT:
+    if(sshc->ssh_session) {
+      rc = libssh2_session_disconnect(sshc->ssh_session, "Shutdown");
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
+      }
+      else if(rc < 0) {
+        infof(data, "Failed to disconnect libssh2 session\n");
+      }
+    }
 
-      Curl_safefree(sftp_scp->homedir);
-      sftp_scp->homedir = NULL;
+    Curl_safefree(sshc->homedir);
+    sshc->homedir = NULL;
 
-      state(conn, SSH_SESSION_FREE);
-      break;
+    state(conn, SSH_SESSION_FREE);
+    break;
 
-    case SSH_SESSION_FREE:
-      if (sftp_scp->ssh_session) {
-        rc = libssh2_session_free(sftp_scp->ssh_session);
-        if (rc == LIBSSH2_ERROR_EAGAIN) {
-          break;
-        }
-        else if (rc < 0) {
-          infof(data, "Failed to free libssh2 session\n");
-        }
-        sftp_scp->ssh_session = NULL;
+  case SSH_SESSION_FREE:
+    if(sshc->ssh_session) {
+      rc = libssh2_session_free(sshc->ssh_session);
+      if(rc == LIBSSH2_ERROR_EAGAIN) {
+        break;
       }
-      sshc->nextState = SSH_NO_STATE;
-      state(conn, SSH_STOP);
-      result = sshc->actualCode;
-      break;
-
-    case SSH_QUIT:
-      /* fallthrough, just stop! */
-    default:
-      /* internal error */
-      sshc->nextState = SSH_NO_STATE;
-      state(conn, SSH_STOP);
-      break;
+      else if(rc < 0) {
+        infof(data, "Failed to free libssh2 session\n");
+      }
+      sshc->ssh_session = NULL;
+    }
+    sshc->nextstate = SSH_NO_STATE;
+    state(conn, SSH_STOP);
+    result = sshc->actualcode;
+    break;
+
+  case SSH_QUIT:
+    /* fallthrough, just stop! */
+  default:
+    /* internal error */
+    sshc->nextstate = SSH_NO_STATE;
+    state(conn, SSH_STOP);
+    break;
   }
 
   return result;
 }
 
 /* called repeatedly until done from multi.c */
-static CURLcode Curl_ssh_multi_statemach(struct connectdata *conn, bool *done)
+static CURLcode ssh_multi_statemach(struct connectdata *conn, bool *done)
 {
   struct ssh_conn *sshc = &conn->proto.sshc;
   CURLcode result = CURLE_OK;
 
   result = ssh_statemach_act(conn);
   *done = (bool)(sshc->state == SSH_STOP);
@@ -1789,88 +1837,74 @@
 
 static CURLcode ssh_easy_statemach(struct connectdata *conn)
 {
   struct ssh_conn *sshc = &conn->proto.sshc;
   CURLcode result = CURLE_OK;
 
-  while (sshc->state != SSH_STOP) {
+  while((sshc->state != SSH_STOP) && !result)
     result = ssh_statemach_act(conn);
-    if (result) {
-      break;
-    }
-  }
 
   return result;
 }
 
 /*
  * SSH setup and connection
  */
 static CURLcode ssh_init(struct connectdata *conn)
 {
   struct SessionHandle *data = conn->data;
   struct SSHPROTO *ssh;
-  if (data->reqdata.proto.ssh)
+  if(data->state.proto.ssh)
     return CURLE_OK;
 
   ssh = (struct SSHPROTO *)calloc(sizeof(struct SSHPROTO), 1);
-  if (!ssh)
+  if(!ssh)
     return CURLE_OUT_OF_MEMORY;
 
-  data->reqdata.proto.ssh = ssh;
-
-  /* get some initial data into the ssh struct */
-  ssh->bytecountp = &data->reqdata.keep.bytecount;
-
-  /* no need to duplicate them, this connectdata struct won't change */
-  ssh->user = conn->user;
-  ssh->passwd = conn->passwd;
-
-  ssh->errorstr = NULL;
-
-  ssh->ssh_session = NULL;
-  ssh->ssh_channel = NULL;
-  ssh->sftp_session = NULL;
-  ssh->sftp_handle = NULL;
+  data->state.proto.ssh = ssh;
 
   return CURLE_OK;
 }
 
 /*
  * Curl_ssh_connect() gets called from Curl_protocol_connect() to allow us to
  * do protocol-specific actions at connect-time.
  */
-static CURLcode Curl_ssh_connect(struct connectdata *conn, bool *done)
+static CURLcode ssh_connect(struct connectdata *conn, bool *done)
 {
-  struct SSHPROTO *ssh;
+  struct ssh_conn *ssh;
   curl_socket_t sock;
   CURLcode result;
   struct SessionHandle *data = conn->data;
 
+  /* We default to persistent connections. We set this already in this connect
+     function to make the re-use checks properly be able to check this bit. */
+  conn->bits.close = FALSE;
+
   /* If there already is a protocol-specific struct allocated for this
      sessionhandle, deal with it */
   Curl_reset_reqproto(conn);
 
   result = ssh_init(conn);
-  if (result)
+  if(result)
     return result;
 
-  ssh = data->reqdata.proto.ssh;
+  ssh = &conn->proto.sshc;
 
 #ifdef CURL_LIBSSH2_DEBUG
-  if (ssh->user) {
-    infof(data, "User: %s\n", ssh->user);
+  if(conn->user) {
+    infof(data, "User: %s\n", conn->user);
   }
-  if (ssh->passwd) {
-    infof(data, "Password: %s\n", ssh->passwd);
+  if(conn->passwd) {
+    infof(data, "Password: %s\n", conn->passwd);
   }
 #endif /* CURL_LIBSSH2_DEBUG */
   sock = conn->sock[FIRSTSOCKET];
   ssh->ssh_session = libssh2_session_init_ex(libssh2_malloc, libssh2_free,
-                                             libssh2_realloc, ssh);
-  if (ssh->ssh_session == NULL) {
+                                             libssh2_realloc, conn);
+  if(ssh->ssh_session == NULL) {
     failf(data, "Failure initialising ssh session");
     return CURLE_FAILED_INIT;
   }
 
 #ifdef CURL_LIBSSH2_DEBUG
   libssh2_trace(ssh->ssh_session, LIBSSH2_TRACE_CONN|LIBSSH2_TRACE_TRANS|
@@ -1879,17 +1913,17 @@
                 LIBSSH2_TRACE_PUBLICKEY);
   infof(data, "SSH socket: %d\n", sock);
 #endif /* CURL_LIBSSH2_DEBUG */
 
   state(conn, SSH_S_STARTUP);
 
-  if (data->state.used_interface == Curl_if_multi)
-    result = Curl_ssh_multi_statemach(conn, done);
+  if(data->state.used_interface == Curl_if_multi)
+    result = ssh_multi_statemach(conn, done);
   else {
     result = ssh_easy_statemach(conn);
-    if (!result)
+    if(!result)
       *done = TRUE;
   }
 
   return result;
 }
 
@@ -1914,130 +1948,134 @@
   *dophase_done = FALSE; /* not done yet */
 
   /* start the first command in the DO phase */
   state(conn, SSH_SCP_TRANS_INIT);
 
   /* run the state-machine */
-  if (conn->data->state.used_interface == Curl_if_multi) {
-    result = Curl_ssh_multi_statemach(conn, dophase_done);
-  } else {
+  if(conn->data->state.used_interface == Curl_if_multi) {
+    result = ssh_multi_statemach(conn, dophase_done);
+  }
+  else {
     result = ssh_easy_statemach(conn);
     *dophase_done = TRUE; /* with the easy interface we are done here */
   }
   *connected = conn->bits.tcpconnect;
 
-  if (*dophase_done) {
+  if(*dophase_done) {
     DEBUGF(infof(conn->data, "DO phase is complete\n"));
   }
 
   return result;
 }
 
 /* called from multi.c while DOing */
-static CURLcode Curl_scp_doing(struct connectdata *conn,
+static CURLcode scp_doing(struct connectdata *conn,
                                bool *dophase_done)
 {
   CURLcode result;
-  result = Curl_ssh_multi_statemach(conn, dophase_done);
+  result = ssh_multi_statemach(conn, dophase_done);
 
-  if (*dophase_done) {
+  if(*dophase_done) {
     DEBUGF(infof(conn->data, "DO phase is complete\n"));
   }
   return result;
 }
 
+/*
+ * The DO function is generic for both protocols. There was previously two
+ * separate ones but this way means less duplicated code.
+ */
 
-static CURLcode Curl_scp_do(struct connectdata *conn, bool *done)
+static CURLcode ssh_do(struct connectdata *conn, bool *done)
 {
   CURLcode res;
   bool connected = 0;
   struct SessionHandle *data = conn->data;
 
   *done = FALSE; /* default to false */
 
-  /*
-   * Since connections can be re-used between SessionHandles, this might be a
-   * connection already existing but on a fresh SessionHandle struct so we must
-   * make sure we have a good 'struct SSHPROTO' to play with. For new
-   * connections, the struct SSHPROTO is allocated and setup in the
-   * Curl_ssh_connect() function.
-   */
-  res = ssh_init(conn);
-  if (res) {
-    return res;
-  }
-
-  data->reqdata.size = -1; /* make sure this is unknown at this point */
+  data->req.size = -1; /* make sure this is unknown at this point */
 
   Curl_pgrsSetUploadCounter(data, 0);
   Curl_pgrsSetDownloadCounter(data, 0);
   Curl_pgrsSetUploadSize(data, 0);
   Curl_pgrsSetDownloadSize(data, 0);
 
-  res = scp_perform(conn, &connected,  done);
+  if(conn->protocol & PROT_SCP)
+    res = scp_perform(conn, &connected,  done);
+  else
+    res = sftp_perform(conn, &connected,  done);
 
-  if (CURLE_OK == res) {
+  return res;
+}
 
-    if (!done) {
-      /* the DO phase has not completed yet */
-      return CURLE_OK;
-    }
-  }
+/* BLOCKING, but the function is using the state machine so the only reason this
+   is still blocking is that the multi interface code has no support for
+   disconnecting operations that takes a while */
+static CURLcode scp_disconnect(struct connectdata *conn)
+{
+  CURLcode result;
 
-  return res;
+  Curl_safefree(conn->data->state.proto.ssh);
+  conn->data->state.proto.ssh = NULL;
+
+  state(conn, SSH_SESSION_DISCONNECT);
+
+  result = ssh_easy_statemach(conn);
+
+  return result;
 }
 
-static CURLcode Curl_scp_done(struct connectdata *conn, CURLcode status,
-                              bool premature)
+static CURLcode scp_done(struct connectdata *conn, CURLcode status,
+                         bool premature)
 {
   CURLcode result = CURLE_OK;
   bool done = FALSE;
   (void)premature; /* not used */
   (void)status; /* unused */
 
-  if (status == CURLE_OK) {
+  if(status == CURLE_OK) {
     state(conn, SSH_SCP_DONE);
     /* run the state-machine */
-    if (conn->data->state.used_interface == Curl_if_multi) {
-      result = Curl_ssh_multi_statemach(conn, &done);
-    } else {
+    if(conn->data->state.used_interface == Curl_if_multi) {
+      result = ssh_multi_statemach(conn, &done);
+    }
+    else {
       result = ssh_easy_statemach(conn);
       done = TRUE;
     }
-  } else {
+  }
+  else {
     result = status;
     done = TRUE;
   }
 
-  if (done) {
-    Curl_safefree(conn->data->reqdata.proto.ssh);
-    conn->data->reqdata.proto.ssh = NULL;
+  if(done) {
+    struct SSHPROTO *sftp_scp = conn->data->state.proto.ssh;
+    Curl_safefree(sftp_scp->path);
+    sftp_scp->path = NULL;
     Curl_pgrsDone(conn);
   }
 
   return result;
 
 }
 
 /* return number of received (decrypted) bytes */
 ssize_t Curl_scp_send(struct connectdata *conn, int sockindex,
                       void *mem, size_t len)
 {
   ssize_t nwrite;
+  (void)sockindex; /* we only support SCP on the fixed known primary socket */
 
-  /* libssh2_channel_write() returns int
-   *
-   * NOTE: we should not store nor rely on connection-related data to be
-   * in the SessionHandle struct
-   */
+  /* libssh2_channel_write() returns int! */
   nwrite = (ssize_t)
-    libssh2_channel_write(conn->data->reqdata.proto.ssh->ssh_channel,
-                          mem, len);
-  if (nwrite == LIBSSH2_ERROR_EAGAIN)
+    libssh2_channel_write(conn->proto.sshc.ssh_channel, mem, len);
+  if(nwrite == LIBSSH2_ERROR_EAGAIN)
     return 0;
-  (void)sockindex;
+
   return nwrite;
 }
 
 /*
  * If the read would block (EWOULDBLOCK) we return -1. Otherwise we return
  * a regular CURLcode value.
@@ -2045,20 +2083,15 @@
 ssize_t Curl_scp_recv(struct connectdata *conn, int sockindex,
                       char *mem, size_t len)
 {
   ssize_t nread;
   (void)sockindex; /* we only support SCP on the fixed known primary socket */
 
-  /* libssh2_channel_read() returns int
-   *
-   * NOTE: we should not store nor rely on connection-related data to be
-   * in the SessionHandle struct
-   */
+  /* libssh2_channel_read() returns int */
   nread = (ssize_t)
-    libssh2_channel_read(conn->data->reqdata.proto.ssh->ssh_channel,
-                         mem, len);
+    libssh2_channel_read(conn->proto.sshc.ssh_channel, mem, len);
   return nread;
 }
 
 /*
  * =============== SFTP ===============
  */
@@ -2084,148 +2117,126 @@
   *dophase_done = FALSE; /* not done yet */
 
   /* start the first command in the DO phase */
   state(conn, SSH_SFTP_QUOTE_INIT);
 
   /* run the state-machine */
-  if (conn->data->state.used_interface == Curl_if_multi) {
-    result = Curl_ssh_multi_statemach(conn, dophase_done);
-  } else {
+  if(conn->data->state.used_interface == Curl_if_multi) {
+    result = ssh_multi_statemach(conn, dophase_done);
+  }
+  else {
     result = ssh_easy_statemach(conn);
     *dophase_done = TRUE; /* with the easy interface we are done here */
   }
   *connected = conn->bits.tcpconnect;
 
-  if (*dophase_done) {
+  if(*dophase_done) {
     DEBUGF(infof(conn->data, "DO phase is complete\n"));
   }
 
   return result;
 }
 
 /* called from multi.c while DOing */
-static CURLcode Curl_sftp_doing(struct connectdata *conn,
-                                bool *dophase_done)
+static CURLcode sftp_doing(struct connectdata *conn,
+                           bool *dophase_done)
 {
   CURLcode result;
-  result = Curl_ssh_multi_statemach(conn, dophase_done);
+  result = ssh_multi_statemach(conn, dophase_done);
 
-  if (*dophase_done) {
+  if(*dophase_done) {
     DEBUGF(infof(conn->data, "DO phase is complete\n"));
   }
   return result;
 }
 
-static CURLcode Curl_sftp_do(struct connectdata *conn, bool *done)
+/* BLOCKING, but the function is using the state machine so the only reason this
+   is still blocking is that the multi interface code has no support for
+   disconnecting operations that takes a while */
+static CURLcode sftp_disconnect(struct connectdata *conn)
 {
-  CURLcode res;
-  bool connected = 0;
-  struct SessionHandle *data = conn->data;
-
-  *done = FALSE; /* default to false */
-
-  /*
-   * Since connections can be re-used between SessionHandles, this might be a
-   * connection already existing but on a fresh SessionHandle struct so we must
-   * make sure we have a good 'struct SSHPROTO' to play with. For new
-   * connections, the struct SSHPROTO is allocated and setup in the
-   * Curl_ssh_connect() function.
-   */
-  res = ssh_init(conn);
-  if (res) {
-    return res;
-  }
+  CURLcode result;
 
-  data->reqdata.size = -1; /* make sure this is unknown at this point */
+  DEBUGF(infof(conn->data, "SSH DISCONNECT starts now\n"));
 
-  Curl_pgrsSetUploadCounter(data, 0);
-  Curl_pgrsSetDownloadCounter(data, 0);
-  Curl_pgrsSetUploadSize(data, 0);
-  Curl_pgrsSetDownloadSize(data, 0);
+  Curl_safefree(conn->data->state.proto.ssh);
+  conn->data->state.proto.ssh = NULL;
 
-  res = sftp_perform(conn, &connected,  done);
+  state(conn, SSH_SFTP_SHUTDOWN);
+  result = ssh_easy_statemach(conn);
 
-  if (CURLE_OK == res) {
+  DEBUGF(infof(conn->data, "SSH DISCONNECT is done\n"));
 
-    if (!done) {
-      /* the DO phase has not completed yet */
-      return CURLE_OK;
-    }
-  }
+  return result;
 
-  return res;
 }
 
-static CURLcode Curl_sftp_done(struct connectdata *conn, CURLcode status,
+static CURLcode sftp_done(struct connectdata *conn, CURLcode status,
                                bool premature)
 {
   CURLcode result = CURLE_OK;
   bool done = FALSE;
   struct ssh_conn *sshc = &conn->proto.sshc;
 
   (void)status; /* unused */
 
-  if (status == CURLE_OK) {
+  if(status == CURLE_OK) {
     /* Before we shut down, see if there are any post-quote commands to send: */
-    if (!status && !premature && conn->data->set.postquote) {
-      sshc->nextState = SSH_SFTP_CLOSE;
+    if(!status && !premature && conn->data->set.postquote) {
+      sshc->nextstate = SSH_SFTP_CLOSE;
       state(conn, SSH_SFTP_POSTQUOTE_INIT);
-    } else {
-      state(conn, SSH_SFTP_CLOSE);
     }
+    else
+      state(conn, SSH_SFTP_CLOSE);
 
     /* run the state-machine */
-    if (conn->data->state.used_interface == Curl_if_multi) {
-      result = Curl_ssh_multi_statemach(conn, &done);
-    } else {
+    if(conn->data->state.used_interface == Curl_if_multi)
+      result = ssh_multi_statemach(conn, &done);
+    else {
       result = ssh_easy_statemach(conn);
       done = TRUE;
     }
-  } else {
+  }
+  else {
     result = status;
     done = TRUE;
   }
 
-  if (done) {
-    Curl_safefree(conn->data->reqdata.proto.ssh);
-    conn->data->reqdata.proto.ssh = NULL;
+  if(done) {
     Curl_pgrsDone(conn);
   }
 
   return result;
 }
 
-/* return number of received (decrypted) bytes */
+/* return number of sent bytes */
 ssize_t Curl_sftp_send(struct connectdata *conn, int sockindex,
                        void *mem, size_t len)
 {
   ssize_t nwrite;   /* libssh2_sftp_write() used to return size_t in 0.14
-                       but is changed to ssize_t in 0.15! */
+                       but is changed to ssize_t in 0.15. These days we don't
+                       support libssh2 0.15*/
+  (void)sockindex;
 
-  nwrite = (ssize_t)
-    libssh2_sftp_write(conn->data->reqdata.proto.ssh->sftp_handle, mem, len);
-  if (nwrite == LIBSSH2_ERROR_EAGAIN)
+  nwrite = libssh2_sftp_write(conn->proto.sshc.sftp_handle, mem, len);
+  if(nwrite == LIBSSH2_ERROR_EAGAIN)
     return 0;
 
-  (void)sockindex;
   return nwrite;
 }
 
 /*
- * If the read would block (EWOULDBLOCK) we return -1. Otherwise we return
- * a regular CURLcode value.
+ * Return number of received (decrypted) bytes
  */
 ssize_t Curl_sftp_recv(struct connectdata *conn, int sockindex,
                        char *mem, size_t len)
 {
   ssize_t nread;
   (void)sockindex;
 
-  /* libssh2_sftp_read() returns size_t !*/
-  nread = (ssize_t)
-    libssh2_sftp_read(conn->data->reqdata.proto.ssh->sftp_handle, mem, len);
+  nread = libssh2_sftp_read(conn->proto.sshc.sftp_handle, mem, len);
 
   return nread;
 }
 
 /* The get_pathname() function is being borrowed from OpenSSH sftp.c
    version 4.6p1. */
@@ -2250,59 +2261,59 @@
   const char *cp = *cpp, *end;
   char quot;
   u_int i, j;
   static const char * const WHITESPACE = " \t\r\n";
 
   cp += strspn(cp, WHITESPACE);
-  if (!*cp) {
+  if(!*cp) {
     *cpp = cp;
     *path = NULL;
     return CURLE_QUOTE_ERROR;
   }
 
   *path = malloc(strlen(cp) + 1);
-  if (*path == NULL)
+  if(*path == NULL)
     return CURLE_OUT_OF_MEMORY;
 
   /* Check for quoted filenames */
-  if (*cp == '\"' || *cp == '\'') {
+  if(*cp == '\"' || *cp == '\'') {
     quot = *cp++;
 
     /* Search for terminating quote, unescape some chars */
     for (i = j = 0; i <= strlen(cp); i++) {
-      if (cp[i] == quot) {  /* Found quote */
+      if(cp[i] == quot) {  /* Found quote */
         i++;
         (*path)[j] = '\0';
         break;
       }
-      if (cp[i] == '\0') {  /* End of string */
+      if(cp[i] == '\0') {  /* End of string */
         /*error("Unterminated quote");*/
         goto fail;
       }
-      if (cp[i] == '\\') {  /* Escaped characters */
+      if(cp[i] == '\\') {  /* Escaped characters */
         i++;
-        if (cp[i] != '\'' && cp[i] != '\"' &&
+        if(cp[i] != '\'' && cp[i] != '\"' &&
             cp[i] != '\\') {
           /*error("Bad escaped character '\\%c'",
               cp[i]);*/
           goto fail;
         }
       }
       (*path)[j++] = cp[i];
     }
 
-    if (j == 0) {
+    if(j == 0) {
       /*error("Empty quotes");*/
       goto fail;
     }
     *cpp = cp + i + strspn(cp + i, WHITESPACE);
   }
   else {
     /* Read to end of filename */
     end = strpbrk(cp, WHITESPACE);
-    if (end == NULL)
+    if(end == NULL)
       end = strchr(cp, '\0');
     *cpp = end + strspn(end, WHITESPACE);
 
     memcpy(*path, cp, end - cp);
     (*path)[end - cp] = '\0';
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/sslgen.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/sslgen.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/sslgen.c	2007-09-26 20:51:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/sslgen.c	2008-01-28 06:41:56.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sslgen.c,v 1.29 2007-09-25 06:45:05 danf Exp $
+ * $Id: sslgen.c,v 1.35 2007-12-25 13:26:01 gknauf Exp $
  ***************************************************************************/
 
 /* This file is for "generic" SSL functions that all libcurl internals should
    use. It is responsible for calling the proper 'ossl' function in ssluse.c
    (OpenSSL based) or the 'gtls' function in gtls.c (GnuTLS based).
 
@@ -93,12 +93,13 @@
 }
 
 bool
 Curl_clone_ssl_config(struct ssl_config_data *source,
                       struct ssl_config_data *dest)
 {
+  dest->sessionid = source->sessionid;
   dest->verifyhost = source->verifyhost;
   dest->verifypeer = source->verifypeer;
   dest->version = source->version;
 
   if(source->CAfile) {
     dest->CAfile = strdup(source->CAfile);
@@ -240,21 +241,24 @@
   conn->ssl[sockindex].use = TRUE;
   return Curl_ossl_connect_nonblocking(conn, sockindex, done);
 
 #else
 #ifdef USE_NSS
   *done = TRUE; /* fallback to BLOCKING */
+  conn->ssl[sockindex].use = TRUE;
   return Curl_nss_connect(conn, sockindex);
 #else
 #ifdef USE_QSOSSL
   *done = TRUE; /* fallback to BLOCKING */
+  conn->ssl[sockindex].use = TRUE;
   return Curl_qsossl_connect(conn, sockindex);
 #else
   /* not implemented!
      fallback to BLOCKING call. */
   *done = TRUE;
+  conn->ssl[sockindex].use = TRUE;
   return Curl_ssl_connect(conn, sockindex);
 #endif /* USE_QSOSSL */
 #endif /* USE_NSS */
 #endif /* USE_SSLEAY */
 }
 
@@ -377,16 +381,19 @@
     store = &data->state.session[i]; /* use this slot */
 
   /* now init the session struct wisely */
   store->sessionid = ssl_sessionid;
   store->idsize = idsize;
   store->age = data->state.sessionage;    /* set current age */
+  if (store->name)
+    /* free it if there's one already present */
+    free(store->name);
   store->name = clone_host;               /* clone host name */
   store->remote_port = conn->remote_port; /* port number */
 
-  if (!Curl_clone_ssl_config(&conn->ssl_config, &store->ssl_config))
+  if(!Curl_clone_ssl_config(&conn->ssl_config, &store->ssl_config))
     return CURLE_OUT_OF_MEMORY;
 
   return CURLE_OK;
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ssluse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ssluse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/ssluse.c	2007-10-03 16:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/ssluse.c	2008-01-28 06:41:56.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.c,v 1.186 2007-10-03 08:07:50 bagder Exp $
+ * $Id: ssluse.c,v 1.191 2008-01-15 23:19:02 bagder Exp $
  ***************************************************************************/
 
 /*
  * Source file for all OpenSSL-specific code for the TLS/SSL layer. No code
  * but sslgen.c should ever call or use these functions.
  */
@@ -235,13 +235,13 @@
         return 3; /* out of memory */
 
       len = (int)strlen(area);
       RAND_add(area, len, (len >> 1));
 
       free(area); /* now remove the random junk */
-    } while (!RAND_status());
+    } while(!RAND_status());
   }
 #endif
 
   /* generates a default path for the random seed file */
   buf[0]=0; /* blank it first */
   RAND_file_name(buf, BUFSIZE);
@@ -363,22 +363,22 @@
 #ifdef HAVE_PKCS12_SUPPORT
       FILE *f;
       PKCS12 *p12;
       EVP_PKEY *pri;
 
       f = fopen(cert_file,"rb");
-      if (!f) {
+      if(!f) {
         failf(data, "could not open PKCS12 file '%s'", cert_file);
         return 0;
       }
       p12 = d2i_PKCS12_fp(f, NULL);
       fclose(f);
 
       PKCS12_PBE_add();
 
-      if (!PKCS12_parse(p12, data->set.str[STRING_KEY_PASSWD], &pri, &x509,
+      if(!PKCS12_parse(p12, data->set.str[STRING_KEY_PASSWD], &pri, &x509,
                         NULL)) {
         failf(data,
               "could not parse PKCS12 file, check password, OpenSSL error %s",
               ERR_error_string(ERR_get_error(), NULL) );
         PKCS12_free(p12);
         return 0;
@@ -423,13 +423,13 @@
         break;
       if(key_file == NULL)
         /* cert & key can only be in PEM case in the same file */
         key_file=cert_file;
     case SSL_FILETYPE_ASN1:
       if(SSL_CTX_use_PrivateKey_file(ctx, key_file, file_type) != 1) {
-        failf(data, "unable to set private key file: '%s' type %s\n",
+        failf(data, "unable to set private key file: '%s' type %s",
               key_file, key_type?key_type:"PEM");
         return 0;
       }
       break;
     case SSL_FILETYPE_ENGINE:
 #ifdef HAVE_OPENSSL_ENGINE_H
@@ -437,57 +437,57 @@
         EVP_PKEY *priv_key = NULL;
         if(data->state.engine) {
 #ifdef HAVE_ENGINE_LOAD_FOUR_ARGS
           UI_METHOD *ui_method = UI_OpenSSL();
 #endif
           if(!key_file || !key_file[0]) {
-            failf(data, "no key set to load from crypto engine\n");
+            failf(data, "no key set to load from crypto engine");
             return 0;
           }
           /* the typecast below was added to please mingw32 */
           priv_key = (EVP_PKEY *)
             ENGINE_load_private_key(data->state.engine,key_file,
 #ifdef HAVE_ENGINE_LOAD_FOUR_ARGS
                                     ui_method,
 #endif
                                     data->set.str[STRING_KEY_PASSWD]);
           if(!priv_key) {
-            failf(data, "failed to load private key from crypto engine\n");
+            failf(data, "failed to load private key from crypto engine");
             return 0;
           }
           if(SSL_CTX_use_PrivateKey(ctx, priv_key) != 1) {
-            failf(data, "unable to set private key\n");
+            failf(data, "unable to set private key");
             EVP_PKEY_free(priv_key);
             return 0;
           }
           EVP_PKEY_free(priv_key);  /* we don't need the handle any more... */
         }
         else {
-          failf(data, "crypto engine not set, can't load private key\n");
+          failf(data, "crypto engine not set, can't load private key");
           return 0;
         }
       }
       break;
 #else
-      failf(data, "file type ENG for private key not supported\n");
+      failf(data, "file type ENG for private key not supported");
       return 0;
 #endif
     case SSL_FILETYPE_PKCS12:
       if(!cert_done) {
-        failf(data, "file type P12 for private key not supported\n");
+        failf(data, "file type P12 for private key not supported");
         return 0;
       }
       break;
     default:
-      failf(data, "not supported file type for private key\n");
+      failf(data, "not supported file type for private key");
       return 0;
     }
 
     ssl=SSL_new(ctx);
-    if (NULL == ssl) {
-      failf(data,"unable to create an SSL structure\n");
+    if(NULL == ssl) {
+      failf(data,"unable to create an SSL structure");
       return 0;
     }
 
     x509=SSL_get_certificate(ssl);
 
     /* This version was provided by Evan Jordan and is supposed to not
@@ -561,13 +561,13 @@
 #endif
 
   /* Lets get nice error messages */
   SSL_load_error_strings();
 
   /* Setup all the global SSL stuff */
-  if (!SSLeay_add_ssl_algorithms())
+  if(!SSLeay_add_ssl_algorithms())
     return 0;
 
   return 1;
 }
 
 #endif /* USE_SSLEAY */
@@ -606,39 +606,39 @@
 int Curl_ossl_check_cxn(struct connectdata *conn)
 {
   int rc;
   char buf;
 
   rc = SSL_peek(conn->ssl[FIRSTSOCKET].handle, (void*)&buf, 1);
-  if (rc > 0)
+  if(rc > 0)
     return 1; /* connection still in place */
 
-  if (rc == 0)
+  if(rc == 0)
     return 0; /* connection has been closed */
 
   return -1; /* connection status unknown */
 }
 
 /* Selects an OpenSSL crypto engine
  */
 CURLcode Curl_ossl_set_engine(struct SessionHandle *data, const char *engine)
 {
 #if defined(USE_SSLEAY) && defined(HAVE_OPENSSL_ENGINE_H)
   ENGINE *e = ENGINE_by_id(engine);
 
-  if (!e) {
+  if(!e) {
     failf(data, "SSL Engine '%s' not found", engine);
     return (CURLE_SSL_ENGINE_NOTFOUND);
   }
 
-  if (data->state.engine) {
+  if(data->state.engine) {
     ENGINE_finish(data->state.engine);
     ENGINE_free(data->state.engine);
     data->state.engine = NULL;
   }
-  if (!ENGINE_init(e)) {
+  if(!ENGINE_init(e)) {
     char buf[256];
 
     ENGINE_free(e);
     failf(data, "Failed to initialise SSL Engine '%s':\n%s",
           engine, SSL_strerror(ERR_get_error(), buf, sizeof(buf)));
     return (CURLE_SSL_ENGINE_INITFAILED);
@@ -654,14 +654,14 @@
 
 /* Sets engine as default for all SSL operations
  */
 CURLcode Curl_ossl_set_engine_default(struct SessionHandle *data)
 {
 #ifdef HAVE_OPENSSL_ENGINE_H
-  if (data->state.engine) {
-    if (ENGINE_set_default(data->state.engine, ENGINE_METHOD_ALL) > 0) {
+  if(data->state.engine) {
+    if(ENGINE_set_default(data->state.engine, ENGINE_METHOD_ALL) > 0) {
       infof(data,"set default crypto engine '%s'\n", ENGINE_get_id(data->state.engine));
     }
     else {
       failf(data, "set default crypto engine '%s' failed", ENGINE_get_id(data->state.engine));
       return CURLE_SSL_ENGINE_SETFAILED;
     }
@@ -680,17 +680,17 @@
 #if defined(USE_SSLEAY) && defined(HAVE_OPENSSL_ENGINE_H)
   struct curl_slist *beg = NULL;
   ENGINE *e;
 
   for (e = ENGINE_get_first(); e; e = ENGINE_get_next(e)) {
     list = curl_slist_append(list, ENGINE_get_id(e));
-    if (list == NULL) {
+    if(list == NULL) {
       curl_slist_free_all(beg);
       return NULL;
     }
-    else if (beg == NULL) {
+    else if(beg == NULL) {
       beg = list;
     }
   }
 #endif
   (void) data;
   return (list);
@@ -847,15 +847,15 @@
 #else
   (void)data;
 #endif
   return 0;
 }
 
-static int Curl_ASN1_UTCTIME_output(struct connectdata *conn,
-                                    const char *prefix,
-                                    const ASN1_UTCTIME *tm)
+static int asn1_output(struct connectdata *conn,
+                       const char *prefix,
+                       const ASN1_UTCTIME *tm)
 {
   const char *asn1_string;
   int gmt=FALSE;
   int i;
   int year=0,month=0,day=0,hour=0,minute=0,second=0;
   struct SessionHandle *data = conn->data;
@@ -916,48 +916,48 @@
  */
 #define HOST_NOMATCH 0
 #define HOST_MATCH   1
 
 static int hostmatch(const char *hostname, const char *pattern)
 {
-  while (1) {
+  while(1) {
     char c = *pattern++;
 
-    if (c == '\0')
+    if(c == '\0')
       return (*hostname ? HOST_NOMATCH : HOST_MATCH);
 
-    if (c == '*') {
+    if(c == '*') {
       c = *pattern;
-      if (c == '\0')      /* "*\0" matches anything remaining */
+      if(c == '\0')      /* "*\0" matches anything remaining */
         return HOST_MATCH;
 
-      while (*hostname) {
+      while(*hostname) {
         /* The only recursive function in libcurl! */
-        if (hostmatch(hostname++,pattern) == HOST_MATCH)
+        if(hostmatch(hostname++,pattern) == HOST_MATCH)
           return HOST_MATCH;
       }
       break;
     }
 
-    if (toupper(c) != toupper(*hostname++))
+    if(toupper(c) != toupper(*hostname++))
       break;
   }
   return HOST_NOMATCH;
 }
 
 static int
 cert_hostcheck(const char *match_pattern, const char *hostname)
 {
-  if (!match_pattern || !*match_pattern ||
+  if(!match_pattern || !*match_pattern ||
       !hostname || !*hostname) /* sanity check */
     return 0;
 
   if(curl_strequal(hostname,match_pattern)) /* trivial case */
     return 1;
 
-  if (hostmatch(hostname,match_pattern) == HOST_MATCH)
+  if(hostmatch(hostname,match_pattern) == HOST_MATCH)
     return 1;
   return 0;
 }
 
 /* Quote from RFC2818 section 3.1 "Server Identity"
 
@@ -1039,13 +1039,13 @@
              type itself: for example for and IA5String the data will be ASCII"
 
              Gisle researched the OpenSSL sources:
              "I checked the 0.9.6 and 0.9.8 sources before my patch and
              it always 0-terminates an IA5String."
           */
-          if (cert_hostcheck(altptr, conn->host.name))
+          if(cert_hostcheck(altptr, conn->host.name))
             matched = TRUE;
           break;
 
         case GEN_IPADD: /* IP address comparison */
           /* compare alternative IP address if the data chunk is the same size
              our server IP address is */
@@ -1070,58 +1070,58 @@
 /* The following is done because of a bug in 0.9.6b */
 
     unsigned char *nulstr = (unsigned char *)"";
     unsigned char *peer_CN = nulstr;
 
     X509_NAME *name = X509_get_subject_name(server_cert) ;
-    if (name)
-      while ((j=X509_NAME_get_index_by_NID(name,NID_commonName,i))>=0)
+    if(name)
+      while((j=X509_NAME_get_index_by_NID(name,NID_commonName,i))>=0)
         i=j;
 
     /* we have the name entry and we will now convert this to a string
        that we can use for comparison. Doing this we support BMPstring,
        UTF8 etc. */
 
-    if (i>=0) {
+    if(i>=0) {
       ASN1_STRING *tmp = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name,i));
 
       /* In OpenSSL 0.9.7d and earlier, ASN1_STRING_to_UTF8 fails if the input
          is already UTF-8 encoded. We check for this case and copy the raw
          string manually to avoid the problem. This code can be made
          conditional in the future when OpenSSL has been fixed. Work-around
          brought by Alexis S. L. Carvalho. */
-      if (tmp && ASN1_STRING_type(tmp) == V_ASN1_UTF8STRING) {
+      if(tmp && ASN1_STRING_type(tmp) == V_ASN1_UTF8STRING) {
         j = ASN1_STRING_length(tmp);
-        if (j >= 0) {
+        if(j >= 0) {
           peer_CN = OPENSSL_malloc(j+1);
-          if (peer_CN) {
+          if(peer_CN) {
             memcpy(peer_CN, ASN1_STRING_data(tmp), j);
             peer_CN[j] = '\0';
           }
         }
       }
       else /* not a UTF8 name */
         j = ASN1_STRING_to_UTF8(&peer_CN, tmp);
     }
 
-    if (peer_CN == nulstr)
+    if(peer_CN == nulstr)
        peer_CN = NULL;
 #ifdef CURL_DOES_CONVERSIONS
     else {
       /* convert peer_CN from UTF8 */
       size_t rc;
       rc = Curl_convert_from_utf8(data, peer_CN, strlen(peer_CN));
       /* Curl_convert_from_utf8 calls failf if unsuccessful */
-      if (rc != CURLE_OK) {
+      if(rc != CURLE_OK) {
         OPENSSL_free(peer_CN);
         return rc;
       }
     }
 #endif /* CURL_DOES_CONVERSIONS */
 
-    if (!peer_CN) {
+    if(!peer_CN) {
       failf(data,
             "SSL: unable to obtain common name from peer certificate");
       return CURLE_PEER_FAILED_VERIFICATION;
     }
     else if(!cert_hostcheck((const char *)peer_CN, conn->host.name)) {
       if(data->set.ssl.verifyhost > 1) {
@@ -1146,13 +1146,13 @@
 /* The SSL_CTRL_SET_MSG_CALLBACK doesn't exist in ancient OpenSSL versions
    and thus this cannot be done there. */
 #ifdef SSL_CTRL_SET_MSG_CALLBACK
 
 static const char *ssl_msg_type(int ssl_ver, int msg)
 {
-  if (ssl_ver == SSL2_VERSION_MAJOR) {
+  if(ssl_ver == SSL2_VERSION_MAJOR) {
     switch (msg) {
       case SSL2_MT_ERROR:
         return "Error";
       case SSL2_MT_CLIENT_HELLO:
         return "Client hello";
       case SSL2_MT_CLIENT_MASTER_KEY:
@@ -1168,13 +1168,13 @@
       case SSL2_MT_REQUEST_CERTIFICATE:
         return "Request CERT";
       case SSL2_MT_CLIENT_CERTIFICATE:
         return "Client CERT";
     }
   }
-  else if (ssl_ver == SSL3_VERSION_MAJOR) {
+  else if(ssl_ver == SSL3_VERSION_MAJOR) {
     switch (msg) {
       case SSL3_MT_HELLO_REQUEST:
         return "Hello request";
       case SSL3_MT_CLIENT_HELLO:
         return "Client hello";
       case SSL3_MT_SERVER_HELLO:
@@ -1218,26 +1218,26 @@
 {
   struct SessionHandle *data;
   const char *msg_name, *tls_rt_name;
   char ssl_buf[1024];
   int  ver, msg_type, txt_len;
 
-  if (!conn || !conn->data || !conn->data->set.fdebug ||
+  if(!conn || !conn->data || !conn->data->set.fdebug ||
       (direction != 0 && direction != 1))
     return;
 
   data = conn->data;
   ssl_ver >>= 8;
   ver = (ssl_ver == SSL2_VERSION_MAJOR ? '2' :
          ssl_ver == SSL3_VERSION_MAJOR ? '3' : '?');
 
   /* SSLv2 doesn't seem to have TLS record-type headers, so OpenSSL
    * always pass-up content-type as 0. But the interesting message-type
    * is at 'buf[0]'.
    */
-  if (ssl_ver == SSL3_VERSION_MAJOR && content_type != 0)
+  if(ssl_ver == SSL3_VERSION_MAJOR && content_type != 0)
     tls_rt_name = tls_rt_type(content_type);
   else
     tls_rt_name = "";
 
   msg_type = *(char*)buf;
   msg_name = ssl_msg_type(ssl_ver, msg_type);
@@ -1253,14 +1253,14 @@
 #endif
 
 #ifdef USE_SSLEAY
 /* ====================================================== */
 
 static CURLcode
-Curl_ossl_connect_step1(struct connectdata *conn,
-                        int sockindex)
+ossl_connect_step1(struct connectdata *conn,
+                   int sockindex)
 {
   CURLcode retcode = CURLE_OK;
 
   struct SessionHandle *data = conn->data;
   SSL_METHOD_QUAL SSL_METHOD *req_method=NULL;
   void *ssl_sessionid=NULL;
@@ -1287,30 +1287,30 @@
     break;
   case CURL_SSLVERSION_SSLv3:
     req_method = SSLv3_client_method();
     break;
   }
 
-  if (connssl->ctx)
+  if(connssl->ctx)
     SSL_CTX_free(connssl->ctx);
   connssl->ctx = SSL_CTX_new(req_method);
 
   if(!connssl->ctx) {
     failf(data, "SSL: couldn't create a context!");
     return CURLE_OUT_OF_MEMORY;
   }
 
 #ifdef SSL_CTRL_SET_MSG_CALLBACK
-  if (data->set.fdebug && data->set.verbose) {
+  if(data->set.fdebug && data->set.verbose) {
     /* the SSL trace callback is only used for verbose logging so we only
        inform about failures of setting it */
-    if (!SSL_CTX_callback_ctrl(connssl->ctx, SSL_CTRL_SET_MSG_CALLBACK,
+    if(!SSL_CTX_callback_ctrl(connssl->ctx, SSL_CTRL_SET_MSG_CALLBACK,
                                (void (*)(void))ssl_tls_trace)) {
       infof(data, "SSL: couldn't set callback!\n");
     }
-    else if (!SSL_CTX_ctrl(connssl->ctx, SSL_CTRL_SET_MSG_CALLBACK_ARG, 0,
+    else if(!SSL_CTX_ctrl(connssl->ctx, SSL_CTRL_SET_MSG_CALLBACK_ARG, 0,
                            conn)) {
       infof(data, "SSL: couldn't set callback argument!\n");
     }
   }
 #endif
 
@@ -1327,13 +1327,13 @@
 #if 0
   /*
    * Not sure it's needed to tell SSL_connect() that socket is
    * non-blocking. It doesn't seem to care, but just return with
    * SSL_ERROR_WANT_x.
    */
-  if (data->state.used_interface == Curl_if_multi)
+  if(data->state.used_interface == Curl_if_multi)
     SSL_CTX_ctrl(connssl->ctx, BIO_C_SET_NBIO, 1, NULL);
 #endif
 
   if(data->set.str[STRING_CERT]) {
     if(!cert_stuff(conn,
                    connssl->ctx,
@@ -1351,19 +1351,19 @@
                                 data->set.str[STRING_SSL_CIPHER_LIST])) {
       failf(data, "failed setting cipher list");
       return CURLE_SSL_CIPHER;
     }
   }
 
-  if (data->set.str[STRING_SSL_CAFILE] || data->set.str[STRING_SSL_CAPATH]) {
+  if(data->set.str[STRING_SSL_CAFILE] || data->set.str[STRING_SSL_CAPATH]) {
     /* tell SSL where to find CA certificates that are used to verify
        the servers certificate. */
-    if (!SSL_CTX_load_verify_locations(connssl->ctx,
+    if(!SSL_CTX_load_verify_locations(connssl->ctx,
                                        data->set.str[STRING_SSL_CAFILE],
                                        data->set.str[STRING_SSL_CAPATH])) {
-      if (data->set.ssl.verifypeer) {
+      if(data->set.ssl.verifypeer) {
         /* Fail if we insist on successfully verifying the server. */
         failf(data,"error setting certificate verify locations:\n"
               "  CAfile: %s\n  CApath: %s\n",
               data->set.str[STRING_SSL_CAFILE]?
               data->set.str[STRING_SSL_CAFILE]: "none",
               data->set.str[STRING_SSL_CAPATH]?
@@ -1405,49 +1405,49 @@
       failf(data,"error signaled by ssl ctx callback");
       return retcode;
     }
   }
 
   /* Lets make an SSL structure */
-  if (connssl->handle)
+  if(connssl->handle)
     SSL_free(connssl->handle);
   connssl->handle = SSL_new(connssl->ctx);
-  if (!connssl->handle) {
+  if(!connssl->handle) {
     failf(data, "SSL: couldn't create a context (handle)!");
     return CURLE_OUT_OF_MEMORY;
   }
   SSL_set_connect_state(connssl->handle);
 
   connssl->server_cert = 0x0;
 
   /* Check if there's a cached ID we can/should use here! */
   if(!Curl_ssl_getsessionid(conn, &ssl_sessionid, NULL)) {
     /* we got a session id, use it! */
-    if (!SSL_set_session(connssl->handle, ssl_sessionid)) {
+    if(!SSL_set_session(connssl->handle, ssl_sessionid)) {
       failf(data, "SSL: SSL_set_session failed: %s",
             ERR_error_string(ERR_get_error(),NULL));
       return CURLE_SSL_CONNECT_ERROR;
     }
     /* Informational message */
     infof (data, "SSL re-using session ID\n");
   }
 
   /* pass the raw socket into the SSL layers */
-  if (!SSL_set_fd(connssl->handle, sockfd)) {
+  if(!SSL_set_fd(connssl->handle, sockfd)) {
      failf(data, "SSL: SSL_set_fd failed: %s",
            ERR_error_string(ERR_get_error(),NULL));
      return CURLE_SSL_CONNECT_ERROR;
   }
 
   connssl->connecting_state = ssl_connect_2;
   return CURLE_OK;
 }
 
 static CURLcode
-Curl_ossl_connect_step2(struct connectdata *conn,
-                        int sockindex, long *timeout_ms)
+ossl_connect_step2(struct connectdata *conn,
+                   int sockindex, long *timeout_ms)
 {
   struct SessionHandle *data = conn->data;
   int err;
   long has_passed;
   struct ssl_connect_data *connssl = &conn->ssl[sockindex];
 
@@ -1542,13 +1542,13 @@
       /* detail is already set to the SSL error above */
 
       /* If we e.g. use SSLv2 request-method and the server doesn't like us
        * (RST connection etc.), OpenSSL gives no explanation whatsoever and
        * the SO_ERROR is also lost.
        */
-      if (CURLE_SSL_CONNECT_ERROR == rc && errdetail == 0) {
+      if(CURLE_SSL_CONNECT_ERROR == rc && errdetail == 0) {
         failf(data, "Unknown SSL protocol error in connection to %s:%d ",
               conn->host.name, conn->port);
         return rc;
       }
       /* Could be a CERT problem */
 
@@ -1566,87 +1566,54 @@
            SSL_get_cipher(connssl->handle));
 
     return CURLE_OK;
   }
 }
 
-static CURLcode
-Curl_ossl_connect_step3(struct connectdata *conn,
-                  int sockindex)
+/*
+ * Get the server cert, verify it and show it etc, only call failf() if the
+ * 'strict' argument is TRUE as otherwise all this is for informational
+ * purposes only!
+ *
+ * We check certificates to authenticate the server; otherwise we risk
+ * man-in-the-middle attack.
+ */
+static CURLcode servercert(struct connectdata *conn,
+                           struct ssl_connect_data *connssl,
+                           bool strict)
 {
   CURLcode retcode = CURLE_OK;
-  char * str;
+  char *str;
   long lerr;
   ASN1_TIME *certdate;
-  void *ssl_sessionid=NULL;
   struct SessionHandle *data = conn->data;
-  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
-
-  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);
-
-  if(Curl_ssl_getsessionid(conn, &ssl_sessionid, NULL)) {
-    /* Since this is not a cached session ID, then we want to stach this one
-       in the cache! */
-    SSL_SESSION *our_ssl_sessionid;
-#ifdef HAVE_SSL_GET1_SESSION
-    our_ssl_sessionid = SSL_get1_session(connssl->handle);
-
-    /* SSL_get1_session() will increment the reference
-       count and the session will stay in memory until explicitly freed with
-       SSL_SESSION_free(3), regardless of its state.
-       This function was introduced in openssl 0.9.5a. */
-#else
-    our_ssl_sessionid = SSL_get_session(connssl->handle);
-
-    /* if SSL_get1_session() is unavailable, use SSL_get_session().
-       This is an inferior option because the session can be flushed
-       at any time by openssl. It is included only so curl compiles
-       under versions of openssl < 0.9.5a.
-
-       WARNING: How curl behaves if it's session is flushed is
-       untested.
-    */
-#endif
-    retcode = Curl_ssl_addsessionid(conn, our_ssl_sessionid,
-                                    0 /* unknown size */);
-    if(retcode) {
-      failf(data, "failed to store ssl session");
-      return retcode;
-    }
-  }
-
-
-  /* Get server's certificate (note: beware of dynamic allocation) - opt */
-  /* major serious hack alert -- we should check certificates
-   * to authenticate the server; otherwise we risk man-in-the-middle
-   * attack
-   */
-
   connssl->server_cert = SSL_get_peer_certificate(connssl->handle);
   if(!connssl->server_cert) {
-    failf(data, "SSL: couldn't get peer certificate!");
+    if(strict)
+      failf(data, "SSL: couldn't get peer certificate!");
     return CURLE_PEER_FAILED_VERIFICATION;
   }
   infof (data, "Server certificate:\n");
 
   str = X509_NAME_oneline(X509_get_subject_name(connssl->server_cert),
                           NULL, 0);
   if(!str) {
-    failf(data, "SSL: couldn't get X509-subject!");
+    if(strict)
+      failf(data, "SSL: couldn't get X509-subject!");
     X509_free(connssl->server_cert);
     connssl->server_cert = NULL;
     return CURLE_SSL_CONNECT_ERROR;
   }
   infof(data, "\t subject: %s\n", str);
   CRYPTO_free(str);
 
   certdate = X509_get_notBefore(connssl->server_cert);
-  Curl_ASN1_UTCTIME_output(conn, "\t start date: ", certdate);
+  asn1_output(conn, "\t start date: ", certdate);
 
   certdate = X509_get_notAfter(connssl->server_cert);
-  Curl_ASN1_UTCTIME_output(conn, "\t expire date: ", certdate);
+  asn1_output(conn, "\t expire date: ", certdate);
 
   if(data->set.ssl.verifyhost) {
     retcode = verifyhost(conn, connssl->server_cert);
     if(retcode) {
       X509_free(connssl->server_cert);
       connssl->server_cert = NULL;
@@ -1654,13 +1621,14 @@
     }
   }
 
   str = X509_NAME_oneline(X509_get_issuer_name(connssl->server_cert),
                           NULL, 0);
   if(!str) {
-    failf(data, "SSL: couldn't get X509-issuer name!");
+    if(strict)
+      failf(data, "SSL: couldn't get X509-issuer name!");
     retcode = CURLE_SSL_CONNECT_ERROR;
   }
   else {
     infof(data, "\t issuer: %s\n", str);
     CRYPTO_free(str);
 
@@ -1670,14 +1638,15 @@
     lerr = data->set.ssl.certverifyresult=
       SSL_get_verify_result(connssl->handle);
     if(data->set.ssl.certverifyresult != X509_V_OK) {
       if(data->set.ssl.verifypeer) {
         /* We probably never reach this, because SSL_connect() will fail
            and we return earlyer if verifypeer is set? */
-        failf(data, "SSL certificate verify result: %s (%ld)",
-              X509_verify_cert_error_string(lerr), lerr);
+        if(strict)
+          failf(data, "SSL certificate verify result: %s (%ld)",
+                X509_verify_cert_error_string(lerr), lerr);
         retcode = CURLE_PEER_FAILED_VERIFICATION;
       }
       else
         infof(data, "SSL certificate verify result: %s (%ld),"
               " continuing anyway.\n",
               X509_verify_cert_error_string(lerr), lerr);
@@ -1686,40 +1655,102 @@
       infof(data, "SSL certificate verify ok.\n");
   }
 
   X509_free(connssl->server_cert);
   connssl->server_cert = NULL;
   connssl->connecting_state = ssl_connect_done;
+
+  return retcode;
+}
+
+
+static CURLcode
+ossl_connect_step3(struct connectdata *conn,
+                   int sockindex)
+{
+  CURLcode retcode = CURLE_OK;
+  void *ssl_sessionid=NULL;
+  struct SessionHandle *data = conn->data;
+  struct ssl_connect_data *connssl = &conn->ssl[sockindex];
+
+  DEBUGASSERT(ssl_connect_3 == connssl->connecting_state);
+
+  if(Curl_ssl_getsessionid(conn, &ssl_sessionid, NULL)) {
+    /* Since this is not a cached session ID, then we want to stach this one
+       in the cache! */
+    SSL_SESSION *our_ssl_sessionid;
+#ifdef HAVE_SSL_GET1_SESSION
+    our_ssl_sessionid = SSL_get1_session(connssl->handle);
+
+    /* SSL_get1_session() will increment the reference
+       count and the session will stay in memory until explicitly freed with
+       SSL_SESSION_free(3), regardless of its state.
+       This function was introduced in openssl 0.9.5a. */
+#else
+    our_ssl_sessionid = SSL_get_session(connssl->handle);
+
+    /* if SSL_get1_session() is unavailable, use SSL_get_session().
+       This is an inferior option because the session can be flushed
+       at any time by openssl. It is included only so curl compiles
+       under versions of openssl < 0.9.5a.
+
+       WARNING: How curl behaves if it's session is flushed is
+       untested.
+    */
+#endif
+    retcode = Curl_ssl_addsessionid(conn, our_ssl_sessionid,
+                                    0 /* unknown size */);
+    if(retcode) {
+      failf(data, "failed to store ssl session");
+      return retcode;
+    }
+  }
+
+
+  /*
+   * We check certificates to authenticate the server; otherwise we risk
+   * man-in-the-middle attack; NEVERTHELESS, if we're told explicitly not to
+   * verify the peer ignore faults and failures from the server cert
+   * operations.
+   */
+
+  if(!data->set.ssl.verifypeer)
+    (void)servercert(conn, connssl, FALSE);
+  else
+    retcode = servercert(conn, connssl, TRUE);
+
+  if(CURLE_OK == retcode)
+    connssl->connecting_state = ssl_connect_done;
   return retcode;
 }
 
 static CURLcode
-Curl_ossl_connect_common(struct connectdata *conn,
-                         int sockindex,
-                         bool nonblocking,
-                         bool *done)
+ossl_connect_common(struct connectdata *conn,
+                    int sockindex,
+                    bool nonblocking,
+                    bool *done)
 {
   CURLcode retcode;
   struct SessionHandle *data = conn->data;
   struct ssl_connect_data *connssl = &conn->ssl[sockindex];
   curl_socket_t sockfd = conn->sock[sockindex];
   long timeout_ms;
 
-  if (ssl_connect_1==connssl->connecting_state) {
-    retcode = Curl_ossl_connect_step1(conn, sockindex);
-    if (retcode)
+  if(ssl_connect_1==connssl->connecting_state) {
+    retcode = ossl_connect_step1(conn, sockindex);
+    if(retcode)
       return retcode;
   }
 
   timeout_ms = 0;
-  while (ssl_connect_2 == connssl->connecting_state ||
-         ssl_connect_2_reading == connssl->connecting_state ||
-         ssl_connect_2_writing == connssl->connecting_state) {
+  while(ssl_connect_2 == connssl->connecting_state ||
+        ssl_connect_2_reading == connssl->connecting_state ||
+        ssl_connect_2_writing == connssl->connecting_state) {
 
     /* if ssl is expecting something, check if it's available. */
-    if (connssl->connecting_state == ssl_connect_2_reading
+    if(connssl->connecting_state == ssl_connect_2_reading
         || connssl->connecting_state == ssl_connect_2_writing) {
 
       int writefd = ssl_connect_2_writing==
         connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
       int readfd = ssl_connect_2_reading==
         connssl->connecting_state?sockfd:CURL_SOCKET_BAD;
@@ -1727,13 +1758,13 @@
       while(1) {
         int what = Curl_socket_ready(readfd, writefd, nonblocking?0:(int)timeout_ms);
         if(what > 0)
           /* readable or writable, go loop in the outer loop */
           break;
         else if(0 == what) {
-          if (nonblocking) {
+          if(nonblocking) {
             *done = FALSE;
             return CURLE_OK;
           }
           else {
             /* timeout */
             failf(data, "SSL connection timeout");
@@ -1746,26 +1777,26 @@
           return CURLE_SSL_CONNECT_ERROR;
         }
       } /* while()-loop for the select() */
     }
 
     /* get the timeout from step2 to avoid computing it twice. */
-    retcode = Curl_ossl_connect_step2(conn, sockindex, &timeout_ms);
-    if (retcode)
+    retcode = ossl_connect_step2(conn, sockindex, &timeout_ms);
+    if(retcode)
       return retcode;
 
   } /* repeat step2 until all transactions are done. */
 
 
-  if (ssl_connect_3==connssl->connecting_state) {
-    retcode = Curl_ossl_connect_step3(conn, sockindex);
-    if (retcode)
+  if(ssl_connect_3==connssl->connecting_state) {
+    retcode = ossl_connect_step3(conn, sockindex);
+    if(retcode)
       return retcode;
   }
 
-  if (ssl_connect_done==connssl->connecting_state) {
+  if(ssl_connect_done==connssl->connecting_state) {
     *done = TRUE;
   }
   else {
     *done = FALSE;
   }
 
@@ -1777,24 +1808,24 @@
 
 CURLcode
 Curl_ossl_connect_nonblocking(struct connectdata *conn,
                               int sockindex,
                               bool *done)
 {
-  return Curl_ossl_connect_common(conn, sockindex, TRUE, done);
+  return ossl_connect_common(conn, sockindex, TRUE, done);
 }
 
 CURLcode
 Curl_ossl_connect(struct connectdata *conn,
                   int sockindex)
 {
   CURLcode retcode;
   bool done = FALSE;
 
-  retcode = Curl_ossl_connect_common(conn, sockindex, FALSE, &done);
-  if (retcode)
+  retcode = ossl_connect_common(conn, sockindex, FALSE, &done);
+  if(retcode)
     return retcode;
 
   DEBUGASSERT(done);
 
   return CURLE_OK;
 }
@@ -1821,25 +1852,25 @@
     case SSL_ERROR_WANT_WRITE:
       /* The operation did not complete; the same TLS/SSL I/O function
          should be called again later. This is basicly an EWOULDBLOCK
          equivalent. */
       return 0;
     case SSL_ERROR_SYSCALL:
-      failf(conn->data, "SSL_write() returned SYSCALL, errno = %d\n",
+      failf(conn->data, "SSL_write() returned SYSCALL, errno = %d",
             SOCKERRNO);
       return -1;
     case SSL_ERROR_SSL:
       /*  A failure in the SSL library occurred, usually a protocol error.
           The OpenSSL error queue contains more information on the error. */
       sslerror = ERR_get_error();
-      failf(conn->data, "SSL_write() error: %s\n",
+      failf(conn->data, "SSL_write() error: %s",
             ERR_error_string(sslerror, error_buffer));
       return -1;
     }
     /* a true error */
-    failf(conn->data, "SSL_write() return error %d\n", err);
+    failf(conn->data, "SSL_write() return error %d", err);
     return -1;
   }
   return (ssize_t)rc; /* number of bytes */
 }
 
 /*
@@ -1889,13 +1920,13 @@
 #ifdef YASSL_VERSION
   /* yassl provides an OpenSSL API compatiblity layer so it looks identical
      to OpenSSL in all other aspects */
   return snprintf(buffer, size, "yassl/%s", YASSL_VERSION);
 #else /* YASSL_VERSION */
 
-#if (SSLEAY_VERSION_NUMBER >= 0x905000)
+#if(SSLEAY_VERSION_NUMBER >= 0x905000)
   {
     char sub[2];
     unsigned long ssleay_value;
     sub[1]='\0';
     ssleay_value=SSLeay();
     if(ssleay_value < 0x906000) {
@@ -1916,13 +1947,13 @@
                     (ssleay_value>>12)&0xff,
                     sub);
   }
 
 #else /* SSLEAY_VERSION_NUMBER is less than 0.9.5 */
 
-#if (SSLEAY_VERSION_NUMBER >= 0x900000)
+#if(SSLEAY_VERSION_NUMBER >= 0x900000)
   return snprintf(buffer, size, "OpenSSL/%lx.%lx.%lx",
                   (SSLEAY_VERSION_NUMBER>>28)&0xff,
                   (SSLEAY_VERSION_NUMBER>>20)&0xff,
                   (SSLEAY_VERSION_NUMBER>>12)&0xf);
 
 #else /* (SSLEAY_VERSION_NUMBER >= 0x900000) */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strdup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strdup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strdup.c	2007-05-02 21:46:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strdup.c	2007-11-07 17:21:36.000000000 +0800
@@ -2,43 +2,43 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strdup.c,v 1.3 2007-05-01 20:50:50 danf Exp $
+ * $Id: strdup.c,v 1.4 2007-11-07 09:21:36 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 #include "strdup.h"
 
 #ifndef HAVE_STRDUP
 char *curlx_strdup(const char *str)
 {
   int len;
   char *newstr;
 
-  if (!str)
+  if(!str)
     return (char *)NULL;
 
   len = strlen(str);
   newstr = (char *) malloc((len+1)*sizeof(char));
-  if (!newstr)
+  if(!newstr)
     return (char *)NULL;
 
   memcpy(newstr,str,(len+1)*sizeof(char));
 
   return newstr;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strequal.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strequal.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strequal.c	2007-09-26 20:51:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strequal.c	2007-11-07 17:21:36.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.c,v 1.32 2007-09-25 17:33:56 danf Exp $
+ * $Id: strequal.c,v 1.33 2007-11-07 09:21:36 bagder Exp $
  ***************************************************************************/
 
 #ifndef _GNU_SOURCE
 /* glibc needs this to define the prototype for strcasestr */
 #define _GNU_SOURCE 1
 #endif
@@ -49,14 +49,14 @@
   return !(strcasecmp)(first, second);
 #elif defined(HAVE_STRCMPI)
   return !(strcmpi)(first, second);
 #elif defined(HAVE_STRICMP)
   return !(stricmp)(first, second);
 #else
-  while (*first && *second) {
-    if (toupper(*first) != toupper(*second)) {
+  while(*first && *second) {
+    if(toupper(*first) != toupper(*second)) {
       break;
     }
     first++;
     second++;
   }
   return toupper(*first) == toupper(*second);
@@ -69,14 +69,14 @@
   return !strncasecmp(first, second, max);
 #elif defined(HAVE_STRCMPI)
   return !strncmpi(first, second, max);
 #elif defined(HAVE_STRICMP)
   return !strnicmp(first, second, max);
 #else
-  while (*first && *second && max) {
-    if (toupper(*first) != toupper(*second)) {
+  while(*first && *second && max) {
+    if(toupper(*first) != toupper(*second)) {
       break;
     }
     max--;
     first++;
     second++;
   }
@@ -129,21 +129,21 @@
   char *d = dst;
   const char *s = src;
   size_t n = siz;
   size_t dlen;
 
   /* Find the end of dst and adjust bytes left but don't go past end */
-  while (n-- != 0 && *d != '\0')
+  while(n-- != 0 && *d != '\0')
     d++;
   dlen = d - dst;
   n = siz - dlen;
 
-  if (n == 0)
+  if(n == 0)
     return(dlen + strlen(s));
-  while (*s != '\0') {
-    if (n != 1) {
+  while(*s != '\0') {
+    if(n != 1) {
       *d++ = *s;
       n--;
     }
     s++;
   }
   *d = '\0';
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strerror.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strerror.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strerror.c	2007-10-03 16:07:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strerror.c	2007-11-07 17:21:36.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strerror.c,v 1.48 2007-10-03 08:07:50 bagder Exp $
+ * $Id: strerror.c,v 1.49 2007-11-07 09:21:36 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifdef HAVE_STRERROR_R
 #if !defined(HAVE_POSIX_STRERROR_R) && !defined(HAVE_GLIBC_STRERROR_R)
@@ -291,13 +291,13 @@
    *
    * The line number for the error will be near this comment, which
    * is why it is here, and not at the start of the switch.
    */
   return "Unknown error";
 #else
-  if (error == CURLE_OK)
+  if(error == CURLE_OK)
     return "No error";
   else
     return "Error";
 #endif
 }
 
@@ -333,13 +333,13 @@
   case CURLM_LAST:
     break;
   }
 
   return "Unknown error";
 #else
-  if (error == CURLM_OK)
+  if(error == CURLM_OK)
     return "No error";
   else
     return "Error";
 #endif
 }
 
@@ -366,13 +366,13 @@
   case CURLSHE_LAST:
     break;
   }
 
   return "CURLSHcode unknown";
 #else
-  if (error == CURLSHE_OK)
+  if(error == CURLSHE_OK)
     return "No error";
   else
     return "Error";
 #endif
 }
 
@@ -552,13 +552,13 @@
     break;
 
   default:
     return NULL;
   }
 #else
-  if (err == CURLE_OK)
+  if(err == CURLE_OK)
     return NULL;
   else
     p = "error";
 #endif
   strncpy (buf, p, len);
   buf [len-1] = '\0';
@@ -601,16 +601,16 @@
     wcstombs(buf,wbuf,max);
   }
 
 #else
 
   /* 'sys_nerr' is the maximum errno number, it is not widely portable */
-  if (err >= 0 && err < sys_nerr)
+  if(err >= 0 && err < sys_nerr)
     strncpy(buf, strerror(err), max);
   else {
-    if (!get_winsock_error(err, buf, max) &&
+    if(!get_winsock_error(err, buf, max) &&
         !FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
                        LANG_NEUTRAL, buf, (DWORD)max, NULL))
       snprintf(buf, max, "Unknown error %d (%#x)", err, err);
   }
 #endif
 #else /* not USE_WINSOCK coming up */
@@ -643,15 +643,15 @@
 #endif /* end of HAVE_STRERROR_R */
 #endif /* end of ! USE_WINSOCK */
 
   buf[max] = '\0'; /* make sure the string is zero terminated */
 
   /* strip trailing '\r\n' or '\n'. */
-  if ((p = strrchr(buf,'\n')) != NULL && (p - buf) >= 2)
+  if((p = strrchr(buf,'\n')) != NULL && (p - buf) >= 2)
      *p = '\0';
-  if ((p = strrchr(buf,'\r')) != NULL && (p - buf) >= 1)
+  if((p = strrchr(buf,'\r')) != NULL && (p - buf) >= 1)
      *p = '\0';
   return buf;
 }
 
 #ifdef USE_LIBIDN
 /*
@@ -713,18 +713,18 @@
     default:
       snprintf(buf, max, "error %d", (int)err);
       str = NULL;
       break;
   }
 #else
-  if ((Idna_rc)err == IDNA_SUCCESS)
+  if((Idna_rc)err == IDNA_SUCCESS)
     str = "No error";
   else
     str = "Error";
 #endif
-  if (str)
+  if(str)
     strncpy(buf, str, max);
   buf[max] = '\0';
   return (buf);
 #endif
 }
 #endif  /* USE_LIBIDN */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strtok.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strtok.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strtok.c	2004-01-29 21:56:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strtok.c	2007-11-07 17:21:36.000000000 +0800
@@ -1,27 +1,27 @@
 /***************************************************************************
- *                                  _   _ ____  _     
- *  Project                     ___| | | |  _ \| |    
- *                             / __| | | | |_) | |    
- *                            | (__| |_| |  _ <| |___ 
+ *                                  _   _ ____  _
+ *  Project                     ___| | | |  _ \| |
+ *                             / __| | | | |_) | |
+ *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2004, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
- * 
+ *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strtok.c,v 1.13 2004/01/29 13:56:45 bagder Exp $
+ * $Id: strtok.c,v 1.14 2007-11-07 09:21:36 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef HAVE_STRTOK_R
 #include <stddef.h>
@@ -29,33 +29,33 @@
 
 #include "strtok.h"
 
 char *
 Curl_strtok_r(char *ptr, const char *sep, char **end)
 {
-  if (!ptr)
+  if(!ptr)
     /* we got NULL input so then we get our last position instead */
     ptr = *end;
 
   /* pass all letters that are including in the separator string */
-  while (*ptr && strchr(sep, *ptr))
+  while(*ptr && strchr(sep, *ptr))
     ++ptr;
 
-  if (*ptr) {
+  if(*ptr) {
     /* so this is where the next piece of string starts */
     char *start = ptr;
 
     /* set the end pointer to the first byte after the start */
     *end = start + 1;
 
     /* scan through the string to find where it ends, it ends on a
        null byte or a character that exists in the separator string */
-    while (**end && !strchr(sep, **end))
+    while(**end && !strchr(sep, **end))
       ++*end;
 
-    if (**end) {
+    if(**end) {
       /* the end is not a null byte */
       **end = '\0';  /* zero terminate it! */
       ++*end;        /* advance the last pointer to beyond the null byte */
     }
 
     return start; /* return the position where the string starts */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strtoofft.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strtoofft.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strtoofft.c	2007-08-05 04:47:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strtoofft.c	2007-11-05 17:45:09.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strtoofft.c,v 1.12 2007-08-04 20:47:59 bagder Exp $
+ * $Id: strtoofft.c,v 1.13 2007-11-05 09:45:09 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 #include "strtoofft.h"
 
 /*
@@ -37,13 +37,13 @@
 #include <ctype.h>
 #include <errno.h>
 
 /* Range tests can be used for alphanum decoding if characters are consecutive,
    like in ASCII. Else an array is scanned. Determine this condition now. */
 
-#if ('9' - '0') != 9 || ('Z' - 'A') != 25 || ('z' - 'a') != 25
+#if('9' - '0') != 9 || ('Z' - 'A') != 25 || ('z' - 'a') != 25
 #include <string.h>
 
 #define NO_RANGE_TEST
 
 static const char valchars[] =
             "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
@@ -64,85 +64,85 @@
   int i;
   curl_off_t value = 0;
   curl_off_t newval;
 
   /* Skip leading whitespace. */
   end = (char *)nptr;
-  while (ISSPACE(end[0])) {
+  while(ISSPACE(end[0])) {
     end++;
   }
 
   /* Handle the sign, if any. */
-  if (end[0] == '-') {
+  if(end[0] == '-') {
     is_negative = 1;
     end++;
   }
-  else if (end[0] == '+') {
+  else if(end[0] == '+') {
     end++;
   }
-  else if (end[0] == '\0') {
+  else if(end[0] == '\0') {
     /* We had nothing but perhaps some whitespace -- there was no number. */
-    if (endptr) {
+    if(endptr) {
       *endptr = end;
     }
     return 0;
   }
 
   /* Handle special beginnings, if present and allowed. */
-  if (end[0] == '0' && end[1] == 'x') {
-    if (base == 16 || base == 0) {
+  if(end[0] == '0' && end[1] == 'x') {
+    if(base == 16 || base == 0) {
       end += 2;
       base = 16;
     }
   }
-  else if (end[0] == '0') {
-    if (base == 8 || base == 0) {
+  else if(end[0] == '0') {
+    if(base == 8 || base == 0) {
       end++;
       base = 8;
     }
   }
 
   /* Matching strtol, if the base is 0 and it doesn't look like
    * the number is octal or hex, we assume it's base 10.
    */
-  if (base == 0) {
+  if(base == 0) {
     base = 10;
   }
 
   /* Loop handling digits. */
   value = 0;
   overflow = 0;
   for (i = get_char(end[0], base);
        i != -1;
        end++, i = get_char(end[0], base)) {
     newval = base * value + i;
-    if (newval < value) {
+    if(newval < value) {
       /* We've overflowed. */
       overflow = 1;
       break;
     }
     else
       value = newval;
   }
 
-  if (!overflow) {
-    if (is_negative) {
+  if(!overflow) {
+    if(is_negative) {
       /* Fix the sign. */
       value *= -1;
     }
   }
   else {
-    if (is_negative)
+    if(is_negative)
       value = CURL_LLONG_MIN;
     else
       value = CURL_LLONG_MAX;
 
     SET_ERRNO(ERANGE);
   }
 
-  if (endptr)
+  if(endptr)
     *endptr = end;
 
   return value;
 }
 
 /**
@@ -156,37 +156,37 @@
  * @return  the value of c in base, or -1 if c isn't in range
  */
 static int get_char(char c, int base)
 {
 #ifndef NO_RANGE_TEST
   int value = -1;
-  if (c <= '9' && c >= '0') {
+  if(c <= '9' && c >= '0') {
     value = c - '0';
   }
-  else if (c <= 'Z' && c >= 'A') {
+  else if(c <= 'Z' && c >= 'A') {
     value = c - 'A' + 10;
   }
-  else if (c <= 'z' && c >= 'a') {
+  else if(c <= 'z' && c >= 'a') {
     value = c - 'a' + 10;
   }
 #else
   const char * cp;
   int value;
 
   cp = memchr(valchars, c, 10 + 26 + 26);
 
-  if (!cp)
+  if(!cp)
     return -1;
 
   value = cp - valchars;
 
-  if (value >= 10 + 26)
+  if(value >= 10 + 26)
     value -= 26;                /* Lowercase. */
 #endif
 
-  if (value >= base) {
+  if(value >= base) {
     value = -1;
   }
 
   return value;
 }
 #endif  /* Only present if we need strtoll, but don't have it. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strtoofft.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strtoofft.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/strtoofft.h	2007-08-08 16:40:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/strtoofft.h	2007-11-07 17:02:02.000000000 +0800
@@ -17,13 +17,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strtoofft.h,v 1.15 2007-08-07 12:44:41 patrickm Exp $
+ * $Id: strtoofft.h,v 1.16 2007-11-06 16:20:54 giva Exp $
  ***************************************************************************/
 
 /*
  * CAUTION: this header is designed to work when included by the app-side
  * as well as the library. Do not mix with library internals!
  */
@@ -42,12 +42,13 @@
 #ifdef HAVE_STRTOLL
 #define curlx_strtoofft strtoll
 #else /* HAVE_STRTOLL */
 
 /* For MSVC7 we can use _strtoi64() which seems to be a strtoll() clone */
 #if defined(_MSC_VER) && (_MSC_VER >= 1300)
+_CRTIMP __int64 __cdecl _strtoi64(const char *, char **, int);  /* in <crt/stdlib.h> */
 #define curlx_strtoofft _strtoi64
 #else /* MSVC7 or later */
 curl_off_t curlx_strtoll(const char *nptr, char **endptr, int base);
 #define curlx_strtoofft curlx_strtoll
 #define NEED_CURL_STRTOLL
 #endif /* MSVC7 or later */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/telnet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/telnet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/telnet.c	2007-10-22 22:30:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/telnet.c	2007-12-09 07:03:52.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: telnet.c,v 1.93 2007-10-17 16:58:32 yangtse Exp $
+ * $Id: telnet.c,v 1.98 2007-12-08 22:50:55 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_TELNET
 /* -- WIN32 approved -- */
@@ -83,33 +83,33 @@
 
 #define SUBBUFSIZE 512
 
 #define CURL_SB_CLEAR(x)  x->subpointer = x->subbuffer;
 #define CURL_SB_TERM(x)   { x->subend = x->subpointer; CURL_SB_CLEAR(x); }
 #define CURL_SB_ACCUM(x,c) \
-  if (x->subpointer < (x->subbuffer+sizeof x->subbuffer)) { \
+  if(x->subpointer < (x->subbuffer+sizeof x->subbuffer)) { \
     *x->subpointer++ = (c); \
   }
 
 #define  CURL_SB_GET(x) ((*x->subpointer++)&0xff)
 #define  CURL_SB_PEEK(x)   ((*x->subpointer)&0xff)
 #define  CURL_SB_EOF(x) (x->subpointer >= x->subend)
 #define  CURL_SB_LEN(x) (x->subend - x->subpointer)
 
 #ifdef CURL_DISABLE_VERBOSE_STRINGS
-#define printoption(a,b,c,d)  do { } while (0)
+#define printoption(a,b,c,d)  do { } while(0)
 #endif
 
 #ifdef USE_WINSOCK
 typedef FARPROC WSOCK2_FUNC;
 static CURLcode check_wsock2 ( struct SessionHandle *data );
 #endif
 
 static
 void telrcv(struct connectdata *,
-            unsigned char *inbuf,       /* Data received from socket */
+            const unsigned char *inbuf, /* Data received from socket */
             ssize_t count);             /* Number of bytes received */
 
 #ifndef CURL_DISABLE_VERBOSE_STRINGS
 static void printoption(struct SessionHandle *data,
                         const char *direction,
                         int cmd, int option);
@@ -122,14 +122,14 @@
 
 static void printsub(struct SessionHandle *data,
                      int direction, unsigned char *pointer,
                      size_t length);
 static void suboption(struct connectdata *);
 
-static CURLcode Curl_telnet(struct connectdata *conn, bool *done);
-static CURLcode Curl_telnet_done(struct connectdata *conn,
+static CURLcode telnet_do(struct connectdata *conn, bool *done);
+static CURLcode telnet_done(struct connectdata *conn,
                                  CURLcode, bool premature);
 
 /* For negotiation compliant to RFC 1143 */
 #define CURL_NO          0
 #define CURL_YES         1
 #define CURL_WANTYES     2
@@ -179,14 +179,14 @@
  * TELNET protocol handler.
  */
 
 const struct Curl_handler Curl_handler_telnet = {
   "TELNET",                             /* scheme */
   ZERO_NULL,                            /* setup_connection */
-  Curl_telnet,                          /* do_it */
-  Curl_telnet_done,                     /* done */
+  telnet_do,                            /* do_it */
+  telnet_done,                          /* done */
   ZERO_NULL,                            /* do_more */
   ZERO_NULL,                            /* connect_it */
   ZERO_NULL,                            /* connecting */
   ZERO_NULL,                            /* doing */
   ZERO_NULL,                            /* proto_getsock */
   ZERO_NULL,                            /* doing_getsock */
@@ -210,23 +210,23 @@
   wVersionRequested = MAKEWORD(2, 0);
 
   err = WSAStartup(wVersionRequested, &wsaData);
 
   /* We must've called this once already, so this call */
   /* should always succeed.  But, just in case... */
-  if (err != 0) {
+  if(err != 0) {
     failf(data,"WSAStartup failed (%d)",err);
     return CURLE_FAILED_INIT;
   }
 
   /* We have to have a WSACleanup call for every successful */
   /* WSAStartup call. */
   WSACleanup();
 
   /* Check that our version is supported */
-  if (LOBYTE(wsaData.wVersion) != LOBYTE(wVersionRequested) ||
+  if(LOBYTE(wsaData.wVersion) != LOBYTE(wVersionRequested) ||
       HIBYTE(wsaData.wVersion) != HIBYTE(wVersionRequested)) {
       /* Our version isn't supported */
       failf(data,"insufficient winsock version to support "
             "telnet");
       return CURLE_FAILED_INIT;
   }
@@ -242,13 +242,13 @@
   struct TELNET *tn;
 
   tn = (struct TELNET *)calloc(1, sizeof(struct TELNET));
   if(!tn)
     return CURLE_OUT_OF_MEMORY;
 
-  conn->data->reqdata.proto.telnet = (void *)tn; /* make us known */
+  conn->data->state.proto.telnet = (void *)tn; /* make us known */
 
   tn->telrcv_state = CURL_TS_DATA;
 
   /* Init suboptions */
   CURL_SB_CLEAR(tn);
 
@@ -261,13 +261,13 @@
   return CURLE_OK;
 }
 
 static void negotiate(struct connectdata *conn)
 {
   int i;
-  struct TELNET *tn = (struct TELNET *) conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *) conn->data->state.proto.telnet;
 
   for(i = 0;i < CURL_NTELOPTS;i++)
   {
     if(tn->us_preferred[i] == CURL_YES)
       set_local_option(conn, i, CURL_YES);
 
@@ -280,30 +280,30 @@
 static void printoption(struct SessionHandle *data,
                         const char *direction, int cmd, int option)
 {
   const char *fmt;
   const char *opt;
 
-  if (data->set.verbose)
+  if(data->set.verbose)
   {
-    if (cmd == CURL_IAC)
+    if(cmd == CURL_IAC)
     {
-      if (CURL_TELCMD_OK(option))
+      if(CURL_TELCMD_OK(option))
         infof(data, "%s IAC %s\n", direction, CURL_TELCMD(option));
       else
         infof(data, "%s IAC %d\n", direction, option);
     }
     else
     {
       fmt = (cmd == CURL_WILL) ? "WILL" : (cmd == CURL_WONT) ? "WONT" :
         (cmd == CURL_DO) ? "DO" : (cmd == CURL_DONT) ? "DONT" : 0;
-      if (fmt)
+      if(fmt)
       {
-        if (CURL_TELOPT_OK(option))
+        if(CURL_TELOPT_OK(option))
           opt = CURL_TELOPT(option);
-        else if (option == CURL_TELOPT_EXOPL)
+        else if(option == CURL_TELOPT_EXOPL)
           opt = "EXOPL";
         else
           opt = NULL;
 
         if(opt)
           infof(data, "%s %s %s\n", direction, fmt, opt);
@@ -337,13 +337,13 @@
    printoption(conn->data, "SENT", cmd, option);
 }
 
 static
 void set_remote_option(struct connectdata *conn, int option, int newstate)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   if(newstate == CURL_YES)
   {
     switch(tn->him[option])
     {
       case CURL_NO:
         tn->him[option] = CURL_WANTYES;
@@ -419,13 +419,13 @@
   }
 }
 
 static
 void rec_will(struct connectdata *conn, int option)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   switch(tn->him[option])
   {
     case CURL_NO:
       if(tn->him_preferred[option] == CURL_YES)
       {
         tn->him[option] = CURL_YES;
@@ -472,13 +472,13 @@
   }
 }
 
 static
 void rec_wont(struct connectdata *conn, int option)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   switch(tn->him[option])
   {
     case CURL_NO:
       /* Already disabled */
       break;
 
@@ -517,13 +517,13 @@
   }
 }
 
 static void
 set_local_option(struct connectdata *conn, int option, int newstate)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   if(newstate == CURL_YES)
   {
     switch(tn->us[option])
     {
       case CURL_NO:
         tn->us[option] = CURL_WANTYES;
@@ -599,13 +599,13 @@
   }
 }
 
 static
 void rec_do(struct connectdata *conn, int option)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   switch(tn->us[option])
   {
     case CURL_NO:
       if(tn->us_preferred[option] == CURL_YES)
       {
         tn->us[option] = CURL_YES;
@@ -652,13 +652,13 @@
   }
 }
 
 static
 void rec_dont(struct connectdata *conn, int option)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   switch(tn->us[option])
   {
     case CURL_NO:
       /* Already disabled */
       break;
 
@@ -702,51 +702,51 @@
                      int direction,             /* '<' or '>' */
                      unsigned char *pointer,    /* where suboption data is */
                      size_t length)             /* length of suboption data */
 {
   unsigned int i = 0;
 
-  if (data->set.verbose)
+  if(data->set.verbose)
   {
-    if (direction)
+    if(direction)
     {
       infof(data, "%s IAC SB ", (direction == '<')? "RCVD":"SENT");
-      if (length >= 3)
+      if(length >= 3)
       {
         int j;
 
         i = pointer[length-2];
         j = pointer[length-1];
 
-        if (i != CURL_IAC || j != CURL_SE)
+        if(i != CURL_IAC || j != CURL_SE)
         {
           infof(data, "(terminated by ");
-          if (CURL_TELOPT_OK(i))
+          if(CURL_TELOPT_OK(i))
             infof(data, "%s ", CURL_TELOPT(i));
-          else if (CURL_TELCMD_OK(i))
+          else if(CURL_TELCMD_OK(i))
             infof(data, "%s ", CURL_TELCMD(i));
           else
             infof(data, "%d ", i);
-          if (CURL_TELOPT_OK(j))
+          if(CURL_TELOPT_OK(j))
             infof(data, "%s", CURL_TELOPT(j));
-          else if (CURL_TELCMD_OK(j))
+          else if(CURL_TELCMD_OK(j))
             infof(data, "%s", CURL_TELCMD(j));
           else
             infof(data, "%d", j);
           infof(data, ", not IAC SE!) ");
         }
       }
       length -= 2;
     }
-    if (length < 1)
+    if(length < 1)
     {
       infof(data, "(Empty suboption?)");
       return;
     }
 
-    if (CURL_TELOPT_OK(pointer[0])) {
+    if(CURL_TELOPT_OK(pointer[0])) {
       switch(pointer[0]) {
         case CURL_TELOPT_TTYPE:
         case CURL_TELOPT_XDISPLOC:
         case CURL_TELOPT_NEW_ENVIRON:
           infof(data, "%s", CURL_TELOPT(pointer[0]));
           break;
@@ -800,13 +800,13 @@
       default:
         for (i = 2; i < length; i++)
           infof(data, " %.2x", pointer[i]);
         break;
     }
 
-    if (direction)
+    if(direction)
     {
       infof(data, "\n");
     }
   }
 }
 
@@ -814,13 +814,13 @@
 {
   struct curl_slist *head;
   char option_keyword[128];
   char option_arg[256];
   char *buf;
   struct SessionHandle *data = conn->data;
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
 
   /* Add the user name as an environment variable if it
      was given on the command line */
   if(conn->bits.user_passwd)
   {
     snprintf(option_arg, sizeof(option_arg), "USER,%s", conn->user);
@@ -885,13 +885,13 @@
   size_t len;
   size_t tmplen;
   int err;
   char varname[128];
   char varval[128];
   struct SessionHandle *data = conn->data;
-  struct TELNET *tn = (struct TELNET *)data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)data->state.proto.telnet;
 
   printsub(data, '<', (unsigned char *)tn->subbuffer, CURL_SB_LEN(tn)+2);
   switch (CURL_SB_GET(tn)) {
     case CURL_TELOPT_TTYPE:
       len = strlen(tn->subopt_ttype) + 4 + 2;
       snprintf((char *)temp, sizeof(temp),
@@ -946,126 +946,141 @@
   }
   return;
 }
 
 static
 void telrcv(struct connectdata *conn,
-            unsigned char *inbuf,       /* Data received from socket */
+            const unsigned char *inbuf, /* Data received from socket */
             ssize_t count)              /* Number of bytes received */
 {
   unsigned char c;
   int in = 0;
+  int startwrite=-1;
   struct SessionHandle *data = conn->data;
-  struct TELNET *tn = (struct TELNET *)data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)data->state.proto.telnet;
+
+#define startskipping() \
+    if(startwrite >= 0) \
+       Curl_client_write(conn, CLIENTWRITE_BODY, (char *)&inbuf[startwrite], in-startwrite); \
+    startwrite = -1
+
+#define writebyte() \
+    if(startwrite < 0) \
+      startwrite = in
+
+#define bufferflush() startskipping()
 
   while(count--)
   {
-    c = inbuf[in++];
+    c = inbuf[in];
 
+    /*infof(data,"In rcv state %d char %d\n", tn->telrcv_state, c);*/
     switch (tn->telrcv_state)
     {
       case CURL_TS_CR:
         tn->telrcv_state = CURL_TS_DATA;
-        if (c == '\0')
+        if(c == '\0')
         {
+          startskipping();
           break;   /* Ignore \0 after CR */
         }
-
-        Curl_client_write(conn, CLIENTWRITE_BODY, (char *)&c, 1);
-        continue;
+        writebyte();
+        break;
 
       case CURL_TS_DATA:
-        if (c == CURL_IAC)
+        if(c == CURL_IAC)
         {
           tn->telrcv_state = CURL_TS_IAC;
+          startskipping();
           break;
         }
         else if(c == '\r')
         {
           tn->telrcv_state = CURL_TS_CR;
         }
-
-        Curl_client_write(conn, CLIENTWRITE_BODY, (char *)&c, 1);
-        continue;
+        writebyte();
+        break;
 
       case CURL_TS_IAC:
       process_iac:
+      DEBUGASSERT(startwrite < 0);
       switch (c)
       {
         case CURL_WILL:
           tn->telrcv_state = CURL_TS_WILL;
-          continue;
+          break;
         case CURL_WONT:
           tn->telrcv_state = CURL_TS_WONT;
-          continue;
+          break;
         case CURL_DO:
           tn->telrcv_state = CURL_TS_DO;
-          continue;
+          break;
         case CURL_DONT:
           tn->telrcv_state = CURL_TS_DONT;
-          continue;
+          break;
         case CURL_SB:
           CURL_SB_CLEAR(tn);
           tn->telrcv_state = CURL_TS_SB;
-          continue;
+          break;
         case CURL_IAC:
-          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)&c, 1);
+          tn->telrcv_state = CURL_TS_DATA;
+          writebyte();
           break;
         case CURL_DM:
         case CURL_NOP:
         case CURL_GA:
         default:
+          tn->telrcv_state = CURL_TS_DATA;
           printoption(data, "RCVD", CURL_IAC, c);
           break;
       }
-      tn->telrcv_state = CURL_TS_DATA;
-      continue;
+      break;
 
       case CURL_TS_WILL:
         printoption(data, "RCVD", CURL_WILL, c);
         tn->please_negotiate = 1;
         rec_will(conn, c);
         tn->telrcv_state = CURL_TS_DATA;
-        continue;
+        break;
 
       case CURL_TS_WONT:
         printoption(data, "RCVD", CURL_WONT, c);
         tn->please_negotiate = 1;
         rec_wont(conn, c);
         tn->telrcv_state = CURL_TS_DATA;
-        continue;
+        break;
 
       case CURL_TS_DO:
         printoption(data, "RCVD", CURL_DO, c);
         tn->please_negotiate = 1;
         rec_do(conn, c);
         tn->telrcv_state = CURL_TS_DATA;
-        continue;
+        break;
 
       case CURL_TS_DONT:
         printoption(data, "RCVD", CURL_DONT, c);
         tn->please_negotiate = 1;
         rec_dont(conn, c);
         tn->telrcv_state = CURL_TS_DATA;
-        continue;
+        break;
 
       case CURL_TS_SB:
-        if (c == CURL_IAC)
+        if(c == CURL_IAC)
         {
           tn->telrcv_state = CURL_TS_SE;
         }
         else
         {
           CURL_SB_ACCUM(tn,c);
         }
-        continue;
+        break;
 
       case CURL_TS_SE:
-        if (c != CURL_SE)
+        if(c != CURL_SE)
         {
-          if (c != CURL_IAC)
+          if(c != CURL_IAC)
           {
             /*
              * This is an error.  We only expect to get "IAC IAC" or "IAC SE".
              * Several things may have happend.  An IAC was not doubled, the
              * IAC SE was left off, or another option got inserted into the
              * suboption are all possibilities.  If we assume that the IAC was
@@ -1094,31 +1109,33 @@
           CURL_SB_TERM(tn);
           suboption(conn);   /* handle sub-option */
           tn->telrcv_state = CURL_TS_DATA;
         }
         break;
     }
+    ++in;
   }
+  bufferflush();
 }
 
-static CURLcode Curl_telnet_done(struct connectdata *conn,
+static CURLcode telnet_done(struct connectdata *conn,
                                  CURLcode status, bool premature)
 {
-  struct TELNET *tn = (struct TELNET *)conn->data->reqdata.proto.telnet;
+  struct TELNET *tn = (struct TELNET *)conn->data->state.proto.telnet;
   (void)status; /* unused */
   (void)premature; /* not used */
 
   curl_slist_free_all(tn->telnet_vars);
 
-  free(conn->data->reqdata.proto.telnet);
-  conn->data->reqdata.proto.telnet = NULL;
+  free(conn->data->state.proto.telnet);
+  conn->data->state.proto.telnet = NULL;
 
   return CURLE_OK;
 }
 
-static CURLcode Curl_telnet(struct connectdata *conn, bool *done)
+static CURLcode telnet_do(struct connectdata *conn, bool *done)
 {
   CURLcode code;
   struct SessionHandle *data = conn->data;
   curl_socket_t sockfd = conn->sock[FIRSTSOCKET];
 #ifdef USE_WINSOCK
   HMODULE wsock2;
@@ -1140,71 +1157,71 @@
 #endif
   ssize_t nread;
   bool keepon = TRUE;
   char *buf = data->state.buffer;
   struct TELNET *tn;
 
-  *done = TRUE; /* uncontionally */
+  *done = TRUE; /* unconditionally */
 
   code = init_telnet(conn);
   if(code)
     return code;
 
-  tn = (struct TELNET *)data->reqdata.proto.telnet;
+  tn = (struct TELNET *)data->state.proto.telnet;
 
   code = check_telnet_options(conn);
   if(code)
     return code;
 
 #ifdef USE_WINSOCK
   /*
   ** This functionality only works with WinSock >= 2.0.  So,
   ** make sure have it.
   */
   code = check_wsock2(data);
-  if (code)
+  if(code)
     return code;
 
   /* OK, so we have WinSock 2.0.  We need to dynamically */
   /* load ws2_32.dll and get the function pointers we need. */
   wsock2 = LoadLibrary("WS2_32.DLL");
-  if (wsock2 == NULL) {
+  if(wsock2 == NULL) {
     failf(data,"failed to load WS2_32.DLL (%d)", ERRNO);
     return CURLE_FAILED_INIT;
   }
 
   /* Grab a pointer to WSACreateEvent */
   create_event_func = GetProcAddress(wsock2,"WSACreateEvent");
-  if (create_event_func == NULL) {
+  if(create_event_func == NULL) {
     failf(data,"failed to find WSACreateEvent function (%d)",
           ERRNO);
     FreeLibrary(wsock2);
     return CURLE_FAILED_INIT;
   }
 
   /* And WSACloseEvent */
   close_event_func = GetProcAddress(wsock2,"WSACloseEvent");
-  if (close_event_func == NULL) {
+  if(close_event_func == NULL) {
     failf(data,"failed to find WSACloseEvent function (%d)",
           ERRNO);
     FreeLibrary(wsock2);
     return CURLE_FAILED_INIT;
   }
 
   /* And WSAEventSelect */
   event_select_func = GetProcAddress(wsock2,"WSAEventSelect");
-  if (event_select_func == NULL) {
+  if(event_select_func == NULL) {
     failf(data,"failed to find WSAEventSelect function (%d)",
           ERRNO);
     FreeLibrary(wsock2);
     return CURLE_FAILED_INIT;
   }
 
   /* And WSAEnumNetworkEvents */
   enum_netevents_func = GetProcAddress(wsock2,"WSAEnumNetworkEvents");
-  if (enum_netevents_func == NULL) {
+  if(enum_netevents_func == NULL) {
     failf(data,"failed to find WSAEnumNetworkEvents function (%d)",
           ERRNO);
     FreeLibrary(wsock2);
     return CURLE_FAILED_INIT;
   }
 
@@ -1212,13 +1229,13 @@
   ** the select() function in winsock only works on sockets
   ** we have to use the WaitForMultipleObjects() call.
   */
 
   /* First, create a sockets event object */
   event_handle = (WSAEVENT)create_event_func();
-  if (event_handle == WSA_INVALID_EVENT) {
+  if(event_handle == WSA_INVALID_EVENT) {
     failf(data,"WSACreateEvent failed (%d)", SOCKERRNO);
     FreeLibrary(wsock2);
     return CURLE_FAILED_INIT;
   }
 
   /* The get the Windows file handle for stdin */
@@ -1340,33 +1357,33 @@
       }
       break;
     }
   }
 
   /* We called WSACreateEvent, so call WSACloseEvent */
-  if (close_event_func(event_handle) == FALSE) {
+  if(close_event_func(event_handle) == FALSE) {
     infof(data,"WSACloseEvent failed (%d)", SOCKERRNO);
   }
 
   /* "Forget" pointers into the library we're about to free */
   create_event_func = NULL;
   close_event_func = NULL;
   event_select_func = NULL;
   enum_netevents_func = NULL;
 
   /* We called LoadLibrary, so call FreeLibrary */
-  if (!FreeLibrary(wsock2))
+  if(!FreeLibrary(wsock2))
     infof(data,"FreeLibrary(wsock2) failed (%d)", ERRNO);
 #else
   pfd[0].fd = sockfd;
   pfd[0].events = POLLIN;
   pfd[1].fd = 0;
   pfd[1].events = POLLIN;
   interval_ms = 1 * 1000;
 
-  while (keepon) {
+  while(keepon) {
     switch (Curl_poll(pfd, 2, interval_ms)) {
     case -1:                    /* error, stop reading */
       keepon = FALSE;
       continue;
     case 0:                     /* timeout */
       break;
@@ -1393,13 +1410,13 @@
       if(pfd[0].revents & POLLIN) {
         /* This OUGHT to check the return code... */
         (void)Curl_read(conn, sockfd, buf, BUFSIZE - 1, &nread);
 
         /* if we receive 0 or less here, the server closed the connection and
            we bail out from this! */
-        if (nread <= 0) {
+        if(nread <= 0) {
           keepon = FALSE;
           break;
         }
 
         telrcv(conn, (unsigned char *)buf, nread);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/tftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/tftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/tftp.c	2007-10-25 17:34:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/tftp.c	2008-01-22 07:47:28.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: tftp.c,v 1.56 2007-10-25 09:34:16 bagder Exp $
+ * $Id: tftp.c,v 1.65 2008-01-15 23:19:02 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #ifndef CURL_DISABLE_TFTP
 /* -- WIN32 approved -- */
@@ -148,30 +148,30 @@
 } tftp_state_data_t;
 
 
 /* Forward declarations */
 static CURLcode tftp_rx(tftp_state_data_t *state, tftp_event_t event) ;
 static CURLcode tftp_tx(tftp_state_data_t *state, tftp_event_t event) ;
-static CURLcode Curl_tftp_connect(struct connectdata *conn, bool *done);
-static CURLcode Curl_tftp(struct connectdata *conn, bool *done);
-static CURLcode Curl_tftp_done(struct connectdata *conn,
+static CURLcode tftp_connect(struct connectdata *conn, bool *done);
+static CURLcode tftp_do(struct connectdata *conn, bool *done);
+static CURLcode tftp_done(struct connectdata *conn,
                                CURLcode, bool premature);
-static CURLcode Curl_tftp_setup_connection(struct connectdata * conn);
+static CURLcode tftp_setup_connection(struct connectdata * conn);
 
 
 /*
  * TFTP protocol handler.
  */
 
 const struct Curl_handler Curl_handler_tftp = {
   "TFTP",                               /* scheme */
-  Curl_tftp_setup_connection,           /* setup_connection */
-  Curl_tftp,                            /* do_it */
-  Curl_tftp_done,                       /* done */
+  tftp_setup_connection,                /* setup_connection */
+  tftp_do,                              /* do_it */
+  tftp_done,                            /* done */
   ZERO_NULL,                            /* do_more */
-  Curl_tftp_connect,                    /* connect_it */
+  tftp_connect,                         /* connect_it */
   ZERO_NULL,                            /* connecting */
   ZERO_NULL,                            /* doing */
   ZERO_NULL,                            /* proto_getsock */
   ZERO_NULL,                            /* doing_getsock */
   ZERO_NULL,                            /* disconnect */
   PORT_TFTP,                            /* defport */
@@ -303,37 +303,38 @@
       return res;
     }
 
     if(data->set.upload) {
       /* If we are uploading, send an WRQ */
       setpacketevent(&state->spacket, TFTP_EVENT_WRQ);
-      state->conn->data->reqdata.upload_fromhere = (char *)&state->spacket.data[4];
+      state->conn->data->req.upload_fromhere =
+        (char *)&state->spacket.data[4];
       if(data->set.infilesize != -1)
         Curl_pgrsSetUploadSize(data, data->set.infilesize);
     }
     else {
       /* If we are downloading, send an RRQ */
       setpacketevent(&state->spacket, TFTP_EVENT_RRQ);
     }
     /* As RFC3617 describes the separator slash is not actually part of the
     file name so we skip the always-present first letter of the path string. */
-    filename = curl_easy_unescape(data, &state->conn->data->reqdata.path[1], 0,
+    filename = curl_easy_unescape(data, &state->conn->data->state.path[1], 0,
                                   NULL);
-    if (!filename)
+    if(!filename)
       return CURLE_OUT_OF_MEMORY;
 
     snprintf((char *)&state->spacket.data[2],
              TFTP_BLOCKSIZE,
              "%s%c%s%c", filename, '\0',  mode, '\0');
     sbytes = 4 + (int)strlen(filename) + (int)strlen(mode);
     sbytes = sendto(state->sockfd, (void *)&state->spacket,
                     sbytes, 0,
                     state->conn->ip_addr->ai_addr,
                     state->conn->ip_addr->ai_addrlen);
     if(sbytes < 0) {
-      failf(data, "%s\n", Curl_strerror(state->conn, SOCKERRNO));
+      failf(data, "%s", Curl_strerror(state->conn, SOCKERRNO));
     }
     Curl_safefree(filename);
     break;
 
   case TFTP_EVENT_ACK: /* Connected for transmit */
     infof(data, "%s\n", "Connected for transmit");
@@ -349,13 +350,13 @@
 
   case TFTP_EVENT_ERROR:
     state->state = TFTP_STATE_FIN;
     break;
 
   default:
-    failf(state->conn->data, "tftp_send_first: internal error\n");
+    failf(state->conn->data, "tftp_send_first: internal error");
     break;
   }
   return res;
 }
 
 /**********************************************************
@@ -374,19 +375,19 @@
   switch(event) {
 
   case TFTP_EVENT_DATA:
 
     /* Is this the block we expect? */
     rblock = getrpacketblock(&state->rpacket);
-    if ((state->block+1) != rblock) {
+    if((state->block+1) != rblock) {
       /* No, log it, up the retry count and fail if over the limit */
       infof(data,
             "Received unexpected DATA packet block %d\n", rblock);
       state->retries++;
-      if (state->retries>state->retry_max) {
-        failf(data, "tftp_rx: giving up waiting for block %d\n",
+      if(state->retries>state->retry_max) {
+        failf(data, "tftp_rx: giving up waiting for block %d",
               state->block+1);
         return CURLE_TFTP_ILLEGAL;
       }
     }
     /* This is the expected block.  Reset counters and ACK it. */
     state->block = (unsigned short)rblock;
@@ -395,18 +396,18 @@
     setpacketblock(&state->spacket, state->block);
     sbytes = sendto(state->sockfd, (void *)state->spacket.data,
                     4, SEND_4TH_ARG,
                     (struct sockaddr *)&state->remote_addr,
                     state->remote_addrlen);
     if(sbytes < 0) {
-      failf(data, "%s\n", Curl_strerror(state->conn, SOCKERRNO));
+      failf(data, "%s", Curl_strerror(state->conn, SOCKERRNO));
       return CURLE_SEND_ERROR;
     }
 
     /* Check if completed (That is, a less than full packet is received) */
-    if (state->rbytes < (int)sizeof(state->spacket)){
+    if(state->rbytes < (int)sizeof(state->spacket)){
       state->state = TFTP_STATE_FIN;
     }
     else {
       state->state = TFTP_STATE_RX;
     }
     break;
@@ -425,24 +426,24 @@
       sbytes = sendto(state->sockfd, (void *)&state->spacket,
                       4, SEND_4TH_ARG,
                       (struct sockaddr *)&state->remote_addr,
                       state->remote_addrlen);
       /* Check all sbytes were sent */
       if(sbytes<0) {
-        failf(data, "%s\n", Curl_strerror(state->conn, SOCKERRNO));
+        failf(data, "%s", Curl_strerror(state->conn, SOCKERRNO));
         return CURLE_SEND_ERROR;
       }
     }
     break;
 
   case TFTP_EVENT_ERROR:
     state->state = TFTP_STATE_FIN;
     break;
 
   default:
-    failf(data, "%s\n", "tftp_rx: internal error");
+    failf(data, "%s", "tftp_rx: internal error");
     return CURLE_TFTP_ILLEGAL; /* not really the perfect return code for
                                   this */
   }
   return CURLE_OK;
 }
 
@@ -456,13 +457,13 @@
 static CURLcode tftp_tx(tftp_state_data_t *state, tftp_event_t event)
 {
   struct SessionHandle *data = state->conn->data;
   int sbytes;
   int rblock;
   CURLcode res = CURLE_OK;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct SingleRequest *k = &data->req;
 
   switch(event) {
 
   case TFTP_EVENT_ACK:
     /* Ack the packet */
     rblock = getrpacketblock(&state->rpacket);
@@ -483,13 +484,13 @@
         sbytes = sendto(state->sockfd, (void *)&state->spacket,
                         4+state->sbytes, SEND_4TH_ARG,
                         (struct sockaddr *)&state->remote_addr,
                         state->remote_addrlen);
         /* Check all sbytes were sent */
         if(sbytes<0) {
-          failf(data, "%s\n", Curl_strerror(state->conn, SOCKERRNO));
+          failf(data, "%s", Curl_strerror(state->conn, SOCKERRNO));
           res = CURLE_SEND_ERROR;
         }
       }
       return res;
     }
     /* This is the expected packet.  Reset the counters and send the next
@@ -508,13 +509,13 @@
     sbytes = sendto(state->sockfd, (void *)state->spacket.data,
                     4+state->sbytes, SEND_4TH_ARG,
                     (struct sockaddr *)&state->remote_addr,
                     state->remote_addrlen);
     /* Check all sbytes were sent */
     if(sbytes<0) {
-      failf(data, "%s\n", Curl_strerror(state->conn, SOCKERRNO));
+      failf(data, "%s", Curl_strerror(state->conn, SOCKERRNO));
       return CURLE_SEND_ERROR;
     }
     /* Update the progress meter */
     k->writebytecount += state->sbytes;
     Curl_pgrsSetUploadCounter(data, k->writebytecount);
     break;
@@ -534,26 +535,26 @@
       sbytes = sendto(state->sockfd, (void *)&state->spacket,
                       4+state->sbytes, SEND_4TH_ARG,
                       (struct sockaddr *)&state->remote_addr,
                       state->remote_addrlen);
       /* Check all sbytes were sent */
       if(sbytes<0) {
-        failf(data, "%s\n", Curl_strerror(state->conn, SOCKERRNO));
+        failf(data, "%s", Curl_strerror(state->conn, SOCKERRNO));
         return CURLE_SEND_ERROR;
       }
       /* since this was a re-send, we remain at the still byte position */
       Curl_pgrsSetUploadCounter(data, k->writebytecount);
     }
     break;
 
   case TFTP_EVENT_ERROR:
     state->state = TFTP_STATE_FIN;
     break;
 
   default:
-    failf(data, "%s\n", "tftp_tx: internal error");
+    failf(data, "%s", "tftp_tx: internal error");
     break;
   }
 
   return res;
 }
 
@@ -584,40 +585,41 @@
     break;
   case TFTP_STATE_FIN:
     infof(data, "%s\n", "TFTP finished");
     break;
   default:
     DEBUGF(infof(data, "STATE: %d\n", state->state));
-    failf(data, "%s\n", "Internal state machine error");
+    failf(data, "%s", "Internal state machine error");
     res = CURLE_TFTP_ILLEGAL;
     break;
   }
   return res;
 }
 
 
 /**********************************************************
  *
- * Curl_tftp_connect
+ * tftp_connect
  *
  * The connect callback
  *
  **********************************************************/
-static CURLcode Curl_tftp_connect(struct connectdata *conn, bool *done)
+static CURLcode tftp_connect(struct connectdata *conn, bool *done)
 {
   CURLcode code;
   tftp_state_data_t *state;
   int rc;
 
   /* If there already is a protocol-specific struct allocated for this
      sessionhandle, deal with it */
   Curl_reset_reqproto(conn);
 
-  if(!(state = conn->data->reqdata.proto.tftp)) {
-    state = conn->data->reqdata.proto.tftp = calloc(sizeof(tftp_state_data_t),
-                                                    1);
+  state = conn->data->state.proto.tftp;
+  if(!state) {
+    state = conn->data->state.proto.tftp = calloc(sizeof(tftp_state_data_t),
+                                                  1);
     if(!state)
       return CURLE_OUT_OF_MEMORY;
   }
 
   conn->bits.close = FALSE; /* keep it open if possible */
 
@@ -645,13 +647,13 @@
      * assume uses the same IP version and thus hopefully this works for both
      * IPv4 and IPv6...
      */
     rc = bind(state->sockfd, (struct sockaddr *)&state->local_addr,
               conn->ip_addr->ai_addrlen);
     if(rc) {
-      failf(conn->data, "bind() failed; %s\n",
+      failf(conn->data, "bind() failed; %s",
             Curl_strerror(conn, SOCKERRNO));
       return CURLE_COULDNT_CONNECT;
     }
     conn->bits.bound = TRUE;
   }
 
@@ -661,74 +663,67 @@
   code = CURLE_OK;
   return(code);
 }
 
 /**********************************************************
  *
- * Curl_tftp_done
+ * tftp_done
  *
  * The done callback
  *
  **********************************************************/
-static CURLcode Curl_tftp_done(struct connectdata *conn, CURLcode status,
+static CURLcode tftp_done(struct connectdata *conn, CURLcode status,
                                bool premature)
 {
   (void)status; /* unused */
   (void)premature; /* not used */
 
-#if 0
-  free(conn->data->reqdata.proto.tftp);
-  conn->data->reqdata.proto.tftp = NULL;
-#endif
   Curl_pgrsDone(conn);
 
   return CURLE_OK;
 }
 
 
 /**********************************************************
  *
- * Curl_tftp
+ * tftp
  *
  * The do callback
  *
  * This callback handles the entire TFTP transfer
  *
  **********************************************************/
 
-static CURLcode Curl_tftp(struct connectdata *conn, bool *done)
+static CURLcode tftp_do(struct connectdata *conn, bool *done)
 {
   struct SessionHandle  *data = conn->data;
-  tftp_state_data_t     *state =
-    (tftp_state_data_t *) conn->data->reqdata.proto.tftp;
+  tftp_state_data_t     *state;
   tftp_event_t          event;
   CURLcode              code;
   int                   rc;
   struct Curl_sockaddr_storage fromaddr;
   socklen_t             fromlen;
   int                   check_time = 0;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct SingleRequest *k = &data->req;
 
   *done = TRUE;
 
   /*
     Since connections can be re-used between SessionHandles, this might be a
     connection already existing but on a fresh SessionHandle struct so we must
     make sure we have a good 'struct TFTP' to play with. For new connections,
-    the struct TFTP is allocated and setup in the Curl_tftp_connect() function.
+    the struct TFTP is allocated and setup in the tftp_connect() function.
   */
-  if(!state) {
-    code = Curl_tftp_connect(conn, done);
+  Curl_reset_reqproto(conn);
+
+  if(!data->state.proto.tftp) {
+    code = tftp_connect(conn, done);
     if(code)
       return code;
-    state = (tftp_state_data_t *)conn->data->reqdata.proto.tftp;
   }
-
-  code = Curl_readwrite_init(conn);
-  if(code)
-    return code;
+  state = (tftp_state_data_t *)data->state.proto.tftp;
 
   /* Run the TFTP State Machine */
   for(code=tftp_state_machine(state, TFTP_EVENT_INIT);
       (state->state != TFTP_STATE_FIN) && (code == CURLE_OK);
       code=tftp_state_machine(state, event) ) {
 
@@ -736,16 +731,16 @@
     rc=Curl_socket_ready(state->sockfd, CURL_SOCKET_BAD,
                          state->retry_time * 1000);
 
     if(rc == -1) {
       /* bail out */
       int error = SOCKERRNO;
-      failf(data, "%s\n", Curl_strerror(conn, error));
+      failf(data, "%s", Curl_strerror(conn, error));
       event = TFTP_EVENT_ERROR;
     }
-    else if (rc==0) {
+    else if(rc==0) {
       /* A timeout occured */
       event = TFTP_EVENT_TIMEOUT;
 
       /* Force a look at transfer timeouts */
       check_time = 0;
 
@@ -760,46 +755,46 @@
       if(state->remote_addrlen==0) {
         memcpy(&state->remote_addr, &fromaddr, fromlen);
         state->remote_addrlen = fromlen;
       }
 
       /* Sanity check packet length */
-      if (state->rbytes < 4) {
-        failf(conn->data, "Received too short packet\n");
+      if(state->rbytes < 4) {
+        failf(data, "Received too short packet");
         /* Not a timeout, but how best to handle it? */
         event = TFTP_EVENT_TIMEOUT;
       }
       else {
 
         /* The event is given by the TFTP packet time */
         event = (tftp_event_t)getrpacketevent(&state->rpacket);
 
         switch(event) {
         case TFTP_EVENT_DATA:
           /* Don't pass to the client empty or retransmitted packets */
-          if (state->rbytes > 4 &&
+          if(state->rbytes > 4 &&
               ((state->block+1) == getrpacketblock(&state->rpacket))) {
             code = Curl_client_write(conn, CLIENTWRITE_BODY,
                                      (char *)&state->rpacket.data[4],
                                      state->rbytes-4);
             if(code)
               return code;
             k->bytecount += state->rbytes-4;
             Curl_pgrsSetDownloadCounter(data, (curl_off_t) k->bytecount);
           }
           break;
         case TFTP_EVENT_ERROR:
           state->error = (tftp_error_t)getrpacketblock(&state->rpacket);
-          infof(conn->data, "%s\n", (char *)&state->rpacket.data[4]);
+          infof(data, "%s\n", (char *)&state->rpacket.data[4]);
           break;
         case TFTP_EVENT_ACK:
           break;
         case TFTP_EVENT_RRQ:
         case TFTP_EVENT_WRQ:
         default:
-          failf(conn->data, "%s\n", "Internal error: Unexpected packet");
+          failf(data, "%s", "Internal error: Unexpected packet");
           break;
         }
 
         /* Update the progress meter */
         if(Curl_pgrsUpdate(conn))
           return CURLE_ABORTED_BY_CALLBACK;
@@ -867,28 +862,28 @@
   }
   else
     code = CURLE_OK;
   return code;
 }
 
-static CURLcode Curl_tftp_setup_connection(struct connectdata * conn)
+static CURLcode tftp_setup_connection(struct connectdata * conn)
 {
   struct SessionHandle *data = conn->data;
   char * type;
   char command;
 
   conn->socktype = SOCK_DGRAM;   /* UDP datagram based */
 
   /* TFTP URLs support an extension like ";mode=<typecode>" that
    * we'll try to get now! */
-  type = strstr(data->reqdata.path, ";mode=");
+  type = strstr(data->state.path, ";mode=");
 
-  if (!type)
+  if(!type)
     type = strstr(conn->host.rawalloc, ";mode=");
 
-  if (type) {
+  if(type) {
     *type = 0;                   /* it was in the middle of the hostname */
     command = (char) toupper((int) type[6]);
 
     switch (command) {
     case 'A': /* ASCII mode */
     case 'N': /* NETASCII mode */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/transfer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/transfer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/transfer.c	2007-10-22 22:30:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/transfer.c	2008-01-16 20:24:00.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.c,v 1.370 2007-10-15 18:32:01 patrickm Exp $
+ * $Id: transfer.c,v 1.381 2008-01-16 12:24:00 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -119,54 +119,62 @@
   size_t buffersize = (size_t)bytes;
   int nread;
 
   if(conn->bits.upload_chunky) {
     /* if chunked Transfer-Encoding */
     buffersize -= (8 + 2 + 2);   /* 32bit hex + CRLF + CRLF */
-    data->reqdata.upload_fromhere += 10; /* 32bit hex + CRLF */
+    data->req.upload_fromhere += 10; /* 32bit hex + CRLF */
   }
 
   /* this function returns a size_t, so we typecast to int to prevent warnings
      with picky compilers */
-  nread = (int)conn->fread_func(data->reqdata.upload_fromhere, 1,
-                           buffersize, conn->fread_in);
+  nread = (int)conn->fread_func(data->req.upload_fromhere, 1,
+                                buffersize, conn->fread_in);
 
   if(nread == CURL_READFUNC_ABORT) {
-    failf(data, "operation aborted by callback\n");
+    failf(data, "operation aborted by callback");
     return CURLE_ABORTED_BY_CALLBACK;
   }
+  else if(nread == CURL_READFUNC_PAUSE) {
+    struct SingleRequest *k = &data->req;
+    k->keepon |= KEEP_READ_PAUSE; /* mark reading as paused */
+    return CURLE_OK; /* nothing was read */
+  }
+  else if((size_t)nread > buffersize)
+    /* the read function returned a too large value */
+    return CURLE_READ_ERROR;
 
   if(!conn->bits.forbidchunk && conn->bits.upload_chunky) {
     /* if chunked Transfer-Encoding */
     char hexbuffer[11];
     int hexlen = snprintf(hexbuffer, sizeof(hexbuffer),
                           "%x\r\n", nread);
     /* move buffer pointer */
-    data->reqdata.upload_fromhere -= hexlen;
+    data->req.upload_fromhere -= hexlen;
     nread += hexlen;
 
     /* copy the prefix to the buffer */
-    memcpy(data->reqdata.upload_fromhere, hexbuffer, hexlen);
+    memcpy(data->req.upload_fromhere, hexbuffer, hexlen);
 
     /* always append CRLF to the data */
-    memcpy(data->reqdata.upload_fromhere + nread, "\r\n", 2);
+    memcpy(data->req.upload_fromhere + nread, "\r\n", 2);
 
     if((nread - hexlen) == 0) {
       /* mark this as done once this chunk is transfered */
-      data->reqdata.keep.upload_done = TRUE;
+      data->req.upload_done = TRUE;
     }
 
     nread+=2; /* for the added CRLF */
   }
 
   *nreadp = nread;
 
 #ifdef CURL_DOES_CONVERSIONS
   if(data->set.prefer_ascii) {
     CURLcode res;
-    res = Curl_convert_to_network(data, data->reqdata.upload_fromhere, nread);
+    res = Curl_convert_to_network(data, data->req.upload_fromhere, nread);
     /* Curl_convert_to_network calls failf if unsuccessful */
     if(res != CURLE_OK) {
       return(res);
     }
   }
 #endif /* CURL_DOES_CONVERSIONS */
@@ -185,34 +193,34 @@
 {
   struct curl_slist *head = data->set.http200aliases;
   bool rc = FALSE;
 #ifdef CURL_DOES_CONVERSIONS
   /* convert from the network encoding using a scratch area */
   char *scratch = calloc(1, strlen(s)+1);
-  if (NULL == scratch) {
+  if(NULL == scratch) {
      failf (data, "Failed to calloc memory for conversion!");
      return FALSE; /* can't return CURLE_OUT_OF_MEMORY so return FALSE */
   }
   strcpy(scratch, s);
-  if (CURLE_OK != Curl_convert_from_network(data, scratch, strlen(s)+1)) {
+  if(CURLE_OK != Curl_convert_from_network(data, scratch, strlen(s)+1)) {
     /* Curl_convert_from_network calls failf if unsuccessful */
      free(scratch);
      return FALSE; /* can't return CURLE_foobar so return FALSE */
   }
   s = scratch;
 #endif /* CURL_DOES_CONVERSIONS */
 
-  while (head) {
-    if (checkprefix(head->data, s)) {
+  while(head) {
+    if(checkprefix(head->data, s)) {
       rc = TRUE;
       break;
     }
     head = head->next;
   }
 
-  if ((rc != TRUE) && (checkprefix("HTTP/", s))) {
+  if((rc != TRUE) && (checkprefix("HTTP/", s))) {
     rc = TRUE;
   }
 
 #ifdef CURL_DOES_CONVERSIONS
   free(scratch);
 #endif /* CURL_DOES_CONVERSIONS */
@@ -234,22 +242,31 @@
      CURLOPT_HTTPPOST, call app to rewind
   */
   if(data->set.postfields ||
      (data->set.httpreq == HTTPREQ_POST_FORM))
     ; /* do nothing */
   else {
-    if(data->set.ioctl_func) {
+    if(data->set.seek_func) {
+      int err;
+
+      err = (data->set.seek_func)(data->set.seek_client, 0, SEEK_SET);
+      if(err) {
+	failf(data, "seek callback returned error %d", (int)err);
+        return CURLE_SEND_FAIL_REWIND;
+      }
+    }
+    else if(data->set.ioctl_func) {
       curlioerr err;
 
-      err = (data->set.ioctl_func) (data, CURLIOCMD_RESTARTREAD,
-                            data->set.ioctl_client);
+      err = (data->set.ioctl_func)(data, CURLIOCMD_RESTARTREAD,
+                                   data->set.ioctl_client);
       infof(data, "the ioctl callback returned %d\n", (int)err);
 
       if(err) {
         /* FIXME: convert to a human readable error message */
-        failf(data, "ioctl callback returned error %d\n", (int)err);
+        failf(data, "ioctl callback returned error %d", (int)err);
         return CURLE_SEND_FAIL_REWIND;
       }
     }
     else {
       /* If no CURLOPT_READFUNCTION is used, we know that we operate on a
          given FILE * stream and we can actually attempt to rewind that
@@ -258,13 +275,13 @@
         if(-1 != fseek(data->set.in, 0, SEEK_SET))
           /* successful rewind */
           return CURLE_OK;
       }
 
       /* no callback set or failure aboe, makes us fail at once */
-      failf(data, "necessary data rewind wasn't possible\n");
+      failf(data, "necessary data rewind wasn't possible");
       return CURLE_SEND_FAIL_REWIND;
     }
   }
   return CURLE_OK;
 }
 
@@ -289,13 +306,13 @@
 #ifdef CURLDEBUG
   {
     char buf[512 + 1];
     size_t show;
 
     show = MIN(conn->buf_len - conn->read_pos, sizeof(buf)-1);
-    if (conn->master_buffer) {
+    if(conn->master_buffer) {
         memcpy(buf, conn->master_buffer + conn->read_pos, show);
         buf[show] = '\0';
     }
     else {
         buf[0] = '\0';
     }
@@ -312,13 +329,13 @@
  * be read and written to/from the connection.
  */
 CURLcode Curl_readwrite(struct connectdata *conn,
                         bool *done)
 {
   struct SessionHandle *data = conn->data;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct SingleRequest *k = &data->req;
   CURLcode result;
   ssize_t nread; /* number of bytes read */
   int didwhat=0;
 
   curl_socket_t fd_read;
   curl_socket_t fd_write;
@@ -327,27 +344,27 @@
 
   conn->cselect_bits = 0;
 
   /* only use the proper socket if the *_HOLD bit is not set simultaneously as
      then we are in rate limiting state in that transfer direction */
 
-  if((k->keepon & (KEEP_READ|KEEP_READ_HOLD)) == KEEP_READ) {
+  if((k->keepon & KEEP_READBITS) == KEEP_READ) {
     fd_read = conn->sockfd;
 #if defined(USE_LIBSSH2)
-    if (conn->protocol & (PROT_SCP|PROT_SFTP))
+    if(conn->protocol & (PROT_SCP|PROT_SFTP))
       select_res |= CURL_CSELECT_IN;
 #endif /* USE_LIBSSH2 */
   } else
     fd_read = CURL_SOCKET_BAD;
 
-  if((k->keepon & (KEEP_WRITE|KEEP_WRITE_HOLD)) == KEEP_WRITE)
+  if((k->keepon & KEEP_WRITEBITS) == KEEP_WRITE)
     fd_write = conn->writesockfd;
   else
     fd_write = CURL_SOCKET_BAD;
 
-   if (!select_res) { /* Call for select()/poll() only, if read/write/error
+   if(!select_res) { /* Call for select()/poll() only, if read/write/error
                          status is not known. */
        select_res = Curl_socket_ready(fd_read, fd_write, 0);
    }
 
   if(select_res == CURL_CSELECT_ERR) {
     failf(data, "select/poll returned error");
@@ -368,13 +385,13 @@
       do {
         size_t buffersize = data->set.buffer_size?
           data->set.buffer_size : BUFSIZE;
         size_t bytestoread = buffersize;
         int readrc;
 
-        if (k->size != -1 && !k->header) {
+        if(k->size != -1 && !k->header) {
           /* make sure we don't read "too much" if we can help it since we
              might be pipelining and then someone else might want to read what
              follows! */
           curl_off_t totalleft = k->size - k->bytecount;
           if(totalleft < (curl_off_t)bytestoread)
             bytestoread = (size_t)totalleft;
@@ -390,28 +407,28 @@
         /* get the CURLcode from the int */
         result = (CURLcode)readrc;
 
         if(result>0)
           return result;
 
-        if ((k->bytecount == 0) && (k->writebytecount == 0)) {
+        if((k->bytecount == 0) && (k->writebytecount == 0)) {
           Curl_pgrsTime(data, TIMER_STARTTRANSFER);
           if(k->wait100_after_headers)
             /* set time stamp to compare with when waiting for the 100 */
             k->start100 = Curl_tvnow();
         }
 
         didwhat |= KEEP_READ;
         /* indicates data of zero size, i.e. empty file */
         is_empty_data = (bool)((nread == 0) && (k->bodywrites == 0));
 
         /* NULL terminate, allowing string ops to be used */
-        if (0 < nread || is_empty_data) {
+        if(0 < nread || is_empty_data) {
           k->buf[nread] = 0;
         }
-        else if (0 >= nread) {
+        else if(0 >= nread) {
           /* if we receive 0 or less here, the server closed the connection
              and we bail out from this! */
           DEBUGF(infof(data, "nread <= 0, server closed connection, bailing\n"));
           k->keepon &= ~KEEP_READ;
           break;
         }
@@ -419,13 +436,13 @@
         /* Default buffer to use when we write the buffer, it may be changed
            in the flow below before the actual storing is done. */
         k->str = k->buf;
 
         /* Since this is a two-state thing, we check if we are parsing
            headers at the moment or not. */
-        if (k->header) {
+        if(k->header) {
           /* we are in parse-the-header-mode */
           bool stop_reading = FALSE;
 
           /* header line within buffer loop */
           do {
             size_t hbufp_index;
@@ -436,17 +453,17 @@
             /* str_start is start of line within buf */
             k->str_start = k->str;
 
             /* data is in network encoding so use 0x0a instead of '\n' */
             k->end_ptr = memchr(k->str_start, 0x0a, nread);
 
-            if (!k->end_ptr) {
+            if(!k->end_ptr) {
               /* Not a complete header line within buffer, append the data to
                  the end of the headerbuff. */
 
-              if (k->hbuflen + nread >= data->state.headersize) {
+              if(k->hbuflen + nread >= data->state.headersize) {
                 /* We enlarge the header buffer as it is too small */
                 char *newbuff;
                 size_t newsize=CURLMAX((k->hbuflen+nread)*3/2,
                                        data->state.headersize*2);
                 hbufp_index = k->hbufp - data->state.headerbuff;
                 newbuff = (char *)realloc(data->state.headerbuff, newsize);
@@ -458,13 +475,13 @@
                 data->state.headerbuff = newbuff;
                 k->hbufp = data->state.headerbuff + hbufp_index;
               }
               memcpy(k->hbufp, k->str, nread);
               k->hbufp += nread;
               k->hbuflen += nread;
-              if (!k->headerline && (k->hbuflen>5)) {
+              if(!k->headerline && (k->hbuflen>5)) {
                 /* make a first check that this looks like a HTTP header */
                 if(!checkhttpprefix(data, data->state.headerbuff)) {
                   /* this is not the beginning of a HTTP first header line */
                   k->header = FALSE;
                   k->badheader = HEADER_ALLBAD;
                   break;
@@ -485,13 +502,13 @@
             /*
              * We're about to copy a chunk of data to the end of the
              * already received header. We make sure that the full string
              * fit in the allocated header buffer, or else we enlarge
              * it.
              */
-            if (k->hbuflen + full_length >=
+            if(k->hbuflen + full_length >=
                 data->state.headersize) {
               char *newbuff;
               size_t newsize=CURLMAX((k->hbuflen+full_length)*3/2,
                                      data->state.headersize*2);
               hbufp_index = k->hbufp - data->state.headerbuff;
               newbuff = (char *)realloc(data->state.headerbuff, newsize);
@@ -534,29 +551,29 @@
                 break;
               }
             }
 
             /* headers are in network encoding so
                use 0x0a and 0x0d instead of '\n' and '\r' */
-            if ((0x0a == *k->p) || (0x0d == *k->p)) {
+            if((0x0a == *k->p) || (0x0d == *k->p)) {
               size_t headerlen;
               /* Zero-length header line means end of headers! */
 
 #ifdef CURL_DOES_CONVERSIONS
-              if (0x0d == *k->p) {
+              if(0x0d == *k->p) {
                 *k->p = '\r'; /* replace with CR in host encoding */
                 k->p++;       /* pass the CR byte */
               }
-              if (0x0a == *k->p) {
+              if(0x0a == *k->p) {
                 *k->p = '\n'; /* replace with LF in host encoding */
                 k->p++;       /* pass the LF byte */
               }
 #else
-              if ('\r' == *k->p)
+              if('\r' == *k->p)
                 k->p++; /* pass the \r byte */
-              if ('\n' == *k->p)
+              if('\n' == *k->p)
                 k->p++; /* pass the \n byte */
 #endif /* CURL_DOES_CONVERSIONS */
 
               if(100 == k->httpcode) {
                 /*
                  * We have made a HTTP PUT or POST and this is 1.1-lingo
@@ -565,13 +582,13 @@
                  * However, we'll get more headers now so we must get
                  * back into the header-parsing state!
                  */
                 k->header = TRUE;
                 k->headerline = 0; /* restart the header line counter */
                 /* if we did wait for this do enable write now! */
-                if (k->write_after_100_header) {
+                if(k->write_after_100_header) {
 
                   k->write_after_100_header = FALSE;
                   k->keepon |= KEEP_WRITE;
                 }
               }
               else {
@@ -587,13 +604,13 @@
                   infof(data, "no chunk, no close, no size. Assume close to "
                         "signal end\n");
                   conn->bits.close = TRUE;
                 }
               }
 
-              if (417 == k->httpcode) {
+              if(417 == k->httpcode) {
                 /*
                  * we got: "417 Expectation Failed" this means:
                  * we have made a HTTP call and our Expect Header
                  * seems to cause a problem => abort the write operations
                  * (or prevent them from starting).
                  */
@@ -603,40 +620,40 @@
 
 #ifndef CURL_DISABLE_HTTP
               /*
                * When all the headers have been parsed, see if we should give
                * up and return an error.
                */
-              if (Curl_http_should_fail(conn)) {
+              if(Curl_http_should_fail(conn)) {
                 failf (data, "The requested URL returned error: %d",
                        k->httpcode);
                 return CURLE_HTTP_RETURNED_ERROR;
               }
 #endif   /* CURL_DISABLE_HTTP */
 
               /* now, only output this if the header AND body are requested:
                */
               writetype = CLIENTWRITE_HEADER;
-              if (data->set.include_header)
+              if(data->set.include_header)
                 writetype |= CLIENTWRITE_BODY;
 
               headerlen = k->p - data->state.headerbuff;
 
               result = Curl_client_write(conn, writetype,
                                          data->state.headerbuff,
                                          headerlen);
               if(result)
                 return result;
 
               data->info.header_size += (long)headerlen;
-              data->reqdata.keep.headerbytecount += (long)headerlen;
+              data->req.headerbytecount += (long)headerlen;
 
-              data->reqdata.keep.deductheadercount =
-                (100 == k->httpcode)?data->reqdata.keep.headerbytecount:0;
+              data->req.deductheadercount =
+                (100 == k->httpcode)?data->req.headerbytecount:0;
 
-              if (data->reqdata.resume_from &&
+              if(data->state.resume_from &&
                   (data->set.httpreq==HTTPREQ_GET) &&
                   (k->httpcode == 416)) {
                 /* "Requested Range Not Satisfiable" */
                 stop_reading = TRUE;
               }
 
@@ -718,13 +735,13 @@
             }
 
             /*
              * Checks for special headers coming up.
              */
 
-            if (!k->headerline++) {
+            if(!k->headerline++) {
               /* This is the first header, it MUST be the error code line
                  or else we consider this to be the body right away! */
               int httpversion_major;
               int nc;
 #ifdef CURL_DOES_CONVERSIONS
 #define HEADER1 scratch
@@ -738,64 +755,64 @@
               */
               strncpy(&scratch[0], k->p, SCRATCHSIZE);
               scratch[SCRATCHSIZE] = 0; /* null terminate */
               res = Curl_convert_from_network(data,
                                               &scratch[0],
                                               SCRATCHSIZE);
-              if (CURLE_OK != res) {
+              if(CURLE_OK != res) {
                 /* Curl_convert_from_network calls failf if unsuccessful */
                 return res;
               }
 #else
 #define HEADER1 k->p /* no conversion needed, just use k->p */
 #endif /* CURL_DOES_CONVERSIONS */
 
               nc = sscanf(HEADER1,
                           " HTTP/%d.%d %3d",
                           &httpversion_major,
                           &k->httpversion,
                           &k->httpcode);
-              if (nc==3) {
+              if(nc==3) {
                 k->httpversion += 10 * httpversion_major;
               }
               else {
                 /* this is the real world, not a Nirvana
                    NCSA 1.5.x returns this crap when asked for HTTP/1.1
                 */
                 nc=sscanf(HEADER1, " HTTP %3d", &k->httpcode);
                 k->httpversion = 10;
 
                /* If user has set option HTTP200ALIASES,
                   compare header line against list of aliases
                */
-                if (!nc) {
-                  if (checkhttpprefix(data, k->p)) {
+                if(!nc) {
+                  if(checkhttpprefix(data, k->p)) {
                     nc = 1;
                     k->httpcode = 200;
                     k->httpversion = 10;
                   }
                 }
               }
 
-              if (nc) {
+              if(nc) {
                 data->info.httpcode = k->httpcode;
                 data->info.httpversion = k->httpversion;
 
                 /*
                  * This code executes as part of processing the header.  As a
                  * result, it's not totally clear how to interpret the
                  * response code yet as that depends on what other headers may
                  * be present.  401 and 407 may be errors, but may be OK
                  * depending on how authentication is working.  Other codes
                  * are definitely errors, so give up here.
                  */
-                if (data->set.http_fail_on_error && (k->httpcode >= 400) &&
+                if(data->set.http_fail_on_error && (k->httpcode >= 400) &&
                     ((k->httpcode != 401) || !conn->bits.user_passwd) &&
                     ((k->httpcode != 407) || !conn->bits.proxy_user_passwd) ) {
 
-                  if (data->reqdata.resume_from &&
+                  if(data->state.resume_from &&
                       (data->set.httpreq==HTTPREQ_GET) &&
                       (k->httpcode == 416)) {
                     /* "Requested Range Not Satisfiable", just proceed and
                        pretend this is no error */
                   }
                   else {
@@ -810,12 +827,21 @@
                   /* Default action for HTTP/1.0 must be to close, unless
                      we get one of those fancy headers that tell us the
                      server keeps it open for us! */
                   infof(data, "HTTP 1.0, assume close after body\n");
                   conn->bits.close = TRUE;
                 }
+                else if(k->httpversion >= 11 &&
+                        !conn->bits.close) {
+                  /* If HTTP version is >= 1.1 and connection is persistent
+                     server supports pipelining. */
+                  DEBUGF(infof(data,
+                               "HTTP 1.1 or later with persistent connection, "
+                               "pipelining supported\n"));
+                  conn->server_supports_pipelining = TRUE;
+                }
 
                 switch(k->httpcode) {
                 case 204:
                   /* (quote from RFC2616, section 10.2.5): The server has
                    * fulfilled the request but does not need to return an
                    * entity-body ... The 204 response MUST NOT include a
@@ -845,26 +871,26 @@
               }
             }
 
 #ifdef CURL_DOES_CONVERSIONS
             /* convert from the network encoding */
             result = Curl_convert_from_network(data, k->p, strlen(k->p));
-            if (CURLE_OK != result) {
+            if(CURLE_OK != result) {
                return(result);
             }
             /* Curl_convert_from_network calls failf if unsuccessful */
 #endif /* CURL_DOES_CONVERSIONS */
 
             /* Check for Content-Length: header lines to get size. Ignore
                the header completely if we get a 416 response as then we're
                resuming a document that we don't get, and this header contains
                info about the true size of the document we didn't get now. */
-            if (!k->ignorecl && !data->set.ignorecl &&
+            if(!k->ignorecl && !data->set.ignorecl &&
                 checkprefix("Content-Length:", k->p)) {
               contentlength = curlx_strtoofft(k->p+15, NULL, 10);
-              if (data->set.max_filesize &&
+              if(data->set.max_filesize &&
                   contentlength > data->set.max_filesize) {
                 failf(data, "Maximum file size exceeded");
                 return CURLE_FILESIZE_EXCEEDED;
               }
               if(contentlength >= 0) {
                 k->size = contentlength;
@@ -881,13 +907,13 @@
                 conn->bits.close = TRUE;
                 infof(data, "Negative content-length: %" FORMAT_OFF_T
                       ", closing after transfer\n", contentlength);
               }
             }
             /* check for Content-Type: header lines to get the mime-type */
-            else if (checkprefix("Content-Type:", k->p)) {
+            else if(checkprefix("Content-Type:", k->p)) {
               char *start;
               char *end;
               size_t len;
 
               /* Find the first non-space letter */
               for(start=k->p+13;
@@ -910,13 +936,13 @@
                 len = end-start+1;
 
                 /* allocate memory of a cloned copy */
                 Curl_safefree(data->info.contenttype);
 
                 data->info.contenttype = malloc(len + 1);
-                if (NULL == data->info.contenttype)
+                if(NULL == data->info.contenttype)
                   return CURLE_OUT_OF_MEMORY;
 
                 /* copy the content-type string */
                 memcpy(data->info.contenttype, start, len);
                 data->info.contenttype[len] = 0; /* zero terminate */
               }
@@ -954,22 +980,22 @@
                * pleasure.  Default action for 1.0 is to close.
                *
                * [RFC2068, section 19.7.1] */
               conn->bits.close = FALSE; /* don't close when done */
               infof(data, "HTTP/1.0 connection set to keep alive!\n");
             }
-            else if (Curl_compareheader(k->p, "Connection:", "close")) {
+            else if(Curl_compareheader(k->p, "Connection:", "close")) {
               /*
                * [RFC 2616, section 8.1.2.1]
                * "Connection: close" is HTTP/1.1 language and means that
                * the connection will close when this request has been
                * served.
                */
               conn->bits.close = TRUE; /* close when done */
             }
-            else if (Curl_compareheader(k->p,
+            else if(Curl_compareheader(k->p,
                                         "Transfer-Encoding:", "chunked")) {
               /*
                * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
                * means that the server will send a series of "chunks". Each
                * chunk starts with line with info (including size of the
                * coming block) (terminated with CRLF), then a block of data
@@ -979,26 +1005,26 @@
               conn->bits.chunk = TRUE; /* chunks coming our way */
 
               /* init our chunky engine */
               Curl_httpchunk_init(conn);
             }
 
-            else if (checkprefix("Trailer:", k->p) ||
+            else if(checkprefix("Trailer:", k->p) ||
                      checkprefix("Trailers:", k->p)) {
               /*
                * This test helps Curl_httpchunk_read() to determine to look
                * for well formed trailers after the zero chunksize record. In
                * this case a CRLF is required after the zero chunksize record
                * when no trailers are sent, or after the last trailer record.
                *
                * It seems both Trailer: and Trailers: occur in the wild.
                */
-              conn->bits.trailerHdrPresent = TRUE;
+              conn->bits.trailerhdrpresent = TRUE;
             }
 
-            else if (checkprefix("Content-Encoding:", k->p) &&
+            else if(checkprefix("Content-Encoding:", k->p) &&
                      data->set.str[STRING_ENCODING]) {
               /*
                * Process Content-Encoding. Look for the values: identity,
                * gzip, deflate, compress, x-gzip and x-compress. x-gzip and
                * x-compress are the same as gzip and compress. (Sec 3.5 RFC
                * 2616). zlib cannot handle compress.  However, errors are
@@ -1010,24 +1036,24 @@
               for(start=k->p+17;
                   *start && ISSPACE(*start);
                   start++)
                 ;  /* empty loop */
 
               /* Record the content-encoding for later use */
-              if (checkprefix("identity", start))
+              if(checkprefix("identity", start))
                 k->content_encoding = IDENTITY;
-              else if (checkprefix("deflate", start))
+              else if(checkprefix("deflate", start))
                 k->content_encoding = DEFLATE;
-              else if (checkprefix("gzip", start)
+              else if(checkprefix("gzip", start)
                        || checkprefix("x-gzip", start))
                 k->content_encoding = GZIP;
-              else if (checkprefix("compress", start)
+              else if(checkprefix("compress", start)
                        || checkprefix("x-compress", start))
                 k->content_encoding = COMPRESS;
             }
-            else if (checkprefix("Content-Range:", k->p)) {
+            else if(checkprefix("Content-Range:", k->p)) {
               /* Content-Range: bytes [num]-
                  Content-Range: bytes: [num]-
                  Content-Range: [num]-
 
                  The second format was added since Sun's webserver
                  JavaWebServer/1.1.1 obviously sends the header this way!
@@ -1039,13 +1065,13 @@
               /* Move forward until first digit */
               while(*ptr && !ISDIGIT(*ptr))
                 ptr++;
 
               k->offset = curlx_strtoofft(ptr, NULL, 10);
 
-              if (data->reqdata.resume_from == k->offset)
+              if(data->state.resume_from == k->offset)
                 /* we asked for a resume and we got it */
                 k->content_range = TRUE;
             }
 #if !defined(CURL_DISABLE_COOKIES)
             else if(data->cookies &&
                     checkprefix("Set-Cookie:", k->p)) {
@@ -1054,13 +1080,13 @@
               Curl_cookie_add(data,
                               data->cookies, TRUE, k->p+11,
                               /* If there is a custom-set Host: name, use it
                                  here, or else use real peer host name. */
                               conn->allocptr.cookiehost?
                               conn->allocptr.cookiehost:conn->host.name,
-                              data->reqdata.path);
+                              data->state.path);
               Curl_share_unlock(data, CURL_LOCK_DATA_COOKIE);
             }
 #endif
             else if(checkprefix("Last-Modified:", k->p) &&
                     (data->set.timecondition || data->set.get_filetime) ) {
               time_t secs=time(NULL);
@@ -1074,13 +1100,13 @@
                     (checkprefix("Proxy-authenticate:", k->p) &&
                      (407 == k->httpcode))) {
               result = Curl_http_input_auth(conn, k->httpcode, k->p);
               if(result)
                 return result;
             }
-            else if ((k->httpcode >= 300 && k->httpcode < 400) &&
+            else if((k->httpcode >= 300 && k->httpcode < 400) &&
                      checkprefix("Location:", k->p)) {
               if(data->set.http_follow_location) {
                 /* this is the URL that the server advices us to get instead */
                 char *ptr;
                 char *start=k->p;
                 char backup;
@@ -1102,45 +1128,45 @@
                   ptr--;
                 ptr++;
 
                 backup = *ptr; /* store the ending letter */
                 if(ptr != start) {
                   *ptr = '\0';   /* zero terminate */
-                  data->reqdata.newurl = strdup(start); /* clone string */
+                  data->req.newurl = strdup(start); /* clone string */
                   *ptr = backup; /* restore ending letter */
-                  if(!data->reqdata.newurl)
+                  if(!data->req.newurl)
                     return CURLE_OUT_OF_MEMORY;
                 }
               }
             }
 #endif   /* CURL_DISABLE_HTTP */
 
             /*
              * End of header-checks. Write them to the client.
              */
 
             writetype = CLIENTWRITE_HEADER;
-            if (data->set.include_header)
+            if(data->set.include_header)
               writetype |= CLIENTWRITE_BODY;
 
             if(data->set.verbose)
               Curl_debug(data, CURLINFO_HEADER_IN,
                          k->p, (size_t)k->hbuflen, conn);
 
             result = Curl_client_write(conn, writetype, k->p, k->hbuflen);
             if(result)
               return result;
 
             data->info.header_size += (long)k->hbuflen;
-            data->reqdata.keep.headerbytecount += (long)k->hbuflen;
+            data->req.headerbytecount += (long)k->hbuflen;
 
             /* reset hbufp pointer && hbuflen */
             k->hbufp = data->state.headerbuff;
             k->hbuflen = 0;
           }
-          while (!stop_reading && *k->str); /* header line within buffer */
+          while(!stop_reading && *k->str); /* header line within buffer */
 
           if(stop_reading)
             /* We've stopped dealing with input, get out of the do-while loop */
             break;
 
           /* We might have reached the end of the header part here, but
@@ -1149,21 +1175,21 @@
 
         }                       /* end if header mode */
 
         /* This is not an 'else if' since it may be a rest from the header
            parsing, where the beginning of the buffer is headers and the end
            is non-headers. */
-        if (k->str && !k->header && (nread > 0 || is_empty_data)) {
+        if(k->str && !k->header && (nread > 0 || is_empty_data)) {
 
           if(0 == k->bodywrites && !is_empty_data) {
             /* These checks are only made the first time we are about to
                write a piece of the body */
             if(conn->protocol&PROT_HTTP) {
               /* HTTP-only checks */
 
-              if (data->reqdata.newurl) {
+              if(data->req.newurl) {
                 if(conn->bits.close) {
                   /* Abort after the headers if "follow Location" is set
                      and we're set to close anyway. */
                   k->keepon &= ~KEEP_READ;
                   *done = TRUE;
                   return CURLE_OK;
@@ -1171,24 +1197,24 @@
                 /* We have a new url to load, but since we want to be able
                    to re-use this connection properly, we read the full
                    response in "ignore more" */
                 k->ignorebody = TRUE;
                 infof(data, "Ignoring the response-body\n");
               }
-              if (data->reqdata.resume_from && !k->content_range &&
+              if(data->state.resume_from && !k->content_range &&
                   (data->set.httpreq==HTTPREQ_GET) &&
                   !k->ignorebody) {
                 /* we wanted to resume a download, although the server doesn't
                  * seem to support this and we did this with a GET (if it
                  * wasn't a GET we did a POST or PUT resume) */
                 failf(data, "HTTP server doesn't seem to support "
                       "byte ranges. Cannot resume.");
                 return CURLE_RANGE_ERROR;
               }
 
-              if(data->set.timecondition && !data->reqdata.range) {
+              if(data->set.timecondition && !data->state.range) {
                 /* A time condition has been set AND no ranges have been
                    requested. This seems to be what chapter 13.3.4 of
                    RFC 2616 defines to be the correct action for a
                    HTTP/1.1 client */
                 if((k->timeofdoc > 0) && (data->set.timevalue > 0)) {
                   switch(data->set.timecondition) {
@@ -1260,13 +1286,13 @@
                  str buffer that weren't written to the client.
 
                  We DO care about this data if we are pipelining.
                  Push it back to be read on the next pass. */
 
               dataleft = conn->chunk.dataleft;
-              if (dataleft != 0) {
+              if(dataleft != 0) {
                 infof(conn->data, "Leftovers after chunking. "
                       " Rewinding %d bytes\n",dataleft);
                 read_rewind(conn, dataleft);
               }
             }
             /* If it returned OK, we just keep going */
@@ -1275,19 +1301,19 @@
 
           if((-1 != k->maxdownload) &&
              (k->bytecount + nread >= k->maxdownload)) {
             /* The 'excess' amount below can't be more than BUFSIZE which
                always will fit in a size_t */
             size_t excess = (size_t)(k->bytecount + nread - k->maxdownload);
-            if (excess > 0 && !k->ignorebody) {
+            if(excess > 0 && !k->ignorebody) {
               infof(data,
                     "Rewinding stream by : %d"
                     " bytes on url %s (size = %" FORMAT_OFF_T
                     ", maxdownload = %" FORMAT_OFF_T
                     ", bytecount = %" FORMAT_OFF_T ", nread = %d)\n",
-                    excess, conn->data->reqdata.path,
+                    excess, data->state.path,
                     k->size, k->maxdownload, k->bytecount, nread);
               read_rewind(conn, excess);
             }
 
             nread = (ssize_t) (k->maxdownload - k->bytecount);
             if(nread < 0 ) /* this should be unusual */
@@ -1357,15 +1383,15 @@
             k->badheader = HEADER_NORMAL; /* taken care of now */
 
             if(result)
               return result;
           }
 
-        } /* if (! header and data to read ) */
+        } /* if(! header and data to read ) */
 
-        if (is_empty_data) {
+        if(is_empty_data) {
           /* if we received nothing, the server closed the connection and we
              are done */
           k->keepon &= ~KEEP_READ;
         }
 
       } while(data_pending(conn));
@@ -1378,36 +1404,36 @@
       /* write */
 
       ssize_t i, si;
       ssize_t bytes_written;
       bool writedone=TRUE;
 
-      if ((k->bytecount == 0) && (k->writebytecount == 0))
+      if((k->bytecount == 0) && (k->writebytecount == 0))
         Curl_pgrsTime(data, TIMER_STARTTRANSFER);
 
       didwhat |= KEEP_WRITE;
 
       /*
        * We loop here to do the READ and SEND loop until we run out of
        * data to send or until we get EWOULDBLOCK back
        */
       do {
 
         /* only read more data if there's no upload data already
            present in the upload buffer */
-        if(0 == data->reqdata.upload_present) {
+        if(0 == data->req.upload_present) {
           /* init the "upload from here" pointer */
-          data->reqdata.upload_fromhere = k->uploadbuf;
+          data->req.upload_fromhere = k->uploadbuf;
 
           if(!k->upload_done) {
             /* HTTP pollution, this should be written nicer to become more
                protocol agnostic. */
             int fillcount;
 
             if(k->wait100_after_headers &&
-               (data->reqdata.proto.http->sending == HTTPSEND_BODY)) {
+               (data->state.proto.http->sending == HTTPSEND_BODY)) {
               /* If this call is to send body data, we must take some action:
                  We have sent off the full HTTP 1.1 request, and we shall now
                  go into the Expect: 100 state and await such a header */
               k->wait100_after_headers = FALSE; /* headers sent */
               k->write_after_100_header = TRUE; /* wait for the header */
               k->keepon &= ~KEEP_WRITE;         /* disable writing */
@@ -1422,15 +1448,17 @@
 
             nread = (ssize_t)fillcount;
           }
           else
             nread = 0; /* we're done uploading/reading */
 
-          /* the signed int typecase of nread of for systems that has
-             unsigned size_t */
-          if (nread<=0) {
+          if(!nread && (k->keepon & KEEP_READ_PAUSE)) {
+            /* this is a paused transfer */
+            break;
+          }
+          else if(nread<=0) {
             /* done */
             k->keepon &= ~KEEP_WRITE; /* we're done writing */
             writedone = TRUE;
 
             if(conn->bits.rewindaftersend) {
               result = Curl_readrewind(conn);
@@ -1438,20 +1466,20 @@
                 return result;
             }
             break;
           }
 
           /* store number of bytes available for upload */
-          data->reqdata.upload_present = nread;
+          data->req.upload_present = nread;
 
           /* convert LF to CRLF if so asked */
 #ifdef CURL_DO_LINEEND_CONV
           /* always convert if we're FTPing in ASCII mode */
-          if ((data->set.crlf) || (data->set.prefer_ascii)) {
+          if((data->set.crlf) || (data->set.prefer_ascii)) {
 #else
-          if (data->set.crlf) {
+          if(data->set.crlf) {
 #endif /* CURL_DO_LINEEND_CONV */
               if(data->state.scratch == NULL)
                 data->state.scratch = malloc(2*BUFSIZE);
               if(data->state.scratch == NULL) {
                 failf (data, "Failed to alloc scratch buffer!");
                 return CURLE_OUT_OF_MEMORY;
@@ -1460,72 +1488,72 @@
                * ASCII/EBCDIC Note: This is presumably a text (not binary)
                * transfer so the data should already be in ASCII.
                * That means the hex values for ASCII CR (0x0d) & LF (0x0a)
                * must be used instead of the escape sequences \r & \n.
                */
             for(i = 0, si = 0; i < nread; i++, si++) {
-              if (data->reqdata.upload_fromhere[i] == 0x0a) {
+              if(data->req.upload_fromhere[i] == 0x0a) {
                 data->state.scratch[si++] = 0x0d;
                 data->state.scratch[si] = 0x0a;
-                if (!data->set.crlf) {
+                if(!data->set.crlf) {
                   /* we're here only because FTP is in ASCII mode...
                      bump infilesize for the LF we just added */
                   data->set.infilesize++;
                 }
               }
               else
-                data->state.scratch[si] = data->reqdata.upload_fromhere[i];
+                data->state.scratch[si] = data->req.upload_fromhere[i];
             }
             if(si != nread) {
               /* only perform the special operation if we really did replace
                  anything */
               nread = si;
 
               /* upload from the new (replaced) buffer instead */
-              data->reqdata.upload_fromhere = data->state.scratch;
+              data->req.upload_fromhere = data->state.scratch;
 
               /* set the new amount too */
-              data->reqdata.upload_present = nread;
+              data->req.upload_present = nread;
             }
           }
         }
         else {
           /* We have a partial buffer left from a previous "round". Use
              that instead of reading more data */
         }
 
         /* write to socket (send away data) */
         result = Curl_write(conn,
                             conn->writesockfd,     /* socket to send to */
-                            data->reqdata.upload_fromhere, /* buffer pointer */
-                            data->reqdata.upload_present,  /* buffer size */
+                            data->req.upload_fromhere, /* buffer pointer */
+                            data->req.upload_present,  /* buffer size */
                             &bytes_written);       /* actually send away */
         if(result)
           return result;
 
         if(data->set.verbose)
           /* show the data before we change the pointer upload_fromhere */
-          Curl_debug(data, CURLINFO_DATA_OUT, data->reqdata.upload_fromhere,
+          Curl_debug(data, CURLINFO_DATA_OUT, data->req.upload_fromhere,
                      (size_t)bytes_written, conn);
 
-        if(data->reqdata.upload_present != bytes_written) {
+        if(data->req.upload_present != bytes_written) {
           /* we only wrote a part of the buffer (if anything), deal with it! */
 
           /* store the amount of bytes left in the buffer to write */
-          data->reqdata.upload_present -= bytes_written;
+          data->req.upload_present -= bytes_written;
 
           /* advance the pointer where to find the buffer when the next send
              is to happen */
-          data->reqdata.upload_fromhere += bytes_written;
+          data->req.upload_fromhere += bytes_written;
 
           writedone = TRUE; /* we are done, stop the loop */
         }
         else {
           /* we've uploaded that buffer now */
-          data->reqdata.upload_fromhere = k->uploadbuf;
-          data->reqdata.upload_present = 0; /* no more bytes left */
+          data->req.upload_fromhere = k->uploadbuf;
+          data->req.upload_present = 0; /* no more bytes left */
 
           if(k->upload_done) {
             /* switch off writing, we're done! */
             k->keepon &= ~KEEP_WRITE; /* we're done writing */
             writedone = TRUE;
           }
@@ -1547,13 +1575,13 @@
       *k->bytecountp = k->bytecount; /* read count */
     if(k->writebytecountp)
       *k->writebytecountp = k->writebytecount; /* write count */
   }
   else {
     /* no read no write, this is a timeout? */
-    if (k->write_after_100_header) {
+    if(k->write_after_100_header) {
       /* This should allow some time for the header to arrive, but only a
          very short time as otherwise it'll be too much wasted times too
          often. */
 
       /* Quoting RFC2616, section "8.2.3 Use of the 100 (Continue) Status":
 
@@ -1574,18 +1602,18 @@
   }
 
   if(Curl_pgrsUpdate(conn))
     result = CURLE_ABORTED_BY_CALLBACK;
   else
     result = Curl_speedcheck(data, k->now);
-  if (result)
+  if(result)
     return result;
 
-  if (data->set.timeout &&
+  if(data->set.timeout &&
       (Curl_tvdiff(k->now, k->start) >= data->set.timeout)) {
-    if (k->size != -1) {
+    if(k->size != -1) {
       failf(data, "Operation timed out after %ld milliseconds with %"
             FORMAT_OFF_T " out of %" FORMAT_OFF_T " bytes received",
             data->set.timeout, k->bytecount, k->size);
     } else {
       failf(data, "Operation timed out after %ld milliseconds with %"
             FORMAT_OFF_T " bytes received",
@@ -1606,13 +1634,13 @@
        /* Most FTP servers don't adjust their file SIZE response for CRLFs,
           so we'll check to see if the discrepancy can be explained
           by the number of CRLFs we've changed to LFs.
         */
        (k->bytecount != (k->size + data->state.crlf_conversions)) &&
 #endif /* CURL_DO_LINEEND_CONV */
-       !data->reqdata.newurl) {
+       !data->req.newurl) {
       failf(data, "transfer closed with %" FORMAT_OFF_T
             " bytes remaining to read",
             k->size - k->bytecount);
       return CURLE_PARTIAL_FILE;
     }
     else if(!(conn->bits.no_body) &&
@@ -1632,114 +1660,18 @@
     }
     if(Curl_pgrsUpdate(conn))
       return CURLE_ABORTED_BY_CALLBACK;
   }
 
   /* Now update the "done" boolean we return */
-  *done = (bool)(0 == (k->keepon&(KEEP_READ|KEEP_WRITE)));
-
-  return CURLE_OK;
-}
-
-
-/*
- * Curl_readwrite_init() inits the readwrite session. This is inited each time
- * for a transfer, sometimes multiple times on the same SessionHandle
- */
-
-CURLcode Curl_readwrite_init(struct connectdata *conn)
-{
-  struct SessionHandle *data = conn->data;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
-
-  /* NB: the content encoding software depends on this initialization of
-     Curl_transfer_keeper.*/
-  memset(k, 0, sizeof(struct Curl_transfer_keeper));
-
-  k->start = Curl_tvnow(); /* start time */
-  k->now = k->start;   /* current time is now */
-  k->header = TRUE; /* assume header */
-  k->httpversion = -1; /* unknown at this point */
-
-  k->size = data->reqdata.size;
-  k->maxdownload = data->reqdata.maxdownload;
-  k->bytecountp = data->reqdata.bytecountp;
-  k->writebytecountp = data->reqdata.writebytecountp;
-
-  k->bytecount = 0;
-
-  k->buf = data->state.buffer;
-  k->uploadbuf = data->state.uploadbuffer;
-  k->maxfd = (conn->sockfd>conn->writesockfd?
-              conn->sockfd:conn->writesockfd)+1;
-  k->hbufp = data->state.headerbuff;
-  k->ignorebody=FALSE;
-
-  Curl_pgrsTime(data, TIMER_PRETRANSFER);
-  Curl_speedinit(data);
-
-  Curl_pgrsSetUploadCounter(data, 0);
-  Curl_pgrsSetDownloadCounter(data, 0);
-
-  if (!conn->bits.getheader) {
-    k->header = FALSE;
-    if(k->size > 0)
-      Curl_pgrsSetDownloadSize(data, k->size);
-  }
-  /* we want header and/or body, if neither then don't do this! */
-  if(conn->bits.getheader || !conn->bits.no_body) {
-
-    if(conn->sockfd != CURL_SOCKET_BAD) {
-      k->keepon |= KEEP_READ;
-    }
-
-    if(conn->writesockfd != CURL_SOCKET_BAD) {
-      /* HTTP 1.1 magic:
-
-         Even if we require a 100-return code before uploading data, we might
-         need to write data before that since the REQUEST may not have been
-         finished sent off just yet.
-
-         Thus, we must check if the request has been sent before we set the
-         state info where we wait for the 100-return code
-      */
-      if (data->state.expect100header &&
-          (data->reqdata.proto.http->sending == HTTPSEND_BODY)) {
-        /* wait with write until we either got 100-continue or a timeout */
-        k->write_after_100_header = TRUE;
-        k->start100 = k->start;
-      }
-      else {
-        if(data->state.expect100header)
-          /* when we've sent off the rest of the headers, we must await a
-             100-continue */
-          k->wait100_after_headers = TRUE;
-        k->keepon |= KEEP_WRITE;
-      }
-    }
-  }
+  *done = (bool)(0 == (k->keepon&(KEEP_READ|KEEP_WRITE|KEEP_READ_PAUSE|KEEP_WRITE_PAUSE)));
 
   return CURLE_OK;
 }
 
 /*
- * Curl_readwrite may get called multiple times.  This function is called
- * immediately before the first Curl_readwrite.  Note that this can't be moved
- * to Curl_readwrite_init since that function can get called while another
- * pipeline request is in the middle of receiving data.
- *
- * We init chunking and trailer bits to their default values here immediately
- * before receiving any header data for the current request in the pipeline.
- */
-void Curl_pre_readwrite(struct connectdata *conn)
-{
-  conn->bits.chunk=FALSE;
-  conn->bits.trailerHdrPresent=FALSE;
-}
-
-/*
  * Curl_single_getsock() gets called by the multi interface code when the app
  * has requested to get the sockets for the current connection. This function
  * will then be called once for every connection that the multi interface
  * keeps track of. This function will only be called for connections that are
  * in the proper state to have this information available.
  */
@@ -1753,25 +1685,33 @@
   unsigned sockindex = 0;
 
   if(numsocks < 2)
     /* simple check but we might need two slots */
     return GETSOCK_BLANK;
 
-  if(data->reqdata.keep.keepon & KEEP_READ) {
+  /* don't include HOLD and PAUSE connections */
+  if((data->req.keepon & KEEP_READBITS) == KEEP_READ) {
+
+    DEBUGASSERT(conn->sockfd != CURL_SOCKET_BAD);
+
     bitmap |= GETSOCK_READSOCK(sockindex);
     sock[sockindex] = conn->sockfd;
   }
 
-  if(data->reqdata.keep.keepon & KEEP_WRITE) {
+  /* don't include HOLD and PAUSE connections */
+  if((data->req.keepon & KEEP_WRITEBITS) == KEEP_WRITE) {
 
     if((conn->sockfd != conn->writesockfd) ||
-       !(data->reqdata.keep.keepon & KEEP_READ)) {
+       !(data->req.keepon & KEEP_READ)) {
       /* only if they are not the same socket or we didn't have a readable
          one, we increase index */
-      if(data->reqdata.keep.keepon & KEEP_READ)
+      if(data->req.keepon & KEEP_READ)
         sockindex++; /* increase index if we need two entries */
+
+      DEBUGASSERT(conn->writesockfd != CURL_SOCKET_BAD);
+
       sock[sockindex] = conn->writesockfd;
     }
 
     bitmap |= GETSOCK_WRITESOCK(sockindex);
   }
 
@@ -1795,68 +1735,66 @@
 
 static CURLcode
 Transfer(struct connectdata *conn)
 {
   CURLcode result;
   struct SessionHandle *data = conn->data;
-  struct Curl_transfer_keeper *k = &data->reqdata.keep;
+  struct SingleRequest *k = &data->req;
   bool done=FALSE;
 
-  if(!(conn->protocol & (PROT_FILE|PROT_TFTP))) {
-    /* Only do this if we are not transferring FILE or TFTP, since those
-       transfers are treated differently. They do their entire transfers in
-       the DO function and just returns from this. That is ugly indeed.
-    */
-    Curl_readwrite_init(conn);
-    Curl_pre_readwrite(conn);
-  }
-
   if((conn->sockfd == CURL_SOCKET_BAD) &&
      (conn->writesockfd == CURL_SOCKET_BAD))
     /* nothing to read, nothing to write, we're already OK! */
     return CURLE_OK;
 
   /* we want header and/or body, if neither then don't do this! */
   if(!conn->bits.getheader && conn->bits.no_body)
     return CURLE_OK;
 
-  while (!done) {
+  while(!done) {
     curl_socket_t fd_read;
     curl_socket_t fd_write;
 
     /* limit-rate logic: if speed exceeds threshold, then do not include fd in
        select set. The current speed is recalculated in each Curl_readwrite()
        call */
-    if ((k->keepon & KEEP_WRITE) &&
+    if((k->keepon & KEEP_WRITE) &&
         (!data->set.max_send_speed ||
          (data->progress.ulspeed < data->set.max_send_speed) )) {
       fd_write = conn->writesockfd;
       k->keepon &= ~KEEP_WRITE_HOLD;
     }
     else {
       fd_write = CURL_SOCKET_BAD;
       if(k->keepon & KEEP_WRITE)
         k->keepon |= KEEP_WRITE_HOLD; /* hold it */
     }
 
-    if ((k->keepon & KEEP_READ) &&
+    if((k->keepon & KEEP_READ) &&
         (!data->set.max_recv_speed ||
          (data->progress.dlspeed < data->set.max_recv_speed)) ) {
       fd_read = conn->sockfd;
       k->keepon &= ~KEEP_READ_HOLD;
     }
     else {
       fd_read = CURL_SOCKET_BAD;
       if(k->keepon & KEEP_READ)
         k->keepon |= KEEP_READ_HOLD; /* hold it */
     }
 
-    /* The *_HOLD logic is necessary since even though there might be no
-       traffic during the select interval, we still call Curl_readwrite() for
-       the timeout case and if we limit transfer speed we must make sure that
-       this function doesn't transfer anything while in HOLD status. */
+    /* pause logic. Don't check descriptors for paused connections */
+    if(k->keepon & KEEP_READ_PAUSE)
+      fd_read = CURL_SOCKET_BAD;
+    if(k->keepon & KEEP_WRITE_PAUSE)
+      fd_write = CURL_SOCKET_BAD;
+
+    /* The *_HOLD and *_PAUSE logic is necessary since even though there might
+       be no traffic during the select interval, we still call
+       Curl_readwrite() for the timeout case and if we limit transfer speed we
+       must make sure that this function doesn't transfer anything while in
+       HOLD status. */
 
     switch (Curl_socket_ready(fd_read, fd_write, 1000)) {
     case -1: /* select() error, stop reading */
 #ifdef EINTR
       /* The EINTR is not serious, and it seems you might get this more
          ofen when using the lib in a multi-threaded environment! */
@@ -1886,13 +1824,13 @@
  */
 CURLcode Curl_pretransfer(struct SessionHandle *data)
 {
   CURLcode res;
   if(!data->change.url) {
     /* we can't do anything wihout URL */
-    failf(data, "No URL set!\n");
+    failf(data, "No URL set!");
     return CURLE_URL_MALFORMAT;
   }
 
   /* Init the SSL session ID cache here. We do it here since we want to do it
      after the *_setopt() calls (that could change the size of the cache) but
      before any transfer takes place. */
@@ -2031,13 +1969,13 @@
   char prot[16]; /* URL protocol string storage */
   char letter;   /* used for a silly sscanf */
   size_t newlen;
   char *newest;
 
   if(!retry) {
-    if ((data->set.maxredirs != -1) &&
+    if((data->set.maxredirs != -1) &&
         (data->set.followlocation >= data->set.maxredirs)) {
       failf(data,"Maximum (%d) redirects followed", data->set.maxredirs);
       return CURLE_TOO_MANY_REDIRECTS;
     }
 
     /* mark the next request as a followed location: */
@@ -2229,15 +2167,15 @@
    * differently based on exactly what return code there was.
    *
    * News from 7.10.6: we can also get here on a 401 or 407, in case we act on
    * a HTTP (proxy-) authentication scheme other than Basic.
    */
   switch(data->info.httpcode) {
-    /* 401 - Act on a www-authentication, we keep on moving and do the
+    /* 401 - Act on a WWW-Authenticate, we keep on moving and do the
        Authorization: XXXX header in the HTTP request code snippet */
-    /* 407 - Act on a proxy-authentication, we keep on moving and do the
+    /* 407 - Act on a Proxy-Authenticate, we keep on moving and do the
        Proxy-Authorization: XXXX header in the HTTP request code snippet */
     /* 300 - Multiple Choices */
     /* 306 - Not used */
     /* 307 - Temporary Redirect */
   default:  /* for all above (and the unknown ones) */
     /* Some codes are explicitly mentioned since I've checked RFC2616 and they
@@ -2315,14 +2253,14 @@
   Curl_pgrsResetTimes(data);
 
   return CURLE_OK;
 }
 
 static CURLcode
-Curl_connect_host(struct SessionHandle *data,
-                  struct connectdata **conn)
+connect_host(struct SessionHandle *data,
+             struct connectdata **conn)
 {
   CURLcode res = CURLE_OK;
   int urlchanged = FALSE;
 
   do {
     bool async;
@@ -2347,22 +2285,22 @@
       break;
 
     /* If a callback (or something) has altered the URL we should use within
        the Curl_connect(), we detect it here and act as if we are redirected
        to the new URL */
     urlchanged = data->change.url_changed;
-    if ((CURLE_OK == res) && urlchanged) {
+    if((CURLE_OK == res) && urlchanged) {
       res = Curl_done(conn, res, FALSE);
       if(CURLE_OK == res) {
         char *gotourl = strdup(data->change.url);
         res = Curl_follow(data, gotourl, FALSE);
         if(res)
           free(gotourl);
       }
     }
-  } while (urlchanged && res == CURLE_OK);
+  } while(urlchanged && res == CURLE_OK);
 
   return res;
 }
 
 /* Returns TRUE and sets '*url' if a request retry is wanted */
 bool Curl_retry_request(struct connectdata *conn,
@@ -2373,14 +2311,14 @@
 
   /* if we're talking upload, we can't do the checks below, unless the protocol
      is HTTP as when uploading over HTTP we will still get a response */
   if(data->set.upload && !(conn->protocol&PROT_HTTP))
     return retry;
 
-  if((data->reqdata.keep.bytecount +
-      data->reqdata.keep.headerbytecount == 0) &&
+  if((data->req.bytecount +
+      data->req.headerbytecount == 0) &&
      conn->bits.reuse &&
      !conn->bits.no_body) {
     /* We got no data, we attempted to re-use a connection and yet we want a
        "body". This might happen if the connection was left alive when we were
        done using it before, but that was closed when we wanted to read from
        it again. Bad luck. Retry the same request on a fresh connect! */
@@ -2423,13 +2361,13 @@
    * place than falling down to the end of the function! This is because we
    * have cleanup stuff that must be done before we get back, and that is only
    * performed after this do-while loop.
    */
 
   do {
-    res = Curl_connect_host(data, &conn);   /* primary connection */
+    res = connect_host(data, &conn);   /* primary connection */
 
     if(res == CURLE_OK) {
       bool do_done;
       if(data->set.connect_only) {
         /* keep connection open for application to use the socket */
         conn->bits.close = FALSE;
@@ -2445,13 +2383,13 @@
 
           if(!retry)
             /*
              * We must duplicate the new URL here as the connection data may
              * be free()ed in the Curl_done() function.
              */
-            newurl = data->reqdata.newurl?strdup(data->reqdata.newurl):NULL;
+            newurl = data->req.newurl?strdup(data->req.newurl):NULL;
         }
         else {
           /* The transfer phase returned error, we mark the connection to get
            * closed to prevent being re-used. This is becasue we can't
            * possibly know if the connection is in a good shape or not now. */
           conn->bits.close = TRUE;
@@ -2520,41 +2458,81 @@
 /*
  * Curl_setup_transfer() is called to setup some basic properties for the
  * upcoming transfer.
  */
 CURLcode
 Curl_setup_transfer(
-    struct connectdata *c_conn, /* connection data */
-    int sockindex,       /* socket index to read from or -1 */
-    curl_off_t size,     /* -1 if unknown at this point */
-    bool getheader,      /* TRUE if header parsing is wanted */
-    curl_off_t *bytecountp, /* return number of bytes read or NULL */
-    int writesockindex,  /* socket index to write to, it may very
-                            well be the same we read from. -1
-                            disables */
-    curl_off_t *writecountp /* return number of bytes written or
-                               NULL */
-   )
+  struct connectdata *conn, /* connection data */
+  int sockindex,            /* socket index to read from or -1 */
+  curl_off_t size,          /* -1 if unknown at this point */
+  bool getheader,           /* TRUE if header parsing is wanted */
+  curl_off_t *bytecountp,   /* return number of bytes read or NULL */
+  int writesockindex,       /* socket index to write to, it may very well be
+                               the same we read from. -1 disables */
+  curl_off_t *writecountp   /* return number of bytes written or NULL */
+  )
 {
-  struct connectdata *conn = (struct connectdata *)c_conn;
   struct SessionHandle *data;
+  struct SingleRequest *k;
 
-  if(!conn)
-    return CURLE_BAD_FUNCTION_ARGUMENT;
+  DEBUGASSERT(conn != NULL);
 
   data = conn->data;
+  k = &data->req;
 
   DEBUGASSERT((sockindex <= 1) && (sockindex >= -1));
 
   /* now copy all input parameters */
   conn->sockfd = sockindex == -1 ?
       CURL_SOCKET_BAD : conn->sock[sockindex];
   conn->writesockfd = writesockindex == -1 ?
       CURL_SOCKET_BAD:conn->sock[writesockindex];
   conn->bits.getheader = getheader;
 
-  data->reqdata.size = size;
-  data->reqdata.bytecountp = bytecountp;
-  data->reqdata.writebytecountp = writecountp;
+  k->size = size;
+  k->bytecountp = bytecountp;
+  k->writebytecountp = writecountp;
+
+  /* The code sequence below is placed in this function just because all
+     necessary input is not always known in do_complete() as this function may
+     be called after that */
+
+  if(!conn->bits.getheader) {
+    k->header = FALSE;
+    if(size > 0)
+      Curl_pgrsSetDownloadSize(data, size);
+  }
+  /* we want header and/or body, if neither then don't do this! */
+  if(conn->bits.getheader || !conn->bits.no_body) {
+
+    if(conn->sockfd != CURL_SOCKET_BAD) {
+      k->keepon |= KEEP_READ;
+    }
+
+    if(conn->writesockfd != CURL_SOCKET_BAD) {
+      /* HTTP 1.1 magic:
+
+         Even if we require a 100-return code before uploading data, we might
+         need to write data before that since the REQUEST may not have been
+         finished sent off just yet.
+
+         Thus, we must check if the request has been sent before we set the
+         state info where we wait for the 100-return code
+      */
+      if(data->state.expect100header &&
+          (data->state.proto.http->sending == HTTPSEND_BODY)) {
+        /* wait with write until we either got 100-continue or a timeout */
+        k->write_after_100_header = TRUE;
+        k->start100 = k->start;
+      }
+      else {
+        if(data->state.expect100header)
+          /* when we've sent off the rest of the headers, we must await a
+             100-continue */
+          k->wait100_after_headers = TRUE;
+        k->keepon |= KEEP_WRITE;
+      }
+    }
+  }
 
   return CURLE_OK;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/transfer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/transfer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/transfer.h	2007-08-27 21:01:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/transfer.h	2007-11-16 05:45:45.000000000 +0800
@@ -17,25 +17,23 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.h,v 1.30 2007-08-27 06:31:28 danf Exp $
+ * $Id: transfer.h,v 1.31 2007-11-15 21:45:45 bagder Exp $
  ***************************************************************************/
 CURLcode Curl_perform(struct SessionHandle *data);
 CURLcode Curl_pretransfer(struct SessionHandle *data);
 CURLcode Curl_second_connect(struct connectdata *conn);
 CURLcode Curl_posttransfer(struct SessionHandle *data);
 CURLcode Curl_follow(struct SessionHandle *data, char *newurl, bool retry);
 CURLcode Curl_readwrite(struct connectdata *conn, bool *done);
 int Curl_single_getsock(const struct connectdata *conn,
                         curl_socket_t *socks,
                         int numsocks);
-CURLcode Curl_readwrite_init(struct connectdata *conn);
-void Curl_pre_readwrite(struct connectdata *conn);
 CURLcode Curl_readrewind(struct connectdata *conn);
 CURLcode Curl_fillreadbuffer(struct connectdata *conn, int bytes, int *nreadp);
 bool Curl_retry_request(struct connectdata *conn, char **url);
 
 /* This sets up a forthcoming transfer */
 CURLcode
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/url.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/url.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/url.c	2007-10-27 06:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/url.c	2008-01-28 06:41:56.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.c,v 1.671 2007-10-26 01:12:33 yangtse Exp $
+ * $Id: url.c,v 1.696 2008-01-21 23:48:58 bagder Exp $
  ***************************************************************************/
 
 /* -- WIN32 approved -- */
 
 #include "setup.h"
 
@@ -118,12 +118,13 @@
 #include "content_encoding.h"
 #include "http_digest.h"
 #include "http_negotiate.h"
 #include "select.h"
 #include "multiif.h"
 #include "easyif.h"
+#include "speedcheck.h"
 
 /* And now for the protocols */
 #include "ftp.h"
 #include "dict.h"
 #include "telnet.h"
 #include "tftp.h"
@@ -155,29 +156,28 @@
 static bool ConnectionExists(struct SessionHandle *data,
                              struct connectdata *needle,
                              struct connectdata **usethis);
 static long ConnectionStore(struct SessionHandle *data,
                             struct connectdata *conn);
 static bool IsPipeliningPossible(const struct SessionHandle *handle);
-static bool IsPipeliningEnabled(const struct SessionHandle *handle);
 static void conn_free(struct connectdata *conn);
 
 static void signalPipeClose(struct curl_llist *pipeline);
 
 static struct SessionHandle* gethandleathead(struct curl_llist *pipeline);
+static CURLcode do_init(struct connectdata *conn);
+static void do_complete(struct connectdata *conn);
 
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
 static void flush_cookies(struct SessionHandle *data, int cleanup);
 #endif
 
 #ifdef CURL_DISABLE_VERBOSE_STRINGS
 #define verboseconnect(x)  do { } while (0)
 #endif
 
-#define MAX_PIPELINE_LENGTH 5
-
 #ifndef USE_ARES
 /* not for ares builds */
 
 #ifndef WIN32
 /* not for WIN32 builds */
 
@@ -292,26 +292,26 @@
   /* Free all dynamic strings stored in the data->set substructure. */
   enum dupstring i;
   for(i=(enum dupstring)0; i < STRING_LAST; i++)
     Curl_safefree(data->set.str[i]);
 }
 
-static CURLcode Curl_setstropt(char **charp, char * s)
+static CURLcode setstropt(char **charp, char * s)
 {
   /* Release the previous storage at `charp' and replace by a dynamic storage
      copy of `s'. Return CURLE_OK or CURLE_OUT_OF_MEMORY. */
 
-  if (*charp) {
+  if(*charp) {
     free(*charp);
     *charp = (char *) NULL;
   }
 
-  if (s) {
+  if(s) {
     s = strdup(s);
 
-    if (!s)
+    if(!s)
       return CURLE_OUT_OF_MEMORY;
 
     *charp = s;
   }
 
   return CURLE_OK;
@@ -328,14 +328,14 @@
 
   /* clear all string pointers first */
   memset(dst->set.str, 0, STRING_LAST * sizeof(char *));
 
   /* duplicate all strings */
   for(i=(enum dupstring)0; i< STRING_LAST; i++) {
-    r = Curl_setstropt(&dst->set.str[i], src->set.str[i]);
-    if (r != CURLE_OK)
+    r = setstropt(&dst->set.str[i], src->set.str[i]);
+    if(r != CURLE_OK)
       break;
   }
 
   /* If a failure occurred, freeing has to be performed externally. */
   return r;
 }
@@ -348,13 +348,13 @@
     if(data->change.cookielist) {
       /* If there is a list of cookie files to read, do it first so that
          we have all the told files read before we write the new jar */
       Curl_cookie_loadfiles(data);
     }
 
-    /* we have a "destination" for all the cookies to get dumped to */
+    /* if we have a destination file for all the cookies to get dumped to */
     if(Curl_cookie_output(data->cookies, data->set.str[STRING_COOKIEJAR]))
       infof(data, "WARNING: failed to save cookies in %s\n",
             data->set.str[STRING_COOKIEJAR]);
   }
   else {
     if(cleanup && data->change.cookielist)
@@ -419,12 +419,22 @@
             fprintf(stderr,
                     "MAJOR problem we %p are still in recv pipe for %p done %d\n",
                     data, connptr, connptr->bits.done);
           }
         }
       }
+      pipeline = connptr->pend_pipe;
+      if(pipeline) {
+        for (curr = pipeline->head; curr; curr=curr->next) {
+          if(data == (struct SessionHandle *) curr->ptr) {
+            fprintf(stderr,
+                    "MAJOR problem we %p are still in pend pipe for %p done %d\n",
+                    data, connptr, connptr->bits.done);
+          }
+        }
+      }
     }
   }
 #endif
 
   if(m)
     /* This handle is still part of a multi handle, take care of this first
@@ -451,24 +461,21 @@
     /* marked to be used by a pending connection so we can't kill this handle
        just yet */
     data->state.closed = TRUE;
     return CURLE_OK;
   }
 
-  if ( ! (data->share && data->share->hostcache) ) {
-    if ( !Curl_global_host_cache_use(data)) {
-      Curl_hash_destroy(data->dns.hostcache);
-    }
-  }
+  if(data->dns.hostcachetype == HCACHE_PRIVATE)
+    Curl_hash_destroy(data->dns.hostcache);
 
-  if(data->reqdata.rangestringalloc)
-    free(data->reqdata.range);
+  if(data->state.rangestringalloc)
+    free(data->state.range);
 
   /* Free the pathbuffer */
-  Curl_safefree(data->reqdata.pathbuffer);
-  Curl_safefree(data->reqdata.proto.generic);
+  Curl_safefree(data->state.pathbuffer);
+  Curl_safefree(data->state.proto.generic);
 
   /* Close down all open SSL info and sessions */
   Curl_ssl_close_all(data);
   Curl_safefree(data->state.first_host);
   Curl_safefree(data->state.scratch);
 
@@ -490,25 +497,25 @@
 
   /* this destroys the channel and we cannot use it anymore after this */
   ares_destroy(data->state.areschannel);
 
 #if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)
   /* close iconv conversion descriptors */
-  if (data->inbound_cd != (iconv_t)-1) {
+  if(data->inbound_cd != (iconv_t)-1) {
      iconv_close(data->inbound_cd);
   }
-  if (data->outbound_cd != (iconv_t)-1) {
+  if(data->outbound_cd != (iconv_t)-1) {
      iconv_close(data->outbound_cd);
   }
-  if (data->utf8_cd != (iconv_t)-1) {
+  if(data->utf8_cd != (iconv_t)-1) {
      iconv_close(data->utf8_cd);
   }
 #endif /* CURL_DOES_CONVERSIONS && HAVE_ICONV */
 
   /* No longer a dirty share, if it exists */
-  if (data->share) {
+  if(data->share) {
     Curl_share_lock(data, CURL_LOCK_DATA_SHARE, CURL_LOCK_ACCESS_SINGLE);
     data->share->dirty--;
     Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
   }
 
   Curl_freeset(data);
@@ -523,24 +530,24 @@
   /* It is subject for debate how many default connections to have for a multi
      connection cache... */
 
   struct conncache *c;
   long default_amount;
 
-  if (type == CONNCACHE_PRIVATE) {
+  if(type == CONNCACHE_PRIVATE) {
     default_amount = (amount < 0) ? 5 : amount;
   }
   else {
     default_amount = (amount < 0) ? 10 : amount;
   }
 
   c= calloc(sizeof(struct conncache), 1);
   if(!c)
     return NULL;
 
-  if ((size_t)(default_amount) > ((size_t)-1) / sizeof(struct connectdata *))
+  if((size_t)(default_amount) > ((size_t)-1) / sizeof(struct connectdata *))
     default_amount = ((size_t)-1) / sizeof(struct connectdata *);
 
   c->connects = calloc(sizeof(struct connectdata *), (size_t)default_amount);
   if(!c->connects) {
     free(c);
     return NULL;
@@ -647,16 +654,16 @@
     return CURLE_OUT_OF_MEMORY;
   }
 
   data->magic = CURLEASY_MAGIC_NUMBER;
 
 #ifdef USE_ARES
-  if ((status = ares_init(&data->state.areschannel)) != ARES_SUCCESS) {
+  if((status = ares_init(&data->state.areschannel)) != ARES_SUCCESS) {
     DEBUGF(fprintf(stderr, "Error: ares_init failed\n"));
     free(data);
-    if (status == ARES_ENOMEM)
+    if(status == ARES_ENOMEM)
       return CURLE_OUT_OF_MEMORY;
     else
       return CURLE_FAILED_INIT;
   }
   /* make sure that all other returns from this function should destroy the
      ares channel before returning error! */
@@ -679,12 +686,16 @@
     /* use fwrite as default function to store output */
     data->set.fwrite_func = (curl_write_callback)fwrite;
 
     /* use fread as default function to read input */
     data->set.fread_func = (curl_read_callback)fread;
 
+    /* don't use a seek function by default */
+    data->set.seek_func = ZERO_NULL;
+    data->set.seek_client = ZERO_NULL;
+
     /* conversion callbacks for non-ASCII hosts */
     data->set.convfromnetwork = ZERO_NULL;
     data->set.convtonetwork   = ZERO_NULL;
     data->set.convfromutf8    = ZERO_NULL;
 
 #if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)
@@ -737,13 +748,13 @@
      */
     data->set.ssl.verifypeer = TRUE;
     data->set.ssl.verifyhost = 2;
     data->set.ssl.sessionid = TRUE; /* session ID caching enabled by default */
 #ifdef CURL_CA_BUNDLE
     /* This is our preferred CA cert bundle since install time */
-    res = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE],
+    res = setstropt(&data->set.str[STRING_SSL_CAFILE],
                          (char *) CURL_CA_BUNDLE);
 #endif
   }
 
   if(res) {
     ares_destroy(data->state.areschannel);
@@ -771,38 +782,36 @@
   switch(option) {
   case CURLOPT_DNS_CACHE_TIMEOUT:
     data->set.dns_cache_timeout = va_arg(param, long);
     break;
   case CURLOPT_DNS_USE_GLOBAL_CACHE:
     {
+      /* remember we want this enabled */
       long use_cache = va_arg(param, long);
-      if (use_cache)
-        Curl_global_host_cache_init();
-
       data->set.global_dns_cache = (bool)(0 != use_cache);
     }
     break;
   case CURLOPT_SSL_CIPHER_LIST:
     /* set a list of cipher we want to use in the SSL connection */
-    result = Curl_setstropt(&data->set.str[STRING_SSL_CIPHER_LIST],
+    result = setstropt(&data->set.str[STRING_SSL_CIPHER_LIST],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_RANDOM_FILE:
     /*
      * This is the path name to a file that contains random data to seed
      * the random SSL stuff with. The file is only used for reading.
      */
-    result = Curl_setstropt(&data->set.str[STRING_SSL_RANDOM_FILE],
+    result = setstropt(&data->set.str[STRING_SSL_RANDOM_FILE],
                             va_arg(param, char *));
     break;
   case CURLOPT_EGDSOCKET:
     /*
      * The Entropy Gathering Daemon socket pathname
      */
-    result = Curl_setstropt(&data->set.str[STRING_SSL_EGDSOCKET],
+    result = setstropt(&data->set.str[STRING_SSL_EGDSOCKET],
                             va_arg(param, char *));
     break;
   case CURLOPT_MAXCONNECTS:
     /*
      * Set the absolute number of maximum simultaneous alive connection that
      * libcurl is allowed to have.
@@ -920,13 +929,13 @@
     data->set.use_netrc = (enum CURL_NETRC_OPTION)va_arg(param, long);
     break;
   case CURLOPT_NETRC_FILE:
     /*
      * Use this file instead of the $HOME/.netrc file
      */
-    result = Curl_setstropt(&data->set.str[STRING_NETRC_FILE],
+    result = setstropt(&data->set.str[STRING_NETRC_FILE],
                             va_arg(param, char *));
     break;
   case CURLOPT_TRANSFERTEXT:
     /*
      * This option was previously named 'FTPASCII'. Renamed to work with
      * more protocols than merely FTP.
@@ -973,13 +982,13 @@
      * encompasses all the encodings we support.
      * If the encoding is set to NULL we don't send an Accept-Encoding header
      * and ignore an received Content-Encoding header.
      *
      */
     argptr = va_arg(param, char *);
-    result = Curl_setstropt(&data->set.str[STRING_ENCODING],
+    result = setstropt(&data->set.str[STRING_ENCODING],
                             (argptr && !*argptr)?
                             (char *) ALL_CONTENT_ENCODINGS: argptr);
     break;
 
   case CURLOPT_FOLLOWLOCATION:
     /*
@@ -1029,40 +1038,40 @@
      * A string with POST data. Makes curl HTTP POST. Even if it is NULL.
      * If needed, CURLOPT_POSTFIELDSIZE must have been set prior to
      *  CURLOPT_COPYPOSTFIELDS and not altered later.
      */
     argptr = va_arg(param, char *);
 
-    if (!argptr || data->set.postfieldsize == -1)
-      result = Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], argptr);
+    if(!argptr || data->set.postfieldsize == -1)
+      result = setstropt(&data->set.str[STRING_COPYPOSTFIELDS], argptr);
     else {
       /*
        *  Check that requested length does not overflow the size_t type.
        */
 
-      if ((data->set.postfieldsize < 0) ||
+      if((data->set.postfieldsize < 0) ||
           ((sizeof(curl_off_t) != sizeof(size_t)) &&
            (data->set.postfieldsize > (curl_off_t)((size_t)-1))))
         result = CURLE_OUT_OF_MEMORY;
       else {
         char * p;
 
-        (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
+        (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
 
         /* Allocate even when size == 0. This satisfies the need of possible
            later address compare to detect the COPYPOSTFIELDS mode, and
            to mark that postfields is used rather than read function or
            form data.
          */
         p = malloc((size_t)(data->set.postfieldsize?data->set.postfieldsize:1));
 
-        if (!p)
+        if(!p)
           result = CURLE_OUT_OF_MEMORY;
         else {
-          if (data->set.postfieldsize)
-            memcpy(p, argptr, data->set.postfieldsize);
+          if(data->set.postfieldsize)
+            memcpy(p, argptr, (size_t)data->set.postfieldsize);
 
           data->set.str[STRING_COPYPOSTFIELDS] = p;
         }
       }
     }
 
@@ -1073,27 +1082,27 @@
   case CURLOPT_POSTFIELDS:
     /*
      * Like above, but use static data instead of copying it.
      */
     data->set.postfields = va_arg(param, void *);
     /* Release old copied data. */
-    (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
+    (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
     data->set.httpreq = HTTPREQ_POST;
     break;
 
   case CURLOPT_POSTFIELDSIZE:
     /*
      * The size of the POSTFIELD data to prevent libcurl to do strlen() to
      * figure it out. Enables binary posts.
      */
     bigsize = va_arg(param, long);
 
-    if (data->set.postfieldsize < bigsize &&
+    if(data->set.postfieldsize < bigsize &&
         data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {
       /* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */
-      (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
+      (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
       data->set.postfields = NULL;
       }
 
     data->set.postfieldsize = bigsize;
     break;
 
@@ -1101,16 +1110,16 @@
     /*
      * The size of the POSTFIELD data to prevent libcurl to do strlen() to
      * figure it out. Enables binary posts.
      */
     bigsize = va_arg(param, curl_off_t);
 
-    if (data->set.postfieldsize < bigsize &&
+    if(data->set.postfieldsize < bigsize &&
         data->set.postfields == data->set.str[STRING_COPYPOSTFIELDS]) {
       /* Previous CURLOPT_COPYPOSTFIELDS is no longer valid. */
-      (void) Curl_setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
+      (void) setstropt(&data->set.str[STRING_COPYPOSTFIELDS], NULL);
       data->set.postfields = NULL;
       }
 
     data->set.postfieldsize = bigsize;
     break;
 
@@ -1128,22 +1137,22 @@
      * String to set in the HTTP Referer: field.
      */
     if(data->change.referer_alloc) {
       free(data->change.referer);
       data->change.referer_alloc = FALSE;
     }
-    result = Curl_setstropt(&data->set.str[STRING_SET_REFERER],
+    result = setstropt(&data->set.str[STRING_SET_REFERER],
                             va_arg(param, char *));
     data->change.referer = data->set.str[STRING_SET_REFERER];
     break;
 
   case CURLOPT_USERAGENT:
     /*
      * String to use in the HTTP User-Agent field
      */
-    result = Curl_setstropt(&data->set.str[STRING_USERAGENT],
+    result = setstropt(&data->set.str[STRING_USERAGENT],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_HTTPHEADER:
     /*
      * Set a list with HTTP headers to use (or replace internals with)
@@ -1160,13 +1169,13 @@
 
 #if !defined(CURL_DISABLE_COOKIES)
   case CURLOPT_COOKIE:
     /*
      * Cookie string to send to the remote server in the request.
      */
-    result = Curl_setstropt(&data->set.str[STRING_COOKIE],
+    result = setstropt(&data->set.str[STRING_COOKIE],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_COOKIEFILE:
     /*
      * Set cookie file to read and parse. Can be used multiple times.
@@ -1178,21 +1187,21 @@
          them later */
       cl = curl_slist_append(data->change.cookielist, argptr);
 
       if(!cl)
         return CURLE_OUT_OF_MEMORY;
 
-      data->change.cookielist = cl;
+      data->change.cookielist = cl; /* store the list for later use */
     }
     break;
 
   case CURLOPT_COOKIEJAR:
     /*
      * Set cookie file name to dump all cookies to when we're done.
      */
-    result = Curl_setstropt(&data->set.str[STRING_COOKIEJAR],
+    result = setstropt(&data->set.str[STRING_COOKIEJAR],
                             va_arg(param, char *));
 
     /*
      * Activate the cookie parser. This may or may not already
      * have been made.
      */
@@ -1290,13 +1299,13 @@
     break;
 
   case CURLOPT_CUSTOMREQUEST:
     /*
      * Set a custom string to use as request
      */
-    result = Curl_setstropt(&data->set.str[STRING_CUSTOMREQUEST],
+    result = setstropt(&data->set.str[STRING_CUSTOMREQUEST],
                             va_arg(param, char *));
 
     /* we don't set
        data->set.httpreq = HTTPREQ_CUSTOM;
        here, we continue as if we were using the already set type
        and this just changes the actual request keyword */
@@ -1357,13 +1366,13 @@
      * If the proxy is set to "" we explicitly say that we don't want to use a
      * proxy (even though there might be environment variables saying so).
      *
      * Setting it to NULL, means no proxy but allows the environment variables
      * to decide for us.
      */
-    result = Curl_setstropt(&data->set.str[STRING_PROXY],
+    result = setstropt(&data->set.str[STRING_PROXY],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_WRITEHEADER:
     /*
      * Custom pointer to pass the header write callback function
@@ -1384,13 +1393,13 @@
     data->set.out = va_arg(param, FILE *);
     break;
   case CURLOPT_FTPPORT:
     /*
      * Use FTP PORT, this also specifies which IP address to use
      */
-    result = Curl_setstropt(&data->set.str[STRING_FTPPORT],
+    result = setstropt(&data->set.str[STRING_FTPPORT],
                             va_arg(param, char *));
     data->set.ftp_use_port = (bool)(NULL != data->set.str[STRING_FTPPORT]);
     break;
 
   case CURLOPT_FTP_USE_EPRT:
     data->set.ftp_use_eprt = (bool)(0 != va_arg(param, long));
@@ -1469,16 +1478,16 @@
      */
     if(data->change.url_alloc) {
       /* the already set URL is allocated, free it first! */
       free(data->change.url);
       data->change.url_alloc=FALSE;
     }
-    result = Curl_setstropt(&data->set.str[STRING_SET_URL],
+    result = setstropt(&data->set.str[STRING_SET_URL],
                             va_arg(param, char *));
     data->change.url = data->set.str[STRING_SET_URL];
-    if (data->change.url)
+    if(data->change.url)
       data->change.url_changed = TRUE;
     break;
   case CURLOPT_PORT:
     /*
      * The port number to use when getting the URL
      */
@@ -1508,13 +1517,13 @@
     break;
 
   case CURLOPT_USERPWD:
     /*
      * user:password to use in the operation
      */
-    result = Curl_setstropt(&data->set.str[STRING_USERPWD],
+    result = setstropt(&data->set.str[STRING_USERPWD],
                             va_arg(param, char *));
     break;
   case CURLOPT_POSTQUOTE:
     /*
      * List of RAW FTP commands to use after a transfer
      */
@@ -1550,20 +1559,20 @@
     data->set.progress_client = va_arg(param, void *);
     break;
   case CURLOPT_PROXYUSERPWD:
     /*
      * user:password needed to use the proxy
      */
-    result = Curl_setstropt(&data->set.str[STRING_PROXYUSERPWD],
+    result = setstropt(&data->set.str[STRING_PROXYUSERPWD],
                             va_arg(param, char *));
     break;
   case CURLOPT_RANGE:
     /*
      * What range of the file you want to transfer
      */
-    result = Curl_setstropt(&data->set.str[STRING_SET_RANGE],
+    result = setstropt(&data->set.str[STRING_SET_RANGE],
                             va_arg(param, char *));
     break;
   case CURLOPT_RESUME_FROM:
     /*
      * Resume transfer at the give file position
      */
@@ -1621,12 +1630,24 @@
      */
     data->set.fread_func = va_arg(param, curl_read_callback);
     if(!data->set.fread_func)
       /* When set to NULL, reset to our internal default function */
       data->set.fread_func = (curl_read_callback)fread;
     break;
+  case CURLOPT_SEEKFUNCTION:
+    /*
+     * Seek callback. Might be NULL.
+     */
+    data->set.seek_func = va_arg(param, curl_seek_callback);
+    break;
+  case CURLOPT_SEEKDATA:
+    /*
+     * Seek control callback. Might be NULL.
+     */
+    data->set.seek_client = va_arg(param, void *);
+    break;
   case CURLOPT_CONV_FROM_NETWORK_FUNCTION:
     /*
      * "Convert from network encoding" callback
      */
     data->set.convfromnetwork = va_arg(param, curl_conv_callback);
     break;
@@ -1655,49 +1676,49 @@
     data->set.ioctl_client = va_arg(param, void *);
     break;
   case CURLOPT_SSLCERT:
     /*
      * String that holds file name of the SSL certificate to use
      */
-    result = Curl_setstropt(&data->set.str[STRING_CERT],
+    result = setstropt(&data->set.str[STRING_CERT],
                             va_arg(param, char *));
     break;
   case CURLOPT_SSLCERTTYPE:
     /*
      * String that holds file type of the SSL certificate to use
      */
-    result = Curl_setstropt(&data->set.str[STRING_CERT_TYPE],
+    result = setstropt(&data->set.str[STRING_CERT_TYPE],
                             va_arg(param, char *));
     break;
   case CURLOPT_SSLKEY:
     /*
      * String that holds file name of the SSL certificate to use
      */
-    result = Curl_setstropt(&data->set.str[STRING_KEY],
+    result = setstropt(&data->set.str[STRING_KEY],
                             va_arg(param, char *));
     break;
   case CURLOPT_SSLKEYTYPE:
     /*
      * String that holds file type of the SSL certificate to use
      */
-    result = Curl_setstropt(&data->set.str[STRING_KEY_TYPE],
+    result = setstropt(&data->set.str[STRING_KEY_TYPE],
                             va_arg(param, char *));
     break;
   case CURLOPT_KEYPASSWD:
     /*
      * String that holds the SSL or SSH private key password.
      */
-    result = Curl_setstropt(&data->set.str[STRING_KEY_PASSWD],
+    result = setstropt(&data->set.str[STRING_KEY_PASSWD],
                             va_arg(param, char *));
     break;
   case CURLOPT_SSLENGINE:
     /*
      * String that holds the SSL crypto engine.
      */
     argptr = va_arg(param, char *);
-    if (argptr && argptr[0])
+    if(argptr && argptr[0])
        result = Curl_ssl_set_engine(data, argptr);
     break;
 
   case CURLOPT_SSLENGINE_DEFAULT:
     /*
      * flag to set engine as default.
@@ -1713,13 +1734,13 @@
 
   case CURLOPT_INTERFACE:
     /*
      * Set what interface or address/hostname to bind the socket to when
      * performing an operation and thus what from-IP your connection will use.
      */
-    result = Curl_setstropt(&data->set.str[STRING_DEVICE],
+    result = setstropt(&data->set.str[STRING_DEVICE],
                             va_arg(param, char *));
     break;
   case CURLOPT_LOCALPORT:
     /*
      * Set what local port to bind the socket to when performing an operation.
      */
@@ -1732,13 +1753,13 @@
     data->set.localportrange = (int) va_arg(param, long);
     break;
   case CURLOPT_KRBLEVEL:
     /*
      * A string that defines the kerberos security level.
      */
-    result = Curl_setstropt(&data->set.str[STRING_KRB_LEVEL],
+    result = setstropt(&data->set.str[STRING_KRB_LEVEL],
                             va_arg(param, char *));
     data->set.krb = (bool)(NULL != data->set.str[STRING_KRB_LEVEL]);
     break;
   case CURLOPT_SSL_VERIFYPEER:
     /*
      * Enable peer SSL verifying.
@@ -1764,22 +1785,22 @@
     data->set.ssl.fsslctxp = va_arg(param, void *);
     break;
   case CURLOPT_CAINFO:
     /*
      * Set CA info for SSL connection. Specify file name of the CA certificate
      */
-    result = Curl_setstropt(&data->set.str[STRING_SSL_CAFILE],
+    result = setstropt(&data->set.str[STRING_SSL_CAFILE],
                             va_arg(param, char *));
     break;
   case CURLOPT_CAPATH:
     /*
      * Set CA path info for SSL connection. Specify directory name of the CA
      * certificates which have been prepared using openssl c_rehash utility.
      */
     /* This does not work on windows. */
-    result = Curl_setstropt(&data->set.str[STRING_SSL_CAPATH],
+    result = setstropt(&data->set.str[STRING_SSL_CAPATH],
                             va_arg(param, char *));
     break;
   case CURLOPT_TELNETOPTIONS:
     /*
      * Set a linked list of telnet options
      */
@@ -1846,33 +1867,29 @@
           data->dns.hostcache = data->share->hostcache;
           data->dns.hostcachetype = HCACHE_SHARED;
         }
 #if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
         if(data->share->cookies) {
           /* use shared cookie list, first free own one if any */
-          if (data->cookies)
+          if(data->cookies)
             Curl_cookie_cleanup(data->cookies);
+          /* enable cookies since we now use a share that uses cookies! */
           data->cookies = data->share->cookies;
         }
 #endif   /* CURL_DISABLE_HTTP */
         Curl_share_unlock(data, CURL_LOCK_DATA_SHARE);
 
       }
-#if !defined(CURL_DISABLE_HTTP) && !defined(CURL_DISABLE_COOKIES)
-      /* check cookie list is set */
-      if(!data->cookies)
-        data->cookies = Curl_cookie_init(data, NULL, NULL, TRUE );
-#endif   /* CURL_DISABLE_HTTP */
       /* check for host cache not needed,
        * it will be done by curl_easy_perform */
     }
     break;
 
   case CURLOPT_PROXYTYPE:
     /*
-     * Set proxy type. HTTP/SOCKS4/SOCKS5
+     * Set proxy type. HTTP/SOCKS4/SOCKS4a/SOCKS5/SOCKS5_HOSTNAME
      */
     data->set.proxytype = (curl_proxytype)va_arg(param, long);
     break;
 
   case CURLOPT_PRIVATE:
     /*
@@ -1927,13 +1944,13 @@
       case CURLOPT_SOURCE_QUOTE:
       case CURLOPT_SOURCE_PREQUOTE:
       case CURLOPT_SOURCE_POSTQUOTE:
       These former 3rd party transfer options are deprecated */
 
   case CURLOPT_FTP_ACCOUNT:
-    result = Curl_setstropt(&data->set.str[STRING_FTP_ACCOUNT],
+    result = setstropt(&data->set.str[STRING_FTP_ACCOUNT],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_IGNORE_CONTENT_LENGTH:
     data->set.ignorecl = (bool)(0 != va_arg(param, long));
     break;
@@ -1943,13 +1960,13 @@
      * No data transfer, set up connection and let application use the socket
      */
     data->set.connect_only = (bool)(0 != va_arg(param, long));
     break;
 
   case CURLOPT_FTP_ALTERNATIVE_TO_USER:
-    result = Curl_setstropt(&data->set.str[STRING_FTP_ALTERNATIVE_TO_USER],
+    result = setstropt(&data->set.str[STRING_FTP_ALTERNATIVE_TO_USER],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_SOCKOPTFUNCTION:
     /*
      * socket callback function: called after socket() but before connect()
@@ -1988,29 +2005,29 @@
     break;
 
   case CURLOPT_SSH_PUBLIC_KEYFILE:
     /*
      * Use this file instead of the $HOME/.ssh/id_dsa.pub file
      */
-    result = Curl_setstropt(&data->set.str[STRING_SSH_PUBLIC_KEY],
+    result = setstropt(&data->set.str[STRING_SSH_PUBLIC_KEY],
                             va_arg(param, char *));
     break;
 
   case CURLOPT_SSH_PRIVATE_KEYFILE:
     /*
      * Use this file instead of the $HOME/.ssh/id_dsa file
      */
-    result = Curl_setstropt(&data->set.str[STRING_SSH_PRIVATE_KEY],
+    result = setstropt(&data->set.str[STRING_SSH_PRIVATE_KEY],
                             va_arg(param, char *));
     break;
   case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
     /*
      * Option to allow for the MD5 of the host public key to be checked
      * for validation purposes.
      */
-    result = Curl_setstropt(&data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5],
+    result = setstropt(&data->set.str[STRING_SSH_HOST_PUBLIC_KEY_MD5],
                             va_arg(param, char *));
     break;
   case CURLOPT_HTTP_TRANSFER_DECODING:
     /*
      * disable libcurl transfer encoding is used
      */
@@ -2034,25 +2051,42 @@
   case CURLOPT_NEW_DIRECTORY_PERMS:
     /*
      * Uses these permissions instead of 0755
      */
     data->set.new_directory_perms = va_arg(param, long);
     break;
+  case CURLOPT_PROXY_TRANSFER_MODE:
+    /*
+     * set transfer mode (;type=<a|i>) when doing FTP via an HTTP proxy
+     */
+    switch (va_arg(param, long)) {
+      case 0:
+        data->set.proxy_transfer_mode = FALSE;
+        break;
+      case 1:
+        data->set.proxy_transfer_mode = TRUE;
+        break;
+      default:
+        /* reserve other values for future use */
+        result = CURLE_FAILED_INIT;
+        break;
+    }
+    break;
 
   default:
     /* unknown tag and its companion, just ignore: */
     result = CURLE_FAILED_INIT; /* correct this */
     break;
   }
 
   return result;
 }
 
 static void conn_free(struct connectdata *conn)
 {
-  if (!conn)
+  if(!conn)
     return;
 
   /* close possibly still open sockets */
   if(CURL_SOCKET_BAD != conn->sock[SECONDARYSOCKET])
     sclose(conn->sock[SECONDARYSOCKET]);
   if(CURL_SOCKET_BAD != conn->sock[FIRSTSOCKET])
@@ -2075,12 +2109,13 @@
   Curl_safefree(conn->host.rawalloc); /* host name buffer */
   Curl_safefree(conn->proxy.rawalloc); /* proxy name buffer */
   Curl_safefree(conn->master_buffer);
 
   Curl_llist_destroy(conn->send_pipe, NULL);
   Curl_llist_destroy(conn->recv_pipe, NULL);
+  Curl_llist_destroy(conn->pend_pipe, NULL);
 
   /* possible left-overs from the async name resolvers */
 #if defined(USE_ARES)
   Curl_safefree(conn->async.hostname);
   Curl_safefree(conn->async.os_specific);
 #elif defined(CURLRES_THREADED)
@@ -2131,13 +2166,13 @@
 
     data->state.authproblem = FALSE;
 
     Curl_ntlm_cleanup(conn);
   }
 
-  if(conn->handler && conn->handler->disconnect)
+  if(conn->handler->disconnect)
     /* This is set if protocol-specific cleanups should be made */
     conn->handler->disconnect(conn);
 
   if(-1 != conn->connectindex) {
     /* unlink ourselves! */
     infof(data, "Closing connection #%ld\n", conn->connectindex);
@@ -2158,19 +2193,20 @@
                                        allocated by libidn */
 #endif
 
   Curl_ssl_close(conn, FIRSTSOCKET);
 
   /* Indicate to all handles on the pipe that we're dead */
-  if (IsPipeliningEnabled(data)) {
+  if(Curl_isPipeliningEnabled(data)) {
     signalPipeClose(conn->send_pipe);
     signalPipeClose(conn->recv_pipe);
+    signalPipeClose(conn->pend_pipe);
   }
 
   conn_free(conn);
-  data->reqdata.current_conn = NULL;
+  data->state.current_conn = NULL;
 
   return CURLE_OK;
 }
 
 /*
  * This function should return TRUE if the socket is to be assumed to
@@ -2189,24 +2225,24 @@
 
   return ret_val;
 }
 
 static bool IsPipeliningPossible(const struct SessionHandle *handle)
 {
-  if (handle->multi && Curl_multi_canPipeline(handle->multi) &&
+  if(handle->multi && Curl_multi_canPipeline(handle->multi) &&
       (handle->set.httpreq == HTTPREQ_GET ||
        handle->set.httpreq == HTTPREQ_HEAD) &&
       handle->set.httpversion != CURL_HTTP_VERSION_1_0)
     return TRUE;
 
   return FALSE;
 }
 
-static bool IsPipeliningEnabled(const struct SessionHandle *handle)
+bool Curl_isPipeliningEnabled(const struct SessionHandle *handle)
 {
-  if (handle->multi && Curl_multi_canPipeline(handle->multi))
+  if(handle->multi && Curl_multi_canPipeline(handle->multi))
     return TRUE;
 
   return FALSE;
 }
 
 CURLcode Curl_addHandleToPipeline(struct SessionHandle *data,
@@ -2216,26 +2252,25 @@
   if(!IsPipeliningPossible(data)) {
     /* when not pipelined, there MUST be no handle in the list already */
     if(pipeline->head)
       infof(data, "PIPE when no PIPE supposed!\n");
   }
 #endif
-  if (!Curl_llist_insert_next(pipeline, pipeline->tail, data))
+  if(!Curl_llist_insert_next(pipeline, pipeline->tail, data))
     return CURLE_OUT_OF_MEMORY;
   return CURLE_OK;
 }
 
-
 int Curl_removeHandleFromPipeline(struct SessionHandle *handle,
-                                   struct curl_llist *pipeline)
+                                  struct curl_llist *pipeline)
 {
   struct curl_llist_element *curr;
 
   curr = pipeline->head;
-  while (curr) {
-    if (curr->ptr == handle) {
+  while(curr) {
+    if(curr->ptr == handle) {
       Curl_llist_remove(pipeline, curr, NULL);
       return 1; /* we removed a handle */
     }
     curr = curr->next;
   }
 
@@ -2245,50 +2280,39 @@
 #if 0 /* this code is saved here as it is useful for debugging purposes */
 static void Curl_printPipeline(struct curl_llist *pipeline)
 {
   struct curl_llist_element *curr;
 
   curr = pipeline->head;
-  while (curr) {
+  while(curr) {
     struct SessionHandle *data = (struct SessionHandle *) curr->ptr;
-    infof(data, "Handle in pipeline: %s\n", data->reqdata.path);
+    infof(data, "Handle in pipeline: %s\n", data->state.path);
     curr = curr->next;
   }
 }
 #endif
 
-bool Curl_isHandleAtHead(struct SessionHandle *handle,
-                         struct curl_llist *pipeline)
-{
-  struct curl_llist_element *curr = pipeline->head;
-  if (curr) {
-    return (bool)(curr->ptr == handle);
-  }
-
-  return FALSE;
-}
-
 static struct SessionHandle* gethandleathead(struct curl_llist *pipeline)
 {
   struct curl_llist_element *curr = pipeline->head;
-  if (curr) {
+  if(curr) {
     return (struct SessionHandle *) curr->ptr;
   }
 
   return NULL;
 }
 
 static void signalPipeClose(struct curl_llist *pipeline)
 {
   struct curl_llist_element *curr;
 
-  if (!pipeline)
+  if(!pipeline)
     return;
 
   curr = pipeline->head;
-  while (curr) {
+  while(curr) {
     struct curl_llist_element *next = curr->next;
     struct SessionHandle *data = (struct SessionHandle *) curr->ptr;
 
 #ifdef CURLDEBUG /* debug-only code */
     if(data->magic != CURLEASY_MAGIC_NUMBER) {
       /* MAJOR BADNESS */
@@ -2333,67 +2357,69 @@
     if(!check)
       /* NULL pointer means not filled-in entry */
       continue;
 
     pipeLen = check->send_pipe->size + check->recv_pipe->size;
 
-    if (check->connectindex == -1) {
+    if(check->connectindex == -1) {
       check->connectindex = i; /* Set this appropriately since it might have
                                   been set to -1 when the easy was removed
                                   from the multi */
     }
 
-    if(pipeLen > 0 && !canPipeline) {
-      /* can only happen within multi handles, and means that another easy
-         handle is using this connection */
-      continue;
-    }
-
-#ifdef CURLRES_ASYNCH
-    /* ip_addr_str is NULL only if the resolving of the name hasn't completed
-       yet and until then we don't re-use this connection */
-    if (!check->ip_addr_str) {
-      infof(data,
-            "Connection #%ld hasn't finished name resolve, can't reuse\n",
-            check->connectindex);
-      continue;
-    }
-#endif
-
-    if ((check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) || check->bits.close) {
-      /* Don't pick a connection that hasn't connected yet or that is going to
-         get closed. */
-      infof(data, "Connection #%ld isn't open enough, can't reuse\n",
-            check->connectindex);
-#ifdef CURLDEBUG
-      if (check->recv_pipe->size > 0) {
-        infof(data, "BAD! Unconnected #%ld has a non-empty recv pipeline!\n",
-              check->connectindex);
-      }
-#endif
-      continue;
-    }
-
-    if (pipeLen >= MAX_PIPELINE_LENGTH) {
-      infof(data, "Connection #%ld has its pipeline full, can't reuse\n",
-            check->connectindex);
-      continue;
-    }
-
-    if (canPipeline) {
+    if(canPipeline) {
       /* Make sure the pipe has only GET requests */
       struct SessionHandle* sh = gethandleathead(check->send_pipe);
       struct SessionHandle* rh = gethandleathead(check->recv_pipe);
-      if (sh) {
+      if(sh) {
         if(!IsPipeliningPossible(sh))
           continue;
       }
-      else if (rh) {
+      else if(rh) {
         if(!IsPipeliningPossible(rh))
           continue;
       }
+
+#ifdef CURLDEBUG
+      if(pipeLen > MAX_PIPELINE_LENGTH) {
+        infof(data, "BAD! Connection #%ld has too big pipeline!\n",
+              check->connectindex);
+      }
+#endif
+    }
+    else {
+      if(pipeLen > 0) {
+        /* can only happen within multi handles, and means that another easy
+           handle is using this connection */
+        continue;
+      }
+
+#ifdef CURLRES_ASYNCH
+      /* ip_addr_str is NULL only if the resolving of the name hasn't completed
+         yet and until then we don't re-use this connection */
+      if(!check->ip_addr_str) {
+        infof(data,
+              "Connection #%ld hasn't finished name resolve, can't reuse\n",
+              check->connectindex);
+        continue;
+      }
+#endif
+
+      if((check->sock[FIRSTSOCKET] == CURL_SOCKET_BAD) || check->bits.close) {
+        /* Don't pick a connection that hasn't connected yet or that is going to
+           get closed. */
+        infof(data, "Connection #%ld isn't open enough, can't reuse\n",
+              check->connectindex);
+#ifdef CURLDEBUG
+        if(check->recv_pipe->size > 0) {
+          infof(data, "BAD! Unconnected #%ld has a non-empty recv pipeline!\n",
+                check->connectindex);
+        }
+#endif
+        continue;
+      }
     }
 
     if((needle->protocol&PROT_SSL) != (check->protocol&PROT_SSL))
       /* don't do mixed SSL and non-SSL connections */
       continue;
 
@@ -2448,13 +2474,13 @@
         /* This is the same proxy connection, use it! */
         match = TRUE;
       }
     }
 
     if(match) {
-      if (!IsPipeliningEnabled(data)) {
+      if(!check->is_in_pipeline) {
         /* The check for a dead socket makes sense only in the
            non-pipelining case */
         bool dead = SocketIsDead(check->sock[FIRSTSOCKET]);
         if(dead) {
           check->data = data;
           infof(data, "Connection #%d seems to be dead!\n", i);
@@ -2465,13 +2491,13 @@
           return FALSE;
         }
       }
 
       check->inuse = TRUE; /* mark this as being in use so that no other
                               handle in a multi stack may nick it */
-      if (canPipeline) {
+      if(canPipeline) {
         /* Mark the connection as being in a pipeline */
         check->is_in_pipeline = TRUE;
       }
 
       *usethis = check;
       return TRUE; /* yes, we found one to use! */
@@ -2531,13 +2557,13 @@
 
 /* this connection can now be marked 'idle' */
 static void
 ConnectionDone(struct connectdata *conn)
 {
   conn->inuse = FALSE;
-  if (!conn->send_pipe && !conn->recv_pipe)
+  if(!conn->send_pipe && !conn->recv_pipe && !conn->pend_pipe)
     conn->is_in_pipeline = FALSE;
 }
 
 /*
  * The given input connection struct pointer is to be stored. If the "cache"
  * is already full, we must clean out the most suitable using the previously
@@ -2617,21 +2643,27 @@
     result = Curl_store_ip_addr(conn);
 
     if(CURLE_OK == result) {
 
       switch(data->set.proxytype) {
       case CURLPROXY_SOCKS5:
-        result = Curl_SOCKS5(conn->proxyuser, conn->proxypasswd, conn->host.name,
-                             conn->remote_port, FIRSTSOCKET, conn);
+      case CURLPROXY_SOCKS5_HOSTNAME:
+        result = Curl_SOCKS5(conn->proxyuser, conn->proxypasswd,
+                             conn->host.name, conn->remote_port,
+                             FIRSTSOCKET, conn);
         break;
       case CURLPROXY_HTTP:
         /* do nothing here. handled later. */
         break;
       case CURLPROXY_SOCKS4:
-        result = Curl_SOCKS4(conn->proxyuser, conn->host.name, conn->remote_port,
-                             FIRSTSOCKET, conn);
+        result = Curl_SOCKS4(conn->proxyuser, conn->host.name,
+                             conn->remote_port, FIRSTSOCKET, conn, FALSE);
+        break;
+      case CURLPROXY_SOCKS4A:
+        result = Curl_SOCKS4(conn->proxyuser, conn->host.name,
+                             conn->remote_port, FIRSTSOCKET, conn, TRUE);
         break;
       default:
         failf(data, "unknown proxytype option given");
         result = CURLE_COULDNT_CONNECT;
         break;
       }
@@ -2665,13 +2697,13 @@
 }
 
 int Curl_doing_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks)
 {
-  if(conn && conn->handler && conn->handler->doing_getsock)
+  if(conn && conn->handler->doing_getsock)
     return conn->handler->doing_getsock(conn, socks, numsocks);
   return GETSOCK_BLANK;
 }
 
 /*
  * We are doing protocol-specific connecting and this is being called over and
@@ -2681,13 +2713,13 @@
 
 CURLcode Curl_protocol_connecting(struct connectdata *conn,
                                   bool *done)
 {
   CURLcode result=CURLE_OK;
 
-  if(conn && conn->handler && conn->handler->connecting) {
+  if(conn && conn->handler->connecting) {
     *done = FALSE;
     result = conn->handler->connecting(conn, done);
   }
   else
     *done = TRUE;
 
@@ -2700,13 +2732,13 @@
  */
 
 CURLcode Curl_protocol_doing(struct connectdata *conn, bool *done)
 {
   CURLcode result=CURLE_OK;
 
-  if(conn && conn->handler && conn->handler->doing) {
+  if(conn && conn->handler->doing) {
     *done = FALSE;
     result = conn->handler->doing(conn, done);
   }
   else
     *done = TRUE;
 
@@ -2760,13 +2792,13 @@
     }
     else
       *protocol_done = TRUE;
 
     /* it has started, possibly even completed but that knowledge isn't stored
        in this bit! */
-    if (!result)
+    if(!result)
       conn->bits.protoconnstart = TRUE;
   }
 
   return result; /* pass back status */
 }
 
@@ -2775,14 +2807,14 @@
  */
 #ifdef USE_LIBIDN
 static bool is_ASCII_name(const char *hostname)
 {
   const unsigned char *ch = (const unsigned char*)hostname;
 
-  while (*ch) {
-    if (*ch++ & 0x80)
+  while(*ch) {
+    if(*ch++ & 0x80)
       return FALSE;
   }
   return TRUE;
 }
 
 /*
@@ -2799,30 +2831,30 @@
 #else
   (void)data;
 #endif
 
   /* Convert (and downcase) ACE-name back into locale's character set */
   rc = idna_to_unicode_lzlz(ace_hostname, &uc_name, 0);
-  if (rc != IDNA_SUCCESS)
+  if(rc != IDNA_SUCCESS)
     return (FALSE);
 
   rc = tld_check_lz(uc_name, &err_pos, NULL);
 #ifndef CURL_DISABLE_VERBOSE_STRINGS
 #ifdef HAVE_TLD_STRERROR
-  if (rc != TLD_SUCCESS)
+  if(rc != TLD_SUCCESS)
     tld_errmsg = (char *)tld_strerror((Tld_rc)rc);
 #endif
-  if (rc == TLD_INVALID)
+  if(rc == TLD_INVALID)
     infof(data, "WARNING: %s; pos %u = `%c'/0x%02X\n",
           tld_errmsg, err_pos, uc_name[err_pos],
           uc_name[err_pos] & 255);
-  else if (rc != TLD_SUCCESS)
+  else if(rc != TLD_SUCCESS)
     infof(data, "WARNING: TLD check for %s failed; %s\n",
           uc_name, tld_errmsg);
 #endif /* CURL_DISABLE_VERBOSE_STRINGS */
-  if (uc_name)
+  if(uc_name)
      idn_free(uc_name);
   return (bool)(rc == TLD_SUCCESS);
 }
 #endif
 
 static void fix_hostname(struct SessionHandle *data,
@@ -2839,19 +2871,19 @@
   host->dispname = host->name;
 
 #ifdef USE_LIBIDN
   /*************************************************************
    * Check name for non-ASCII and convert hostname to ACE form.
    *************************************************************/
-  if (!is_ASCII_name(host->name) &&
+  if(!is_ASCII_name(host->name) &&
       stringprep_check_version(LIBIDN_REQUIRED_VERSION)) {
     char *ace_hostname = NULL;
     int rc = idna_to_ascii_lz(host->name, &ace_hostname, 0);
     infof (data, "Input domain encoded as `%s'\n",
            stringprep_locale_charset ());
-    if (rc != IDNA_SUCCESS)
+    if(rc != IDNA_SUCCESS)
       infof(data, "Failed to convert %s to ACE; %s\n",
             host->name, Curl_idn_strerror(conn,rc));
     else {
       /* tld_check_name() displays a warning if the host name contains
          "illegal" characters for this TLD */
       (void)tld_check_name(data, ace_hostname);
@@ -2870,13 +2902,13 @@
 static CURLcode ParseURLAndFillConnection(struct SessionHandle *data,
                                           struct connectdata *conn)
 {
   char *at;
   char *tmp;
 
-  char *path = data->reqdata.path;
+  char *path = data->state.path;
 
   /*************************************************************
    * Parse the URL.
    *
    * We need to parse the url even when using the proxy, because we will need
    * the hostname and port in case we are trying to SSL connect through the
@@ -2934,13 +2966,13 @@
     strcpy(conn->protostr, "file"); /* store protocol string lowercase */
   }
   else {
     /* clear path */
     path[0]=0;
 
-    if (2 > sscanf(data->change.url,
+    if(2 > sscanf(data->change.url,
                    "%15[^\n:]://%[^\n/]%[^\n]",
                    conn->protostr,
                    conn->host.name, path)) {
 
       /*
        * The URL was badly formatted, let's try the browser-style _without_
@@ -2962,15 +2994,15 @@
 
       /* Note: if you add a new protocol, please update the list in
        * lib/version.c too! */
 
       if(checkprefix("FTP.", conn->host.name))
         strcpy(conn->protostr, "ftp");
-      else if (checkprefix("DICT.", conn->host.name))
+      else if(checkprefix("DICT.", conn->host.name))
         strcpy(conn->protostr, "DICT");
-      else if (checkprefix("LDAP.", conn->host.name))
+      else if(checkprefix("LDAP.", conn->host.name))
         strcpy(conn->protostr, "LDAP");
       else {
         strcpy(conn->protostr, "http");
       }
 
       conn->protocol |= PROT_MISSING; /* not given in URL */
@@ -3028,13 +3060,13 @@
   }
 
   /*
    * So if the URL was A://B/C,
    *   conn->protostr is A
    *   conn->host.name is B
-   *   data->reqdata.path is /C
+   *   data->state.path is /C
    */
 
   return CURLE_OK;
 }
 
 static void llist_dtor(void *user, void *element)
@@ -3047,34 +3079,33 @@
 static CURLcode setup_range(struct SessionHandle *data)
 {
   /*
    * If we're doing a resumed transfer, we need to setup our stuff
    * properly.
    */
-  struct HandleData *req = &data->reqdata;
-
-  req->resume_from = data->set.set_resume_from;
-  if (req->resume_from || data->set.str[STRING_SET_RANGE]) {
-    if (req->rangestringalloc)
-      free(req->range);
+  struct UrlState *s = &data->state;
+  s->resume_from = data->set.set_resume_from;
+  if(s->resume_from || data->set.str[STRING_SET_RANGE]) {
+    if(s->rangestringalloc)
+      free(s->range);
 
-    if(req->resume_from)
-      req->range = aprintf("%" FORMAT_OFF_T "-", req->resume_from);
+    if(s->resume_from)
+      s->range = aprintf("%" FORMAT_OFF_T "-", s->resume_from);
     else
-      req->range = strdup(data->set.str[STRING_SET_RANGE]);
+      s->range = strdup(data->set.str[STRING_SET_RANGE]);
 
-    req->rangestringalloc = (unsigned char)(req->range?TRUE:FALSE);
+    s->rangestringalloc = (bool)(s->range?TRUE:FALSE);
 
-    if(!req->range)
+    if(!s->range)
       return CURLE_OUT_OF_MEMORY;
 
     /* tell ourselves to fetch this range */
-    req->use_range = TRUE;        /* enable range download */
+    s->use_range = TRUE;        /* enable range download */
   }
   else
-    req->use_range = FALSE; /* disable range download */
+    s->use_range = FALSE; /* disable range download */
 
   return CURLE_OK;
 }
 
 
 /***************************************************************
@@ -3089,33 +3120,34 @@
 
   conn->socktype = SOCK_STREAM; /* most of them are TCP streams */
 
   /* Scan protocol handler table. */
 
   for (pp = protocols; (p = *pp) != NULL; pp++)
-    if (strequal(p->scheme, conn->protostr)) {
+    if(strequal(p->scheme, conn->protostr)) {
       /* Protocol found in table. Perform setup complement if some. */
       conn->handler = p;
 
-      if (p->setup_connection) {
+      if(p->setup_connection) {
         result = (*p->setup_connection)(conn);
 
-        if (result != CURLE_OK)
+        if(result != CURLE_OK)
           return result;
 
         p = conn->handler;              /* May have changed. */
       }
 
       conn->port = p->defport;
       conn->remote_port = (unsigned short)p->defport;
       conn->protocol |= p->protocol;
       return CURLE_OK;
     }
 
-  /* Protocol not found in table. */
-  conn->handler = &Curl_handler_dummy;  /* Be sure we have a handler defined. */
+  /* The protocol was not found in the table, but we don't have to assign it
+     to anything since it is already assigned to a dummy-struct in the
+     CreateConnection() function when the connectdata struct is allocated. */
   failf(data, "Protocol %s not supported or disabled in " LIBCURL_NAME,
         conn->protostr);
   return CURLE_UNSUPPORTED_PROTOCOL;
 }
 
 /****************************************************************
@@ -3223,16 +3255,16 @@
       if(proxy && *proxy) {
         long bits = conn->protocol & (PROT_HTTPS|PROT_SSL|PROT_MISSING);
 
         if(conn->proxytype == CURLPROXY_HTTP) {
           /* force this connection's protocol to become HTTP */
           conn->protocol = PROT_HTTP | bits;
-          conn->bits.httpproxy = TRUE;
+          conn->bits.proxy = conn->bits.httpproxy = TRUE;
         }
       }
-    } /* if (!nope) - it wasn't specified non-proxy */
+    } /* if(!nope) - it wasn't specified non-proxy */
   } /* NO_PROXY wasn't specified or '*' */
   if(no_proxy)
     free(no_proxy);
 
 #else /* !CURL_DISABLE_HTTP */
 
@@ -3335,13 +3367,13 @@
      * name nor a numeric can legally start with a bracket.
      */
   }
 
   /* Get port number off proxy.server.com:1080 */
   prox_portno = strchr(portptr, ':');
-  if (prox_portno) {
+  if(prox_portno) {
     *prox_portno = 0x0; /* cut off number from host name */
     prox_portno ++;
     /* now set the local port number */
     conn->port = atoi(prox_portno);
   }
   else {
@@ -3467,12 +3499,16 @@
   }
   /* We must set the return variable as soon as possible, so that our
      parent can cleanup any possible allocs we may have done before
      any failure */
   *in_connect = conn;
 
+  conn->handler = &Curl_handler_dummy;  /* Be sure we have a handler defined
+                                           already from start to avoid NULL
+                                           situations and checks */
+
   /* and we setup a few fields in case we end up actually using this struct */
 
   conn->data = data; /* Setup the association between this connection
                         and the SessionHandle */
 
   conn->sock[FIRSTSOCKET] = CURL_SOCKET_BAD;     /* no file descriptor */
@@ -3504,24 +3540,25 @@
   conn->bits.proxy_user_passwd = (bool)(NULL != data->set.str[STRING_PROXYUSERPWD]);
   conn->bits.no_body = data->set.opt_no_body;
   conn->bits.tunnel_proxy = data->set.tunnel_thru_httpproxy;
   conn->bits.ftp_use_epsv = data->set.ftp_use_epsv;
   conn->bits.ftp_use_eprt = data->set.ftp_use_eprt;
 
-  if (data->multi && Curl_multi_canPipeline(data->multi) &&
+  if(data->multi && Curl_multi_canPipeline(data->multi) &&
       !conn->master_buffer) {
     /* Allocate master_buffer to be used for pipelining */
     conn->master_buffer = calloc(BUFSIZE, sizeof (char));
-    if (!conn->master_buffer)
+    if(!conn->master_buffer)
       return CURLE_OUT_OF_MEMORY;
   }
 
   /* Initialize the pipeline lists */
   conn->send_pipe = Curl_llist_alloc((curl_llist_dtor) llist_dtor);
   conn->recv_pipe = Curl_llist_alloc((curl_llist_dtor) llist_dtor);
-  if (!conn->send_pipe || !conn->recv_pipe)
+  conn->pend_pipe = Curl_llist_alloc((curl_llist_dtor) llist_dtor);
+  if(!conn->send_pipe || !conn->recv_pipe || !conn->pend_pipe)
     return CURLE_OUT_OF_MEMORY;
 
   /* This initing continues below, see the comment "Continue connectdata
    * initialization here" */
 
   /***********************************************************
@@ -3532,61 +3569,61 @@
 #define LEAST_PATH_ALLOC 256
   urllen=strlen(data->change.url);
   if(urllen < LEAST_PATH_ALLOC)
     urllen=LEAST_PATH_ALLOC;
 
   /* Free the old buffer */
-  Curl_safefree(data->reqdata.pathbuffer);
+  Curl_safefree(data->state.pathbuffer);
 
   /*
    * We malloc() the buffers below urllen+2 to make room for to possibilities:
    * 1 - an extra terminating zero
    * 2 - an extra slash (in case a syntax like "www.host.com?moo" is used)
    */
 
-  data->reqdata.pathbuffer=(char *)malloc(urllen+2);
-  if(NULL == data->reqdata.pathbuffer)
+  data->state.pathbuffer=(char *)malloc(urllen+2);
+  if(NULL == data->state.pathbuffer)
     return CURLE_OUT_OF_MEMORY; /* really bad error */
-  data->reqdata.path = data->reqdata.pathbuffer;
+  data->state.path = data->state.pathbuffer;
 
   conn->host.rawalloc=(char *)malloc(urllen+2);
   if(NULL == conn->host.rawalloc)
     return CURLE_OUT_OF_MEMORY;
 
   conn->host.name = conn->host.rawalloc;
   conn->host.name[0] = 0;
 
   result = ParseURLAndFillConnection(data, conn);
-  if (result != CURLE_OK) {
+  if(result != CURLE_OK) {
       return result;
   }
 
   /*************************************************************
    * Take care of proxy authentication stuff
    *************************************************************/
   if(conn->bits.proxy_user_passwd) {
     result = parse_proxy_auth(data, conn);
-    if (result != CURLE_OK)
+    if(result != CURLE_OK)
         return result;
   }
 
   /*************************************************************
    * Detect what (if any) proxy to use
    *************************************************************/
-  if (data->set.str[STRING_PROXY]) {
+  if(data->set.str[STRING_PROXY]) {
     proxy = strdup(data->set.str[STRING_PROXY]);
     /* if global proxy is set, this is it */
     if(NULL == proxy) {
       failf(data, "memory shortage");
       return CURLE_OUT_OF_MEMORY;
     }
   }
 
-  if (!proxy)
+  if(!proxy)
     proxy = detect_proxy(conn);
-  if (proxy && !*proxy) {
+  if(proxy && !*proxy) {
     free(proxy);  /* Don't bother with an empty proxy string */
     proxy = NULL;
   }
   /* proxy must be freed later unless NULL */
 
   /*************************************************************
@@ -3611,52 +3648,54 @@
   }
 
   /*************************************************************
    * Setup internals depending on protocol
    *************************************************************/
   result = setup_connection_internals(data, conn);
-  if (result != CURLE_OK) {
+  if(result != CURLE_OK) {
     Curl_safefree(proxy);
     return result;
   }
 
 
   /***********************************************************************
    * If this is supposed to use a proxy, we need to figure out the proxy
    * host name, so that we can re-use an existing connection
    * that may exist registered to the same proxy host.
    ***********************************************************************/
-  if (proxy) {
+  if(proxy) {
     result = parse_proxy(data, conn, proxy);
     /* parse_proxy has freed the proxy string, so don't try to use it again */
     proxy = NULL;
-    if (result != CURLE_OK)
+    if(result != CURLE_OK)
       return result;
   }
 
 
   /***********************************************************************
    * file: is a special case in that it doesn't need a network connection
    ***********************************************************************/
 #ifndef CURL_DISABLE_FILE
-  if (strequal(conn->protostr, "FILE")) {
+  if(conn->protocol & PROT_FILE) {
+    bool done;
     /* this is supposed to be the connect function so we better at least check
        that the file is present here! */
-    result = Curl_file_connect(conn);
+    DEBUGASSERT(conn->handler->connect_it);
+    result = conn->handler->connect_it(conn, &done);
 
     /* Setup a "faked" transfer that'll do nothing */
     if(CURLE_OK == result) {
       conn->data = data;
       conn->bits.tcpconnect = TRUE; /* we are "connected */
 
       ConnectionStore(data, conn);
 
       result = setup_range(data);
       if(result) {
-        if(conn->handler->done)
-          result = conn->handler->done(conn, result, FALSE);
+        DEBUGASSERT(conn->handler->done);
+        conn->handler->done(conn, result, FALSE);
         return result;
       }
 
       result = Curl_setup_transfer(conn, -1, -1, FALSE,
                                    NULL, /* no download */
                                    -1, NULL); /* no upload */
@@ -3699,13 +3738,13 @@
    * We need somewhere to put the embedded details, so do that first.
    */
 
   user[0] =0;   /* to make everything well-defined */
   passwd[0]=0;
 
-  if (conn->protocol & (PROT_FTP|PROT_HTTP|PROT_SCP|PROT_SFTP)) {
+  if(conn->protocol & (PROT_FTP|PROT_HTTP|PROT_SCP|PROT_SFTP)) {
     /* This is a FTP, HTTP, SCP or SFTP URL, we will now try to extract the
      * possible user+password pair in a string like:
      * ftp://user:password@ftp.my.site:8021/README */
     char *ptr=strchr(conn->host.name, '@');
     char *userpass = conn->host.name;
     if(ptr != NULL) {
@@ -3716,13 +3755,13 @@
       /* So the hostname is sane.  Only bother interpreting the
        * results if we could care.  It could still be wasted
        * work because it might be overtaken by the programmatically
        * set user/passwd, but doing that first adds more cases here :-(
        */
 
-      if (data->set.use_netrc != CURL_NETRC_REQUIRED) {
+      if(data->set.use_netrc != CURL_NETRC_REQUIRED) {
         /* We could use the one in the URL */
 
         conn->bits.user_passwd = 1; /* enable user+password */
 
         if(*userpass != ':') {
           /* the name is given, get user+password */
@@ -3742,13 +3781,13 @@
             strcpy(user, newname);
 
           /* if the new name is longer than accepted, then just use
              the unconverted name, it'll be wrong but what the heck */
           free(newname);
         }
-        if (passwd[0]) {
+        if(passwd[0]) {
           /* we have a password found in the URL, decode it! */
           char *newpasswd=curl_easy_unescape(data, passwd, 0, NULL);
           if(!newpasswd)
             return CURLE_OUT_OF_MEMORY;
           if(strlen(newpasswd) < sizeof(passwd))
             strcpy(passwd, newpasswd);
@@ -3794,36 +3833,36 @@
                       number - since the port number is to be ignored! */
     if(conn->bits.httpproxy) {
       /* we need to create new URL with the new port number */
       char *url;
 
       url = aprintf("%s://%s:%d%s", conn->protostr, conn->host.name,
-                    conn->remote_port, data->reqdata.path);
+                    conn->remote_port, data->state.path);
       if(!url)
         return CURLE_OUT_OF_MEMORY;
 
       if(data->change.url_alloc)
         free(data->change.url);
 
       data->change.url = url;
       data->change.url_alloc = TRUE;
     }
   }
-  else if (tmp) {
+  else if(tmp) {
     /* no CURLOPT_PORT given, extract the one from the URL */
 
     char *rest;
     unsigned long port;
 
     port=strtoul(tmp+1, &rest, 10);  /* Port number must be decimal */
 
-    if (rest != (tmp+1) && *rest == '\0') {
+    if(rest != (tmp+1) && *rest == '\0') {
       /* The colon really did have only digits after it,
        * so it is either a port number or a mistake */
 
-      if (port > 0xffff) {   /* Single unix standard says port numbers are
+      if(port > 0xffff) {   /* Single unix standard says port numbers are
                               * 16 bits long */
         failf(data, "Port number too large: %lu", port);
         return CURLE_URL_MALFORMAT;
       }
 
       *tmp = '\0'; /* cut off the name there */
@@ -3837,22 +3876,22 @@
    * so scribble it over the top.
    * User-supplied passwords are assumed not to need unescaping.
    *
    * user_password is set in "inherit initial knowledge' above,
    * so it doesn't have to be set in this block
    */
-  if (data->set.str[STRING_USERPWD] != NULL) {
+  if(data->set.str[STRING_USERPWD] != NULL) {
     /* the name is given, get user+password */
     sscanf(data->set.str[STRING_USERPWD],
            "%" MAX_CURL_USER_LENGTH_TXT "[^:]:"
            "%" MAX_CURL_PASSWORD_LENGTH_TXT "[^\n]",
            user, passwd);
   }
 
   conn->bits.netrc = FALSE;
-  if (data->set.use_netrc != CURL_NETRC_IGNORED) {
+  if(data->set.use_netrc != CURL_NETRC_IGNORED) {
     if(Curl_parsenetrc(conn->host.name,
                        user, passwd,
                        data->set.str[STRING_NETRC_FILE])) {
       infof(data, "Couldn't find host %s in the " DOT_CHAR
             "netrc file, using defaults\n",
             conn->host.name);
@@ -3865,13 +3904,13 @@
 
       conn->bits.user_passwd = 1; /* enable user+password */
     }
   }
 
   /* If our protocol needs a password and we have none, use the defaults */
-  if ( (conn->protocol & PROT_FTP) &&
+  if( (conn->protocol & PROT_FTP) &&
        !conn->bits.user_passwd) {
 
     conn->user = strdup(CURL_DEFAULT_USER);
     conn->passwd = strdup(CURL_DEFAULT_PASSWORD);
     /* This is the default password, so DON'T set conn->bits.user_passwd */
   }
@@ -3936,35 +3975,35 @@
 
     conn->data = old_conn->data;
 
     /* get the user+password information from the old_conn struct since it may
      * be new for this request even when we re-use an existing connection */
     conn->bits.user_passwd = old_conn->bits.user_passwd;
-    if (conn->bits.user_passwd) {
+    if(conn->bits.user_passwd) {
       /* use the new user namd and password though */
       Curl_safefree(conn->user);
       Curl_safefree(conn->passwd);
       conn->user = old_conn->user;
       conn->passwd = old_conn->passwd;
       old_conn->user = NULL;
       old_conn->passwd = NULL;
     }
 
     conn->bits.proxy_user_passwd = old_conn->bits.proxy_user_passwd;
-    if (conn->bits.proxy_user_passwd) {
+    if(conn->bits.proxy_user_passwd) {
       /* use the new proxy user name and proxy password though */
       Curl_safefree(conn->proxyuser);
       Curl_safefree(conn->proxypasswd);
       conn->proxyuser = old_conn->proxyuser;
       conn->proxypasswd = old_conn->proxypasswd;
       old_conn->proxyuser = NULL;
       old_conn->proxypasswd = NULL;
     }
 
     /* host can change, when doing keepalive with a proxy ! */
-    if (conn->bits.proxy) {
+    if(conn->bits.proxy) {
       free(conn->host.rawalloc);
       conn->host=old_conn->host;
     }
     else
       free(old_conn->host.rawalloc); /* free the newly allocated name buffer */
 
@@ -3977,12 +4016,13 @@
     Curl_safefree(old_conn->user);
     Curl_safefree(old_conn->passwd);
     Curl_safefree(old_conn->proxyuser);
     Curl_safefree(old_conn->proxypasswd);
     Curl_llist_destroy(old_conn->send_pipe, NULL);
     Curl_llist_destroy(old_conn->recv_pipe, NULL);
+    Curl_llist_destroy(old_conn->pend_pipe, NULL);
     Curl_safefree(old_conn->master_buffer);
 
     free(old_conn);          /* we don't need this anymore */
 
     *in_connect = conn;      /* return this instead! */
 
@@ -4007,14 +4047,16 @@
   /*
    *
    * Inherit the proper values from the urldata struct AFTER we have arranged
    * the persistent connection stuff */
   conn->fread_func = data->set.fread_func;
   conn->fread_in = data->set.in;
+  conn->seek_func = data->set.seek_func;
+  conn->seek_client = data->set.seek_client;
 
-  if ((conn->protocol&PROT_HTTP) &&
+  if((conn->protocol&PROT_HTTP) &&
       data->set.upload &&
       (data->set.infilesize == -1) &&
       (data->set.httpversion != CURL_HTTP_VERSION_1_0)) {
     /* HTTP, upload, unknown file size and not HTTP 1.0 */
     conn->bits.upload_chunky = TRUE;
   }
@@ -4093,13 +4135,13 @@
    *************************************************************/
   if(conn->bits.reuse) {
     /* re-used connection, no resolving is necessary */
     hostaddr = NULL;
     /* we'll need to clear conn->dns_entry later in Curl_disconnect() */
 
-    if (conn->bits.proxy)
+    if(conn->bits.proxy)
       fix_hostname(data, conn, &conn->host);
   }
   else {
     /* this is a fresh connect */
 
     /* set a pointer to the hostname we display */
@@ -4228,13 +4270,13 @@
     conn->allocptr.uagent =
       aprintf("User-Agent: %s\r\n", data->set.str[STRING_USERAGENT]);
     if(!conn->allocptr.uagent)
       return CURLE_OUT_OF_MEMORY;
   }
 
-  data->reqdata.keep.headerbytecount = 0;
+  data->req.headerbytecount = 0;
 
 #ifdef CURL_DO_LINEEND_CONV
   data->state.crlf_conversions = 0; /* reset CRLF conversion counter */
 #endif /* CURL_DO_LINEEND_CONV */
 
   for(;;) {
@@ -4256,13 +4298,13 @@
 
       /* if the connection was closed by the server while exchanging
          authentication informations, retry with the new set
          authentication information */
       if(conn->bits.proxy_connect_closed) {
         /* reset the error buffer */
-        if (data->set.errorbuffer)
+        if(data->set.errorbuffer)
           data->set.errorbuffer[0] = '\0';
         data->state.errorbuf = FALSE;
         continue;
       }
 
       if(CURLE_OK != result)
@@ -4286,13 +4328,13 @@
   /* 20000330 mgs
    * the check is quite a hack...
    * we're calling _fsetmode to fix the problem with fwrite converting newline
    * characters (you get mangled text files, and corrupted binary files when
    * you download to stdout and redirect it to a file). */
 
-  if ((data->set.out)->_handle == NULL) {
+  if((data->set.out)->_handle == NULL) {
     _fsetmode(stdout, "b");
   }
 #endif
 
   return CURLE_OK;
 }
@@ -4309,32 +4351,30 @@
 
   /* call the stuff that needs to be called */
   code = CreateConnection(data, in_connect, &dns, asyncp);
 
   if(CURLE_OK == code) {
     /* no error */
-    if(dns || !*asyncp)
-      /* If an address is available it means that we already have the name
-         resolved, OR it isn't async. if this is a re-used connection 'dns'
-         will be NULL here. Continue connecting from here */
-      code = SetupConnection(*in_connect, dns, protocol_done);
-    /* else
-       response will be received and treated async wise */
+    if((*in_connect)->is_in_pipeline)
+      data->state.is_in_pipeline = TRUE;
+    else {
+      if(dns || !*asyncp)
+        /* If an address is available it means that we already have the name
+           resolved, OR it isn't async. if this is a re-used connection 'dns'
+           will be NULL here. Continue connecting from here */
+        code = SetupConnection(*in_connect, dns, protocol_done);
+      /* else
+         response will be received and treated async wise */
+    }
   }
 
-  if(CURLE_OK != code) {
+  if(CURLE_OK != code && *in_connect) {
     /* We're not allowed to return failure with memory left allocated
        in the connectdata struct, free those here */
-    if(*in_connect) {
-      Curl_disconnect(*in_connect); /* close the connection */
-      *in_connect = NULL;           /* return a NULL */
-    }
-  }
-  else {
-    if ((*in_connect)->is_in_pipeline)
-      data->state.is_in_pipeline = TRUE;
+    Curl_disconnect(*in_connect); /* close the connection */
+    *in_connect = NULL;           /* return a NULL */
   }
 
   return code;
 }
 
 /* Call this function after Curl_connect() has returned async=TRUE and
@@ -4382,17 +4422,18 @@
   if(Curl_removeHandleFromPipeline(data, conn->recv_pipe) &&
      conn->readchannel_inuse)
     conn->readchannel_inuse = FALSE;
   if(Curl_removeHandleFromPipeline(data, conn->send_pipe) &&
      conn->writechannel_inuse)
     conn->writechannel_inuse = FALSE;
+  Curl_removeHandleFromPipeline(data, conn->pend_pipe);
 
   /* Cleanup possible redirect junk */
-  if(data->reqdata.newurl) {
-    free(data->reqdata.newurl);
-    data->reqdata.newurl = NULL;
+  if(data->req.newurl) {
+    free(data->req.newurl);
+    data->req.newurl = NULL;
   }
 
   if(conn->dns_entry) {
     Curl_resolv_unlock(data, conn->dns_entry); /* done with this */
     conn->dns_entry = NULL;
   }
@@ -4402,12 +4443,19 @@
     result = conn->handler->done(conn, status, premature);
   else
     result = CURLE_OK;
 
   Curl_pgrsDone(conn); /* done with the operation */
 
+  /* if the transfer was completed in a paused state there can be buffered
+     data left to write and then kill */
+  if(data->state.tempwrite) {
+    free(data->state.tempwrite);
+    data->state.tempwrite = NULL;
+  }
+
   /* for ares-using, make sure all possible outstanding requests are properly
      cancelled before we proceed */
   ares_cancel(data->state.areschannel);
 
   /* if data->set.reuse_forbid is TRUE, it means the libcurl client has
      forced us to close this no matter what we think.
@@ -4439,20 +4487,74 @@
                     cache here, and therefore cannot be used from this point on
                  */
 
   return result;
 }
 
+/*
+ * do_init() inits the readwrite session. This is inited each time (in the DO
+ * function before the protocol-specific DO functions are invoked) for a
+ * transfer, sometimes multiple times on the same SessionHandle. Make sure
+ * nothing in here depends on stuff that are setup dynamicly for the transfer.
+ */
+
+static CURLcode do_init(struct connectdata *conn)
+{
+  struct SessionHandle *data = conn->data;
+  struct SingleRequest *k = &data->req;
+
+  conn->bits.done = FALSE; /* Curl_done() is not called yet */
+  conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to use */
+
+  /* NB: the content encoding software depends on this initialization */
+  Curl_easy_initHandleData(data);
+
+  k->start = Curl_tvnow(); /* start time */
+  k->now = k->start;   /* current time is now */
+  k->header = TRUE; /* assume header */
+  k->httpversion = -1; /* unknown at this point */
+
+  k->bytecount = 0;
+
+  k->buf = data->state.buffer;
+  k->uploadbuf = data->state.uploadbuffer;
+  k->hbufp = data->state.headerbuff;
+  k->ignorebody=FALSE;
+
+  Curl_pgrsTime(data, TIMER_PRETRANSFER);
+  Curl_speedinit(data);
+
+  Curl_pgrsSetUploadCounter(data, 0);
+  Curl_pgrsSetDownloadCounter(data, 0);
+
+  return CURLE_OK;
+}
+
+/*
+ * do_complete is called when the DO actions are complete.
+ *
+ * We init chunking and trailer bits to their default values here immediately
+ * before receiving any header data for the current request in the pipeline.
+ */
+static void do_complete(struct connectdata *conn)
+{
+  conn->bits.chunk=FALSE;
+  conn->bits.trailerhdrpresent=FALSE;
+
+  conn->data->req.maxfd = (conn->sockfd>conn->writesockfd?
+                               conn->sockfd:conn->writesockfd)+1;
+}
+
 CURLcode Curl_do(struct connectdata **connp, bool *done)
 {
   CURLcode result=CURLE_OK;
   struct connectdata *conn = *connp;
   struct SessionHandle *data = conn->data;
 
-  conn->bits.done = FALSE; /* Curl_done() is not called yet */
-  conn->bits.do_more = FALSE; /* by default there's no curl_do_more() to use */
+  /* setup and init stuff before DO starts, in preparing for the transfer */
+  do_init(conn);
 
   if(conn->handler->do_it) {
     /* generic protocol-specific function pointer set in curl_connect() */
     result = conn->handler->do_it(conn, done);
 
     /* This was formerly done in transfer.c, but we better do it here */
@@ -4503,32 +4604,40 @@
 
           /* ... finally back to actually retry the DO phase */
           result = conn->handler->do_it(conn, done);
         }
       }
     }
+
+    if((result == CURLE_OK) && *done)
+      /* do_complete must be called after the protocol-specific DO function */
+      do_complete(conn);
   }
   return result;
 }
 
 CURLcode Curl_do_more(struct connectdata *conn)
 {
   CURLcode result=CURLE_OK;
 
   if(conn->handler->do_more)
     result = conn->handler->do_more(conn);
 
+  if(result == CURLE_OK)
+    /* do_complete must be called after the protocol-specific DO function */
+    do_complete(conn);
+
   return result;
 }
 
 /* Called on connect, and if there's already a protocol-specific struct
    allocated for a different connection, this frees it that it can be setup
    properly later on. */
 void Curl_reset_reqproto(struct connectdata *conn)
 {
   struct SessionHandle *data = conn->data;
-  if (data->reqdata.proto.generic && data->reqdata.current_conn != conn) {
-    free(data->reqdata.proto.generic);
-    data->reqdata.proto.generic = NULL;
+  if(data->state.proto.generic && data->state.current_conn != conn) {
+    free(data->state.proto.generic);
+    data->state.proto.generic = NULL;
   }
-  data->reqdata.current_conn = conn;
+  data->state.current_conn = conn;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/urldata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/urldata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/urldata.h	2007-10-25 05:09:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/urldata.h	2008-01-28 06:41:56.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urldata.h,v 1.354 2007-10-24 21:09:59 bagder Exp $
+ * $Id: urldata.h,v 1.372 2008-01-21 23:48:58 bagder Exp $
  ***************************************************************************/
 
 /* This file is for lib internal stuff */
 
 #include "setup.h"
 
@@ -70,12 +70,15 @@
 #include "crypto.h"
 #include "x509.h"
 #include "pem.h"
 #include "ssl.h"
 #include "err.h"
 #endif /* USE_OPENSSL */
+#ifdef USE_GNUTLS
+#error Configuration error; cannot use GnuTLS *and* OpenSSL.
+#endif
 #endif /* USE_SSLEAY */
 
 #ifdef USE_GNUTLS
 #include <gnutls/gnutls.h>
 #endif
 
@@ -428,28 +431,29 @@
 /****************************************************************************
  * SSH unique setup
  ***************************************************************************/
 typedef enum {
   SSH_NO_STATE = -1,  /* Used for "nextState" so say there is none */
   SSH_STOP = 0,       /* do nothing state, stops the state machine */
-  SSH_S_STARTUP,      /* Session startup */
+
+  SSH_S_STARTUP,      /* Session startup, First state in SSH-CONNECT */
   SSH_AUTHLIST,
   SSH_AUTH_PKEY_INIT,
   SSH_AUTH_PKEY,
   SSH_AUTH_PASS_INIT,
   SSH_AUTH_PASS,
   SSH_AUTH_HOST_INIT,
   SSH_AUTH_HOST,
   SSH_AUTH_KEY_INIT,
   SSH_AUTH_KEY,
   SSH_AUTH_DONE,
   SSH_SFTP_INIT,
-  SSH_SFTP_REALPATH,
-  SSH_GET_WORKINGPATH,
-  SSH_SFTP_QUOTE_INIT,
-  SSH_SFTP_POSTQUOTE_INIT,
+  SSH_SFTP_REALPATH,   /* Last state in SSH-CONNECT */
+
+  SSH_SFTP_QUOTE_INIT, /* First state in SFTP-DO */
+  SSH_SFTP_POSTQUOTE_INIT, /* (Possibly) First state in SFTP-DONE */
   SSH_SFTP_QUOTE,
   SSH_SFTP_NEXT_QUOTE,
   SSH_SFTP_QUOTE_STAT,
   SSH_SFTP_QUOTE_SETSTAT,
   SSH_SFTP_QUOTE_SYMLINK,
   SSH_SFTP_QUOTE_MKDIR,
@@ -464,69 +468,73 @@
   SSH_SFTP_READDIR_INIT,
   SSH_SFTP_READDIR,
   SSH_SFTP_READDIR_LINK,
   SSH_SFTP_READDIR_BOTTOM,
   SSH_SFTP_READDIR_DONE,
   SSH_SFTP_DOWNLOAD_INIT,
-  SSH_SFTP_DOWNLOAD_STAT,
-  SSH_SFTP_CLOSE,
-  SSH_SFTP_SHUTDOWN,
-  SSH_SCP_TRANS_INIT,
+  SSH_SFTP_DOWNLOAD_STAT, /* Last state in SFTP-DO */
+  SSH_SFTP_CLOSE,    /* Last state in SFTP-DONE */
+  SSH_SFTP_SHUTDOWN, /* First state in SFTP-DISCONNECT */
+  SSH_SCP_TRANS_INIT, /* First state in SCP-DO */
   SSH_SCP_UPLOAD_INIT,
   SSH_SCP_DOWNLOAD_INIT,
   SSH_SCP_DONE,
   SSH_SCP_SEND_EOF,
   SSH_SCP_WAIT_EOF,
   SSH_SCP_WAIT_CLOSE,
-  SSH_SCP_CHANNEL_FREE,
-  SSH_CHANNEL_CLOSE,
-  SSH_SESSION_DISCONECT,
-  SSH_SESSION_FREE,
+  SSH_SCP_CHANNEL_FREE,   /* Last state in SCP-DONE */
+  SSH_SESSION_DISCONNECT, /* First state in SCP-DISCONNECT */
+  SSH_SESSION_FREE,       /* Last state in SCP/SFTP-DISCONNECT */
   SSH_QUIT,
   SSH_LAST  /* never used */
 } sshstate;
 
+/* this struct is used in the HandleData struct which is part of the
+   SessionHandle, which means this is used on a per-easy handle basis.
+   Everything that is strictly related to a connection is banned from this
+   struct. */
 struct SSHPROTO {
-  curl_off_t *bytecountp;
-  char *user;
-  char *passwd;
   char *path;                   /* the path we operate on */
-  char *homedir;
-  char *errorstr;
-#ifdef USE_LIBSSH2
-  LIBSSH2_SESSION       *ssh_session;  /* Secure Shell session */
-  LIBSSH2_CHANNEL       *ssh_channel;  /* Secure Shell channel handle */
-  LIBSSH2_SFTP          *sftp_session; /* SFTP handle */
-  LIBSSH2_SFTP_HANDLE   *sftp_handle;
-#endif /* USE_LIBSSH2 */
 };
 
 /* ssh_conn is used for struct connection-oriented data in the connectdata
    struct */
 struct ssh_conn {
-  const char *authlist; /* List of auth. methods, managed by libssh2 */
+  const char *authlist;       /* List of auth. methods, managed by libssh2 */
 #ifdef USE_LIBSSH2
-  const char *passphrase;
-  char *rsa_pub;
-  char *rsa;
-  bool authed;
-  sshstate state; /* always use ssh.c:state() to change state! */
-  sshstate nextState; /* the state to goto after stopping */
-  CURLcode actualCode;  /* the actual error code */
-  struct curl_slist *quote_item;
-  char *quote_path1;
+  const char *passphrase;     /* passphrase to use */
+  char *rsa_pub;              /* path name */
+  char *rsa;                  /* path name */
+  bool authed;                /* the connection has been authenticated fine */
+  sshstate state;             /* always use ssh.c:state() to change state! */
+  sshstate nextstate;         /* the state to goto after stopping */
+  CURLcode actualcode;        /* the actual error code */
+  struct curl_slist *quote_item; /* for the quote option */
+  char *quote_path1;          /* two generic pointers for the QUOTE stuff */
   char *quote_path2;
-  LIBSSH2_SFTP_ATTRIBUTES quote_attrs;
+  LIBSSH2_SFTP_ATTRIBUTES quote_attrs; /* used by the SFTP_QUOTE state */
+  char *homedir;              /* when doing SFTP we figure out home dir in the
+                                 connect phase */
+
+  /* Here's a set of struct members used by the SFTP_READDIR state */
   LIBSSH2_SFTP_ATTRIBUTES readdir_attrs;
   char *readdir_filename;
   char *readdir_longentry;
   int readdir_len, readdir_totalLen, readdir_currLen;
   char *readdir_line;
   char *readdir_linkPath;
-  int secondCreateDirs;
-  char *slash_pos;
+  /* end of READDIR stuff */
+
+  int secondCreateDirs;         /* counter use by the code to see if the
+                                   second attempt has been made to change
+                                   to/create a directory */
+  char *slash_pos;              /* used by the SFTP_CREATE_DIRS state */
+  LIBSSH2_SESSION *ssh_session; /* Secure Shell session */
+  LIBSSH2_CHANNEL *ssh_channel; /* Secure Shell channel handle */
+  LIBSSH2_SFTP *sftp_session;   /* SFTP handle */
+  LIBSSH2_SFTP_HANDLE *sftp_handle;
 #endif /* USE_LIBSSH2 */
 };
 
 
 /****************************************************************************
  * FILE unique setup
@@ -592,13 +600,13 @@
 
   bool ftp_use_eprt;  /* As set with CURLOPT_FTP_USE_EPRT, but if we find out
                          EPRT doesn't work we disable it for the forthcoming
                          requests */
   bool netrc;         /* name+password provided by netrc */
 
-  bool trailerHdrPresent; /* Set when Trailer: header found in HTTP response.
+  bool trailerhdrpresent; /* Set when Trailer: header found in HTTP response.
                              Required to determine whether to look for trailers
                              in case of Transfer-Encoding: chunking */
   bool done;          /* set to FALSE when Curl_do() is called and set to TRUE
                          when Curl_done() is called, to prevent Curl_done() to
                          get invoked twice when the multi interface is
                          used. */
@@ -621,57 +629,81 @@
 
 /*
  * Flags on the keepon member of the Curl_transfer_keeper
  */
 
 #define KEEP_NONE  0
-#define KEEP_READ  1      /* there is or may be data to read */
-#define KEEP_WRITE 2      /* there is or may be data to write */
-#define KEEP_READ_HOLD 4  /* when set, no reading should be done but there
-                             might still be data to read */
-#define KEEP_WRITE_HOLD 8 /* when set, no writing should be done but there
-                             might still be data to write */
+#define KEEP_READ  (1<<0)     /* there is or may be data to read */
+#define KEEP_WRITE (1<<1)     /* there is or may be data to write */
+#define KEEP_READ_HOLD (1<<2) /* when set, no reading should be done but there
+                                 might still be data to read */
+#define KEEP_WRITE_HOLD (1<<3) /* when set, no writing should be done but there
+                                  might still be data to write */
+#define KEEP_READ_PAUSE (1<<4) /* reading is paused */
+#define KEEP_WRITE_PAUSE (1<<5) /* writing is paused */
+
+#define KEEP_READBITS (KEEP_READ | KEEP_READ_HOLD | KEEP_READ_PAUSE)
+#define KEEP_WRITEBITS (KEEP_WRITE | KEEP_WRITE_HOLD | KEEP_WRITE_PAUSE)
+
 
 #ifdef HAVE_LIBZ
 typedef enum {
   ZLIB_UNINIT,          /* uninitialized */
   ZLIB_INIT,            /* initialized */
   ZLIB_GZIP_HEADER,     /* reading gzip header */
   ZLIB_GZIP_INFLATING,  /* inflating gzip stream */
   ZLIB_INIT_GZIP        /* initialized in transparent gzip mode */
 } zlibInitState;
 #endif
 
-/*
- * This struct is all the previously local variables from Curl_perform() moved
- * to struct to allow the function to return and get re-invoked better without
- * losing state.
- */
+#if defined(USE_ARES) || defined(USE_THREADING_GETHOSTBYNAME) || \
+    defined(USE_THREADING_GETADDRINFO)
+struct Curl_async {
+  char *hostname;
+  int port;
+  struct Curl_dns_entry *dns;
+  bool done;  /* set TRUE when the lookup is complete */
+  int status; /* if done is TRUE, this is the status from the callback */
+  void *os_specific;  /* 'struct thread_data' for Windows */
+};
+#endif
 
-struct Curl_transfer_keeper {
+#define FIRSTSOCKET     0
+#define SECONDARYSOCKET 1
+
+/* These function pointer types are here only to allow easier typecasting
+   within the source when we need to cast between data pointers (such as NULL)
+   and function pointers. */
+typedef CURLcode (*Curl_do_more_func)(struct connectdata *);
+typedef CURLcode (*Curl_done_func)(struct connectdata *, CURLcode, bool);
 
-  /** Values copied over from the HandleData struct each time on init **/
 
+/*
+ * Request specific data in the easy handle (SessionHandle).  Previously,
+ * these members were on the connectdata struct but since a conn struct may
+ * now be shared between different SessionHandles, we store connection-specifc
+ * data here. This struct only keeps stuff that's interesting for *this*
+ * request, as it will be cleared between multiple ones
+ */
+struct SingleRequest {
   curl_off_t size;        /* -1 if unknown at this point */
   curl_off_t *bytecountp; /* return number of bytes read or NULL */
 
   curl_off_t maxdownload; /* in bytes, the maximum amount of data to fetch,
                              -1 means unlimited */
   curl_off_t *writebytecountp; /* return number of bytes written or NULL */
 
-  /** End of HandleData struct copies **/
-
   curl_off_t bytecount;         /* total number of bytes read */
   curl_off_t writebytecount;    /* number of bytes written */
 
-  long headerbytecount;  /* only count received headers */
+  long headerbytecount;         /* only count received headers */
   long deductheadercount; /* this amount of bytes doesn't count when we check
-                          if anything has been transfered at the end of
-                          a connection. We use this counter to make only
-                          a 100 reply (without a following second response
-                          code) result in a CURLE_GOT_NOTHING error code */
+                             if anything has been transfered at the end of a
+                             connection. We use this counter to make only a
+                             100 reply (without a following second response
+                             code) result in a CURLE_GOT_NOTHING error code */
 
   struct timeval start;         /* transfer started at this time */
   struct timeval now;           /* current time */
   bool header;                  /* incoming data has HTTP header */
   enum {
     HEADER_NORMAL,              /* no bad header at all */
@@ -725,97 +757,25 @@
   bool upload_done; /* set to TRUE when doing chunked transfer-encoding upload
                        and we're uploading the last chunk */
 
   bool ignorebody;  /* we read a response-body but we ignore it! */
   bool ignorecl;    /* This HTTP response has no body so we ignore the Content-
                        Length: header */
-};
-
-#if defined(USE_ARES) || defined(USE_THREADING_GETHOSTBYNAME) || \
-    defined(USE_THREADING_GETADDRINFO)
-struct Curl_async {
-  char *hostname;
-  int port;
-  struct Curl_dns_entry *dns;
-  bool done;  /* set TRUE when the lookup is complete */
-  int status; /* if done is TRUE, this is the status from the callback */
-  void *os_specific;  /* 'struct thread_data' for Windows */
-};
-#endif
-
-#define FIRSTSOCKET     0
-#define SECONDARYSOCKET 1
-
-/* These function pointer types are here only to allow easier typecasting
-   within the source when we need to cast between data pointers (such as NULL)
-   and function pointers. */
-typedef CURLcode (*Curl_do_more_func)(struct connectdata *);
-typedef CURLcode (*Curl_done_func)(struct connectdata *, CURLcode, bool);
-
-
-/*
- * Store's request specific data in the easy handle (SessionHandle).
- * Previously, these members were on the connectdata struct but since
- * a conn struct may now be shared between different SessionHandles,
- * we store connection-specifc data here.
- *
- */
-struct HandleData {
-  char *pathbuffer;/* allocated buffer to store the URL's path part in */
-  char *path;      /* path to use, points to somewhere within the pathbuffer
-                      area */
 
   char *newurl; /* This can only be set if a Location: was in the
                    document headers */
 
-  /* This struct is inited when needed */
-  struct Curl_transfer_keeper keep;
-
   /* 'upload_present' is used to keep a byte counter of how much data there is
      still left in the buffer, aimed for upload. */
   ssize_t upload_present;
 
    /* 'upload_fromhere' is used as a read-pointer when we uploaded parts of a
       buffer, so the next read should read from where this pointer points to,
       and the 'upload_present' contains the number of bytes available at this
       position */
   char *upload_fromhere;
-
-  curl_off_t size;        /* -1 if unknown at this point */
-  curl_off_t *bytecountp; /* return number of bytes read or NULL */
-
-  curl_off_t maxdownload; /* in bytes, the maximum amount of data to fetch, -1
-                             means unlimited */
-  curl_off_t *writebytecountp; /* return number of bytes written or NULL */
-
-  bool use_range;
-  bool rangestringalloc; /* the range string is malloc()'ed */
-
-  char *range; /* range, if used. See README for detailed specification on
-                  this syntax. */
-  curl_off_t resume_from; /* continue [ftp] transfer from here */
-
-  /* Protocol specific data.
-   *
-   *************************************************************************
-   * Note that this data will be REMOVED after each request, so anything that
-   * should be kept/stored on a per-connection basis and thus live for the
-   * next requst on the same connection MUST be put in the connectdata struct!
-   *************************************************************************/
-  union {
-    struct HTTP *http;
-    struct HTTP *https;  /* alias, just for the sake of being more readable */
-    struct FTP *ftp;
-    void *tftp;        /* private for tftp.c-eyes only */
-    struct FILEPROTO *file;
-    void *telnet;        /* private for telnet.c-eyes only */
-    void *generic;
-    struct SSHPROTO *ssh;
-  } proto;
-  /* current user of this HandleData instance, or NULL */
-  struct connectdata *current_conn;
 };
 
 /*
  * Specific protocol handler.
  */
 
@@ -989,24 +949,32 @@
 
   bool readchannel_inuse;  /* whether the read channel is in use by an easy
                               handle */
   bool writechannel_inuse; /* whether the write channel is in use by an easy
                               handle */
   bool is_in_pipeline;     /* TRUE if this connection is in a pipeline */
+  bool server_supports_pipelining; /* TRUE if server supports pipelining,
+                                      set after first response */
 
   struct curl_llist *send_pipe; /* List of handles waiting to
                                    send on this pipeline */
   struct curl_llist *recv_pipe; /* List of handles waiting to read
                                    their responses on this pipeline */
+  struct curl_llist *pend_pipe; /* List of pending handles on
+                                   this pipeline */
+#define MAX_PIPELINE_LENGTH 5
 
   char* master_buffer; /* The master buffer allocated on-demand;
                           used for pipelining. */
   size_t read_pos; /* Current read position in the master buffer */
   size_t buf_len; /* Length of the buffer?? */
 
 
+  curl_seek_callback seek_func; /* function that seeks the input */
+  void *seek_client;            /* pointer to pass to the seek() above */
+
   /*************** Request - specific items ************/
 
   /* previously this was in the urldata struct */
   curl_read_callback fread_func; /* function that reads the input */
   void *fread_in;           /* pointer to pass to the fread() above */
 
@@ -1172,37 +1140,40 @@
 
   char *first_host; /* if set, this should be the host name that we will
                        sent authorization to, no else. Used to make Location:
                        following not keep sending user+password... This is
                        strdup() data.
                     */
-
   struct curl_ssl_session *session; /* array of 'numsessions' size */
   long sessionage;                  /* number of the most recent session */
-
+  char *tempwrite;      /* allocated buffer to keep data in when a write
+                           callback returns to make the connection paused */
+  size_t tempwritesize; /* size of the 'tempwrite' allocated buffer */
+  int tempwritetype;    /* type of the 'tempwrite' buffer as a bitmask that is
+                           used with Curl_client_write() */
   char *scratch; /* huge buffer[BUFSIZE*2] when doing upload CRLF replacing */
   bool errorbuf; /* Set to TRUE if the error buffer is already filled in.
                     This must be set to FALSE every time _easy_perform() is
                     called. */
   int os_errno;  /* filled in with errno whenever an error occurs */
 #ifdef HAVE_SIGNAL
   /* storage for the previous bag^H^H^HSIGPIPE signal handler :-) */
   void (*prev_signal)(int sig);
 #endif
   bool allow_port; /* Is set.use_port allowed to take effect or not. This
                       is always set TRUE when curl_easy_perform() is called. */
-
-  struct digestdata digest;
-  struct digestdata proxydigest;
+  struct digestdata digest;      /* state data for host Digest auth */
+  struct digestdata proxydigest; /* state data for proxy Digest auth */
 
 #ifdef HAVE_GSSAPI
-  struct negotiatedata negotiate;
+  struct negotiatedata negotiate; /* state data for host Negotiate auth */
+  struct negotiatedata proxyneg; /* state data for proxy Negotiate auth */
 #endif
 
-  struct auth authhost;
-  struct auth authproxy;
+  struct auth authhost;  /* auth details for host */
+  struct auth authproxy; /* auth details for proxy */
 
   bool authproblem; /* TRUE if there's some problem authenticating */
 
 #ifdef USE_ARES
   ares_channel areschannel; /* for name resolves */
 #endif
@@ -1220,13 +1191,12 @@
   bool ftp_trying_alternative;
 
   bool expect100header;  /* TRUE if we added Expect: 100-continue */
 
   bool pipe_broke; /* TRUE if the connection we were pipelined on broke
                       and we need to restart from the beginning */
-  bool cancelled; /* TRUE if the request was cancelled */
 
 #ifndef WIN32
 /* do FTP line-end conversions on most platforms */
 #define CURL_DO_LINEEND_CONV
   /* for FTP downloads: track CRLF sequences that span blocks */
   bool prev_block_had_trailing_cr;
@@ -1238,12 +1208,42 @@
      must keep it around and add it to the list of handles to kill once all
      its connections are gone */
   void *shared_conn;
   bool closed; /* set to TRUE when curl_easy_cleanup() has been called on this
                   handle, but it is kept around as mentioned for
                   shared_conn */
+  char *pathbuffer;/* allocated buffer to store the URL's path part in */
+  char *path;      /* path to use, points to somewhere within the pathbuffer
+                      area */
+
+  bool use_range;
+  bool rangestringalloc; /* the range string is malloc()'ed */
+
+  char *range; /* range, if used. See README for detailed specification on
+                  this syntax. */
+  curl_off_t resume_from; /* continue [ftp] transfer from here */
+
+  /* Protocol specific data.
+   *
+   *************************************************************************
+   * Note that this data will be REMOVED after each request, so anything that
+   * should be kept/stored on a per-connection basis and thus live for the
+   * next requst on the same connection MUST be put in the connectdata struct!
+   *************************************************************************/
+  union {
+    struct HTTP *http;
+    struct HTTP *https;  /* alias, just for the sake of being more readable */
+    struct FTP *ftp;
+    void *tftp;        /* private for tftp.c-eyes only */
+    struct FILEPROTO *file;
+    void *telnet;        /* private for telnet.c-eyes only */
+    void *generic;
+    struct SSHPROTO *ssh;
+  } proto;
+  /* current user of this SessionHandle instance, or NULL */
+  struct connectdata *current_conn;
 };
 
 
 /*
  * This 'DynamicStatic' struct defines dynamic states that actually change
  * values in the 'UserDefined' area, which MUST be taken into consideration
@@ -1326,16 +1326,18 @@
   long use_port;     /* which port to use (when not using default) */
   long httpauth;     /* what kind of HTTP authentication to use (bitmask) */
   long proxyauth;    /* what kind of proxy authentication to use (bitmask) */
   long followlocation; /* as in HTTP Location: */
   long maxredirs;    /* maximum no. of http(s) redirects to follow, set to -1
                         for infinity */
-  bool post301;      /* Obey RFC 2616/10.3.2 and keep POSTs as POSTs after a 301 */
+  bool post301;      /* Obey RFC 2616/10.3.2 and keep POSTs as POSTs after a
+                        301 */
   bool free_referer; /* set TRUE if 'referer' points to a string we
                         allocated */
   void *postfields;  /* if POST, set the fields' values here */
+  curl_seek_callback seek_func;      /* function that seeks the input */
   curl_off_t postfieldsize; /* if POST, this might have a size to use instead
                                of strlen(), and then the data *may* be binary
                                (contain zero bytes) */
   unsigned short localport; /* local port number to bind to */
   int localportrange; /* number of additional port numbers to test in case the
                          'localport' one can't be bind()ed */
@@ -1348,12 +1350,13 @@
   curl_sockopt_callback fsockopt;  /* function for setting socket options */
   void *sockopt_client; /* pointer to pass to the socket options callback */
   curl_opensocket_callback fopensocket; /* function for checking/translating
                                            the address and opening the socket */
   void* opensocket_client;
 
+  void *seek_client;    /* pointer to pass to the seek callback */
   /* the 3 curl_conv_callback functions below are used on non-ASCII hosts */
   /* function to convert from the network encoding: */
   curl_conv_callback convfromnetwork;
   /* function to convert to the network encoding: */
   curl_conv_callback convtonetwork;
   /* function to convert from UTF-8 encoding: */
@@ -1386,59 +1389,57 @@
   curl_TimeCond timecondition; /* kind of time/date comparison */
   time_t timevalue;       /* what time to compare with */
   Curl_HttpReq httpreq;   /* what kind of HTTP request (if any) is this */
   long httpversion; /* when non-zero, a specific HTTP version requested to
                        be used in the library's request(s) */
   struct ssl_config_data ssl;  /* user defined SSL stuff */
-
   curl_proxytype proxytype; /* what kind of proxy that is in use */
-
   long dns_cache_timeout; /* DNS cache timeout */
   long buffer_size;      /* size of receive buffer to use */
-
-  void *private_data; /* Private data */
+  void *private_data; /* application-private data */
 
   struct Curl_one_easy *one_easy; /* When adding an easy handle to a multi
                                      handle, an internal 'Curl_one_easy'
                                      struct is created and this is a pointer
                                      to the particular struct associated with
                                      this SessionHandle */
 
   struct curl_slist *http200aliases; /* linked list of aliases for http200 */
 
-  long ip_version;
+  long ip_version; /* the CURL_IPRESOLVE_* defines in the public header file
+                      0 - whatever, 1 - v2, 2 - v6 */
 
   curl_off_t max_filesize; /* Maximum file size to download */
 
   curl_ftpfile ftp_filemethod; /* how to get to a file when FTP is used  */
 
 /* Here follows boolean settings that define how to behave during
    this session. They are STATIC, set by libcurl users or at least initially
    and they don't change during operations. */
 
-  bool printhost;       /* printing host name in debug info */
-  bool get_filetime;
-  bool tunnel_thru_httpproxy;
-  bool prefer_ascii;    /* ASCII rather than binary */
-  bool ftp_append;
-  bool ftp_list_only;
-  bool ftp_create_missing_dirs;
-  bool ftp_use_port;
-  bool hide_progress;
-  bool http_fail_on_error;
-  bool http_follow_location;
+  bool printhost;        /* printing host name in debug info */
+  bool get_filetime;     /* get the time and get of the remote file */
+  bool tunnel_thru_httpproxy; /* use CONNECT through a HTTP proxy */
+  bool prefer_ascii;     /* ASCII rather than binary */
+  bool ftp_append;       /* append, not overwrite, on upload */
+  bool ftp_list_only;    /* switch FTP command for listing directories */
+  bool ftp_create_missing_dirs; /* create directories that don't exist */
+  bool ftp_use_port;     /* use the FTP PORT command */
+  bool hide_progress;    /* don't use the progress meter */
+  bool http_fail_on_error;  /* fail on HTTP error codes >= 300 */
+  bool http_follow_location; /* follow HTTP redirects */
   bool http_disable_hostname_check_before_authentication;
   bool include_header;   /* include received protocol headers in data output */
-  bool http_set_referer;
+  bool http_set_referer; /* is a custom referer used */
   bool http_auto_referer; /* set "correct" referer when following location: */
   bool opt_no_body;      /* as set with CURLOPT_NO_BODY */
-  bool set_port;
-  bool upload;
+  bool set_port;         /* custom port number used */
+  bool upload;           /* upload request */
   enum CURL_NETRC_OPTION
        use_netrc;        /* defined in include/curl.h */
-  bool verbose;
+  bool verbose;          /* output verbosity */
   bool krb;              /* kerberos connection requested */
   bool reuse_forbid;     /* forbidden to be reused, close after use */
   bool reuse_fresh;      /* do not re-use an existing connection  */
   bool ftp_use_epsv;     /* if EPSV is to be attempted or not */
   bool ftp_use_eprt;     /* if EPRT is to be attempted or not */
 
@@ -1456,13 +1457,14 @@
   bool http_te_skip;     /* pass the raw body data to the user, even when
                             transfer-encoded (chunked, compressed) */
   bool http_ce_skip;     /* pass the raw body data to the user, even when
                             content-encoded (chunked, compressed) */
   long new_file_perms;    /* Permissions to use when creating remote files */
   long new_directory_perms; /* Permissions to use when creating remote dirs */
-
+  bool proxy_transfer_mode; /* set transfer mode (;type=<a|i>) when doing FTP
+                               via an HTTP proxy */
   char *str[STRING_LAST]; /* array of strings, pointing to allocated memory */
 };
 
 struct Names {
   struct curl_hash *hostcache;
   enum {
@@ -1489,17 +1491,19 @@
   struct Curl_multi *multi;    /* if non-NULL, points to the multi handle
                                   struct to which this "belongs" */
   struct Curl_one_easy *multi_pos; /* if non-NULL, points to the its position
                                       in multi controlling structure to assist
                                       in removal. */
   struct Curl_share *share;    /* Share, handles global variable mutexing */
-  struct HandleData reqdata;   /* Request-specific data */
+  struct SingleRequest req;    /* Request-specific data */
   struct UserDefined set;      /* values set by the libcurl user */
   struct DynamicStatic change; /* possibly modified userdefined data */
-
-  struct CookieInfo *cookies;  /* the cookies, read from files and servers */
+  struct CookieInfo *cookies;  /* the cookies, read from files and servers.
+                                  NOTE that the 'cookie' field in the
+                                  UserDefined struct defines if the "engine"
+                                  is to be used or not. */
   struct Progress progress;    /* for all the progress meter data */
   struct UrlState state;       /* struct for fields used for state info and
                                   other dynamic purposes */
   struct PureInfo info;        /* stats, reports and info data */
 #if defined(CURL_DOES_CONVERSIONS) && defined(HAVE_ICONV)
   iconv_t outbound_cd;         /* for translating to the network encoding */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/url.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/url.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/url.h	2007-10-22 23:05:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/url.h	2008-01-16 20:24:00.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.h,v 1.36 2007-10-22 15:05:35 bagder Exp $
+ * $Id: url.h,v 1.37 2008-01-16 12:24:00 bagder Exp $
  ***************************************************************************/
 
 #include <stdarg.h> /* to make sure we have ap_list */
 
 /*
  * Prototypes for library-wide functions provided by url.c
@@ -61,18 +61,17 @@
                           curl_socket_t *socks,
                           int numsocks);
 int Curl_doing_getsock(struct connectdata *conn,
                        curl_socket_t *socks,
                        int numsocks);
 
+bool Curl_isPipeliningEnabled(const struct SessionHandle *handle);
 CURLcode Curl_addHandleToPipeline(struct SessionHandle *handle,
                                   struct curl_llist *pipeline);
 int Curl_removeHandleFromPipeline(struct SessionHandle *handle,
                                   struct curl_llist *pipeline);
-bool Curl_isHandleAtHead(struct SessionHandle *handle,
-                         struct curl_llist *pipeline);
 
 void Curl_close_connections(struct SessionHandle *data);
 
 #if 0
 CURLcode Curl_protocol_fdset(struct connectdata *conn,
                              fd_set *read_fd_set,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/version.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/version.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/lib/version.c	2007-08-24 21:52:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/lib/version.c	2007-11-07 17:21:36.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: version.c,v 1.55 2007-08-24 09:06:17 patrickm Exp $
+ * $Id: version.c,v 1.56 2007-11-07 09:21:36 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <stdio.h>
@@ -58,16 +58,16 @@
   size_t left = sizeof(version);
   strcpy(ptr, LIBCURL_NAME "/" LIBCURL_VERSION );
   len = strlen(ptr);
   left -= len;
   ptr += len;
 
-  if (left > 1) {
+  if(left > 1) {
     len = Curl_ssl_version(ptr + 1, left - 1);
 
-    if (len > 0) {
+    if(len > 0) {
       *ptr = ' ';
       left -= ++len;
       ptr += len;
     }
   }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/ltmain.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/ltmain.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/ltmain.sh	2007-07-12 05:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/ltmain.sh	2007-11-28 05:23:09.000000000 +0800
@@ -40,13 +40,13 @@
 # Global variables:
 EXIT_SUCCESS=0
 EXIT_FAILURE=1
 
 PROGRAM=ltmain.sh
 PACKAGE=libtool
-VERSION="1.5.24 Debian 1.5.24-1"
+VERSION="1.5.24 Debian 1.5.24-2"
 TIMESTAMP=" (1.1220.2.456 2007/06/24 02:25:32)"
 
 # Be Bourne compatible (taken from Autoconf:_AS_BOURNE_COMPATIBLE).
 if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
   emulate sh
   NULLCMD=:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/Makefile	2007-10-29 22:49:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/Makefile	2008-01-29 01:29:23.000000000 +0800
@@ -2,26 +2,26 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.dist,v 1.40 2007-08-03 11:24:22 gknauf Exp $
+# $Id: Makefile.dist,v 1.41 2008-01-19 11:33:06 bagder Exp $
 ###########################################################################
 
 VC=vc6
 
 all:
 	./configure
@@ -125,12 +125,18 @@
 vc:
 	cd lib
 	nmake /f Makefile.$(VC) cfg=release
 	cd ..\src
 	nmake /f Makefile.$(VC)
 
+vc-x64:
+	cd lib
+	MACHINE=x64 nmake /f Makefile.$(VC) cfg=release
+	cd ..\src
+	MACHINE=x64 nmake /f Makefile.$(VC)
+
 vc-zlib:
 	cd lib
 	nmake /f Makefile.$(VC) cfg=release-zlib
 	cd ..\src
 	nmake /f Makefile.$(VC) cfg=release-zlib
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/Makefile.in	2007-10-29 22:49:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/Makefile.in	2008-01-29 01:29:18.000000000 +0800
@@ -195,12 +195,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/AIX/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/AIX/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/AIX/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/AIX/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -144,12 +144,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/AIX/RPM/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/AIX/RPM/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/AIX/RPM/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/AIX/RPM/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -136,12 +136,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/DOS/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/DOS/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/DOS/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/DOS/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -135,12 +135,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/EPM/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/EPM/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/EPM/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/EPM/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -136,12 +136,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Linux/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Linux/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Linux/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Linux/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -144,12 +144,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Linux/RPM/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Linux/RPM/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Linux/RPM/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Linux/RPM/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -136,12 +136,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -144,12 +144,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/NetWare/get_ver.awk /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/NetWare/get_ver.awk
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/NetWare/get_ver.awk	2004-07-12 01:59:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/NetWare/get_ver.awk	2008-01-26 06:11:15.000000000 +0800
@@ -2,67 +2,75 @@
 # *                                  _   _ ____  _
 # *  Project                     ___| | | |  _ \| |
 # *                             / __| | | | |_) | |
 # *                            | (__| |_| |  _ <| |___
 # *                             \___|\___/|_| \_\_____|
 # *
-# * Copyright (C) 1998 - 2004, Daniel Stenberg, <daniel@haxx.se>, et al.
+# * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 # *
 # * This software is licensed as described in the file COPYING, which
 # * you should have received as part of this distribution. The terms
 # * are also available at http://curl.haxx.se/docs/copyright.html.
 # *
 # * You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # * copies of the Software, and permit persons to whom the Software is
 # * furnished to do so, under the terms of the COPYING file.
 # *
 # * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # * KIND, either express or implied.
 # *
-# * $Id: get_ver.awk,v 1.5 2004/07/11 17:59:07 gknauf Exp $
+# * $Id: get_ver.awk,v 1.7 2008-01-24 15:39:51 gknauf Exp $
 # ***************************************************************************
-# awk script which fetches libcurl version number and string from input file
-# and writes them to STDOUT. Here you can get an awk version for Win32:
-# http://www.gknw.com/development/prgtools/awk.zip
+# awk script which fetches curl / ares version number and string from input
+# file and writes them to STDOUT. Here you can get an awk version for Win32:
+# http://www.gknw.net/development/prgtools/awk-20070501.zip
 #
 BEGIN {
   if (match (ARGV[1], /curlver.h/)) {
     while ((getline < ARGV[1]) > 0) {
-      if (match ($0, /^#define LIBCURL_VERSION "[^"]+"/)) {
+      if (match ($0, /^#define LIBCURL_COPYRIGHT "[^"]+"$/)) {
+        libcurl_copyright_str = substr($0, 28, length($0)-28);
+      }
+      else if (match ($0, /^#define LIBCURL_VERSION "[^"]+"$/)) {
         libcurl_ver_str = substr($3, 2, length($3)-2);
       }
-      else if (match ($0, /^#define LIBCURL_VERSION_MAJOR [^"]+/)) {
+      else if (match ($0, /^#define LIBCURL_VERSION_MAJOR [0-9]+$/)) {
         libcurl_ver_major = substr($3, 1, length($3));
       }
-      else if (match ($0, /^#define LIBCURL_VERSION_MINOR [^"]+/)) {
+      else if (match ($0, /^#define LIBCURL_VERSION_MINOR [0-9]+$/)) {
         libcurl_ver_minor = substr($3, 1, length($3));
       }
-      else if (match ($0, /^#define LIBCURL_VERSION_PATCH [^"]+/)) {
+      else if (match ($0, /^#define LIBCURL_VERSION_PATCH [0-9]+$/)) {
         libcurl_ver_patch = substr($3, 1, length($3));
       }
     }
     libcurl_ver = libcurl_ver_major "," libcurl_ver_minor "," libcurl_ver_patch;
     print "LIBCURL_VERSION = " libcurl_ver "";
     print "LIBCURL_VERSION_STR = " libcurl_ver_str "";
+    print "LIBCURL_COPYRIGHT_STR = " libcurl_copyright_str "";
   }
   if (match (ARGV[1], /ares_version.h/)) {
     while ((getline < ARGV[1]) > 0) {
-      if (match ($0, /^#define ARES_VERSION_STR "[^"]+"/)) {
+      if (match ($0, /^#define ARES_COPYRIGHT "[^"]+"$/)) {
+        libcares_copyright_str = substr($0, 25, length($0)-25);
+      }
+      else if (match ($0, /^#define ARES_VERSION_STR "[^"]+"$/)) {
         libcares_ver_str = substr($3, 2, length($3)-2);
       }
-      else if (match ($0, /^#define ARES_VERSION_MAJOR [^"]+/)) {
+      else if (match ($0, /^#define ARES_VERSION_MAJOR [0-9]+$/)) {
         libcares_ver_major = substr($3, 1, length($3));
       }
-      else if (match ($0, /^#define ARES_VERSION_MINOR [^"]+/)) {
+      else if (match ($0, /^#define ARES_VERSION_MINOR [0-9]+$/)) {
         libcares_ver_minor = substr($3, 1, length($3));
       }
-      else if (match ($0, /^#define ARES_VERSION_PATCH [^"]+/)) {
+      else if (match ($0, /^#define ARES_VERSION_PATCH [0-9]+$/)) {
         libcares_ver_patch = substr($3, 1, length($3));
       }
     }
     libcares_ver = libcares_ver_major "," libcares_ver_minor "," libcares_ver_patch;
     print "LIBCARES_VERSION = " libcares_ver "";
     print "LIBCARES_VERSION_STR = " libcares_ver_str "";
+    print "LIBCARES_COPYRIGHT_STR = " libcares_copyright_str "";
   }
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/ccsidcurl.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/ccsidcurl.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/ccsidcurl.c	2007-10-22 22:30:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/ccsidcurl.c	2008-01-17 05:30:30.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ccsidcurl.c,v 1.4 2007-10-15 18:32:01 patrickm Exp $
+ * $Id: ccsidcurl.c,v 1.5 2008-01-16 16:04:47 patrickm Exp $
  *
  ***************************************************************************/
 
 /* CCSID API wrappers for OS/400. */
 
 #include <iconv.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/ccsidcurl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/ccsidcurl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/ccsidcurl.h	2007-08-23 22:30:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/ccsidcurl.h	2008-01-17 05:30:30.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ccsidcurl.h,v 1.1 2007-08-23 14:30:24 patrickm Exp $
+ * $Id: ccsidcurl.h,v 1.2 2008-01-16 16:04:47 patrickm Exp $
  *
  ***************************************************************************/
 
 #ifndef __CURL_CCSIDCURL_H
 #define __CURL_CCSIDCURL_H
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/curl.inc.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/curl.inc.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/curl.inc.in	2007-10-04 04:25:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/curl.inc.in	2008-01-17 05:30:30.000000000 +0800
@@ -2,26 +2,26 @@
       *                                  _   _ ____  _
       *  Project                     ___| | | |  _ \| |
       *                             / __| | | | |_) | |
       *                            | (__| |_| |  _ <| |___
       *                             \___|\___/|_| \_\_____|
       *
-      * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+      * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
       *
       * This software is licensed as described in the file COPYING, which
       * you should have received as part of this distribution. The terms
       * are also available at http://curl.haxx.se/docs/copyright.html.
       *
       * You may opt to use, copy, modify, merge, publish, distribute and/or sell
       * copies of the Software, and permit persons to whom the Software is
       * furnished to do so, under the terms of the COPYING file.
       *
       * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF
       * ANY KIND, either express or implied.
       *
-      * $Id: curl.inc.in,v 1.5 2007-10-03 15:09:21 patrickm Exp $
+      * $Id: curl.inc.in,v 1.8 2008-01-16 16:04:47 patrickm Exp $
       *
       **************************************************************************
       *
       /if not defined(CURL_CURL_INC_)
       /define CURL_CURL_INC_
       *
@@ -109,12 +109,17 @@
      d                 c                   X'00000010'
      d HTTPPOST_PTRBUFFER...
      d                 c                   X'00000020'
       *
      d CURL_READFUNC_ABORT...
      d                 c                   X'10000000'
+     d CURL_READFUNC_PAUSE...
+     d                 c                   X'10000001'
+      *
+     d CURL_WRITEFUNC_PAUSE...
+     d                 c                   X'10000001'
       *
      d CURLAUTH_NONE   c                   X'00000000'
      d CURLAUTH_BASIC  c                   X'00000001'
      d CURLAUTH_DIGEST...
      d                 c                   X'00000002'
      d CURLAUTH_GSSNEGOTIATE...
@@ -193,12 +198,21 @@
      d                 c                   X'00000001'
      d CURL_CSELECT_OUT...
      d                 c                   X'00000002'
      d CURL_CSELECT_ERR...
      d                 c                   X'00000004'
       *
+     d CURLPAUSE_RECV  c                   X'00000001'
+     d CURLPAUSE_RECV_CONT...
+     d                 c                   X'00000000'
+     d CURLPAUSE_SEND  c                   X'00000004'
+     d CURLPAUSE_SEND_CONT...
+     d                 c                   X'00000000'
+     d CURLPAUSE_ALL   c                   X'00000005'
+     d CURLPAUSE_CONT  c                   X'00000000'
+      *
       **************************************************************************
       *                                Types
       **************************************************************************
       *
      d curl_socket_t   s             10i 0 based(######ptr######)
       *
@@ -401,12 +415,16 @@
      d  CURLPROXY_HTTP...
      d                 c                   0
      d  CURLPROXY_SOCKS4...
      d                 c                   4
      d  CURLPROXY_SOCKS5...
      d                 c                   5
+     d  CURLPROXY_SOCKS4A...
+     d                 c                   6
+     d  CURLPROXY_SOCKS5_HOSTNAME...
+     d                 c                   7
       *
      d curl_usessl     s             10i 0 based(######ptr######)               Enum
      d  CURLUSESSL_NONE...
      d                 c                   0
      d  CURLUSESSL_TRY...
      d                 c                   1
@@ -549,13 +567,13 @@
      d  CURLOPT_POSTFIELDSIZE...
      d                 c                   00060
      d  CURLOPT_HTTPPROXYTUNNEL...
      d                 c                   00061
      d  CURLOPT_INTERFACE...
      d                 c                   10062
-     d  CURLOPT_KRB4LEVEL...
+     d  CURLOPT_KRBLEVEL...
      d                 c                   10063
      d  CURLOPT_SSL_VERIFYPEER...
      d                 c                   00064
      d  CURLOPT_CAINFO...
      d                 c                   10065
      d  CURLOPT_MAXREDIRS...
@@ -728,12 +746,20 @@
      d  CURLOPT_SSH_HOST_PUBLIC_KEY_MD5...
      d                 c                   10162
      d  CURLOPT_OPENSOCKETFUNCTION...
      d                 c                   20163
      d  CURLOPT_OPENSOCKETDATA...
      d                 c                   10164
+     d  CURLOPT_COPYPOSTFIELDS...
+     d                 c                   10165
+     d  CURLOPT_PROXY_TRANSFER_MODE...
+     d                 c                   00166
+     d  CURLOPT_SEEKFUNCTION...
+     d                 c                   20167
+     d  CURLOPT_SEEKDATA...
+     d                 c                   10168
       *
      d CURLFORMcode    s             10i 0 based(######ptr######)               Enum
      d  CURL_FORMADD_OK...
      d                 c                   0
      d  CURL_FORMADD_MEMORY...
      d                 c                   1
@@ -1079,12 +1105,15 @@
      d curl_progress_callback...
      d                 s               *   based(######ptr######) procptr
       *
      d curl_read_callback...
      d                 s               *   based(######ptr######) procptr
       *
+     d curl_seek_callback...
+     d                 s               *   based(######ptr######) procptr
+      *
      d curl_sockopt_callback...
      d                 s               *   based(######ptr######) procptr
       *
      d curl_ioctl_callback...
      d                 s               *   based(######ptr######) procptr
       *
@@ -1322,12 +1351,17 @@
      d  curl                           *   value                                CURL *
       *
      d curl_easy_reset...
      d                 pr                  extproc('curl_easy_reset')
      d  curl                           *   value                                CURL *
       *
+     d curl_easy_pause...
+     d                 pr                  extproc('curl_easy_pause')
+     d  curl                           *   value                                CURL *
+     d  bitmask                      10i 0 value
+      *
      d curl_multi_init...
      d                 pr              *   extproc('curl_multi_init')           CURLM *
       *
      d curl_multi_add_handle...
      d                 pr                  extproc('curl_multi_add_handle')
      d                                     like(CURLMcode)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/initscript.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/initscript.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/initscript.sh	2007-08-23 22:30:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/initscript.sh	2008-01-17 05:30:30.000000000 +0800
@@ -1,9 +1,9 @@
 #!/bin/sh
 
-# $Id: initscript.sh,v 1.1 2007-08-23 14:30:24 patrickm Exp $
+# $Id: initscript.sh,v 1.3 2008-01-16 16:04:47 patrickm Exp $
 
 case "${SCRIPTDIR}" in
 /*)     ;;
 *)      SCRIPTDIR="`pwd`/${SCRIPTDIR}"
 esac
 
@@ -17,28 +17,34 @@
 #  The script directory is supposed to be in $TOPDIR/packages/os400.
 
 TOPDIR=`dirname "${SCRIPTDIR}"`
 TOPDIR=`dirname "${TOPDIR}"`
 export SCRIPTDIR TOPDIR
 
+#  Extract the SONAME from the library makefile.
+
+SONAME=`sed -e '/^VERSION=/!d' -e 's/^.* \([0-9]*\):.*$/\1/'           \
+                                                < "${TOPDIR}/lib/Makefile.am"`
+export SONAME
+
 
 ################################################################################
 #
 #                       Tunable configuration parameters.
 #
 ################################################################################
 
 TARGETLIB='CURL'                # Target OS/400 program library
 STATBNDDIR='CURL_A'             # Static binding directory.
 DYNBNDDIR='CURL'                # Dynamic binding directory.
-SRVPGM='CURL'                   # Service program.
+SRVPGM="CURL.${SONAME}"         # Service program.
 TGTCCSID='500'                  # Target CCSID of objects
 DEBUG='*ALL'                    # Debug level
 OPTIMIZE='10'                   # Optimisation level
 OUTPUT='*NONE'                   # Compilation output option.
-TGTRLS='V5R1M0'                 # Target OS release
+TGTRLS='V5R2M0'                 # Target OS release
 
 export TARGETLIB STATBNDDIR DYNBNDDIR SRVPGM TGTCCSID DEBUG OPTIMIZE OUTPUTC
 export TGTRLS
 
 
 ################################################################################
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/make-lib.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/make-lib.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/make-lib.sh	2007-08-23 22:30:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/make-lib.sh	2008-01-17 05:30:30.000000000 +0800
@@ -1,11 +1,11 @@
 #!/bin/sh
 #
 #       libcurl compilation script for the OS/400.
 #
-# $Id: make-lib.sh,v 1.1 2007-08-23 14:30:24 patrickm Exp $
+# $Id: make-lib.sh,v 1.3 2008-01-16 16:04:47 patrickm Exp $
 
 SCRIPTDIR=`dirname "${0}"`
 . "${SCRIPTDIR}/initscript.sh"
 cd "${TOPDIR}/lib"
 
 
@@ -25,13 +25,13 @@
 
 
 #      Create and compile the identification source file.
 
 echo '#pragma comment(user, "libcurl version '"${LIBCURL_VERSION}"'")' > os400.c
 echo '#pragma comment(date)' >> os400.c
-echo '#pragma comment(copyright, "Copyright (C) 1998-2007 Daniel Stenberg et al. OS/400 version by P. Monnerat")' >> os400.c
+echo '#pragma comment(copyright, "Copyright (C) 1998-2008 Daniel Stenberg et al. OS/400 version by P. Monnerat")' >> os400.c
 make_module     OS400           os400.c
 LINK=                           # No need to rebuild service program yet.
 MODULES=
 
 
 #       Get source list.
@@ -110,18 +110,19 @@
              -e 's/(\(.*\))/\1/'`
 
 #       Create the service program exportation file in DB2 member if needed.
 
 BSF="${LIBIFSNAME}/TOOLS.FILE/BNDSRC.MBR"
 
-if action_needed "${BSF}"
+if action_needed "${BSF}" Makefile.am
 then    LINK=YES
 fi
 
 if [ "${LINK}" ]
-then    echo " STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('LIBCURL')" > "${BSF}"
+then    echo " STRPGMEXP PGMLVL(*CURRENT) SIGNATURE('LIBCURL_${SONAME}')" \
+            > "${BSF}"
         for EXPORT in ${EXPORTS}
         do      echo ' EXPORT    SYMBOL("'"${EXPORT}"'")' >> "${BSF}"
         done
 
         echo ' ENDPGMEXP' >> "${BSF}"
 fi
@@ -135,13 +136,13 @@
 
 if [ "${LINK}" ]
 then    CMD="CRTSRVPGM SRVPGM(${TARGETLIB}/${SRVPGM})"
         CMD="${CMD} SRCFILE(${TARGETLIB}/TOOLS) SRCMBR(BNDSRC)"
         CMD="${CMD} MODULE(${TARGETLIB}/OS400)"
         CMD="${CMD} BNDDIR(${TARGETLIB}/${STATBNDDIR})"
-        CMD="${CMD} BNDSRVPGM(QADRTTS)"
+        CMD="${CMD} BNDSRVPGM(QADRTTS QGLDCLNT QGLDBRDR)"
         CMD="${CMD} TEXT('curl API library')"
         CMD="${CMD} TGTRLS(${TGTRLS})"
         system "${CMD}"
         LINK=YES
 fi
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/os400sys.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/os400sys.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/os400sys.c	2007-08-24 16:25:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/os400sys.c	2008-01-17 05:30:30.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: os400sys.c,v 1.2 2007-08-23 18:46:45 patrickm Exp $
+ * $Id: os400sys.c,v 1.3 2008-01-16 16:04:47 patrickm Exp $
  *
  ***************************************************************************/
 
 /* OS/400 additional support. */
 
 #include "config-os400.h"	/* Not setup.h: we only need some defines. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/os400sys.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/os400sys.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/os400sys.h	2007-08-23 22:30:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/os400sys.h	2008-01-17 05:30:30.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: os400sys.h,v 1.1 2007-08-23 14:30:24 patrickm Exp $
+ * $Id: os400sys.h,v 1.2 2008-01-16 16:04:47 patrickm Exp $
  *
  ***************************************************************************/
 
 /* OS/400 additional definitions. */
 
 #ifndef __OS400_SYS_
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/README.OS400 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/README.OS400
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/OS400/README.OS400	2007-10-22 22:30:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/OS400/README.OS400	2008-01-17 05:30:30.000000000 +0800
@@ -1,7 +1,7 @@
-$Id: README.OS400,v 1.4 2007-10-15 18:32:01 patrickm Exp $
+$Id: README.OS400,v 1.6 2008-01-16 16:04:47 patrickm Exp $
 
 Implementation notes:
 
   This is a true OS/400 implementation, not a PASE implementation (for PASE,
 use AIX implementation).
 
@@ -178,16 +178,17 @@
 
   Leaving file initscript.sh unchanged, this will produce the following OS/400
 objects:
 _ Library CURL. All other objects will be stored in this library.
 _ Modules for all libcurl units.
 _ Binding directory CURL_A, to be used at calling program link time for
-  statically binding the modules (specify BNDSRVPGM(QADRTTS) when creating a
-  program using CURL_A).
-_ Service program CURL, to be used at calling program run-time when this program
-  has dynamically bound curl at link time.
+  statically binding the modules (specify BNDSRVPGM(QADRTTS QGLDCLNT QGLDBRDR)
+  when creating a program using CURL_A).
+_ Service program CURL.<soname>, where <soname> is extracted from the
+  lib/Makefile.am VERSION variable. To be used at calling program run-time
+  when this program has dynamically bound curl at link time.
 _ Binding directory CURL. To be used to dynamically bind libcurl when linking a
   calling program.
 _ Source file H. It contains all the include members needed to compile a C/C++
   module using libcurl, and an ILE/RPG /copy member for support in this
   language.
 _ Standard C/C++ libcurl include members in file H.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Solaris/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Solaris/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Solaris/Makefile.in	2007-10-27 06:25:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Solaris/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -139,12 +139,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/vms/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/vms/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/vms/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/vms/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -135,12 +135,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Win32/cygwin/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Win32/cygwin/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Win32/cygwin/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Win32/cygwin/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -135,12 +135,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Win32/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Win32/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/packages/Win32/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/packages/Win32/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -144,12 +144,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/RELEASE-NOTES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/RELEASE-NOTES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/RELEASE-NOTES	2007-10-28 17:33:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/RELEASE-NOTES	2008-01-26 07:31:37.000000000 +0800
@@ -1,72 +1,94 @@
-Curl and libcurl 7.17.1
+Curl and libcurl 7.18.0
 
- Public curl release number:               102
- Releases counted from the very beginning: 128
- Available command line options:           121
- Available curl_easy_setopt() options:     147
- Number of public functions in libcurl:    55
- Amount of public web site mirrors:        43
- Number of known libcurl bindings:         36
- Number of contributors:                   588
+ Public curl releases:         103
+ Command line options:         126
+ curl_easy_setopt() options:   150
+ Public functions in libcurl:  56
+ Public web site mirrors:      43
+ Known libcurl bindings:       36
+ Contributors:                 597
 
 This release includes the following changes:
  
- o automatically append ";type=<a|i>" when using HTTP proxies for FTP urls
- o improved NSS support
- o added --proxy-negotiate
- o added --post301 and CURLOPT_POST301
- o builds with c-ares 1.5.0
- o added CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 and --hostpubmd5
- o renamed CURLE_SSL_PEER_CERTIFICATE to CURLE_PEER_FAILED_VERIFICATION
- o added CURLOPT_OPENSOCKETFUNCTION and CURLOPT_OPENSOCKETDATA
- o CULROPT_COOKIELIST supports "FLUSH"
- o added CURLOPT_COPYPOSTFIELDS
- o added --static-libs to curl-config
+ o --data-urlencode
+ o CURLOPT_PROXY_TRANSFER_MODE
+ o --no-keepalive - now curl does connections with keep-alive enabled by
+   default
+ o --socks4a added (proxy type CURLPROXY_SOCKS4A for libcurl)
+ o --socks5-hostname added (CURLPROXY_SOCKS5_HOSTNAME for libcurl)
+ o curl_easy_pause()
+ o CURLOPT_SEEKFUNCTION and CURLOPT_SEEKDATA
+ o --keepalive-time
+ o curl --help output was re-ordered
 
 This release includes the following bugfixes:
 
- o curl-config --protocols now properly reports LDAPS, SCP and SFTP
- o ldapv3 support on Windows
- o ldap builds with the MSVC makefiles
- o no HOME and no key given caused SSH auth failure
- o Negotiate authentication over proxy
- o --ftp-method nocwd on directory listings
- o FTP, CURLOPT_NOBODY enabled and CURLOPT_HEADER disabled now does TYPE
-   before SIZE
- o re-used handle transfers with SFTP
- o curl_easy_escape() problem with byte values >= 128
- o handles chunked-encoded CONNECT responses
- o misuse of ares_timeout() result
- o --local-port on TFTP transfers
- o CURLOPT_POSTFIELDS could fail to send binary data
- o specifying a proxy with a trailing slash didn't work (unless it also
-   contained a port number)
- o redirect from HTTP to FTP or TFTP memory problems and leaks
- o re-used connections a bit too much when using non-SSL protocols tunneled
-   over a HTTP proxy
- o embed the manifest in VC8 builds
- o use valgrind in the tests even when the lib is built shared with libtool
- o libcurl built with NSS can now ignore the peer verification even when the
-   ca cert bundle is absent
+ o curl-config --features and --protocols show the correct output when built
+   with NSS, and also when SCP, SFTP and libz are not available
+ o free problem in the curl tool for users with empty home dir
+ o curl.h version 7.17.1 problem when building C++ apps with MSVC
+ o SFTP and SCP use persistent connections
+ o segfault on bad URL
+ o variable wrapping when using absolutely huge send buffer sizes
+ o variable wrapping when using debug callback and the HTTP request wasn't sent
+   in one go
+ o SSL connections with NSS done with the multi-interface
+ o setting a share no longer activates cookies
+ o Negotiate now works on auth and proxy simultanouesly
+ o support HTTP Digest nonces up to 1023 letters
+ o resumed ftp upload no longer requires the read callback to return full
+   buffers
+ o no longer default-appends ;type= on FTP URLs thru proxies
+ o SSL session id caching
+ o POST with callback over proxy requiring NTLM or Digest
+ o Expect: 100-continue flaw on re-used connection with POSTs
+ o build fix for MSVC 9.0 (VS2008)
+ o Windows curl builds failed file truncation when retry downloading
+ o SSL session ID cache memory leak
+ o bad connection re-use check with environment variable-activated proxy use
+ o --libcurl now generates a return statement as well
+ o socklen_t is no longer used in the public includes
+ o time zone offsets from -1400 to +1400 are now accepted by the date parser
+ o allows more spaces in WWW/Proxy-Authenticate: headers
+ o curl-config --libs skips /usr/lib64
+ o range support for file:// transfers
+ o libcurl hang with huge POST request and request-body read from callback
+ o removed extra newlines from many error messages
+ o improved pipelining
+ o improved OOM handling for data url encoded HTTP POSTs when read from a file
+ o test suite could pick wrong tool(s) if more than one existed in the PATH
+ o curl_multi_fdset() failed to return socket while doing CONNECT over proxy
+ o curl_multi_remove_handle() on a handle that is in used for a pipeline now
+   break that pipeline
+ o CURLOPT_COOKIELIST memory leaks
+ o progress meter/callback during http proxy CONNECT requests
+ o auth for http proxy when the proxy closes connection after first response
 
 This release includes the following known bugs:
 
  o see docs/KNOWN_BUGS (http://curl.haxx.se/docs/knownbugs.html)
 
 Other curl-related news:
 
- o 
+ o TclCurl 7.17.1 => http://personal1.iddeo.es/andresgarci/tclcurl/english/
+ o Ruby Curl::Multi 0.1 => http://curl-multi.rubyforge.org/ 
+ o curl-java 0.2.1 => http://curl.haxx.se/libcurl/java/
 
 New curl mirrors:
 
- o http://curl.wetzlmayr.at/ is a new web mirror in Nuremberg, Germany
+ o http://curl.gominet.net/ is new mirror in Vizcaya, Portugal
+ o http://curl.very-clever.com/ is a new mirror in Nuremberg, Germany
 
 This release would not have looked like this without help, code, reports and
 advice from friends like these:
 
- Dan Fandrich, Michal Marek, Gnter Knauf, Rob Crittenden, Immanuel Gregoire,
- Mark Davies, Max Katsev, Philip Langdale, Alex Fishman, Johnny Luong,
- Alexey Pesternikov, Yang Tse, Kim Rinnewitz, Michael Wallner,
- Patrick Monnerat, Vladimir Lazarenko
+ Dan Fandrich, Gisle Vanem, Toby Peterson, Yang Tse, Daniel Black,
+ Robin Johnson, Michal Marek, Ates Goral, Andres Garcia, Rob Crittenden,
+ Emil Romanus, Alessandro Vesely, Ray Pekowski, Spacen Jasset, Andrew Moise,
+ Gilles Blanc, David Wright, Vikram Saxena, Mateusz Loskot, Gary Maxwell,
+ Dmitry Kurochkin, Mohun Biswas, Richard Atterer, Maxim Perenesenko,
+ Daniel Egger, Jeff Johnson, Nikitinskit Dmitriy, Georg Lippitsch, Eric Landes,
+ Joe Malicki, Nathan Coulter, Lau Hang Kin, Judson Bishop, Igor Franchuk,
+ Kevin Reed
  
         Thanks! (and sorry if I forgot to mention someone)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/config.h.in	2007-10-29 22:49:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/config.h.in	2008-01-29 01:28:54.000000000 +0800
@@ -369,12 +369,15 @@
 /* Define to 1 if you have the `poll' function. */
 #undef HAVE_POLL
 
 /* If you have a fine poll */
 #undef HAVE_POLL_FINE
 
+/* Define to 1 if you have the <poll.h> header file. */
+#undef HAVE_POLL_H
+
 /* we have a POSIX-style strerror_r() */
 #undef HAVE_POSIX_STRERROR_R
 
 /* Define to 1 if you have the <pwd.h> header file. */
 #undef HAVE_PWD_H
 
@@ -690,12 +693,15 @@
 /* The size of `curl_off_t', as computed by sizeof. */
 #undef SIZEOF_CURL_OFF_T
 
 /* The size of `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
+/* The size of `off_t', as computed by sizeof. */
+#undef SIZEOF_OFF_T
+
 /* The size of `size_t', as computed by sizeof. */
 #undef SIZEOF_SIZE_T
 
 /* The size of `time_t', as computed by sizeof. */
 #undef SIZEOF_TIME_T
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/config-win32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/config-win32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/config-win32.h	2007-10-25 04:08:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/config-win32.h	2007-12-20 06:10:42.000000000 +0800
@@ -178,20 +178,36 @@
 
 /* Define if the compiler supports LONGLONG. */
 #if defined(__MINGW32__) || defined(__WATCOMC__)
 #define HAVE_LONGLONG 1
 #endif
 
+/* Define to avoid VS2005 complaining about portable C functions */
+#if defined(_MSC_VER) && (_MSC_VER >= 1400)
+#define _CRT_SECURE_NO_DEPRECATE 1
+#define _CRT_NONSTDC_NO_DEPRECATE 1
+#endif
+
+/* VS2008 does not support Windows build targets prior to WinXP, */
+/* so, if no build target has been defined we will target WinXP. */
+#if defined(_MSC_VER) && (_MSC_VER >= 1500)
+#  ifndef _WIN32_WINNT
+#    define _WIN32_WINNT 0x0501
+#  endif
+#  ifndef WINVER
+#    define WINVER 0x0501
+#  endif
+#  if (_WIN32_WINNT < 0x0501) || (WINVER < 0x0501)
+#    error VS2008 does not support Windows build targets prior to WinXP
+#  endif
+#endif
+
 /* ---------------------------------------------------------------- */
 /*                       ADDITIONAL DEFINITIONS                     */
 /* ---------------------------------------------------------------- */
 
-/* Defines set for VS2005 to _not_ deprecate a few functions we use. */
-#define _CRT_SECURE_NO_DEPRECATE 1
-#define _CRT_NONSTDC_NO_DEPRECATE 1
-
 /* Define cpu-machine-OS */
 #ifndef OS
 #define OS "i386-pc-win32"
 #endif
 
 /* Define to 1 if you want the built-in manual */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/curl.rc /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/curl.rc
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/curl.rc	2007-04-14 06:07:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/curl.rc	2008-01-26 06:11:15.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curl.rc,v 1.8 2007-04-13 08:22:57 yangtse Exp $
+ * $Id: curl.rc,v 1.11 2008-01-24 14:14:34 gknauf Exp $
  ***************************************************************************/
 #include <winver.h>
 #include "version.h"
 
 LANGUAGE  0x09,0x01
 
@@ -49,13 +49,14 @@
       VALUE "FileDescription",  "The cURL executable\0"
       VALUE "FileVersion",      CURL_VERSION "\0"
       VALUE "InternalName",     "curl\0"
       VALUE "OriginalFilename", "curl.exe\0"
       VALUE "ProductName",      "The cURL executable\0"
       VALUE "ProductVersion",   CURL_VERSION "\0"
-      VALUE "LegalCopyright",   "Copyright 1996-2007 by Daniel Stenberg. http://curl.haxx.se/docs/copyright.html\0"
+      VALUE "LegalCopyright",   " " CURL_COPYRIGHT "\0"
+      VALUE "License",          "http://curl.haxx.se/docs/copyright.html\0"
     END
   END
 
   BLOCK "VarFileInfo"
   BEGIN
     VALUE "Translation", 0x409, 1200
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/homedir.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/homedir.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/homedir.c	2005-12-20 16:13:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/homedir.c	2007-11-02 05:49:59.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2005, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: homedir.c,v 1.9 2005/12/18 15:36:14 yangtse Exp $
+ * $Id: homedir.c,v 1.10 2007-11-01 21:49:59 bagder Exp $
  ***************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -103,12 +103,14 @@
      home = decc$translate_vms(pw->pw_dir);
 #else
      home = pw->pw_dir;
 #endif
      if (home && home[0])
        home = strdup(home);
+     else
+       home = NULL;
    }
  }
 #endif /* PWD-stuff */
 #ifdef WIN32
   home = GetEnv("APPDATA", TRUE);
   if(!home)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/hugehelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/hugehelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/hugehelp.c	2007-10-14 04:50:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/hugehelp.c	2008-01-26 06:44:31.000000000 +0800
@@ -1,11 +1,11 @@
 #include "setup.h"
 #ifndef HAVE_LIBZ
 /*
  * NEVER EVER edit this manually, fix the mkhelp.pl script instead!
- * Generation time: Sat Oct 13 22:50:00 2007
+ * Generation time: Fri Jan 25 23:44:31 2008
  */
 #include "setup.h"
 #ifdef USE_MANUAL
 #include "hugehelp.h"
 #include <stdio.h>
 void hugehelp(void)
@@ -28,24 +28,24 @@
 , stdout);
  fputs(
 "       supported protocols (HTTP, HTTPS, FTP, FTPS,  SCP,  SFTP,  TFTP,  DICT,\n"
 "       TELNET,  LDAP  or  FILE).  The command is designed to work without user\n"
 "       interaction.\n"
 "\n"
-"       curl offers a busload of useful tricks like proxy support, user authen\n"
-"       tication,  ftp upload, HTTP post, SSL connections, cookies, file trans\n"
+"       curl offers a busload of useful tricks like proxy support, user authen-\n"
+"       tication,  ftp upload, HTTP post, SSL connections, cookies, file trans-\n"
 "       fer resume and more. As you will see below, the number of features will\n"
 "       make your head spin!\n"
 "\n"
 , stdout);
  fputs(
 "       curl  is  powered  by  libcurl  for  all transfer-related features. See\n"
 "       libcurl(3) for details.\n"
 "\n"
 "URL\n"
-"       The URL syntax is protocol dependent. Youll find a  detailed  descrip\n"
+"       The URL syntax is protocol dependent. You'll find a  detailed  descrip-\n"
 "       tion in RFC 3986.\n"
 "\n"
 "       You  can  specify  multiple  URLs or parts of URLs by writing part sets\n"
 "       within braces as in:\n"
 "\n"
 "        http://site.{one,two,three}.com\n"
@@ -72,1076 +72,1136 @@
 "       that you can get every Nth number or letter:\n"
 "        http://www.numericals.com/file[1-100:10].txt\n"
 "        http://www.letters.com/file[a-z:2].txt\n"
 "\n"
 "       If  you  specify  URL  without protocol:// prefix, curl will attempt to\n"
 "       guess what protocol you might want. It will then default  to  HTTP  but\n"
-"       try  other  protocols based on often-used host name prefixes. For exam\n"
+"       try  other  protocols based on often-used host name prefixes. For exam-\n"
 , stdout);
  fputs(
 "       ple, for host names starting with \"ftp.\" curl will assume you  want  to\n"
 "       speak FTP.\n"
 "\n"
 "       Curl will attempt to re-use connections for multiple file transfers, so\n"
-"       that getting many files from the same server will not do multiple  con\n"
+"       that getting many files from the same server will not do multiple  con-\n"
 "       nects / handshakes. This improves speed. Of course this is only done on\n"
 "       files specified on a single command line and  cannot  be  used  between\n"
 "       separate curl invokes.\n"
 "\n"
 "PROGRESS METER\n"
 , stdout);
  fputs(
 "       curl  normally  displays a progress meter during operations, indicating\n"
-"       amount of transfered data, transfer speeds and estimated time left etc.\n"
+"       amount of transferred data, transfer speeds  and  estimated  time  left\n"
+"       etc.\n"
+"\n"
 "       However,  since  curl  displays data to the terminal by default, if you\n"
 "       invoke curl to do an operation and it is about to  write  data  to  the\n"
 "       terminal,  it disables the progress meter as otherwise it would mess up\n"
 "       the output mixing progress meter and response data.\n"
 "\n"
 , stdout);
  fputs(
 "       If you want a progress meter for HTTP POST or PUT requests, you need to\n"
 "       redirect  the  response  output to a file, using shell redirect (>), -o\n"
 "       [file] or similar.\n"
 "\n"
-"       It is not the same case for FTP upload as that operation is  not  spit\n"
+"       It is not the same case for FTP upload as that operation is  not  spit-\n"
 "       ting out any response data to the terminal.\n"
 "\n"
 "       If you prefer a progress \"bar\" instead of the regular meter, -# is your\n"
 "       friend.\n"
 "OPTIONS\n"
 "       -a/--append\n"
 , stdout);
  fputs(
 "              (FTP) When used in an FTP upload, this will tell curl to  append\n"
 "              to  the  target  file  instead  of  overwriting  it. If the file\n"
-"              doesnt exist, it will be created.\n"
+"              doesn't exist, it will be created.\n"
 "\n"
 "              If this option is used twice, the second one will disable append\n"
 "              mode again.\n"
 "\n"
 "       -A/--user-agent <agent string>\n"
 "              (HTTP) Specify the User-Agent string to send to the HTTP server.\n"
 , stdout);
  fputs(
-"              Some  badly  done  CGIs  fail  if  this  field  isnt   set   to\n"
+"              Some  badly  done  CGIs  fail  if  this  field  isn't   set   to\n"
 "              \"Mozilla/4.0\".  To  encode  blanks  in  the string, surround the\n"
 "              string with single quote marks. This can also be  set  with  the\n"
 "              -H/--header option of course.\n"
 "\n"
 "              If  this  option is set more than once, the last one will be the\n"
-"              one thats used.\n"
+"              one that's used.\n"
 "\n"
 "       --anyauth\n"
 "              (HTTP) Tells curl to figure out authentication method by itself,\n"
 , stdout);
  fputs(
 "              and  use the most secure one the remote site claims it supports.\n"
 "              This is done by first doing a request and checking the response-\n"
-"              headers, thus inducing an extra network round-trip. This is used\n"
-"              instead of setting a specific authentication method,  which  you\n"
-"              can do with --basic, --digest, --ntlm, and --negotiate.\n"
+"              headers,  thus  possibly  inducing  an extra network round-trip.\n"
+"              This is  used  instead  of  setting  a  specific  authentication\n"
+"              method,  which  you  can  do with --basic, --digest, --ntlm, and\n"
+"              --negotiate.\n"
 "\n"
-"              Note  that  using --anyauth is not recommended if you do uploads\n"
 , stdout);
  fputs(
-"              from stdin, since it may require data to be sent twice and  then\n"
+"              Note that using --anyauth is not recommended if you  do  uploads\n"
+"              from  stdin, since it may require data to be sent twice and then\n"
 "              the client must be able to rewind. If the need should arise when\n"
 "              uploading from stdin, the upload operation will fail.\n"
 "\n"
-"              If this option is used several times, the following  occurrences\n"
+"              If  this option is used several times, the following occurrences\n"
 "              make no difference.\n"
 "\n"
 "       -b/--cookie <name=data>\n"
-"              (HTTP)  Pass the data to the HTTP server as a cookie. It is sup\n"
 , stdout);
  fputs(
-"              posedly the data previously received from the server in a  \"Set-\n"
-"              Cookie:\"  line.  The data should be in the format \"NAME1=VALUE1;\n"
+"              (HTTP) Pass the data to the HTTP server as a cookie. It is  sup-\n"
+"              posedly  the data previously received from the server in a \"Set-\n"
+"              Cookie:\" line.  The data should be in the format  \"NAME1=VALUE1;\n"
 "              NAME2=VALUE2\".\n"
 "\n"
-"              If no = letter is used in the line, it is treated as  a  file\n"
-"              name  to  use to read previously stored cookie lines from, which\n"
-"              should be used in this session if they match. Using this  method\n"
+"              If  no  '=' letter is used in the line, it is treated as a file-\n"
+"              name to use to read previously stored cookie lines  from,  which\n"
 , stdout);
  fputs(
-"              also  activates  the \"cookie parser\" which will make curl record\n"
-"              incoming cookies too, which may be handy if youre using this in\n"
-"              combination  with  the  -L/--location option. The file format of\n"
-"              the file to read cookies from should be plain  HTTP  headers  or\n"
+"              should  be used in this session if they match. Using this method\n"
+"              also activates the \"cookie parser\" which will make  curl  record\n"
+"              incoming cookies too, which may be handy if you're using this in\n"
+"              combination with the -L/--location option. The  file  format  of\n"
+"              the  file  to  read cookies from should be plain HTTP headers or\n"
 "              the Netscape/Mozilla cookie file format.\n"
 "\n"
-"              NOTE  that  the  file specified with -b/--cookie is only used as\n"
 , stdout);
  fputs(
-"              input. No cookies will be stored in the file. To store  cookies,\n"
-"              use  the  -c/--cookie-jar option or you could even save the HTTP\n"
+"              NOTE that the file specified with -b/--cookie is  only  used  as\n"
+"              input.  No cookies will be stored in the file. To store cookies,\n"
+"              use the -c/--cookie-jar option or you could even save  the  HTTP\n"
 "              headers to a file using -D/--dump-header!\n"
 "\n"
-"              If this option is set more than once, the last one will  be  the\n"
-"              one thats used.\n"
+"              If  this  option is set more than once, the last one will be the\n"
+"              one that's used.\n"
 "\n"
 "       -B/--use-ascii\n"
-"              Enable  ASCII transfer when using FTP or LDAP. For FTP, this can\n"
 , stdout);
  fputs(
-"              also be enforced by using an URL that ends with \";type=A\".  This\n"
-"              option  causes  data sent to stdout to be in text mode for win32\n"
+"              Enable ASCII transfer when using FTP or LDAP. For FTP, this  can\n"
+"              also  be enforced by using an URL that ends with \";type=A\". This\n"
+"              option causes data sent to stdout to be in text mode  for  win32\n"
 "              systems.\n"
 "\n"
-"              If this option is used twice, the second one will disable  ASCII\n"
+"              If  this option is used twice, the second one will disable ASCII\n"
 "              usage.\n"
 "\n"
 "       --basic\n"
-"              (HTTP)  Tells curl to use HTTP Basic authentication. This is the\n"
-"              default and this option is usually pointless, unless you use  it\n"
+"              (HTTP) Tells curl to use HTTP Basic authentication. This is  the\n"
 , stdout);
  fputs(
-"              to  override  a  previously  set  option  that  sets a different\n"
-"              authentication method (such as --ntlm,  --digest  and  --negoti\n"
+"              default  and this option is usually pointless, unless you use it\n"
+"              to override a  previously  set  option  that  sets  a  different\n"
+"              authentication  method  (such  as --ntlm, --digest and --negoti-\n"
 "              ate).\n"
 "\n"
-"              If  this option is used several times, the following occurrences\n"
+"              If this option is used several times, the following  occurrences\n"
 "              make no difference.\n"
 "\n"
 "       --ciphers <list of ciphers>\n"
 "              (SSL) Specifies which ciphers to use in the connection. The list\n"
-"              of  ciphers  must  be using valid ciphers. Read up on SSL cipher\n"
 , stdout);
  fputs(
-"              list          details           on           this           URL:\n"
+"              of ciphers must be using valid ciphers. Read up  on  SSL  cipher\n"
+"              list           details           on           this          URL:\n"
 "              http://www.openssl.org/docs/apps/ciphers.html\n"
 "\n"
-"              NSS  ciphers  are  done differently than OpenSSL and GnuTLS. The\n"
-"              full list of NSS ciphers is in the NSSCipherSuite entry at  this\n"
-"              URL: http://directory.fedora.redhat.com/docs/mod_nss.html#Direc\n"
+"              NSS ciphers are done differently than OpenSSL  and  GnuTLS.  The\n"
+"              full  list of NSS ciphers is in the NSSCipherSuite entry at this\n"
+"              URL: http://directory.fedora.redhat.com/docs/mod_nss.html#Direc-\n"
 "              tives\n"
 "\n"
-"              If this option is used several times, the last one will override\n"
 , stdout);
  fputs(
+"              If this option is used several times, the last one will override\n"
 "              the others.\n"
 "\n"
 "       --compressed\n"
 "              (HTTP) Request a compressed response using one of the algorithms\n"
 "              libcurl supports, and return the uncompressed document.  If this\n"
-"              option  is  used  and  the server sends an unsupported encoding,\n"
+"              option is used and the server  sends  an  unsupported  encoding,\n"
 "              Curl will report an error.\n"
 "\n"
-"              If this option is used several times, each occurrence will  tog\n"
+"              If  this option is used several times, each occurrence will tog-\n"
+, stdout);
+ fputs(
 "              gle it on/off.\n"
 "\n"
 "       --connect-timeout <seconds>\n"
-, stdout);
- fputs(
-"              Maximum  time  in  seconds  that you allow the connection to the\n"
-"              server to take.  This only limits  the  connection  phase,  once\n"
-"              curl  has  connected this option is of no more use. See also the\n"
+"              Maximum time in seconds that you allow  the  connection  to  the\n"
+"              server  to  take.   This  only limits the connection phase, once\n"
+"              curl has connected this option is of no more use. See  also  the\n"
 "              -m/--max-time option.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -c/--cookie-jar <file name>\n"
+, stdout);
+ fputs(
 "              Specify to which file you want curl to write all cookies after a\n"
+"              completed  operation.  Curl  writes  all cookies previously read\n"
+"              from a specified file as  well  as  all  cookies  received  from\n"
+"              remote server(s). If no cookies are known, no file will be writ-\n"
+"              ten. The file will be written using  the  Netscape  cookie  file\n"
+"              format.  If  you  set  the  file name to a single dash, \"-\", the\n"
 , stdout);
  fputs(
-"              completed operation. Curl writes  all  cookies  previously  read\n"
-"              from  a  specified  file  as  well  as all cookies received from\n"
-"              remote server(s). If no cookies are known, no file will be writ\n"
-"              ten.  The  file  will  be written using the Netscape cookie file\n"
-"              format. If you set the file name to  a  single  dash,  \"-\",  the\n"
 "              cookies will be written to stdout.\n"
 "\n"
-, stdout);
- fputs(
-"              NOTE If the cookie jar cant be created or written to, the whole\n"
-"              curl operation wont fail or even report an error clearly. Using\n"
-"              -v  will  get  a warning displayed, but that is the only visible\n"
+"              NOTE If the cookie jar can't be created or written to, the whole\n"
+"              curl operation won't fail or even report an error clearly. Using\n"
+"              -v will get a warning displayed, but that is  the  only  visible\n"
 "              feedback you get about this possibly lethal situation.\n"
 "\n"
-"              If this option is used several times, the  last  specified  file\n"
+"              If  this  option  is used several times, the last specified file\n"
 "              name will be used.\n"
 "\n"
-"       -C/--continue-at <offset>\n"
 , stdout);
  fputs(
-"              Continue/Resume  a  previous  file transfer at the given offset.\n"
-"              The given offset is the exact  number  of  bytes  that  will  be\n"
-"              skipped  counted from the beginning of the source file before it\n"
-"              is transferred to the destination.  If used  with  uploads,  the\n"
+"       -C/--continue-at <offset>\n"
+"              Continue/Resume a previous file transfer at  the  given  offset.\n"
+"              The  given  offset  is  the  exact  number of bytes that will be\n"
+"              skipped counted from the beginning of the source file before  it\n"
+"              is  transferred  to  the destination.  If used with uploads, the\n"
 "              ftp server command SIZE will not be used by curl.\n"
 "\n"
-"              Use  \"-C  -\" to tell curl to automatically find out where/how to\n"
+"              Use \"-C -\" to tell curl to automatically find out  where/how  to\n"
 , stdout);
  fputs(
-"              resume the transfer. It then uses the given  output/input  files\n"
+"              resume  the  transfer. It then uses the given output/input files\n"
 "              to figure that out.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --create-dirs\n"
-"              When used in conjunction with the -o option,  curl  will  create\n"
-"              the  necessary  local directory hierarchy as needed. This option\n"
-"              creates the dirs mentioned with the -o option, nothing else.  If\n"
+"              When  used  in  conjunction with the -o option, curl will create\n"
+"              the necessary local directory hierarchy as needed.  This  option\n"
+"              creates  the dirs mentioned with the -o option, nothing else. If\n"
 , stdout);
  fputs(
-"              the  -o file name uses no dir or if the dirs it mentions already\n"
+"              the -o file name uses no dir or if the dirs it mentions  already\n"
 "              exist, no dir will be created.\n"
 "\n"
-"              To create remote directories when using FTP or SFTP, try  --ftp-\n"
+"              To  create remote directories when using FTP or SFTP, try --ftp-\n"
 "              create-dirs.\n"
 "\n"
 "       --crlf (FTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).\n"
 "\n"
-"              If  this option is used several times, the following occurrences\n"
+"              If this option is used several times, the following  occurrences\n"
 "              make no difference.\n"
 "\n"
 "       -d/--data <data>\n"
 , stdout);
  fputs(
-"              (HTTP) Sends the specified data in a POST request  to  the  HTTP\n"
-"              server,  in  a way that can emulate as if a user has filled in a\n"
-"              HTML form and pressed the submit button. Note that the  data  is\n"
-"              sent  exactly  as  specified  with no extra processing (with all\n"
-"              newlines cut off).  The data is expected  to  be  \"url-encoded\".\n"
-"              This  will  cause  curl to pass the data to the server using the\n"
+"              (HTTP)  Sends  the  specified data in a POST request to the HTTP\n"
+"              server, in the same way that a browser  does  when  a  user  has\n"
+"              filled  in an HTML form and presses the submit button. This will\n"
+"              cause curl to pass the data to the server using the content-type\n"
+"              application/x-www-form-urlencoded.  Compare to -F/--form.\n"
+"\n"
+"              -d/--data  is  the  same  as  --data-ascii.  To post data purely\n"
 , stdout);
  fputs(
-"              content-type   application/x-www-form-urlencoded.   Compare   to\n"
-"              -F/--form.  If  this  option  is used more than once on the same\n"
-"              command line, the data pieces specified will be merged  together\n"
-"              with  a  separating  &-letter.  Thus,  using  -d name=daniel -d\n"
-"              skill=lousy  would  generate  a  post  chunk  that  looks  like\n"
-"              name=daniel&skill=lousy.\n"
+"              binary, you should instead use the --data-binary option. To  URL\n"
+"              encode the value of a form field you may use --data-urlencode.\n"
 "\n"
+"              If  any of these options is used more than once on the same com-\n"
+"              mand line, the data pieces specified  will  be  merged  together\n"
+"              with  a  separating  &-letter.  Thus,  using  '-d name=daniel -d\n"
+"              skill=lousy'  would  generate  a  post  chunk  that  looks  like\n"
 , stdout);
  fputs(
+"              'name=daniel&skill=lousy'.\n"
+"\n"
 "              If  you  start  the data with the letter @, the rest should be a\n"
 "              file name to read the data from, or - if you want curl  to  read\n"
 "              the  data  from stdin.  The contents of the file must already be\n"
 "              url-encoded. Multiple files can also be specified. Posting  data\n"
-"              from  a file named foobar would thus be done with --data @foo\n"
-"              bar\".\n"
+"              from  a file named 'foobar' would thus be done with --data @foo-\n"
+"              bar.\n"
 "\n"
+"       --data-binary <data>\n"
 , stdout);
  fputs(
-"              To post data purely binary, you should instead use  the  --data-\n"
-"              binary option.\n"
+"              (HTTP) This posts data exactly as specified with no  extra  pro-\n"
+"              cessing whatsoever.\n"
+"\n"
+"              If  you  start  the data with the letter @, the rest should be a\n"
+"              filename.  Data is posted in a similar  manner  as  --data-ascii\n"
+"              does,  except  that  newlines  are preserved and conversions are\n"
+"              never done.\n"
 "\n"
-"              -d/--data is the same as --data-ascii.\n"
+"              If this option is used several times,  the  ones  following  the\n"
+, stdout);
+ fputs(
+"              first will append data. As described in -d/--data.\n"
 "\n"
-"              If  this  option  is  used several times, the ones following the\n"
-"              first will append data.\n"
+"       --data-urlencode <data>\n"
+"              (HTTP) This posts data, similar to the other --data options with\n"
+"              the exception that this performs URL encoding. (Added in 7.18.0)\n"
+"              To  be  CGI  compliant, the <data> part should begin with a name\n"
+"              followed by a separator and a content specification. The  <data>\n"
+"              part can be passed to curl using one of the following syntaxes:\n"
 "\n"
-"       --data-ascii <data>\n"
-"              (HTTP) This is an alias for the -d/--data option.\n"
+, stdout);
+ fputs(
+"              content\n"
+"                     This  will make curl URL encode the content and pass that\n"
+"                     on. Just be careful so that the content  doesn't  contain\n"
+"                     any  =  or  @  letters, as that will then make the syntax\n"
+"                     match one of the other cases below!\n"
 "\n"
-"              If this option is used several times,  the  ones  following  the\n"
-"              first will append data.\n"
+"              =content\n"
+"                     This will make curl URL encode the content and pass  that\n"
+"                     on. The preceding = letter is not included in the data.\n"
 "\n"
 , stdout);
  fputs(
-"       --data-binary <data>\n"
-"              (HTTP) This posts data in a similar manner as --data-ascii does,\n"
-"              although when using this option the entire context of the posted\n"
-"              data  is  kept  as-is. If you want to post a binary file without\n"
-"              the strip-newlines feature of the --data-ascii option,  this  is\n"
-"              for you.\n"
+"              name=content\n"
+"                     This  will make curl URL encode the content part and pass\n"
+"                     that on. Note that the name part is expected  to  be  URL\n"
+"                     encoded already.\n"
 "\n"
-"              If  this  option  is  used several times, the ones following the\n"
-"              first will append data.\n"
+"              @filename\n"
+"                     This  will  make  curl  load  data  from  the  given file\n"
+"                     (including any newlines), URL encode that data  and  pass\n"
+"                     it on in the POST.\n"
 "\n"
+"              name@filename\n"
 , stdout);
  fputs(
+"                     This  will  make  curl  load  data  from  the  given file\n"
+"                     (including any newlines), URL encode that data  and  pass\n"
+"                     it  on  in  the  POST.  The  name part gets an equal sign\n"
+"                     appended, resulting in name=urlencoded-file-content. Note\n"
+"                     that the name is expected to be URL encoded already.\n"
+"\n"
 "       --digest\n"
-"              (HTTP) Enables HTTP Digest authentication. This is a authentica\n"
+"              (HTTP) Enables HTTP Digest authentication. This is a authentica-\n"
+, stdout);
+ fputs(
 "              tion that prevents the password from being sent over the wire in\n"
-"              clear text. Use this in combination with  the  normal  -u/--user\n"
-"              option to set user name and password. See also --ntlm, --negoti\n"
+"              clear  text.  Use  this in combination with the normal -u/--user\n"
+"              option to set user name and password. See also --ntlm, --negoti-\n"
 "              ate and --anyauth for related options.\n"
 "\n"
-"              If this option is used several times, the following  occurrences\n"
-, stdout);
- fputs(
+"              If  this option is used several times, the following occurrences\n"
 "              make no difference.\n"
 "\n"
 "       --disable-eprt\n"
+, stdout);
+ fputs(
 "              (FTP) Tell curl to disable the use of the EPRT and LPRT commands\n"
 "              when doing active FTP transfers. Curl will normally always first\n"
-"              attempt  to use EPRT, then LPRT before using PORT, but with this\n"
-"              option, it will use PORT right away. EPRT and  LPRT  are  exten\n"
-"              sions  to the original FTP protocol, may not work on all servers\n"
+"              attempt to use EPRT, then LPRT before using PORT, but with  this\n"
+"              option,  it  will  use PORT right away. EPRT and LPRT are exten-\n"
+"              sions to the original FTP protocol, may not work on all  servers\n"
+"              but  enable  more  functionality in a better way than the tradi-\n"
 , stdout);
  fputs(
-"              but enable more functionality in a better way  than  the  tradi\n"
 "              tional PORT command.\n"
 "\n"
-"              If  this option is used several times, each occurrence will tog\n"
+"              If this option is used several times, each occurrence will  tog-\n"
 "              gle this on/off.\n"
 "\n"
 "       --disable-epsv\n"
-"              (FTP) Tell curl to disable the use  of  the  EPSV  command  when\n"
-"              doing  passive  FTP  transfers.  Curl will normally always first\n"
-"              attempt to use EPSV before PASV, but with this option,  it  will\n"
-, stdout);
- fputs(
+"              (FTP)  Tell  curl  to  disable  the use of the EPSV command when\n"
+"              doing passive FTP transfers. Curl  will  normally  always  first\n"
+"              attempt  to  use EPSV before PASV, but with this option, it will\n"
 "              not try using EPSV.\n"
 "\n"
-"              If  this option is used several times, each occurrence will tog\n"
+, stdout);
+ fputs(
+"              If this option is used several times, each occurrence will  tog-\n"
 "              gle this on/off.\n"
 "\n"
 "       -D/--dump-header <file>\n"
 "              Write the protocol headers to the specified file.\n"
 "\n"
-"              This option is handy to use when you want to store  the  headers\n"
-"              that  a  HTTP  site sends to you. Cookies from the headers could\n"
-"              then be read in a second curl invoke by  using  the  -b/--cookie\n"
+"              This  option  is handy to use when you want to store the headers\n"
+"              that a HTTP site sends to you. Cookies from  the  headers  could\n"
+"              then  be  read  in a second curl invoke by using the -b/--cookie\n"
 , stdout);
  fputs(
-"              option!  The  -c/--cookie-jar  option is however a better way to\n"
+"              option! The -c/--cookie-jar option is however a  better  way  to\n"
 "              store cookies.\n"
 "\n"
-"              When used on FTP, the ftp server response lines  are  considered\n"
+"              When  used  on FTP, the ftp server response lines are considered\n"
 "              being \"headers\" and thus are saved there.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -e/--referer <URL>\n"
-"              (HTTP) Sends the \"Referer Page\" information to the HTTP  server.\n"
+"              (HTTP)  Sends the \"Referer Page\" information to the HTTP server.\n"
 , stdout);
  fputs(
-"              This  can also be set with the -H/--header flag of course.  When\n"
-"              used with -L/--location you can append \";auto\" to the  --referer\n"
-"              URL to make curl automatically set the previous URL when it fol\n"
-"              lows a Location: header. The \";auto\" string can be  used  alone,\n"
-"              even if you dont set an initial --referer.\n"
+"              This can also be set with the -H/--header flag of course.   When\n"
+"              used  with -L/--location you can append \";auto\" to the --referer\n"
+"              URL to make curl automatically set the previous URL when it fol-\n"
+"              lows  a  Location: header. The \";auto\" string can be used alone,\n"
+"              even if you don't set an initial --referer.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --engine <name>\n"
 , stdout);
  fputs(
-"              Select the OpenSSL crypto engine to use for  cipher  operations.\n"
-"              Use  --engine  list  to  print  a  list  of build-time supported\n"
-"              engines. Note that not all (or  none)  of  the  engines  may  be\n"
+"              Select  the  OpenSSL crypto engine to use for cipher operations.\n"
+"              Use --engine list  to  print  a  list  of  build-time  supported\n"
+"              engines.  Note  that  not  all  (or  none) of the engines may be\n"
 "              available at run-time.\n"
 "\n"
 "       --environment\n"
-"              (RISC  OS ONLY) Sets a range of environment variables, using the\n"
-"              names the -w option supports, to easier allow extraction of use\n"
+"              (RISC OS ONLY) Sets a range of environment variables, using  the\n"
+"              names the -w option supports, to easier allow extraction of use-\n"
 , stdout);
  fputs(
 "              ful information after having run curl.\n"
 "\n"
-"              If  this option is used several times, each occurrence will tog\n"
+"              If this option is used several times, each occurrence will  tog-\n"
 "              gle this on/off.\n"
 "\n"
 "       --egd-file <file>\n"
-"              (SSL) Specify the path name  to  the  Entropy  Gathering  Daemon\n"
-"              socket.  The  socket  is  used to seed the random engine for SSL\n"
+"              (SSL)  Specify  the  path  name  to the Entropy Gathering Daemon\n"
+"              socket. The socket is used to seed the  random  engine  for  SSL\n"
 "              connections. See also the --random-file option.\n"
 "\n"
 "       -E/--cert <certificate[:password]>\n"
 , stdout);
  fputs(
-"              (SSL) Tells curl to use the specified certificate file when get\n"
-"              ting  a  file with HTTPS or FTPS. The certificate must be in PEM\n"
-"              format.  If the optional password isnt specified,  it  will  be\n"
-"              queried  for  on  the  terminal. Note that this option assumes a\n"
-"              \"certificate\" file that is the private key and the private  cer\n"
-"              tificate  concatenated!  See  --cert  and  --key to specify them\n"
+"              (SSL) Tells curl to use the specified certificate file when get-\n"
+"              ting a file with HTTPS or FTPS. The certificate must be  in  PEM\n"
+"              format.   If  the  optional password isn't specified, it will be\n"
+"              queried for on the terminal. Note that  this  option  assumes  a\n"
+"              \"certificate\"  file that is the private key and the private cer-\n"
+"              tificate concatenated! See --cert  and  --key  to  specify  them\n"
 , stdout);
  fputs(
 "              independently.\n"
 "\n"
-"              If curl is built against the NSS SSL library  then  this  option\n"
+"              If  curl  is  built against the NSS SSL library then this option\n"
 "              tells curl the nickname of the certificate to use within the NSS\n"
-"              database defined by the  environment  variable  SSL_DIR  (or  by\n"
-"              default  /etc/pki/nssdb).  If  the  NSS PEM PKCS#11 module (lib\n"
+"              database  defined  by  the  environment  variable SSL_DIR (or by\n"
+"              default /etc/pki/nssdb). If the NSS  PEM  PKCS#11  module  (lib-\n"
 "              nsspem.so) is available then PEM files may be loaded.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 , stdout);
  fputs(
 "       --cert-type <type>\n"
-"              (SSL)  Tells curl what certificate type the provided certificate\n"
+"              (SSL) Tells curl what certificate type the provided  certificate\n"
 "              is in. PEM, DER and ENG are recognized types.  If not specified,\n"
 "              PEM is assumed.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --cacert <CA certificate>\n"
 "              (SSL) Tells curl to use the specified certificate file to verify\n"
-"              the  peer.  The  file  may contain multiple CA certificates. The\n"
+"              the peer. The file may contain  multiple  CA  certificates.  The\n"
 , stdout);
  fputs(
 "              certificate(s) must be in PEM format.\n"
 "\n"
-"              curl recognizes the environment variable named  CURL_CA_BUNDLE\n"
-"              if  that  is set, and uses the given path as a path to a CA cert\n"
+"              curl  recognizes the environment variable named 'CURL_CA_BUNDLE'\n"
+"              if that is set, and uses the given path as a path to a  CA  cert\n"
 "              bundle. This option overrides that variable.\n"
 "\n"
-"              The windows version of curl will automatically  look  for  a  CA\n"
-"              certs file named curl-ca-bundle.crt, either in the same direc\n"
+"              The  windows  version  of  curl will automatically look for a CA\n"
+"              certs file named 'curl-ca-bundle.crt', either in the same direc-\n"
 , stdout);
  fputs(
 "              tory as curl.exe, or in the Current Working Directory, or in any\n"
 "              folder along your PATH.\n"
 "\n"
-"              If  curl  is  built against the NSS SSL library then this option\n"
-"              tells curl the nickname of the CA certificate to use within  the\n"
-"              NSS  database defined by the environment variable SSL_DIR (or by\n"
-"              default /etc/pki/nssdb).  If the NSS PEM  PKCS#11  module  (lib\n"
+"              If curl is built against the NSS SSL library  then  this  option\n"
+"              tells  curl the nickname of the CA certificate to use within the\n"
+"              NSS database defined by the environment variable SSL_DIR (or  by\n"
+"              default  /etc/pki/nssdb).   If  the NSS PEM PKCS#11 module (lib-\n"
 , stdout);
  fputs(
 "              nsspem.so) is available then PEM files may be loaded.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --capath <CA certificate directory>\n"
-"              (SSL) Tells curl to use the specified certificate  directory  to\n"
+"              (SSL)  Tells  curl to use the specified certificate directory to\n"
 "              verify the peer. The certificates must be in PEM format, and the\n"
-"              directory must have been processed using  the  c_rehash  utility\n"
+"              directory  must  have  been processed using the c_rehash utility\n"
 , stdout);
  fputs(
-"              supplied  with  openssl.  Using  --capath can allow curl to make\n"
+"              supplied with openssl. Using --capath can  allow  curl  to  make\n"
 "              SSL-connections much more efficiently than using --cacert if the\n"
 "              --cacert file contains many CA certificates.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -f/--fail\n"
-"              (HTTP) Fail silently (no output at all) on server  errors.  This\n"
-"              is  mostly done like this to better enable scripts etc to better\n"
+"              (HTTP)  Fail  silently (no output at all) on server errors. This\n"
+"              is mostly done like this to better enable scripts etc to  better\n"
 , stdout);
  fputs(
-"              deal with failed attempts. In normal cases when  a  HTTP  server\n"
+"              deal  with  failed  attempts. In normal cases when a HTTP server\n"
 "              fails to deliver a document, it returns an HTML document stating\n"
-"              so (which often also describes why and  more).  This  flag  will\n"
+"              so  (which  often  also  describes why and more). This flag will\n"
 "              prevent curl from outputting that and return error 22.\n"
 "\n"
-"              This  method is not fail-safe and there are occasions where non-\n"
-"              successful response codes will  slip  through,  especially  when\n"
+"              This method is not fail-safe and there are occasions where  non-\n"
+"              successful  response  codes  will  slip through, especially when\n"
 , stdout);
  fputs(
 "              authentication is involved (response codes 401 and 407).\n"
 "\n"
-"              If  this  option  is  used  twice, the second will again disable\n"
+"              If this option is used twice,  the  second  will  again  disable\n"
 "              silent failure.\n"
 "\n"
 "       --ftp-account [data]\n"
 "              (FTP) When an FTP server asks for \"account data\" after user name\n"
-"              and  password has been provided, this data is sent off using the\n"
+"              and password has been provided, this data is sent off using  the\n"
 "              ACCT command. (Added in 7.13.0)\n"
 "\n"
-"              If this option is used twice, the second will override the  pre\n"
+"              If  this option is used twice, the second will override the pre-\n"
 , stdout);
  fputs(
 "              vious use.\n"
 "\n"
 "       --ftp-create-dirs\n"
-"              (FTP) When an FTP or SFTP URL/operation uses a path that doesnt\n"
-"              currently exist on the server, the standard behavior of curl  is\n"
-"              to  fail. Using this option, curl will instead attempt to create\n"
+"              (FTP) When an FTP or SFTP URL/operation uses a path that doesn't\n"
+"              currently  exist on the server, the standard behavior of curl is\n"
+"              to fail. Using this option, curl will instead attempt to  create\n"
 "              missing directories.\n"
 "\n"
-"              If this option is used twice,  the  second  will  again  disable\n"
+"              If  this  option  is  used  twice, the second will again disable\n"
 "              directory creation.\n"
 "\n"
 "       --ftp-method [method]\n"
 , stdout);
  fputs(
-"              (FTP)  Control  what method curl should use to reach a file on a\n"
-"              FTP(S) server. The method argument should be one of the  follow\n"
+"              (FTP) Control what method curl should use to reach a file  on  a\n"
+"              FTP(S)  server. The method argument should be one of the follow-\n"
 "              ing alternatives:\n"
 "\n"
 "              multicwd\n"
-"                     curl  does  a  single CWD operation for each path part in\n"
-"                     the given URL. For deep hierarchies this means very  many\n"
-"                     commands.  This  is  how  RFC1738 says it should be done.\n"
+"                     curl does a single CWD operation for each  path  part  in\n"
+"                     the  given URL. For deep hierarchies this means very many\n"
+"                     commands. This is how RFC1738 says  it  should  be  done.\n"
 , stdout);
  fputs(
 "                     This is the default but the slowest behavior.\n"
 "\n"
-"              nocwd  curl does no CWD at all. curl will do  SIZE,  RETR,  STOR\n"
-"                     etc and give a full path to the server for all these com\n"
+"              nocwd  curl  does  no  CWD at all. curl will do SIZE, RETR, STOR\n"
+"                     etc and give a full path to the server for all these com-\n"
 "                     mands. This is the fastest behavior.\n"
 "\n"
 "              singlecwd\n"
 "                     curl does one CWD with the full target directory and then\n"
-"                     operates  on  the  file  \"normally\" (like in the multicwd\n"
+"                     operates on the file \"normally\"  (like  in  the  multicwd\n"
 , stdout);
  fputs(
-"                     case). This is somewhat  more  standards  compliant  than\n"
-"                     nocwd but without the full penalty of multicwd.\n"
+"                     case).  This  is  somewhat  more standards compliant than\n"
+"                     'nocwd' but without the full penalty of 'multicwd'.\n"
 "\n"
 "       --ftp-pasv\n"
-"              (FTP)  Use  PASV when transferring. PASV is the internal default\n"
-"              behavior, but using this option can be used to override a previ\n"
+"              (FTP) Use PASV when transferring. PASV is the  internal  default\n"
+"              behavior, but using this option can be used to override a previ-\n"
 "              ous --ftp-port option. (Added in 7.11.0)\n"
 "\n"
-"              If  this option is used several times, the following occurrences\n"
-, stdout);
- fputs(
+"              If this option is used several times, the following  occurrences\n"
 "              make no difference.\n"
 "\n"
+, stdout);
+ fputs(
 "       --ftp-alternative-to-user <command>\n"
-"              (FTP) If authenticating with the USER and PASS  commands  fails,\n"
-"              send  this  command.   When  connecting  to  Tumbleweeds Secure\n"
-"              Transport server over FTPS using  a  client  certificate,  using\n"
-"              \"SITE  AUTH\"  will tell the server to retrieve the username from\n"
+"              (FTP)  If  authenticating with the USER and PASS commands fails,\n"
+"              send this  command.   When  connecting  to  Tumbleweed's  Secure\n"
+"              Transport  server  over  FTPS  using a client certificate, using\n"
+"              \"SITE AUTH\" will tell the server to retrieve the  username  from\n"
 "              the certificate. (Added in 7.15.5)\n"
 "\n"
 "       --ftp-skip-pasv-ip\n"
 , stdout);
  fputs(
 "              (FTP) Tell curl to not use the IP address the server suggests in\n"
-"              its  response to curls PASV command when curl connects the data\n"
-"              connection. Instead curl will re-use  the  same  IP  address  it\n"
+"              its response to curl's PASV command when curl connects the  data\n"
+"              connection.  Instead  curl  will  re-use  the same IP address it\n"
 "              already uses for the control connection. (Added in 7.14.2)\n"
 "\n"
-"              This  option has no effect if PORT, EPRT or EPSV is used instead\n"
+"              This option has no effect if PORT, EPRT or EPSV is used  instead\n"
 "              of PASV.\n"
 "\n"
-"              If this option is used twice, the  second  will  again  use  the\n"
+"              If  this  option  is  used  twice, the second will again use the\n"
 , stdout);
  fputs(
-"              servers suggested address.\n"
+"              server's suggested address.\n"
 "\n"
 "       --ftp-ssl\n"
-"              (FTP)  Try  to use SSL/TLS for the FTP connection.  Reverts to a\n"
-"              non-secure connection if the  server  doesnt  support  SSL/TLS.\n"
-"              See also --ftp-ssl-control and --ftp-ssl-reqd for different lev\n"
+"              (FTP) Try to use SSL/TLS for the FTP connection.  Reverts  to  a\n"
+"              non-secure  connection  if  the  server doesn't support SSL/TLS.\n"
+"              See also --ftp-ssl-control and --ftp-ssl-reqd for different lev-\n"
 "              els of encryption required. (Added in 7.11.0)\n"
 "\n"
-"              If this option is used twice,  the  second  will  again  disable\n"
+"              If  this  option  is  used  twice, the second will again disable\n"
 "              this.\n"
 "\n"
 "       --ftp-ssl-control\n"
 , stdout);
  fputs(
-"              (FTP)  Require  SSL/TLS  for  the ftp login, clear for transfer.\n"
-"              Allows secure authentication, but non-encrypted  data  transfers\n"
-"              for  efficiency.   Fails the transfer if the server doesnt sup\n"
+"              (FTP) Require SSL/TLS for the ftp  login,  clear  for  transfer.\n"
+"              Allows  secure  authentication, but non-encrypted data transfers\n"
+"              for efficiency.  Fails the transfer if the server  doesn't  sup-\n"
 "              port SSL/TLS.  (Added in 7.16.0)\n"
 "\n"
-"              If this option is used twice,  the  second  will  again  disable\n"
+"              If  this  option  is  used  twice, the second will again disable\n"
 "              this.\n"
 "\n"
 "       --ftp-ssl-reqd\n"
-"              (FTP)  Require  SSL/TLS  for the FTP connection.  Terminates the\n"
+"              (FTP) Require SSL/TLS for the FTP  connection.   Terminates  the\n"
 , stdout);
  fputs(
-"              connection if the server doesnt  support  SSL/TLS.   (Added  in\n"
+"              connection  if  the  server  doesn't support SSL/TLS.  (Added in\n"
 "              7.15.5)\n"
 "\n"
-"              If  this  option  is  used  twice, the second will again disable\n"
+"              If this option is used twice,  the  second  will  again  disable\n"
 "              this.\n"
 "\n"
 "       --ftp-ssl-ccc\n"
-"              (FTP) Use CCC (Clear Command Channel)  Shuts  down  the  SSL/TLS\n"
-"              layer after authenticating. The rest of the control channel com\n"
-"              munication will be unencrypted. This allows NAT routers to  fol\n"
+"              (FTP)  Use  CCC  (Clear  Command Channel) Shuts down the SSL/TLS\n"
+"              layer after authenticating. The rest of the control channel com-\n"
+"              munication  will be unencrypted. This allows NAT routers to fol-\n"
 , stdout);
  fputs(
 "              low the FTP transaction. The default mode is passive. See --ftp-\n"
 "              ssl-ccc-mode for other modes.  (Added in 7.16.1)\n"
 "\n"
-"              If this option is used twice,  the  second  will  again  disable\n"
+"              If  this  option  is  used  twice, the second will again disable\n"
 "              this.\n"
 "\n"
 "       --ftp-ssl-ccc-mode [active/passive]\n"
-"              (FTP)  Use  CCC  (Clear  Command Channel) Sets the CCC mode. The\n"
-"              passive mode will not initiate the shutdown,  but  instead  wait\n"
+"              (FTP) Use CCC (Clear Command Channel) Sets  the  CCC  mode.  The\n"
+"              passive  mode  will  not initiate the shutdown, but instead wait\n"
 , stdout);
  fputs(
 "              for the server to do it, and will not reply to the shutdown from\n"
 "              the server. The active mode initiates the shutdown and waits for\n"
 "              a reply from the server.  (Added in 7.16.2)\n"
 "\n"
 "       -F/--form <name=content>\n"
-"              (HTTP)  This  lets curl emulate a filled in form in which a user\n"
-"              has pressed the submit button. This causes  curl  to  POST  data\n"
+"              (HTTP) This lets curl emulate a filled in form in which  a  user\n"
+"              has  pressed  the  submit  button. This causes curl to POST data\n"
 "              using the Content-Type multipart/form-data according to RFC1867.\n"
 , stdout);
  fputs(
-"              This enables uploading of binary files etc. To force  the  con\n"
-"              tent part to be a file, prefix the file name with an @ sign. To\n"
+"              This  enables  uploading of binary files etc. To force the 'con-\n"
+"              tent' part to be a file, prefix the file name with an @ sign. To\n"
 "              just get the content part from a file, prefix the file name with\n"
-"              the  letter  <.  The  difference  between @ and < is then that @\n"
-"              makes a file get attached in the post as a  file  upload,  while\n"
+"              the letter <. The difference between @ and  <  is  then  that  @\n"
+"              makes  a  file  get attached in the post as a file upload, while\n"
 "              the < makes a text field and just get the contents for that text\n"
 , stdout);
  fputs(
 "              field from a file.\n"
 "\n"
-"              Example, to send your password file to the server, where  pass\n"
-"              word is the name of the form-field to which /etc/passwd will be\n"
+"              Example,  to send your password file to the server, where 'pass-\n"
+"              word' is the name of the form-field to which /etc/passwd will be\n"
 "              the input:\n"
 "\n"
 "              curl -F password=@/etc/passwd www.mypasswords.com\n"
 "\n"
-"              To read the files content from stdin instead of a file,  use  -\n"
-"              where  the  file name shouldve been. This goes for both @ and <\n"
+"              To  read  the file's content from stdin instead of a file, use -\n"
+"              where the file name should've been. This goes for both @  and  <\n"
 "              constructs.\n"
 "\n"
 , stdout);
  fputs(
-"              You can also  tell  curl  what  Content-Type  to  use  by  using\n"
-"              type=, in a manner similar to:\n"
+"              You  can  also  tell  curl  what  Content-Type  to  use by using\n"
+"              'type=', in a manner similar to:\n"
 "\n"
 "              curl -F \"web=@index.html;type=text/html\" url.com\n"
 "\n"
 "              or\n"
 "\n"
 "              curl -F \"name=daniel;type=text/foo\" url.com\n"
 "\n"
-"              You  can also explicitly change the name field of an file upload\n"
+"              You can also explicitly change the name field of an file  upload\n"
 "              part by setting filename=, like this:\n"
 "\n"
 "              curl -F \"file=@localfile;filename=nameinpost\" url.com\n"
 "\n"
 , stdout);
  fputs(
 "              See further examples and details in the MANUAL.\n"
 "\n"
 "              This option can be used multiple times.\n"
 "\n"
 "       --form-string <name=string>\n"
-"              (HTTP) Similar to --form except that the value  string  for  the\n"
-"              named  parameter  is used literally. Leading @ and < charac\n"
-"              ters, and the ;type= string in the value have no special mean\n"
-"              ing. Use this in preference to --form if theres any possibility\n"
+"              (HTTP)  Similar  to  --form except that the value string for the\n"
+"              named parameter is used literally. Leading '@' and  '<'  charac-\n"
+"              ters, and the ';type=' string in the value have no special mean-\n"
+"              ing. Use this in preference to --form if there's any possibility\n"
 , stdout);
  fputs(
-"              that the string value may accidentally trigger the  @  or  <\n"
+"              that  the  string  value may accidentally trigger the '@' or '<'\n"
 "              features of --form.\n"
 "\n"
 "       -g/--globoff\n"
 "              This option switches off the \"URL globbing parser\". When you set\n"
-"              this option, you can specify URLs that contain the letters  {}[]\n"
-"              without  having them being interpreted by curl itself. Note that\n"
-"              these letters are not normal legal URL contents but they  should\n"
+"              this  option, you can specify URLs that contain the letters {}[]\n"
+"              without having them being interpreted by curl itself. Note  that\n"
+"              these  letters are not normal legal URL contents but they should\n"
 , stdout);
  fputs(
 "              be encoded according to the URI standard.\n"
 "\n"
 "       -G/--get\n"
-"              When  used,  this  option  will  make  all  data  specified with\n"
-"              -d/--data or --data-binary to be used  in  a  HTTP  GET  request\n"
-"              instead  of  the  POST request that otherwise would be used. The\n"
-"              data will be appended to the URL with a ?  separator.\n"
+"              When used,  this  option  will  make  all  data  specified  with\n"
+"              -d/--data  or  --data-binary  to  be  used in a HTTP GET request\n"
+"              instead of the POST request that otherwise would  be  used.  The\n"
+"              data will be appended to the URL with a '?'  separator.\n"
 "\n"
-"              If used in combination with -I, the POST data  will  instead  be\n"
+"              If  used  in  combination with -I, the POST data will instead be\n"
 , stdout);
  fputs(
 "              appended to the URL with a HEAD request.\n"
 "\n"
-"              If  this option is used several times, the following occurrences\n"
+"              If this option is used several times, the following  occurrences\n"
 "              make no difference.\n"
 "\n"
 "       -h/--help\n"
 "              Usage help.\n"
 "\n"
 "       -H/--header <header>\n"
-"              (HTTP) Extra header to use when getting  a  web  page.  You  may\n"
+"              (HTTP)  Extra  header  to  use  when getting a web page. You may\n"
 "              specify any number of extra headers. Note that if you should add\n"
-"              a custom header that has the same name as one  of  the  internal\n"
-, stdout);
- fputs(
-"              ones  curl  would  use,  your externally set header will be used\n"
-"              instead of the internal one. This allows you to make even trick\n"
-"              ier  stuff  than  curl would normally do. You should not replace\n"
-"              internally set  headers  without  knowing  perfectly  well  what\n"
-"              youre  doing. Remove an internal header by giving a replacement\n"
-"              without content on the right  side  of  the  colon,  as  in:  -H\n"
+"              a  custom  header  that has the same name as one of the internal\n"
 , stdout);
  fputs(
+"              ones curl would use, your externally set  header  will  be  used\n"
+"              instead of the internal one. This allows you to make even trick-\n"
+"              ier stuff than curl would normally do. You  should  not  replace\n"
+"              internally  set  headers  without  knowing  perfectly  well what\n"
+"              you're doing. Remove an internal header by giving a  replacement\n"
+"              without  content  on  the  right  side  of  the colon, as in: -H\n"
 "              \"Host:\".\n"
 "\n"
-"              curl  will  make  sure that each header you add/replace get sent\n"
+, stdout);
+ fputs(
+"              curl will make sure that each header you  add/replace  get  sent\n"
 "              with the proper end of line marker, you should thus not add that\n"
 "              as a part of the header content: do not add newlines or carriage\n"
 "              returns they will only mess things up for you.\n"
 "\n"
 "              See also the -A/--user-agent and -e/--referer options.\n"
 "\n"
-"              This option can be used  multiple  times  to  add/replace/remove\n"
-, stdout);
- fputs(
+"              This  option  can  be  used multiple times to add/replace/remove\n"
 "              multiple headers.\n"
 "\n"
+, stdout);
+ fputs(
 "       --hostpubmd5\n"
-"              Pass  a  string  containing  32  hexadecimal  digits. The string\n"
-"              should be the 128 bit MD5 cheksum of the  remote  hosts  public\n"
-"              key,  curl  will  refuse the connection with the host unless the\n"
-"              md5sums match. This option is only for SCP and  SFTP  transfers.\n"
+"              Pass a string  containing  32  hexadecimal  digits.  The  string\n"
+"              should  be  the 128 bit MD5 checksum of the remote host's public\n"
+"              key, curl will refuse the connection with the  host  unless  the\n"
+"              md5sums  match.  This option is only for SCP and SFTP transfers.\n"
 "              (Added in 7.17.1)\n"
 "\n"
 "       --ignore-content-length\n"
+"              (HTTP) Ignore the Content-Length header.  This  is  particularly\n"
 , stdout);
  fputs(
-"              (HTTP)  Ignore  the  Content-Length header. This is particularly\n"
-"              useful for servers running Apache 1.x, which will report  incor\n"
+"              useful  for servers running Apache 1.x, which will report incor-\n"
 "              rect Content-Length for files larger than 2 gigabytes.\n"
 "\n"
 "       -i/--include\n"
-"              (HTTP)  Include  the  HTTP-header in the output. The HTTP-header\n"
-"              includes things like server-name, date of  the  document,  HTTP-\n"
+"              (HTTP) Include the HTTP-header in the  output.  The  HTTP-header\n"
+"              includes  things  like  server-name, date of the document, HTTP-\n"
 "              version and more...\n"
 "\n"
-, stdout);
- fputs(
-"              If  this  option  is  used  twice, the second will again disable\n"
+"              If this option is used twice,  the  second  will  again  disable\n"
 "              header include.\n"
 "\n"
 "       --interface <name>\n"
-"              Perform an operation using a specified interface. You can  enter\n"
-"              interface  name,  IP address or host name. An example could look\n"
+, stdout);
+ fputs(
+"              Perform  an operation using a specified interface. You can enter\n"
+"              interface name, IP address or host name. An example  could  look\n"
 "              like:\n"
 "\n"
 "               curl --interface eth0:1 http://www.netscape.com/\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -I/--head\n"
+"              (HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature\n"
+"              the  command  HEAD which this uses to get nothing but the header\n"
 , stdout);
  fputs(
-"              (HTTP/FTP/FILE) Fetch the HTTP-header only! HTTP-servers feature\n"
-"              the command HEAD which this uses to get nothing but  the  header\n"
-"              of  a  document.  When used on a FTP or FILE file, curl displays\n"
+"              of a document. When used on a FTP or FILE  file,  curl  displays\n"
 "              the file size and last modification time only.\n"
 "\n"
-"              If this option is used twice,  the  second  will  again  disable\n"
+"              If  this  option  is  used  twice, the second will again disable\n"
 "              header only.\n"
 "\n"
 "       -j/--junk-session-cookies\n"
+"              (HTTP) When curl is told to read cookies from a given file, this\n"
+"              option  will  make  it  discard all \"session cookies\". This will\n"
 , stdout);
  fputs(
-"              (HTTP) When curl is told to read cookies from a given file, this\n"
-"              option will make it discard all  \"session  cookies\".  This  will\n"
-"              basically  have  the same effect as if a new session is started.\n"
-"              Typical browsers always discard  session  cookies  when  theyre\n"
+"              basically have the same effect as if a new session  is  started.\n"
+"              Typical  browsers  always  discard  session cookies when they're\n"
 "              closed down.\n"
 "\n"
-"              If  this option is used several times, each occurrence will tog\n"
+"              If this option is used several times, each occurrence will  tog-\n"
 "              gle this on/off.\n"
 "\n"
 "       -k/--insecure\n"
+"              (SSL)  This  option explicitly allows curl to perform \"insecure\"\n"
+"              SSL connections and transfers. All SSL connections are attempted\n"
 , stdout);
  fputs(
-"              (SSL) This option explicitly allows curl to  perform  \"insecure\"\n"
-"              SSL connections and transfers. All SSL connections are attempted\n"
-"              to be made secure by using the CA certificate  bundle  installed\n"
-"              by  default. This makes all connections considered \"insecure\" to\n"
+"              to  be  made secure by using the CA certificate bundle installed\n"
+"              by default. This makes all connections considered \"insecure\"  to\n"
 "              fail unless -k/--insecure is used.\n"
 "\n"
-"              See    this    online    resource    for    further     details:\n"
+"              See     this    online    resource    for    further    details:\n"
 "              http://curl.haxx.se/docs/sslcerts.html\n"
-, stdout);
- fputs(
 "\n"
 "              If this option is used twice, the second time will again disable\n"
 "              it.\n"
 "\n"
+"       --keepalive-time <seconds>\n"
+, stdout);
+ fputs(
+"              This  option  sets  the  time  a connection needs to remain idle\n"
+"              before sending keepalive probes and the time between  individual\n"
+"              keepalive probes. It is currently effective on operating systems\n"
+"              offering  the  TCP_KEEPIDLE  and  TCP_KEEPINTVL  socket  options\n"
+"              (meaning  Linux, recent AIX, HP-UX and more). This option has no\n"
+"              effect if --no-keepalive is used. (Added in 7.18.0)\n"
+"\n"
+, stdout);
+ fputs(
+"              If this option is used multiple times, the last occurrence  sets\n"
+"              the amount.\n"
 "       --key <key>\n"
-"              (SSL/SSH) Private key file name. Allows you to provide your pri\n"
+"              (SSL/SSH) Private key file name. Allows you to provide your pri-\n"
 "              vate key in this separate file.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --key-type <type>\n"
-"              (SSL) Private key file type. Specify which type your --key  pro\n"
+"              (SSL)  Private key file type. Specify which type your --key pro-\n"
 , stdout);
  fputs(
-"              vided  private  key  is.  DER, PEM and ENG are supported. If not\n"
+"              vided private key is. DER, PEM and ENG  are  supported.  If  not\n"
 "              specified, PEM is assumed.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --krb <level>\n"
-"              (FTP)  Enable Kerberos authentication and use. The level must be\n"
-"              entered and should be one of clear, safe, confidential  or\n"
-"              private.  Should  you  use  a  level that is not one of these,\n"
+"              (FTP) Enable Kerberos authentication and use. The level must  be\n"
+"              entered  and should be one of 'clear', 'safe', 'confidential' or\n"
+"              'private'. Should you use a level that  is  not  one  of  these,\n"
 , stdout);
  fputs(
-"              private will instead be used.\n"
+"              'private' will instead be used.\n"
 "\n"
-"              This option requires that the library was built  with  kerberos4\n"
-"              or  GSSAPI (GSS-Negotiate) support. This is not very common. Use\n"
+"              This  option  requires that the library was built with kerberos4\n"
+"              or GSSAPI (GSS-Negotiate) support. This is not very common.  Use\n"
 "              -V/--version to see if your curl supports it.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -K/--config <config file>\n"
-"              Specify  which config file to read curl arguments from. The con\n"
+"              Specify which config file to read curl arguments from. The  con-\n"
 , stdout);
  fputs(
-"              fig file is a text file in which command line arguments  can  be\n"
-"              written  which  then will be used as if they were written on the\n"
-"              actual command line. Options and their parameters must be speci\n"
-"              fied  on  the same config file line. If the parameter is to con\n"
-"              tain white spaces, the parameter must be enclosed within quotes.\n"
-"              If  the  first  column  of a config line is a # character, the\n"
+"              fig  file  is a text file in which command line arguments can be\n"
+"              written which then will be used as if they were written  on  the\n"
+"              actual command line. Options and their parameters must be speci-\n"
+"              fied on the same config file line,  separated  by  white  space,\n"
+"              colon,  the equals sign or any combination thereof (however, the\n"
+"              preferred separator is the equals sign). If the parameter is  to\n"
 , stdout);
  fputs(
-"              rest of the line will be treated as a comment.  Only  write  one\n"
-"              option per physical line in the config file.\n"
+"              contain  white  spaces,  the  parameter  must be enclosed within\n"
+"              quotes. Within double quotes, the following escape sequences are\n"
+"              available:  \\\\,  \\\", \\t, \\n, \\r and \\v. A backlash preceding any\n"
+"              other letter is  ignored. If the first column of a  config  line\n"
+"              is  a  '#'  character, the rest of the line will be treated as a\n"
+"              comment. Only write one option per physical line in  the  config\n"
+"              file.\n"
 "\n"
-"              Specify the filename to -K/--config as - to make curl read the\n"
+, stdout);
+ fputs(
+"              Specify the filename to -K/--config as '-' to make curl read the\n"
 "              file from stdin.\n"
 "\n"
 "              Note that to be able to specify a URL in the  config  file,  you\n"
 "              need  to  specify  it  using the --url option, and not by simply\n"
 "              writing the URL on its own line. So, it could  look  similar  to\n"
-, stdout);
- fputs(
 "              this:\n"
 "\n"
 "              url = \"http://curl.haxx.se/docs/\"\n"
 "\n"
 "              Long  option  names  can  optionally be given in the config file\n"
+, stdout);
+ fputs(
 "              without the initial double dashes.\n"
 "\n"
 "              When curl is invoked, it always (unless -q is used) checks for a\n"
 "              default  config  file  and  uses it if found. The default config\n"
 "              file is checked for in the following places in this order:\n"
 "\n"
-, stdout);
- fputs(
 "              1) curl tries to find the \"home dir\": It first  checks  for  the\n"
 "              CURL_HOME and then the HOME environment variables. Failing that,\n"
+, stdout);
+ fputs(
 "              it uses getpwuid() on unix-like systems (which returns the  home\n"
 "              dir  given the current user in your system). On Windows, it then\n"
-"              checks for the APPDATA variable, or as a last resort the %USER\n"
-"              PROFILE%0lication Data.\n"
+"              checks for the APPDATA variable, or as a last resort the '%USER-\n"
+"              PROFILE%0lication Data'.\n"
 "\n"
-, stdout);
- fputs(
 "              2)  On  windows, if there is no _curlrc file in the home dir, it\n"
 "              checks for one in the same dir the executable curl is placed. On\n"
+, stdout);
+ fputs(
 "              unix-like  systems,  it will simply try to load .curlrc from the\n"
 "              determined home dir.\n"
 "\n"
 "              # --- Example file ---\n"
 "              # this is a comment\n"
 "              url = \"curl.haxx.se\"\n"
 "              output = \"curlhere.html\"\n"
 "              user-agent = \"superagent/1.0\"\n"
 "\n"
-, stdout);
- fputs(
 "              # and fetch another URL too\n"
 "              url = \"curl.haxx.se/docs/manpage.html\"\n"
 "              -O\n"
 "              referer = \"http://nowhereatall.com/\"\n"
+, stdout);
+ fputs(
 "              # --- End of example file ---\n"
 "\n"
 "              This option can be used multiple times to load  multiple  config\n"
 "              files.\n"
 "\n"
 "       --libcurl <file>\n"
 "              Append  this  option  to any ordinary curl command line, and you\n"
 "              will get a libcurl-using source code written to  the  file  that\n"
-, stdout);
- fputs(
-"              does  the  equivalent operation of what your command line opera\n"
+"              does  the  equivalent operation of what your command line opera-\n"
 "              tion does!\n"
 "\n"
-"              NOTE: this does not properly support -F and the sending of  mul\n"
+, stdout);
+ fputs(
+"              NOTE: this does not properly support -F and the sending of  mul-\n"
 "              tipart  formposts,  so in those cases the output program will be\n"
 "              missing necessary calls to curl_formadd(3), and possibly more.\n"
 "\n"
 "              If this option is used several times, the last given  file  name\n"
-"              will be used.\n"
+"              will be used. (Added in 7.16.1)\n"
 "\n"
 "       --limit-rate <speed>\n"
+"              Specify  the  maximum  transfer  rate you want curl to use. This\n"
 , stdout);
  fputs(
-"              Specify  the  maximum  transfer  rate you want curl to use. This\n"
-"              feature is useful if you have a limited pipe and youd like your\n"
+"              feature is useful if you have a limited pipe and you'd like your\n"
 "              transfer not use your entire bandwidth.\n"
 "\n"
 "              The  given speed is measured in bytes/second, unless a suffix is\n"
-"              appended.  Appending k or K will count the number  as  kilo\n"
-"              bytes,  m  or  M makes it megabytes while g or G makes it\n"
-, stdout);
- fputs(
+"              appended.  Appending 'k' or 'K' will count the number  as  kilo-\n"
+"              bytes,  'm'  or  M' makes it megabytes while 'g' or 'G' makes it\n"
 "              gigabytes. Examples: 200K, 3m and 1G.\n"
 "\n"
+, stdout);
+ fputs(
 "              The given rate is the average speed, counted during  the  entire\n"
 "              transfer. It means that curl might use higher transfer speeds in\n"
 "              short bursts, but over time it uses no more than the given rate.\n"
 "              If  you  are also using the -Y/--speed-limit option, that option\n"
 "              will  take  precedence  and  might  cripple  the   rate-limiting\n"
-, stdout);
- fputs(
 "              slightly, to help keeping the speed-limit logic working.\n"
 "\n"
+, stdout);
+ fputs(
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -l/--list-only\n"
 "              (FTP) When listing an FTP directory, this switch forces a  name-\n"
 "              only  view.   Especially useful if you want to machine-parse the\n"
 "              contents of an FTP directory since  the  normal  directory  view\n"
-"              doesnt use a standard look or format.\n"
+"              doesn't use a standard look or format.\n"
 "\n"
+"              This  option  causes  an  FTP NLST command to be sent.  Some FTP\n"
 , stdout);
  fputs(
-"              This  option  causes  an  FTP NLST command to be sent.  Some FTP\n"
 "              servers list only files in their response to NLST; they  do  not\n"
 "              include subdirectories and symbolic links.\n"
 "\n"
 "              If this option is used twice, the second will again disable list\n"
 "              only.\n"
 "\n"
 "       --local-port <num>[-num]\n"
 "              Set a preferred number or range of local port numbers to use for\n"
+"              the connection(s).  Note that port numbers by nature is a scarce\n"
 , stdout);
  fputs(
-"              the connection(s).  Note that port numbers by nature is a scarce\n"
 "              resource that will be busy at times so  setting  this  range  to\n"
 "              something  too  narrow  might cause unnecessary connection setup\n"
 "              failures. (Added in 7.15.2)\n"
 "\n"
 "       -L/--location\n"
 "              (HTTP/HTTPS) If the server reports that the requested  page  has\n"
 "              moved to a different location (indicated with a Location: header\n"
+"              and a 3XX response code) this option will  make  curl  redo  the\n"
 , stdout);
  fputs(
-"              and a 3XX response code) this option will  make  curl  redo  the\n"
 "              request  on the new place. If used together with -i/--include or\n"
 "              -I/--head, headers from all requested pages will be shown.  When\n"
 "              authentication  is  used, curl only sends its credentials to the\n"
 "              initial host. If a redirect takes curl to a different  host,  it\n"
-"              wont  be  able to intercept the user+password. See also --loca\n"
+"              won't  be  able to intercept the user+password. See also --loca-\n"
+"              tion-trusted on how to change this. You can limit the amount  of\n"
 , stdout);
  fputs(
-"              tion-trusted on how to change this. You can limit the amount  of\n"
 "              redirects to follow by using the --max-redirs option.\n"
 "\n"
 "              When  curl follows a redirect and the request is not a plain GET\n"
 "              (for example POST or PUT), it will do the following request with\n"
 "              a GET if the HTTP response was 301, 302, or 303. If the response\n"
 "              code was any other 3xx code, curl  will  re-send  the  following\n"
-, stdout);
- fputs(
 "              request using the same unmodified method.\n"
 "\n"
+, stdout);
+ fputs(
 "              If  this  option  is  used  twice, the second will again disable\n"
 "              location following.\n"
 "\n"
 "       --location-trusted\n"
 "              (HTTP/HTTPS) Like -L/--location, but will allow sending the name\n"
 "              +  password to all hosts that the site may redirect to. This may\n"
 "              or may not introduce a security breach if the site redirects you\n"
+"              do  a  site to which you'll send your authentication info (which\n"
 , stdout);
  fputs(
-"              do  a  site to which youll send your authentication info (which\n"
 "              is plaintext in the case of HTTP Basic authentication).\n"
 "\n"
 "              If this option is used twice,  the  second  will  again  disable\n"
 "              location following.\n"
 "\n"
 "       --max-filesize <bytes>\n"
 "              Specify  the  maximum  size (in bytes) of a file to download. If\n"
 "              the file requested is larger than this value, the transfer  will\n"
-, stdout);
- fputs(
 "              not start and curl will return with exit code 63.\n"
 "\n"
+, stdout);
+ fputs(
 "              NOTE:  The  file size is not always known prior to download, and\n"
-"              for such files this option has no effect even if the file trans\n"
+"              for such files this option has no effect even if the file trans-\n"
 "              fer  ends  up  being larger than this given limit. This concerns\n"
 "              both FTP and HTTP transfers.\n"
 "\n"
 "       -m/--max-time <seconds>\n"
 "              Maximum time in seconds that you allow the  whole  operation  to\n"
+"              take.   This is useful for preventing your batch jobs from hang-\n"
 , stdout);
  fputs(
-"              take.   This is useful for preventing your batch jobs from hang\n"
 "              ing for hours due to slow networks or  links  going  down.   See\n"
 "              also the --connect-timeout option.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -M/--manual\n"
 "              Manual. Display the huge help text.\n"
 "\n"
 "       -n/--netrc\n"
-"              Makes curl scan the .netrc file in the users home directory for\n"
+"              Makes curl scan the .netrc file in the user's home directory for\n"
+"              login name and password. This is typically used for ftp on unix.\n"
 , stdout);
  fputs(
-"              login name and password. This is typically used for ftp on unix.\n"
 "              If used with http, curl will  enable  user  authentication.  See\n"
 "              netrc(4) or ftp(1) for details on the file format. Curl will not\n"
-"              complain if that file hasnt the right  permissions  (it  should\n"
+"              complain if that file hasn't the right  permissions  (it  should\n"
 "              not  be  world  nor  group  readable).  The environment variable\n"
 "              \"HOME\" is used to find the home directory.\n"
 "\n"
+"              A quick and very simple example of how  to  setup  a  .netrc  to\n"
 , stdout);
  fputs(
-"              A quick and very simple example of how  to  setup  a  .netrc  to\n"
 "              allow  curl to ftp to the machine host.domain.com with user name\n"
-"              myself and password secret should look similar to:\n"
+"              'myself' and password 'secret' should look similar to:\n"
 "\n"
 "              machine host.domain.com login myself password secret\n"
 "\n"
 "              If this option is used twice,  the  second  will  again  disable\n"
 "              netrc usage.\n"
 "\n"
 "       --netrc-optional\n"
-, stdout);
- fputs(
 "              Very  similar to --netrc, but this option makes the .netrc usage\n"
 "              optional and not mandatory as the --netrc does.\n"
 "\n"
+, stdout);
+ fputs(
 "       --negotiate\n"
 "              (HTTP) Enables GSS-Negotiate authentication.  The  GSS-Negotiate\n"
-"              method was designed by Microsoft and is used in their web appli\n"
+"              method was designed by Microsoft and is used in their web appli-\n"
 "              cations. It is  primarily  meant  as  a  support  for  Kerberos5\n"
-"              authentication but may be also used along with another authenti\n"
-, stdout);
- fputs(
+"              authentication but may be also used along with another authenti-\n"
 "              cation methods. For  more  information  see  IETF  draft  draft-\n"
 "              brezak-spnego-http-04.txt.\n"
 "\n"
+, stdout);
+ fputs(
 "              If  you  want to enable Negotiate for your proxy authentication,\n"
 "              then use --proxy-negotiate.\n"
 "\n"
-"              This option requires that the library was built with GSSAPI sup\n"
+"              This option requires that the library was built with GSSAPI sup-\n"
 "              port.  This  is not very common. Use -V/--version to see if your\n"
 "              version supports GSS-Negotiate.\n"
 "\n"
-, stdout);
- fputs(
 "              When using this option, you must also provide a  fake  -u/--user\n"
 "              option  to  activate the authentication code properly. Sending a\n"
-"              -u : is enough as the user  name  and  password  from  the  -u\n"
-"              option arent actually used.\n"
+, stdout);
+ fputs(
+"              '-u :' is enough as the user  name  and  password  from  the  -u\n"
+"              option aren't actually used.\n"
 "\n"
 "              If  this option is used several times, the following occurrences\n"
 "              make no difference.\n"
 "\n"
 "       -N/--no-buffer\n"
-, stdout);
- fputs(
-"              Disables the buffering of the output stream. In normal work sit\n"
+"              Disables the buffering of the output stream. In normal work sit-\n"
 "              uations,  curl  will  use a standard buffered output stream that\n"
 "              will have the effect that it will output the data in chunks, not\n"
+, stdout);
+ fputs(
 "              necessarily  exactly  when  the data arrives.  Using this option\n"
 "              will disable that buffering.\n"
 "\n"
 "              If this option is used twice, the second will  again  switch  on\n"
 "              buffering.\n"
 "\n"
-"       --no-sessionid\n"
+"       --no-keepalive\n"
+"              Disables the use of keepalive messages on the TCP connection, as\n"
+"              by default curl enables them.\n"
+"\n"
+"              If this option is used  twice,  the  second  will  again  enable\n"
+"              keepalive.\n"
+"\n"
 , stdout);
  fputs(
-"              (SSL)  Disable curls use of SSL session-ID caching.  By default\n"
+"       --no-sessionid\n"
+"              (SSL)  Disable curl's use of SSL session-ID caching.  By default\n"
 "              all transfers are done using the cache. Note that while  nothing\n"
 "              ever  should  get  hurt  by attempting to reuse SSL session-IDs,\n"
 "              there seem to be broken SSL implementations in the wild that may\n"
 "              require  you to disable this in order for you to succeed. (Added\n"
 "              in 7.16.0)\n"
 "\n"
@@ -1149,34 +1209,34 @@
  fputs(
 "              If this option is used twice, the second will  again  switch  on\n"
 "              use of the session cache.\n"
 "\n"
 "       --ntlm (HTTP)  Enables  NTLM  authentication.  The  NTLM authentication\n"
 "              method was designed by Microsoft and is used by IIS web servers.\n"
-"              It is a proprietary protocol, reversed engineered by clever peo\n"
+"              It is a proprietary protocol, reversed engineered by clever peo-\n"
 "              ple and implemented in curl based on their efforts. This kind of\n"
 , stdout);
  fputs(
 "              behavior  should  not be endorsed, you should encourage everyone\n"
-"              who uses NTLM to switch to a public and  documented  authentica\n"
+"              who uses NTLM to switch to a public and  documented  authentica-\n"
 "              tion method instead. Such as Digest.\n"
 "\n"
 "              If  you  want to enable NTLM for your proxy authentication, then\n"
 "              use --proxy-ntlm.\n"
 "\n"
-"              This option requires that the library was built  with  SSL  sup\n"
+"              This option requires that the library was built  with  SSL  sup-\n"
 "              port. Use -V/--version to see if your curl supports NTLM.\n"
 "\n"
 , stdout);
  fputs(
 "              If  this option is used several times, the following occurrences\n"
 "              make no difference.\n"
 "\n"
 "       -o/--output <file>\n"
 "              Write output to <file> instead of stdout. If you are using {} or\n"
-"              []  to  fetch  multiple documents, you can use # followed by a\n"
+"              []  to  fetch  multiple documents, you can use '#' followed by a\n"
 "              number in the <file> specifier. That variable will  be  replaced\n"
 "              with the current string for the URL being fetched. Like in:\n"
 "\n"
 , stdout);
  fputs(
 "                curl http://{one,two}.site.com -o \"file_#1.txt\"\n"
@@ -1185,13 +1245,13 @@
 "\n"
 "                curl http://{site,host}.host[1-5].com -o \"#1_#2\"\n"
 "\n"
 "              You  may  use  this  option  as many times as you have number of\n"
 "              URLs.\n"
 "\n"
-"              See also the --create-dirs option to create the  local  directo\n"
+"              See also the --create-dirs option to create the  local  directo-\n"
 "              ries dynamically.\n"
 "\n"
 "       -O/--remote-name\n"
 "              Write  output to a local file named like the remote file we get.\n"
 , stdout);
  fputs(
@@ -1213,730 +1273,759 @@
 , stdout);
  fputs(
 "              Tells curl to respect  RFC  2616/10.3.2  and  not  convert  POST\n"
 "              requests into GET requests when following a 301 redirection. The\n"
 "              non-RFC behaviour is ubiquitous in web browsers,  so  curl  does\n"
 "              the  conversion  by  default to maintain consistency. However, a\n"
-"              server may requires a POST to remain a POST after such  a  redi\n"
+"              server may requires a POST to remain a POST after such  a  redi-\n"
 "              rection. This option is meaningful only when using -L/--location\n"
 , stdout);
  fputs(
 "              (Added in 7.17.1)\n"
 "\n"
 "       --proxy-anyauth\n"
-"              Tells curl to pick a suitable authentication method when  commu\n"
-"              nicating  with  the  given  proxy.  This  will  cause  an  extra\n"
+"              Tells curl to pick a suitable authentication method when  commu-\n"
+"              nicating  with  the  given  proxy.  This  might  cause  an extra\n"
 "              request/response round-trip. (Added in 7.13.2)\n"
 "\n"
 "              If this option is used twice, the second will again disable  the\n"
 "              proxy use-any authentication.\n"
 "\n"
 "       --proxy-basic\n"
+"              Tells  curl  to use HTTP Basic authentication when communicating\n"
 , stdout);
  fputs(
-"              Tells  curl  to use HTTP Basic authentication when communicating\n"
 "              with the given proxy. Use --basic for enabling HTTP Basic with a\n"
 "              remote  host.  Basic  is  the default authentication method curl\n"
 "              uses with proxies.\n"
 "\n"
 "              If this option is used twice,  the  second  will  again  disable\n"
 "              proxy HTTP Basic authentication.\n"
 "\n"
 "       --proxy-digest\n"
 "              Tells  curl to use HTTP Digest authentication when communicating\n"
+"              with the given proxy. Use --digest for enabling HTTP Digest with\n"
 , stdout);
  fputs(
-"              with the given proxy. Use --digest for enabling HTTP Digest with\n"
 "              a remote host.\n"
 "\n"
 "              If  this  option  is  used  twice, the second will again disable\n"
 "              proxy HTTP Digest.\n"
 "\n"
 "       --proxy-negotiate\n"
-"              Tells curl to use HTTP Negotiate authentication when communicat\n"
+"              Tells curl to use HTTP Negotiate authentication when communicat-\n"
 "              ing  with  the  given  proxy.  Use --negotiate for enabling HTTP\n"
 "              Negotiate with a remote host.\n"
 "\n"
+"              If this option is used twice,  the  second  will  again  disable\n"
 , stdout);
  fputs(
-"              If this option is used twice,  the  second  will  again  disable\n"
 "              proxy HTTP Negotiate. (Added in 7.17.1)\n"
 "\n"
 "       --proxy-ntlm\n"
 "              Tells  curl  to  use HTTP NTLM authentication when communicating\n"
 "              with the given proxy. Use --ntlm for enabling NTLM with a remote\n"
 "              host.\n"
 "\n"
 "              If  this  option  is  used  twice, the second will again disable\n"
 "              proxy HTTP NTLM.\n"
 "       -p/--proxytunnel\n"
+"              When an HTTP proxy is used (-x/--proxy), this option will  cause\n"
 , stdout);
  fputs(
-"              When an HTTP proxy is used (-x/--proxy), this option will  cause\n"
 "              non-HTTP  protocols  to  attempt  to  tunnel  through  the proxy\n"
-"              instead of merely using it to do HTTP-like operations. The  tun\n"
+"              instead of merely using it to do HTTP-like operations. The  tun-\n"
 "              nel  approach  is  made  with the HTTP proxy CONNECT request and\n"
 "              requires that the proxy allows direct connect to the remote port\n"
 "              number curl wants to tunnel through to.\n"
 "\n"
-, stdout);
- fputs(
 "              If  this  option  is  used  twice, the second will again disable\n"
 "              proxy tunnel.\n"
 "\n"
+, stdout);
+ fputs(
 "       --pubkey <key>\n"
 "              (SSH) Public key file name. Allows you to  provide  your  public\n"
 "              key in this separate file.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -P/--ftp-port <address>\n"
 "              (FTP) Reverses the initiator/listener roles when connecting with\n"
-, stdout);
- fputs(
 "              ftp.  This  switch  makes  Curl  use the PORT command instead of\n"
 "              PASV. In practise, PORT tells  the  server  to  connect  to  the\n"
-"              clients  specified address and port, while PASV asks the server\n"
+, stdout);
+ fputs(
+"              client's  specified address and port, while PASV asks the server\n"
 "              for an ip address and port to connect to.  <address>  should  be\n"
 "              one of:\n"
 "\n"
 "              interface\n"
-"                     i.e  \"eth0\"  to  specify which interfaces IP address you\n"
+"                     i.e  \"eth0\"  to  specify which interface's IP address you\n"
 "                     want to use  (Unix only)\n"
 "\n"
-, stdout);
- fputs(
 "              IP address\n"
 "                     i.e \"192.168.10.1\" to specify exact IP number\n"
 "\n"
 "              host name\n"
+, stdout);
+ fputs(
 "                     i.e \"my.host.domain\" to specify machine\n"
 "\n"
 "              -      make curl pick the same IP address that is  already  used\n"
 "                     for the control connection\n"
 "\n"
-"       If  this  option is used several times, the last one will be used. Dis\n"
+"       If  this  option is used several times, the last one will be used. Dis-\n"
 "       able the use of PORT with --ftp-pasv. Disable the attempt  to  use  the\n"
-, stdout);
- fputs(
 "       EPRT  command  instead  of PORT by using --disable-eprt. EPRT is really\n"
 "       PORT++.\n"
 "\n"
+, stdout);
+ fputs(
 "       -q     If used as the first parameter on the command line,  the  curlrc\n"
 "              config  file  will not be read and used. See the -K/--config for\n"
 "              details on the default config file search path.\n"
 "\n"
 "       -Q/--quote <command>\n"
 "              (FTP/SFTP) Send an arbitrary command to the remote FTP  or  SFTP\n"
-, stdout);
- fputs(
 "              server.  Quote  commands  are sent BEFORE the transfer is taking\n"
 "              place (just after the initial PWD command in an FTP transfer, to\n"
-"              be exact). To make commands take place after a successful trans\n"
-"              fer, prefix them with a dash -.  To  make  commands  get  sent\n"
-"              after  libcurl  has  changed  working directory, just before the\n"
-"              transfer command(s), prefix the command with + (this  is  only\n"
 , stdout);
  fputs(
+"              be exact). To make commands take place after a successful trans-\n"
+"              fer, prefix them with a dash '-'.  To  make  commands  get  sent\n"
+"              after  libcurl  has  changed  working directory, just before the\n"
+"              transfer command(s), prefix the command with '+' (this  is  only\n"
 "              supported  for  FTP). You may specify any number of commands. If\n"
 "              the server returns failure for one of the commands,  the  entire\n"
+, stdout);
+ fputs(
 "              operation  will  be aborted. You must send syntactically correct\n"
 "              FTP commands as RFC959 defines to FTP servers,  or  one  of  the\n"
 "              following commands (with appropriate arguments) to SFTP servers:\n"
 "              chgrp, chmod, chown, ln, mkdir, pwd, rename, rm, rmdir, symlink.\n"
 "\n"
-, stdout);
- fputs(
 "              This option can be used multiple times.\n"
 "\n"
 "       --random-file <file>\n"
-"              (SSL) Specify the path name to file containing what will be con\n"
+"              (SSL) Specify the path name to file containing what will be con-\n"
+, stdout);
+ fputs(
 "              sidered as random data. The data is  used  to  seed  the  random\n"
 "              engine for SSL connections.  See also the --egd-file option.\n"
 "\n"
 "       -r/--range <range>\n"
-"              (HTTP/FTP) Retrieve a byte range (i.e a partial document) from a\n"
-, stdout);
- fputs(
-"              HTTP/1.1 or FTP server. Ranges can be specified in a  number  of\n"
-"              ways.\n"
+"              (HTTP/FTP/FILE)  Retrieve  a byte range (i.e a partial document)\n"
+"              from a HTTP/1.1, FTP server or a local FILE. Ranges can be spec-\n"
+"              ified in a number of ways.\n"
 "\n"
 "              0-499     specifies the first 500 bytes\n"
 "\n"
 "              500-999   specifies the second 500 bytes\n"
 "\n"
+, stdout);
+ fputs(
 "              -500      specifies the last 500 bytes\n"
 "\n"
 "              9500-     specifies the bytes from offset 9500 and forward\n"
 "\n"
 "              0-0,-1    specifies the first and last byte only(*)(H)\n"
 "\n"
 "              500-700,600-799\n"
-, stdout);
- fputs(
 "                        specifies 300 bytes from offset 500(H)\n"
 "\n"
 "              100-199,500-599\n"
 "                        specifies two separate 100 bytes ranges(*)(H)\n"
 "\n"
 "       (*)  =  NOTE  that this will cause the server to reply with a multipart\n"
 "       response!\n"
 "\n"
-"       Only digit characters (0-9) are valid in start and  stop  of  range\n"
-"       syntax  start-stop.  If  a non-digit character is given in the range,\n"
 , stdout);
  fputs(
-"       the servers response will be indeterminable,  depending  on  different\n"
-"       servers configuration.\n"
+"       Only digit characters (0-9) are valid in 'start' and  'stop'  of  range\n"
+"       syntax  'start-stop'.  If  a non-digit character is given in the range,\n"
+"       the server's response will be indeterminable,  depending  on  different\n"
+"       server's configuration.\n"
 "\n"
 "       You  should  also  be aware that many HTTP/1.1 servers do not have this\n"
-"       feature enabled, so that when  you  attempt  to  get  a  range,  youll\n"
+"       feature enabled, so that when  you  attempt  to  get  a  range,  you'll\n"
 "       instead get the whole document.\n"
 "\n"
-"       FTP  range  downloads  only  support  the  simple  syntax  start-stop\n"
+, stdout);
+ fputs(
+"       FTP  range  downloads  only  support  the  simple  syntax  'start-stop'\n"
 "       (optionally with one of the numbers omitted). It depends on the non-RFC\n"
 "       command SIZE.\n"
 "\n"
-, stdout);
- fputs(
 "       If this option is used several times, the last one will be used.\n"
 "\n"
 "       --raw  When  used, it disables all internal HTTP decoding of content or\n"
 "              transfer encodings and instead makes them passed  on  unaltered,\n"
 "              raw. (Added in 7.16.2)\n"
 "\n"
+, stdout);
+ fputs(
 "              If  this  option  is used several times, each occurrence toggles\n"
 "              this on/off.\n"
 "\n"
 "       -R/--remote-time\n"
 "              When used, this will make libcurl  attempt  to  figure  out  the\n"
-, stdout);
- fputs(
 "              timestamp  of the remote file, and if that is available make the\n"
 "              local file get that same timestamp.\n"
 "\n"
 "              If this option is used twice,  the  second  time  disables  this\n"
 "              again.\n"
 "\n"
 "       --retry <num>\n"
+, stdout);
+ fputs(
 "              If  a  transient  error is returned when curl tries to perform a\n"
 "              transfer, it will retry this number of times before  giving  up.\n"
 "              Setting  the  number to 0 makes curl do no retries (which is the\n"
-, stdout);
- fputs(
 "              default). Transient error means either: a timeout,  an  FTP  5xx\n"
 "              response code or an HTTP 5xx response code.\n"
 "\n"
 "              When  curl  is about to retry a transfer, it will first wait one\n"
+, stdout);
+ fputs(
 "              second and then for all forthcoming retries it will  double  the\n"
 "              waiting  time until it reaches 10 minutes which then will be the\n"
 "              delay between the rest of the retries.  By  using  --retry-delay\n"
-, stdout);
- fputs(
 "              you   disable  this  exponential  backoff  algorithm.  See  also\n"
 "              --retry-max-time to limit the total time  allowed  for  retries.\n"
 "              (Added in 7.12.3)\n"
 "\n"
+, stdout);
+ fputs(
 "              If  this  option  is  used  multiple  times, the last occurrence\n"
 "              decide the amount.\n"
 "\n"
 "       --retry-delay <seconds>\n"
 "              Make curl sleep this amount of time between each  retry  when  a\n"
 "              transfer  has  failed  with  a  transient  error (it changes the\n"
-, stdout);
- fputs(
 "              default backoff time algorithm between retries). This option  is\n"
 "              only  interesting if --retry is also used. Setting this delay to\n"
+, stdout);
+ fputs(
 "              zero will make curl use the default  backoff  time.   (Added  in\n"
 "              7.12.3)\n"
 "\n"
 "              If  this  option  is  used  multiple  times, the last occurrence\n"
 "              decide the amount.\n"
 "\n"
 "       --retry-max-time <seconds>\n"
 "              The retry timer is reset  before  the  first  transfer  attempt.\n"
+"              Retries will be done as usual (see --retry) as long as the timer\n"
+"              hasn't reached this given limit. Notice that if the timer hasn't\n"
 , stdout);
  fputs(
-"              Retries will be done as usual (see --retry) as long as the timer\n"
-"              hasnt reached this given limit. Notice that if the timer hasnt\n"
-"              reached  the  limit, the request will be made and while perform\n"
+"              reached  the  limit, the request will be made and while perform-\n"
 "              ing, it may take longer than this given time period. To limit  a\n"
-"              single  requests  maximum  time,  use  -m/--max-time.  Set this\n"
+"              single  request's  maximum  time,  use  -m/--max-time.  Set this\n"
 "              option to zero to not timeout retries. (Added in 7.12.3)\n"
 "\n"
-, stdout);
- fputs(
 "              If this option is  used  multiple  times,  the  last  occurrence\n"
 "              decide the amount.\n"
 "\n"
 "       -s/--silent\n"
-"              Silent mode. Dont show progress meter or error messages.  Makes\n"
+, stdout);
+ fputs(
+"              Silent mode. Don't show progress meter or error messages.  Makes\n"
 "              Curl mute.\n"
 "\n"
 "              If this option is used twice,  the  second  will  again  disable\n"
 "              silent mode.\n"
 "\n"
 "       -S/--show-error\n"
 "              When  used with -s it makes curl show error message if it fails.\n"
-, stdout);
- fputs(
 "              If this option is used twice, the second will again disable show\n"
 "              error.\n"
 "\n"
 "       --socks4 <host[:port]>\n"
-"              Use the specified SOCKS4 proxy. If the port number is not speci\n"
+, stdout);
+ fputs(
+"              Use the specified SOCKS4 proxy. If the port number is not speci-\n"
 "              fied, it is assumed at port 1080. (Added in 7.15.2)\n"
 "\n"
 "              This option overrides any previous use of  -x/--proxy,  as  they\n"
 "              are mutually exclusive.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
+"       --socks4a <host[:port]>\n"
+"              Use the specified SOCKS4a proxy. If the port number is not spec-\n"
 , stdout);
  fputs(
-"       --socks5 <host[:port]>\n"
-"              Use the specified SOCKS5 proxy. If the port number is not speci\n"
-"              fied, it is assumed at port 1080. (Added in 7.11.1)\n"
+"              ified, it is assumed at port 1080. (Added in 7.18.0)\n"
+"\n"
+"              This  option  overrides  any previous use of -x/--proxy, as they\n"
+"              are mutually exclusive.\n"
+"\n"
+"              If this option is used several times, the last one will be used.\n"
+"\n"
+"       --socks5-hostname <host[:port]>\n"
+"              Use  the  specified  SOCKS5 proxy (and let the proxy resolve the\n"
+"              host name). If the port number is not specified, it  is  assumed\n"
+, stdout);
+ fputs(
+"              at port 1080. (Added in 7.18.0)\n"
 "\n"
 "              This  option  overrides  any previous use of -x/--proxy, as they\n"
 "              are mutually exclusive.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "              (This  option  was  previously  wrongly  documented  and used as\n"
+"              --socks without the number appended.)\n"
+"\n"
+"       --socks5 <host[:port]>\n"
+"              Use the specified SOCKS5 proxy  -  but  resolve  the  host  name\n"
 , stdout);
  fputs(
+"              locally.  If  the port number is not specified, it is assumed at\n"
+"              port 1080.\n"
+"\n"
+"              This option overrides any previous use of  -x/--proxy,  as  they\n"
+"              are mutually exclusive.\n"
+"\n"
+"              If this option is used several times, the last one will be used.\n"
+"              (This option was  previously  wrongly  documented  and  used  as\n"
 "              --socks without the number appended.)\n"
 "\n"
 "       --stderr <file>\n"
-"              Redirect all writes to stderr to the specified file instead.  If\n"
-"              the  file  name is a plain -, it is instead written to stdout.\n"
-"              This option has no point when youre using a shell  with  decent\n"
+, stdout);
+ fputs(
+"              Redirect  all writes to stderr to the specified file instead. If\n"
+"              the file name is a plain '-', it is instead written  to  stdout.\n"
+"              This  option  has no point when you're using a shell with decent\n"
 "              redirecting capabilities.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --tcp-nodelay\n"
+"              Turn  on the TCP_NODELAY option. See the curl_easy_setopt(3) man\n"
 , stdout);
  fputs(
-"              Turn on the TCP_NODELAY option. See the curl_easy_setopt(3)  man\n"
 "              page for details about this option. (Added in 7.11.2)\n"
 "\n"
-"              If  this  option  is used several times, each occurrence toggles\n"
+"              If this option is used several times,  each  occurrence  toggles\n"
 "              this on/off.\n"
 "\n"
 "       -t/--telnet-option <OPT=val>\n"
 "              Pass options to the telnet protocol. Supported options are:\n"
 "\n"
 "              TTYPE=<term> Sets the terminal type.\n"
 "\n"
 "              XDISPLOC=<X display> Sets the X display location.\n"
 "\n"
-, stdout);
- fputs(
 "              NEW_ENV=<var,val> Sets an environment variable.\n"
 "\n"
 "       -T/--upload-file <file>\n"
-"              This transfers the specified local file to the  remote  URL.  If\n"
+, stdout);
+ fputs(
+"              This  transfers  the  specified local file to the remote URL. If\n"
 "              there is no file part in the specified URL, Curl will append the\n"
 "              local file name. NOTE that you must use a trailing / on the last\n"
-"              directory  to really prove to Curl that there is no file name or\n"
+"              directory to really prove to Curl that there is no file name  or\n"
 "              curl will think that your last directory name is the remote file\n"
+"              name to use. That will most likely cause the upload operation to\n"
 , stdout);
  fputs(
-"              name to use. That will most likely cause the upload operation to\n"
-"              fail. If this is used on a http(s) server, the PUT command  will\n"
+"              fail.  If this is used on a http(s) server, the PUT command will\n"
 "              be used.\n"
 "\n"
-"              Use  the file name \"-\" (a single dash) to use stdin instead of a\n"
+"              Use the file name \"-\" (a single dash) to use stdin instead of  a\n"
 "              given file.\n"
 "\n"
 "              You can specify one -T for each URL on the command line. Each -T\n"
-"              + URL pair specifies what to upload and to where. curl also sup\n"
+"              + URL pair specifies what to upload and to where. curl also sup-\n"
+"              ports \"globbing\" of the -T argument, meaning that you can upload\n"
 , stdout);
  fputs(
-"              ports \"globbing\" of the -T argument, meaning that you can upload\n"
-"              multiple  files  to  a single URL by using the same URL globbing\n"
+"              multiple files to a single URL by using the  same  URL  globbing\n"
 "              style supported in the URL, like this:\n"
 "\n"
 "              curl -T \"{file1,file2}\" http://www.uploadtothissite.com\n"
 "\n"
 "              or even\n"
 "\n"
 "              curl -T \"img[1-1000].png\" ftp://ftp.picturemania.com/upload/\n"
 "\n"
 "       --trace <file>\n"
-"              Enables a full trace dump of all  incoming  and  outgoing  data,\n"
+"              Enables  a  full  trace  dump of all incoming and outgoing data,\n"
+"              including descriptive information, to the given output file. Use\n"
 , stdout);
  fputs(
-"              including descriptive information, to the given output file. Use\n"
 "              \"-\" as filename to have the output sent to stdout.\n"
 "\n"
-"              This option overrides previous uses of -v/--verbose or  --trace-\n"
+"              This  option overrides previous uses of -v/--verbose or --trace-\n"
 "              ascii.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --trace-ascii <file>\n"
-"              Enables a full trace dump of all  incoming  and  outgoing  data,\n"
-, stdout);
- fputs(
+"              Enables  a  full  trace  dump of all incoming and outgoing data,\n"
 "              including descriptive information, to the given output file. Use\n"
 "              \"-\" as filename to have the output sent to stdout.\n"
+, stdout);
+ fputs(
 "\n"
 "              This is very similar to --trace, but leaves out the hex part and\n"
-"              only  shows  the ASCII part of the dump. It makes smaller output\n"
+"              only shows the ASCII part of the dump. It makes  smaller  output\n"
 "              that might be easier to read for untrained humans.\n"
 "\n"
-"              This option overrides previous uses of -v/--verbose or  --trace.\n"
-, stdout);
- fputs(
+"              This  option overrides previous uses of -v/--verbose or --trace.\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --trace-time\n"
-"              Prepends a time stamp to each trace or verbose  line  that  curl\n"
+"              Prepends  a  time  stamp to each trace or verbose line that curl\n"
+, stdout);
+ fputs(
 "              displays.  (Added in 7.14.0)\n"
 "\n"
-"              If  this option is used several times, each occurrence will tog\n"
+"              If this option is used several times, each occurrence will  tog-\n"
 "              gle it on/off.\n"
 "\n"
 "       -u/--user <user:password>\n"
-"              Specify user and password  to  use  for  server  authentication.\n"
-, stdout);
- fputs(
+"              Specify  user  and  password  to  use for server authentication.\n"
 "              Overrides -n/--netrc and --netrc-optional.\n"
 "\n"
-"              If  you  use an SSPI-enabled curl binary and do NTLM authentica\n"
+"              If you just give the user name (without entering a  colon)  curl\n"
+"              will prompt for a password.\n"
+"\n"
+, stdout);
+ fputs(
+"              If  you  use an SSPI-enabled curl binary and do NTLM authentica-\n"
 "              tion, you can force curl to pick up the user name  and  password\n"
 "              from  your  environment by simply specifying a single colon with\n"
 "              this option: \"-u :\".\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -U/--proxy-user <user:password>\n"
-, stdout);
- fputs(
 "              Specify user and password to use for proxy authentication.\n"
 "\n"
-"              If  you  use an SSPI-enabled curl binary and do NTLM authentica\n"
+, stdout);
+ fputs(
+"              If  you  use an SSPI-enabled curl binary and do NTLM authentica-\n"
 "              tion, you can force curl to pick up the user name  and  password\n"
 "              from  your  environment by simply specifying a single colon with\n"
 "              this option: \"-U :\".\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --url <URL>\n"
+"              Specify  a  URL  to  fetch. This option is mostly handy when you\n"
 , stdout);
  fputs(
-"              Specify  a  URL  to  fetch. This option is mostly handy when you\n"
 "              want to specify URL(s) in a config file.\n"
 "\n"
 "              This option may be used any number of times.  To  control  where\n"
 "              this URL is written, use the -o/--output or the -O/--remote-name\n"
 "              options.\n"
 "\n"
 "       -v/--verbose\n"
 "              Makes the fetching more  verbose/talkative.  Mostly  usable  for\n"
-"              debugging.  Lines  starting with > means \"header data\" sent by\n"
+"              debugging.  Lines  starting with '>' means \"header data\" sent by\n"
+"              curl, '<' means \"header data\" received by curl that is hidden in\n"
 , stdout);
  fputs(
-"              curl, < means \"header data\" received by curl that is hidden in\n"
-"              normal  cases  and lines starting with * means additional info\n"
+"              normal  cases  and lines starting with '*' means additional info\n"
 "              provided by curl.\n"
 "\n"
 "              Note  that  if  you  only  want  HTTP  headers  in  the  output,\n"
-"              -i/--include might be option youre looking for.\n"
+"              -i/--include might be option you're looking for.\n"
 "\n"
-"              If  you think this option still doesnt give you enough details,\n"
+"              If  you think this option still doesn't give you enough details,\n"
 "              consider using --trace or --trace-ascii instead.\n"
 "\n"
+"              This option overrides previous uses of --trace-ascii or --trace.\n"
 , stdout);
  fputs(
-"              This option overrides previous uses of --trace-ascii or --trace.\n"
 "              If  this option is used twice, the second will do nothing extra.\n"
 "\n"
 "       -V/--version\n"
 "              Displays information about curl and the libcurl version it uses.\n"
 "              The  first  line  includes the full version of curl, libcurl and\n"
 "              other 3rd party libraries linked with the executable.\n"
 "\n"
 "              The second line (starts with \"Protocols:\") shows  all  protocols\n"
-, stdout);
- fputs(
 "              that libcurl reports to support.\n"
 "\n"
+, stdout);
+ fputs(
 "              The third line (starts with \"Features:\") shows specific features\n"
 "              libcurl reports to offer. Available features include:\n"
 "\n"
 "              IPv6   You can use IPv6 with this.\n"
 "\n"
 "              krb4   Krb4 for ftp is supported.\n"
 "\n"
 "              SSL    HTTPS and FTPS are supported.\n"
 "\n"
 "              libz   Automatic decompression of compressed files over HTTP  is\n"
 "                     supported.\n"
 "\n"
-, stdout);
- fputs(
 "              NTLM   NTLM authentication is supported.\n"
 "\n"
 "              GSS-Negotiate\n"
+, stdout);
+ fputs(
 "                     Negotiate authentication and krb5 for ftp is supported.\n"
 "\n"
 "              Debug  This  curl  uses a libcurl built with Debug. This enables\n"
 "                     more error-tracking and memory debugging etc.  For  curl-\n"
 "                     developers only!\n"
 "\n"
 "              AsynchDNS\n"
 "                     This curl uses asynchronous name resolves.\n"
 "\n"
-, stdout);
- fputs(
 "              SPNEGO SPNEGO Negotiate authentication is supported.\n"
 "\n"
 "              Largefile\n"
+, stdout);
+ fputs(
 "                     This curl supports transfers of large files, files larger\n"
 "                     than 2GB.\n"
 "\n"
 "              IDN    This curl supports IDN - international domain names.\n"
 "\n"
 "              SSPI   SSPI is supported. If you use NTLM and set a  blank  user\n"
 "                     name,  curl  will authenticate with your current user and\n"
 "                     password.\n"
 "\n"
 "       -w/--write-out <format>\n"
+"              Defines what to display on stdout after a completed and success-\n"
 , stdout);
  fputs(
-"              Defines what to display on stdout after a completed and success\n"
 "              ful  operation.  The  format  is a string that may contain plain\n"
-"              text mixed with any number of variables. The string can be spec\n"
-"              ified  as \"string\", to get read from a particular file you spec\n"
+"              text mixed with any number of variables. The string can be spec-\n"
+"              ified  as \"string\", to get read from a particular file you spec-\n"
 "              ify it \"@filename\" and to tell curl  to  read  the  format  from\n"
 "              stdin you write \"@-\".\n"
 "\n"
+"              The  variables  present in the output format will be substituted\n"
 , stdout);
  fputs(
-"              The  variables  present in the output format will be substituted\n"
 "              by the value or text that curl thinks fit, as  described  below.\n"
 "              All  variables are specified like %{variable_name} and to output\n"
 "              a normal % you just write them like %%. You can output a newline\n"
 "              by  using \\n, a carriage return with \\r and a tab space with \\t.\n"
 "              NOTE: The %-letter is a special letter in the win32-environment,\n"
-, stdout);
- fputs(
 "              where  all  occurrences  of  %  must  be doubled when using this\n"
 "              option.\n"
 "\n"
+, stdout);
+ fputs(
 "              Available variables are at this point:\n"
 "\n"
 "              url_effective  The URL that was fetched  last.  This  is  mostly\n"
-"                             meaningful  if  youve  told curl to follow loca\n"
+"                             meaningful  if  you've  told curl to follow loca-\n"
 "                             tion: headers.\n"
 "\n"
 "              http_code      The numerical code that was  found  in  the  last\n"
 "                             retrieved HTTP(S) page.\n"
 "\n"
+"              http_connect   The  numerical  code  that  was found in the last\n"
 , stdout);
  fputs(
-"              http_connect   The  numerical  code  that  was found in the last\n"
 "                             response  (from  a  proxy)  to  a  curl   CONNECT\n"
 "                             request. (Added in 7.12.4)\n"
 "\n"
-"              time_total     The  total time, in seconds, that the full opera\n"
-"                             tion lasted. The time will be displayed with mil\n"
+"              time_total     The  total time, in seconds, that the full opera-\n"
+"                             tion lasted. The time will be displayed with mil-\n"
 "                             lisecond resolution.\n"
 "\n"
 "              time_namelookup\n"
+"                             The  time,  in  seconds,  it  took from the start\n"
 , stdout);
  fputs(
-"                             The  time,  in  seconds,  it  took from the start\n"
 "                             until the name resolving was completed.\n"
 "\n"
 "              time_connect   The time, in seconds,  it  took  from  the  start\n"
 "                             until  the  connect to the remote host (or proxy)\n"
 "                             was completed.\n"
 "\n"
 "              time_pretransfer\n"
 "                             The time, in seconds,  it  took  from  the  start\n"
+"                             until  the  file transfer is just about to begin.\n"
 , stdout);
  fputs(
-"                             until  the  file transfer is just about to begin.\n"
-"                             This includes all pre-transfer commands and nego\n"
-"                             tiations that are specific to the particular pro\n"
+"                             This includes all pre-transfer commands and nego-\n"
+"                             tiations that are specific to the particular pro-\n"
 "                             tocol(s) involved.\n"
 "\n"
 "              time_redirect  The time, in seconds, it took for all redirection\n"
 "                             steps  include  name lookup, connect, pretransfer\n"
+"                             and  transfer  before   final   transaction   was\n"
 , stdout);
  fputs(
-"                             and  transfer  before   final   transaction   was\n"
-"                             started.  time_redirect shows the complete execu\n"
+"                             started.  time_redirect shows the complete execu-\n"
 "                             tion time for multiple  redirections.  (Added  in\n"
 "                             7.12.3)\n"
 "\n"
 "              time_starttransfer\n"
 "                             The  time,  in  seconds,  it  took from the start\n"
-"                             until the first byte is just about to  be  trans\n"
+"                             until the first byte is just about to  be  trans-\n"
+"                             ferred.  This  includes time_pretransfer and also\n"
 , stdout);
  fputs(
-"                             ferred.  This  includes time_pretransfer and also\n"
 "                             the  time  the  server  needs  to  calculate  the\n"
 "                             result.\n"
 "\n"
 "              size_download  The total amount of bytes that were downloaded.\n"
 "\n"
 "              size_upload    The total amount of bytes that were uploaded.\n"
 "\n"
-"              size_header    The total amount of bytes of the downloaded head\n"
+"              size_header    The total amount of bytes of the downloaded head-\n"
 "                             ers.\n"
 "\n"
+"              size_request   The total amount of bytes that were sent  in  the\n"
 , stdout);
  fputs(
-"              size_request   The total amount of bytes that were sent  in  the\n"
 "                             HTTP request.\n"
 "\n"
 "              speed_download The average download speed that curl measured for\n"
 "                             the complete download.\n"
 "\n"
 "              speed_upload   The average upload speed that curl  measured  for\n"
 "                             the complete upload.\n"
 "\n"
 "              content_type   The  Content-Type  of  the requested document, if\n"
-, stdout);
- fputs(
 "                             there was any.\n"
 "\n"
-"              num_connects   Number of new connects made in the recent  trans\n"
+, stdout);
+ fputs(
+"              num_connects   Number of new connects made in the recent  trans-\n"
 "                             fer. (Added in 7.12.3)\n"
 "\n"
 "              num_redirects  Number  of  redirects  that  were followed in the\n"
 "                             request. (Added in 7.12.3)\n"
 "\n"
 "              ftp_entry_path The initial path libcurl ended up in when logging\n"
 "                             on to the remote FTP server. (Added in 7.15.4)\n"
 "\n"
-, stdout);
- fputs(
 "       If this option is used several times, the last one will be used.\n"
 "\n"
+, stdout);
+ fputs(
 "       -x/--proxy <proxyhost[:port]>\n"
 "              Use  specified  HTTP proxy. If the port number is not specified,\n"
 "              it is assumed at port 1080.\n"
 "\n"
 "              This option overrides existing environment variables  that  sets\n"
-"              proxy  to  use.  If  theres  an  environment variable setting a\n"
+"              proxy  to  use.  If  there's  an  environment variable setting a\n"
 "              proxy, you can set proxy to \"\" to override it.\n"
 "\n"
+"              Note that all operations that are performed over  a  HTTP  proxy\n"
 , stdout);
  fputs(
-"              Note that all operations that are performed over  a  HTTP  proxy\n"
 "              will  transparently  be converted to HTTP. It means that certain\n"
 "              protocol specific operations might not be available. This is not\n"
 "              the  case  if you can tunnel through the proxy, as done with the\n"
 "              -p/--proxytunnel option.\n"
 "\n"
 "              Starting with 7.14.1, the proxy host can be specified the  exact\n"
-, stdout);
- fputs(
 "              same  way  as  the proxy environment variables, include protocol\n"
 "              prefix (http://) and embedded user + password.\n"
 "\n"
+, stdout);
+ fputs(
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -X/--request <command>\n"
-"              (HTTP) Specifies a custom request method to use when communicat\n"
+"              (HTTP) Specifies a custom request method to use when communicat-\n"
 "              ing with the HTTP server.  The specified request  will  be  used\n"
 "              instead  of  the  method otherwise used (which defaults to GET).\n"
-, stdout);
- fputs(
 "              Read the HTTP 1.1 specification for details and explanations.\n"
 "\n"
+, stdout);
+ fputs(
 "              (FTP) Specifies a custom FTP command to use instead of LIST when\n"
 "              doing file lists with ftp.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -y/--speed-time <time>\n"
 "              If a download is slower than speed-limit bytes per second during\n"
 "              a speed-time period, the download gets aborted. If speed-time is\n"
-, stdout);
- fputs(
 "              used, the default speed-limit will be 1 unless set with -y.\n"
 "\n"
+, stdout);
+ fputs(
 "              This option controls transfers and thus  will  not  affect  slow\n"
 "              connects  etc.  If this is a concern for you, try the --connect-\n"
 "              timeout option.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -Y/--speed-limit <speed>\n"
-"              If a download is slower than this given speed, in bytes per sec\n"
+"              If a download is slower than this given speed, in bytes per sec-\n"
+"              ond, for speed-time seconds it gets aborted. speed-time  is  set\n"
 , stdout);
  fputs(
-"              ond, for speed-time seconds it gets aborted. speed-time  is  set\n"
 "              with -Y and is 30 if not set.\n"
 "\n"
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -z/--time-cond <date expression>\n"
 "              (HTTP/FTP) Request a file that has been modified later than  the\n"
 "              given  time  and date, or one that has been modified before that\n"
 "              time. The date expression can be all sorts of date strings or if\n"
+"              it  doesn't  match  any  internal ones, it tries to get the time\n"
 , stdout);
  fputs(
-"              it  doesnt  match  any  internal ones, it tries to get the time\n"
 "              from a given file name  instead!  See  the  curl_getdate(3)  man\n"
 "              pages for date expression details.\n"
 "\n"
 "              Start the date expression with a dash (-) to make it request for\n"
 "              a document that is older than the given date/time, default is  a\n"
 "              document that is newer than the specified date/time.\n"
 "\n"
-, stdout);
- fputs(
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       --max-redirs <num>\n"
+, stdout);
+ fputs(
 "              Set  maximum  number  of  redirection-followings   allowed.   If\n"
 "              -L/--location  is  used, this option can be used to prevent curl\n"
 "              from following redirections \"in absurdum\". By default, the limit\n"
-"              is set to 50 redirections. Set this option to -1 to make it lim\n"
+"              is set to 50 redirections. Set this option to -1 to make it lim-\n"
 "              itless.\n"
 "\n"
-, stdout);
- fputs(
 "              If this option is used several times, the last one will be used.\n"
 "\n"
 "       -0/--http1.0\n"
+, stdout);
+ fputs(
 "              (HTTP)  Forces curl to issue its requests using HTTP 1.0 instead\n"
 "              of using its internally preferred: HTTP 1.1.\n"
 "\n"
 "       -1/--tlsv1\n"
 "              (SSL) Forces curl to use TSL version 1 when negotiating  with  a\n"
 "              remote TLS server.\n"
 "\n"
 "       -2/--sslv2\n"
 "              (SSL)  Forces  curl to use SSL version 2 when negotiating with a\n"
 "              remote SSL server.\n"
-, stdout);
- fputs(
 "\n"
 "       -3/--sslv3\n"
 "              (SSL) Forces curl to use SSL version 3 when negotiating  with  a\n"
+, stdout);
+ fputs(
 "              remote SSL server.\n"
 "\n"
 "       -4/--ipv4\n"
 "              If  libcurl  is  capable  of resolving an address to multiple IP\n"
 "              versions (which it is if it is ipv6-capable), this option  tells\n"
 "              libcurl to resolve names to IPv4 addresses only.\n"
 "\n"
 "       -6/--ipv6\n"
 "              If  libcurl  is  capable  of resolving an address to multiple IP\n"
+"              versions (which it is if it is ipv6-capable), this option  tells\n"
 , stdout);
  fputs(
-"              versions (which it is if it is ipv6-capable), this option  tells\n"
 "              libcurl to resolve names to IPv6 addresses only.\n"
 "\n"
 "       -#/--progress-bar\n"
 "              Make curl display progress information as a progress bar instead\n"
 "              of the default statistics.\n"
 "\n"
@@ -1945,100 +2034,100 @@
 "\n"
 "FILES\n"
 "       ~/.curlrc\n"
 "              Default config file, see -K/--config for details.\n"
 "\n"
 "ENVIRONMENT\n"
+"       http_proxy [protocol://]<host>[:port]\n"
 , stdout);
  fputs(
-"       http_proxy [protocol://]<host>[:port]\n"
 "              Sets proxy server to use for HTTP.\n"
 "\n"
 "       HTTPS_PROXY [protocol://]<host>[:port]\n"
 "              Sets proxy server to use for HTTPS.\n"
 "\n"
 "       FTP_PROXY [protocol://]<host>[:port]\n"
 "              Sets proxy server to use for FTP.\n"
 "\n"
 "       ALL_PROXY [protocol://]<host>[:port]\n"
 "              Sets proxy server to use if no protocol-specific proxy is set.\n"
 "\n"
 "       NO_PROXY <comma-separated list of hosts>\n"
+"              list  of  host names that shouldn't go through any proxy. If set\n"
 , stdout);
  fputs(
-"              list  of  host names that shouldnt go through any proxy. If set\n"
-"              to a asterisk * only, it matches all hosts.\n"
+"              to a asterisk '*' only, it matches all hosts.\n"
 "\n"
 "EXIT CODES\n"
 "       There exists a bunch of different error codes and  their  corresponding\n"
 "       error  messages  that  may appear during bad conditions. At the time of\n"
 "       this writing, the exit codes are:\n"
 "\n"
 "       1      Unsupported protocol. This build of curl has no support for this\n"
 "              protocol.\n"
 "\n"
 "       2      Failed to initialize.\n"
 "\n"
-, stdout);
- fputs(
 "       3      URL malformat. The syntax was not correct.\n"
 "\n"
-"       5      Couldnt  resolve  proxy.  The  given  proxy  host  could not be\n"
+, stdout);
+ fputs(
+"       5      Couldn't  resolve  proxy.  The  given  proxy  host  could not be\n"
 "              resolved.\n"
 "\n"
-"       6      Couldnt resolve host. The given remote host was not resolved.\n"
+"       6      Couldn't resolve host. The given remote host was not resolved.\n"
 "\n"
 "       7      Failed to connect to host.\n"
 "\n"
-"       8      FTP weird server reply.  The  server  sent  data  curl  couldnt\n"
+"       8      FTP weird server reply.  The  server  sent  data  curl  couldn't\n"
 "              parse.\n"
 "\n"
 "       9      FTP  access  denied. The server denied login or denied access to\n"
+"              the particular resource or directory you wanted to  reach.  Most\n"
 , stdout);
  fputs(
-"              the particular resource or directory you wanted to  reach.  Most\n"
-"              often  you  tried to change to a directory that doesnt exist on\n"
+"              often  you  tried to change to a directory that doesn't exist on\n"
 "              the server.\n"
 "\n"
-"       11     FTP weird PASS reply. Curl couldnt parse the reply sent to  the\n"
+"       11     FTP weird PASS reply. Curl couldn't parse the reply sent to  the\n"
 "              PASS request.\n"
 "\n"
-"       13     FTP  weird PASV reply, Curl couldnt parse the reply sent to the\n"
+"       13     FTP  weird PASV reply, Curl couldn't parse the reply sent to the\n"
 "              PASV request.\n"
 "\n"
-"       14     FTP weird 227 format.  Curl  couldnt  parse  the  227-line  the\n"
-, stdout);
- fputs(
+"       14     FTP weird 227 format.  Curl  couldn't  parse  the  227-line  the\n"
 "              server sent.\n"
 "\n"
-"       15     FTP  cant  get host. Couldnt resolve the host IP we got in the\n"
+, stdout);
+ fputs(
+"       15     FTP  can't  get host. Couldn't resolve the host IP we got in the\n"
 "              227-line.\n"
 "\n"
-"       17     FTP couldnt set binary.  Couldnt  change  transfer  method  to\n"
+"       17     FTP couldn't set binary.  Couldn't  change  transfer  method  to\n"
 "              binary.\n"
 "\n"
 "       18     Partial file. Only a part of the file was transferred.\n"
 "\n"
-"       19     FTP  couldnt download/access the given file, the RETR (or simi\n"
+"       19     FTP  couldn't download/access the given file, the RETR (or simi-\n"
 "              lar) command failed.\n"
 "\n"
+"       21     FTP quote error. A quote command returned error from the server.\n"
 , stdout);
  fputs(
-"       21     FTP quote error. A quote command returned error from the server.\n"
 "       22     HTTP  page  not  retrieved.  The  requested url was not found or\n"
 "              returned another error with the HTTP error  code  being  400  or\n"
 "              above. This return code only appears if -f/--fail is used.\n"
 "\n"
-"       23     Write  error.  Curl couldnt write data to a local filesystem or\n"
+"       23     Write  error.  Curl couldn't write data to a local filesystem or\n"
 "              similar.\n"
 "\n"
-"       25     FTP couldnt STOR file. The server denied  the  STOR  operation,\n"
-, stdout);
- fputs(
+"       25     FTP couldn't STOR file. The server denied  the  STOR  operation,\n"
 "              used for FTP uploading.\n"
 "\n"
+, stdout);
+ fputs(
 "       26     Read error. Various reading problems.\n"
 "\n"
 "       27     Out of memory. A memory allocation request failed.\n"
 "\n"
 "       28     Operation  timeout.  The  specified  time-out period was reached\n"
 "              according to the conditions.\n"
@@ -2046,54 +2135,54 @@
 "       30     FTP PORT failed. The PORT command failed. Not  all  FTP  servers\n"
 "              support  the  PORT  command,  try  doing  a  transfer using PASV\n"
 "              instead!\n"
 "\n"
 , stdout);
  fputs(
-"       31     FTP couldnt use REST. The REST command failed. This command  is\n"
+"       31     FTP couldn't use REST. The REST command failed. This command  is\n"
 "              used for resumed FTP transfers.\n"
 "\n"
-"       33     HTTP range error. The range \"command\" didnt work.\n"
+"       33     HTTP range error. The range \"command\" didn't work.\n"
 "\n"
 "       34     HTTP post error. Internal post-request generation error.\n"
 "\n"
 "       35     SSL connect error. The SSL handshaking failed.\n"
 "\n"
-"       36     FTP  bad  download  resume. Couldnt continue an earlier aborted\n"
+"       36     FTP  bad  download  resume. Couldn't continue an earlier aborted\n"
 "              download.\n"
 "\n"
 , stdout);
  fputs(
-"       37     FILE couldnt read file. Failed to open the file. Permissions?\n"
+"       37     FILE couldn't read file. Failed to open the file. Permissions?\n"
 "\n"
 "       38     LDAP cannot bind. LDAP bind operation failed.\n"
 "\n"
 "       39     LDAP search failed.\n"
 "\n"
 "       41     Function not found. A required LDAP function was not found.\n"
 "\n"
-"       42     Aborted by callback. An application told curl to abort the oper\n"
+"       42     Aborted by callback. An application told curl to abort the oper-\n"
 "              ation.\n"
 "\n"
 "       43     Internal error. A function was called with a bad parameter.\n"
 "\n"
 , stdout);
  fputs(
 "       45     Interface  error.  A  specified  outgoing interface could not be\n"
 "              used.\n"
 "\n"
-"       47     Too many redirects. When following redirects, curl hit the maxi\n"
+"       47     Too many redirects. When following redirects, curl hit the maxi-\n"
 "              mum amount.\n"
 "\n"
 "       48     Unknown TELNET option specified.\n"
 "\n"
 "       49     Malformed telnet option.\n"
 "\n"
-"       51     The peers SSL certificate or SSH MD5 fingerprint was not ok\n"
+"       51     The peer's SSL certificate or SSH MD5 fingerprint was not ok\n"
 "\n"
-"       52     The  server  didnt  reply anything, which here is considered an\n"
+"       52     The  server  didn't  reply anything, which here is considered an\n"
 "              error.\n"
 "\n"
 , stdout);
  fputs(
 "       53     SSL crypto engine not found\n"
 "\n"
@@ -2102,15 +2191,15 @@
 "       55     Failed sending network data\n"
 "\n"
 "       56     Failure in receiving network data\n"
 "\n"
 "       58     Problem with the local certificate\n"
 "\n"
-"       59     Couldnt use specified SSL cipher\n"
+"       59     Couldn't use specified SSL cipher\n"
 "\n"
-"       60     Peer certificate cannot be authenticated with known CA  certifi\n"
+"       60     Peer certificate cannot be authenticated with known CA  certifi-\n"
 "              cates\n"
 "\n"
 "       61     Unrecognized transfer encoding\n"
 "\n"
 "       62     Invalid LDAP URL\n"
 "\n"
@@ -3241,3035 +3330,3100 @@
 , stdout) ;
 }
 #endif /* USE_MANUAL */
 #else
 /*
  * NEVER EVER edit this manually, fix the mkhelp.pl script instead!
- * Generation time: Sat Oct 13 22:50:01 2007
+ * Generation time: Fri Jan 25 23:44:31 2008
  */
 #include "setup.h"
 #ifdef USE_MANUAL
 #include "hugehelp.h"
 #include <stdio.h>
 #include <zlib.h>
 static const unsigned char hugehelpgz[] = {
   /* This mumbo-jumbo is the huge help text compressed with gzip.
-     Thanks to this operation, the size of this data shrunk from 118099
-     to 36125 bytes. You can disable the use of compressed help
+     Thanks to this operation, the size of this data shrunk from 121433
+     to 36910 bytes. You can disable the use of compressed help
      texts by NOT passing -c to the mkhelp.pl tool. */
   0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0xed, 0xbd,
-  0xeb, 0x76, 0x1b, 0xd7, 0xb5, 0x26, 0xfa, 0xfb, 0xf0, 0x29, 0x2a, 0xf0,
-  0x48, 0x48, 0x26, 0x00, 0x78, 0x91, 0x64, 0x5b, 0x8a, 0xe4, 0x84, 0x26,
-  0x29, 0x9b, 0x6d, 0x8a, 0x64, 0x13, 0x94, 0x2f, 0xed, 0x78, 0x68, 0x14,
-  0x80, 0x02, 0x59, 0x21, 0x80, 0x42, 0xaa, 0x0a, 0x24, 0xe1, 0xec, 0xf4,
-  0xe8, 0x47, 0x38, 0x7f, 0xfb, 0x3d, 0xfa, 0x09, 0xfa, 0x51, 0xfa, 0x49,
-  0xce, 0xfc, 0xe6, 0x65, 0xad, 0x55, 0x17, 0x50, 0xb2, 0x63, 0x27, 0x7d,
-  0xfa, 0x9c, 0xec, 0x6d, 0x91, 0x04, 0xaa, 0xd6, 0x75, 0xae, 0xb9, 0xe6,
-  0xf5, 0x9b, 0x51, 0xf4, 0xbe, 0xff, 0xbd, 0xe3, 0xff, 0xde, 0xd1, 0xff,
-  0xe4, 0xf7, 0x28, 0xda, 0x88, 0xa2, 0x8b, 0x3c, 0xfb, 0x6b, 0x32, 0x2a,
-  0xdb, 0x5f, 0x78, 0xf7, 0xee, 0x3f, 0x22, 0xf9, 0x3f, 0x7a, 0xe1, 0x2f,
-  0xfc, 0x93, 0x5f, 0x7a, 0xe4, 0x7f, 0x3b, 0x91, 0x7f, 0xe9, 0x3f, 0xde,
-  0x6d, 0x47, 0x1f, 0xf2, 0xd2, 0x7f, 0x44, 0x5b, 0xfc, 0xd2, 0x3b, 0xed,
-  0xe9, 0x25, 0x7e, 0xa7, 0x51, 0x3e, 0xde, 0xd3, 0x5f, 0x30, 0x3c, 0xfc,
-  0xb3, 0x83, 0x17, 0xff, 0xf2, 0x0e, 0xbf, 0xd2, 0x27, 0x1b, 0x1b, 0x67,
-  0x07, 0x6f, 0x8e, 0xed, 0xd5, 0xd1, 0x32, 0x9f, 0x46, 0xbd, 0xa8, 0xcc,
-  0xe3, 0x79, 0x31, 0x49, 0xf2, 0x28, 0x8e, 0xde, 0x5e, 0x9e, 0x6e, 0x6c,
-  0x0c, 0xbe, 0x3b, 0x3b, 0xbf, 0x18, 0x9c, 0x0c, 0x2a, 0x8f, 0x7d, 0x9f,
-  0x2d, 0xca, 0x34, 0x9b, 0x17, 0x3f, 0x44, 0xdf, 0xd3, 0x43, 0xfd, 0x7e,
-  0xff, 0x87, 0x8d, 0x8d, 0xa3, 0xe3, 0xc1, 0xe1, 0xe5, 0xc9, 0xc5, 0xd5,
-  0xc9, 0xf9, 0x59, 0xe5, 0xd9, 0x28, 0x2d, 0x22, 0x6a, 0xac, 0xcc, 0xb2,
-  0x29, 0xfd, 0xe3, 0xdb, 0x1f, 0xc7, 0x65, 0x1c, 0x4d, 0xf2, 0x6c, 0x16,
-  0x65, 0x39, 0xbe, 0x88, 0xa3, 0x22, 0xc9, 0xef, 0x92, 0xbc, 0x1b, 0x2d,
-  0x8b, 0x74, 0x7e, 0x1d, 0x65, 0xf3, 0x24, 0xca, 0x26, 0x51, 0x79, 0x93,
-  0x58, 0x73, 0xc5, 0x72, 0xb1, 0xc8, 0xf2, 0x32, 0x19, 0x47, 0x8b, 0x3c,
-  0x2b, 0xb3, 0x51, 0x36, 0x2d, 0xa2, 0xad, 0x2f, 0xaf, 0xae, 0x2e, 0xba,
-  0x11, 0xfe, 0x1d, 0x74, 0xa3, 0xd7, 0xf8, 0xfd, 0x35, 0xff, 0x1a, 0x0d,
-  0x0e, 0x2f, 0xf0, 0x2f, 0x7f, 0x14, 0x5d, 0xc9, 0x8f, 0xa3, 0x93, 0xc3,
-  0xab, 0xae, 0x35, 0x77, 0x75, 0x7c, 0x7a, 0x76, 0x7c, 0x45, 0x9f, 0x9e,
-  0x1e, 0x1d, 0x5c, 0x44, 0x18, 0x45, 0xf4, 0xfa, 0xe4, 0xf4, 0x78, 0xbb,
-  0x4f, 0x5f, 0xdd, 0x24, 0xd1, 0x28, 0x9b, 0xcd, 0xe2, 0xf9, 0x18, 0xc3,
-  0x1f, 0x27, 0x45, 0x7a, 0x3d, 0xa7, 0x7e, 0x69, 0x98, 0xf7, 0x59, 0x7e,
-  0x1b, 0xdd, 0xa7, 0xe5, 0x4d, 0xb6, 0x2c, 0x69, 0xa4, 0x49, 0x6e, 0xcd,
-  0xa5, 0xf3, 0x32, 0xc9, 0xe3, 0x11, 0xd6, 0xa5, 0xbf, 0x51, 0x59, 0x81,
-  0x6c, 0x42, 0xf3, 0x2d, 0x68, 0x82, 0xc3, 0x65, 0x31, 0xcd, 0xe2, 0x31,
-  0xa6, 0x45, 0x6f, 0x4e, 0x96, 0xb4, 0x20, 0x79, 0x3a, 0xba, 0x2d, 0xa2,
-  0x69, 0x7a, 0x9b, 0x60, 0x52, 0x0f, 0x2b, 0x9b, 0x64, 0x97, 0xdb, 0x8e,
-  0xe2, 0x25, 0xcd, 0x7f, 0xfe, 0xbf, 0xfe, 0xdb, 0xff, 0x6d, 0x0d, 0x96,
-  0xe9, 0x28, 0x46, 0x17, 0x34, 0xec, 0x49, 0xb9, 0x88, 0x96, 0x0b, 0x34,
-  0x28, 0xf3, 0x8f, 0x16, 0x59, 0x41, 0xef, 0x0d, 0x06, 0xa7, 0x34, 0xf6,
-  0xf9, 0x3c, 0xe1, 0xa1, 0x14, 0x5d, 0xfa, 0x23, 0xbb, 0x4d, 0x13, 0xfa,
-  0x65, 0x92, 0x4e, 0x13, 0x59, 0xff, 0xa0, 0x41, 0x6c, 0x45, 0x9e, 0x14,
-  0xcb, 0x59, 0x12, 0x61, 0xb6, 0xb3, 0x2c, 0x4f, 0xfa, 0xd1, 0x41, 0x11,
-  0xad, 0xb2, 0x25, 0x4d, 0x73, 0x3a, 0xa5, 0x5d, 0x49, 0xa2, 0x61, 0x32,
-  0xcd, 0xee, 0xbb, 0xd8, 0x8b, 0x68, 0xbe, 0x9c, 0x0d, 0xe9, 0x15, 0x9a,
-  0xc2, 0x24, 0x89, 0xcb, 0x25, 0xbd, 0xca, 0x8f, 0x59, 0x73, 0xb3, 0x98,
-  0x66, 0x42, 0xef, 0xe6, 0xd1, 0x4d, 0x42, 0x33, 0x2d, 0x16, 0xe9, 0xfc,
-  0x37, 0x1b, 0x4d, 0x7a, 0x58, 0x64, 0xf7, 0x49, 0x4e, 0x0b, 0x1a, 0x0d,
-  0x57, 0x11, 0xcd, 0x7e, 0x28, 0xdf, 0x4c, 0xb0, 0x07, 0xf1, 0x74, 0xea,
-  0x88, 0xa4, 0x97, 0x27, 0xd3, 0x18, 0x1b, 0x6e, 0x7d, 0xf5, 0xa3, 0x41,
-  0xe2, 0xe8, 0x41, 0xdf, 0xdb, 0x7a, 0xb2, 0xcd, 0x6f, 0x8e, 0x93, 0x32,
-  0x4e, 0xa7, 0x05, 0x2d, 0x3e, 0x08, 0xd7, 0x36, 0x99, 0x86, 0x4c, 0x7f,
-  0x46, 0xc5, 0x6a, 0x5e, 0xc6, 0x0f, 0xe8, 0xdb, 0x68, 0x87, 0x9e, 0x5f,
-  0x24, 0xf3, 0x71, 0x32, 0x2f, 0xfb, 0xd1, 0x77, 0xd9, 0xf2, 0x7f, 0xfd,
-  0xb7, 0xff, 0x4e, 0x1d, 0x4f, 0x52, 0x5a, 0x83, 0x38, 0xd2, 0xb6, 0x30,
-  0x40, 0xda, 0xfb, 0x51, 0x9e, 0x2e, 0x2a, 0x5b, 0x90, 0xcd, 0x69, 0xb7,
-  0xa3, 0xcb, 0xd7, 0x87, 0xd1, 0x93, 0xe7, 0x9f, 0x7e, 0xec, 0x77, 0x9b,
-  0x9a, 0xa1, 0x49, 0xc6, 0x73, 0x22, 0xd5, 0x45, 0x32, 0x4a, 0x27, 0x34,
-  0xb7, 0xd9, 0x72, 0x5a, 0xa6, 0x0b, 0x5a, 0x77, 0x8c, 0xa2, 0x00, 0x91,
-  0x2d, 0xe2, 0xbc, 0x2c, 0xb0, 0x7e, 0xfc, 0x01, 0xcd, 0xff, 0x3e, 0x4f,
-  0x4b, 0x10, 0x3c, 0xbe, 0xa0, 0xd5, 0x2e, 0x0b, 0x6b, 0x0e, 0x54, 0x46,
-  0xfd, 0x0c, 0x89, 0xaa, 0x68, 0x95, 0xe3, 0x82, 0x3a, 0x7d, 0xe1, 0xfa,
-  0x8a, 0x6e, 0xca, 0x72, 0xf1, 0x62, 0x67, 0xa7, 0x48, 0xcb, 0xa4, 0xff,
-  0x77, 0x3a, 0x2c, 0xdd, 0xf2, 0x3e, 0xeb, 0x96, 0x37, 0x79, 0x92, 0xfc,
-  0xa3, 0x4f, 0xb4, 0xeb, 0x1e, 0xa4, 0x2e, 0xb1, 0x97, 0x18, 0xd6, 0x75,
-  0x82, 0x0e, 0xfe, 0xb6, 0x4c, 0xe6, 0x68, 0x90, 0x86, 0x10, 0x4f, 0x17,
-  0x37, 0x31, 0xed, 0x68, 0x42, 0x64, 0x88, 0xe3, 0x47, 0x64, 0x82, 0x11,
-  0xc9, 0x01, 0xfc, 0xfe, 0x87, 0x46, 0x9f, 0x13, 0xee, 0x92, 0xfe, 0xed,
-  0xeb, 0x4b, 0x31, 0xad, 0x37, 0x75, 0xb6, 0x03, 0xd2, 0xfa, 0x7e, 0xaf,
-  0xb7, 0xb7, 0xbb, 0xfb, 0x43, 0xbf, 0x7c, 0x28, 0x3f, 0xf0, 0x85, 0xdd,
-  0x5d, 0xff, 0x0a, 0x9e, 0xde, 0xc2, 0x8c, 0xa3, 0x29, 0x11, 0x0e, 0xfa,
-  0xff, 0x31, 0xc9, 0xb3, 0x62, 0xbb, 0xa5, 0xa9, 0x69, 0x52, 0xd2, 0x51,
-  0x0b, 0xda, 0x89, 0x7b, 0x3f, 0x4a, 0xb7, 0xf6, 0xf0, 0x59, 0x16, 0xcd,
-  0x93, 0x82, 0x57, 0x55, 0x58, 0x48, 0x30, 0x6d, 0x22, 0x01, 0xcf, 0x48,
-  0xe2, 0x92, 0xbf, 0x9d, 0x65, 0x33, 0xa2, 0x83, 0x2e, 0x1d, 0xd0, 0xd2,
-  0x2d, 0x16, 0x9d, 0x3f, 0xc7, 0x78, 0x12, 0xe2, 0x4b, 0xf1, 0x14, 0x2c,
-  0xa9, 0xa0, 0x86, 0x69, 0xb0, 0xc4, 0x08, 0x92, 0x78, 0x74, 0x13, 0x65,
-  0xf4, 0x76, 0xde, 0xdc, 0x94, 0x78, 0xbe, 0xea, 0x67, 0xf9, 0xf5, 0x4e,
-  0x9c, 0x8f, 0x6e, 0xd2, 0x3b, 0x5a, 0x99, 0xe7, 0xcf, 0x3f, 0xee, 0xd1,
-  0x3f, 0xcf, 0x7f, 0xd8, 0xb9, 0xcb, 0xa6, 0xb4, 0x50, 0x4f, 0x7f, 0xd8,
-  0xc1, 0x76, 0xff, 0x3d, 0xee, 0x0e, 0xbb, 0xa3, 0x7f, 0xf4, 0x6f, 0xca,
-  0xd9, 0xf4, 0x31, 0x2a, 0xa2, 0xf6, 0xa2, 0x78, 0x96, 0x2d, 0xe7, 0xa5,
-  0x23, 0x1c, 0xa2, 0xc1, 0x32, 0xe0, 0x52, 0xd3, 0x74, 0x4e, 0xe7, 0x96,
-  0xa8, 0x7d, 0x25, 0xa7, 0x76, 0x98, 0xf8, 0x03, 0x5e, 0x8e, 0x6e, 0x68,
-  0xaa, 0x44, 0x49, 0xb1, 0x2e, 0x43, 0x99, 0xd2, 0x64, 0xe8, 0xb5, 0x39,
-  0x1d, 0xe4, 0x54, 0xda, 0x91, 0xae, 0x52, 0x7a, 0x2e, 0xcb, 0xc7, 0x49,
-  0xee, 0x69, 0x7a, 0x90, 0xd2, 0xaa, 0xc9, 0xc9, 0xfd, 0xa4, 0xbf, 0xf7,
-  0xac, 0xbf, 0xe7, 0x16, 0x88, 0xb6, 0x32, 0x73, 0x43, 0x2c, 0xca, 0x64,
-  0x41, 0x83, 0x59, 0x82, 0x09, 0xf2, 0x69, 0x44, 0xa3, 0x74, 0x8a, 0xaf,
-  0xc1, 0x78, 0xa2, 0x22, 0x73, 0x87, 0xe7, 0x26, 0x2e, 0x2b, 0xf4, 0x88,
-  0xa5, 0x5d, 0x45, 0x67, 0xb4, 0xef, 0xc6, 0x59, 0xf2, 0x48, 0x36, 0xf8,
-  0x45, 0x7d, 0x55, 0xef, 0xef, 0xef, 0xd7, 0xd3, 0xdd, 0x8b, 0xbd, 0x1a,
-  0xe9, 0x05, 0x2f, 0xb5, 0x11, 0xcc, 0x8b, 0xfd, 0x2a, 0xc9, 0x9c, 0x4c,
-  0x22, 0x1e, 0x97, 0x5f, 0x74, 0xb0, 0x0d, 0xc7, 0xe9, 0x8d, 0x6b, 0x50,
-  0x8b, 0xf4, 0x7b, 0x32, 0x49, 0x1f, 0xba, 0xb2, 0x28, 0xbc, 0xda, 0x31,
-  0xb5, 0x3f, 0x5b, 0x80, 0x2c, 0xac, 0xb9, 0xeb, 0x65, 0x52, 0x10, 0x67,
-  0xc4, 0x6c, 0x1d, 0xc3, 0x41, 0xf3, 0xb3, 0xf4, 0xfa, 0xa6, 0x8c, 0xee,
-  0x63, 0x70, 0x9d, 0x93, 0x52, 0xde, 0x06, 0x8b, 0x27, 0x3e, 0x33, 0x89,
-  0x89, 0x57, 0x44, 0x20, 0x2d, 0x61, 0xe7, 0xa0, 0x46, 0xb7, 0x6c, 0xb4,
-  0x46, 0x42, 0x6c, 0x51, 0x70, 0xf9, 0x0d, 0xe3, 0x02, 0x1b, 0x36, 0x27,
-  0xa2, 0x28, 0x93, 0x79, 0x6f, 0x89, 0xbf, 0x6e, 0xe8, 0x12, 0x88, 0xe6,
-  0xf1, 0x2c, 0xd1, 0x61, 0x82, 0x67, 0xbe, 0xa6, 0x35, 0x4d, 0x1e, 0xe2,
-  0x59, 0xc0, 0xc4, 0x88, 0x25, 0x75, 0x79, 0x9f, 0xdc, 0xf3, 0x74, 0x2c,
-  0x4a, 0x22, 0x49, 0x9c, 0x19, 0x3e, 0x86, 0x1d, 0x1c, 0xb5, 0x4e, 0x38,
-  0xc9, 0x82, 0x6f, 0x09, 0x5e, 0x24, 0x4c, 0x20, 0x0a, 0xa6, 0x4b, 0x8b,
-  0x16, 0xdf, 0xe2, 0xe6, 0xf5, 0x84, 0x73, 0xd8, 0xb2, 0x3a, 0x74, 0xd3,
-  0x60, 0x94, 0xe1, 0xfd, 0xc4, 0x83, 0x70, 0x5c, 0xd2, 0x5f, 0x51, 0xb8,
-  0x32, 0xbb, 0x75, 0xc2, 0x21, 0x82, 0xe1, 0x01, 0xce, 0x70, 0x20, 0xf0,
-  0x6c, 0x21, 0x12, 0x04, 0x53, 0x30, 0xe6, 0x2c, 0x22, 0x84, 0x74, 0x3b,
-  0xcf, 0xca, 0x68, 0x9c, 0x05, 0x1c, 0x98, 0x7a, 0x0d, 0x56, 0x00, 0x03,
-  0x28, 0x48, 0x08, 0x23, 0x06, 0x38, 0x2e, 0x6e, 0xe8, 0xda, 0x2a, 0x70,
-  0x7e, 0x88, 0x3b, 0xa4, 0x33, 0x5a, 0xe1, 0x3b, 0xac, 0xc7, 0x22, 0x49,
-  0xc6, 0xfd, 0xe8, 0x7c, 0x02, 0xc2, 0xce, 0x69, 0xd8, 0x25, 0x7f, 0x8d,
-  0xb3, 0x37, 0x5d, 0x51, 0xd3, 0x10, 0x50, 0xe6, 0xee, 0x98, 0xf1, 0x68,
-  0x82, 0x63, 0xc4, 0xc7, 0x8d, 0x06, 0x3b, 0xad, 0x1e, 0x52, 0xbe, 0x65,
-  0x41, 0xfd, 0x18, 0x1e, 0x1d, 0xd3, 0x28, 0xe2, 0x6d, 0xa3, 0xdf, 0xca,
-  0xfb, 0x24, 0x99, 0x7b, 0x96, 0x43, 0xfc, 0x81, 0xae, 0x3e, 0x59, 0xff,
-  0x74, 0x7e, 0x97, 0x61, 0x80, 0x1b, 0x1b, 0x17, 0x97, 0xe7, 0x5f, 0x5c,
-  0x1e, 0x0f, 0x06, 0xd1, 0x9b, 0xe3, 0xab, 0xe3, 0xcb, 0xea, 0xc5, 0x3a,
-  0xcf, 0xf2, 0x19, 0xdd, 0x9e, 0x44, 0x29, 0xe3, 0xb4, 0x58, 0x4c, 0xe3,
-  0x15, 0x64, 0x0e, 0x9a, 0xcb, 0x75, 0x0e, 0x5a, 0x9c, 0x25, 0x38, 0x9a,
-  0xe3, 0x65, 0xce, 0x5c, 0x71, 0x41, 0x0c, 0x4d, 0xe5, 0x03, 0xba, 0xf2,
-  0x58, 0xa8, 0x98, 0x5f, 0x5b, 0x73, 0x9e, 0xd5, 0xd8, 0x56, 0xd0, 0x08,
-  0x21, 0xaf, 0x75, 0xbd, 0xf8, 0xc6, 0x8b, 0x53, 0xf0, 0x6c, 0xc0, 0x69,
-  0x67, 0x7c, 0x4d, 0xd3, 0xcf, 0x84, 0x4e, 0xef, 0x84, 0x8e, 0x75, 0x39,
-  0xea, 0x5b, 0x73, 0x5f, 0xd2, 0x65, 0xcf, 0x82, 0x1d, 0xd6, 0x63, 0x94,
-  0xd8, 0x70, 0xdd, 0x20, 0x59, 0x12, 0x84, 0x68, 0x48, 0xbb, 0x48, 0x63,
-  0x9c, 0xa5, 0x73, 0x62, 0x4f, 0x74, 0x0d, 0xe9, 0x91, 0xa0, 0x11, 0x4e,
-  0x40, 0x75, 0x5e, 0xd0, 0xc2, 0x62, 0x48, 0x23, 0xf4, 0x16, 0x6d, 0x31,
-  0xb1, 0x12, 0x37, 0x21, 0x1e, 0x51, 0x5a, 0x62, 0x9b, 0xe2, 0x21, 0x4e,
-  0x2e, 0xce, 0x13, 0xae, 0x58, 0xea, 0x97, 0x3b, 0xe2, 0x0f, 0x02, 0xa9,
-  0xd2, 0x7a, 0xa4, 0xe1, 0xd1, 0x6b, 0x34, 0xa8, 0x78, 0x88, 0x9d, 0xc4,
-  0x60, 0x6a, 0x6b, 0x47, 0xb7, 0x21, 0x1f, 0xc1, 0xfb, 0x94, 0x68, 0x81,
-  0x9e, 0xbd, 0xcf, 0x96, 0x53, 0x92, 0x98, 0xf0, 0xc0, 0x72, 0xe1, 0xe9,
-  0x94, 0xa8, 0x62, 0x59, 0x2e, 0xa8, 0xe7, 0x59, 0xfa, 0xc0, 0xf7, 0x7a,
-  0xad, 0x15, 0x1a, 0x1f, 0xfd, 0xb9, 0xa0, 0xb5, 0x4f, 0x78, 0x44, 0xfd,
-  0x90, 0x07, 0xb1, 0xd8, 0x85, 0xc3, 0xd5, 0xd8, 0x39, 0x9c, 0x13, 0xe6,
-  0x0b, 0x17, 0xe7, 0x83, 0x2b, 0x70, 0xc9, 0x8b, 0xb7, 0x57, 0xd4, 0x10,
-  0xf1, 0xf3, 0xa2, 0xa4, 0x5d, 0xc4, 0x8b, 0xf3, 0x84, 0x65, 0x54, 0x6b,
-  0x8e, 0x76, 0x2d, 0xcd, 0x59, 0x63, 0xc1, 0xa0, 0x7c, 0xa7, 0x36, 0x3e,
-  0x16, 0xba, 0x41, 0xb7, 0x26, 0x72, 0x17, 0x37, 0x09, 0x9d, 0x1b, 0xf7,
-  0xda, 0xd6, 0x67, 0xdb, 0xdd, 0xa8, 0xe7, 0x9a, 0xfb, 0x1e, 0x8f, 0xfe,
-  0x80, 0x9e, 0x8b, 0x74, 0x96, 0x4e, 0xe3, 0xe0, 0x92, 0x38, 0xe1, 0xf5,
-  0x06, 0x45, 0xbb, 0x93, 0x38, 0x22, 0xde, 0xc4, 0x63, 0x26, 0xa6, 0xa0,
-  0x62, 0x2a, 0x16, 0x90, 0x8f, 0xb1, 0xdf, 0x2c, 0xc8, 0x82, 0x7c, 0x10,
-  0x48, 0x50, 0x2c, 0x2b, 0x32, 0x16, 0x88, 0x94, 0xc6, 0x88, 0x83, 0x5e,
-  0x59, 0xad, 0x3a, 0xa1, 0x34, 0x56, 0x0f, 0x6c, 0x8f, 0xd5, 0x17, 0xb7,
-  0x7e, 0x9d, 0x61, 0x9c, 0x77, 0x88, 0x6c, 0xe8, 0x8e, 0x12, 0xe1, 0x9b,
-  0xef, 0xa6, 0xe4, 0x7a, 0x49, 0x73, 0x90, 0xc5, 0xa5, 0x69, 0x7e, 0x84,
-  0xb1, 0x40, 0x70, 0x75, 0x07, 0x9a, 0xa4, 0xa1, 0xf9, 0xb8, 0xbf, 0x71,
-  0xce, 0x2a, 0x8d, 0xd3, 0x7f, 0x7a, 0xf1, 0x4e, 0xaf, 0x17, 0x2f, 0x20,
-  0x3a, 0xd6, 0x94, 0xae, 0x2d, 0x9a, 0xe9, 0x76, 0xf4, 0x0d, 0x98, 0x39,
-  0x1f, 0x69, 0x5c, 0xb8, 0xf3, 0x60, 0xfa, 0x5d, 0xe1, 0x1f, 0xc2, 0xf2,
-  0xb1, 0xd0, 0x46, 0xc1, 0x51, 0x6b, 0x73, 0x4a, 0xa6, 0xf4, 0x4f, 0x9c,
-  0xe3, 0xa2, 0x14, 0xde, 0xe8, 0xa6, 0x81, 0x79, 0x44, 0xc4, 0xa6, 0x72,
-  0x13, 0x1f, 0x89, 0x22, 0xfb, 0x58, 0x03, 0xbc, 0x83, 0x47, 0x6b, 0xcd,
-  0x8d, 0xb3, 0xa4, 0x20, 0xf6, 0xf7, 0xdf, 0xe9, 0x68, 0x3e, 0xa4, 0xd0,
-  0x13, 0xd2, 0xd2, 0x24, 0x85, 0x68, 0x94, 0x27, 0x38, 0xbe, 0x7e, 0x29,
-  0xfd, 0x8a, 0xf2, 0x90, 0x45, 0xdb, 0xc3, 0x02, 0xf1, 0xc4, 0xca, 0xfb,
-  0x74, 0x94, 0x74, 0x55, 0xac, 0x22, 0xa6, 0x3a, 0x66, 0x5d, 0x8d, 0x1b,
-  0xd3, 0xe3, 0xd3, 0x3e, 0xa3, 0x59, 0x36, 0xa6, 0x6f, 0xae, 0xe3, 0x34,
-  0x50, 0x90, 0x7a, 0x07, 0xb4, 0x9c, 0x50, 0x75, 0x7a, 0xf1, 0x35, 0x09,
-  0x26, 0xd1, 0x4b, 0xf9, 0x51, 0x94, 0x60, 0x53, 0x9f, 0xd5, 0x57, 0x18,
-  0xf4, 0xbf, 0x1d, 0x0d, 0xf4, 0x86, 0xc6, 0x00, 0xde, 0xe2, 0xd5, 0x83,
-  0xe0, 0x1d, 0xac, 0x5b, 0x41, 0x7d, 0x1b, 0x9d, 0xf0, 0x91, 0x91, 0x6b,
-  0xa1, 0x5f, 0x6b, 0x6e, 0x40, 0x52, 0x1f, 0x31, 0xde, 0x78, 0xcc, 0x2c,
-  0x13, 0x73, 0x88, 0x0e, 0xbf, 0x38, 0x21, 0x8a, 0x9c, 0x90, 0xec, 0x1f,
-  0x81, 0xeb, 0xc8, 0xf4, 0x69, 0x39, 0x13, 0x3a, 0xe8, 0x34, 0x7f, 0x59,
-  0x40, 0x70, 0xe7, 0x32, 0x0a, 0xaf, 0x3f, 0xfd, 0x5f, 0xe7, 0x4d, 0xf6,
-  0x23, 0xad, 0x42, 0xbc, 0xf3, 0xb4, 0xbf, 0xdb, 0x81, 0x1a, 0x49, 0x5b,
-  0x48, 0x42, 0x27, 0xa6, 0x1d, 0x0d, 0xa7, 0xf1, 0x9c, 0x34, 0x3d, 0x50,
-  0x85, 0xac, 0x1c, 0x8f, 0x96, 0x6e, 0xb8, 0x65, 0x9e, 0x13, 0xb7, 0x1d,
-  0x87, 0x2c, 0xc9, 0xee, 0x00, 0x99, 0x10, 0xdf, 0xc6, 0x7a, 0x93, 0xfc,
-  0x6d, 0x99, 0x11, 0x23, 0x9b, 0xc5, 0xf9, 0xad, 0xdd, 0x56, 0x4e, 0x12,
-  0xc3, 0x55, 0xc2, 0xe3, 0xe2, 0xe7, 0x5b, 0x9a, 0xeb, 0x7d, 0x49, 0x4b,
-  0x0d, 0xad, 0x0c, 0x42, 0x96, 0xec, 0x68, 0x66, 0x57, 0x5b, 0xdb, 0xd6,
-  0xeb, 0xe4, 0xfd, 0xe6, 0xa3, 0x75, 0xe8, 0x87, 0x38, 0xc4, 0xf4, 0xee,
-  0xdc, 0x88, 0x60, 0x1a, 0x93, 0x08, 0xe1, 0x48, 0x60, 0x98, 0xb4, 0xf4,
-  0x8d, 0x6f, 0x71, 0xf4, 0x69, 0xfd, 0x84, 0x88, 0x02, 0x0a, 0xe8, 0xd1,
-  0x19, 0x87, 0x9e, 0xdb, 0xbe, 0xd9, 0x57, 0x74, 0x52, 0x0a, 0x77, 0x54,
-  0x26, 0xe9, 0x35, 0xa9, 0x81, 0xc2, 0x19, 0x58, 0x35, 0x36, 0x7d, 0x18,
-  0xe7, 0xf8, 0x26, 0x1b, 0xe3, 0xda, 0x48, 0xcb, 0x22, 0x99, 0x4e, 0xba,
-  0xb5, 0xe6, 0xf8, 0xda, 0x5d, 0xf2, 0x25, 0x0e, 0x79, 0xbf, 0x80, 0x26,
-  0x34, 0xe2, 0xb6, 0xe6, 0x89, 0x32, 0x84, 0x19, 0xd6, 0x16, 0xfa, 0x54,
-  0x34, 0x9a, 0xc6, 0xe9, 0xac, 0xc0, 0x11, 0x51, 0x55, 0xa1, 0xa8, 0xd3,
-  0xce, 0x95, 0x8a, 0x02, 0x4c, 0x36, 0x43, 0x08, 0x23, 0x79, 0x01, 0x71,
-  0x03, 0x1b, 0x16, 0x1b, 0x5b, 0xe6, 0x4e, 0x49, 0xf8, 0x1e, 0xdd, 0x32,
-  0x61, 0x72, 0x27, 0xc2, 0xca, 0x7a, 0xb5, 0xe6, 0x64, 0x5b, 0x0a, 0xac,
-  0xe7, 0x12, 0x3a, 0xd7, 0x78, 0x39, 0xe2, 0x96, 0xe6, 0x74, 0x5a, 0xe9,
-  0xca, 0x25, 0xce, 0x5e, 0xb2, 0xe1, 0x81, 0x49, 0xa5, 0x47, 0x74, 0xb1,
-  0xe8, 0xbb, 0x21, 0x60, 0x39, 0x6b, 0xcd, 0x05, 0xbc, 0xae, 0x50, 0x91,
-  0x29, 0x36, 0xd9, 0x64, 0xd4, 0xbe, 0x72, 0x74, 0xfd, 0xdd, 0xdf, 0xa4,
-  0xa4, 0xd2, 0x84, 0x57, 0xad, 0x89, 0x17, 0x34, 0x0e, 0xba, 0x66, 0x99,
-  0xb0, 0x7a, 0x3d, 0x92, 0x3a, 0xd3, 0x11, 0x71, 0xcc, 0xde, 0x38, 0x25,
-  0xe9, 0xbe, 0xc4, 0x6f, 0xf3, 0x72, 0x3a, 0xeb, 0xf2, 0x6c, 0xe9, 0xf7,
-  0xe4, 0x3a, 0x23, 0x05, 0xa3, 0x6c, 0xd2, 0xd4, 0x19, 0xd6, 0x57, 0x6e,
-  0x00, 0xbd, 0x70, 0xdc, 0xde, 0xdb, 0xf5, 0x41, 0xf7, 0x0e, 0xc9, 0x4a,
-  0x50, 0xcb, 0xc7, 0x7a, 0xeb, 0xa3, 0x63, 0xe1, 0x9f, 0x45, 0xad, 0x39,
-  0x96, 0xfc, 0x8a, 0x92, 0x74, 0xc5, 0xae, 0x0a, 0x16, 0xb4, 0x5f, 0xb3,
-  0x78, 0xc5, 0xab, 0x4f, 0x37, 0x98, 0xbb, 0x2e, 0x86, 0xe0, 0x53, 0xc4,
-  0x20, 0x98, 0x6f, 0x09, 0x21, 0x60, 0x01, 0xea, 0xfc, 0x16, 0xda, 0xd4,
-  0x34, 0xc5, 0x83, 0xb3, 0x25, 0xed, 0x1d, 0xbd, 0xc5, 0xac, 0x8c, 0xa5,
-  0xd6, 0x7b, 0xda, 0x12, 0xc7, 0x5d, 0xf9, 0x9a, 0x2d, 0x6e, 0xf8, 0xf6,
-  0x8f, 0x73, 0x08, 0x03, 0xf7, 0xcd, 0xe6, 0x64, 0xcc, 0x98, 0x64, 0x38,
-  0x4e, 0xbc, 0xae, 0x97, 0xa1, 0xbf, 0x04, 0xf9, 0xd8, 0x80, 0xe7, 0x7c,
-  0x28, 0x03, 0x36, 0x7d, 0x14, 0xe2, 0x56, 0x21, 0x8d, 0x4e, 0xb2, 0xe9,
-  0x34, 0xbb, 0xe7, 0x7b, 0x20, 0x1b, 0x11, 0x5d, 0xe7, 0xac, 0xec, 0xd6,
-  0x19, 0x30, 0x8c, 0x33, 0x73, 0x12, 0x99, 0x52, 0x58, 0xa4, 0xf0, 0x44,
-  0x70, 0x0c, 0x87, 0xc4, 0x1d, 0xc4, 0x54, 0x14, 0xbd, 0x84, 0x3e, 0xf0,
-  0x0a, 0xcb, 0xb7, 0x86, 0x03, 0x47, 0x17, 0xa4, 0x0c, 0x70, 0xbf, 0xe1,
-  0x95, 0x1c, 0xb0, 0x5a, 0x5c, 0xf5, 0xb1, 0x5a, 0x9e, 0xfa, 0x2a, 0x1e,
-  0xd0, 0x51, 0x0a, 0x6e, 0x78, 0xd3, 0x43, 0x32, 0x9a, 0xd0, 0x74, 0xe5,
-  0xdb, 0xa2, 0xeb, 0xfb, 0x2e, 0xcd, 0x96, 0xc5, 0x14, 0xfb, 0x38, 0x4a,
-  0x48, 0x7b, 0x1e, 0x07, 0x32, 0xbe, 0x34, 0xce, 0xaa, 0x6c, 0xd4, 0x19,
-  0x24, 0x65, 0xfd, 0x1c, 0x1d, 0x72, 0x8f, 0x2f, 0x3a, 0x91, 0x2a, 0xc4,
-  0x6c, 0xff, 0xe1, 0x76, 0x75, 0xbf, 0x68, 0x57, 0x55, 0xe3, 0x9d, 0x40,
-  0x5a, 0x2e, 0xa3, 0x0e, 0x6c, 0xa0, 0x7b, 0xaf, 0xbe, 0x3e, 0x38, 0x7d,
-  0x7b, 0xbc, 0xf7, 0xc7, 0x3a, 0xc5, 0xd2, 0x77, 0xfb, 0xf2, 0xdd, 0x7e,
-  0xa7, 0x6d, 0x77, 0x68, 0x31, 0x89, 0xa5, 0xbd, 0xa2, 0xff, 0x54, 0x69,
-  0x75, 0x7b, 0xa4, 0xbd, 0x60, 0x18, 0x5d, 0x95, 0x47, 0x4b, 0xb9, 0x66,
-  0xb1, 0x36, 0x18, 0x3f, 0x2e, 0xe9, 0xe6, 0x82, 0xb0, 0xea, 0xc6, 0x97,
-  0x3f, 0x33, 0x2b, 0x10, 0x5f, 0x3c, 0x0e, 0x57, 0xa5, 0x28, 0x33, 0x88,
-  0xe3, 0xba, 0x55, 0x68, 0x5f, 0x94, 0xa0, 0xae, 0x9c, 0xdf, 0xfa, 0x1d,
-  0xe2, 0xa6, 0xed, 0x47, 0xc5, 0xac, 0xbc, 0x28, 0x98, 0xa2, 0x98, 0xa2,
-  0x57, 0x44, 0x19, 0xe5, 0xe8, 0xa6, 0x4f, 0xb7, 0xa9, 0x30, 0x2a, 0xf0,
-  0x7d, 0x61, 0x0b, 0x75, 0x2e, 0x8a, 0x9b, 0x26, 0x82, 0x95, 0xf3, 0x8e,
-  0xa6, 0x52, 0xc8, 0xa9, 0xe9, 0xe8, 0x58, 0x48, 0x63, 0xa1, 0x0d, 0xea,
-  0x28, 0x1f, 0x61, 0xaa, 0x66, 0x8a, 0x63, 0xe6, 0x8d, 0x93, 0x9d, 0x37,
-  0xf9, 0x14, 0x1d, 0x77, 0x74, 0xa9, 0x36, 0x4a, 0x58, 0x89, 0x75, 0x1e,
-  0x7c, 0x92, 0x69, 0xd8, 0x50, 0xcf, 0x56, 0xca, 0x0b, 0x68, 0x99, 0xf3,
-  0x44, 0x59, 0x87, 0xe8, 0x62, 0xf5, 0x53, 0x47, 0xcd, 0x0d, 0x49, 0x2a,
-  0xe4, 0xd3, 0xe2, 0x2f, 0x42, 0xa2, 0xee, 0x53, 0xa2, 0xee, 0x69, 0xa6,
-  0x1c, 0x4f, 0x8e, 0x13, 0x9b, 0x4b, 0x44, 0xaa, 0x52, 0x5a, 0xc8, 0x26,
-  0x2d, 0x3c, 0x41, 0x54, 0x52, 0xdd, 0x07, 0x1b, 0xa7, 0x9c, 0x69, 0xb7,
-  0xb6, 0xa4, 0xc7, 0xe0, 0x5e, 0x17, 0xb5, 0x5d, 0x79, 0x39, 0x2c, 0x6f,
-  0x2d, 0xcd, 0x9d, 0x25, 0x65, 0x31, 0x8a, 0x17, 0xc9, 0x8e, 0xca, 0x0a,
-  0xb6, 0x91, 0xc1, 0x38, 0x9a, 0x8c, 0xf3, 0xfc, 0xea, 0xd8, 0x18, 0x27,
-  0x4f, 0x87, 0x1f, 0xf6, 0xba, 0xa6, 0x30, 0xe6, 0xe0, 0x00, 0x9b, 0x8e,
-  0xca, 0x7b, 0x1e, 0x17, 0x8d, 0x55, 0x27, 0xe9, 0xbf, 0x0f, 0x23, 0x99,
-  0x4d, 0xc7, 0x2e, 0x6e, 0xa5, 0x2d, 0x3b, 0x21, 0xd4, 0x4b, 0x1f, 0x42,
-  0x0c, 0x7f, 0x1c, 0x39, 0x43, 0x72, 0x9d, 0xd3, 0x15, 0x89, 0xad, 0xf2,
-  0xc8, 0x0d, 0xa1, 0xf7, 0xd7, 0xd8, 0x4b, 0x19, 0x6a, 0x81, 0xe4, 0xd5,
-  0x22, 0xd6, 0x35, 0x27, 0x0d, 0xe1, 0x2e, 0x71, 0x2c, 0xa3, 0xfd, 0x2a,
-  0xf4, 0xda, 0x89, 0xdd, 0x15, 0x47, 0xd4, 0xf8, 0x78, 0x39, 0x5b, 0xa8,
-  0x0c, 0xf3, 0x9b, 0xf7, 0x33, 0xcb, 0x0f, 0x13, 0x58, 0x58, 0x72, 0xfa,
-  0x69, 0x22, 0xcb, 0xe7, 0x22, 0xb4, 0xf6, 0xe2, 0x62, 0x94, 0xa6, 0xb5,
-  0xf7, 0x8e, 0xe7, 0x7c, 0x6d, 0x44, 0x07, 0x83, 0xc3, 0x93, 0x13, 0xaf,
-  0x2f, 0xdf, 0x8b, 0x5e, 0x80, 0x99, 0x40, 0x25, 0xa0, 0x35, 0x81, 0xdb,
-  0x41, 0x6c, 0x33, 0xec, 0x9c, 0x28, 0x55, 0x9a, 0x6b, 0x3b, 0x71, 0x34,
-  0xc2, 0x64, 0x4e, 0xc4, 0x31, 0x4a, 0xc6, 0xde, 0x3e, 0x4b, 0x53, 0x82,
-  0x89, 0x8a, 0xc9, 0x82, 0x6e, 0xcc, 0x42, 0xcd, 0x36, 0x7f, 0x2c, 0x57,
-  0x8b, 0xe4, 0xd5, 0x01, 0xcb, 0x9f, 0xd4, 0x64, 0x7d, 0x56, 0xb2, 0x38,
-  0xd4, 0x11, 0x8d, 0xbf, 0x50, 0x95, 0x58, 0x6e, 0x47, 0xec, 0xf3, 0x58,
-  0x35, 0x66, 0x65, 0x93, 0x30, 0x75, 0xb2, 0xd4, 0x0e, 0x45, 0x8e, 0x6e,
-  0x97, 0x27, 0xfb, 0x75, 0xf6, 0xb2, 0x22, 0x41, 0x63, 0x56, 0xfc, 0x82,
-  0x9a, 0x83, 0xac, 0x5b, 0x83, 0xc4, 0x48, 0x2d, 0x08, 0x45, 0x46, 0x96,
-  0x41, 0xd6, 0xdc, 0x4d, 0x55, 0x89, 0x11, 0xd4, 0xc9, 0xe7, 0xf2, 0x73,
-  0xbc, 0x52, 0x93, 0x7d, 0xbc, 0x10, 0xd5, 0xdc, 0x7f, 0x33, 0xc8, 0xc5,
-  0x2c, 0x9b, 0xd7, 0xe6, 0xb2, 0x64, 0x3b, 0xcb, 0x82, 0xc4, 0xbd, 0x72,
-  0x4a, 0xac, 0x94, 0x14, 0xe8, 0x39, 0x7e, 0x32, 0x9d, 0xf3, 0x79, 0x48,
-  0xcb, 0x16, 0x75, 0x0e, 0xea, 0x5a, 0x9e, 0x42, 0x1b, 0x88, 0xa3, 0x90,
-  0xa5, 0x8b, 0xdc, 0x6e, 0x5b, 0x23, 0xe7, 0x1c, 0x8e, 0x00, 0x7a, 0xcc,
-  0xae, 0xea, 0x7a, 0x73, 0xed, 0xd2, 0xef, 0x56, 0xb1, 0x24, 0xce, 0x49,
-  0xf7, 0x8b, 0x89, 0x64, 0x4e, 0x4a, 0x53, 0x01, 0xd8, 0xc4, 0xb3, 0xe6,
-  0xbd, 0x43, 0xec, 0x7c, 0x7b, 0xbd, 0x16, 0xf0, 0x53, 0x04, 0x90, 0x9f,
-  0x29, 0x7f, 0xf4, 0x46, 0xe9, 0xe2, 0x06, 0x07, 0xff, 0xe5, 0x34, 0x2d,
-  0xd8, 0xf8, 0xa4, 0x1f, 0x34, 0x64, 0x90, 0xc1, 0xe0, 0xd4, 0x94, 0x40,
-  0x66, 0x5e, 0x7c, 0x5d, 0xd8, 0xdb, 0xba, 0xe5, 0xa9, 0x99, 0xc7, 0xcd,
-  0xd0, 0x28, 0xdc, 0x1e, 0x4d, 0xd7, 0x4f, 0x04, 0xcd, 0xd1, 0x5e, 0x16,
-  0xc9, 0x4f, 0x6e, 0x4b, 0x4c, 0xe5, 0x2e, 0x9e, 0xa6, 0x63, 0xfb, 0xb6,
-  0x1f, 0x5d, 0xe2, 0x0a, 0x58, 0x2e, 0x60, 0xdb, 0x63, 0x2f, 0x1b, 0x7f,
-  0x5e, 0x6b, 0x8e, 0x07, 0x1f, 0x10, 0x11, 0xfb, 0xa4, 0x2a, 0x6c, 0xa5,
-  0x72, 0x21, 0xa4, 0xe1, 0x77, 0x74, 0x9c, 0x5f, 0xd4, 0xb9, 0xa1, 0xb7,
-  0x62, 0x93, 0xc0, 0x38, 0x2f, 0x8a, 0x29, 0x3b, 0x16, 0xc6, 0xd9, 0xa8,
-  0xd8, 0x21, 0x25, 0xbb, 0xd8, 0xb1, 0xc1, 0x55, 0x5c, 0x08, 0x76, 0x6f,
-  0x0c, 0x06, 0xc1, 0xdc, 0x62, 0xf0, 0x70, 0xd6, 0x57, 0x1c, 0x51, 0xb1,
-  0xe0, 0x45, 0x7c, 0xe4, 0x9c, 0x9a, 0xc6, 0x8c, 0x40, 0x23, 0x5f, 0xcc,
-  0x97, 0x57, 0xa7, 0x03, 0x5e, 0xae, 0xba, 0xc0, 0xbd, 0xa4, 0x73, 0x6a,
-  0x9b, 0x83, 0xb6, 0xad, 0x69, 0xbe, 0x89, 0xe5, 0x76, 0x1b, 0x0c, 0x0e,
-  0xf9, 0xc3, 0xc1, 0x12, 0x7a, 0x14, 0x75, 0x91, 0xaf, 0x22, 0xb9, 0xb6,
-  0x1a, 0xac, 0x08, 0xb3, 0xb5, 0xf9, 0x89, 0xc5, 0x29, 0xcb, 0x57, 0xfd,
-  0x49, 0x32, 0xce, 0xf2, 0xb8, 0x4f, 0xd7, 0x10, 0x1d, 0x03, 0xb6, 0xd8,
-  0xf3, 0x5c, 0x89, 0x0b, 0xbd, 0xa3, 0xd9, 0xf3, 0x34, 0x3f, 0x3a, 0xc2,
-  0xd3, 0x4d, 0x12, 0x26, 0xa1, 0x84, 0x48, 0xee, 0x67, 0x8b, 0xd0, 0xd5,
-  0x5b, 0xc1, 0xce, 0x6a, 0xcb, 0x15, 0xce, 0x46, 0xc0, 0xa2, 0x42, 0xba,
-  0xd9, 0x6c, 0x01, 0x53, 0x53, 0x43, 0x11, 0x53, 0x9e, 0x74, 0x69, 0xfa,
-  0x60, 0xe4, 0x9f, 0xf4, 0x66, 0xad, 0xba, 0xbf, 0x9b, 0x78, 0xfe, 0x75,
-  0x96, 0x13, 0x33, 0x9f, 0x15, 0x0d, 0xe2, 0x12, 0x4f, 0xa9, 0x69, 0xa5,
-  0x5d, 0xb5, 0x26, 0x96, 0xcb, 0x5c, 0xd6, 0x7f, 0x39, 0x0f, 0x3a, 0xa0,
-  0x85, 0x5b, 0xce, 0xd8, 0xbf, 0x69, 0xab, 0xb0, 0xe6, 0x32, 0x00, 0x11,
-  0x8a, 0x15, 0xda, 0x94, 0x23, 0x93, 0xb4, 0x0b, 0xbe, 0x58, 0xe0, 0x0d,
-  0x9b, 0x7b, 0xa7, 0x19, 0x9b, 0x34, 0x60, 0xbc, 0xa8, 0x0b, 0xdf, 0xce,
-  0xe2, 0x9f, 0x27, 0x78, 0x94, 0xd5, 0xd7, 0x3c, 0xcf, 0xf2, 0x9f, 0xa9,
-  0xd7, 0x88, 0x87, 0xcd, 0x71, 0x13, 0xbd, 0xad, 0xcb, 0xec, 0xba, 0xb9,
-  0xf5, 0xb0, 0x8d, 0xa4, 0xd8, 0xbd, 0x9d, 0x6c, 0x32, 0xa9, 0xee, 0x0c,
-  0x33, 0x80, 0x1e, 0x9a, 0xc4, 0xdd, 0xf6, 0x52, 0xee, 0x9d, 0x06, 0x53,
-  0x79, 0x13, 0x3f, 0xa4, 0xb3, 0xe5, 0x2c, 0x12, 0x13, 0x36, 0x5b, 0x69,
-  0xf4, 0xc9, 0xc0, 0x67, 0x15, 0x83, 0xc5, 0xd5, 0xf8, 0x8a, 0x2a, 0x3f,
-  0xf5, 0x7b, 0x51, 0x96, 0x0f, 0xdf, 0x11, 0xcf, 0xd3, 0xab, 0x58, 0x64,
-  0xb2, 0x69, 0x3a, 0x4b, 0x4b, 0x95, 0x9c, 0xc3, 0x76, 0xa2, 0xc5, 0x4d,
-  0x5c, 0xd0, 0xe5, 0xc8, 0x72, 0x4a, 0x5d, 0xac, 0x65, 0x83, 0xf9, 0x0d,
-  0x14, 0x07, 0x7d, 0x23, 0x69, 0x5c, 0x4a, 0x19, 0x6b, 0x23, 0x2c, 0xee,
-  0xd0, 0x62, 0xb2, 0xa3, 0x5c, 0x84, 0x87, 0x16, 0x4b, 0xd0, 0x8c, 0xe4,
-  0x97, 0x59, 0xfc, 0xc0, 0xab, 0x62, 0xd2, 0xf0, 0x2f, 0x75, 0x70, 0x54,
-  0xd5, 0x08, 0x36, 0xa1, 0x26, 0x15, 0xbe, 0x64, 0xa1, 0x0e, 0x7a, 0x4e,
-  0x7d, 0x13, 0x9c, 0x61, 0x2f, 0x53, 0xa6, 0xce, 0x4f, 0x3a, 0x93, 0xb8,
-  0x5d, 0xe9, 0x62, 0xcd, 0x47, 0x9c, 0x80, 0xc9, 0xaf, 0xf1, 0x84, 0x2d,
-  0xeb, 0x4d, 0x65, 0x60, 0x41, 0x5a, 0x59, 0x12, 0xe8, 0xda, 0x7d, 0x25,
-  0x52, 0xb4, 0x50, 0x48, 0xac, 0x81, 0x6b, 0xa4, 0x72, 0x23, 0x43, 0xda,
-  0x6f, 0xb3, 0x37, 0xe0, 0xe6, 0xf6, 0x82, 0xb7, 0xda, 0x64, 0xb1, 0x2f,
-  0xf7, 0xb0, 0xe8, 0xb2, 0xda, 0x1b, 0x8c, 0xab, 0xa2, 0xc1, 0xd6, 0x9a,
-  0x33, 0x7b, 0x13, 0x53, 0xca, 0x56, 0xb1, 0xdd, 0x57, 0x7d, 0xd2, 0xcd,
-  0x89, 0x36, 0xf2, 0x76, 0x9e, 0xdd, 0xcf, 0xbb, 0xf8, 0x94, 0x3b, 0xb2,
-  0xf5, 0xc5, 0xf0, 0x5b, 0xd8, 0x5f, 0x32, 0x57, 0x85, 0x57, 0x87, 0xe5,
-  0xa4, 0x5b, 0x3c, 0x5f, 0x3a, 0xf1, 0x33, 0xd4, 0x42, 0x42, 0xed, 0xa3,
-  0x3e, 0x5d, 0xd1, 0x45, 0xcc, 0xac, 0x0e, 0x11, 0xc5, 0xa9, 0x43, 0xac,
-  0xa4, 0xb2, 0xe5, 0x3a, 0x32, 0xcb, 0x24, 0x49, 0x92, 0xc5, 0x0d, 0x51,
-  0x6f, 0xa7, 0xd7, 0xe9, 0xb6, 0x89, 0xd3, 0x75, 0x55, 0xc3, 0xc6, 0xe4,
-  0xc4, 0xce, 0x76, 0xad, 0x47, 0x4d, 0x2e, 0x3a, 0x4c, 0x90, 0x0f, 0x89,
-  0xc8, 0x6c, 0x85, 0xf5, 0x76, 0x6b, 0x08, 0xd3, 0xbe, 0x39, 0xa1, 0xc9,
-  0xfb, 0x9b, 0x6c, 0xda, 0x7a, 0x8a, 0x02, 0xb3, 0x4b, 0x26, 0x0d, 0xb1,
-  0xb5, 0x17, 0x1e, 0x52, 0x68, 0x26, 0x35, 0xce, 0x15, 0x8d, 0xa6, 0x49,
-  0x9c, 0x4f, 0x57, 0xaa, 0x1a, 0xd7, 0xcf, 0xd1, 0x9d, 0x2d, 0x32, 0x1b,
-  0xe8, 0x63, 0x22, 0xd3, 0x7c, 0x8e, 0x25, 0x56, 0xd7, 0x56, 0x32, 0x96,
-  0x90, 0x02, 0x66, 0x20, 0x22, 0x64, 0x0a, 0x0f, 0xb8, 0x4b, 0x8b, 0x74,
-  0xd8, 0x5c, 0xf1, 0x24, 0x19, 0x0f, 0xe3, 0xd1, 0x2d, 0xaf, 0x37, 0x5a,
-  0x54, 0x07, 0x16, 0x4e, 0xe1, 0x22, 0x2b, 0xf0, 0xca, 0x0a, 0x66, 0x86,
-  0x1b, 0x3a, 0x7e, 0x45, 0x5a, 0x2e, 0xe3, 0x7f, 0xf2, 0xdc, 0xca, 0xc1,
-  0xad, 0x93, 0x73, 0x9b, 0x3d, 0x62, 0xcd, 0xc1, 0x3e, 0xe4, 0x83, 0x4d,
-  0x52, 0xe8, 0x7c, 0x49, 0xba, 0x10, 0x31, 0x57, 0x62, 0xbe, 0x44, 0x27,
-  0x9f, 0x35, 0x8c, 0x32, 0xf2, 0xc8, 0xce, 0xa5, 0xc4, 0x19, 0x85, 0xd2,
-  0x6f, 0x54, 0x75, 0xf9, 0x5a, 0x40, 0xc6, 0x75, 0x8a, 0xcd, 0x90, 0xe6,
-  0x9a, 0xa6, 0xd7, 0xea, 0xf7, 0xb6, 0xb2, 0xc9, 0x43, 0x0c, 0x5f, 0x97,
-  0x86, 0x11, 0xb0, 0x5c, 0x37, 0x5c, 0xa9, 0x91, 0x22, 0x2e, 0xfd, 0x71,
-  0xa8, 0xb3, 0xea, 0xdb, 0x74, 0xb1, 0xc0, 0xe4, 0x25, 0x7a, 0x21, 0xb0,
-  0x36, 0x0d, 0x93, 0xeb, 0x74, 0x3e, 0x0f, 0x83, 0x48, 0xb2, 0x25, 0xa9,
-  0x60, 0x32, 0xe2, 0x61, 0x32, 0x01, 0xab, 0x6d, 0xc8, 0xf9, 0x6c, 0xe7,
-  0x91, 0xc9, 0xe4, 0x89, 0xf3, 0x42, 0x8c, 0x39, 0x1a, 0x45, 0x59, 0x10,
-  0xb6, 0x48, 0xae, 0x5b, 0xb1, 0x50, 0xa8, 0x79, 0xb3, 0xf5, 0xd8, 0x20,
-  0xc8, 0x4b, 0x2f, 0x13, 0xf3, 0x22, 0x0f, 0x4e, 0xfe, 0xcb, 0xb1, 0xf7,
-  0x70, 0x9b, 0x65, 0x87, 0xd4, 0x42, 0xd0, 0x77, 0x83, 0x1c, 0xde, 0x42,
-  0x1b, 0xe9, 0xf4, 0x0e, 0x69, 0xbb, 0x3a, 0x3c, 0x9a, 0xd0, 0xf3, 0x44,
-  0x5a, 0x44, 0x46, 0x87, 0x1c, 0xf1, 0x14, 0xd3, 0x95, 0x04, 0x3f, 0x81,
-  0xe2, 0x48, 0x57, 0xcd, 0x93, 0x9d, 0x1b, 0xdc, 0x75, 0x59, 0x83, 0x6b,
-  0xf1, 0x16, 0xb2, 0x07, 0x4e, 0xa7, 0xc9, 0xf6, 0xbd, 0x52, 0xdd, 0x5e,
-  0x45, 0xb0, 0x7d, 0xea, 0x67, 0xdc, 0x61, 0x7b, 0x83, 0x7a, 0xc8, 0x9b,
-  0x5a, 0x91, 0x9a, 0xf4, 0xc5, 0x31, 0xd8, 0xc2, 0x06, 0x7e, 0xb9, 0x7b,
-  0xa8, 0x27, 0xfc, 0x82, 0x34, 0xa2, 0xbc, 0x3e, 0x8e, 0x8a, 0xd7, 0x8e,
-  0x48, 0xfa, 0xaf, 0x24, 0x48, 0xa9, 0x6d, 0x96, 0x76, 0x08, 0x8d, 0xf7,
-  0x32, 0x1d, 0x41, 0xd7, 0xae, 0x63, 0xa1, 0x27, 0x69, 0xb3, 0x45, 0x4a,
-  0x44, 0x80, 0x01, 0xc9, 0x61, 0x31, 0x22, 0x37, 0x60, 0x79, 0x82, 0x8a,
-  0xab, 0x42, 0x6e, 0x74, 0x93, 0xd2, 0xd8, 0xf3, 0xd1, 0xcd, 0x0a, 0x17,
-  0x06, 0xcc, 0xc9, 0x88, 0x33, 0xb8, 0xf2, 0xb3, 0xac, 0x33, 0x2e, 0xee,
-  0x43, 0x0d, 0xae, 0x34, 0xf8, 0x08, 0x52, 0x1d, 0x3d, 0x66, 0xa6, 0x9f,
-  0xda, 0xf8, 0x88, 0x2c, 0x6e, 0x40, 0xb5, 0xc9, 0x14, 0x72, 0x00, 0x2d,
-  0x60, 0xdb, 0xe8, 0x7a, 0x59, 0xc0, 0xca, 0x79, 0xe3, 0x58, 0x31, 0xe3,
-  0xf8, 0x1b, 0xb1, 0x0a, 0x4a, 0x57, 0xb0, 0xa9, 0x4b, 0x6f, 0xb8, 0xda,
-  0x70, 0x2d, 0xae, 0x6a, 0xcd, 0xa9, 0x3f, 0x51, 0x5f, 0x7f, 0x9f, 0x4f,
-  0xf1, 0x2a, 0xd3, 0xaf, 0xec, 0x02, 0xb4, 0x55, 0x11, 0x55, 0xae, 0x6e,
-  0x24, 0x91, 0xf8, 0x4d, 0x0e, 0x7f, 0xe9, 0xf5, 0xe8, 0x30, 0xf4, 0x5a,
-  0x97, 0x86, 0xb7, 0xb4, 0xba, 0xd3, 0xd3, 0x89, 0x3a, 0x64, 0x89, 0xfb,
-  0x10, 0xa5, 0x94, 0xd1, 0xe9, 0x6b, 0x50, 0xdb, 0xe1, 0x25, 0xfd, 0xa4,
-  0x3d, 0x96, 0x33, 0x07, 0xb6, 0xce, 0x71, 0x98, 0xb0, 0x6f, 0xbc, 0xf9,
-  0x7a, 0x10, 0x6d, 0x9d, 0x0f, 0x76, 0x9e, 0x3c, 0xdf, 0xfd, 0xf7, 0x6a,
-  0xc2, 0x63, 0x18, 0xba, 0x60, 0x97, 0x79, 0xf9, 0x88, 0x09, 0x7e, 0xc0,
-  0x92, 0x79, 0x35, 0x74, 0x8b, 0x5f, 0x62, 0xe3, 0x38, 0xc7, 0x08, 0x98,
-  0x17, 0xca, 0xbb, 0x92, 0x5b, 0xcc, 0x6d, 0x16, 0x74, 0xcb, 0x22, 0x2f,
-  0x6e, 0xb0, 0x95, 0x1c, 0x45, 0xf8, 0x7c, 0x92, 0xd9, 0x12, 0xe1, 0x97,
-  0x1c, 0x06, 0x38, 0xa1, 0x2f, 0x39, 0x24, 0x15, 0x52, 0x28, 0x51, 0xce,
-  0x54, 0x3d, 0xdc, 0xb5, 0xe6, 0xbe, 0xbc, 0x7a, 0x73, 0xca, 0xa2, 0x03,
-  0xab, 0x12, 0xa6, 0x89, 0xf0, 0x30, 0x97, 0x43, 0x12, 0x7c, 0x71, 0x1f,
-  0x96, 0x60, 0x82, 0xec, 0x0c, 0xe2, 0x9e, 0x78, 0x64, 0x12, 0x9a, 0xd1,
-  0xd0, 0x50, 0xd8, 0x32, 0x25, 0x9c, 0x1d, 0x52, 0x19, 0x04, 0xad, 0xe0,
-  0xba, 0x62, 0xe2, 0xa7, 0x55, 0x14, 0x1f, 0xd9, 0x22, 0xcf, 0x70, 0xe0,
-  0xb0, 0xf0, 0x12, 0x48, 0x18, 0xfb, 0xb0, 0x54, 0x17, 0xf3, 0x73, 0x2f,
-  0x06, 0xf3, 0xd1, 0x12, 0x4a, 0xec, 0x64, 0x3b, 0xf4, 0x10, 0xd0, 0x96,
-  0x26, 0x0f, 0x0b, 0x91, 0xad, 0x79, 0xc9, 0x60, 0x17, 0xec, 0xd0, 0x51,
-  0xef, 0x89, 0x0f, 0x77, 0xdc, 0x69, 0x75, 0x02, 0x1a, 0x1f, 0x88, 0xd9,
-  0xee, 0x63, 0x9c, 0x75, 0xd1, 0xe6, 0x20, 0x51, 0x46, 0xee, 0xc4, 0xb0,
-  0x86, 0x88, 0x44, 0xf7, 0xcf, 0x9c, 0x74, 0x95, 0x15, 0x09, 0x66, 0x1c,
-  0x15, 0x30, 0x55, 0xfb, 0xce, 0xce, 0x43, 0xef, 0xfe, 0xfe, 0xbe, 0x87,
-  0x75, 0xed, 0x51, 0x07, 0x3a, 0x9e, 0x3e, 0xdf, 0xad, 0xb3, 0x05, 0x2b,
-  0xf6, 0x4d, 0x56, 0xdd, 0x7b, 0x4d, 0x74, 0x84, 0x57, 0xfa, 0x2d, 0xee,
-  0x5c, 0x47, 0xc0, 0x55, 0xfb, 0xa8, 0x85, 0x15, 0x22, 0x84, 0xa3, 0x29,
-  0x4d, 0xbb, 0x20, 0xa6, 0x6e, 0xe0, 0xaf, 0x49, 0xc1, 0xe6, 0x2a, 0xc6,
-  0x68, 0x61, 0x00, 0xb3, 0x24, 0xbf, 0x96, 0x95, 0x24, 0x51, 0xa6, 0x69,
-  0x27, 0x91, 0xab, 0x2f, 0x76, 0x91, 0x4e, 0xec, 0xba, 0xfa, 0x5d, 0x4f,
-  0xbc, 0x28, 0xbc, 0x2d, 0x4b, 0xdc, 0x88, 0xb2, 0x56, 0x70, 0xb2, 0xf4,
-  0xc6, 0x91, 0xba, 0xa5, 0xe6, 0x69, 0x32, 0xa5, 0x53, 0xd2, 0xbc, 0xc7,
-  0xa7, 0xd3, 0x57, 0x53, 0x92, 0x29, 0x56, 0x70, 0xc7, 0x68, 0x74, 0x0e,
-  0xc9, 0x51, 0xf3, 0x84, 0x03, 0xa9, 0x58, 0xea, 0x80, 0xdf, 0x37, 0x1a,
-  0xdd, 0x2c, 0xe7, 0xb7, 0x26, 0x15, 0x4c, 0x49, 0xb2, 0x2c, 0x22, 0x8e,
-  0xc0, 0xae, 0x35, 0x48, 0xad, 0x04, 0x1d, 0xfe, 0xae, 0xda, 0x7e, 0x2b,
-  0x83, 0x90, 0xf8, 0x41, 0x44, 0xd1, 0x45, 0x7e, 0x81, 0x1c, 0x87, 0x56,
-  0x07, 0xd1, 0x9f, 0xbb, 0xe6, 0x09, 0x2e, 0x03, 0x0f, 0x42, 0xfd, 0x1c,
-  0x55, 0xc4, 0x6c, 0x76, 0x3d, 0xb8, 0x06, 0xc5, 0xd9, 0x43, 0x0c, 0xab,
-  0x67, 0x2e, 0x52, 0xaf, 0x1d, 0x31, 0xdd, 0xb6, 0xe8, 0x2e, 0xc1, 0x19,
-  0xf3, 0xee, 0x48, 0x17, 0xe8, 0xce, 0x64, 0x57, 0x98, 0x94, 0xc3, 0x5d,
-  0xb3, 0x21, 0x4c, 0xf9, 0x7d, 0x53, 0x66, 0x0a, 0x0e, 0x45, 0x3f, 0x7a,
-  0x13, 0x06, 0xef, 0x55, 0x03, 0x12, 0x1c, 0x55, 0xf4, 0xa3, 0x8b, 0x4c,
-  0xe2, 0x71, 0x79, 0x14, 0x6b, 0x34, 0x2b, 0x37, 0xe9, 0x31, 0x16, 0x7f,
-  0x92, 0x65, 0xc3, 0x38, 0xc7, 0x5e, 0xca, 0x56, 0xb2, 0x6b, 0x9c, 0x1a,
-  0x1d, 0xcb, 0x15, 0xcf, 0xbe, 0x68, 0x9e, 0xd2, 0x9f, 0xe9, 0xc9, 0xa6,
-  0x3a, 0x84, 0xa0, 0x9f, 0xb6, 0xdb, 0x87, 0x69, 0x40, 0x48, 0x97, 0xe4,
-  0x0e, 0xe2, 0x2a, 0x70, 0x18, 0xe5, 0x2b, 0x89, 0xa0, 0xd2, 0x0d, 0x31,
-  0xff, 0x79, 0xe0, 0xda, 0xe0, 0xae, 0xea, 0xb7, 0x8f, 0xbc, 0xba, 0x4e,
-  0x83, 0xf6, 0x8c, 0x5c, 0x25, 0x54, 0x0e, 0x8c, 0x62, 0xeb, 0x2c, 0x37,
-  0xc6, 0xde, 0x83, 0xf7, 0x47, 0x5e, 0x78, 0xf3, 0x4c, 0xcb, 0x65, 0xc3,
-  0x21, 0xc9, 0xfe, 0xc6, 0x69, 0x11, 0x20, 0x39, 0x30, 0x41, 0xe2, 0x30,
-  0x39, 0x28, 0xa7, 0x16, 0x73, 0x16, 0x8e, 0xe5, 0xd1, 0x0b, 0xc7, 0x2c,
-  0xe5, 0xbc, 0xbd, 0x69, 0x5c, 0xb8, 0x28, 0x5f, 0x3f, 0xcd, 0x7f, 0xca,
-  0x92, 0x20, 0xeb, 0xcc, 0xf3, 0x09, 0xbd, 0xd9, 0x3f, 0x7b, 0x46, 0xba,
-  0x37, 0xef, 0x9d, 0x12, 0xe8, 0xa1, 0x08, 0xae, 0x4e, 0x0d, 0x6e, 0xb3,
-  0xf8, 0xe8, 0xda, 0x76, 0x71, 0x1c, 0x55, 0x23, 0xb6, 0x64, 0x8a, 0x20,
-  0xe1, 0xeb, 0x9b, 0x50, 0x7e, 0x09, 0x67, 0xcc, 0xda, 0x09, 0xc9, 0x50,
-  0xb9, 0x1e, 0xb6, 0x87, 0xd2, 0xce, 0x1a, 0x3a, 0x6f, 0x18, 0x0d, 0xed,
-  0x2e, 0x8c, 0xa2, 0xdb, 0x64, 0x01, 0xbd, 0xb2, 0xe8, 0xa5, 0x45, 0xbf,
-  0x12, 0x1d, 0x58, 0x2a, 0x1d, 0xc7, 0x46, 0x82, 0x6a, 0x1f, 0xe0, 0x60,
-  0xe5, 0x96, 0xb3, 0x8f, 0x50, 0xa2, 0x45, 0xcf, 0x5d, 0x7f, 0x9a, 0x4e,
-  0x61, 0xa3, 0xa8, 0x4c, 0xd0, 0x49, 0xb9, 0x42, 0x84, 0x8d, 0x2b, 0x79,
-  0x22, 0xee, 0xbc, 0xff, 0x0d, 0xe8, 0x96, 0x1d, 0x1b, 0xed, 0x3b, 0x2b,
-  0x4e, 0xb8, 0x42, 0x3c, 0x3f, 0x47, 0xe2, 0x01, 0x59, 0xe7, 0xfa, 0x89,
-  0x83, 0x6f, 0xda, 0x8c, 0xca, 0xbc, 0x81, 0x1c, 0xc7, 0x0d, 0x0b, 0x41,
-  0xa9, 0xa1, 0xa1, 0x74, 0xbf, 0xdf, 0x67, 0xb9, 0x6a, 0x8b, 0xc3, 0x84,
-  0xc3, 0x27, 0x21, 0xac, 0x64, 0x6c, 0xf7, 0x83, 0x05, 0x02, 0xdb, 0xdd,
-  0x74, 0x50, 0xc3, 0x9e, 0xc0, 0x8e, 0x35, 0x96, 0x3d, 0xcd, 0x8d, 0x5d,
-  0x71, 0x5c, 0x07, 0x7e, 0x6b, 0x09, 0xe9, 0xa5, 0xd9, 0x2e, 0x35, 0x4c,
-  0xae, 0xdd, 0x82, 0xcb, 0x31, 0x6f, 0x92, 0x8e, 0x24, 0x97, 0x06, 0x0b,
-  0x5f, 0x3a, 0xc4, 0xc0, 0x14, 0x68, 0x6e, 0xa1, 0x47, 0xdd, 0x40, 0x1a,
-  0xc7, 0x63, 0x91, 0x39, 0xd8, 0x6f, 0x4b, 0xc3, 0xd1, 0xb4, 0xaf, 0x7f,
-  0x6b, 0x9c, 0x4a, 0x4f, 0x3d, 0x85, 0xbd, 0x64, 0x91, 0x97, 0xad, 0x21,
-  0x98, 0x57, 0xa1, 0x8a, 0x6b, 0x7e, 0x45, 0xb6, 0x8e, 0x17, 0x8e, 0xe4,
-  0x8f, 0x2f, 0x2e, 0xaf, 0x78, 0xa2, 0xa7, 0xf8, 0x45, 0x65, 0x9b, 0xfa,
-  0x38, 0xf8, 0x38, 0x6b, 0x4c, 0x17, 0x42, 0x1e, 0x12, 0xd6, 0x4a, 0x5c,
-  0x78, 0x7a, 0x3f, 0xb0, 0x78, 0xbb, 0xd8, 0xeb, 0x78, 0x7a, 0x8f, 0x98,
-  0x66, 0x26, 0xdf, 0xc6, 0xda, 0x4a, 0x1c, 0xbc, 0xf9, 0xa8, 0x30, 0x86,
-  0xae, 0x68, 0xce, 0x3c, 0x0a, 0x35, 0x29, 0x08, 0xff, 0xb8, 0x38, 0xc7,
-  0x97, 0xb0, 0x1e, 0xa9, 0x00, 0xb1, 0xc6, 0x7a, 0xef, 0x03, 0x39, 0xd1,
-  0x24, 0xde, 0x8a, 0x72, 0xce, 0x31, 0x88, 0x69, 0x1c, 0x7d, 0x3f, 0x4f,
-  0xe9, 0x42, 0x9c, 0x40, 0x44, 0x7d, 0x95, 0xa4, 0x32, 0x93, 0xa0, 0x58,
-  0xc9, 0x33, 0x61, 0x95, 0x34, 0xb2, 0x6b, 0x8e, 0xc4, 0xc6, 0x9c, 0x2d,
-  0xe7, 0xa0, 0xcb, 0x61, 0x19, 0xb0, 0x3b, 0x70, 0x38, 0x1a, 0xc2, 0xad,
-  0x39, 0x45, 0x0c, 0x72, 0x6d, 0x7d, 0x7c, 0x18, 0x7b, 0x22, 0xce, 0x70,
-  0x16, 0x32, 0x27, 0xaa, 0x53, 0xd3, 0xed, 0x51, 0xae, 0x84, 0xd7, 0x0e,
-  0x45, 0x24, 0x82, 0xd2, 0x21, 0x32, 0xa8, 0x46, 0xbc, 0xe6, 0xf1, 0x38,
-  0x6d, 0x3f, 0x8a, 0x34, 0x1e, 0x9e, 0xa3, 0xee, 0xd8, 0xcf, 0xd5, 0xd3,
-  0x5a, 0x5d, 0x0b, 0x6b, 0x3d, 0x0b, 0xd2, 0x60, 0xc3, 0xb7, 0xe0, 0x09,
-  0xb1, 0xb8, 0xfb, 0xe9, 0x84, 0xc8, 0x06, 0x2a, 0x9e, 0xee, 0xf1, 0xc5,
-  0xe0, 0x6b, 0x2f, 0x5f, 0xb7, 0x05, 0x93, 0x09, 0x0d, 0xf2, 0x89, 0x06,
-  0x15, 0xf2, 0x96, 0x84, 0x74, 0xf8, 0x33, 0x09, 0xd1, 0xd1, 0x21, 0xf5,
-  0xaf, 0xc4, 0x77, 0x71, 0x30, 0xf8, 0xba, 0x46, 0x76, 0xfe, 0x46, 0x48,
-  0xd5, 0x8a, 0x56, 0xd7, 0xaa, 0x10, 0xf7, 0x9d, 0x5b, 0x58, 0x02, 0x5a,
-  0xfb, 0x77, 0x6e, 0x4b, 0x2d, 0x4c, 0x44, 0xdc, 0x0d, 0x75, 0x01, 0xe0,
-  0x1b, 0x76, 0x21, 0x68, 0x8c, 0xbf, 0x64, 0xe7, 0x04, 0x71, 0x27, 0x55,
-  0xad, 0x9a, 0xc3, 0x60, 0x36, 0xda, 0x54, 0x3f, 0x3f, 0x19, 0x89, 0x52,
-  0xd2, 0xf5, 0x64, 0xb6, 0x11, 0x5e, 0xd5, 0x1a, 0x3f, 0xc3, 0x9b, 0xad,
-  0xdd, 0x34, 0xee, 0xe8, 0x98, 0x0d, 0xc8, 0x1a, 0x42, 0xc4, 0x41, 0xa8,
-  0xe2, 0x7b, 0xa3, 0xd7, 0x71, 0xdb, 0x6a, 0x64, 0x5b, 0x90, 0xef, 0x62,
-  0xe3, 0xe5, 0xb0, 0x9a, 0xe6, 0x95, 0x3f, 0x87, 0xa8, 0xcc, 0x8a, 0x83,
-  0x26, 0x7e, 0x71, 0xb8, 0x45, 0x90, 0x4d, 0xc2, 0xa9, 0x97, 0xaa, 0x5e,
-  0x89, 0x88, 0xeb, 0x03, 0x88, 0x5a, 0x39, 0xcd, 0x6f, 0xd4, 0xb9, 0x50,
-  0xf7, 0xe7, 0x84, 0xcb, 0x20, 0x99, 0x1e, 0xd5, 0x93, 0xdd, 0x50, 0x4c,
-  0x65, 0x39, 0xd4, 0x21, 0xd0, 0x58, 0x59, 0x6f, 0x8a, 0xcb, 0xe6, 0x16,
-  0x19, 0x93, 0x84, 0x76, 0x50, 0xe7, 0x37, 0x15, 0x59, 0x46, 0x58, 0x1a,
-  0xcd, 0xae, 0x48, 0xc7, 0x48, 0x54, 0xa9, 0x73, 0x21, 0xbe, 0x9a, 0x3b,
-  0xba, 0x5a, 0x1d, 0x0d, 0xe7, 0x58, 0x8a, 0x7f, 0x05, 0x71, 0x48, 0xac,
-  0x59, 0xe5, 0xc9, 0xaf, 0x68, 0x77, 0x4c, 0x68, 0xbd, 0x38, 0x29, 0x01,
-  0xd4, 0xf8, 0xf6, 0xf2, 0xf4, 0xbd, 0x16, 0x9d, 0xce, 0xa5, 0x3e, 0x7d,
-  0x11, 0x5f, 0x27, 0xc8, 0x5c, 0x10, 0x5f, 0x8c, 0xf7, 0x36, 0x1a, 0x99,
-  0xb4, 0x86, 0xb5, 0x8b, 0x55, 0xa2, 0xa2, 0x86, 0x25, 0x65, 0x60, 0x28,
-  0x0c, 0xc2, 0xc0, 0x27, 0xd3, 0xf8, 0x3a, 0x08, 0x02, 0x97, 0xc5, 0x6f,
-  0x86, 0x77, 0x59, 0x84, 0x59, 0x25, 0x88, 0xce, 0xa5, 0x01, 0x8a, 0x74,
-  0xd6, 0xf9, 0x23, 0x8c, 0xc9, 0x1d, 0x1b, 0x60, 0xe4, 0xa6, 0xdc, 0xf4,
-  0xfa, 0xe3, 0x19, 0x1f, 0x18, 0x58, 0xb5, 0x41, 0x9b, 0x9b, 0xc9, 0xf9,
-  0x07, 0xf0, 0x3c, 0x1f, 0x28, 0x62, 0x3e, 0x24, 0x3c, 0x34, 0x39, 0x01,
-  0x89, 0x13, 0x90, 0xe1, 0x4e, 0x75, 0x5c, 0x2f, 0xf4, 0x60, 0x48, 0xbc,
-  0x87, 0x8d, 0x4a, 0x43, 0xe9, 0x31, 0x5e, 0x9f, 0x72, 0x15, 0x4f, 0x91,
-  0x36, 0x5b, 0xb7, 0x66, 0xc2, 0x72, 0xed, 0x42, 0x8f, 0xc5, 0x43, 0x84,
-  0x41, 0xc5, 0xc8, 0xf9, 0x4d, 0x39, 0x73, 0xd2, 0x4d, 0xed, 0xd7, 0xb4,
-  0x55, 0x27, 0xf3, 0x6b, 0x64, 0x8b, 0xbd, 0x6c, 0xf5, 0x93, 0x26, 0x53,
-  0xe4, 0xe7, 0xa0, 0x1d, 0x8b, 0xdc, 0x18, 0xe5, 0xab, 0x05, 0x92, 0x52,
-  0xe5, 0x2d, 0x65, 0x44, 0x9c, 0x4f, 0x2d, 0x41, 0x1a, 0x51, 0x90, 0xf2,
-  0xd5, 0x6f, 0x73, 0x11, 0xb8, 0x1e, 0x35, 0x82, 0x05, 0x86, 0x84, 0x05,
-  0x2d, 0x9a, 0xb0, 0x25, 0xf9, 0x8c, 0x28, 0x65, 0xb8, 0x4c, 0xa7, 0x63,
-  0xf1, 0x1b, 0xbb, 0x80, 0x80, 0xfa, 0x0a, 0x72, 0x3b, 0x45, 0x68, 0xe2,
-  0xc3, 0x0d, 0x01, 0x41, 0x61, 0x0b, 0x03, 0x9a, 0xd3, 0xb4, 0xb7, 0x83,
-  0xeb, 0x4f, 0x9f, 0x8f, 0x58, 0xb4, 0x68, 0xda, 0x1a, 0xe2, 0xbb, 0x98,
-  0xf4, 0x31, 0x4e, 0x2a, 0x29, 0xa3, 0x7c, 0x39, 0xe7, 0xce, 0xab, 0x2b,
-  0x75, 0x97, 0xe6, 0xd9, 0x7c, 0xd6, 0x0c, 0x92, 0xda, 0xba, 0x3c, 0x19,
-  0x1c, 0x46, 0xd1, 0xf9, 0x20, 0x3a, 0x3f, 0x3b, 0xfd, 0x0e, 0x27, 0x8c,
-  0x63, 0xaa, 0x38, 0x2d, 0x15, 0xfd, 0x07, 0x6f, 0x46, 0x77, 0x71, 0x9e,
-  0xb2, 0xce, 0xd0, 0x5d, 0x6b, 0x9f, 0x93, 0x2c, 0x49, 0x3e, 0x43, 0xf7,
-  0xb6, 0xc5, 0x3e, 0x12, 0x83, 0x53, 0x82, 0x8b, 0x14, 0xdc, 0x8f, 0xc3,
-  0x04, 0xd8, 0x28, 0x39, 0xb2, 0x34, 0x0b, 0xda, 0x8e, 0x26, 0xe9, 0xc2,
-  0xf2, 0x1c, 0x1e, 0x6e, 0x71, 0x63, 0xdf, 0xc4, 0x77, 0xe8, 0x9f, 0xa6,
-  0xda, 0xee, 0xd1, 0xf9, 0x57, 0x8a, 0x38, 0xc9, 0xf5, 0xb8, 0xc7, 0xaa,
-  0x65, 0xeb, 0x2d, 0x1a, 0x46, 0x62, 0xad, 0x54, 0x2d, 0x82, 0x45, 0xd6,
-  0x85, 0x30, 0x8b, 0x78, 0x33, 0x2f, 0xf3, 0x6c, 0x41, 0x5b, 0xfb, 0x45,
-  0x0c, 0x4e, 0xcb, 0x17, 0xce, 0x51, 0x9c, 0xcc, 0x1a, 0x6e, 0x8e, 0x22,
-  0x1b, 0xdd, 0x26, 0xa5, 0xf9, 0xb0, 0xe5, 0xaf, 0x40, 0x8b, 0x64, 0x25,
-  0x47, 0x8d, 0xc9, 0xb4, 0x85, 0x63, 0xba, 0x07, 0x95, 0x64, 0x41, 0xe7,
-  0x34, 0x94, 0xa6, 0x39, 0xd5, 0x92, 0x4c, 0xab, 0xd1, 0x10, 0x38, 0xc0,
-  0xfc, 0xbe, 0x4c, 0xad, 0x6e, 0xb5, 0xe8, 0x1d, 0xe3, 0x7e, 0x83, 0xcb,
-  0xe0, 0x25, 0xfe, 0x45, 0xca, 0x04, 0x29, 0x3f, 0xdf, 0xbf, 0x30, 0x7d,
-  0xea, 0x87, 0xf6, 0x65, 0x68, 0x86, 0x1d, 0x56, 0xc5, 0x88, 0xa0, 0x2d,
-  0xd5, 0xd6, 0xc1, 0xd5, 0xae, 0x93, 0x36, 0x4f, 0x3e, 0xaf, 0x91, 0x86,
-  0x88, 0x0b, 0xef, 0x65, 0x80, 0x8b, 0x48, 0x62, 0x45, 0x25, 0x38, 0xab,
-  0xd2, 0xa0, 0x65, 0x2c, 0xd0, 0x5d, 0x7f, 0x71, 0xfc, 0x66, 0x8d, 0x27,
-  0xdf, 0x9c, 0xe9, 0x32, 0x61, 0xa2, 0x14, 0xa7, 0xc4, 0x5a, 0x66, 0x93,
-  0x1b, 0x6d, 0x20, 0xec, 0xb5, 0x1c, 0xc9, 0xbf, 0x2d, 0x01, 0x15, 0x30,
-  0x56, 0xc0, 0x86, 0xcc, 0x89, 0xed, 0x96, 0x92, 0x57, 0x31, 0xee, 0x7b,
-  0x42, 0x95, 0x04, 0xe2, 0xa2, 0x61, 0xeb, 0xec, 0x04, 0x33, 0xe9, 0xa8,
-  0x3f, 0x38, 0xf0, 0x98, 0x13, 0x17, 0x42, 0xb0, 0x79, 0x74, 0x9b, 0xac,
-  0xf4, 0xf6, 0xf6, 0x9f, 0x61, 0x11, 0xda, 0xd6, 0x4f, 0x97, 0x05, 0x34,
-  0x80, 0x5f, 0xe6, 0xd0, 0x5e, 0x7f, 0x13, 0x31, 0x15, 0x44, 0xba, 0xb9,
-  0x16, 0x10, 0x89, 0x66, 0x4b, 0x9f, 0xc8, 0x4e, 0xad, 0xcf, 0x1a, 0xf1,
-  0xd2, 0x0e, 0x2a, 0x62, 0xba, 0x6a, 0x3b, 0x8e, 0x22, 0x55, 0x15, 0xcc,
-  0x1c, 0x4b, 0xc9, 0x70, 0x2b, 0x4a, 0x8b, 0x87, 0xe3, 0x50, 0xc1, 0x69,
-  0x3a, 0xcc, 0xd9, 0x13, 0xc8, 0x92, 0x59, 0xc5, 0x4e, 0xd2, 0x88, 0xe2,
-  0xf0, 0x64, 0x84, 0x5c, 0x93, 0x74, 0x74, 0xcb, 0xe7, 0x49, 0xf5, 0xd6,
-  0x70, 0xd3, 0x4d, 0xdc, 0x14, 0x98, 0x08, 0xed, 0xae, 0xc5, 0x96, 0x84,
-  0x34, 0x71, 0x84, 0xb3, 0xa6, 0x73, 0xf1, 0x13, 0x2b, 0xd7, 0xf5, 0xbc,
-  0xcf, 0x31, 0xbf, 0x08, 0x83, 0x7d, 0x77, 0x74, 0x72, 0x19, 0x09, 0xab,
-  0x1e, 0xae, 0xd6, 0x04, 0xc5, 0x46, 0x3b, 0x49, 0x39, 0xda, 0x59, 0xdc,
-  0xa6, 0x3b, 0xf3, 0xa2, 0x18, 0x0f, 0xb7, 0x9d, 0x8b, 0x21, 0x91, 0xa8,
-  0x43, 0x22, 0xc2, 0xe8, 0xe2, 0xab, 0xc3, 0xc1, 0x47, 0x7b, 0x7b, 0x08,
-  0x20, 0x5e, 0x52, 0xd3, 0x5b, 0xb4, 0x06, 0x2d, 0xe9, 0x0e, 0x05, 0x2d,
-  0xfc, 0xac, 0x5f, 0x64, 0xdb, 0x6c, 0x8a, 0x71, 0xbc, 0x9e, 0xd7, 0x09,
-  0xad, 0x88, 0x51, 0x59, 0x93, 0x01, 0xe0, 0xb3, 0xfb, 0xf0, 0x3c, 0xc5,
-  0x9f, 0xe5, 0x22, 0xa6, 0xf5, 0x15, 0x07, 0xcc, 0x4b, 0xfc, 0xdb, 0x7e,
-  0xd4, 0xc3, 0xb3, 0xce, 0x29, 0xfe, 0x95, 0x5d, 0xc1, 0xcb, 0xaa, 0x59,
-  0xdc, 0xa5, 0xe3, 0xea, 0xc9, 0x6f, 0x06, 0x0b, 0xc0, 0x0c, 0x4f, 0xf3,
-  0xec, 0x46, 0x47, 0xc7, 0x97, 0x4c, 0x92, 0xc7, 0x67, 0x5f, 0xb0, 0x6c,
-  0x8a, 0x84, 0x89, 0xeb, 0x79, 0xfa, 0x23, 0x38, 0x1e, 0x35, 0x59, 0xf4,
-  0x35, 0xe1, 0x24, 0x3c, 0xa5, 0xb5, 0xe6, 0xb0, 0x5e, 0x58, 0x45, 0x3e,
-  0x67, 0xbf, 0xee, 0x32, 0xc5, 0xc2, 0x20, 0x0f, 0x0f, 0xc2, 0xd9, 0xfd,
-  0x42, 0x8c, 0x91, 0x9e, 0xa2, 0x11, 0xd1, 0x61, 0x6c, 0x73, 0x62, 0x2c,
-  0x12, 0x75, 0x0f, 0xb9, 0x30, 0x27, 0xd0, 0x06, 0xcc, 0xaa, 0x48, 0xc1,
-  0x70, 0xc9, 0xfe, 0xd5, 0x81, 0x15, 0x6d, 0xe1, 0xac, 0xc1, 0xf7, 0x5b,
-  0xc5, 0x76, 0x8d, 0x85, 0xae, 0x4b, 0xc5, 0x70, 0xb9, 0x2c, 0xbc, 0x35,
-  0x1a, 0x78, 0xd2, 0x22, 0x46, 0xa8, 0x1b, 0x03, 0x7e, 0x8c, 0x43, 0x12,
-  0x61, 0xdf, 0x1d, 0x1e, 0xbc, 0xfb, 0xfc, 0xed, 0xd9, 0xd1, 0xe9, 0x31,
-  0x7d, 0x50, 0x27, 0x82, 0x89, 0xe9, 0x7f, 0x92, 0xb2, 0x20, 0x41, 0x9d,
-  0xb5, 0x58, 0x0a, 0xbe, 0x58, 0x39, 0xa9, 0x8a, 0x7f, 0xe3, 0xe4, 0x08,
-  0x9d, 0x63, 0xc3, 0xec, 0x32, 0x1f, 0x73, 0xde, 0x46, 0xb0, 0xd5, 0x16,
-  0xcc, 0xaa, 0xf9, 0xd7, 0x36, 0xc8, 0x16, 0xad, 0x16, 0x5b, 0x4e, 0x57,
-  0x23, 0x89, 0xd4, 0xb0, 0xe8, 0x58, 0x8e, 0xa8, 0x87, 0x72, 0xa8, 0x08,
-  0xeb, 0xec, 0x3c, 0x33, 0xd8, 0x9e, 0x88, 0xc6, 0xd3, 0xb2, 0xc2, 0x45,
-  0xe8, 0xd5, 0xf9, 0x9f, 0xff, 0x03, 0x4d, 0x11, 0xf5, 0xf4, 0x74, 0x94,
-  0xa3, 0xbc, 0xfc, 0x9f, 0xff, 0x83, 0x64, 0x95, 0x94, 0xa1, 0x2d, 0x52,
-  0xef, 0x7c, 0x94, 0xb0, 0x80, 0x16, 0xd6, 0x8e, 0xf0, 0x89, 0x58, 0xc8,
-  0xa9, 0x9f, 0x3c, 0x24, 0xec, 0x08, 0xd3, 0xf7, 0x0e, 0x59, 0xd4, 0x29,
-  0xa3, 0x6f, 0xb2, 0x9c, 0x13, 0x2e, 0x8f, 0x2c, 0xde, 0xc2, 0x1e, 0x8a,
-  0xe7, 0xab, 0xc6, 0xd5, 0x38, 0x1d, 0xb3, 0xc4, 0x96, 0xd1, 0xf3, 0x0c,
-  0x5b, 0x74, 0x71, 0x70, 0xf5, 0x65, 0xab, 0xc8, 0xe5, 0xc1, 0x8b, 0xde,
-  0xcf, 0xe6, 0x99, 0x7b, 0x95, 0x6b, 0xe3, 0x39, 0xde, 0xc3, 0xe3, 0xab,
-  0xb4, 0x5b, 0x63, 0xf3, 0x2d, 0x72, 0x29, 0x87, 0x79, 0xaf, 0x63, 0xf4,
-  0xad, 0xc4, 0x69, 0x5c, 0x1e, 0x4c, 0x7e, 0x2d, 0x8f, 0x6f, 0x65, 0xf1,
-  0x36, 0x5b, 0x1c, 0x11, 0xc7, 0xe1, 0x8d, 0xc5, 0xff, 0xbf, 0x85, 0xc7,
-  0xc7, 0x7c, 0x86, 0x6a, 0xcc, 0xcb, 0x87, 0xe7, 0xfc, 0xf3, 0x6c, 0x2c,
-  0x08, 0xf5, 0x69, 0x9a, 0x3f, 0x84, 0xb7, 0xc9, 0x15, 0x91, 0x98, 0xa2,
-  0x1a, 0x32, 0xab, 0x76, 0x56, 0xd4, 0x35, 0xe1, 0xa7, 0xbe, 0x5d, 0xae,
-  0x2b, 0x7e, 0xed, 0x06, 0xa9, 0x55, 0xc3, 0x04, 0x2c, 0x43, 0xe2, 0x21,
-  0x92, 0x71, 0xc5, 0xca, 0x33, 0x7a, 0x97, 0x27, 0x37, 0x71, 0x81, 0xb0,
-  0xb3, 0x32, 0x85, 0x25, 0xb6, 0x2e, 0x84, 0x2f, 0x11, 0x76, 0xe0, 0x83,
-  0xd3, 0x2c, 0xeb, 0x20, 0xd2, 0xe4, 0x40, 0xbf, 0x7e, 0x62, 0x61, 0x80,
-  0xaa, 0x63, 0x8b, 0x02, 0xa5, 0xbe, 0xae, 0xaa, 0x0e, 0x4e, 0x7b, 0x21,
-  0xda, 0xcb, 0x0c, 0x09, 0x2a, 0x6c, 0x0e, 0x4e, 0x26, 0x34, 0xdd, 0x34,
-  0x48, 0x42, 0xb0, 0x94, 0x60, 0xbd, 0x5b, 0xd2, 0x49, 0x5b, 0xe4, 0xb2,
-  0x7d, 0xcb, 0x4c, 0x45, 0xb9, 0x7e, 0x21, 0x78, 0x30, 0x75, 0x96, 0xff,
-  0xeb, 0x51, 0xd0, 0x04, 0x81, 0x15, 0x44, 0xc5, 0xed, 0x76, 0x9c, 0xd7,
-  0x88, 0x27, 0x2d, 0x68, 0x7c, 0x3c, 0xb5, 0xad, 0x79, 0x66, 0x78, 0x1b,
-  0x31, 0x2b, 0xc1, 0xdb, 0x10, 0x98, 0xd5, 0x94, 0x25, 0x41, 0xa6, 0x45,
-  0x7b, 0xaa, 0x16, 0x27, 0x61, 0x66, 0x45, 0x69, 0x58, 0x33, 0x0c, 0x12,
-  0xc7, 0x33, 0xe0, 0x04, 0x2d, 0xb6, 0xaf, 0xa9, 0x7d, 0x9d, 0x21, 0xca,
-  0x88, 0xd5, 0xd2, 0x89, 0xf5, 0x5f, 0x36, 0x8e, 0x75, 0x3c, 0x95, 0x3d,
-  0x9d, 0x08, 0xb4, 0x99, 0x5a, 0x81, 0xe1, 0x59, 0x9c, 0x9b, 0xa3, 0x09,
-  0xa8, 0x1d, 0x1a, 0x86, 0x15, 0x58, 0x23, 0x79, 0xb0, 0x75, 0xce, 0xc9,
-  0x79, 0x2d, 0xb0, 0x6b, 0x27, 0xd3, 0x54, 0x6c, 0x7e, 0x96, 0x6f, 0xc0,
-  0x2e, 0x09, 0x49, 0x4a, 0x60, 0x77, 0x31, 0xc7, 0x04, 0xd9, 0x97, 0x88,
-  0x8f, 0x28, 0x9b, 0xa1, 0xb4, 0xa4, 0x99, 0x6d, 0x49, 0xcc, 0x37, 0x63,
-  0x19, 0x89, 0xae, 0x26, 0xd8, 0x6b, 0x43, 0x1e, 0x91, 0xc8, 0xfe, 0x4c,
-  0x3a, 0xdb, 0x16, 0x4f, 0x2f, 0xf6, 0xab, 0x36, 0x93, 0xb4, 0xfa, 0xea,
-  0x84, 0x32, 0x05, 0x64, 0x90, 0xf7, 0xa0, 0x14, 0xcd, 0x3e, 0x2e, 0xc3,
-  0xc4, 0x09, 0x89, 0xf4, 0xdd, 0xdf, 0x6f, 0x37, 0xf2, 0x5a, 0x6e, 0x95,
-  0x66, 0xa8, 0x63, 0xde, 0xbd, 0x22, 0x9e, 0x24, 0x76, 0x1c, 0x89, 0x94,
-  0x21, 0xae, 0x91, 0xa6, 0x1d, 0x8b, 0x03, 0x85, 0xa3, 0x27, 0x61, 0xe5,
-  0xe8, 0x35, 0x8e, 0xd6, 0x08, 0x07, 0x12, 0x5a, 0xbf, 0xb3, 0x61, 0x22,
-  0x86, 0x42, 0x83, 0xa2, 0xa3, 0x62, 0x9a, 0x2e, 0x70, 0x4a, 0x73, 0xf8,
-  0x92, 0x49, 0x03, 0x4b, 0x98, 0xb9, 0xc8, 0x4d, 0xdb, 0xe2, 0x14, 0xa8,
-  0xa5, 0x80, 0xb1, 0x2c, 0x79, 0x97, 0x4d, 0x61, 0xd1, 0xdc, 0xaa, 0xb5,
-  0xff, 0x74, 0x77, 0x8f, 0x87, 0xfb, 0x74, 0xf7, 0x93, 0xed, 0x9f, 0xe2,
-  0xb8, 0x6d, 0x49, 0xd8, 0x13, 0x31, 0x00, 0x77, 0x9f, 0x79, 0x34, 0x1a,
-  0x5e, 0x24, 0x50, 0x3e, 0xaf, 0xd3, 0x32, 0xaf, 0x18, 0x6a, 0x10, 0xbe,
-  0x17, 0x8f, 0x38, 0xcc, 0x36, 0xfa, 0x1e, 0xf7, 0xd5, 0x0f, 0xeb, 0x11,
-  0x54, 0x14, 0x39, 0xc5, 0x65, 0x93, 0xdf, 0x4a, 0xbc, 0x41, 0xc7, 0xde,
-  0xc7, 0xeb, 0x1d, 0x35, 0x98, 0x38, 0xb7, 0x67, 0x1b, 0xe4, 0x83, 0xd3,
-  0x71, 0x11, 0xb7, 0x66, 0x7c, 0x91, 0xe5, 0x72, 0x4d, 0xb9, 0xb4, 0x00,
-  0x0d, 0xf1, 0xde, 0x4e, 0x26, 0x6b, 0xcd, 0x3f, 0x07, 0x87, 0x87, 0xde,
-  0xef, 0x14, 0x6d, 0x1d, 0x8c, 0xc7, 0x12, 0x02, 0xf7, 0x49, 0x7f, 0xef,
-  0x49, 0x7f, 0x77, 0xfb, 0x67, 0xa7, 0x40, 0x56, 0xd2, 0x8d, 0x54, 0xc8,
-  0xcd, 0x5b, 0xac, 0x45, 0x62, 0x0f, 0x5d, 0x16, 0x8d, 0x35, 0x5d, 0x1f,
-  0xd6, 0xda, 0x5c, 0x50, 0x0d, 0xa9, 0x84, 0x59, 0x75, 0xc7, 0x87, 0xc2,
-  0xb3, 0xb0, 0x69, 0xa2, 0x25, 0x4e, 0x87, 0x43, 0x8b, 0x69, 0x8a, 0xbf,
-  0x9a, 0x37, 0xc6, 0x51, 0x9f, 0x2e, 0x5c, 0x4c, 0x83, 0x08, 0x25, 0xd4,
-  0x80, 0xd6, 0x27, 0xce, 0x11, 0xd5, 0x04, 0x4b, 0x56, 0x96, 0x3b, 0x09,
-  0xb2, 0x19, 0x4b, 0x00, 0x1b, 0x11, 0x03, 0x1f, 0x84, 0x99, 0xe7, 0xe6,
-  0x6e, 0xf2, 0x52, 0xa7, 0x85, 0xe3, 0x04, 0x7e, 0xab, 0xd6, 0xb0, 0xdb,
-  0x59, 0x2a, 0xe1, 0x7f, 0x41, 0x48, 0xe9, 0x4f, 0xcc, 0x4c, 0x95, 0xe5,
-  0xd7, 0x8d, 0xd1, 0x63, 0x29, 0xc4, 0xbe, 0x86, 0xda, 0xfd, 0xed, 0xcb,
-  0x23, 0xaa, 0x1a, 0x92, 0x78, 0x77, 0x94, 0x7d, 0x7c, 0x2f, 0x3f, 0xdb,
-  0x49, 0x9e, 0x43, 0xe4, 0xf3, 0x0c, 0x41, 0xc5, 0x58, 0x7d, 0x7d, 0x45,
-  0x52, 0xbd, 0x24, 0x22, 0xc9, 0x83, 0x01, 0x20, 0xc1, 0x53, 0xae, 0xbf,
-  0xac, 0x19, 0x7e, 0x49, 0xad, 0x6d, 0x0d, 0xb6, 0xcd, 0x31, 0xc0, 0x92,
-  0x85, 0x36, 0x16, 0xe7, 0xd7, 0xca, 0x7f, 0x5d, 0xcc, 0x59, 0x90, 0x71,
-  0xa6, 0x7e, 0xf9, 0x26, 0xd1, 0xb1, 0xef, 0x7b, 0x4a, 0xa7, 0x0c, 0xb1,
-  0x09, 0x77, 0x49, 0xf1, 0xa2, 0xbe, 0x9e, 0xac, 0x71, 0x8d, 0xee, 0xc7,
-  0xed, 0x08, 0xb4, 0x8a, 0xf4, 0x95, 0x25, 0x45, 0x98, 0x2b, 0x72, 0xf8,
-  0xcd, 0x51, 0x90, 0x87, 0x81, 0x73, 0xcd, 0xd3, 0x62, 0xf2, 0x63, 0x14,
-  0xcc, 0x46, 0xd8, 0x44, 0xa0, 0x01, 0x8a, 0x3e, 0x04, 0xd8, 0x59, 0xce,
-  0x9d, 0x1e, 0x27, 0xc9, 0xc2, 0xc5, 0x53, 0x33, 0x84, 0x00, 0x76, 0x77,
-  0x96, 0xc4, 0x73, 0x56, 0x61, 0x00, 0xc1, 0xd9, 0x14, 0xfb, 0xab, 0x21,
-  0x8d, 0x85, 0xbb, 0x4f, 0xf0, 0x1f, 0xc2, 0xde, 0x81, 0xed, 0xb9, 0xf7,
-  0xc9, 0x93, 0x4f, 0x49, 0x15, 0x59, 0x09, 0x0c, 0x8c, 0x5b, 0x34, 0x5c,
-  0xc5, 0xfd, 0xf6, 0xe6, 0x82, 0x5c, 0x62, 0x27, 0x44, 0x4b, 0xfa, 0x07,
-  0x9d, 0x0a, 0x5a, 0xdd, 0x84, 0xa5, 0x3a, 0x39, 0x14, 0x0d, 0xba, 0x9c,
-  0x67, 0xb4, 0x88, 0xba, 0x60, 0xbc, 0x5e, 0x24, 0x37, 0x60, 0x9d, 0x44,
-  0x68, 0xe8, 0x07, 0xa7, 0x61, 0x4c, 0x87, 0x06, 0x39, 0x00, 0x44, 0xad,
-  0x97, 0xc7, 0x57, 0x97, 0x00, 0xb9, 0xbd, 0x3a, 0xbf, 0x6c, 0x1f, 0x12,
-  0x04, 0x02, 0xb0, 0x41, 0x2c, 0x1a, 0xc8, 0x06, 0x19, 0x9c, 0xa6, 0x40,
-  0x06, 0x11, 0xa9, 0xd8, 0x82, 0x58, 0x90, 0x08, 0xf9, 0xce, 0x98, 0x35,
-  0x09, 0xc1, 0x85, 0x66, 0xf0, 0x7a, 0x85, 0x53, 0x9d, 0x90, 0xb4, 0xf4,
-  0xe8, 0xd4, 0x64, 0xd7, 0x1f, 0xa7, 0x11, 0x9e, 0x32, 0x08, 0x12, 0x73,
-  0x76, 0xbe, 0x2a, 0x1e, 0xaf, 0xe2, 0x5f, 0xf9, 0x93, 0xa6, 0x17, 0xef,
-  0x1a, 0x1a, 0x11, 0xc2, 0x02, 0xc1, 0x39, 0xc3, 0xa4, 0xd8, 0x09, 0x3a,
-  0xe6, 0x1a, 0xef, 0x40, 0x4f, 0xb9, 0x75, 0x39, 0xc2, 0xef, 0xa1, 0x60,
-  0x92, 0x88, 0xb6, 0xfd, 0x84, 0x8b, 0x6c, 0x96, 0xf0, 0x19, 0x15, 0x21,
-  0xd6, 0x71, 0xbb, 0x42, 0xd3, 0xcd, 0x52, 0x01, 0x46, 0xbc, 0x89, 0xd7,
-  0x8c, 0x0e, 0x41, 0xa5, 0xd8, 0x69, 0x84, 0x35, 0x9a, 0x97, 0x3d, 0x53,
-  0x1a, 0x91, 0xdd, 0x21, 0x91, 0x6e, 0x5a, 0xae, 0x70, 0x30, 0xe9, 0x19,
-  0x1b, 0x5b, 0x25, 0xe2, 0x54, 0xf8, 0x0a, 0x5d, 0x6c, 0xed, 0x51, 0x07,
-  0xe2, 0xcf, 0x81, 0x23, 0x5f, 0x04, 0x39, 0x97, 0x8e, 0x42, 0xdb, 0xd0,
-  0x97, 0xcf, 0x75, 0xe7, 0x18, 0xb2, 0x18, 0x86, 0x60, 0xa5, 0xd6, 0x86,
-  0xeb, 0x54, 0x36, 0x54, 0xe2, 0x01, 0x9a, 0x61, 0x6d, 0xea, 0x4d, 0x33,
-  0xe3, 0xbc, 0xbb, 0xc2, 0x14, 0xc4, 0xa5, 0x49, 0x43, 0xb8, 0xbf, 0x74,
-  0xf0, 0x48, 0xb2, 0x32, 0x18, 0x8e, 0xca, 0x55, 0xba, 0xd7, 0x7e, 0x95,
-  0xfe, 0xeb, 0xd2, 0xd0, 0x59, 0x4a, 0xf1, 0x1c, 0xaf, 0x57, 0x66, 0x1c,
-  0x78, 0x15, 0xbd, 0x54, 0x6e, 0xf1, 0x59, 0xeb, 0xa2, 0xd3, 0x10, 0x43,
-  0x79, 0xcc, 0x60, 0xbb, 0x18, 0xa2, 0x6c, 0xa0, 0x96, 0x3d, 0x5a, 0xfa,
-  0x81, 0x67, 0x3a, 0x2a, 0x42, 0x77, 0x9b, 0x11, 0xef, 0x63, 0x93, 0xc7,
-  0x9c, 0xb0, 0xa1, 0x5e, 0x71, 0xe7, 0xd2, 0x60, 0x6d, 0x8e, 0xd8, 0xc0,
-  0xd5, 0x72, 0x46, 0x57, 0xd2, 0x7d, 0x92, 0x8c, 0x19, 0xa5, 0x62, 0xc0,
-  0x88, 0x56, 0x75, 0x21, 0x16, 0xdb, 0xcf, 0xeb, 0xad, 0x87, 0x9d, 0x23,
-  0xd4, 0xe0, 0x46, 0x30, 0xbd, 0x30, 0x8e, 0x0c, 0xf8, 0x28, 0x54, 0xa0,
-  0x2c, 0xf8, 0xba, 0x6e, 0xac, 0x1f, 0x9c, 0x00, 0x8c, 0xe4, 0xe0, 0xed,
-  0xd5, 0x97, 0x9d, 0x28, 0x00, 0xb3, 0x0b, 0xb8, 0x09, 0xdf, 0x53, 0x25,
-  0xdd, 0xbe, 0x77, 0x2e, 0xda, 0x25, 0x67, 0xfb, 0x46, 0x4b, 0x16, 0x64,
-  0xcd, 0xa6, 0x5d, 0x23, 0x86, 0x67, 0xfd, 0x67, 0xdb, 0xb5, 0xad, 0x41,
-  0xba, 0x16, 0xd3, 0x7e, 0x2f, 0x5d, 0xbc, 0x3f, 0xe8, 0x06, 0x12, 0xbb,
-  0xa9, 0xea, 0x27, 0x17, 0x51, 0x3c, 0x1e, 0x33, 0x22, 0x60, 0x98, 0xe1,
-  0xbc, 0xbc, 0x46, 0x74, 0x60, 0x0b, 0x96, 0x0c, 0x67, 0xe9, 0x3a, 0x41,
-  0x1a, 0x32, 0x07, 0x35, 0xca, 0xeb, 0xcc, 0x67, 0xc8, 0xe2, 0x75, 0xf8,
-  0x8c, 0x71, 0x7f, 0xba, 0x3b, 0x3e, 0xee, 0x7f, 0xad, 0x43, 0x0a, 0x2a,
-  0x97, 0x88, 0x34, 0xa3, 0x20, 0x67, 0xba, 0xe7, 0xc3, 0x8d, 0xd9, 0x04,
-  0x86, 0x11, 0xbb, 0x21, 0x37, 0x33, 0xcd, 0x2c, 0x3a, 0x9b, 0x85, 0x37,
-  0x0b, 0xc6, 0x1d, 0xa9, 0x20, 0x11, 0xf6, 0x55, 0x59, 0xd2, 0xa7, 0xfd,
-  0xfd, 0xed, 0x76, 0x3d, 0x47, 0x0f, 0x17, 0xe4, 0x64, 0xe4, 0x54, 0xd0,
-  0xd9, 0x18, 0xb1, 0x16, 0x2e, 0x91, 0x68, 0x1c, 0x48, 0x46, 0x9d, 0x70,
-  0xb0, 0x90, 0x07, 0x39, 0xe2, 0x59, 0x34, 0x11, 0x15, 0xb0, 0x42, 0x3f,
-  0x03, 0x14, 0xa4, 0x5d, 0xf2, 0xb2, 0x65, 0x69, 0xcd, 0x5c, 0xe1, 0x0d,
-  0xd1, 0x4d, 0x84, 0x52, 0x2b, 0xcb, 0x55, 0x3f, 0xd0, 0x45, 0x31, 0x6d,
-  0xe7, 0x95, 0x57, 0x62, 0xa2, 0xe1, 0x3e, 0x06, 0x83, 0xd3, 0x9d, 0xab,
-  0xd3, 0x81, 0x5b, 0x4b, 0xc8, 0xc9, 0xe1, 0x3a, 0x46, 0x97, 0xe0, 0x37,
-  0xa5, 0x40, 0xd3, 0x34, 0xae, 0xef, 0x79, 0x4f, 0x01, 0xe5, 0x82, 0x9c,
-  0x6e, 0x4d, 0xa4, 0x72, 0xea, 0xbe, 0x07, 0x61, 0x34, 0xc7, 0x71, 0x64,
-  0xbd, 0x36, 0xc0, 0x09, 0x7d, 0xcc, 0xa6, 0x4e, 0xa0, 0x67, 0x7b, 0x2b,
-  0xf1, 0x99, 0xf6, 0x69, 0x9e, 0xfc, 0x6d, 0x2c, 0xf8, 0xe7, 0x86, 0xea,
-  0x10, 0x4d, 0x93, 0xbb, 0x26, 0xf3, 0x4d, 0xa6, 0x85, 0xf8, 0xbc, 0x39,
-  0x54, 0x00, 0xa3, 0x53, 0x9c, 0xb4, 0xf1, 0x87, 0x71, 0xe0, 0x5f, 0x52,
-  0x6a, 0x46, 0x5b, 0x2d, 0x5b, 0x64, 0x33, 0x6c, 0xdf, 0xaa, 0x4b, 0x85,
-  0x75, 0x73, 0xfb, 0x24, 0x86, 0x67, 0x8b, 0x0e, 0x9a, 0x66, 0xd7, 0x40,
-  0x58, 0x93, 0x00, 0x5b, 0xde, 0x42, 0xcb, 0x4f, 0xac, 0xeb, 0x71, 0x53,
-  0x0e, 0x19, 0xd1, 0xdd, 0xaa, 0x6a, 0xd1, 0x72, 0xd5, 0x61, 0x33, 0x75,
-  0x9d, 0x18, 0x02, 0x5e, 0x60, 0x63, 0x2d, 0xdc, 0xae, 0x25, 0x1e, 0xda,
-  0x19, 0xb3, 0x46, 0x2b, 0x30, 0xeb, 0xd7, 0x62, 0x1b, 0x09, 0x72, 0x24,
-  0x8d, 0x12, 0x94, 0x10, 0x3c, 0x1d, 0xac, 0x01, 0x45, 0x23, 0xc2, 0x30,
-  0xba, 0x88, 0xaa, 0xbb, 0xf3, 0xf1, 0xbf, 0x6f, 0x77, 0x40, 0x69, 0x3f,
-  0x65, 0x6b, 0x5a, 0xcf, 0xd0, 0x95, 0x38, 0x89, 0x35, 0x9d, 0x71, 0x2d,
-  0x87, 0x5c, 0xbb, 0x60, 0xcd, 0x83, 0x13, 0xb9, 0x15, 0x6a, 0xf2, 0xf0,
-  0xfa, 0x1d, 0xf2, 0xeb, 0x98, 0x3c, 0xd6, 0x92, 0xf3, 0x68, 0xd4, 0xba,
-  0x5e, 0x10, 0xd0, 0x0e, 0x0f, 0x0f, 0xa3, 0xad, 0x43, 0x26, 0xd6, 0x43,
-  0xbd, 0x49, 0x0e, 0x6f, 0x90, 0x72, 0x30, 0xa5, 0xf5, 0x1c, 0xdc, 0x2c,
-  0x71, 0xf9, 0x8c, 0xb3, 0x7b, 0x13, 0x61, 0x75, 0xb2, 0xf5, 0xd8, 0xa7,
-  0x78, 0x05, 0xeb, 0x88, 0xa0, 0x1f, 0x54, 0xc4, 0x0f, 0xd1, 0xfd, 0x38,
-  0xc9, 0xc8, 0x3c, 0xc7, 0x76, 0x33, 0x48, 0x2f, 0xed, 0x52, 0xfe, 0x6c,
-  0x39, 0x37, 0x7b, 0x92, 0xb3, 0x7d, 0xce, 0xdd, 0x51, 0x50, 0x31, 0x38,
-  0x96, 0x03, 0x74, 0x76, 0x70, 0x05, 0x3c, 0xca, 0x52, 0x83, 0x26, 0xd7,
-  0x46, 0x67, 0x39, 0x3a, 0xe0, 0xc3, 0x10, 0x07, 0x68, 0x3c, 0xa6, 0x24,
-  0x31, 0xc4, 0x14, 0x52, 0x31, 0x24, 0xbe, 0x55, 0xa2, 0x35, 0x5a, 0xd3,
-  0x3d, 0x75, 0x55, 0x7b, 0x0e, 0x94, 0x4a, 0x30, 0xd1, 0xf1, 0x67, 0xd1,
-  0x3c, 0x29, 0x7b, 0xff, 0x36, 0x3e, 0x66, 0x43, 0xfc, 0x5e, 0xe2, 0xc6,
-  0x77, 0x74, 0x66, 0x3f, 0x3c, 0x22, 0xb0, 0x83, 0x20, 0x8c, 0x22, 0x9a,
-  0x24, 0xc1, 0xa1, 0x4b, 0xec, 0x1c, 0xa2, 0xc7, 0xd0, 0x74, 0x9b, 0x47,
-  0xd3, 0xe2, 0x83, 0xb9, 0x6b, 0x97, 0x21, 0x2e, 0x61, 0x6b, 0x1a, 0xee,
-  0x5a, 0x10, 0x65, 0x8d, 0x19, 0x54, 0x82, 0x39, 0x9d, 0x87, 0x13, 0xbe,
-  0x8f, 0x1b, 0x02, 0x86, 0x9d, 0x61, 0x2f, 0xd6, 0x91, 0xea, 0x99, 0xaa,
-  0x23, 0xc2, 0x35, 0x9f, 0x27, 0x8b, 0xe9, 0xca, 0xe9, 0x93, 0xda, 0xfc,
-  0x3a, 0x51, 0x2f, 0x34, 0x4c, 0x68, 0x48, 0xbd, 0x6c, 0xbe, 0x8e, 0xb1,
-  0xa8, 0xb6, 0xc2, 0x1d, 0xc5, 0x10, 0xc4, 0x26, 0x0d, 0x30, 0xbd, 0x58,
-  0x7b, 0xae, 0x81, 0x43, 0x36, 0xa9, 0x20, 0x90, 0x77, 0x5c, 0x4a, 0xa4,
-  0x42, 0x5c, 0x6a, 0xea, 0xdb, 0x3a, 0x94, 0x4b, 0x91, 0x8b, 0xa6, 0x58,
-  0x7a, 0x96, 0xd3, 0x5c, 0x3e, 0x6c, 0x90, 0x00, 0xcb, 0xad, 0xd1, 0x4f,
-  0x31, 0x5e, 0xc7, 0x51, 0x4b, 0x92, 0x06, 0x24, 0xaa, 0x47, 0x32, 0x61,
-  0x15, 0xc6, 0x57, 0xf0, 0xd8, 0x7c, 0x16, 0x1f, 0xa7, 0xf0, 0xb6, 0x89,
-  0x91, 0x1e, 0xc5, 0xe3, 0x50, 0x13, 0x46, 0xaf, 0x10, 0x72, 0x20, 0xae,
-  0xef, 0x38, 0x2f, 0x77, 0x38, 0x4d, 0x94, 0x2f, 0x2d, 0x58, 0x4b, 0xf3,
-  0xb1, 0xa2, 0x22, 0xc3, 0xa6, 0xf1, 0xe9, 0xc7, 0x9f, 0xb4, 0x86, 0x8b,
-  0x26, 0x9a, 0x2f, 0xe3, 0x51, 0x4b, 0x11, 0xeb, 0xe7, 0x53, 0x8b, 0xd8,
-  0xb5, 0xc0, 0x58, 0x80, 0x8c, 0x42, 0xa7, 0x27, 0x85, 0x18, 0x72, 0x15,
-  0x53, 0xdf, 0x23, 0x91, 0x00, 0x36, 0x4f, 0x6c, 0x39, 0x82, 0x26, 0x67,
-  0x40, 0xe3, 0x52, 0x94, 0xa0, 0x86, 0x24, 0x22, 0xd9, 0xba, 0xf3, 0xe8,
-  0xcf, 0x11, 0xea, 0xec, 0xa0, 0x9b, 0x5a, 0x83, 0x7f, 0x85, 0x67, 0xeb,
-  0x5a, 0x43, 0x43, 0x75, 0xd3, 0xa4, 0x75, 0xde, 0xfd, 0xf7, 0x36, 0xde,
-  0x16, 0x48, 0xa0, 0xe9, 0x98, 0xd1, 0x4b, 0x8b, 0x26, 0xf0, 0xea, 0xa0,
-  0x43, 0xe3, 0xa7, 0x11, 0x81, 0x04, 0x5f, 0xaa, 0xc2, 0xac, 0x89, 0x40,
-  0x7f, 0x6e, 0xd1, 0x27, 0x0b, 0x33, 0xca, 0x31, 0x6e, 0x47, 0x59, 0xc6,
-  0x56, 0x73, 0xc3, 0xb2, 0xbc, 0xc4, 0x79, 0xaf, 0xa6, 0x08, 0x03, 0x04,
-  0x07, 0xd5, 0x4c, 0xdb, 0xc0, 0x03, 0x5e, 0xba, 0x46, 0x39, 0x5b, 0x4c,
-  0x00, 0xa8, 0x31, 0x94, 0xb6, 0x95, 0x30, 0xe9, 0x1f, 0xe1, 0x56, 0xc9,
-  0x43, 0xe3, 0x14, 0xf3, 0xbb, 0xc1, 0x3a, 0x35, 0xe4, 0xf2, 0xe3, 0x87,
-  0x78, 0xc6, 0xf5, 0x20, 0x0c, 0x3a, 0x9b, 0x1d, 0xe1, 0x3e, 0xc3, 0x49,
-  0x63, 0x32, 0x42, 0x43, 0xaf, 0xf8, 0x38, 0x40, 0x00, 0x78, 0xac, 0x49,
-  0x01, 0x78, 0x11, 0x14, 0xa0, 0x86, 0x86, 0xd0, 0xbb, 0xcd, 0xd4, 0x29,
-  0x83, 0x72, 0x38, 0x3f, 0xe2, 0x6a, 0x46, 0x87, 0xe3, 0x7a, 0xf9, 0x92,
-  0x60, 0x51, 0x18, 0x47, 0xe2, 0x45, 0x6b, 0x44, 0x46, 0xef, 0xb5, 0x1b,
-  0xef, 0xab, 0x3f, 0x57, 0x5a, 0xbb, 0xbf, 0xef, 0xcf, 0x56, 0xf6, 0x5d,
-  0x51, 0xa9, 0x8c, 0xe3, 0x73, 0x42, 0x5d, 0x82, 0xad, 0x60, 0xb2, 0xfe,
-  0xf7, 0xc2, 0x11, 0x99, 0xcf, 0x96, 0x0d, 0x41, 0x95, 0x8d, 0xe0, 0x44,
-  0x35, 0xe9, 0x35, 0xd3, 0x86, 0x5c, 0xb8, 0xbf, 0xa7, 0x43, 0x31, 0x21,
-  0x52, 0xe3, 0xea, 0x9f, 0xd5, 0x83, 0x7f, 0x9d, 0xa9, 0xf6, 0x36, 0xa4,
-  0xab, 0xcc, 0xe8, 0xad, 0x29, 0x16, 0x15, 0x65, 0xbe, 0x1c, 0x95, 0x4d,
-  0x73, 0xf6, 0x77, 0x61, 0x31, 0x16, 0xd1, 0xc4, 0x0d, 0x9e, 0x82, 0xad,
-  0x54, 0x15, 0x16, 0xe1, 0x60, 0x65, 0x7d, 0xec, 0x7f, 0x33, 0xe7, 0x99,
-  0xe1, 0x23, 0xe9, 0x67, 0x57, 0x12, 0x07, 0x34, 0x0d, 0xd2, 0xb2, 0x22,
-  0xcb, 0x6c, 0xed, 0x06, 0x74, 0xee, 0x93, 0xe1, 0xab, 0x3f, 0x23, 0x58,
-  0xee, 0x81, 0x61, 0xda, 0x04, 0x88, 0x12, 0x14, 0xb9, 0x83, 0x3f, 0x3b,
-  0xc8, 0x1a, 0x6e, 0x5b, 0x7f, 0xe2, 0xec, 0xeb, 0x5a, 0x0c, 0xf2, 0xaf,
-  0x83, 0xd6, 0x26, 0x59, 0xb6, 0xb6, 0x31, 0x57, 0x3c, 0x87, 0x17, 0x24,
-  0x79, 0x40, 0x0a, 0x7d, 0x0a, 0x7f, 0x05, 0xc4, 0x9e, 0xeb, 0xc4, 0x53,
-  0xa3, 0x50, 0x20, 0xf6, 0x72, 0xae, 0x28, 0xa3, 0x7c, 0x26, 0x1b, 0x37,
-  0x2a, 0xf1, 0x98, 0xe1, 0xca, 0xa1, 0x68, 0xe3, 0x49, 0x1e, 0x54, 0xd7,
-  0xbb, 0x63, 0xd7, 0x2f, 0x08, 0x9e, 0x7e, 0xf5, 0x67, 0x06, 0xff, 0xc0,
-  0xaf, 0x7f, 0x74, 0x6f, 0xe3, 0x1f, 0xa2, 0x66, 0x62, 0x0b, 0x6b, 0x27,
-  0x02, 0x11, 0x68, 0xb2, 0xcc, 0x59, 0xbc, 0x49, 0xe4, 0x80, 0x4a, 0xb5,
-  0x0d, 0x83, 0x14, 0x54, 0xde, 0xf2, 0xe6, 0xe0, 0xec, 0xed, 0xc1, 0xe9,
-  0xa3, 0xf9, 0x29, 0xa1, 0x9d, 0xce, 0x05, 0x48, 0xb1, 0xcd, 0xac, 0x22,
-  0xbb, 0xe0, 0x5c, 0x6a, 0x9c, 0xbc, 0xdc, 0x8e, 0x8f, 0x83, 0xf0, 0x3b,
-  0x82, 0xd0, 0x77, 0x69, 0x94, 0x23, 0xa4, 0xab, 0x3a, 0x4c, 0x87, 0xbb,
-  0x78, 0xba, 0x4c, 0x1c, 0x8a, 0xbd, 0x53, 0xd6, 0x5a, 0x82, 0xaa, 0xd9,
-  0x4d, 0x97, 0xc7, 0x52, 0xe7, 0xc2, 0x09, 0x65, 0xd3, 0x14, 0x05, 0xd5,
-  0xa6, 0x00, 0x5f, 0x3a, 0xd5, 0x92, 0x50, 0x44, 0x96, 0x7f, 0x06, 0x5b,
-  0xc1, 0x3a, 0xd0, 0xcf, 0x97, 0xf8, 0x9d, 0x36, 0x36, 0x8f, 0xdb, 0x22,
-  0x85, 0x18, 0x4f, 0xdd, 0x02, 0x46, 0xe9, 0xc9, 0x3f, 0x1a, 0x65, 0xdb,
-  0x90, 0x74, 0x05, 0x65, 0x9c, 0x1c, 0x37, 0x31, 0xd7, 0x38, 0x50, 0x94,
-  0x47, 0x4a, 0xe2, 0x79, 0xab, 0x3b, 0xa4, 0x9a, 0xb7, 0x29, 0xd5, 0x26,
-  0xf8, 0xd2, 0xf0, 0x2b, 0x21, 0xba, 0x4b, 0x2e, 0x9c, 0x04, 0xa1, 0x09,
-  0x82, 0xde, 0xd4, 0x16, 0x6e, 0xe1, 0x56, 0x4b, 0xc7, 0x24, 0x83, 0x41,
-  0x28, 0x0c, 0xdd, 0xdd, 0x29, 0x42, 0x4e, 0xd9, 0xff, 0x4b, 0x5f, 0x5e,
-  0x5f, 0x6b, 0x62, 0xa9, 0x5b, 0x05, 0x2e, 0x59, 0xa7, 0xcb, 0xd0, 0x80,
-  0x92, 0xd2, 0xda, 0x6c, 0x44, 0xe0, 0x0a, 0x02, 0xe1, 0xb7, 0xfa, 0x9a,
-  0x84, 0xa0, 0xeb, 0x69, 0x36, 0xcc, 0x26, 0x93, 0x47, 0xa8, 0xa6, 0xa0,
-  0x8b, 0x93, 0x2e, 0xb1, 0x82, 0x7d, 0xa2, 0x9c, 0x95, 0x82, 0x54, 0x0c,
-  0xbc, 0x37, 0xd4, 0x6a, 0x65, 0x00, 0x7b, 0xee, 0x8b, 0x65, 0x52, 0x11,
-  0xc2, 0x5a, 0xc4, 0x63, 0xe7, 0xce, 0xb3, 0x7c, 0x11, 0x0b, 0xb4, 0xe5,
-  0x2a, 0x56, 0x02, 0x35, 0xa2, 0xc1, 0x7b, 0x1e, 0x24, 0x81, 0x04, 0xa1,
-  0xbf, 0xff, 0xe3, 0xfb, 0x1f, 0x5a, 0x20, 0x23, 0x60, 0x2b, 0xb7, 0x08,
-  0x79, 0x84, 0xea, 0x6a, 0x7e, 0x0f, 0x5b, 0xb2, 0x69, 0x2f, 0x4a, 0x8f,
-  0x84, 0xa4, 0x75, 0x00, 0x82, 0x60, 0xe4, 0xe6, 0x95, 0x52, 0xf8, 0x0e,
-  0x63, 0xf6, 0xd9, 0x97, 0x16, 0x08, 0x31, 0x4d, 0xae, 0xe9, 0x5f, 0xcc,
-  0xd8, 0x5d, 0xb2, 0xea, 0xca, 0x59, 0x19, 0xa8, 0x76, 0xc3, 0x5a, 0xae,
-  0xb5, 0x1e, 0xc6, 0x55, 0xb1, 0x8b, 0x4d, 0xc0, 0x97, 0x27, 0xce, 0x53,
-  0x10, 0x6c, 0xc4, 0x17, 0xd8, 0x88, 0xc6, 0xaa, 0x89, 0xa9, 0x17, 0x47,
-  0xa0, 0x5b, 0xd7, 0x52, 0x45, 0x25, 0x61, 0xfb, 0xb5, 0x60, 0xd7, 0x89,
-  0x69, 0xa2, 0x8a, 0x04, 0xbd, 0x16, 0x85, 0x00, 0x90, 0x11, 0x95, 0xdc,
-  0x78, 0x11, 0xcd, 0x44, 0xed, 0x4d, 0xc3, 0x88, 0x8f, 0x2f, 0x8e, 0xaf,
-  0x22, 0x83, 0x8f, 0x59, 0x53, 0x5a, 0xc0, 0xe7, 0x6f, 0x54, 0xb0, 0x66,
-  0x04, 0xc6, 0xc9, 0x55, 0xc9, 0xb9, 0x0f, 0xd1, 0xc7, 0xdb, 0x54, 0x16,
-  0x85, 0xc8, 0x10, 0x55, 0x53, 0x52, 0x89, 0x3c, 0x6a, 0x16, 0xe7, 0xfe,
-  0xb0, 0x6c, 0x08, 0x32, 0xff, 0x13, 0xd3, 0xbc, 0xc2, 0x85, 0xb4, 0x83,
-  0x4a, 0x7a, 0x04, 0xa7, 0x5a, 0x36, 0x75, 0xef, 0x44, 0x34, 0x7a, 0x1e,
-  0xab, 0x2c, 0x9a, 0xac, 0xa5, 0x9b, 0x4e, 0x33, 0xef, 0x64, 0xfd, 0x60,
-  0xbe, 0x3c, 0x3e, 0x38, 0xb2, 0x19, 0xff, 0x5b, 0x91, 0x82, 0x6e, 0x38,
-  0x95, 0x6b, 0xba, 0x68, 0x24, 0xf4, 0xc4, 0xd7, 0x48, 0x10, 0x9c, 0x2e,
-  0x82, 0x67, 0x83, 0xb4, 0xaf, 0x97, 0xf2, 0x73, 0x0d, 0x67, 0x3f, 0x66,
-  0x34, 0x1d, 0x7d, 0x34, 0x4c, 0x69, 0xb4, 0xea, 0x5b, 0xa0, 0x13, 0xba,
-  0xeb, 0xc1, 0xb4, 0xaf, 0x91, 0x34, 0xc6, 0x77, 0x2e, 0xb1, 0xac, 0xba,
-  0xae, 0xae, 0x07, 0x1d, 0x0c, 0xd0, 0x57, 0x8d, 0x4c, 0x82, 0xd6, 0x2b,
-  0x39, 0x42, 0x9a, 0x73, 0x65, 0x75, 0x15, 0xc6, 0x0d, 0xe8, 0x79, 0x3a,
-  0xd5, 0x45, 0x49, 0xd2, 0x98, 0x8d, 0x0c, 0x2f, 0xdd, 0xc4, 0x01, 0xb2,
-  0xc6, 0x5c, 0xe1, 0x35, 0xb8, 0x92, 0x8b, 0x23, 0x4f, 0x73, 0x72, 0x35,
-  0xe1, 0xbd, 0x9d, 0xba, 0xa5, 0x50, 0x31, 0x4b, 0x86, 0xdf, 0x64, 0xe1,
-  0x17, 0x19, 0xd2, 0x78, 0x49, 0x33, 0xd2, 0xb4, 0xcb, 0x30, 0x1c, 0x6c,
-  0x7d, 0xc5, 0x8d, 0x8a, 0x67, 0x2d, 0x9b, 0x27, 0x55, 0xab, 0x09, 0xe6,
-  0x68, 0xf9, 0x6f, 0x9c, 0x6b, 0xc6, 0x25, 0x40, 0x5b, 0x6e, 0x1a, 0x5c,
-  0x85, 0x45, 0xb9, 0x9c, 0x4c, 0x2c, 0x35, 0x5a, 0x5c, 0x05, 0x3c, 0x54,
-  0x97, 0xe4, 0x3b, 0xce, 0xb8, 0x78, 0xa5, 0xad, 0x9a, 0xe9, 0xe3, 0x71,
-  0x03, 0x41, 0xd4, 0x06, 0xa4, 0x13, 0xf2, 0x20, 0xf5, 0x8e, 0xa9, 0x02,
-  0x6b, 0x52, 0xb2, 0x8c, 0x93, 0x1c, 0xa6, 0x7f, 0x8e, 0x3a, 0x62, 0x79,
-  0xf2, 0xbe, 0xc9, 0x3b, 0x1d, 0x18, 0xbf, 0xa4, 0x26, 0x03, 0x1a, 0x79,
-  0x96, 0xc1, 0xc5, 0x3c, 0xf7, 0x53, 0xd7, 0x45, 0x23, 0x76, 0x7c, 0x9d,
-  0xde, 0x59, 0x5d, 0x14, 0x1e, 0x5b, 0x4b, 0xaa, 0x96, 0x0d, 0xc3, 0xe4,
-  0x6e, 0x0d, 0x2c, 0x91, 0x54, 0xf6, 0xa8, 0x60, 0xd0, 0x6c, 0xb7, 0xa5,
-  0xa3, 0x6c, 0xca, 0xf9, 0xc8, 0x31, 0xd7, 0xd3, 0x79, 0x01, 0xe2, 0xae,
-  0x7b, 0xa9, 0xbe, 0x24, 0xd9, 0xea, 0x45, 0xa7, 0x3d, 0x7c, 0xbb, 0xc2,
-  0x46, 0x0b, 0x07, 0x3e, 0xc7, 0x31, 0x08, 0x3a, 0x68, 0x46, 0x7b, 0x1d,
-  0x8f, 0x77, 0x74, 0xc0, 0x5a, 0x39, 0xb3, 0x75, 0xd4, 0x16, 0xeb, 0xbf,
-  0xe0, 0x70, 0x3c, 0xa6, 0x00, 0xae, 0xf3, 0x86, 0x22, 0x3d, 0x50, 0x95,
-  0x02, 0xa2, 0xe6, 0xbc, 0x53, 0xce, 0x85, 0x1b, 0x8f, 0xdb, 0x6e, 0x24,
-  0x8d, 0xef, 0xce, 0x9d, 0xcd, 0x4e, 0x47, 0xa3, 0x8b, 0xf2, 0x02, 0xf6,
-  0x17, 0x7b, 0xdd, 0x61, 0x79, 0x00, 0xa4, 0x32, 0xce, 0xf3, 0x94, 0xce,
-  0x62, 0x03, 0xab, 0x4f, 0x42, 0xf0, 0x4a, 0x57, 0x15, 0x92, 0xc1, 0x27,
-  0x67, 0xe2, 0x01, 0xa3, 0x1d, 0x81, 0xbe, 0xbf, 0x16, 0xcf, 0xa3, 0x9a,
-  0x31, 0x55, 0x2b, 0xd3, 0xc4, 0x2e, 0x88, 0x30, 0xaf, 0x75, 0x1d, 0x32,
-  0xc4, 0x3a, 0x39, 0x34, 0x28, 0xcb, 0xc7, 0x0c, 0x51, 0x74, 0x93, 0x60,
-  0xc9, 0x77, 0x72, 0xa6, 0xa8, 0xb6, 0x68, 0x13, 0xbc, 0x65, 0x0c, 0x24,
-  0x10, 0x60, 0x51, 0xc9, 0x70, 0xb1, 0x1c, 0xce, 0xc6, 0xcf, 0xea, 0x69,
-  0x11, 0xc0, 0xe2, 0xe2, 0xf0, 0x13, 0x15, 0x45, 0x55, 0xe0, 0xe0, 0xdf,
-  0x9f, 0xec, 0xe3, 0x30, 0x3c, 0x50, 0x6b, 0xa3, 0x94, 0xa1, 0x36, 0xc6,
-  0xe9, 0x75, 0x5a, 0x4a, 0xc2, 0x80, 0xbe, 0xb0, 0xb6, 0xa4, 0x06, 0x56,
-  0x66, 0x6f, 0xff, 0xd3, 0x68, 0x98, 0x96, 0xd1, 0x9b, 0xa3, 0x67, 0x28,
-  0xf5, 0x73, 0x5b, 0x2c, 0x67, 0x2e, 0xa8, 0x46, 0x11, 0xee, 0xb8, 0xc6,
-  0x22, 0xcb, 0x82, 0x11, 0x8d, 0x6f, 0xda, 0x00, 0xae, 0xbf, 0x4d, 0x56,
-  0x35, 0x50, 0x41, 0x5a, 0x55, 0xf3, 0x5a, 0x06, 0x26, 0x71, 0x47, 0x6d,
-  0x5c, 0xb3, 0x51, 0x11, 0xe7, 0x9b, 0x12, 0x35, 0x2d, 0x00, 0x0d, 0xa2,
-  0xb0, 0x9a, 0x1e, 0xb5, 0x4c, 0x75, 0x26, 0x01, 0x4e, 0x98, 0x3b, 0xbc,
-  0x90, 0x08, 0xb9, 0x41, 0x0d, 0x4d, 0xa0, 0x7e, 0x2b, 0x84, 0xd6, 0xb4,
-  0x4f, 0x42, 0x9b, 0x6a, 0xaf, 0x97, 0x5e, 0x13, 0x27, 0x4a, 0x7a, 0x06,
-  0x5c, 0x46, 0xda, 0xcd, 0xf5, 0xba, 0x3a, 0x4e, 0xd1, 0x09, 0x3f, 0xab,
-  0x27, 0xd8, 0xd4, 0xd2, 0x53, 0x7e, 0x23, 0x48, 0xd9, 0x95, 0x28, 0x0b,
-  0x9c, 0x81, 0x74, 0x84, 0xfa, 0x6c, 0xd3, 0x55, 0x33, 0x1d, 0xd9, 0x00,
-  0xfb, 0x14, 0x76, 0x02, 0x99, 0x92, 0xbc, 0x97, 0x07, 0x0b, 0x58, 0x5d,
-  0xa2, 0xbd, 0xfe, 0x43, 0x37, 0xac, 0x41, 0xa2, 0x90, 0xae, 0x5c, 0x6c,
-  0xa4, 0x25, 0x59, 0x8c, 0x4b, 0xdd, 0xd5, 0xc6, 0x83, 0xd6, 0xc5, 0xec,
-  0x35, 0x45, 0xf0, 0x49, 0x2e, 0x1c, 0x78, 0x9f, 0x18, 0xd9, 0x75, 0xcc,
-  0x98, 0xa2, 0x01, 0xdd, 0xa5, 0x74, 0x0a, 0xa8, 0xe9, 0xe9, 0xb2, 0x81,
-  0x15, 0xee, 0x66, 0x2e, 0xdf, 0x06, 0x18, 0x7c, 0x76, 0x11, 0xab, 0xd0,
-  0x2b, 0xb1, 0xa9, 0x42, 0x72, 0xc1, 0xd7, 0xcd, 0x62, 0x29, 0x68, 0xc6,
-  0x9d, 0x5d, 0x56, 0x40, 0x65, 0x0d, 0x7a, 0xb8, 0xfa, 0xba, 0x10, 0x6c,
-  0x12, 0xcf, 0x25, 0x7d, 0x38, 0xae, 0x34, 0xda, 0x0c, 0x43, 0x2f, 0xac,
-  0x5e, 0x22, 0x57, 0x7d, 0xee, 0xff, 0xda, 0x91, 0xa1, 0x6e, 0xd2, 0x3c,
-  0x8f, 0xf0, 0xe8, 0xf2, 0x9d, 0x31, 0x01, 0xa3, 0x6d, 0xcd, 0x77, 0xbe,
-  0xa0, 0x2f, 0x05, 0x52, 0x30, 0x0a, 0x63, 0x16, 0x2b, 0x65, 0xad, 0x98,
-  0x44, 0xb5, 0x95, 0xbe, 0x33, 0x8b, 0x00, 0x76, 0xa9, 0x65, 0x21, 0xad,
-  0xb7, 0x48, 0xd6, 0x2d, 0x0c, 0x0d, 0x08, 0x4b, 0xa2, 0xf6, 0xa3, 0x83,
-  0xb9, 0x29, 0xdf, 0x5a, 0xbe, 0x04, 0x19, 0x2f, 0x0d, 0x50, 0xf6, 0xdb,
-  0xa4, 0x61, 0x03, 0x50, 0x23, 0x40, 0x30, 0xb3, 0xa4, 0xbc, 0xd9, 0x7d,
-  0xb1, 0x57, 0xa9, 0x65, 0xab, 0x20, 0xcc, 0x8c, 0x72, 0xff, 0xeb, 0x45,
-  0xab, 0x9f, 0xa8, 0xe0, 0xd7, 0x46, 0x9d, 0x3b, 0xaf, 0xf1, 0x1f, 0xaa,
-  0x9e, 0x47, 0xaf, 0x51, 0x27, 0xd8, 0x81, 0x0b, 0xb8, 0x42, 0x71, 0xc4,
-  0x2e, 0x7e, 0x23, 0x9f, 0xd8, 0x71, 0x53, 0xdd, 0xb2, 0x2d, 0x90, 0x43,
-  0xbd, 0x16, 0x2c, 0x1f, 0xcb, 0x09, 0xe4, 0x39, 0x48, 0x2e, 0x53, 0xc6,
-  0xb7, 0xa8, 0x81, 0x93, 0xb2, 0xf7, 0x21, 0x40, 0xc4, 0x68, 0xa9, 0xca,
-  0x10, 0x47, 0x21, 0x84, 0x7d, 0x05, 0x17, 0x22, 0xb6, 0x60, 0x56, 0x8c,
-  0x5d, 0x8d, 0x71, 0x12, 0x47, 0xa6, 0x45, 0x45, 0xd7, 0x15, 0xf2, 0x29,
-  0xd2, 0x1f, 0x25, 0x72, 0x9b, 0x57, 0x6d, 0x96, 0x8d, 0x25, 0xf0, 0x84,
-  0xa1, 0x15, 0x18, 0x0c, 0x7d, 0xde, 0x9e, 0xe2, 0xf9, 0x4b, 0x7a, 0x8d,
-  0x82, 0xa5, 0x0d, 0xb6, 0xe9, 0xaf, 0xb4, 0x4d, 0x7f, 0x5d, 0xce, 0x6f,
-  0x7b, 0x5a, 0x9b, 0x49, 0x21, 0x36, 0x8a, 0x76, 0xa6, 0xf2, 0x8d, 0x8b,
-  0x3a, 0xe1, 0x7c, 0x00, 0x31, 0xa6, 0x36, 0x4b, 0x14, 0xc5, 0x1a, 0x2e,
-  0x29, 0x2b, 0xb4, 0xbe, 0x04, 0x80, 0x2f, 0xd6, 0x24, 0x35, 0x50, 0x47,
-  0x08, 0xe0, 0x65, 0x0d, 0xb3, 0x63, 0xa5, 0xa2, 0xac, 0xe1, 0x4e, 0x3f,
-  0x04, 0xbe, 0x6c, 0x80, 0xee, 0x15, 0x96, 0x1b, 0xc6, 0x06, 0x15, 0x2f,
-  0x9c, 0x6b, 0x3c, 0x89, 0x41, 0x89, 0x92, 0xf8, 0xe2, 0x8b, 0x50, 0x69,
-  0xe9, 0x61, 0x50, 0x6d, 0x4d, 0x7a, 0x58, 0x2d, 0xd0, 0x5c, 0x34, 0xcc,
-  0x49, 0x74, 0x66, 0x2d, 0x5d, 0x40, 0x6d, 0x6c, 0x84, 0x51, 0x7d, 0x70,
-  0x8a, 0xd9, 0xc4, 0x22, 0x0f, 0x0b, 0xa8, 0x0d, 0xf8, 0xad, 0x4c, 0x2a,
-  0x23, 0xdc, 0xcf, 0xff, 0x9d, 0x79, 0xf5, 0xb7, 0x7c, 0x67, 0x14, 0x6d,
-  0xe1, 0x5a, 0x9a, 0x6c, 0x14, 0x8c, 0x23, 0x30, 0x62, 0xaa, 0x0e, 0xe1,
-  0x0a, 0x87, 0x2e, 0x94, 0x31, 0x46, 0x1d, 0x6b, 0xad, 0xd3, 0xcc, 0xbf,
-  0xa9, 0x54, 0x5b, 0x66, 0x7b, 0x98, 0x07, 0x0e, 0x3a, 0xa0, 0xb1, 0x37,
-  0x1e, 0x41, 0x54, 0x84, 0x44, 0x5a, 0x27, 0x2d, 0x45, 0x49, 0x01, 0xed,
-  0x49, 0xf4, 0x6b, 0xf1, 0x13, 0xae, 0x1c, 0x51, 0x4b, 0xe6, 0x9a, 0xe6,
-  0x22, 0x8a, 0x76, 0x14, 0xc3, 0x63, 0x56, 0x27, 0x97, 0x95, 0x4b, 0x37,
-  0xd3, 0xcb, 0x5f, 0xdd, 0x1e, 0xd3, 0x69, 0x65, 0x48, 0x1e, 0xdd, 0x25,
-  0x98, 0x69, 0x33, 0xb3, 0x8a, 0x91, 0xdc, 0x55, 0x2e, 0xaa, 0xac, 0xb1,
-  0xed, 0x65, 0xab, 0x90, 0x1b, 0xf9, 0x3a, 0x2c, 0x74, 0x24, 0x19, 0x02,
-  0x83, 0xe3, 0xbe, 0x04, 0xec, 0xdb, 0x22, 0x3c, 0x22, 0x67, 0x8d, 0x95,
-  0x64, 0x1a, 0x36, 0xc2, 0xae, 0xa9, 0xd6, 0xc2, 0xc9, 0x89, 0x37, 0xf1,
-  0xc3, 0x43, 0xbf, 0x48, 0xa4, 0x7c, 0x49, 0x51, 0x4c, 0x39, 0x19, 0xb2,
-  0xb5, 0x4c, 0xcb, 0x07, 0x67, 0x0a, 0x30, 0x87, 0x7a, 0xef, 0x35, 0x9b,
-  0x96, 0xe1, 0xd5, 0x8a, 0xf4, 0xf6, 0x97, 0xf4, 0x4f, 0x5b, 0x52, 0xdb,
-  0xce, 0x60, 0xf0, 0xe5, 0x76, 0x74, 0x11, 0xe4, 0xd7, 0x3b, 0x77, 0x45,
-  0xdf, 0xc2, 0x64, 0x54, 0x5f, 0xd5, 0xa4, 0x09, 0x75, 0x0d, 0xe5, 0x2d,
-  0xc1, 0x9d, 0xae, 0x0d, 0x5f, 0x63, 0x4e, 0x4b, 0x58, 0xb7, 0x3a, 0x9d,
-  0x7e, 0xc1, 0x7c, 0x3e, 0xea, 0xf4, 0xbd, 0x29, 0xdb, 0x8d, 0x49, 0xe2,
-  0xd1, 0xbe, 0xc3, 0xae, 0xd0, 0xcb, 0x0a, 0x8d, 0xf0, 0x0c, 0x65, 0xdd,
-  0x30, 0xeb, 0xb6, 0x3c, 0x0c, 0x8e, 0x35, 0x71, 0x10, 0x04, 0xfc, 0x24,
-  0x00, 0x1a, 0x91, 0xc2, 0xdd, 0xe5, 0x8c, 0xbd, 0x30, 0x8f, 0xdb, 0xc1,
-  0xa4, 0x68, 0x81, 0x87, 0xb2, 0xd5, 0x4c, 0xc2, 0x98, 0x0b, 0xff, 0xba,
-  0xfc, 0xed, 0xdb, 0x7c, 0x18, 0xbd, 0x9c, 0xd2, 0x8b, 0xd3, 0xf6, 0x70,
-  0x56, 0xab, 0x62, 0xf6, 0x55, 0x92, 0x0f, 0x93, 0x3c, 0x2b, 0xea, 0xc9,
-  0x46, 0x9a, 0xa1, 0xac, 0x45, 0x95, 0xd0, 0x8e, 0x25, 0x2d, 0x36, 0xc0,
-  0x60, 0x4a, 0x3e, 0xb6, 0x78, 0xa1, 0x91, 0x79, 0x00, 0xff, 0x31, 0xe2,
-  0x1d, 0xd8, 0xdb, 0x04, 0x05, 0x29, 0x9e, 0x24, 0xf6, 0x3b, 0x11, 0xfc,
-  0x84, 0xed, 0xdf, 0x69, 0x3c, 0x55, 0x63, 0x77, 0xd3, 0x57, 0xa5, 0x7b,
-  0x80, 0xe8, 0x68, 0x04, 0xcd, 0x88, 0x19, 0x87, 0x51, 0x78, 0xd9, 0xcb,
-  0x05, 0xe0, 0x1a, 0x1e, 0x9b, 0xc1, 0x49, 0x40, 0x79, 0xf6, 0x59, 0x0f,
-  0x45, 0x03, 0xfc, 0xa7, 0xd2, 0x64, 0x35, 0xf7, 0xa4, 0xb1, 0x88, 0x2d,
-  0x0a, 0xae, 0x06, 0xd4, 0x15, 0xde, 0xaa, 0x6f, 0x09, 0xc1, 0xf7, 0xb1,
-  0xa1, 0x43, 0x68, 0x5a, 0xe5, 0xad, 0x2e, 0xec, 0xd3, 0x86, 0x33, 0x2c,
-  0x8a, 0xbe, 0x18, 0x0c, 0x0e, 0x2e, 0x4e, 0xa2, 0x2d, 0xfa, 0xd9, 0x3b,
-  0xb3, 0x6a, 0xaa, 0xdb, 0x46, 0x48, 0x5e, 0x4b, 0xc2, 0x6c, 0x38, 0xc5,
-  0x01, 0x72, 0x17, 0x22, 0x09, 0xde, 0x16, 0x8d, 0x7c, 0xc9, 0xaf, 0x89,
-  0x0b, 0x9a, 0xa4, 0x2f, 0x00, 0x2a, 0x6a, 0x68, 0xcb, 0xa3, 0x4a, 0x25,
-  0xa1, 0x0a, 0xd7, 0xf8, 0xc5, 0xe9, 0xed, 0x2b, 0x29, 0x14, 0x31, 0x49,
-  0xaf, 0x11, 0x46, 0xcd, 0x3f, 0xdb, 0xf0, 0x64, 0xec, 0x34, 0x5a, 0x49,
-  0x2f, 0xff, 0xa4, 0x97, 0x6e, 0x18, 0x32, 0x4a, 0x73, 0x59, 0x44, 0xc8,
-  0xe9, 0x1b, 0x8a, 0x71, 0x0b, 0xc0, 0x8e, 0xbd, 0x9e, 0x06, 0xae, 0xf4,
-  0x69, 0xe2, 0xe3, 0x35, 0x42, 0x50, 0xeb, 0xa0, 0x59, 0xd1, 0x1d, 0x1a,
-  0xc4, 0x6c, 0x45, 0x46, 0xac, 0x52, 0x2e, 0x87, 0x04, 0x84, 0x53, 0x56,
-  0xf1, 0x46, 0x0c, 0x2e, 0x70, 0x02, 0xdb, 0x1b, 0x62, 0xce, 0xaa, 0x9b,
-  0x7b, 0x46, 0xe5, 0x32, 0x9e, 0x56, 0xc6, 0xd0, 0x8f, 0xce, 0x17, 0xc1,
-  0x45, 0x7d, 0x93, 0xa4, 0xb9, 0x77, 0x8d, 0xf9, 0xc4, 0x60, 0xe6, 0x19,
-  0x6d, 0xd3, 0x05, 0x63, 0xb2, 0xb4, 0x07, 0x29, 0xc3, 0x1e, 0xac, 0xa1,
-  0x74, 0xa0, 0x49, 0xdc, 0xde, 0xe1, 0x26, 0x09, 0xa5, 0xed, 0x81, 0x1c,
-  0xb1, 0xac, 0x14, 0xd0, 0xe8, 0x48, 0xb9, 0xb6, 0xed, 0xf6, 0xef, 0xda,
-  0x80, 0x48, 0x12, 0x12, 0xc9, 0x4a, 0xb3, 0xd4, 0xb9, 0x4e, 0x75, 0xc3,
-  0x94, 0xe0, 0x20, 0x42, 0x04, 0xdc, 0x15, 0x76, 0xbc, 0xe5, 0x6c, 0x1e,
-  0x89, 0x47, 0x5d, 0x47, 0xca, 0x3b, 0xc1, 0xdb, 0x45, 0x47, 0xf0, 0x23,
-  0xef, 0xe0, 0x2b, 0x35, 0xbf, 0xac, 0x59, 0x8f, 0xc2, 0x59, 0xcb, 0xf8,
-  0x55, 0x57, 0x83, 0xda, 0x17, 0x5b, 0xe5, 0xaa, 0x5b, 0xaa, 0x45, 0x9c,
-  0xcf, 0xd9, 0xae, 0xc9, 0xf0, 0x7f, 0xa0, 0xd8, 0x76, 0x71, 0x18, 0xb6,
-  0xbc, 0xc5, 0xcd, 0x8a, 0x65, 0x59, 0x1d, 0x91, 0xab, 0x27, 0x67, 0xcb,
-  0xd9, 0x94, 0x25, 0x02, 0x1c, 0x24, 0xf3, 0xf4, 0xb2, 0x53, 0x30, 0xa0,
-  0x7e, 0x1a, 0x0d, 0xa0, 0xcc, 0x31, 0xad, 0x0a, 0x08, 0x9a, 0x05, 0x20,
-  0xb4, 0xa1, 0x80, 0x07, 0x80, 0xdd, 0xad, 0x15, 0x95, 0x85, 0xd9, 0x64,
-  0x61, 0xc1, 0x62, 0x67, 0x7a, 0x67, 0xaf, 0x85, 0x8e, 0xdd, 0x06, 0x6f,
-  0xb1, 0x0b, 0xcd, 0x3a, 0xcf, 0x5c, 0xd8, 0x98, 0x05, 0x4b, 0x6b, 0x80,
-  0x51, 0x80, 0xbc, 0x7c, 0xd7, 0xeb, 0x49, 0x09, 0x1d, 0xf1, 0xe8, 0x81,
-  0x44, 0xb9, 0x04, 0xc9, 0x0a, 0xe1, 0x01, 0x8b, 0x86, 0xa9, 0xc6, 0x2a,
-  0xd3, 0x9b, 0xf7, 0x04, 0x3c, 0x04, 0x30, 0xe3, 0xf7, 0x73, 0x25, 0xc5,
-  0x41, 0xc6, 0xa9, 0xc2, 0xa2, 0x59, 0x2b, 0x98, 0x84, 0x05, 0x1a, 0x34,
-  0xa5, 0xbb, 0x56, 0x5f, 0x3b, 0xc6, 0xf3, 0x2a, 0xea, 0xac, 0x15, 0xbc,
-  0x3a, 0xf5, 0x17, 0x4e, 0x33, 0xc6, 0x9e, 0x55, 0x7b, 0x86, 0x40, 0x7a,
-  0xc9, 0x71, 0x37, 0x58, 0xa4, 0x29, 0xc3, 0x10, 0x88, 0xde, 0xd4, 0xdc,
-  0xf6, 0x35, 0x76, 0x6b, 0x31, 0xfa, 0x0b, 0x3e, 0xdc, 0x38, 0x5b, 0x62,
-  0x1f, 0x50, 0x10, 0x69, 0x1d, 0xbe, 0xa1, 0x69, 0x6e, 0x02, 0xc5, 0x38,
-  0xe6, 0x65, 0x50, 0xdd, 0x66, 0xcb, 0x04, 0xd8, 0xbf, 0x19, 0xc7, 0xdd,
-  0x96, 0x1a, 0xe2, 0x12, 0x26, 0x12, 0xaf, 0x43, 0xe4, 0x09, 0x77, 0xd7,
-  0x97, 0x3b, 0xe7, 0xec, 0x35, 0x62, 0x49, 0x13, 0x14, 0x0e, 0xaf, 0x46,
-  0x5d, 0xca, 0x0b, 0x6d, 0x14, 0x87, 0x78, 0x34, 0xf4, 0x98, 0x48, 0x60,
-  0xb9, 0x2b, 0x98, 0x6c, 0xde, 0x2a, 0x36, 0xd0, 0x16, 0x4e, 0xd0, 0xcb,
-  0x72, 0x12, 0xcd, 0x1b, 0x3b, 0xb3, 0xb7, 0xad, 0x7a, 0x4a, 0x2e, 0x85,
-  0x7d, 0xa5, 0xbc, 0x0c, 0x3b, 0x92, 0x6f, 0x32, 0x01, 0xf8, 0xe8, 0xbc,
-  0x40, 0xe9, 0x18, 0x63, 0x06, 0x32, 0xc7, 0x75, 0x71, 0x02, 0x8c, 0xa2,
-  0xf2, 0xe5, 0xf9, 0x9b, 0x63, 0x97, 0xfe, 0x25, 0xb6, 0x0a, 0x7c, 0xd2,
-  0x8a, 0xe3, 0xd6, 0xe7, 0x30, 0x6c, 0xcb, 0xf7, 0xee, 0x36, 0x84, 0x64,
-  0x59, 0x9d, 0xeb, 0xa4, 0x5c, 0xdc, 0x2f, 0xd3, 0xf1, 0x16, 0xa7, 0xe5,
-  0x2f, 0xe7, 0xe9, 0x43, 0x4f, 0xec, 0x6a, 0x52, 0xd8, 0xd4, 0x92, 0xd2,
-  0x03, 0x53, 0x3a, 0xcc, 0xb9, 0xb3, 0x96, 0x34, 0xd0, 0x48, 0x49, 0x86,
-  0xe9, 0x45, 0x91, 0x48, 0x38, 0x71, 0x28, 0x9d, 0xcb, 0x7d, 0x2b, 0x4d,
-  0x6e, 0x13, 0x8b, 0x9f, 0x47, 0xdf, 0x08, 0xc8, 0x0a, 0xef, 0x7b, 0x4b,
-  0x2a, 0x5b, 0xb0, 0xdf, 0x68, 0xee, 0xe0, 0xe2, 0xe2, 0xe8, 0xe0, 0xea,
-  0xc0, 0xcd, 0x8d, 0xf1, 0x4c, 0x98, 0xb1, 0xf1, 0xc5, 0x0b, 0x5d, 0x25,
-  0x2f, 0x2d, 0xcc, 0xe1, 0xb7, 0xc8, 0x37, 0x6a, 0xb2, 0xf2, 0x8b, 0xcb,
-  0x73, 0xd8, 0x4a, 0x7e, 0xbb, 0x6b, 0x35, 0x25, 0xa2, 0xa3, 0xb8, 0x8c,
-  0xdb, 0x2a, 0x19, 0xec, 0x6f, 0x83, 0x4d, 0x46, 0x06, 0x04, 0xd3, 0x75,
-  0xe1, 0x0c, 0x22, 0x73, 0x44, 0xef, 0xb0, 0xad, 0xf9, 0xc8, 0xdd, 0xa4,
-  0x62, 0x91, 0x96, 0x1d, 0xed, 0x36, 0xd3, 0x54, 0x82, 0xb9, 0x64, 0x9e,
-  0x91, 0x1a, 0xc6, 0x8b, 0x56, 0x6e, 0x22, 0x2d, 0xad, 0x64, 0xe6, 0x65,
-  0x07, 0x83, 0x49, 0x6c, 0x8c, 0xb5, 0xaa, 0x1f, 0x78, 0xb7, 0x45, 0xb6,
-  0x47, 0x82, 0x55, 0xc6, 0x7c, 0x5f, 0xd8, 0x10, 0x83, 0xd1, 0x12, 0xc1,
-  0x71, 0x99, 0xf5, 0xbe, 0x8d, 0x56, 0xc3, 0x44, 0x1b, 0xc7, 0x47, 0x50,
-  0xcb, 0x88, 0xd4, 0x6d, 0x0e, 0x8d, 0x05, 0xf9, 0x88, 0xf8, 0x5e, 0xcf,
-  0xa2, 0xe4, 0x64, 0xda, 0xf4, 0x41, 0xe3, 0xa1, 0xd2, 0xe1, 0x89, 0xeb,
-  0x75, 0xd3, 0xce, 0xaa, 0x42, 0x1e, 0xd5, 0x69, 0x24, 0xc8, 0x31, 0x50,
-  0x84, 0x3e, 0xc5, 0xb0, 0xa4, 0x1c, 0x3a, 0xd5, 0xb4, 0x81, 0x9b, 0x23,
-  0x86, 0x1e, 0x25, 0x11, 0x8e, 0xe4, 0x31, 0xfc, 0xb5, 0xb3, 0xd7, 0xdf,
-  0xed, 0x34, 0x47, 0x8f, 0x03, 0x33, 0x61, 0xeb, 0x5e, 0x3c, 0x97, 0x78,
-  0x69, 0x01, 0xe1, 0xcc, 0xde, 0x3f, 0x40, 0x2d, 0xbe, 0x19, 0xcf, 0xd9,
-  0xd5, 0xdb, 0x36, 0x96, 0xde, 0x79, 0xe3, 0x46, 0x16, 0x8f, 0x90, 0xe7,
-  0xca, 0xf3, 0x8c, 0x23, 0xe2, 0x62, 0x98, 0x00, 0xd8, 0xd6, 0xd9, 0x69,
-  0x5f, 0x60, 0x71, 0x9e, 0x25, 0xf5, 0x75, 0xfe, 0x59, 0x91, 0x4d, 0x6e,
-  0xff, 0x03, 0x47, 0xd3, 0x5a, 0x86, 0x57, 0x71, 0x23, 0x59, 0x8d, 0xcd,
-  0x56, 0xc4, 0xc3, 0x03, 0x01, 0x3b, 0xad, 0x59, 0xc5, 0x91, 0x0f, 0x34,
-  0x5f, 0x45, 0x1c, 0xf3, 0x01, 0x69, 0x5f, 0xb3, 0xc1, 0xc2, 0x7a, 0x29,
-  0xb1, 0x84, 0x55, 0x36, 0x6e, 0x0f, 0x22, 0x5a, 0x8e, 0x18, 0xb5, 0xd2,
-  0x9e, 0x3d, 0xb9, 0x6c, 0xd5, 0xf8, 0x30, 0xe2, 0x40, 0x6e, 0x5f, 0x29,
-  0x2f, 0x4c, 0x67, 0x6d, 0xf1, 0x1f, 0x4a, 0x9e, 0xb5, 0xc0, 0xbb, 0x91,
-  0x26, 0x72, 0x17, 0x33, 0x12, 0x83, 0x37, 0x99, 0xd3, 0xea, 0xde, 0x6b,
-  0x2d, 0xcb, 0xbc, 0x2a, 0xfa, 0xf2, 0x33, 0x6b, 0xc0, 0xef, 0xd1, 0xea,
-  0x6f, 0xda, 0x8a, 0xf3, 0xbd, 0x50, 0x00, 0x05, 0xc9, 0x56, 0x2e, 0xd5,
-  0x09, 0x0a, 0x0f, 0xb3, 0xa6, 0x68, 0xf4, 0x5e, 0xbb, 0xf8, 0x2b, 0xc4,
-  0x95, 0x6a, 0x58, 0x31, 0x76, 0xa4, 0xad, 0x2b, 0x76, 0x7c, 0x72, 0x78,
-  0x28, 0x97, 0x64, 0xe8, 0x32, 0x28, 0x08, 0xb3, 0x8b, 0x0c, 0x49, 0xc9,
-  0xb1, 0x01, 0x62, 0xe9, 0x21, 0xa1, 0xde, 0xae, 0x49, 0x0c, 0x5d, 0x13,
-  0x2f, 0x6a, 0x50, 0x00, 0xbe, 0x08, 0x17, 0xcc, 0x92, 0x85, 0xa5, 0xf1,
-  0xbd, 0x63, 0x4c, 0x9d, 0xf1, 0x78, 0xeb, 0xc9, 0xb6, 0xec, 0x8d, 0xab,
-  0xaf, 0xc7, 0xae, 0x90, 0x7f, 0x52, 0x13, 0xd2, 0xf2, 0x67, 0xb2, 0x4f,
-  0x2d, 0xc0, 0x14, 0xeb, 0xb4, 0x72, 0x2e, 0x0d, 0xda, 0x63, 0x9b, 0xc9,
-  0x4b, 0x92, 0xc0, 0x92, 0xf1, 0x5a, 0x05, 0x89, 0xf7, 0x78, 0xe6, 0x6a,
-  0x96, 0x5a, 0x96, 0x51, 0xc4, 0xef, 0x36, 0x0a, 0x66, 0xaa, 0xa6, 0xde,
-  0x2c, 0xe5, 0xa0, 0x65, 0x20, 0x64, 0x3e, 0x8c, 0x46, 0x2a, 0x41, 0x18,
-  0x6c, 0xbb, 0x8d, 0xa5, 0x54, 0x29, 0xcd, 0x73, 0x91, 0x2e, 0x12, 0xa3,
-  0x60, 0xba, 0x31, 0xc6, 0xe2, 0x7a, 0x02, 0x15, 0xd5, 0x37, 0xd1, 0x06,
-  0x62, 0x79, 0x97, 0x12, 0x4c, 0x21, 0xa5, 0x2f, 0x86, 0xd4, 0xc2, 0x7d,
-  0x3a, 0x2e, 0x6f, 0x5a, 0x61, 0xc7, 0x74, 0xd1, 0x78, 0xda, 0x91, 0x64,
-  0xf0, 0xc3, 0x35, 0xcf, 0x8e, 0x47, 0x76, 0xb9, 0xed, 0x88, 0x11, 0xcc,
-  0x95, 0xda, 0x8e, 0x89, 0xcc, 0x26, 0x08, 0xf7, 0x6e, 0x4c, 0xcb, 0x22,
-  0x77, 0xfa, 0x76, 0x5e, 0x35, 0x74, 0xf0, 0x16, 0x62, 0x37, 0x5d, 0x43,
-  0xf4, 0xe3, 0x2b, 0xa7, 0xdf, 0x0b, 0x9c, 0x08, 0x87, 0x85, 0x6a, 0xe1,
-  0x40, 0x44, 0x15, 0xdc, 0xa6, 0xd3, 0xb6, 0x92, 0x32, 0x18, 0x47, 0x97,
-  0xcd, 0x04, 0x33, 0x17, 0x80, 0xf7, 0x06, 0xbf, 0x89, 0xd9, 0x92, 0x6b,
-  0xa5, 0xa9, 0x87, 0x50, 0x42, 0xbb, 0xf1, 0xe8, 0xb5, 0xef, 0xf6, 0x8b,
-  0xf0, 0xd9, 0xba, 0xb5, 0xd8, 0xf9, 0x16, 0xed, 0xaa, 0x29, 0x5e, 0x44,
-  0xfb, 0xbb, 0xbb, 0x5f, 0x75, 0xa3, 0x27, 0x52, 0x4d, 0x6b, 0xef, 0x8b,
-  0xd6, 0x95, 0x93, 0x85, 0xe3, 0x9d, 0xd7, 0x70, 0xeb, 0xf8, 0x8e, 0x2f,
-  0x04, 0x59, 0xcc, 0xae, 0x2b, 0x6c, 0x38, 0x5e, 0xe6, 0x1e, 0x07, 0x4a,
-  0x36, 0x65, 0xcd, 0xfe, 0x71, 0x49, 0x3f, 0xc1, 0x50, 0x90, 0x08, 0x3d,
-  0x10, 0xd2, 0x8c, 0x63, 0x31, 0xb0, 0xab, 0x37, 0xf4, 0x5b, 0xe2, 0x13,
-  0xec, 0xa4, 0x9f, 0x96, 0x0c, 0xda, 0xe2, 0x06, 0x5c, 0x60, 0xb8, 0xcc,
-  0xf9, 0x38, 0xc3, 0xe3, 0x23, 0xd5, 0x31, 0x60, 0xc6, 0x34, 0x01, 0xcc,
-  0x6a, 0xd6, 0xb2, 0x87, 0xb5, 0xac, 0x4c, 0xa7, 0xbf, 0xae, 0xc4, 0x12,
-  0x5b, 0xa8, 0x11, 0x9a, 0x10, 0x68, 0x26, 0xdf, 0x91, 0x92, 0xc5, 0xe3,
-  0x90, 0x53, 0xe4, 0x94, 0x14, 0x09, 0x48, 0x6b, 0x43, 0x61, 0xd3, 0x72,
-  0xc2, 0x1c, 0x05, 0xb2, 0x40, 0xa5, 0xd6, 0xb1, 0xc4, 0xfe, 0x0b, 0xce,
-  0x90, 0x04, 0x9e, 0x00, 0x57, 0x49, 0x82, 0x14, 0xb0, 0x66, 0x3c, 0x2a,
-  0x69, 0xbf, 0x25, 0x2c, 0x60, 0x8a, 0x57, 0xa6, 0x2b, 0x0e, 0xa3, 0x47,
-  0xec, 0x55, 0x74, 0x9b, 0x24, 0x0b, 0x1b, 0x5f, 0x38, 0x34, 0x64, 0x2a,
-  0x8e, 0xb8, 0x80, 0x02, 0x42, 0x67, 0x7e, 0x3d, 0xab, 0xcb, 0x14, 0x70,
-  0xdd, 0x69, 0x51, 0xf6, 0xe0, 0x69, 0x5a, 0x8f, 0x0c, 0x83, 0x47, 0xd8,
-  0x95, 0x2a, 0x08, 0x31, 0x63, 0x8f, 0x9a, 0x27, 0x66, 0x5c, 0x8e, 0x03,
-  0x95, 0xbc, 0x0f, 0x4e, 0x61, 0x00, 0x43, 0xeb, 0x35, 0xa2, 0xa9, 0xa0,
-  0x56, 0xdf, 0xa5, 0xc9, 0x3d, 0xd2, 0xf1, 0x8e, 0x3d, 0x70, 0x51, 0x95,
-  0xaf, 0x18, 0x20, 0xfe, 0x2c, 0x1e, 0xdd, 0xd0, 0xb5, 0xd3, 0xe3, 0x20,
-  0xd2, 0xf5, 0x95, 0xd0, 0x0a, 0x8d, 0xcf, 0xae, 0x0c, 0x0b, 0x70, 0x12,
-  0x2e, 0x03, 0xc5, 0xea, 0xa3, 0x04, 0x78, 0x6b, 0x18, 0x44, 0xcb, 0xbd,
-  0x28, 0xd9, 0x83, 0xa0, 0xde, 0xd8, 0x43, 0xd4, 0xb0, 0xca, 0x99, 0xe5,
-  0xeb, 0xc0, 0x1e, 0x2b, 0x79, 0xd1, 0x2e, 0x45, 0x07, 0xba, 0x22, 0x46,
-  0x74, 0x76, 0x3a, 0x70, 0x78, 0x40, 0xaa, 0x7f, 0x17, 0x62, 0x64, 0x18,
-  0x40, 0x92, 0x7c, 0xbd, 0xa6, 0xd4, 0x5e, 0xa1, 0x25, 0xd4, 0x39, 0x0e,
-  0x83, 0x63, 0x0c, 0x44, 0x24, 0x4e, 0xf3, 0x4a, 0xb2, 0x39, 0x5a, 0xff,
-  0xa3, 0xc6, 0x9b, 0x02, 0xf1, 0xa3, 0x69, 0x38, 0x56, 0x3f, 0x3a, 0xd2,
-  0x89, 0xc2, 0x1a, 0x8a, 0x6c, 0x69, 0x5d, 0xcd, 0x86, 0x19, 0x09, 0xfa,
-  0xb8, 0xdc, 0x6f, 0x8b, 0xfe, 0x3f, 0x07, 0x4d, 0x54, 0xf1, 0x35, 0xf0,
-  0xe0, 0x5b, 0x36, 0xbf, 0x72, 0x8d, 0x21, 0xe0, 0x5d, 0x20, 0x1e, 0x5e,
-  0x12, 0x53, 0xfd, 0xec, 0xfb, 0x1e, 0xfd, 0xfb, 0x43, 0xc3, 0xf3, 0x52,
-  0x0a, 0x50, 0x84, 0x16, 0x4a, 0xb5, 0x08, 0xc1, 0xdc, 0xc3, 0x73, 0x4b,
-  0xd5, 0x4c, 0x6e, 0x47, 0xbe, 0x2d, 0x02, 0x60, 0xf3, 0x56, 0xf7, 0xb3,
-  0x79, 0x8c, 0xb8, 0x9c, 0x72, 0x60, 0x1d, 0xa9, 0xb4, 0x31, 0x5c, 0x11,
-  0x09, 0xdb, 0xbd, 0x47, 0xc4, 0x30, 0x8a, 0xf3, 0x51, 0x8b, 0x59, 0x49,
-  0x24, 0x30, 0x7e, 0xdd, 0xce, 0xd7, 0x70, 0x59, 0x70, 0x35, 0x7b, 0x91,
-  0x30, 0x91, 0x70, 0x61, 0x79, 0x01, 0x2a, 0x10, 0xca, 0xd0, 0x5b, 0x2a,
-  0x1e, 0x64, 0x40, 0xe1, 0x51, 0xd8, 0x06, 0x6c, 0x66, 0x9c, 0xe7, 0x80,
-  0x99, 0x11, 0x2e, 0x23, 0xa5, 0x03, 0x97, 0xf3, 0x40, 0x56, 0xf1, 0x41,
-  0x3f, 0xd4, 0xc3, 0x72, 0xd1, 0xe2, 0xe7, 0x42, 0x74, 0x77, 0x03, 0x2d,
-  0x21, 0x4c, 0x75, 0x0b, 0xc1, 0xfa, 0x5b, 0x5d, 0xff, 0x0c, 0x29, 0xbd,
-  0x6d, 0xf6, 0x40, 0x57, 0x5c, 0x41, 0xcc, 0xc1, 0xce, 0x82, 0xad, 0x61,
-  0xae, 0x12, 0xa3, 0x8f, 0xc9, 0xdd, 0xc4, 0x8d, 0x10, 0xd5, 0xec, 0x4e,
-  0xc2, 0x64, 0xe3, 0x30, 0x07, 0xdd, 0xea, 0x04, 0x6c, 0x91, 0x1a, 0xc9,
-  0xee, 0xc0, 0xb1, 0x85, 0xcf, 0xd6, 0xa1, 0xfa, 0x5b, 0x60, 0xbb, 0xe2,
-  0xe8, 0xc9, 0xb7, 0xdf, 0x56, 0x51, 0xd2, 0xb6, 0x2b, 0x34, 0x1b, 0x86,
-  0xf0, 0x49, 0xe4, 0x14, 0x11, 0x51, 0x16, 0xb5, 0x5a, 0x08, 0xb5, 0x0a,
-  0xa6, 0x86, 0x14, 0xc2, 0xf3, 0xcc, 0xda, 0x65, 0xdf, 0x45, 0x0c, 0x5b,
-  0x89, 0x42, 0x8d, 0x15, 0x0e, 0x22, 0x7a, 0x9a, 0x5e, 0x07, 0x17, 0x4e,
-  0xd1, 0x75, 0x31, 0x94, 0xe2, 0x69, 0xe7, 0x48, 0x23, 0x5b, 0x2b, 0x2c,
-  0x95, 0xaf, 0x75, 0x4d, 0xf7, 0xe0, 0xfd, 0xbc, 0xbd, 0xba, 0x42, 0xcd,
-  0xaf, 0xe2, 0x02, 0x6c, 0x34, 0x9c, 0x81, 0xb9, 0x84, 0x14, 0x02, 0x81,
-  0xe9, 0x6c, 0x94, 0x27, 0xea, 0x12, 0x29, 0xda, 0xeb, 0xce, 0x9b, 0x09,
-  0x0a, 0x21, 0x2c, 0x3c, 0x3f, 0xc4, 0x5c, 0x0a, 0x77, 0xe0, 0x9b, 0xce,
-  0xfb, 0x8e, 0xc3, 0xbd, 0xe2, 0xc7, 0xbb, 0x2d, 0x10, 0x13, 0x56, 0x22,
-  0x9b, 0x8b, 0x26, 0x98, 0x71, 0x91, 0x43, 0x5a, 0x34, 0xd5, 0x43, 0xc0,
-  0x3d, 0xfe, 0xd0, 0x5a, 0x6a, 0x0a, 0x14, 0xd0, 0xae, 0x52, 0xf4, 0xca,
-  0x7c, 0xc9, 0xcb, 0x04, 0xb8, 0x09, 0xae, 0x32, 0xec, 0xd3, 0x73, 0xe0,
-  0x48, 0xb3, 0xe8, 0x1d, 0xb9, 0x2e, 0x59, 0xa2, 0x99, 0xb1, 0x98, 0x46,
-  0x5c, 0xa1, 0xb1, 0xbb, 0x32, 0x3b, 0xb1, 0x30, 0xb1, 0x85, 0xaa, 0xea,
-  0x92, 0x96, 0x42, 0xf7, 0xfc, 0x58, 0xb1, 0xae, 0x40, 0x9d, 0x82, 0xab,
-  0x30, 0x56, 0x60, 0x36, 0xd5, 0x82, 0x12, 0x6e, 0xdd, 0x4c, 0x85, 0x31,
-  0x42, 0x52, 0xcf, 0x4b, 0x0c, 0x2a, 0xa2, 0x83, 0xf7, 0xc5, 0xf1, 0x55,
-  0xfd, 0x78, 0x31, 0xa2, 0x95, 0xaa, 0xb1, 0x1c, 0x71, 0x4e, 0x7f, 0x5f,
-  0xbc, 0xbd, 0xda, 0xf6, 0xb5, 0x9a, 0xc6, 0x59, 0xcd, 0xa4, 0x66, 0x8d,
-  0xb7, 0x04, 0xf0, 0xc7, 0x1c, 0x8e, 0xaf, 0xf9, 0xf0, 0x1c, 0x9f, 0xef,
-  0xce, 0x05, 0xdc, 0x4a, 0x4f, 0x76, 0xf7, 0x48, 0x42, 0xdc, 0xdd, 0x67,
-  0xa3, 0xd0, 0x93, 0xdd, 0x27, 0xce, 0xc2, 0x6f, 0x4f, 0x35, 0xee, 0xd6,
-  0xb1, 0xbc, 0xc8, 0x2a, 0x2b, 0x93, 0xfd, 0x93, 0x87, 0x07, 0xfe, 0xb8,
-  0x5b, 0x0b, 0x42, 0xec, 0x19, 0x18, 0x4d, 0x12, 0x94, 0xe4, 0x5b, 0x73,
-  0xbc, 0xfc, 0x8a, 0xb3, 0x69, 0x67, 0x39, 0x97, 0xd8, 0x1a, 0x28, 0xe6,
-  0x0c, 0x40, 0xf6, 0x6b, 0x07, 0x97, 0x39, 0x7e, 0xe3, 0x06, 0x5a, 0xbf,
-  0x92, 0x42, 0xca, 0x7b, 0x8c, 0x21, 0x9e, 0x42, 0xb9, 0xa9, 0xb0, 0x4f,
-  0x2b, 0x88, 0x84, 0x21, 0x30, 0x85, 0x99, 0x36, 0x6b, 0xd9, 0x64, 0xb5,
-  0xe6, 0xfe, 0x10, 0xc0, 0x0e, 0xe2, 0xa8, 0x4d, 0xe5, 0x40, 0x06, 0x5c,
-  0x95, 0x0b, 0xfc, 0x20, 0xcb, 0xc7, 0x9f, 0xce, 0xcc, 0x45, 0x40, 0xac,
-  0x9a, 0x3e, 0x41, 0xab, 0xba, 0x95, 0x22, 0x87, 0x7f, 0xbc, 0x1c, 0x25,
-  0x52, 0xd2, 0x87, 0x04, 0xfa, 0x72, 0x15, 0x0d, 0x05, 0x15, 0xce, 0x10,
-  0x13, 0x52, 0xae, 0xad, 0x6c, 0xc7, 0xa2, 0x69, 0x74, 0x00, 0x9b, 0x8c,
-  0xb5, 0xc6, 0x90, 0xcb, 0xc0, 0x14, 0xcd, 0x8e, 0x6b, 0x79, 0x59, 0x02,
-  0x68, 0x1d, 0x5f, 0x72, 0x3e, 0x31, 0x8c, 0xce, 0x26, 0x50, 0x29, 0x1f,
-  0x05, 0xf6, 0xaf, 0x99, 0xc5, 0x3c, 0x96, 0x5a, 0x6b, 0x4c, 0xaf, 0x9f,
-  0x23, 0x2a, 0xa8, 0xd6, 0xde, 0xf6, 0xaf, 0x1d, 0x65, 0xf5, 0x38, 0x41,
-  0x80, 0x29, 0xb0, 0xf4, 0x85, 0x78, 0xb0, 0x97, 0xac, 0x77, 0x7d, 0xa0,
-  0xb2, 0xcd, 0x6f, 0x6c, 0x99, 0x56, 0xba, 0xed, 0xd3, 0x41, 0x25, 0x41,
-  0xfe, 0x7e, 0x2e, 0x85, 0xa5, 0x5b, 0xab, 0x6e, 0xf3, 0x63, 0xfe, 0x96,
-  0x48, 0xab, 0xf1, 0xa5, 0x3c, 0x7b, 0x4e, 0x00, 0xeb, 0x56, 0xc1, 0x43,
-  0xd6, 0x15, 0xdd, 0x92, 0x52, 0xb3, 0xf1, 0xbc, 0x0a, 0x23, 0xc4, 0x98,
-  0xa6, 0x7c, 0x93, 0x25, 0x0f, 0xec, 0x5d, 0xa1, 0xf3, 0xfe, 0xf1, 0x93,
-  0x7e, 0xbb, 0x05, 0x27, 0x00, 0x52, 0xe7, 0x89, 0x19, 0x73, 0x13, 0x5f,
-  0x04, 0x72, 0x02, 0x90, 0xe3, 0x06, 0x14, 0xc7, 0x60, 0x76, 0x6c, 0x32,
-  0x69, 0x01, 0x0b, 0x28, 0x00, 0xee, 0x2b, 0x32, 0x6d, 0xb8, 0x93, 0x55,
-  0x44, 0x21, 0x2b, 0xb0, 0xe3, 0xd6, 0x83, 0xa7, 0xd9, 0xe2, 0xcc, 0x64,
-  0x7c, 0x5c, 0x06, 0xca, 0x5a, 0x2e, 0xac, 0x8e, 0x53, 0x63, 0xb9, 0x44,
-  0x5b, 0xe4, 0x8b, 0xc2, 0x32, 0xe9, 0x51, 0xc7, 0x38, 0x9f, 0x37, 0xaa,
-  0xd1, 0x21, 0xbd, 0x16, 0x62, 0x3b, 0x07, 0x28, 0x5e, 0x55, 0xea, 0xf8,
-  0x79, 0xba, 0x98, 0xed, 0x08, 0x69, 0xb0, 0x8a, 0xfa, 0x52, 0xa8, 0xad,
-  0x41, 0x18, 0x6f, 0x94, 0x14, 0x44, 0x8f, 0x9d, 0x2b, 0x51, 0xea, 0xe9,
-  0xe6, 0xcc, 0x81, 0xa9, 0xc1, 0x5e, 0xd0, 0xe9, 0xca, 0xa0, 0x3e, 0x7a,
-  0x1b, 0x5c, 0x8b, 0x5f, 0x8b, 0xee, 0xe5, 0x7e, 0x00, 0x1f, 0x18, 0x44,
-  0x38, 0x2b, 0x8c, 0x6d, 0x6a, 0xe0, 0xe4, 0x43, 0x84, 0x74, 0x47, 0x7f,
-  0xcd, 0x86, 0x2a, 0x74, 0xe0, 0xd2, 0x6c, 0xc7, 0x6c, 0x9c, 0x70, 0x1c,
-  0x2b, 0x69, 0xde, 0xa4, 0xf5, 0x8b, 0x4b, 0x10, 0x43, 0x9a, 0x27, 0x25,
-  0xd4, 0x4e, 0x8e, 0x72, 0x15, 0xdd, 0x20, 0x8a, 0xae, 0xa5, 0xb6, 0xdc,
-  0x58, 0x44, 0x14, 0x5c, 0xe0, 0x0d, 0x9c, 0x29, 0x57, 0x36, 0x45, 0xe5,
-  0x52, 0x5e, 0x1e, 0x78, 0xbd, 0xfe, 0xa9, 0x82, 0xaf, 0x1f, 0xa2, 0xc2,
-  0xbe, 0xe1, 0xfd, 0x98, 0x2f, 0x1b, 0xe9, 0x3b, 0x6f, 0xf8, 0xc3, 0x7e,
-  0x74, 0x24, 0xf1, 0x9e, 0xe2, 0x84, 0x58, 0x6a, 0xd6, 0x93, 0xd4, 0xd7,
-  0xf4, 0xad, 0xcc, 0x77, 0x50, 0xf0, 0xb2, 0xcc, 0x47, 0x8d, 0x46, 0x9c,
-  0x44, 0x54, 0x8c, 0xd4, 0xfc, 0xd0, 0xe7, 0x07, 0x2b, 0xce, 0x0d, 0x88,
-  0x38, 0x1c, 0xbe, 0x6f, 0x1e, 0x02, 0x55, 0x35, 0x9b, 0x5a, 0x08, 0x63,
-  0x10, 0xb5, 0x55, 0xe0, 0x74, 0x78, 0x89, 0x12, 0xd0, 0x28, 0x8a, 0xb1,
-  0x78, 0xd7, 0x80, 0x5d, 0xa4, 0xae, 0xa7, 0xfe, 0x9a, 0x8c, 0x36, 0x3e,
-  0xcc, 0x30, 0xa6, 0x87, 0xa0, 0xa8, 0x86, 0xfd, 0x2c, 0x4e, 0xa6, 0x46,
-  0x75, 0xd3, 0x96, 0x8d, 0xe4, 0x99, 0x6d, 0x3d, 0xdd, 0x8e, 0xa4, 0xd7,
-  0xad, 0xbd, 0x6d, 0xc1, 0x8d, 0xd2, 0x84, 0x62, 0x95, 0x8f, 0xc5, 0xe7,
-  0xac, 0x25, 0x63, 0xc2, 0xba, 0x82, 0x65, 0xb3, 0x20, 0xb8, 0x48, 0x40,
-  0x7c, 0x98, 0x63, 0x0d, 0xad, 0xa0, 0xc3, 0x2e, 0x32, 0x63, 0x90, 0xbe,
-  0xb3, 0x80, 0x8b, 0xa5, 0xd0, 0xf2, 0x92, 0x5b, 0x70, 0x29, 0xb7, 0x66,
-  0x50, 0x82, 0xf1, 0xb0, 0xa4, 0x49, 0x6b, 0x06, 0x87, 0xf0, 0x1c, 0x54,
-  0x7a, 0x9d, 0x67, 0x38, 0xfe, 0x70, 0x90, 0x63, 0xba, 0x56, 0xb1, 0xbd,
-  0xcd, 0xe5, 0xd7, 0xc8, 0x01, 0x3a, 0x7f, 0x73, 0xdc, 0xf1, 0xf7, 0x48,
-  0xe0, 0x81, 0xac, 0x6e, 0x64, 0x83, 0x7e, 0x0f, 0xa2, 0xbf, 0x2d, 0xd3,
-  0xd1, 0x2d, 0xef, 0x21, 0x07, 0xd8, 0xb0, 0x5f, 0x29, 0x71, 0x32, 0x1d,
-  0xb1, 0x7c, 0x46, 0x09, 0x2d, 0x45, 0x03, 0xc4, 0xf8, 0xe8, 0x42, 0x55,
-  0xca, 0x69, 0x1e, 0x70, 0x61, 0x07, 0x4e, 0xf2, 0xc6, 0x86, 0x6b, 0x4e,
-  0xa1, 0xda, 0x41, 0x44, 0x5c, 0x1f, 0x67, 0x33, 0x5a, 0x4d, 0x38, 0x48,
-  0x64, 0xc3, 0xd7, 0xc1, 0x1a, 0xc3, 0xfa, 0xb8, 0x42, 0x6a, 0xab, 0x65,
-  0x42, 0x3b, 0x59, 0x03, 0x44, 0x9a, 0x90, 0x8e, 0xc0, 0xe0, 0x1b, 0x1a,
-  0x6d, 0xc5, 0x26, 0x8e, 0x47, 0xb2, 0xf7, 0xd7, 0x0d, 0x41, 0x48, 0x59,
-  0x3a, 0xf2, 0x3d, 0x48, 0xf3, 0xbf, 0xf2, 0xcd, 0x2d, 0xeb, 0xb8, 0x44,
-  0x12, 0x63, 0x78, 0x65, 0xf3, 0xc7, 0x3d, 0xf3, 0xd2, 0xd7, 0xde, 0xf9,
-  0x9a, 0xa1, 0x5e, 0x8b, 0x30, 0x29, 0x9d, 0x9f, 0xef, 0x6a, 0xda, 0xae,
-  0x1f, 0x9d, 0x98, 0x5f, 0x83, 0xa3, 0xce, 0x1d, 0xb5, 0xc6, 0x81, 0xc4,
-  0x53, 0x17, 0xe3, 0x00, 0x23, 0x4f, 0x6c, 0xc5, 0x27, 0x84, 0x19, 0xca,
-  0xdb, 0xb0, 0x2d, 0x55, 0x47, 0xa9, 0x01, 0x5b, 0x8f, 0x17, 0x26, 0xae,
-  0xc4, 0x76, 0x35, 0x0f, 0x2f, 0xdf, 0xca, 0x95, 0x67, 0xea, 0xdb, 0x26,
-  0xa8, 0xbe, 0x90, 0xe3, 0xc7, 0x09, 0x50, 0x53, 0x24, 0xf1, 0xf9, 0x4d,
-  0x3a, 0xca, 0xb3, 0x22, 0x9b, 0x88, 0x54, 0xe0, 0x61, 0xfa, 0xd4, 0xc0,
-  0x84, 0xac, 0xcd, 0x18, 0xf8, 0xfe, 0xcd, 0x4b, 0x63, 0xa4, 0xb5, 0xe1,
-  0x60, 0xf9, 0x85, 0x20, 0x4e, 0x97, 0xfe, 0x8c, 0xce, 0x15, 0xcc, 0x7a,
-  0x30, 0x04, 0x97, 0x62, 0x17, 0x8f, 0x03, 0xfc, 0x2d, 0x76, 0xd4, 0x5b,
-  0x80, 0xe0, 0xb3, 0xc7, 0xf5, 0x5a, 0x6c, 0x82, 0xd6, 0x77, 0x50, 0xc3,
-  0x2d, 0x42, 0x73, 0xb8, 0xea, 0x86, 0x82, 0xbf, 0x88, 0x26, 0x62, 0xaf,
-  0xad, 0x1b, 0x9f, 0xce, 0xbb, 0x10, 0xec, 0x5f, 0xc5, 0x60, 0x0d, 0x4b,
-  0xa8, 0x71, 0x84, 0x5b, 0x74, 0x72, 0x7c, 0xf5, 0x9a, 0xa8, 0x2b, 0x8f,
-  0x69, 0x21, 0xe4, 0x47, 0xa3, 0x72, 0x7b, 0x9e, 0xfc, 0x18, 0xdf, 0xf6,
-  0x8a, 0x05, 0xf6, 0xab, 0x07, 0xde, 0xda, 0xdb, 0x7d, 0xda, 0x2f, 0x1f,
-  0xda, 0xf3, 0x79, 0xd9, 0xea, 0x6c, 0xc6, 0x4b, 0xe5, 0xbb, 0x7e, 0xf7,
-  0x34, 0x83, 0x0e, 0xd7, 0x75, 0xf6, 0xb0, 0xaa, 0x23, 0xca, 0xb5, 0x95,
-  0xe6, 0x84, 0xbd, 0xa7, 0xd7, 0xe3, 0xc7, 0x3d, 0xc1, 0xfc, 0xd3, 0xa1,
-  0x85, 0xbc, 0x92, 0x1a, 0x3c, 0xb8, 0x16, 0x57, 0x2e, 0xc4, 0x3a, 0x6e,
-  0x0b, 0x20, 0x7c, 0x2c, 0x64, 0x70, 0x4d, 0x06, 0x91, 0x8b, 0x21, 0xac,
-  0x10, 0xec, 0xba, 0xc2, 0x9e, 0x0d, 0x9c, 0x6f, 0x2c, 0x2e, 0xc7, 0x91,
-  0x31, 0x65, 0x58, 0xa0, 0x31, 0xb0, 0x72, 0xd8, 0xba, 0xf3, 0x9e, 0xd2,
-  0xd7, 0x92, 0x37, 0x08, 0x28, 0x29, 0x83, 0xb8, 0xaa, 0x91, 0x1e, 0xcb,
-  0xbf, 0xe6, 0x9a, 0xec, 0x73, 0x95, 0x4d, 0xb6, 0x76, 0x37, 0xb9, 0x6a,
-  0x6f, 0x19, 0xbd, 0x50, 0xd0, 0x9a, 0x64, 0xce, 0xf5, 0xdc, 0xf5, 0xac,
-  0xcb, 0x0d, 0x2b, 0x65, 0xed, 0xaa, 0xa0, 0xf2, 0x22, 0x86, 0x69, 0xc5,
-  0xcb, 0x65, 0xfb, 0x08, 0xe3, 0x3c, 0x91, 0x1b, 0x51, 0xe2, 0xfd, 0xf4,
-  0xee, 0xff, 0xb7, 0xe6, 0x8d, 0x9f, 0x41, 0x20, 0xca, 0x7a, 0xc3, 0x25,
-  0xbe, 0xab, 0xbd, 0x78, 0x24, 0x3c, 0x59, 0x66, 0x2e, 0x4f, 0xa8, 0xe3,
-  0x36, 0x70, 0xbe, 0x16, 0x08, 0xaf, 0x9b, 0x85, 0x95, 0x23, 0xb8, 0x1e,
-  0x34, 0xe9, 0x94, 0x4d, 0xaa, 0x5b, 0x0a, 0x67, 0xa9, 0xa5, 0x38, 0xd6,
-  0x2c, 0xf1, 0xd2, 0x11, 0x4c, 0x42, 0x61, 0x07, 0x6d, 0x4e, 0x6e, 0x7e,
-  0x9d, 0x1d, 0x94, 0x1c, 0x3a, 0x22, 0x4a, 0x85, 0x04, 0xf8, 0xaa, 0x8e,
-  0xae, 0x4d, 0x18, 0x0a, 0x2b, 0x03, 0x02, 0xdc, 0x2c, 0x49, 0xd8, 0xed,
-  0xb6, 0x48, 0x31, 0x66, 0x74, 0x65, 0x4e, 0x47, 0x17, 0xbc, 0x26, 0x3e,
-  0x5b, 0x16, 0x89, 0xb4, 0x80, 0xfc, 0xda, 0x3b, 0x46, 0x98, 0x6b, 0xe0,
-  0xd4, 0xb7, 0x8d, 0xce, 0x97, 0x7a, 0x8e, 0x4b, 0xbf, 0x84, 0xff, 0xa4,
-  0x19, 0xde, 0xee, 0x4c, 0xf5, 0xc7, 0x44, 0x8d, 0xae, 0x5b, 0x3a, 0xe2,
-  0x5d, 0xd6, 0x1c, 0x99, 0x74, 0xdc, 0x5e, 0xcb, 0x4c, 0xf7, 0xdb, 0xa3,
-  0xdb, 0x6a, 0x95, 0x74, 0xa4, 0x85, 0x58, 0x2a, 0xd2, 0xc9, 0x11, 0xf1,
-  0x5f, 0xc8, 0x09, 0xd7, 0xb4, 0x04, 0x9f, 0xaf, 0xd6, 0xe0, 0x45, 0x33,
-  0x82, 0xb8, 0x29, 0x55, 0xec, 0xa4, 0xe3, 0xba, 0x25, 0xde, 0x32, 0x84,
-  0x36, 0x92, 0x30, 0xe7, 0x5f, 0x7c, 0xa4, 0x96, 0x13, 0xd6, 0xac, 0xc4,
-  0x9a, 0xbb, 0x6c, 0x5b, 0x8e, 0x92, 0x20, 0x09, 0x1f, 0x17, 0xcf, 0x70,
-  0x65, 0xf9, 0x29, 0x0a, 0xb1, 0x91, 0x27, 0x0a, 0xdf, 0x1a, 0x0c, 0xb8,
-  0x68, 0x61, 0xbc, 0x88, 0xc6, 0x4f, 0x92, 0x99, 0x3a, 0x6b, 0x86, 0x79,
-  0x76, 0x4b, 0xbb, 0x8c, 0xd7, 0x58, 0xbc, 0x83, 0x2c, 0x29, 0xa4, 0x6a,
-  0x82, 0x3f, 0xad, 0xbb, 0xe4, 0x69, 0xb7, 0x18, 0x65, 0x72, 0x83, 0xbc,
-  0xd4, 0x04, 0x09, 0xbf, 0xe7, 0x02, 0x0c, 0xc3, 0x41, 0x71, 0x76, 0x35,
-  0x30, 0x1f, 0x45, 0xf5, 0x0f, 0x0f, 0xb6, 0xda, 0xd0, 0xd9, 0x7e, 0x1e,
-  0xb8, 0xe7, 0x4f, 0xa6, 0x12, 0xdd, 0x5d, 0x79, 0x4f, 0x92, 0xa7, 0x64,
-  0x5b, 0x42, 0xa2, 0x29, 0xa7, 0x33, 0x97, 0xbd, 0x6a, 0x12, 0x4b, 0x74,
-  0x76, 0x75, 0xfa, 0x26, 0x5a, 0x23, 0xaa, 0xf0, 0x77, 0xd5, 0xaf, 0xfe,
-  0x19, 0x81, 0x85, 0xbe, 0x38, 0x39, 0x19, 0xb0, 0xb8, 0xa2, 0x4e, 0xb3,
-  0x86, 0x6a, 0x54, 0x8a, 0xf7, 0x06, 0x8c, 0x3d, 0x4f, 0x49, 0x83, 0xa1,
-  0x5b, 0xcc, 0x17, 0xa9, 0x87, 0xda, 0x9c, 0xa3, 0x21, 0x29, 0x10, 0xca,
-  0x8c, 0x05, 0xb0, 0x30, 0x53, 0xa6, 0xa9, 0x45, 0xd2, 0xe2, 0xdb, 0x87,
-  0x5c, 0xcf, 0x43, 0x30, 0x52, 0x50, 0x24, 0x11, 0xb0, 0x2c, 0xd4, 0xd5,
-  0x1a, 0xab, 0x7e, 0x44, 0x52, 0x14, 0xf1, 0x1c, 0x5c, 0x77, 0xaa, 0xd5,
-  0xdd, 0xa6, 0x1c, 0xb7, 0xb4, 0x06, 0x3b, 0xdd, 0x13, 0x30, 0x47, 0xca,
-  0x42, 0x71, 0x19, 0x67, 0x39, 0x1b, 0xf8, 0x03, 0x60, 0x00, 0x00, 0xc7,
-  0x2c, 0xd9, 0x65, 0x8f, 0x01, 0xae, 0x9a, 0x71, 0xc9, 0xf7, 0x37, 0x99,
-  0xb8, 0xcb, 0x79, 0xa1, 0x41, 0x4d, 0xb2, 0xbf, 0x6c, 0xc8, 0x97, 0xa4,
-  0x72, 0xb9, 0x99, 0x2c, 0x61, 0x92, 0xeb, 0x1b, 0xbb, 0xfd, 0x58, 0x13,
-  0xd9, 0x63, 0x95, 0x6d, 0x24, 0xc5, 0x81, 0xee, 0x46, 0xd8, 0x6f, 0x68,
-  0x83, 0x8e, 0xd2, 0xeb, 0x75, 0xc8, 0x26, 0xad, 0x92, 0x10, 0xc6, 0xf4,
-  0xb8, 0x10, 0xd4, 0x16, 0xe4, 0x58, 0x11, 0x82, 0x88, 0xe2, 0x7e, 0xa9,
-  0xd4, 0x0a, 0x1c, 0xe8, 0xc7, 0xe4, 0x9f, 0xf7, 0x08, 0x39, 0xb5, 0xbc,
-  0x08, 0x4c, 0xee, 0xdf, 0x7a, 0x57, 0x67, 0x34, 0x52, 0xbd, 0xd1, 0x1e,
-  0x29, 0x65, 0x6f, 0x77, 0x5e, 0xa6, 0x0f, 0x85, 0x80, 0x24, 0x45, 0x39,
-  0xce, 0x96, 0xe2, 0x0e, 0x62, 0xeb, 0x54, 0x6e, 0x3c, 0xf9, 0xef, 0xff,
-  0x68, 0xfa, 0xb7, 0xbe, 0xff, 0x41, 0xcb, 0xb2, 0x70, 0xc0, 0xa0, 0x8f,
-  0x9e, 0x33, 0xc2, 0x2a, 0x3c, 0x92, 0x13, 0x36, 0xd0, 0x82, 0xf4, 0x65,
-  0x9a, 0x72, 0xcc, 0x1a, 0xd8, 0xd8, 0xe2, 0xda, 0x55, 0xa6, 0xaa, 0xe3,
-  0xb3, 0xb4, 0x27, 0xce, 0xfa, 0x0f, 0x6a, 0x12, 0xba, 0x9a, 0xb3, 0x91,
-  0xa1, 0x85, 0x8c, 0xd7, 0x81, 0x6e, 0x58, 0x94, 0xad, 0xc2, 0x3a, 0x58,
-  0xb4, 0x2c, 0x82, 0x1b, 0xc5, 0x5a, 0xc8, 0x73, 0x00, 0xcb, 0x3d, 0x95,
-  0x72, 0x0f, 0xcd, 0x2c, 0x6d, 0xd9, 0x6c, 0x8d, 0x53, 0xfc, 0x3b, 0xca,
-  0x81, 0x97, 0xf7, 0xd9, 0x3f, 0xfa, 0xb0, 0x8d, 0xb3, 0x16, 0xdc, 0xcb,
-  0x04, 0xc5, 0xed, 0xdd, 0x47, 0x7b, 0x50, 0x0e, 0x3a, 0x4d, 0xec, 0x3a,
-  0x5e, 0x05, 0xdb, 0x77, 0x17, 0x7c, 0xbc, 0x26, 0x29, 0xbc, 0xda, 0x1d,
-  0x7a, 0xe9, 0x42, 0xef, 0xfe, 0x47, 0x1f, 0xff, 0x7e, 0xbf, 0xd7, 0x7b,
-  0xf6, 0x83, 0xeb, 0xf5, 0xa3, 0xbd, 0x77, 0x1f, 0xed, 0x77, 0x5a, 0xe1,
-  0xed, 0xb8, 0x4e, 0xb6, 0x82, 0xa2, 0x87, 0xfe, 0x93, 0x58, 0x0b, 0xa1,
-  0x89, 0x7b, 0x3a, 0x2e, 0x7c, 0x28, 0x97, 0x83, 0xdf, 0x69, 0x16, 0x63,
-  0x2f, 0xde, 0x03, 0xfc, 0x11, 0x56, 0x17, 0xb2, 0x9e, 0x5c, 0xfd, 0x1d,
-  0x45, 0xd2, 0x64, 0x3f, 0xbd, 0xd9, 0x53, 0x5a, 0x10, 0x16, 0x10, 0x96,
-  0x30, 0x5e, 0x91, 0xfc, 0x2c, 0xb6, 0xaf, 0x80, 0xb8, 0xcf, 0x19, 0x42,
-  0x04, 0x28, 0x19, 0xbd, 0x16, 0x4b, 0xc7, 0x37, 0x9a, 0xa6, 0xe1, 0x68,
-  0x3b, 0xd6, 0xbe, 0x82, 0x92, 0x92, 0x0a, 0xc3, 0x97, 0x18, 0xd8, 0x86,
-  0x94, 0x4c, 0x66, 0xc4, 0x96, 0x06, 0x92, 0x05, 0x27, 0x7f, 0x38, 0x1b,
-  0x57, 0x08, 0xb4, 0x12, 0xbe, 0xac, 0x87, 0xb9, 0xeb, 0x0b, 0x5a, 0x73,
-  0x2d, 0x86, 0x65, 0x23, 0xec, 0x61, 0x32, 0xe9, 0x6f, 0xb7, 0x86, 0xb2,
-  0x19, 0xee, 0x87, 0x0f, 0x00, 0x8c, 0xc2, 0x92, 0xec, 0x85, 0xc0, 0x97,
-  0x41, 0xcd, 0x90, 0x1a, 0xe1, 0xc9, 0x78, 0x5d, 0x78, 0xb2, 0x2b, 0x76,
-  0xd3, 0x75, 0x89, 0xf3, 0xc9, 0xb4, 0x48, 0x5a, 0x61, 0x20, 0x41, 0x16,
-  0x4b, 0x83, 0xa6, 0x73, 0x25, 0x97, 0x43, 0x92, 0x60, 0x15, 0x9e, 0x39,
-  0xb8, 0x24, 0x67, 0x5b, 0xc4, 0xdb, 0x7b, 0xe8, 0xa2, 0x87, 0x7a, 0x0b,
-  0x45, 0xf4, 0x72, 0x71, 0x93, 0xd3, 0x45, 0xf8, 0x48, 0x22, 0x29, 0x9e,
-  0x92, 0x87, 0xdc, 0x61, 0x0c, 0x8a, 0x37, 0xff, 0x8a, 0xe9, 0x8c, 0x08,
-  0x18, 0x7d, 0xb2, 0xbb, 0x57, 0xdf, 0x8b, 0x4a, 0xc5, 0xc6, 0x9c, 0xcb,
-  0xa9, 0x95, 0x5c, 0xdb, 0x27, 0x8a, 0xf6, 0x3f, 0xde, 0xfb, 0x78, 0x67,
-  0x6f, 0xb7, 0xff, 0xa4, 0xbf, 0xaf, 0x3a, 0x1d, 0x5b, 0x1f, 0x49, 0x90,
-  0xba, 0xe3, 0xe2, 0xd0, 0x70, 0xdb, 0xb6, 0x7b, 0x3a, 0x21, 0xdd, 0x51,
-  0x73, 0xf0, 0xc9, 0xba, 0x4f, 0x58, 0x5d, 0xf0, 0x9c, 0x3e, 0x86, 0x53,
-  0xd6, 0xf9, 0xe0, 0x0c, 0xee, 0xba, 0xa5, 0x62, 0x00, 0x86, 0xa2, 0x92,
-  0xc2, 0x92, 0x13, 0xb1, 0x96, 0xc3, 0x94, 0xee, 0xb9, 0x12, 0x85, 0x52,
-  0x90, 0x79, 0x45, 0xf2, 0x8f, 0xa5, 0xbe, 0x4b, 0x38, 0x6c, 0x50, 0x50,
-  0xa9, 0x0d, 0xd3, 0x56, 0x86, 0x2f, 0x19, 0xf1, 0x41, 0x6e, 0xb5, 0x84,
-  0x5c, 0xa5, 0x82, 0xb2, 0xc7, 0xb9, 0xd4, 0x74, 0x37, 0x30, 0x56, 0xfd,
-  0x97, 0xc4, 0xb3, 0x19, 0xd0, 0x35, 0x6e, 0x8d, 0x55, 0x52, 0x17, 0xa5,
-  0x5e, 0xbd, 0xb1, 0x38, 0xb3, 0x79, 0x2d, 0xd1, 0x9c, 0x7d, 0x20, 0xf8,
-  0xe3, 0xec, 0xfc, 0x81, 0xda, 0x8e, 0x79, 0xb7, 0xc3, 0xac, 0xa4, 0x0e,
-  0xee, 0xd8, 0xef, 0x39, 0x8c, 0x4b, 0xb4, 0x66, 0xf0, 0x78, 0x70, 0xb0,
-  0xc3, 0xbd, 0xb7, 0x12, 0x3c, 0x1a, 0xc2, 0xf2, 0x08, 0x2a, 0x8d, 0x88,
-  0x14, 0x44, 0xf6, 0x10, 0x42, 0x1e, 0xa5, 0x89, 0x05, 0x5b, 0x79, 0x69,
-  0xe8, 0xa9, 0x64, 0x1f, 0xd4, 0x4c, 0x07, 0x26, 0xb3, 0x6a, 0xed, 0x95,
-  0xd9, 0x6c, 0xd9, 0x52, 0xdc, 0xd4, 0xea, 0xbd, 0xa8, 0xf4, 0x51, 0xfa,
-  0x58, 0x56, 0x11, 0x85, 0x2a, 0x70, 0x09, 0x1a, 0x45, 0x26, 0x41, 0x64,
-  0x7c, 0xfa, 0xdb, 0x89, 0x6c, 0xc7, 0xb9, 0xf8, 0x73, 0x24, 0xee, 0xf4,
-  0xe8, 0x86, 0x5b, 0x34, 0x6a, 0xce, 0xed, 0x6f, 0xff, 0x92, 0x81, 0x5d,
-  0x2d, 0xdc, 0x47, 0x44, 0x39, 0x6a, 0x02, 0x8b, 0x59, 0x97, 0xfc, 0x1b,
-  0x0b, 0xce, 0xd8, 0x0f, 0xad, 0xcb, 0xed, 0x51, 0xad, 0x31, 0xf7, 0xb5,
-  0x2e, 0x61, 0x2d, 0xa5, 0x82, 0x75, 0xb6, 0x55, 0x5d, 0x77, 0xf5, 0x6b,
-  0x51, 0x64, 0x59, 0x5f, 0x16, 0xe8, 0xa4, 0x7b, 0x29, 0x26, 0x06, 0xb1,
-  0x14, 0x5b, 0x12, 0xf4, 0x24, 0x56, 0xc6, 0xc6, 0x62, 0x7b, 0x7c, 0x26,
-  0x28, 0xb6, 0xfc, 0x24, 0x73, 0xfb, 0xb0, 0x84, 0x57, 0x3b, 0x51, 0x60,
-  0x4a, 0x4d, 0x81, 0xb6, 0x90, 0x8e, 0x30, 0xb0, 0x7f, 0x41, 0xf1, 0x39,
-  0xd9, 0x9f, 0xb5, 0xeb, 0xd9, 0xdc, 0xa2, 0x31, 0x0b, 0xf6, 0x8f, 0xec,
-  0x51, 0xb8, 0x45, 0xa2, 0x05, 0xfc, 0xa2, 0x7b, 0x24, 0xfd, 0xb7, 0x6c,
-  0x92, 0xf6, 0xd5, 0x1a, 0xfd, 0xa2, 0xbb, 0xc4, 0x9b, 0xf4, 0x2b, 0x07,
-  0x91, 0x04, 0x0b, 0x5a, 0xd7, 0x81, 0x1a, 0xe6, 0xda, 0x47, 0x19, 0x8b,
-  0x5b, 0xc4, 0x75, 0x36, 0xfe, 0xfa, 0x3a, 0xb6, 0x7b, 0x71, 0x1f, 0xe1,
-  0x29, 0xb2, 0xa0, 0xf3, 0x8a, 0x11, 0xba, 0xb2, 0xa6, 0x75, 0x77, 0xbf,
-  0x7b, 0x52, 0xa3, 0xf0, 0xde, 0xb3, 0xac, 0xbf, 0x12, 0x9d, 0x7a, 0xf3,
-  0xf0, 0x07, 0xb0, 0x70, 0x68, 0x85, 0xef, 0x61, 0x28, 0xc1, 0x4a, 0x37,
-  0x4d, 0x10, 0xff, 0x1c, 0xb1, 0xb2, 0x15, 0xa4, 0xb2, 0xac, 0xdc, 0x45,
-  0x65, 0xf9, 0xea, 0xf8, 0x1f, 0xff, 0x5a, 0x1a, 0x15, 0xdd, 0xd4, 0x16,
-  0x6d, 0xb1, 0xa3, 0xeb, 0x56, 0x22, 0x94, 0x74, 0xda, 0x66, 0x7d, 0xe7,
-  0x62, 0xbc, 0xf4, 0xa2, 0xb4, 0x61, 0xdb, 0xba, 0xd5, 0x7b, 0xb0, 0x57,
-  0xb7, 0xbb, 0x2d, 0x51, 0x96, 0x7c, 0x65, 0xb5, 0x48, 0x2f, 0x82, 0x15,
-  0x6b, 0x56, 0x17, 0x83, 0xf0, 0xd3, 0x1a, 0x9d, 0x92, 0xae, 0xc4, 0x23,
-  0x71, 0x35, 0x6d, 0x23, 0xc3, 0x4a, 0x7c, 0x58, 0xad, 0x87, 0xcf, 0x9c,
-  0x91, 0x06, 0x3c, 0xb5, 0x08, 0xbe, 0xb4, 0xd4, 0xb2, 0x13, 0x8c, 0x40,
-  0xc5, 0xb2, 0xbe, 0x0b, 0xa5, 0x50, 0x8c, 0x3e, 0x74, 0xd2, 0x72, 0x2d,
-  0xa3, 0xdb, 0x78, 0x41, 0x7d, 0x21, 0x34, 0x4a, 0x6a, 0x29, 0x03, 0xb5,
-  0xc6, 0xef, 0x78, 0xb0, 0x10, 0x87, 0xe7, 0x67, 0x67, 0xc7, 0x87, 0x1e,
-  0xc4, 0xb6, 0x19, 0xdd, 0xd2, 0x34, 0x3f, 0xa8, 0x99, 0x43, 0xa2, 0x05,
-  0x35, 0x86, 0x4b, 0xc3, 0x23, 0xcc, 0xbb, 0xab, 0x27, 0x0c, 0x76, 0x84,
-  0x76, 0x8d, 0x58, 0x9c, 0xf9, 0xf1, 0x5c, 0xa2, 0x17, 0x75, 0xb1, 0x6c,
-  0xad, 0xca, 0xec, 0x5f, 0x43, 0x49, 0xd2, 0x6d, 0x85, 0xd1, 0x2d, 0x87,
-  0x8f, 0xa0, 0xc6, 0x40, 0xd0, 0x17, 0x83, 0xd3, 0xa3, 0x80, 0x31, 0xce,
-  0x91, 0x23, 0x46, 0x95, 0xb5, 0xc8, 0x87, 0xff, 0x72, 0xb8, 0x98, 0x8b,
-  0x9d, 0xa0, 0x04, 0xe1, 0x4b, 0x85, 0x7d, 0x6b, 0x47, 0x41, 0xb9, 0x14,
-  0x33, 0x62, 0x11, 0x64, 0x77, 0x97, 0x59, 0xbe, 0x33, 0x65, 0xf1, 0x19,
-  0xc1, 0xd2, 0xd9, 0xd4, 0xaa, 0x65, 0x07, 0x95, 0xf9, 0x5a, 0x2e, 0x31,
-  0xea, 0xcf, 0x89, 0x81, 0x66, 0x99, 0x15, 0x3f, 0xb4, 0x44, 0x58, 0xb8,
-  0x1a, 0x75, 0xa8, 0xb5, 0xe6, 0x72, 0x0a, 0xfc, 0xa1, 0xa8, 0xe7, 0xf2,
-  0xa2, 0xba, 0x1a, 0x7c, 0x2f, 0x0b, 0x68, 0x8f, 0x29, 0x60, 0x6b, 0xf9,
-  0xc5, 0x52, 0x98, 0x63, 0xa5, 0xe4, 0x18, 0xb6, 0xc2, 0xe8, 0xd2, 0x52,
-  0x08, 0x1b, 0xa0, 0x58, 0xa9, 0x14, 0xec, 0x28, 0x42, 0x28, 0x69, 0x03,
-  0xc4, 0x93, 0xec, 0xb8, 0xbc, 0xec, 0xaa, 0xb5, 0x9e, 0x8b, 0xdf, 0x71,
-  0x41, 0x66, 0x1f, 0x36, 0xde, 0x12, 0x0b, 0x06, 0x24, 0xd8, 0x45, 0xa3,
-  0x11, 0x45, 0x9a, 0x98, 0x5b, 0xc4, 0xa3, 0xdf, 0x00, 0x6f, 0x28, 0x6d,
-  0xe4, 0xf2, 0x09, 0x62, 0x4b, 0xc3, 0x9a, 0xe2, 0xa0, 0xf5, 0xda, 0x2b,
-  0x6d, 0xa6, 0x7d, 0xd4, 0xfc, 0x04, 0xea, 0x5e, 0xa7, 0x8a, 0x69, 0x20,
-  0x01, 0x8f, 0xee, 0x6d, 0x9e, 0x77, 0x00, 0x00, 0xd8, 0x0c, 0x98, 0xb4,
-  0xbb, 0x42, 0xad, 0x9e, 0x2c, 0xbf, 0x6f, 0xbd, 0x9d, 0xa7, 0x0f, 0xac,
-  0xb1, 0x34, 0x85, 0x70, 0xd7, 0xd6, 0xfa, 0x81, 0x75, 0xf6, 0x9e, 0xef,
-  0xf7, 0xf7, 0x3e, 0xfe, 0xb4, 0x4f, 0x2a, 0xe8, 0x5e, 0x27, 0x84, 0x6c,
-  0x60, 0x17, 0x14, 0xda, 0x10, 0x1e, 0xb1, 0xd1, 0x72, 0xc3, 0xb4, 0x05,
-  0x85, 0x84, 0x6d, 0xcf, 0x56, 0xfd, 0x20, 0x9a, 0xa3, 0xd2, 0xba, 0x46,
-  0x7b, 0xd4, 0x5b, 0xed, 0x05, 0x76, 0x48, 0x66, 0x4a, 0xac, 0x18, 0xb9,
-  0x60, 0xde, 0x4a, 0xe5, 0x44, 0x41, 0xd2, 0x71, 0xd5, 0x07, 0xdb, 0xc0,
-  0x90, 0x03, 0x32, 0x68, 0xaf, 0x49, 0xe8, 0xfa, 0x6f, 0x70, 0xb4, 0x9f,
-  0x7c, 0xb0, 0xe1, 0xbf, 0x0a, 0xd8, 0xbf, 0xfa, 0x60, 0x12, 0xf3, 0x73,
-  0xf0, 0xb9, 0x90, 0xb0, 0x7e, 0x57, 0x35, 0xb5, 0xef, 0x7c, 0x5e, 0xec,
-  0x2e, 0x0e, 0x2f, 0xac, 0x7a, 0xa9, 0x41, 0xae, 0x7a, 0xe8, 0x0e, 0x64,
-  0x05, 0xfc, 0x9c, 0x5b, 0x76, 0xa1, 0xe6, 0x90, 0x6d, 0xb9, 0xcd, 0x5e,
-  0xb2, 0x80, 0x91, 0x99, 0x5f, 0xa4, 0xc9, 0xd0, 0x22, 0x4d, 0x7d, 0xf2,
-  0x15, 0xde, 0xf9, 0xc3, 0x1f, 0x02, 0x66, 0xf4, 0xb7, 0x4a, 0x9c, 0x97,
-  0xba, 0x9b, 0x05, 0x10, 0xc1, 0x83, 0xac, 0x64, 0xf3, 0x0a, 0xba, 0xa2,
-  0x24, 0x14, 0xab, 0xc2, 0xcf, 0xc9, 0xed, 0xcd, 0xec, 0xa9, 0x00, 0x09,
-  0xc2, 0x15, 0x6a, 0x1a, 0x26, 0x02, 0x33, 0xa2, 0xd8, 0x4d, 0x1a, 0xac,
-  0xcf, 0x46, 0xbe, 0x00, 0xa1, 0xa4, 0x19, 0xd4, 0x56, 0x8b, 0x0f, 0xab,
-  0xc2, 0x47, 0x68, 0xe8, 0x68, 0x82, 0xea, 0xcb, 0x6c, 0x2c, 0x0b, 0x26,
-  0xf7, 0x9f, 0xa9, 0x55, 0x06, 0x82, 0x79, 0xb4, 0x76, 0xea, 0xce, 0x80,
-  0x79, 0x2d, 0xfc, 0xf2, 0x60, 0x1a, 0x71, 0x3e, 0x4c, 0xcb, 0x3c, 0xd6,
-  0xa0, 0x04, 0x4d, 0xad, 0x0a, 0x6e, 0x53, 0x06, 0xab, 0x85, 0x5f, 0x65,
-  0xb0, 0x2e, 0xc1, 0x8a, 0xb8, 0xca, 0x7f, 0xe6, 0x5e, 0x83, 0x52, 0xab,
-  0x0c, 0xc4, 0x05, 0x5b, 0xf1, 0xe7, 0xc7, 0xaf, 0xcf, 0x2f, 0x8f, 0x6b,
-  0xb5, 0xf9, 0x0a, 0xc4, 0x60, 0x36, 0x85, 0x43, 0x81, 0x7e, 0xde, 0xe2,
-  0x92, 0x3b, 0x62, 0xe3, 0x08, 0x51, 0x3e, 0x2e, 0xbe, 0x39, 0x0a, 0x38,
-  0xb5, 0xa5, 0xa9, 0x59, 0xa3, 0xdd, 0x66, 0x18, 0xd8, 0x30, 0x91, 0xc3,
-  0xbd, 0xcd, 0x75, 0x94, 0xe4, 0xac, 0xd9, 0x00, 0x39, 0x0b, 0x51, 0xfa,
-  0xd3, 0x6a, 0x6e, 0xe2, 0x2f, 0x2c, 0x0a, 0x18, 0x46, 0xd6, 0x47, 0xc8,
-  0x86, 0x35, 0x8f, 0x66, 0x26, 0x9a, 0x02, 0x78, 0xc4, 0x60, 0x66, 0xfa,
-  0x5c, 0xdf, 0xc6, 0x12, 0x65, 0xdc, 0x7a, 0xb0, 0x37, 0xb5, 0x05, 0xd0,
-  0x5a, 0x3a, 0xb7, 0x64, 0x74, 0x29, 0x5d, 0xa5, 0xb9, 0x19, 0xe3, 0xc8,
-  0x52, 0x16, 0xc3, 0x14, 0xc1, 0xbf, 0x0a, 0x00, 0xd0, 0x44, 0x52, 0x38,
-  0xd7, 0xe5, 0x93, 0x5a, 0xcf, 0x5b, 0xc5, 0x76, 0xa5, 0x4a, 0x93, 0xab,
-  0xa1, 0x8a, 0x81, 0xd3, 0x68, 0xff, 0x00, 0x57, 0xc2, 0x56, 0xe9, 0x6a,
-  0x71, 0xb7, 0x24, 0x2e, 0x3a, 0x38, 0x35, 0x0d, 0x40, 0x02, 0xf1, 0xf4,
-  0x9d, 0xfd, 0xb3, 0x1d, 0x73, 0xde, 0xd7, 0xf9, 0x6e, 0x8d, 0xca, 0x76,
-  0xa9, 0x4f, 0x82, 0xf1, 0xa1, 0xd9, 0x55, 0x0e, 0xb1, 0xc2, 0xd5, 0xcf,
-  0x93, 0x46, 0xba, 0x8f, 0x25, 0xd0, 0x06, 0x71, 0xbe, 0xce, 0x8f, 0x11,
-  0x0f, 0x15, 0xfe, 0xed, 0x3b, 0x0b, 0x74, 0xe1, 0x18, 0xfb, 0x62, 0x35,
-  0x2f, 0x71, 0x7b, 0x4b, 0x38, 0xe8, 0x28, 0xcb, 0xb1, 0xa6, 0xcd, 0x72,
-  0xee, 0x7e, 0xd3, 0x68, 0x2b, 0x2e, 0x5f, 0x1f, 0x3e, 0x7f, 0xf6, 0x1c,
-  0x47, 0x90, 0xa1, 0xbf, 0xe9, 0x64, 0xe0, 0x09, 0x75, 0x91, 0x76, 0xe5,
-  0x5c, 0x84, 0xe8, 0xf7, 0x8d, 0x7b, 0xd9, 0x2c, 0x94, 0xae, 0xd1, 0x2d,
-  0xa1, 0x99, 0x85, 0xf8, 0x51, 0x59, 0x4f, 0x35, 0x14, 0xac, 0x6d, 0xb4,
-  0x3f, 0x08, 0x3a, 0x78, 0xd1, 0x40, 0xf6, 0xb8, 0xce, 0x11, 0x92, 0x7a,
-  0x33, 0xcb, 0x90, 0xaf, 0x74, 0xc3, 0x65, 0xe5, 0xa6, 0xf4, 0xdf, 0xec,
-  0x96, 0xa1, 0x40, 0x16, 0xf7, 0x63, 0xb8, 0x62, 0x05, 0x63, 0x37, 0x9f,
-  0xe1, 0x3f, 0xfe, 0xbc, 0x58, 0xcd, 0x10, 0x7b, 0xfc, 0x0b, 0xd4, 0xac,
-  0x21, 0xf2, 0xa2, 0x4b, 0x8e, 0x03, 0xf9, 0xdb, 0x9d, 0x63, 0x12, 0xe3,
-  0x10, 0x22, 0x33, 0xb1, 0x41, 0xdf, 0xa0, 0x99, 0xf8, 0xc5, 0x00, 0x0d,
-  0xfc, 0x3e, 0xcc, 0xf6, 0x6b, 0x45, 0xc4, 0x32, 0x18, 0x4a, 0xda, 0x0c,
-  0xe9, 0x9c, 0x03, 0x44, 0x14, 0x58, 0x87, 0x83, 0x4d, 0xbc, 0x44, 0xce,
-  0xd1, 0xa1, 0x89, 0x25, 0xd0, 0xc8, 0xe3, 0x0d, 0x78, 0x3c, 0xf8, 0xa7,
-  0x05, 0x8f, 0xbb, 0x0a, 0xc3, 0xd9, 0x6f, 0x38, 0x62, 0x92, 0xeb, 0xb1,
-  0xcc, 0xb4, 0x1e, 0x75, 0xdd, 0xcb, 0x77, 0x78, 0x29, 0xae, 0x69, 0x11,
-  0xf8, 0xc7, 0x67, 0xeb, 0xa0, 0x7e, 0x21, 0xd2, 0x6a, 0x61, 0xe6, 0x98,
-  0xf3, 0x17, 0x34, 0x63, 0x71, 0x0b, 0x72, 0x83, 0x40, 0xcf, 0x0b, 0x80,
-  0x91, 0xf8, 0xfa, 0xb6, 0x35, 0xb5, 0xad, 0xd6, 0x1c, 0xb7, 0xb6, 0xd7,
-  0xdf, 0x63, 0xfc, 0x5d, 0x47, 0x1e, 0xfd, 0xe8, 0x12, 0x6d, 0x15, 0xb6,
-  0x75, 0x21, 0x2e, 0x33, 0xa7, 0x0d, 0xaf, 0x73, 0x36, 0x20, 0xd3, 0xa0,
-  0x41, 0x0b, 0xbb, 0xbd, 0xa7, 0xcf, 0x9f, 0x57, 0xf0, 0x11, 0xc3, 0xbb,
-  0xf1, 0xd9, 0xee, 0xae, 0xa4, 0x5f, 0xd4, 0x5f, 0xa3, 0x2f, 0x7a, 0xcf,
-  0xf9, 0xc5, 0xea, 0x6b, 0xaa, 0x12, 0xad, 0x7d, 0xaf, 0x87, 0x6f, 0x5a,
-  0xba, 0x63, 0x99, 0x63, 0xed, 0x5b, 0xcf, 0xd1, 0x5d, 0xcb, 0x5b, 0x02,
-  0x00, 0xc0, 0x6b, 0x97, 0x4d, 0x26, 0xa8, 0xb7, 0x80, 0x27, 0x05, 0x87,
-  0x25, 0xcb, 0xef, 0xe3, 0x7c, 0xdc, 0x9c, 0xee, 0x6e, 0xb7, 0xb7, 0xb7,
-  0x6e, 0xba, 0x0e, 0xaf, 0x98, 0xb7, 0x0c, 0x4c, 0x71, 0xeb, 0xf7, 0xdb,
-  0x5b, 0x5f, 0x6e, 0xb7, 0xcd, 0xfe, 0x93, 0xdd, 0xdd, 0xee, 0xc7, 0xf8,
-  0xf9, 0xfc, 0x79, 0xbb, 0x54, 0x56, 0xe9, 0xe3, 0x89, 0x4d, 0xad, 0x32,
-  0x5a, 0x6a, 0xa7, 0xa5, 0xf5, 0x3d, 0x6a, 0x75, 0xef, 0xf9, 0xf3, 0x2e,
-  0x7a, 0x79, 0xf6, 0x41, 0xad, 0x97, 0xf7, 0x99, 0x57, 0xeb, 0xf6, 0x5c,
-  0x57, 0x4c, 0x73, 0x45, 0x6d, 0x0a, 0xf4, 0x67, 0x14, 0xbd, 0x92, 0xb4,
-  0x14, 0x57, 0x16, 0x29, 0xd5, 0x1c, 0x4a, 0x31, 0x9a, 0xd7, 0x4b, 0x8c,
-  0x03, 0xea, 0x47, 0xaf, 0x3c, 0x57, 0xfc, 0x70, 0xc3, 0x27, 0xf0, 0xb2,
-  0xfd, 0xdc, 0x03, 0x97, 0xb0, 0xf3, 0x8f, 0xc1, 0xfd, 0x3d, 0xa2, 0x1c,
-  0xf1, 0x3f, 0xa2, 0x97, 0x6d, 0x16, 0x0f, 0xee, 0xe2, 0x69, 0xca, 0xb4,
-  0x0a, 0x85, 0x00, 0x89, 0x35, 0x16, 0x5e, 0x2d, 0x1f, 0x64, 0x0b, 0x41,
-  0x7c, 0x98, 0x68, 0x96, 0xaf, 0x35, 0xcb, 0x6c, 0xfc, 0x21, 0x72, 0x6f,
-  0xf5, 0xf4, 0xd1, 0xbe, 0x08, 0xb7, 0x31, 0x5b, 0x4a, 0x6a, 0xdd, 0x46,
-  0x2e, 0x71, 0x45, 0x7d, 0xe2, 0xdc, 0xa2, 0x0b, 0x58, 0xf2, 0xf3, 0x64,
-  0xdd, 0xc4, 0x67, 0xfb, 0x29, 0x63, 0x42, 0x89, 0x35, 0x41, 0x2d, 0x12,
-  0x30, 0x28, 0xba, 0x0f, 0x0c, 0xe5, 0x82, 0xc1, 0xff, 0x5c, 0x62, 0xe7,
-  0x46, 0x45, 0x2e, 0xb2, 0xba, 0x76, 0x24, 0xb5, 0x2d, 0xf3, 0x9a, 0x81,
-  0x98, 0xfd, 0xca, 0xa6, 0x80, 0x49, 0x2d, 0x39, 0xdc, 0x5c, 0xf7, 0xb1,
-  0x15, 0xc7, 0x60, 0x2f, 0xa2, 0x3b, 0xf8, 0x96, 0xc9, 0xae, 0xf5, 0x28,
-  0x34, 0x1a, 0xcf, 0x03, 0x71, 0x18, 0xb0, 0x88, 0x04, 0x88, 0xd0, 0x2d,
-  0xc0, 0x4c, 0x8c, 0x03, 0xbe, 0x60, 0xc3, 0x14, 0x10, 0x87, 0x50, 0xee,
-  0x66, 0x79, 0x24, 0xd6, 0xa5, 0xed, 0x46, 0x2e, 0x1d, 0x6d, 0xa3, 0x66,
-  0x1f, 0xb2, 0xca, 0x87, 0x92, 0x56, 0xe3, 0xd0, 0xc1, 0xdd, 0x3c, 0x58,
-  0x3a, 0xd4, 0x2c, 0x6c, 0xcb, 0x56, 0x2a, 0x0c, 0x9e, 0xc0, 0x45, 0x2e,
-  0x8b, 0x82, 0x2c, 0x31, 0xfd, 0x6b, 0x37, 0xd0, 0x11, 0x66, 0x80, 0x0b,
-  0xc7, 0xd4, 0x16, 0xc8, 0x04, 0x96, 0x52, 0x9e, 0xcd, 0x00, 0xd1, 0x33,
-  0xde, 0xe6, 0xe8, 0x69, 0xd9, 0x0d, 0x27, 0x2f, 0xab, 0x9f, 0x6f, 0xc3,
-  0x67, 0x4d, 0xb0, 0xc8, 0x33, 0x38, 0xf9, 0x2f, 0xc7, 0xfd, 0x50, 0x0f,
-  0xfa, 0xa5, 0x7c, 0xa1, 0x79, 0x7c, 0x5f, 0xad, 0x21, 0x25, 0x88, 0xde,
-  0x12, 0x96, 0x10, 0x33, 0xa2, 0xa9, 0x16, 0x68, 0x61, 0x0b, 0xd8, 0x98,
-  0x38, 0xa3, 0x21, 0xf3, 0xb8, 0xe2, 0x2b, 0x6b, 0x71, 0x5d, 0xb8, 0xc2,
-  0x15, 0x57, 0x1f, 0x08, 0x0d, 0x14, 0x2e, 0xa4, 0x7e, 0xc6, 0x91, 0xb1,
-  0x06, 0x42, 0xb9, 0xa4, 0x4e, 0x18, 0xfd, 0xb5, 0x1e, 0x8a, 0x47, 0x43,
-  0xec, 0x3f, 0x52, 0xa5, 0xf5, 0x31, 0x6b, 0xd7, 0x87, 0x20, 0x72, 0x97,
-  0xd9, 0xf5, 0xf5, 0xb4, 0xc5, 0x41, 0xda, 0x86, 0xc4, 0x7d, 0xe9, 0x03,
-  0x10, 0xd0, 0x5a, 0x7b, 0xc8, 0xb2, 0x04, 0x03, 0x18, 0x33, 0x62, 0x59,
-  0xda, 0x49, 0xc8, 0x15, 0x32, 0xe6, 0xa3, 0x25, 0x11, 0x0b, 0x6d, 0xf2,
-  0x17, 0x8f, 0xb7, 0x8c, 0x67, 0x8b, 0xa8, 0x25, 0xee, 0x40, 0x70, 0x88,
-  0x2c, 0x97, 0x06, 0xc1, 0x6d, 0x77, 0x24, 0x88, 0xb2, 0x9a, 0xca, 0x3d,
-  0x36, 0x9b, 0x0b, 0x62, 0x21, 0xe4, 0x5c, 0xd0, 0x7b, 0xac, 0xaf, 0xbb,
-  0x7e, 0xfe, 0x29, 0xc3, 0x3e, 0xa7, 0xb7, 0x79, 0xd2, 0x69, 0x43, 0x8f,
-  0x67, 0xeb, 0x62, 0x85, 0xf8, 0x12, 0x60, 0xaf, 0x31, 0xea, 0x43, 0xcb,
-  0x6e, 0x5a, 0x15, 0xf5, 0x94, 0x93, 0xce, 0x93, 0x3c, 0xcf, 0x72, 0xd1,
-  0x91, 0x21, 0x78, 0x27, 0xea, 0x68, 0xad, 0x82, 0x06, 0x1a, 0xc2, 0x79,
-  0xbc, 0x86, 0x22, 0x7d, 0x4a, 0xb5, 0x74, 0xcd, 0xb3, 0xf3, 0x92, 0xbf,
-  0xc4, 0x3d, 0xa8, 0x7e, 0x62, 0x75, 0x88, 0xa2, 0xe5, 0xa2, 0xdf, 0x44,
-  0xa3, 0x28, 0x3d, 0x36, 0x8e, 0xbe, 0x4f, 0xdd, 0xef, 0x2a, 0x6d, 0x4b,
-  0x6d, 0x01, 0x70, 0x3b, 0xee, 0x07, 0x83, 0x53, 0x64, 0xc0, 0xb4, 0x68,
-  0x45, 0x95, 0x63, 0x1d, 0x19, 0x9a, 0x9e, 0x9b, 0xaf, 0x4c, 0x57, 0x40,
-  0x75, 0x92, 0x14, 0xd1, 0xa8, 0x2f, 0x80, 0x49, 0x2b, 0x99, 0x74, 0x5d,
-  0x0f, 0x2b, 0x12, 0x3d, 0x7b, 0x78, 0x68, 0xa2, 0x51, 0x78, 0x1c, 0x84,
-  0x48, 0x8c, 0x6b, 0x7c, 0x78, 0xe9, 0xd1, 0xea, 0x97, 0x8f, 0xa5, 0xb6,
-  0x33, 0x4d, 0x0d, 0x33, 0x89, 0xa4, 0x91, 0xd5, 0x8a, 0x5b, 0xd6, 0x51,
-  0x44, 0x0e, 0x54, 0x5d, 0x6e, 0xc1, 0x47, 0x55, 0xda, 0x70, 0x10, 0x8c,
-  0x6c, 0xe9, 0x9b, 0x72, 0xb2, 0x62, 0x79, 0x43, 0xac, 0x4d, 0x52, 0xd9,
-  0x65, 0x81, 0xac, 0x41, 0xc3, 0xc3, 0x6c, 0x59, 0x27, 0xf4, 0x22, 0xcb,
-  0x9e, 0x72, 0xce, 0x78, 0x99, 0xa2, 0x6c, 0x5f, 0xc4, 0xf9, 0xcc, 0xd4,
-  0xc2, 0x1e, 0x2d, 0x7f, 0x3a, 0x5f, 0x2a, 0x9a, 0x92, 0x54, 0xa7, 0xf0,
-  0x80, 0xbb, 0x6d, 0xcb, 0x3e, 0xe5, 0x1c, 0x13, 0xa9, 0xdd, 0x5b, 0xd6,
-  0x0a, 0xa0, 0xeb, 0xb8, 0x24, 0x82, 0x59, 0xcd, 0x36, 0x46, 0xb2, 0x3d,
-  0x7e, 0xb5, 0x59, 0xe4, 0x2a, 0x8a, 0x42, 0xff, 0x38, 0x78, 0x51, 0xf2,
-  0x40, 0xab, 0x2d, 0x18, 0x0c, 0x28, 0x77, 0x30, 0xba, 0x45, 0x79, 0x44,
-  0x5a, 0x83, 0xeb, 0x2c, 0xa7, 0x4d, 0x9d, 0xa9, 0xd8, 0xce, 0x77, 0x68,
-  0x5d, 0xc6, 0xd4, 0xae, 0x5c, 0x7e, 0x29, 0x20, 0xea, 0x1c, 0xc2, 0x41,
-  0x99, 0x95, 0xca, 0xd1, 0x34, 0x61, 0xcc, 0x69, 0xb8, 0x36, 0xee, 0xc7,
-  0x22, 0x20, 0xf6, 0xfb, 0x4f, 0x7e, 0x52, 0x91, 0xfb, 0x5a, 0xf5, 0xa5,
-  0xf0, 0x6a, 0x71, 0x7c, 0xb4, 0xb1, 0xb8, 0xa8, 0x47, 0x19, 0xa0, 0x31,
-  0x34, 0xce, 0xbd, 0x2c, 0xe2, 0x23, 0x69, 0xb3, 0x66, 0x5d, 0x2c, 0xa6,
-  0x49, 0xb2, 0x90, 0xb1, 0x29, 0xb0, 0x83, 0x1e, 0x55, 0xb7, 0x77, 0xcc,
-  0xd2, 0x95, 0x48, 0x55, 0x68, 0x58, 0xc7, 0x01, 0xd4, 0x48, 0x01, 0xad,
-  0x9d, 0x6d, 0x14, 0xec, 0x31, 0x6d, 0xe3, 0x34, 0x5b, 0x22, 0x82, 0xb1,
-  0x8e, 0xb2, 0xf6, 0xc8, 0xba, 0x2d, 0xe5, 0xe1, 0xb8, 0x6d, 0x75, 0x03,
-  0xd3, 0xcd, 0xd8, 0xae, 0xc6, 0xb1, 0x34, 0x31, 0xc8, 0x44, 0xe2, 0xe0,
-  0xab, 0x36, 0x11, 0x78, 0xa5, 0x74, 0xe2, 0xf8, 0x23, 0x57, 0x83, 0xd3,
-  0x2c, 0xa8, 0xbe, 0xe3, 0x3d, 0x02, 0xa6, 0xc7, 0x4b, 0xd8, 0xb0, 0x1d,
-  0xfd, 0x98, 0xe4, 0x59, 0x70, 0xfb, 0xf0, 0x2a, 0x9a, 0x48, 0xec, 0x10,
-  0x60, 0x1d, 0x35, 0x62, 0xec, 0x7d, 0x4f, 0x22, 0x4d, 0x60, 0xae, 0xff,
-  0x6d, 0x28, 0xe6, 0xbd, 0xb9, 0xd6, 0x57, 0x7a, 0x70, 0x25, 0x84, 0x4d,
-  0xaf, 0x0b, 0xae, 0x60, 0x67, 0x4c, 0x3d, 0x04, 0x94, 0xf6, 0x34, 0xa1,
-  0xd7, 0x72, 0xfd, 0xd0, 0x5c, 0x2a, 0x6f, 0x32, 0x1e, 0xc2, 0x09, 0x0a,
-  0x31, 0x6e, 0x41, 0x20, 0x71, 0x6f, 0x21, 0x0c, 0x58, 0x87, 0xb6, 0x8d,
-  0x8f, 0x39, 0x41, 0x4d, 0xad, 0xb2, 0xdc, 0x7f, 0xb3, 0xb2, 0xbb, 0xa4,
-  0xf6, 0x08, 0xc7, 0x1a, 0xb7, 0xe4, 0xa4, 0x9f, 0x65, 0x65, 0x3a, 0xf2,
-  0x25, 0x0e, 0x5d, 0x4b, 0xee, 0xdd, 0x06, 0xaf, 0x97, 0x96, 0x34, 0xb4,
-  0x12, 0x8d, 0x74, 0x2b, 0xf0, 0x23, 0x36, 0x74, 0x76, 0x67, 0xb2, 0xf1,
-  0x8c, 0xdd, 0x32, 0x7a, 0x51, 0xb6, 0xc6, 0x11, 0x30, 0x73, 0x87, 0x79,
-  0x8c, 0xcd, 0x8c, 0x98, 0x54, 0x4b, 0x0e, 0x3d, 0x6f, 0x03, 0xb5, 0x92,
-  0x66, 0x63, 0x36, 0x50, 0x0a, 0x6b, 0x6a, 0x06, 0x86, 0x51, 0x7b, 0xd3,
-  0xc4, 0x05, 0x2a, 0xfd, 0xcf, 0xff, 0x51, 0x84, 0x40, 0x84, 0xe9, 0xcc,
-  0x57, 0xc5, 0x0e, 0x73, 0xe9, 0xfb, 0x02, 0xf8, 0xb4, 0xbe, 0x00, 0x0d,
-  0xf1, 0x42, 0xa6, 0xf1, 0x52, 0x34, 0x0a, 0x4b, 0x30, 0x77, 0x3c, 0xfb,
-  0x43, 0xb8, 0x5d, 0x4d, 0xb2, 0x59, 0x47, 0xb8, 0xba, 0xb2, 0x31, 0x63,
-  0x02, 0xfd, 0x1c, 0xda, 0x2d, 0x00, 0x35, 0x07, 0x80, 0xef, 0xfa, 0xde,
-  0x0d, 0xf8, 0x43, 0x54, 0x15, 0xa2, 0x09, 0x1f, 0x29, 0x76, 0x0e, 0xc0,
-  0x7f, 0x04, 0xac, 0x12, 0xfe, 0x13, 0xb5, 0xe8, 0xe7, 0x4e, 0x1c, 0x28,
-  0x90, 0x7d, 0x8a, 0x4b, 0x89, 0x93, 0xd1, 0xeb, 0xa0, 0xc7, 0x8c, 0xbb,
-  0xb7, 0x2c, 0x93, 0x5f, 0x3b, 0x42, 0xa3, 0x08, 0x46, 0xee, 0x27, 0x3a,
-  0xc0, 0x44, 0x69, 0xf8, 0x3d, 0x1e, 0xec, 0xda, 0x32, 0xb5, 0xea, 0x5f,
-  0x11, 0xfc, 0xc3, 0x20, 0xa5, 0x1e, 0x13, 0xaf, 0x4c, 0x13, 0x07, 0x80,
-  0x9e, 0x01, 0xab, 0x6e, 0xc3, 0x86, 0xff, 0xd9, 0xa1, 0x6b, 0xe8, 0xa9,
-  0x6e, 0x58, 0x43, 0xbf, 0x21, 0xbf, 0x29, 0xb2, 0xd1, 0x6d, 0xf1, 0x34,
-  0x7a, 0xc9, 0x91, 0xd6, 0x2f, 0xa0, 0x07, 0xfe, 0xf0, 0x59, 0xa3, 0x6c,
-  0x6a, 0x62, 0x58, 0x7d, 0x6a, 0xb9, 0x1a, 0x9c, 0x1f, 0x7e, 0x35, 0x78,
-  0x6a, 0x61, 0x21, 0x86, 0x9c, 0xef, 0xc1, 0xc4, 0x2c, 0x89, 0xf2, 0x11,
-  0x3c, 0x7e, 0x3e, 0x7b, 0xbe, 0xa8, 0x47, 0x64, 0x68, 0x64, 0x7b, 0xbb,
-  0x9f, 0xee, 0x3e, 0x86, 0xdf, 0xd5, 0x62, 0x13, 0x05, 0x78, 0x62, 0x9e,
-  0x8e, 0x13, 0xad, 0x29, 0x9d, 0x27, 0x08, 0x1b, 0x75, 0xf9, 0x5a, 0x91,
-  0x8f, 0xe2, 0xd0, 0xd2, 0x98, 0x00, 0x8f, 0xab, 0x0b, 0xec, 0xc4, 0x31,
-  0x89, 0x9e, 0x24, 0x0d, 0x31, 0x79, 0x18, 0x4d, 0x49, 0x0c, 0xba, 0xfb,
-  0x55, 0x8b, 0xb3, 0xf0, 0xba, 0x3f, 0xfb, 0x39, 0xeb, 0xfe, 0xec, 0x5f,
-  0xb5, 0xee, 0x7b, 0x61, 0xec, 0x51, 0x2b, 0xf4, 0x9f, 0x5f, 0xf9, 0xd6,
-  0xa5, 0x0f, 0x57, 0x5e, 0x6e, 0x8b, 0x7f, 0xd7, 0xba, 0xd7, 0x44, 0xc4,
-  0xea, 0x2c, 0x90, 0x29, 0xe3, 0xc6, 0x2e, 0x65, 0x10, 0xe8, 0x2a, 0x98,
-  0xae, 0x6a, 0x59, 0x43, 0xea, 0x1e, 0x8c, 0x1a, 0x38, 0x6f, 0xba, 0x99,
-  0x15, 0xcc, 0x7b, 0xdd, 0x0f, 0x07, 0xb9, 0x1a, 0x06, 0x71, 0x15, 0xe5,
-  0x98, 0x96, 0xad, 0xdd, 0x30, 0x7f, 0xe9, 0xd0, 0xb5, 0x68, 0xf8, 0x5c,
-  0x8e, 0x81, 0xd5, 0x3d, 0x7d, 0x45, 0x5d, 0x7e, 0x9e, 0x20, 0x14, 0x8e,
-  0x43, 0xf3, 0x94, 0xda, 0xdd, 0x38, 0x61, 0xb8, 0xbd, 0xe4, 0x86, 0x31,
-  0x3a, 0x85, 0x3a, 0xc2, 0x8c, 0x1e, 0xcc, 0x66, 0x11, 0xa0, 0x2a, 0x6b,
-  0x7e, 0xcc, 0x23, 0x27, 0x4f, 0x11, 0x6c, 0x16, 0x19, 0x09, 0x74, 0x22,
-  0x8e, 0xba, 0x02, 0xb8, 0xae, 0x0c, 0xe1, 0x8d, 0xd4, 0xca, 0x65, 0xf1,
-  0x93, 0x6e, 0x8f, 0xe6, 0xed, 0xe0, 0xe2, 0xc1, 0xe1, 0x7f, 0x89, 0x17,
-  0x31, 0xd7, 0x83, 0xff, 0x09, 0x51, 0xa2, 0x3f, 0xe7, 0xf4, 0x95, 0xa3,
-  0x45, 0x6f, 0x9e, 0xb5, 0x29, 0x37, 0x57, 0x40, 0x09, 0x52, 0x13, 0xd5,
-  0xd5, 0xe1, 0xc5, 0xbb, 0xb3, 0xf3, 0xa3, 0xe3, 0xd3, 0x83, 0xef, 0xcc,
-  0xb9, 0xe0, 0x7c, 0xc3, 0x8c, 0x96, 0x9c, 0xc4, 0xc5, 0xea, 0x1d, 0x49,
-  0x5d, 0xf4, 0xe5, 0xd6, 0x93, 0x6d, 0x5c, 0xf8, 0x75, 0x89, 0x92, 0xb1,
-  0x01, 0x43, 0x34, 0x11, 0xd5, 0x34, 0xfd, 0x3c, 0x1a, 0x87, 0xee, 0xdf,
-  0x64, 0xf1, 0x29, 0xe9, 0xac, 0x96, 0xc9, 0x74, 0x9e, 0x94, 0x8a, 0x25,
-  0x11, 0xbd, 0x3c, 0xbf, 0xb8, 0x7a, 0x75, 0x17, 0x37, 0x4a, 0x21, 0x71,
-  0x3e, 0x83, 0x16, 0xb6, 0x35, 0x92, 0x94, 0x37, 0x5d, 0xd0, 0x1b, 0x72,
-  0xe6, 0xcc, 0x1f, 0x69, 0x4f, 0xd2, 0x59, 0x6f, 0xc4, 0xaa, 0x5c, 0x5d,
-  0x7d, 0x77, 0x71, 0xfc, 0xea, 0x25, 0xac, 0xb6, 0x9f, 0x41, 0x12, 0x52,
-  0x91, 0x52, 0x8c, 0xb8, 0x53, 0x29, 0x46, 0x55, 0x7f, 0xe7, 0xdb, 0xa3,
-  0x93, 0xc1, 0xc5, 0xe9, 0xf9, 0xe1, 0xab, 0x97, 0xdf, 0x5a, 0x59, 0xc3,
-  0xe0, 0x5d, 0xf7, 0x99, 0x03, 0xba, 0x6a, 0x22, 0x3c, 0x1d, 0x7f, 0xf3,
-  0xee, 0xf8, 0xec, 0xeb, 0x57, 0x2f, 0xef, 0xe2, 0xbc, 0x8b, 0xf9, 0xc9,
-  0xdb, 0x24, 0xf6, 0xb5, 0xa1, 0xa7, 0x04, 0x4b, 0x74, 0x85, 0x8c, 0xfb,
-  0x05, 0x6c, 0xa7, 0x8f, 0xb8, 0xd6, 0xf8, 0x7c, 0xf8, 0x74, 0xdf, 0xea,
-  0x79, 0x0d, 0x4c, 0x53, 0xba, 0x70, 0x2e, 0xd8, 0xfa, 0xed, 0xe5, 0xe9,
-  0x9a, 0x13, 0xec, 0x2a, 0x0c, 0xf8, 0xf4, 0x1c, 0xab, 0x16, 0xe0, 0x1a,
-  0xe6, 0x54, 0x18, 0x8f, 0x4a, 0x23, 0x7c, 0xe7, 0x71, 0xdb, 0x98, 0x44,
-  0xa7, 0xb1, 0x5f, 0xc1, 0x21, 0x34, 0xb1, 0x1b, 0x56, 0x52, 0xd0, 0x69,
-  0x0a, 0x52, 0x26, 0x62, 0xc7, 0x8e, 0x03, 0x4e, 0x55, 0xb3, 0xbe, 0x83,
-  0xe1, 0xcb, 0x4a, 0x25, 0x22, 0xf0, 0x71, 0x44, 0xb8, 0xf1, 0xfc, 0x78,
-  0x3c, 0x16, 0x19, 0x58, 0x9d, 0x05, 0x73, 0xa3, 0x86, 0xec, 0xe4, 0x51,
-  0x7c, 0x90, 0xd3, 0x73, 0xeb, 0xc6, 0x95, 0xcb, 0x89, 0xf6, 0xbd, 0x19,
-  0x33, 0xab, 0xd9, 0x0a, 0xeb, 0xe1, 0x84, 0xea, 0xce, 0x54, 0x9c, 0x6f,
-  0xf3, 0x61, 0xce, 0x10, 0x2b, 0x84, 0x98, 0x49, 0xf8, 0x97, 0x9d, 0x07,
-  0x45, 0x36, 0x36, 0xf0, 0x54, 0xb7, 0x96, 0xd1, 0xeb, 0x3b, 0x2e, 0x64,
-  0x47, 0x90, 0xab, 0x6e, 0x22, 0x75, 0x6d, 0xab, 0xd8, 0x56, 0x07, 0x80,
-  0x30, 0xa1, 0x8b, 0xb7, 0x3e, 0x64, 0xad, 0xb5, 0x26, 0xe4, 0x9a, 0xca,
-  0x59, 0x6f, 0x35, 0xd6, 0x26, 0x58, 0xa8, 0x4e, 0xaf, 0x13, 0x6d, 0xc5,
-  0xa6, 0x63, 0x20, 0x8e, 0x61, 0xdb, 0x22, 0xae, 0xb8, 0x00, 0x4e, 0x18,
-  0x27, 0x1a, 0xb7, 0xa6, 0x4a, 0xb5, 0x06, 0x0f, 0x1a, 0x9e, 0xa4, 0x45,
-  0x07, 0x80, 0x63, 0xf6, 0xae, 0x24, 0xb6, 0x17, 0x9c, 0x44, 0x8b, 0xd3,
-  0xd4, 0x83, 0x6c, 0xfa, 0xd1, 0x31, 0xbe, 0xed, 0x5d, 0x35, 0xe0, 0xfd,
-  0xf0, 0xc2, 0x22, 0x4e, 0xf3, 0xc0, 0xd7, 0x75, 0xaf, 0x55, 0x78, 0x74,
-  0x79, 0x35, 0x70, 0x85, 0x0b, 0x1f, 0xf4, 0xb5, 0x6a, 0x15, 0x54, 0xfe,
-  0xb5, 0x79, 0xa9, 0x45, 0xd4, 0xb9, 0x9e, 0x66, 0xc3, 0x21, 0x4d, 0xbd,
-  0x63, 0x16, 0x2b, 0x1a, 0xa3, 0x79, 0xe3, 0xbb, 0x96, 0x28, 0xe3, 0x69,
-  0x98, 0x53, 0x30, 0xb9, 0xb7, 0x75, 0x45, 0xb2, 0x15, 0x8b, 0x4d, 0xe2,
-  0x72, 0x6d, 0x55, 0x39, 0x3d, 0x72, 0x55, 0xc7, 0x6b, 0xc4, 0xa7, 0xd6,
-  0x7f, 0x5d, 0x37, 0x28, 0x57, 0xd3, 0xa0, 0x8c, 0x9d, 0x9d, 0x49, 0x3e,
-  0x89, 0x9a, 0x7d, 0xd7, 0x52, 0x98, 0x47, 0xea, 0xdf, 0x5e, 0x45, 0x9d,
-  0xbf, 0x63, 0x10, 0x7b, 0x5d, 0xfc, 0xbb, 0xff, 0x8f, 0x4e, 0x58, 0xff,
-  0x56, 0x06, 0x5f, 0x22, 0xaf, 0xad, 0xb0, 0x8c, 0xcb, 0x96, 0x04, 0x4b,
-  0x40, 0xa0, 0xad, 0x6d, 0x3d, 0x9d, 0x5d, 0x7f, 0xbf, 0xd7, 0xdb, 0xdb,
-  0xdd, 0xdd, 0xfd, 0xa1, 0xbf, 0xc0, 0xd2, 0x4d, 0xb8, 0x79, 0x04, 0x5c,
-  0x2e, 0xd2, 0x11, 0x9c, 0x50, 0xb4, 0x9d, 0x69, 0xcc, 0x65, 0x27, 0xa4,
-  0xbf, 0x9d, 0xf0, 0x7a, 0xcc, 0xb9, 0xe6, 0x70, 0x1b, 0x7b, 0xb3, 0xb4,
-  0xf7, 0x38, 0x9a, 0x2c, 0x05, 0xd7, 0x80, 0x9e, 0x1c, 0x2f, 0x67, 0x0b,
-  0xa6, 0x3d, 0x5c, 0xf5, 0xa8, 0x27, 0xcd, 0x06, 0x4f, 0xf1, 0x12, 0xd2,
-  0x75, 0x67, 0x50, 0x6a, 0x71, 0x19, 0x77, 0x5b, 0xc1, 0x9a, 0x39, 0x78,
-  0x26, 0x29, 0x80, 0x2a, 0x5e, 0x12, 0xb9, 0x86, 0xc8, 0x35, 0x5d, 0x63,
-  0x94, 0x42, 0xc7, 0x9a, 0xf3, 0xc8, 0xe4, 0xdc, 0x52, 0xd7, 0x0d, 0x07,
-  0x85, 0x64, 0x92, 0xb0, 0xcc, 0x94, 0x83, 0xc4, 0x30, 0x04, 0x8d, 0x44,
-  0xc2, 0x15, 0x4d, 0xba, 0xf9, 0x20, 0xc5, 0x22, 0x94, 0x6c, 0x19, 0x7d,
-  0xbb, 0x77, 0x27, 0x89, 0xd2, 0x43, 0xd4, 0x60, 0x80, 0x35, 0x52, 0x17,
-  0xad, 0xd7, 0x28, 0x5d, 0x3f, 0x4a, 0xd3, 0x5f, 0x55, 0x92, 0xe1, 0x5e,
-  0xb9, 0x9b, 0xff, 0x0f, 0x6f, 0x18, 0x00, 0x22, 0x15, 0x90, 0xcc, 0x03,
-  0x5d, 0xf1, 0x54, 0x05, 0xe8, 0x6a, 0x9a, 0x50, 0xa3, 0x45, 0x64, 0xd2,
-  0xf9, 0x4d, 0xf2, 0x20, 0xf7, 0x68, 0x33, 0xa2, 0x5d, 0x5d, 0xa2, 0x37,
-  0x08, 0xd9, 0x96, 0x22, 0x43, 0x83, 0xc3, 0x93, 0x93, 0x4a, 0x52, 0x2c,
-  0x16, 0x4f, 0x2a, 0x01, 0xb0, 0x52, 0x5f, 0xcc, 0x50, 0xc2, 0x35, 0xd7,
-  0xe1, 0x36, 0xae, 0x6f, 0x38, 0x89, 0x19, 0xee, 0x0d, 0x71, 0x6e, 0x71,
-  0x91, 0x9a, 0x97, 0x3e, 0x16, 0x98, 0xbb, 0xe5, 0x1c, 0x17, 0x2d, 0xd7,
-  0xd9, 0x59, 0xd2, 0x91, 0x2c, 0x7e, 0x69, 0x82, 0xec, 0xff, 0xda, 0xa4,
-  0xd7, 0xe2, 0x1e, 0xbc, 0xc8, 0xd5, 0xd5, 0x2b, 0x7e, 0x9c, 0x48, 0x7c,
-  0x7b, 0x00, 0x46, 0xc0, 0xbd, 0x21, 0x14, 0x48, 0x43, 0xb4, 0xd1, 0x4a,
-  0xa9, 0x15, 0x59, 0xaa, 0xb6, 0xfc, 0x31, 0xab, 0x5d, 0xdd, 0xaf, 0x19,
-  0xf7, 0x9f, 0xb6, 0xa3, 0x82, 0xfc, 0xf2, 0xc5, 0x8a, 0xd9, 0xe5, 0x53,
-  0x13, 0x97, 0x0d, 0x7d, 0x29, 0x7a, 0x89, 0x7f, 0x5f, 0x18, 0xf2, 0xd1,
-  0x3a, 0xb0, 0x54, 0x7e, 0xb4, 0x02, 0x4a, 0xe7, 0xe3, 0x6a, 0xd9, 0x9b,
-  0x61, 0x71, 0xe9, 0xf5, 0x54, 0xb5, 0x6a, 0x73, 0xe7, 0x8e, 0x00, 0x3c,
-  0x78, 0x23, 0x37, 0x5b, 0x87, 0x81, 0x5b, 0x0f, 0x52, 0xc1, 0xd2, 0x1d,
-  0xe0, 0x5d, 0x2e, 0x4e, 0x7a, 0x1a, 0x87, 0xa0, 0x68, 0x1e, 0x52, 0xa4,
-  0x07, 0xad, 0x8d, 0xb3, 0x7a, 0xda, 0x50, 0x3b, 0x52, 0x86, 0xc7, 0x3c,
-  0xe0, 0x32, 0x08, 0xd5, 0xfc, 0xd1, 0xe5, 0xc2, 0x83, 0x44, 0xb5, 0x60,
-  0x44, 0xd5, 0x85, 0x2b, 0x06, 0x8c, 0x92, 0x9c, 0x88, 0x50, 0x0c, 0x77,
-  0x45, 0xf4, 0x4c, 0x4a, 0x51, 0xb5, 0x52, 0x2e, 0x6d, 0x52, 0x35, 0xb2,
-  0x79, 0x5b, 0x66, 0x41, 0x40, 0x03, 0x2f, 0x88, 0xc9, 0x2c, 0xa3, 0x17,
-  0x9d, 0x5f, 0x91, 0x0b, 0xbf, 0x35, 0x3b, 0xc7, 0x3f, 0x47, 0x12, 0x41,
-  0x2e, 0x7c, 0x1b, 0x5a, 0xc8, 0xff, 0xbf, 0xa7, 0x95, 0x3d, 0x7d, 0xfb,
-  0xeb, 0xee, 0x29, 0x97, 0x74, 0x7c, 0x49, 0xd2, 0xdc, 0x5a, 0xfc, 0xe3,
-  0x98, 0x95, 0xb6, 0x00, 0x16, 0xa4, 0x99, 0xc4, 0x4d, 0x9a, 0x06, 0xcd,
-  0xf2, 0x86, 0x16, 0x69, 0xe5, 0xec, 0x23, 0x1b, 0xed, 0xe9, 0x13, 0x26,
-  0x84, 0x53, 0x93, 0xd0, 0x24, 0x38, 0x38, 0xf0, 0xb1, 0xb2, 0x9a, 0x57,
-  0x15, 0xec, 0xc6, 0x95, 0x2f, 0xb5, 0x5a, 0x09, 0xf1, 0x95, 0xd0, 0x50,
-  0x09, 0x76, 0xb6, 0x7c, 0x03, 0x91, 0xbe, 0xdb, 0x16, 0x97, 0xab, 0x62,
-  0x16, 0x66, 0x03, 0xea, 0x3a, 0x57, 0x5a, 0x08, 0xb6, 0xa2, 0xc9, 0x0b,
-  0xef, 0x81, 0xa8, 0x50, 0xa5, 0x3f, 0x58, 0xcf, 0xe0, 0x7e, 0x6a, 0x85,
-  0x9b, 0x65, 0x8d, 0x07, 0xab, 0x08, 0x62, 0x10, 0x00, 0x43, 0x7d, 0x7c,
-  0xa7, 0x8c, 0xa7, 0xb7, 0x31, 0xe4, 0x0c, 0xb8, 0x03, 0x64, 0x49, 0x81,
-  0x4e, 0xc9, 0xde, 0xe7, 0xb6, 0xb8, 0xfc, 0xe1, 0xf2, 0xfa, 0x5a, 0x30,
-  0xb9, 0x4e, 0x39, 0x1e, 0x58, 0x00, 0xa1, 0x2d, 0x07, 0x09, 0x96, 0xaf,
-  0xcf, 0xb8, 0xe0, 0x10, 0xc7, 0x1c, 0x74, 0xa4, 0x5c, 0x01, 0x0b, 0x3b,
-  0x1d, 0x11, 0x36, 0x86, 0xab, 0x16, 0xb1, 0x9a, 0xab, 0x2f, 0xbf, 0x5c,
-  0xf7, 0x1e, 0xea, 0xe4, 0xa4, 0x77, 0x0a, 0xa7, 0xe4, 0xd4, 0x5e, 0x5a,
-  0xcb, 0x9b, 0x94, 0x6e, 0xac, 0x79, 0xd3, 0xd5, 0x68, 0x15, 0x5a, 0xa4,
-  0x7e, 0x57, 0x64, 0xba, 0x55, 0xd1, 0x1c, 0xeb, 0xef, 0x7d, 0x9f, 0xf1,
-  0x78, 0x9c, 0x2a, 0x00, 0x27, 0x24, 0xae, 0x66, 0xde, 0x9a, 0xd4, 0xe0,
-  0xd6, 0x31, 0xb4, 0x97, 0x45, 0xd5, 0x7b, 0x36, 0x35, 0xde, 0x21, 0x02,
-  0x0f, 0x53, 0xa1, 0x04, 0x4f, 0xb8, 0xfa, 0x0d, 0xa0, 0x41, 0xb1, 0x51,
-  0xc8, 0xd6, 0xd7, 0x45, 0xc1, 0x4a, 0x41, 0x08, 0x27, 0xe3, 0x28, 0x49,
-  0x3a, 0x43, 0x20, 0x80, 0x56, 0x15, 0x86, 0x66, 0x2d, 0x03, 0x33, 0x6d,
-  0xdf, 0x53, 0x74, 0x51, 0x4a, 0x39, 0x00, 0x2b, 0x50, 0x03, 0x61, 0x92,
-  0x1f, 0x55, 0x04, 0x42, 0x35, 0xa7, 0x75, 0x9b, 0x29, 0x1e, 0x1c, 0x89,
-  0xec, 0xb2, 0x4f, 0x9c, 0xb0, 0x51, 0x95, 0x94, 0xcd, 0x64, 0xfa, 0x73,
-  0x85, 0xad, 0x4a, 0x63, 0xbe, 0xf5, 0xfe, 0x07, 0x4a, 0x23, 0x6b, 0xbc,
-  0x37, 0x12, 0x36, 0x28, 0x68, 0x26, 0xc0, 0x40, 0x08, 0x4e, 0x4f, 0x80,
-  0xcb, 0xd4, 0xc4, 0x25, 0x64, 0xe9, 0xa8, 0x02, 0xf7, 0x29, 0x56, 0x46,
-  0x51, 0xaf, 0x15, 0xdb, 0xd7, 0x22, 0xb3, 0x0c, 0x08, 0x43, 0x0b, 0x4d,
-  0xf5, 0xdb, 0x80, 0x5a, 0xd4, 0x6d, 0x2c, 0x72, 0x99, 0xee, 0xb0, 0x9e,
-  0x50, 0xe8, 0x10, 0xd6, 0x04, 0x42, 0xe3, 0xf8, 0x64, 0x58, 0xdb, 0x2d,
-  0xe2, 0xb4, 0x14, 0x52, 0xc8, 0xc7, 0x2c, 0x41, 0xaf, 0x14, 0x9d, 0x2a,
-  0x65, 0x24, 0xa0, 0xf9, 0xad, 0xf9, 0xc8, 0xaa, 0xc5, 0x2e, 0x5b, 0xab,
-  0x79, 0xe9, 0x3a, 0xf1, 0x90, 0xb6, 0xf8, 0x8c, 0x28, 0xa6, 0x40, 0xe7,
-  0xc2, 0x12, 0x6d, 0x5f, 0x74, 0xb6, 0x4d, 0x70, 0x67, 0xbd, 0xc6, 0x65,
-  0xe0, 0xb6, 0xc9, 0xe4, 0x36, 0x64, 0x57, 0xd8, 0x25, 0x73, 0x85, 0xc4,
-  0xdb, 0xba, 0xa7, 0x5d, 0xc9, 0x5b, 0x7b, 0x7f, 0x2d, 0x21, 0x9d, 0x41,
-  0xe7, 0x6a, 0xfb, 0x18, 0x59, 0xb4, 0x67, 0xbd, 0xfb, 0x96, 0x9e, 0xb3,
-  0x09, 0x17, 0x17, 0x3b, 0x70, 0x91, 0x6d, 0xf6, 0xaa, 0x2d, 0xfe, 0x8b,
-  0x66, 0x32, 0xdd, 0xdd, 0xc7, 0x81, 0x05, 0x07, 0x8c, 0x9a, 0x3f, 0xd2,
-  0xe5, 0x4c, 0x9b, 0x7a, 0xc4, 0x6d, 0x3e, 0x7c, 0x4a, 0x3f, 0xbe, 0xc2,
-  0x0f, 0xc3, 0xd7, 0x46, 0x7a, 0xa9, 0xd9, 0x2f, 0x9a, 0x78, 0x47, 0xc0,
-  0x0b, 0x13, 0x9e, 0x30, 0x60, 0x2a, 0x7a, 0xcd, 0xbf, 0xe4, 0xc9, 0x23,
-  0xef, 0xd0, 0xdc, 0x7e, 0x04, 0x50, 0xf4, 0xb2, 0xcc, 0x40, 0x89, 0x23,
-  0x0e, 0xa3, 0x9c, 0x2d, 0x72, 0x45, 0xd4, 0x93, 0x9c, 0x13, 0xfe, 0x53,
-  0x9d, 0x17, 0x85, 0x94, 0x3e, 0x13, 0xc6, 0x93, 0xae, 0xc9, 0x0c, 0x5c,
-  0xdf, 0x9f, 0x60, 0xef, 0xb5, 0xe6, 0xb8, 0x3f, 0x3a, 0xb7, 0xc7, 0x20,
-  0x84, 0x1b, 0xc0, 0x00, 0xb5, 0x86, 0xb1, 0x14, 0xb4, 0x98, 0xcf, 0x3e,
-  0x6c, 0x15, 0x8f, 0x70, 0x1b, 0x99, 0xdf, 0x6c, 0x64, 0x49, 0xad, 0x85,
-  0xaf, 0x6c, 0x19, 0x82, 0xd4, 0xf2, 0xc3, 0x2a, 0x45, 0x88, 0x1c, 0xb7,
-  0x66, 0x45, 0xf8, 0x7e, 0x64, 0x5f, 0x2e, 0x33, 0x9e, 0x5b, 0xa9, 0x53,
-  0x86, 0x9a, 0x22, 0x33, 0x98, 0x47, 0xdd, 0x15, 0x18, 0xd1, 0x85, 0x4a,
-  0xd7, 0x20, 0x83, 0x02, 0x73, 0x19, 0xcd, 0xf6, 0xe6, 0xc6, 0x24, 0x1e,
-  0x4d, 0x61, 0xf9, 0x2c, 0xf8, 0x3a, 0x68, 0x54, 0xb5, 0x3c, 0x28, 0x56,
-  0xf3, 0xd1, 0xcd, 0xd1, 0xd9, 0xa0, 0xfd, 0x75, 0xa9, 0x2f, 0xa0, 0xb1,
-  0x37, 0x70, 0x2d, 0xe2, 0x69, 0x12, 0xf6, 0xc0, 0x32, 0x59, 0x4a, 0x44,
-  0xd9, 0xa8, 0xe9, 0x5d, 0x8b, 0x4b, 0x67, 0x70, 0x71, 0x76, 0xfc, 0xc5,
-  0xb9, 0xfd, 0x58, 0xbb, 0xe4, 0x8f, 0xae, 0xf0, 0x29, 0x6a, 0x1f, 0xb4,
-  0x58, 0x7f, 0x1b, 0x83, 0x73, 0xd8, 0x75, 0xde, 0x3a, 0x8f, 0x6a, 0x5a,
-  0x78, 0x5d, 0x68, 0xb1, 0xab, 0x24, 0x29, 0xd5, 0x14, 0xda, 0x9b, 0xe3,
-  0xf0, 0x90, 0xfd, 0x2f, 0x3e, 0x6f, 0xde, 0x65, 0x47, 0x67, 0x6b, 0xba,
-  0xc3, 0x37, 0x3d, 0x0b, 0x2f, 0xd6, 0xeb, 0x5b, 0x72, 0x50, 0xa5, 0xce,
-  0x76, 0xcb, 0xc9, 0xbb, 0x38, 0xb1, 0x1f, 0x95, 0xa9, 0x1b, 0x54, 0x1d,
-  0x8e, 0xbb, 0xd0, 0x3c, 0x12, 0xa6, 0xb8, 0x62, 0x58, 0x34, 0x9c, 0xc6,
-  0x74, 0x87, 0x46, 0x2d, 0x88, 0xc0, 0x81, 0x35, 0xbc, 0x0a, 0x36, 0x1b,
-  0xac, 0xb2, 0xc2, 0x5f, 0x18, 0xd0, 0x9f, 0xaf, 0xd2, 0xdc, 0x64, 0xe9,
-  0xce, 0xb3, 0xa5, 0x20, 0xfe, 0xfe, 0x92, 0xba, 0xa7, 0x4b, 0x8a, 0x7d,
-  0x96, 0x90, 0x15, 0xa3, 0x97, 0x72, 0x1d, 0x7d, 0xd6, 0x38, 0x10, 0x92,
-  0xa4, 0x65, 0x86, 0x61, 0x73, 0xd7, 0xf0, 0xa5, 0x0f, 0x0b, 0x8f, 0xcb,
-  0xf4, 0x63, 0x20, 0xfd, 0x84, 0x8b, 0xd5, 0x63, 0x9a, 0x92, 0xf7, 0xd7,
-  0xe2, 0xd5, 0x5e, 0x4e, 0x83, 0x04, 0x33, 0x43, 0xde, 0x94, 0xce, 0x23,
-  0xad, 0x65, 0x26, 0x48, 0x78, 0x06, 0x59, 0x6a, 0xa9, 0x4d, 0xe2, 0x09,
-  0xad, 0xdf, 0x0e, 0xa8, 0xd6, 0x32, 0x4b, 0x1f, 0x5c, 0x5d, 0xae, 0x8a,
-  0x3c, 0x1d, 0x94, 0xd1, 0xe6, 0x5b, 0x49, 0x1a, 0x0e, 0x52, 0x7b, 0x5a,
-  0x02, 0x8d, 0xd8, 0x41, 0x03, 0x2b, 0x57, 0x47, 0x1e, 0xef, 0xb0, 0x89,
-  0x0c, 0xa1, 0xc9, 0x62, 0x05, 0xe2, 0x5c, 0x22, 0x49, 0x32, 0x1a, 0x2d,
-  0x61, 0xbd, 0x62, 0xc3, 0x3f, 0xc3, 0x60, 0xae, 0x69, 0x70, 0x85, 0xdb,
-  0xbb, 0xf3, 0x67, 0xb3, 0x9a, 0x75, 0xcc, 0xac, 0x8e, 0x44, 0xf7, 0x00,
-  0x03, 0x84, 0x9b, 0xb7, 0x32, 0x45, 0xb2, 0x1c, 0xe8, 0xac, 0x61, 0xc7,
-  0x1e, 0x4b, 0x29, 0x6e, 0xf1, 0x37, 0x53, 0xbb, 0xbd, 0x4e, 0x7b, 0x29,
-  0x52, 0x0f, 0xe3, 0x07, 0x91, 0x88, 0x45, 0x65, 0x35, 0x7a, 0x9b, 0x95,
-  0x4f, 0x7a, 0x71, 0xf5, 0xbd, 0x96, 0x43, 0x92, 0xe3, 0xca, 0x65, 0xb3,
-  0xb0, 0xd0, 0x50, 0x92, 0xce, 0xb8, 0xa8, 0x0b, 0x6b, 0x14, 0x58, 0x74,
-  0x5f, 0x52, 0x93, 0xe5, 0x41, 0x58, 0x05, 0x4b, 0x0e, 0x1c, 0x50, 0x53,
-  0xe3, 0x30, 0xe1, 0x2c, 0xf8, 0x69, 0x76, 0x5f, 0x17, 0x5a, 0x0e, 0x70,
-  0xdd, 0xfb, 0xd1, 0xf1, 0x1d, 0xe5, 0x7d, 0x6e, 0xb0, 0xc5, 0xff, 0xf6,
-  0xef, 0xf6, 0xf5, 0x3b, 0xac, 0xd8, 0x3f, 0x6c, 0xc5, 0x5a, 0x8d, 0x76,
-  0xb1, 0x49, 0xe7, 0xbf, 0xe5, 0x65, 0xe1, 0x5c, 0x4e, 0x59, 0x1b, 0x8e,
-  0xe5, 0x97, 0x06, 0x7f, 0xeb, 0xeb, 0x71, 0xe9, 0xec, 0x63, 0xd4, 0x50,
-  0x83, 0x88, 0xd0, 0x9c, 0xac, 0xca, 0xa3, 0x7f, 0x21, 0x9d, 0x8a, 0xe8,
-  0x1a, 0xb0, 0xc9, 0xf0, 0x0b, 0x87, 0x35, 0x69, 0xfe, 0x92, 0x6b, 0x81,
-  0x37, 0x12, 0x81, 0x68, 0xf0, 0xf1, 0x48, 0x4f, 0xe4, 0x5f, 0x1a, 0x0e,
-  0x78, 0x29, 0x50, 0x83, 0x0d, 0xf9, 0x6d, 0x8f, 0x8e, 0x87, 0xe6, 0xcd,
-  0xc4, 0x91, 0x16, 0x97, 0x8c, 0xec, 0x33, 0xc3, 0xea, 0x9d, 0x3f, 0xd9,
-  0xef, 0x05, 0xda, 0x77, 0xb7, 0x01, 0xa1, 0x0a, 0xd7, 0x9c, 0x48, 0x4c,
-  0x01, 0x14, 0xa7, 0xa4, 0xf4, 0xfc, 0x36, 0x12, 0x97, 0xa0, 0xc4, 0x04,
-  0x2e, 0xd9, 0xb0, 0x70, 0x5f, 0xc5, 0x2b, 0x6f, 0x55, 0xfc, 0x9a, 0xa5,
-  0x23, 0x9c, 0x68, 0x53, 0xdd, 0x26, 0x4b, 0x67, 0xe2, 0x10, 0x82, 0x86,
-  0x94, 0xc3, 0x3e, 0x76, 0x46, 0xb2, 0x86, 0xf8, 0xcf, 0x73, 0xe6, 0x12,
-  0xdd, 0xec, 0xca, 0x83, 0xd9, 0x58, 0x80, 0x2c, 0x25, 0x6a, 0x2d, 0x44,
-  0x70, 0x57, 0xcd, 0x7b, 0x6d, 0x2e, 0x96, 0x42, 0xef, 0x3a, 0x88, 0x35,
-  0x53, 0x87, 0x48, 0xd7, 0xb8, 0x63, 0x50, 0xc2, 0xe9, 0xd8, 0xd7, 0xa5,
-  0x90, 0xea, 0x69, 0xed, 0x65, 0xdb, 0xa2, 0xa6, 0x01, 0xc5, 0xca, 0xf7,
-  0x35, 0xf9, 0x3a, 0x7c, 0x3c, 0xef, 0x38, 0x56, 0xdd, 0x9d, 0x29, 0xe2,
-  0x2c, 0x49, 0x8e, 0x5c, 0x57, 0x89, 0x61, 0x77, 0x33, 0xa3, 0x5e, 0x97,
-  0x92, 0x59, 0x1f, 0xc4, 0xe5, 0x3d, 0xde, 0x77, 0xae, 0x29, 0x8c, 0x52,
-  0xc6, 0x67, 0x6b, 0xb0, 0xcd, 0xc1, 0x07, 0xeb, 0x06, 0xa1, 0xc8, 0x17,
-  0x72, 0xb0, 0xfd, 0x28, 0x64, 0x18, 0xaa, 0x23, 0xf2, 0x12, 0xf3, 0x38,
-  0xd2, 0xb5, 0x1e, 0xe0, 0x68, 0x4d, 0x48, 0x7e, 0xb4, 0x25, 0xd6, 0x9f,
-  0x58, 0xf1, 0x54, 0xb6, 0xcd, 0xdd, 0xa6, 0xfc, 0xc9, 0xc0, 0x65, 0xde,
-  0xd7, 0x1c, 0x47, 0x53, 0x36, 0xe2, 0x1c, 0x9f, 0x36, 0x0c, 0xbf, 0x30,
-  0x74, 0xbc, 0x93, 0x60, 0x71, 0xc7, 0xaf, 0x7c, 0xec, 0x78, 0x37, 0xa8,
-  0x47, 0xd4, 0xf5, 0x60, 0x35, 0xac, 0xcd, 0xac, 0xa9, 0xf1, 0xdd, 0xb2,
-  0xb3, 0x3c, 0xff, 0x64, 0x2c, 0xac, 0x9f, 0x2d, 0xdb, 0x2e, 0x5e, 0x56,
-  0x2e, 0x31, 0xbb, 0x33, 0x66, 0xe9, 0xf4, 0xbd, 0x0d, 0x4e, 0x53, 0x55,
-  0x69, 0x58, 0x38, 0x5a, 0xb6, 0x9e, 0x1a, 0x9e, 0x14, 0xf8, 0x15, 0x94,
-  0xe8, 0x46, 0xb9, 0xcb, 0xa8, 0x85, 0x45, 0x6b, 0xa4, 0x29, 0x43, 0x5d,
-  0xdb, 0x74, 0x71, 0x59, 0xa0, 0xbe, 0xe6, 0xad, 0x43, 0xd3, 0x14, 0x23,
-  0xc3, 0xe3, 0xcd, 0x49, 0xd6, 0x81, 0x55, 0x72, 0x53, 0x11, 0x8e, 0xed,
-  0x12, 0x71, 0xe1, 0xaf, 0xe6, 0xf6, 0x21, 0x57, 0xc9, 0xab, 0xb9, 0x01,
-  0x7e, 0x44, 0x61, 0xa1, 0x80, 0x0f, 0x1e, 0x94, 0x03, 0x75, 0x6c, 0x41,
-  0x15, 0x62, 0x20, 0x90, 0x2d, 0xb3, 0xa0, 0x6e, 0x3f, 0xde, 0xdc, 0x07,
-  0x4c, 0x65, 0x81, 0x63, 0x25, 0xe2, 0xe2, 0xfb, 0x97, 0xff, 0x57, 0x9a,
-  0xa9, 0x2f, 0x07, 0xa6, 0xb0, 0x0c, 0x02, 0xbd, 0x60, 0x39, 0x2b, 0xc3,
-  0xe4, 0x3a, 0x6d, 0x78, 0x0a, 0xda, 0xa4, 0x60, 0xa7, 0xc9, 0x83, 0xd9,
-  0xd3, 0xc4, 0x7a, 0x75, 0x1c, 0x02, 0x49, 0x5f, 0x03, 0x78, 0xda, 0x07,
-  0x9c, 0x07, 0xc5, 0x84, 0xe7, 0xc3, 0x14, 0xdc, 0xb8, 0x23, 0xdb, 0x90,
-  0x40, 0xa0, 0xa1, 0xbd, 0x78, 0x7f, 0x83, 0x50, 0xd5, 0xc5, 0xf2, 0x79,
-  0x07, 0x65, 0x61, 0xcd, 0x7e, 0xb8, 0xc2, 0x80, 0x6b, 0x16, 0x9c, 0x91,
-  0xb1, 0x40, 0xea, 0x9a, 0x81, 0x13, 0xa0, 0x8d, 0x3e, 0xde, 0x3f, 0x9d,
-  0xec, 0x45, 0xe1, 0xab, 0x07, 0x0b, 0xd5, 0xcb, 0xb9, 0xeb, 0x1a, 0xad,
-  0x31, 0x48, 0xc3, 0x87, 0x91, 0x03, 0xdb, 0xc5, 0x7d, 0xdc, 0xbd, 0x45,
-  0xe5, 0xa3, 0xd6, 0x12, 0xb3, 0x28, 0xfe, 0x2a, 0x96, 0x5a, 0xb6, 0x4c,
-  0x88, 0xef, 0x1b, 0x5d, 0x2c, 0x1a, 0x40, 0x6d, 0x15, 0xc4, 0xe4, 0xa0,
-  0x11, 0x1a, 0x4c, 0xc7, 0x62, 0x48, 0xf9, 0x30, 0x7e, 0xc6, 0x3c, 0x0c,
-  0x2b, 0xe5, 0x43, 0x23, 0x82, 0xf5, 0x0a, 0x1c, 0x6e, 0x4d, 0xfb, 0x65,
-  0xf4, 0x41, 0x99, 0x13, 0x3c, 0x58, 0x1e, 0xfb, 0x87, 0x1f, 0xa2, 0x5f,
-  0x85, 0x87, 0x89, 0x45, 0x8b, 0xf3, 0xc4, 0x1b, 0xe7, 0x87, 0x41, 0xb5,
-  0xd7, 0x60, 0x89, 0x44, 0x0d, 0x68, 0x91, 0x9c, 0x77, 0x41, 0x25, 0x0d,
-  0x67, 0x1a, 0xab, 0xb1, 0x0a, 0x91, 0xe5, 0x9a, 0xb9, 0x4e, 0x51, 0x4b,
-  0x78, 0xa6, 0xe4, 0x36, 0x55, 0xc0, 0xa9, 0xe6, 0x5c, 0x37, 0x5e, 0x30,
-  0xaa, 0xe2, 0x29, 0xce, 0x50, 0xd9, 0x9a, 0x27, 0xd6, 0xbc, 0x7c, 0x69,
-  0x1f, 0x1b, 0xe7, 0x06, 0x05, 0x0c, 0xdf, 0x59, 0xd6, 0xaf, 0x9e, 0x1b,
-  0xbe, 0x19, 0x7d, 0x92, 0x91, 0x24, 0xa0, 0x8b, 0xf4, 0x91, 0x70, 0x81,
-  0x0a, 0x79, 0xba, 0xe5, 0x14, 0x72, 0x6b, 0x1a, 0xcd, 0x13, 0x7d, 0x58,
-  0x6b, 0xf2, 0xf4, 0xba, 0xb6, 0xd4, 0x8e, 0xfe, 0x68, 0x5b, 0xe6, 0x79,
-  0x77, 0xc3, 0x62, 0x19, 0xeb, 0xbd, 0xdb, 0xd5, 0x26, 0x84, 0x71, 0x9f,
-  0xae, 0xf8, 0xf1, 0x07, 0x8d, 0x9f, 0x35, 0x1d, 0x13, 0xc5, 0x1e, 0xef,
-  0x51, 0xeb, 0xd0, 0x8a, 0xd4, 0xd2, 0xe8, 0x1a, 0xc5, 0xee, 0xfd, 0x4e,
-  0xa0, 0xeb, 0x18, 0x7e, 0xa9, 0x6b, 0x3f, 0x33, 0x79, 0x26, 0x50, 0x85,
-  0x48, 0x48, 0x2d, 0x96, 0xb9, 0xd4, 0xc4, 0x7b, 0x3f, 0x31, 0x39, 0x26,
-  0xe0, 0x0a, 0x6e, 0xb6, 0x8f, 0xc1, 0xed, 0x5f, 0x38, 0x06, 0xfd, 0xb0,
-  0x3e, 0x02, 0x3f, 0x84, 0x9f, 0x38, 0x06, 0x69, 0xaf, 0x31, 0x02, 0xcd,
-  0xa6, 0x7e, 0x87, 0xe0, 0x4e, 0x3b, 0xf2, 0x87, 0xf2, 0x59, 0xef, 0x8a,
-  0x3f, 0x53, 0x94, 0x96, 0xa0, 0x22, 0xa8, 0x05, 0x62, 0x13, 0x7f, 0x9f,
-  0xbc, 0x77, 0x04, 0xb9, 0xab, 0xe3, 0xdb, 0xe8, 0x9b, 0x04, 0x5d, 0x13,
-  0x4e, 0x0a, 0xa8, 0x52, 0x4e, 0xaf, 0x47, 0xf5, 0x6b, 0xf7, 0x05, 0xa7,
-  0x10, 0x19, 0x04, 0x01, 0x87, 0x2c, 0xff, 0x04, 0xfe, 0xf0, 0x01, 0x39,
-  0x39, 0x18, 0x85, 0xaf, 0x44, 0x6b, 0xa3, 0x10, 0x0c, 0x05, 0xff, 0xb1,
-  0xca, 0xe0, 0x49, 0x9e, 0xf8, 0x2a, 0x02, 0x32, 0xa8, 0x9f, 0x27, 0x33,
-  0x37, 0xc7, 0x31, 0x21, 0x4d, 0x80, 0x26, 0x97, 0xaf, 0xde, 0x31, 0xfa,
-  0xcb, 0x55, 0x80, 0xe2, 0xc4, 0x1f, 0x98, 0x85, 0x92, 0x43, 0xd8, 0xe1,
-  0xfb, 0x4d, 0x15, 0x3a, 0x74, 0x9a, 0xb1, 0x75, 0xf1, 0xf1, 0x71, 0x48,
-  0xf6, 0x52, 0x0d, 0xa2, 0xca, 0x30, 0x51, 0x6a, 0x09, 0x1e, 0x81, 0x3c,
-  0xff, 0xcb, 0x79, 0x70, 0x5d, 0xf6, 0x41, 0xf4, 0x92, 0x7f, 0xbc, 0x27,
-  0xd5, 0x22, 0x30, 0x19, 0x04, 0x20, 0x98, 0xef, 0x4d, 0xb3, 0xe0, 0xa4,
-  0x8a, 0xba, 0x85, 0x66, 0x7d, 0x8a, 0xc5, 0x87, 0x79, 0x9c, 0x92, 0x87,
-  0x54, 0xb2, 0x23, 0xdb, 0x22, 0x92, 0x1d, 0x6d, 0x14, 0x49, 0x59, 0xb4,
-  0x62, 0x57, 0x5a, 0x6c, 0x49, 0xdf, 0x5c, 0x50, 0x44, 0x44, 0x82, 0x63,
-  0xc8, 0xf8, 0xda, 0x2d, 0x6d, 0xa2, 0xad, 0xb2, 0xad, 0xfe, 0x97, 0xa6,
-  0x6f, 0x58, 0x4c, 0x40, 0x21, 0x41, 0xde, 0xc0, 0xc7, 0xcc, 0xa2, 0x0e,
-  0x63, 0xe8, 0xd9, 0xa8, 0x69, 0xd6, 0xed, 0x1e, 0x47, 0x91, 0x10, 0x4d,
-  0xd3, 0xaa, 0x49, 0x8d, 0x9a, 0x9f, 0x87, 0x40, 0x5a, 0x89, 0x7f, 0x31,
-  0x2f, 0x64, 0x1b, 0x1c, 0xaa, 0x64, 0x6c, 0xf1, 0x51, 0x5c, 0xa0, 0x7c,
-  0x18, 0x7b, 0x82, 0x05, 0x92, 0x08, 0xf0, 0xf4, 0x52, 0xcd, 0x12, 0xaf,
-  0x4b, 0x78, 0x16, 0xfb, 0x4c, 0x85, 0x91, 0xd1, 0xb7, 0x4d, 0x53, 0x9f,
-  0x39, 0x88, 0xbc, 0xe8, 0x1a, 0x8c, 0x50, 0x1c, 0x9a, 0x0a, 0x10, 0xe7,
-  0x30, 0x07, 0x7c, 0xc9, 0xd2, 0x66, 0xc9, 0x2c, 0xd1, 0x4a, 0x80, 0xf2,
-  0xaf, 0x35, 0x53, 0x78, 0xc5, 0xea, 0xf0, 0xa5, 0x86, 0x91, 0xca, 0x96,
-  0xad, 0xb1, 0x90, 0xaf, 0xb8, 0xc0, 0xea, 0xee, 0xd5, 0x1a, 0x70, 0xed,
-  0x3a, 0xd3, 0xca, 0xa0, 0xe2, 0x30, 0xe6, 0xb8, 0xa8, 0xbd, 0x6e, 0x80,
-  0xc5, 0xca, 0x1a, 0x51, 0x03, 0x7c, 0x48, 0xb0, 0xba, 0x80, 0xbb, 0x56,
-  0xbf, 0x20, 0x38, 0xac, 0xe3, 0x1e, 0xb5, 0x34, 0x34, 0x59, 0x4a, 0xdb,
-  0x69, 0x25, 0xc5, 0xae, 0x13, 0x98, 0x6d, 0x31, 0x1b, 0x6b, 0xcc, 0xa8,
-  0x66, 0x5b, 0x1a, 0xdf, 0xba, 0xcd, 0x92, 0x51, 0x42, 0xa7, 0x88, 0xcf,
-  0x3f, 0x9b, 0x98, 0xff, 0xd0, 0x62, 0x4b, 0xfe, 0xc5, 0x99, 0xc1, 0xb7,
-  0x1c, 0xae, 0x20, 0xb7, 0xfe, 0x5a, 0xd8, 0x3d, 0x29, 0xed, 0x34, 0x70,
-  0xc1, 0xcb, 0x31, 0xdd, 0x80, 0x45, 0x49, 0xf2, 0xa6, 0xbd, 0xa9, 0x20,
-  0xe7, 0x1a, 0xa8, 0xf3, 0x41, 0x58, 0xd5, 0x55, 0x60, 0x5d, 0x07, 0xc5,
-  0x77, 0x55, 0x09, 0xdf, 0x77, 0xf2, 0x88, 0xaf, 0xf2, 0xd2, 0x82, 0x1f,
-  0x19, 0xc2, 0x2c, 0x6a, 0xf5, 0x6d, 0x19, 0x0f, 0x7b, 0x59, 0xef, 0xd3,
-  0x42, 0x43, 0x40, 0x14, 0x82, 0x41, 0x13, 0xa0, 0xd9, 0xc3, 0xf8, 0xc5,
-  0xf1, 0xd5, 0x76, 0x33, 0xe9, 0x37, 0x1e, 0xfb, 0x91, 0x31, 0x7e, 0x8d,
-  0x9e, 0x03, 0x2b, 0x10, 0x1e, 0xa4, 0xad, 0x60, 0xd7, 0x1e, 0x16, 0xd3,
-  0x78, 0x1e, 0xd7, 0x02, 0x3b, 0x6c, 0xed, 0x5e, 0xaf, 0x59, 0xba, 0x00,
-  0xab, 0xcd, 0xd6, 0x2d, 0x88, 0x56, 0x3f, 0x3d, 0x19, 0x5c, 0xf1, 0x3a,
-  0x36, 0x8a, 0xb1, 0x73, 0xcc, 0x00, 0x14, 0x5f, 0xc0, 0xca, 0xaa, 0xb7,
-  0x15, 0xe1, 0xcb, 0xbf, 0x1e, 0x89, 0xac, 0x90, 0xd6, 0x09, 0xe1, 0x47,
-  0x53, 0xaf, 0xf1, 0x6f, 0x0b, 0x5c, 0x47, 0xec, 0x85, 0x35, 0x38, 0x67,
-  0x70, 0x31, 0x6b, 0xd6, 0xb0, 0xbc, 0x2c, 0x09, 0xc2, 0x22, 0x43, 0x2e,
-  0x50, 0x00, 0x42, 0xcc, 0x3c, 0xe3, 0x65, 0xde, 0xbc, 0x32, 0xe3, 0x28,
-  0xe8, 0x50, 0x92, 0x8c, 0xbb, 0x15, 0x49, 0x17, 0x6e, 0x82, 0xc2, 0x43,
-  0xe5, 0x51, 0xf7, 0xc1, 0x0b, 0x0d, 0xe3, 0xab, 0xaf, 0xcf, 0x62, 0xc9,
-  0xef, 0xe1, 0x90, 0x6c, 0xda, 0x7b, 0xa4, 0x17, 0x4d, 0x91, 0x74, 0x0b,
-  0x66, 0x2e, 0x39, 0xaa, 0xab, 0xc7, 0x41, 0xe7, 0x24, 0x70, 0x28, 0x74,
-  0x9c, 0x49, 0x54, 0xc1, 0xd2, 0x95, 0x6f, 0xe0, 0x2a, 0x21, 0xb1, 0x14,
-  0x1d, 0xe4, 0x35, 0x69, 0x0a, 0x7d, 0x2a, 0x74, 0x89, 0x47, 0x32, 0xc8,
-  0xa2, 0x88, 0xad, 0x34, 0xb9, 0xd5, 0xca, 0xa2, 0x19, 0xe4, 0xab, 0x5a,
-  0x65, 0xed, 0x16, 0xbd, 0xf2, 0x5f, 0x52, 0x68, 0xfb, 0x3b, 0x47, 0x13,
-  0xb2, 0x86, 0x2f, 0xf9, 0x8f, 0x9f, 0x44, 0x15, 0x41, 0x2e, 0x39, 0xbf,
-  0xcc, 0xf6, 0x8a, 0x0a, 0x79, 0x34, 0x19, 0x07, 0x11, 0x4c, 0x57, 0x6a,
-  0xe2, 0xf8, 0xdd, 0xb6, 0x72, 0xea, 0x34, 0x8a, 0x2a, 0x51, 0x04, 0xcf,
-  0xb0, 0xed, 0x9b, 0xb6, 0xb5, 0x0d, 0xce, 0xbd, 0xf7, 0x9d, 0xd5, 0x92,
-  0x7b, 0xb2, 0x8b, 0x0b, 0x8a, 0x25, 0x98, 0xa4, 0xfc, 0x15, 0x17, 0xef,
-  0x47, 0xa4, 0x94, 0xd1, 0xe3, 0x3d, 0x3e, 0x00, 0x2f, 0xc7, 0x31, 0x5b,
-  0x27, 0x2c, 0x1a, 0xe0, 0x51, 0x34, 0x3e, 0x05, 0x1c, 0x57, 0xd3, 0x17,
-  0xae, 0x70, 0xe4, 0x1a, 0x0e, 0x01, 0x35, 0x31, 0xcb, 0xc6, 0xea, 0xd8,
-  0x89, 0x4b, 0x5b, 0xe3, 0xb5, 0x25, 0x82, 0x0c, 0x39, 0x04, 0x07, 0x90,
-  0x1e, 0xef, 0x46, 0x0a, 0x5e, 0xb9, 0xa6, 0x49, 0x87, 0xd8, 0xd9, 0x28,
-  0xaf, 0x29, 0xd9, 0xfa, 0x0a, 0x67, 0x18, 0x4e, 0xc3, 0xae, 0x56, 0x08,
-  0x38, 0x05, 0xfb, 0x7b, 0x89, 0xad, 0xf1, 0x33, 0xe2, 0xed, 0xe3, 0xa2,
-  0xf2, 0x0d, 0xad, 0x05, 0xe6, 0x0c, 0x1f, 0xdd, 0x44, 0x1a, 0x07, 0x63,
-  0x5f, 0xc3, 0xd7, 0xe8, 0x71, 0xa8, 0x68, 0x9c, 0x6a, 0xd0, 0x32, 0xd4,
-  0x1f, 0x83, 0xf9, 0x6a, 0x89, 0xb9, 0x56, 0x2f, 0xa2, 0xcf, 0xf6, 0xd1,
-  0xf8, 0x4c, 0xe5, 0xb5, 0xbf, 0x51, 0xfc, 0x15, 0x87, 0x8e, 0xfb, 0x8e,
-  0xda, 0xc2, 0x28, 0x1f, 0xc9, 0x5b, 0x2c, 0xe4, 0x06, 0xa8, 0x4d, 0x57,
-  0x6f, 0x84, 0x76, 0x31, 0xc4, 0x4a, 0x83, 0x56, 0xde, 0x08, 0xe1, 0x57,
-  0xb7, 0x7a, 0xdb, 0x52, 0x75, 0xe7, 0x36, 0x11, 0x44, 0x1b, 0xd9, 0xe8,
-  0xa6, 0x62, 0x19, 0x3b, 0x9d, 0xcf, 0x85, 0xd2, 0x65, 0xd3, 0xb1, 0x3f,
-  0x53, 0x96, 0x5f, 0x80, 0xce, 0x76, 0xc4, 0x62, 0x64, 0x3c, 0x8f, 0x61,
-  0x98, 0x1b, 0xf7, 0x49, 0xad, 0x31, 0x52, 0xf8, 0xc2, 0xc6, 0xfc, 0x55,
-  0xec, 0x1a, 0xfc, 0x35, 0x63, 0x4b, 0x81, 0xff, 0xc0, 0xaa, 0x5e, 0xd1,
-  0x0a, 0x0a, 0x05, 0x4c, 0x08, 0x8f, 0x1e, 0x31, 0x6f, 0xd1, 0x0f, 0x51,
-  0xcc, 0xd3, 0xc1, 0x96, 0x42, 0x95, 0x55, 0x6c, 0x9c, 0x7e, 0xd4, 0x92,
-  0x43, 0x58, 0x29, 0x18, 0xe4, 0xc1, 0x4b, 0xaa, 0x35, 0x0d, 0x42, 0x64,
-  0x51, 0x84, 0xfb, 0xa2, 0x56, 0xe4, 0xbc, 0x6c, 0x8b, 0xc7, 0x67, 0x52,
-  0xf3, 0x98, 0xa9, 0xa1, 0xc5, 0x30, 0xea, 0x20, 0x6e, 0x75, 0x58, 0x2c,
-  0xf3, 0xf1, 0x72, 0xd6, 0xe9, 0x07, 0x35, 0x51, 0x75, 0x61, 0xc0, 0x44,
-  0xeb, 0x47, 0x41, 0x2e, 0x22, 0xea, 0xf3, 0xd9, 0x6e, 0xcd, 0xfc, 0x68,
-  0xd8, 0x18, 0x01, 0x1a, 0x46, 0x6f, 0x2f, 0xa4, 0x1f, 0x6a, 0xaf, 0x45,
-  0xea, 0x2a, 0x71, 0xbb, 0xfd, 0x8a, 0xdb, 0xb7, 0x4b, 0xcb, 0x09, 0x79,
-  0x76, 0xaf, 0xbf, 0xdb, 0x2e, 0x41, 0x22, 0xe0, 0x66, 0x94, 0xf8, 0xb2,
-  0x27, 0x29, 0x69, 0x82, 0x18, 0x6f, 0xe1, 0x4b, 0x63, 0x89, 0x03, 0x55,
-  0x25, 0xaf, 0x5d, 0x3b, 0xa6, 0x8d, 0x52, 0x6a, 0xae, 0xde, 0x43, 0xe1,
-  0xf8, 0x02, 0x67, 0x58, 0x26, 0x62, 0x89, 0x7c, 0xe1, 0x64, 0xb7, 0x60,
-  0x78, 0x7b, 0x60, 0xbb, 0xd3, 0xe2, 0x6e, 0xaf, 0x15, 0xf4, 0xb5, 0x36,
-  0x34, 0xc8, 0x63, 0x57, 0x83, 0x53, 0x17, 0xd3, 0xb7, 0x27, 0x52, 0xad,
-  0x15, 0x50, 0x09, 0xaa, 0xad, 0xac, 0xa9, 0x12, 0x74, 0x75, 0x3a, 0x30,
-  0xa9, 0xd6, 0x0f, 0x61, 0x1f, 0xd7, 0x66, 0x31, 0xbd, 0xdb, 0x6f, 0xaf,
-  0xad, 0xab, 0x63, 0xa8, 0x0c, 0x62, 0x10, 0x0c, 0x62, 0xbf, 0x39, 0x88,
-  0xc7, 0x0a, 0x15, 0x49, 0x85, 0xdb, 0xda, 0x10, 0x9e, 0xe8, 0x10, 0x9e,
-  0x7c, 0xe8, 0x2a, 0x84, 0x03, 0x78, 0xf2, 0x53, 0x57, 0xa1, 0x75, 0x08,
-  0x4f, 0x11, 0x1f, 0xbb, 0xb8, 0x7b, 0xda, 0x12, 0x15, 0xea, 0x70, 0xf2,
-  0x38, 0x2c, 0x0c, 0x59, 0xef, 0x53, 0x31, 0x7c, 0x79, 0x3f, 0x1b, 0x40,
-  0xbf, 0x0d, 0x5d, 0x3e, 0xf3, 0x16, 0xfa, 0x93, 0x8b, 0xf6, 0x72, 0xe3,
-  0x1e, 0x79, 0x4d, 0xf2, 0xf9, 0x27, 0xf6, 0xcb, 0xe2, 0xee, 0xe3, 0x9e,
-  0xf6, 0x50, 0x2b, 0x63, 0x22, 0x85, 0x11, 0xd6, 0x84, 0x27, 0x4a, 0x69,
-  0x38, 0x78, 0x62, 0x24, 0x4a, 0x09, 0x1f, 0x9c, 0x5c, 0xdc, 0x3d, 0xb5,
-  0x41, 0x25, 0x12, 0x2b, 0x16, 0x4c, 0xf7, 0x63, 0x99, 0xee, 0xc7, 0xff,
-  0x27, 0x4d, 0xf7, 0xe3, 0xf5, 0xd3, 0xfd, 0x48, 0xd4, 0x73, 0xc6, 0xaf,
-  0xe9, 0x0d, 0xe3, 0x7c, 0x2d, 0xac, 0x97, 0x45, 0x38, 0x39, 0xb0, 0x9b,
-  0x4a, 0xa4, 0xae, 0x56, 0xeb, 0x95, 0x6f, 0xa8, 0x99, 0xf5, 0xac, 0xa0,
-  0x22, 0xd7, 0xa3, 0x24, 0x73, 0x51, 0xa6, 0xa3, 0xa2, 0xff, 0xeb, 0x17,
-  0x3b, 0x73, 0x63, 0xa3, 0xbe, 0x5e, 0x9f, 0x9c, 0x1e, 0xbb, 0x30, 0xc0,
-  0xff, 0xba, 0xd3, 0x6f, 0x45, 0xda, 0x3f, 0x6a, 0x62, 0xe1, 0x77, 0xb9,
-  0x96, 0x6c, 0x0d, 0x51, 0x3f, 0x10, 0x26, 0x8e, 0xcf, 0xbe, 0x3e, 0xb9,
-  0x3c, 0x3f, 0x7b, 0x73, 0x7c, 0xe6, 0x42, 0x02, 0x38, 0x52, 0x41, 0x6c,
-  0x0f, 0xdf, 0x9b, 0x75, 0xe1, 0xc5, 0xce, 0xce, 0x0f, 0x8c, 0x99, 0xf2,
-  0x99, 0x5a, 0xf2, 0x9a, 0x37, 0x67, 0xa1, 0xf6, 0x0a, 0x0f, 0x89, 0x6b,
-  0x49, 0x35, 0x6c, 0x19, 0x72, 0xcb, 0xc5, 0x81, 0xad, 0xef, 0x2e, 0x2e,
-  0xcf, 0xbf, 0xfd, 0xee, 0x17, 0x6c, 0x7f, 0x50, 0x01, 0x5d, 0xfd, 0x45,
-  0x9b, 0x7f, 0x1d, 0x8e, 0xfe, 0xe0, 0xf4, 0xf4, 0x17, 0x6b, 0x9c, 0x95,
-  0x01, 0x67, 0xc0, 0xe9, 0x39, 0x6b, 0x98, 0x2b, 0x87, 0x54, 0x51, 0x13,
-  0xce, 0xce, 0xb5, 0x63, 0x31, 0xa3, 0xf4, 0x0c, 0xc9, 0x78, 0xcc, 0x9a,
-  0x3a, 0x08, 0x15, 0x63, 0x68, 0x20, 0x96, 0xf1, 0x97, 0x2c, 0xc3, 0xb8,
-  0x5a, 0x1d, 0x6a, 0x9c, 0x13, 0x7c, 0x5d, 0x8d, 0xf3, 0xcf, 0x9c, 0xa5,
-  0x4c, 0x10, 0x65, 0xcc, 0x04, 0xdb, 0x54, 0x6a, 0xb8, 0xee, 0x29, 0x02,
-  0x32, 0xf2, 0xb4, 0xb8, 0x75, 0x89, 0x12, 0x38, 0xa4, 0x8a, 0xeb, 0x55,
-  0x32, 0x58, 0x22, 0xe4, 0x72, 0x1e, 0x10, 0x88, 0xec, 0xdb, 0x93, 0xab,
-  0xe8, 0xf0, 0xfc, 0xc8, 0x53, 0xf0, 0x15, 0xbb, 0x0b, 0xd8, 0xdc, 0x8a,
-  0x83, 0x38, 0x5c, 0xce, 0x91, 0x18, 0x38, 0xf1, 0x58, 0xc1, 0x8a, 0xd4,
-  0x84, 0xb0, 0x98, 0x42, 0x9d, 0xba, 0x5c, 0xec, 0x5a, 0x90, 0xe9, 0x11,
-  0xec, 0x32, 0x0e, 0xd4, 0x7a, 0x79, 0xd8, 0xc1, 0x57, 0x99, 0xa1, 0x16,
-  0x31, 0x87, 0x80, 0x64, 0xa0, 0xd3, 0x2d, 0x66, 0x00, 0x3a, 0x4c, 0x63,
-  0x9c, 0x0e, 0x49, 0xe7, 0x20, 0x49, 0xe7, 0xc0, 0x0b, 0xf6, 0x01, 0x12,
-  0xb8, 0x80, 0xab, 0xe6, 0x0c, 0x06, 0xd9, 0xd5, 0x28, 0x79, 0xa0, 0xf5,
-  0xc9, 0x60, 0x42, 0x3c, 0x8d, 0x3d, 0xb5, 0x63, 0xcf, 0x7d, 0x3e, 0xba,
-  0xc7, 0xe2, 0x60, 0x5d, 0x1e, 0x61, 0xc6, 0x63, 0x0b, 0xd9, 0x37, 0xe4,
-  0x16, 0x83, 0xfe, 0x95, 0x92, 0x24, 0x69, 0xb1, 0xc6, 0x40, 0xea, 0x37,
-  0x7f, 0x5f, 0x49, 0x5b, 0x50, 0x05, 0x21, 0xda, 0x88, 0xc3, 0x20, 0xfd,
-  0x31, 0x90, 0x97, 0x9f, 0xe8, 0x60, 0x2e, 0x4f, 0x69, 0xe6, 0x53, 0xe1,
-  0x75, 0x1a, 0x2f, 0x29, 0xa0, 0xc2, 0xf7, 0xb1, 0x18, 0xd0, 0x15, 0xdd,
-  0xdf, 0xbf, 0xf9, 0x4c, 0xf1, 0xbd, 0x3c, 0x41, 0x38, 0xae, 0x1c, 0x54,
-  0x8d, 0xac, 0x55, 0x7d, 0x53, 0x8a, 0xa2, 0xd6, 0x00, 0xd3, 0x2c, 0x16,
-  0xdb, 0x26, 0x52, 0x68, 0x2d, 0xa6, 0xe0, 0xe3, 0x46, 0x4f, 0xd6, 0x91,
-  0x54, 0x3d, 0xbc, 0x72, 0x1a, 0x46, 0x18, 0x58, 0x62, 0x03, 0x6f, 0xb6,
-  0xf7, 0x49, 0x7d, 0x61, 0x82, 0xf0, 0x94, 0x6a, 0xf9, 0xb3, 0x4f, 0x1d,
-  0x77, 0x88, 0xee, 0x13, 0x64, 0x15, 0xb8, 0x3a, 0x0b, 0x8b, 0xa9, 0x9b,
-  0x9f, 0x79, 0x82, 0xc5, 0xf5, 0xc8, 0x08, 0xfa, 0xea, 0x8d, 0x1b, 0xb9,
-  0x11, 0x37, 0x54, 0xb6, 0x3c, 0xac, 0x80, 0xfb, 0xdc, 0x77, 0x13, 0xc5,
-  0x1c, 0x3a, 0x8b, 0x38, 0xca, 0x79, 0x6a, 0xf1, 0x4b, 0xda, 0x83, 0x7c,
-  0x04, 0x8f, 0x0e, 0x5d, 0x03, 0x99, 0xfb, 0x5b, 0xdf, 0x68, 0x60, 0x60,
-  0xd4, 0x02, 0x3b, 0xb0, 0x0e, 0xcb, 0x5c, 0x32, 0x6c, 0x3c, 0x3a, 0x07,
-  0xc7, 0x92, 0xc6, 0x73, 0xb5, 0xc7, 0x0b, 0x74, 0x9f, 0xa6, 0x6e, 0x35,
-  0x6e, 0xb5, 0xd2, 0x01, 0x5f, 0x43, 0xcb, 0x95, 0x95, 0x63, 0x30, 0x4a,
-  0x39, 0xdf, 0xbe, 0x51, 0x3e, 0x49, 0x5e, 0x65, 0xe6, 0x23, 0x1b, 0x35,
-  0x82, 0x3a, 0x3c, 0x46, 0xb8, 0x5f, 0x89, 0xbd, 0xbd, 0xda, 0x82, 0x5f,
-  0x1c, 0x0c, 0x06, 0xb6, 0xdc, 0x8c, 0x51, 0xe2, 0xd7, 0x54, 0x56, 0x51,
-  0xbd, 0x56, 0x9c, 0xa1, 0xa8, 0xd9, 0xe7, 0x2d, 0x37, 0xa3, 0x36, 0x53,
-  0xf3, 0xf5, 0xee, 0x3d, 0xf1, 0xeb, 0xee, 0xba, 0xfb, 0x5a, 0x5a, 0xeb,
-  0x7e, 0x70, 0x77, 0xad, 0xbd, 0x7d, 0xdd, 0xd2, 0xdb, 0xd3, 0xda, 0xdc,
-  0xf6, 0xf7, 0x3f, 0x89, 0xec, 0xc4, 0x69, 0x11, 0xad, 0xa0, 0x3b, 0xed,
-  0x4f, 0xcc, 0x00, 0xf4, 0x68, 0xcf, 0x52, 0xaf, 0x93, 0xf6, 0x3a, 0xb7,
-  0x45, 0x05, 0x45, 0x7c, 0xef, 0x99, 0x9f, 0x1a, 0xa9, 0x8b, 0xd2, 0x22,
-  0x6c, 0x12, 0x72, 0x64, 0x5a, 0xce, 0x12, 0x27, 0xdb, 0xe3, 0xe0, 0x9c,
-  0x5c, 0x70, 0xf1, 0xe9, 0xac, 0x6c, 0x77, 0x61, 0xda, 0x50, 0x82, 0xbe,
-  0x3e, 0x71, 0x7d, 0x05, 0xe3, 0x87, 0xa2, 0x28, 0x39, 0xad, 0xfd, 0x2a,
-  0x97, 0x50, 0x9a, 0x09, 0x22, 0x6e, 0xd4, 0x34, 0xde, 0x52, 0x6f, 0x46,
-  0xde, 0xf7, 0x3d, 0x7d, 0xaa, 0xa8, 0x46, 0x52, 0xe4, 0x41, 0x90, 0x0a,
-  0x18, 0x15, 0x3f, 0xae, 0xa4, 0xfd, 0x4b, 0x05, 0xed, 0xd8, 0x5b, 0x41,
-  0xf3, 0xf0, 0xfc, 0xef, 0x3d, 0x0f, 0xd6, 0xc6, 0x0f, 0xcc, 0x8c, 0x82,
-  0x3b, 0x76, 0xa0, 0x1c, 0x5b, 0x11, 0xa1, 0x08, 0x7f, 0x5f, 0x1e, 0x5f,
-  0x5d, 0x72, 0xc8, 0x1a, 0xd0, 0x0b, 0x9a, 0xea, 0x2c, 0x9d, 0xb3, 0x6d,
-  0x67, 0x41, 0x17, 0x38, 0xd7, 0x80, 0x1f, 0x7b, 0xda, 0x96, 0x92, 0x42,
-  0x02, 0xf0, 0x17, 0x1d, 0xe8, 0x9f, 0xf6, 0x9e, 0xc3, 0x92, 0x96, 0x1b,
-  0xca, 0x07, 0xd1, 0xe8, 0x59, 0x71, 0xfb, 0xe0, 0xa3, 0x18, 0x04, 0xbb,
-  0x4a, 0x2c, 0xbb, 0x2e, 0xb6, 0xb4, 0xef, 0x4a, 0x79, 0x9b, 0x6b, 0x5e,
-  0x6a, 0xf5, 0x09, 0x5b, 0x94, 0x60, 0xd1, 0x86, 0x2d, 0xc7, 0x75, 0x1e,
-  0xcf, 0x25, 0x1f, 0x4c, 0x06, 0x51, 0xf5, 0x8c, 0xe8, 0xd5, 0x29, 0xf1,
-  0xa7, 0x52, 0xa7, 0x3e, 0x7a, 0x8a, 0xea, 0x13, 0x4d, 0xd3, 0xd0, 0x30,
-  0xbb, 0x33, 0x47, 0x9c, 0x86, 0x50, 0x0b, 0x00, 0x34, 0xef, 0x19, 0x5f,
-  0xb3, 0xac, 0x10, 0xf4, 0x26, 0x28, 0x69, 0x17, 0x03, 0x3b, 0xb9, 0xa8,
-  0xa9, 0xf0, 0xfb, 0x72, 0x48, 0xb5, 0x90, 0xba, 0xae, 0x59, 0xe3, 0x70,
-  0x4a, 0xcc, 0x37, 0x33, 0xdf, 0x5a, 0x91, 0xf5, 0x62, 0x45, 0x73, 0x9f,
-  0x35, 0x87, 0xa6, 0xf8, 0x13, 0x41, 0x47, 0xcf, 0xda, 0xc8, 0x78, 0x70,
-  0x75, 0x7e, 0xa9, 0x84, 0xd6, 0x64, 0xc5, 0x72, 0x38, 0xf9, 0x11, 0xef,
-  0x8f, 0xec, 0xb6, 0x58, 0xfa, 0x4d, 0x28, 0xd4, 0x40, 0x0b, 0x64, 0xbc,
-  0xfa, 0x7e, 0x3f, 0xf6, 0x2e, 0x1e, 0x9d, 0xde, 0xd7, 0x71, 0xce, 0x49,
-  0x8c, 0xc8, 0x0a, 0xc0, 0xea, 0xd2, 0xdd, 0x49, 0x22, 0xff, 0x2c, 0x50,
-  0x20, 0xf6, 0xe5, 0xcc, 0x9d, 0x2f, 0x4b, 0x29, 0x38, 0x89, 0x5c, 0x22,
-  0x90, 0x92, 0x66, 0x15, 0xc1, 0xc4, 0xa4, 0x36, 0x24, 0x67, 0xb7, 0xab,
-  0x93, 0xa3, 0x9c, 0xa5, 0x73, 0x5f, 0xee, 0x47, 0x2d, 0xf5, 0xee, 0x5e,
-  0xf3, 0x3e, 0x76, 0xb6, 0x0c, 0xc3, 0x88, 0x2f, 0x7e, 0x0f, 0x26, 0x22,
-  0x45, 0x79, 0xad, 0x6f, 0xf8, 0x88, 0x04, 0x05, 0x1e, 0xb3, 0x06, 0x14,
-  0x04, 0x92, 0x93, 0x17, 0x3a, 0x76, 0xdd, 0x4a, 0x73, 0x09, 0x32, 0x1d,
-  0x1a, 0x77, 0x5b, 0x29, 0x1f, 0x68, 0x5f, 0x9c, 0xb1, 0xcb, 0x02, 0xce,
-  0x0b, 0x3e, 0xb4, 0x5a, 0xbb, 0xa1, 0xbd, 0xac, 0x92, 0x6e, 0x0a, 0xb7,
-  0x63, 0x0d, 0x01, 0x4e, 0x34, 0x5f, 0x99, 0xab, 0xca, 0x41, 0x2b, 0x4f,
-  0x5c, 0xf6, 0x29, 0x38, 0x76, 0xbb, 0x07, 0xcf, 0x27, 0x58, 0x3d, 0xd9,
-  0x6b, 0xa3, 0x0f, 0x08, 0xe5, 0x97, 0xc7, 0x83, 0x2b, 0x19, 0x3d, 0x7e,
-  0x6b, 0x8c, 0x5e, 0xf2, 0x8c, 0x5c, 0x01, 0xb6, 0x62, 0x1d, 0x7d, 0x20,
-  0x26, 0x0c, 0xde, 0xf5, 0xb0, 0x08, 0x57, 0xb8, 0x6a, 0x4f, 0x82, 0xb0,
-  0x25, 0x66, 0xa1, 0x4a, 0x2d, 0x57, 0x56, 0x7e, 0x23, 0xea, 0x68, 0x2f,
-  0x1d, 0xba, 0x8c, 0xed, 0x60, 0x64, 0x79, 0x50, 0xa6, 0xe8, 0xc9, 0x53,
-  0xdf, 0x06, 0x2a, 0xce, 0x5b, 0x13, 0x27, 0x66, 0xc8, 0xc6, 0x87, 0xce,
-  0xf9, 0x7a, 0x8d, 0x12, 0x91, 0x42, 0x1c, 0x35, 0x30, 0xd2, 0x27, 0xcf,
-  0x5c, 0xde, 0xa1, 0x09, 0x4f, 0xc1, 0x60, 0xf0, 0x31, 0x12, 0xe9, 0x8b,
-  0x9b, 0x58, 0xf2, 0x89, 0x6b, 0xa4, 0xf7, 0xe4, 0x63, 0xcf, 0x80, 0x21,
-  0x5d, 0x7b, 0x7f, 0x8c, 0xae, 0x41, 0xe5, 0x82, 0x82, 0x4b, 0x2b, 0x9d,
-  0x2f, 0x19, 0x36, 0x81, 0xf8, 0xc5, 0x14, 0xb0, 0x2c, 0xea, 0x50, 0x69,
-  0x58, 0x8e, 0xeb, 0x91, 0x54, 0x4f, 0xf4, 0x6a, 0x22, 0x4d, 0x38, 0xdc,
-  0x34, 0x49, 0xe6, 0xe1, 0x43, 0xed, 0xa5, 0x40, 0x3a, 0xc0, 0x73, 0x77,
-  0x7b, 0xf4, 0xa3, 0x0b, 0x20, 0xdb, 0xb1, 0x55, 0xbc, 0xf8, 0x93, 0x6f,
-  0x4f, 0x0e, 0xcd, 0xe9, 0xd1, 0xc1, 0x05, 0xae, 0x55, 0x16, 0x60, 0xd3,
-  0x39, 0xed, 0x31, 0x7f, 0x82, 0x5f, 0x03, 0x54, 0xb2, 0xc6, 0xb4, 0x9f,
-  0xfb, 0x97, 0xb5, 0xdc, 0x5c, 0xfd, 0x91, 0xa7, 0x4a, 0x63, 0xa4, 0xdb,
-  0x70, 0x13, 0x8e, 0x53, 0xe3, 0x6c, 0x6b, 0x05, 0xd7, 0xb1, 0xb4, 0x30,
-  0xb1, 0x67, 0x2a, 0x1c, 0x3d, 0x68, 0x4a, 0xee, 0x87, 0x03, 0x59, 0x29,
-  0x4e, 0x34, 0xa7, 0x13, 0x04, 0x80, 0x6d, 0x6a, 0x6b, 0x0e, 0xe6, 0x3b,
-  0x35, 0xef, 0x71, 0x25, 0x87, 0x82, 0x97, 0x56, 0x32, 0x85, 0x16, 0xa8,
-  0xb8, 0x52, 0xbf, 0xe3, 0x6a, 0xf8, 0x16, 0x4f, 0x85, 0x2a, 0x1d, 0x01,
-  0xb9, 0x4b, 0xad, 0x32, 0x3e, 0x74, 0xed, 0xb2, 0xb4, 0x78, 0xcf, 0x5d,
-  0x6d, 0xc0, 0xa0, 0xa9, 0x67, 0xbe, 0x29, 0x94, 0xb5, 0xf4, 0xdc, 0xfe,
-  0xa0, 0xc2, 0x8d, 0x1c, 0xea, 0x91, 0x2b, 0x80, 0xf9, 0x98, 0x3e, 0x51,
-  0xbd, 0x4d, 0x9e, 0x0a, 0x41, 0x5c, 0x65, 0x99, 0xd4, 0x83, 0x71, 0x41,
-  0x5c, 0x7d, 0x41, 0x03, 0x6e, 0xda, 0xca, 0x8b, 0xae, 0xaa, 0x61, 0x8a,
-  0x72, 0x0f, 0x5b, 0x7f, 0x73, 0x55, 0x60, 0xfd, 0xaf, 0xa3, 0x2c, 0x3f,
-  0xfd, 0x54, 0x15, 0xbd, 0xdb, 0x39, 0x11, 0x66, 0x74, 0x75, 0x7c, 0x7a,
-  0x76, 0x7c, 0xe5, 0xb2, 0xe6, 0x6d, 0x3e, 0xc1, 0xf3, 0xcf, 0xd5, 0x1a,
-  0x35, 0xd5, 0x30, 0x1b, 0x45, 0x6a, 0xac, 0x7b, 0x4e, 0x9f, 0xed, 0xb9,
-  0x00, 0xdc, 0x45, 0xa2, 0x45, 0x71, 0xf8, 0x24, 0x26, 0x24, 0x16, 0x4d,
-  0x24, 0x45, 0x90, 0xab, 0x71, 0x7d, 0x19, 0xbd, 0x39, 0x7a, 0x86, 0x30,
-  0xe6, 0xeb, 0x24, 0x5f, 0xe4, 0x0c, 0xfc, 0xa9, 0xb4, 0x92, 0xdd, 0xfa,
-  0xd6, 0xf6, 0x7d, 0x38, 0xaf, 0xa9, 0x32, 0x8e, 0x7b, 0xa8, 0xa8, 0x4b,
-  0x2b, 0xc5, 0xb9, 0xee, 0x5d, 0x2d, 0x62, 0x60, 0x10, 0x81, 0x96, 0xc3,
-  0xcf, 0xf2, 0xc2, 0xe3, 0xf0, 0xc5, 0xcf, 0x9e, 0x78, 0x8e, 0x91, 0xaf,
-  0x16, 0x40, 0x18, 0x92, 0xc2, 0x61, 0x8e, 0x74, 0xfd, 0xa3, 0xc2, 0xa4,
-  0x0e, 0xe5, 0x7c, 0x41, 0x8e, 0x6c, 0xbe, 0x85, 0x80, 0x1c, 0xb1, 0x5c,
-  0xf9, 0xd7, 0x9e, 0x85, 0x6a, 0x5d, 0xa1, 0xe5, 0x84, 0x68, 0x01, 0xc1,
-  0x02, 0x59, 0x34, 0xf0, 0x8f, 0x7e, 0xec, 0x1e, 0x45, 0xb1, 0x93, 0x74,
-  0xae, 0xa0, 0x10, 0xeb, 0x5f, 0x50, 0xc1, 0x53, 0xee, 0x61, 0x2f, 0x0e,
-  0x89, 0x98, 0x11, 0x2c, 0xbc, 0x7f, 0xe3, 0x79, 0x5d, 0x69, 0x65, 0x08,
-  0x40, 0x8f, 0x0f, 0x8c, 0x29, 0xa5, 0x8b, 0x9b, 0xa0, 0x3e, 0xea, 0xc7,
-  0x72, 0x2d, 0x5e, 0x24, 0x88, 0xf2, 0x0f, 0xf6, 0xd2, 0x18, 0x4d, 0x25,
-  0xd7, 0xd6, 0x4e, 0x93, 0xd0, 0xd6, 0x21, 0x9d, 0x10, 0x7d, 0xa5, 0x49,
-  0x9b, 0x78, 0xda, 0x17, 0xfe, 0xfa, 0x78, 0x4f, 0xa9, 0x92, 0xa6, 0x9c,
-  0x5d, 0xcf, 0xd3, 0x1f, 0x41, 0x68, 0xf5, 0xe2, 0x38, 0xfe, 0xe9, 0x7d,
-  0x3d, 0x93, 0x52, 0x5b, 0x8a, 0x39, 0xcf, 0xdb, 0xcb, 0x53, 0xff, 0xfd,
-  0x13, 0xa5, 0x59, 0x71, 0x80, 0x49, 0x29, 0x4d, 0x6a, 0x13, 0x08, 0xc1,
-  0x49, 0x32, 0x4e, 0xfc, 0xae, 0x7e, 0xfc, 0x54, 0xc5, 0x1c, 0x93, 0x46,
-  0xc1, 0xfe, 0xb1, 0x0a, 0x53, 0x64, 0x34, 0x2b, 0x27, 0xf4, 0x4f, 0xeb,
-  0x05, 0xa3, 0xbb, 0x58, 0x5a, 0x6d, 0x3a, 0x57, 0xc5, 0x1a, 0xbf, 0xde,
-  0xa7, 0x73, 0x8d, 0x7e, 0xad, 0xbf, 0xfd, 0xf1, 0x1a, 0xd3, 0x87, 0xfa,
-  0x0e, 0x8e, 0x99, 0x88, 0xfc, 0xe3, 0x9f, 0x58, 0x64, 0x61, 0xde, 0x8d,
-  0x02, 0xd8, 0x27, 0x06, 0x7b, 0x52, 0x98, 0x32, 0x3b, 0x39, 0x50, 0x0e,
-  0x16, 0x96, 0xe8, 0xca, 0x8c, 0x61, 0x62, 0xbd, 0x34, 0xf0, 0x3b, 0xa9,
-  0x13, 0xdf, 0x87, 0x50, 0xd0, 0x6b, 0x76, 0xf7, 0x7a, 0xf9, 0x9b, 0xd8,
-  0x82, 0x8f, 0xb5, 0xf4, 0x0f, 0x3f, 0x57, 0x4a, 0xb0, 0x2b, 0xc8, 0x24,
-  0xc0, 0x75, 0x2f, 0x7c, 0xb2, 0x1b, 0x8a, 0x83, 0x63, 0x58, 0xd9, 0x24,
-  0x31, 0x71, 0xdd, 0xf3, 0x42, 0x04, 0x27, 0xc4, 0x95, 0xaf, 0x89, 0x80,
-  0xf9, 0x11, 0x77, 0x71, 0xf9, 0xa7, 0xf6, 0xab, 0x0c, 0x2c, 0x14, 0x4c,
-  0xa2, 0x93, 0x23, 0xff, 0xdc, 0x13, 0x3f, 0x37, 0x2b, 0xaa, 0xab, 0x76,
-  0xba, 0x2d, 0xbc, 0xe4, 0x23, 0x46, 0x3f, 0x79, 0xaa, 0xb1, 0x86, 0xc8,
-  0x11, 0xbe, 0x91, 0x98, 0xb2, 0xfa, 0x23, 0xb2, 0xf3, 0x87, 0xae, 0xd2,
-  0x98, 0x44, 0x0c, 0x16, 0xfe, 0x46, 0xf5, 0x8f, 0x7e, 0xfc, 0xc8, 0xa3,
-  0x7a, 0xfd, 0x14, 0xee, 0xda, 0xf4, 0xaf, 0x7d, 0xd2, 0x3c, 0xcc, 0x26,
-  0x69, 0x97, 0x2a, 0xbe, 0xd0, 0x81, 0xc2, 0x79, 0x8a, 0xb6, 0x10, 0x5d,
-  0xfb, 0x27, 0xb3, 0xb1, 0xe4, 0x08, 0x34, 0x2c, 0xfe, 0x14, 0x0c, 0xf6,
-  0x53, 0xc7, 0x3c, 0x9d, 0x7d, 0x85, 0x1d, 0x7e, 0x48, 0xcc, 0x0c, 0x71,
-  0x26, 0xd9, 0x1c, 0xc2, 0x1b, 0xcf, 0x0b, 0xe3, 0x1b, 0x90, 0x9d, 0xa6,
-  0x0b, 0x79, 0x39, 0xf7, 0xcc, 0x41, 0x14, 0x2c, 0x4d, 0xf1, 0xb4, 0x78,
-  0x24, 0x1d, 0xdb, 0x97, 0xb4, 0x97, 0x4c, 0x13, 0xde, 0x4a, 0xb5, 0x5b,
-  0xa3, 0xf6, 0xe2, 0x66, 0x29, 0xea, 0xac, 0x9b, 0x4e, 0x4b, 0xdd, 0xe2,
-  0x6f, 0xbf, 0x0d, 0xac, 0xaa, 0x0e, 0x89, 0x96, 0x28, 0xdd, 0x03, 0x16,
-  0xa8, 0xf5, 0x52, 0xb8, 0x3d, 0x96, 0x94, 0x2b, 0xa2, 0xe5, 0xc9, 0x34,
-  0x01, 0x12, 0x8e, 0xe8, 0x09, 0x75, 0xae, 0x6f, 0xd1, 0xb0, 0x88, 0x88,
-  0x10, 0xcc, 0xf0, 0x44, 0x51, 0x93, 0xe6, 0xf0, 0xde, 0xaa, 0xf6, 0x4f,
-  0xf7, 0xc2, 0xc1, 0xdb, 0xab, 0x2f, 0xcf, 0x2f, 0x07, 0xd1, 0x0e, 0xd2,
-  0x0b, 0xaf, 0x2e, 0x4f, 0x3e, 0x7f, 0x4b, 0x6a, 0x94, 0x33, 0xf6, 0x1e,
-  0xc5, 0xa4, 0x60, 0x4d, 0x11, 0xaa, 0x90, 0xcc, 0x87, 0x49, 0x7e, 0x6d,
-  0x08, 0xb2, 0x9c, 0x8a, 0x0f, 0x36, 0x98, 0xe5, 0x02, 0x17, 0xe8, 0x4b,
-  0xa9, 0x99, 0x49, 0x9b, 0x43, 0xa0, 0x52, 0xfa, 0x2e, 0xf3, 0x2a, 0x42,
-  0x5a, 0xcb, 0x8e, 0x74, 0x25, 0xfd, 0xae, 0xbe, 0x3c, 0x38, 0xfb, 0x6a,
-  0x60, 0xb0, 0x4d, 0xdf, 0x7c, 0xf3, 0x4d, 0xe8, 0xd1, 0x78, 0xb1, 0xb3,
-  0xc3, 0xe0, 0x3c, 0x37, 0xf1, 0xc3, 0x43, 0xbf, 0x20, 0x7e, 0x11, 0xd4,
-  0xeb, 0xf5, 0x20, 0x9d, 0xc5, 0x92, 0xae, 0x0c, 0xfa, 0x7a, 0x67, 0xb1,
-  0x1c, 0x02, 0x14, 0x74, 0x67, 0x59, 0x2a, 0x2c, 0x36, 0xbf, 0xbd, 0xb3,
-  0xb1, 0x31, 0x38, 0x3e, 0x8e, 0x0e, 0x4e, 0x07, 0xe7, 0xc1, 0xbb, 0x5b,
-  0x7b, 0xdb, 0x74, 0x99, 0x5e, 0x27, 0xe5, 0x16, 0x80, 0xdb, 0x4f, 0x0f,
-  0xae, 0xa0, 0x38, 0x7c, 0x7d, 0x7c, 0x39, 0x38, 0x39, 0x3f, 0xc3, 0x16,
-  0x21, 0x5f, 0x39, 0x9e, 0xa2, 0xae, 0x24, 0xee, 0x6f, 0x24, 0x7a, 0xdd,
-  0x1b, 0x20, 0x35, 0xb2, 0xf1, 0x37, 0x8b, 0x48, 0x44, 0x20, 0x71, 0x4b,
-  0xdd, 0x23, 0x99, 0x3c, 0xb6, 0x7a, 0x8f, 0x25, 0x64, 0x77, 0xf3, 0xbd,
-  0x6d, 0x44, 0xde, 0x82, 0x20, 0x98, 0xbd, 0xc9, 0x50, 0x42, 0x46, 0xba,
-  0x02, 0xbb, 0xcc, 0x51, 0xcf, 0x41, 0x3a, 0x6f, 0xeb, 0xc4, 0x07, 0x27,
-  0x6f, 0x2e, 0x48, 0x84, 0x7e, 0x3b, 0x38, 0xf8, 0xe2, 0x18, 0x8f, 0x7e,
-  0x91, 0x94, 0x7e, 0x3b, 0x04, 0x38, 0x1b, 0x9d, 0x9c, 0x25, 0x65, 0x31,
-  0x8a, 0x17, 0xc9, 0x26, 0x86, 0x34, 0xec, 0x09, 0xd3, 0x09, 0xda, 0x16,
-  0x41, 0xca, 0xc3, 0xa7, 0xce, 0xf5, 0x79, 0xc6, 0x36, 0x0d, 0xdb, 0xbd,
-  0x3c, 0x3e, 0x38, 0x7a, 0x73, 0x6c, 0x21, 0x45, 0x82, 0x62, 0x46, 0x8d,
-  0xde, 0x64, 0xb3, 0x24, 0xb0, 0x33, 0x82, 0xf1, 0x63, 0xf1, 0xe9, 0x1b,
-  0x14, 0xc6, 0x6e, 0xef, 0xce, 0x6f, 0x14, 0x3f, 0xdb, 0x9f, 0xa4, 0x3b,
-  0xd2, 0xba, 0xf5, 0x17, 0xbb, 0x25, 0xb1, 0xc8, 0x1c, 0x15, 0x83, 0x44,
-  0x35, 0x64, 0x9d, 0xf2, 0xd3, 0xdd, 0xdd, 0xdd, 0x47, 0xe6, 0xc1, 0xf6,
-  0x3c, 0xb5, 0xcf, 0xd0, 0x54, 0x5e, 0xe0, 0xf1, 0x1d, 0xdf, 0xbe, 0x51,
-  0x66, 0x68, 0x23, 0xc5, 0x9f, 0x52, 0x6f, 0x19, 0xb8, 0xb1, 0xed, 0x83,
-  0x1e, 0x65, 0x99, 0xdb, 0x83, 0xca, 0xf2, 0x70, 0xf5, 0xdc, 0xb4, 0x0c,
-  0x80, 0x7d, 0x6c, 0xe8, 0xe3, 0x94, 0x4f, 0x79, 0x9c, 0xaf, 0xea, 0x4d,
-  0xe2, 0x1b, 0x6a, 0x13, 0x3f, 0xfa, 0x59, 0x7e, 0xbd, 0x33, 0x7b, 0xc1,
-  0xf1, 0x22, 0xf4, 0xd0, 0x6b, 0xa4, 0x66, 0x73, 0xa5, 0x4b, 0x0b, 0xbd,
-  0x29, 0xb0, 0xb4, 0x88, 0xf4, 0xfb, 0x80, 0x71, 0xfd, 0x84, 0x75, 0x90,
-  0xd2, 0xaf, 0x13, 0x9b, 0xb9, 0x05, 0x23, 0xb4, 0x74, 0x52, 0x60, 0xcb,
-  0x60, 0xbc, 0xe9, 0x13, 0x0b, 0xa1, 0x5e, 0xe8, 0x73, 0x21, 0x12, 0xfa,
-  0x35, 0x27, 0xa2, 0xe9, 0x97, 0x0f, 0xcc, 0x43, 0x81, 0xca, 0xa9, 0x46,
-  0x59, 0x66, 0x5b, 0x61, 0x15, 0x60, 0xee, 0xe1, 0x9e, 0x4b, 0x11, 0xb9,
-  0x68, 0x2c, 0x8e, 0x98, 0x46, 0xc3, 0xf5, 0x3e, 0xa5, 0xb4, 0x7a, 0x51,
-  0x38, 0x7a, 0xf9, 0x80, 0xce, 0x83, 0x49, 0xc9, 0xea, 0xcf, 0x95, 0x3d,
-  0x07, 0xd4, 0x83, 0xe2, 0xc3, 0x8d, 0xbe, 0x18, 0x15, 0x24, 0xe7, 0xa0,
-  0xaf, 0x42, 0xba, 0x63, 0xe8, 0xfd, 0x7e, 0xf2, 0x10, 0x23, 0x1f, 0x87,
-  0xfb, 0xa2, 0x3d, 0xd9, 0xe1, 0x58, 0x94, 0x0f, 0xee, 0xe9, 0xf0, 0xc2,
-  0x21, 0xf9, 0xd3, 0x0a, 0xdc, 0x61, 0x09, 0x6e, 0x13, 0x9e, 0x7d, 0x28,
-  0x36, 0x3e, 0x32, 0x98, 0x17, 0xb4, 0x0a, 0x78, 0xe3, 0xbf, 0xee, 0xf4,
-  0x8b, 0xe2, 0x66, 0x27, 0x1d, 0xbf, 0x1b, 0x17, 0x31, 0x7d, 0x46, 0x7c,
-  0xad, 0xf1, 0x71, 0x9f, 0x3e, 0x8c, 0xfe, 0xe2, 0x9a, 0xfa, 0xbf, 0x8a,
-  0x51, 0xfb, 0x34, 0xfe, 0xeb, 0x0e, 0xa0, 0x6a, 0x18, 0xe6, 0x92, 0x57,
-  0x6d, 0xe3, 0xe8, 0xfc, 0x9b, 0xb3, 0xd3, 0xf3, 0x83, 0xa3, 0xe8, 0xea,
-  0x9c, 0xd4, 0x3a, 0x28, 0xe6, 0x2d, 0xe7, 0x90, 0x41, 0x44, 0xca, 0x4c,
-  0xae, 0x9d, 0xd0, 0x98, 0xd7, 0x18, 0xbd, 0x14, 0xe5, 0xe4, 0xec, 0xf9,
-  0x9b, 0x72, 0xf6, 0x7e, 0xe6, 0xf2, 0x21, 0x9d, 0x74, 0x5d, 0xb5, 0xc2,
-  0x66, 0x7d, 0x42, 0x09, 0x39, 0xd8, 0xa8, 0x57, 0x3f, 0x74, 0x31, 0x6b,
-  0x5b, 0xe2, 0xa0, 0xf5, 0x51, 0x7d, 0x82, 0x01, 0x5f, 0x54, 0x6b, 0x09,
-  0x3b, 0xf0, 0x69, 0x75, 0xe4, 0x49, 0xd5, 0x3a, 0xba, 0xbf, 0xb7, 0x1b,
-  0x13, 0x3c, 0x5f, 0x3b, 0x25, 0xd4, 0x50, 0x7d, 0xe0, 0x59, 0x57, 0x0f,
-  0xb1, 0x00, 0xe3, 0xf8, 0xd9, 0xf9, 0xba, 0xea, 0xe2, 0x0e, 0xd5, 0x21,
-  0xb3, 0x57, 0xb7, 0xa5, 0x3b, 0xf4, 0x63, 0x67, 0xdb, 0x77, 0x81, 0x6f,
-  0xc2, 0x2b, 0x61, 0xc7, 0xd9, 0x5a, 0x64, 0x00, 0x6f, 0x07, 0x27, 0x67,
-  0x5f, 0xb0, 0x9b, 0xe5, 0x9b, 0xf3, 0xcb, 0xa3, 0x01, 0x35, 0x8b, 0xbb,
-  0x72, 0x83, 0x55, 0x6d, 0x46, 0x5e, 0x92, 0x51, 0x09, 0x81, 0xa2, 0xeb,
-  0x3f, 0xb0, 0x98, 0x3d, 0xf6, 0x49, 0x09, 0x3c, 0xcc, 0x40, 0x60, 0x02,
-  0x74, 0x47, 0x3b, 0xfb, 0x61, 0x5a, 0x95, 0xd7, 0xff, 0x3c, 0x8b, 0x81,
-  0x42, 0x98, 0xf4, 0x05, 0xa4, 0x87, 0x7d, 0xe9, 0x3b, 0x80, 0x0a, 0xd8,
-  0x81, 0xdc, 0xb6, 0x53, 0x66, 0x7c, 0x90, 0xb9, 0x95, 0x2c, 0x77, 0xb8,
-  0x8d, 0x95, 0x15, 0xc1, 0x09, 0x98, 0x4c, 0xe3, 0x6b, 0xee, 0xb0, 0x79,
-  0x38, 0x82, 0xce, 0xb4, 0xfb, 0x0f, 0xed, 0x12, 0xfc, 0x87, 0xdb, 0x3b,
-  0x29, 0x5d, 0x22, 0x2b, 0xe3, 0x91, 0xa8, 0x2d, 0x58, 0xe4, 0x97, 0x95,
-  0x96, 0x7d, 0x67, 0x68, 0xf5, 0x3a, 0xc0, 0xa4, 0x16, 0x32, 0xd9, 0x10,
-  0xc5, 0xb9, 0x17, 0xe4, 0xbe, 0x88, 0x68, 0x8b, 0x96, 0x02, 0x4d, 0xb1,
-  0xe0, 0x88, 0x6d, 0xee, 0xd3, 0x67, 0xf3, 0xc8, 0x92, 0x63, 0x30, 0x34,
-  0x76, 0x08, 0x09, 0x9a, 0xe6, 0xa1, 0x02, 0x55, 0x07, 0xe8, 0x9e, 0xe9,
-  0x28, 0x2d, 0x3b, 0xcc, 0x2b, 0x59, 0xaf, 0x36, 0x04, 0x17, 0xef, 0xff,
-  0x29, 0x4a, 0x1a, 0x4a, 0x4c, 0xbc, 0x5d, 0x4b, 0x75, 0x69, 0xba, 0x5d,
-  0x36, 0x9b, 0x49, 0xc2, 0x59, 0x07, 0x09, 0x07, 0xbe, 0x95, 0x54, 0xd3,
-  0x65, 0x1c, 0x48, 0x3b, 0xb8, 0x20, 0x7a, 0x17, 0x84, 0x22, 0x89, 0x17,
-  0x37, 0x86, 0xeb, 0xcd, 0x1b, 0x30, 0x4b, 0xf2, 0xe8, 0x0f, 0x43, 0xb0,
-  0x79, 0x41, 0x66, 0x6a, 0x42, 0xb0, 0xa6, 0x5a, 0x41, 0x92, 0x88, 0x85,
-  0x83, 0x01, 0x97, 0x85, 0x4b, 0xe4, 0x61, 0x00, 0xd4, 0xd8, 0xd5, 0x19,
-  0x68, 0x23, 0x25, 0x3d, 0x55, 0xeb, 0x69, 0xe9, 0xfd, 0x64, 0xd4, 0x1c,
-  0x92, 0x89, 0x95, 0xd3, 0x95, 0xec, 0x74, 0xa0, 0xff, 0xb5, 0x12, 0x94,
-  0x0e, 0xe2, 0x83, 0x3a, 0xe6, 0xb9, 0x32, 0xfa, 0x5c, 0x21, 0xa6, 0x2b,
-  0x1f, 0xf7, 0x20, 0xfe, 0x33, 0x8e, 0x66, 0x6e, 0x01, 0x40, 0xab, 0x20,
-  0x5c, 0xf1, 0x66, 0x4a, 0x18, 0xe5, 0x8b, 0xe8, 0xf3, 0xb8, 0x48, 0x47,
-  0xdd, 0xe8, 0x28, 0x25, 0x69, 0xb0, 0xec, 0x7a, 0x98, 0x2a, 0x07, 0xee,
-  0xd5, 0x8f, 0xbe, 0xb1, 0x42, 0x39, 0xc4, 0xd8, 0xa5, 0xbc, 0x3c, 0xec,
-  0x3f, 0x2e, 0xb7, 0x66, 0x43, 0x0c, 0x6c, 0x6a, 0x22, 0x0b, 0xb3, 0x58,
-  0xb8, 0x6d, 0x8f, 0xbb, 0xc3, 0x9b, 0x19, 0x93, 0x5a, 0x5a, 0xc1, 0xa8,
-  0x95, 0x7b, 0xbb, 0x80, 0x91, 0x07, 0x97, 0x2c, 0xaf, 0xef, 0x5c, 0xc1,
-  0xbf, 0x95, 0xc1, 0xf2, 0xdf, 0x0e, 0x05, 0x44, 0x6f, 0x3c, 0x51, 0xc2,
-  0x0b, 0x8d, 0x85, 0x30, 0x37, 0x1d, 0x73, 0x54, 0x23, 0xb9, 0x0d, 0x0e,
-  0xde, 0xa5, 0x75, 0xc2, 0x8a, 0xe8, 0x99, 0x38, 0xbf, 0x3a, 0xfe, 0x4d,
-  0x34, 0x48, 0x81, 0x22, 0xed, 0x28, 0x07, 0x84, 0xba, 0x59, 0x3a, 0xe7,
-  0x41, 0x63, 0x4f, 0x5d, 0x3e, 0xdd, 0x66, 0xa9, 0xa2, 0x86, 0xc4, 0x9b,
-  0x4b, 0x49, 0x81, 0x00, 0x60, 0x87, 0x69, 0xf6, 0x2e, 0x8d, 0x25, 0x46,
-  0x0c, 0xe1, 0x0f, 0x98, 0xfb, 0x3b, 0x60, 0xf2, 0xbc, 0xf3, 0xe8, 0xac,
-  0x4b, 0x7d, 0x91, 0xe1, 0x70, 0xd0, 0x8e, 0xea, 0x76, 0xac, 0x0e, 0x8f,
-  0xd2, 0x9c, 0xae, 0x11, 0x9c, 0xb5, 0x91, 0x40, 0x8d, 0x71, 0x94, 0x12,
-  0x8f, 0x1d, 0xca, 0x6a, 0x3c, 0x24, 0xba, 0xe2, 0xe5, 0xc2, 0xc1, 0x63,
-  0x17, 0x9a, 0xaf, 0x5d, 0x66, 0x57, 0x7e, 0xc8, 0x0e, 0x38, 0x6f, 0x8d,
-  0x53, 0x81, 0x18, 0xb5, 0x5c, 0xf1, 0x98, 0x36, 0x38, 0x24, 0x88, 0x5a,
-  0xe5, 0xfb, 0x70, 0xee, 0xb8, 0x73, 0x20, 0x3d, 0x20, 0x52, 0x03, 0x74,
-  0x3a, 0x8e, 0x66, 0x2b, 0xcd, 0xcb, 0x54, 0x5e, 0x82, 0x4c, 0x08, 0x16,
-  0x88, 0x3f, 0xfd, 0xb4, 0x71, 0x77, 0x3c, 0xb8, 0xa7, 0x5f, 0xd0, 0xd7,
-  0x81, 0xe0, 0x3d, 0x85, 0xab, 0xc8, 0xca, 0x23, 0x78, 0xe9, 0xbb, 0x21,
-  0xd5, 0x84, 0x79, 0x57, 0xd2, 0xa1, 0x33, 0xf7, 0xb4, 0xec, 0x8b, 0x2b,
-  0xff, 0xb0, 0x21, 0x62, 0x9d, 0xe2, 0x30, 0x17, 0xe2, 0x74, 0x5c, 0x23,
-  0xe7, 0xd8, 0xc9, 0xab, 0x0f, 0x36, 0xb8, 0x64, 0xe9, 0xa2, 0xef, 0xe3,
-  0x5e, 0x86, 0xcc, 0x30, 0xc8, 0xb4, 0x61, 0x44, 0xf5, 0xeb, 0x60, 0x1c,
-  0x7a, 0x53, 0x0d, 0xf2, 0xd9, 0xa1, 0x0d, 0x3b, 0xae, 0xd7, 0x7b, 0xbb,
-  0x7e, 0x38, 0x6f, 0x7f, 0xce, 0x70, 0x46, 0x4d, 0xbe, 0xa8, 0xf5, 0xdd,
-  0xb8, 0x1e, 0xb7, 0x2f, 0x39, 0x26, 0x05, 0x22, 0x91, 0x49, 0x62, 0x55,
-  0xe3, 0x04, 0x79, 0x5c, 0x4a, 0x99, 0x81, 0xb4, 0x90, 0x62, 0xc0, 0x2d,
-  0x71, 0xa8, 0x52, 0x6b, 0xea, 0xea, 0x61, 0xc0, 0x38, 0x64, 0x3b, 0x98,
-  0xfd, 0x90, 0xce, 0x95, 0xb3, 0x6b, 0x58, 0xd3, 0x3e, 0x35, 0xe5, 0x88,
-  0x1a, 0xbd, 0x3c, 0x38, 0xfb, 0xe2, 0x98, 0xe9, 0x15, 0x6c, 0xc3, 0xe7,
-  0xaa, 0x21, 0x83, 0xa6, 0x97, 0x4b, 0xd9, 0xd2, 0x7b, 0x31, 0x26, 0xd0,
-  0x1b, 0xe3, 0xe5, 0x08, 0xde, 0xb1, 0xb7, 0x0e, 0x9e, 0x8a, 0x01, 0xb7,
-  0xa6, 0x5c, 0xef, 0x14, 0x2c, 0x43, 0xbd, 0x50, 0x1b, 0x91, 0x09, 0xf0,
-  0x4c, 0xf1, 0x5c, 0xba, 0x5c, 0x8d, 0x14, 0xc5, 0x72, 0xb8, 0x88, 0x35,
-  0x8d, 0x23, 0x0e, 0xf3, 0x02, 0xac, 0xa8, 0x7a, 0x65, 0x0a, 0xe0, 0x7d,
-  0x5a, 0x02, 0xdb, 0x6e, 0xfe, 0x9c, 0x6f, 0xfe, 0x7e, 0xa8, 0x5a, 0x09,
-  0xfa, 0xc4, 0xde, 0xee, 0xae, 0x87, 0x33, 0xf0, 0xf9, 0x0d, 0x8d, 0x5d,
-  0xcc, 0xa3, 0xdd, 0xde, 0xf3, 0xe7, 0xeb, 0xb6, 0xcb, 0x35, 0xca, 0x51,
-  0xea, 0xcf, 0x3e, 0xb8, 0xcd, 0x1e, 0x1e, 0x5d, 0xd7, 0x66, 0xcb, 0xdd,
-  0xa8, 0x75, 0xe0, 0x75, 0x85, 0xcd, 0xd5, 0xac, 0x72, 0xa0, 0x58, 0x07,
-  0xd8, 0x31, 0x37, 0x77, 0x17, 0x24, 0x96, 0x72, 0x23, 0x72, 0x37, 0x19,
-  0xe3, 0x73, 0x98, 0xc8, 0xb8, 0x80, 0x13, 0x30, 0x75, 0x2e, 0x87, 0x0f,
-  0x5a, 0x98, 0xe0, 0x9a, 0x5f, 0xb3, 0x44, 0x93, 0xe6, 0x6c, 0x54, 0xc9,
-  0x8f, 0x48, 0x7a, 0xbc, 0x80, 0x4a, 0x40, 0x12, 0xa4, 0x97, 0x1b, 0xdf,
-  0x6a, 0x11, 0x1a, 0x60, 0xed, 0xc2, 0xf0, 0x2b, 0x98, 0x83, 0xe9, 0x5c,
-  0xdc, 0xfb, 0x41, 0x59, 0x35, 0xe2, 0x5e, 0x6d, 0x1a, 0x74, 0xef, 0x2a,
-  0xea, 0x05, 0x2c, 0x48, 0x01, 0x0e, 0xc0, 0x7f, 0x66, 0x2b, 0xbb, 0x53,
-  0xb5, 0x0f, 0x6e, 0xdf, 0x54, 0xff, 0x4a, 0xbd, 0xb6, 0xae, 0x06, 0x5b,
-  0x31, 0xc5, 0x34, 0x58, 0x50, 0x4b, 0x97, 0xd2, 0x0d, 0xb3, 0xb4, 0x1a,
-  0xc3, 0xf9, 0xb0, 0xa1, 0xc4, 0x2d, 0x65, 0xa7, 0x54, 0x5e, 0xc7, 0x24,
-  0xbb, 0x26, 0x11, 0xd6, 0x95, 0x13, 0xc5, 0x7d, 0xc2, 0x83, 0x7c, 0x5e,
-  0xb2, 0x17, 0x1b, 0xd1, 0x3f, 0x3b, 0xb8, 0x47, 0x86, 0x85, 0xd3, 0x68,
-  0xf5, 0xf2, 0x6a, 0xc3, 0x0c, 0x6e, 0x12, 0xb4, 0xda, 0x5c, 0x22, 0x6e,
-  0x49, 0x06, 0x11, 0xb7, 0x77, 0x2c, 0x2d, 0xd9, 0xca, 0xb4, 0xd0, 0x3b,
-  0xf6, 0x5c, 0x11, 0x30, 0x5c, 0x04, 0xaa, 0x65, 0x6a, 0x43, 0xa6, 0x66,
-  0x46, 0xa1, 0x95, 0x6a, 0x2d, 0x30, 0x76, 0x23, 0xd2, 0x10, 0x67, 0x86,
-  0xc7, 0x00, 0x11, 0x31, 0x54, 0x1c, 0xb3, 0xb5, 0x5b, 0xf6, 0xdb, 0x4e,
-  0x34, 0xff, 0x9b, 0xe1, 0xc8, 0x4f, 0x38, 0x48, 0x1d, 0x46, 0x5b, 0x9f,
-  0x50, 0x9f, 0x2f, 0xb5, 0xb4, 0x3b, 0x67, 0xa7, 0xd3, 0xe0, 0xe3, 0xe2,
-  0x86, 0x5d, 0x79, 0xae, 0x92, 0x49, 0xd3, 0xaa, 0x10, 0x26, 0x85, 0x13,
-  0x93, 0x17, 0x0e, 0xcf, 0x0c, 0xb5, 0xb2, 0x14, 0xd5, 0x15, 0x08, 0x44,
-  0xe1, 0x0f, 0x3d, 0x06, 0xe0, 0x16, 0xeb, 0xcf, 0x41, 0xa3, 0x62, 0x51,
-  0x8d, 0xfa, 0xbc, 0xb6, 0xc0, 0x51, 0x60, 0xdc, 0x96, 0xdc, 0xc2, 0x0c,
-  0x29, 0xc8, 0x65, 0x5e, 0x38, 0xfb, 0xae, 0xb6, 0x84, 0x2c, 0x86, 0x71,
-  0xf5, 0x2c, 0xc9, 0xc6, 0x33, 0x0e, 0xab, 0x09, 0x4a, 0xac, 0x03, 0x28,
-  0x18, 0x28, 0x84, 0x5a, 0x89, 0xe4, 0x02, 0xc2, 0xad, 0xc4, 0x16, 0xb1,
-  0x79, 0x13, 0xb8, 0xa2, 0x99, 0xf4, 0xc9, 0x33, 0x94, 0x01, 0x4a, 0x0c,
-  0x3a, 0xd7, 0xe6, 0x3a, 0x1f, 0x5c, 0x41, 0x3e, 0x64, 0x79, 0xd6, 0x44,
-  0x98, 0xaf, 0x8f, 0x2f, 0x3f, 0x3f, 0x1f, 0x1c, 0x47, 0x3b, 0xd1, 0xd1,
-  0xf1, 0xe7, 0x6f, 0xc1, 0x36, 0xb0, 0x63, 0xce, 0x1d, 0x53, 0x28, 0x54,
-  0x22, 0xe7, 0x19, 0x38, 0xf1, 0x4e, 0xd2, 0xa5, 0xba, 0x46, 0x19, 0x1a,
-  0x45, 0xa2, 0x02, 0xe0, 0x34, 0x11, 0x5d, 0x2c, 0xe5, 0xf8, 0x1d, 0x0f,
-  0x0a, 0x00, 0xb1, 0x6f, 0x0e, 0x88, 0xc0, 0xd2, 0xd0, 0xb9, 0x0d, 0x37,
-  0xaf, 0x78, 0xe1, 0xc5, 0xba, 0x3b, 0x51, 0x21, 0xf5, 0x68, 0x78, 0xec,
-  0x7c, 0x43, 0xc9, 0xef, 0x07, 0x05, 0xdf, 0x14, 0x82, 0x72, 0x9a, 0xc9,
-  0xc5, 0x85, 0x0c, 0x03, 0x2d, 0x82, 0x8c, 0x74, 0x37, 0x2e, 0xa2, 0xa3,
-  0xe8, 0x5e, 0x8a, 0x54, 0x5f, 0x08, 0xc1, 0x11, 0xc7, 0x91, 0x38, 0xf0,
-  0xa9, 0x72, 0x64, 0x66, 0x48, 0x45, 0x22, 0xf9, 0x8c, 0x72, 0x71, 0xaa,
-  0x0d, 0x54, 0x3c, 0xe3, 0x0a, 0x59, 0xb5, 0x85, 0x23, 0x81, 0x9c, 0x62,
-  0x11, 0x74, 0xa5, 0xd0, 0xac, 0x40, 0xb9, 0xd3, 0xab, 0x23, 0x54, 0xf4,
-  0xe4, 0x95, 0xdf, 0xee, 0xd7, 0x49, 0xe7, 0x6e, 0x3d, 0x63, 0xb8, 0x92,
-  0x99, 0x22, 0xf1, 0x4c, 0xee, 0xe2, 0x30, 0xfb, 0x3c, 0x4c, 0x9a, 0x40,
-  0x00, 0x80, 0xc3, 0xa7, 0x91, 0xf3, 0x84, 0x50, 0x9c, 0x40, 0x78, 0x5b,
-  0x0f, 0xfd, 0x6e, 0x6a, 0xae, 0x86, 0x0d, 0xd4, 0x13, 0x26, 0xb1, 0x14,
-  0xd9, 0x35, 0x6f, 0x29, 0xeb, 0xee, 0x51, 0xbd, 0x8c, 0x97, 0x9e, 0x41,
-  0x69, 0x5d, 0x50, 0xdf, 0xcb, 0x87, 0x32, 0xb4, 0x70, 0x10, 0x97, 0xdc,
-  0x38, 0x3a, 0xbe, 0x3a, 0x38, 0x39, 0x3d, 0x3e, 0x8a, 0x4e, 0xce, 0x5e,
-  0x9f, 0x5f, 0xbe, 0x39, 0xb8, 0x52, 0x13, 0xfc, 0x91, 0xd3, 0xaf, 0x1c,
-  0x3a, 0xb9, 0xe1, 0xf6, 0x07, 0xba, 0x17, 0xd3, 0x30, 0x6d, 0xe3, 0xb5,
-  0x82, 0x72, 0xc8, 0x3a, 0x24, 0x95, 0x45, 0xd8, 0x88, 0xd4, 0x74, 0xef,
-  0xf1, 0xc6, 0x71, 0x37, 0xef, 0x38, 0x73, 0x6b, 0xdf, 0xd6, 0xd3, 0xb4,
-  0x23, 0x2e, 0x3c, 0xfc, 0x68, 0x53, 0xae, 0x06, 0x87, 0xdc, 0x53, 0x0c,
-  0x41, 0xcb, 0xc1, 0xf9, 0x4c, 0x94, 0xbd, 0x13, 0xe4, 0xbd, 0x71, 0xe2,
-  0xbe, 0x56, 0xae, 0x3c, 0x29, 0x5d, 0x71, 0x1e, 0xd0, 0x0b, 0xda, 0x71,
-  0x38, 0x9f, 0x4c, 0x82, 0x5c, 0x1c, 0x2f, 0x68, 0xd3, 0xa5, 0x49, 0x18,
-  0xa0, 0xb8, 0xc4, 0xf6, 0xf0, 0x27, 0xe1, 0x06, 0x23, 0x2d, 0x7c, 0x03,
-  0xde, 0xce, 0x52, 0x3d, 0x47, 0x0f, 0x65, 0x32, 0x77, 0xa5, 0x61, 0x5f,
-  0x6b, 0x23, 0x9e, 0x8b, 0x9a, 0x1d, 0x4d, 0xb1, 0xa4, 0xc2, 0xa6, 0xb6,
-  0x9c, 0x89, 0x96, 0xa4, 0x96, 0xde, 0x09, 0x51, 0x2c, 0xe6, 0x83, 0xb5,
-  0x00, 0x38, 0x20, 0x7e, 0xce, 0x7d, 0xda, 0xaf, 0x3a, 0x84, 0xbd, 0xb0,
-  0x1d, 0x94, 0x38, 0xd0, 0xe3, 0xe6, 0x0f, 0x6e, 0x61, 0xa4, 0x76, 0x44,
-  0x0f, 0xa1, 0x28, 0x54, 0x4f, 0xbb, 0xd7, 0x68, 0x0c, 0xd6, 0xe3, 0x6c,
-  0x0b, 0x45, 0x70, 0x62, 0x81, 0x60, 0x48, 0x8c, 0x8a, 0x85, 0x29, 0xac,
-  0x81, 0xcc, 0x83, 0x09, 0xbc, 0x34, 0xa3, 0x1d, 0x34, 0x00, 0x6f, 0x67,
-  0x73, 0xf5, 0x18, 0x1a, 0x45, 0x1f, 0x5d, 0x5d, 0x90, 0x81, 0x7b, 0x96,
-  0x57, 0x32, 0x78, 0x21, 0xf6, 0x5e, 0x29, 0x5e, 0xff, 0x2d, 0xc3, 0x26,
-  0x05, 0xcd, 0x6a, 0x83, 0x6a, 0x5a, 0x6d, 0x9a, 0x09, 0x2b, 0x93, 0x0a,
-  0x5f, 0xac, 0xfa, 0x71, 0x42, 0x56, 0x6f, 0x5d, 0xf3, 0xe8, 0xc7, 0x6d,
-  0x23, 0x50, 0x36, 0xce, 0xe5, 0xba, 0x88, 0xaa, 0x80, 0xbe, 0x1a, 0xb3,
-  0x3f, 0x03, 0xd9, 0xdc, 0x1b, 0x9a, 0xb0, 0xad, 0xac, 0x92, 0x4d, 0x57,
-  0x61, 0x8e, 0xde, 0x08, 0xc5, 0x24, 0x50, 0x24, 0x43, 0xcb, 0xc8, 0x04,
-  0x21, 0xac, 0xd1, 0x1b, 0xb6, 0xd5, 0x6b, 0x79, 0x55, 0x70, 0xbd, 0xf9,
-  0x86, 0x01, 0x52, 0xd9, 0x4b, 0x23, 0x15, 0x40, 0x99, 0xfd, 0x4b, 0xae,
-  0x26, 0x73, 0x79, 0x38, 0x7b, 0x50, 0xcb, 0x95, 0x6d, 0x08, 0xd0, 0x85,
-  0xe5, 0xd2, 0x60, 0x12, 0xe0, 0xb9, 0x3a, 0xd4, 0x17, 0xbe, 0x7d, 0x7c,
-  0x8d, 0xc0, 0x9e, 0xa4, 0xb5, 0xc7, 0x48, 0x76, 0xb1, 0x43, 0x21, 0x31,
-  0x34, 0xae, 0x15, 0xbe, 0xec, 0x90, 0x43, 0x9a, 0x4f, 0x39, 0x10, 0x42,
-  0x83, 0x73, 0x2e, 0xb2, 0x42, 0xce, 0x1b, 0x4b, 0xd9, 0x1d, 0x0f, 0xe3,
-  0xdc, 0x59, 0xdc, 0x50, 0x1f, 0x9d, 0xe8, 0x1a, 0x7a, 0xca, 0x90, 0x86,
-  0xde, 0xe0, 0xa0, 0x63, 0x79, 0xfc, 0xd5, 0x65, 0x3c, 0x89, 0x93, 0xe9,
-  0x6f, 0xf7, 0x77, 0x07, 0xf1, 0xf5, 0x72, 0x1a, 0xff, 0x8e, 0x5f, 0x7c,
-  0xf5, 0xe4, 0xc9, 0xfe, 0xee, 0x27, 0x9f, 0xee, 0x76, 0x02, 0x43, 0x7a,
-  0xcd, 0x0b, 0xc7, 0x4e, 0x15, 0x2e, 0xc0, 0x08, 0xc6, 0xcb, 0xfd, 0xf4,
-  0x47, 0xd7, 0x29, 0xba, 0xf9, 0x12, 0xd2, 0x8b, 0xae, 0x41, 0xcc, 0x71,
-  0xe4, 0xc2, 0x27, 0xb5, 0xcc, 0x03, 0x5d, 0xb9, 0x44, 0xd7, 0x1f, 0xed,
-  0xbd, 0x10, 0x56, 0x76, 0xcd, 0x36, 0x95, 0x58, 0x28, 0x36, 0x7a, 0x99,
-  0xce, 0xe9, 0x0a, 0xfa, 0x2c, 0x2a, 0xe3, 0x6b, 0x47, 0xab, 0xdc, 0x82,
-  0xab, 0xcc, 0x68, 0x96, 0xc8, 0x09, 0x88, 0x3c, 0x45, 0xe5, 0x5b, 0x76,
-  0x14, 0x6f, 0x16, 0x2c, 0xf9, 0x2c, 0x92, 0x7c, 0x2a, 0xd9, 0x66, 0xf1,
-  0xcc, 0x62, 0xbb, 0xf0, 0x3e, 0x5c, 0x95, 0xfd, 0xc5, 0xd4, 0x55, 0xa2,
-  0x64, 0xed, 0x2b, 0xf5, 0x04, 0x37, 0x5d, 0x14, 0xbe, 0xec, 0x81, 0xdc,
-  0x37, 0x02, 0xd9, 0x84, 0x96, 0xa9, 0xdd, 0x8e, 0x80, 0x39, 0x77, 0x78,
-  0x56, 0x5d, 0x87, 0x9f, 0xde, 0x1b, 0xdb, 0x4c, 0xfb, 0xfc, 0x3b, 0x17,
-  0xa1, 0xd1, 0x22, 0x79, 0x9d, 0x85, 0xa4, 0x2a, 0x38, 0xbc, 0x6e, 0x4d,
-  0x35, 0xac, 0xcc, 0x2b, 0xf6, 0x0e, 0xf7, 0xe8, 0xa5, 0x29, 0xb8, 0x7b,
-  0x9f, 0xbd, 0x62, 0x82, 0xd8, 0xfb, 0xec, 0x77, 0xee, 0xb3, 0x7d, 0xfd,
-  0x6c, 0xff, 0xb3, 0xdf, 0xf5, 0xfb, 0x3c, 0x3e, 0x50, 0xc8, 0xa6, 0x7d,
-  0xbd, 0xa9, 0xb9, 0x50, 0xb1, 0x1e, 0x61, 0xf9, 0xcb, 0x61, 0x73, 0xc8,
-  0x5e, 0x77, 0xac, 0xe7, 0x70, 0x95, 0xbb, 0x6a, 0xfb, 0x74, 0x7c, 0x2b,
-  0x35, 0x28, 0x48, 0x46, 0x53, 0x2b, 0xda, 0x16, 0xdd, 0x99, 0xb7, 0xb8,
-  0x9d, 0xc2, 0x41, 0x1a, 0xc4, 0xd1, 0xef, 0x41, 0xa9, 0xbf, 0xdf, 0x60,
-  0xf4, 0x19, 0x38, 0xbc, 0x68, 0x3b, 0xb8, 0x1a, 0x51, 0x64, 0x64, 0x2b,
-  0x25, 0x54, 0x05, 0x55, 0x09, 0x2d, 0x23, 0x8c, 0x0b, 0x97, 0x60, 0x80,
-  0x56, 0xfd, 0x07, 0x05, 0x06, 0x91, 0x0d, 0x07, 0x3f, 0xe3, 0x10, 0x6a,
-  0x49, 0x4d, 0x10, 0x60, 0x6a, 0xdd, 0xac, 0xdf, 0x7e, 0xfb, 0xad, 0xca,
-  0x53, 0xf4, 0x8b, 0x8e, 0xfb, 0x86, 0x38, 0xd1, 0x98, 0x98, 0x1b, 0xa0,
-  0xb7, 0xa9, 0x71, 0x81, 0x18, 0xd7, 0x1b, 0x7f, 0xa2, 0xf3, 0x94, 0x46,
-  0x68, 0x63, 0xa5, 0x2e, 0x1f, 0x46, 0xc6, 0x4b, 0x7a, 0x2c, 0x4c, 0x8c,
-  0x29, 0x73, 0x8b, 0x5d, 0x31, 0xde, 0x11, 0x1d, 0x12, 0x3e, 0x76, 0x8e,
-  0x37, 0x9d, 0x69, 0x9f, 0x1a, 0x33, 0x15, 0x58, 0x37, 0x92, 0x29, 0x56,
-  0x84, 0x9c, 0x57, 0x1d, 0x79, 0xf0, 0x3a, 0xed, 0xa8, 0x71, 0x52, 0x3e,
-  0xe9, 0xf8, 0xd4, 0x36, 0xd9, 0x0d, 0xde, 0xb2, 0x57, 0x22, 0x39, 0xa5,
-  0x3f, 0x26, 0xaf, 0xf6, 0x76, 0xdb, 0x9f, 0x80, 0x62, 0xc4, 0x35, 0x8d,
-  0x5f, 0x79, 0xe3, 0xee, 0x63, 0xcf, 0xa7, 0x63, 0x79, 0x5a, 0x6b, 0x08,
-  0x31, 0x5a, 0xfa, 0xab, 0xce, 0x10, 0xf7, 0x2b, 0xfe, 0x7f, 0xcd, 0x38,
-  0x38, 0xe4, 0x44, 0x9f, 0x2d, 0x96, 0xc3, 0x59, 0x5a, 0x19, 0xf0, 0x0e,
-  0x26, 0xf8, 0x19, 0x9b, 0x53, 0x12, 0x47, 0x1b, 0x28, 0x71, 0x9e, 0x8b,
-  0xe8, 0xb7, 0x39, 0xc9, 0xb2, 0x61, 0x9c, 0x6f, 0xaa, 0x01, 0xd0, 0xc6,
-  0xb9, 0xb9, 0xb7, 0xff, 0xe4, 0xe9, 0xb3, 0xcd, 0xbe, 0x8a, 0x69, 0xcc,
-  0x20, 0x58, 0x47, 0x4b, 0x55, 0x97, 0x91, 0x26, 0x62, 0x39, 0x9e, 0x61,
-  0xb5, 0xd8, 0x56, 0x43, 0x39, 0x78, 0x18, 0xba, 0x7b, 0x25, 0xbd, 0xfd,
-  0x0e, 0xfd, 0xbc, 0xe2, 0x2e, 0x7e, 0x97, 0x8e, 0x5f, 0xb9, 0x19, 0xfe,
-  0x0e, 0x73, 0x79, 0xa5, 0x93, 0xa0, 0x7d, 0xb5, 0xa8, 0xdd, 0x22, 0xc4,
-  0xf5, 0x7d, 0xdf, 0xe6, 0xda, 0x26, 0x6e, 0xf0, 0xa4, 0xd9, 0xd3, 0xd0,
-  0x1b, 0x8b, 0xd5, 0x91, 0x85, 0x55, 0x1f, 0xb3, 0xba, 0xf3, 0xd0, 0xa3,
-  0x56, 0x7a, 0x68, 0xa5, 0xe7, 0xd9, 0x75, 0x34, 0x43, 0xa0, 0x3a, 0x36,
-  0xa2, 0xab, 0xc1, 0xcb, 0x53, 0xb6, 0x73, 0xa8, 0x20, 0x90, 0x65, 0x1c,
-  0x07, 0x7b, 0xf8, 0xc5, 0xc9, 0xa6, 0x3a, 0xc8, 0x44, 0x73, 0xeb, 0xb6,
-  0x19, 0xd6, 0x9c, 0x4f, 0x59, 0x33, 0x94, 0x37, 0xac, 0x2a, 0x6d, 0x0c,
-  0x7f, 0x0f, 0xfa, 0x95, 0x6c, 0x03, 0xd4, 0xbd, 0x96, 0x3b, 0x87, 0xae,
-  0x45, 0x46, 0x39, 0x01, 0x30, 0x62, 0xd0, 0x0c, 0xa3, 0x3e, 0x88, 0xe3,
-  0x87, 0x75, 0x63, 0x0f, 0xb5, 0xd8, 0x7b, 0xed, 0x2c, 0xd9, 0x2e, 0x1c,
-  0x56, 0x1f, 0xa5, 0xaf, 0x84, 0x9b, 0x18, 0x83, 0xe8, 0xb8, 0x8a, 0x12,
-  0x42, 0x09, 0x21, 0xef, 0x60, 0x3b, 0xfc, 0x30, 0xa9, 0xd4, 0x28, 0x10,
-  0xb1, 0x10, 0xdc, 0xf3, 0xa5, 0x2b, 0x3e, 0xf0, 0x59, 0xc4, 0x20, 0xca,
-  0xf2, 0x96, 0x06, 0xbc, 0x56, 0xca, 0xba, 0xf1, 0x4b, 0xaa, 0x1d, 0x38,
-  0xab, 0x7d, 0xe0, 0x35, 0x53, 0xb1, 0x40, 0x5a, 0x90, 0x89, 0x0e, 0x57,
-  0x6a, 0x09, 0x40, 0x0b, 0x9b, 0x7f, 0xe4, 0x43, 0xf0, 0x12, 0xdb, 0xc0,
-  0x5f, 0x7f, 0xb6, 0x29, 0xe6, 0xbb, 0x4a, 0x8d, 0xe4, 0x9a, 0x57, 0x40,
-  0x08, 0x34, 0x9c, 0x4f, 0x36, 0x71, 0x50, 0x0f, 0x22, 0x8b, 0x21, 0xdf,
-  0x8d, 0xb1, 0xfa, 0x49, 0x96, 0x9a, 0x8e, 0xb5, 0x4a, 0x8a, 0xca, 0x42,
-  0x5d, 0x6d, 0x3c, 0x41, 0x00, 0x30, 0x64, 0xc7, 0x4d, 0x84, 0x27, 0xf0,
-  0x7b, 0x9b, 0x3e, 0xa3, 0x3a, 0x63, 0xb5, 0x0a, 0xe6, 0x82, 0xc4, 0x2a,
-  0x88, 0x6c, 0x28, 0x4e, 0x80, 0x97, 0xe5, 0xc3, 0x89, 0x15, 0x81, 0xe8,
-  0xe0, 0x83, 0x82, 0x25, 0x29, 0xb2, 0x71, 0x44, 0x5e, 0x23, 0xf2, 0x5e,
-  0x3b, 0x7d, 0x85, 0xe5, 0xde, 0xeb, 0x5f, 0xa7, 0x13, 0x59, 0x0c, 0x62,
-  0x91, 0xd7, 0xc9, 0x0e, 0xfd, 0x89, 0xfa, 0xc1, 0xfb, 0x90, 0xc9, 0xf0,
-  0xcb, 0x13, 0xf6, 0x9b, 0x86, 0x37, 0x7f, 0x70, 0x36, 0xdc, 0xb9, 0xc0,
-  0x2f, 0xa9, 0xbb, 0xf1, 0x15, 0xdd, 0x50, 0x47, 0xc9, 0x64, 0xde, 0x84,
-  0x37, 0x0c, 0x0b, 0x73, 0xe7, 0x12, 0xfb, 0xb0, 0x44, 0xe8, 0x9a, 0x0b,
-  0x02, 0x52, 0xa7, 0x98, 0x8a, 0xe9, 0x90, 0xba, 0x53, 0xb5, 0x98, 0x20,
-  0xca, 0x8f, 0xef, 0xd5, 0xe4, 0x7e, 0xbb, 0x1b, 0x86, 0x56, 0x58, 0x51,
-  0x2d, 0x57, 0x05, 0x90, 0xb3, 0xff, 0xd0, 0xfd, 0x96, 0x16, 0xa9, 0x08,
-  0x42, 0xf3, 0x79, 0x9b, 0xd3, 0xfa, 0x0e, 0x56, 0xeb, 0x3c, 0x88, 0xc3,
-  0x3d, 0x2d, 0xca, 0x6d, 0xae, 0x8e, 0x3c, 0x2d, 0x58, 0x55, 0xd7, 0xc2,
-  0xdb, 0x7e, 0xdd, 0x2d, 0x83, 0x9e, 0xbb, 0xda, 0x44, 0xe1, 0x89, 0x1d,
-  0xf6, 0x65, 0x08, 0x6f, 0x3b, 0x9e, 0x09, 0xd8, 0x2e, 0x93, 0xed, 0xb4,
-  0x27, 0xf7, 0xa5, 0x0a, 0x41, 0xbd, 0xd7, 0xfd, 0xe8, 0x94, 0x03, 0x83,
-  0x8a, 0x58, 0x92, 0x1c, 0xed, 0x4e, 0x35, 0x0a, 0x20, 0x72, 0x11, 0xa9,
-  0x7b, 0x43, 0x2a, 0x6e, 0x20, 0x8f, 0xcc, 0xc8, 0x88, 0x91, 0xae, 0xbc,
-  0x9e, 0x29, 0x12, 0x85, 0x4a, 0x20, 0x5d, 0xb6, 0x40, 0xbb, 0xe7, 0xb8,
-  0x0a, 0x0b, 0x3f, 0x15, 0x73, 0x38, 0xa7, 0x23, 0xd2, 0xa0, 0x11, 0x57,
-  0x7d, 0x17, 0x22, 0x67, 0xc0, 0xca, 0x1d, 0xe1, 0x4b, 0xba, 0x5a, 0x22,
-  0x76, 0x16, 0xad, 0xe8, 0x27, 0xfe, 0x17, 0x6a, 0x8d, 0x29, 0x0b, 0x73,
-  0x07, 0xe9, 0x74, 0x58, 0x53, 0x9c, 0x26, 0x4e, 0x9f, 0x56, 0xbc, 0x4b,
-  0x8d, 0xb9, 0x53, 0x38, 0x01, 0x11, 0x30, 0x3c, 0x72, 0x1b, 0x06, 0x89,
-  0x71, 0xc5, 0x77, 0xf4, 0x0b, 0x2e, 0xf9, 0x61, 0x4e, 0x3b, 0x8d, 0x60,
-  0x57, 0xac, 0x8c, 0x14, 0xf1, 0xd5, 0x3a, 0xb7, 0xa2, 0x98, 0xbc, 0x39,
-  0x8d, 0x2c, 0x59, 0x74, 0xe2, 0x85, 0x43, 0x8b, 0x9a, 0xe0, 0x29, 0xaa,
-  0x31, 0x44, 0x24, 0x20, 0x7d, 0x4a, 0x6e, 0x36, 0x59, 0x5b, 0xe4, 0x94,
-  0x44, 0x58, 0x9c, 0xca, 0x31, 0x0d, 0x9e, 0x90, 0x57, 0x41, 0x3b, 0x44,
-  0x1a, 0x9b, 0x58, 0x82, 0xcd, 0x6e, 0xb4, 0x89, 0xa1, 0xe2, 0x8b, 0x4d,
-  0x5e, 0x4f, 0xfe, 0x38, 0x58, 0xbe, 0xcd, 0x7e, 0xcb, 0xc9, 0xc3, 0x33,
-  0xaf, 0xfe, 0x5c, 0x59, 0x25, 0xfe, 0xdc, 0x9a, 0x7a, 0x25, 0xb1, 0x84,
-  0x0d, 0x29, 0xdb, 0xde, 0x0d, 0xda, 0x7f, 0x75, 0x48, 0xad, 0x48, 0x85,
-  0x13, 0xd9, 0x13, 0x16, 0xa8, 0xdd, 0x67, 0x29, 0x47, 0xbb, 0x37, 0x1a,
-  0x7a, 0xff, 0xc9, 0xbd, 0x32, 0xf6, 0xe3, 0xc2, 0x33, 0x84, 0xa3, 0x09,
-  0x09, 0x18, 0xb7, 0xa5, 0xdd, 0x4c, 0x45, 0xd3, 0xbb, 0xcf, 0xd8, 0xae,
-  0xc0, 0x7c, 0x66, 0xaf, 0xcf, 0x51, 0xd0, 0x1e, 0x66, 0xc3, 0x35, 0xe0,
-  0xd4, 0xf5, 0x0e, 0x2f, 0x68, 0xc7, 0xec, 0x24, 0x4e, 0x89, 0xb7, 0x55,
-  0x6e, 0x1a, 0x83, 0x69, 0xea, 0x5a, 0x5b, 0x9c, 0xf8, 0xd5, 0x38, 0xbb,
-  0x06, 0xbb, 0xea, 0xd2, 0xcd, 0x8a, 0x9f, 0x9d, 0x88, 0x1f, 0xdf, 0xd7,
-  0x7e, 0x65, 0xcc, 0x7c, 0x5c, 0x44, 0x74, 0xb7, 0xbf, 0x35, 0x82, 0x24,
-  0x6a, 0xd9, 0x92, 0x71, 0x36, 0xd2, 0xe6, 0x5d, 0xeb, 0xb2, 0x27, 0xd4,
-  0x85, 0xfb, 0xc2, 0x77, 0x17, 0xac, 0x50, 0xac, 0x6d, 0x4b, 0xb9, 0x99,
-  0x69, 0x5a, 0xca, 0x1d, 0xce, 0x5d, 0x43, 0x83, 0x61, 0xc3, 0x16, 0xd0,
-  0xbb, 0xe5, 0xc2, 0x9a, 0x6a, 0xd8, 0xee, 0xe6, 0x9f, 0x37, 0x25, 0x1a,
-  0x6c, 0xf3, 0xe5, 0x26, 0xb3, 0x2e, 0x30, 0x24, 0x43, 0xae, 0xd4, 0x5b,
-  0x69, 0x53, 0xae, 0xc3, 0x9e, 0x08, 0x0d, 0x5a, 0x0e, 0xc8, 0x9f, 0x12,
-  0xbe, 0x8f, 0xbd, 0xf6, 0x18, 0x46, 0x37, 0xb0, 0x75, 0xc0, 0x17, 0xc1,
-  0x01, 0x60, 0xc7, 0xb0, 0x14, 0x9f, 0xaa, 0xde, 0xb6, 0x2c, 0x8f, 0x71,
-  0x8a, 0x61, 0x01, 0x8f, 0xa1, 0x98, 0x37, 0x97, 0xf3, 0x05, 0x92, 0x48,
-  0x46, 0xa5, 0xa0, 0xb6, 0xf2, 0x81, 0xea, 0x47, 0x6f, 0xe7, 0x02, 0x8d,
-  0x95, 0x40, 0x47, 0x0e, 0x1d, 0xbe, 0x5d, 0xe7, 0xb8, 0xa6, 0x95, 0x0a,
-  0x4e, 0x6f, 0x75, 0xc0, 0x62, 0x13, 0x11, 0xe3, 0xb5, 0xf6, 0x8b, 0xfb,
-  0x35, 0x87, 0x3b, 0x5d, 0x8d, 0xd3, 0x2c, 0x0e, 0xb8, 0x44, 0x43, 0xe5,
-  0x42, 0x70, 0xcf, 0x1d, 0xbf, 0x3e, 0xbe, 0xbc, 0x3c, 0xbe, 0xc4, 0x7a,
-  0x1f, 0x54, 0xe0, 0xaf, 0x19, 0x63, 0x40, 0x52, 0x7e, 0x0c, 0xbc, 0xc9,
-  0xc2, 0x72, 0x9a, 0xa5, 0x0a, 0x85, 0x1d, 0x2a, 0xd6, 0xca, 0x46, 0x64,
-  0x8e, 0x5a, 0xc9, 0xb2, 0x15, 0xb3, 0x30, 0xdb, 0x14, 0x39, 0x28, 0xcb,
-  0xd9, 0xef, 0xa7, 0xb8, 0x5b, 0xd8, 0xea, 0x58, 0x91, 0x28, 0x36, 0x22,
-  0x7b, 0x35, 0x97, 0xfa, 0x08, 0x72, 0x5f, 0x9b, 0x02, 0x19, 0x08, 0xa7,
-  0x7d, 0x8d, 0xa3, 0x49, 0xd4, 0xfd, 0x3a, 0x75, 0x36, 0x09, 0x9e, 0xef,
-  0x04, 0xa7, 0x14, 0xfa, 0x12, 0xaf, 0x44, 0x51, 0x2e, 0x17, 0xe9, 0xd8,
-  0x99, 0x78, 0xe9, 0x73, 0x12, 0xfa, 0x22, 0x39, 0xe7, 0x85, 0x8d, 0x98,
-  0xbd, 0x89, 0x66, 0x80, 0x08, 0x2d, 0x6c, 0x92, 0xd2, 0xea, 0xed, 0x63,
-  0x1c, 0x09, 0x2d, 0x65, 0xa8, 0x14, 0x9d, 0x96, 0x59, 0x6c, 0x83, 0x19,
-  0x25, 0x6c, 0x5a, 0x04, 0xbf, 0x30, 0x67, 0x77, 0xc8, 0x1b, 0x60, 0xbf,
-  0x9a, 0xf9, 0x68, 0x34, 0x5f, 0x1b, 0x48, 0x02, 0xc6, 0x73, 0x7f, 0x6f,
-  0x70, 0x78, 0xa7, 0x8f, 0x14, 0x13, 0xaf, 0x38, 0xcd, 0x5a, 0x57, 0x48,
-  0x35, 0x5f, 0xd2, 0xf7, 0xfa, 0x08, 0xbc, 0x3a, 0xbe, 0x8c, 0x0e, 0xbe,
-  0x00, 0x16, 0xcb, 0x3f, 0xb7, 0xad, 0x78, 0x4e, 0xef, 0x05, 0xdb, 0x54,
-  0xcd, 0xff, 0x4b, 0xc6, 0x21, 0xc4, 0x77, 0xbf, 0xb2, 0xa3, 0xa9, 0x96,
-  0xb5, 0x08, 0x2e, 0xf7, 0xea, 0xde, 0x6d, 0x44, 0xef, 0xdd, 0xbd, 0x0f,
-  0xd9, 0x3b, 0x9c, 0xac, 0x70, 0xf7, 0x24, 0x81, 0x58, 0xfc, 0x0f, 0xb6,
-  0x27, 0x3a, 0xfa, 0xa2, 0xa1, 0x64, 0xca, 0xee, 0x1c, 0x44, 0x9b, 0x6f,
-  0xb2, 0x1f, 0x49, 0x0c, 0x88, 0x77, 0x9e, 0xf4, 0x77, 0xa3, 0xad, 0x6f,
-  0xd2, 0xf9, 0xf3, 0x67, 0x7f, 0x8c, 0x4e, 0xb6, 0x37, 0x2b, 0x21, 0x76,
-  0x02, 0x9a, 0x3a, 0x8c, 0xe7, 0xb7, 0x6e, 0xab, 0xce, 0xf9, 0x38, 0x4b,
-  0xd0, 0x85, 0x41, 0x05, 0xbe, 0xe0, 0xbd, 0x5f, 0xdb, 0xa2, 0x94, 0x25,
-  0x94, 0x68, 0xbd, 0xe8, 0x6b, 0x07, 0x55, 0x05, 0x8d, 0x9e, 0x9e, 0x1a,
-  0x63, 0xe9, 0x9e, 0x3f, 0x6b, 0x34, 0xf1, 0xd4, 0xb5, 0xf1, 0x56, 0xda,
-  0xf8, 0x89, 0x4d, 0xec, 0xf7, 0x77, 0xf7, 0xa3, 0xad, 0xf3, 0xc1, 0xce,
-  0xbe, 0x6b, 0xa1, 0xd9, 0xc4, 0x3e, 0x37, 0x81, 0x87, 0xaa, 0x2f, 0x3f,
-  0x45, 0xff, 0xdf, 0x27, 0xf3, 0x1f, 0xa2, 0xad, 0x6f, 0xf7, 0xf6, 0xa8,
-  0x81, 0x3f, 0x46, 0x07, 0x27, 0xdf, 0x46, 0x4f, 0xfb, 0xd4, 0xd8, 0x59,
-  0x7c, 0xa7, 0xcd, 0x29, 0xb0, 0xcc, 0x80, 0x1b, 0xa1, 0xef, 0x1b, 0x6d,
-  0x3c, 0xab, 0xb5, 0x71, 0x4a, 0x5a, 0xe0, 0x03, 0xdd, 0x26, 0xbb, 0xfd,
-  0x27, 0xfb, 0x51, 0xfa, 0xec, 0xd3, 0x8f, 0xad, 0x21, 0x6d, 0x83, 0xbf,
-  0xaf, 0x5a, 0x26, 0x25, 0x99, 0x90, 0x84, 0x9c, 0xe3, 0x07, 0xe2, 0x62,
-  0xcc, 0x1a, 0x18, 0x56, 0xf1, 0x26, 0x96, 0xca, 0xdb, 0x43, 0x41, 0xae,
-  0xa7, 0x9d, 0x12, 0xeb, 0x35, 0xdc, 0x10, 0x24, 0xeb, 0xd2, 0x95, 0xf9,
-  0xa2, 0x31, 0x1c, 0x68, 0xa2, 0xf6, 0xe8, 0x1f, 0xa3, 0x37, 0x83, 0x93,
-  0x63, 0x9a, 0xd1, 0x2e, 0x0d, 0xcd, 0xaf, 0xa1, 0x0c, 0x88, 0xbf, 0xe2,
-  0xc5, 0xa5, 0x55, 0xdd, 0x00, 0x04, 0x06, 0xb7, 0x61, 0x12, 0xb6, 0xc4,
-  0x22, 0x01, 0xd0, 0x2d, 0x2b, 0x0a, 0xee, 0x17, 0xe9, 0x42, 0xbd, 0x83,
-  0x6b, 0x28, 0x0c, 0x7a, 0xc9, 0xa2, 0xeb, 0xaf, 0xb2, 0x39, 0x1d, 0x93,
-  0x3c, 0xcb, 0x77, 0xf6, 0xfa, 0xbb, 0x9b, 0x15, 0x39, 0xe1, 0xab, 0xa3,
-  0x63, 0xc9, 0x91, 0x79, 0x13, 0xcf, 0x89, 0x37, 0x22, 0x8b, 0xbc, 0xb8,
-  0x85, 0xbf, 0x5d, 0x7c, 0x37, 0xf2, 0xfe, 0xe9, 0x6a, 0xfe, 0x40, 0xfb,
-  0xf8, 0x49, 0x7f, 0x0f, 0x78, 0x57, 0xd0, 0x71, 0x5f, 0xbf, 0xa1, 0xbf,
-  0xf7, 0x9e, 0x6e, 0x46, 0xf8, 0xaa, 0xaa, 0xaf, 0xdb, 0x79, 0xdd, 0x38,
-  0x3c, 0x3f, 0xff, 0xea, 0x44, 0x42, 0x2f, 0x0e, 0xd5, 0x84, 0x0a, 0xb1,
-  0xca, 0xe9, 0xc0, 0xc2, 0x55, 0x49, 0x57, 0x43, 0xf4, 0xab, 0x9d, 0x2c,
-  0x5a, 0xc9, 0xdb, 0x24, 0x59, 0x30, 0x40, 0x55, 0x8d, 0x23, 0x94, 0xca,
-  0x9b, 0x65, 0x64, 0x10, 0xa3, 0xd3, 0x71, 0x35, 0x03, 0x1e, 0x80, 0xe6,
-  0xce, 0x5c, 0x3b, 0x5c, 0xb9, 0x7c, 0xbb, 0xd8, 0xd7, 0x95, 0xe2, 0x21,
-  0xba, 0x18, 0x42, 0x33, 0x37, 0x4b, 0x49, 0x57, 0x7a, 0x51, 0x35, 0xdd,
-  0xcd, 0x41, 0x52, 0xf6, 0x64, 0xd0, 0x2f, 0xd4, 0x42, 0xbb, 0xa9, 0xe6,
-  0x26, 0x67, 0x2c, 0x5b, 0x28, 0x5e, 0x25, 0x9b, 0x89, 0x57, 0x0b, 0x94,
-  0xbf, 0x9a, 0xba, 0xd2, 0x80, 0x5c, 0x50, 0x2d, 0xe1, 0x80, 0xb1, 0xb3,
-  0x83, 0x37, 0xc7, 0xaf, 0xbe, 0x3e, 0x38, 0x7d, 0x7b, 0x4c, 0xaf, 0x00,
-  0xb1, 0x71, 0xcb, 0x23, 0x1e, 0xf1, 0x18, 0x67, 0x29, 0x97, 0x2c, 0x2f,
-  0x48, 0x26, 0xd8, 0xdc, 0x90, 0xc0, 0xc0, 0xa8, 0x83, 0xb7, 0xf6, 0xe4,
-  0x35, 0xa2, 0x0b, 0xfc, 0xb5, 0x2f, 0x7f, 0xed, 0xff, 0xb1, 0xb3, 0x5d,
-  0x99, 0x74, 0x43, 0x27, 0x06, 0xbd, 0xdc, 0x4b, 0x44, 0x18, 0xc3, 0xf0,
-  0x73, 0x44, 0xa5, 0xac, 0x4a, 0xc7, 0xfc, 0x31, 0x76, 0xa7, 0xe1, 0xd9,
-  0xad, 0x61, 0xa5, 0x90, 0x7a, 0x07, 0x2f, 0xbd, 0x62, 0xa9, 0xa2, 0x83,
-  0x7c, 0x10, 0x95, 0x33, 0xd8, 0x57, 0x8d, 0x36, 0xac, 0x89, 0xe4, 0x61,
-  0x81, 0xc0, 0xa3, 0xad, 0x8e, 0xfc, 0xf2, 0xea, 0xe8, 0xe0, 0xea, 0x18,
-  0x2f, 0x58, 0xf7, 0x56, 0xa3, 0xd2, 0x40, 0xa2, 0x30, 0x9e, 0xad, 0x8e,
-  0x7c, 0xf8, 0x0a, 0x13, 0xea, 0x08, 0x98, 0xb7, 0x40, 0xaf, 0xd5, 0xc6,
-  0x95, 0xcd, 0x35, 0xfc, 0x2e, 0xc8, 0x12, 0x2a, 0x2c, 0x42, 0x64, 0xab,
-  0x23, 0xdf, 0x75, 0x9c, 0xb5, 0x96, 0xee, 0xf0, 0xcd, 0xbb, 0xc4, 0x57,
-  0xd1, 0x8e, 0xdb, 0x52, 0x27, 0x04, 0xc9, 0xdd, 0xef, 0x8f, 0x3a, 0x26,
-  0xc4, 0xbe, 0x14, 0x80, 0x5c, 0xb9, 0x8d, 0xd7, 0x9c, 0x26, 0x58, 0x94,
-  0xb2, 0x6c, 0x6f, 0xff, 0xc9, 0x1f, 0x79, 0x3d, 0x5f, 0x75, 0x76, 0xe8,
-  0x6e, 0xe8, 0xfc, 0x11, 0x5d, 0xa7, 0x1e, 0x25, 0xde, 0xed, 0x07, 0x34,
-  0x29, 0xa5, 0x28, 0x09, 0x4f, 0xc1, 0xae, 0xb3, 0x25, 0x4c, 0xe6, 0xc5,
-  0x0b, 0x7a, 0x2f, 0xb1, 0xdb, 0x96, 0xc3, 0x6a, 0xde, 0x7b, 0xde, 0x2f,
-  0xae, 0xc7, 0x34, 0x77, 0xa0, 0x85, 0xd2, 0x5d, 0x78, 0x7f, 0x74, 0xe5,
-  0x5d, 0x99, 0xa3, 0x96, 0x7c, 0x43, 0x9f, 0xb3, 0x95, 0x85, 0x77, 0x73,
-  0x5f, 0x5a, 0x02, 0x9e, 0xe7, 0x52, 0x97, 0x0a, 0x86, 0x6a, 0xc9, 0x31,
-  0x35, 0x84, 0x65, 0x01, 0x62, 0x2d, 0x2b, 0x16, 0x90, 0xc4, 0xdd, 0x1f,
-  0x44, 0x39, 0xd8, 0x9d, 0x1d, 0x0f, 0x91, 0x45, 0xb4, 0xb2, 0x3d, 0x0d,
-  0x74, 0x70, 0xb7, 0xf4, 0x76, 0xfc, 0xd2, 0x20, 0x6f, 0x19, 0x17, 0xa5,
-  0xac, 0x65, 0xe1, 0x2c, 0x46, 0xec, 0x59, 0xd4, 0x67, 0xab, 0xfb, 0x54,
-  0x8b, 0x12, 0xe7, 0x69, 0x88, 0x02, 0x2f, 0x9a, 0x31, 0xb1, 0x9a, 0x79,
-  0x92, 0x3f, 0x1a, 0xe1, 0xd0, 0xe2, 0x78, 0xe2, 0x29, 0x06, 0x59, 0x00,
-  0x78, 0xa7, 0xdf, 0xef, 0x7b, 0x9c, 0xfd, 0x1b, 0x2e, 0xb3, 0xce, 0xc3,
-  0x60, 0x78, 0xbb, 0x4a, 0x7d, 0xb0, 0x58, 0x8a, 0x82, 0x29, 0x00, 0xc9,
-  0xb6, 0x06, 0xbe, 0xa8, 0x2d, 0xc2, 0x1d, 0x8d, 0xc0, 0xa2, 0xb1, 0xa9,
-  0xdd, 0x6e, 0x1a, 0x08, 0xf9, 0x6d, 0xdb, 0x26, 0x3c, 0x32, 0x36, 0xb1,
-  0x34, 0x16, 0x31, 0xe7, 0xff, 0x3a, 0x3e, 0x95, 0xb9, 0xb5, 0x00, 0x05,
-  0x23, 0x27, 0x58, 0x4a, 0xaa, 0xf1, 0x96, 0xc8, 0xa2, 0xe9, 0x50, 0xba,
-  0x12, 0x68, 0x00, 0x26, 0x97, 0xdd, 0x73, 0x96, 0x9b, 0xd4, 0xfb, 0x5d,
-  0xe4, 0xd0, 0xf1, 0xb8, 0x4e, 0x97, 0xde, 0x20, 0x0e, 0x0d, 0xd4, 0xda,
-  0x19, 0x8b, 0x61, 0x16, 0xda, 0x32, 0x0b, 0xfc, 0x9a, 0x7b, 0xa0, 0x50,
-  0xae, 0x45, 0xac, 0xc0, 0x3c, 0x24, 0xb6, 0x65, 0x33, 0x76, 0x71, 0xe9,
-  0xe4, 0xbd, 0x91, 0x04, 0xd1, 0x5d, 0x3d, 0x49, 0xd0, 0xb4, 0xf4, 0x00,
-  0xe3, 0x1e, 0x5a, 0xe3, 0xf3, 0x31, 0xe7, 0xf8, 0xc8, 0x5a, 0x74, 0x9e,
-  0xf1, 0xda, 0xda, 0xf8, 0x5b, 0xb9, 0xca, 0xba, 0x68, 0x45, 0xc5, 0x96,
-  0xcc, 0x12, 0x72, 0xc0, 0xf7, 0xa2, 0xf8, 0x1e, 0xf5, 0x1e, 0x88, 0x06,
-  0xc5, 0x49, 0x26, 0xf6, 0x98, 0xd3, 0xc0, 0xaa, 0xe8, 0x66, 0x68, 0xf5,
-  0x1a, 0x25, 0xbc, 0x48, 0x0a, 0x32, 0x2a, 0x54, 0xa4, 0xa0, 0x4d, 0x99,
-  0xf9, 0x2e, 0x65, 0xec, 0x7e, 0xa0, 0x01, 0xa9, 0x84, 0x6e, 0x8a, 0x39,
-  0x46, 0x4e, 0x2c, 0x7a, 0xa0, 0x74, 0x93, 0x72, 0x1c, 0x20, 0x2c, 0x1c,
-  0x12, 0x44, 0x61, 0xab, 0x25, 0xe5, 0x3a, 0xad, 0x13, 0xe7, 0x8b, 0x66,
-  0x63, 0x53, 0xc2, 0x35, 0x44, 0xe7, 0x3d, 0x97, 0xb9, 0xe8, 0x62, 0xaf,
-  0xf2, 0xf4, 0xfa, 0x5a, 0x54, 0xb5, 0xa8, 0x3e, 0xb5, 0x76, 0x22, 0x3b,
-  0xc5, 0xaa, 0x24, 0xb3, 0x45, 0xb9, 0x5a, 0xb7, 0x9a, 0x57, 0x66, 0xed,
-  0x31, 0x7b, 0x4b, 0x85, 0x98, 0xcd, 0xff, 0x28, 0xfb, 0xc6, 0x88, 0x3d,
-  0x92, 0x82, 0x06, 0xa3, 0x57, 0xd5, 0x5f, 0x7c, 0x7e, 0xb9, 0xc1, 0x45,
-  0x1f, 0xe6, 0x3e, 0xe3, 0xce, 0x36, 0x9d, 0xd1, 0x2b, 0x7c, 0xb8, 0xc9,
-  0x18, 0x56, 0xe5, 0x19, 0xae, 0xe2, 0x7b, 0x17, 0xeb, 0x24, 0xf8, 0x9b,
-  0xc3, 0xd8, 0xab, 0x5a, 0x1b, 0x51, 0xc5, 0xb6, 0x8b, 0xe4, 0xce, 0x93,
-  0xb9, 0xf2, 0xa1, 0xec, 0x2e, 0xf1, 0x40, 0x2a, 0xde, 0xbc, 0xe8, 0xf1,
-  0xb0, 0xf4, 0xf4, 0x3b, 0x66, 0x52, 0x73, 0xe6, 0x3a, 0x7e, 0xc5, 0x93,
-  0xac, 0xad, 0x4a, 0x3f, 0x0a, 0x9a, 0x14, 0x23, 0x49, 0x16, 0xb2, 0x78,
-  0x19, 0x9b, 0xfa, 0xa8, 0xad, 0x45, 0x8d, 0x42, 0x67, 0x24, 0xee, 0x40,
-  0x35, 0xc1, 0x82, 0xa4, 0xa5, 0x52, 0x55, 0xe1, 0x62, 0xe4, 0xbc, 0xaf,
-  0xd7, 0x66, 0xd9, 0x71, 0x9b, 0xd4, 0xe1, 0xe4, 0x8b, 0xa1, 0x12, 0x01,
-  0xd3, 0x00, 0x04, 0x3a, 0xe7, 0xae, 0x3f, 0x98, 0xc6, 0x05, 0xd7, 0x00,
-  0xe6, 0x48, 0x00, 0xde, 0x32, 0x26, 0x6a, 0x36, 0xa3, 0xd5, 0x78, 0x6a,
-  0xe3, 0xf8, 0xb9, 0xc8, 0x0c, 0xa1, 0x35, 0x46, 0xc4, 0x42, 0x33, 0x44,
-  0x25, 0x1c, 0x8e, 0x3b, 0x32, 0xe6, 0xfe, 0x78, 0x6a, 0xda, 0xb0, 0x72,
-  0x46, 0xdf, 0x77, 0x64, 0x2f, 0x2e, 0xcf, 0xbf, 0xb8, 0x3c, 0x1e, 0x0c,
-  0xa2, 0x37, 0xc7, 0x57, 0xa2, 0xeb, 0x5f, 0x49, 0x18, 0x9c, 0x40, 0x83,
-  0xb2, 0x93, 0xc1, 0xb2, 0xb3, 0x2d, 0xd2, 0xc4, 0x0c, 0x09, 0x0c, 0xf1,
-  0x98, 0xc1, 0x81, 0xc6, 0xa2, 0x1c, 0xeb, 0xf1, 0x53, 0x8d, 0x9e, 0xbb,
-  0x61, 0x33, 0x3f, 0xc7, 0x32, 0xb1, 0x1f, 0xd2, 0x59, 0xcd, 0xbd, 0x2d,
-  0x35, 0x28, 0x2f, 0x7c, 0x63, 0x9c, 0xcb, 0xdb, 0xce, 0xb5, 0x86, 0x2b,
-  0x4f, 0xef, 0xb7, 0xd1, 0x95, 0xd5, 0xff, 0xfc, 0x6d, 0x74, 0x69, 0xf4,
-  0xf1, 0xdb, 0xe8, 0x5b, 0x6a, 0x73, 0x8c, 0x12, 0xb4, 0x52, 0xe6, 0x6a,
-  0xc0, 0xf5, 0xad, 0x7c, 0xa1, 0x03, 0x06, 0x88, 0x0f, 0xfe, 0x47, 0x54,
-  0x9e, 0xbf, 0xa7, 0x9a, 0x22, 0x27, 0x13, 0x0b, 0xb6, 0x8c, 0xc6, 0xd2,
-  0xb9, 0x9e, 0x0f, 0xb5, 0x78, 0x76, 0x74, 0x9a, 0x4c, 0x4a, 0x16, 0x48,
-  0xd0, 0x1d, 0x35, 0xb7, 0x0b, 0xfc, 0xb4, 0x3d, 0x54, 0xab, 0xa7, 0x5f,
-  0x9f, 0x7c, 0xfa, 0xf1, 0xee, 0xa7, 0xf2, 0xab, 0xfd, 0xfb, 0xfc, 0xe9,
-  0xae, 0x62, 0x12, 0xd2, 0x5f, 0x4f, 0x5f, 0x3c, 0xdd, 0x7b, 0x01, 0x14,
-  0x94, 0xdd, 0x17, 0xbb, 0xf4, 0xff, 0x4f, 0xf5, 0x13, 0x80, 0xbd, 0x3c,
-  0xdf, 0xff, 0xf4, 0x13, 0x0e, 0x82, 0x01, 0x7d, 0x4c, 0xa9, 0x93, 0x5e,
-  0x99, 0xf5, 0x38, 0x87, 0x9c, 0x85, 0xa0, 0xdf, 0x56, 0xcd, 0x91, 0xf0,
-  0xaa, 0xa3, 0x80, 0x15, 0x26, 0xee, 0xeb, 0x69, 0xab, 0x69, 0x55, 0x52,
-  0x9c, 0xc3, 0xca, 0x7c, 0x6e, 0x1a, 0xfa, 0xb6, 0x54, 0x46, 0x63, 0xec,
-  0x85, 0xca, 0x3b, 0x24, 0x32, 0xd2, 0xd5, 0x1a, 0x80, 0x3c, 0xfc, 0xd4,
-  0xae, 0x2d, 0xd3, 0x6b, 0x83, 0xd1, 0x1b, 0x74, 0xab, 0xf4, 0x3d, 0xad,
-  0x3f, 0x4e, 0x34, 0x12, 0xd4, 0x7b, 0xab, 0x55, 0x67, 0xfb, 0xa9, 0xfd,
-  0x89, 0xe5, 0x0a, 0x6f, 0x29, 0x35, 0x44, 0xcd, 0xde, 0xac, 0x4c, 0x5d,
-  0x5b, 0x5f, 0x15, 0xe2, 0xd9, 0xf0, 0xdb, 0xef, 0x57, 0x2a, 0x28, 0xa4,
-  0xe6, 0xe0, 0x0c, 0xa4, 0x94, 0x5a, 0xcb, 0x94, 0x1b, 0xcd, 0xbd, 0x5d,
-  0x84, 0xed, 0x7d, 0x48, 0x73, 0x7e, 0x46, 0x4c, 0xc1, 0x6e, 0xe7, 0x7a,
-  0xc1, 0xe6, 0xa4, 0x12, 0xd0, 0xe6, 0x2a, 0xb2, 0x19, 0x00, 0x8f, 0xdd,
-  0x78, 0xf2, 0xaa, 0x23, 0xd9, 0x9e, 0xbc, 0xa1, 0xe2, 0x67, 0xc1, 0x39,
-  0x2d, 0x22, 0x28, 0xdc, 0x65, 0x7c, 0xdb, 0xcb, 0xf3, 0x46, 0xd9, 0x8d,
-  0xae, 0x40, 0x8d, 0x41, 0x7f, 0xda, 0x07, 0x9f, 0x27, 0x77, 0xe8, 0x1e,
-  0x9d, 0x9a, 0x0f, 0x6b, 0x77, 0xd5, 0x2e, 0xb6, 0x5c, 0x98, 0x78, 0xdb,
-  0x91, 0xf4, 0xcf, 0x71, 0xe4, 0x78, 0x58, 0x23, 0xd5, 0x5d, 0x44, 0x5c,
-  0xea, 0x44, 0x81, 0x55, 0x81, 0xe9, 0x03, 0x94, 0xcc, 0x6d, 0x63, 0x61,
-  0xbd, 0x8f, 0x5c, 0xb4, 0x16, 0xdf, 0x6b, 0x0a, 0xd5, 0x1c, 0x0b, 0xe5,
-  0x4f, 0xc3, 0x84, 0xa8, 0x0a, 0x48, 0xb3, 0x47, 0xa3, 0xdc, 0xc4, 0xc0,
-  0x50, 0xb0, 0x91, 0x6e, 0x5a, 0xba, 0x39, 0x82, 0x22, 0x39, 0xbf, 0xd9,
-  0xd8, 0x18, 0x5c, 0x1c, 0x1f, 0x1f, 0x45, 0xa7, 0x27, 0x6f, 0x4e, 0xae,
-  0x02, 0x81, 0xdc, 0x5d, 0x24, 0x66, 0x69, 0x2d, 0xac, 0xae, 0x43, 0x75,
-  0x39, 0x3c, 0xcc, 0x99, 0x96, 0xae, 0xd7, 0xab, 0x7c, 0x96, 0x68, 0x02,
-  0xc3, 0xb4, 0xfe, 0x1e, 0xab, 0xde, 0x9c, 0xc4, 0xcf, 0xd8, 0xfb, 0x5e,
-  0xa0, 0x2b, 0x48, 0xb8, 0x19, 0xa1, 0xd0, 0x8b, 0x5c, 0x12, 0xdf, 0x69,
-  0x78, 0x46, 0x55, 0x72, 0x52, 0x94, 0x26, 0x57, 0xe4, 0x45, 0x63, 0x5a,
-  0x6b, 0xa3, 0xc2, 0xda, 0x26, 0x12, 0xe6, 0x1c, 0x58, 0xe8, 0x38, 0x5a,
-  0xef, 0x3e, 0xe1, 0x74, 0xc4, 0x59, 0x2a, 0x88, 0xb2, 0x61, 0x2c, 0xb1,
-  0xab, 0xa8, 0x70, 0x95, 0x09, 0x1f, 0x0f, 0x7b, 0x0c, 0x0b, 0xde, 0x58,
-  0x20, 0xad, 0xf5, 0x15, 0x96, 0x52, 0x79, 0xb2, 0xeb, 0x32, 0x05, 0x16,
-  0xcc, 0x73, 0x54, 0xd4, 0x47, 0x67, 0x7b, 0x11, 0xc9, 0x23, 0x4b, 0x48,
-  0xf5, 0xf9, 0x72, 0xde, 0xb8, 0xee, 0xbe, 0x93, 0x77, 0x69, 0xfe, 0x1f,
-  0xef, 0xf2, 0xf5, 0x36, 0x89, 0xf3, 0x1e, 0x49, 0x5e, 0xab, 0x9e, 0x59,
-  0x55, 0x85, 0x22, 0x34, 0xce, 0x58, 0x4c, 0x3f, 0x89, 0x47, 0xff, 0xaf,
-  0x49, 0x8b, 0x3e, 0xdd, 0x23, 0x63, 0x87, 0xe4, 0x54, 0x0f, 0x00, 0xa6,
-  0xde, 0x8d, 0xb8, 0xec, 0xa7, 0x8b, 0x7c, 0x16, 0x59, 0xc7, 0x23, 0x78,
-  0xd9, 0x2e, 0x7a, 0x1e, 0xc5, 0x65, 0xf5, 0x32, 0x75, 0x0d, 0xa5, 0x98,
-  0xa6, 0xce, 0xa5, 0x29, 0x5a, 0xcf, 0xa2, 0xbd, 0x4f, 0x31, 0x8f, 0x0f,
-  0x9b, 0x0f, 0x50, 0xee, 0x2d, 0x86, 0x4d, 0xd4, 0x85, 0xcc, 0xef, 0xa6,
-  0x64, 0x28, 0x30, 0x80, 0xb2, 0xac, 0xae, 0x05, 0xc3, 0x72, 0xac, 0x1e,
-  0xf4, 0x13, 0x75, 0xa4, 0xb3, 0x65, 0x8a, 0x3d, 0xdb, 0x22, 0x21, 0x71,
-  0x61, 0x34, 0x59, 0x17, 0xd8, 0x5a, 0x25, 0x56, 0x6f, 0x33, 0xf7, 0xb9,
-  0x5e, 0xbc, 0x0c, 0xb0, 0x8e, 0x10, 0xad, 0xdd, 0xa7, 0x63, 0x96, 0xaa,
-  0xcd, 0x08, 0xc0, 0xf4, 0x27, 0xc4, 0x27, 0x31, 0xd2, 0xec, 0xb8, 0x64,
-  0x8f, 0xa7, 0x1b, 0x99, 0x0a, 0x30, 0x5c, 0x32, 0x8e, 0x8d, 0x0b, 0x5b,
-  0x2c, 0x3f, 0xa0, 0x40, 0x43, 0xd5, 0x27, 0x00, 0xd6, 0xdc, 0xf1, 0xbd,
-  0x20, 0x6e, 0xbf, 0x2c, 0xa7, 0x66, 0x57, 0xf0, 0x08, 0xec, 0xd5, 0x39,
-  0x23, 0x95, 0x3a, 0x98, 0xf6, 0xde, 0x2e, 0xc9, 0xaf, 0xd3, 0xac, 0x5e,
-  0xb0, 0xa9, 0xa9, 0x94, 0xf2, 0xb4, 0x7a, 0xbc, 0x3a, 0x7b, 0xbb, 0x5f,
-  0xad, 0x5f, 0x75, 0x86, 0xac, 0x7c, 0xf4, 0xe5, 0xfd, 0xa7, 0x8f, 0x6c,
-  0xda, 0x79, 0x5e, 0x29, 0xbe, 0x21, 0x82, 0xa0, 0xf7, 0xbc, 0x34, 0xb6,
-  0x8d, 0x08, 0x3f, 0xb9, 0x8e, 0xb9, 0xb4, 0xed, 0x23, 0xa3, 0xb7, 0x4c,
-  0x8d, 0xda, 0x50, 0xde, 0x68, 0x34, 0xb6, 0x7c, 0x59, 0xc0, 0x42, 0xb6,
-  0x60, 0x24, 0x16, 0xaf, 0xc6, 0xba, 0x64, 0x44, 0xc9, 0xb0, 0x0d, 0xde,
-  0x16, 0xce, 0xd9, 0xad, 0x32, 0x09, 0xa3, 0x9e, 0x3c, 0xb9, 0x66, 0x57,
-  0x3a, 0xf3, 0x60, 0xa8, 0xfd, 0x34, 0xb8, 0x9e, 0x9e, 0x57, 0xe2, 0xcd,
-  0x88, 0x1b, 0x12, 0x7a, 0x62, 0xc6, 0x3b, 0x8a, 0x4d, 0x64, 0xd5, 0xa2,
-  0xed, 0xb5, 0x8b, 0x01, 0xf6, 0xd9, 0x51, 0xc6, 0x15, 0x99, 0xef, 0xcd,
-  0x97, 0x10, 0x96, 0x81, 0x91, 0x1a, 0x29, 0x7d, 0xce, 0xad, 0x13, 0x42,
-  0x71, 0xcc, 0x1e, 0x19, 0x5d, 0xf0, 0x86, 0x95, 0xe2, 0x21, 0xe0, 0x06,
-  0xba, 0x4a, 0xb5, 0xdc, 0x92, 0xeb, 0x0a, 0x1c, 0xbf, 0xb0, 0xe4, 0x49,
-  0x41, 0xa5, 0x84, 0xdd, 0xff, 0xf0, 0xfc, 0xec, 0xf5, 0xc9, 0x17, 0x0e,
-  0x56, 0x40, 0x98, 0xf8, 0xb2, 0xcc, 0x60, 0xd7, 0x14, 0xa3, 0xa1, 0x2b,
-  0xd0, 0xe3, 0xdc, 0xdd, 0x8a, 0x8b, 0xaf, 0x41, 0xb7, 0xc4, 0x9e, 0xde,
-  0x85, 0x1f, 0x30, 0x03, 0x99, 0x3f, 0x81, 0xad, 0x5c, 0x90, 0x44, 0x8b,
-  0x6d, 0x6f, 0x79, 0xa8, 0xc1, 0x92, 0x48, 0x76, 0x46, 0x9c, 0x97, 0xcb,
-  0x85, 0x8b, 0x1d, 0x0c, 0x70, 0xf5, 0x15, 0xa5, 0x0e, 0xb7, 0x02, 0xaa,
-  0x96, 0x2e, 0x17, 0xc2, 0x9a, 0x24, 0xe6, 0xb1, 0x6a, 0xd8, 0x95, 0x3b,
-  0x00, 0x96, 0x05, 0xcd, 0x11, 0xd7, 0x0b, 0xa0, 0x11, 0x90, 0x33, 0xcd,
-  0xe0, 0xf7, 0x0f, 0xe2, 0xe4, 0xcd, 0x95, 0x83, 0x12, 0x3e, 0x32, 0x51,
-  0x2b, 0xc0, 0x32, 0x13, 0xcd, 0x0c, 0xf3, 0x96, 0xf2, 0x88, 0xdf, 0xb9,
-  0x42, 0x91, 0x1a, 0xf4, 0xeb, 0x5d, 0x45, 0x56, 0x35, 0x2c, 0xf1, 0x81,
-  0x49, 0x32, 0x58, 0x0e, 0x20, 0x2c, 0xba, 0xe2, 0xeb, 0xe4, 0x4f, 0x5e,
-  0xc1, 0x43, 0xf3, 0x02, 0x88, 0x8d, 0x33, 0x81, 0x0e, 0x09, 0xab, 0xd3,
-  0x28, 0x97, 0xf4, 0xa8, 0x8a, 0x27, 0x93, 0x20, 0x99, 0x4c, 0x02, 0x04,
-  0x8d, 0xe8, 0xc4, 0x5c, 0x0c, 0x5b, 0xcb, 0xe6, 0x47, 0x9b, 0x3d, 0xfd,
-  0x4e, 0x13, 0x2e, 0x5c, 0x3a, 0xb0, 0x3d, 0x54, 0xd2, 0x34, 0x38, 0x62,
-  0x50, 0x8a, 0x92, 0x71, 0xd7, 0x81, 0x85, 0xd2, 0x07, 0x49, 0xf9, 0xf1,
-  0x0b, 0xd0, 0x37, 0x7b, 0x8a, 0x6c, 0x16, 0x9c, 0x7c, 0x0f, 0x1e, 0x0f,
-  0xb7, 0x58, 0xa6, 0x54, 0x8d, 0x94, 0x4e, 0x5e, 0xa9, 0xea, 0xd4, 0xe1,
-  0xf4, 0xcb, 0x96, 0x30, 0x76, 0x30, 0x5c, 0x2f, 0x89, 0x3b, 0x30, 0x0e,
-  0x7f, 0x63, 0x13, 0xc4, 0xdb, 0xf2, 0x85, 0x06, 0xe3, 0x5b, 0x0a, 0x3f,
-  0x35, 0x24, 0xf8, 0xbe, 0x34, 0xd4, 0xbf, 0x88, 0x6d, 0x51, 0x5c, 0x7f,
-  0xdf, 0x59, 0xe7, 0xf6, 0x68, 0x6d, 0xe9, 0x89, 0x9e, 0xe2, 0xfc, 0x5a,
-  0xf1, 0x58, 0xd4, 0xa9, 0xc6, 0x4a, 0xa2, 0x43, 0x5f, 0x76, 0x36, 0x4a,
-  0x08, 0x25, 0x2e, 0x58, 0x86, 0xc5, 0xa7, 0xa5, 0xa4, 0xf3, 0x69, 0xf6,
-  0x93, 0x58, 0x27, 0x1d, 0x21, 0x06, 0x1c, 0xe7, 0x23, 0x17, 0x90, 0x12,
-  0xfb, 0xbb, 0xcc, 0x90, 0x60, 0xbd, 0xa9, 0x56, 0x2f, 0xb3, 0xe0, 0x35,
-  0xd8, 0xf3, 0x58, 0x13, 0x4e, 0xd4, 0x86, 0x22, 0x5d, 0x59, 0x2d, 0x77,
-  0x01, 0xcc, 0x4a, 0x0a, 0xdf, 0x84, 0x7c, 0xff, 0x4a, 0x93, 0xa3, 0xe9,
-  0x3c, 0x6b, 0xba, 0xbb, 0x02, 0xc5, 0x7c, 0xba, 0xab, 0x96, 0xb8, 0x52,
-  0xa3, 0x54, 0x8b, 0xe8, 0xe0, 0xf2, 0x98, 0x24, 0xdb, 0xeb, 0x39, 0xa7,
-  0x33, 0x63, 0x84, 0xa5, 0xee, 0x0f, 0x0b, 0xd6, 0x58, 0x05, 0x3d, 0x1f,
-  0xe8, 0xf0, 0x3e, 0x78, 0x13, 0xc4, 0xa4, 0x81, 0x01, 0x74, 0xc8, 0x5c,
-  0xf8, 0x19, 0x48, 0x6e, 0x64, 0x58, 0x61, 0xcc, 0x75, 0x90, 0x97, 0x2c,
-  0x24, 0x05, 0x6f, 0x09, 0x75, 0x95, 0x19, 0x50, 0xf4, 0x45, 0x83, 0xad,
-  0x87, 0x08, 0x61, 0xb6, 0xd6, 0x7c, 0xaa, 0x7d, 0x06, 0xc2, 0xdf, 0x0c,
-  0x83, 0x49, 0xfb, 0xaa, 0x78, 0x40, 0x3d, 0x39, 0x75, 0xdb, 0xad, 0x47,
-  0x7f, 0xe3, 0x7b, 0x06, 0xb2, 0x48, 0x5d, 0x2e, 0x48, 0x5c, 0x60, 0xbd,
-  0x18, 0xb2, 0xc7, 0x81, 0xf0, 0x2b, 0x89, 0x79, 0x08, 0xad, 0x16, 0x1b,
-  0x35, 0x84, 0x9f, 0xb8, 0x48, 0xac, 0xc4, 0x0a, 0xab, 0x03, 0x63, 0x3d,
-  0xab, 0xa0, 0x0a, 0x44, 0x09, 0xd3, 0x88, 0x67, 0x82, 0xcc, 0x5a, 0x21,
-  0x8b, 0x76, 0x33, 0xef, 0x47, 0x6e, 0xb6, 0x7e, 0x0c, 0xee, 0x4b, 0x7c,
-  0xf4, 0x2a, 0xea, 0xa8, 0xff, 0x14, 0xa3, 0xe8, 0xa3, 0x23, 0x66, 0xa9,
-  0xec, 0x3e, 0xc5, 0x2f, 0xfc, 0x31, 0x87, 0xbb, 0x19, 0xb2, 0xd5, 0x28,
-  0x9e, 0x07, 0x18, 0x17, 0x99, 0xba, 0x57, 0xfd, 0x40, 0xc4, 0xc7, 0xc7,
-  0x1c, 0x7a, 0x18, 0x8a, 0xc6, 0x41, 0x4d, 0x12, 0x98, 0x72, 0x90, 0xbb,
-  0x6b, 0x07, 0xbe, 0x48, 0x2a, 0x35, 0x4c, 0x5c, 0x86, 0x50, 0xa7, 0xd7,
-  0xa1, 0xb5, 0xd8, 0x9c, 0x4e, 0x3d, 0xc3, 0xb7, 0xc7, 0xb0, 0xab, 0x9c,
-  0x4c, 0xe7, 0x05, 0x26, 0xe5, 0x5d, 0x00, 0xaf, 0x5d, 0x55, 0x32, 0x1b,
-  0x50, 0x1a, 0x00, 0x89, 0x3f, 0x0e, 0x79, 0x83, 0xb3, 0x43, 0x38, 0x4e,
-  0xe0, 0x2e, 0x2d, 0xcc, 0x0f, 0x49, 0xb4, 0x3d, 0xd2, 0xa0, 0x08, 0x49,
-  0xa1, 0x4e, 0xca, 0x51, 0xb0, 0x94, 0xc9, 0xe8, 0x26, 0x93, 0x60, 0x5a,
-  0x5a, 0xb4, 0x20, 0xff, 0xb2, 0x13, 0xfd, 0x87, 0xd2, 0xc0, 0x57, 0x3e,
-  0x59, 0x0f, 0x84, 0xd0, 0x17, 0xc4, 0xa1, 0xbe, 0x27, 0x88, 0xe3, 0x6f,
-  0xaf, 0x2e, 0x0f, 0xa2, 0x2f, 0x8f, 0x0f, 0x8e, 0x8e, 0x2f, 0x07, 0xb5,
-  0x4b, 0x5f, 0xc3, 0x3f, 0x44, 0x42, 0x83, 0x3d, 0x98, 0x45, 0x63, 0xcb,
-  0x56, 0xd7, 0x70, 0x7d, 0xe3, 0x7a, 0xf1, 0x8a, 0x0f, 0x12, 0x9d, 0x0f,
-  0x28, 0x44, 0xe2, 0x38, 0x40, 0x4c, 0x1a, 0xe2, 0x9e, 0xb3, 0xa0, 0x0d,
-  0x2d, 0x0d, 0xea, 0xac, 0xe7, 0x61, 0xa2, 0x8c, 0x07, 0xd3, 0xf1, 0x97,
-  0xc9, 0x38, 0xb3, 0x24, 0xc0, 0xea, 0xce, 0x7d, 0xe9, 0x53, 0xad, 0x03,
-  0xb6, 0xa5, 0x97, 0x8c, 0x1a, 0x10, 0x3b, 0xdf, 0xf6, 0xa8, 0xdf, 0x1e,
-  0x2d, 0x7e, 0x0f, 0x68, 0x44, 0xab, 0xa4, 0xe8, 0xd4, 0xac, 0x81, 0xd5,
-  0xee, 0x37, 0x04, 0xf8, 0xbc, 0x71, 0x92, 0xbe, 0x6c, 0x6d, 0x09, 0xa7,
-  0x6b, 0x0a, 0x38, 0xf2, 0xba, 0x06, 0xc1, 0x97, 0x6a, 0x20, 0x24, 0xeb,
-  0x09, 0x6a, 0x64, 0xb5, 0x68, 0x80, 0x92, 0x57, 0x33, 0x35, 0x28, 0x8c,
-  0x07, 0xa2, 0x53, 0x60, 0x59, 0x27, 0x2d, 0xf5, 0x52, 0x67, 0xbb, 0x48,
-  0xa2, 0x91, 0xfb, 0x34, 0x2c, 0x7d, 0x28, 0xbc, 0x1f, 0xd8, 0x17, 0xa2,
-  0xe1, 0xf9, 0x45, 0xc5, 0x55, 0xaa, 0x76, 0x51, 0x45, 0xb6, 0xd5, 0xe6,
-  0x30, 0x06, 0x47, 0xf3, 0x16, 0xd5, 0x8f, 0x2e, 0x0d, 0x7f, 0x57, 0xdf,
-  0x95, 0x50, 0x30, 0x28, 0xf5, 0x6c, 0xea, 0x44, 0xb0, 0x99, 0x6c, 0xbc,
-  0xc9, 0xab, 0x41, 0x0a, 0x50, 0x48, 0xcc, 0x5c, 0x45, 0x80, 0xc3, 0xc6,
-  0xdd, 0x73, 0x49, 0xf4, 0x65, 0x56, 0xf0, 0x5d, 0xd0, 0x7c, 0x1c, 0x97,
-  0x7c, 0xdb, 0xf2, 0xf3, 0x1b, 0xea, 0xea, 0x72, 0x70, 0x60, 0x8c, 0x9f,
-  0xc7, 0xec, 0xeb, 0xe2, 0xe0, 0xea, 0x4b, 0x76, 0xb4, 0x32, 0x09, 0x1f,
-  0x65, 0x50, 0x78, 0xcc, 0xbd, 0xd6, 0xcc, 0xc4, 0x72, 0x0a, 0x9c, 0xc8,
-  0xbf, 0x86, 0x9c, 0x64, 0xf2, 0x24, 0x3b, 0xf2, 0xd8, 0x44, 0x99, 0x27,
-  0x24, 0xc5, 0xa6, 0x6a, 0x78, 0xac, 0xd6, 0xb8, 0xe0, 0x98, 0x77, 0x97,
-  0x66, 0xe7, 0x82, 0x2e, 0x37, 0x25, 0x07, 0x7d, 0x53, 0xe6, 0xc4, 0x44,
-  0x0f, 0x61, 0x0e, 0x1a, 0x4f, 0x88, 0x32, 0xc7, 0x5f, 0x58, 0xa6, 0x79,
-  0x97, 0xf6, 0xb4, 0x1d, 0x98, 0x28, 0x38, 0xd2, 0x7f, 0x9e, 0xad, 0xfa,
-  0x4d, 0xc4, 0x8b, 0xe8, 0xf3, 0x65, 0x59, 0x65, 0x2b, 0x35, 0xac, 0x3b,
-  0x27, 0x59, 0xe6, 0x59, 0x56, 0x56, 0xd1, 0xe2, 0x78, 0x75, 0xe4, 0x44,
-  0x0b, 0x02, 0x95, 0x8c, 0x05, 0x4d, 0xcd, 0x55, 0xee, 0x0e, 0x05, 0xc3,
-  0x78, 0x58, 0x64, 0xd3, 0x65, 0x19, 0x84, 0x5d, 0xff, 0xb4, 0x31, 0x07,
-  0x83, 0xde, 0x3a, 0xe9, 0x27, 0x46, 0x50, 0x88, 0x1b, 0xce, 0x63, 0xd2,
-  0xf4, 0x51, 0x21, 0x12, 0x7e, 0xc7, 0x3c, 0x9b, 0x57, 0xcb, 0x2e, 0x70,
-  0x84, 0xf7, 0xb6, 0xdf, 0x6b, 0xba, 0x0b, 0x93, 0x7b, 0x48, 0xeb, 0x26,
-  0x11, 0xbf, 0x96, 0x7a, 0xed, 0x52, 0xce, 0xdb, 0x01, 0x7c, 0x30, 0xae,
-  0xc3, 0xc4, 0xd9, 0xb0, 0x50, 0xb1, 0x45, 0xaa, 0x97, 0x88, 0x10, 0xcb,
-  0xe0, 0xdc, 0xe6, 0x2f, 0x94, 0x5c, 0x6e, 0x85, 0x97, 0xa6, 0x2b, 0xb7,
-  0xc8, 0xe4, 0xa7, 0x25, 0xd6, 0x68, 0x40, 0x93, 0xee, 0xb5, 0xea, 0x0c,
-  0x0a, 0x30, 0x9f, 0xcb, 0x5d, 0x6f, 0x21, 0x96, 0x12, 0x3c, 0x66, 0x5e,
-  0x38, 0x1b, 0xa2, 0xdd, 0x78, 0x70, 0xd2, 0x31, 0xc6, 0x12, 0x73, 0xd6,
-  0xc2, 0xd7, 0x07, 0xe4, 0xc4, 0x64, 0x54, 0xf9, 0x30, 0xa9, 0xdd, 0xae,
-  0x0f, 0xcb, 0x55, 0xd8, 0x88, 0x82, 0xc2, 0x4d, 0x32, 0x78, 0xbd, 0xe7,
-  0x38, 0xf9, 0x9b, 0x1d, 0x52, 0xf7, 0x71, 0x5a, 0x86, 0xd7, 0x9f, 0xa9,
-  0xdd, 0xbe, 0xce, 0xfa, 0x70, 0x55, 0x89, 0xc3, 0xf0, 0xd1, 0x89, 0xd7,
-  0x48, 0x65, 0x50, 0xf3, 0x8b, 0x42, 0x66, 0xb0, 0xad, 0xe7, 0x26, 0xd5,
-  0x18, 0x4a, 0x59, 0x73, 0xb3, 0x7d, 0x41, 0x79, 0x67, 0x5b, 0x16, 0xfc,
-  0xe8, 0xde, 0x95, 0xe8, 0xbc, 0xfd, 0xfd, 0x26, 0x69, 0xf4, 0x1d, 0xc0,
-  0x97, 0xb2, 0xcb, 0x93, 0x30, 0x6b, 0x9a, 0x57, 0xc5, 0x45, 0xf6, 0x7e,
-  0x50, 0xd7, 0x61, 0x7f, 0x88, 0xd5, 0x9c, 0x47, 0x7e, 0x3d, 0x0a, 0xe1,
-  0x9b, 0xfb, 0x7b, 0xac, 0x7f, 0x49, 0x94, 0x02, 0xe3, 0x65, 0xa9, 0xd9,
-  0x2e, 0x40, 0x21, 0xa9, 0xae, 0x3b, 0x97, 0x8d, 0x63, 0x38, 0x36, 0x4b,
-  0x28, 0x57, 0xa7, 0xaa, 0x88, 0x3f, 0x81, 0x7b, 0xa5, 0x52, 0x57, 0x40,
-  0x92, 0x94, 0x8b, 0x32, 0x5f, 0x8e, 0x2a, 0xb8, 0x42, 0x4c, 0x0c, 0x15,
-  0x67, 0xb4, 0x5b, 0xde, 0x2c, 0x54, 0x61, 0xb7, 0xe2, 0x4a, 0xc6, 0x86,
-  0x3e, 0x19, 0x76, 0xb1, 0x2d, 0xd5, 0xf0, 0xb4, 0x1e, 0x28, 0x8b, 0xe2,
-  0x34, 0x7e, 0x47, 0x60, 0xbd, 0x0b, 0x97, 0x30, 0x5e, 0x81, 0x67, 0x92,
-  0xe8, 0xfb, 0xe0, 0x8a, 0x51, 0x79, 0x83, 0xef, 0xd7, 0x3c, 0x52, 0xa0,
-  0x28, 0xbe, 0xbd, 0x61, 0x99, 0xdb, 0x70, 0x60, 0x4e, 0xd4, 0x5d, 0xcf,
-  0x97, 0xbf, 0xa3, 0xfe, 0x76, 0x68, 0x21, 0x0d, 0xca, 0xda, 0xe1, 0xa4,
-  0x17, 0x1e, 0x10, 0xaa, 0x16, 0x91, 0x99, 0x4c, 0x13, 0x2e, 0x2f, 0x6f,
-  0xde, 0x57, 0x89, 0x07, 0x90, 0xf5, 0xeb, 0xbb, 0x22, 0x71, 0x56, 0xf5,
-  0xaf, 0x76, 0x6b, 0x36, 0xaf, 0x80, 0x0b, 0x01, 0xdf, 0x68, 0x10, 0xd1,
-  0x91, 0x99, 0x0e, 0x99, 0x9d, 0xf0, 0x82, 0x41, 0x80, 0xb7, 0x4d, 0x3a,
-  0xb9, 0x70, 0x5d, 0xd0, 0x10, 0x30, 0xe3, 0xcd, 0x69, 0xb2, 0xbb, 0x19,
-  0x00, 0xbd, 0x6f, 0x49, 0x80, 0x7b, 0xc6, 0x42, 0x3e, 0xcc, 0x64, 0x3c,
-  0x41, 0x51, 0xd2, 0x11, 0xce, 0xb5, 0xdd, 0x32, 0x14, 0x6a, 0xe2, 0xa7,
-  0x0e, 0x66, 0xef, 0xf9, 0x7e, 0x7f, 0xef, 0xe3, 0x4f, 0xfb, 0xbb, 0xfd,
-  0xbd, 0x5d, 0x70, 0x16, 0x0c, 0x25, 0x18, 0x9c, 0xac, 0x4b, 0x4b, 0x57,
-  0x95, 0xf7, 0x9a, 0x7d, 0x9e, 0x1d, 0x5f, 0x7d, 0x73, 0x7e, 0xf9, 0x55,
-  0x74, 0x72, 0x76, 0x75, 0x7c, 0xf9, 0xfa, 0xe0, 0xf0, 0x43, 0x31, 0x48,
-  0x43, 0xeb, 0x6c, 0x50, 0x04, 0x2c, 0xf1, 0x0b, 0xd3, 0x34, 0x81, 0xf9,
-  0x35, 0x4b, 0xca, 0x9b, 0xdd, 0x17, 0x7b, 0x8f, 0x42, 0x23, 0xb6, 0x58,
-  0xc1, 0xfc, 0xfb, 0x36, 0xa9, 0x3d, 0x4c, 0x6a, 0x7d, 0x2b, 0x0e, 0xac,
-  0x6a, 0x20, 0xd1, 0x44, 0x2e, 0x12, 0x95, 0xf9, 0x3b, 0x23, 0x7d, 0xa7,
-  0xc3, 0x3c, 0x36, 0xfb, 0xcb, 0x50, 0x8a, 0xcb, 0x4b, 0xf2, 0xa8, 0xc2,
-  0x9a, 0x68, 0xa8, 0xb5, 0xb2, 0x5b, 0x44, 0xe2, 0x2e, 0xd3, 0x69, 0xa9,
-  0x56, 0x03, 0x29, 0x06, 0x3c, 0x66, 0x49, 0xc6, 0x18, 0xb2, 0xd5, 0xa7,
-  0xe4, 0xf2, 0x94, 0x5c, 0xf7, 0x46, 0xea, 0x53, 0x8e, 0x5d, 0x4e, 0x84,
-  0xcb, 0xb1, 0xaf, 0x64, 0x96, 0xf0, 0x58, 0xab, 0x35, 0xd3, 0xc2, 0x80,
-  0xd1, 0x1a, 0x4e, 0x5c, 0x61, 0x11, 0xbc, 0x3c, 0xb1, 0x8a, 0x05, 0xf0,
-  0x50, 0x07, 0xc2, 0xa7, 0x21, 0x18, 0x8d, 0x74, 0xc5, 0x72, 0x83, 0x01,
-  0x60, 0x56, 0x91, 0xfa, 0xe4, 0x76, 0xe2, 0x3c, 0x01, 0x11, 0x73, 0x0c,
-  0xa8, 0x17, 0xad, 0x17, 0x15, 0xf4, 0xab, 0x48, 0xb0, 0xd7, 0xc3, 0xd7,
-  0x45, 0xa2, 0xe4, 0x78, 0xc4, 0x71, 0x1e, 0xdf, 0xa3, 0xaa, 0x83, 0x64,
-  0x66, 0xfa, 0xc8, 0xbd, 0x00, 0x40, 0x1e, 0xf2, 0x81, 0x5f, 0xf3, 0xe8,
-  0xe2, 0xf8, 0x4d, 0xcf, 0xea, 0x4e, 0xd1, 0xef, 0x62, 0x73, 0x31, 0x84,
-  0x3f, 0xc9, 0x63, 0x59, 0x24, 0x73, 0x8b, 0x1e, 0x61, 0x9e, 0xa8, 0xe1,
-  0x2e, 0xe1, 0x04, 0x70, 0x68, 0x44, 0xfd, 0x16, 0x5e, 0x8b, 0xc3, 0x68,
-  0x51, 0x86, 0x0e, 0xd7, 0xad, 0x02, 0x54, 0x86, 0xfd, 0xd4, 0x10, 0xdd,
-  0x68, 0xcb, 0x85, 0xa5, 0xa2, 0x3f, 0x8e, 0xbd, 0x64, 0xd7, 0xb8, 0xf3,
-  0x86, 0x67, 0x96, 0x57, 0x7c, 0xf1, 0xd5, 0xe1, 0xe0, 0xa3, 0xbd, 0x7d,
-  0x1d, 0xce, 0xb6, 0x09, 0xbf, 0xe0, 0x55, 0xf5, 0x94, 0x73, 0x66, 0xd7,
-  0xe1, 0x18, 0x2d, 0x81, 0x98, 0x0f, 0x38, 0x6f, 0xc6, 0x96, 0x4b, 0x82,
-  0xd9, 0xae, 0x64, 0xc1, 0x6c, 0x48, 0xe5, 0x3f, 0x93, 0xa4, 0x5c, 0x2d,
-  0x28, 0x58, 0xfe, 0x19, 0xd6, 0x5c, 0xb1, 0xc5, 0x4b, 0x17, 0xdc, 0x16,
-  0xcf, 0xed, 0x23, 0x69, 0x59, 0x5b, 0xe3, 0x0c, 0x69, 0x1f, 0xc0, 0x51,
-  0xdf, 0x73, 0xac, 0xb7, 0xff, 0x16, 0xe0, 0x76, 0x7a, 0xa9, 0x1b, 0x06,
-  0x8d, 0xef, 0x86, 0x0f, 0x80, 0xc6, 0x6b, 0x8f, 0xad, 0x46, 0xc1, 0xdc,
-  0x23, 0x3b, 0xe3, 0xe9, 0x73, 0xda, 0x28, 0x3a, 0x59, 0x82, 0x4a, 0x00,
-  0xa6, 0x20, 0x85, 0xb7, 0xdd, 0x23, 0x47, 0x39, 0x10, 0xb4, 0x17, 0x12,
-  0x39, 0x79, 0xd6, 0x8f, 0xbe, 0x4c, 0xe6, 0x48, 0x0b, 0x47, 0x8c, 0x99,
-  0xe5, 0x19, 0x71, 0x24, 0x1c, 0x4a, 0x91, 0x70, 0xc9, 0x88, 0xd3, 0x24,
-  0x56, 0xac, 0x37, 0xe2, 0x75, 0x85, 0x28, 0x72, 0x06, 0xa5, 0x1e, 0x23,
-  0x1e, 0x8d, 0x6f, 0x22, 0xb5, 0x46, 0x72, 0x3d, 0xb1, 0xb4, 0xd0, 0x06,
-  0xb6, 0xaa, 0x88, 0x6d, 0x8c, 0x51, 0xcb, 0xcd, 0xe9, 0x31, 0x67, 0x97,
-  0x8a, 0x1a, 0x4f, 0xf1, 0x16, 0xc7, 0xe9, 0xc4, 0xa2, 0x58, 0x78, 0xa6,
-  0x32, 0xce, 0x6f, 0xa0, 0xe1, 0x17, 0x74, 0xdd, 0xc4, 0xf3, 0xd1, 0xaa,
-  0x3f, 0x4e, 0x88, 0x80, 0xe8, 0xb4, 0xf5, 0x97, 0xb7, 0x3b, 0xc1, 0x31,
-  0x05, 0xcb, 0xbf, 0x91, 0x0c, 0xf8, 0xaa, 0x7d, 0xd7, 0xca, 0x5f, 0x35,
-  0xc1, 0xa9, 0xe2, 0xca, 0x99, 0x00, 0x49, 0x58, 0x2e, 0xbb, 0x1c, 0xcf,
-  0xb5, 0xb0, 0x4e, 0xc7, 0x91, 0x43, 0x63, 0x44, 0x0b, 0xfd, 0x45, 0x32,
-  0x7b, 0xe1, 0xb2, 0x6d, 0x8d, 0x3f, 0x28, 0x4c, 0xb0, 0x93, 0x9f, 0x03,
-  0x5b, 0xe4, 0x3c, 0xb9, 0x9e, 0xaa, 0x40, 0x11, 0x4a, 0xe8, 0xae, 0x89,
-  0x96, 0x64, 0x07, 0x91, 0xeb, 0xb5, 0xa6, 0xf5, 0x06, 0x1b, 0xcf, 0x66,
-  0x5c, 0x75, 0xc0, 0x18, 0xbf, 0x96, 0x63, 0xf4, 0x8d, 0x28, 0x2e, 0x06,
-  0x03, 0x43, 0x42, 0x0c, 0x56, 0x4b, 0x86, 0xc5, 0xde, 0xa8, 0x97, 0x85,
-  0xbe, 0x15, 0x0a, 0x61, 0x38, 0x51, 0x8d, 0x03, 0x66, 0x1f, 0x9f, 0x95,
-  0x98, 0x92, 0xb3, 0x42, 0x5f, 0xdf, 0x3d, 0x81, 0x61, 0xf7, 0xea, 0x74,
-  0xd0, 0x15, 0x7a, 0x90, 0x2a, 0xec, 0x01, 0xac, 0xb8, 0x27, 0x3f, 0x98,
-  0x39, 0x24, 0x56, 0xcb, 0x8a, 0x5f, 0xe6, 0x32, 0x1a, 0xe1, 0x0c, 0xde,
-  0x23, 0xe4, 0x43, 0xfe, 0x6d, 0x21, 0x34, 0x78, 0x16, 0xc3, 0x31, 0xe4,
-  0x7e, 0x11, 0x88, 0x1c, 0x96, 0x09, 0x10, 0xe2, 0x48, 0x60, 0x7a, 0xd2,
-  0x8d, 0x7a, 0xfb, 0x0c, 0x11, 0xb3, 0x57, 0x5d, 0xc8, 0x18, 0x90, 0xfa,
-  0xf1, 0x88, 0x8b, 0x84, 0x6c, 0xb8, 0x9a, 0xc3, 0xc6, 0x12, 0xb6, 0x94,
-  0xac, 0xef, 0xe8, 0x7d, 0xfc, 0xd8, 0xd7, 0x49, 0xdd, 0xed, 0x71, 0x9c,
-  0x32, 0xe4, 0xd1, 0xbb, 0x64, 0xba, 0x6a, 0x8a, 0x0d, 0xfb, 0x8f, 0xee,
-  0x2c, 0x67, 0x04, 0xdc, 0xa7, 0x0e, 0xf9, 0x52, 0x00, 0x7c, 0xd9, 0xea,
-  0x87, 0x93, 0x4d, 0x7b, 0x65, 0x03, 0xa0, 0x65, 0x54, 0x7b, 0xee, 0x3c,
-  0xba, 0xdb, 0x37, 0xb7, 0x2a, 0xbe, 0xb1, 0xc5, 0x13, 0xbb, 0xb4, 0x67,
-  0x24, 0x8d, 0x34, 0x3d, 0xc4, 0x76, 0x05, 0x94, 0x8b, 0x04, 0x1f, 0xa2,
-  0x5b, 0xe2, 0x24, 0x15, 0x4e, 0x03, 0x05, 0xaa, 0x74, 0x48, 0x3b, 0xd8,
-  0x7e, 0x06, 0xe6, 0x24, 0x59, 0xd8, 0x47, 0xf4, 0x70, 0xbc, 0x33, 0x9f,
-  0x69, 0x92, 0x60, 0x8b, 0xe5, 0x4c, 0xeb, 0x9d, 0x30, 0x23, 0xee, 0xf2,
-  0x75, 0x5b, 0x46, 0xc4, 0x89, 0x53, 0x89, 0x6f, 0x9b, 0xb2, 0x30, 0xcd,
-  0x02, 0x96, 0x5a, 0x06, 0xfd, 0x42, 0xc1, 0xdc, 0x23, 0xa8, 0x71, 0x4c,
-  0x2f, 0x37, 0xa9, 0x28, 0xec, 0x1c, 0x8e, 0xc9, 0x0b, 0x46, 0xac, 0x62,
-  0x33, 0xa2, 0xd3, 0xb7, 0x44, 0xa3, 0x65, 0xc6, 0xf1, 0x9e, 0x4e, 0x60,
-  0xd0, 0x9c, 0xb1, 0x01, 0x4b, 0x9d, 0xd1, 0x66, 0xc8, 0x24, 0x7b, 0x9f,
-  0x61, 0x11, 0x8a, 0x4d, 0xbf, 0x6a, 0x0a, 0xe6, 0x5a, 0x5d, 0x02, 0x75,
-  0x06, 0xd0, 0x7a, 0x4b, 0x53, 0x17, 0xb9, 0x95, 0xec, 0xdb, 0x4c, 0x1e,
-  0x20, 0x22, 0x6d, 0x5a, 0xbf, 0xf2, 0xbd, 0xe4, 0xbc, 0xf3, 0xfa, 0x5e,
-  0x9c, 0x9c, 0x49, 0x11, 0x3a, 0x77, 0x96, 0x12, 0x48, 0xde, 0xf2, 0x9c,
-  0x08, 0xc2, 0x62, 0xce, 0x86, 0x8b, 0x4e, 0x0c, 0x2c, 0x20, 0x38, 0x1c,
-  0x92, 0xd4, 0xba, 0xbb, 0x5c, 0xca, 0x08, 0x36, 0x71, 0x53, 0x16, 0xc5,
-  0x74, 0xb3, 0x56, 0x4f, 0xc9, 0xed, 0x68, 0xed, 0x4a, 0x72, 0xa6, 0x9b,
-  0xd1, 0x38, 0x2c, 0x1d, 0xa9, 0xad, 0x54, 0x38, 0x65, 0xb7, 0x96, 0x17,
-  0x18, 0xda, 0x8c, 0x3f, 0x8a, 0xfa, 0x3b, 0xd4, 0x61, 0xb1, 0x63, 0x2f,
-  0x2e, 0x6e, 0x47, 0x05, 0xdd, 0x91, 0x48, 0x82, 0xfd, 0x9e, 0xb5, 0x70,
-  0x36, 0x31, 0xd1, 0x90, 0xc7, 0x3f, 0x44, 0xbd, 0xd1, 0x54, 0x66, 0xc8,
-  0x15, 0xdc, 0xbe, 0x27, 0xba, 0xc1, 0x13, 0x3f, 0x6c, 0x20, 0x21, 0x6c,
-  0xf0, 0xf6, 0x0d, 0x70, 0x9b, 0xb9, 0x3e, 0xd6, 0xd5, 0xe5, 0xc1, 0xd9,
-  0xe0, 0xb5, 0x98, 0x15, 0xaf, 0xb2, 0xa0, 0xec, 0x96, 0xda, 0x64, 0xcd,
-  0xf7, 0xe6, 0xa0, 0xb5, 0xee, 0x05, 0x4c, 0xd8, 0xc2, 0x92, 0xb5, 0x26,
-  0x57, 0xb7, 0x0e, 0x38, 0x2b, 0x25, 0xbd, 0x98, 0x61, 0xd3, 0x89, 0xda,
-  0x2a, 0xb6, 0xdd, 0xed, 0x5a, 0x84, 0xb5, 0x0b, 0x3c, 0xa8, 0x9b, 0x68,
-  0x29, 0xee, 0x21, 0x9c, 0x99, 0x43, 0x1b, 0x8c, 0x7d, 0x2a, 0x0c, 0x7d,
-  0x2d, 0x86, 0xe2, 0x21, 0xe9, 0x1f, 0x3d, 0x85, 0xe1, 0x0e, 0x2a, 0x35,
-  0x38, 0x53, 0x94, 0x30, 0x74, 0x85, 0x3f, 0x73, 0x8d, 0x87, 0x39, 0x73,
-  0xd6, 0xf4, 0xd6, 0xef, 0xf7, 0xb6, 0xdb, 0x9b, 0xbf, 0xfa, 0xa9, 0xcd,
-  0xb7, 0x8f, 0xdd, 0x04, 0x7e, 0x9f, 0x99, 0xb1, 0xf5, 0xfb, 0xfd, 0xed,
-  0x47, 0x67, 0x14, 0x26, 0x95, 0xf9, 0x3e, 0xe9, 0x0d, 0x0c, 0x36, 0x7a,
-  0x65, 0xe5, 0x16, 0xf5, 0x22, 0x76, 0xd1, 0x0d, 0x13, 0x0f, 0xeb, 0x56,
-  0x41, 0x39, 0x40, 0xf4, 0xab, 0x13, 0xff, 0xbc, 0xd3, 0x42, 0x83, 0xf4,
-  0x4f, 0xfe, 0xcb, 0x71, 0x08, 0x87, 0x47, 0xda, 0x78, 0xc8, 0xf3, 0x90,
-  0x5e, 0x5d, 0x64, 0x7d, 0xee, 0x7b, 0xff, 0x91, 0xbe, 0xfd, 0xec, 0x02,
-  0x5d, 0x17, 0x1e, 0x40, 0x84, 0x10, 0x41, 0x1a, 0xdf, 0x21, 0xed, 0x42,
-  0xfb, 0xd9, 0xf0, 0xf5, 0xdc, 0xd6, 0xf7, 0x77, 0x75, 0xf2, 0xe6, 0x18,
-  0x95, 0x43, 0x8e, 0x4e, 0x80, 0xd7, 0x35, 0x50, 0xc8, 0x3c, 0x53, 0x6b,
-  0x1d, 0x90, 0x68, 0x08, 0xa6, 0x2d, 0xae, 0x31, 0x17, 0xa9, 0xe3, 0xce,
-  0xbf, 0xdb, 0x09, 0x74, 0xad, 0xa1, 0xa4, 0x85, 0x25, 0xac, 0x9d, 0x4c,
-  0x7a, 0x6f, 0xb2, 0x31, 0xab, 0x5e, 0x3d, 0x81, 0x0e, 0xa6, 0xb7, 0xe8,
-  0xc3, 0xb7, 0xf3, 0x59, 0xe5, 0xe3, 0x30, 0x2d, 0x4e, 0xb5, 0xea, 0x8d,
-  0x75, 0x80, 0xe3, 0x3f, 0xee, 0xf4, 0x7a, 0x5c, 0x52, 0x51, 0x22, 0x62,
-  0xd4, 0x2e, 0x5e, 0xc1, 0x34, 0xb0, 0xb3, 0x4f, 0xeb, 0x93, 0x4e, 0x57,
-  0xe2, 0xc3, 0x8d, 0x7d, 0xe4, 0x8d, 0xcf, 0x81, 0xbb, 0xe6, 0x4a, 0xe1,
-  0xce, 0x62, 0x24, 0x36, 0xa1, 0x8d, 0x0a, 0x1a, 0x23, 0x84, 0xf3, 0xe4,
-  0xde, 0x87, 0x8e, 0x68, 0xd1, 0xaa, 0x6c, 0xb1, 0xe2, 0x49, 0xde, 0x57,
-  0xbc, 0xd2, 0xad, 0xae, 0xa9, 0x1f, 0xe5, 0x9d, 0x0a, 0xc4, 0xbe, 0xf4,
-  0x10, 0x12, 0xa0, 0x7e, 0xa2, 0x88, 0xf4, 0xe7, 0x79, 0xc0, 0xc0, 0x74,
-  0xd8, 0x56, 0x02, 0x22, 0xc0, 0x67, 0x0c, 0x80, 0x25, 0xab, 0xe3, 0xf4,
-  0x98, 0x92, 0x1b, 0xb8, 0xdb, 0xfa, 0x30, 0x13, 0x9b, 0x5f, 0x81, 0xb8,
-  0xce, 0xa2, 0x5a, 0x19, 0x2a, 0x89, 0x2c, 0x3f, 0x56, 0x72, 0xa0, 0x37,
-  0x7b, 0x9b, 0x8c, 0x7e, 0x9c, 0xce, 0x5b, 0x26, 0xd3, 0xfb, 0xe9, 0xb3,
-  0x69, 0x78, 0xad, 0xa2, 0xce, 0x04, 0x40, 0x02, 0x70, 0x01, 0x74, 0x64,
-  0x00, 0x82, 0xad, 0x21, 0xb4, 0x45, 0x42, 0x3d, 0xd8, 0x9a, 0x29, 0x27,
-  0xa2, 0xa8, 0xb9, 0xa0, 0x42, 0x67, 0x2b, 0x15, 0x4b, 0x17, 0xf8, 0xe8,
-  0x72, 0x31, 0x66, 0x7f, 0xb6, 0x44, 0xf2, 0xfd, 0xa7, 0x78, 0xbe, 0x8c,
-  0xf3, 0x55, 0xb4, 0xb7, 0xdf, 0x8d, 0xf6, 0x77, 0xf7, 0xf6, 0x5b, 0xe6,
-  0xd0, 0xf9, 0x4f, 0x88, 0x27, 0xd9, 0xe7, 0xaf, 0x3b, 0x1f, 0x3a, 0x0b,
-  0x1f, 0x15, 0xce, 0x37, 0xab, 0xe6, 0x4f, 0x12, 0xef, 0x81, 0x6b, 0x4b,
-  0x4a, 0x48, 0xa2, 0x7c, 0x14, 0x03, 0x80, 0xb1, 0x60, 0x21, 0x86, 0x27,
-  0xab, 0x44, 0xe3, 0xca, 0x22, 0xe0, 0x89, 0x8d, 0x68, 0x74, 0x93, 0x28,
-  0x86, 0xb7, 0xb7, 0xbe, 0xc5, 0x39, 0x97, 0xd9, 0xa9, 0xee, 0x51, 0x5a,
-  0xda, 0xb6, 0x20, 0x2a, 0x01, 0x7b, 0x43, 0xf4, 0x7e, 0x74, 0x72, 0x78,
-  0x65, 0x08, 0x71, 0x13, 0x5c, 0xa7, 0xf9, 0xea, 0xc3, 0x2a, 0x96, 0x3c,
-  0xfa, 0xcc, 0xf8, 0xc5, 0x4d, 0x42, 0x62, 0xd9, 0x7c, 0xb8, 0xbc, 0x7e,
-  0xf1, 0xd7, 0x38, 0xbf, 0x0e, 0xaa, 0x4e, 0xaf, 0x79, 0x7e, 0xcc, 0x69,
-  0x39, 0x2f, 0x88, 0x41, 0xed, 0x3d, 0xdf, 0x7b, 0x22, 0x31, 0xdf, 0x29,
-  0xea, 0x1b, 0x31, 0x7f, 0xd8, 0x9c, 0x6d, 0x0a, 0x40, 0x01, 0x07, 0x9b,
-  0x3b, 0x54, 0x82, 0xf9, 0x78, 0x53, 0x74, 0xae, 0x38, 0x7c, 0x76, 0xac,
-  0xcf, 0x4a, 0xfe, 0xee, 0x26, 0xe3, 0x62, 0xd0, 0xe3, 0x48, 0x76, 0x5b,
-  0x2e, 0x36, 0xfb, 0x95, 0x13, 0xfe, 0x9e, 0xb9, 0xa2, 0x0b, 0x57, 0xa0,
-  0xe5, 0x50, 0x78, 0xb2, 0xb2, 0xd3, 0x61, 0x9e, 0xc4, 0xb7, 0xbe, 0xae,
-  0x94, 0x47, 0x2f, 0x30, 0xfb, 0xf9, 0xe5, 0xeb, 0x43, 0x01, 0x7d, 0xb4,
-  0xac, 0x13, 0x5e, 0x6a, 0x5f, 0x22, 0x7e, 0x1b, 0xa3, 0x7c, 0x4f, 0xff,
-  0x08, 0x0b, 0x7f, 0x31, 0x1e, 0x7e, 0xc0, 0x43, 0x74, 0xee, 0x04, 0x5e,
-  0xeb, 0xa0, 0x0a, 0x3d, 0x0f, 0xc1, 0xbf, 0x04, 0xa9, 0x71, 0x09, 0x33,
-  0xa2, 0x82, 0x2d, 0x29, 0xd7, 0x24, 0x06, 0x6c, 0xa9, 0xcc, 0xae, 0xf5,
-  0x2c, 0xd5, 0x62, 0x40, 0xe3, 0x46, 0x2d, 0xa4, 0xa3, 0x83, 0x8b, 0x40,
-  0x79, 0x62, 0xe5, 0xc4, 0x1b, 0x8a, 0xf0, 0x1c, 0x04, 0x67, 0x2e, 0x44,
-  0x27, 0xf6, 0xa4, 0x55, 0xd7, 0x8b, 0xbc, 0x25, 0xf3, 0xc9, 0xf1, 0x5d,
-  0x2c, 0xb1, 0xc5, 0x99, 0x5e, 0x27, 0x6c, 0xd3, 0x60, 0xec, 0xea, 0xe9,
-  0x38, 0x66, 0x1f, 0x92, 0x5e, 0x42, 0x2c, 0x8f, 0x73, 0x5b, 0xa9, 0x06,
-  0x92, 0xd0, 0xde, 0x3c, 0x44, 0x1a, 0xff, 0xae, 0x81, 0xfe, 0xf2, 0xbb,
-  0x3c, 0x86, 0xdc, 0xce, 0x95, 0x4d, 0x40, 0xf8, 0x33, 0x0d, 0x3e, 0x2e,
-  0x6e, 0x89, 0x95, 0x8a, 0xef, 0x93, 0x7a, 0x4f, 0x47, 0x89, 0x19, 0x56,
-  0xc7, 0xa9, 0xc4, 0x20, 0xc0, 0xa4, 0xc1, 0xd8, 0x31, 0x95, 0x0d, 0x93,
-  0x1b, 0x08, 0x1a, 0xcc, 0xb4, 0x48, 0x04, 0xe7, 0x2d, 0xba, 0xba, 0xcf,
-  0x44, 0xea, 0x74, 0xb9, 0xf5, 0x12, 0xc5, 0x57, 0x2c, 0x53, 0x81, 0x8a,
-  0xa0, 0xcd, 0x63, 0x7e, 0x10, 0x14, 0x5b, 0xea, 0x38, 0x6b, 0xca, 0x91,
-  0x73, 0x19, 0x0d, 0x8e, 0xbe, 0x8a, 0x90, 0x95, 0x8c, 0x3e, 0x0e, 0x81,
-  0x1f, 0x0f, 0xef, 0xef, 0x8c, 0xb5, 0x89, 0x2f, 0x96, 0x38, 0xef, 0x87,
-  0x37, 0xf1, 0x02, 0x42, 0xf1, 0xde, 0x2e, 0x54, 0xf0, 0x6f, 0x2c, 0xbf,
-  0x09, 0x07, 0xd5, 0xca, 0xfc, 0x15, 0x9d, 0x40, 0x3b, 0x1f, 0xa3, 0x4e,
-  0x1f, 0x84, 0xe2, 0xaa, 0xe1, 0x8f, 0x6e, 0xcf, 0x62, 0x67, 0x06, 0x86,
-  0x35, 0x2d, 0x88, 0x34, 0xf2, 0x62, 0x7c, 0xbb, 0x33, 0xa2, 0x7f, 0x9e,
-  0xec, 0xee, 0x30, 0xf4, 0x60, 0xc9, 0x76, 0x32, 0xd0, 0xe4, 0xfe, 0xfe,
-  0xb3, 0x67, 0xdd, 0xa8, 0x03, 0xcb, 0x95, 0x75, 0x80, 0x23, 0x41, 0x27,
-  0xab, 0xd3, 0x56, 0x75, 0x6a, 0x27, 0x9f, 0x8c, 0xf0, 0x1f, 0x5e, 0xb3,
-  0x92, 0x3b, 0x57, 0x9a, 0xb0, 0xc0, 0xeb, 0x30, 0x0f, 0xb1, 0x45, 0x8c,
-  0xac, 0xee, 0x69, 0x1f, 0xcc, 0x36, 0x01, 0x37, 0xc4, 0x22, 0xc9, 0x16,
-  0xe6, 0x58, 0x9b, 0xad, 0xf4, 0xba, 0x61, 0x1a, 0x8b, 0x2a, 0xc9, 0x8a,
-  0x37, 0x12, 0x49, 0xa4, 0xa9, 0xe4, 0xc5, 0x72, 0xd8, 0xd3, 0x9c, 0x4a,
-  0xd1, 0x35, 0x52, 0x3a, 0xb9, 0x33, 0xd4, 0xa7, 0x56, 0x13, 0x70, 0x83,
-  0x23, 0x7f, 0x1e, 0x75, 0x94, 0xb6, 0xf0, 0xa3, 0xcf, 0x7e, 0xb1, 0x64,
-  0x84, 0x69, 0x64, 0xaf, 0xf4, 0x8f, 0x3f, 0xfd, 0x89, 0x9a, 0xfd, 0x13,
-  0x5a, 0x79, 0xf5, 0xfb, 0xa2, 0xbc, 0x09, 0x9e, 0xe9, 0x28, 0xc1, 0x9f,
-  0x78, 0xaf, 0x20, 0x47, 0xfa, 0x30, 0x30, 0x27, 0xa7, 0xfe, 0xbc, 0x39,
-  0x55, 0x8e, 0xdc, 0x0d, 0xe6, 0x97, 0x72, 0x52, 0x96, 0x18, 0xde, 0x9c,
-  0xa3, 0xfd, 0x73, 0x78, 0xec, 0x12, 0x24, 0xf3, 0x12, 0x15, 0x32, 0xf2,
-  0xda, 0xb6, 0x89, 0x18, 0xc7, 0x67, 0x5f, 0x9f, 0x5c, 0x9e, 0x9f, 0xbd,
-  0x39, 0x3e, 0xbb, 0x8a, 0xbe, 0x3e, 0xb8, 0x3c, 0x39, 0xf8, 0xfc, 0x54,
-  0x73, 0x86, 0x31, 0x05, 0xc4, 0x47, 0x88, 0xe8, 0x5d, 0xc3, 0xcd, 0x0c,
-  0x72, 0x38, 0x5a, 0x81, 0xe2, 0x6b, 0xc5, 0xc3, 0xde, 0x29, 0x12, 0x33,
-  0xdb, 0x58, 0xdf, 0x71, 0xb1, 0x81, 0x2e, 0x9c, 0x7e, 0xef, 0xac, 0xee,
-  0x00, 0x6c, 0x97, 0xab, 0x20, 0x0b, 0x15, 0xa1, 0x1b, 0xa0, 0x52, 0xe3,
-  0x4f, 0xbe, 0xce, 0x89, 0x42, 0xd9, 0xf7, 0xa3, 0x2f, 0x24, 0x91, 0x59,
-  0x83, 0x88, 0xdc, 0xab, 0x9a, 0x54, 0xa3, 0xb6, 0x1c, 0xf9, 0x9f, 0xfb,
-  0xe5, 0xe0, 0xf4, 0xd4, 0x77, 0x79, 0x20, 0x82, 0x6d, 0xcf, 0xe7, 0x03,
-  0x5b, 0x51, 0x2e, 0xae, 0x79, 0x2f, 0x30, 0x36, 0x92, 0xff, 0xc2, 0x8d,
-  0xc3, 0xe9, 0x74, 0x9d, 0x79, 0x78, 0xe9, 0xf9, 0x2a, 0x44, 0x92, 0x46,
-  0xa7, 0xb4, 0x2d, 0x5b, 0x82, 0x42, 0x00, 0xdf, 0x23, 0x1d, 0xa4, 0xb4,
-  0xb8, 0xed, 0x46, 0x9b, 0xbf, 0xdf, 0x94, 0xbc, 0xa4, 0x84, 0x61, 0x56,
-  0xb9, 0xf5, 0xc2, 0xd7, 0x0b, 0x8c, 0xce, 0xce, 0xfd, 0x98, 0x4e, 0x38,
-  0x0e, 0x1e, 0x44, 0xc5, 0x61, 0x8f, 0xb9, 0x83, 0xf0, 0x49, 0x34, 0x9f,
-  0xb7, 0xc7, 0xae, 0x6d, 0x09, 0xcf, 0xe6, 0x61, 0x5a, 0xcb, 0xde, 0x59,
-  0x5a, 0x24, 0x0e, 0xfb, 0x90, 0x91, 0x75, 0x49, 0x47, 0x8b, 0x47, 0x01,
-  0x6a, 0xae, 0x98, 0x6e, 0xa0, 0xed, 0xf2, 0xb5, 0xaf, 0x75, 0x44, 0x65,
-  0x5d, 0x61, 0x14, 0x52, 0x7f, 0xd4, 0xb2, 0x50, 0x76, 0xc9, 0x24, 0xf4,
-  0xb0, 0xa3, 0xc0, 0xd5, 0xe2, 0xa4, 0x42, 0xdc, 0x74, 0x9e, 0x8e, 0x15,
-  0x84, 0xad, 0x95, 0x04, 0xfa, 0xec, 0xdb, 0xb8, 0x3c, 0x64, 0xc8, 0xea,
-  0x39, 0xaa, 0xcb, 0x38, 0x84, 0x7f, 0x89, 0xb1, 0x24, 0x96, 0x91, 0x23,
-  0x71, 0x69, 0xae, 0x12, 0x07, 0xc7, 0x2d, 0xb2, 0x3c, 0x1e, 0x5f, 0x67,
-  0x26, 0x6b, 0xc7, 0xce, 0xe1, 0x2a, 0x09, 0x49, 0x12, 0x92, 0x62, 0x22,
-  0x97, 0x43, 0x59, 0x72, 0x36, 0x2f, 0x76, 0xcd, 0x9a, 0x85, 0x19, 0x61,
-  0x38, 0x65, 0x00, 0x08, 0x5f, 0x04, 0xd9, 0xac, 0x3e, 0xca, 0x1b, 0x8c,
-  0x43, 0x9c, 0x92, 0x06, 0x7b, 0xc4, 0xe0, 0x52, 0x96, 0xfd, 0xca, 0x01,
-  0x61, 0x3c, 0x2c, 0x3c, 0xc8, 0x4d, 0x6a, 0x6c, 0x1f, 0x37, 0x69, 0xc6,
-  0x4f, 0x3a, 0x2a, 0x53, 0x24, 0xda, 0x18, 0xdb, 0x89, 0xa3, 0x61, 0x7a,
-  0x1d, 0x99, 0xdd, 0x23, 0x02, 0x29, 0x30, 0x04, 0x56, 0x36, 0x4b, 0xb0,
-  0x55, 0x0c, 0x70, 0xc5, 0x82, 0xfa, 0x0d, 0x2a, 0x2d, 0x7b, 0x44, 0x26,
-  0x9b, 0x49, 0x81, 0x40, 0xf4, 0xc0, 0x6e, 0xc6, 0xb6, 0xf3, 0x25, 0xd6,
-  0xd1, 0xa2, 0x76, 0x14, 0xbd, 0x59, 0x63, 0x98, 0x60, 0x94, 0x65, 0x2c,
-  0xb9, 0x39, 0x67, 0x4c, 0x58, 0xf6, 0x29, 0xaf, 0x83, 0xc5, 0x77, 0x82,
-  0x35, 0xb0, 0x29, 0x25, 0x99, 0x4e, 0xa2, 0x2d, 0x07, 0xbf, 0x8c, 0x56,
-  0x46, 0x82, 0x5f, 0x09, 0xca, 0x96, 0xf0, 0xeb, 0x4a, 0x99, 0x04, 0xdb,
-  0x2c, 0xc5, 0x19, 0x9a, 0x48, 0x79, 0x68, 0x1a, 0xdf, 0x56, 0xc0, 0x65,
-  0xe6, 0x44, 0x22, 0xf2, 0x98, 0x28, 0x8b, 0xfa, 0x57, 0x4f, 0xfc, 0x95,
-  0xb1, 0x55, 0xf5, 0x29, 0xb6, 0xbd, 0xcf, 0x5a, 0xae, 0x7c, 0xd0, 0xaa,
-  0xa4, 0xa1, 0xa8, 0x58, 0x4c, 0xfb, 0x65, 0xa6, 0xa7, 0xd0, 0x72, 0x15,
-  0x59, 0x62, 0xc2, 0x74, 0x1a, 0xe0, 0x2f, 0x8b, 0xed, 0x21, 0x6e, 0x48,
-  0x1a, 0xae, 0xc8, 0xf3, 0x81, 0x86, 0x48, 0x08, 0x56, 0x6b, 0x30, 0x13,
-  0x0d, 0xbe, 0x85, 0x2c, 0x56, 0x33, 0x88, 0x05, 0xec, 0xcb, 0xfc, 0xab,
-  0xe1, 0x35, 0xa4, 0x25, 0x00, 0xd2, 0x78, 0x26, 0x92, 0xa2, 0x27, 0xbf,
-  0xd9, 0x4a, 0xc2, 0xb3, 0x36, 0x36, 0x0e, 0xdf, 0x0e, 0xae, 0xce, 0xdf,
-  0x44, 0xe7, 0x6f, 0xaf, 0x2e, 0xde, 0x5e, 0xe9, 0x3d, 0x35, 0x94, 0x00,
-  0x56, 0x51, 0x08, 0xe5, 0xca, 0xb7, 0xdd, 0x9c, 0xa9, 0xd3, 0x98, 0xc3,
-  0x13, 0x32, 0xc6, 0x5d, 0x0b, 0x40, 0x58, 0x5c, 0xf2, 0x0a, 0x63, 0x12,
-  0x09, 0x9c, 0x2b, 0xaf, 0xf9, 0x3d, 0xad, 0x39, 0x27, 0x1e, 0xb2, 0x21,
-  0xc7, 0x72, 0x61, 0x58, 0xc9, 0x69, 0x2f, 0xa7, 0xb1, 0xaa, 0x2a, 0x2d,
-  0xec, 0xde, 0xad, 0x82, 0xdd, 0xf8, 0x80, 0x13, 0x33, 0xe4, 0x78, 0x3b,
-  0x4f, 0x18, 0xfb, 0xc6, 0x51, 0x1f, 0xa3, 0xd2, 0xcc, 0x97, 0x16, 0x7e,
-  0xc8, 0x81, 0x26, 0xd5, 0x0c, 0xac, 0x30, 0x11, 0xac, 0xcc, 0x68, 0x86,
-  0x37, 0x2e, 0x74, 0x18, 0x51, 0xd2, 0x1c, 0x32, 0x25, 0x2e, 0x78, 0xc4,
-  0x26, 0x59, 0x8d, 0xe6, 0x7b, 0x18, 0xbd, 0x1b, 0x77, 0xea, 0x7d, 0xb4,
-  0xf9, 0x4d, 0x12, 0x36, 0xf8, 0xdb, 0xbf, 0x23, 0xbf, 0xed, 0x9d, 0x7d,
-  0xf2, 0x0f, 0xe9, 0xf2, 0x2f, 0xf3, 0x4d, 0x8e, 0x34, 0xaa, 0xfa, 0x5a,
-  0xbf, 0x3a, 0xbe, 0xfc, 0xfc, 0xf8, 0xf2, 0x7c, 0xc0, 0xf1, 0x26, 0x66,
-  0xdb, 0x6a, 0x12, 0xfb, 0x6d, 0x92, 0x0f, 0x93, 0x3c, 0xd3, 0x0a, 0x29,
-  0xf6, 0xd7, 0xb3, 0x9d, 0x2f, 0x06, 0x83, 0x83, 0x8b, 0x13, 0x57, 0x4c,
-  0xc3, 0x65, 0xda, 0x88, 0x42, 0x34, 0x97, 0x5c, 0x30, 0xcc, 0xdf, 0x5e,
-  0x21, 0xba, 0x18, 0xdd, 0x4a, 0x04, 0x66, 0xc3, 0xab, 0x69, 0x56, 0x59,
-  0xb8, 0x33, 0x35, 0x01, 0x0b, 0x0d, 0x1b, 0x78, 0xce, 0x46, 0x50, 0xa5,
-  0xfc, 0x35, 0x8c, 0xc8, 0x5d, 0x17, 0xa5, 0x74, 0x9b, 0x0f, 0x7b, 0x44,
-  0xe8, 0xb7, 0x56, 0x7c, 0x4e, 0x62, 0xc5, 0x89, 0x4d, 0x4a, 0x10, 0xa9,
-  0x37, 0x2a, 0xdc, 0xa2, 0x20, 0xe4, 0xce, 0x2d, 0x8e, 0x06, 0xea, 0x3f,
-  0x4c, 0xfb, 0xc2, 0xd9, 0xe5, 0x2c, 0x59, 0x64, 0x20, 0xd8, 0xeb, 0x63,
-  0xb9, 0xfc, 0xd4, 0x9b, 0x2b, 0x24, 0x24, 0x76, 0x2d, 0xfa, 0xe4, 0xa9,
-  0x03, 0x33, 0x0a, 0x6b, 0x05, 0x4e, 0x48, 0xd2, 0x5e, 0xdc, 0x8f, 0xf5,
-  0x02, 0x61, 0xfc, 0xde, 0xb9, 0xd8, 0xb5, 0x85, 0x7f, 0xd7, 0xbd, 0x1b,
-  0xa8, 0x7c, 0xc4, 0x41, 0xed, 0x1a, 0xb2, 0x1b, 0x0d, 0xa7, 0xf1, 0xfc,
-  0x96, 0x6f, 0x32, 0xbe, 0x99, 0xa0, 0x5b, 0x1a, 0x54, 0x0f, 0xea, 0x44,
-  0xb1, 0x33, 0x4b, 0xb3, 0xe7, 0x59, 0xda, 0xb3, 0xba, 0xc2, 0x30, 0xe4,
-  0x3a, 0x44, 0xa2, 0xc0, 0x6d, 0xc3, 0x27, 0xc9, 0x2f, 0x02, 0x4c, 0x44,
-  0x5c, 0x70, 0xdd, 0x05, 0xe2, 0xb3, 0x2e, 0x2e, 0x15, 0xd5, 0x2d, 0x9c,
-  0x44, 0x72, 0xcf, 0x52, 0x66, 0x62, 0xc2, 0x38, 0x0c, 0x5a, 0x9a, 0x1d,
-  0x0f, 0x4c, 0x29, 0x9c, 0x62, 0x57, 0xb8, 0x0a, 0x0c, 0xca, 0xb5, 0xb5,
-  0xac, 0x74, 0x59, 0x29, 0xc8, 0x10, 0x56, 0xeb, 0x50, 0xa4, 0xeb, 0x43,
-  0x1f, 0x4c, 0x12, 0xdb, 0x77, 0x32, 0x08, 0x2f, 0x7f, 0x3a, 0xf7, 0x54,
-  0x25, 0x03, 0x60, 0xed, 0x36, 0xc9, 0xeb, 0x6d, 0xda, 0x3e, 0x33, 0x40,
-  0x6a, 0x40, 0x8c, 0xdd, 0x0e, 0x3d, 0xc5, 0xc2, 0x3a, 0xab, 0xa1, 0x94,
-  0x36, 0xf0, 0xbe, 0x55, 0x2f, 0xe6, 0x80, 0x27, 0xf1, 0x38, 0x71, 0x18,
-  0xa0, 0xde, 0xbe, 0xe5, 0x98, 0xb9, 0x4d, 0x5e, 0x81, 0xf1, 0x0c, 0x23,
-  0x18, 0x25, 0xc1, 0x9f, 0x6d, 0x80, 0x12, 0xd3, 0xce, 0xea, 0x8a, 0x13,
-  0x64, 0x7b, 0x67, 0xb8, 0x2a, 0xb2, 0xde, 0x70, 0xc9, 0x0a, 0x98, 0x87,
-  0xa2, 0xd2, 0x3c, 0x37, 0xd4, 0x03, 0x65, 0xec, 0x29, 0xfe, 0x1e, 0x8e,
-  0x0c, 0xce, 0x20, 0x16, 0xdf, 0x06, 0xa7, 0x94, 0x55, 0x71, 0x49, 0x1c,
-  0x1a, 0x85, 0xc4, 0x69, 0x73, 0xbc, 0xaa, 0x06, 0xe5, 0xea, 0x08, 0x75,
-  0x93, 0x5d, 0x8c, 0xd9, 0x5c, 0xcb, 0x99, 0xb1, 0x51, 0xbd, 0x1a, 0x95,
-  0x5a, 0x3a, 0x28, 0xf0, 0x2b, 0x16, 0x11, 0x12, 0x05, 0xc8, 0xb6, 0x70,
-  0x53, 0x0b, 0x6e, 0xbf, 0x2b, 0x51, 0xf8, 0x46, 0x12, 0xe9, 0xe3, 0xa9,
-  0x94, 0x30, 0x58, 0x7b, 0x8b, 0xc8, 0x61, 0x2a, 0xaf, 0xae, 0xbe, 0xbb,
-  0x38, 0x7e, 0x65, 0x6f, 0x3e, 0xb6, 0x67, 0x82, 0x2f, 0xc5, 0x01, 0x17,
-  0x89, 0x22, 0x39, 0x06, 0x05, 0xfe, 0x88, 0xc8, 0x7a, 0xa5, 0x39, 0x82,
-  0xa5, 0x9b, 0x5e, 0xf4, 0xed, 0xd1, 0xc9, 0xe0, 0xe2, 0xf4, 0xfc, 0xf0,
-  0xd5, 0xcb, 0x6f, 0x8d, 0x1b, 0x7f, 0x06, 0x40, 0x15, 0x91, 0xd1, 0xdc,
-  0x67, 0x3e, 0xff, 0x5d, 0xdf, 0x3b, 0x3b, 0xfe, 0xe6, 0x1d, 0xa9, 0x01,
-  0xaf, 0x80, 0x78, 0xdd, 0xbd, 0x8b, 0xa7, 0xfa, 0x12, 0x74, 0xa9, 0x16,
-  0xb9, 0x2e, 0xc8, 0x56, 0x68, 0x5b, 0x58, 0x57, 0xd3, 0xda, 0xc7, 0x72,
-  0xaf, 0x2c, 0x06, 0x2b, 0x28, 0x9c, 0x13, 0x57, 0x52, 0x0f, 0x5b, 0xaa,
-  0xe6, 0x65, 0xee, 0xe6, 0xdf, 0x2c, 0x25, 0x16, 0x0f, 0xfe, 0xe7, 0xd0,
-  0xad, 0xcb, 0x91, 0x9b, 0xfa, 0x8d, 0x8f, 0x79, 0x54, 0x6c, 0xd9, 0x1c,
-  0xd1, 0x0f, 0x0e, 0xa3, 0x4f, 0x3a, 0x16, 0x87, 0xa9, 0x02, 0xf9, 0x29,
-  0x50, 0x0d, 0xe0, 0x09, 0x2c, 0xe2, 0xd8, 0x15, 0x60, 0x15, 0xf1, 0xc5,
-  0x8d, 0x25, 0x1e, 0x8d, 0xe8, 0x07, 0x00, 0x14, 0x51, 0xac, 0xe4, 0x02,
-  0x05, 0x99, 0x07, 0x57, 0xd0, 0x97, 0x0e, 0xcf, 0xcf, 0xce, 0x8e, 0x0f,
-  0xcd, 0xd6, 0x6c, 0xb5, 0xbe, 0x38, 0xaf, 0xbd, 0x0a, 0xcc, 0x18, 0xd6,
-  0x51, 0xa8, 0x9c, 0x68, 0xc7, 0xe6, 0xaa, 0x89, 0x6e, 0x30, 0x19, 0x48,
-  0xf6, 0x1c, 0x84, 0x50, 0x81, 0x17, 0x8d, 0x27, 0x76, 0x80, 0x33, 0x25,
-  0x8d, 0x5a, 0x39, 0x01, 0xae, 0x05, 0xc2, 0xbb, 0x33, 0x4d, 0x87, 0xde,
-  0x3a, 0x5e, 0xf3, 0x3d, 0xc2, 0xb5, 0xad, 0x80, 0x06, 0xe1, 0x11, 0x32,
-  0xbb, 0xb7, 0xcf, 0x1e, 0x2d, 0x32, 0xab, 0x6b, 0x27, 0xc4, 0xcf, 0x76,
-  0xe9, 0x30, 0xc7, 0xcf, 0x69, 0xa4, 0xac, 0x86, 0x98, 0x88, 0xe6, 0x3e,
-  0x0d, 0x82, 0x17, 0x15, 0x23, 0x87, 0x81, 0x3d, 0x95, 0x65, 0x73, 0xa9,
-  0x62, 0xc9, 0xd6, 0x81, 0x45, 0x85, 0x04, 0x16, 0xce, 0x3e, 0xe6, 0x20,
-  0x13, 0x9d, 0x59, 0x43, 0xfa, 0x50, 0xb1, 0xf1, 0x1a, 0x69, 0x3e, 0x0c,
-  0x44, 0x34, 0x86, 0xa8, 0xc5, 0xa6, 0xb6, 0xb0, 0x33, 0xbb, 0x49, 0xb1,
-  0x82, 0x56, 0x0d, 0x5c, 0xdc, 0xb0, 0x6e, 0xf4, 0x52, 0xaf, 0x81, 0x17,
-  0x9e, 0xc3, 0xeb, 0xe2, 0x9c, 0x11, 0xfe, 0x4a, 0x85, 0xd1, 0x36, 0xa5,
-  0x47, 0x63, 0xe5, 0xfa, 0x55, 0xcc, 0x13, 0xa3, 0x4b, 0x0d, 0x6e, 0x79,
-  0x74, 0x45, 0xdd, 0x6a, 0x0a, 0xf9, 0xe6, 0x89, 0x05, 0xbd, 0x88, 0x3d,
-  0xa1, 0x80, 0x63, 0x61, 0x3e, 0x72, 0x97, 0x31, 0x12, 0x33, 0x10, 0xfc,
-  0x91, 0x2b, 0x9e, 0xcc, 0x12, 0x75, 0x91, 0xb5, 0xb4, 0x23, 0x17, 0x26,
-  0x84, 0x77, 0xcd, 0xb0, 0xc6, 0x1c, 0x48, 0x87, 0x2e, 0x77, 0x40, 0x56,
-  0x62, 0x47, 0x5f, 0x69, 0x87, 0x2e, 0x89, 0xd8, 0x36, 0xab, 0x2b, 0x39,
-  0x29, 0x31, 0xa7, 0x40, 0x98, 0x01, 0x37, 0x48, 0xa5, 0x2b, 0x34, 0x41,
-  0xd1, 0x79, 0x26, 0x85, 0xe1, 0x71, 0x3d, 0x1e, 0x9f, 0xd2, 0x53, 0xf1,
-  0x00, 0x92, 0x64, 0xb9, 0xe0, 0xe2, 0x32, 0x23, 0x85, 0xd7, 0xe6, 0x70,
-  0x4f, 0xd7, 0x9e, 0xdd, 0x21, 0x7e, 0xad, 0x68, 0x51, 0xdf, 0xbc, 0x3d,
-  0xbd, 0x3a, 0xb9, 0x08, 0xbd, 0x8c, 0xd1, 0x37, 0x27, 0x57, 0x5f, 0x92,
-  0xbc, 0x8e, 0xc2, 0xb1, 0xa7, 0x70, 0xe5, 0xbc, 0x79, 0x73, 0x70, 0x86,
-  0x04, 0xec, 0x33, 0x8e, 0x8a, 0x3b, 0x60, 0x9d, 0x01, 0xdc, 0x88, 0x56,
-  0x18, 0xa4, 0x83, 0xd4, 0xdc, 0x6e, 0xd3, 0xa5, 0x50, 0x3b, 0x7d, 0xcc,
-  0x70, 0x70, 0x84, 0xc2, 0x35, 0xc2, 0x86, 0xab, 0x4e, 0xb0, 0x82, 0x01,
-  0x87, 0x4f, 0x2d, 0xf4, 0x2c, 0xac, 0x73, 0x1d, 0x57, 0x9b, 0xd3, 0xc0,
-  0x44, 0x36, 0x67, 0x07, 0xaa, 0x5c, 0xdd, 0xde, 0x4d, 0xc1, 0x1b, 0xea,
-  0xc0, 0x39, 0x39, 0x4a, 0x95, 0x44, 0xa6, 0xb9, 0xaa, 0x34, 0x72, 0x5d,
-  0x56, 0xc3, 0xb2, 0xa9, 0x47, 0x1e, 0x12, 0xbb, 0x90, 0x33, 0x6f, 0xf9,
-  0x83, 0xb2, 0x09, 0x7d, 0xf9, 0xf2, 0x34, 0xbc, 0x4f, 0xfb, 0x95, 0x6a,
-  0x4c, 0x16, 0x5a, 0x76, 0x9d, 0x25, 0xfe, 0xe0, 0xf6, 0xce, 0x83, 0xa2,
-  0xa9, 0xa1, 0x55, 0xf9, 0x85, 0xc8, 0x8d, 0x95, 0x22, 0xc0, 0x8c, 0x79,
-  0x7a, 0xee, 0xde, 0xd5, 0x20, 0x05, 0x8e, 0xd5, 0xd5, 0xdc, 0x0e, 0x9d,
-  0x15, 0xb3, 0x43, 0x7b, 0xac, 0x92, 0x9a, 0x5a, 0xab, 0x44, 0x6c, 0xb9,
-  0x3d, 0x9c, 0xd1, 0x07, 0x0c, 0x12, 0xef, 0x02, 0xe5, 0xb2, 0x52, 0x59,
-  0xd6, 0x4f, 0x1e, 0x12, 0x78, 0x2b, 0xf1, 0xeb, 0x5f, 0x17, 0xd7, 0x61,
-  0xda, 0x0f, 0xcf, 0x46, 0xf3, 0x5b, 0xdb, 0x21, 0x6d, 0x45, 0xee, 0xd1,
-  0xe2, 0x5a, 0x95, 0x11, 0x68, 0xc5, 0xac, 0xbd, 0x75, 0x1d, 0xea, 0xf7,
-  0xfb, 0xcd, 0xef, 0xf7, 0xc5, 0x80, 0xf8, 0xe6, 0xe0, 0xe4, 0x14, 0xfe,
-  0xee, 0x53, 0x62, 0xea, 0x03, 0x5b, 0x3b, 0x0e, 0x0a, 0x60, 0x7f, 0x3d,
-  0xa9, 0x77, 0x74, 0x40, 0xbb, 0x0e, 0x8a, 0xd9, 0x62, 0x6b, 0x99, 0x53,
-  0xc1, 0x6e, 0x27, 0x97, 0xbd, 0x22, 0xa7, 0xd0, 0x15, 0x4b, 0x0b, 0x58,
-  0x88, 0x86, 0xc6, 0x00, 0x65, 0x40, 0xee, 0x64, 0x1b, 0x29, 0x5f, 0xa2,
-  0x12, 0xc0, 0xc0, 0xe8, 0xef, 0x79, 0x32, 0x4d, 0xee, 0x54, 0x95, 0x12,
-  0xb8, 0xa7, 0x2f, 0xd4, 0x3c, 0x29, 0xd5, 0x9f, 0x4a, 0x6f, 0x65, 0xad,
-  0x58, 0x40, 0xd1, 0xe7, 0x8e, 0x64, 0xca, 0xfa, 0x04, 0x48, 0x74, 0xef,
-  0xb1, 0x49, 0xcd, 0x1a, 0x8c, 0xf7, 0x7a, 0xb8, 0xd5, 0x0a, 0x59, 0xb1,
-  0xb7, 0x85, 0xe6, 0xb8, 0xd5, 0x43, 0x8b, 0x44, 0x3b, 0xb0, 0xf2, 0x21,
-  0xa2, 0x69, 0x77, 0x0d, 0x45, 0x4e, 0xec, 0x03, 0x60, 0x84, 0x5d, 0x68,
-  0x65, 0xdc, 0xd2, 0x84, 0x58, 0x30, 0x80, 0x82, 0xbb, 0x92, 0x5f, 0xc1,
-  0x34, 0x4d, 0xba, 0x78, 0x37, 0x62, 0x47, 0x29, 0xf8, 0x1f, 0x3f, 0x0b,
-  0x14, 0xac, 0x20, 0x7c, 0x81, 0xfe, 0x94, 0xd8, 0x39, 0xfd, 0x8b, 0x9b,
-  0xca, 0x97, 0x0c, 0xb6, 0xd6, 0xe5, 0x20, 0x56, 0xb6, 0x27, 0x6a, 0xbd,
-  0x62, 0x1e, 0xbd, 0x9a, 0xf3, 0x65, 0xfc, 0x47, 0x66, 0x6d, 0x36, 0xac,
-  0xab, 0x2c, 0xb7, 0xd5, 0x95, 0x5d, 0x18, 0x4a, 0xb5, 0x97, 0xcf, 0x97,
-  0x30, 0x7c, 0x39, 0x34, 0x73, 0x8c, 0x62, 0x86, 0x2a, 0x4d, 0x89, 0x14,
-  0x56, 0x72, 0x8d, 0x83, 0x87, 0x2f, 0x69, 0x77, 0xa5, 0xf5, 0xd3, 0xec,
-  0x1e, 0x65, 0xa1, 0x26, 0x13, 0xd4, 0xa8, 0x3d, 0x9f, 0x7b, 0x50, 0x35,
-  0x9c, 0x19, 0x79, 0x70, 0x66, 0x50, 0xf4, 0x34, 0xb7, 0x68, 0xb1, 0x1c,
-  0x4e, 0x49, 0x4d, 0xb0, 0xe8, 0xa7, 0x7e, 0x74, 0xc0, 0xab, 0x44, 0xec,
-  0x95, 0x9b, 0x13, 0x33, 0x3d, 0xdf, 0x30, 0xb5, 0x60, 0x1b, 0x2d, 0x57,
-  0x89, 0x23, 0x39, 0xe3, 0xfa, 0x58, 0x08, 0x2a, 0x99, 0x65, 0x73, 0x8b,
-  0x9d, 0x5c, 0x16, 0x02, 0xb1, 0x63, 0xb5, 0x2d, 0x37, 0xc4, 0x0c, 0x91,
-  0x4e, 0x15, 0xd3, 0x52, 0xef, 0x62, 0x7e, 0x23, 0x9c, 0xcc, 0xb8, 0xb7,
-  0xb8, 0x59, 0xd8, 0x4e, 0x1b, 0xd3, 0x97, 0xd8, 0x7d, 0x8d, 0xd6, 0xe3,
-  0xf3, 0x74, 0xf1, 0xe5, 0x45, 0x3f, 0x3a, 0x46, 0x4b, 0x32, 0x26, 0x15,
-  0x15, 0x58, 0x28, 0xa3, 0xef, 0x68, 0xb2, 0xd7, 0xc8, 0xca, 0x3d, 0xcf,
-  0xf1, 0x17, 0xb7, 0xa6, 0x5f, 0x8a, 0x1e, 0xc6, 0xdf, 0x56, 0x7b, 0xa5,
-  0x86, 0x32, 0xad, 0x6a, 0x7c, 0xc1, 0xbf, 0xd3, 0x51, 0x21, 0xf5, 0xd4,
-  0x6d, 0x93, 0xef, 0x21, 0xcb, 0x2b, 0x09, 0xc9, 0xf2, 0x66, 0x34, 0x4c,
-  0x45, 0xe7, 0x5f, 0xac, 0x78, 0xff, 0x58, 0x86, 0xe7, 0x2c, 0x76, 0xcd,
-  0x76, 0x91, 0x06, 0x02, 0xd2, 0x52, 0xf2, 0x73, 0x8e, 0x79, 0x39, 0x57,
-  0xb9, 0xa4, 0xe2, 0xe6, 0x89, 0x86, 0x31, 0x64, 0x6a, 0x13, 0x15, 0x11,
-  0xa6, 0x48, 0x6a, 0xc7, 0x35, 0xe0, 0xd8, 0xf6, 0x05, 0xee, 0x59, 0x8c,
-  0xe5, 0x2e, 0x1d, 0xd3, 0x16, 0xf4, 0x37, 0xfe, 0x1f, 0xb5, 0xd8, 0x6e,
-  0x5d, 0x53, 0xcd, 0x01, 0x00,
+  0x69, 0x77, 0x1b, 0xc7, 0xb5, 0x2e, 0xfc, 0xf9, 0xe5, 0xaf, 0xe8, 0xc0,
+  0x2b, 0x01, 0x99, 0x00, 0xe0, 0x20, 0xc9, 0xb6, 0x14, 0xc9, 0x31, 0x4d,
+  0x52, 0x36, 0xaf, 0x29, 0x91, 0x97, 0xa0, 0x3c, 0x5c, 0xdb, 0x4b, 0xab,
+  0x01, 0x34, 0xc9, 0x0e, 0x01, 0x34, 0xd2, 0xdd, 0x20, 0x89, 0xe4, 0xe4,
+  0xfe, 0xf6, 0xbb, 0x9f, 0x3d, 0x54, 0x55, 0x0f, 0xa0, 0x68, 0xc7, 0x4e,
+  0xee, 0xf0, 0xe6, 0x1c, 0x8b, 0x24, 0xd0, 0x5d, 0xe3, 0xae, 0x5d, 0x7b,
+  0x7c, 0x76, 0x14, 0x7d, 0xe8, 0x7f, 0xef, 0xf9, 0xbf, 0xf7, 0xf4, 0x3f,
+  0xf9, 0x3d, 0x8a, 0x36, 0xa2, 0xe8, 0x2c, 0xcf, 0xfe, 0x9a, 0x8c, 0xcb,
+  0xf6, 0x17, 0xde, 0xbf, 0xff, 0xaf, 0x48, 0xfe, 0x8f, 0x5e, 0xf8, 0x91,
+  0x7f, 0xf2, 0x4b, 0x0f, 0xfc, 0x6f, 0x3b, 0xf2, 0x2f, 0xfd, 0xd7, 0xfb,
+  0xad, 0xe8, 0x31, 0x2f, 0xfd, 0x57, 0xb4, 0xc9, 0x2f, 0xbd, 0xd7, 0x9e,
+  0x5e, 0xe2, 0x77, 0x1a, 0xe5, 0xc3, 0x3d, 0xfd, 0x88, 0xe1, 0xe1, 0x9f,
+  0x6d, 0xbc, 0xf8, 0xe3, 0x7b, 0xfc, 0x4a, 0x9f, 0x6c, 0x6c, 0xbc, 0xdd,
+  0x7f, 0x73, 0x64, 0xaf, 0x8e, 0x97, 0xf9, 0x34, 0xea, 0x47, 0x65, 0x1e,
+  0xcf, 0x8b, 0xcb, 0x24, 0x8f, 0xe2, 0xe8, 0xdd, 0xf9, 0xc9, 0xc6, 0xc6,
+  0xf0, 0xfb, 0xb7, 0xa7, 0x67, 0xc3, 0xe3, 0x61, 0xe5, 0xb1, 0x1f, 0xb2,
+  0x45, 0x99, 0x66, 0xf3, 0xe2, 0xa7, 0xe8, 0x07, 0x7a, 0x68, 0x30, 0x18,
+  0xfc, 0xb4, 0xb1, 0x71, 0x78, 0x34, 0x3c, 0x38, 0x3f, 0x3e, 0xbb, 0x38,
+  0x3e, 0x7d, 0x5b, 0x79, 0x36, 0x4a, 0x8b, 0x88, 0x1a, 0x2b, 0xb3, 0x6c,
+  0x4a, 0xff, 0xf8, 0xf6, 0x27, 0x71, 0x19, 0x47, 0x97, 0x79, 0x36, 0x8b,
+  0xb2, 0x1c, 0x5f, 0xc4, 0x51, 0x91, 0xe4, 0xb7, 0x49, 0xde, 0x8b, 0x96,
+  0x45, 0x3a, 0xbf, 0x8a, 0xb2, 0x79, 0x12, 0x65, 0x97, 0x51, 0x79, 0x9d,
+  0x58, 0x73, 0xc5, 0x72, 0xb1, 0xc8, 0xf2, 0x32, 0x99, 0x44, 0x8b, 0x3c,
+  0x2b, 0xb3, 0x71, 0x36, 0x2d, 0xa2, 0xcd, 0xaf, 0x2e, 0x2e, 0xce, 0x7a,
+  0x11, 0xfe, 0x1d, 0xf6, 0xa2, 0xd7, 0xf8, 0xfd, 0x35, 0xff, 0x1a, 0x0d,
+  0x0f, 0xce, 0xf0, 0x2f, 0x7f, 0x14, 0x5d, 0xc8, 0x8f, 0xc3, 0xe3, 0x83,
+  0x8b, 0x9e, 0x35, 0x77, 0x71, 0x74, 0xf2, 0xf6, 0xe8, 0x82, 0x3e, 0x3d,
+  0x39, 0xdc, 0x3f, 0x8b, 0x30, 0x8a, 0xe8, 0xf5, 0xf1, 0xc9, 0xd1, 0xd6,
+  0x80, 0xbe, 0xba, 0x4e, 0xa2, 0x71, 0x36, 0x9b, 0xc5, 0xf3, 0x09, 0x86,
+  0x3f, 0x49, 0x8a, 0xf4, 0x6a, 0x4e, 0xfd, 0xd2, 0x30, 0xef, 0xb2, 0xfc,
+  0x26, 0xba, 0x4b, 0xcb, 0xeb, 0x6c, 0x59, 0xd2, 0x48, 0x93, 0xdc, 0x9a,
+  0x4b, 0xe7, 0x65, 0x92, 0xc7, 0x63, 0xac, 0xcb, 0x60, 0xa3, 0xb2, 0x02,
+  0xd9, 0x25, 0xcd, 0xb7, 0xa0, 0x09, 0x8e, 0x96, 0xc5, 0x34, 0x8b, 0x27,
+  0x98, 0x16, 0xbd, 0x79, 0xb9, 0xa4, 0x05, 0xc9, 0xd3, 0xf1, 0x4d, 0x11,
+  0x4d, 0xd3, 0x9b, 0x04, 0x93, 0xba, 0x5f, 0xd9, 0x24, 0x7b, 0xdc, 0x76,
+  0x14, 0x2f, 0x69, 0xfe, 0xf3, 0xbe, 0x35, 0x57, 0xa6, 0xe3, 0x18, 0x1d,
+  0xd0, 0xa0, 0x2f, 0xcb, 0x45, 0xb4, 0x5c, 0xa0, 0x39, 0x99, 0x7d, 0xb4,
+  0xc8, 0x0a, 0x7a, 0x6b, 0x38, 0x3c, 0xa1, 0x91, 0xcf, 0xe7, 0x09, 0x0f,
+  0xa4, 0xe8, 0xd1, 0x1f, 0xd9, 0x4d, 0x9a, 0xd0, 0x2f, 0x97, 0xe9, 0x34,
+  0x91, 0xd5, 0x77, 0xcd, 0x61, 0x1b, 0xf2, 0xa4, 0x58, 0xce, 0x92, 0x08,
+  0x33, 0x9d, 0x65, 0x79, 0x32, 0x88, 0xf6, 0x8b, 0x68, 0x95, 0x2d, 0x69,
+  0x8a, 0xd3, 0x29, 0xed, 0x48, 0x12, 0x8d, 0x92, 0x69, 0x76, 0xd7, 0xc3,
+  0x3e, 0x44, 0xf3, 0xe5, 0x6c, 0x44, 0xaf, 0xd0, 0xf0, 0x2f, 0x93, 0xb8,
+  0x5c, 0xd2, 0xab, 0xfc, 0x98, 0x35, 0x37, 0x8b, 0x69, 0x16, 0xf4, 0x6e,
+  0x1e, 0x5d, 0x27, 0x34, 0xcb, 0x62, 0x91, 0xce, 0x7f, 0xb7, 0xd1, 0xa4,
+  0x85, 0x45, 0x76, 0x97, 0xe4, 0xb4, 0x98, 0xd1, 0x68, 0x15, 0xd1, 0xcc,
+  0x47, 0xf2, 0xcd, 0x25, 0xd6, 0x3f, 0x9e, 0x4e, 0x1d, 0x81, 0xf4, 0xf3,
+  0x64, 0x1a, 0x63, 0xb3, 0xad, 0xaf, 0x41, 0x34, 0x4c, 0x1c, 0x2d, 0xe8,
+  0x7b, 0x9b, 0x4f, 0xb6, 0xf8, 0xcd, 0x49, 0x52, 0xc6, 0xe9, 0xb4, 0xa0,
+  0x85, 0x07, 0xd1, 0xda, 0x06, 0xd3, 0x90, 0xe9, 0xcf, 0xa8, 0x58, 0xcd,
+  0xcb, 0xf8, 0x1e, 0x7d, 0x1b, 0xdd, 0xd0, 0xf3, 0x8b, 0x64, 0x3e, 0x49,
+  0xe6, 0xe5, 0x20, 0xfa, 0x3e, 0x5b, 0x76, 0xa9, 0xdb, 0xcb, 0x94, 0x56,
+  0x20, 0x8e, 0xb4, 0x25, 0x0c, 0x8f, 0x76, 0x7d, 0x9c, 0xa7, 0x8b, 0x60,
+  0xf1, 0xb3, 0x39, 0xed, 0x72, 0x74, 0xfe, 0xfa, 0x20, 0x7a, 0xf2, 0xfc,
+  0xd3, 0x8f, 0xfd, 0x2e, 0x53, 0x13, 0x34, 0xc1, 0x78, 0x4e, 0x24, 0xba,
+  0x48, 0xc6, 0xe9, 0x25, 0xcd, 0x6b, 0xb6, 0x9c, 0x96, 0xe9, 0x82, 0x56,
+  0x1c, 0x23, 0x28, 0x40, 0x5c, 0x8b, 0x38, 0x2f, 0x0b, 0xac, 0x1d, 0x7f,
+  0x40, 0x73, 0xbf, 0xcb, 0xd3, 0x12, 0x84, 0x8e, 0x2f, 0x68, 0xa5, 0xcb,
+  0xc2, 0x9a, 0x03, 0x75, 0x51, 0x3f, 0x23, 0xa2, 0x26, 0x5a, 0xe1, 0xb8,
+  0xa0, 0x4e, 0x5f, 0xb8, 0xbe, 0xa2, 0xeb, 0xb2, 0x5c, 0xbc, 0xd8, 0xde,
+  0x2e, 0xd2, 0x32, 0x19, 0xfc, 0x83, 0x0e, 0x49, 0xaf, 0xbc, 0xcb, 0x7a,
+  0xe5, 0x75, 0x9e, 0x24, 0xff, 0x1c, 0x10, 0xcd, 0xba, 0x07, 0xa9, 0x4b,
+  0xec, 0x23, 0x86, 0x75, 0x95, 0xa0, 0x83, 0xbf, 0x2d, 0x93, 0x39, 0x1a,
+  0xa4, 0x21, 0xc4, 0xd3, 0xc5, 0x75, 0x4c, 0xbb, 0x99, 0x10, 0xf9, 0xe1,
+  0xd8, 0x11, 0x81, 0x60, 0x44, 0x72, 0xf0, 0x7e, 0xf8, 0xa9, 0xd1, 0xe7,
+  0x25, 0x77, 0x49, 0xff, 0x0e, 0xf4, 0xa5, 0x98, 0xd6, 0x9a, 0x3a, 0xdb,
+  0x06, 0x51, 0xfd, 0xb0, 0xdb, 0xdf, 0xdd, 0xd9, 0xf9, 0x69, 0x50, 0xde,
+  0x97, 0x8f, 0x7c, 0x61, 0x67, 0xc7, 0xbf, 0x82, 0xa7, 0x37, 0x31, 0xe3,
+  0x68, 0x4a, 0x44, 0x83, 0xfe, 0xff, 0x9e, 0xe4, 0x59, 0xb1, 0xd5, 0xd2,
+  0xd4, 0x34, 0x29, 0xe9, 0x88, 0x05, 0xed, 0xc4, 0xfd, 0xbf, 0x4b, 0xb7,
+  0xf6, 0xf0, 0xdb, 0x2c, 0x9a, 0x27, 0x05, 0xaf, 0xaa, 0xb0, 0x8e, 0x60,
+  0xda, 0xb4, 0xfd, 0x9e, 0x81, 0xc4, 0x25, 0x7f, 0x3b, 0xcb, 0x66, 0x44,
+  0x03, 0x3d, 0x3a, 0x98, 0xa5, 0x5b, 0x2c, 0x3a, 0x77, 0x8e, 0xe1, 0x24,
+  0xc4, 0x8f, 0xe2, 0x29, 0x58, 0x51, 0x41, 0x0d, 0xd3, 0x60, 0x89, 0x01,
+  0x24, 0xf1, 0xf8, 0x3a, 0xca, 0xe8, 0xed, 0xbc, 0xb9, 0x29, 0xf1, 0x7c,
+  0x35, 0xc8, 0xf2, 0xab, 0xed, 0x38, 0x1f, 0x5f, 0xa7, 0xb7, 0xb4, 0x32,
+  0xcf, 0x9f, 0x7f, 0xdc, 0xa7, 0x7f, 0x9e, 0xff, 0xb4, 0x7d, 0x9b, 0x4d,
+  0x69, 0xa1, 0x9e, 0xfe, 0xb4, 0x8d, 0xed, 0xfe, 0x47, 0xdc, 0x1b, 0xf5,
+  0xc6, 0xff, 0x1c, 0x5c, 0x97, 0xb3, 0xe9, 0x43, 0x54, 0x44, 0xed, 0x45,
+  0xf1, 0x2c, 0x5b, 0xce, 0x4b, 0x47, 0x38, 0x44, 0x83, 0x65, 0xc0, 0x9d,
+  0xa6, 0xe9, 0x9c, 0xce, 0x2c, 0x51, 0xfa, 0x4a, 0x4e, 0xec, 0x28, 0xf1,
+  0x87, 0xbb, 0x1c, 0x5f, 0xd3, 0x54, 0x89, 0x92, 0x62, 0x5d, 0x86, 0x32,
+  0xa5, 0xc9, 0xd0, 0x6b, 0x73, 0x3a, 0xc4, 0xa9, 0xb4, 0x23, 0x5d, 0xa5,
+  0xf4, 0x5c, 0x96, 0x4f, 0x92, 0xdc, 0xd3, 0xf4, 0x30, 0xa5, 0x55, 0x93,
+  0x53, 0xfb, 0xc9, 0x60, 0xf7, 0xd9, 0x60, 0xd7, 0x2d, 0x10, 0x6d, 0x65,
+  0xe6, 0x86, 0x58, 0x94, 0xc9, 0x82, 0x06, 0xb3, 0x04, 0xf3, 0xe3, 0x93,
+  0x88, 0x46, 0xe9, 0x04, 0x5f, 0x81, 0xe5, 0x44, 0x45, 0xe6, 0x0e, 0xcf,
+  0x75, 0x5c, 0x56, 0xe8, 0x11, 0x4b, 0xbb, 0x8a, 0xde, 0xd2, 0xbe, 0x1b,
+  0x57, 0xc9, 0x23, 0xd9, 0xe0, 0x17, 0xf5, 0x55, 0xbd, 0xbb, 0xbb, 0x5b,
+  0x4f, 0x77, 0x2f, 0x76, 0x6b, 0xa4, 0x17, 0xbc, 0xd4, 0x46, 0x30, 0x2f,
+  0xf6, 0xaa, 0x24, 0x73, 0x7c, 0x19, 0xf1, 0xb8, 0xfc, 0xa2, 0x83, 0x65,
+  0x38, 0x0e, 0x6f, 0x1c, 0x83, 0x5a, 0xa4, 0xdf, 0x93, 0xcb, 0xf4, 0xbe,
+  0x27, 0x8b, 0xc2, 0xab, 0x1d, 0x53, 0xfb, 0xb3, 0x05, 0xc8, 0xc2, 0x9a,
+  0xbb, 0x5a, 0x26, 0x05, 0x71, 0x45, 0xcc, 0xd6, 0x31, 0x1b, 0x34, 0x3f,
+  0x4b, 0xaf, 0xae, 0xcb, 0xe8, 0x2e, 0x06, 0xc7, 0x39, 0x2e, 0xe5, 0x6d,
+  0xb0, 0x76, 0xe2, 0x32, 0x97, 0x31, 0xf1, 0x8a, 0x08, 0xa4, 0x25, 0x8c,
+  0x1c, 0xd4, 0xe8, 0x96, 0x8d, 0xd6, 0x48, 0x88, 0x2d, 0x0a, 0x2e, 0xbd,
+  0x51, 0x5c, 0x60, 0xc3, 0xe6, 0x44, 0x14, 0x25, 0xdd, 0x0e, 0x4b, 0xfc,
+  0x75, 0x4d, 0xec, 0x3f, 0x9a, 0xc7, 0xb3, 0x44, 0x87, 0x09, 0x7e, 0xf9,
+  0x9a, 0xd6, 0x34, 0xb9, 0x8f, 0x67, 0x8e, 0x85, 0x11, 0x43, 0xea, 0xf1,
+  0x2e, 0xb9, 0xa7, 0xe9, 0x50, 0x94, 0x44, 0x90, 0x38, 0x31, 0x7c, 0x08,
+  0x3b, 0x38, 0x68, 0x9d, 0x70, 0x8a, 0x05, 0xdf, 0x0f, 0xbc, 0x44, 0x18,
+  0x7e, 0x14, 0x4c, 0x96, 0x96, 0x2c, 0xbe, 0xc1, 0x7d, 0xeb, 0xc9, 0xe6,
+  0xa0, 0x65, 0x6d, 0xe8, 0x8e, 0xc1, 0x18, 0xc3, 0x7b, 0x89, 0x07, 0xe1,
+  0x78, 0xa4, 0xbf, 0x9a, 0x70, 0x51, 0xf6, 0xea, 0x64, 0x43, 0xe4, 0xc2,
+  0x03, 0x9c, 0xe1, 0x38, 0xe0, 0xd9, 0x42, 0xe4, 0x06, 0xa6, 0x5f, 0xcc,
+  0x58, 0x04, 0x07, 0xe9, 0x76, 0x9e, 0x95, 0xd1, 0x24, 0x0b, 0xf8, 0x2f,
+  0xf5, 0xea, 0xe6, 0x8f, 0xee, 0x0b, 0x12, 0xbc, 0x88, 0xf9, 0x4d, 0x8a,
+  0x6b, 0xba, 0xae, 0x0a, 0x9c, 0x1d, 0xe2, 0x0c, 0xe9, 0x8c, 0x56, 0xf7,
+  0x16, 0xab, 0xb1, 0x48, 0x92, 0xc9, 0x20, 0x3a, 0xbd, 0x04, 0x51, 0xe7,
+  0x34, 0xe8, 0x92, 0xbf, 0xc6, 0xb9, 0x9b, 0xae, 0xa8, 0x61, 0x08, 0x25,
+  0x73, 0x77, 0xc4, 0x78, 0x2c, 0xc1, 0x11, 0xe2, 0xa3, 0x46, 0x43, 0x9d,
+  0x56, 0x0f, 0x28, 0xdf, 0xae, 0xa0, 0x7c, 0x0c, 0x8e, 0x8e, 0x68, 0x14,
+  0xf1, 0x96, 0xd1, 0x6f, 0xe5, 0x5d, 0x92, 0xcc, 0x3d, 0xbb, 0x21, 0xde,
+  0x40, 0x57, 0x9e, 0xac, 0x7e, 0x3a, 0xbf, 0xcd, 0x30, 0xc0, 0x8d, 0x8d,
+  0xb3, 0xf3, 0xd3, 0x2f, 0xcf, 0x8f, 0x86, 0xc3, 0xe8, 0xcd, 0xd1, 0xc5,
+  0xd1, 0x79, 0xf5, 0x42, 0x9d, 0x67, 0xf9, 0x8c, 0x6e, 0x4d, 0xa2, 0x92,
+  0x49, 0x5a, 0x2c, 0xa6, 0xf1, 0x0a, 0x72, 0x06, 0xcd, 0xe5, 0x2a, 0x07,
+  0x1d, 0xce, 0x12, 0x1c, 0xcb, 0xc9, 0x32, 0x67, 0x8e, 0xb8, 0x20, 0x66,
+  0xa6, 0x52, 0x01, 0x5d, 0x76, 0x2c, 0x4a, 0xcc, 0xaf, 0xac, 0x39, 0xcf,
+  0x66, 0x6c, 0x23, 0x70, 0x47, 0x43, 0x48, 0xeb, 0x79, 0x99, 0x8d, 0x57,
+  0x07, 0xe2, 0x1c, 0xe6, 0x03, 0x46, 0x3b, 0xe3, 0x1b, 0x9a, 0xae, 0x46,
+  0xda, 0x05, 0x3a, 0xbe, 0x97, 0x8e, 0x70, 0x89, 0xf9, 0x78, 0xa2, 0xf8,
+  0x8a, 0x6e, 0x7c, 0x96, 0xec, 0xb0, 0x38, 0xe3, 0xc4, 0xc6, 0xee, 0x46,
+  0xcc, 0xa2, 0x20, 0x64, 0x43, 0xda, 0x50, 0x1a, 0xf0, 0x2c, 0x9d, 0x13,
+  0x9f, 0xa2, 0xfb, 0x48, 0xcf, 0x06, 0x0d, 0xf7, 0x12, 0x04, 0xe8, 0x25,
+  0x2d, 0xac, 0x8c, 0x34, 0x42, 0x6f, 0xd1, 0x6e, 0x13, 0x4f, 0x71, 0xb3,
+  0xe3, 0xc1, 0xa5, 0x25, 0xf6, 0x2c, 0x1e, 0xe1, 0x08, 0xe3, 0x60, 0xe1,
+  0xae, 0xa5, 0x7e, 0xb9, 0x23, 0xfe, 0x20, 0x10, 0x2b, 0xad, 0x47, 0x1a,
+  0x1e, 0xbd, 0x46, 0x83, 0x8a, 0x47, 0xd8, 0x56, 0x0c, 0xa6, 0xb6, 0x90,
+  0x74, 0x2d, 0xf2, 0x59, 0xbc, 0x4b, 0x89, 0x30, 0xe8, 0xd9, 0xbb, 0x6c,
+  0x39, 0x25, 0xb1, 0x09, 0x0f, 0x2c, 0x17, 0x9e, 0x64, 0x89, 0x44, 0x96,
+  0xe5, 0x82, 0x7a, 0x9e, 0xa5, 0xf7, 0x7c, 0xc1, 0xd7, 0x5a, 0xa1, 0xf1,
+  0xd1, 0x9f, 0x0b, 0xda, 0x88, 0x84, 0x47, 0x34, 0x08, 0x99, 0x11, 0xcb,
+  0x5e, 0x38, 0x67, 0x8d, 0x6d, 0xc4, 0x91, 0x61, 0x06, 0x71, 0x76, 0x3a,
+  0xbc, 0x00, 0xbb, 0x3c, 0x7b, 0x77, 0x41, 0x0d, 0x11, 0x63, 0x2f, 0x4a,
+  0xda, 0x52, 0xbc, 0x38, 0x4f, 0x58, 0x48, 0xb5, 0xe6, 0x68, 0x07, 0xd3,
+  0x9c, 0x55, 0x16, 0x0c, 0xca, 0x77, 0x6a, 0xe3, 0x63, 0xa9, 0x1b, 0x44,
+  0x6c, 0x32, 0x77, 0x71, 0x9d, 0xd0, 0x11, 0x72, 0xaf, 0x6d, 0x7e, 0xb6,
+  0xd5, 0x8b, 0xfa, 0xae, 0xb9, 0x1f, 0xf0, 0xe8, 0x4f, 0xe8, 0xb9, 0x48,
+  0x67, 0xe9, 0x34, 0x0e, 0x6e, 0x8b, 0x63, 0x5e, 0x6f, 0x90, 0xb7, 0x3b,
+  0x94, 0x63, 0x62, 0x52, 0x3c, 0x66, 0xe2, 0x0f, 0x2a, 0xa9, 0x62, 0x01,
+  0xf9, 0x44, 0xfb, 0xcd, 0x82, 0x40, 0xc8, 0xa7, 0x82, 0xa4, 0xc5, 0x32,
+  0x10, 0xb5, 0x40, 0xaf, 0x34, 0x42, 0x9c, 0xf8, 0xca, 0x5a, 0xd5, 0xc9,
+  0xa4, 0xb1, 0x76, 0xe0, 0x7e, 0xac, 0xbd, 0xb8, 0xd5, 0xeb, 0x8c, 0xe2,
+  0xbc, 0x43, 0x44, 0x43, 0x57, 0x95, 0xc8, 0xde, 0x7c, 0x45, 0x25, 0x57,
+  0x4b, 0x9a, 0x81, 0x2c, 0x2d, 0x4d, 0xf2, 0x23, 0x8c, 0x04, 0xb2, 0xab,
+  0x3b, 0xdb, 0x24, 0x14, 0xcd, 0x27, 0x83, 0x8d, 0x53, 0xd6, 0x68, 0x9c,
+  0xfa, 0xd3, 0x8f, 0xb7, 0xfb, 0xfd, 0x78, 0x01, 0xe9, 0xb1, 0xa6, 0x73,
+  0x6d, 0xd2, 0x3c, 0xb7, 0xa2, 0x6f, 0xc1, 0xd3, 0xf9, 0x74, 0xe3, 0xde,
+  0x9d, 0x07, 0x93, 0xef, 0x09, 0x2b, 0x11, 0xce, 0x8f, 0x65, 0x36, 0xfa,
+  0x8d, 0x5a, 0x9b, 0x53, 0x22, 0xa5, 0x7f, 0xe2, 0x1c, 0xf7, 0xa5, 0x30,
+  0x49, 0x37, 0x0d, 0xcc, 0x23, 0x22, 0x8e, 0x95, 0x9b, 0x14, 0x49, 0xf4,
+  0x38, 0xc0, 0x1a, 0xe0, 0x1d, 0x3c, 0x5a, 0x6b, 0x6e, 0x92, 0x25, 0xc5,
+  0xbc, 0x4b, 0xd7, 0xee, 0x7d, 0x0a, 0x35, 0x21, 0x2d, 0x4d, 0x5c, 0x88,
+  0xc6, 0x79, 0x82, 0x43, 0xec, 0x17, 0xd2, 0xaf, 0x27, 0x0f, 0x58, 0x54,
+  0x3d, 0x2c, 0x0f, 0x4f, 0xab, 0xbc, 0x4b, 0xc7, 0x49, 0x4f, 0x65, 0x2b,
+  0xe2, 0xad, 0x13, 0x56, 0xd4, 0xb8, 0x31, 0x3d, 0x3a, 0xed, 0xf3, 0x99,
+  0x65, 0x13, 0xfa, 0xe6, 0x2a, 0x4e, 0x03, 0xed, 0xa8, 0xbf, 0x4f, 0x8b,
+  0x09, 0x3d, 0xa7, 0x1f, 0x5f, 0x91, 0x74, 0x12, 0xbd, 0x94, 0x1f, 0x45,
+  0x09, 0x7e, 0xf5, 0x59, 0x7d, 0x7d, 0x41, 0xfb, 0x5b, 0xd1, 0x50, 0xaf,
+  0x69, 0x0c, 0xe0, 0x1d, 0x5e, 0xdd, 0x0f, 0xde, 0xc1, 0xaa, 0x15, 0xd4,
+  0xb7, 0x51, 0x09, 0x1f, 0x17, 0xb9, 0x1d, 0x06, 0xb5, 0xe6, 0x86, 0x19,
+  0x58, 0xd6, 0x28, 0x9e, 0x30, 0xef, 0xc4, 0x1c, 0xa2, 0x83, 0x2f, 0x8f,
+  0x89, 0x1a, 0x2f, 0x49, 0xfc, 0x8f, 0xc0, 0x71, 0x64, 0xfa, 0xb4, 0x98,
+  0x09, 0x1d, 0x72, 0x9a, 0x3f, 0x96, 0x0f, 0x4c, 0xba, 0x8c, 0xc2, 0x3b,
+  0x50, 0xff, 0xd7, 0x79, 0x93, 0xfd, 0x9d, 0xd6, 0x20, 0xde, 0x7e, 0x3a,
+  0xd8, 0xe9, 0x40, 0x83, 0xa4, 0xed, 0x23, 0xb9, 0x13, 0x93, 0x8e, 0x46,
+  0xd3, 0x78, 0x4e, 0x4a, 0x1e, 0x28, 0x42, 0xd6, 0x8d, 0xc7, 0x4a, 0xd7,
+  0xdc, 0x32, 0xcf, 0x89, 0xe9, 0x4e, 0x42, 0x66, 0x64, 0x57, 0x81, 0x4c,
+  0x87, 0xaf, 0x64, 0xbd, 0x50, 0xfe, 0xb6, 0xcc, 0x88, 0x85, 0xcd, 0xe2,
+  0xfc, 0xc6, 0x2e, 0x2d, 0x27, 0x8c, 0xe1, 0x46, 0xe1, 0x71, 0xf1, 0xf3,
+  0x2d, 0xcd, 0xf5, 0xbf, 0xa2, 0x85, 0x86, 0x52, 0x06, 0x39, 0x4b, 0xf6,
+  0x33, 0xb3, 0x1b, 0xae, 0x6d, 0xe3, 0x75, 0xea, 0x7e, 0xeb, 0xd1, 0x3a,
+  0xd4, 0x43, 0x1c, 0x5f, 0x7a, 0x77, 0x6e, 0x24, 0x30, 0x8d, 0x49, 0x8e,
+  0x70, 0x04, 0x30, 0x4a, 0x5a, 0xfa, 0xc6, 0xb7, 0x38, 0xf4, 0x5d, 0x21,
+  0xa0, 0x60, 0xf7, 0xfb, 0x74, 0xba, 0xa1, 0xe0, 0xb6, 0x6f, 0xf4, 0x05,
+  0x9d, 0x91, 0xc2, 0x1d, 0x92, 0xcb, 0xf4, 0x8a, 0x74, 0x40, 0xe1, 0x09,
+  0xac, 0x13, 0x9b, 0x2a, 0x8c, 0x13, 0x7c, 0x9d, 0x4d, 0x70, 0x5d, 0xa4,
+  0x65, 0x91, 0x4c, 0x2f, 0x7b, 0xb5, 0xe6, 0xf8, 0xae, 0x5a, 0xf2, 0x4d,
+  0x0e, 0x81, 0xbf, 0x80, 0x2a, 0x34, 0xe6, 0xb6, 0xe6, 0x89, 0xb2, 0x82,
+  0x19, 0x56, 0x16, 0x0a, 0x55, 0x34, 0x9e, 0xc6, 0xe9, 0xac, 0xc0, 0xf1,
+  0x50, 0x5d, 0xa1, 0xa8, 0xd3, 0xcd, 0x85, 0xca, 0x03, 0x4c, 0x32, 0x23,
+  0xc8, 0x23, 0x79, 0x01, 0x89, 0x03, 0xdb, 0x15, 0x1b, 0x3b, 0xe6, 0x4e,
+  0x49, 0xfa, 0x1e, 0xdf, 0x30, 0x51, 0x72, 0x27, 0xc2, 0xc4, 0xfa, 0xb5,
+  0xe6, 0x64, 0x53, 0x20, 0x2b, 0x97, 0xd7, 0x4b, 0x56, 0x8e, 0x8b, 0x22,
+  0x1d, 0x81, 0x26, 0xe9, 0x8a, 0x5e, 0x8e, 0xf9, 0x64, 0xd3, 0x8a, 0x93,
+  0xee, 0x91, 0xc7, 0xc4, 0xde, 0x4b, 0x36, 0x3f, 0x30, 0xd5, 0xf4, 0x89,
+  0x44, 0x16, 0xeb, 0x46, 0xa7, 0x02, 0x46, 0x85, 0x5b, 0x14, 0x2a, 0x46,
+  0x41, 0xcb, 0x55, 0x99, 0x65, 0x1c, 0xd5, 0x56, 0xb3, 0x7e, 0x68, 0x79,
+  0x6d, 0x69, 0x70, 0x77, 0xd7, 0x29, 0x69, 0x3d, 0x22, 0x05, 0xb2, 0x8a,
+  0x42, 0x97, 0x2e, 0x13, 0x5b, 0xbf, 0x4f, 0xc2, 0x68, 0x3a, 0x26, 0x0e,
+  0xda, 0x9f, 0xa4, 0x24, 0xf4, 0x97, 0xf8, 0x6d, 0x5e, 0x4e, 0x67, 0x3d,
+  0xac, 0x41, 0x9d, 0x0c, 0xfb, 0xf3, 0xe4, 0x2a, 0x23, 0x2d, 0xa4, 0x6c,
+  0x52, 0xdd, 0x5b, 0xec, 0x01, 0x5f, 0x0e, 0x72, 0x15, 0x39, 0xea, 0xb0,
+  0x8b, 0x85, 0x6e, 0x24, 0x12, 0xa9, 0xa0, 0xb5, 0x4f, 0x54, 0x1e, 0xe0,
+  0x51, 0x28, 0x77, 0x2d, 0x6a, 0xcd, 0xb1, 0x80, 0x48, 0xc7, 0x88, 0x34,
+  0xca, 0x9e, 0x4a, 0x1d, 0xb4, 0xa9, 0xb3, 0x78, 0xc5, 0x5b, 0x44, 0xd7,
+  0x9b, 0xbb, 0x4d, 0x46, 0x60, 0x64, 0xc4, 0x41, 0x98, 0xb1, 0xf1, 0xc6,
+  0x61, 0x41, 0xea, 0xdc, 0x18, 0x2a, 0xd7, 0x34, 0xc5, 0x73, 0xb3, 0x25,
+  0xed, 0x2f, 0xbd, 0xc4, 0xac, 0x8e, 0x85, 0xdb, 0x3b, 0xda, 0x2a, 0xc7,
+  0x7b, 0xf9, 0x0a, 0x2e, 0xae, 0x59, 0x32, 0x88, 0x73, 0x08, 0x0a, 0x77,
+  0xcd, 0xe6, 0x64, 0xcc, 0x98, 0x26, 0x8f, 0x53, 0x87, 0x89, 0xd7, 0xf5,
+  0xa2, 0xf4, 0x17, 0x24, 0x1f, 0x2c, 0xf0, 0xa4, 0xf5, 0xe7, 0xb4, 0xc6,
+  0xa1, 0x4d, 0x6b, 0x85, 0x50, 0x56, 0x48, 0xab, 0x97, 0xd9, 0x74, 0x9a,
+  0xdd, 0xf1, 0xa5, 0x3a, 0x26, 0xda, 0xcf, 0x59, 0x23, 0xae, 0xef, 0x35,
+  0xac, 0x37, 0x73, 0x12, 0xa7, 0x52, 0x98, 0xab, 0xf0, 0x44, 0x70, 0x54,
+  0x47, 0xc4, 0x3f, 0xc4, 0x92, 0x14, 0xbd, 0x84, 0xda, 0xf0, 0x0a, 0xab,
+  0xb7, 0x86, 0x43, 0x9f, 0x91, 0xca, 0xc0, 0xbd, 0x86, 0xf7, 0x75, 0xc0,
+  0x89, 0x21, 0x05, 0xc4, 0x6a, 0x97, 0x1a, 0xa8, 0xe4, 0x80, 0xe3, 0x56,
+  0x3f, 0x1a, 0x74, 0x14, 0x12, 0xe6, 0xce, 0xae, 0x2d, 0xba, 0xdb, 0x6f,
+  0xd3, 0x6c, 0x59, 0x4c, 0xb1, 0x8b, 0xe3, 0x84, 0x34, 0xec, 0x49, 0xa0,
+  0x09, 0x48, 0xe3, 0xac, 0xee, 0x76, 0x86, 0x49, 0x59, 0x6f, 0xee, 0x80,
+  0x3b, 0x7c, 0xd1, 0x51, 0x95, 0x99, 0xad, 0x43, 0xdc, 0xaa, 0x6e, 0x16,
+  0x6d, 0xa9, 0xea, 0xc4, 0x97, 0x90, 0xa9, 0x89, 0x9b, 0x76, 0x60, 0x1e,
+  0xdd, 0x7d, 0xf5, 0xcd, 0xfe, 0xc9, 0xbb, 0xa3, 0xdd, 0x3f, 0xd7, 0xe9,
+  0x95, 0xbe, 0xdb, 0x93, 0xef, 0xf6, 0x3a, 0xad, 0x7b, 0x43, 0x6b, 0x19,
+  0x75, 0x5f, 0x75, 0x55, 0xab, 0x75, 0xdb, 0xa3, 0x9d, 0x60, 0x14, 0x3d,
+  0x95, 0x53, 0x4b, 0xb9, 0x82, 0x65, 0x61, 0x70, 0x79, 0xd7, 0xc7, 0xce,
+  0x7a, 0x1d, 0xad, 0x24, 0xb3, 0x31, 0x90, 0x5c, 0x3c, 0x09, 0x17, 0xa3,
+  0x28, 0x33, 0x08, 0xeb, 0xba, 0x41, 0x68, 0xb9, 0x90, 0x13, 0x60, 0x27,
+  0xb7, 0x7e, 0xbb, 0xc8, 0x8c, 0x31, 0x65, 0x3f, 0x24, 0xe6, 0xf2, 0xc4,
+  0x7c, 0x40, 0x49, 0x4c, 0xca, 0x2b, 0x22, 0x89, 0x72, 0x7c, 0x3d, 0xa0,
+  0x6b, 0x56, 0xb8, 0x58, 0x5a, 0x28, 0x43, 0xa8, 0x73, 0x58, 0xdc, 0x41,
+  0xb0, 0x7c, 0xde, 0xd2, 0x2c, 0x64, 0xeb, 0x3b, 0x3a, 0x16, 0x52, 0x68,
+  0x68, 0x5f, 0x3a, 0xca, 0x3f, 0x98, 0x96, 0x99, 0xce, 0x54, 0x03, 0xc0,
+  0x99, 0xce, 0xeb, 0xcd, 0xd1, 0x61, 0xcd, 0x66, 0xe8, 0x51, 0x4d, 0x97,
+  0x30, 0x1d, 0xf7, 0xb4, 0x05, 0x1c, 0x60, 0x1a, 0x35, 0xf4, 0xb7, 0x95,
+  0x72, 0x81, 0x6e, 0x9e, 0x28, 0xcb, 0x10, 0x55, 0xad, 0x7e, 0xd6, 0xa8,
+  0xb1, 0x11, 0x49, 0x8a, 0x7a, 0x98, 0x88, 0x9f, 0x60, 0x7c, 0xfd, 0x13,
+  0x22, 0xe8, 0x69, 0xa6, 0x57, 0x88, 0x1c, 0x20, 0x36, 0xa3, 0x98, 0x9c,
+  0x65, 0x34, 0x90, 0x5d, 0xb6, 0x70, 0x02, 0x7d, 0x06, 0x22, 0x1a, 0x6f,
+  0x85, 0x0d, 0x54, 0x0e, 0xb3, 0x23, 0x27, 0x52, 0x6e, 0x68, 0x65, 0x99,
+  0xf2, 0x95, 0xcd, 0x93, 0xec, 0xdc, 0xd2, 0xdc, 0xdb, 0xa4, 0x2c, 0xc6,
+  0xf1, 0x22, 0xd9, 0x56, 0x19, 0xc2, 0x36, 0x92, 0x7b, 0x91, 0x81, 0x34,
+  0xd9, 0xe5, 0xe9, 0xc5, 0x91, 0xb0, 0x4b, 0x13, 0xf8, 0x02, 0x3d, 0x54,
+  0x38, 0x73, 0x70, 0x66, 0xf9, 0x32, 0x87, 0x02, 0xab, 0xf7, 0x42, 0x5c,
+  0x34, 0xd6, 0x9c, 0xf4, 0x81, 0x01, 0x1b, 0xd0, 0x6c, 0x32, 0x76, 0xa3,
+  0x2b, 0x71, 0xd9, 0xd9, 0xa0, 0x9e, 0x06, 0x90, 0x6e, 0xf8, 0x63, 0x67,
+  0x5d, 0xae, 0xf3, 0x37, 0xbd, 0x6e, 0xfb, 0x63, 0x37, 0x86, 0xfe, 0x5f,
+  0x63, 0x2f, 0x7b, 0xa8, 0x69, 0x92, 0x17, 0x8a, 0xb8, 0xd5, 0x9c, 0x34,
+  0x86, 0xdb, 0x44, 0xd7, 0x16, 0xeb, 0xd5, 0x7e, 0x49, 0x7a, 0x7d, 0xc5,
+  0xee, 0x88, 0x43, 0x6a, 0x7e, 0xb2, 0x9c, 0x2d, 0x54, 0xb6, 0xf9, 0xdd,
+  0x7f, 0x4c, 0x94, 0xf9, 0x42, 0x04, 0xd9, 0x7e, 0x5c, 0x8c, 0xd3, 0xb4,
+  0xf6, 0xd6, 0xd1, 0x9c, 0xaf, 0x8a, 0xfd, 0xe1, 0xc1, 0xf1, 0xb1, 0x57,
+  0xa5, 0xef, 0x44, 0x51, 0xc0, 0x34, 0xa0, 0x23, 0xd0, 0x92, 0xc0, 0x0d,
+  0x21, 0x36, 0x1b, 0x76, 0x56, 0xc8, 0xb8, 0xe9, 0xb2, 0x6d, 0x3b, 0x6d,
+  0x18, 0x5f, 0x32, 0x27, 0xda, 0x18, 0x27, 0x13, 0x6f, 0xb9, 0xa5, 0xf9,
+  0xc0, 0x78, 0xc5, 0x64, 0x41, 0x17, 0x65, 0xa1, 0x26, 0x9d, 0x3f, 0x97,
+  0xab, 0x45, 0xf2, 0x6a, 0xbf, 0x23, 0x62, 0x63, 0x7d, 0x4e, 0xb2, 0x30,
+  0xe3, 0x98, 0x86, 0xaf, 0x9a, 0xb8, 0x5c, 0x87, 0xd8, 0xe2, 0x89, 0xea,
+  0xcf, 0xca, 0x1b, 0x61, 0x01, 0x65, 0x39, 0x5e, 0xac, 0xf5, 0x74, 0xa1,
+  0x3c, 0xd9, 0xab, 0xb3, 0x96, 0x15, 0x49, 0x1c, 0xb3, 0xe2, 0xd1, 0x97,
+  0xd5, 0x23, 0xd4, 0x09, 0x5e, 0xb8, 0x06, 0x81, 0x91, 0xaa, 0x10, 0x8a,
+  0x92, 0x2c, 0x85, 0x3c, 0x46, 0x90, 0x04, 0x69, 0xf2, 0x91, 0xfc, 0x02,
+  0x6f, 0xd4, 0xc4, 0x9f, 0x81, 0x17, 0xa0, 0x9a, 0xbb, 0xef, 0x2c, 0x75,
+  0x22, 0x23, 0xd4, 0xe6, 0xb2, 0x64, 0x2b, 0xcc, 0x82, 0xe4, 0xc0, 0x72,
+  0x4a, 0x6c, 0x94, 0x34, 0xea, 0x39, 0x7e, 0x32, 0xa1, 0x2f, 0xd9, 0x5c,
+  0xd0, 0x54, 0xf0, 0xa0, 0xbf, 0xe5, 0x29, 0xf4, 0xa2, 0x28, 0x64, 0xe7,
+  0x22, 0xcb, 0x6b, 0xe3, 0xb2, 0x9b, 0xec, 0x1f, 0x60, 0xc9, 0xcd, 0xae,
+  0xe7, 0x7a, 0x73, 0x35, 0xa9, 0xd8, 0xc4, 0xe2, 0x68, 0xb3, 0x58, 0x42,
+  0x72, 0xa3, 0xab, 0xc5, 0xe4, 0x32, 0x93, 0xd4, 0x78, 0x1e, 0x26, 0x92,
+  0xd5, 0x6f, 0x1c, 0xe2, 0xe4, 0x5b, 0x8f, 0x55, 0x09, 0x1f, 0x14, 0x38,
+  0x7e, 0xa9, 0xc4, 0xd1, 0x1f, 0xa7, 0x8b, 0x6b, 0x1c, 0xfa, 0x97, 0xd3,
+  0xb4, 0x60, 0xbb, 0x94, 0x7e, 0xd0, 0x90, 0x3a, 0x86, 0xc3, 0x13, 0x53,
+  0x0b, 0x99, 0x6f, 0xf1, 0x45, 0x61, 0x6f, 0xeb, 0x8e, 0xa7, 0x66, 0x35,
+  0x37, 0x0b, 0xa4, 0x30, 0x7b, 0x34, 0x5d, 0x3f, 0x0f, 0xae, 0x23, 0x27,
+  0xe9, 0xc9, 0xe1, 0xba, 0x8d, 0xa7, 0xe9, 0xc4, 0xbe, 0x1b, 0x44, 0xe7,
+  0x60, 0xfc, 0xcb, 0x05, 0x98, 0x42, 0xc4, 0x5e, 0x37, 0xfd, 0xaa, 0xd6,
+  0x1c, 0x0f, 0x3e, 0xa4, 0x21, 0xf6, 0x53, 0x55, 0x78, 0x4a, 0xe5, 0x36,
+  0x48, 0x83, 0xef, 0xe8, 0x2c, 0xbf, 0xa8, 0x73, 0x42, 0x6f, 0xdc, 0x26,
+  0x11, 0x71, 0x5e, 0x14, 0x53, 0xf6, 0x37, 0x4c, 0xb2, 0x71, 0xb1, 0x4d,
+  0x6a, 0x77, 0xb1, 0x6d, 0xe3, 0xab, 0x78, 0x16, 0xec, 0xce, 0x18, 0x0e,
+  0xdd, 0xdc, 0x62, 0x48, 0xc0, 0x38, 0x6a, 0x8e, 0x9e, 0xa6, 0x2b, 0xe1,
+  0x88, 0xa7, 0xd4, 0x2e, 0xcf, 0x87, 0x15, 0xa7, 0x2f, 0xe7, 0xcb, 0x8b,
+  0x93, 0xa1, 0x88, 0x4b, 0x75, 0x11, 0x7b, 0x49, 0x87, 0x34, 0xb2, 0xdd,
+  0x09, 0x1b, 0xe7, 0x6b, 0x58, 0xae, 0xb6, 0xe1, 0xf0, 0x80, 0x3f, 0x1c,
+  0x2e, 0xa1, 0x5e, 0x51, 0x37, 0xf9, 0x4a, 0x9c, 0x2f, 0x0d, 0x46, 0x84,
+  0xd9, 0xda, 0xfc, 0xc4, 0xfe, 0x94, 0xe5, 0xab, 0xc1, 0x65, 0x32, 0xc9,
+  0xf2, 0x78, 0x40, 0x37, 0x10, 0x1d, 0x03, 0x36, 0xe4, 0xf3, 0x5c, 0x89,
+  0x0b, 0xbd, 0xa7, 0xd9, 0xf3, 0x34, 0x3f, 0x3a, 0xc4, 0xd3, 0x75, 0x02,
+  0x26, 0x69, 0x84, 0x08, 0xee, 0x17, 0x13, 0x70, 0xf5, 0x36, 0xb0, 0x83,
+  0xda, 0x72, 0x79, 0xb3, 0x41, 0xb0, 0xa8, 0x10, 0x6e, 0x36, 0x5b, 0xc0,
+  0xf0, 0x94, 0x4c, 0xda, 0xf9, 0xd1, 0xb9, 0xe9, 0x88, 0x91, 0x7f, 0xd2,
+  0x1b, 0xb9, 0xea, 0xce, 0x6f, 0xe2, 0xf7, 0x57, 0x59, 0x4e, 0x7c, 0x7c,
+  0x56, 0x34, 0x48, 0x4b, 0x5c, 0xa7, 0xa6, 0xa9, 0xf6, 0xd4, 0xb2, 0x58,
+  0x2e, 0x73, 0x59, 0xfc, 0xe5, 0x3c, 0xe8, 0x80, 0x96, 0x6d, 0x39, 0x63,
+  0x87, 0xa7, 0xad, 0x42, 0xfb, 0x45, 0x60, 0x6b, 0xa2, 0x8a, 0x90, 0x89,
+  0xd5, 0x6c, 0x56, 0x61, 0xcb, 0x2f, 0x31, 0xdf, 0xb9, 0x77, 0xa4, 0x89,
+  0x91, 0x03, 0xe6, 0x8c, 0xba, 0xb8, 0xed, 0x1c, 0x01, 0x79, 0x82, 0x67,
+  0x59, 0x8b, 0xcd, 0xf3, 0x2c, 0xff, 0xa5, 0x7a, 0x8c, 0xf8, 0xdd, 0x1c,
+  0x33, 0x51, 0x43, 0x5a, 0x76, 0x55, 0xdf, 0x78, 0xd8, 0x4a, 0x52, 0xec,
+  0xdd, 0x76, 0x76, 0x79, 0x59, 0xdd, 0x17, 0x3e, 0xfc, 0x7d, 0xb4, 0x87,
+  0x7b, 0xed, 0xa5, 0x5c, 0x38, 0x0d, 0x86, 0xf2, 0x26, 0xbe, 0x4f, 0x67,
+  0xcb, 0x99, 0x18, 0xb5, 0x89, 0x8e, 0xf5, 0x31, 0xef, 0xc2, 0x8a, 0xc1,
+  0xdb, 0x54, 0x5a, 0xf1, 0x1c, 0xa5, 0x61, 0x57, 0x76, 0x56, 0x7d, 0x59,
+  0x40, 0xfe, 0x96, 0x38, 0xde, 0xc0, 0xd4, 0x74, 0x91, 0xc8, 0xa6, 0xe9,
+  0x2c, 0x2d, 0x8b, 0x1a, 0x77, 0x8a, 0x16, 0xd7, 0x71, 0x41, 0xd7, 0x22,
+  0xa4, 0x93, 0xba, 0x38, 0x8b, 0x75, 0xa5, 0x6f, 0xed, 0xe9, 0xa4, 0x71,
+  0x17, 0x11, 0xdd, 0x10, 0x53, 0x65, 0x11, 0x87, 0xd6, 0x91, 0xbd, 0xe6,
+  0x26, 0x35, 0xb4, 0x58, 0x86, 0x66, 0x24, 0xb9, 0xcc, 0xe2, 0x7b, 0x5e,
+  0x15, 0x13, 0x84, 0x7f, 0xad, 0x63, 0xa3, 0xfa, 0x45, 0xb0, 0x09, 0x35,
+  0x79, 0xf0, 0x25, 0x0b, 0x73, 0xd0, 0x6e, 0xea, 0x9b, 0xe0, 0xcc, 0x7c,
+  0x99, 0x32, 0x74, 0x7e, 0xd2, 0x19, 0xc7, 0xed, 0x36, 0x17, 0xbb, 0x3e,
+  0xc2, 0x06, 0x4c, 0x6c, 0x8d, 0x2f, 0xd9, 0xc6, 0xde, 0x54, 0x02, 0x16,
+  0xa4, 0x87, 0x81, 0x60, 0x9d, 0x6a, 0x3d, 0x50, 0x22, 0x95, 0x46, 0x8a,
+  0xa8, 0xd2, 0x4c, 0x45, 0xd5, 0x8c, 0x27, 0x6d, 0xd6, 0x85, 0x38, 0x90,
+  0xb8, 0x79, 0x74, 0xb4, 0x29, 0xd1, 0x1d, 0x2c, 0xbb, 0xfc, 0x1b, 0x5a,
+  0x73, 0xcd, 0x79, 0x7d, 0x95, 0xdf, 0xad, 0x35, 0x67, 0x16, 0x28, 0xa6,
+  0x94, 0xcd, 0x62, 0x8b, 0x8d, 0x09, 0x73, 0x2f, 0x8a, 0x83, 0x59, 0xdf,
+  0xcc, 0xb3, 0xbb, 0x79, 0x0f, 0x9f, 0x72, 0x5f, 0xb6, 0xbe, 0x18, 0x7b,
+  0x83, 0xf5, 0x25, 0x7a, 0xbd, 0x35, 0x9e, 0x2c, 0x9d, 0xcc, 0x29, 0xd4,
+  0x6b, 0x9a, 0x87, 0x0d, 0x34, 0x6a, 0x33, 0x1d, 0xab, 0x06, 0x12, 0xba,
+  0x4a, 0x93, 0x32, 0x54, 0x84, 0x4c, 0x3b, 0x75, 0xbe, 0xaf, 0x49, 0x5c,
+  0x5c, 0xf7, 0xa2, 0x4e, 0xbf, 0xd3, 0x6b, 0xa1, 0xb8, 0xba, 0x7e, 0x61,
+  0xe3, 0x72, 0x02, 0x67, 0xbb, 0xae, 0xa3, 0xe6, 0x15, 0x1d, 0x27, 0x88,
+  0x87, 0x44, 0xe3, 0x6e, 0x19, 0x58, 0xb0, 0x21, 0x43, 0xfb, 0xc6, 0x84,
+  0x1e, 0xef, 0xae, 0xb3, 0x69, 0xeb, 0x09, 0x0a, 0x0c, 0x2c, 0x19, 0x9a,
+  0x61, 0xab, 0x2f, 0xdc, 0xa5, 0xd0, 0x46, 0x6a, 0x1c, 0x2b, 0x1a, 0x4f,
+  0x93, 0x38, 0x9f, 0xae, 0x54, 0x13, 0xae, 0x9f, 0xa0, 0x5b, 0x99, 0x0a,
+  0x8c, 0xf4, 0x31, 0x51, 0x67, 0x3e, 0xc7, 0xfa, 0xaa, 0x6f, 0x2b, 0x99,
+  0x48, 0x70, 0x01, 0xf3, 0x0e, 0x15, 0x2b, 0x4d, 0x15, 0xbb, 0x4d, 0x61,
+  0xe9, 0x6b, 0xac, 0x76, 0x92, 0x4c, 0x46, 0xf1, 0xf8, 0x86, 0x57, 0x9a,
+  0xdb, 0x14, 0x27, 0x16, 0xce, 0x9f, 0x33, 0x0e, 0x12, 0x29, 0x5f, 0xd3,
+  0xc1, 0x2b, 0xd2, 0x72, 0x19, 0xaf, 0x3b, 0xb1, 0x55, 0xc5, 0xe7, 0x83,
+  0x87, 0xb6, 0x4a, 0xcb, 0x6d, 0xf6, 0x87, 0x35, 0x47, 0xfa, 0x80, 0x8f,
+  0x34, 0x49, 0x9e, 0xf3, 0x25, 0xe9, 0x3f, 0xc4, 0x56, 0x89, 0xed, 0x12,
+  0x81, 0x7c, 0xd6, 0x30, 0xbf, 0xc8, 0x23, 0xdb, 0xe7, 0x1a, 0x70, 0xe4,
+  0x8e, 0x58, 0xd5, 0xfd, 0x0b, 0xe9, 0x40, 0x56, 0xe9, 0x2a, 0xc5, 0x5e,
+  0x44, 0xd2, 0x5c, 0xd3, 0xd0, 0x59, 0x7f, 0x22, 0xf2, 0xeb, 0x9b, 0xdc,
+  0xc7, 0x70, 0x7a, 0xf9, 0x70, 0xa5, 0xd1, 0x4a, 0x0c, 0x13, 0x71, 0x59,
+  0x8f, 0x92, 0x30, 0x26, 0x7d, 0x93, 0x2e, 0x16, 0x6c, 0x42, 0x41, 0x24,
+  0x43, 0x60, 0x55, 0x1a, 0x25, 0x57, 0xe9, 0x7c, 0x1e, 0x06, 0x94, 0x64,
+  0x4b, 0x52, 0xba, 0x64, 0xcc, 0xa3, 0xe4, 0x12, 0x5c, 0xb6, 0x29, 0xdb,
+  0xf3, 0x48, 0x02, 0x37, 0xaa, 0xf3, 0xe6, 0x4c, 0x38, 0x3a, 0xc5, 0xd8,
+  0xcf, 0xf1, 0xa5, 0xec, 0x09, 0xab, 0x69, 0x6a, 0xc7, 0x6c, 0x3b, 0x32,
+  0x88, 0xf5, 0xd2, 0x6b, 0xc4, 0xdc, 0xca, 0xc3, 0xe3, 0xff, 0x71, 0xe4,
+  0x1d, 0xde, 0x66, 0xc8, 0x21, 0x4d, 0x10, 0xd4, 0xdd, 0x20, 0x87, 0x77,
+  0x24, 0x58, 0x74, 0xfa, 0x07, 0x51, 0xbf, 0xc3, 0xf6, 0xb8, 0xd0, 0xfb,
+  0x44, 0x7a, 0x43, 0x46, 0xc7, 0x1b, 0xa1, 0x15, 0xd3, 0x95, 0x44, 0x41,
+  0x81, 0xde, 0xa0, 0x9f, 0xe6, 0xc9, 0xf6, 0x35, 0x5f, 0x74, 0x59, 0x83,
+  0x5f, 0xf1, 0x16, 0xaa, 0x7f, 0x4a, 0xe7, 0xc9, 0xa6, 0xbc, 0x52, 0xdd,
+  0x5f, 0x72, 0xa1, 0xc9, 0xfe, 0x88, 0xb3, 0x71, 0x9b, 0x4d, 0x0c, 0xe2,
+  0x32, 0x6f, 0x6a, 0x42, 0x6a, 0xde, 0x17, 0xe7, 0x60, 0x0b, 0x0b, 0xf8,
+  0xf5, 0x6e, 0xa0, 0xbe, 0x70, 0x0b, 0xd2, 0x81, 0xf2, 0xfa, 0x38, 0xd8,
+  0x77, 0xe7, 0x2c, 0xe7, 0x7c, 0xb7, 0xff, 0x95, 0x64, 0xa8, 0x9a, 0xe5,
+  0x28, 0xd3, 0x41, 0x84, 0x71, 0x20, 0xd2, 0x66, 0x8b, 0x74, 0x48, 0x37,
+  0x34, 0x89, 0x5f, 0x31, 0x09, 0xbd, 0x30, 0x36, 0x41, 0xa7, 0x55, 0xc1,
+  0x36, 0xba, 0x4e, 0x69, 0xe4, 0xf9, 0xf8, 0x7a, 0x85, 0xcb, 0x02, 0x46,
+  0x63, 0x84, 0x1d, 0x98, 0x60, 0xb0, 0x68, 0xb1, 0xc5, 0x4b, 0x1f, 0x4a,
+  0xe2, 0x18, 0x7d, 0x04, 0x71, 0x8e, 0x9e, 0x33, 0x02, 0xaa, 0x8d, 0x8e,
+  0xe8, 0xe2, 0x1a, 0x74, 0x9b, 0x4c, 0x21, 0x04, 0x1c, 0xb7, 0xd9, 0xb1,
+  0xfa, 0x59, 0xc0, 0xc0, 0x79, 0xd7, 0x58, 0x1b, 0xe3, 0x58, 0x1c, 0xb1,
+  0x01, 0x4a, 0x47, 0xb0, 0x9c, 0x4b, 0x5f, 0x7c, 0xaf, 0xe1, 0x42, 0x5c,
+  0xd5, 0x9a, 0x53, 0xbf, 0xa2, 0xbe, 0xff, 0x21, 0xdf, 0x22, 0xbc, 0x63,
+  0xf2, 0x9d, 0xdd, 0x7d, 0xb6, 0x30, 0xa2, 0xc1, 0xd5, 0x4d, 0x23, 0x12,
+  0xc5, 0x09, 0xdd, 0xa1, 0xdf, 0xa7, 0xc3, 0xd0, 0x6f, 0x5d, 0x1a, 0xde,
+  0xd2, 0xea, 0x4e, 0x4f, 0x2f, 0xd5, 0x2d, 0x4b, 0xdc, 0x87, 0x28, 0xa5,
+  0x8c, 0x4e, 0x5e, 0x83, 0xda, 0x0e, 0xce, 0xe9, 0x27, 0xed, 0xb0, 0x1c,
+  0x39, 0xb0, 0x75, 0x0e, 0xc6, 0x84, 0x51, 0xe3, 0xcd, 0x37, 0xc3, 0x68,
+  0xf3, 0x74, 0xb8, 0xfd, 0xe4, 0xf9, 0xce, 0x7f, 0x56, 0xff, 0x9d, 0xc0,
+  0xb4, 0x05, 0x6b, 0xcc, 0xcb, 0x07, 0x4c, 0xed, 0x24, 0xdb, 0xb1, 0x54,
+  0xce, 0x07, 0xd1, 0x73, 0x70, 0x7e, 0x8f, 0x0d, 0xe1, 0x1c, 0x2a, 0x60,
+  0x4e, 0xa9, 0xc0, 0x14, 0xdf, 0x2a, 0xa3, 0xf6, 0x5c, 0x50, 0x18, 0xb3,
+  0xfb, 0x78, 0x25, 0xe7, 0x31, 0x8e, 0x46, 0x79, 0x76, 0x87, 0x68, 0x54,
+  0xf6, 0x22, 0x47, 0xb2, 0x3f, 0xb0, 0x45, 0x70, 0x88, 0x2a, 0x84, 0xd1,
+  0x3a, 0xbf, 0xa2, 0xed, 0xd7, 0x43, 0x14, 0xc3, 0x00, 0xfa, 0xe6, 0x84,
+  0x85, 0x08, 0xd6, 0x29, 0x44, 0x1f, 0x11, 0xfe, 0x50, 0x2c, 0x47, 0x24,
+  0xfc, 0xe2, 0x82, 0x2c, 0x9d, 0xed, 0x25, 0x0c, 0x28, 0xb5, 0xed, 0x8d,
+  0x39, 0x7a, 0x48, 0x19, 0xd6, 0xa2, 0xcd, 0xbd, 0xa0, 0xdc, 0xd1, 0xec,
+  0xc0, 0x2c, 0x4b, 0x93, 0x1c, 0x40, 0xc2, 0xfe, 0x6a, 0x51, 0x3f, 0x97,
+  0xa4, 0x27, 0x4f, 0xd5, 0x4c, 0xb2, 0x7d, 0xdf, 0x27, 0x55, 0xba, 0x8f,
+  0xc1, 0xf5, 0xa9, 0x79, 0x71, 0xd8, 0xe2, 0x1c, 0x1e, 0x90, 0xbc, 0x08,
+  0xa9, 0x8b, 0x9a, 0xef, 0xbf, 0xa6, 0x9d, 0xc0, 0x13, 0x0d, 0x72, 0xf0,
+  0x7b, 0xe4, 0xaf, 0x1e, 0x5e, 0x3a, 0x96, 0xff, 0xe4, 0x2b, 0xb1, 0x08,
+  0x8a, 0x43, 0x18, 0x11, 0xba, 0xea, 0xc8, 0x20, 0x66, 0x37, 0xad, 0x1f,
+  0x21, 0x58, 0xa9, 0xf3, 0x95, 0x04, 0x72, 0xa8, 0x11, 0xd9, 0xfc, 0x77,
+  0xce, 0x9e, 0x2a, 0x6d, 0xca, 0x93, 0xde, 0x6c, 0x9d, 0xb1, 0xf6, 0x5c,
+  0x3f, 0x91, 0xe2, 0x7d, 0xc6, 0x6b, 0xb7, 0xf1, 0x74, 0xc9, 0xfa, 0x64,
+  0x2c, 0xfb, 0x20, 0x2e, 0x6d, 0x0e, 0x4b, 0x8b, 0x57, 0xdc, 0xb8, 0x36,
+  0xec, 0xd6, 0xa0, 0x55, 0xa0, 0x40, 0x30, 0x86, 0xdc, 0x82, 0x85, 0xa9,
+  0x0a, 0x85, 0x3b, 0x04, 0x55, 0x93, 0xaa, 0x85, 0x29, 0x4a, 0x24, 0x48,
+  0x36, 0xeb, 0x37, 0x48, 0x5f, 0x43, 0xa3, 0x7a, 0x81, 0x77, 0x27, 0x05,
+  0xb3, 0x0c, 0xc8, 0x58, 0xd8, 0x08, 0x7b, 0xb7, 0x67, 0x49, 0x7e, 0x25,
+  0xf7, 0x28, 0x89, 0x44, 0x4d, 0x2b, 0x8b, 0xf8, 0xbd, 0x63, 0x17, 0x42,
+  0xc5, 0x07, 0xef, 0x0f, 0x7d, 0xf1, 0xbc, 0x30, 0x5b, 0x5d, 0xc2, 0xc5,
+  0xaa, 0xa2, 0x6f, 0xb7, 0x3f, 0x89, 0xd4, 0x89, 0x35, 0xa7, 0x95, 0xa0,
+  0x7d, 0x6c, 0x4a, 0x03, 0xd3, 0xe9, 0xab, 0x29, 0xc9, 0x26, 0xab, 0x6e,
+  0xa4, 0x51, 0x3e, 0x24, 0x8b, 0xcd, 0x13, 0x8e, 0xce, 0x62, 0x6b, 0x1d,
+  0xb6, 0x32, 0x1a, 0x5f, 0x2f, 0xe7, 0x37, 0x66, 0xa1, 0x9b, 0x92, 0x64,
+  0x5a, 0x44, 0x1c, 0xca, 0x5d, 0x6b, 0xae, 0x1b, 0x74, 0xf6, 0x87, 0xb0,
+  0xed, 0xd6, 0x55, 0x16, 0x09, 0x1b, 0x41, 0x79, 0x81, 0xe7, 0xcb, 0x31,
+  0x78, 0x75, 0x26, 0x7d, 0xde, 0x33, 0xaf, 0x72, 0x19, 0x38, 0x1c, 0xe2,
+  0xe6, 0x39, 0xf4, 0xd2, 0x39, 0x7b, 0x2a, 0x5c, 0x83, 0xe2, 0x1d, 0x22,
+  0x86, 0xd7, 0x37, 0x67, 0xaa, 0xd7, 0xab, 0x9c, 0x63, 0xa3, 0xcd, 0xf5,
+  0x21, 0xf4, 0xee, 0xdd, 0x96, 0x2e, 0x5a, 0x9e, 0xcf, 0x5b, 0x61, 0x62,
+  0x12, 0x77, 0xcd, 0x06, 0x34, 0xbd, 0x2f, 0x9a, 0x32, 0x17, 0x75, 0xd5,
+  0x77, 0x27, 0xee, 0x4d, 0x18, 0x0b, 0x58, 0x0d, 0x6d, 0x70, 0x04, 0x31,
+  0x88, 0xce, 0x32, 0x09, 0xee, 0xe5, 0x51, 0xb4, 0x7a, 0x7c, 0x63, 0x3f,
+  0xe9, 0x49, 0xd4, 0xbd, 0xcc, 0xb2, 0x51, 0x9c, 0x77, 0x75, 0x0b, 0xd9,
+  0xc3, 0x3e, 0x52, 0xbb, 0x97, 0x7a, 0xaf, 0x79, 0x3a, 0x9f, 0xd3, 0x73,
+  0x75, 0x0a, 0x1d, 0x85, 0xe1, 0x4d, 0xd5, 0x73, 0xf7, 0x10, 0x47, 0xbe,
+  0x50, 0x39, 0xbd, 0x54, 0x5b, 0x3a, 0x8b, 0xa2, 0x53, 0xbe, 0xe4, 0x6b,
+  0xfe, 0x19, 0xb8, 0x07, 0xc5, 0xad, 0x8f, 0x50, 0xa5, 0xc6, 0x95, 0x06,
+  0x57, 0x1c, 0x22, 0x40, 0x88, 0xb6, 0x8a, 0x2c, 0xb9, 0x4d, 0xf2, 0x7f,
+  0x07, 0xb1, 0x60, 0xd9, 0x68, 0x43, 0x0f, 0xf9, 0xfe, 0x90, 0x79, 0xb8,
+  0x08, 0x62, 0x09, 0xf9, 0x8a, 0x2c, 0x7e, 0xb8, 0xc1, 0xe3, 0x5a, 0x02,
+  0x8e, 0x7a, 0x98, 0xe1, 0x38, 0x59, 0x94, 0x76, 0x46, 0xe6, 0xc9, 0x9d,
+  0x7a, 0x27, 0xc1, 0x5c, 0x71, 0x15, 0x80, 0x6f, 0x8b, 0xb1, 0x69, 0xcc,
+  0x57, 0x74, 0xc1, 0x4c, 0x85, 0xbe, 0xad, 0x6b, 0x20, 0x58, 0x02, 0xde,
+  0xb9, 0x5f, 0x78, 0x2b, 0x9b, 0xe6, 0xc5, 0xae, 0x51, 0x7f, 0x3b, 0xb7,
+  0x08, 0xdb, 0x1c, 0xd0, 0x21, 0x21, 0xac, 0x1c, 0xc8, 0x24, 0x31, 0x7a,
+  0xc8, 0x8b, 0x90, 0x8c, 0x80, 0x91, 0x2c, 0x89, 0xe3, 0xfe, 0x0d, 0x32,
+  0x71, 0x5c, 0xf4, 0xe7, 0x50, 0x4a, 0xcf, 0xad, 0xb0, 0x5e, 0x69, 0x12,
+  0xf5, 0xab, 0x14, 0x6a, 0xdc, 0x16, 0x5b, 0xdb, 0x72, 0x2a, 0x65, 0x95,
+  0x53, 0x66, 0xba, 0xb1, 0x29, 0x8b, 0x49, 0x0e, 0x66, 0x5f, 0xb0, 0x4b,
+  0xc8, 0xac, 0x74, 0x83, 0x68, 0x73, 0x7f, 0x32, 0x91, 0x09, 0x7c, 0x32,
+  0xd8, 0xfd, 0x74, 0xb0, 0xb3, 0xd5, 0x22, 0x9a, 0x8d, 0x24, 0x18, 0x4a,
+  0xcd, 0x26, 0x69, 0x8c, 0x10, 0x79, 0x74, 0x23, 0xd3, 0xd1, 0x84, 0x05,
+  0x23, 0x24, 0xd2, 0x8f, 0x84, 0xe2, 0x62, 0x3e, 0x75, 0x0d, 0xe3, 0x01,
+  0x96, 0x5a, 0x54, 0x93, 0xd8, 0xd8, 0x73, 0x26, 0x41, 0x90, 0xb1, 0x71,
+  0x0d, 0x17, 0x8e, 0x12, 0x07, 0x7e, 0xd8, 0xd6, 0xb5, 0xe3, 0xae, 0xc1,
+  0x1c, 0xe0, 0x5e, 0x8d, 0xd9, 0xb0, 0x49, 0xcb, 0xc5, 0x5c, 0xab, 0x61,
+  0x38, 0xf5, 0xbb, 0x2c, 0x09, 0x20, 0x49, 0xf1, 0x62, 0xa3, 0x61, 0x8b,
+  0xe0, 0xfe, 0xdb, 0xb3, 0xa7, 0x44, 0x16, 0xf7, 0x3e, 0x6b, 0xee, 0xc5,
+  0x2d, 0x66, 0x12, 0x8a, 0x19, 0x22, 0xd9, 0x88, 0x60, 0x12, 0xaf, 0x69,
+  0x0e, 0x13, 0xfb, 0x6f, 0xea, 0x51, 0x18, 0x13, 0x81, 0x43, 0xe2, 0x2c,
+  0x32, 0xef, 0xc3, 0xb5, 0xa6, 0x5c, 0xa8, 0x1e, 0x7f, 0x12, 0x37, 0xfc,
+  0xd9, 0x2e, 0xac, 0x69, 0x15, 0x45, 0xaf, 0x24, 0x6d, 0xe9, 0xf3, 0x48,
+  0x8f, 0x3a, 0x6c, 0xc0, 0xa1, 0x9e, 0xcb, 0xea, 0x18, 0x0f, 0x9e, 0x2f,
+  0x63, 0x5e, 0x86, 0xf6, 0xe6, 0xd8, 0xd5, 0x1f, 0xae, 0x9e, 0x90, 0x1f,
+  0x82, 0x38, 0x0b, 0x49, 0x01, 0x6a, 0x38, 0x57, 0x5f, 0x7d, 0x78, 0xf5,
+  0x7e, 0xe6, 0xe2, 0x7d, 0x60, 0xf5, 0x2e, 0x38, 0x22, 0x97, 0x84, 0x04,
+  0x8e, 0x9c, 0x79, 0x15, 0x04, 0x56, 0x40, 0x07, 0x4e, 0xe7, 0xe3, 0xe9,
+  0x72, 0xe2, 0x3d, 0xd5, 0xd5, 0xa3, 0x19, 0x18, 0x32, 0x5e, 0xfd, 0x6a,
+  0xbb, 0xce, 0xd4, 0x68, 0xa3, 0x6f, 0x6f, 0x4e, 0x34, 0x5a, 0x1a, 0xbc,
+  0x8f, 0x6f, 0x62, 0xbd, 0x90, 0x03, 0xf5, 0xf1, 0x3a, 0xf5, 0x96, 0xdc,
+  0x2f, 0xc4, 0x90, 0xcb, 0x17, 0xef, 0x28, 0x69, 0x93, 0xe6, 0x2a, 0x42,
+  0xdd, 0xc4, 0x2e, 0xd5, 0xc6, 0xfc, 0x3e, 0x37, 0x2e, 0xfe, 0xc1, 0xc9,
+  0x55, 0xe2, 0x30, 0x38, 0xe6, 0x28, 0xbc, 0xda, 0x43, 0x0b, 0x4c, 0x8b,
+  0x3d, 0xc8, 0x38, 0x99, 0xac, 0xb9, 0xb8, 0x9e, 0x57, 0x8e, 0xbb, 0x6f,
+  0xf5, 0xaa, 0x0b, 0x16, 0xab, 0xd4, 0x2b, 0x1e, 0xa5, 0xf5, 0x6b, 0xc5,
+  0x56, 0x7b, 0xdb, 0x3e, 0x68, 0x2e, 0xad, 0xdb, 0xf7, 0x7f, 0xfa, 0x14,
+  0xd9, 0xe3, 0x67, 0xa1, 0xa0, 0x32, 0x4d, 0x35, 0x67, 0x79, 0xa2, 0xb8,
+  0x82, 0xb7, 0x17, 0xe6, 0xc7, 0xbf, 0x2d, 0xd9, 0xcc, 0x77, 0xb5, 0x8e,
+  0x09, 0xf0, 0x05, 0x05, 0x23, 0x23, 0x4c, 0x32, 0x53, 0x96, 0x8d, 0xa8,
+  0x69, 0xa6, 0x72, 0xaf, 0xcf, 0xf4, 0x39, 0xa4, 0x48, 0x89, 0x56, 0x28,
+  0xf1, 0x01, 0x62, 0x75, 0xe4, 0x19, 0x52, 0xa6, 0xc4, 0x00, 0xf8, 0x29,
+  0xb7, 0x50, 0xa0, 0xb9, 0x95, 0xdb, 0x6f, 0x3b, 0x09, 0x82, 0x28, 0xc4,
+  0xf5, 0x7e, 0xa8, 0xfe, 0xe7, 0x35, 0xbe, 0xf7, 0x38, 0xf8, 0xa6, 0xe9,
+  0xd6, 0xb3, 0x4b, 0x0e, 0xe6, 0x43, 0x96, 0x38, 0x39, 0x50, 0x9f, 0x56,
+  0xfc, 0x2e, 0xcb, 0xd5, 0x70, 0x37, 0x4a, 0x98, 0xeb, 0xe3, 0x88, 0xc2,
+  0x73, 0x27, 0x96, 0x60, 0xc4, 0xfc, 0x35, 0x83, 0x83, 0x60, 0xd9, 0x8d,
+  0x38, 0xb2, 0x61, 0x20, 0x66, 0x32, 0x8b, 0x22, 0x6a, 0x8f, 0x1b, 0x92,
+  0x74, 0x8b, 0xa8, 0xbf, 0xd4, 0xc0, 0xe5, 0x76, 0x1f, 0x1a, 0x47, 0x21,
+  0x4b, 0x76, 0xa8, 0x2c, 0xa5, 0xf1, 0x08, 0x0c, 0x51, 0x1c, 0x32, 0x2c,
+  0xdc, 0x7a, 0x8f, 0xfc, 0x5a, 0x27, 0xbc, 0x3a, 0xe9, 0x2d, 0x16, 0x12,
+  0x26, 0x0a, 0xcb, 0x8b, 0x54, 0x99, 0xe0, 0x3f, 0x1a, 0x17, 0xd8, 0xd7,
+  0x20, 0x8d, 0x7e, 0xb2, 0xc8, 0xcb, 0xd6, 0x80, 0xf8, 0x8b, 0xd0, 0xd8,
+  0x68, 0x21, 0x1d, 0xec, 0x9d, 0x2c, 0xdc, 0x5d, 0x73, 0x74, 0x76, 0x7e,
+  0xc1, 0x13, 0x3d, 0xc1, 0x2f, 0x6a, 0xe2, 0xac, 0x8f, 0x83, 0xad, 0x0e,
+  0x1a, 0x67, 0x8b, 0x58, 0xb3, 0x84, 0x8d, 0x43, 0x2e, 0x6b, 0x68, 0x10,
+  0x78, 0x1c, 0x5d, 0x52, 0x4c, 0x3c, 0xbd, 0x43, 0x7e, 0x09, 0x8b, 0x74,
+  0x8d, 0xb5, 0x75, 0xe9, 0x49, 0x18, 0x09, 0x86, 0xd0, 0x93, 0xfb, 0x92,
+  0x07, 0xa1, 0xa6, 0x5d, 0x11, 0x2a, 0xce, 0x4e, 0xf1, 0x25, 0xec, 0xf8,
+  0x16, 0x60, 0xbd, 0xc6, 0x7b, 0x2a, 0x29, 0x24, 0xca, 0x7d, 0xd0, 0x2c,
+  0xde, 0x8c, 0x72, 0xce, 0xfd, 0x8a, 0x69, 0x28, 0x83, 0xda, 0x54, 0x21,
+  0x05, 0x13, 0xe9, 0x05, 0x19, 0xbe, 0xa6, 0x81, 0xb2, 0xb4, 0x67, 0x92,
+  0x20, 0x35, 0xc0, 0x29, 0x31, 0x98, 0xb0, 0x65, 0x81, 0xf5, 0x58, 0x77,
+  0xc7, 0xc5, 0xc7, 0x21, 0xc1, 0xc8, 0x7b, 0x41, 0xa7, 0x62, 0x08, 0xa9,
+  0x8f, 0x0e, 0x43, 0xa7, 0x93, 0xcb, 0x6b, 0x2f, 0x9a, 0x7a, 0x74, 0xa9,
+  0x96, 0xcd, 0x78, 0x9a, 0x96, 0x2b, 0x11, 0xf1, 0x47, 0x72, 0x9f, 0xaa,
+  0xe1, 0x47, 0xd8, 0x30, 0xad, 0xef, 0x24, 0x6d, 0x3b, 0x84, 0x34, 0x1c,
+  0x9e, 0x9c, 0xee, 0xd6, 0x2f, 0x94, 0xca, 0x5b, 0x9d, 0xba, 0xeb, 0xbc,
+  0xba, 0xd2, 0x5e, 0xc3, 0xaf, 0xeb, 0x49, 0xb0, 0xb8, 0x6d, 0x25, 0x41,
+  0xa1, 0xc1, 0x40, 0xb7, 0x35, 0x32, 0x6c, 0xd2, 0xe1, 0xf0, 0x1b, 0x67,
+  0x61, 0x6f, 0x09, 0xdb, 0x15, 0xea, 0xc3, 0x41, 0x5e, 0x47, 0x7e, 0x3a,
+  0x01, 0x9f, 0x95, 0xa5, 0x14, 0xf8, 0x20, 0x09, 0xf2, 0x98, 0x84, 0x08,
+  0xa9, 0x7f, 0xa5, 0xbc, 0xb3, 0xfd, 0xe1, 0x37, 0x01, 0xcd, 0x05, 0x6b,
+  0xe9, 0xb2, 0x37, 0xea, 0x97, 0x23, 0xb2, 0x6f, 0x72, 0x8b, 0x05, 0x43,
+  0x5b, 0xff, 0xb9, 0x4d, 0xa9, 0x05, 0xe6, 0x89, 0xa3, 0xb7, 0x2e, 0xcc,
+  0x7f, 0xcb, 0xce, 0x5b, 0xcd, 0xb3, 0x92, 0x54, 0xc9, 0x20, 0xd2, 0xaf,
+  0x9a, 0x9d, 0xca, 0x71, 0x87, 0x1b, 0x6d, 0xd1, 0xee, 0xa1, 0x87, 0x4b,
+  0xe2, 0x42, 0xf5, 0x48, 0x33, 0xc3, 0x70, 0x96, 0x8d, 0xd2, 0x42, 0x16,
+  0xd1, 0xae, 0x76, 0xb3, 0xd1, 0x72, 0xfd, 0xc5, 0x1a, 0xaa, 0x9c, 0xb2,
+  0x43, 0x96, 0xfd, 0xfe, 0x19, 0x5a, 0x19, 0x68, 0x00, 0x71, 0x11, 0x4a,
+  0x0f, 0x36, 0x5c, 0x09, 0x65, 0x6c, 0x2a, 0x66, 0x73, 0x11, 0xe7, 0xd8,
+  0xf4, 0x62, 0x89, 0xb8, 0x1c, 0xe4, 0x16, 0x64, 0xf8, 0xf9, 0xf0, 0x3d,
+  0xb6, 0xf0, 0xf9, 0xa8, 0xcd, 0x56, 0x0e, 0xf3, 0x3b, 0x16, 0x15, 0xd6,
+  0xc4, 0x55, 0x62, 0x05, 0x24, 0xd5, 0x0e, 0x36, 0x2a, 0x3d, 0xce, 0x7c,
+  0x9e, 0x9b, 0x3e, 0x9c, 0x4a, 0xfc, 0x66, 0x63, 0x65, 0x43, 0x57, 0x48,
+  0x36, 0xb7, 0x80, 0xc4, 0x24, 0xf4, 0x44, 0xb9, 0x88, 0x15, 0xd1, 0xe8,
+  0x63, 0x6e, 0x6d, 0x5e, 0xa4, 0x13, 0x24, 0xf7, 0xd7, 0xf9, 0x0f, 0x5f,
+  0xc8, 0x1d, 0x5d, 0xae, 0x8e, 0x06, 0x97, 0x2c, 0xe5, 0x2d, 0xc4, 0x7e,
+  0xb2, 0x65, 0x2a, 0x4f, 0x7e, 0x43, 0xbf, 0x4f, 0x42, 0x2b, 0xc6, 0xa9,
+  0x61, 0xa0, 0x46, 0x12, 0x64, 0x1e, 0xb6, 0xa8, 0x73, 0x0c, 0xf3, 0xb9,
+  0x3e, 0x7e, 0x16, 0x5f, 0x25, 0x48, 0x20, 0x13, 0x47, 0xb8, 0x5e, 0xf0,
+  0x1f, 0x48, 0x2f, 0x6a, 0x24, 0xe8, 0x40, 0x20, 0xf0, 0x6e, 0x9a, 0x20,
+  0x1f, 0xe7, 0x72, 0x1a, 0x5f, 0x05, 0xd9, 0x38, 0xba, 0xf8, 0xcd, 0x80,
+  0xda, 0x89, 0x9a, 0x39, 0xab, 0xa1, 0xcb, 0x2e, 0x29, 0x5b, 0x4c, 0x15,
+  0x9d, 0x3f, 0xc3, 0x9f, 0xd7, 0xb1, 0x01, 0xba, 0x29, 0x37, 0x63, 0xad,
+  0xf0, 0x88, 0x57, 0x70, 0xaa, 0x5e, 0x40, 0x8c, 0x55, 0x8e, 0xa5, 0x7a,
+  0x68, 0xf1, 0x3c, 0x1f, 0x27, 0xe2, 0x3c, 0x24, 0x33, 0xd4, 0xf9, 0x00,
+  0xc9, 0x10, 0x12, 0x9c, 0x78, 0xa2, 0xc3, 0x7a, 0xa1, 0x27, 0x43, 0x74,
+  0x36, 0x1b, 0x94, 0x26, 0x35, 0xa9, 0xfa, 0x2e, 0x51, 0x46, 0x53, 0x20,
+  0x18, 0xd4, 0x2d, 0xd7, 0x10, 0xc9, 0xd5, 0x2a, 0x39, 0x61, 0xef, 0x3c,
+  0x06, 0x14, 0x43, 0x35, 0x48, 0x39, 0x85, 0xdd, 0x4d, 0xeb, 0xb7, 0xf4,
+  0x13, 0x26, 0xf3, 0x2b, 0xa4, 0xee, 0xbe, 0x6c, 0x8d, 0x4e, 0x49, 0xa6,
+  0x3e, 0xad, 0xd2, 0x02, 0xe6, 0xc6, 0xf9, 0x6a, 0x01, 0x7c, 0x00, 0x79,
+  0x4f, 0x99, 0x10, 0x04, 0x36, 0x09, 0x8b, 0x0b, 0xf2, 0x6f, 0x07, 0x2d,
+  0xee, 0x59, 0xd7, 0xa1, 0x44, 0x0c, 0xe2, 0x4a, 0x58, 0xd0, 0x72, 0x95,
+  0xbc, 0xae, 0xf2, 0x19, 0x92, 0x78, 0x46, 0xcb, 0x74, 0x3a, 0x91, 0x60,
+  0x1d, 0x0f, 0x67, 0xd0, 0xb0, 0xfc, 0xa3, 0xa1, 0x62, 0xa0, 0x49, 0x35,
+  0x66, 0x7b, 0x43, 0x96, 0x25, 0xcb, 0x08, 0x9b, 0xb0, 0x19, 0xcc, 0x69,
+  0xee, 0x5b, 0x76, 0xf1, 0xe9, 0x1b, 0x1a, 0x5e, 0x5f, 0xbf, 0xa6, 0x6e,
+  0xe3, 0x74, 0x2a, 0x89, 0x7d, 0x65, 0x94, 0x2f, 0xe7, 0xdc, 0x7b, 0x75,
+  0xa5, 0x6e, 0xd3, 0x3c, 0x9b, 0xcf, 0x9a, 0x3a, 0xf5, 0xe6, 0xf9, 0xf1,
+  0xf0, 0x20, 0x3a, 0x1d, 0x46, 0xa7, 0x6f, 0x4f, 0xbe, 0xdf, 0xa2, 0x65,
+  0x83, 0x5a, 0x23, 0xf0, 0x00, 0xe8, 0x3a, 0x78, 0x31, 0xba, 0x8d, 0xf3,
+  0x94, 0x55, 0x84, 0x5e, 0x10, 0xa1, 0xd2, 0xa2, 0xfe, 0xc9, 0xd9, 0xec,
+  0xdf, 0xd9, 0x16, 0xfb, 0xe8, 0x37, 0xc6, 0x66, 0x28, 0x52, 0x30, 0x3f,
+  0x0e, 0xd0, 0x62, 0xe3, 0xea, 0xd8, 0x92, 0xdd, 0x96, 0xcd, 0xdc, 0x2b,
+  0x58, 0x60, 0xc2, 0x53, 0x2d, 0xa1, 0x43, 0xd7, 0xf1, 0x2d, 0xba, 0xa7,
+  0x89, 0xb6, 0xfb, 0xd2, 0xff, 0x7d, 0x82, 0x4d, 0x72, 0x25, 0xaa, 0x5b,
+  0xfb, 0xed, 0x29, 0x71, 0xaf, 0x2e, 0x50, 0x4a, 0x68, 0x71, 0x11, 0x43,
+  0x3e, 0x65, 0x9d, 0xc3, 0x78, 0xc0, 0xd1, 0xbc, 0xcc, 0xb3, 0xc5, 0x2a,
+  0xfa, 0x32, 0x06, 0x8b, 0xc5, 0xd4, 0x0e, 0xe3, 0x64, 0xd6, 0x70, 0x2f,
+  0x17, 0xd9, 0xf8, 0x26, 0x29, 0xe5, 0xc0, 0xca, 0xef, 0x3e, 0x46, 0x1b,
+  0xea, 0x8c, 0xb0, 0xe8, 0x08, 0x9b, 0x37, 0xc1, 0xfd, 0xa7, 0xd4, 0x2a,
+  0x91, 0xe0, 0x34, 0x94, 0xa6, 0x65, 0xcd, 0x72, 0xfd, 0x03, 0x85, 0x47,
+  0x79, 0x12, 0x37, 0x21, 0x53, 0xab, 0x47, 0x9c, 0xf5, 0x8f, 0x70, 0xb3,
+  0xc1, 0x55, 0xfb, 0x12, 0xff, 0x8a, 0x51, 0x30, 0xf9, 0xe1, 0x85, 0x69,
+  0x4f, 0x3f, 0xb5, 0x2f, 0x43, 0x33, 0xc6, 0xbb, 0x2a, 0x3e, 0x04, 0x6d,
+  0x69, 0x54, 0x14, 0xb8, 0xd9, 0x55, 0x33, 0x4b, 0xa8, 0x94, 0x3c, 0x3e,
+  0x8d, 0x9c, 0xa2, 0xc5, 0x64, 0x64, 0xa1, 0x48, 0x82, 0xf2, 0x87, 0xb2,
+  0x3c, 0x61, 0x63, 0x16, 0x23, 0xcc, 0x1a, 0xfd, 0xd9, 0xd1, 0x9b, 0x75,
+  0xb1, 0x53, 0xaa, 0x95, 0x25, 0x76, 0x8f, 0x13, 0xa5, 0x38, 0x9d, 0x55,
+  0x52, 0x4b, 0xdd, 0x60, 0xc3, 0xec, 0xdc, 0x5a, 0x73, 0x7f, 0x5b, 0x02,
+  0xab, 0x65, 0xc2, 0x8b, 0xae, 0x1e, 0x36, 0x97, 0x08, 0x1d, 0x58, 0x98,
+  0x6a, 0xa1, 0x3f, 0x02, 0xe1, 0x00, 0x0e, 0x5d, 0x4f, 0x5a, 0x0d, 0x66,
+  0xd2, 0x51, 0x77, 0x91, 0x45, 0x2a, 0x09, 0xff, 0xe7, 0x94, 0x9e, 0xe8,
+  0x26, 0x59, 0xb9, 0x78, 0x50, 0xfb, 0x8c, 0x5e, 0x6d, 0xae, 0x9d, 0x2e,
+  0x0a, 0x6d, 0x3e, 0x7e, 0xce, 0xa1, 0xa6, 0xfe, 0x8e, 0x77, 0x5f, 0xf7,
+  0x54, 0xcc, 0x23, 0xfd, 0x3e, 0x1a, 0x64, 0x16, 0x57, 0x04, 0xd4, 0x3b,
+  0x6b, 0xe4, 0xa4, 0x38, 0x94, 0x9e, 0xe9, 0xaa, 0x55, 0xcb, 0xf5, 0x98,
+  0x42, 0x60, 0x8b, 0xa5, 0xa4, 0x17, 0x17, 0xa5, 0x45, 0x1e, 0x73, 0x58,
+  0xf6, 0x34, 0x1d, 0xe5, 0x70, 0xda, 0xb0, 0x34, 0x16, 0x1c, 0xdc, 0x46,
+  0xcc, 0x9c, 0x27, 0x20, 0xe8, 0xf9, 0xe9, 0xf8, 0x86, 0x4f, 0x91, 0x32,
+  0xc8, 0x70, 0xcb, 0x4d, 0xbc, 0x14, 0x94, 0x1e, 0xed, 0xab, 0xae, 0x29,
+  0xc4, 0x65, 0x0c, 0x94, 0x0e, 0xce, 0x1a, 0x48, 0xe7, 0x86, 0x76, 0x24,
+  0xd1, 0x49, 0x01, 0xd7, 0x73, 0x6c, 0x0f, 0x63, 0x7d, 0x7f, 0x78, 0x7c,
+  0xce, 0xcc, 0x79, 0xb4, 0x5a, 0x93, 0x7a, 0xb0, 0x9d, 0x94, 0xe3, 0xed,
+  0xc5, 0x4d, 0xba, 0x3d, 0x2f, 0x8a, 0xc9, 0x68, 0xcb, 0x25, 0x1d, 0x62,
+  0xb2, 0xa0, 0x3e, 0xfa, 0xe7, 0xeb, 0x83, 0xe1, 0x47, 0xbb, 0xbb, 0x9c,
+  0x6f, 0xbd, 0x84, 0x8a, 0xb3, 0x49, 0x0b, 0xd0, 0x48, 0x27, 0x2b, 0x68,
+  0xdd, 0x67, 0x83, 0x22, 0xdb, 0x62, 0x73, 0x8b, 0xe3, 0xef, 0xbc, 0x46,
+  0x68, 0x46, 0x9c, 0x70, 0x9a, 0x6c, 0x05, 0xcb, 0x59, 0x32, 0xf9, 0x4d,
+  0x43, 0x72, 0x68, 0x75, 0xd9, 0x53, 0x1f, 0xbd, 0xc4, 0xbf, 0x1f, 0x3c,
+  0xe2, 0x0c, 0xaf, 0x52, 0xd9, 0x12, 0xbc, 0xab, 0x8a, 0xc4, 0x6d, 0x0a,
+  0xf3, 0x54, 0xf8, 0x75, 0x33, 0x38, 0x0b, 0x6e, 0x4b, 0x9a, 0x67, 0x2f,
+  0x3a, 0x3c, 0x3a, 0x67, 0x9a, 0x3c, 0x7a, 0xfb, 0x25, 0xcb, 0xa2, 0x48,
+  0x48, 0xbb, 0x9a, 0xa7, 0x7f, 0x07, 0xb7, 0xa3, 0x36, 0x0b, 0x09, 0xd2,
+  0xc2, 0xd5, 0xe9, 0x8f, 0x67, 0xad, 0x39, 0xac, 0x17, 0x56, 0x91, 0x0f,
+  0xd9, 0x6f, 0xbb, 0x4c, 0xb1, 0x30, 0xc6, 0x83, 0xfd, 0x70, 0x76, 0xbf,
+  0x12, 0x43, 0xa4, 0xa7, 0x68, 0x44, 0x74, 0x16, 0x5b, 0xdc, 0x4b, 0x8b,
+  0xc4, 0x44, 0x39, 0x71, 0xeb, 0x12, 0x5d, 0xa8, 0x6f, 0x22, 0x04, 0xba,
+  0xa2, 0x61, 0x85, 0xcd, 0x16, 0xad, 0x49, 0x03, 0xc1, 0x03, 0x9b, 0xc5,
+  0x96, 0x63, 0x9f, 0xa9, 0xd2, 0x5d, 0x7b, 0xb2, 0x9b, 0x4f, 0x16, 0xe4,
+  0xbd, 0x29, 0x54, 0x66, 0x69, 0x0a, 0x0f, 0xe6, 0xf7, 0x3d, 0x20, 0x81,
+  0xf5, 0xfd, 0xc1, 0xfe, 0xfb, 0x2f, 0xde, 0xbd, 0x3d, 0x3c, 0x39, 0xea,
+  0xd6, 0x09, 0xe0, 0xd2, 0x71, 0x39, 0x12, 0x2c, 0x25, 0x6c, 0xbe, 0x16,
+  0xb3, 0xc6, 0xf7, 0x28, 0xa7, 0x63, 0xf2, 0x6f, 0x1c, 0xdc, 0xea, 0x26,
+  0xd8, 0x30, 0xae, 0xcc, 0x27, 0x9c, 0x14, 0x17, 0x6c, 0xb3, 0x25, 0x0c,
+  0xa8, 0x33, 0xc6, 0xc6, 0xd7, 0xa2, 0xc1, 0x26, 0x9c, 0x47, 0x35, 0x61,
+  0x09, 0x5a, 0xfd, 0x9f, 0x22, 0xe9, 0x05, 0x10, 0x3c, 0x15, 0xe1, 0x1c,
+  0x71, 0x06, 0x7c, 0x01, 0xc4, 0x34, 0xa0, 0x96, 0xd5, 0x2d, 0x2a, 0x1e,
+  0x70, 0xb4, 0x42, 0x84, 0xd3, 0xd7, 0x41, 0x8e, 0xf3, 0xb2, 0x4b, 0xc2,
+  0x49, 0xca, 0xce, 0x9d, 0x30, 0xda, 0x67, 0xd2, 0x9a, 0x43, 0x81, 0x40,
+  0xb5, 0x58, 0xc8, 0x68, 0x90, 0xdc, 0x27, 0x1c, 0x30, 0xa0, 0x6f, 0x1d,
+  0xb0, 0x64, 0x53, 0x46, 0xdf, 0x66, 0x39, 0x27, 0xb9, 0x1f, 0x5a, 0x64,
+  0x9b, 0x3d, 0x14, 0xcf, 0x57, 0x4d, 0x5f, 0xe0, 0x84, 0xa5, 0xb3, 0x8c,
+  0x9e, 0x67, 0x9c, 0xb8, 0xb3, 0xfd, 0x8b, 0xaf, 0xda, 0x4e, 0x8c, 0xa8,
+  0xc7, 0xc5, 0x23, 0xd8, 0xba, 0x6a, 0xd9, 0xe5, 0xfa, 0xb8, 0x39, 0xe1,
+  0xec, 0xeb, 0x59, 0x7b, 0xf5, 0x34, 0x35, 0xb9, 0x7b, 0x4b, 0x12, 0x8d,
+  0xe3, 0xee, 0xc6, 0xdc, 0x47, 0xab, 0xf5, 0x24, 0x19, 0x32, 0xf6, 0xf5,
+  0x9c, 0xbd, 0xc9, 0xda, 0xbd, 0xc8, 0x80, 0x2e, 0x71, 0x3a, 0x8c, 0xb7,
+  0x2b, 0x6b, 0xff, 0x3f, 0x82, 0xb3, 0xc7, 0x7c, 0x7e, 0x6a, 0x2c, 0xcb,
+  0x87, 0x41, 0xae, 0x11, 0x6a, 0x2f, 0xc2, 0x3d, 0xfb, 0x10, 0xfb, 0xf2,
+  0x31, 0x95, 0x0d, 0x23, 0x87, 0x70, 0xb4, 0x1a, 0x0f, 0x0b, 0x79, 0x54,
+  0x3b, 0x03, 0xea, 0x99, 0xb4, 0x53, 0xdf, 0x2c, 0xd7, 0x93, 0xbc, 0x07,
+  0x5d, 0x01, 0xf8, 0x1e, 0x09, 0x38, 0x46, 0x9e, 0x8d, 0x25, 0xd3, 0x26,
+  0x08, 0x42, 0x7b, 0x9f, 0x27, 0xd7, 0x71, 0x71, 0x1d, 0x2d, 0xcb, 0x14,
+  0x66, 0xd6, 0xba, 0xc8, 0xbd, 0x44, 0x24, 0x9a, 0xc5, 0x83, 0x58, 0x3e,
+  0x97, 0xa6, 0x5b, 0xbb, 0xb5, 0x63, 0xb8, 0x05, 0x4d, 0x39, 0xf1, 0x26,
+  0x4c, 0xa8, 0xee, 0x75, 0xa5, 0x74, 0x78, 0xd2, 0x0f, 0x21, 0xb6, 0x66,
+  0x48, 0xfc, 0x63, 0x63, 0x6f, 0x72, 0x49, 0xd3, 0x4d, 0x83, 0x1c, 0xaf,
+  0xa5, 0xeb, 0x82, 0x6f, 0x94, 0xf4, 0xb2, 0x2d, 0x33, 0xc4, 0xbe, 0x65,
+  0x76, 0xa2, 0xfc, 0xbe, 0x10, 0x10, 0xae, 0xea, 0x76, 0x16, 0xbf, 0x21,
+  0x05, 0x5d, 0x22, 0xf8, 0x8e, 0xa8, 0x78, 0x8d, 0xb5, 0xe6, 0x35, 0x83,
+  0xb5, 0x14, 0xf0, 0x08, 0x62, 0x72, 0x9b, 0xf3, 0xcc, 0xb0, 0x8d, 0x60,
+  0xca, 0x9b, 0x4e, 0xb7, 0x20, 0x26, 0xab, 0xc1, 0x8a, 0x63, 0xf9, 0x8b,
+  0xd6, 0x24, 0x58, 0x64, 0xb6, 0x67, 0x45, 0x69, 0x08, 0x5f, 0x0c, 0xc7,
+  0xc9, 0x13, 0x60, 0xbf, 0x17, 0x9b, 0xd1, 0xd4, 0x7a, 0xce, 0x90, 0x90,
+  0xc4, 0x63, 0xe9, 0xb4, 0xaa, 0xb7, 0x16, 0xdf, 0x36, 0x0e, 0x75, 0x3c,
+  0xb5, 0xa0, 0xb4, 0x4b, 0x45, 0x93, 0x54, 0x63, 0x2f, 0xf5, 0x7f, 0x3c,
+  0x37, 0x37, 0x92, 0x78, 0xd7, 0x59, 0x15, 0x89, 0x43, 0x63, 0x52, 0x9d,
+  0x6f, 0x72, 0xca, 0x20, 0xdc, 0x27, 0xc9, 0x34, 0x15, 0xe3, 0x9e, 0x65,
+  0x73, 0xb1, 0xae, 0x20, 0x29, 0x5f, 0x85, 0x8b, 0xb5, 0xb4, 0x2f, 0x11,
+  0x18, 0x54, 0x36, 0x13, 0x16, 0x90, 0x08, 0xb4, 0xa9, 0x80, 0x1e, 0x0c,
+  0x20, 0x67, 0xd9, 0x41, 0x16, 0xde, 0x82, 0x21, 0xad, 0x1c, 0x22, 0xe8,
+  0x96, 0xde, 0x6c, 0x6c, 0xa7, 0x6a, 0x31, 0x3b, 0xab, 0x1f, 0x4e, 0x68,
+  0x53, 0xf0, 0x5c, 0x79, 0x07, 0x4a, 0x39, 0x05, 0x71, 0x19, 0xa6, 0xa5,
+  0x49, 0x3e, 0xc5, 0xde, 0x5e, 0xbb, 0x29, 0x57, 0x73, 0x56, 0xd5, 0xa1,
+  0x8f, 0x69, 0xf7, 0x8b, 0xf8, 0xd2, 0x81, 0x72, 0x10, 0x25, 0x43, 0x46,
+  0x23, 0xad, 0x3a, 0x16, 0xff, 0x08, 0xc7, 0xa8, 0xb3, 0x29, 0xa3, 0xe1,
+  0x3f, 0x59, 0x8e, 0x71, 0x1a, 0xa1, 0xe1, 0x07, 0xb0, 0x57, 0xf0, 0x5c,
+  0x3a, 0xe7, 0x70, 0x31, 0x4d, 0x17, 0xd4, 0x6a, 0x9e, 0x2d, 0xaf, 0xae,
+  0xe9, 0x4a, 0x64, 0xde, 0xc2, 0x17, 0x6c, 0x8b, 0xe1, 0xbf, 0x96, 0x5c,
+  0xcb, 0x12, 0xe4, 0x6d, 0x36, 0x85, 0xdd, 0x72, 0xd3, 0x35, 0x2f, 0xad,
+  0x3f, 0xdd, 0xd9, 0xe5, 0xf1, 0x3e, 0xdd, 0xf9, 0x64, 0xeb, 0x67, 0x62,
+  0x2a, 0x69, 0x04, 0xa9, 0x58, 0x88, 0x75, 0x94, 0x7c, 0xf7, 0x39, 0x8f,
+  0x45, 0xc3, 0x4b, 0x04, 0xba, 0xe7, 0x85, 0x5a, 0xe6, 0x15, 0x93, 0x0c,
+  0x82, 0xa4, 0xe3, 0x31, 0x67, 0x33, 0x44, 0x3f, 0xe0, 0xba, 0xfa, 0x69,
+  0x3d, 0x5a, 0x95, 0xa2, 0x54, 0x39, 0x70, 0x8e, 0x1b, 0x41, 0xe7, 0xeb,
+  0xd8, 0xfb, 0x78, 0xbd, 0xa3, 0xc6, 0x11, 0xe7, 0xd2, 0x6c, 0x01, 0xd9,
+  0x71, 0xfa, 0x2c, 0xb2, 0xd3, 0x8c, 0x27, 0xb2, 0x34, 0xae, 0xc9, 0xec,
+  0x13, 0x0d, 0x2b, 0x13, 0xc7, 0xec, 0xe5, 0xe5, 0x7a, 0x43, 0xcf, 0xfe,
+  0xc1, 0x81, 0xf7, 0x2c, 0x55, 0x43, 0x96, 0x9e, 0x20, 0x64, 0xe9, 0x17,
+  0x27, 0x97, 0x57, 0xb2, 0x39, 0xcd, 0xc6, 0x59, 0x27, 0x1e, 0xb1, 0x79,
+  0x2e, 0x8b, 0xc6, 0x8a, 0xae, 0x4f, 0x1d, 0x68, 0x2e, 0xa7, 0x46, 0xad,
+  0xc3, 0x74, 0xba, 0xed, 0x93, 0x8d, 0x58, 0xcc, 0x34, 0xa1, 0x92, 0xa3,
+  0x06, 0x24, 0xd8, 0xa7, 0x29, 0xf0, 0x6a, 0x4a, 0xae, 0x04, 0xd6, 0xbb,
+  0x70, 0x5a, 0x8d, 0xd3, 0x16, 0x14, 0x29, 0x5a, 0x9c, 0x38, 0x47, 0x08,
+  0x16, 0x4c, 0x56, 0x19, 0x27, 0xba, 0xa8, 0xe0, 0xd4, 0x92, 0x60, 0x01,
+  0x04, 0x99, 0x10, 0xc9, 0xa3, 0x99, 0xc4, 0x60, 0xc1, 0xc6, 0x81, 0x67,
+  0xb4, 0x3d, 0xb1, 0x61, 0x96, 0x4a, 0x6c, 0x62, 0x10, 0xb3, 0xff, 0xb8,
+  0x04, 0x24, 0x35, 0x63, 0xaf, 0xd9, 0x16, 0x21, 0xf5, 0x76, 0x4a, 0xf7,
+  0x37, 0x2f, 0x8f, 0xa8, 0x6a, 0x32, 0xe2, 0xbd, 0x51, 0xde, 0xf1, 0x83,
+  0xfc, 0x6c, 0x27, 0x77, 0xe4, 0x20, 0xe5, 0x99, 0xea, 0x8f, 0xfa, 0x82,
+  0xa4, 0xd0, 0x4a, 0x30, 0x9b, 0x87, 0x57, 0x19, 0x5f, 0x9b, 0x11, 0x88,
+  0xc3, 0x35, 0xea, 0x86, 0x13, 0x6a, 0x6d, 0x73, 0xb8, 0x65, 0xde, 0x56,
+  0x11, 0x2b, 0xb4, 0xbd, 0x38, 0xbf, 0x52, 0xe6, 0xeb, 0x22, 0x2d, 0x1b,
+  0x31, 0x69, 0xfd, 0x86, 0xa5, 0xe3, 0x8a, 0x58, 0x30, 0x9d, 0x2f, 0x84,
+  0x1b, 0xdc, 0xb6, 0xc4, 0xa9, 0xb1, 0x92, 0x35, 0xbe, 0x9b, 0xb4, 0x87,
+  0x6d, 0xf0, 0x14, 0x38, 0x34, 0xdf, 0x65, 0xe0, 0x1d, 0x7c, 0x7b, 0x18,
+  0xa4, 0xb8, 0xe1, 0x38, 0xf3, 0x9c, 0xd4, 0x3e, 0xc8, 0x31, 0x26, 0xd1,
+  0xba, 0xc8, 0xb2, 0x20, 0x2e, 0x06, 0xe0, 0xde, 0x8c, 0x48, 0x31, 0x49,
+  0x92, 0x85, 0x4b, 0x59, 0x61, 0x4c, 0x16, 0xe1, 0xd7, 0x31, 0x71, 0x61,
+  0x06, 0x72, 0x9d, 0x35, 0xc5, 0x7d, 0x9f, 0x7a, 0xc9, 0xee, 0x7c, 0x1f,
+  0xdf, 0x81, 0xa4, 0xa2, 0xf3, 0xd7, 0x07, 0xbb, 0x9f, 0x3c, 0xf9, 0x94,
+  0x94, 0x0f, 0x78, 0x47, 0xe1, 0x34, 0x0f, 0x40, 0x69, 0x34, 0xce, 0x73,
+  0x7d, 0x7c, 0x8f, 0xda, 0xa7, 0x4c, 0x78, 0x96, 0x0c, 0x3b, 0xa2, 0x26,
+  0x84, 0x1a, 0xb2, 0x3c, 0x27, 0x27, 0xa2, 0x19, 0x3f, 0x94, 0xd1, 0x22,
+  0x3a, 0xf8, 0x49, 0x4e, 0x66, 0x40, 0x18, 0x2e, 0x56, 0x4b, 0xe4, 0x85,
+  0x41, 0x70, 0x1e, 0x26, 0x19, 0x67, 0x59, 0xf5, 0xa2, 0xf3, 0xa3, 0x8b,
+  0xf3, 0x5e, 0x34, 0xbc, 0x38, 0x3d, 0x5f, 0x13, 0x94, 0x45, 0xb2, 0x00,
+  0x18, 0x20, 0xd6, 0x0c, 0x64, 0x83, 0xbc, 0x78, 0x53, 0x1b, 0x83, 0xe4,
+  0x04, 0xd6, 0xd9, 0x24, 0x28, 0xaf, 0x68, 0x0d, 0x8a, 0x0f, 0x62, 0xe3,
+  0x83, 0xd5, 0x62, 0xb2, 0x21, 0x29, 0xe9, 0xc1, 0x89, 0xc9, 0xb6, 0x3f,
+  0x82, 0x42, 0x40, 0x8b, 0x98, 0xae, 0x73, 0x45, 0xf1, 0x68, 0x15, 0x63,
+  0xd0, 0x9f, 0xb2, 0x35, 0x30, 0x58, 0xce, 0x15, 0xc9, 0x91, 0xf0, 0x0e,
+  0x8c, 0x98, 0x0f, 0x4a, 0xc7, 0x9c, 0xde, 0x1d, 0x36, 0x3a, 0xdd, 0x24,
+  0x41, 0x94, 0xd3, 0x07, 0xe8, 0x97, 0xc4, 0xa0, 0x2d, 0x97, 0xfc, 0xc4,
+  0x68, 0x50, 0xd9, 0x2c, 0xe1, 0x43, 0x2a, 0xf2, 0xab, 0xb1, 0xba, 0xc2,
+  0x07, 0xa4, 0xb2, 0x1c, 0xdb, 0xde, 0x5c, 0x97, 0x77, 0xb9, 0xeb, 0x7c,
+  0xe7, 0x99, 0x52, 0x87, 0xec, 0x0b, 0xc9, 0x71, 0xd3, 0x92, 0xf3, 0x18,
+  0xba, 0x36, 0xaa, 0x6e, 0x9d, 0x97, 0xd0, 0x4d, 0xd6, 0x1e, 0x49, 0x00,
+  0x47, 0x0d, 0x1c, 0xf3, 0x22, 0xb3, 0xb9, 0x0c, 0x3f, 0x0e, 0xac, 0xe5,
+  0xcf, 0x75, 0xbf, 0x04, 0x0c, 0x1e, 0x46, 0x5e, 0xa3, 0xd1, 0x86, 0x43,
+  0x54, 0x36, 0x52, 0x3c, 0xfc, 0xcb, 0x3a, 0x5b, 0xae, 0xf8, 0xc8, 0xaa,
+  0x40, 0x21, 0xec, 0x93, 0xab, 0x53, 0x0e, 0xee, 0x2b, 0x1d, 0x3a, 0x12,
+  0x57, 0x2d, 0x31, 0xa4, 0x72, 0x71, 0xee, 0xb6, 0x5f, 0x9c, 0xff, 0x3e,
+  0x40, 0x0f, 0x96, 0x49, 0x3c, 0x97, 0xeb, 0x97, 0x19, 0x87, 0x50, 0x45,
+  0x2f, 0x95, 0x43, 0x7c, 0xd6, 0x1e, 0xbc, 0xc1, 0x99, 0x27, 0x81, 0xfc,
+  0x65, 0xb0, 0x88, 0x0c, 0x00, 0x39, 0x54, 0xfb, 0x1d, 0x2d, 0xfe, 0xd0,
+  0x71, 0x1a, 0x11, 0x98, 0x7b, 0x8d, 0x1c, 0x27, 0x83, 0x6d, 0xf1, 0x92,
+  0x85, 0x39, 0xba, 0x4d, 0x6d, 0x62, 0x69, 0x84, 0x18, 0xc2, 0xc5, 0x72,
+  0x46, 0x77, 0xd0, 0x5d, 0x92, 0x4c, 0xba, 0x05, 0xbc, 0x7d, 0xc0, 0x0b,
+  0xac, 0x0b, 0xac, 0xd8, 0x7c, 0x5e, 0x6d, 0x97, 0xe1, 0xcf, 0xb1, 0x66,
+  0xec, 0x27, 0xb0, 0x54, 0x93, 0xd8, 0x40, 0xe3, 0x02, 0x6d, 0x49, 0xfd,
+  0x5b, 0x75, 0x53, 0xfc, 0xf0, 0xf8, 0xe2, 0x28, 0xda, 0x7f, 0x77, 0xf1,
+  0x55, 0x27, 0x80, 0x08, 0x0d, 0xb8, 0x07, 0xdf, 0x4b, 0x25, 0xdd, 0xb5,
+  0xb7, 0x22, 0xb7, 0xb0, 0x28, 0x26, 0x8e, 0x9e, 0x96, 0x8c, 0xf2, 0x9a,
+  0xcd, 0xba, 0x46, 0x0a, 0xcf, 0x06, 0xcf, 0xb6, 0x6a, 0x1b, 0x83, 0x04,
+  0x58, 0xa6, 0xfb, 0x7e, 0xba, 0xf8, 0x70, 0x1c, 0x17, 0xc4, 0x73, 0x53,
+  0xca, 0x8f, 0xcf, 0xa2, 0x78, 0x32, 0x61, 0xa4, 0xd5, 0x60, 0xb8, 0xc5,
+  0xf2, 0x0a, 0x31, 0x7e, 0x2d, 0x78, 0x5c, 0x40, 0x3b, 0x70, 0x32, 0xb3,
+  0x06, 0x6f, 0xd3, 0x2a, 0xf3, 0xf1, 0x09, 0x63, 0x6f, 0xa4, 0x33, 0xdd,
+  0x99, 0xc2, 0x27, 0x9f, 0xac, 0x75, 0x34, 0xc1, 0x56, 0x6b, 0x78, 0x87,
+  0xe3, 0x20, 0x18, 0x47, 0xd1, 0xa7, 0xbd, 0xad, 0x2b, 0x18, 0x71, 0x23,
+  0x73, 0xd7, 0xb2, 0x55, 0x58, 0x50, 0x33, 0x3c, 0xf3, 0xb1, 0xca, 0x0d,
+  0x61, 0x5f, 0x95, 0x05, 0x7d, 0x3a, 0xd8, 0xdb, 0x6a, 0xd5, 0x68, 0xf4,
+  0x60, 0x41, 0x22, 0xa6, 0x73, 0x41, 0x7a, 0x38, 0xdc, 0xc6, 0xa4, 0x6e,
+  0x4b, 0x44, 0x19, 0x07, 0x83, 0x51, 0x1f, 0x1c, 0xf7, 0x63, 0x87, 0xcf,
+  0xe4, 0xb0, 0x26, 0x2e, 0x0d, 0x96, 0xe8, 0xd7, 0x13, 0xb4, 0x74, 0xff,
+  0x5a, 0x33, 0x01, 0xbb, 0x85, 0x6d, 0x20, 0x7c, 0xf4, 0xb2, 0x56, 0xf5,
+  0xa3, 0x5c, 0x14, 0xd3, 0x76, 0x42, 0xc9, 0x5d, 0x04, 0xce, 0x70, 0x78,
+  0xb2, 0x7d, 0x71, 0x32, 0x74, 0xeb, 0x08, 0x79, 0xb8, 0xb2, 0x5f, 0xe7,
+  0x60, 0x34, 0x00, 0x36, 0x62, 0x18, 0xdc, 0xc6, 0x65, 0x3d, 0xef, 0x2b,
+  0x54, 0x67, 0x05, 0x66, 0x23, 0xbd, 0x74, 0x9a, 0x52, 0x2e, 0x49, 0x21,
+  0x12, 0x2f, 0xaf, 0x9e, 0x60, 0xeb, 0xb5, 0x01, 0xf8, 0xea, 0xa3, 0x2e,
+  0x75, 0xf8, 0x7d, 0xdb, 0x57, 0x89, 0xb1, 0xb4, 0x4f, 0xf3, 0xe4, 0x6f,
+  0xe2, 0x61, 0x73, 0xd0, 0x38, 0xd1, 0x34, 0xb9, 0xad, 0xb3, 0xdc, 0x64,
+  0x5a, 0x88, 0x0b, 0x9b, 0xdd, 0xfe, 0x18, 0x98, 0x02, 0x4b, 0x4e, 0x1e,
+  0xc7, 0x77, 0x7f, 0x4d, 0xe9, 0x18, 0x4d, 0xb5, 0x6c, 0x8f, 0xcd, 0xaf,
+  0x75, 0x9b, 0xce, 0x15, 0x06, 0xb3, 0xbe, 0x47, 0x88, 0xf0, 0x89, 0xa6,
+  0xd9, 0x15, 0x00, 0x29, 0x2d, 0x3c, 0x96, 0x7d, 0xbc, 0x2e, 0xcf, 0xbb,
+  0xae, 0xab, 0x4d, 0x25, 0xfc, 0xc3, 0xb6, 0xaa, 0xaa, 0x2b, 0xcb, 0x05,
+  0x87, 0xad, 0xd4, 0x95, 0xb2, 0xf4, 0x54, 0x17, 0x39, 0xd7, 0xf4, 0x98,
+  0x3a, 0x7b, 0xd5, 0x78, 0x35, 0x10, 0x13, 0x4f, 0x61, 0xb1, 0x88, 0x02,
+  0x11, 0x90, 0x5e, 0x56, 0xa0, 0x69, 0x5c, 0xc2, 0x44, 0x2b, 0x88, 0x64,
+  0x40, 0x11, 0x51, 0x75, 0x67, 0x3e, 0xfe, 0xcf, 0xed, 0x0c, 0x68, 0xec,
+  0x67, 0x6d, 0x0b, 0x8e, 0x4e, 0xf5, 0xec, 0x10, 0x47, 0x66, 0xcf, 0xaf,
+  0xe5, 0x84, 0xaf, 0xe5, 0x8b, 0xcd, 0x13, 0xb3, 0xf6, 0xc8, 0x04, 0x0b,
+  0x54, 0x6b, 0xae, 0x7e, 0x6b, 0xfc, 0x36, 0x06, 0x8d, 0xb5, 0x84, 0x3c,
+  0x1e, 0xb7, 0x0b, 0x07, 0x1c, 0xb1, 0x7d, 0x70, 0x70, 0x40, 0x1f, 0x1c,
+  0x08, 0xad, 0x1e, 0xe8, 0x15, 0x72, 0x70, 0x8d, 0x3c, 0xb5, 0xe9, 0x56,
+  0x34, 0xbc, 0x5e, 0x22, 0xc5, 0x2a, 0xbb, 0x13, 0x59, 0x55, 0xa7, 0x5a,
+  0x8f, 0x60, 0x8a, 0x57, 0xb0, 0x7d, 0x08, 0x76, 0x4c, 0x45, 0xd8, 0x10,
+  0xe5, 0x8e, 0x73, 0xe7, 0xcc, 0x17, 0x6c, 0xb7, 0x81, 0xf4, 0xd0, 0x9a,
+  0xde, 0xba, 0x9c, 0x3b, 0x20, 0x36, 0x67, 0xd8, 0x9c, 0xbb, 0x13, 0xa0,
+  0xc2, 0x7d, 0x2c, 0x27, 0xe7, 0xed, 0xfe, 0x05, 0x10, 0x7d, 0x4b, 0x8d,
+  0x7b, 0x6c, 0x8f, 0xaf, 0x72, 0x44, 0xc0, 0x87, 0x20, 0x0e, 0x30, 0xcc,
+  0x4c, 0x09, 0x62, 0x60, 0x3e, 0xe4, 0x7d, 0x49, 0x78, 0xea, 0x40, 0xfd,
+  0xee, 0x2d, 0xe9, 0xf2, 0xba, 0xa2, 0x7d, 0x7e, 0x83, 0x43, 0x09, 0xd8,
+  0x1d, 0x84, 0x3f, 0x8b, 0xe6, 0x19, 0xd9, 0xfd, 0x8f, 0x71, 0x2f, 0x1b,
+  0xe2, 0x0f, 0x12, 0xef, 0xbd, 0xad, 0x33, 0xfb, 0x69, 0xad, 0x68, 0x0e,
+  0x42, 0x50, 0x3a, 0x68, 0x92, 0x01, 0x03, 0xe8, 0x31, 0x41, 0x32, 0xbd,
+  0xa0, 0xe5, 0x56, 0x0f, 0xa5, 0x85, 0xf7, 0x2a, 0xd2, 0xa1, 0x05, 0xf4,
+  0x96, 0x1a, 0x7d, 0xa6, 0x11, 0xab, 0x05, 0x51, 0xd5, 0x84, 0x11, 0x79,
+  0xc0, 0xdf, 0xcc, 0x74, 0x72, 0x17, 0x37, 0x04, 0x0a, 0x3b, 0xc0, 0x5e,
+  0x8c, 0x23, 0xbd, 0x32, 0x55, 0x17, 0x83, 0x03, 0xf0, 0xc8, 0x93, 0xc5,
+  0x74, 0xe5, 0xf4, 0x45, 0x6d, 0x7b, 0x9d, 0x60, 0x17, 0x5a, 0x1d, 0x34,
+  0x14, 0x5e, 0x36, 0x5f, 0x07, 0x58, 0x54, 0x5b, 0xe1, 0x8e, 0x62, 0x88,
+  0x5d, 0x97, 0x0d, 0xf8, 0xd1, 0x58, 0x7b, 0xae, 0xa1, 0xe8, 0x36, 0xa9,
+  0x20, 0x90, 0x6f, 0x5c, 0x42, 0xbc, 0x42, 0x01, 0x6b, 0x62, 0xc9, 0x43,
+  0x69, 0x8e, 0x53, 0x2c, 0x3e, 0xcb, 0x64, 0x09, 0x29, 0x5d, 0x9c, 0xd6,
+  0x60, 0x20, 0x01, 0xe9, 0x5c, 0x72, 0xd2, 0x91, 0x45, 0x28, 0x36, 0x69,
+  0x05, 0x16, 0xa8, 0x23, 0xdf, 0x21, 0xdf, 0xd4, 0xc0, 0xcc, 0x94, 0xb1,
+  0x08, 0x7c, 0x40, 0x15, 0x3f, 0x40, 0x81, 0x2c, 0x4d, 0x52, 0x65, 0x00,
+  0x84, 0x16, 0xb1, 0xd1, 0x3b, 0x69, 0x0e, 0x14, 0x29, 0xe0, 0x02, 0x31,
+  0x04, 0xe2, 0xcd, 0x8e, 0xf3, 0x72, 0x9b, 0x31, 0x01, 0xf8, 0xa6, 0x82,
+  0x1d, 0x34, 0x9f, 0x28, 0xba, 0x3c, 0xec, 0x16, 0x9f, 0x7e, 0xfc, 0x49,
+  0x6b, 0xb8, 0xa7, 0xfa, 0x08, 0x8a, 0x10, 0xdf, 0x19, 0xe0, 0x33, 0x92,
+  0x35, 0x2c, 0x9e, 0x37, 0xd4, 0xc5, 0x40, 0x8e, 0x25, 0x43, 0x77, 0x72,
+  0xff, 0xdd, 0x71, 0xd3, 0x7c, 0x8d, 0x01, 0x75, 0xc5, 0x4c, 0x23, 0x99,
+  0x37, 0x56, 0xa6, 0x41, 0x6a, 0xbb, 0x78, 0xa5, 0x5b, 0x81, 0x79, 0xe0,
+  0xac, 0x9e, 0x47, 0x9f, 0x73, 0xa6, 0x10, 0x9a, 0xaf, 0x35, 0xf7, 0x57,
+  0x38, 0xab, 0xae, 0x92, 0xb2, 0x99, 0xbc, 0xa6, 0x40, 0x56, 0x1f, 0x68,
+  0xbc, 0x85, 0x06, 0x35, 0xf7, 0xee, 0xa5, 0xf2, 0x20, 0xa7, 0xf0, 0x59,
+  0x4d, 0x13, 0x1a, 0x0c, 0xc7, 0xfa, 0xbc, 0x74, 0xd8, 0x08, 0x0e, 0xca,
+  0xf2, 0xf3, 0x16, 0xad, 0x51, 0xc2, 0x47, 0xc5, 0xe0, 0xc6, 0xa0, 0x47,
+  0x65, 0x19, 0x5b, 0xf5, 0x22, 0xb6, 0xd2, 0x22, 0xdf, 0xde, 0xc1, 0x23,
+  0xbb, 0x8a, 0x0a, 0x44, 0x31, 0xd3, 0x36, 0xd8, 0x95, 0x97, 0xda, 0x68,
+  0x2c, 0x98, 0xa5, 0x82, 0x77, 0x80, 0xf1, 0xb4, 0xad, 0x84, 0xc9, 0xf9,
+  0xc8, 0x7d, 0x4a, 0xee, 0x1b, 0xe7, 0x97, 0xdf, 0x0d, 0xd6, 0xa9, 0x21,
+  0x81, 0x1f, 0xdd, 0xc7, 0x33, 0x2e, 0xac, 0xe3, 0xaa, 0x0f, 0xb0, 0x6f,
+  0xdb, 0xa7, 0x24, 0x69, 0x78, 0x45, 0x68, 0xc0, 0x15, 0xcf, 0x45, 0x17,
+  0xcf, 0xd4, 0xf7, 0x1e, 0xef, 0x74, 0xcd, 0x90, 0x10, 0x3a, 0xaa, 0x99,
+  0x22, 0x65, 0x38, 0x0e, 0x15, 0x4d, 0xbc, 0xc6, 0xe8, 0x69, 0xb2, 0x26,
+  0x64, 0x0c, 0x6f, 0x32, 0xf4, 0xce, 0x8b, 0xd6, 0xa8, 0x8a, 0xfe, 0x6b,
+  0x37, 0xd0, 0x57, 0x9f, 0x57, 0x5a, 0xbb, 0xbb, 0x1b, 0xcc, 0x56, 0xf6,
+  0x5d, 0x51, 0x29, 0x2d, 0x16, 0xa4, 0x0a, 0x4b, 0x68, 0xbb, 0x91, 0x4c,
+  0xb7, 0x70, 0xe4, 0xe5, 0x11, 0x02, 0xc2, 0xd2, 0x1b, 0xbe, 0xdc, 0x08,
+  0xdd, 0x4d, 0xcd, 0x04, 0x1f, 0x0d, 0xcf, 0xf7, 0xd4, 0x27, 0x46, 0xc1,
+  0xee, 0x6d, 0xc2, 0x0e, 0x05, 0x3d, 0xe2, 0x57, 0x99, 0xea, 0x66, 0x23,
+  0xba, 0xb8, 0x90, 0xfc, 0x2a, 0x94, 0xd6, 0x14, 0x80, 0x8a, 0x32, 0x5f,
+  0x8e, 0xcb, 0xa6, 0x71, 0xda, 0x57, 0xda, 0x52, 0x58, 0xbc, 0x20, 0x3f,
+  0x44, 0xcc, 0x4e, 0x15, 0xa6, 0xe0, 0xf2, 0x33, 0x2c, 0x52, 0xbf, 0x8e,
+  0xef, 0xc0, 0xf8, 0xba, 0xdd, 0x9e, 0x44, 0xf8, 0x6b, 0x7e, 0xbc, 0xcf,
+  0xe6, 0x5e, 0xbb, 0xf0, 0x9d, 0xbb, 0x64, 0xf4, 0xea, 0x73, 0x84, 0xb9,
+  0xdd, 0x33, 0x90, 0xa5, 0xe0, 0xf4, 0x82, 0x06, 0xb7, 0xf1, 0x67, 0x07,
+  0x08, 0x09, 0x6d, 0xeb, 0x4e, 0x5c, 0x7c, 0x5d, 0x8b, 0x01, 0xd2, 0x44,
+  0xd0, 0xda, 0x65, 0x96, 0xad, 0x6d, 0xec, 0xfb, 0xb0, 0xaa, 0x57, 0x72,
+  0x0f, 0x68, 0x94, 0x14, 0x8e, 0x07, 0x48, 0x37, 0x57, 0x89, 0x27, 0x42,
+  0x21, 0x3c, 0x6c, 0xe1, 0x5c, 0xcf, 0xa9, 0x1c, 0xc2, 0xb6, 0x04, 0xed,
+  0xd1, 0xca, 0x15, 0x1b, 0xb0, 0x64, 0xcd, 0x57, 0x3d, 0xef, 0x55, 0x5d,
+  0xbf, 0x20, 0x78, 0xfa, 0xd5, 0xe7, 0x0c, 0x95, 0x84, 0x5f, 0xff, 0xec,
+  0xde, 0xc6, 0x3f, 0x44, 0xc5, 0xc4, 0x05, 0xd6, 0x4e, 0x04, 0xe2, 0xce,
+  0xe5, 0x32, 0x67, 0x51, 0x26, 0x91, 0x23, 0x59, 0x30, 0x65, 0x18, 0xe6,
+  0xaa, 0xb2, 0x92, 0x37, 0xfb, 0x6f, 0xdf, 0xed, 0x9f, 0x0c, 0x1e, 0x52,
+  0xd7, 0x43, 0xeb, 0x9b, 0x8b, 0x6f, 0x62, 0x63, 0x58, 0x45, 0x4e, 0xc1,
+  0x79, 0xd4, 0x98, 0x76, 0xb9, 0x09, 0x1f, 0x2c, 0x5c, 0x12, 0x0d, 0x0d,
+  0x41, 0x01, 0xe4, 0xa4, 0x37, 0xa8, 0xc2, 0x23, 0xb8, 0xc4, 0x4b, 0x41,
+  0x6a, 0xd1, 0x46, 0x55, 0x74, 0x68, 0x09, 0x82, 0x86, 0xb3, 0x2d, 0x8f,
+  0xa5, 0x2c, 0x90, 0xc9, 0xdc, 0xd3, 0x14, 0xf5, 0x27, 0xa7, 0x80, 0xa9,
+  0x3b, 0xd1, 0x4a, 0x7a, 0xdd, 0xcf, 0xbb, 0x72, 0x36, 0xba, 0x2f, 0xbb,
+  0x40, 0x2b, 0xa1, 0x77, 0x9a, 0x31, 0x3e, 0x92, 0x35, 0xae, 0xd1, 0x9d,
+  0x5d, 0xa1, 0x9a, 0xae, 0x0d, 0x41, 0xd7, 0x4c, 0x86, 0xc5, 0xd1, 0x0e,
+  0x73, 0xad, 0xfd, 0x86, 0x4a, 0x72, 0x49, 0x3c, 0x6f, 0x71, 0x65, 0x30,
+  0x9e, 0x92, 0x4b, 0xa3, 0x94, 0x7a, 0x3c, 0x7c, 0x35, 0x94, 0x99, 0x4d,
+  0x5b, 0x14, 0xb8, 0x1c, 0xfc, 0x02, 0xe1, 0x04, 0x82, 0x6b, 0xd7, 0x16,
+  0x22, 0x61, 0xe1, 0xac, 0x89, 0x2b, 0x89, 0xa2, 0x63, 0x41, 0x04, 0x0b,
+  0x5d, 0xcc, 0x29, 0xa2, 0x43, 0xd9, 0x6b, 0x4b, 0xdf, 0x5e, 0x5d, 0x69,
+  0xae, 0x27, 0xe6, 0x4d, 0x6b, 0x47, 0xb3, 0x6e, 0x80, 0xeb, 0x69, 0xd9,
+  0x4a, 0xa2, 0xe3, 0x3a, 0xa8, 0x4f, 0xff, 0x8a, 0xc4, 0x9a, 0xab, 0x69,
+  0x36, 0xca, 0x2e, 0x2f, 0x1f, 0xa0, 0x8d, 0x82, 0x2e, 0x44, 0xba, 0x99,
+  0x0a, 0x76, 0x60, 0x72, 0x9a, 0x08, 0x92, 0x23, 0xf0, 0xde, 0x48, 0x8b,
+  0x39, 0x02, 0xf0, 0x7e, 0x20, 0x86, 0x45, 0x86, 0xf2, 0x49, 0xca, 0x16,
+  0x81, 0xd7, 0x67, 0x0c, 0x5a, 0x06, 0x87, 0x85, 0xc2, 0x72, 0x95, 0x3f,
+  0x9e, 0xb7, 0xc5, 0xd8, 0xf9, 0xfb, 0xb6, 0x88, 0xfe, 0xf1, 0xcf, 0x1f,
+  0x7e, 0x6a, 0x01, 0xbf, 0x81, 0x8d, 0x5b, 0x03, 0xd7, 0x11, 0x49, 0xab,
+  0x09, 0x37, 0x6c, 0x85, 0xa6, 0x0d, 0x28, 0x3d, 0x34, 0x9c, 0x16, 0x49,
+  0x19, 0x04, 0xa9, 0x01, 0xcd, 0x0b, 0xa3, 0x48, 0x1c, 0xa0, 0x00, 0x7b,
+  0xdc, 0x21, 0xa1, 0x6a, 0xc8, 0xc2, 0x34, 0xb9, 0x8a, 0x25, 0x1f, 0xde,
+  0xdd, 0x9e, 0xea, 0x7d, 0x59, 0x29, 0xb3, 0x6e, 0x58, 0xba, 0x7d, 0xca,
+  0x70, 0x28, 0x48, 0xb1, 0xf9, 0xf6, 0xfc, 0xd8, 0xd9, 0xf6, 0x83, 0x8d,
+  0xf8, 0x12, 0x1b, 0xd1, 0x58, 0x35, 0x57, 0x59, 0xa9, 0x57, 0xd7, 0x3e,
+  0xc2, 0x64, 0x6f, 0x4e, 0x70, 0x90, 0x54, 0xec, 0x0a, 0x90, 0x50, 0x43,
+  0x88, 0x09, 0xc0, 0x9b, 0x60, 0xdd, 0xa8, 0x22, 0xbc, 0xb8, 0x44, 0x7c,
+  0x57, 0xc9, 0x49, 0xc2, 0x33, 0xbe, 0x3c, 0x72, 0x68, 0x5a, 0x0d, 0xba,
+  0xaf, 0x94, 0x97, 0xaa, 0xe2, 0x6e, 0x31, 0x06, 0x80, 0x2b, 0x1c, 0x76,
+  0xe7, 0xfd, 0x5c, 0x1c, 0xec, 0xd2, 0xa6, 0x84, 0x28, 0x8e, 0x8b, 0x68,
+  0x8e, 0x96, 0xe5, 0xed, 0x97, 0xed, 0xc4, 0x10, 0x37, 0xba, 0x7f, 0xe9,
+  0x46, 0x1e, 0x55, 0xa3, 0xd5, 0x38, 0x18, 0xe2, 0xd9, 0xd5, 0x32, 0x9a,
+  0xfb, 0xc7, 0x3d, 0x3f, 0x5a, 0xdf, 0xa5, 0xcd, 0x65, 0xd4, 0x82, 0x9c,
+  0xb5, 0x6e, 0x20, 0x5f, 0x1d, 0xed, 0x1f, 0xda, 0x84, 0xff, 0xa3, 0xb8,
+  0x69, 0xd7, 0x9c, 0x59, 0x35, 0x5d, 0x34, 0x52, 0x6c, 0xe2, 0x2b, 0xe4,
+  0xfd, 0x4d, 0x17, 0xc1, 0xb3, 0x41, 0x16, 0xd6, 0x4b, 0xf9, 0xb9, 0x8e,
+  0x77, 0x1f, 0x09, 0x50, 0x8f, 0x3e, 0xec, 0x04, 0x02, 0x97, 0x46, 0xa0,
+  0x69, 0x03, 0x74, 0xa1, 0x13, 0x07, 0xb8, 0x4a, 0xb8, 0xaa, 0x2c, 0x78,
+  0x54, 0x5d, 0xf3, 0xd6, 0x33, 0xce, 0x50, 0x02, 0x0e, 0x9d, 0x52, 0x50,
+  0x80, 0x34, 0x39, 0x2e, 0x8c, 0xe3, 0xd7, 0x1c, 0x28, 0xab, 0x26, 0x33,
+  0x69, 0x14, 0xde, 0xc0, 0xd5, 0x59, 0x94, 0x48, 0xc7, 0x70, 0x23, 0xc3,
+  0x7b, 0xd7, 0x71, 0xe1, 0xad, 0xdd, 0x92, 0x80, 0x5e, 0x84, 0x5e, 0x68,
+  0xf3, 0x4e, 0x35, 0xcb, 0x1b, 0x58, 0x80, 0xb5, 0xb9, 0xc3, 0x7b, 0x22,
+  0xcb, 0x22, 0x47, 0x19, 0x2f, 0x68, 0x6e, 0x98, 0xeb, 0xcd, 0x03, 0x74,
+  0x2d, 0x9b, 0x70, 0xd7, 0xb5, 0x23, 0xe1, 0x5c, 0x62, 0xd9, 0x3c, 0xa9,
+  0x1a, 0x40, 0x30, 0x47, 0xcb, 0x46, 0xe3, 0xdc, 0x2f, 0xae, 0x8a, 0xdc,
+  0xb8, 0x59, 0x20, 0x54, 0x95, 0x4b, 0xe6, 0xba, 0xf1, 0x3c, 0x1c, 0xa7,
+  0xcb, 0xb6, 0x9d, 0x64, 0xb2, 0xf0, 0xce, 0x97, 0xcc, 0x39, 0x4f, 0xd0,
+  0x70, 0xe3, 0x06, 0x8e, 0xb2, 0x0d, 0xc7, 0xe1, 0xed, 0xbb, 0x5c, 0x4e,
+  0xe3, 0xa7, 0x0c, 0xb9, 0xcb, 0xa4, 0x08, 0x28, 0x9d, 0x84, 0x61, 0x9c,
+  0x04, 0xdf, 0xf7, 0xae, 0xc9, 0x35, 0xb5, 0x10, 0x09, 0x67, 0x08, 0x03,
+  0x1c, 0x7e, 0x96, 0xc1, 0x17, 0x3c, 0xf7, 0xb3, 0xd6, 0x25, 0x23, 0x36,
+  0x7c, 0x95, 0xde, 0x0a, 0xb5, 0xd8, 0xc8, 0x5a, 0x12, 0xa7, 0xdc, 0x18,
+  0x1c, 0x2a, 0x4c, 0x66, 0xbe, 0x54, 0xc9, 0x26, 0x8f, 0x90, 0x68, 0x29,
+  0x81, 0xc2, 0xa2, 0xca, 0x4c, 0x71, 0x97, 0x48, 0xdd, 0x5e, 0x22, 0xec,
+  0xba, 0x77, 0xe9, 0x2b, 0x92, 0x9c, 0x5e, 0x74, 0xda, 0x03, 0xab, 0x3d,
+  0xd6, 0x49, 0xe1, 0x30, 0x38, 0x39, 0x5a, 0x40, 0x87, 0xcc, 0x18, 0x53,
+  0x44, 0x7c, 0xdb, 0x3a, 0x5c, 0xd1, 0xd0, 0x38, 0x8a, 0xa7, 0x0d, 0x86,
+  0x4d, 0xc3, 0xf0, 0x17, 0x1c, 0x33, 0xc7, 0xbb, 0xcf, 0x25, 0x30, 0x51,
+  0xb8, 0x0c, 0x9a, 0x4f, 0x40, 0xd0, 0x9c, 0x01, 0x8a, 0x2d, 0xa2, 0xc6,
+  0xdb, 0x6e, 0x22, 0x8d, 0xbf, 0xce, 0x9d, 0xe5, 0x4d, 0x07, 0xa4, 0x6b,
+  0xf2, 0x02, 0x96, 0x14, 0x7b, 0xdd, 0x21, 0x4b, 0x21, 0xdf, 0x2e, 0xce,
+  0xf3, 0x94, 0x4e, 0x61, 0x03, 0xb5, 0x54, 0xc2, 0xe4, 0x4a, 0x57, 0x2c,
+  0x97, 0x71, 0x78, 0x67, 0xe2, 0xb9, 0xa2, 0x2d, 0x41, 0x15, 0x47, 0x16,
+  0xba, 0x90, 0xee, 0xbb, 0xb1, 0xce, 0x7d, 0xc0, 0x39, 0x4c, 0xb5, 0xc2,
+  0x75, 0xec, 0x40, 0x08, 0x33, 0x4c, 0xd7, 0x61, 0x33, 0x54, 0x33, 0x96,
+  0x59, 0x05, 0x71, 0xd7, 0x4c, 0x55, 0xd2, 0xe4, 0x98, 0x73, 0xbf, 0xe8,
+  0xdb, 0x39, 0x93, 0x54, 0x5b, 0x5c, 0x08, 0x5e, 0x31, 0xe6, 0x11, 0x88,
+  0xa7, 0x28, 0xf1, 0xba, 0x58, 0x8e, 0x66, 0x93, 0x67, 0xf5, 0x84, 0x05,
+  0x40, 0xed, 0xc4, 0x4e, 0x9e, 0x52, 0x29, 0x83, 0x7f, 0x7f, 0xb2, 0x87,
+  0x73, 0x70, 0x4f, 0x6d, 0x8d, 0xd3, 0x19, 0x7b, 0xaf, 0xd3, 0xab, 0xb4,
+  0x2c, 0x0c, 0xa0, 0x44, 0x5e, 0x59, 0x5f, 0x4c, 0x88, 0xd7, 0x66, 0x77,
+  0xef, 0xd3, 0x68, 0x94, 0x96, 0xd1, 0x9b, 0xc3, 0x67, 0x52, 0x02, 0xad,
+  0x58, 0xce, 0x7c, 0xd5, 0x45, 0x06, 0xfb, 0xc4, 0xd0, 0x48, 0xf4, 0xa3,
+  0xd1, 0x4d, 0x1b, 0x45, 0x3b, 0x6e, 0x92, 0x55, 0x18, 0x94, 0x04, 0x9c,
+  0xa4, 0x22, 0xa9, 0xc3, 0xa3, 0x3b, 0x42, 0x93, 0x42, 0xb6, 0x56, 0x6b,
+  0xa3, 0x45, 0x5a, 0xa6, 0xe9, 0x53, 0xff, 0x45, 0x64, 0xb5, 0x8c, 0x2a,
+  0xb2, 0x9c, 0x95, 0x75, 0xc5, 0x9e, 0x0f, 0x0f, 0xce, 0x78, 0x1b, 0x87,
+  0xd5, 0xb4, 0xfe, 0xfa, 0x7d, 0x10, 0x5a, 0xc5, 0x3e, 0x09, 0x6d, 0xa3,
+  0xfd, 0x7e, 0x7a, 0x45, 0x8c, 0xc8, 0xe1, 0xac, 0xf4, 0x49, 0x73, 0xb9,
+  0x5a, 0x57, 0xdb, 0xee, 0x98, 0x1f, 0xad, 0x98, 0x9f, 0x4e, 0xf8, 0x71,
+  0x97, 0x37, 0x1b, 0x04, 0x43, 0xe0, 0x04, 0xa4, 0x63, 0x54, 0xab, 0x6c,
+  0x40, 0x46, 0x6a, 0x15, 0x79, 0x9e, 0x80, 0x22, 0x3f, 0x20, 0x71, 0x91,
+  0x37, 0x73, 0x7f, 0x01, 0x0b, 0x4a, 0xb4, 0x3b, 0xb8, 0xef, 0x85, 0xe5,
+  0x97, 0x14, 0xdb, 0x1a, 0x45, 0x96, 0x1a, 0x09, 0x5c, 0x5c, 0xf4, 0xb3,
+  0x36, 0x20, 0x34, 0x2d, 0xa6, 0xab, 0x29, 0x82, 0x44, 0x72, 0xe1, 0xbe,
+  0x7b, 0xc4, 0xc5, 0xae, 0x62, 0x86, 0x55, 0x0e, 0x68, 0x2e, 0xa5, 0x13,
+  0xa0, 0x30, 0x4c, 0x6b, 0xe6, 0x2d, 0x5f, 0xba, 0xe4, 0x69, 0xbb, 0x7d,
+  0x55, 0xc8, 0xd5, 0xc8, 0x51, 0x23, 0xb7, 0xe0, 0x89, 0x66, 0x89, 0x28,
+  0xb4, 0xc3, 0x3b, 0xce, 0x07, 0x57, 0x94, 0x4b, 0x5d, 0x83, 0x3e, 0xae,
+  0xbc, 0x1e, 0x04, 0x1a, 0x77, 0xe3, 0xf9, 0x78, 0x59, 0x6e, 0xb4, 0x19,
+  0x26, 0x5e, 0x58, 0xe5, 0x58, 0x04, 0x9c, 0x0c, 0x06, 0xbf, 0x75, 0xe4,
+  0xa6, 0x9b, 0x37, 0xcf, 0x23, 0x3c, 0xb6, 0x7c, 0x61, 0x5c, 0x82, 0xcd,
+  0xb6, 0x66, 0x1e, 0x9f, 0x09, 0xaa, 0x5b, 0x54, 0x2d, 0x79, 0x6b, 0xd1,
+  0x06, 0x5e, 0xe4, 0x75, 0xcd, 0x0c, 0x9c, 0x86, 0x9f, 0xcc, 0xcb, 0x96,
+  0x85, 0xb4, 0xde, 0x64, 0xcd, 0x02, 0xd7, 0x78, 0x58, 0x25, 0x7a, 0x10,
+  0xed, 0xcf, 0x4d, 0xa9, 0x56, 0xb0, 0x03, 0x01, 0xbc, 0x6c, 0x94, 0xa4,
+  0xb8, 0x49, 0x1a, 0xda, 0xbd, 0xaa, 0xf7, 0xc1, 0xcc, 0x92, 0xf2, 0x7a,
+  0xe7, 0xc5, 0x6e, 0xa5, 0xbc, 0xb7, 0x02, 0xd1, 0x73, 0x85, 0x8f, 0xdf,
+  0x2e, 0x9a, 0xfc, 0x58, 0x05, 0xbe, 0x36, 0xea, 0xdc, 0x7e, 0x8d, 0xff,
+  0x8e, 0x4f, 0x8e, 0xb6, 0xa2, 0xd7, 0x28, 0x9d, 0xde, 0x20, 0x52, 0xb0,
+  0x8a, 0xdf, 0xc9, 0x27, 0x76, 0xd6, 0x54, 0x9f, 0x6c, 0xc3, 0xc9, 0xb4,
+  0x50, 0x06, 0x91, 0x8c, 0xe5, 0x00, 0xf2, 0x2c, 0x24, 0xd3, 0x28, 0xe3,
+  0x4b, 0xd4, 0x30, 0x9a, 0x2d, 0x80, 0xad, 0x95, 0xd8, 0xd9, 0x6c, 0xe6,
+  0xcb, 0x77, 0xf8, 0x0a, 0xb3, 0x5c, 0x6e, 0x5a, 0x63, 0x4d, 0x31, 0xf0,
+  0x48, 0x8d, 0x6b, 0xb5, 0xf2, 0xca, 0x2d, 0xa3, 0x93, 0x7a, 0x61, 0xe9,
+  0xdf, 0x25, 0xb4, 0x9a, 0x57, 0x6d, 0x96, 0x4d, 0x1c, 0x02, 0x9f, 0x94,
+  0xbe, 0xc0, 0x7c, 0x7f, 0xeb, 0xb8, 0xce, 0x60, 0x69, 0x83, 0x6d, 0xfa,
+  0x2b, 0x6d, 0xd3, 0x5f, 0x97, 0xf3, 0x9b, 0xbe, 0x16, 0xa4, 0x53, 0xa8,
+  0x8b, 0xa2, 0x9d, 0xa9, 0x7c, 0xeb, 0x82, 0x45, 0x38, 0x60, 0x5f, 0xcc,
+  0xa3, 0xcd, 0xba, 0x6c, 0x71, 0x80, 0xf5, 0xd5, 0x7b, 0xa0, 0x00, 0x4a,
+  0x45, 0x9d, 0x84, 0x7b, 0x81, 0x46, 0x3e, 0x46, 0x9c, 0x2d, 0x54, 0xcb,
+  0x8e, 0x95, 0xc8, 0xd3, 0xa6, 0x3b, 0xeb, 0x51, 0x8b, 0xb9, 0x22, 0x15,
+  0xcb, 0x97, 0x6c, 0x37, 0x71, 0xf2, 0xb8, 0x06, 0x81, 0x40, 0x54, 0xc3,
+  0xc6, 0x92, 0xe0, 0xe2, 0xea, 0xee, 0x49, 0xec, 0x1b, 0xd0, 0x3c, 0x41,
+  0xb5, 0x35, 0xc9, 0x61, 0xb5, 0x40, 0x73, 0x91, 0x81, 0x31, 0x17, 0x1e,
+  0x5b, 0xc6, 0x06, 0x18, 0xd5, 0x06, 0xa7, 0x51, 0x6a, 0x24, 0xee, 0x74,
+  0x1b, 0x34, 0x3a, 0x9e, 0x66, 0x52, 0x15, 0xe6, 0x6e, 0xfe, 0x9f, 0xcb,
+  0x70, 0xbf, 0xe1, 0xfb, 0xa2, 0x68, 0x0b, 0xaf, 0xb2, 0x44, 0xa0, 0x90,
+  0xd4, 0x02, 0xeb, 0xa4, 0x6a, 0x0e, 0x0e, 0x13, 0x5a, 0xb9, 0x62, 0xc7,
+  0x5a, 0xeb, 0x34, 0x73, 0x63, 0x2a, 0xe5, 0xe7, 0xd9, 0xde, 0xe5, 0xb1,
+  0x7b, 0xf6, 0x69, 0xe8, 0x8d, 0x47, 0x90, 0x6e, 0x20, 0xa1, 0xd0, 0x49,
+  0x5b, 0x71, 0x66, 0x86, 0x25, 0x26, 0xea, 0xb5, 0xc0, 0x87, 0x0a, 0x8c,
+  0x4b, 0x2d, 0xdf, 0x49, 0xb2, 0xef, 0x58, 0x23, 0x8a, 0xe1, 0xf5, 0xaa,
+  0x93, 0x8a, 0x2b, 0x75, 0xae, 0xe4, 0xa4, 0xde, 0x8b, 0xe9, 0xb4, 0x32,
+  0x22, 0x0f, 0xaf, 0x12, 0x4c, 0xb4, 0x05, 0xda, 0x85, 0x6b, 0x59, 0xa8,
+  0x48, 0x54, 0x59, 0x63, 0xdb, 0xca, 0x56, 0xe1, 0xd6, 0x5b, 0xa6, 0xb8,
+  0x40, 0x05, 0x27, 0xf7, 0x73, 0xf2, 0x84, 0x14, 0x3c, 0x50, 0x57, 0x26,
+  0xc3, 0x26, 0x88, 0x91, 0x35, 0x72, 0xe5, 0xac, 0xd6, 0x54, 0xa9, 0xe2,
+  0xb4, 0xc1, 0xeb, 0xf8, 0xfe, 0x7e, 0x50, 0x24, 0x52, 0xb6, 0xa9, 0x28,
+  0xa6, 0x9c, 0xa2, 0xd8, 0x5a, 0x9e, 0xea, 0xd1, 0x05, 0xa7, 0x99, 0x3b,
+  0x7d, 0x90, 0xb5, 0xa4, 0x65, 0x78, 0xad, 0xde, 0x24, 0xc9, 0x22, 0x9e,
+  0x72, 0xd8, 0x21, 0xde, 0x5e, 0x57, 0xfb, 0xa7, 0x2a, 0x9f, 0x17, 0xde,
+  0x67, 0x2c, 0x88, 0x1b, 0x71, 0x28, 0x84, 0x02, 0xb4, 0xbf, 0x10, 0x5e,
+  0x33, 0xc3, 0x30, 0xd2, 0x49, 0x63, 0x0c, 0x8a, 0xe5, 0x04, 0xa7, 0x10,
+  0x28, 0xc3, 0x0d, 0x02, 0x0a, 0xd2, 0x48, 0xcd, 0xd3, 0x1c, 0xd9, 0x82,
+  0xd6, 0xcd, 0x73, 0x86, 0xc4, 0x77, 0x52, 0x11, 0x27, 0xcb, 0x86, 0x82,
+  0x5e, 0x7f, 0xdf, 0xaa, 0xa7, 0xfa, 0x74, 0x01, 0x61, 0x2e, 0x78, 0x22,
+  0x73, 0xf2, 0x01, 0x03, 0xa0, 0x72, 0x55, 0xbe, 0xc6, 0xc5, 0x72, 0x29,
+  0x80, 0x10, 0x32, 0xc5, 0x8b, 0x83, 0xb3, 0xf7, 0x5f, 0x1f, 0x1d, 0x9d,
+  0x1d, 0x1f, 0xe2, 0x2a, 0xe1, 0xbb, 0xcb, 0x7d, 0xf4, 0xf6, 0xe2, 0x9b,
+  0x13, 0xc3, 0x88, 0xb0, 0xf5, 0x69, 0xb0, 0x63, 0xd8, 0x83, 0xb9, 0xb9,
+  0x93, 0x74, 0xbe, 0xbc, 0xef, 0x71, 0xcd, 0x1b, 0x52, 0x8e, 0xf6, 0x8f,
+  0xbf, 0x23, 0xb1, 0xeb, 0xac, 0xff, 0xee, 0xbb, 0x46, 0x4e, 0x51, 0x25,
+  0x3c, 0xae, 0x1e, 0x60, 0xe5, 0x82, 0xe5, 0xfa, 0xfd, 0x79, 0xe6, 0x37,
+  0xd0, 0x11, 0x71, 0x0b, 0x94, 0xed, 0xe3, 0x28, 0xaa, 0xaa, 0x68, 0x85,
+  0x92, 0x83, 0xe7, 0x66, 0xbc, 0xf7, 0x2d, 0x37, 0x67, 0x3c, 0x43, 0x4e,
+  0xcc, 0x20, 0x24, 0xac, 0x55, 0xf4, 0x92, 0xfe, 0x69, 0xcb, 0x64, 0xdc,
+  0x1e, 0x0e, 0xbf, 0xda, 0x8a, 0xce, 0x02, 0x14, 0x05, 0xe7, 0xd9, 0x1a,
+  0x58, 0xdc, 0x94, 0x1a, 0x3f, 0x34, 0x55, 0x46, 0x5d, 0x87, 0x79, 0x23,
+  0xc2, 0xd7, 0xb5, 0xe0, 0x6b, 0xb5, 0xb2, 0xd1, 0x2f, 0x69, 0xf7, 0x49,
+  0xfe, 0x8a, 0x29, 0x9c, 0xd4, 0xe9, 0x07, 0x73, 0xf3, 0x9b, 0x73, 0xc4,
+  0xb3, 0x03, 0x07, 0x4e, 0xa2, 0xe2, 0x0f, 0x5a, 0xe1, 0x09, 0xca, 0xb2,
+  0xb5, 0xc0, 0x5e, 0x4b, 0xf2, 0x7e, 0x88, 0x3b, 0x91, 0x12, 0x95, 0x1f,
+  0x1e, 0x9d, 0xf7, 0x38, 0x3d, 0xd3, 0x52, 0xf5, 0x99, 0x39, 0x7b, 0xfc,
+  0x9b, 0x81, 0x15, 0xdc, 0x2d, 0x5b, 0xed, 0x6d, 0x8c, 0xa9, 0xf1, 0xef,
+  0x4b, 0xd3, 0xbf, 0xc9, 0x47, 0xd1, 0xcb, 0x29, 0xbd, 0x38, 0x6d, 0x8f,
+  0x68, 0xd6, 0x7a, 0xa0, 0x5f, 0x27, 0xf9, 0x28, 0xc9, 0xb3, 0xa2, 0x9e,
+  0x5c, 0xa6, 0xd9, 0xe8, 0x5a, 0xa0, 0x10, 0xcd, 0x68, 0xb2, 0x69, 0xc3,
+  0x1c, 0xcb, 0x02, 0x3d, 0xe7, 0x16, 0xce, 0x27, 0xcd, 0x74, 0x93, 0x2e,
+  0x07, 0xef, 0x75, 0x7b, 0x51, 0x17, 0x39, 0x74, 0xf8, 0x49, 0xbc, 0xeb,
+  0x92, 0x1d, 0x26, 0x69, 0x3c, 0xed, 0x36, 0x4b, 0xd1, 0x76, 0x75, 0xd9,
+  0xbb, 0xb4, 0x6f, 0xd2, 0x98, 0xd5, 0xae, 0x8c, 0x75, 0x1c, 0xe2, 0x8d,
+  0x49, 0x0b, 0x35, 0xac, 0xa1, 0x23, 0xb3, 0x40, 0x15, 0x0d, 0x14, 0x27,
+  0xd7, 0x5c, 0xdd, 0xa8, 0xdc, 0x7e, 0x05, 0x55, 0x39, 0xaf, 0xc6, 0x52,
+  0x16, 0xde, 0x33, 0x66, 0x09, 0xdf, 0x77, 0xb1, 0xa5, 0x85, 0xb3, 0x11,
+  0xe0, 0x46, 0x57, 0xf1, 0x69, 0xc3, 0x47, 0x1a, 0x7d, 0x39, 0x1c, 0xee,
+  0x9f, 0x1d, 0x47, 0x9b, 0xf4, 0xb3, 0xff, 0xd6, 0xea, 0x8e, 0x6f, 0x19,
+  0xd5, 0xf8, 0x04, 0x0b, 0xcc, 0x85, 0x73, 0x58, 0x20, 0xb2, 0x73, 0x68,
+  0xdd, 0xbb, 0xa2, 0x91, 0x0c, 0xfb, 0x0d, 0x5d, 0xa3, 0xa6, 0x26, 0x0a,
+  0x1e, 0x8e, 0x5a, 0x67, 0xf3, 0xa8, 0x52, 0x84, 0xaf, 0x72, 0xed, 0xfc,
+  0xea, 0xb4, 0xf5, 0xb5, 0xd4, 0x5a, 0xba, 0x4c, 0xaf, 0x10, 0x35, 0xcf,
+  0x3f, 0xdb, 0xa0, 0x81, 0xaa, 0xc7, 0x2e, 0x78, 0xd0, 0x4b, 0xc6, 0x0c,
+  0xfa, 0xa5, 0xa9, 0x4a, 0x22, 0x20, 0x2b, 0xec, 0x76, 0x4b, 0x34, 0x0a,
+  0xde, 0x56, 0x9f, 0x6f, 0x1a, 0xc4, 0x54, 0xb0, 0x40, 0xe3, 0xfa, 0x98,
+  0xb9, 0x92, 0x0e, 0x41, 0xbb, 0xe2, 0x48, 0xad, 0x5b, 0x09, 0xb5, 0x46,
+  0x97, 0xe9, 0x44, 0xc9, 0xbc, 0x32, 0x5d, 0x95, 0x8c, 0xc5, 0x4a, 0x87,
+  0x88, 0x00, 0x7b, 0xde, 0x4c, 0xa0, 0x75, 0x2b, 0xe1, 0xb8, 0x04, 0x48,
+  0x6e, 0x38, 0x82, 0x41, 0x74, 0xba, 0x08, 0xe4, 0xbc, 0xeb, 0x24, 0xcd,
+  0xbd, 0xc3, 0xd4, 0xe7, 0x7c, 0x33, 0x77, 0x68, 0x4e, 0x56, 0x34, 0xab,
+  0xa0, 0x7a, 0x85, 0x5f, 0x3e, 0xa9, 0x58, 0xe1, 0x78, 0xaf, 0xa2, 0xba,
+  0xd0, 0x44, 0x4a, 0xae, 0xbf, 0x42, 0xba, 0x6d, 0xaf, 0x11, 0x85, 0xc0,
+  0x86, 0x59, 0x81, 0x07, 0x00, 0x9a, 0x6f, 0xc1, 0x41, 0x3a, 0x11, 0x43,
+  0xa0, 0xaf, 0x2a, 0x2e, 0x19, 0xf6, 0x88, 0xd2, 0x71, 0xda, 0x54, 0x0c,
+  0xbf, 0xb6, 0x4a, 0x50, 0xe2, 0x4d, 0xcd, 0x99, 0x7a, 0x0c, 0x4a, 0x5d,
+  0x43, 0x45, 0x82, 0xd6, 0x3d, 0x30, 0x4c, 0xc5, 0x4d, 0xdc, 0x94, 0x14,
+  0x1d, 0x8a, 0x47, 0x38, 0x05, 0x07, 0x96, 0xef, 0x5f, 0x76, 0x4b, 0x46,
+  0x77, 0xa3, 0x28, 0x0e, 0x82, 0x8f, 0xd0, 0x80, 0x27, 0xca, 0x18, 0xf7,
+  0xe3, 0x5b, 0x01, 0x4f, 0x98, 0x64, 0x4b, 0x30, 0x3a, 0xf9, 0xb4, 0xee,
+  0xdf, 0x49, 0xa4, 0xf0, 0x5c, 0x01, 0x97, 0x11, 0x7c, 0x3c, 0x2d, 0x98,
+  0xff, 0x0e, 0xbe, 0xe0, 0x45, 0x14, 0xfd, 0xf8, 0x23, 0x8d, 0xea, 0xc7,
+  0x4e, 0x2f, 0xfa, 0xb1, 0xa4, 0xff, 0x68, 0x45, 0x7f, 0x14, 0x0c, 0xf9,
+  0x1f, 0x6f, 0xe9, 0x26, 0x8d, 0x50, 0x30, 0x6d, 0x8a, 0x44, 0x7b, 0x0f,
+  0x0f, 0xde, 0xcc, 0x47, 0x93, 0x28, 0x47, 0x0f, 0x1a, 0x1e, 0x89, 0xc1,
+  0x6e, 0xe2, 0x16, 0x4b, 0x90, 0xff, 0x69, 0xc7, 0x96, 0xb3, 0xb9, 0x68,
+  0xdd, 0xb6, 0xf9, 0xbc, 0xf1, 0x2d, 0x35, 0xbe, 0xe8, 0x89, 0xee, 0x47,
+  0xce, 0xb5, 0x5e, 0x5a, 0x6a, 0x66, 0x18, 0x2d, 0xca, 0x27, 0xc2, 0x95,
+  0x94, 0x0e, 0x0a, 0xbd, 0x37, 0x2b, 0x14, 0x8a, 0x7e, 0x7f, 0x0a, 0x8b,
+  0xa4, 0xd4, 0x35, 0x64, 0x4e, 0x2e, 0x4c, 0x03, 0xe6, 0xf4, 0xc5, 0xf5,
+  0x8a, 0x55, 0x4a, 0x69, 0xd3, 0x25, 0x57, 0xc9, 0x18, 0x5b, 0xaa, 0x39,
+  0x34, 0xc5, 0x7c, 0x2b, 0xaa, 0xa8, 0x26, 0x00, 0x2b, 0x0d, 0x12, 0xf2,
+  0x15, 0x1a, 0x5a, 0xb7, 0xdf, 0xad, 0xa2, 0x03, 0x5a, 0xe9, 0x90, 0xb6,
+  0xf2, 0x22, 0x41, 0x25, 0x90, 0x46, 0xdd, 0x3e, 0x0f, 0x79, 0x2e, 0x41,
+  0x6c, 0x23, 0xe1, 0x40, 0xce, 0x0b, 0xc6, 0x0e, 0x44, 0xb3, 0xfd, 0xd9,
+  0x52, 0xab, 0x0d, 0x83, 0x58, 0x6b, 0xa3, 0x04, 0x84, 0x41, 0xa4, 0x3b,
+  0xd4, 0x28, 0xa8, 0xe7, 0x01, 0x76, 0x66, 0x5f, 0x2a, 0xfb, 0x89, 0x5f,
+  0x1d, 0xd4, 0xc1, 0xb5, 0xd1, 0x56, 0x88, 0xc5, 0x59, 0x34, 0x6c, 0xa7,
+  0x58, 0x62, 0x7b, 0x13, 0xe3, 0x00, 0x67, 0x46, 0xfd, 0x92, 0xbb, 0xb9,
+  0xf2, 0x90, 0x61, 0xc6, 0xd9, 0xf5, 0x81, 0xb5, 0x2b, 0xf2, 0x55, 0x30,
+  0x1a, 0x47, 0xa9, 0x35, 0xb0, 0x05, 0xe3, 0x79, 0x15, 0x75, 0xd6, 0xea,
+  0x43, 0x9d, 0xfa, 0x0b, 0x27, 0x19, 0xbb, 0x3e, 0xf5, 0x16, 0x14, 0xbc,
+  0x3b, 0x71, 0x13, 0x18, 0x6c, 0xd8, 0x94, 0x91, 0x3b, 0xc4, 0x94, 0xe1,
+  0xab, 0x1a, 0x1b, 0x87, 0x5a, 0xe3, 0x46, 0x12, 0xff, 0x9b, 0x80, 0x27,
+  0xea, 0xa9, 0x44, 0x8d, 0xc6, 0x75, 0xc0, 0x9f, 0x66, 0x4c, 0x11, 0x80,
+  0x52, 0x01, 0x24, 0x53, 0x63, 0xc3, 0xa6, 0xe9, 0x95, 0x7f, 0xb3, 0x7b,
+  0x6c, 0x4b, 0xad, 0xfc, 0x92, 0xdf, 0xb8, 0x0e, 0xde, 0x24, 0xdc, 0x5d,
+  0x55, 0x2e, 0xd8, 0x10, 0x96, 0xb2, 0x84, 0x7f, 0x49, 0x42, 0xf5, 0xa4,
+  0x1a, 0xce, 0xbc, 0x96, 0xaa, 0x59, 0xe1, 0x41, 0x8f, 0x8a, 0x83, 0x66,
+  0x85, 0xe9, 0x1d, 0x67, 0x61, 0x7f, 0x49, 0xe1, 0x04, 0xe5, 0x2c, 0x27,
+  0x95, 0xb9, 0xb1, 0x33, 0xbb, 0x5b, 0x6a, 0x3c, 0xe0, 0x8a, 0x63, 0x5c,
+  0x81, 0x4e, 0x75, 0xb1, 0xce, 0x75, 0x26, 0x78, 0x38, 0x9d, 0x17, 0x50,
+  0xaf, 0x84, 0x29, 0xd8, 0x1c, 0x35, 0x15, 0xa2, 0x71, 0x14, 0x18, 0x70,
+  0xe8, 0xab, 0xd3, 0x37, 0x47, 0x2e, 0x73, 0x52, 0xcc, 0x87, 0xf8, 0xa4,
+  0x15, 0xe5, 0x70, 0xc0, 0x79, 0x0d, 0x06, 0x91, 0xd0, 0x6b, 0xe8, 0xae,
+  0xb2, 0x3a, 0x57, 0x49, 0xb9, 0xb8, 0x5b, 0xa6, 0x93, 0x4d, 0xc6, 0xb1,
+  0x58, 0xce, 0xd3, 0xfb, 0x3e, 0x1b, 0xba, 0x55, 0x9f, 0x33, 0x18, 0x87,
+  0xc0, 0xb3, 0x05, 0x8f, 0xc8, 0xac, 0x25, 0x7b, 0xda, 0x32, 0x7a, 0x99,
+  0x5e, 0x14, 0xba, 0x87, 0xb3, 0xef, 0xd2, 0xb9, 0x48, 0x31, 0xd2, 0xe4,
+  0x16, 0xf8, 0x0f, 0xf1, 0x6f, 0x06, 0x24, 0xe2, 0x7d, 0x6f, 0xc9, 0x02,
+  0x0d, 0xf6, 0x1b, 0xcd, 0xed, 0x9f, 0x9d, 0x1d, 0xee, 0x5f, 0xec, 0xbb,
+  0xb9, 0x31, 0x00, 0x10, 0xfb, 0xee, 0x58, 0x9c, 0x81, 0x05, 0x21, 0x17,
+  0x12, 0xec, 0xfe, 0x1e, 0x09, 0x7b, 0xf5, 0x1b, 0xf7, 0xec, 0xfc, 0x14,
+  0xd6, 0xcb, 0xdf, 0xef, 0x58, 0x55, 0x2e, 0xae, 0x3f, 0xd3, 0x2c, 0x8e,
+  0xb4, 0x47, 0x7a, 0xc6, 0xe9, 0xdc, 0xc1, 0x25, 0xf5, 0x5c, 0x14, 0x91,
+  0x08, 0x71, 0xd1, 0x7b, 0x6c, 0x68, 0x3e, 0x76, 0x92, 0x09, 0x1b, 0x54,
+  0x75, 0x2f, 0x7b, 0xcd, 0x4c, 0xaf, 0x60, 0x16, 0xd9, 0x3c, 0xa9, 0x83,
+  0x21, 0x69, 0x59, 0x95, 0x64, 0xbc, 0x2c, 0x99, 0x6d, 0xd9, 0x91, 0x60,
+  0xe2, 0x9a, 0x60, 0x95, 0xea, 0x47, 0xdd, 0x6d, 0x8e, 0xed, 0x8e, 0x80,
+  0x81, 0x33, 0xeb, 0x17, 0x06, 0xc4, 0xe8, 0xcc, 0x44, 0x6a, 0x5c, 0x8a,
+  0x60, 0x60, 0xa3, 0xd5, 0xc8, 0xeb, 0xc6, 0xc1, 0x11, 0x60, 0x3f, 0x22,
+  0x72, 0x9b, 0x43, 0x63, 0x41, 0x3e, 0x22, 0x8e, 0xd7, 0xb7, 0xf0, 0x53,
+  0x99, 0x36, 0x7d, 0xd0, 0x78, 0xa8, 0x74, 0xb0, 0xfa, 0x7a, 0xc7, 0xb4,
+  0x33, 0xa9, 0x90, 0x3b, 0x75, 0x1a, 0xf9, 0xa5, 0x8c, 0xa9, 0xa2, 0x4f,
+  0x31, 0x52, 0x2f, 0x47, 0x28, 0x36, 0xdd, 0x51, 0xe6, 0x11, 0xa5, 0x47,
+  0x49, 0x24, 0x26, 0xf9, 0x16, 0x7f, 0x6d, 0xef, 0x0e, 0x76, 0x3a, 0xcd,
+  0xd1, 0xe3, 0xa8, 0x5c, 0xb2, 0xa9, 0x3d, 0x9e, 0xcb, 0xe5, 0x2c, 0xb8,
+  0xb4, 0xd9, 0x87, 0x07, 0xa8, 0x55, 0xc0, 0xe3, 0x39, 0x47, 0x5b, 0xb4,
+  0x8d, 0xa5, 0x7f, 0xda, 0x70, 0x6e, 0x89, 0x6b, 0xd6, 0xf3, 0xe3, 0x79,
+  0xc6, 0x21, 0xa7, 0x31, 0x6c, 0x72, 0xec, 0x78, 0xe8, 0xb4, 0x2f, 0xb0,
+  0x78, 0xb1, 0x93, 0xfa, 0x3a, 0xff, 0xa2, 0x00, 0x42, 0xb7, 0xff, 0x01,
+  0x70, 0xda, 0x5a, 0x56, 0x57, 0xf1, 0xe7, 0x5a, 0xb9, 0xef, 0x56, 0x30,
+  0xd0, 0x7d, 0x81, 0xff, 0xad, 0x99, 0xe6, 0xe1, 0x42, 0x46, 0xcd, 0x36,
+  0x04, 0x5d, 0x41, 0x77, 0xd2, 0x8c, 0xca, 0x59, 0x50, 0x7d, 0x2d, 0x96,
+  0x70, 0xe5, 0xc6, 0xbd, 0xe1, 0x0a, 0xda, 0x6a, 0xb7, 0x7d, 0xb9, 0x66,
+  0xd5, 0x18, 0xc8, 0x55, 0x2f, 0x82, 0xc2, 0xbd, 0x41, 0x31, 0xe0, 0x36,
+  0x47, 0xbe, 0x64, 0xda, 0x0b, 0xf8, 0x21, 0xe9, 0x75, 0xb7, 0x31, 0xc3,
+  0x96, 0x78, 0xf7, 0x15, 0xad, 0xee, 0x9d, 0x16, 0xd7, 0xce, 0xab, 0xaa,
+  0x04, 0x3f, 0xd3, 0x5a, 0x03, 0x02, 0x6d, 0xfe, 0xae, 0xad, 0x52, 0xf0,
+  0x0b, 0x05, 0x1b, 0xc9, 0x12, 0x51, 0xed, 0x24, 0x16, 0x01, 0x91, 0x2b,
+  0x9a, 0xec, 0xd4, 0x7f, 0x1d, 0x14, 0x37, 0x9f, 0x5b, 0x94, 0x3e, 0xf6,
+  0xa3, 0xd9, 0x91, 0x20, 0x25, 0xc0, 0xb6, 0xcc, 0x95, 0x9a, 0x7a, 0x8c,
+  0x9e, 0xc3, 0xac, 0x22, 0x43, 0x0e, 0x7f, 0x6c, 0xa8, 0x71, 0x7a, 0x40,
+  0xa8, 0xaf, 0x2b, 0x92, 0x99, 0xd7, 0x84, 0x62, 0x1b, 0x6e, 0x86, 0x2f,
+  0x0a, 0x0a, 0xff, 0x40, 0x61, 0x49, 0xb0, 0xef, 0x19, 0x7c, 0x6a, 0x32,
+  0xd9, 0x7c, 0xb2, 0x25, 0xfb, 0xe2, 0xca, 0xfd, 0xb2, 0x4f, 0xf2, 0x5f,
+  0xd4, 0x2a, 0xb5, 0x56, 0xae, 0xec, 0x51, 0x0b, 0x82, 0x4b, 0x45, 0xe3,
+  0x7c, 0x20, 0x07, 0x08, 0x84, 0x38, 0x4b, 0xcb, 0x3e, 0xdb, 0x9e, 0x5e,
+  0x92, 0x24, 0x96, 0x4c, 0xd6, 0xa9, 0x9f, 0x9a, 0xfb, 0xaf, 0xe5, 0xd4,
+  0x7d, 0xfa, 0x5e, 0xc4, 0xef, 0x36, 0x6a, 0x79, 0xab, 0xd1, 0xa3, 0xe1,
+  0x97, 0x51, 0x27, 0x9b, 0xce, 0x90, 0x41, 0x7b, 0x25, 0x2e, 0x8a, 0xfd,
+  0x2a, 0xb1, 0x54, 0x50, 0x87, 0xd5, 0x28, 0x5d, 0x24, 0x46, 0xcf, 0xdd,
+  0x89, 0x78, 0x84, 0x41, 0x51, 0xf5, 0x4d, 0xb5, 0x61, 0x58, 0x12, 0xb3,
+  0x44, 0x38, 0xcd, 0x4b, 0xa4, 0xdd, 0x8d, 0xe8, 0xfd, 0xbb, 0x74, 0x52,
+  0x5e, 0xb7, 0x23, 0xf5, 0xc9, 0x22, 0xf2, 0xa4, 0x23, 0xc1, 0xbf, 0x40,
+  0xc8, 0x0c, 0xaf, 0x13, 0xfb, 0xc2, 0xb7, 0xc5, 0xac, 0xdc, 0x33, 0xeb,
+  0x7b, 0x4c, 0x44, 0x77, 0x89, 0x9c, 0x8a, 0xc6, 0xa4, 0x2c, 0x94, 0x6e,
+  0x60, 0x67, 0x97, 0xe3, 0x75, 0x6f, 0x24, 0x6e, 0xf5, 0x6b, 0xb5, 0x99,
+  0x08, 0xfe, 0x0e, 0x87, 0x60, 0x4b, 0xb0, 0x18, 0x17, 0x5d, 0xbb, 0x49,
+  0xa7, 0xcd, 0x6a, 0x75, 0x2b, 0x56, 0xb1, 0xa2, 0xee, 0xac, 0x2b, 0xf1,
+  0x8c, 0x6f, 0xba, 0xea, 0x44, 0xe0, 0xda, 0xad, 0xea, 0xaa, 0x97, 0x7c,
+  0x89, 0xa8, 0x7b, 0x25, 0xdd, 0x7c, 0xe9, 0x9f, 0xa9, 0xbb, 0x6c, 0x9c,
+  0x73, 0xdf, 0xae, 0x97, 0xe2, 0x45, 0xb4, 0xb7, 0xb3, 0xf3, 0x75, 0x2f,
+  0x7a, 0x22, 0x65, 0x3c, 0x77, 0xbf, 0x6c, 0x5d, 0x21, 0x59, 0x20, 0xde,
+  0x5f, 0x55, 0x4b, 0xe3, 0x5b, 0xbe, 0x04, 0x64, 0xd1, 0x7a, 0xae, 0xc0,
+  0xf2, 0x64, 0x19, 0x58, 0x9e, 0x65, 0xf1, 0xd7, 0xec, 0x13, 0x1b, 0xb9,
+  0x05, 0x69, 0x44, 0xa2, 0x62, 0x41, 0x2e, 0x33, 0x0e, 0x82, 0xc2, 0xee,
+  0x5d, 0xd3, 0x6f, 0x88, 0x4a, 0xb0, 0x5d, 0xe5, 0x7e, 0x5a, 0xd2, 0xce,
+  0x8b, 0x6b, 0x9c, 0xfd, 0xd1, 0x32, 0xe7, 0x63, 0x0c, 0x87, 0xab, 0x94,
+  0x86, 0x81, 0xe5, 0xdd, 0xc4, 0x2d, 0x12, 0x22, 0x7c, 0x19, 0xcb, 0xb2,
+  0x32, 0x9d, 0xc1, 0xba, 0xe2, 0x7b, 0xec, 0x26, 0x42, 0x5c, 0x50, 0xa0,
+  0x87, 0x7c, 0x4f, 0xea, 0x14, 0x8f, 0x43, 0xce, 0x8a, 0x53, 0x49, 0x24,
+  0x10, 0xb4, 0x0d, 0xa4, 0x50, 0x9d, 0x67, 0xec, 0x73, 0x14, 0x1d, 0x56,
+  0xac, 0xd0, 0x2c, 0x28, 0xcb, 0x64, 0x23, 0x20, 0x8f, 0x2d, 0xac, 0x6a,
+  0x85, 0x1c, 0x22, 0x69, 0xbf, 0x25, 0x26, 0x67, 0x8a, 0x57, 0xa6, 0x2b,
+  0x06, 0xc5, 0x46, 0xd0, 0x23, 0xbb, 0x0e, 0x6c, 0x7c, 0xe1, 0xd0, 0x90,
+  0xe9, 0x3b, 0xe6, 0x12, 0x22, 0x08, 0x5c, 0xfb, 0xed, 0x2c, 0x57, 0x53,
+  0x80, 0xd6, 0xa7, 0x45, 0xd9, 0x87, 0xab, 0x77, 0x3d, 0x78, 0x12, 0x1e,
+  0x11, 0xed, 0x9d, 0x1d, 0xdb, 0x13, 0x0f, 0x2a, 0x29, 0x46, 0x6f, 0x0e,
+  0xbe, 0x96, 0xe4, 0x29, 0x9c, 0x2e, 0x66, 0x64, 0x0d, 0x30, 0x0c, 0xad,
+  0xae, 0x9e, 0xdc, 0x21, 0x4b, 0xf6, 0xc8, 0x03, 0x7b, 0x55, 0xb9, 0x87,
+  0x55, 0x85, 0x98, 0xc5, 0xe3, 0x6b, 0xba, 0x6a, 0xfa, 0x1c, 0xb9, 0xdd,
+  0x9e, 0x48, 0xeb, 0x2a, 0x5b, 0xd6, 0x87, 0x05, 0xdc, 0x95, 0xb1, 0xed,
+  0x88, 0x46, 0x48, 0x87, 0x28, 0x81, 0x18, 0x44, 0xcb, 0x5d, 0x88, 0xd4,
+  0x5b, 0xb1, 0xab, 0x3a, 0x10, 0x27, 0x56, 0x2f, 0xb3, 0x7c, 0x1d, 0x02,
+  0x6a, 0x3d, 0x6e, 0x8c, 0xc9, 0x15, 0xc3, 0xe1, 0xf1, 0xbc, 0x3d, 0x19,
+  0x3a, 0xb8, 0x2c, 0xd5, 0xb5, 0x0b, 0xb6, 0x25, 0x90, 0x0e, 0x3b, 0xe3,
+  0xb4, 0xd1, 0xd6, 0x2c, 0xff, 0x42, 0x70, 0xe5, 0x25, 0x04, 0x8a, 0x43,
+  0x7c, 0x44, 0x08, 0x4e, 0xf3, 0x0a, 0x40, 0x03, 0x5a, 0xff, 0xb3, 0xd8,
+  0xe3, 0x10, 0x71, 0xd7, 0x62, 0x66, 0xd7, 0x30, 0x16, 0x24, 0xe4, 0x85,
+  0x75, 0x9c, 0xd9, 0x2c, 0xbd, 0x9a, 0x8d, 0x32, 0x12, 0xec, 0x71, 0x9d,
+  0xdf, 0x14, 0x83, 0x5f, 0xec, 0xf3, 0x6b, 0xba, 0xfb, 0x78, 0xf0, 0x2d,
+  0x5b, 0x5f, 0x91, 0x99, 0x90, 0x49, 0x22, 0x98, 0x28, 0x2f, 0x89, 0x85,
+  0x7e, 0xf6, 0x43, 0x9f, 0xfe, 0xfd, 0xa9, 0xe1, 0xfc, 0x2c, 0x05, 0x57,
+  0x45, 0x2d, 0x6b, 0x16, 0x98, 0x9b, 0x7b, 0xa0, 0x7a, 0x29, 0xde, 0xcd,
+  0xed, 0xc8, 0xb7, 0x45, 0x80, 0xef, 0xdf, 0x06, 0xbd, 0xe1, 0xbc, 0x84,
+  0x9b, 0xc5, 0xd6, 0x20, 0xb4, 0x84, 0x54, 0xda, 0x18, 0xad, 0x88, 0x80,
+  0xed, 0x6e, 0x23, 0x62, 0x18, 0xc7, 0xf9, 0xb8, 0x19, 0xb5, 0xa8, 0x32,
+  0x57, 0x58, 0xbd, 0x9e, 0xf8, 0x57, 0xb1, 0x02, 0x64, 0x91, 0xc8, 0x94,
+  0xc8, 0x61, 0xb2, 0x84, 0x1b, 0x15, 0x01, 0x65, 0xe8, 0x2d, 0x65, 0x3f,
+  0x32, 0xe0, 0x54, 0x29, 0xd0, 0x09, 0x36, 0x33, 0xce, 0x73, 0x20, 0x4b,
+  0x0a, 0x8f, 0x91, 0x4a, 0xcb, 0xcb, 0x79, 0x20, 0xa1, 0x78, 0x7f, 0x27,
+  0xf5, 0xb0, 0x5c, 0xb4, 0xb8, 0x9a, 0x91, 0x50, 0xd1, 0x00, 0x18, 0x09,
+  0xf3, 0x45, 0xc3, 0x82, 0x15, 0xad, 0x91, 0x37, 0x8c, 0xb1, 0xbe, 0x65,
+  0x66, 0x38, 0x57, 0x5f, 0x44, 0x0c, 0xea, 0xce, 0x03, 0xa0, 0xd1, 0xe5,
+  0x09, 0x17, 0x58, 0xc3, 0xe4, 0x9a, 0x85, 0xa7, 0x11, 0x22, 0x39, 0x11,
+  0xb4, 0xde, 0x00, 0xbc, 0xc1, 0x6a, 0x65, 0x6c, 0xc2, 0xb1, 0x3a, 0x66,
+  0x03, 0x9c, 0x46, 0xad, 0xd7, 0xeb, 0x55, 0xb4, 0xa0, 0xda, 0xc5, 0xd1,
+  0x93, 0xef, 0xbe, 0x8b, 0x2a, 0x20, 0x7f, 0x5b, 0x15, 0x9a, 0x6d, 0x96,
+  0x9a, 0x23, 0x22, 0xca, 0xda, 0x8c, 0x04, 0x96, 0x0f, 0x60, 0xe6, 0x65,
+  0x84, 0x7e, 0xb0, 0x3e, 0xc9, 0x16, 0x48, 0xc5, 0xfa, 0x91, 0xfa, 0xc6,
+  0x1a, 0x9f, 0x1f, 0x04, 0xd4, 0x35, 0xfd, 0x35, 0x2e, 0x9a, 0xa9, 0xe7,
+  0x62, 0x97, 0x25, 0xd0, 0x85, 0xa3, 0xfc, 0x6c, 0xad, 0xb0, 0x54, 0x85,
+  0xa3, 0x1b, 0xba, 0x05, 0xef, 0xe0, 0xe1, 0xf8, 0xf6, 0x83, 0x18, 0x87,
+  0x2e, 0xae, 0x47, 0xa3, 0x31, 0x99, 0x4b, 0x48, 0x41, 0x1c, 0x98, 0xc9,
+  0xc6, 0x79, 0xa2, 0x9e, 0x24, 0x2b, 0xd6, 0xd3, 0xe0, 0x09, 0x62, 0x6e,
+  0x42, 0x0c, 0x19, 0xcf, 0x0f, 0xa9, 0xc6, 0xc2, 0x1d, 0xf8, 0x9e, 0xf3,
+  0xc1, 0x1b, 0xe1, 0x5e, 0xf1, 0xe3, 0xac, 0x38, 0x37, 0xb2, 0x22, 0x19,
+  0xe1, 0x01, 0x41, 0x17, 0x66, 0x46, 0xe4, 0x78, 0x32, 0x4d, 0x9f, 0xe2,
+  0xfb, 0x26, 0xff, 0x53, 0x6b, 0x8d, 0x35, 0xec, 0x7f, 0x9b, 0x0a, 0xd1,
+  0x2f, 0xf3, 0x25, 0x2f, 0x11, 0x3c, 0xd0, 0xc8, 0xb0, 0xcf, 0x7c, 0xd2,
+  0x1b, 0xbc, 0x8e, 0x16, 0x37, 0x27, 0x17, 0xa5, 0x77, 0xfe, 0xc2, 0xe7,
+  0xd5, 0xd8, 0x59, 0x99, 0x99, 0x25, 0xf0, 0x23, 0x61, 0xbf, 0x5a, 0xd6,
+  0xa7, 0x4f, 0x62, 0x70, 0x9f, 0x1f, 0x2b, 0x1a, 0x35, 0x0f, 0x42, 0xd3,
+  0x9b, 0xc2, 0x68, 0x66, 0xe2, 0x1c, 0x0e, 0xd6, 0xcc, 0x54, 0x16, 0x23,
+  0x22, 0x75, 0x5c, 0xc5, 0xa0, 0x20, 0x3a, 0x74, 0x5f, 0x1e, 0x5d, 0xd4,
+  0x8f, 0x16, 0x23, 0x69, 0xa8, 0xd2, 0xca, 0x19, 0x1e, 0xf4, 0xf7, 0xd9,
+  0xbb, 0x8b, 0x2d, 0x5f, 0x5f, 0x60, 0x92, 0xd5, 0x4c, 0x67, 0xd6, 0x78,
+  0x4b, 0xbe, 0x4c, 0xcc, 0xc9, 0x2f, 0x8a, 0xbc, 0xc1, 0xc9, 0x30, 0xee,
+  0x4c, 0xc0, 0x25, 0xf7, 0x64, 0x67, 0x97, 0x64, 0xc3, 0x9d, 0x3d, 0x36,
+  0xfe, 0x3c, 0xd9, 0x79, 0xe2, 0x8c, 0xea, 0xf6, 0x54, 0xe3, 0x56, 0x9d,
+  0xc8, 0x8b, 0xac, 0xa0, 0x32, 0xc9, 0x3f, 0xb9, 0xbf, 0xe7, 0x8f, 0x7b,
+  0x75, 0xf4, 0x9e, 0x42, 0x55, 0xdb, 0x24, 0xa8, 0xdc, 0xbb, 0xe6, 0x68,
+  0xf9, 0x15, 0x67, 0x43, 0xce, 0x72, 0x2e, 0x61, 0x6d, 0x50, 0xc3, 0x19,
+  0x9e, 0xef, 0xb7, 0x8e, 0x67, 0x73, 0xbc, 0xc6, 0x0d, 0xb4, 0x7e, 0x1d,
+  0x85, 0x94, 0xf7, 0x10, 0x33, 0x3c, 0x81, 0xfa, 0x52, 0x61, 0x9d, 0x56,
+  0x0d, 0x0c, 0x43, 0x60, 0x0a, 0x33, 0xed, 0xd5, 0x72, 0x34, 0x6b, 0xcd,
+  0xfd, 0x29, 0xf2, 0x39, 0xc8, 0x38, 0x66, 0x53, 0x39, 0x8c, 0x01, 0x47,
+  0xe5, 0x22, 0x57, 0xc8, 0xa4, 0xf3, 0x27, 0x33, 0x73, 0x11, 0x48, 0xab,
+  0xa6, 0x47, 0xd5, 0x2a, 0xce, 0xa5, 0x00, 0xc0, 0x98, 0x2c, 0xc7, 0x89,
+  0x14, 0xb4, 0x22, 0x51, 0xbe, 0x5c, 0x45, 0x23, 0x81, 0x4d, 0x34, 0x6c,
+  0x16, 0x34, 0xed, 0x8f, 0x45, 0xd3, 0xc4, 0x00, 0x16, 0x89, 0x24, 0xad,
+  0x54, 0x30, 0xb7, 0xc5, 0x90, 0x09, 0xcd, 0x0d, 0xe6, 0x32, 0x97, 0x44,
+  0x5d, 0x07, 0x5e, 0x9d, 0x5f, 0x66, 0x6a, 0xf4, 0x6c, 0x7a, 0x63, 0xf8,
+  0x20, 0xb0, 0x6f, 0xd2, 0xec, 0xe2, 0xb1, 0x94, 0x76, 0x63, 0x6a, 0xfd,
+  0x02, 0xe1, 0x78, 0xb5, 0xf6, 0x7e, 0x73, 0x80, 0xd6, 0x87, 0xc9, 0x01,
+  0x2c, 0x81, 0xe5, 0x2e, 0x04, 0x62, 0xbe, 0x64, 0x7d, 0xeb, 0x91, 0xaa,
+  0x34, 0xbf, 0xb1, 0x69, 0x5a, 0xe7, 0x96, 0xcf, 0xac, 0x16, 0x7c, 0x89,
+  0xbb, 0x39, 0x4c, 0x4c, 0x38, 0x82, 0xeb, 0x62, 0x3f, 0xfd, 0xfd, 0x90,
+  0x56, 0x03, 0xbb, 0x79, 0xf6, 0x9c, 0x62, 0xd9, 0xab, 0x62, 0xee, 0xac,
+  0xab, 0x38, 0x27, 0xc5, 0xc7, 0x63, 0xab, 0x69, 0xa6, 0x31, 0xe6, 0x0c,
+  0xf6, 0xcb, 0x77, 0x58, 0x72, 0xcf, 0x3e, 0x14, 0x3a, 0xed, 0x1f, 0x3f,
+  0x19, 0xb4, 0xdb, 0x6b, 0x44, 0xb7, 0xf6, 0x31, 0xa9, 0xc6, 0xda, 0xc4,
+  0xe3, 0x80, 0x2c, 0x1c, 0xa4, 0x91, 0x02, 0xe1, 0x34, 0x98, 0x1d, 0x9b,
+  0x48, 0x5a, 0xb0, 0x36, 0x0a, 0xa0, 0x5e, 0x8b, 0x34, 0x5b, 0xae, 0x45,
+  0xe0, 0xb2, 0x0a, 0x53, 0x6e, 0x3d, 0x78, 0x9a, 0x0d, 0x57, 0x30, 0xa6,
+  0xcd, 0x37, 0x1e, 0x12, 0x43, 0x34, 0xa7, 0xb2, 0xb1, 0x58, 0xa2, 0x23,
+  0xf2, 0x25, 0x61, 0x10, 0x14, 0x19, 0x29, 0x05, 0x79, 0x23, 0x3e, 0x8a,
+  0xb3, 0xd5, 0x21, 0xae, 0x63, 0xb1, 0x98, 0x26, 0x83, 0x34, 0x03, 0x47,
+  0x15, 0xb3, 0x6d, 0x21, 0x8c, 0x07, 0xc3, 0xd4, 0xde, 0x28, 0x21, 0x88,
+  0xf6, 0x3a, 0x57, 0x92, 0xd4, 0x93, 0x0d, 0xe5, 0x46, 0x18, 0x04, 0x13,
+  0xcd, 0xdd, 0x75, 0xc6, 0x30, 0xa6, 0xce, 0xda, 0xd6, 0xe2, 0xbb, 0xa2,
+  0xfb, 0x78, 0x10, 0x60, 0x6b, 0xaa, 0xa2, 0x84, 0xe5, 0x54, 0x74, 0xe7,
+  0xd4, 0x10, 0xfb, 0x47, 0x5c, 0x27, 0xfa, 0xaf, 0xd9, 0x48, 0x85, 0x0d,
+  0x5c, 0x98, 0x6d, 0x70, 0xa6, 0x97, 0x1c, 0x3e, 0x4e, 0xda, 0x36, 0x69,
+  0xfa, 0xe2, 0xf4, 0xc3, 0x80, 0xe6, 0x49, 0x09, 0x55, 0x93, 0x83, 0xcb,
+  0x45, 0x23, 0x88, 0xa2, 0x2b, 0x2e, 0xaa, 0x28, 0x91, 0xa8, 0x12, 0x8a,
+  0xd8, 0x80, 0x64, 0x73, 0x95, 0x83, 0x54, 0x1a, 0xe5, 0xc5, 0x81, 0x5f,
+  0x6b, 0xcd, 0x4d, 0xfa, 0xeb, 0xa9, 0xad, 0x6f, 0x78, 0x37, 0xe6, 0xcd,
+  0x50, 0xbc, 0x37, 0xfc, 0xe1, 0x20, 0x3a, 0x94, 0x20, 0x6b, 0x71, 0x36,
+  0x2c, 0x35, 0xc5, 0x50, 0xea, 0xc9, 0xfa, 0x56, 0xe6, 0xdb, 0xa8, 0xf0,
+  0x5a, 0xe6, 0xe3, 0x46, 0x23, 0x4e, 0x0e, 0x2a, 0xc6, 0x6a, 0x72, 0x18,
+  0xf0, 0x83, 0x15, 0x27, 0x06, 0x44, 0x9b, 0x6e, 0xe1, 0xfc, 0x00, 0xaa,
+  0x5c, 0x36, 0x35, 0x0f, 0x46, 0xed, 0x6a, 0x2b, 0x38, 0xeb, 0xa0, 0x44,
+  0x25, 0x86, 0x58, 0x54, 0x61, 0xf1, 0x9e, 0x01, 0xee, 0x4b, 0x5d, 0x4b,
+  0x2d, 0x26, 0x8e, 0xa5, 0xb9, 0xfa, 0x39, 0xa4, 0x33, 0xcc, 0xcb, 0x71,
+  0xd5, 0x44, 0xd9, 0x89, 0xd4, 0x28, 0xe5, 0xdb, 0xb2, 0x8d, 0x3c, 0xaf,
+  0xcd, 0xa7, 0x5b, 0x91, 0xf4, 0xba, 0xb9, 0xbb, 0x25, 0x20, 0x6b, 0x9a,
+  0x9d, 0x1f, 0x42, 0x89, 0x5a, 0xd5, 0xa4, 0xb0, 0xa2, 0x6b, 0xd9, 0xf4,
+  0x97, 0x8b, 0xe4, 0x63, 0xd5, 0x3c, 0xf8, 0x4d, 0x3a, 0xe6, 0x90, 0x13,
+  0x59, 0xf0, 0x10, 0xab, 0xc9, 0x02, 0x6e, 0x94, 0x42, 0xf0, 0xc2, 0x89,
+  0x65, 0x3a, 0xa0, 0xd9, 0x16, 0x56, 0xc6, 0xd2, 0x25, 0xad, 0x98, 0x64,
+  0x0e, 0xc2, 0x65, 0x96, 0x67, 0x38, 0xf8, 0x70, 0x7f, 0x63, 0xb2, 0x5b,
+  0x9a, 0x98, 0xd2, 0xe6, 0xd0, 0x6b, 0x24, 0xdc, 0x9d, 0xbe, 0x39, 0xea,
+  0x84, 0x15, 0xb4, 0x9c, 0x7f, 0xb1, 0xba, 0x8d, 0x0d, 0xda, 0xdd, 0x8f,
+  0xfe, 0xb6, 0x4c, 0xc7, 0x37, 0xbc, 0x83, 0x1c, 0x95, 0xc4, 0xbe, 0xa3,
+  0xc4, 0x49, 0x72, 0xc4, 0xea, 0x21, 0xac, 0x8a, 0x1f, 0x1c, 0x1a, 0x19,
+  0x5f, 0xa3, 0x4a, 0x35, 0xcd, 0xa3, 0x1d, 0x16, 0x0e, 0xc0, 0x28, 0x68,
+  0xbb, 0x35, 0x79, 0x57, 0xed, 0x1e, 0x22, 0xa0, 0x4f, 0x32, 0x84, 0xb0,
+  0xc2, 0x09, 0x22, 0xdb, 0xbd, 0x0e, 0xe7, 0xbb, 0x3b, 0x5b, 0x21, 0x7d,
+  0xbc, 0x5b, 0x05, 0xfc, 0xee, 0x12, 0xff, 0x21, 0x9e, 0xdf, 0xb5, 0x20,
+  0x34, 0x36, 0x66, 0x3c, 0x00, 0x80, 0xb1, 0xae, 0x6b, 0x21, 0x60, 0xe9,
+  0xc2, 0xb7, 0x2e, 0x8d, 0xff, 0xc6, 0x37, 0xb5, 0xac, 0xdf, 0x12, 0x59,
+  0xc2, 0xe1, 0x15, 0xcd, 0x1f, 0xf7, 0xcd, 0xf7, 0x5e, 0x7b, 0xe7, 0x1b,
+  0x6c, 0x4f, 0x30, 0x4f, 0x7b, 0xbe, 0xa7, 0xf9, 0x1c, 0x7e, 0x74, 0x62,
+  0x66, 0x0d, 0x8e, 0x37, 0x77, 0xd4, 0x9a, 0x7f, 0x10, 0x4f, 0x5d, 0xe4,
+  0x02, 0xcc, 0x39, 0xb1, 0xd5, 0x60, 0x11, 0x06, 0x28, 0x6f, 0xc3, 0x86,
+  0x54, 0x1d, 0xa5, 0x46, 0xb7, 0x3d, 0x5c, 0x7b, 0xbb, 0x12, 0x08, 0xd7,
+  0x3c, 0xb2, 0x7c, 0x0b, 0x57, 0x9e, 0xa9, 0x6f, 0x9b, 0x20, 0x5c, 0x43,
+  0x6a, 0x9f, 0x24, 0x88, 0x33, 0x12, 0x58, 0x81, 0x37, 0xe9, 0x38, 0xcf,
+  0x8a, 0xec, 0x52, 0xa4, 0x00, 0xdb, 0x08, 0x67, 0x4a, 0x42, 0x4e, 0x74,
+  0x8c, 0x42, 0x17, 0xf5, 0x6b, 0x62, 0xac, 0xc5, 0x10, 0x35, 0x88, 0x19,
+  0x57, 0xfc, 0x8c, 0x4e, 0x13, 0x8c, 0x77, 0x30, 0xf7, 0x96, 0x62, 0xed,
+  0x8e, 0x5d, 0x9c, 0xa7, 0x3a, 0xdf, 0x2d, 0x6e, 0xf2, 0xd9, 0xc3, 0xfa,
+  0x2b, 0xb6, 0x40, 0xcb, 0x9c, 0xa8, 0x79, 0x56, 0xcb, 0x4d, 0x5e, 0x19,
+  0x5e, 0x92, 0x68, 0x1d, 0xf6, 0x5a, 0xfb, 0xe8, 0x74, 0xce, 0x85, 0xa0,
+  0x60, 0x6b, 0xe9, 0xe4, 0xb0, 0x66, 0x20, 0x47, 0x02, 0x46, 0xc7, 0x47,
+  0x17, 0xaf, 0x89, 0xb2, 0xf2, 0xf8, 0xb2, 0xd4, 0x1f, 0x0d, 0x03, 0x7d,
+  0x9e, 0xfc, 0x3d, 0xbe, 0xe9, 0x17, 0x0b, 0xec, 0x55, 0x1f, 0xdc, 0xb4,
+  0xbf, 0xf3, 0x74, 0x50, 0xde, 0xb7, 0x46, 0x0b, 0x8a, 0x65, 0xd9, 0x0c,
+  0x94, 0xca, 0x69, 0xfd, 0xce, 0x69, 0x8a, 0x2a, 0x2e, 0xe7, 0xec, 0x7e,
+  0x55, 0x07, 0x5c, 0x6c, 0xab, 0x42, 0xcb, 0x70, 0x3b, 0x7d, 0x7e, 0xdc,
+  0x13, 0xcb, 0x83, 0x10, 0x28, 0x8f, 0x0e, 0xc0, 0xd4, 0x28, 0xcb, 0x35,
+  0xd0, 0x8b, 0x61, 0x22, 0x63, 0x23, 0xce, 0x92, 0xcb, 0x5e, 0xae, 0x0f,
+  0xac, 0x5c, 0x93, 0xa4, 0xe7, 0x22, 0x2d, 0x2b, 0xa4, 0xda, 0xae, 0x4d,
+  0x2f, 0x9b, 0x78, 0xf7, 0x58, 0x5a, 0x8e, 0x66, 0x63, 0xaa, 0xb0, 0xb0,
+  0x6b, 0x80, 0x4f, 0xb1, 0x05, 0xe7, 0x03, 0x95, 0xdd, 0x05, 0xa8, 0x14,
+  0x11, 0xf6, 0x06, 0x04, 0x57, 0x23, 0x3b, 0x96, 0x74, 0xcd, 0xe5, 0x38,
+  0xe0, 0x6a, 0xb2, 0x6c, 0xcf, 0xae, 0xf3, 0xd1, 0xfe, 0x32, 0x7a, 0xc1,
+  0x28, 0x4f, 0xc9, 0x1c, 0x05, 0x28, 0xec, 0x84, 0xcb, 0x6d, 0x2a, 0xb0,
+  0xbe, 0x6c, 0xfb, 0x77, 0x5c, 0x30, 0x2c, 0x3b, 0xdc, 0x5f, 0xb6, 0x8f,
+  0x2e, 0xce, 0x13, 0xdc, 0x7e, 0x12, 0x11, 0xa9, 0xb7, 0xfc, 0x7f, 0xb4,
+  0x3c, 0xfc, 0xdb, 0x6d, 0x8e, 0xdd, 0x1f, 0x2d, 0xf1, 0x5d, 0xed, 0xc5,
+  0x43, 0xe1, 0xc3, 0x32, 0x6f, 0x79, 0x42, 0x5d, 0xb1, 0x81, 0x43, 0xb5,
+  0x40, 0xc4, 0xdc, 0x2c, 0xac, 0x99, 0xc2, 0xd5, 0xce, 0x49, 0x6b, 0xac,
+  0x53, 0xdb, 0x52, 0xb8, 0x49, 0xaf, 0x8a, 0xfd, 0x5b, 0xb3, 0xb2, 0x4b,
+  0x37, 0x30, 0xf9, 0x84, 0xcd, 0xb7, 0xb9, 0xac, 0xf9, 0x75, 0x97, 0xb8,
+  0xa5, 0x6a, 0x83, 0x80, 0x32, 0xa8, 0x0e, 0xae, 0x4d, 0x70, 0x76, 0x29,
+  0x17, 0xb6, 0xa0, 0xcd, 0xbf, 0x5e, 0x92, 0x48, 0xdb, 0x6b, 0x91, 0x56,
+  0xcc, 0xa0, 0x9a, 0x4a, 0x49, 0x87, 0x58, 0xc1, 0x04, 0x14, 0x15, 0x4d,
+  0x5b, 0x40, 0xda, 0xfa, 0x2d, 0x43, 0x30, 0x36, 0xea, 0x34, 0xb4, 0x8d,
+  0xce, 0xec, 0xe0, 0x3c, 0x2a, 0xb7, 0x80, 0xff, 0xa2, 0x89, 0xdd, 0x6e,
+  0x49, 0xf5, 0xb4, 0x44, 0x8d, 0xae, 0x5b, 0x3a, 0xaa, 0xe6, 0x67, 0x3c,
+  0xb4, 0xcd, 0x5a, 0x6b, 0xdd, 0xe7, 0x72, 0x20, 0xf9, 0x9e, 0x0d, 0x94,
+  0x2a, 0xfe, 0x5d, 0x1c, 0x84, 0x08, 0xc1, 0x00, 0x34, 0x58, 0x9b, 0x2a,
+  0xa5, 0x78, 0x82, 0x73, 0xd7, 0xfa, 0xec, 0xb1, 0x53, 0x7f, 0x84, 0x90,
+  0x20, 0xcd, 0xae, 0x4b, 0xbf, 0xa9, 0x4d, 0x5d, 0xd3, 0xee, 0xd2, 0x49,
+  0x7b, 0x6e, 0x84, 0xae, 0x80, 0x01, 0x5d, 0xeb, 0x1a, 0x20, 0xdd, 0xcc,
+  0xd2, 0x1b, 0x8f, 0x0f, 0xe9, 0xba, 0x81, 0x48, 0x74, 0x45, 0x7b, 0xff,
+  0xc5, 0x6a, 0x0d, 0x66, 0x3c, 0xd7, 0x0e, 0x30, 0x8d, 0x91, 0xfd, 0x8e,
+  0x5c, 0xac, 0x28, 0x28, 0x37, 0x85, 0x84, 0xef, 0x10, 0x3f, 0x44, 0xdc,
+  0xbd, 0x96, 0x65, 0xda, 0xac, 0xb2, 0x9c, 0xfb, 0xec, 0x7d, 0x86, 0x74,
+  0xb8, 0x5e, 0xe2, 0x96, 0x1d, 0xad, 0x2c, 0xef, 0x4d, 0xa1, 0x7a, 0xf2,
+  0x44, 0xc1, 0x9c, 0x83, 0x01, 0x17, 0x2d, 0xf7, 0x0c, 0x67, 0x3a, 0x25,
+  0x33, 0xf5, 0x40, 0x8d, 0xf2, 0xec, 0x86, 0xc8, 0x1b, 0xaf, 0xb1, 0x04,
+  0x0b, 0x71, 0x59, 0xce, 0xa8, 0xe9, 0x35, 0xb4, 0xe2, 0x82, 0xfb, 0xd0,
+  0x62, 0x6d, 0xd2, 0xfb, 0x27, 0xb2, 0xfc, 0x18, 0x4f, 0xec, 0x02, 0x2b,
+  0xc5, 0x51, 0x7d, 0x76, 0x13, 0xf2, 0xc5, 0x81, 0x8a, 0x3f, 0x3e, 0x74,
+  0xa1, 0xa1, 0x92, 0x3e, 0x00, 0xf8, 0xfb, 0x6b, 0x1e, 0x0f, 0xdd, 0x5d,
+  0x79, 0x4f, 0xb3, 0x31, 0x79, 0x5b, 0x42, 0x92, 0x29, 0xa7, 0x33, 0x8f,
+  0x2c, 0x63, 0x98, 0x91, 0x6f, 0x2f, 0x4e, 0xde, 0x44, 0x6b, 0xa4, 0x32,
+  0xfe, 0xae, 0xfa, 0xd5, 0xbf, 0x22, 0x9b, 0xd1, 0x17, 0xc7, 0xc7, 0x43,
+  0x96, 0xcc, 0xd4, 0x13, 0xd8, 0xd0, 0xfd, 0x4a, 0x71, 0x49, 0xe1, 0x26,
+  0xcb, 0x53, 0x52, 0xd1, 0x72, 0x4e, 0xd7, 0x29, 0xb3, 0x71, 0x36, 0x45,
+  0x62, 0x17, 0xde, 0xa1, 0x86, 0xa4, 0x08, 0x30, 0x73, 0x54, 0xe0, 0x4b,
+  0x4d, 0x99, 0xa6, 0x16, 0x49, 0x23, 0x3c, 0x01, 0x8a, 0x0b, 0x0f, 0xc0,
+  0x08, 0x41, 0x04, 0x44, 0x3e, 0xc1, 0x28, 0xa4, 0x67, 0x11, 0xf7, 0x29,
+  0x63, 0x3f, 0xe3, 0x76, 0x57, 0xa5, 0xf5, 0x26, 0xe5, 0xe0, 0xab, 0x35,
+  0xd5, 0x13, 0xaa, 0x40, 0x2f, 0x1c, 0x9e, 0x3e, 0xc9, 0x72, 0xf6, 0x59,
+  0x04, 0x30, 0x23, 0x80, 0x9f, 0x5a, 0x72, 0x0c, 0x02, 0x86, 0xb7, 0xca,
+  0x1a, 0x91, 0xdc, 0x77, 0xd7, 0x99, 0xf8, 0xff, 0x79, 0x99, 0x41, 0x4b,
+  0xb2, 0xbb, 0xec, 0x9b, 0x10, 0x90, 0x0a, 0xb9, 0x8c, 0x2d, 0x09, 0x9b,
+  0x73, 0x6e, 0xdc, 0x6e, 0xb4, 0x86, 0x27, 0x59, 0x29, 0x2b, 0xc9, 0x7a,
+  0x21, 0x41, 0x00, 0x66, 0x29, 0xda, 0x9c, 0xc3, 0xf4, 0x6a, 0x0d, 0x42,
+  0x52, 0xbb, 0xd0, 0x87, 0x11, 0x3d, 0x2c, 0xef, 0xb5, 0x45, 0x68, 0x56,
+  0xe4, 0x3d, 0xa2, 0xb6, 0x7f, 0x59, 0xd4, 0xd3, 0x62, 0x66, 0x38, 0xcc,
+  0xeb, 0x45, 0xbd, 0x0f, 0xc8, 0x73, 0xb5, 0x44, 0x19, 0x4c, 0xed, 0x3f,
+  0x2a, 0x9c, 0x64, 0x34, 0x52, 0xbd, 0xc4, 0x5b, 0x63, 0xea, 0xbe, 0x95,
+  0x18, 0x7c, 0xbd, 0xe6, 0x33, 0x7d, 0x28, 0x84, 0x35, 0x2a, 0xca, 0x49,
+  0xb6, 0x14, 0xef, 0x16, 0x1b, 0xdd, 0x72, 0xe3, 0xc6, 0xff, 0xf8, 0x67,
+  0xd3, 0x5d, 0xf7, 0xc3, 0x4f, 0x22, 0x3d, 0x4a, 0xc4, 0xa3, 0x0f, 0xff,
+  0x33, 0xa2, 0x2a, 0x3c, 0x14, 0x1c, 0xb6, 0x0f, 0x79, 0x05, 0x32, 0x45,
+  0x39, 0x5c, 0x0d, 0x74, 0x7c, 0xf1, 0x52, 0x2b, 0x2b, 0xd5, 0xb1, 0x59,
+  0xbe, 0x1b, 0x83, 0x03, 0x07, 0x75, 0x47, 0x03, 0xa0, 0x26, 0xc5, 0x93,
+  0x99, 0xac, 0x83, 0xee, 0xb1, 0xe0, 0xe0, 0x2a, 0x06, 0x21, 0x47, 0x66,
+  0x8a, 0x01, 0x94, 0xc7, 0x0f, 0x46, 0xcb, 0x1e, 0x8a, 0x74, 0xde, 0xc4,
+  0x7b, 0x90, 0x8d, 0xd6, 0x20, 0xcb, 0x7f, 0xd0, 0x79, 0xeb, 0x95, 0x77,
+  0xd9, 0x3f, 0x07, 0x30, 0xf5, 0xb3, 0x9a, 0xdf, 0xcf, 0x04, 0xe9, 0xf1,
+  0xfd, 0x47, 0xbb, 0xd0, 0x80, 0x3a, 0x4d, 0x7c, 0x4b, 0x5e, 0x01, 0xdb,
+  0x73, 0x17, 0x33, 0xbd, 0x06, 0x5e, 0xa2, 0xda, 0x1d, 0x7a, 0xe9, 0xc1,
+  0xb0, 0xf0, 0xcf, 0x01, 0xfe, 0xfd, 0x61, 0xb7, 0xff, 0xec, 0x27, 0xd7,
+  0xeb, 0x47, 0xbb, 0xef, 0x3f, 0xda, 0xeb, 0xb4, 0xc2, 0x81, 0x42, 0x57,
+  0x8c, 0xb4, 0x4e, 0x44, 0xb5, 0x78, 0xb6, 0x94, 0x3c, 0x14, 0x4f, 0x7b,
+  0x5c, 0xf8, 0xc8, 0x33, 0x07, 0xe0, 0x55, 0x87, 0x1a, 0x3b, 0x3f, 0x29,
+  0x3e, 0x00, 0x1f, 0x14, 0x56, 0x12, 0xb3, 0x9e, 0xe0, 0x7e, 0xe4, 0x4f,
+  0x45, 0x2c, 0x91, 0x90, 0x03, 0x33, 0x14, 0x35, 0x90, 0x5a, 0x10, 0x5f,
+  0x31, 0x59, 0x91, 0xa2, 0x20, 0x06, 0xbd, 0x80, 0xac, 0x4f, 0x19, 0x86,
+  0x08, 0x38, 0x3b, 0xfd, 0x16, 0x03, 0x8e, 0x10, 0x75, 0x40, 0xd5, 0xb1,
+  0xf6, 0x14, 0x14, 0x8d, 0x55, 0xa0, 0x4e, 0x07, 0xd7, 0x23, 0xc5, 0xd0,
+  0x13, 0xc8, 0x08, 0x0d, 0x3c, 0x1c, 0xce, 0x56, 0x71, 0x86, 0xbb, 0x10,
+  0xac, 0x29, 0x7c, 0x59, 0x8f, 0x71, 0x4f, 0x73, 0x92, 0x88, 0xd4, 0xb8,
+  0x0c, 0xcb, 0xb2, 0x6c, 0x66, 0x24, 0x0f, 0xb6, 0x5a, 0x23, 0xef, 0xb4,
+  0xb5, 0x20, 0x7e, 0x31, 0x0a, 0x42, 0x30, 0xa2, 0x42, 0xb0, 0x0f, 0xa1,
+  0x4f, 0x01, 0x4c, 0x6d, 0x0c, 0x16, 0xbd, 0x26, 0xb2, 0xda, 0x55, 0xb6,
+  0xea, 0x39, 0xf8, 0x8d, 0x64, 0x5a, 0x24, 0xad, 0x20, 0xb1, 0x20, 0x8a,
+  0xa5, 0x81, 0x59, 0x9a, 0x92, 0x55, 0x21, 0x08, 0xb6, 0x51, 0x30, 0xe7,
+  0x96, 0x5a, 0xa0, 0x16, 0xa8, 0xf7, 0x01, 0xaa, 0xe8, 0xa3, 0xd6, 0x4a,
+  0x11, 0xbd, 0x5c, 0x5c, 0xe7, 0x74, 0xfd, 0x3d, 0x90, 0x3b, 0x8c, 0xa7,
+  0xe4, 0x21, 0x77, 0x14, 0x83, 0xec, 0xd8, 0xdf, 0x30, 0x8b, 0x15, 0xf1,
+  0xae, 0x4f, 0x76, 0x76, 0xeb, 0x7b, 0x51, 0x29, 0x2b, 0x9d, 0x73, 0xd5,
+  0x44, 0xba, 0x1d, 0xce, 0x5f, 0x1f, 0x44, 0xd1, 0xde, 0xc7, 0xbb, 0x1f,
+  0x6f, 0xef, 0xee, 0x0c, 0x9e, 0x0c, 0xf6, 0x54, 0x79, 0x65, 0xa3, 0x2a,
+  0x09, 0x4f, 0xb7, 0x5c, 0xfb, 0x1d, 0x3e, 0xe8, 0x76, 0xb7, 0x2d, 0x24,
+  0x3a, 0x6a, 0x2e, 0x40, 0x57, 0x54, 0xec, 0x0a, 0xcf, 0xe3, 0x63, 0x78,
+  0x98, 0x9d, 0x43, 0xd1, 0xc0, 0xef, 0x5b, 0x2a, 0x86, 0x60, 0x28, 0x2a,
+  0x1f, 0x2c, 0x05, 0x1c, 0x75, 0x94, 0xd2, 0xfd, 0x56, 0xa2, 0x44, 0x12,
+  0xd2, 0x15, 0x49, 0xe6, 0x31, 0x04, 0x0d, 0x89, 0xe6, 0x0d, 0xaa, 0x81,
+  0xb5, 0xe3, 0xb8, 0xcc, 0x5d, 0x59, 0x66, 0x24, 0xfb, 0x99, 0xf6, 0xc1,
+  0x91, 0x63, 0xa9, 0xa4, 0xcf, 0x31, 0x30, 0x03, 0xdd, 0x0a, 0x5c, 0xb0,
+  0xe2, 0x2b, 0xcb, 0xde, 0x8b, 0x5b, 0x83, 0xae, 0xd4, 0xdf, 0xaa, 0x57,
+  0x6e, 0x2c, 0x9e, 0x79, 0x0f, 0x22, 0xa0, 0x1f, 0x48, 0x25, 0x02, 0xf6,
+  0x65, 0x09, 0x50, 0xdc, 0x24, 0x6d, 0x03, 0x6b, 0x4a, 0x1d, 0xec, 0xb9,
+  0xdf, 0x71, 0xcd, 0xc2, 0x87, 0x03, 0x87, 0x63, 0x36, 0xee, 0xbc, 0x21,
+  0xe4, 0xc1, 0x48, 0x9c, 0x07, 0x90, 0xad, 0x44, 0x90, 0x20, 0xa2, 0x87,
+  0xe8, 0xf1, 0x20, 0x45, 0x2c, 0xd8, 0x74, 0x4d, 0x03, 0x4f, 0x25, 0x6d,
+  0xa2, 0x66, 0x1d, 0x31, 0x29, 0x55, 0x8b, 0x2e, 0xcd, 0x66, 0xcb, 0x46,
+  0x01, 0x63, 0xab, 0xf1, 0xa4, 0x12, 0x47, 0x50, 0x8c, 0x4e, 0xc4, 0x1f,
+  0x67, 0x51, 0xb2, 0xa8, 0x48, 0x0e, 0x59, 0x42, 0x28, 0x1c, 0x9f, 0xfc,
+  0x76, 0x02, 0xdb, 0x76, 0xb1, 0x0a, 0x39, 0x32, 0x8d, 0xfa, 0x74, 0xb7,
+  0x2d, 0x1a, 0x75, 0x25, 0xf7, 0xb6, 0x7e, 0xcd, 0xe8, 0xb4, 0xd6, 0xe4,
+  0x4d, 0x88, 0x6f, 0xd4, 0x04, 0x96, 0xb2, 0x2e, 0xe9, 0x37, 0x96, 0x9b,
+  0xf1, 0x63, 0x5a, 0x17, 0xdb, 0x97, 0x01, 0xc6, 0xd4, 0xd7, 0x7a, 0xb7,
+  0xb5, 0x8a, 0x12, 0x56, 0xd9, 0x56, 0x75, 0xdd, 0xa5, 0xaf, 0x45, 0xcf,
+  0x65, 0x7d, 0x59, 0x8c, 0x93, 0xee, 0xa5, 0x1a, 0x0b, 0x44, 0x51, 0x6c,
+  0x49, 0xd0, 0x93, 0x98, 0x50, 0x1b, 0x8b, 0x2d, 0x3c, 0x5a, 0x42, 0x7e,
+  0xf4, 0x49, 0x83, 0x7f, 0x77, 0x07, 0xa7, 0x9d, 0x24, 0x30, 0xa5, 0xa6,
+  0x10, 0x5b, 0x48, 0x47, 0x18, 0x58, 0x9a, 0x14, 0xbf, 0xb5, 0xb7, 0x5e,
+  0xf6, 0x67, 0xed, 0x7a, 0x36, 0xb7, 0x68, 0xc2, 0xc2, 0xfc, 0x03, 0x7b,
+  0x14, 0x6e, 0x91, 0x48, 0xfe, 0xbf, 0xea, 0x1e, 0x49, 0xff, 0x2d, 0x9b,
+  0xa4, 0x7d, 0xb5, 0x86, 0xf1, 0x04, 0x18, 0x7c, 0xbf, 0x75, 0x34, 0x4c,
+  0xb0, 0xa0, 0x75, 0xbd, 0xa7, 0x61, 0x8d, 0x7e, 0x90, 0xad, 0xb8, 0x45,
+  0x5c, 0xe7, 0xbe, 0xa8, 0xaf, 0x63, 0x9b, 0x4b, 0xfa, 0x01, 0x8e, 0x22,
+  0xcb, 0x39, 0xaf, 0x58, 0xd8, 0x2b, 0x2b, 0x5a, 0x8f, 0x5b, 0x70, 0x4f,
+  0x6a, 0x20, 0xe1, 0x07, 0x16, 0xf5, 0x37, 0xa2, 0x52, 0x6f, 0xfd, 0x7e,
+  0x04, 0xfb, 0x86, 0x1e, 0xf8, 0x01, 0x76, 0x12, 0xac, 0x73, 0xd3, 0xe0,
+  0xf0, 0xaf, 0x91, 0x2a, 0xdb, 0x3c, 0x2a, 0xcb, 0xca, 0x5d, 0x54, 0x96,
+  0xaf, 0x8e, 0x22, 0xf4, 0xef, 0xa5, 0x50, 0xd1, 0x47, 0x6d, 0xd1, 0x16,
+  0xdb, 0xba, 0x6e, 0x25, 0xa2, 0x61, 0xa7, 0x6d, 0xce, 0x05, 0x2e, 0xb7,
+  0x4d, 0x2f, 0x4a, 0x1b, 0xb6, 0xad, 0x9b, 0xfd, 0x7b, 0x7b, 0x75, 0xab,
+  0xd7, 0x12, 0x28, 0xca, 0xf7, 0x55, 0x8b, 0xdc, 0xc2, 0x4d, 0x39, 0x1b,
+  0x8b, 0x95, 0x44, 0xd3, 0x52, 0xbc, 0x92, 0x63, 0xc5, 0x23, 0x89, 0xac,
+  0x66, 0x75, 0x64, 0x48, 0xab, 0xf7, 0xab, 0xf5, 0xc0, 0xbb, 0x33, 0xd2,
+  0x7a, 0xa7, 0x16, 0x88, 0x98, 0x96, 0x5a, 0x7e, 0x86, 0x31, 0xec, 0x58,
+  0xca, 0x77, 0x51, 0x21, 0x85, 0xc2, 0x3f, 0x50, 0x27, 0x8d, 0x2b, 0x19,
+  0x9d, 0xc6, 0x0b, 0xea, 0x89, 0x4b, 0xc8, 0xf2, 0xdd, 0x1b, 0x4b, 0x69,
+  0x9c, 0xd2, 0xa3, 0xe4, 0xe9, 0x32, 0x1c, 0x9c, 0xbe, 0x7d, 0x7b, 0x74,
+  0xe0, 0xb1, 0xaf, 0x9b, 0x41, 0x3a, 0x4d, 0x73, 0x83, 0x9a, 0x35, 0x24,
+  0xe4, 0x51, 0x03, 0xd1, 0xd4, 0x08, 0x6c, 0xce, 0x6a, 0x3d, 0x5f, 0xb0,
+  0x1c, 0xb4, 0xeb, 0xc1, 0x12, 0x99, 0x10, 0xcf, 0x25, 0x04, 0x53, 0x97,
+  0xca, 0x56, 0xaa, 0xcc, 0xfe, 0x3d, 0x74, 0x24, 0xdd, 0x56, 0x98, 0xdc,
+  0x72, 0xf4, 0x00, 0x40, 0x10, 0x04, 0x7c, 0x31, 0x2f, 0x3d, 0x88, 0x0d,
+  0xe4, 0xbc, 0x54, 0x62, 0x46, 0x59, 0x8b, 0x9b, 0xfa, 0x6f, 0xc7, 0x06,
+  0x3a, 0xdb, 0x0e, 0x8a, 0x8e, 0xbe, 0x54, 0xe0, 0xc8, 0xcf, 0xd6, 0xd4,
+  0x35, 0x63, 0x93, 0x61, 0x11, 0xa4, 0xa2, 0x97, 0x59, 0xbe, 0x3d, 0x65,
+  0xb1, 0x19, 0xd1, 0xde, 0xd9, 0xd4, 0x00, 0xeb, 0x82, 0x62, 0x9c, 0x2d,
+  0x17, 0x18, 0xf5, 0xe7, 0x44, 0x40, 0xb3, 0xc2, 0x6a, 0x05, 0x19, 0x0e,
+  0x17, 0x71, 0x75, 0x29, 0x51, 0x62, 0xd1, 0x25, 0x45, 0xf8, 0x23, 0x51,
+  0x4f, 0x3e, 0x46, 0x4d, 0x45, 0xb8, 0x97, 0x16, 0xd0, 0x1a, 0x53, 0x20,
+  0x5e, 0xf3, 0x8b, 0xa5, 0xb0, 0xc6, 0x4a, 0xd5, 0x34, 0x2e, 0x88, 0xad,
+  0x74, 0x69, 0x59, 0x8f, 0x0d, 0x58, 0x3d, 0x94, 0xfb, 0x44, 0xd1, 0x50,
+  0x0f, 0xc5, 0x69, 0x80, 0x9a, 0x92, 0xd2, 0x97, 0x97, 0x5a, 0xb6, 0x46,
+  0x2a, 0x5e, 0x72, 0xb9, 0x75, 0x1f, 0xf5, 0xde, 0x12, 0xd0, 0x06, 0x10,
+  0xe9, 0x45, 0xa3, 0x11, 0x36, 0x17, 0xb8, 0x33, 0x42, 0x2b, 0xe2, 0x96,
+  0x3f, 0x44, 0xe4, 0x6d, 0x02, 0x7c, 0xd3, 0x0a, 0x34, 0x2c, 0x28, 0x0e,
+  0x98, 0xb3, 0xbd, 0x9e, 0x6e, 0x3a, 0xa0, 0x35, 0xe8, 0x00, 0xb3, 0xb3,
+  0x53, 0x85, 0x5f, 0x90, 0x98, 0x4d, 0xf7, 0x36, 0xcd, 0x3a, 0x80, 0x0f,
+  0x6d, 0x46, 0x7c, 0xda, 0x2d, 0xa1, 0x16, 0x4e, 0x16, 0xdb, 0x37, 0xdf,
+  0xcd, 0xd3, 0x7b, 0xd6, 0x53, 0x9a, 0xc2, 0xb7, 0x6b, 0x6b, 0xfd, 0xb0,
+  0x3a, 0xbb, 0xcf, 0xf7, 0x06, 0xbb, 0x1f, 0x7f, 0x3a, 0x20, 0xb5, 0x73,
+  0xb7, 0x13, 0x62, 0x4b, 0xb0, 0x8f, 0x0d, 0x6d, 0x08, 0x7f, 0xd8, 0x68,
+  0xb9, 0x5b, 0xda, 0xe2, 0x5b, 0xc2, 0xb6, 0x67, 0xab, 0x41, 0x10, 0xa0,
+  0x52, 0x69, 0x5d, 0x03, 0x58, 0xea, 0xad, 0xf6, 0x03, 0xab, 0x23, 0x33,
+  0x24, 0x56, 0x87, 0xda, 0xea, 0x8e, 0x8a, 0x27, 0xb1, 0xf0, 0xf5, 0x46,
+  0xdb, 0x00, 0xd4, 0x03, 0x22, 0x68, 0xaf, 0x42, 0xea, 0xfa, 0x6f, 0x70,
+  0xb3, 0x9f, 0x7d, 0xa8, 0xe1, 0xa5, 0x72, 0x8c, 0x5f, 0x3d, 0x2d, 0xce,
+  0x5f, 0xc7, 0x27, 0x42, 0x32, 0x12, 0x5c, 0x7d, 0xe4, 0x81, 0xf3, 0x6b,
+  0xb1, 0x17, 0x3c, 0xbc, 0xa8, 0xac, 0xda, 0xaa, 0x35, 0xc7, 0x65, 0x4e,
+  0x3d, 0x20, 0xaa, 0x9d, 0x45, 0xd7, 0xb2, 0x8b, 0x94, 0x87, 0x44, 0xcb,
+  0x6d, 0xf6, 0x93, 0x05, 0x0c, 0xca, 0xfc, 0x62, 0x8a, 0x72, 0xb1, 0xb0,
+  0x71, 0x59, 0x73, 0x78, 0xe7, 0x4f, 0x7f, 0x0a, 0xd8, 0xd0, 0xdf, 0x2a,
+  0xe1, 0x6a, 0xea, 0x49, 0x17, 0xdc, 0x06, 0x0f, 0x61, 0x93, 0x19, 0x56,
+  0x46, 0x98, 0xfd, 0xac, 0x2a, 0x3e, 0x67, 0xe2, 0x37, 0xd3, 0xbe, 0x02,
+  0xc0, 0x0a, 0x57, 0xa8, 0x6d, 0x94, 0x08, 0x1a, 0x8a, 0xa2, 0x74, 0x69,
+  0xa6, 0x01, 0x1b, 0xf5, 0x02, 0x10, 0x95, 0x66, 0x6c, 0x5e, 0x2d, 0xcc,
+  0xad, 0x8a, 0x72, 0xa1, 0xb1, 0xaf, 0x09, 0x8a, 0xab, 0xb3, 0x79, 0x2c,
+  0x98, 0xdc, 0x7f, 0xa7, 0x56, 0x19, 0x41, 0xe7, 0xc1, 0x3a, 0xc9, 0xdb,
+  0x43, 0xe6, 0xb2, 0x08, 0x37, 0x00, 0xc3, 0x88, 0xf3, 0x51, 0x5a, 0xe6,
+  0xb1, 0xc6, 0x5a, 0x68, 0x56, 0x58, 0x70, 0x8f, 0x72, 0x35, 0x49, 0xf8,
+  0x4f, 0x86, 0xeb, 0x72, 0xc3, 0x88, 0xa3, 0xfc, 0x77, 0xee, 0xd5, 0x57,
+  0x55, 0x66, 0xfb, 0x36, 0xf2, 0xca, 0xa2, 0x2f, 0x8e, 0x5e, 0x9f, 0x9e,
+  0x1f, 0xd5, 0x6a, 0x72, 0x16, 0x08, 0x23, 0x6d, 0x0a, 0x85, 0x02, 0x19,
+  0xbf, 0xc9, 0x85, 0xb7, 0xc4, 0xaa, 0x11, 0x82, 0x91, 0x9c, 0x7d, 0x7b,
+  0x18, 0xf0, 0x68, 0xcb, 0xaf, 0xb3, 0x46, 0x7b, 0xcd, 0x78, 0xb6, 0x51,
+  0x22, 0x47, 0x7b, 0x8b, 0xab, 0xa8, 0xc9, 0x49, 0xb3, 0x01, 0x72, 0xfa,
+  0xa4, 0xf4, 0xa7, 0x95, 0x1c, 0xc5, 0x2b, 0x58, 0x14, 0x30, 0x86, 0xac,
+  0x0b, 0xf1, 0x0d, 0xeb, 0x9e, 0xcd, 0x4c, 0x20, 0x05, 0x3a, 0x0a, 0x70,
+  0x70, 0x06, 0x52, 0xe5, 0x4a, 0xb3, 0x7b, 0xdc, 0x4a, 0xac, 0x03, 0xc0,
+  0x97, 0x6e, 0x2d, 0x67, 0x5e, 0x8b, 0xd6, 0x49, 0x52, 0xc9, 0x24, 0xb2,
+  0x2c, 0xcb, 0x30, 0xab, 0xf1, 0xaf, 0x82, 0xab, 0x74, 0xa9, 0x68, 0xe0,
+  0xeb, 0x52, 0x95, 0xb5, 0xe7, 0xcd, 0x62, 0xab, 0x52, 0xa5, 0xcd, 0x95,
+  0x4b, 0xc6, 0xa0, 0xbb, 0x7f, 0xea, 0x46, 0x9b, 0xa5, 0x43, 0x0d, 0x6f,
+  0xc9, 0xb3, 0x74, 0x78, 0x79, 0x1a, 0x49, 0x05, 0x92, 0x71, 0x95, 0x2a,
+  0xd6, 0xd4, 0xa6, 0xb0, 0x39, 0xaf, 0x09, 0x26, 0x77, 0xb9, 0x5a, 0x02,
+  0x40, 0xa2, 0xe9, 0x60, 0x0e, 0x54, 0xc3, 0x55, 0xcc, 0x94, 0x46, 0x7a,
+  0x0f, 0xe5, 0xfb, 0x06, 0x01, 0xca, 0xce, 0x5b, 0x11, 0x8f, 0x14, 0xdf,
+  0xef, 0x7b, 0x8b, 0xda, 0xe1, 0xd4, 0x80, 0x62, 0x35, 0x2f, 0x71, 0x5b,
+  0x4b, 0x2c, 0xeb, 0x38, 0xcb, 0xb1, 0x9e, 0xb5, 0xe6, 0xa4, 0xd6, 0xb0,
+  0x6e, 0x18, 0x6d, 0xc3, 0xf9, 0xeb, 0x83, 0xe7, 0xcf, 0x9e, 0xe3, 0xe0,
+  0x71, 0x99, 0x00, 0x3a, 0x0f, 0x78, 0x42, 0xdd, 0x9f, 0x3d, 0x39, 0x0d,
+  0x21, 0xa0, 0x5d, 0xe3, 0x26, 0x36, 0x4b, 0xa4, 0x6b, 0x74, 0x53, 0x68,
+  0x65, 0x21, 0x3e, 0x52, 0xd6, 0x49, 0x0d, 0xf8, 0x6c, 0x0b, 0xed, 0x0f,
+  0x83, 0x0e, 0x5e, 0x34, 0xc0, 0x47, 0xae, 0x72, 0xc4, 0xd3, 0x5e, 0xcf,
+  0x32, 0x24, 0x58, 0x5d, 0x73, 0x25, 0xc9, 0x29, 0xfd, 0x37, 0xbb, 0x61,
+  0xb4, 0x92, 0xc5, 0xdd, 0x04, 0x6e, 0x56, 0x01, 0xe5, 0xce, 0x67, 0xf8,
+  0x8f, 0x3f, 0x2f, 0x56, 0x33, 0x84, 0x4d, 0xff, 0x0a, 0xd5, 0xab, 0x88,
+  0xb4, 0xe8, 0x62, 0xe3, 0xfc, 0x83, 0x76, 0xf7, 0x97, 0x44, 0x2f, 0x84,
+  0x90, 0x51, 0x6c, 0xb8, 0x37, 0xcc, 0x28, 0x7e, 0x31, 0xa8, 0x1d, 0x70,
+  0x17, 0xa6, 0x27, 0xb6, 0x80, 0xc8, 0x19, 0x72, 0x2d, 0x6d, 0x85, 0x74,
+  0xcd, 0x31, 0x2f, 0x8a, 0xf9, 0xc3, 0xf1, 0x33, 0x5e, 0xfe, 0xe6, 0xd0,
+  0x56, 0x57, 0xe6, 0x51, 0x1e, 0x6f, 0x60, 0x1f, 0xc2, 0xf3, 0x2c, 0xc8,
+  0xfd, 0x55, 0xe0, 0xde, 0x41, 0xc3, 0xd9, 0x92, 0x5c, 0x4d, 0x64, 0x9e,
+  0xf5, 0x70, 0xf1, 0x7e, 0xbe, 0xcd, 0x0b, 0x71, 0x45, 0x4b, 0xc0, 0x3f,
+  0x3e, 0xfb, 0x00, 0x30, 0x38, 0x89, 0xb1, 0x5a, 0x82, 0x9d, 0x78, 0x04,
+  0x72, 0x2f, 0x34, 0xcf, 0x72, 0x13, 0x02, 0x83, 0xd4, 0xaa, 0x10, 0x88,
+  0x25, 0x71, 0xe9, 0x6d, 0xd5, 0x89, 0x48, 0x70, 0xa8, 0xb9, 0xd1, 0xdd,
+  0xc1, 0x6e, 0x2f, 0x20, 0x41, 0xc6, 0xcc, 0x51, 0x57, 0x0c, 0xfa, 0x1a,
+  0x44, 0xe7, 0x68, 0xd9, 0x20, 0xf4, 0xf8, 0x74, 0x36, 0x8c, 0x1a, 0x8a,
+  0xf4, 0x0e, 0x14, 0x69, 0x77, 0x60, 0x91, 0x33, 0xd1, 0x20, 0x8f, 0x9d,
+  0xfe, 0xd3, 0xe7, 0xcf, 0x2b, 0x88, 0x98, 0xe1, 0x25, 0xf9, 0x6c, 0x67,
+  0x47, 0x12, 0x49, 0xea, 0xaf, 0xd1, 0x17, 0xfd, 0xe7, 0xfc, 0x62, 0xf5,
+  0x35, 0xd5, 0x8a, 0xd6, 0xbe, 0xd7, 0xc7, 0x37, 0x2d, 0xdd, 0xb1, 0xe8,
+  0xb1, 0xf6, 0xad, 0xe7, 0xe8, 0xae, 0xe5, 0x2d, 0x81, 0x2e, 0xe0, 0xb5,
+  0xcb, 0x2e, 0x2f, 0x51, 0xab, 0x05, 0x4f, 0x0a, 0x7a, 0x4c, 0x96, 0xdf,
+  0xc5, 0xf9, 0xa4, 0x39, 0xdd, 0x9d, 0x5e, 0x7f, 0x77, 0xdd, 0x74, 0x1d,
+  0xe4, 0x39, 0x6f, 0x20, 0xf8, 0xe4, 0xe6, 0x1f, 0xb7, 0x36, 0xbf, 0xda,
+  0x6a, 0x9b, 0xfd, 0x27, 0x3b, 0x3b, 0xbd, 0x8f, 0xf1, 0xf3, 0xf9, 0xf3,
+  0x76, 0xe1, 0xac, 0xd2, 0xc7, 0x13, 0x9b, 0x5a, 0x65, 0xb4, 0xd4, 0x4e,
+  0x4b, 0xeb, 0xbb, 0xd4, 0xea, 0xee, 0xf3, 0xe7, 0x3d, 0xf4, 0xf2, 0xec,
+  0x51, 0xad, 0x97, 0x77, 0x99, 0xd7, 0xec, 0x76, 0x5d, 0x57, 0x4c, 0x81,
+  0x45, 0x6d, 0x0a, 0xf4, 0x67, 0x14, 0xbd, 0x92, 0x04, 0x9b, 0xc8, 0x34,
+  0x6d, 0xc5, 0x29, 0x57, 0x93, 0x79, 0xb5, 0x28, 0xad, 0x94, 0x81, 0xd5,
+  0xdb, 0xcf, 0x55, 0x41, 0xdd, 0xf0, 0x49, 0xc8, 0x6c, 0x3e, 0xf7, 0x80,
+  0x2b, 0xec, 0xf7, 0xe3, 0xea, 0x20, 0x1e, 0xfc, 0x8e, 0x58, 0x22, 0xd1,
+  0xcb, 0x16, 0xcb, 0x09, 0xb7, 0xf1, 0x34, 0x65, 0xda, 0xec, 0x72, 0x82,
+  0x90, 0xd5, 0xa1, 0x2b, 0xca, 0x6c, 0xd1, 0x15, 0x1e, 0xcb, 0xe3, 0xb6,
+  0xe6, 0x98, 0xa3, 0xdf, 0x47, 0xfa, 0x74, 0x9f, 0x1f, 0x53, 0x54, 0xd7,
+  0x98, 0xcd, 0x23, 0xb5, 0xae, 0x22, 0x97, 0x78, 0xa3, 0x0e, 0x70, 0x6e,
+  0xcd, 0xc5, 0x24, 0xf9, 0xb9, 0x75, 0x8b, 0x20, 0x4f, 0x51, 0xb9, 0x13,
+  0x2a, 0x2e, 0x0a, 0xba, 0x92, 0xc0, 0x55, 0xd1, 0xa5, 0x60, 0x08, 0x1c,
+  0x8c, 0x31, 0xe9, 0xd2, 0x51, 0x37, 0x2a, 0x22, 0x91, 0x14, 0xb7, 0x24,
+  0x71, 0x6d, 0x99, 0xd7, 0xec, 0xc1, 0x95, 0x9a, 0x43, 0x52, 0x52, 0x12,
+  0x97, 0xd7, 0x5d, 0x6c, 0xe5, 0x74, 0xd8, 0x61, 0x68, 0xc7, 0xde, 0x65,
+  0xdf, 0x6b, 0xf9, 0x1a, 0x8d, 0x32, 0xf4, 0x10, 0x21, 0x06, 0x78, 0x22,
+  0x31, 0x20, 0x74, 0x11, 0x30, 0x27, 0xe3, 0x78, 0x2e, 0x18, 0x2d, 0x05,
+  0x76, 0x22, 0x14, 0xb8, 0x59, 0x1c, 0x89, 0x75, 0x49, 0x05, 0x3b, 0xaf,
+  0xeb, 0x93, 0xb5, 0x4c, 0xde, 0xb6, 0xb2, 0xa7, 0x92, 0x10, 0xe4, 0x0a,
+  0x0a, 0xb8, 0x59, 0xb0, 0x50, 0xa8, 0x79, 0xe3, 0x96, 0x65, 0x55, 0x18,
+  0x9c, 0x82, 0x8b, 0xc1, 0x16, 0x8d, 0x58, 0x72, 0x12, 0x5a, 0xb7, 0xcd,
+  0x91, 0x60, 0x80, 0x58, 0xc7, 0x74, 0x15, 0x08, 0x04, 0x96, 0x00, 0x9f,
+  0xcd, 0x00, 0x21, 0x34, 0xd9, 0xe2, 0x18, 0x70, 0xd9, 0x05, 0x27, 0x22,
+  0xab, 0x33, 0x6f, 0x23, 0xc0, 0x47, 0xe4, 0xfa, 0x2c, 0xc7, 0xff, 0xe3,
+  0x68, 0x10, 0x2a, 0x3e, 0xbf, 0x96, 0xc3, 0x33, 0x8f, 0xef, 0x2c, 0x07,
+  0x57, 0x7c, 0xd5, 0x44, 0x6f, 0x13, 0x0b, 0x5e, 0x8c, 0x19, 0xc1, 0x56,
+  0x4b, 0x39, 0xb1, 0xb9, 0x6b, 0x42, 0x3c, 0xd0, 0xb0, 0x83, 0xac, 0x48,
+  0x53, 0xb6, 0x16, 0x6b, 0x86, 0x4b, 0xe0, 0x71, 0xa5, 0x92, 0xd0, 0x1a,
+  0xe1, 0xd2, 0x02, 0x66, 0x1c, 0xe7, 0x8b, 0x1b, 0x0f, 0xf4, 0xb7, 0xa4,
+  0x4e, 0x18, 0xd9, 0xb7, 0x1e, 0x63, 0x47, 0x43, 0x1c, 0x3c, 0x50, 0x98,
+  0xf9, 0x21, 0xd3, 0xd6, 0x63, 0x10, 0xfc, 0xcb, 0xec, 0xea, 0x6a, 0xda,
+  0xe2, 0x05, 0x6d, 0x83, 0xee, 0x3f, 0xf7, 0x51, 0x06, 0x68, 0x6d, 0x7d,
+  0xad, 0x3e, 0xcf, 0x76, 0x58, 0x88, 0x76, 0xa2, 0x71, 0x85, 0x80, 0xf9,
+  0x50, 0x49, 0x58, 0x42, 0x9b, 0xf0, 0xc5, 0xe3, 0x2d, 0xe3, 0xd9, 0x22,
+  0x6a, 0x09, 0x2e, 0x10, 0xac, 0x24, 0xcb, 0x02, 0x42, 0xd4, 0x9a, 0xc1,
+  0x86, 0x4a, 0x8f, 0xcd, 0xe6, 0x82, 0x80, 0x07, 0x39, 0x13, 0xf4, 0x1e,
+  0x2b, 0xe8, 0xae, 0x9f, 0x7f, 0xc9, 0x86, 0x2f, 0x50, 0xf1, 0x8e, 0x74,
+  0xda, 0x4a, 0x4d, 0xb0, 0x29, 0xb1, 0x42, 0x7c, 0x09, 0xb0, 0xe1, 0x18,
+  0xa3, 0xa2, 0x65, 0x37, 0x63, 0xa5, 0xa4, 0x94, 0x53, 0xe4, 0x93, 0x3c,
+  0x17, 0xd4, 0x57, 0x91, 0xba, 0x13, 0xf5, 0xa7, 0x56, 0xe1, 0x0c, 0xad,
+  0x22, 0x42, 0xbc, 0x86, 0x22, 0x7d, 0x12, 0xb8, 0x74, 0xcd, 0xb3, 0xf3,
+  0x52, 0x84, 0x04, 0x37, 0xa8, 0x62, 0x62, 0x15, 0xcb, 0xa2, 0xe5, 0x62,
+  0xd0, 0xc4, 0xce, 0x28, 0x3d, 0x8e, 0x8f, 0xbe, 0x4f, 0xdd, 0xef, 0x28,
+  0x6d, 0xf3, 0xa0, 0x98, 0xcf, 0x71, 0x3f, 0x18, 0x9c, 0x62, 0x16, 0x0a,
+  0x3c, 0x50, 0x3b, 0x5c, 0x24, 0x94, 0x3b, 0x37, 0x5f, 0x99, 0xae, 0x00,
+  0x00, 0x25, 0x29, 0xc2, 0x4c, 0x5f, 0x00, 0x83, 0x58, 0x32, 0x00, 0x7b,
+  0x1e, 0x04, 0x25, 0x7a, 0x76, 0x7f, 0xdf, 0xc4, 0xce, 0xf0, 0xa8, 0x0d,
+  0x02, 0xb9, 0x2b, 0x87, 0x97, 0x1e, 0xad, 0x7e, 0xf9, 0x50, 0x32, 0x3e,
+  0xd3, 0xd4, 0x28, 0x93, 0x70, 0x19, 0x59, 0xad, 0xb8, 0x65, 0x1d, 0x45,
+  0xb8, 0x40, 0xa1, 0xf5, 0xa8, 0x19, 0x62, 0xa8, 0xb4, 0xe1, 0xc0, 0x21,
+  0xd9, 0xb0, 0x37, 0xe5, 0x14, 0xcb, 0xf2, 0x9a, 0x58, 0x9b, 0x24, 0xdf,
+  0xcb, 0x02, 0x59, 0x83, 0x86, 0xd4, 0xd9, 0xb2, 0x4e, 0xe8, 0x45, 0x96,
+  0x3d, 0xe5, 0x2c, 0xf7, 0x32, 0x45, 0x61, 0xcf, 0x88, 0x33, 0xb0, 0xa9,
+  0x85, 0x5d, 0x5a, 0xfe, 0x74, 0xbe, 0x54, 0xc4, 0xa7, 0x3a, 0xc8, 0x72,
+  0xdb, 0xb2, 0x4f, 0x39, 0x53, 0x46, 0xea, 0x0f, 0xd4, 0x11, 0x6c, 0x75,
+  0x5c, 0x12, 0x9a, 0xac, 0x96, 0x1a, 0x23, 0xd9, 0x3e, 0xbf, 0xda, 0xac,
+  0x85, 0x17, 0x45, 0xa1, 0x23, 0x9c, 0x6b, 0xa3, 0xdf, 0xd3, 0x6a, 0x0b,
+  0x62, 0x44, 0xc4, 0x78, 0xbd, 0xa8, 0x9f, 0x4a, 0x6b, 0x70, 0x95, 0xe5,
+  0xb4, 0xa9, 0x33, 0x95, 0xda, 0xf9, 0xf6, 0xac, 0x4b, 0x93, 0xda, 0x95,
+  0xcb, 0x8a, 0x05, 0x84, 0x9e, 0xc3, 0x64, 0x28, 0xb3, 0x52, 0x39, 0x9a,
+  0x26, 0xbb, 0x39, 0xf5, 0xd6, 0xc6, 0xfd, 0x50, 0xa0, 0xc3, 0xde, 0xe0,
+  0xc9, 0xd6, 0xcf, 0x71, 0x0d, 0x78, 0xd0, 0xbe, 0xf5, 0xb5, 0x03, 0x1a,
+  0x8b, 0x8b, 0x2a, 0xb5, 0x95, 0xe2, 0x01, 0xb5, 0x73, 0x2f, 0x8b, 0xf8,
+  0x40, 0xb2, 0xaf, 0x99, 0x13, 0x8b, 0x69, 0x92, 0x2c, 0x64, 0x6c, 0x0a,
+  0x45, 0xa1, 0x47, 0xd5, 0xed, 0x1d, 0xb3, 0x74, 0x25, 0x52, 0x15, 0x17,
+  0xd6, 0x71, 0x00, 0xb5, 0x4e, 0x40, 0x65, 0xb7, 0x12, 0xa9, 0xed, 0x9c,
+  0x66, 0x53, 0x04, 0x2f, 0xd6, 0x46, 0xd6, 0x1e, 0x59, 0xb7, 0xa5, 0x3c,
+  0x1c, 0xb7, 0xad, 0x6e, 0x60, 0xba, 0x19, 0xb5, 0xc2, 0x0f, 0x4d, 0x5c,
+  0x34, 0x91, 0x36, 0xf8, 0xaa, 0x4d, 0x04, 0x0a, 0x8a, 0x0b, 0x40, 0xc8,
+  0x8c, 0xb8, 0x64, 0xa4, 0xe6, 0x72, 0x0d, 0x1c, 0xef, 0x11, 0xb8, 0x3f,
+  0x5e, 0xc2, 0x86, 0xb9, 0xe8, 0xef, 0x49, 0x9e, 0x05, 0xb7, 0x0f, 0xaf,
+  0xa2, 0x09, 0xbf, 0x0e, 0x9b, 0xd6, 0x51, 0x23, 0xc6, 0x3e, 0xf0, 0x24,
+  0xd2, 0x04, 0x11, 0xfb, 0xdf, 0x86, 0x62, 0x3e, 0x98, 0x21, 0x7e, 0xa1,
+  0x07, 0x57, 0xe2, 0xd4, 0xf4, 0xba, 0xe0, 0x3a, 0x97, 0xc6, 0xd4, 0x15,
+  0xb2, 0x91, 0xd1, 0x6d, 0x3d, 0x4d, 0xe8, 0xb5, 0x5c, 0x3f, 0x34, 0xe7,
+  0xca, 0x9b, 0x8c, 0x87, 0x70, 0xe6, 0x41, 0x8c, 0x5b, 0x10, 0xd8, 0xeb,
+  0x9b, 0x88, 0xf2, 0xd5, 0xa1, 0x6d, 0xe1, 0x63, 0x4e, 0xb3, 0x53, 0x43,
+  0x2c, 0xf7, 0x5f, 0x37, 0xbf, 0x4b, 0x9a, 0xae, 0xf0, 0xab, 0x49, 0x4b,
+  0x1e, 0xfd, 0xdb, 0xac, 0x4c, 0xc7, 0xbe, 0x0a, 0xaa, 0x6b, 0x47, 0xdf,
+  0x6c, 0xf0, 0x79, 0x69, 0x47, 0x23, 0x27, 0xd1, 0x44, 0xaf, 0x02, 0x96,
+  0x62, 0xc3, 0x66, 0xbf, 0x25, 0x5b, 0xcc, 0xd8, 0x03, 0xa3, 0x97, 0x64,
+  0x4b, 0xb0, 0x00, 0xb3, 0x75, 0x58, 0xc5, 0xd8, 0xa6, 0x88, 0xe9, 0xb4,
+  0xe4, 0xfc, 0xf3, 0x06, 0x50, 0x1b, 0x69, 0x36, 0x61, 0x6b, 0xa4, 0x30,
+  0xa5, 0x66, 0xdc, 0x17, 0xb5, 0x37, 0x4d, 0x5c, 0x2c, 0x52, 0xb7, 0x08,
+  0x31, 0x11, 0x53, 0x18, 0x78, 0xc4, 0x62, 0x5e, 0x49, 0xfd, 0x1f, 0x08,
+  0x2e, 0xd5, 0xfa, 0x32, 0x55, 0xc4, 0x04, 0x99, 0xb8, 0x4b, 0x51, 0x22,
+  0x2c, 0x23, 0xde, 0x31, 0xeb, 0xc7, 0xb0, 0xb9, 0x9a, 0x48, 0xb3, 0x8e,
+  0x62, 0x75, 0x59, 0x63, 0x86, 0x2e, 0xfa, 0x25, 0x44, 0x5b, 0x00, 0x0f,
+  0x0f, 0x78, 0xe3, 0xf5, 0x8d, 0x1b, 0xf2, 0x87, 0xa8, 0x3d, 0x46, 0x13,
+  0x3e, 0x64, 0x88, 0x1f, 0x20, 0x14, 0x09, 0x8e, 0x26, 0xfc, 0x24, 0x6a,
+  0xbb, 0xcf, 0x9d, 0x14, 0x20, 0xe9, 0x42, 0x03, 0xcd, 0x9d, 0xaf, 0xa3,
+  0x30, 0x33, 0x34, 0xe0, 0xb2, 0x4c, 0x7e, 0xeb, 0x18, 0x8c, 0x22, 0x18,
+  0xb7, 0x9f, 0xe6, 0x10, 0xd3, 0xa4, 0xe1, 0xf7, 0x79, 0xb0, 0xad, 0x02,
+  0x85, 0x4f, 0xa8, 0xef, 0x0b, 0x34, 0x63, 0x80, 0x00, 0x80, 0x89, 0x57,
+  0xa6, 0x09, 0xca, 0xa7, 0x67, 0xc0, 0xa1, 0x8b, 0xc1, 0xaf, 0x18, 0x9a,
+  0x86, 0x9e, 0xea, 0xe6, 0x34, 0xf4, 0x1b, 0xb2, 0x19, 0x94, 0xfa, 0x29,
+  0x9e, 0x46, 0x2f, 0x39, 0x86, 0xfa, 0x05, 0x54, 0xbf, 0x9f, 0x3e, 0x6b,
+  0x94, 0x54, 0x4e, 0x0c, 0x4e, 0x50, 0x3d, 0x9d, 0xc3, 0xd3, 0x83, 0xaf,
+  0x87, 0x4f, 0x2d, 0xf0, 0xc3, 0x4a, 0x10, 0x78, 0xc4, 0x33, 0xcb, 0x02,
+  0x5d, 0x5b, 0x78, 0x81, 0x8f, 0x9d, 0xaf, 0xd2, 0x12, 0x19, 0x60, 0xda,
+  0xee, 0xce, 0xa7, 0x3b, 0x0f, 0x41, 0x8c, 0xb5, 0x58, 0x41, 0x81, 0xee,
+  0x98, 0xa7, 0x93, 0x44, 0x2b, 0xcc, 0xe7, 0x09, 0x02, 0x42, 0x5d, 0xf6,
+  0x55, 0xe4, 0xa3, 0x34, 0x7a, 0x12, 0xc3, 0x0b, 0x7c, 0xbb, 0xba, 0x94,
+  0x4e, 0x6c, 0x92, 0xa8, 0x49, 0x72, 0x29, 0x93, 0xfb, 0xf1, 0x94, 0x64,
+  0x9f, 0xdb, 0xdf, 0xb4, 0xd6, 0x8e, 0xac, 0x7a, 0xfc, 0x8b, 0x96, 0x3d,
+  0x7e, 0xdc, 0xba, 0xb7, 0x1a, 0x11, 0x7f, 0xc6, 0xba, 0xb7, 0xd5, 0x59,
+  0xaa, 0xa2, 0x13, 0xfa, 0x95, 0x6f, 0x5d, 0xfa, 0x70, 0xe5, 0xe5, 0x8a,
+  0xf8, 0xdf, 0x64, 0xdd, 0x9f, 0x71, 0xc9, 0x5c, 0xb6, 0x6f, 0x7f, 0x68,
+  0xfd, 0x95, 0x61, 0xf8, 0x02, 0xf3, 0xbc, 0x05, 0xcf, 0x34, 0x0c, 0x64,
+  0x93, 0x2d, 0x8c, 0x49, 0x18, 0xdc, 0x02, 0x14, 0xbf, 0xe9, 0x6d, 0x9b,
+  0xec, 0xed, 0x3c, 0xd1, 0x5b, 0x1f, 0x3c, 0x31, 0x6e, 0xa7, 0xc4, 0x73,
+  0x2c, 0x7b, 0x55, 0x5f, 0xbb, 0xff, 0x27, 0x76, 0xae, 0x26, 0xd1, 0x57,
+  0x67, 0x81, 0xac, 0x25, 0x37, 0x76, 0x4e, 0xb3, 0xcd, 0xe9, 0xfe, 0x9e,
+  0xae, 0x6a, 0xf9, 0x5b, 0xea, 0xc0, 0x6d, 0xa6, 0x98, 0x2a, 0x39, 0x54,
+  0x8a, 0x27, 0xe8, 0x6e, 0x38, 0xd4, 0xde, 0xad, 0x06, 0xf1, 0xfc, 0x92,
+  0x33, 0x6b, 0x04, 0x83, 0xc0, 0x01, 0xe0, 0x15, 0x38, 0x32, 0x09, 0x6b,
+  0x1b, 0xb7, 0x44, 0x29, 0xb0, 0x01, 0x03, 0xe9, 0xe5, 0x2a, 0x79, 0x3e,
+  0x82, 0x64, 0x2a, 0x87, 0xbb, 0x25, 0x7b, 0x4b, 0x08, 0xe6, 0xff, 0x12,
+  0x86, 0xda, 0x46, 0x1e, 0x16, 0x84, 0xf7, 0x68, 0xe2, 0x50, 0x69, 0xe8,
+  0x5f, 0x27, 0x8f, 0x72, 0x42, 0x0b, 0xd7, 0xee, 0x63, 0x3b, 0x37, 0xdc,
+  0x35, 0x36, 0x06, 0x70, 0xd1, 0x17, 0xb6, 0xde, 0xe8, 0x3b, 0xea, 0xb4,
+  0xf7, 0x54, 0xa3, 0xa8, 0x40, 0x9a, 0x53, 0xb8, 0x1e, 0xde, 0x8b, 0x99,
+  0x98, 0x24, 0x70, 0x32, 0x46, 0x4e, 0xb7, 0xdf, 0x35, 0x2a, 0x30, 0xdb,
+  0xa3, 0xab, 0xaa, 0xc4, 0xde, 0x36, 0x49, 0x64, 0x7b, 0x90, 0x39, 0x28,
+  0x82, 0xd6, 0x22, 0x23, 0xe5, 0x4c, 0x54, 0x4b, 0xad, 0x79, 0xef, 0x8a,
+  0x0f, 0x5f, 0x27, 0x98, 0x04, 0x84, 0x9b, 0x09, 0x57, 0xfe, 0x5b, 0x03,
+  0x92, 0xc8, 0x4e, 0xd4, 0x78, 0x11, 0x8f, 0xd2, 0x69, 0x5a, 0xfe, 0x8c,
+  0xb0, 0xee, 0x5f, 0xc2, 0xd8, 0xcb, 0xf1, 0xa2, 0x3f, 0xcf, 0xda, 0x8c,
+  0x14, 0x17, 0x40, 0x28, 0x0b, 0xd2, 0xce, 0xdf, 0xbf, 0x3d, 0x3d, 0x3c,
+  0x3a, 0xd9, 0xff, 0xde, 0x9c, 0x84, 0x2e, 0xae, 0x83, 0xa1, 0xd9, 0x93,
+  0xb8, 0x58, 0xbd, 0x27, 0xf5, 0x89, 0xbe, 0xdc, 0x7c, 0xb2, 0x05, 0x7b,
+  0x7e, 0xfd, 0x0c, 0x41, 0x5e, 0x0b, 0xf1, 0x8c, 0xd4, 0x62, 0xe4, 0xe7,
+  0x51, 0xe3, 0xc6, 0xbb, 0x8f, 0xcf, 0x37, 0xa8, 0x4d, 0x5c, 0x95, 0xfc,
+  0xb0, 0x58, 0xe1, 0xcf, 0xb1, 0xdc, 0x96, 0x74, 0x4e, 0xcb, 0x64, 0x3a,
+  0x4f, 0x4a, 0xc5, 0xb5, 0x89, 0x5e, 0x9e, 0x9e, 0x5d, 0xbc, 0xba, 0x8d,
+  0x1b, 0xe5, 0xea, 0x38, 0xf9, 0x48, 0x6b, 0x3d, 0x1a, 0x2d, 0xca, 0x9b,
+  0x2e, 0x4e, 0x15, 0x89, 0xad, 0x16, 0x54, 0x60, 0x4f, 0xd2, 0x29, 0x6f,
+  0x84, 0x98, 0x5d, 0x5c, 0x7c, 0x7f, 0x76, 0xf4, 0xea, 0x25, 0xbc, 0x2e,
+  0x9f, 0x41, 0xb1, 0x51, 0xd5, 0x50, 0x9c, 0x30, 0x53, 0xa9, 0x16, 0x58,
+  0x7f, 0xe7, 0xbb, 0xc3, 0xe3, 0xe1, 0xd9, 0xc9, 0xe9, 0xc1, 0xab, 0x97,
+  0xdf, 0x59, 0x2d, 0xe3, 0xe0, 0x5d, 0xf7, 0x99, 0x03, 0xd9, 0x6b, 0xa2,
+  0xcb, 0x1d, 0x7d, 0xfb, 0xfe, 0xe8, 0xed, 0x37, 0xaf, 0x5e, 0xde, 0xc6,
+  0x79, 0x0f, 0xf3, 0x93, 0xb7, 0xb9, 0x14, 0x76, 0x13, 0xc1, 0x29, 0x58,
+  0xa2, 0x0b, 0x60, 0x80, 0x2c, 0xe0, 0xff, 0x78, 0xc0, 0x3f, 0x2e, 0xa7,
+  0xc3, 0x27, 0xe4, 0xd7, 0x65, 0x82, 0xc0, 0xca, 0x5c, 0x0d, 0xbe, 0x79,
+  0x77, 0x7e, 0xd2, 0x7e, 0x76, 0x5d, 0x25, 0x13, 0x9f, 0x4b, 0x67, 0x55,
+  0x49, 0x5c, 0xab, 0x9c, 0xb7, 0xe6, 0x71, 0xb1, 0x84, 0xe3, 0x3c, 0x6c,
+  0xe3, 0x96, 0x90, 0x52, 0xf6, 0x04, 0x3a, 0x7c, 0x38, 0x8e, 0xa5, 0x10,
+  0x70, 0x0c, 0x9a, 0x81, 0x14, 0xa2, 0xd9, 0xb6, 0xd3, 0x80, 0x53, 0xd5,
+  0xac, 0x20, 0xa3, 0xb0, 0x63, 0x52, 0x41, 0x0e, 0x0c, 0x1c, 0x51, 0xa9,
+  0x3c, 0x37, 0x1e, 0x8e, 0x45, 0xf3, 0x56, 0x27, 0x21, 0x89, 0x7a, 0x0d,
+  0x65, 0xc8, 0xe3, 0x88, 0x21, 0x01, 0xef, 0xc6, 0x8d, 0x2b, 0x97, 0x13,
+  0xed, 0x7b, 0x33, 0x46, 0x56, 0xb3, 0xf9, 0xd7, 0x63, 0x80, 0x35, 0x26,
+  0x41, 0x2b, 0x08, 0x58, 0x20, 0xc2, 0x0c, 0xf7, 0x27, 0xc2, 0x9c, 0x11,
+  0x24, 0xe2, 0x7c, 0x9e, 0xb2, 0xb1, 0x41, 0xb8, 0x49, 0x6b, 0xfd, 0xdc,
+  0x81, 0x3f, 0x8d, 0x76, 0x0c, 0xb9, 0xdc, 0x36, 0xd2, 0x4c, 0x37, 0x8b,
+  0x2d, 0xf5, 0xe1, 0x09, 0x17, 0x3a, 0x7b, 0x77, 0x11, 0x84, 0xe2, 0x34,
+  0x0b, 0x41, 0xaf, 0xa9, 0x78, 0x68, 0x42, 0x81, 0x5f, 0xa8, 0x4e, 0xbf,
+  0x43, 0xc2, 0xa3, 0x19, 0x0c, 0x10, 0x83, 0xb4, 0x65, 0x91, 0x92, 0x5c,
+  0x61, 0x2b, 0x8c, 0xec, 0x6e, 0x98, 0x19, 0x7c, 0x75, 0xeb, 0xd6, 0x54,
+  0x46, 0xc4, 0x11, 0x58, 0x88, 0x0f, 0x38, 0x66, 0xff, 0x42, 0xc2, 0xf1,
+  0xc1, 0x4b, 0xb4, 0xfc, 0x55, 0x3d, 0x3e, 0x6e, 0x10, 0x1d, 0xe1, 0xdb,
+  0xfe, 0x45, 0x03, 0x58, 0x14, 0x2f, 0x2c, 0xe2, 0x34, 0x0f, 0xbc, 0xd3,
+  0x77, 0x5a, 0xe7, 0x4b, 0x97, 0x57, 0x63, 0xce, 0xb8, 0xc0, 0xca, 0x40,
+  0xcb, 0x0d, 0xc2, 0x74, 0xb7, 0x26, 0x79, 0xbc, 0x88, 0x3a, 0x57, 0xd3,
+  0x6c, 0x34, 0xa2, 0x99, 0x77, 0xcc, 0xee, 0x4c, 0x23, 0xb4, 0x80, 0x9a,
+  0x9e, 0x65, 0xb5, 0x79, 0x0a, 0xe6, 0x3c, 0x69, 0xee, 0xab, 0x9e, 0xf3,
+  0x6d, 0xe6, 0x0b, 0x05, 0x81, 0x44, 0x8a, 0xab, 0xae, 0x28, 0x27, 0x31,
+  0x87, 0xb0, 0xbc, 0xe2, 0xf6, 0xe1, 0xcf, 0x23, 0xeb, 0xbf, 0xae, 0xea,
+  0x97, 0x2b, 0xa8, 0xcc, 0x8e, 0xcb, 0xe9, 0x89, 0xe4, 0x73, 0xa8, 0x89,
+  0xb2, 0x2d, 0x85, 0xbf, 0xa4, 0xe4, 0xfd, 0x45, 0xd4, 0xf9, 0x07, 0x46,
+  0xb1, 0xdb, 0xc3, 0xbf, 0x7b, 0xff, 0xec, 0x84, 0x25, 0xef, 0x65, 0xf0,
+  0x25, 0x52, 0x50, 0x0b, 0x4b, 0x8d, 0x6e, 0xc9, 0x84, 0x06, 0xfc, 0xe2,
+  0xda, 0xd6, 0xd3, 0xd9, 0xd5, 0x0f, 0xbb, 0xfd, 0xdd, 0x9d, 0x9d, 0x9d,
+  0x9f, 0x06, 0x0b, 0x2c, 0xdd, 0x25, 0x37, 0x8f, 0x18, 0xe9, 0x45, 0x3a,
+  0x86, 0x13, 0x99, 0x36, 0x33, 0x8d, 0xb9, 0xb8, 0x8d, 0xf4, 0xb7, 0x1d,
+  0x5e, 0x8e, 0x39, 0x42, 0xe5, 0x5a, 0x99, 0x9b, 0x43, 0xa5, 0x00, 0x30,
+  0xd2, 0x92, 0x6b, 0x13, 0xf0, 0xc3, 0xd1, 0x64, 0x39, 0x5b, 0x30, 0xdc,
+  0x28, 0x3b, 0x44, 0xd5, 0x73, 0x81, 0xcd, 0xa6, 0xdb, 0x4e, 0x90, 0x1c,
+  0x11, 0xcc, 0xd3, 0x6b, 0x05, 0x88, 0xe7, 0x6f, 0x93, 0x02, 0x75, 0x0c,
+  0xb8, 0x44, 0x71, 0x80, 0xa3, 0xd5, 0x33, 0x1e, 0x29, 0x54, 0xac, 0xe9,
+  0xc9, 0x4c, 0xcc, 0x2d, 0xd5, 0x38, 0x71, 0x4e, 0x48, 0x1a, 0x09, 0x4b,
+  0xd8, 0x39, 0xa8, 0x1e, 0x43, 0xf6, 0x49, 0x24, 0xca, 0xd8, 0x24, 0x9b,
+  0x87, 0x44, 0x1b, 0x2f, 0xd9, 0x86, 0x52, 0x2d, 0x03, 0xfe, 0xf7, 0x6f,
+  0x05, 0xce, 0x60, 0x84, 0x72, 0x2f, 0x59, 0x6e, 0x8b, 0x56, 0x27, 0xe1,
+  0xb8, 0x18, 0xa7, 0xe9, 0x6f, 0x2a, 0xc7, 0x70, 0xaf, 0xdc, 0xcd, 0xff,
+  0xc3, 0x1b, 0x06, 0x68, 0x5a, 0x85, 0x44, 0xf4, 0x90, 0x7b, 0x3c, 0x4f,
+  0x81, 0xdc, 0x9b, 0x26, 0xd4, 0x68, 0x11, 0x99, 0x54, 0x7e, 0x9d, 0xdc,
+  0xcb, 0x2d, 0xda, 0x4c, 0x42, 0x11, 0x34, 0xf3, 0x6b, 0x24, 0x59, 0x70,
+  0x09, 0xb3, 0xe1, 0xc1, 0xf1, 0x71, 0x25, 0x7b, 0x1d, 0xcb, 0x26, 0x95,
+  0x47, 0x24, 0xb7, 0xa0, 0x98, 0xa1, 0x70, 0x7b, 0x6e, 0x99, 0xf3, 0x8d,
+  0xcb, 0x1b, 0x41, 0x1e, 0x9c, 0x90, 0x8a, 0x00, 0xd5, 0xb8, 0x48, 0x2d,
+  0xaa, 0x26, 0x16, 0x98, 0xcd, 0xe5, 0x1c, 0xd7, 0x2c, 0x57, 0xf3, 0x5a,
+  0xd2, 0x91, 0x2c, 0x7e, 0x6d, 0x82, 0x1c, 0xfc, 0xd6, 0xa4, 0xd7, 0xe2,
+  0xe4, 0x3f, 0xcb, 0x35, 0x60, 0x83, 0xbd, 0x46, 0xec, 0x80, 0x13, 0x27,
+  0x3d, 0xe0, 0x4b, 0x70, 0x71, 0x08, 0x05, 0xd2, 0x20, 0x6d, 0xbc, 0x5c,
+  0xd2, 0xc9, 0x15, 0x71, 0x69, 0x88, 0x18, 0x2c, 0xce, 0xc1, 0xb6, 0x5b,
+  0x11, 0x94, 0x9f, 0x3e, 0x1e, 0xb4, 0xe7, 0x03, 0xf1, 0x0d, 0x5a, 0x64,
+  0x25, 0x6b, 0x00, 0xd6, 0xe2, 0x6e, 0x60, 0xb7, 0x6d, 0x4d, 0x54, 0x36,
+  0x2c, 0xb8, 0xe8, 0x25, 0xfe, 0x7d, 0x61, 0x58, 0x6c, 0x6b, 0x41, 0x9a,
+  0x15, 0x0b, 0xb5, 0x8a, 0xdb, 0x66, 0x11, 0xf1, 0x0c, 0x53, 0x20, 0xf1,
+  0x56, 0xf5, 0xbc, 0xd2, 0x6a, 0x73, 0xa7, 0x6e, 0xf7, 0x3d, 0x70, 0x2c,
+  0x37, 0x5a, 0x87, 0xa3, 0x6c, 0x63, 0x38, 0xb8, 0x1a, 0x39, 0xa8, 0x18,
+  0xe7, 0xd2, 0x43, 0xca, 0xf1, 0xa9, 0xdb, 0x34, 0x95, 0x95, 0x0b, 0x47,
+  0x8b, 0xd2, 0x26, 0x05, 0x6a, 0xb7, 0xa2, 0xb6, 0x1d, 0xe1, 0xf5, 0x22,
+  0x29, 0x0f, 0x61, 0x1a, 0xec, 0xb0, 0xf6, 0x90, 0xb2, 0x6b, 0xf1, 0x6b,
+  0x58, 0xa6, 0x04, 0xea, 0xd3, 0xd9, 0x71, 0x5f, 0xe3, 0x97, 0x14, 0xe6,
+  0x47, 0x4a, 0x90, 0x61, 0x1e, 0x93, 0xac, 0x9e, 0x5f, 0xd8, 0x06, 0xa1,
+  0xe3, 0xe1, 0x50, 0xb8, 0xdc, 0x4b, 0x35, 0xc5, 0x7c, 0xb9, 0xa8, 0xcd,
+  0xad, 0xba, 0xea, 0x6d, 0x71, 0x97, 0x9a, 0x3c, 0x15, 0x8a, 0xfe, 0xae,
+  0x34, 0xa8, 0x49, 0x46, 0xaa, 0xc8, 0x8a, 0xb4, 0xc0, 0x2b, 0xd3, 0x96,
+  0x82, 0x14, 0x90, 0xde, 0x0b, 0x62, 0x6d, 0xcb, 0xe8, 0x45, 0xe7, 0x37,
+  0xe4, 0xfd, 0xef, 0xcc, 0xae, 0xf2, 0x73, 0x48, 0x91, 0x1f, 0xad, 0x60,
+  0xb4, 0x06, 0x60, 0x19, 0x6d, 0x30, 0x42, 0xff, 0xff, 0x8e, 0x06, 0x3b,
+  0xfa, 0xee, 0xb7, 0xdd, 0x51, 0x2e, 0x53, 0xfb, 0x92, 0x24, 0xc8, 0xb5,
+  0x8c, 0x24, 0x56, 0x99, 0xd4, 0xe1, 0x05, 0x35, 0x51, 0x1e, 0x48, 0xb7,
+  0xa1, 0x59, 0x5e, 0xd3, 0x22, 0xad, 0x9c, 0x35, 0x66, 0xa3, 0x3d, 0xd3,
+  0xca, 0xc4, 0x7e, 0x6a, 0x12, 0xaa, 0x0b, 0x07, 0x0c, 0x07, 0x89, 0x27,
+  0x0f, 0x5a, 0xfd, 0x14, 0x42, 0x55, 0x2c, 0xa5, 0x95, 0xcc, 0x00, 0x89,
+  0x28, 0x97, 0xfc, 0x08, 0x4b, 0x4d, 0x12, 0x79, 0xbf, 0x6d, 0x71, 0xb9,
+  0xd2, 0x6f, 0x61, 0x56, 0xa7, 0x9e, 0x73, 0xc2, 0x87, 0x28, 0x4c, 0x9a,
+  0xe7, 0xf4, 0x01, 0x04, 0x1b, 0x35, 0x33, 0x04, 0xeb, 0x19, 0x5c, 0x89,
+  0xad, 0x00, 0xdb, 0xac, 0x64, 0x61, 0x15, 0x41, 0x0c, 0x02, 0xe1, 0xaa,
+  0x8f, 0x6f, 0x97, 0xf1, 0xf4, 0x26, 0x86, 0x6c, 0x03, 0x8f, 0xa2, 0x2c,
+  0x29, 0xb0, 0x79, 0x39, 0x6e, 0xa5, 0x2d, 0x89, 0x67, 0xb4, 0xbc, 0xba,
+  0x12, 0x98, 0xbe, 0x13, 0x4e, 0x23, 0x10, 0xf8, 0x7b, 0x4b, 0x55, 0x8c,
+  0xba, 0x9f, 0x75, 0x35, 0x52, 0xa9, 0x23, 0x25, 0x59, 0x58, 0xb8, 0xea,
+  0x88, 0x70, 0x33, 0x5a, 0xb5, 0x88, 0xf1, 0xbd, 0xa8, 0xfb, 0xb2, 0xfd,
+  0x1d, 0x54, 0x01, 0x4b, 0x6f, 0x15, 0x59, 0xcd, 0x69, 0xd8, 0xb4, 0x86,
+  0xd7, 0x29, 0xdd, 0x8e, 0xf3, 0x66, 0x70, 0x82, 0xd5, 0x9f, 0x92, 0xaa,
+  0x84, 0x91, 0x69, 0x71, 0x45, 0x7d, 0x8c, 0x7f, 0xb4, 0xfe, 0xe2, 0xc9,
+  0x24, 0x55, 0xc8, 0x61, 0x48, 0x76, 0xcd, 0x94, 0x56, 0x24, 0x9d, 0xba,
+  0xfe, 0xdb, 0xcb, 0x3b, 0xcb, 0xa8, 0xe0, 0xa9, 0x14, 0x6e, 0x21, 0xf1,
+  0x1b, 0x4c, 0x79, 0x12, 0x6a, 0xe5, 0x6a, 0xd3, 0xf8, 0x82, 0xd5, 0xb2,
+  0xdd, 0x75, 0x91, 0xb3, 0x52, 0xec, 0xc6, 0xc9, 0x52, 0x4a, 0x86, 0x6a,
+  0x6a, 0x04, 0xb0, 0xb4, 0xa2, 0x52, 0xad, 0x65, 0x58, 0x66, 0x51, 0xf0,
+  0x34, 0x5c, 0x94, 0x52, 0xec, 0x44, 0x0a, 0x6f, 0xf1, 0xc5, 0x88, 0x07,
+  0x15, 0x79, 0x55, 0x0d, 0x76, 0xcd, 0xc2, 0xed, 0x73, 0x4e, 0x59, 0x70,
+  0xa9, 0x69, 0x4e, 0x9a, 0xa9, 0x4a, 0xe3, 0x66, 0x8d, 0x7d, 0x9c, 0xe9,
+  0xbc, 0x29, 0xcf, 0x55, 0x1a, 0x7b, 0x50, 0xa0, 0xfb, 0x39, 0x0e, 0x5f,
+  0x09, 0x2d, 0x16, 0x70, 0x23, 0xc0, 0xa2, 0x04, 0xa7, 0x25, 0x00, 0x68,
+  0x6b, 0x42, 0x75, 0xb2, 0x04, 0x56, 0x01, 0x38, 0x16, 0x3b, 0xa6, 0x28,
+  0xf0, 0x8a, 0x60, 0x6e, 0x31, 0x9c, 0x86, 0x8b, 0xa3, 0xe5, 0xf3, 0x06,
+  0x6d, 0xb8, 0x4d, 0x1a, 0x60, 0xc2, 0x92, 0x9f, 0xd5, 0x09, 0xd3, 0x13,
+  0x09, 0x2d, 0xc5, 0x9a, 0x40, 0x10, 0x2d, 0x9f, 0x06, 0x6b, 0xbb, 0x45,
+  0x64, 0x97, 0x22, 0x31, 0xf9, 0x84, 0xe5, 0xf4, 0x95, 0x82, 0xd4, 0xa5,
+  0x0c, 0x0b, 0x36, 0xbf, 0x31, 0xb7, 0x7a, 0xb5, 0x6c, 0x6f, 0x6b, 0x8d,
+  0x42, 0x5d, 0x27, 0x1e, 0xd2, 0x26, 0x9f, 0x0d, 0x85, 0x19, 0xe9, 0x9c,
+  0x59, 0xf6, 0xfd, 0x8b, 0xce, 0x96, 0x6a, 0x07, 0xac, 0x37, 0xf9, 0xb4,
+  0xfc, 0x36, 0xb9, 0xdf, 0x86, 0xec, 0x0a, 0x56, 0x65, 0x66, 0x2e, 0x68,
+  0xed, 0x9e, 0x76, 0x25, 0x6f, 0xed, 0xfd, 0xb5, 0x84, 0x7d, 0x07, 0x9d,
+  0xab, 0x75, 0x65, 0x6c, 0x11, 0xe1, 0xf5, 0xee, 0x5b, 0x7a, 0xce, 0x2e,
+  0xb9, 0x64, 0xe2, 0xbe, 0x8b, 0x81, 0xb5, 0x57, 0x6d, 0xf1, 0x5f, 0x34,
+  0xf3, 0x6c, 0x6f, 0x3f, 0x0e, 0x6c, 0x44, 0x60, 0xcc, 0xfc, 0x91, 0x2e,
+  0x67, 0xda, 0xd4, 0x55, 0x6e, 0xf2, 0xd1, 0x53, 0xfa, 0xf1, 0x35, 0x7e,
+  0x58, 0x0d, 0x01, 0x64, 0x9d, 0x9b, 0x8d, 0xa4, 0x09, 0x7e, 0x06, 0xd8,
+  0x40, 0xe1, 0x07, 0x43, 0xa6, 0xa2, 0xd7, 0xfc, 0x4b, 0x9e, 0x3c, 0xf0,
+  0x0e, 0xcd, 0xed, 0xef, 0xf4, 0x63, 0x7f, 0x59, 0x66, 0xa0, 0xc4, 0x31,
+  0x07, 0x5c, 0xcf, 0x16, 0xb9, 0x82, 0x6a, 0x4a, 0x6a, 0x1a, 0xff, 0xa9,
+  0x7e, 0x91, 0x42, 0x0a, 0x3a, 0x0a, 0xd3, 0x49, 0xd7, 0x24, 0x0d, 0xaf,
+  0xef, 0x4f, 0xe0, 0x37, 0x5b, 0x81, 0x2f, 0x1e, 0x9c, 0xdb, 0x43, 0x80,
+  0xe9, 0x0d, 0xb4, 0x90, 0x5a, 0xc3, 0x58, 0x0a, 0x5a, 0xcc, 0x67, 0x8f,
+  0x5b, 0xc5, 0x43, 0xdc, 0x3e, 0xa6, 0x29, 0x8e, 0x2d, 0xd7, 0xbd, 0xf0,
+  0x35, 0x7a, 0x43, 0x58, 0x6e, 0x7e, 0x58, 0xa5, 0x06, 0xc5, 0xc8, 0x6d,
+  0x1f, 0x1c, 0xdf, 0x87, 0x1c, 0xfe, 0xc1, 0x8c, 0xe7, 0xc6, 0xcc, 0x03,
+  0x33, 0xba, 0x80, 0xf3, 0x95, 0xbf, 0xf2, 0x22, 0xba, 0x40, 0xe9, 0xda,
+  0x63, 0x18, 0x74, 0x2e, 0x08, 0xdc, 0xde, 0xdc, 0x84, 0xc4, 0xa1, 0x29,
+  0x6c, 0xab, 0x05, 0x5f, 0x05, 0x8d, 0x0a, 0xbd, 0xfb, 0xc5, 0x6a, 0x3e,
+  0xbe, 0x3e, 0x7c, 0x3b, 0x6c, 0x7f, 0x5d, 0xea, 0xa7, 0x68, 0x94, 0x1e,
+  0x5c, 0x96, 0x78, 0x9a, 0x84, 0x3b, 0xb0, 0x4c, 0x96, 0x0a, 0xd5, 0x43,
+  0xda, 0x02, 0xb0, 0x77, 0xf6, 0xf6, 0xe8, 0xcb, 0x53, 0xfb, 0xb1, 0x76,
+  0xc9, 0x1f, 0x5c, 0xe1, 0x13, 0xd4, 0x76, 0x69, 0xb1, 0x2f, 0x37, 0x06,
+  0xe7, 0x40, 0x2c, 0xbd, 0xf9, 0x1f, 0x55, 0x02, 0xf1, 0xba, 0xd0, 0x62,
+  0x4f, 0x49, 0x52, 0xaa, 0xc5, 0xb4, 0x37, 0xc7, 0xe1, 0x64, 0x7b, 0x5f,
+  0x7e, 0xd1, 0xbc, 0xc9, 0x0e, 0xdf, 0xae, 0xe9, 0x0e, 0xdf, 0xf4, 0x2d,
+  0x11, 0x41, 0xaf, 0x6e, 0x49, 0x4f, 0xe7, 0xd5, 0x69, 0x59, 0x15, 0x92,
+  0xda, 0xed, 0x47, 0x65, 0xea, 0xa6, 0x2b, 0xe2, 0xb8, 0x0b, 0xcd, 0x23,
+  0xaf, 0x92, 0x2b, 0x21, 0x46, 0xa3, 0x69, 0x4c, 0x37, 0x68, 0xd4, 0x82,
+  0x82, 0x1e, 0xd8, 0xdb, 0xab, 0x40, 0xdb, 0xc1, 0x2a, 0x2b, 0x26, 0x8e,
+  0x21, 0x7e, 0xfa, 0x4a, 0xf3, 0x4d, 0x96, 0xee, 0x7c, 0x67, 0x75, 0xad,
+  0xb2, 0x7f, 0x47, 0x97, 0x14, 0xbb, 0x43, 0x21, 0x1b, 0x46, 0x2f, 0xe5,
+  0x3a, 0xfa, 0xac, 0x71, 0x20, 0x24, 0x97, 0xd3, 0x4c, 0xcf, 0xe6, 0x10,
+  0xe2, 0x2b, 0x1f, 0x56, 0x24, 0x97, 0x06, 0xcc, 0xc5, 0x42, 0x92, 0x32,
+  0x11, 0xbb, 0xb4, 0x26, 0x05, 0x37, 0x02, 0x90, 0x96, 0xd3, 0x20, 0x0b,
+  0xd5, 0xa0, 0x77, 0xa5, 0xeb, 0x48, 0x2b, 0x34, 0x0a, 0x28, 0xa6, 0x61,
+  0x16, 0x5b, 0xfe, 0xa3, 0x78, 0x59, 0xeb, 0x77, 0x03, 0x2a, 0x51, 0xcd,
+  0xd2, 0x7b, 0x57, 0x6d, 0xb0, 0x22, 0x3d, 0x3b, 0x50, 0x4b, 0xc9, 0x80,
+  0xd4, 0x86, 0x3f, 0x98, 0xec, 0x07, 0x2b, 0x5a, 0x47, 0x1e, 0xee, 0xb0,
+  0x09, 0x0e, 0x09, 0x0c, 0x62, 0x65, 0x92, 0xdc, 0x42, 0x4e, 0x41, 0x1c,
+  0x2f, 0x61, 0x1d, 0x63, 0xbf, 0x02, 0xe3, 0xe0, 0xb6, 0x36, 0xb7, 0xc2,
+  0xbd, 0xdd, 0xf9, 0xdc, 0x6c, 0x72, 0x1d, 0x33, 0xd9, 0x03, 0xf9, 0x22,
+  0x80, 0x04, 0xe2, 0xc6, 0xad, 0xf8, 0x9a, 0x2c, 0x05, 0xba, 0x6a, 0x58,
+  0xc9, 0xe1, 0x9e, 0xe0, 0xb2, 0xaa, 0x0c, 0x30, 0xd9, 0xf9, 0xbc, 0xdf,
+  0x69, 0x2f, 0xa1, 0xec, 0xd1, 0x3c, 0x21, 0x0c, 0xb1, 0x60, 0xac, 0x26,
+  0x75, 0xb3, 0x21, 0x4a, 0x2f, 0xae, 0x62, 0xe1, 0x72, 0x44, 0xf2, 0x5b,
+  0xb9, 0x6c, 0x96, 0x4b, 0x1b, 0x49, 0x56, 0x2a, 0x17, 0xab, 0x62, 0xdd,
+  0x01, 0x0b, 0xee, 0x4b, 0x04, 0xb3, 0x1c, 0x08, 0x9b, 0x63, 0xc9, 0xd1,
+  0x2a, 0x6a, 0xc8, 0x1c, 0x25, 0x0c, 0x8c, 0x31, 0xcd, 0xee, 0xea, 0xe2,
+  0xca, 0x3e, 0x2e, 0x7a, 0x3f, 0x3a, 0xbe, 0x9d, 0xbc, 0x33, 0x0f, 0x96,
+  0xfe, 0xdf, 0xff, 0xc3, 0xbe, 0x7e, 0x8f, 0x15, 0xfb, 0xa7, 0xad, 0x58,
+  0xab, 0x49, 0x30, 0x36, 0x79, 0xfc, 0xf7, 0xde, 0x26, 0x23, 0x6b, 0xc3,
+  0xf9, 0x3e, 0xd2, 0xe0, 0xef, 0x7d, 0x95, 0x41, 0x9d, 0x7d, 0x8c, 0xaa,
+  0x90, 0x10, 0x0e, 0x9a, 0x93, 0x55, 0x49, 0xf4, 0x47, 0xc0, 0xa2, 0xd3,
+  0x2b, 0x24, 0x51, 0xc2, 0xe7, 0x1c, 0xd6, 0xda, 0xfa, 0x31, 0xd7, 0x92,
+  0x95, 0x24, 0xfc, 0xd0, 0xe0, 0xe3, 0xb1, 0x9e, 0xc5, 0x1f, 0x1b, 0xae,
+  0x7d, 0x29, 0xbc, 0x85, 0x0d, 0xf9, 0x7d, 0x9f, 0x0e, 0x86, 0x66, 0xd4,
+  0xc5, 0x91, 0x16, 0xcb, 0x8d, 0xec, 0x33, 0x03, 0xea, 0x9e, 0x3f, 0xd9,
+  0xeb, 0x07, 0x7a, 0x76, 0xaf, 0x81, 0xa0, 0x0c, 0xbf, 0x9f, 0xc8, 0x4a,
+  0x01, 0x1a, 0xaf, 0x24, 0xfa, 0xfd, 0x3e, 0x12, 0x77, 0xa3, 0xc4, 0x0d,
+  0x2f, 0xd9, 0x80, 0x70, 0x57, 0xad, 0xce, 0xd0, 0xaa, 0xe2, 0x35, 0x4b,
+  0xe3, 0x38, 0xa1, 0xa6, 0xba, 0x4d, 0x96, 0xdc, 0xc8, 0xa1, 0x09, 0x0d,
+  0xf9, 0x86, 0xdd, 0xf7, 0x8c, 0xdf, 0x0f, 0xc1, 0x9f, 0xe7, 0x0c, 0x65,
+  0x54, 0x12, 0xea, 0x60, 0x94, 0x16, 0x3c, 0x5b, 0x09, 0x70, 0x0d, 0xeb,
+  0x55, 0xa8, 0x8e, 0xbd, 0x36, 0x33, 0x53, 0xae, 0x4f, 0x8f, 0xb6, 0x68,
+  0x4a, 0x50, 0x97, 0x03, 0x78, 0xb2, 0xe9, 0xc4, 0x57, 0xdd, 0x91, 0x8a,
+  0x90, 0x6d, 0x85, 0x28, 0xa3, 0xa6, 0x99, 0xc4, 0x8a, 0x91, 0x36, 0xb9,
+  0x39, 0xbc, 0x47, 0xef, 0x39, 0x97, 0xc5, 0x9d, 0x27, 0xe2, 0x28, 0x49,
+  0x8e, 0x44, 0x78, 0xc9, 0x71, 0x71, 0xb3, 0xa2, 0x3e, 0x97, 0x02, 0xb6,
+  0x11, 0x84, 0xef, 0x3e, 0xdc, 0x77, 0xae, 0xb9, 0xcd, 0x52, 0x9c, 0x6c,
+  0x73, 0xb8, 0xc5, 0x41, 0x0d, 0xeb, 0x06, 0xa1, 0x30, 0x38, 0x72, 0xa8,
+  0xfd, 0x28, 0x64, 0x18, 0xaa, 0x15, 0xf2, 0xf2, 0xf2, 0x38, 0xd2, 0xb5,
+  0x9e, 0xe5, 0x68, 0x4d, 0xca, 0x4e, 0xb4, 0x29, 0x36, 0x9e, 0x58, 0xc1,
+  0x95, 0xb6, 0x14, 0x11, 0xcb, 0xae, 0x1d, 0x43, 0x9a, 0xfa, 0x50, 0x73,
+  0x1c, 0x73, 0xdd, 0x08, 0x87, 0x7e, 0xda, 0x30, 0x29, 0xc3, 0x9c, 0xf1,
+  0x5e, 0x92, 0x49, 0x1c, 0xaf, 0xf2, 0xb9, 0x25, 0xbd, 0xa0, 0xca, 0x5a,
+  0xcf, 0x23, 0x57, 0xb1, 0x0e, 0xc3, 0x57, 0xc6, 0x23, 0xf6, 0x95, 0x67,
+  0x9f, 0x4c, 0x84, 0xe1, 0xb3, 0xbd, 0xdc, 0x45, 0xd3, 0xcb, 0xc5, 0x65,
+  0x37, 0xc5, 0x2c, 0x9d, 0x7e, 0xa0, 0xb9, 0x69, 0xaa, 0x4a, 0x0c, 0x8b,
+  0x43, 0xcb, 0xd6, 0xd3, 0xc2, 0x13, 0x02, 0x9f, 0x82, 0xd2, 0xdc, 0x28,
+  0xdc, 0x1b, 0xb5, 0xb0, 0x66, 0x0d, 0x46, 0x67, 0x7c, 0x7b, 0x9b, 0x2a,
+  0x87, 0x1b, 0x96, 0xa8, 0xe7, 0x64, 0x70, 0xba, 0x62, 0x4e, 0x78, 0xb8,
+  0x39, 0xc9, 0x48, 0xb2, 0xba, 0x94, 0x2a, 0xb4, 0xb1, 0x05, 0x22, 0x2e,
+  0xfc, 0x65, 0xdc, 0x3e, 0xe4, 0x2a, 0x69, 0x35, 0x17, 0xdf, 0x8f, 0x28,
+  0x2c, 0x89, 0xf2, 0xe8, 0x41, 0x39, 0x54, 0xd7, 0x16, 0x78, 0x31, 0x0e,
+  0xb8, 0xdb, 0x34, 0x0b, 0xe9, 0xd6, 0xc3, 0xcd, 0x3d, 0x62, 0x2a, 0x0b,
+  0x1c, 0x29, 0x11, 0x10, 0x3f, 0xbc, 0xfc, 0xbf, 0xd1, 0x4c, 0x7d, 0x79,
+  0x43, 0x45, 0x69, 0x11, 0x24, 0x16, 0xcb, 0x67, 0x1b, 0x25, 0x57, 0x69,
+  0xc3, 0x03, 0xd1, 0x26, 0xf7, 0x3a, 0xdd, 0x3d, 0x66, 0xa7, 0x40, 0xd2,
+  0xaf, 0x83, 0x93, 0x48, 0x6a, 0x2b, 0x97, 0x37, 0xfa, 0xd0, 0x59, 0xd0,
+  0x32, 0x10, 0x7c, 0x8c, 0x82, 0x7b, 0x76, 0x6c, 0xdb, 0x11, 0x08, 0x31,
+  0xb4, 0x13, 0x1f, 0x6a, 0x0e, 0x8a, 0xb9, 0xd8, 0x35, 0x6f, 0xa1, 0x1a,
+  0xac, 0xd9, 0x0b, 0x57, 0xe2, 0x74, 0xcd, 0x62, 0x33, 0x38, 0x1e, 0xc8,
+  0x5c, 0x33, 0xf3, 0x02, 0xa8, 0xe1, 0x87, 0xfb, 0xa7, 0x33, 0xbd, 0x28,
+  0x7c, 0x0d, 0x74, 0xa1, 0x78, 0x39, 0x73, 0x3d, 0xa3, 0x33, 0x46, 0x6d,
+  0x79, 0x1c, 0x29, 0xb0, 0xd5, 0xdb, 0xe7, 0xe3, 0x58, 0xb6, 0x0e, 0xea,
+  0xc7, 0x31, 0x6b, 0xe2, 0xaf, 0x62, 0xa9, 0xc8, 0xcd, 0x44, 0xf8, 0xa1,
+  0xd1, 0xc5, 0x22, 0xef, 0xd7, 0x56, 0xc1, 0xfb, 0x3e, 0x8d, 0x86, 0xc5,
+  0x6c, 0xf2, 0x18, 0x3e, 0xc6, 0xbc, 0x0b, 0xeb, 0xe4, 0x33, 0x45, 0x82,
+  0xd5, 0x0a, 0x1c, 0x78, 0x4d, 0x1b, 0x65, 0xf4, 0xa8, 0x7c, 0x2a, 0x1e,
+  0x2a, 0x8f, 0xfc, 0xf1, 0xc7, 0xe7, 0x37, 0xe1, 0x5e, 0x62, 0xbd, 0x62,
+  0x9c, 0x88, 0xc6, 0xc9, 0x61, 0x34, 0xfd, 0x56, 0x50, 0xa1, 0xa8, 0x81,
+  0x31, 0x94, 0xf3, 0x0e, 0xa8, 0x64, 0xe1, 0x8c, 0x60, 0x35, 0x16, 0x21,
+  0xb2, 0x5b, 0x33, 0xff, 0x31, 0x6a, 0x06, 0x79, 0xaa, 0xbb, 0xb5, 0x82,
+  0x4e, 0x37, 0x4f, 0x92, 0x89, 0xc2, 0x46, 0xd2, 0x45, 0x8c, 0xd3, 0x53,
+  0xb6, 0xe6, 0x8e, 0x36, 0x2f, 0x5c, 0xda, 0xc5, 0xc6, 0x99, 0x41, 0x21,
+  0xd6, 0xf7, 0x86, 0x02, 0xa0, 0x67, 0x86, 0x6f, 0x43, 0x9f, 0x78, 0x28,
+  0xf0, 0x13, 0x22, 0x71, 0x24, 0x5c, 0x8d, 0x46, 0x9e, 0x6e, 0x39, 0x81,
+  0xdc, 0x9a, 0x46, 0x06, 0x45, 0x8f, 0x6b, 0x4d, 0x9e, 0x5e, 0xd7, 0x96,
+  0x5a, 0xca, 0x1f, 0x6c, 0xcb, 0x3c, 0xf9, 0x6e, 0x58, 0x2c, 0x57, 0x7d,
+  0x60, 0xb3, 0xda, 0xc4, 0x2e, 0xee, 0xd1, 0x15, 0x6f, 0x7f, 0xd4, 0xe8,
+  0x59, 0xaf, 0x31, 0xe1, 0xeb, 0xe1, 0x1e, 0xb5, 0x96, 0xb6, 0xc8, 0x29,
+  0x8d, 0xae, 0x17, 0xb4, 0xab, 0x7e, 0x1f, 0xd0, 0x75, 0x0c, 0x7f, 0xd3,
+  0x95, 0x9f, 0x97, 0x3c, 0x13, 0x28, 0x3e, 0x24, 0x92, 0x16, 0xcb, 0x5c,
+  0xea, 0x7b, 0x7e, 0x98, 0x94, 0xdc, 0xf1, 0x77, 0x65, 0x83, 0xdb, 0xc7,
+  0xe0, 0x76, 0x2f, 0x1c, 0x83, 0x7e, 0x58, 0x1f, 0x81, 0x1f, 0xc2, 0xcf,
+  0x1c, 0x83, 0xb4, 0xd7, 0x18, 0x81, 0xe2, 0x2b, 0xbc, 0x47, 0x98, 0xa8,
+  0x1d, 0xf7, 0x03, 0xf9, 0xac, 0x7f, 0xc1, 0x9f, 0x29, 0x68, 0x53, 0x50,
+  0xd7, 0xd8, 0xc2, 0xb9, 0x89, 0xb3, 0x5f, 0x7e, 0x70, 0x04, 0xb9, 0xab,
+  0x45, 0xde, 0xe8, 0x9b, 0x44, 0x5b, 0x13, 0x49, 0x0a, 0x28, 0x4e, 0x4e,
+  0x83, 0x27, 0x3d, 0x2d, 0x72, 0x5f, 0x70, 0x62, 0xa1, 0x41, 0x91, 0x70,
+  0xf0, 0xf3, 0xa3, 0x79, 0xc3, 0x23, 0x52, 0xf5, 0x30, 0x06, 0x5f, 0x4b,
+  0xdb, 0xc6, 0x20, 0x28, 0x2a, 0xfe, 0x63, 0x95, 0xb9, 0x93, 0x3c, 0xf1,
+  0x85, 0x43, 0x64, 0x48, 0xbf, 0x4c, 0x46, 0x6e, 0x8e, 0xe3, 0x92, 0x24,
+  0x7f, 0x9a, 0x5a, 0xbe, 0x7a, 0xcf, 0x50, 0x50, 0x17, 0x01, 0x90, 0x1b,
+  0x7f, 0x60, 0x76, 0x48, 0x0e, 0x82, 0x87, 0x47, 0x37, 0x55, 0xd4, 0xe0,
+  0x69, 0xc6, 0x36, 0xc4, 0x87, 0xc7, 0x21, 0x49, 0x8d, 0x35, 0x94, 0x3a,
+  0x43, 0xa3, 0xab, 0xe5, 0x7e, 0x05, 0xf2, 0xfb, 0xaf, 0xe7, 0x97, 0x75,
+  0x19, 0x0c, 0xd1, 0x4b, 0xfe, 0xf1, 0xa1, 0x24, 0xa0, 0x20, 0xff, 0xc7,
+  0x23, 0xe0, 0x3e, 0x2e, 0x8b, 0xa7, 0x6e, 0x8d, 0x59, 0x9f, 0x7d, 0xf5,
+  0x38, 0xbf, 0x52, 0x72, 0x9f, 0x4a, 0xb6, 0x74, 0x5b, 0x64, 0xb3, 0xa3,
+  0x8d, 0x22, 0x29, 0x8b, 0x56, 0xe0, 0x5a, 0x0b, 0x52, 0xf1, 0x19, 0x25,
+  0x39, 0xe0, 0x3c, 0x19, 0x5b, 0xa1, 0xad, 0x45, 0xb4, 0x54, 0xb6, 0xd5,
+  0x35, 0xd4, 0x04, 0x10, 0xf3, 0xf3, 0x17, 0x12, 0x2a, 0x7e, 0xcf, 0x61,
+  0xc3, 0x1d, 0x86, 0xd0, 0xb4, 0x31, 0xd3, 0x9c, 0xdb, 0x3d, 0x8a, 0x22,
+  0x15, 0x9a, 0x5e, 0x55, 0x93, 0x14, 0x35, 0x63, 0x17, 0xd1, 0xb8, 0x7c,
+  0xe9, 0xc5, 0xe6, 0x65, 0x6c, 0xc3, 0x41, 0xd6, 0x78, 0x1f, 0x1c, 0xc3,
+  0x05, 0x4a, 0x23, 0xb2, 0x77, 0x57, 0xd0, 0xc9, 0x50, 0x91, 0x42, 0xea,
+  0xf2, 0xe2, 0x75, 0x09, 0xf4, 0x62, 0x9f, 0xa8, 0x30, 0x31, 0xfa, 0xb6,
+  0x69, 0xd0, 0x33, 0x27, 0x90, 0x17, 0x57, 0x83, 0x11, 0x8a, 0xc3, 0x52,
+  0x11, 0x22, 0x1d, 0x02, 0x89, 0x2f, 0xbd, 0xdc, 0x2c, 0x09, 0x28, 0x7a,
+  0x08, 0x0a, 0x7b, 0x68, 0x81, 0x24, 0x5e, 0xb1, 0x3a, 0x72, 0xb1, 0x65,
+  0x90, 0xb1, 0x0d, 0x6b, 0x22, 0xc4, 0x2b, 0x6e, 0xae, 0xba, 0xfb, 0xb4,
+  0x86, 0x58, 0xbd, 0xce, 0x88, 0x32, 0xac, 0x38, 0x83, 0x39, 0xbe, 0x6a,
+  0xb7, 0x17, 0x64, 0xaa, 0xb1, 0x0e, 0x14, 0xd8, 0x21, 0x85, 0xc0, 0x05,
+  0xb6, 0x0f, 0xc0, 0x8b, 0xf5, 0xcb, 0x81, 0x43, 0x35, 0xee, 0x50, 0x3c,
+  0x47, 0x93, 0x7e, 0xb4, 0x9d, 0x56, 0x42, 0xec, 0x39, 0x31, 0xd9, 0x16,
+  0xb3, 0xb1, 0xc6, 0x0c, 0x6e, 0xb8, 0xa9, 0x71, 0xb2, 0x5b, 0x2c, 0x13,
+  0x25, 0x74, 0x86, 0xf8, 0xf4, 0xb3, 0x19, 0xf9, 0x4f, 0x0f, 0x46, 0x21,
+  0xfd, 0x4a, 0xac, 0xe0, 0x3b, 0x0e, 0x41, 0x90, 0x1b, 0x7f, 0x2d, 0xee,
+  0xa6, 0x54, 0x70, 0x1b, 0xba, 0x10, 0xe8, 0x98, 0x6e, 0xbf, 0xa2, 0x24,
+  0x39, 0xd3, 0xde, 0xd4, 0xda, 0x06, 0x1a, 0x7a, 0xf3, 0x08, 0x88, 0xfa,
+  0x2a, 0xa2, 0xb6, 0x43, 0xe2, 0xbc, 0xa8, 0xa4, 0x00, 0x38, 0x49, 0xc4,
+  0x17, 0x75, 0x6a, 0x01, 0x8f, 0x0d, 0x51, 0x56, 0x65, 0xfb, 0x74, 0x34,
+  0xec, 0x47, 0xbd, 0x4b, 0x0b, 0x0d, 0xea, 0x50, 0x38, 0x16, 0x05, 0x43,
+  0x60, 0x1f, 0xe2, 0x97, 0x47, 0x17, 0x5b, 0x4d, 0x00, 0x80, 0x78, 0xe2,
+  0x47, 0xc6, 0x28, 0x56, 0x7a, 0x0a, 0xc4, 0xaf, 0x52, 0x49, 0x7d, 0xc1,
+  0x9e, 0xdd, 0x2f, 0xa6, 0xf1, 0x3c, 0xae, 0x85, 0x6a, 0xd8, 0xca, 0xbd,
+  0x5e, 0xb3, 0x70, 0x01, 0x68, 0xa3, 0xad, 0x5a, 0x10, 0xf2, 0x7e, 0x72,
+  0x3c, 0xbc, 0xe0, 0x55, 0xac, 0x87, 0x65, 0x70, 0x18, 0x2b, 0x2b, 0xba,
+  0xc0, 0x93, 0x56, 0x7f, 0x2a, 0x82, 0xa0, 0x7f, 0x3b, 0x02, 0x59, 0x21,
+  0xd7, 0x1b, 0x62, 0x8f, 0xc2, 0x30, 0xe0, 0xdf, 0x16, 0xe8, 0x9e, 0xd8,
+  0x8b, 0x69, 0x70, 0xbf, 0xe0, 0x52, 0x56, 0x1c, 0x01, 0x79, 0x59, 0x20,
+  0x03, 0x44, 0x7a, 0x5c, 0xa0, 0xe2, 0x8b, 0x98, 0x75, 0x26, 0xcb, 0xbc,
+  0x79, 0x5d, 0xc6, 0x51, 0xd0, 0xa1, 0xc0, 0x0e, 0xf4, 0x2a, 0x12, 0x2e,
+  0x9c, 0x01, 0x85, 0xc7, 0xcc, 0xa4, 0xee, 0x83, 0x17, 0x1a, 0x46, 0x56,
+  0x5f, 0x90, 0xc9, 0x80, 0x30, 0xc2, 0x21, 0xd9, 0xb4, 0x77, 0x49, 0x1b,
+  0x9a, 0x22, 0x13, 0x1f, 0xac, 0x5c, 0x12, 0xd7, 0x57, 0x0f, 0xa3, 0x4f,
+  0x4a, 0x28, 0x50, 0xe8, 0x1a, 0x93, 0xb8, 0x81, 0x65, 0x61, 0x14, 0xcb,
+  0x65, 0x81, 0x62, 0x29, 0xa9, 0xca, 0x6b, 0xd2, 0x14, 0xf7, 0x54, 0xdc,
+  0x12, 0x9f, 0x63, 0x90, 0x88, 0xc1, 0x81, 0x4b, 0xc4, 0x9e, 0xe7, 0x56,
+  0x14, 0x8f, 0x66, 0x90, 0xaf, 0xac, 0xa8, 0x96, 0xbc, 0xd7, 0x6f, 0xd1,
+  0x26, 0xa1, 0xb3, 0xad, 0x61, 0x88, 0xbf, 0x1e, 0x4d, 0x7c, 0xef, 0x68,
+  0x42, 0xd6, 0xf0, 0x25, 0xff, 0xf1, 0xb3, 0xa8, 0x22, 0x40, 0x97, 0xe0,
+  0x97, 0xd9, 0x46, 0x51, 0x21, 0x8f, 0x7e, 0x23, 0x92, 0x99, 0x1e, 0xe2,
+  0xd8, 0x52, 0xbf, 0xd7, 0xaa, 0xff, 0x42, 0xac, 0xa8, 0x92, 0x44, 0xf0,
+  0x0c, 0x5b, 0xb8, 0x69, 0x53, 0xdb, 0x6a, 0x38, 0xf4, 0xbf, 0xb7, 0x72,
+  0x91, 0x4f, 0x76, 0x70, 0x39, 0xb1, 0xec, 0x92, 0x94, 0xbf, 0xe1, 0xd2,
+  0xfd, 0x1d, 0x49, 0x69, 0xf4, 0x78, 0x9f, 0xc9, 0xff, 0xe5, 0x24, 0x66,
+  0x7b, 0x84, 0x79, 0xfb, 0xd7, 0xc2, 0x72, 0x02, 0x57, 0x5e, 0xeb, 0x0c,
+  0xa8, 0xa1, 0x0b, 0xd7, 0x37, 0x32, 0x15, 0x47, 0x00, 0x9d, 0x99, 0x65,
+  0x13, 0x75, 0xdf, 0xc4, 0xa5, 0xad, 0xf0, 0xda, 0x8a, 0x60, 0x86, 0x21,
+  0x84, 0xe3, 0x47, 0x8f, 0xf7, 0x22, 0xc5, 0xb0, 0x5d, 0xd3, 0xa4, 0x03,
+  0xed, 0x6d, 0xa4, 0xd3, 0x0a, 0x7c, 0x87, 0xe2, 0x9a, 0x86, 0xd3, 0xb0,
+  0x6b, 0x15, 0xc2, 0x4d, 0xc1, 0xfe, 0x5c, 0x62, 0x6a, 0xfc, 0x8c, 0x78,
+  0xf4, 0x0a, 0x74, 0xd9, 0xd0, 0x56, 0x60, 0xc2, 0xb0, 0xd8, 0x25, 0xd2,
+  0x33, 0x18, 0xf0, 0x1e, 0xbe, 0x44, 0x8f, 0x47, 0x47, 0xa3, 0x54, 0x03,
+  0x96, 0xa1, 0x7f, 0x19, 0xd4, 0x5f, 0x4b, 0xd4, 0xb6, 0xfa, 0x09, 0x7d,
+  0xb6, 0x90, 0x46, 0x5b, 0x2a, 0x9f, 0xfd, 0x9d, 0xe2, 0x30, 0x39, 0x60,
+  0xec, 0xf7, 0xd4, 0x16, 0xc6, 0x88, 0xb4, 0xc7, 0x35, 0x79, 0x8f, 0x85,
+  0x70, 0xff, 0xda, 0x64, 0xf5, 0x36, 0x68, 0x17, 0x40, 0xac, 0xe8, 0x71,
+  0xe5, 0x8d, 0x10, 0x7b, 0x79, 0xb3, 0xbf, 0x25, 0x25, 0xb6, 0x6e, 0x12,
+  0x41, 0xb6, 0x92, 0x6d, 0x6e, 0xaa, 0x93, 0xb1, 0xd3, 0xf4, 0x5c, 0x80,
+  0x5c, 0x36, 0x9d, 0xf8, 0xf3, 0x64, 0x19, 0x0a, 0xe8, 0x6c, 0x5b, 0x6c,
+  0x44, 0xc6, 0xef, 0x38, 0x8b, 0xbe, 0x71, 0x97, 0xd4, 0x1a, 0x23, 0x35,
+  0x2f, 0x6c, 0xcc, 0x5f, 0xc3, 0xae, 0xc1, 0xdf, 0x32, 0x52, 0x14, 0x70,
+  0x30, 0xac, 0xe2, 0x15, 0xad, 0xe0, 0x70, 0x80, 0x88, 0xf1, 0x60, 0x32,
+  0xf3, 0x16, 0xbd, 0x10, 0xd5, 0x7a, 0x1d, 0x76, 0x31, 0x14, 0x58, 0xc5,
+  0xc8, 0x1a, 0xf0, 0x38, 0xeb, 0x32, 0x64, 0x58, 0x1f, 0xcc, 0x83, 0x18,
+  0x55, 0xcb, 0x98, 0x84, 0xf0, 0xc2, 0x08, 0xde, 0x45, 0x31, 0xd8, 0x79,
+  0x6b, 0x44, 0x3f, 0x93, 0x9a, 0x07, 0x4e, 0x0e, 0x6d, 0x84, 0x51, 0x07,
+  0x51, 0xa8, 0xa3, 0x62, 0x99, 0x4f, 0x96, 0xb3, 0xce, 0x20, 0x28, 0x7a,
+  0xac, 0x0b, 0x03, 0x06, 0x5a, 0x3f, 0x08, 0x72, 0x09, 0x51, 0x9f, 0xcf,
+  0x76, 0x6a, 0x06, 0x47, 0x83, 0xca, 0x09, 0xc0, 0x71, 0xfa, 0xbb, 0x21,
+  0xfd, 0x50, 0x7b, 0x0d, 0x79, 0xab, 0xc4, 0xbd, 0xf6, 0x1b, 0x6e, 0xde,
+  0x0e, 0x2d, 0x26, 0xe4, 0xd8, 0xdd, 0xc1, 0x4e, 0xbb, 0xe4, 0x88, 0x60,
+  0x9a, 0x71, 0xe2, 0xab, 0x1c, 0xa5, 0xa4, 0xff, 0x61, 0xb4, 0x85, 0xaf,
+  0x82, 0x27, 0x2e, 0x52, 0x95, 0xb9, 0x76, 0xec, 0x90, 0x36, 0xaa, 0x26,
+  0xba, 0x02, 0x2f, 0x85, 0xe3, 0x0a, 0x9c, 0xa0, 0x99, 0x88, 0xed, 0xf1,
+  0x85, 0x93, 0xda, 0x82, 0xe1, 0xed, 0x82, 0xe5, 0x4e, 0x8b, 0xdb, 0xdd,
+  0x56, 0xdc, 0xe7, 0xda, 0xd0, 0x20, 0x89, 0x5d, 0x0c, 0x4f, 0x5c, 0xbc,
+  0xde, 0xae, 0x48, 0xb3, 0x56, 0x31, 0x29, 0x28, 0xaf, 0xb4, 0xa6, 0x28,
+  0xd8, 0xc5, 0xc9, 0xd0, 0xe4, 0x59, 0x3f, 0x84, 0x3d, 0x5c, 0x98, 0xc5,
+  0xf4, 0x76, 0xaf, 0xbd, 0x70, 0xb6, 0x8e, 0xa1, 0x32, 0x88, 0x61, 0x30,
+  0x88, 0xbd, 0xe6, 0x20, 0x1e, 0xaa, 0x4b, 0x26, 0x05, 0xac, 0x6b, 0x43,
+  0x78, 0xa2, 0x43, 0x78, 0xf2, 0xd8, 0x55, 0x08, 0x07, 0xf0, 0xe4, 0xe7,
+  0xae, 0x42, 0xeb, 0x10, 0x9e, 0x22, 0xee, 0x75, 0x71, 0xfb, 0xb4, 0x25,
+  0xe2, 0xd3, 0xa1, 0x65, 0x72, 0xc8, 0x17, 0x72, 0xe6, 0xa7, 0x62, 0xec,
+  0xf2, 0x1e, 0x35, 0xa0, 0xfd, 0x5b, 0x51, 0x89, 0xcc, 0x5b, 0xe4, 0x8f,
+  0xeb, 0xb0, 0xfe, 0x3a, 0x66, 0x8f, 0xbf, 0x28, 0x68, 0x00, 0x97, 0xf6,
+  0xcb, 0xe2, 0xf6, 0xe3, 0xbe, 0xf6, 0x50, 0xab, 0x5b, 0x24, 0xb5, 0x50,
+  0xd6, 0x84, 0x1e, 0x4a, 0x15, 0x48, 0x06, 0xad, 0xe0, 0x08, 0x24, 0x7c,
+  0x70, 0x7c, 0x76, 0xfb, 0xd4, 0x06, 0x95, 0x48, 0x1c, 0x58, 0x30, 0xdd,
+  0x8f, 0x65, 0xba, 0x1f, 0xff, 0xdf, 0x34, 0xdd, 0x8f, 0xd7, 0x4f, 0xf7,
+  0x23, 0x51, 0xcb, 0x19, 0xce, 0xaa, 0x3f, 0x8a, 0xf3, 0xb5, 0xe0, 0x7e,
+  0x16, 0xbd, 0xe4, 0xb0, 0xaf, 0x2a, 0x51, 0xb8, 0x5a, 0x8c, 0x5b, 0xbe,
+  0xa1, 0x66, 0xd6, 0xb3, 0x82, 0x8a, 0x44, 0x8f, 0x8a, 0xeb, 0x45, 0x99,
+  0x8e, 0x7f, 0x6e, 0xed, 0xbc, 0x5f, 0x52, 0xdb, 0xd0, 0x8d, 0x8d, 0xfa,
+  0x02, 0x84, 0xb9, 0x0b, 0xf1, 0xfb, 0x9f, 0xdb, 0x83, 0xd6, 0x12, 0x1b,
+  0x87, 0xcd, 0x22, 0x18, 0x3d, 0x2e, 0x18, 0x5d, 0x2b, 0xa5, 0x11, 0x88,
+  0x12, 0x47, 0x6f, 0xbf, 0x39, 0x3e, 0x3f, 0x7d, 0xfb, 0xe6, 0xe8, 0xad,
+  0x73, 0xfc, 0x73, 0x3c, 0x82, 0xd8, 0x1c, 0x7e, 0x30, 0xab, 0xc2, 0x8b,
+  0xed, 0xed, 0x9f, 0x18, 0x8f, 0xe5, 0x33, 0xb5, 0xdf, 0x35, 0xef, 0xcd,
+  0x42, 0xed, 0x14, 0x1e, 0x02, 0xdb, 0xd2, 0x63, 0xd8, 0x22, 0xe4, 0x96,
+  0x8b, 0x83, 0x56, 0xdf, 0x9f, 0x9d, 0x9f, 0x7e, 0xf7, 0xfd, 0xaf, 0xd8,
+  0xfe, 0xb0, 0x02, 0xbb, 0xfc, 0xab, 0x36, 0xff, 0x3a, 0x1c, 0xfd, 0xfe,
+  0xc9, 0xc9, 0xaf, 0xd6, 0x38, 0x2b, 0x02, 0xce, 0x70, 0xd3, 0x77, 0x56,
+  0x30, 0x57, 0xff, 0xac, 0xa2, 0x22, 0xbc, 0x3d, 0xd5, 0x8e, 0xc5, 0x7c,
+  0xd2, 0x37, 0xe4, 0xf2, 0x09, 0xeb, 0xe8, 0x20, 0x54, 0x8c, 0xa1, 0x81,
+  0x5b, 0xc8, 0x5f, 0xb2, 0x04, 0xe3, 0x80, 0x91, 0xd4, 0x28, 0x27, 0xf8,
+  0xda, 0x1c, 0xc1, 0x9f, 0x39, 0xfb, 0x98, 0x40, 0xd1, 0x98, 0xd9, 0xb5,
+  0xa9, 0xce, 0x70, 0xf6, 0x37, 0xc2, 0x2e, 0xf2, 0xb4, 0xb8, 0xe1, 0xd4,
+  0x07, 0x1c, 0x4f, 0x45, 0xf7, 0x2b, 0x19, 0x2c, 0x15, 0xd2, 0x38, 0x0f,
+  0x05, 0xe4, 0xf5, 0xdd, 0xf1, 0x45, 0x74, 0x70, 0x7a, 0xe8, 0x69, 0xf7,
+  0x82, 0x9d, 0x03, 0x6c, 0x5e, 0xc5, 0x11, 0x1c, 0x2d, 0xe7, 0xc8, 0x29,
+  0xbc, 0xf4, 0x18, 0xe1, 0x0a, 0xd9, 0x86, 0xb0, 0x97, 0x42, 0x9d, 0xb7,
+  0x5c, 0xc7, 0x5e, 0xca, 0x52, 0x20, 0x98, 0x65, 0x12, 0xa8, 0xf2, 0xf2,
+  0xb0, 0xc3, 0xb1, 0x33, 0xc3, 0x2c, 0x62, 0x09, 0x01, 0xe5, 0x40, 0xe7,
+  0x5a, 0x54, 0x7f, 0x3a, 0x46, 0x13, 0x9c, 0x0b, 0x49, 0xd0, 0x20, 0x09,
+  0x67, 0xdf, 0x0b, 0xf4, 0x41, 0x11, 0x2b, 0x01, 0x57, 0xce, 0x19, 0x0c,
+  0xb6, 0xa7, 0xb1, 0xef, 0x40, 0xeb, 0x94, 0xc1, 0x84, 0x38, 0x1c, 0xbb,
+  0x6a, 0xb7, 0x9e, 0xfb, 0x4c, 0x76, 0x8f, 0xe1, 0xc1, 0xfa, 0x3b, 0x82,
+  0x87, 0x27, 0x16, 0x88, 0x6f, 0x68, 0x2f, 0x06, 0xfb, 0x2d, 0x35, 0x88,
+  0xd2, 0x62, 0x8d, 0x49, 0xd4, 0x6f, 0xfb, 0x9e, 0x12, 0xb5, 0xa0, 0x8a,
+  0x42, 0xa8, 0x11, 0x07, 0x41, 0xfa, 0xf7, 0x40, 0x4e, 0x7e, 0xa2, 0x83,
+  0x39, 0x3f, 0xa1, 0x99, 0x4f, 0x85, 0xcb, 0x69, 0x1c, 0xa4, 0x00, 0x8a,
+  0xdf, 0xc5, 0x62, 0x30, 0xd7, 0xd2, 0x1e, 0xfe, 0xcd, 0x67, 0xf2, 0xe3,
+  0xc0, 0x48, 0xc1, 0x23, 0x26, 0xf9, 0xe2, 0xb0, 0xb5, 0xf2, 0x8e, 0x86,
+  0xa3, 0x34, 0x66, 0x78, 0x76, 0xb1, 0xd0, 0x36, 0x71, 0x82, 0x6b, 0x91,
+  0x03, 0x1f, 0xd7, 0xfa, 0xb1, 0x6e, 0xa4, 0xb4, 0xe9, 0x85, 0xd3, 0x2a,
+  0xc2, 0xc0, 0x11, 0x1b, 0x74, 0xb3, 0xb5, 0x4f, 0xea, 0x8b, 0x12, 0x84,
+  0x9f, 0x54, 0xab, 0x1c, 0x7e, 0xea, 0x78, 0x42, 0x74, 0x97, 0x20, 0x4f,
+  0xc0, 0x15, 0x58, 0x59, 0x4c, 0xdd, 0xec, 0xcc, 0xe3, 0x2b, 0x4e, 0x46,
+  0x2e, 0x9e, 0xa1, 0x7e, 0xb7, 0xb1, 0x8e, 0xb7, 0xa1, 0xa4, 0xe5, 0x61,
+  0x81, 0xeb, 0xe7, 0xbe, 0x93, 0x28, 0xe6, 0x50, 0x58, 0x44, 0x47, 0xce,
+  0x53, 0x8b, 0x4d, 0xd2, 0xf6, 0xe5, 0x23, 0xf8, 0x6e, 0x88, 0xf5, 0x67,
+  0xee, 0x6f, 0x7d, 0xa3, 0x81, 0x9a, 0x51, 0x0b, 0xdc, 0xc0, 0x2a, 0x2c,
+  0x73, 0xc9, 0x98, 0xf1, 0x78, 0x1e, 0x1c, 0x21, 0x1a, 0xcf, 0xd5, 0xf6,
+  0x2e, 0xc0, 0x9d, 0x9a, 0x7a, 0xd5, 0xb8, 0xc9, 0x4a, 0x07, 0x76, 0x0f,
+  0xbd, 0x56, 0xd6, 0x8d, 0x61, 0x68, 0xe5, 0x54, 0x07, 0x90, 0x24, 0x38,
+  0x43, 0xa6, 0x22, 0xf3, 0x51, 0x8d, 0x1a, 0x41, 0x1b, 0xbe, 0x22, 0x80,
+  0x5f, 0x87, 0xdd, 0xdd, 0xda, 0x62, 0x9f, 0xed, 0x0f, 0x87, 0xb6, 0xd4,
+  0x0c, 0x6a, 0x62, 0xeb, 0x29, 0x2b, 0xa8, 0xbe, 0x29, 0xce, 0x2e, 0xd4,
+  0x6c, 0xf5, 0x96, 0x9b, 0x50, 0x1b, 0xa9, 0xf9, 0x73, 0x77, 0x9f, 0xf8,
+  0x35, 0x77, 0x9d, 0x7d, 0x23, 0xad, 0xf5, 0x1e, 0xd9, 0x59, 0x6b, 0x5f,
+  0xdf, 0xb4, 0xf4, 0xf5, 0xb4, 0x36, 0xaf, 0xbd, 0xbd, 0x4f, 0x22, 0x3b,
+  0x65, 0x5a, 0x25, 0xcf, 0x75, 0xa6, 0xbd, 0x89, 0xc2, 0x4f, 0x0f, 0xf6,
+  0x25, 0x55, 0xa7, 0xd9, 0x97, 0x52, 0x45, 0x51, 0xa9, 0x19, 0xb0, 0xfb,
+  0xcc, 0x4f, 0x8b, 0x14, 0x43, 0xb4, 0x07, 0xdb, 0x83, 0x1c, 0x93, 0xc6,
+  0xe9, 0xe1, 0xa4, 0x7c, 0x1c, 0x95, 0xe3, 0x33, 0xae, 0x27, 0x9f, 0x95,
+  0xed, 0x0e, 0x4a, 0x1b, 0x46, 0xd0, 0xcf, 0x27, 0xae, 0x1f, 0x37, 0x72,
+  0x28, 0x83, 0x92, 0x83, 0x3a, 0x08, 0x39, 0x82, 0xd2, 0x48, 0x10, 0x43,
+  0xa3, 0x86, 0xef, 0x96, 0x62, 0x52, 0xf2, 0xb6, 0xef, 0xe5, 0x53, 0xc5,
+  0x3d, 0x92, 0x32, 0x2e, 0x82, 0x66, 0xc0, 0x95, 0x2e, 0xe2, 0x0a, 0x38,
+  0x00, 0x9b, 0x4d, 0x70, 0xdc, 0xad, 0x8f, 0x3c, 0x3c, 0xed, 0xbb, 0xcf,
+  0x83, 0x35, 0xb1, 0x61, 0x99, 0xc1, 0x6f, 0xdb, 0x8e, 0x8f, 0x63, 0x21,
+  0x22, 0xf6, 0xe0, 0xef, 0xf3, 0xa3, 0x8b, 0x73, 0x0e, 0x3f, 0x03, 0xbe,
+  0x41, 0x5d, 0x5d, 0xa5, 0x33, 0xb5, 0xe5, 0x6c, 0xe3, 0x02, 0xda, 0x1c,
+  0x70, 0x5d, 0x4f, 0xc9, 0x52, 0x2b, 0x4c, 0xf0, 0x3c, 0xa3, 0x7d, 0xfd,
+  0xd3, 0xde, 0x73, 0x88, 0xf1, 0x72, 0x0f, 0xf9, 0xa0, 0x18, 0x3d, 0x19,
+  0x6e, 0xfd, 0x7d, 0x64, 0x82, 0x20, 0x5b, 0x89, 0xcd, 0xd6, 0x45, 0x88,
+  0x1a, 0x27, 0xf2, 0xee, 0x76, 0x29, 0xbf, 0x29, 0x0c, 0x50, 0x42, 0x3e,
+  0x1b, 0x96, 0x1a, 0xd7, 0x79, 0x3c, 0x97, 0x5c, 0x2e, 0x19, 0x44, 0xd5,
+  0xe7, 0xa1, 0x17, 0xa4, 0x44, 0x91, 0x8e, 0x12, 0x56, 0xa9, 0x9e, 0xa2,
+  0x9a, 0x4c, 0xd3, 0xf0, 0x33, 0xca, 0x6e, 0xcd, 0xc1, 0xa6, 0x41, 0xd0,
+  0x02, 0xf3, 0xce, 0xfb, 0xc5, 0x97, 0x29, 0x0b, 0xfc, 0xfd, 0x4b, 0x54,
+  0xa9, 0x8c, 0x81, 0x90, 0x5e, 0xd4, 0x54, 0xf4, 0x3d, 0x39, 0x94, 0xdf,
+  0x72, 0x58, 0xb6, 0xad, 0x59, 0xed, 0x30, 0x4a, 0xcc, 0x36, 0x33, 0x59,
+  0x66, 0x3b, 0x1e, 0x58, 0xa9, 0x58, 0xd1, 0xcc, 0x67, 0xcd, 0x81, 0x29,
+  0x3a, 0x45, 0xd0, 0xcd, 0xb3, 0x26, 0xf1, 0x0e, 0x2f, 0x4e, 0xcf, 0x95,
+  0xc0, 0x9a, 0x2c, 0x57, 0x0e, 0x23, 0x3f, 0xe2, 0x7d, 0x8c, 0xbd, 0x16,
+  0xfb, 0xbd, 0x09, 0x7c, 0x1a, 0x38, 0x81, 0xcc, 0x54, 0xdf, 0xeb, 0xc7,
+  0xde, 0x71, 0xa3, 0x53, 0xfb, 0x26, 0xce, 0x39, 0xf9, 0x10, 0x31, 0xfd,
+  0x58, 0x59, 0xba, 0x1f, 0x49, 0x9c, 0x9f, 0x05, 0xca, 0xc1, 0x9e, 0x9c,
+  0xb3, 0xd3, 0x65, 0x29, 0xd5, 0x63, 0x91, 0x03, 0x04, 0x32, 0xd2, 0x6c,
+  0x20, 0x18, 0x8f, 0xd4, 0x3a, 0xe4, 0x2c, 0x72, 0x75, 0x52, 0x94, 0x33,
+  0x74, 0xea, 0xab, 0x79, 0xa9, 0xfd, 0xdd, 0xdd, 0x5e, 0xde, 0x6b, 0xce,
+  0x16, 0x5f, 0x98, 0xe6, 0xc5, 0x9b, 0xc1, 0x04, 0xa4, 0x58, 0xce, 0xf5,
+  0xcd, 0x1e, 0x93, 0x28, 0xc0, 0x63, 0xd6, 0x10, 0x81, 0x40, 0x36, 0xf2,
+  0x62, 0xc5, 0x8e, 0x5b, 0x67, 0xae, 0x2b, 0xa8, 0x43, 0xe3, 0x6e, 0x2b,
+  0xd5, 0x40, 0xed, 0x8b, 0xb7, 0x99, 0x22, 0xef, 0xc9, 0x61, 0xd5, 0xba,
+  0x2c, 0xed, 0x55, 0xd3, 0x74, 0x53, 0xb8, 0x1d, 0x6b, 0x08, 0xc8, 0xc1,
+  0xf9, 0xca, 0x1c, 0x50, 0x0e, 0x3c, 0xfd, 0xd2, 0x65, 0x8d, 0x82, 0x3f,
+  0xb7, 0xfb, 0xe5, 0x7c, 0x62, 0xd4, 0x93, 0xdd, 0x26, 0x75, 0x40, 0xdc,
+  0x3e, 0x3f, 0x1a, 0x5e, 0xc8, 0xd8, 0xf1, 0x5b, 0x63, 0xec, 0x92, 0x1d,
+  0xe4, 0x6a, 0x2a, 0x16, 0xeb, 0xa8, 0x03, 0xf1, 0x5d, 0xf0, 0x97, 0x87,
+  0x75, 0xf5, 0xc2, 0x35, 0x7b, 0x12, 0x04, 0x21, 0x31, 0xe3, 0x54, 0x5a,
+  0xb9, 0xb0, 0xa2, 0x3a, 0x51, 0x47, 0x7b, 0xe9, 0xd0, 0x95, 0x2b, 0x47,
+  0x22, 0xcb, 0x83, 0x0a, 0x64, 0x4f, 0x9e, 0xfa, 0x16, 0x16, 0x60, 0xee,
+  0xda, 0xc0, 0xb1, 0x99, 0xa7, 0xf1, 0xa1, 0x73, 0xa6, 0x5e, 0xa1, 0xda,
+  0xab, 0x10, 0x46, 0x0d, 0x73, 0xf8, 0xc9, 0x33, 0x97, 0x2b, 0x68, 0xe2,
+  0x51, 0x30, 0x14, 0x7c, 0x8c, 0x64, 0xf7, 0xe2, 0x3a, 0x96, 0x0c, 0xe0,
+  0x1a, 0xd9, 0x3d, 0xf9, 0xd8, 0x33, 0x5d, 0xc8, 0xce, 0xde, 0xc3, 0xa2,
+  0x2b, 0x10, 0x5c, 0x47, 0x70, 0x51, 0xa5, 0xf3, 0x25, 0xc3, 0x1a, 0x10,
+  0x97, 0x98, 0x02, 0xac, 0x45, 0x5d, 0x24, 0x0d, 0x6b, 0x70, 0x3d, 0x26,
+  0xea, 0x89, 0x5e, 0x44, 0xa4, 0xdf, 0xfa, 0xed, 0x92, 0x04, 0x1c, 0x3e,
+  0xcc, 0x5e, 0xc6, 0xa3, 0x83, 0x3b, 0x77, 0xb7, 0xc5, 0x20, 0x3a, 0x03,
+  0xd6, 0x1d, 0xdb, 0xb9, 0x8b, 0xbf, 0xf8, 0xd6, 0xe4, 0xb0, 0x9c, 0x1c,
+  0xee, 0x9f, 0xe1, 0xfa, 0x64, 0xe1, 0x34, 0x9d, 0xd3, 0xee, 0xf2, 0x27,
+  0xf8, 0x35, 0xc0, 0x29, 0x6b, 0x4c, 0xf9, 0xb9, 0x7f, 0x59, 0x6b, 0x47,
+  0xd6, 0x1f, 0x79, 0xaa, 0xb4, 0x45, 0x5a, 0x0b, 0x37, 0xe1, 0xb8, 0x33,
+  0xce, 0xb4, 0x16, 0x62, 0x9e, 0x48, 0x0b, 0x97, 0xf6, 0x4c, 0x85, 0x8b,
+  0x07, 0x4d, 0xc9, 0x9d, 0xb0, 0x2f, 0xeb, 0xc4, 0x49, 0xe1, 0x74, 0x72,
+  0x00, 0x9d, 0x4f, 0x6d, 0xcd, 0xc1, 0x70, 0xa7, 0xe6, 0x0b, 0xae, 0xe4,
+  0x3e, 0xf0, 0xc2, 0x4a, 0x7e, 0x0f, 0xcd, 0xa4, 0x01, 0x9c, 0x54, 0x75,
+  0xc9, 0x3d, 0x15, 0x6a, 0x74, 0xa4, 0xe3, 0xae, 0xb1, 0xca, 0xe8, 0xd0,
+  0xb1, 0xcb, 0xaa, 0xe2, 0xdd, 0x76, 0x65, 0x3e, 0x83, 0xa6, 0x9e, 0xf9,
+  0xa6, 0x2e, 0x19, 0x09, 0xc9, 0xf8, 0xfb, 0x7e, 0x85, 0x07, 0x39, 0x18,
+  0x24, 0x57, 0xc7, 0xf6, 0x21, 0x4d, 0xa1, 0x7a, 0x7f, 0x3c, 0x15, 0x62,
+  0xb8, 0xc8, 0x32, 0xa9, 0xf0, 0xe4, 0x82, 0xb1, 0x06, 0x02, 0xf7, 0xdd,
+  0xb4, 0x7d, 0x17, 0x3d, 0x55, 0xaf, 0xb4, 0x7a, 0x05, 0x6c, 0xf7, 0xfd,
+  0x06, 0x80, 0xd9, 0xac, 0x01, 0xa1, 0xfe, 0xf4, 0x53, 0x55, 0xdf, 0x6e,
+  0xe6, 0x44, 0x92, 0xd1, 0xc5, 0xd1, 0xc9, 0xdb, 0xa3, 0x0b, 0x97, 0xdf,
+  0x6e, 0xb3, 0x09, 0x9e, 0x7f, 0xae, 0xd6, 0xa5, 0xa9, 0x86, 0xcb, 0x28,
+  0x6e, 0x63, 0xdd, 0x07, 0xfa, 0x6c, 0xd7, 0x05, 0xd0, 0x2e, 0x12, 0x2e,
+  0x71, 0xc5, 0xe7, 0x2f, 0x21, 0x01, 0xe8, 0x52, 0x92, 0xf9, 0xb8, 0xc0,
+  0xde, 0x57, 0xd1, 0x9b, 0xc3, 0x67, 0x08, 0x41, 0xbe, 0x4a, 0xf2, 0x45,
+  0xce, 0x00, 0xa0, 0x4a, 0x25, 0xd9, 0x8d, 0x6f, 0x6b, 0xcf, 0x07, 0xe3,
+  0x9a, 0x8a, 0xa2, 0x1c, 0x43, 0x05, 0x59, 0x5a, 0x23, 0xce, 0x49, 0xef,
+  0x69, 0x59, 0x12, 0x43, 0x0b, 0xb4, 0x5c, 0x7b, 0x96, 0x0d, 0x1e, 0x46,
+  0x26, 0x7f, 0xf6, 0xc4, 0x73, 0x89, 0x7c, 0xb5, 0x00, 0xd4, 0x90, 0x54,
+  0x02, 0x74, 0x24, 0xeb, 0x1f, 0x15, 0xc6, 0x74, 0x20, 0xe7, 0x0a, 0xd2,
+  0x62, 0xf3, 0x2d, 0x04, 0xd5, 0x88, 0x15, 0xca, 0xbf, 0xf6, 0x2c, 0x54,
+  0xd6, 0x0a, 0x2d, 0x0c, 0x46, 0x8b, 0x07, 0xb6, 0xc7, 0x82, 0x80, 0x7f,
+  0xf4, 0x63, 0xf7, 0x28, 0xca, 0x17, 0xa5, 0x73, 0x05, 0x6d, 0x58, 0xff,
+  0x82, 0x0a, 0x98, 0x72, 0xef, 0x7a, 0xd1, 0x47, 0x84, 0x8a, 0x60, 0xd9,
+  0xfd, 0x1b, 0xcf, 0xab, 0x8a, 0x28, 0x63, 0x01, 0x7a, 0x14, 0x61, 0x4c,
+  0x28, 0x5d, 0x5c, 0x07, 0x05, 0x8e, 0x3f, 0x96, 0x4b, 0xf0, 0x2c, 0x41,
+  0x64, 0x7e, 0xb0, 0x8f, 0xc6, 0x5e, 0x2a, 0x19, 0xb1, 0x76, 0x8a, 0x84,
+  0xaa, 0x0e, 0xe8, 0x64, 0xe8, 0x2b, 0x75, 0x9a, 0xc4, 0xb3, 0xbe, 0x60,
+  0xdf, 0xc7, 0xbb, 0x4a, 0x8d, 0x34, 0xdd, 0xec, 0x6a, 0x4e, 0xba, 0xfd,
+  0xa4, 0x59, 0xea, 0xca, 0x3f, 0xbd, 0xa7, 0x27, 0x51, 0x6a, 0xc2, 0x31,
+  0xb7, 0x21, 0xd5, 0xdf, 0x7f, 0xff, 0x44, 0x69, 0x55, 0xdc, 0x58, 0x52,
+  0x0b, 0x97, 0xda, 0x04, 0x42, 0x70, 0x92, 0x4c, 0x12, 0xbf, 0xa3, 0x1f,
+  0x3f, 0x55, 0x91, 0xc6, 0xa4, 0x4e, 0xb0, 0x7b, 0xac, 0xc1, 0x14, 0x59,
+  0xc7, 0xca, 0xfd, 0xfc, 0xd3, 0x7a, 0xa1, 0xe8, 0x0e, 0x96, 0x56, 0x68,
+  0xd2, 0x15, 0xa0, 0xc7, 0xaf, 0x77, 0xe9, 0x5c, 0x23, 0x57, 0xeb, 0x6f,
+  0x7f, 0xbc, 0xc6, 0x90, 0xa1, 0x3e, 0x80, 0x23, 0x26, 0x20, 0xff, 0xf8,
+  0x27, 0x16, 0x17, 0x98, 0xf7, 0x42, 0xf4, 0x27, 0x08, 0xb3, 0x06, 0x57,
+  0x66, 0x67, 0x06, 0x2a, 0xc0, 0xc2, 0x92, 0x51, 0x99, 0x1d, 0x5c, 0x5a,
+  0x2f, 0x0d, 0x14, 0x4f, 0xea, 0xc4, 0xf7, 0x21, 0xd4, 0xf3, 0x9a, 0x9d,
+  0xb6, 0x5e, 0xce, 0x26, 0x76, 0xe0, 0x23, 0x25, 0xfd, 0xc3, 0xcf, 0x95,
+  0x0e, 0xec, 0xda, 0x31, 0x69, 0x6f, 0xdd, 0x0b, 0x9f, 0xec, 0x84, 0xa2,
+  0xdf, 0x04, 0xf6, 0x32, 0x49, 0x21, 0x5c, 0xf7, 0xbc, 0x10, 0xc1, 0x31,
+  0xf1, 0xe2, 0x2b, 0x22, 0x5e, 0x7e, 0xc4, 0x5d, 0x56, 0xfe, 0xa9, 0xbd,
+  0x2a, 0xe3, 0x0a, 0xc5, 0x90, 0xe8, 0xf8, 0xd0, 0x3f, 0xf7, 0xc4, 0xcf,
+  0xcd, 0x6a, 0x62, 0xab, 0xd5, 0x6d, 0x13, 0x2f, 0xf9, 0x78, 0xcf, 0x4f,
+  0x9e, 0x6a, 0xac, 0x20, 0xf2, 0x78, 0xaf, 0x25, 0x26, 0xac, 0xfe, 0x88,
+  0xec, 0xfc, 0x81, 0xab, 0x16, 0x28, 0x11, 0x7f, 0x85, 0xbf, 0x45, 0xfd,
+  0xa3, 0x1f, 0x3f, 0xf0, 0xa8, 0x5e, 0x3a, 0x85, 0xbb, 0x2a, 0xfd, 0x6b,
+  0x9f, 0x34, 0x0f, 0xb2, 0x49, 0xd5, 0xa5, 0x8a, 0x2b, 0x74, 0x9c, 0x70,
+  0x9a, 0xa2, 0x4d, 0xc4, 0xc6, 0xfe, 0xc5, 0xec, 0x26, 0x39, 0x02, 0x05,
+  0x8b, 0xbf, 0x04, 0x83, 0xfd, 0xd4, 0xb1, 0x4d, 0x67, 0x33, 0x61, 0xc7,
+  0x1d, 0x52, 0x28, 0x43, 0xbc, 0x49, 0x36, 0x71, 0xf0, 0xc6, 0xf3, 0xc2,
+  0xf8, 0x06, 0x64, 0xa7, 0xe9, 0x12, 0x5e, 0xce, 0x3d, 0x6b, 0x10, 0x45,
+  0x4a, 0x93, 0x31, 0x2d, 0xa2, 0x48, 0xc7, 0xf6, 0x15, 0xed, 0x25, 0xd3,
+  0x84, 0xb7, 0x3b, 0xed, 0xd4, 0xa8, 0xbd, 0xb8, 0x5e, 0x8a, 0xd2, 0xea,
+  0xa6, 0xd3, 0x52, 0x76, 0xfc, 0xbb, 0xef, 0x02, 0x1b, 0xa9, 0xc3, 0xa3,
+  0x25, 0x4a, 0xf7, 0xa0, 0x02, 0x6a, 0x8b, 0x14, 0x4e, 0x8f, 0x25, 0xe5,
+  0xca, 0x86, 0x79, 0x32, 0x4d, 0x80, 0x52, 0x23, 0x3a, 0x41, 0x9d, 0xe3,
+  0x5b, 0x2c, 0x2b, 0xe2, 0x1a, 0x04, 0x33, 0x3c, 0x51, 0x24, 0xa3, 0x39,
+  0xbc, 0xb0, 0xaa, 0xe1, 0xd3, 0x9d, 0xb0, 0xff, 0xee, 0xe2, 0xab, 0xd3,
+  0xf3, 0x61, 0xb4, 0x8d, 0x64, 0xc0, 0x8b, 0xf3, 0xe3, 0x2f, 0xde, 0x91,
+  0xca, 0xe4, 0x4c, 0xb7, 0x87, 0x31, 0x29, 0x53, 0x53, 0x04, 0x1c, 0x24,
+  0xf3, 0x51, 0x92, 0x5f, 0x19, 0x8e, 0x2c, 0xa7, 0xcb, 0x83, 0x09, 0x66,
+  0xb9, 0xc0, 0x06, 0xfa, 0xa2, 0x88, 0x66, 0x9a, 0xe6, 0x20, 0xa6, 0x94,
+  0xbe, 0xcb, 0xbc, 0x3a, 0x90, 0xd6, 0x72, 0x19, 0x5d, 0x29, 0xce, 0x8b,
+  0xaf, 0xf6, 0xdf, 0x7e, 0x3d, 0x34, 0x28, 0xa5, 0x6f, 0xbf, 0xfd, 0x36,
+  0xf4, 0x4c, 0xbc, 0xd8, 0xde, 0x66, 0xf0, 0x9c, 0xeb, 0xf8, 0xfe, 0x7e,
+  0x50, 0x10, 0xbf, 0x08, 0x0a, 0x6e, 0x7b, 0xb0, 0xce, 0x62, 0x49, 0xd7,
+  0x05, 0x7d, 0xbd, 0xbd, 0x58, 0x8e, 0x00, 0x0e, 0xba, 0xbd, 0x2c, 0x15,
+  0x1c, 0x9b, 0xdf, 0xde, 0xde, 0xd8, 0x18, 0x1e, 0x1d, 0x45, 0xfb, 0x27,
+  0xc3, 0xd3, 0xe0, 0xdd, 0xcd, 0xdd, 0x2d, 0xba, 0x48, 0xaf, 0x92, 0x92,
+  0x7e, 0xd9, 0xd8, 0x38, 0xd9, 0xbf, 0x80, 0x9a, 0xf0, 0xcd, 0xd1, 0xf9,
+  0xf0, 0xf8, 0xf4, 0x2d, 0xb6, 0x08, 0x99, 0xc5, 0xf1, 0x14, 0xf5, 0x60,
+  0x71, 0x73, 0x23, 0x35, 0xeb, 0xce, 0x60, 0xa9, 0x91, 0x31, 0x4f, 0x77,
+  0xbd, 0x08, 0x3e, 0xe2, 0x5e, 0xba, 0x43, 0xda, 0x77, 0x6c, 0x75, 0x5a,
+  0x4b, 0xc8, 0xea, 0xe6, 0x43, 0xdb, 0x88, 0xbc, 0xa5, 0x40, 0x90, 0x7b,
+  0x93, 0x91, 0x04, 0x7e, 0xf4, 0x04, 0x7c, 0x99, 0x63, 0x96, 0x83, 0xc4,
+  0xdb, 0xd6, 0x89, 0x0f, 0x8f, 0xdf, 0x9c, 0x91, 0xd0, 0xfc, 0x6e, 0xb8,
+  0xff, 0xe5, 0x11, 0x1e, 0xfd, 0x32, 0x29, 0xfd, 0x76, 0x08, 0x7c, 0x36,
+  0x3a, 0x79, 0x9b, 0x94, 0xc5, 0x38, 0x5e, 0x20, 0xfc, 0x98, 0xba, 0xe9,
+  0x0b, 0xd3, 0x09, 0xda, 0x16, 0xf1, 0xc9, 0xc3, 0xa8, 0xce, 0xf5, 0x79,
+  0xc6, 0x38, 0x0d, 0xdb, 0x3d, 0x3f, 0xda, 0x3f, 0x7c, 0x73, 0x64, 0x61,
+  0x41, 0x82, 0x2c, 0x46, 0x8d, 0x5e, 0x67, 0xb3, 0x24, 0xb0, 0x1d, 0x82,
+  0xf1, 0x63, 0xf1, 0xe9, 0x1b, 0x54, 0xb6, 0x6f, 0xef, 0xce, 0x6f, 0x14,
+  0x3f, 0x3b, 0xb8, 0x4c, 0xb7, 0xa5, 0x75, 0xeb, 0x2f, 0x76, 0x4b, 0x62,
+  0xf1, 0x35, 0x2a, 0x00, 0x89, 0x1a, 0xc8, 0xfa, 0xe3, 0xa7, 0x3b, 0x3b,
+  0x3b, 0x0f, 0xcc, 0x83, 0x2d, 0x75, 0x6a, 0x87, 0xa1, 0xa9, 0xbc, 0xc0,
+  0xe3, 0xdb, 0xbe, 0x7d, 0xa3, 0xcc, 0xd0, 0xee, 0x89, 0x3f, 0xa5, 0x60,
+  0x3a, 0xf0, 0x63, 0xdb, 0x07, 0x3d, 0xce, 0x32, 0xb7, 0x07, 0x95, 0xe5,
+  0xe1, 0x42, 0xd8, 0x69, 0x19, 0x80, 0xef, 0xd8, 0xd0, 0x27, 0x29, 0x9f,
+  0xf2, 0x38, 0x5f, 0xd5, 0x9b, 0xc4, 0x37, 0xd4, 0x26, 0x7e, 0x0c, 0xb2,
+  0xfc, 0x6a, 0x7b, 0xf6, 0x82, 0xa3, 0x3e, 0xe8, 0xa1, 0xd7, 0x48, 0xa2,
+  0xe6, 0x0a, 0xb5, 0x16, 0x40, 0x53, 0x60, 0x69, 0x11, 0xab, 0xf7, 0x88,
+  0x71, 0xfd, 0x8c, 0x75, 0x90, 0x3a, 0xce, 0x97, 0x36, 0x73, 0x0b, 0x2a,
+  0x68, 0xe9, 0xa4, 0xc0, 0x96, 0xc1, 0x4c, 0x33, 0x20, 0x16, 0x42, 0xbd,
+  0xd0, 0xe7, 0x42, 0x24, 0xf4, 0x6b, 0x4e, 0x44, 0x33, 0x28, 0xef, 0x99,
+  0x87, 0x02, 0x9d, 0x53, 0xcd, 0xad, 0xcc, 0xb6, 0xc2, 0x82, 0xde, 0xdc,
+  0xc3, 0x1d, 0x17, 0x16, 0x73, 0x31, 0x55, 0x1c, 0xf1, 0x8c, 0x86, 0xeb,
+  0x7d, 0xf6, 0xfb, 0x4c, 0x41, 0x85, 0xa3, 0x97, 0x47, 0x74, 0x1e, 0x4c,
+  0x4a, 0x56, 0x7f, 0xae, 0xec, 0x39, 0xa0, 0x1e, 0xd4, 0x11, 0x6f, 0xf4,
+  0xc5, 0xc8, 0x1d, 0x39, 0x87, 0x6e, 0x15, 0xd2, 0x1d, 0xc3, 0xef, 0x0f,
+  0x92, 0xfb, 0x18, 0xb9, 0x34, 0xdc, 0x17, 0xed, 0xc9, 0x36, 0xc7, 0x94,
+  0x3c, 0xba, 0xa7, 0x83, 0x33, 0x87, 0xe6, 0x4f, 0x2b, 0x70, 0x8b, 0x25,
+  0xb8, 0x49, 0x78, 0xf6, 0xa1, 0xd0, 0xf8, 0xc0, 0x60, 0x5e, 0xd0, 0x2a,
+  0xe0, 0x8d, 0xff, 0xb9, 0x3d, 0x28, 0x8a, 0xeb, 0xed, 0x74, 0xf2, 0x7e,
+  0x52, 0xc4, 0xf4, 0x19, 0xf1, 0xb5, 0xc6, 0xc7, 0x03, 0xfa, 0x30, 0xfa,
+  0xd1, 0x35, 0xf5, 0xff, 0x15, 0xe3, 0xf6, 0x69, 0xfc, 0xcf, 0x6d, 0xc0,
+  0xc9, 0x30, 0xe0, 0x25, 0xaf, 0xda, 0xc6, 0xe1, 0xe9, 0xb7, 0x6f, 0x4f,
+  0x4e, 0xf7, 0x0f, 0xa3, 0x8b, 0x53, 0x52, 0xe6, 0xa0, 0x8a, 0xb7, 0x9c,
+  0x43, 0x06, 0xfa, 0x28, 0x33, 0xb9, 0x76, 0x42, 0xb3, 0x5d, 0x63, 0xf4,
+  0x52, 0x5c, 0x97, 0x73, 0xdd, 0xaf, 0xcb, 0xd9, 0x87, 0x99, 0xcb, 0x63,
+  0x3a, 0xe9, 0xb9, 0xda, 0xa3, 0xcd, 0x6a, 0xa3, 0x89, 0x95, 0xf4, 0xa8,
+  0xd6, 0x32, 0x75, 0x91, 0x67, 0x9b, 0xe2, 0x68, 0xf5, 0xb1, 0x79, 0x82,
+  0x04, 0x5f, 0x04, 0x72, 0x7f, 0x08, 0x42, 0xad, 0x6e, 0x39, 0xa9, 0x41,
+  0x49, 0xf7, 0xf7, 0x56, 0x63, 0x82, 0xa7, 0x6b, 0xa7, 0x84, 0x4a, 0xc8,
+  0xf7, 0x3c, 0xeb, 0xea, 0x21, 0x16, 0xf0, 0x1a, 0x3f, 0x3b, 0x86, 0xac,
+  0x30, 0x6d, 0x25, 0xcd, 0x6d, 0xc8, 0xec, 0x9d, 0x6d, 0xe9, 0x0e, 0xfd,
+  0xd8, 0xd9, 0xf6, 0x5d, 0xe0, 0x9b, 0xf0, 0x4a, 0xd8, 0x76, 0xd6, 0x15,
+  0x19, 0xc0, 0xbb, 0xe1, 0xf1, 0xdb, 0x2f, 0xd9, 0x7d, 0xf2, 0xed, 0xe9,
+  0xf9, 0xe1, 0x90, 0x9a, 0xc5, 0x5d, 0xb9, 0xc1, 0x0a, 0x36, 0xa3, 0x23,
+  0xc9, 0xa8, 0x84, 0x40, 0xd1, 0xf5, 0x9f, 0x58, 0xcc, 0x9e, 0xf8, 0xa4,
+  0x02, 0x1e, 0x66, 0x20, 0x30, 0x01, 0x64, 0xa3, 0x9d, 0xfd, 0x30, 0xad,
+  0xca, 0xeb, 0x9f, 0xcf, 0x62, 0x20, 0x03, 0x26, 0x03, 0x01, 0xd2, 0x61,
+  0x9f, 0xf8, 0x36, 0x12, 0xfb, 0xb7, 0x21, 0xb7, 0x6d, 0x97, 0x19, 0x1f,
+  0x64, 0x6e, 0x25, 0xcb, 0x1d, 0x96, 0x62, 0x65, 0x45, 0x70, 0x02, 0x2e,
+  0xa7, 0xf1, 0x15, 0x77, 0xd8, 0x3c, 0x1c, 0x41, 0x67, 0xda, 0xfd, 0x63,
+  0xbb, 0x04, 0xff, 0xe1, 0xf6, 0x8e, 0x4b, 0x97, 0x80, 0xca, 0xc8, 0x21,
+  0x6a, 0xf7, 0x15, 0xf9, 0x85, 0x01, 0xfd, 0xe1, 0x41, 0x06, 0xc0, 0x7a,
+  0x1d, 0xf4, 0x51, 0xeb, 0xdc, 0x6c, 0x88, 0xd2, 0xdc, 0x0f, 0x72, 0x57,
+  0x44, 0xb4, 0x45, 0x4b, 0x81, 0x9e, 0x58, 0x70, 0xcc, 0x35, 0xf7, 0xe9,
+  0xb3, 0x71, 0x64, 0xc9, 0x31, 0x18, 0x1a, 0x3b, 0x84, 0x04, 0x4d, 0xd3,
+  0x50, 0x81, 0xaa, 0x03, 0xc4, 0xcd, 0x74, 0x9c, 0x96, 0x1d, 0xe6, 0x95,
+  0xac, 0x53, 0x1b, 0xd6, 0x8a, 0xf7, 0xef, 0x14, 0x25, 0x0d, 0x25, 0x26,
+  0xde, 0xae, 0xc5, 0xf7, 0x34, 0x55, 0x2e, 0x9b, 0xcd, 0x24, 0x5d, 0xac,
+  0x83, 0x94, 0x01, 0xdf, 0x4a, 0xaa, 0xe9, 0x2e, 0x0e, 0xaf, 0x1d, 0x5c,
+  0x10, 0xbd, 0x0b, 0x8a, 0x90, 0x44, 0x7c, 0x1b, 0xc3, 0xf5, 0x66, 0x0d,
+  0x98, 0x21, 0x79, 0xf4, 0x07, 0x21, 0xe4, 0xbc, 0xa0, 0x27, 0x35, 0x41,
+  0x51, 0x53, 0xad, 0x07, 0x4b, 0xc4, 0xc2, 0x41, 0x7d, 0xcb, 0xc2, 0x25,
+  0xe2, 0x30, 0x28, 0x69, 0xec, 0xaa, 0x0d, 0xb4, 0x91, 0x92, 0x9e, 0xaa,
+  0xf5, 0xb4, 0xf4, 0x61, 0x32, 0x6a, 0x0e, 0xc9, 0xc4, 0xca, 0xe9, 0x4a,
+  0x76, 0x3a, 0xd0, 0xff, 0x5a, 0x09, 0x4a, 0x07, 0xf1, 0xa8, 0x8e, 0x79,
+  0xae, 0x8c, 0x10, 0x57, 0x88, 0xc1, 0xca, 0x47, 0x31, 0x88, 0x8f, 0x8c,
+  0x23, 0x92, 0x5b, 0x40, 0xca, 0x2a, 0x28, 0x54, 0xbc, 0x99, 0x12, 0x0e,
+  0xf9, 0x22, 0xfa, 0x22, 0x2e, 0xd2, 0x71, 0x2f, 0x3a, 0x4c, 0x49, 0x1a,
+  0x2c, 0x7b, 0x1e, 0x4a, 0xca, 0x01, 0x70, 0x0d, 0xa2, 0x6f, 0xad, 0x50,
+  0x0e, 0x31, 0x76, 0x8e, 0xd1, 0x63, 0xdb, 0x8f, 0xcb, 0x8d, 0xd9, 0x10,
+  0xb3, 0x9a, 0x1a, 0xc6, 0xc2, 0x3c, 0x14, 0x6e, 0xdb, 0x23, 0xe4, 0xf0,
+  0x66, 0xc6, 0xa4, 0x96, 0x56, 0x70, 0x63, 0xe5, 0xde, 0x2e, 0x60, 0xe0,
+  0xc1, 0x25, 0xcb, 0xeb, 0x3b, 0x57, 0x10, 0x70, 0x65, 0xb0, 0xfc, 0xb7,
+  0xc3, 0xec, 0x30, 0x0c, 0x66, 0x56, 0xc2, 0x0b, 0x8d, 0x6c, 0x30, 0x67,
+  0x1c, 0x73, 0x54, 0x23, 0xb9, 0x0d, 0x0e, 0xc1, 0xa5, 0x75, 0xc2, 0x8a,
+  0xe8, 0x99, 0x38, 0xbd, 0x38, 0xfa, 0x5d, 0x34, 0x4c, 0x01, 0x27, 0xed,
+  0x28, 0x07, 0x84, 0x0a, 0x7f, 0xa4, 0x3a, 0x0a, 0x1a, 0x7b, 0xea, 0xf2,
+  0xe1, 0xd4, 0x7e, 0x63, 0x31, 0xe3, 0x52, 0x5a, 0x20, 0x80, 0xc2, 0x61,
+  0x9a, 0xbd, 0x4d, 0xe3, 0xc8, 0xd5, 0x72, 0xc3, 0xdc, 0xdf, 0x03, 0x3d,
+  0xe7, 0xbd, 0x47, 0x4c, 0x5d, 0xea, 0x8b, 0x0c, 0x5c, 0x83, 0x76, 0x54,
+  0xb7, 0x63, 0x75, 0x78, 0x9c, 0xe6, 0x74, 0x8d, 0xe0, 0xac, 0x8d, 0x05,
+  0x0e, 0x8c, 0xa3, 0x8d, 0x78, 0xec, 0x50, 0x56, 0xe3, 0x11, 0xd1, 0x15,
+  0x2f, 0x17, 0x0e, 0x1e, 0xbb, 0xca, 0x7c, 0x49, 0x42, 0xbb, 0xf2, 0x43,
+  0x76, 0xc0, 0x79, 0x67, 0x9c, 0xcc, 0xc3, 0xe8, 0xe5, 0x8a, 0x9c, 0xb4,
+  0xc1, 0xa1, 0x3d, 0xd4, 0x2a, 0xdf, 0x87, 0x73, 0xc7, 0x9d, 0x03, 0xe9,
+  0x01, 0x91, 0x17, 0xa0, 0xd3, 0x49, 0x34, 0x5b, 0x69, 0x56, 0xa5, 0xf2,
+  0x12, 0xe4, 0x32, 0xb0, 0x40, 0xfc, 0xe9, 0xa7, 0x8d, 0xbb, 0xe3, 0xde,
+  0x3d, 0xfd, 0x82, 0xbe, 0x0e, 0x04, 0xef, 0x29, 0xdc, 0x42, 0x56, 0x26,
+  0xc1, 0x4b, 0xdf, 0x0d, 0xa9, 0x26, 0xcc, 0x9c, 0x92, 0x0e, 0x9d, 0xb9,
+  0xa7, 0x65, 0x5f, 0x5c, 0x25, 0x88, 0x0d, 0x11, 0xeb, 0x14, 0x19, 0xb9,
+  0x10, 0xe7, 0xe2, 0x1a, 0x39, 0xc7, 0x4e, 0x5e, 0x7d, 0xb0, 0xc1, 0x25,
+  0x4b, 0x17, 0xfd, 0x00, 0xf7, 0x32, 0x64, 0x86, 0x61, 0xa6, 0x0d, 0x23,
+  0x36, 0x5f, 0x07, 0xe3, 0x70, 0x96, 0x6a, 0x20, 0xcc, 0x0e, 0x01, 0xd8,
+  0x71, 0xbd, 0xfe, 0xbb, 0xf5, 0xc3, 0x79, 0xf7, 0x4b, 0x86, 0x33, 0x6e,
+  0xf2, 0x45, 0x2d, 0xdb, 0x88, 0xa5, 0x09, 0xca, 0x92, 0x49, 0xb9, 0x57,
+  0x64, 0x83, 0x58, 0x31, 0x48, 0xc1, 0x20, 0x97, 0x72, 0x67, 0x20, 0x2d,
+  0x24, 0x0a, 0x70, 0x4b, 0x1c, 0x78, 0xd4, 0x9a, 0x78, 0x7a, 0x10, 0x30,
+  0x0e, 0xd9, 0x0e, 0x66, 0x3f, 0xa4, 0x73, 0xe5, 0xec, 0x02, 0xd6, 0xb4,
+  0x4d, 0x4d, 0x1a, 0xa2, 0x46, 0xcf, 0xf7, 0xdf, 0x7e, 0x79, 0xc4, 0xf4,
+  0x0a, 0xb6, 0xe1, 0xb3, 0xcd, 0x90, 0x03, 0xd3, 0xcf, 0xa5, 0x08, 0xf1,
+  0x9d, 0x18, 0x13, 0xe8, 0x8d, 0xc9, 0x72, 0x0c, 0x5f, 0xd8, 0x3b, 0x07,
+  0x24, 0xc5, 0xd0, 0x58, 0x53, 0xae, 0x5e, 0x0c, 0x96, 0xa1, 0x5e, 0xa7,
+  0x8d, 0xc8, 0x04, 0x78, 0xa6, 0x78, 0x5c, 0x2b, 0x99, 0x1a, 0x29, 0x8a,
+  0xe5, 0x68, 0x11, 0x6b, 0x2a, 0x46, 0x1c, 0x46, 0xf7, 0xab, 0x34, 0x36,
+  0xa8, 0x4c, 0x01, 0xbc, 0x4f, 0x0b, 0xda, 0xdb, 0xcd, 0x9f, 0xf3, 0xcd,
+  0x3f, 0x08, 0x55, 0x2b, 0x41, 0x8d, 0xd8, 0xdd, 0xd9, 0xf1, 0x40, 0x04,
+  0x3e, 0x4b, 0xa1, 0xb1, 0x8b, 0x79, 0xb4, 0xd3, 0x7f, 0xfe, 0x7c, 0xdd,
+  0x76, 0xb9, 0x46, 0x39, 0xda, 0xfc, 0xd9, 0xa3, 0xdb, 0xec, 0xe3, 0xd1,
+  0x75, 0x6d, 0xb6, 0xdc, 0x8d, 0x8c, 0x9a, 0xad, 0x1e, 0xbf, 0xc2, 0xb9,
+  0x95, 0x55, 0x0e, 0x14, 0xeb, 0x00, 0x3b, 0xe2, 0xe6, 0xee, 0x82, 0xc4,
+  0x52, 0x6e, 0x44, 0xee, 0x26, 0x63, 0x5c, 0x0d, 0x13, 0x19, 0x17, 0x70,
+  0xfa, 0xa5, 0xce, 0xd5, 0xf0, 0xa8, 0x85, 0x09, 0xae, 0xf9, 0x35, 0x4b,
+  0x74, 0xd9, 0x9c, 0x8d, 0x2a, 0xf9, 0x11, 0x49, 0x8f, 0x67, 0x50, 0x09,
+  0x48, 0x82, 0xf4, 0x72, 0xe3, 0x3b, 0x2d, 0x45, 0x03, 0x3c, 0x5c, 0x18,
+  0x7e, 0x05, 0x17, 0x30, 0x9d, 0x6b, 0x4d, 0x18, 0x5f, 0x55, 0x8d, 0xb8,
+  0x57, 0x9b, 0x06, 0xdd, 0xbf, 0x88, 0xfa, 0x01, 0x0b, 0x52, 0x70, 0x02,
+  0xf0, 0x9f, 0xd9, 0xca, 0xee, 0x54, 0xed, 0x83, 0xdb, 0x37, 0xd5, 0xbf,
+  0x52, 0xae, 0xad, 0xa7, 0x01, 0x54, 0x4c, 0x31, 0x0d, 0x16, 0xd4, 0xd2,
+  0xa5, 0x74, 0xc3, 0x2c, 0xad, 0xc6, 0x70, 0x1e, 0x37, 0x94, 0x78, 0x7d,
+  0xe5, 0x29, 0x4c, 0xb2, 0x67, 0x12, 0x61, 0x5d, 0x39, 0x51, 0xa4, 0x26,
+  0x3c, 0xc8, 0xe7, 0x25, 0x7b, 0xb1, 0x11, 0xfd, 0xab, 0x83, 0x7b, 0x60,
+  0x58, 0x38, 0x8d, 0x56, 0x2f, 0xaf, 0x36, 0xcc, 0xe0, 0x26, 0x41, 0xab,
+  0xcd, 0x25, 0xe2, 0x96, 0x64, 0x10, 0x71, 0x7b, 0xc7, 0xd2, 0x92, 0xad,
+  0x4c, 0x0b, 0xbd, 0x63, 0xcf, 0x15, 0xbd, 0xc2, 0xc5, 0x92, 0x5a, 0xa6,
+  0x35, 0x64, 0x6a, 0x66, 0x14, 0x5a, 0x79, 0xda, 0x02, 0x5c, 0x37, 0x22,
+  0x0d, 0x55, 0x66, 0x68, 0x0b, 0x10, 0x11, 0xc3, 0xba, 0x31, 0x5b, 0xbb,
+  0x61, 0x5f, 0xed, 0xa5, 0xe6, 0x6f, 0x33, 0x44, 0xf8, 0x31, 0x07, 0x9b,
+  0xc3, 0x68, 0xeb, 0x13, 0xe2, 0xf3, 0xe5, 0x5c, 0x66, 0xc1, 0xd9, 0xe5,
+  0x34, 0xf8, 0xb8, 0xb8, 0x66, 0x17, 0x9e, 0xab, 0x68, 0xd2, 0xb4, 0x2a,
+  0x84, 0x49, 0xdd, 0xc4, 0xe4, 0x85, 0xc3, 0x33, 0x43, 0xad, 0x2c, 0x45,
+  0x75, 0x05, 0x02, 0x51, 0xf8, 0xb1, 0xc7, 0x00, 0xdc, 0x62, 0xfd, 0x39,
+  0x68, 0x54, 0x2e, 0xaa, 0x51, 0x9f, 0xd7, 0x16, 0x38, 0xca, 0x8b, 0xdb,
+  0x92, 0x5b, 0x98, 0xc1, 0xff, 0xb8, 0xdc, 0x0b, 0x67, 0xd0, 0xd5, 0x96,
+  0x90, 0xc5, 0x30, 0x2e, 0xa1, 0x25, 0x19, 0x75, 0xc6, 0x61, 0x35, 0xcd,
+  0x88, 0x75, 0x00, 0x05, 0xec, 0x84, 0x50, 0x2b, 0xd1, 0x5a, 0x40, 0xa1,
+  0x95, 0x18, 0x22, 0x36, 0x6f, 0x02, 0xfb, 0x33, 0x93, 0x3e, 0x79, 0x86,
+  0x32, 0x40, 0x89, 0x25, 0xe7, 0x02, 0x5d, 0xa7, 0xc3, 0x0b, 0xc8, 0x87,
+  0x2c, 0xcf, 0x9a, 0x08, 0xf3, 0xcd, 0xd1, 0xf9, 0x17, 0xa7, 0xc3, 0xa3,
+  0x68, 0x3b, 0x3a, 0x3c, 0xfa, 0xe2, 0x1d, 0xd8, 0x06, 0x76, 0xcc, 0xb9,
+  0x63, 0x0a, 0x05, 0x35, 0xe4, 0x7c, 0x01, 0x27, 0xde, 0x49, 0xd2, 0x53,
+  0xcf, 0x28, 0x43, 0x23, 0x46, 0x54, 0x00, 0x44, 0xc9, 0x57, 0x6c, 0x74,
+  0xca, 0xb1, 0x3a, 0x3e, 0xa9, 0x1f, 0x62, 0xdf, 0x1c, 0x80, 0x7e, 0xa5,
+  0x21, 0x68, 0x1b, 0xca, 0x5d, 0xf1, 0xc2, 0x8b, 0x75, 0xb7, 0xa2, 0x42,
+  0xea, 0xd1, 0xf0, 0x78, 0xf6, 0x86, 0x5c, 0x3f, 0x08, 0xca, 0xbe, 0x29,
+  0x58, 0xe4, 0x34, 0x93, 0x8b, 0x0b, 0x99, 0x02, 0x5a, 0xd6, 0x1c, 0x49,
+  0x6b, 0x5c, 0x4c, 0x47, 0xf1, 0xb8, 0x14, 0x45, 0xbe, 0x10, 0x82, 0x23,
+  0x8e, 0x23, 0xf1, 0xdc, 0x56, 0x9d, 0x96, 0x19, 0x52, 0x91, 0x48, 0x4e,
+  0xa2, 0x5c, 0x9c, 0x6a, 0x03, 0x15, 0x7f, 0xb8, 0x02, 0x4d, 0x6d, 0xe2,
+  0x48, 0x20, 0x2b, 0xd8, 0x95, 0xe8, 0xde, 0x30, 0xb0, 0x75, 0x7a, 0x75,
+  0x8c, 0x8a, 0x9e, 0xbc, 0xf2, 0x5b, 0x83, 0x3a, 0xe9, 0xdc, 0xae, 0x67,
+  0x0c, 0x17, 0x32, 0x53, 0xa4, 0x8f, 0xc9, 0x5d, 0x1c, 0xe6, 0x8f, 0x87,
+  0xc9, 0x0f, 0x70, 0xfb, 0x3b, 0x6c, 0x19, 0x39, 0x4f, 0x08, 0xbb, 0x09,
+  0x84, 0xb7, 0xf5, 0xf0, 0xec, 0xa6, 0xe6, 0x6a, 0xb0, 0x40, 0x3d, 0xed,
+  0x11, 0x4b, 0x91, 0x5d, 0xf1, 0x96, 0xb2, 0xee, 0x1e, 0xd5, 0xcb, 0x79,
+  0xe9, 0x19, 0x94, 0xd6, 0x05, 0x99, 0xbd, 0xbc, 0x2f, 0x43, 0x0b, 0x07,
+  0x71, 0xc9, 0x8d, 0xc3, 0xa3, 0x8b, 0xfd, 0xe3, 0x93, 0xa3, 0xc3, 0xe8,
+  0xf8, 0xed, 0xeb, 0xd3, 0xf3, 0x37, 0xfb, 0x17, 0x6a, 0x82, 0x3f, 0x74,
+  0xfa, 0x95, 0x43, 0x10, 0x37, 0x5c, 0xfd, 0x40, 0xf7, 0x62, 0x1a, 0xa6,
+  0x6d, 0xbc, 0x52, 0x50, 0x0d, 0x59, 0x87, 0xa4, 0xb2, 0x08, 0x1b, 0x91,
+  0x9a, 0xee, 0x3d, 0x26, 0x38, 0xee, 0xe6, 0x6d, 0x67, 0x6e, 0x1d, 0xd8,
+  0x7a, 0x9a, 0x76, 0xc4, 0xf5, 0xc4, 0x1f, 0x6c, 0xca, 0xd5, 0xc5, 0x90,
+  0x7b, 0x8a, 0xa1, 0x62, 0x39, 0xc8, 0x9e, 0x89, 0xb2, 0x7f, 0x8c, 0xfc,
+  0x35, 0x4e, 0xbd, 0xd7, 0xfa, 0x95, 0xc7, 0xa5, 0x2b, 0xd2, 0x03, 0x7a,
+  0x41, 0x3b, 0x0e, 0x91, 0x93, 0x49, 0x90, 0x2b, 0xe4, 0x05, 0x6d, 0xba,
+  0x74, 0x07, 0x03, 0xfd, 0x96, 0x58, 0x1e, 0xfe, 0x24, 0xdc, 0x60, 0x24,
+  0x76, 0x6f, 0xc0, 0xdb, 0x59, 0xaa, 0xe7, 0xe8, 0xbe, 0x4c, 0xe6, 0xae,
+  0x34, 0xec, 0x6b, 0x6d, 0xc4, 0x73, 0x51, 0xb3, 0xa3, 0x29, 0x0a, 0x54,
+  0xd8, 0xd4, 0xa6, 0x33, 0xd1, 0x92, 0xd4, 0xd2, 0x3f, 0x26, 0x8a, 0xc5,
+  0x7c, 0xb0, 0x16, 0x80, 0xf3, 0xc3, 0xcf, 0xb9, 0x4f, 0xdd, 0x55, 0x87,
+  0xb0, 0x17, 0xb6, 0x83, 0x12, 0x04, 0x7a, 0xdc, 0xfc, 0xc1, 0x2d, 0x8c,
+  0xd4, 0x0e, 0xe9, 0x21, 0x94, 0x87, 0xea, 0x6b, 0xf7, 0x56, 0x59, 0x16,
+  0xc2, 0x91, 0x6d, 0xa1, 0x08, 0x4e, 0x2c, 0x10, 0x8c, 0x88, 0x51, 0xb1,
+  0x30, 0x85, 0x35, 0x90, 0x79, 0x30, 0x81, 0x97, 0x66, 0xb4, 0x83, 0x06,
+  0xe0, 0xed, 0x6c, 0xae, 0x5e, 0x42, 0xa3, 0xf4, 0xa3, 0xab, 0xd5, 0x31,
+  0x74, 0xcf, 0xf2, 0x4a, 0x06, 0x2f, 0xc4, 0xde, 0x2b, 0xc5, 0xeb, 0xbf,
+  0x69, 0x48, 0xa2, 0xa0, 0x59, 0x6d, 0x50, 0x4d, 0xab, 0x4d, 0x33, 0x61,
+  0x65, 0x52, 0xe1, 0x8b, 0x55, 0x3f, 0x4e, 0xc8, 0xea, 0xad, 0x6b, 0x1e,
+  0xfd, 0xa4, 0x6d, 0x04, 0xca, 0xc6, 0xb9, 0x6c, 0x17, 0x51, 0x15, 0x70,
+  0x52, 0x63, 0xf6, 0x67, 0x20, 0x23, 0x7b, 0x43, 0x93, 0xae, 0x95, 0x55,
+  0xb2, 0xe9, 0x2a, 0xcc, 0xb5, 0x1b, 0xa3, 0xdc, 0x03, 0x0a, 0x58, 0x68,
+  0x69, 0x97, 0x20, 0x54, 0x35, 0x7a, 0xc3, 0xb6, 0x7a, 0x2d, 0xb2, 0x0a,
+  0xae, 0x37, 0xdf, 0x30, 0x30, 0x29, 0x7b, 0x69, 0xac, 0x02, 0x28, 0xb3,
+  0x7f, 0xc9, 0xb9, 0x64, 0x2e, 0x0f, 0x67, 0x0f, 0x0a, 0xba, 0xb2, 0x0d,
+  0x01, 0xba, 0xb0, 0x5c, 0x1a, 0x4c, 0x02, 0x3c, 0x57, 0x87, 0xda, 0xc2,
+  0xb7, 0x8f, 0x2f, 0x17, 0xd8, 0x97, 0xd4, 0xf4, 0x18, 0x49, 0x2b, 0x76,
+  0x28, 0x24, 0x76, 0xc6, 0xb5, 0xc2, 0x97, 0x1d, 0x72, 0x41, 0xf3, 0x29,
+  0x07, 0x42, 0x68, 0x50, 0xce, 0x59, 0x56, 0xc8, 0x79, 0x63, 0x29, 0xbb,
+  0xe3, 0x01, 0x97, 0x3b, 0x8b, 0x6b, 0xea, 0xa3, 0x13, 0x5d, 0x41, 0x4f,
+  0x19, 0xd1, 0xd0, 0x1b, 0x1c, 0x74, 0x22, 0x8f, 0xbf, 0x3a, 0x8f, 0x2f,
+  0xe3, 0x64, 0xfa, 0xfb, 0xbd, 0x9d, 0x61, 0x7c, 0xb5, 0x9c, 0xc6, 0x7f,
+  0xe0, 0x17, 0x5f, 0x3d, 0x79, 0xb2, 0xb7, 0xf3, 0xc9, 0xa7, 0x3b, 0x9d,
+  0xc0, 0x90, 0x5e, 0xf3, 0xc2, 0xb1, 0x53, 0x85, 0xcb, 0x30, 0x82, 0xf1,
+  0x72, 0x3f, 0x83, 0xf1, 0x55, 0x8a, 0x6e, 0xbe, 0x82, 0xf4, 0xa2, 0x6b,
+  0x10, 0x73, 0x84, 0xb8, 0xf0, 0x49, 0x2d, 0xc5, 0x40, 0x57, 0x2e, 0xd1,
+  0xf5, 0x47, 0xbb, 0x2f, 0x84, 0x95, 0x5d, 0xb1, 0x4d, 0x25, 0x16, 0x8a,
+  0x8d, 0x5e, 0xa6, 0x73, 0xba, 0x82, 0x3e, 0x8b, 0xca, 0xf8, 0xca, 0xd1,
+  0x2a, 0xb7, 0xe0, 0x2a, 0x34, 0x9a, 0x25, 0xf2, 0x32, 0xe5, 0xd2, 0x73,
+  0x03, 0x14, 0x62, 0x66, 0x5c, 0x21, 0x96, 0x7c, 0x16, 0x49, 0x3e, 0x95,
+  0xac, 0xb1, 0x78, 0x66, 0x11, 0x5d, 0x78, 0x1f, 0xae, 0xca, 0xc1, 0x62,
+  0xea, 0xea, 0x51, 0xb2, 0xf6, 0x95, 0x7a, 0x82, 0x9b, 0x2e, 0x0a, 0x5f,
+  0x9a, 0x40, 0xee, 0x1b, 0x01, 0x5c, 0x62, 0xc4, 0xa2, 0x98, 0x16, 0x8b,
+  0x61, 0x97, 0x3b, 0x3c, 0xab, 0x9e, 0xc3, 0x38, 0xef, 0x4f, 0x6c, 0xa6,
+  0x03, 0xfe, 0x9d, 0x0b, 0xc3, 0xc4, 0x02, 0xe0, 0xda, 0x59, 0x48, 0xfa,
+  0x81, 0xc3, 0xd5, 0xd6, 0x94, 0xc1, 0xca, 0xbc, 0x62, 0xef, 0x70, 0x8f,
+  0x5e, 0x9a, 0x82, 0xbb, 0xfb, 0xd9, 0x2b, 0x26, 0x88, 0xdd, 0xcf, 0xfe,
+  0xe0, 0x3e, 0xdb, 0xd3, 0xcf, 0xf6, 0x3e, 0xfb, 0xc3, 0x60, 0xc0, 0xe3,
+  0x03, 0x85, 0x74, 0xed, 0xeb, 0xae, 0xe6, 0x34, 0xc5, 0x7a, 0x84, 0xe5,
+  0x2f, 0x87, 0xae, 0x21, 0x7b, 0xdd, 0xb1, 0x9e, 0xc3, 0x55, 0xee, 0xa9,
+  0xed, 0xd3, 0xf1, 0xad, 0xd4, 0x00, 0x1c, 0x19, 0x09, 0xad, 0x68, 0x5b,
+  0x74, 0x67, 0xde, 0xe2, 0x76, 0x0a, 0x07, 0x4b, 0x10, 0x47, 0x7f, 0x04,
+  0xa5, 0xfe, 0x71, 0x83, 0xf1, 0x63, 0xe0, 0xf0, 0xa2, 0xed, 0xe0, 0x0a,
+  0x41, 0x91, 0x91, 0xad, 0x14, 0x52, 0x15, 0x54, 0x24, 0xb4, 0x8c, 0x10,
+  0x2e, 0x5c, 0x82, 0x01, 0xae, 0xf4, 0x9f, 0x14, 0xda, 0x43, 0x36, 0x1c,
+  0xfc, 0x8c, 0x83, 0xa5, 0x25, 0xe9, 0x40, 0x20, 0xa4, 0x75, 0xb3, 0x7e,
+  0xff, 0xdd, 0x77, 0x2a, 0x4f, 0xd1, 0x2f, 0x3a, 0xee, 0x6b, 0xe2, 0x44,
+  0x13, 0x62, 0x6e, 0x00, 0xc9, 0xa6, 0xc6, 0x05, 0x0c, 0x5c, 0x6f, 0xfc,
+  0x4b, 0x9d, 0xa7, 0x34, 0x42, 0x1b, 0x2b, 0x15, 0xfa, 0x30, 0x32, 0x5e,
+  0xd2, 0x23, 0x61, 0x62, 0x4c, 0x99, 0x9b, 0xec, 0x8a, 0xf1, 0x8e, 0xe8,
+  0x90, 0xf0, 0xb1, 0x73, 0xbc, 0xe9, 0x4c, 0xfb, 0xd4, 0x98, 0xa9, 0xc0,
+  0xba, 0x91, 0x4c, 0xb1, 0x22, 0xe4, 0xbc, 0xea, 0xc8, 0x83, 0x57, 0x69,
+  0x47, 0x8d, 0x93, 0xf2, 0x49, 0xc7, 0xa7, 0xa8, 0xc9, 0x6e, 0xf0, 0x96,
+  0xbd, 0x12, 0xc9, 0x29, 0xfd, 0x7b, 0xf2, 0x6a, 0x77, 0xa7, 0xfd, 0x09,
+  0x28, 0x46, 0x5c, 0xd9, 0xf8, 0x95, 0x37, 0xee, 0x3e, 0xf4, 0x7c, 0x3a,
+  0x91, 0xa7, 0xb5, 0xbe, 0x0f, 0xe3, 0x9a, 0xbf, 0xea, 0x8c, 0x70, 0xbf,
+  0xe2, 0xff, 0xd7, 0x8c, 0x83, 0x43, 0x4e, 0xf4, 0xd9, 0x62, 0x39, 0x9a,
+  0xa5, 0x95, 0x01, 0x6f, 0x63, 0x82, 0x9f, 0xb1, 0x39, 0x25, 0x71, 0xb4,
+  0xc1, 0xe5, 0xdf, 0x44, 0xf4, 0xeb, 0x5e, 0x66, 0xd9, 0x28, 0xce, 0xbb,
+  0x6a, 0x00, 0xb4, 0x71, 0x76, 0x77, 0xf7, 0x9e, 0x3c, 0x7d, 0xd6, 0x1d,
+  0xa8, 0x98, 0xc6, 0x0c, 0x82, 0x75, 0xb4, 0x54, 0x75, 0x19, 0x69, 0x22,
+  0x96, 0xe3, 0x19, 0xd6, 0x8c, 0x6d, 0x35, 0x94, 0x83, 0x87, 0xa1, 0xbb,
+  0x57, 0xd2, 0xdb, 0x1f, 0xd0, 0xcf, 0x2b, 0xee, 0xe2, 0x0f, 0xe9, 0xe4,
+  0x95, 0x9b, 0xe1, 0x1f, 0x30, 0x97, 0x57, 0x3a, 0x09, 0xda, 0x57, 0x8b,
+  0xd3, 0x2d, 0x42, 0x24, 0xde, 0x0f, 0x6d, 0xae, 0x6d, 0xe2, 0x06, 0x4f,
+  0x9a, 0x3d, 0x0d, 0xfd, 0x89, 0x58, 0x1d, 0x59, 0x58, 0xf5, 0x71, 0xaa,
+  0xdb, 0xf7, 0x7d, 0x6a, 0xa5, 0x8f, 0x56, 0xfa, 0x9e, 0x5d, 0x47, 0x33,
+  0x04, 0xa5, 0x63, 0x23, 0x7a, 0x1a, 0xac, 0x3c, 0x65, 0x3b, 0x87, 0x0a,
+  0x02, 0x59, 0xc6, 0xb1, 0xaf, 0x07, 0x5f, 0x1e, 0x77, 0xd5, 0x41, 0x26,
+  0x9a, 0x5b, 0xaf, 0xcd, 0xb0, 0xe6, 0x7c, 0xca, 0x9a, 0x69, 0xbc, 0x61,
+  0xd5, 0x69, 0x63, 0xf8, 0x7b, 0xd0, 0xaf, 0xe4, 0x15, 0xa0, 0xfa, 0xb5,
+  0xdc, 0x39, 0x74, 0x2d, 0x32, 0x52, 0x09, 0x40, 0x0d, 0x83, 0x66, 0x18,
+  0xbb, 0x41, 0x1c, 0x3f, 0xac, 0x1b, 0x7b, 0x98, 0xc4, 0xfe, 0x6b, 0x67,
+  0xc9, 0x76, 0x41, 0xb0, 0xfa, 0x28, 0x7d, 0x25, 0xdc, 0xc4, 0x18, 0x44,
+  0xc7, 0x55, 0x7d, 0x10, 0x4a, 0x08, 0x79, 0x07, 0xdb, 0xe1, 0x47, 0x49,
+  0xa5, 0x96, 0x80, 0x88, 0x85, 0xe0, 0x9e, 0x2f, 0x5d, 0x99, 0x80, 0xcf,
+  0x22, 0x86, 0x3d, 0x96, 0xb7, 0x34, 0xcc, 0xb5, 0x52, 0x6a, 0x8d, 0x5f,
+  0x52, 0xed, 0xc0, 0x59, 0xed, 0x03, 0xaf, 0x99, 0x8a, 0x05, 0xd2, 0x82,
+  0x4c, 0x74, 0xb4, 0x52, 0x4b, 0x00, 0x5a, 0xe8, 0xfe, 0x99, 0x0f, 0xc1,
+  0x4b, 0x6c, 0x03, 0x7f, 0xfd, 0x59, 0x57, 0xcc, 0x77, 0x95, 0x52, 0xc9,
+  0x35, 0xaf, 0x80, 0x10, 0x68, 0x38, 0x9f, 0xec, 0xd2, 0x41, 0x36, 0x88,
+  0x2c, 0x86, 0x1c, 0x36, 0x46, 0xd5, 0x27, 0x59, 0x6a, 0x3a, 0xd1, 0x4a,
+  0x26, 0x2a, 0x0b, 0xf5, 0xb4, 0xf1, 0x04, 0x61, 0xbf, 0x90, 0x1d, 0xbb,
+  0x08, 0x4f, 0xe0, 0xf7, 0xba, 0x3e, 0x33, 0x3a, 0x63, 0xb5, 0x0a, 0xe6,
+  0x82, 0xc4, 0xaa, 0x7c, 0x6c, 0x68, 0xbe, 0xbf, 0x97, 0xe5, 0xc3, 0x89,
+  0x15, 0x81, 0xe8, 0xe0, 0x43, 0x81, 0x25, 0xc5, 0xb1, 0x71, 0x44, 0x5e,
+  0x23, 0xce, 0x5e, 0x3b, 0x7d, 0x85, 0xe5, 0xde, 0x1d, 0x5c, 0xa5, 0x97,
+  0xb2, 0x18, 0xc4, 0x22, 0xaf, 0x92, 0x6d, 0xfa, 0x13, 0x75, 0x84, 0xf7,
+  0x20, 0x93, 0xe1, 0x97, 0x27, 0xec, 0x37, 0x0d, 0x6f, 0xfe, 0xe0, 0x6c,
+  0xb8, 0x73, 0x81, 0x5f, 0x52, 0x77, 0xe3, 0x2b, 0x36, 0xa1, 0x8e, 0x92,
+  0xc9, 0xbc, 0x09, 0x4e, 0x18, 0x96, 0xe7, 0x96, 0x8a, 0xdf, 0x90, 0x1a,
+  0x0a, 0x1f, 0x04, 0xa4, 0x4e, 0x31, 0x15, 0xd3, 0x21, 0x75, 0xa7, 0x6a,
+  0x31, 0x41, 0x94, 0x1f, 0xdf, 0xab, 0xc9, 0xdd, 0x56, 0x2f, 0x0c, 0xad,
+  0xb0, 0xc2, 0x57, 0xae, 0x32, 0x1f, 0x67, 0xf4, 0xa1, 0xfb, 0x4d, 0x2d,
+  0x27, 0x11, 0x04, 0xe3, 0xf3, 0x36, 0xa7, 0xf5, 0x1d, 0xac, 0x56, 0x64,
+  0x10, 0x87, 0x7b, 0x5a, 0x94, 0x5b, 0x5c, 0x25, 0x79, 0x5a, 0xb0, 0xaa,
+  0xae, 0xe5, 0xb7, 0xfd, 0xba, 0x5b, 0x26, 0x3c, 0x77, 0xd5, 0x45, 0x89,
+  0x88, 0x6d, 0xf6, 0x65, 0x08, 0x6f, 0x3b, 0x9a, 0x09, 0x4c, 0x2e, 0x93,
+  0xed, 0xb4, 0x2f, 0xf7, 0xa5, 0x0a, 0x41, 0xfd, 0xd7, 0x83, 0xe8, 0x84,
+  0x03, 0x83, 0x8a, 0x58, 0x12, 0x17, 0xed, 0x4e, 0x35, 0x0a, 0x20, 0x72,
+  0x11, 0xa9, 0x7b, 0x43, 0x6a, 0x63, 0x20, 0x57, 0xcc, 0xc8, 0x88, 0xb1,
+  0xaa, 0xbc, 0x9e, 0x29, 0x12, 0x85, 0x4a, 0x20, 0x3d, 0xb6, 0x40, 0xbb,
+  0xe7, 0xb8, 0x52, 0x0a, 0x3f, 0xc5, 0x65, 0x79, 0x3d, 0x91, 0x06, 0x8d,
+  0xb8, 0x2a, 0xbc, 0x10, 0x39, 0x03, 0x56, 0xee, 0x08, 0x5f, 0x52, 0xd2,
+  0x12, 0xb1, 0xb3, 0x68, 0x95, 0x3d, 0xf1, 0xbf, 0x50, 0x6b, 0x4c, 0x59,
+  0x98, 0x3b, 0x48, 0xa7, 0xc3, 0x9a, 0xe2, 0x34, 0x71, 0xfa, 0xb4, 0xa2,
+  0x55, 0x6a, 0xcc, 0x9d, 0xc2, 0x02, 0x88, 0x80, 0xe1, 0xb1, 0xd7, 0x30,
+  0x48, 0x8c, 0x2b, 0xbe, 0xa5, 0x5f, 0x70, 0xc9, 0x8f, 0x72, 0xda, 0x69,
+  0x04, 0xbb, 0x62, 0x65, 0xa4, 0x98, 0xaf, 0xd6, 0xbb, 0x15, 0xc5, 0xe4,
+  0xcd, 0x49, 0x64, 0x09, 0xa0, 0x97, 0x5e, 0x38, 0xb4, 0xa8, 0x09, 0x9e,
+  0xa2, 0x1a, 0x43, 0x44, 0x02, 0xd2, 0xa7, 0xe4, 0x66, 0x93, 0xb5, 0x45,
+  0x0e, 0x49, 0x84, 0xc5, 0xa9, 0x1c, 0xd3, 0xe0, 0x09, 0x79, 0x15, 0xb4,
+  0x43, 0xa4, 0xd1, 0xc5, 0x12, 0x74, 0x7b, 0x51, 0x17, 0x43, 0xc5, 0x17,
+  0x5d, 0x5e, 0x4f, 0xfe, 0x38, 0x58, 0xbe, 0xee, 0xa0, 0xe5, 0xe4, 0xe1,
+  0x99, 0x57, 0x9f, 0x57, 0x56, 0x89, 0x3f, 0xb7, 0xa6, 0x5e, 0x49, 0x2c,
+  0x61, 0x43, 0xca, 0xb6, 0x77, 0x83, 0xf6, 0x5f, 0x1d, 0x50, 0x2b, 0x52,
+  0x8b, 0x44, 0xf6, 0x84, 0x05, 0x6a, 0xf7, 0x59, 0xca, 0x91, 0xee, 0x8d,
+  0x86, 0x3e, 0x7c, 0x72, 0x2f, 0x8c, 0xfd, 0xb8, 0xf0, 0x0c, 0xe1, 0x68,
+  0x42, 0x02, 0xc6, 0x6d, 0x69, 0x37, 0x53, 0xd1, 0xf4, 0xee, 0x32, 0xb6,
+  0x2b, 0x30, 0x9f, 0xd9, 0x1d, 0x70, 0x14, 0x74, 0xbd, 0x34, 0x7a, 0x1a,
+  0xa8, 0xeb, 0x1d, 0x5e, 0xd0, 0x8e, 0xd9, 0x49, 0x9c, 0x12, 0x6f, 0xab,
+  0xdc, 0x34, 0x06, 0xd3, 0xd4, 0xb5, 0xc6, 0x38, 0xf1, 0xab, 0x49, 0x76,
+  0x05, 0x76, 0xd5, 0xa3, 0x9b, 0x15, 0x3f, 0x3b, 0x11, 0x3f, 0xbe, 0xa7,
+  0xfd, 0xca, 0x98, 0xf9, 0xb8, 0x88, 0xe8, 0x6e, 0x7f, 0x6b, 0x04, 0x49,
+  0xd4, 0xb2, 0x25, 0x93, 0x6c, 0xac, 0xcd, 0xbb, 0xd6, 0x65, 0x4f, 0xa8,
+  0x0b, 0xf7, 0x85, 0xef, 0x2e, 0x58, 0xa1, 0x58, 0xdb, 0x96, 0xc2, 0x30,
+  0xd3, 0xb4, 0x94, 0x3b, 0x3c, 0xb2, 0xea, 0xb7, 0x6c, 0xd8, 0x02, 0xee,
+  0xb6, 0x5c, 0x58, 0x53, 0x0d, 0xdb, 0xed, 0x7e, 0xde, 0x95, 0x68, 0xb0,
+  0xee, 0xcb, 0x2e, 0xb3, 0x2e, 0x30, 0x24, 0x43, 0x9e, 0xd4, 0x5b, 0xa9,
+  0x2b, 0xd7, 0x61, 0x5f, 0x84, 0x06, 0x2d, 0xda, 0xe3, 0x4f, 0x09, 0xdf,
+  0xc7, 0x5e, 0x7b, 0x0c, 0xa3, 0x1b, 0xd8, 0x3a, 0xe0, 0xcb, 0xd5, 0x00,
+  0x78, 0x63, 0x54, 0x8a, 0x4f, 0x55, 0x6f, 0x5b, 0x96, 0xc7, 0x38, 0x99,
+  0xb0, 0x80, 0xc7, 0x50, 0xcc, 0x9b, 0xcb, 0xf9, 0x02, 0xa9, 0x23, 0xe3,
+  0x52, 0x50, 0x57, 0xf9, 0x40, 0x0d, 0xa2, 0x77, 0x73, 0x01, 0xb8, 0x4a,
+  0xa0, 0x23, 0x87, 0x0e, 0xdf, 0x9e, 0x73, 0x5c, 0xd3, 0x4a, 0x05, 0xa7,
+  0xb7, 0x3a, 0x60, 0xb1, 0x89, 0x88, 0xf1, 0x5a, 0xfb, 0xc5, 0xfd, 0x9a,
+  0xc3, 0x9d, 0xae, 0xc6, 0x69, 0x16, 0x07, 0x5c, 0x52, 0xa1, 0x72, 0x21,
+  0xb8, 0xe7, 0x8e, 0x5e, 0x1f, 0x9d, 0x9f, 0x1f, 0x9d, 0x63, 0xbd, 0xf7,
+  0x2b, 0xd0, 0xd5, 0x8c, 0x18, 0x20, 0x69, 0x3e, 0x06, 0xc1, 0x64, 0x61,
+  0x39, 0xcd, 0x72, 0x82, 0xc2, 0x0e, 0x15, 0x33, 0x65, 0x23, 0x32, 0x47,
+  0xad, 0x64, 0xd2, 0x8a, 0x59, 0x98, 0x6d, 0x8a, 0x1c, 0x94, 0xe5, 0xec,
+  0xf7, 0x53, 0xdc, 0x2d, 0x6c, 0x75, 0xac, 0x48, 0x14, 0x1b, 0x91, 0xbd,
+  0x9a, 0x4b, 0x45, 0x03, 0xb9, 0xaf, 0x4d, 0x81, 0x0c, 0x84, 0xd3, 0x81,
+  0xc6, 0xd1, 0x24, 0xea, 0x7e, 0x9d, 0x3a, 0x9b, 0x04, 0xcf, 0xf7, 0x12,
+  0xa7, 0x14, 0xfa, 0x12, 0xaf, 0x44, 0x51, 0x2e, 0x17, 0xe9, 0xc4, 0x99,
+  0x78, 0xe9, 0x73, 0x12, 0xfa, 0x22, 0x39, 0xe7, 0x85, 0x8d, 0x98, 0xbd,
+  0x89, 0x66, 0x80, 0x08, 0x2d, 0x6c, 0x92, 0xba, 0xea, 0xed, 0x63, 0x1c,
+  0x09, 0x2d, 0xc5, 0xa2, 0x14, 0x5d, 0x96, 0x59, 0x6c, 0x83, 0x19, 0x25,
+  0x6c, 0x5a, 0x04, 0xbf, 0x30, 0x67, 0x77, 0xc8, 0x1b, 0x60, 0xbf, 0x9a,
+  0xf9, 0x68, 0x34, 0x5f, 0xc5, 0x47, 0x02, 0xc6, 0x73, 0x7f, 0x6f, 0x70,
+  0x78, 0xa7, 0x8f, 0x14, 0x13, 0xaf, 0x38, 0xcd, 0x5a, 0x57, 0x48, 0x35,
+  0x5f, 0xd2, 0xf7, 0x06, 0x08, 0xbc, 0x3a, 0x3a, 0x8f, 0xf6, 0xbf, 0x04,
+  0xa6, 0xca, 0xbf, 0xb6, 0xad, 0x78, 0x4e, 0xef, 0x05, 0xdb, 0x54, 0xcd,
+  0xf7, 0x4b, 0x26, 0x21, 0x3c, 0xf7, 0xa0, 0xb2, 0xa3, 0xa9, 0x16, 0xa2,
+  0x08, 0x2e, 0xf7, 0xea, 0xde, 0x6d, 0x44, 0x1f, 0xdc, 0xbd, 0xc7, 0xec,
+  0x1d, 0x4e, 0x56, 0xb8, 0x7b, 0x92, 0x28, 0x2c, 0xfe, 0x07, 0xdb, 0x13,
+  0x1d, 0x7d, 0xd1, 0x50, 0x32, 0x65, 0x77, 0xf6, 0xa3, 0xee, 0x9b, 0xec,
+  0xef, 0x24, 0x06, 0xc4, 0xdb, 0x4f, 0x06, 0x3b, 0xd1, 0xe6, 0xb7, 0xe9,
+  0xfc, 0xf9, 0xb3, 0x3f, 0x47, 0xc7, 0x5b, 0xdd, 0x4a, 0x88, 0x9d, 0xc0,
+  0x9e, 0x8e, 0xe2, 0xf9, 0x8d, 0xdb, 0xaa, 0x53, 0x3e, 0xce, 0x12, 0x74,
+  0x61, 0x70, 0x7f, 0x2f, 0x78, 0xef, 0xd7, 0xb6, 0x28, 0xa5, 0x03, 0x25,
+  0x5a, 0x2f, 0xfa, 0xc6, 0x41, 0x4e, 0x41, 0xa3, 0xa7, 0xa7, 0x26, 0x58,
+  0xba, 0xe7, 0xcf, 0x1a, 0x4d, 0x3c, 0x75, 0x6d, 0xbc, 0x93, 0x36, 0x7e,
+  0x66, 0x13, 0x7b, 0x83, 0x9d, 0xbd, 0x68, 0xf3, 0x74, 0xb8, 0xbd, 0xe7,
+  0x5a, 0x68, 0x36, 0xb1, 0xc7, 0x4d, 0xe0, 0xa1, 0xea, 0xcb, 0x4f, 0xd1,
+  0xff, 0x0f, 0xc9, 0xfc, 0xa7, 0x68, 0xf3, 0xbb, 0xdd, 0x5d, 0x6a, 0xe0,
+  0xcf, 0xd1, 0xfe, 0xf1, 0x77, 0xd1, 0xd3, 0x01, 0x35, 0xf6, 0x36, 0xbe,
+  0xd5, 0xe6, 0x14, 0x20, 0x66, 0xc8, 0x8d, 0xd0, 0xf7, 0x8d, 0x36, 0x9e,
+  0xd5, 0xda, 0x38, 0x21, 0x2d, 0xf0, 0x9e, 0x6e, 0x93, 0x9d, 0xc1, 0x93,
+  0xbd, 0x28, 0x7d, 0xf6, 0xe9, 0xc7, 0xd6, 0x90, 0xb6, 0xc1, 0xdf, 0x57,
+  0x2d, 0x93, 0x92, 0x42, 0x48, 0x42, 0xce, 0xd1, 0x3d, 0x71, 0x31, 0x66,
+  0x0d, 0x0c, 0x8e, 0x78, 0x1d, 0x4b, 0x2d, 0xec, 0x91, 0xa0, 0xce, 0xd3,
+  0x4e, 0x89, 0xf5, 0x1a, 0x6e, 0x08, 0x92, 0x75, 0xe9, 0xca, 0x7c, 0xd1,
+  0x18, 0x0e, 0x34, 0x51, 0x7b, 0xf4, 0xcf, 0xd1, 0x9b, 0xe1, 0xf1, 0x11,
+  0xcd, 0x68, 0x87, 0x86, 0xe6, 0xd7, 0x50, 0x06, 0xc4, 0x5f, 0xf1, 0xe2,
+  0xd2, 0xaa, 0x6e, 0x00, 0xd6, 0x82, 0xdb, 0x30, 0x09, 0x5b, 0x62, 0x91,
+  0x00, 0xcc, 0x96, 0x15, 0x05, 0xf7, 0x8b, 0x74, 0xa1, 0xfe, 0xfe, 0x15,
+  0x14, 0x06, 0xbd, 0x64, 0xd1, 0xf5, 0xd7, 0xd9, 0x9c, 0x8e, 0x49, 0x9e,
+  0xe5, 0xdb, 0xbb, 0x83, 0x9d, 0x6e, 0x45, 0x4e, 0xf8, 0xfa, 0xf0, 0x48,
+  0x72, 0x64, 0xde, 0xc4, 0x73, 0xe2, 0x8d, 0xc8, 0x18, 0x2f, 0x6e, 0xe0,
+  0x6f, 0x17, 0xdf, 0x8d, 0xbc, 0x7f, 0xb2, 0x9a, 0xdf, 0xd3, 0x3e, 0x7e,
+  0x32, 0xd8, 0x05, 0x6e, 0x15, 0x74, 0xdc, 0xd7, 0x6f, 0xe8, 0xef, 0xdd,
+  0xa7, 0xdd, 0x08, 0x5f, 0x55, 0xf5, 0x75, 0x3b, 0xaf, 0x1b, 0x07, 0xa7,
+  0xa7, 0x5f, 0x1f, 0x4b, 0xe8, 0xc5, 0x81, 0x9a, 0x50, 0x21, 0x56, 0x39,
+  0x1d, 0x58, 0xb8, 0x2a, 0xe9, 0x6a, 0x88, 0x7e, 0xb5, 0x93, 0x45, 0x2b,
+  0x79, 0x93, 0x24, 0x0b, 0x06, 0x9a, 0xaa, 0x71, 0x84, 0x52, 0x79, 0xb3,
+  0x8c, 0x0c, 0x62, 0x74, 0x3a, 0xa9, 0x66, 0xbb, 0x03, 0x8e, 0xdc, 0x99,
+  0x6b, 0x47, 0x2b, 0x97, 0x6b, 0x17, 0xfb, 0x2a, 0x50, 0x3c, 0x44, 0x17,
+  0x43, 0x68, 0xe6, 0x66, 0x29, 0xbb, 0x4a, 0x2f, 0xaa, 0xa6, 0xdb, 0x1d,
+  0x26, 0x65, 0x5f, 0x06, 0xfd, 0x42, 0x2d, 0xb4, 0x5d, 0x35, 0x37, 0x39,
+  0x63, 0xd9, 0x42, 0x51, 0x27, 0xd9, 0x4c, 0xbc, 0x5a, 0xa0, 0x58, 0xd5,
+  0xd4, 0x15, 0xf0, 0xe3, 0xd2, 0x67, 0x09, 0x07, 0x8c, 0xbd, 0xdd, 0x7f,
+  0x73, 0xf4, 0xea, 0x9b, 0xfd, 0x93, 0x77, 0x47, 0xf4, 0x0a, 0x70, 0x17,
+  0x37, 0x3d, 0x72, 0x11, 0x8f, 0x71, 0x96, 0x72, 0x19, 0xf1, 0x82, 0x64,
+  0x82, 0xee, 0x86, 0x04, 0x06, 0x46, 0x1d, 0xbc, 0xb5, 0x2b, 0xaf, 0x11,
+  0x5d, 0xe0, 0xaf, 0x3d, 0xf9, 0x6b, 0xef, 0xcf, 0x9d, 0xad, 0xca, 0xa4,
+  0x1b, 0x3a, 0x31, 0xe8, 0xe5, 0x4e, 0x22, 0xc2, 0x18, 0x44, 0x9f, 0x23,
+  0x2a, 0x65, 0x55, 0x3a, 0xe6, 0x8f, 0xb1, 0x3b, 0x0d, 0xcf, 0x6e, 0x8e,
+  0x2a, 0xc5, 0xcd, 0x3b, 0x78, 0xe9, 0x15, 0x4b, 0x15, 0x1d, 0xe4, 0x83,
+  0xa8, 0x9c, 0xc1, 0xbe, 0x6a, 0xb4, 0x61, 0x4d, 0x24, 0xf7, 0x0b, 0x04,
+  0x1e, 0x6d, 0x76, 0xe4, 0x97, 0x57, 0x87, 0xfb, 0x17, 0x47, 0x78, 0xc1,
+  0xba, 0xb7, 0x3a, 0x92, 0x06, 0xf6, 0x84, 0xf1, 0x6c, 0x76, 0xe4, 0xc3,
+  0x57, 0x98, 0x50, 0x47, 0xc0, 0xb8, 0x05, 0x42, 0xad, 0x36, 0xae, 0x6c,
+  0xae, 0xe1, 0x77, 0x41, 0x96, 0x50, 0x61, 0x11, 0x22, 0x9b, 0x1d, 0xf9,
+  0xae, 0xe3, 0xac, 0xb5, 0x5a, 0x24, 0xcd, 0x55, 0xb8, 0x8e, 0xdb, 0x52,
+  0x27, 0x04, 0x89, 0xdd, 0xef, 0x8f, 0x3a, 0x26, 0xc4, 0xbe, 0x14, 0x80,
+  0x55, 0xb9, 0x8d, 0xd7, 0x9c, 0x26, 0x58, 0x94, 0xb2, 0x6c, 0x77, 0xef,
+  0xc9, 0x9f, 0x79, 0x3d, 0x5f, 0x75, 0xb6, 0xe9, 0x6e, 0xe8, 0xfc, 0x19,
+  0x5d, 0xa7, 0x1e, 0xe5, 0xdd, 0xed, 0x07, 0x34, 0x29, 0xa5, 0x28, 0x09,
+  0x4f, 0xc1, 0xae, 0xb3, 0x25, 0x4c, 0xe6, 0xc5, 0x0b, 0x7a, 0x27, 0xb1,
+  0xdb, 0x96, 0xbf, 0x6a, 0xde, 0x7b, 0xde, 0x2f, 0xae, 0xa0, 0x34, 0x77,
+  0xe0, 0x83, 0xd2, 0x5d, 0x78, 0x7f, 0xf4, 0xe4, 0x5d, 0x99, 0xa3, 0x16,
+  0x68, 0x43, 0x9f, 0xb3, 0x95, 0x85, 0x77, 0x73, 0x5f, 0x5a, 0x96, 0x9d,
+  0xe7, 0x52, 0x97, 0x0a, 0x46, 0x6a, 0xc9, 0x31, 0x35, 0x84, 0x65, 0x01,
+  0x62, 0x2d, 0x2b, 0x16, 0x90, 0xc4, 0xdd, 0x1f, 0x44, 0x39, 0xd8, 0x9d,
+  0x1d, 0x8f, 0x90, 0x45, 0xb4, 0xb2, 0x3d, 0x0d, 0x74, 0x70, 0xb7, 0xf4,
+  0x76, 0xfc, 0xd2, 0x20, 0x5b, 0x19, 0x17, 0xa5, 0xac, 0x65, 0xe1, 0x2c,
+  0x46, 0xec, 0x59, 0xd4, 0x67, 0xab, 0xfb, 0x54, 0x8b, 0x12, 0xe7, 0x69,
+  0x88, 0x02, 0x2f, 0x9a, 0x31, 0xb1, 0x9a, 0x79, 0x92, 0x3f, 0x18, 0xe1,
+  0xd0, 0xe2, 0x78, 0xe2, 0x29, 0x06, 0x59, 0x00, 0x78, 0x67, 0x30, 0x18,
+  0x78, 0x9c, 0xfc, 0x6b, 0x2e, 0x81, 0xce, 0xc3, 0x60, 0x98, 0xba, 0x4a,
+  0x45, 0xaf, 0x58, 0xca, 0x78, 0x29, 0xd0, 0xc8, 0x96, 0x06, 0xbe, 0xa8,
+  0x2d, 0xc2, 0x1d, 0x8d, 0xc0, 0xa2, 0xd1, 0xd5, 0x6e, 0xbb, 0x06, 0x23,
+  0x7e, 0xd3, 0xb6, 0x09, 0x0f, 0x8c, 0x4d, 0x2c, 0x8d, 0x45, 0xcc, 0xb9,
+  0xbf, 0x8e, 0x4f, 0x65, 0x6e, 0x2d, 0x40, 0xc1, 0xc8, 0x07, 0x96, 0x22,
+  0x68, 0xbc, 0x25, 0xb2, 0x68, 0x3a, 0x94, 0x9e, 0x04, 0x1a, 0x80, 0xc9,
+  0x65, 0x77, 0x9c, 0xe5, 0x26, 0x35, 0x79, 0x17, 0x39, 0x74, 0x3c, 0xae,
+  0xac, 0xa5, 0x37, 0x88, 0x43, 0xf5, 0xb4, 0x76, 0x26, 0x62, 0x98, 0x85,
+  0xb6, 0xcc, 0x02, 0xbf, 0xe6, 0x1e, 0x28, 0x20, 0x6b, 0x11, 0x2b, 0xf0,
+  0x0e, 0x89, 0x6d, 0xd9, 0x8c, 0x5d, 0x5c, 0x3a, 0x79, 0x6f, 0x24, 0x41,
+  0x74, 0x57, 0x5f, 0x12, 0x34, 0x2d, 0x3d, 0xc0, 0xb8, 0x87, 0x56, 0xe3,
+  0x7c, 0xc8, 0x39, 0x3e, 0xb6, 0x16, 0x9d, 0x67, 0xbc, 0xb6, 0x36, 0xfe,
+  0x56, 0xae, 0xb2, 0x2e, 0x5a, 0x51, 0xb1, 0x25, 0xb3, 0x84, 0x1c, 0xf0,
+  0xbd, 0x28, 0xbe, 0x43, 0xbd, 0x06, 0xa2, 0x41, 0x71, 0x92, 0x89, 0x3d,
+  0xe6, 0x24, 0xb0, 0x2a, 0xba, 0x19, 0x5a, 0x6d, 0x45, 0x09, 0x2f, 0x92,
+  0xf2, 0x89, 0x0a, 0xf9, 0x28, 0x08, 0x52, 0x66, 0xbe, 0x4b, 0x19, 0x7b,
+  0x1f, 0x88, 0x3f, 0x2a, 0xa1, 0x9b, 0x62, 0x8e, 0x91, 0x13, 0x8b, 0x1e,
+  0x2a, 0xdd, 0xa4, 0x1c, 0x07, 0x08, 0x0b, 0x87, 0x04, 0x51, 0xd8, 0x6a,
+  0x49, 0x61, 0x4d, 0xeb, 0xc4, 0xf9, 0xa2, 0xd9, 0xd8, 0x94, 0x70, 0xb5,
+  0xcf, 0x79, 0xdf, 0x65, 0x2e, 0xba, 0xd8, 0xab, 0x3c, 0xbd, 0xba, 0x12,
+  0x55, 0x2d, 0xaa, 0x4f, 0xad, 0x9d, 0xc8, 0x4e, 0xb0, 0x2a, 0xc9, 0x6c,
+  0x51, 0xae, 0xd6, 0xad, 0xe6, 0x85, 0x59, 0x7b, 0xcc, 0xde, 0x52, 0x21,
+  0x66, 0xf3, 0x3f, 0xca, 0xbe, 0x31, 0x32, 0x8f, 0xa4, 0xa0, 0xc1, 0xe8,
+  0x55, 0xf5, 0x17, 0x9f, 0x9e, 0x6f, 0x70, 0xd1, 0x86, 0xb9, 0xcf, 0xb8,
+  0xb3, 0x4d, 0x67, 0xc4, 0x0a, 0x1f, 0x6e, 0x32, 0x81, 0x55, 0x79, 0x86,
+  0xab, 0xf8, 0xce, 0xc5, 0x3a, 0x09, 0x8e, 0xe6, 0x28, 0xf6, 0xaa, 0xd6,
+  0x46, 0x54, 0xb1, 0xed, 0x22, 0xb9, 0xf3, 0x78, 0xae, 0x7c, 0x28, 0xbb,
+  0x4d, 0x3c, 0x68, 0x8a, 0x37, 0x2f, 0x7a, 0xa4, 0x2b, 0x3d, 0xfd, 0x8e,
+  0x99, 0xd4, 0x9c, 0xb9, 0x8e, 0x5f, 0xf1, 0x24, 0x6b, 0xab, 0x32, 0x88,
+  0x82, 0x26, 0xc5, 0x48, 0x92, 0x85, 0x2c, 0x5e, 0xc6, 0xa6, 0x3e, 0x6a,
+  0x6b, 0x51, 0xa3, 0xd0, 0x19, 0x4f, 0x3b, 0x50, 0x4d, 0xb0, 0x20, 0x69,
+  0xa9, 0x54, 0x55, 0xb8, 0x18, 0x39, 0xef, 0xeb, 0xb5, 0x59, 0x76, 0xdc,
+  0x26, 0x75, 0x38, 0xf9, 0x62, 0xa4, 0x44, 0xc0, 0x34, 0x00, 0x81, 0xce,
+  0xb9, 0xeb, 0xf7, 0xa7, 0x71, 0xc1, 0xb5, 0x7a, 0x39, 0x12, 0x80, 0xb7,
+  0x8c, 0x89, 0x9a, 0xcd, 0x68, 0x35, 0x9e, 0xda, 0x38, 0x7e, 0x2e, 0x32,
+  0x43, 0x68, 0x8d, 0x31, 0xaf, 0xd0, 0x0c, 0x51, 0x09, 0x87, 0xe3, 0x8e,
+  0x8d, 0xb9, 0x3f, 0x9c, 0x9a, 0x36, 0xaa, 0x9c, 0xd1, 0x0f, 0x1d, 0xd9,
+  0xb3, 0xf3, 0xd3, 0x2f, 0xcf, 0x8f, 0x86, 0xc3, 0xe8, 0xcd, 0xd1, 0x85,
+  0xe8, 0xfa, 0x17, 0x12, 0x06, 0x27, 0x10, 0x9f, 0xec, 0x64, 0xb0, 0xec,
+  0x6c, 0x8b, 0x34, 0x31, 0x43, 0x02, 0x43, 0x35, 0x66, 0x70, 0xa0, 0xb1,
+  0x28, 0xc7, 0x7a, 0xfc, 0x54, 0xa3, 0xe7, 0xae, 0xd9, 0xcc, 0xcf, 0xb1,
+  0x4c, 0xec, 0x87, 0x74, 0x56, 0x73, 0x6f, 0x4b, 0x0d, 0x0a, 0x01, 0x5f,
+  0x1b, 0xe7, 0xf2, 0xb6, 0x73, 0xad, 0xb6, 0xca, 0xd3, 0xfb, 0x7d, 0x74,
+  0x61, 0xd5, 0x3a, 0x7f, 0x1f, 0x9d, 0x1b, 0x7d, 0xfc, 0x3e, 0xfa, 0x8e,
+  0xda, 0x9c, 0xa0, 0x58, 0xac, 0x94, 0xa8, 0x1a, 0x72, 0x6d, 0x2a, 0x5f,
+  0xaa, 0x80, 0x41, 0xde, 0x83, 0xff, 0x11, 0x95, 0xe7, 0x1f, 0xa8, 0x7f,
+  0xc8, 0xc9, 0xc4, 0x82, 0x25, 0xa3, 0xb1, 0x74, 0xae, 0xe7, 0x03, 0x2d,
+  0x70, 0x1d, 0x9d, 0x24, 0x97, 0x25, 0x0b, 0x24, 0xe8, 0x8e, 0x9a, 0xdb,
+  0x01, 0x36, 0xda, 0x2e, 0x2a, 0xca, 0xd3, 0xaf, 0x4f, 0x3e, 0xfd, 0x78,
+  0xe7, 0x53, 0xf9, 0xd5, 0xfe, 0x7d, 0xfe, 0x74, 0x47, 0x31, 0x06, 0xe9,
+  0xaf, 0xa7, 0x2f, 0x9e, 0xee, 0xbe, 0x00, 0xf6, 0xc9, 0xce, 0x8b, 0x1d,
+  0xfa, 0xff, 0xa7, 0xfa, 0x09, 0x00, 0x5e, 0x9e, 0xef, 0x7d, 0xfa, 0x09,
+  0x07, 0xc1, 0x80, 0x3e, 0xa6, 0xd4, 0x49, 0xbf, 0xcc, 0xfa, 0x9c, 0x43,
+  0xce, 0x42, 0xd0, 0xef, 0xab, 0xe6, 0x48, 0x78, 0xd5, 0x51, 0x7c, 0x0a,
+  0x13, 0xf7, 0x35, 0xaf, 0xd5, 0xb4, 0x2a, 0x29, 0xce, 0x61, 0x45, 0x3d,
+  0x37, 0x0d, 0x7d, 0x5b, 0xaa, 0x9a, 0x31, 0xf6, 0x42, 0xe5, 0x1d, 0x12,
+  0x19, 0xe9, 0x6a, 0x0d, 0x40, 0x1e, 0x7e, 0x6e, 0xd7, 0x96, 0xe9, 0xb5,
+  0xc1, 0xe8, 0x0d, 0xba, 0x55, 0xfa, 0x9e, 0xd6, 0x08, 0x27, 0x1a, 0x09,
+  0x2a, 0xb5, 0xd5, 0x2a, 0xab, 0xfd, 0xdc, 0xfe, 0xc4, 0x72, 0x85, 0xb7,
+  0x94, 0x1a, 0xa2, 0x66, 0x6f, 0x56, 0x60, 0xae, 0xad, 0xaf, 0x0a, 0xf1,
+  0x6c, 0xf8, 0xed, 0xf7, 0x2b, 0x15, 0x14, 0x41, 0x73, 0x70, 0x06, 0x52,
+  0x06, 0xad, 0x65, 0xca, 0x8d, 0xe6, 0xde, 0x2d, 0xc2, 0xf6, 0x1e, 0xd3,
+  0x9c, 0x9f, 0x11, 0x53, 0xb0, 0xdb, 0xb9, 0x7e, 0xb0, 0x39, 0xa9, 0x04,
+  0xb4, 0xb9, 0x6a, 0x6a, 0x06, 0xba, 0x63, 0x37, 0x9e, 0xbc, 0xea, 0x48,
+  0xb6, 0x2f, 0x6f, 0xa8, 0xf8, 0x59, 0x70, 0x4e, 0x8b, 0x08, 0x0a, 0xb7,
+  0x19, 0xdf, 0xf6, 0xf2, 0xbc, 0x51, 0x76, 0xa3, 0x2b, 0x50, 0x63, 0xd0,
+  0x9f, 0xf6, 0xc1, 0xe7, 0xc9, 0x1d, 0xba, 0x07, 0xa7, 0xe6, 0xc3, 0xda,
+  0x5d, 0xc5, 0x8a, 0x4d, 0x17, 0x26, 0xde, 0x76, 0x24, 0xfd, 0x73, 0x1c,
+  0x39, 0x1e, 0x56, 0x35, 0x75, 0x17, 0x11, 0x17, 0x2b, 0x51, 0x98, 0x54,
+  0x20, 0xf9, 0x00, 0xf9, 0x72, 0xcb, 0x58, 0x58, 0xff, 0x23, 0x17, 0xad,
+  0xc5, 0xf7, 0x9a, 0x42, 0x2e, 0xc7, 0x42, 0xf9, 0xd3, 0x30, 0x21, 0xaa,
+  0x02, 0xb6, 0x1c, 0x22, 0x4c, 0x6e, 0x48, 0xa9, 0x45, 0xba, 0x69, 0xe9,
+  0xe6, 0x08, 0xca, 0xdc, 0xfc, 0x6e, 0x63, 0x63, 0x78, 0x76, 0x74, 0x74,
+  0x18, 0x9d, 0x1c, 0xbf, 0x39, 0xbe, 0x08, 0x04, 0x72, 0x77, 0x91, 0x98,
+  0xa5, 0xb5, 0xb0, 0xea, 0x0c, 0xd5, 0xe5, 0xf0, 0x90, 0x66, 0x5a, 0x60,
+  0x5e, 0xaf, 0xf2, 0x59, 0xa2, 0x09, 0x0c, 0xd3, 0xfa, 0x7b, 0xac, 0x7a,
+  0x73, 0x12, 0x3f, 0x23, 0xe8, 0x7b, 0x81, 0xae, 0x20, 0xe1, 0x66, 0x8c,
+  0x52, 0x2d, 0x72, 0x49, 0x7c, 0xaf, 0xe1, 0x19, 0x55, 0xc9, 0x49, 0x91,
+  0x99, 0x5c, 0x99, 0x16, 0x8d, 0x69, 0xad, 0x8d, 0x0a, 0x6b, 0x9b, 0x48,
+  0x98, 0x73, 0x60, 0xa1, 0xe3, 0x68, 0xbd, 0xbb, 0x84, 0xd3, 0x11, 0x67,
+  0xa9, 0xe0, 0xc3, 0x86, 0xb1, 0xc4, 0xae, 0x2e, 0xc2, 0x45, 0x26, 0x7c,
+  0x3c, 0xec, 0x31, 0x2c, 0x59, 0x63, 0x81, 0xb4, 0xd6, 0x57, 0x58, 0x0c,
+  0xe5, 0xc9, 0x8e, 0xcb, 0x14, 0x58, 0x30, 0xcf, 0x51, 0x51, 0x1f, 0x9d,
+  0xed, 0x46, 0x24, 0x8f, 0x2c, 0x21, 0xd5, 0xe7, 0xcb, 0x79, 0xe3, 0xba,
+  0xfb, 0x5e, 0xde, 0xa5, 0xf9, 0x7f, 0xbc, 0xc3, 0xd7, 0xdb, 0x65, 0x9c,
+  0xf7, 0x49, 0xf2, 0x5a, 0xf5, 0xcd, 0xaa, 0x2a, 0x14, 0xa1, 0x71, 0xc6,
+  0x62, 0xfa, 0x49, 0x3c, 0x8a, 0x7f, 0x4d, 0x5a, 0xf4, 0xe9, 0x1e, 0x19,
+  0x3b, 0x24, 0xa7, 0x7a, 0x00, 0x30, 0xf5, 0x5e, 0xc4, 0x05, 0x3b, 0x5d,
+  0xe4, 0xb3, 0xc8, 0x3a, 0x1e, 0xb5, 0xcb, 0x76, 0xd1, 0xf3, 0x28, 0x2e,
+  0x8a, 0x97, 0xa9, 0x6b, 0x28, 0xc5, 0x34, 0x75, 0x2e, 0x4d, 0xd1, 0x7a,
+  0x16, 0xed, 0x7e, 0x8a, 0x79, 0x3c, 0x6e, 0x3e, 0x40, 0xab, 0xb7, 0x18,
+  0x36, 0x51, 0x17, 0x32, 0xbf, 0x9b, 0x92, 0xa1, 0xc0, 0x50, 0xc8, 0xb2,
+  0xba, 0x16, 0x0c, 0xcb, 0xb1, 0x7a, 0xd0, 0x4f, 0xd4, 0x91, 0xce, 0x96,
+  0x29, 0xf6, 0x6c, 0x8b, 0x84, 0xc4, 0x85, 0xcd, 0x64, 0x5d, 0x60, 0x6b,
+  0x95, 0x58, 0xbd, 0x6e, 0xee, 0x73, 0xbd, 0x78, 0x19, 0x60, 0x1d, 0x21,
+  0x5a, 0xbb, 0x4b, 0x27, 0x2c, 0x55, 0x9b, 0x11, 0x80, 0xe9, 0x4f, 0x88,
+  0x4f, 0x62, 0xa4, 0xd9, 0x71, 0xc9, 0x1e, 0x4f, 0x37, 0x32, 0x15, 0x60,
+  0xb8, 0xe4, 0x1b, 0x1b, 0x17, 0x36, 0x59, 0x7e, 0x40, 0xa1, 0x85, 0xaa,
+  0x4f, 0x00, 0xac, 0xb9, 0xe3, 0x7b, 0x41, 0xdc, 0x7e, 0x59, 0x4e, 0xcd,
+  0xae, 0xe0, 0x91, 0xd4, 0xab, 0x73, 0x46, 0x2a, 0x75, 0x30, 0xed, 0xdd,
+  0x1d, 0x92, 0x5f, 0xa7, 0x59, 0xbd, 0xe4, 0x52, 0x53, 0x29, 0xe5, 0x69,
+  0xf5, 0x79, 0x75, 0x76, 0x77, 0xbe, 0x5e, 0xbf, 0xea, 0x0c, 0x4d, 0xf9,
+  0xe0, 0xcb, 0x7b, 0x4f, 0x1f, 0xd8, 0xb4, 0xd3, 0xbc, 0x52, 0x42, 0x43,
+  0x04, 0x41, 0xef, 0x79, 0x69, 0x6c, 0x1b, 0x11, 0x7e, 0x72, 0x15, 0x73,
+  0x49, 0xda, 0x07, 0x46, 0x6f, 0x99, 0x1a, 0xb5, 0xa1, 0xbc, 0xd1, 0x68,
+  0x6c, 0xf9, 0xb2, 0x80, 0x85, 0x6c, 0xc1, 0x48, 0x2c, 0x5e, 0x8d, 0x75,
+  0xc9, 0x88, 0x92, 0x61, 0x1b, 0xbc, 0x2d, 0x9c, 0xb3, 0x57, 0x65, 0x12,
+  0x46, 0x3d, 0x79, 0x72, 0xc5, 0xae, 0x74, 0xe6, 0xc1, 0x50, 0xfb, 0x01,
+  0xf6, 0xa6, 0xe7, 0x95, 0x78, 0x33, 0xe2, 0x86, 0x84, 0x9e, 0x98, 0xf1,
+  0x8e, 0x63, 0x13, 0x59, 0xb5, 0xc4, 0x7a, 0xed, 0x62, 0x80, 0x7d, 0x76,
+  0x9c, 0x71, 0x1d, 0xe5, 0x3b, 0xf3, 0x25, 0x84, 0xc5, 0x5c, 0xa4, 0xd2,
+  0xc9, 0x80, 0x73, 0xeb, 0x84, 0x50, 0x1c, 0xb3, 0x47, 0x46, 0x17, 0xbc,
+  0x61, 0xa5, 0x78, 0x08, 0xb8, 0x81, 0x9e, 0x52, 0x2d, 0xb7, 0xe4, 0xba,
+  0x02, 0xc7, 0x2f, 0x2c, 0x79, 0x52, 0x10, 0x28, 0x61, 0xf7, 0x3f, 0x38,
+  0x7d, 0xfb, 0xfa, 0xf8, 0x4b, 0x07, 0x2b, 0x20, 0x4c, 0x7c, 0x59, 0x66,
+  0xb0, 0x6b, 0x8a, 0xd1, 0xd0, 0x95, 0xd9, 0x71, 0xee, 0x6e, 0xc5, 0xb7,
+  0xd7, 0xa0, 0x5b, 0x62, 0x4f, 0xef, 0xc3, 0x0f, 0x98, 0x81, 0xcc, 0x9f,
+  0xc0, 0x56, 0x2e, 0x98, 0xa1, 0xc5, 0x96, 0xb7, 0x3c, 0xd4, 0x60, 0x49,
+  0x24, 0x3b, 0x23, 0xce, 0xcb, 0xe5, 0xc2, 0xc5, 0x0e, 0x06, 0xf8, 0xf8,
+  0x8a, 0x4d, 0x87, 0x5b, 0x01, 0x15, 0x47, 0x97, 0x0b, 0x61, 0x4d, 0x12,
+  0xf3, 0x58, 0x35, 0xec, 0xca, 0x1d, 0x00, 0xcb, 0x82, 0xe6, 0x88, 0xeb,
+  0x05, 0xd0, 0x08, 0xc8, 0x99, 0x66, 0xf0, 0xfb, 0x07, 0x71, 0xf2, 0xe6,
+  0xca, 0x41, 0x21, 0x1e, 0x99, 0xa8, 0x95, 0x51, 0x99, 0x89, 0x66, 0x86,
+  0x79, 0x4b, 0x79, 0xc3, 0xef, 0x5d, 0xa1, 0x47, 0x0d, 0xfa, 0xf5, 0xae,
+  0x22, 0xab, 0xfb, 0x95, 0xf8, 0xc0, 0x24, 0x19, 0x2c, 0x07, 0x10, 0x16,
+  0x3d, 0xf1, 0x75, 0xf2, 0x27, 0xaf, 0xe0, 0xa1, 0x79, 0x01, 0x84, 0xc6,
+  0x99, 0x40, 0x87, 0x84, 0x35, 0x66, 0x94, 0x4b, 0x7a, 0x24, 0xc5, 0xe3,
+  0xcb, 0x20, 0x99, 0x4c, 0x02, 0x04, 0x8d, 0xe8, 0xc4, 0x5c, 0x0c, 0x5b,
+  0x4b, 0xf7, 0xa3, 0x6e, 0x5f, 0xbf, 0xd3, 0x84, 0x0b, 0x97, 0x0e, 0x6c,
+  0x0f, 0x95, 0x34, 0x0d, 0x8e, 0x18, 0x94, 0xb2, 0x62, 0xdc, 0x75, 0x60,
+  0xa1, 0xf4, 0x41, 0x52, 0x7e, 0xfc, 0x02, 0xdd, 0xcd, 0x9e, 0x22, 0x9b,
+  0x05, 0x27, 0xdf, 0x83, 0xc7, 0xc3, 0x2d, 0x96, 0x29, 0x55, 0x23, 0xa5,
+  0x93, 0x57, 0xaa, 0x3a, 0x75, 0x38, 0xfd, 0xb2, 0x25, 0x8c, 0x1d, 0x0c,
+  0xcb, 0x4b, 0xe2, 0x0e, 0x8c, 0xc3, 0xdf, 0xda, 0x04, 0xf1, 0xb6, 0x7c,
+  0xa1, 0xc1, 0xf8, 0x96, 0xc2, 0x4f, 0x0d, 0x09, 0x8e, 0x2f, 0x0d, 0xf5,
+  0x47, 0xb1, 0x2d, 0x8a, 0xeb, 0xef, 0x7b, 0xeb, 0xdc, 0x1e, 0xad, 0x2d,
+  0x3d, 0xd1, 0x53, 0x9c, 0x5f, 0x29, 0x1e, 0x8b, 0x3a, 0xd5, 0x58, 0x49,
+  0x74, 0xe8, 0xca, 0xce, 0x46, 0x09, 0xa1, 0xc4, 0x05, 0xcb, 0xb0, 0xf8,
+  0xb4, 0x94, 0x74, 0x3e, 0xcd, 0x7e, 0x12, 0xeb, 0xa4, 0x23, 0xc4, 0x80,
+  0xe3, 0x7c, 0xe4, 0x02, 0x52, 0x62, 0x7f, 0x97, 0x19, 0xea, 0xab, 0x37,
+  0xd5, 0xea, 0x65, 0x16, 0xbc, 0x06, 0x7b, 0x1e, 0x6b, 0xc2, 0x89, 0xda,
+  0x50, 0xa4, 0x2b, 0xab, 0xc0, 0x2e, 0x80, 0x59, 0x49, 0xe1, 0x9b, 0x90,
+  0xef, 0x5f, 0x69, 0x72, 0x34, 0x9d, 0x67, 0x4d, 0x77, 0x57, 0xa0, 0x98,
+  0x4f, 0x77, 0xd4, 0x12, 0x57, 0x6a, 0x94, 0x6a, 0x11, 0xed, 0x9f, 0x1f,
+  0x91, 0x64, 0x7b, 0x35, 0xe7, 0x74, 0x66, 0x8c, 0xb0, 0xd4, 0xfd, 0x61,
+  0xc1, 0x1a, 0xab, 0xa0, 0xe7, 0x03, 0x1d, 0xde, 0x05, 0x6f, 0x82, 0x98,
+  0x34, 0x30, 0x80, 0x0e, 0x99, 0x0b, 0x3f, 0x03, 0xc9, 0x8d, 0x0d, 0x2b,
+  0x8c, 0xb9, 0x0e, 0xf2, 0x92, 0x85, 0xa4, 0xe0, 0x2d, 0xa1, 0xae, 0x32,
+  0x03, 0x83, 0x3e, 0x6b, 0xb0, 0xf5, 0x10, 0x21, 0xcc, 0xd6, 0x9a, 0x4f,
+  0xb5, 0xcf, 0x40, 0xf8, 0x9b, 0x61, 0x30, 0x69, 0x5f, 0x15, 0x0f, 0xa8,
+  0x27, 0xa7, 0x5e, 0xbb, 0xf5, 0xe8, 0x6f, 0x7c, 0xcf, 0x40, 0x16, 0xa9,
+  0xcb, 0x05, 0x89, 0x0b, 0xac, 0x17, 0x43, 0xf6, 0x24, 0x10, 0x7e, 0x25,
+  0x31, 0x0f, 0xa1, 0xd5, 0x62, 0xa3, 0x86, 0xf0, 0x13, 0x17, 0x89, 0x95,
+  0x4a, 0x61, 0x75, 0x60, 0xa2, 0x67, 0x15, 0x54, 0x81, 0x28, 0x61, 0x1a,
+  0xf1, 0x4c, 0x90, 0x58, 0x2b, 0x64, 0xd1, 0x6e, 0xe6, 0xfd, 0xc8, 0xcd,
+  0xd6, 0x8f, 0xc1, 0x7d, 0x89, 0x8f, 0x5e, 0x45, 0x1d, 0xf5, 0x9f, 0x62,
+  0x14, 0x03, 0x74, 0xc4, 0x2c, 0x95, 0xdd, 0xa7, 0xf8, 0x85, 0x3f, 0xe6,
+  0x70, 0x37, 0x43, 0xb6, 0x1a, 0xc7, 0xf3, 0x00, 0xe3, 0x22, 0x53, 0xf7,
+  0xaa, 0x1f, 0x88, 0xf8, 0xf8, 0x98, 0x43, 0x8f, 0x42, 0xd1, 0x38, 0xa8,
+  0x2d, 0x02, 0x53, 0x0e, 0x72, 0x77, 0xed, 0xc0, 0x17, 0x49, 0xa5, 0x16,
+  0x89, 0xcb, 0x10, 0xea, 0xf4, 0x3b, 0xb4, 0x16, 0xdd, 0xe9, 0xd4, 0x33,
+  0x7c, 0x7b, 0x0c, 0xbb, 0xca, 0xc9, 0x74, 0x5e, 0x60, 0x52, 0xde, 0x05,
+  0xb0, 0xda, 0x55, 0x25, 0xb3, 0x01, 0x60, 0xff, 0x48, 0xfc, 0x71, 0xc8,
+  0x1b, 0x9c, 0x1d, 0xc2, 0x71, 0x02, 0xb7, 0x69, 0x61, 0x7e, 0x48, 0xa2,
+  0xed, 0xb1, 0x06, 0x45, 0x48, 0x0a, 0x75, 0x52, 0x8e, 0x83, 0xa5, 0x4c,
+  0xc6, 0xd7, 0x99, 0x04, 0xd3, 0xd2, 0xa2, 0x05, 0xf9, 0x97, 0x9d, 0xe8,
+  0xbf, 0x94, 0x06, 0xbe, 0xf6, 0xc9, 0x7a, 0x20, 0x84, 0x81, 0x20, 0x0e,
+  0x0d, 0x3c, 0x41, 0x1c, 0x7d, 0x77, 0x71, 0xbe, 0x1f, 0x7d, 0x75, 0xb4,
+  0x7f, 0x78, 0x74, 0x3e, 0xac, 0x5d, 0xfa, 0x1a, 0xfe, 0x21, 0x12, 0x1a,
+  0xec, 0xc1, 0x2c, 0x1a, 0x5b, 0xb6, 0xba, 0x86, 0xeb, 0x1b, 0xd7, 0x8b,
+  0x57, 0x7c, 0x90, 0xe8, 0x7c, 0x40, 0x21, 0x12, 0xc7, 0x01, 0x62, 0xd2,
+  0x10, 0xf7, 0x9c, 0x05, 0x6d, 0x68, 0x71, 0x4f, 0x67, 0x3d, 0x0f, 0x13,
+  0x65, 0x3c, 0x98, 0x8e, 0xbf, 0x4c, 0x26, 0x99, 0x25, 0x01, 0x56, 0x77,
+  0xee, 0x2b, 0x9f, 0x6a, 0x1d, 0xb0, 0x2d, 0xbd, 0x64, 0xd4, 0x80, 0xd8,
+  0xf9, 0xae, 0x4f, 0xfd, 0xf6, 0x69, 0xf1, 0xfb, 0x40, 0x23, 0x5a, 0x25,
+  0x45, 0xa7, 0x66, 0x0d, 0xac, 0x76, 0xbf, 0x21, 0x00, 0xe7, 0x8d, 0x93,
+  0xf4, 0x55, 0x6b, 0x4b, 0x38, 0x5d, 0x53, 0xc0, 0x8e, 0xd7, 0x35, 0x08,
+  0xbe, 0x54, 0x03, 0x21, 0x59, 0x4f, 0x50, 0x23, 0xab, 0x45, 0x03, 0x94,
+  0xbc, 0x9a, 0xa9, 0x41, 0x61, 0x3c, 0x10, 0x9d, 0x02, 0xcb, 0x3a, 0x69,
+  0xa9, 0x97, 0x3a, 0xdb, 0x45, 0x12, 0x8d, 0xdc, 0xa7, 0x61, 0xe9, 0x43,
+  0xe1, 0xfd, 0xc0, 0xbe, 0x10, 0x0d, 0xcf, 0x2f, 0x2a, 0xae, 0x52, 0xb5,
+  0x8b, 0x2a, 0x9e, 0xad, 0x36, 0x87, 0x31, 0x38, 0x9a, 0xb7, 0xa8, 0x7e,
+  0x74, 0x69, 0xa8, 0xbb, 0xfa, 0xae, 0x84, 0x82, 0x41, 0xa9, 0x67, 0x53,
+  0x27, 0x82, 0xcd, 0x64, 0xe3, 0x4d, 0x5e, 0x0d, 0x52, 0x80, 0x42, 0x62,
+  0xe6, 0x0a, 0x01, 0x1c, 0x36, 0xee, 0x9e, 0x4b, 0xa2, 0xaf, 0xb2, 0x82,
+  0xef, 0x82, 0xe6, 0xe3, 0xb8, 0xe4, 0xdb, 0x96, 0x9f, 0xdf, 0x50, 0x57,
+  0x97, 0x83, 0x03, 0x63, 0xfc, 0x3c, 0x66, 0x5f, 0x67, 0xfb, 0x17, 0x5f,
+  0xb1, 0xa3, 0x95, 0x49, 0xf8, 0x30, 0x83, 0xc2, 0x63, 0xee, 0xb5, 0x66,
+  0x26, 0x96, 0x53, 0xe0, 0x44, 0xfe, 0x35, 0xe4, 0x24, 0x93, 0x27, 0xd9,
+  0x91, 0xc7, 0x26, 0xca, 0x3c, 0x21, 0x29, 0x36, 0x55, 0xc3, 0x63, 0xb5,
+  0x6e, 0x05, 0xc7, 0xbc, 0xbb, 0x34, 0x3b, 0x17, 0x74, 0xd9, 0x95, 0x1c,
+  0xf4, 0xae, 0xcc, 0x89, 0x89, 0x1e, 0xc2, 0x1c, 0x34, 0x9e, 0x10, 0x65,
+  0x8e, 0xbf, 0xb0, 0x4c, 0xf3, 0x1e, 0xed, 0x69, 0x3b, 0x30, 0x51, 0x70,
+  0xa4, 0x3f, 0x9f, 0xad, 0x06, 0x4d, 0xc4, 0x8b, 0xe8, 0x8b, 0x65, 0x59,
+  0x65, 0x2b, 0x35, 0xac, 0x3b, 0x27, 0x59, 0xe6, 0x59, 0x56, 0x56, 0xd1,
+  0xe2, 0x78, 0x75, 0xe4, 0x44, 0x0b, 0x02, 0x95, 0x8c, 0x05, 0x4d, 0xcd,
+  0x55, 0xee, 0x0e, 0x05, 0xc3, 0x78, 0x54, 0x64, 0xd3, 0x65, 0x19, 0x84,
+  0x5d, 0xff, 0xbc, 0x31, 0x07, 0x83, 0xde, 0x3c, 0x1e, 0x24, 0x46, 0x50,
+  0x88, 0x1b, 0xce, 0x63, 0xd2, 0xf4, 0x51, 0xe7, 0x11, 0x7e, 0xc7, 0x3c,
+  0x9b, 0x57, 0x4b, 0x2b, 0x70, 0x84, 0xf7, 0x96, 0xdf, 0x6b, 0xba, 0x0b,
+  0x93, 0x3b, 0x48, 0xeb, 0x26, 0x11, 0xbf, 0x96, 0x6a, 0xeb, 0x52, 0x8e,
+  0xdb, 0x01, 0x7c, 0x30, 0xae, 0xc3, 0xa5, 0xb3, 0x61, 0xa1, 0x06, 0x8b,
+  0x54, 0x24, 0x11, 0x21, 0x96, 0x01, 0xb9, 0xcd, 0x5f, 0x28, 0xb9, 0xdc,
+  0x0a, 0x2a, 0x4d, 0x57, 0x6e, 0x91, 0xc9, 0x4f, 0x4b, 0xac, 0xd1, 0x80,
+  0x26, 0xdd, 0x6b, 0xd5, 0x19, 0x14, 0x4c, 0x3e, 0x97, 0xbb, 0xde, 0x42,
+  0x2c, 0x25, 0x78, 0xcc, 0xbc, 0x70, 0x36, 0x44, 0xbb, 0xf1, 0xe0, 0xa4,
+  0x63, 0x8c, 0x25, 0xe6, 0xac, 0x85, 0xaf, 0xf3, 0xc7, 0x89, 0xc9, 0xa8,
+  0xdf, 0x61, 0x52, 0xbb, 0x5d, 0x1f, 0x96, 0xab, 0xb0, 0x11, 0x05, 0x05,
+  0x98, 0x64, 0xf0, 0x7a, 0xcf, 0x71, 0xf2, 0x37, 0x3b, 0xa4, 0xee, 0xe2,
+  0xb4, 0x0c, 0xaf, 0x3f, 0x53, 0xbb, 0x7d, 0x9d, 0xf4, 0xd1, 0xaa, 0x12,
+  0x87, 0xe1, 0xa3, 0x13, 0xaf, 0x90, 0xca, 0xa0, 0xe6, 0x17, 0x85, 0xcc,
+  0x60, 0x5b, 0xcf, 0x75, 0xaa, 0x31, 0x94, 0xb2, 0xe6, 0x66, 0xfb, 0x82,
+  0xf2, 0xce, 0xb6, 0x2c, 0xf8, 0xd1, 0xbd, 0x2b, 0xd1, 0x79, 0xfb, 0x07,
+  0x4d, 0xd2, 0x18, 0x38, 0x80, 0x2f, 0x65, 0x97, 0xc7, 0x61, 0xd6, 0x34,
+  0xaf, 0x8a, 0x8b, 0xec, 0x7d, 0x54, 0xd7, 0x61, 0x7f, 0x88, 0xd5, 0x9c,
+  0x47, 0x7e, 0x3d, 0x0a, 0xe1, 0x9b, 0x7b, 0xbb, 0xac, 0x7f, 0x49, 0x94,
+  0x02, 0xe3, 0x65, 0x59, 0x61, 0x18, 0x8f, 0x42, 0x52, 0x5d, 0x77, 0x2e,
+  0xff, 0xc6, 0x70, 0x6c, 0x96, 0x50, 0xae, 0x4e, 0x55, 0x11, 0x7f, 0x02,
+  0xf7, 0x4a, 0xa5, 0x86, 0x80, 0x24, 0x29, 0x17, 0x65, 0xbe, 0x1c, 0x57,
+  0x70, 0x85, 0x98, 0x18, 0x2a, 0xce, 0x68, 0xb7, 0xbc, 0x59, 0xa8, 0xc2,
+  0x6e, 0xc6, 0x95, 0x8c, 0x0d, 0x7d, 0x32, 0xec, 0x62, 0x4b, 0xaa, 0xda,
+  0x69, 0x55, 0x4f, 0x16, 0xc5, 0x69, 0xfc, 0x8e, 0xc0, 0xfa, 0x67, 0x2e,
+  0x61, 0xbc, 0x02, 0xcf, 0x24, 0xd1, 0xf7, 0xc1, 0x15, 0xa3, 0xf2, 0x06,
+  0xdf, 0xaf, 0x79, 0xa4, 0x40, 0x51, 0x7c, 0x7b, 0xc3, 0x32, 0xb7, 0xe1,
+  0xc0, 0x9c, 0xa8, 0xbb, 0xbe, 0x2f, 0x63, 0x47, 0xfd, 0x6d, 0xd3, 0x42,
+  0x1a, 0x8c, 0xb5, 0x43, 0x47, 0x2f, 0x3c, 0x20, 0x54, 0x2d, 0x22, 0x33,
+  0x99, 0x26, 0x5c, 0x1e, 0xde, 0xbc, 0xaf, 0x12, 0x0f, 0x20, 0xeb, 0x37,
+  0x70, 0xc5, 0xde, 0xac, 0x7a, 0x5f, 0xed, 0xd6, 0x6c, 0x5e, 0x01, 0x67,
+  0x02, 0xbe, 0xd1, 0x20, 0xa2, 0x43, 0x33, 0x1d, 0x32, 0x3b, 0xe1, 0x05,
+  0x83, 0x00, 0x6f, 0x9b, 0x74, 0x7c, 0xe6, 0xba, 0xa0, 0x21, 0x60, 0xc6,
+  0xdd, 0x69, 0xb2, 0xd3, 0x0d, 0xe0, 0xdd, 0x37, 0x25, 0xc0, 0x3d, 0x63,
+  0x21, 0x1f, 0x66, 0x32, 0x9e, 0xa0, 0x28, 0xe9, 0x08, 0xe7, 0xda, 0x6a,
+  0x19, 0x0a, 0x35, 0xf1, 0x73, 0x07, 0xb3, 0xfb, 0x7c, 0x6f, 0xb0, 0xfb,
+  0xf1, 0xa7, 0x83, 0x9d, 0xc1, 0xee, 0x0e, 0x38, 0x0b, 0x86, 0x12, 0x0c,
+  0x4e, 0xd6, 0xa5, 0xa5, 0xab, 0xca, 0x7b, 0xcd, 0x3e, 0xdf, 0x1e, 0x5d,
+  0x7c, 0x7b, 0x7a, 0xfe, 0x75, 0x74, 0xfc, 0xf6, 0xe2, 0xe8, 0xfc, 0xf5,
+  0xfe, 0xc1, 0x63, 0x31, 0x48, 0x43, 0xeb, 0x6c, 0x50, 0xd2, 0x2b, 0xf1,
+  0x0b, 0xd3, 0x34, 0x81, 0xf9, 0x35, 0x4b, 0xca, 0xeb, 0x9d, 0x17, 0xbb,
+  0x0f, 0x42, 0x23, 0xb6, 0x58, 0xc1, 0xfc, 0xfb, 0x36, 0xa9, 0x5d, 0x4c,
+  0x6a, 0x7d, 0x2b, 0x0e, 0xac, 0x6a, 0x28, 0xd1, 0x44, 0x2e, 0x12, 0x95,
+  0xf9, 0x3b, 0x23, 0x7d, 0xa7, 0xa3, 0x3c, 0x36, 0xfb, 0xcb, 0x48, 0xca,
+  0xc3, 0x4b, 0xf2, 0xa8, 0xc2, 0x9a, 0x68, 0xa8, 0xb5, 0xb2, 0x5b, 0x44,
+  0xe2, 0x2e, 0xd3, 0x69, 0xa9, 0x56, 0x03, 0x29, 0xe9, 0x3b, 0x61, 0x49,
+  0xc6, 0x18, 0xb2, 0xd5, 0x99, 0xe4, 0x32, 0x93, 0x5c, 0xdf, 0x46, 0xea,
+  0x4c, 0x4e, 0x5c, 0x4e, 0x84, 0xcb, 0xb1, 0xaf, 0x64, 0x96, 0xf0, 0x58,
+  0xab, 0x15, 0xd0, 0xc2, 0x80, 0xd1, 0x1a, 0x4e, 0x5c, 0x61, 0x11, 0xbc,
+  0x3c, 0xb1, 0x8a, 0x05, 0xf0, 0x40, 0x07, 0xc2, 0xa7, 0x21, 0x18, 0x8d,
+  0x74, 0xc5, 0x72, 0x83, 0x01, 0x60, 0x56, 0x91, 0xfa, 0xe4, 0x76, 0xe2,
+  0x3c, 0x01, 0x11, 0x73, 0x0c, 0xa8, 0x17, 0xad, 0x17, 0x15, 0xf4, 0xab,
+  0x48, 0xb0, 0xd7, 0xc3, 0xd7, 0x45, 0xa2, 0xe4, 0x78, 0xc4, 0x49, 0x1e,
+  0xdf, 0xa1, 0x92, 0x83, 0x64, 0x66, 0xfa, 0xc8, 0xbd, 0x00, 0x3e, 0x1e,
+  0xf2, 0x81, 0x5f, 0xf3, 0xe8, 0xec, 0xe8, 0x4d, 0xdf, 0x2a, 0x4a, 0xd1,
+  0xef, 0x62, 0x73, 0x31, 0x84, 0x3f, 0xc9, 0x63, 0x59, 0x24, 0x73, 0x8b,
+  0x1e, 0x61, 0x9e, 0xa8, 0xe1, 0x2e, 0xe1, 0x04, 0x70, 0x68, 0x44, 0xfd,
+  0x16, 0x5e, 0x8b, 0xc3, 0x68, 0x51, 0x86, 0x0e, 0xd7, 0xad, 0x02, 0x54,
+  0x86, 0xfd, 0xd4, 0x10, 0xdd, 0x68, 0xd3, 0x85, 0xa5, 0xa2, 0x3f, 0x8e,
+  0xbd, 0x64, 0xd7, 0xb8, 0xf3, 0x86, 0x67, 0x96, 0x57, 0x7c, 0xf6, 0xf5,
+  0xc1, 0xf0, 0xa3, 0xdd, 0x3d, 0x1d, 0xce, 0x96, 0x09, 0xbf, 0xe0, 0x55,
+  0xf5, 0x94, 0x73, 0x66, 0xd7, 0xe1, 0x18, 0x2d, 0x81, 0x98, 0x0f, 0x38,
+  0x6f, 0xc6, 0xa6, 0x4b, 0x82, 0xd9, 0xaa, 0x64, 0xc1, 0x6c, 0x48, 0x1d,
+  0x3f, 0x93, 0xa4, 0x5c, 0xc5, 0x27, 0x58, 0xfe, 0x19, 0xd6, 0x5c, 0xb1,
+  0xc5, 0x4b, 0x17, 0xdc, 0x16, 0xcf, 0xed, 0x23, 0x69, 0x59, 0x5b, 0xe3,
+  0x0c, 0x69, 0x1f, 0xc0, 0x51, 0xdf, 0x73, 0xac, 0xb7, 0xff, 0x16, 0xe0,
+  0x76, 0x7a, 0xa9, 0x1b, 0x06, 0x8d, 0xef, 0x86, 0x0f, 0x80, 0xc6, 0x6b,
+  0x4f, 0xac, 0x3e, 0xc1, 0xdc, 0x23, 0x3b, 0xe3, 0xe9, 0x53, 0xda, 0x28,
+  0x3a, 0x59, 0x82, 0x4a, 0x00, 0xa6, 0x20, 0xe5, 0xb3, 0xdd, 0x23, 0x87,
+  0x39, 0x10, 0xb4, 0x17, 0x12, 0x39, 0xf9, 0x76, 0x10, 0x7d, 0x95, 0xcc,
+  0x91, 0x16, 0x8e, 0x18, 0x33, 0xcb, 0x33, 0xe2, 0x48, 0x38, 0x94, 0x1f,
+  0xe1, 0x62, 0x11, 0x27, 0x49, 0xac, 0x58, 0x6f, 0xc4, 0xeb, 0x0a, 0x51,
+  0xe4, 0x0c, 0x4a, 0x3d, 0x46, 0x3c, 0x1a, 0xdf, 0x44, 0x6a, 0x8d, 0xe4,
+  0x6a, 0x61, 0x69, 0xa1, 0x0d, 0x6c, 0x56, 0x11, 0xdb, 0x18, 0xa3, 0x96,
+  0x9b, 0xd3, 0x63, 0xce, 0x2e, 0x15, 0x35, 0x9e, 0xe2, 0x2d, 0x8e, 0xd3,
+  0x89, 0x45, 0xb1, 0xf0, 0x4c, 0x65, 0x92, 0x5f, 0x43, 0xc3, 0x2f, 0xe8,
+  0xba, 0x89, 0xe7, 0xe3, 0xd5, 0x60, 0x92, 0x10, 0x01, 0xd1, 0x69, 0x1b,
+  0x2c, 0x6f, 0xb6, 0x83, 0x63, 0x0a, 0x96, 0x7f, 0x2d, 0x19, 0xf0, 0x55,
+  0xfb, 0xae, 0x95, 0xb9, 0x6a, 0x82, 0x53, 0xc5, 0x95, 0x33, 0x01, 0x92,
+  0xb0, 0x5c, 0x76, 0x39, 0x9e, 0x6b, 0x61, 0x9d, 0x8e, 0x22, 0x87, 0xc6,
+  0x88, 0x16, 0x06, 0x8b, 0x64, 0xf6, 0xc2, 0x65, 0xdb, 0x1a, 0x7f, 0x50,
+  0x98, 0x60, 0x27, 0x3f, 0x07, 0xb6, 0xc8, 0x79, 0x72, 0x35, 0x55, 0x81,
+  0x22, 0x94, 0xd0, 0x5d, 0x13, 0x2d, 0xc9, 0x0e, 0x22, 0xd7, 0x6b, 0x6d,
+  0xea, 0x0d, 0x36, 0x9e, 0xcd, 0xb8, 0xea, 0x80, 0x31, 0x7e, 0x2d, 0xae,
+  0xe8, 0x1b, 0x51, 0x5c, 0x0c, 0x06, 0x86, 0x84, 0x18, 0xac, 0x96, 0x0c,
+  0x8b, 0xbd, 0x51, 0x2f, 0x0b, 0x7d, 0x2b, 0x14, 0xc2, 0x70, 0xa2, 0x1a,
+  0x07, 0xcc, 0x3e, 0x3e, 0x2b, 0x27, 0x25, 0x67, 0x85, 0xbe, 0xbe, 0x7d,
+  0x02, 0xc3, 0xee, 0xc5, 0xc9, 0xb0, 0x27, 0xf4, 0x20, 0xb5, 0xd4, 0x03,
+  0x58, 0x71, 0x4f, 0x7e, 0x30, 0x73, 0x48, 0xac, 0x96, 0x95, 0xb2, 0xcc,
+  0x65, 0x34, 0xc2, 0x19, 0xbc, 0x47, 0xc8, 0x87, 0xfc, 0xdb, 0x42, 0x68,
+  0xf0, 0x2c, 0x86, 0x63, 0xc8, 0xfd, 0x22, 0x10, 0x39, 0x2c, 0x13, 0x20,
+  0xc4, 0x91, 0xc0, 0xf4, 0xa4, 0x17, 0xf5, 0xf7, 0x18, 0x22, 0x66, 0xb7,
+  0xba, 0x90, 0x31, 0x20, 0xf5, 0xe3, 0x31, 0x17, 0x08, 0xd9, 0x70, 0xb5,
+  0x83, 0x8d, 0x25, 0x6c, 0x2a, 0x59, 0xdf, 0xd2, 0xfb, 0xf8, 0xb1, 0xa7,
+  0x93, 0xba, 0xdd, 0xe5, 0x38, 0x65, 0xc8, 0xa3, 0xb7, 0xc9, 0x74, 0xd5,
+  0x14, 0x1b, 0xf6, 0x1e, 0xdc, 0x59, 0xce, 0x08, 0xb8, 0x4b, 0x1d, 0xf2,
+  0xa5, 0x00, 0xf8, 0xb2, 0xd5, 0x0f, 0x27, 0x9b, 0xf6, 0xca, 0x06, 0x40,
+  0xcb, 0xa8, 0xf6, 0xdc, 0x79, 0x74, 0xbb, 0x67, 0x6e, 0x55, 0x7c, 0x63,
+  0x8b, 0x27, 0x76, 0x69, 0xcf, 0x48, 0x1a, 0x69, 0x7a, 0x88, 0xed, 0x0a,
+  0x28, 0x17, 0x09, 0x3e, 0x44, 0xb7, 0xc4, 0x49, 0x2a, 0x9c, 0x06, 0x0a,
+  0x54, 0xe9, 0x90, 0x76, 0xb0, 0xfd, 0x0c, 0xcc, 0x49, 0xb2, 0xb0, 0x8f,
+  0xe8, 0xe1, 0x78, 0x67, 0x3e, 0xd3, 0x24, 0xc1, 0x16, 0xcb, 0x99, 0xd6,
+  0x3a, 0x61, 0x46, 0xdc, 0xe3, 0xeb, 0xb6, 0x8c, 0x88, 0x13, 0xa7, 0x12,
+  0xdf, 0x36, 0x65, 0x61, 0x9a, 0x05, 0x2c, 0xb5, 0x0c, 0xfa, 0x85, 0x82,
+  0xb9, 0x47, 0x50, 0xe3, 0x98, 0x5e, 0xae, 0x53, 0x51, 0xd8, 0x39, 0x1c,
+  0x93, 0x17, 0x8c, 0x58, 0x45, 0x37, 0xa2, 0xd3, 0xb7, 0x44, 0xa3, 0x65,
+  0xc6, 0xf1, 0x9e, 0x4e, 0x60, 0xd0, 0x9c, 0xb1, 0x21, 0x4b, 0x9d, 0x51,
+  0x37, 0x64, 0x92, 0xfd, 0xcf, 0xb0, 0x08, 0x45, 0xd7, 0xaf, 0x9a, 0x82,
+  0xb9, 0x56, 0x97, 0x40, 0x9d, 0x01, 0xb4, 0xde, 0xd2, 0xd4, 0x59, 0x6e,
+  0x85, 0xf9, 0xba, 0xc9, 0x3d, 0x44, 0xa4, 0xae, 0xf5, 0x2b, 0xdf, 0x4b,
+  0xce, 0x3b, 0xaf, 0xef, 0xd9, 0xf1, 0x5b, 0x29, 0x36, 0xe7, 0xce, 0x52,
+  0x02, 0xc9, 0x5b, 0x9e, 0x13, 0x41, 0x58, 0xcc, 0xd9, 0x70, 0xd1, 0x89,
+  0x81, 0x05, 0x04, 0x87, 0x43, 0x92, 0x5a, 0x77, 0xe7, 0x4b, 0x19, 0x41,
+  0x17, 0x37, 0x65, 0x51, 0x4c, 0xbb, 0xb5, 0x1a, 0x4a, 0x6e, 0x47, 0x6b,
+  0x57, 0x92, 0x33, 0xdd, 0x8c, 0x27, 0x61, 0x51, 0x48, 0x6d, 0xa5, 0xc2,
+  0x29, 0x7b, 0xb5, 0xbc, 0xc0, 0xd0, 0x66, 0xfc, 0x51, 0x34, 0xd8, 0xa6,
+  0x0e, 0x8b, 0x6d, 0x7b, 0x71, 0x71, 0x33, 0x2e, 0xe8, 0x8e, 0x44, 0x12,
+  0xec, 0x0f, 0xac, 0x85, 0xb3, 0x89, 0x89, 0x86, 0x3c, 0xf9, 0x29, 0xea,
+  0x8f, 0xa7, 0x32, 0x43, 0xae, 0xd6, 0xf6, 0x03, 0xd1, 0x0d, 0x9e, 0xf8,
+  0x69, 0x03, 0x09, 0x61, 0xc3, 0x77, 0x6f, 0x80, 0xdb, 0xcc, 0x15, 0xb1,
+  0x2e, 0xce, 0xf7, 0xdf, 0x0e, 0x5f, 0x8b, 0x59, 0xf1, 0x22, 0x0b, 0x0a,
+  0x6d, 0xa9, 0x4d, 0xd6, 0x7c, 0x6f, 0x0e, 0x5a, 0xeb, 0x4e, 0xc0, 0x84,
+  0x2d, 0x2c, 0x59, 0xab, 0x70, 0xf5, 0xea, 0x80, 0xb3, 0x52, 0xc2, 0x8b,
+  0x19, 0x36, 0x9d, 0xa8, 0xcd, 0x62, 0xcb, 0xdd, 0xae, 0x45, 0x58, 0xbb,
+  0xc0, 0x83, 0xba, 0x89, 0x96, 0xe2, 0x1e, 0xc2, 0x99, 0x39, 0xb0, 0xc1,
+  0xd8, 0xa7, 0xc2, 0xd0, 0xd7, 0x62, 0x28, 0x1e, 0x90, 0xfe, 0xd1, 0x57,
+  0x18, 0xee, 0xa0, 0x52, 0x83, 0x33, 0x45, 0x09, 0x43, 0x57, 0xf8, 0x33,
+  0xd7, 0x78, 0x98, 0x33, 0x67, 0x4d, 0x6f, 0xfe, 0x71, 0x77, 0xab, 0xbd,
+  0xf9, 0x8b, 0x9f, 0xdb, 0x7c, 0xfb, 0xd8, 0x4d, 0xe0, 0xf7, 0x99, 0x19,
+  0x9b, 0x7f, 0xdc, 0xdb, 0x7a, 0x70, 0x46, 0x61, 0x52, 0x99, 0xef, 0x93,
+  0xde, 0xc0, 0x60, 0xa3, 0x57, 0x56, 0x56, 0x51, 0x2f, 0x62, 0x17, 0xdd,
+  0x70, 0xe9, 0x61, 0xdd, 0x2a, 0x28, 0x07, 0x88, 0x7e, 0x75, 0xe2, 0x9f,
+  0x77, 0x5a, 0x68, 0x90, 0xfe, 0xf1, 0xff, 0x38, 0x0a, 0xe1, 0xf0, 0x48,
+  0x1b, 0x0f, 0x79, 0x1e, 0xd2, 0xab, 0x8b, 0x6c, 0xc0, 0x7d, 0xef, 0x3d,
+  0xd0, 0xb7, 0x9f, 0x5d, 0xa0, 0xeb, 0xc2, 0x03, 0x88, 0x10, 0x22, 0x48,
+  0xe3, 0xdb, 0xa4, 0x5d, 0x68, 0x3f, 0x1b, 0xbe, 0x82, 0xdb, 0xfa, 0xfe,
+  0x2e, 0x8e, 0xdf, 0x1c, 0xa1, 0x72, 0xc8, 0xe1, 0x31, 0xf0, 0xba, 0x86,
+  0x0a, 0x99, 0x67, 0x6a, 0xad, 0x03, 0x12, 0x0d, 0xc1, 0xb4, 0xc5, 0x35,
+  0xe6, 0x22, 0x75, 0xdc, 0xf9, 0x77, 0x3b, 0x81, 0xae, 0x35, 0x94, 0xb4,
+  0xb0, 0x84, 0xb5, 0xe3, 0xcb, 0xfe, 0x9b, 0x6c, 0xc2, 0xaa, 0x57, 0x5f,
+  0xa0, 0x83, 0xe9, 0x2d, 0xfa, 0xf0, 0xdd, 0x7c, 0x56, 0xf9, 0x38, 0x4c,
+  0x8b, 0x53, 0xad, 0x7a, 0x63, 0x1d, 0xe0, 0xf8, 0xdf, 0xb7, 0xfb, 0x7d,
+  0x2e, 0x9f, 0x28, 0x11, 0x31, 0x6a, 0x17, 0xaf, 0x60, 0x1a, 0xd8, 0xd9,
+  0xa7, 0xf5, 0x49, 0xa7, 0x2b, 0xf1, 0xe1, 0xc6, 0x3e, 0xf2, 0xc6, 0xe7,
+  0xc0, 0x5d, 0x71, 0xc5, 0x6f, 0x67, 0x31, 0x12, 0x9b, 0xd0, 0x46, 0x05,
+  0x8d, 0x11, 0xc2, 0x79, 0x72, 0xe7, 0x43, 0x47, 0xb4, 0x60, 0x55, 0xb6,
+  0x58, 0xf1, 0x24, 0xef, 0x2a, 0x5e, 0xe9, 0x56, 0xd7, 0xd4, 0xdf, 0xe5,
+  0x9d, 0x0a, 0xc4, 0xbe, 0xf4, 0x10, 0x12, 0xa0, 0x7e, 0xa2, 0x88, 0xf4,
+  0xa7, 0x79, 0xc0, 0xc0, 0x74, 0xd8, 0x56, 0x02, 0x22, 0xc0, 0x67, 0x0c,
+  0x80, 0x25, 0xab, 0xe3, 0xf4, 0x98, 0x92, 0x1b, 0xb8, 0xdb, 0x06, 0x30,
+  0x13, 0x9b, 0x5f, 0x81, 0xb8, 0xce, 0xa2, 0x5a, 0x19, 0x2a, 0x89, 0x2c,
+  0x3f, 0x56, 0x72, 0xa0, 0xbb, 0xfd, 0x2e, 0xa3, 0x1f, 0xa7, 0xf3, 0x96,
+  0xc9, 0xf4, 0x7f, 0xfe, 0x6c, 0x1a, 0x5e, 0xab, 0xa8, 0x73, 0x09, 0x20,
+  0x01, 0xb8, 0x00, 0x3a, 0x32, 0x00, 0xc1, 0xd6, 0x10, 0xda, 0x22, 0xa1,
+  0x1e, 0x6c, 0xcd, 0x94, 0x13, 0x51, 0xd4, 0x5c, 0x50, 0xa1, 0xb3, 0x95,
+  0x8a, 0xa5, 0x0b, 0x7c, 0x74, 0xb9, 0x98, 0xb0, 0x3f, 0x5b, 0x22, 0xf9,
+  0xfe, 0x5b, 0x3c, 0x5f, 0xc6, 0xf9, 0x2a, 0xda, 0xdd, 0xeb, 0x45, 0x7b,
+  0x3b, 0xbb, 0x7b, 0x2d, 0x73, 0xe8, 0xfc, 0x37, 0xc4, 0x93, 0xec, 0xf1,
+  0xd7, 0x9d, 0xc7, 0xce, 0xc2, 0x47, 0x85, 0xf3, 0xcd, 0xaa, 0xf9, 0x93,
+  0xc4, 0x7b, 0xe0, 0xda, 0x92, 0x82, 0x91, 0x28, 0x1f, 0xc5, 0x00, 0x60,
+  0x2c, 0x58, 0x88, 0xe1, 0xc9, 0x2a, 0xd1, 0xb8, 0xb2, 0x08, 0x78, 0x62,
+  0x23, 0x1a, 0x5f, 0x27, 0x8a, 0xe1, 0xed, 0xad, 0x6f, 0x71, 0xce, 0x65,
+  0x76, 0xaa, 0x7b, 0x94, 0x96, 0xb6, 0x2d, 0x88, 0x4a, 0xc0, 0xde, 0x10,
+  0xbd, 0x1f, 0x1e, 0x1f, 0x5c, 0x18, 0x42, 0xdc, 0x25, 0xae, 0xd3, 0x7c,
+  0xf5, 0xb8, 0x8a, 0x25, 0x0f, 0x3e, 0x33, 0x79, 0x71, 0x9d, 0x90, 0x58,
+  0x36, 0x1f, 0x2d, 0xaf, 0x5e, 0xfc, 0x35, 0xce, 0xaf, 0x82, 0x5a, 0xd2,
+  0x6b, 0x9e, 0x9f, 0x70, 0x5a, 0xce, 0x0b, 0x62, 0x50, 0xbb, 0xcf, 0x77,
+  0x9f, 0x48, 0xcc, 0x77, 0x8a, 0xfa, 0x46, 0xcc, 0x1f, 0xba, 0xb3, 0xae,
+  0x00, 0x14, 0x70, 0xb0, 0xb9, 0x43, 0x25, 0x98, 0x4f, 0xba, 0xa2, 0x73,
+  0xc5, 0xe1, 0xb3, 0x13, 0x7d, 0x56, 0xf2, 0x77, 0xbb, 0x8c, 0x8b, 0x41,
+  0x8f, 0x23, 0xd9, 0x6d, 0xb9, 0xe8, 0x0e, 0x2a, 0x27, 0xfc, 0x03, 0x73,
+  0x45, 0x17, 0xae, 0x40, 0xcb, 0x81, 0xf0, 0x64, 0x65, 0xa7, 0xa3, 0x3c,
+  0x89, 0x6f, 0x7c, 0x5d, 0x29, 0x8f, 0x5e, 0x60, 0xf6, 0xf3, 0xf3, 0xd7,
+  0x07, 0x02, 0xfa, 0x68, 0x59, 0x27, 0xbc, 0xd4, 0xbe, 0xe0, 0xfb, 0x16,
+  0x46, 0xf9, 0x81, 0xfe, 0x11, 0x16, 0xfe, 0x62, 0x32, 0x7a, 0xc4, 0x43,
+  0x74, 0xee, 0x04, 0x5e, 0x6b, 0xbf, 0x0a, 0x3d, 0x0f, 0xc1, 0xbf, 0x04,
+  0xa9, 0x71, 0x09, 0x33, 0xa2, 0x82, 0x4d, 0x29, 0xd7, 0x24, 0x06, 0x6c,
+  0xa9, 0xb5, 0xae, 0x35, 0x2c, 0xd5, 0x62, 0x40, 0xe3, 0x46, 0x2d, 0xa4,
+  0xc3, 0xfd, 0xb3, 0x40, 0x79, 0x62, 0xe5, 0xc4, 0x1b, 0x8a, 0xf0, 0x1c,
+  0x04, 0x67, 0x2e, 0x44, 0x27, 0xf6, 0xa4, 0x55, 0xcf, 0x8b, 0xbc, 0x25,
+  0xf3, 0xc9, 0xc9, 0x6d, 0x2c, 0xb1, 0xc5, 0x99, 0x5e, 0x27, 0x6c, 0xd3,
+  0x60, 0xec, 0xea, 0xe9, 0x24, 0x66, 0x1f, 0x92, 0x5e, 0x42, 0x2c, 0x8f,
+  0x73, 0x5b, 0xa9, 0x06, 0x92, 0xd0, 0xde, 0xdc, 0x47, 0x1a, 0xff, 0xae,
+  0x81, 0xfe, 0xf2, 0xbb, 0x3c, 0x86, 0xdc, 0xce, 0x95, 0x4d, 0x40, 0xf8,
+  0x33, 0x0d, 0x3e, 0x2e, 0x6e, 0x88, 0x95, 0x8a, 0xef, 0x93, 0x7a, 0x4f,
+  0xc7, 0x89, 0x19, 0x56, 0x27, 0xa9, 0xc4, 0x20, 0xc0, 0xa4, 0xc1, 0xd8,
+  0x31, 0x95, 0x0d, 0x93, 0x1b, 0x08, 0x1a, 0xcc, 0xb4, 0x48, 0x04, 0xe7,
+  0x2d, 0xba, 0xb8, 0xcb, 0x44, 0xea, 0x74, 0xb9, 0xf5, 0x12, 0xc5, 0x57,
+  0x2c, 0x53, 0x81, 0x8a, 0xa0, 0xcd, 0x63, 0x7e, 0x10, 0x14, 0x5b, 0xea,
+  0x38, 0x6b, 0xca, 0xa1, 0x73, 0x19, 0x0d, 0x0f, 0xbf, 0x8e, 0x90, 0x95,
+  0x8c, 0x3e, 0x0e, 0x80, 0x1f, 0x0f, 0xef, 0xef, 0x8c, 0xb5, 0x89, 0x2f,
+  0x97, 0x38, 0xef, 0x07, 0xd7, 0xf1, 0x02, 0x42, 0xf1, 0xee, 0x0e, 0x54,
+  0xf0, 0x6f, 0x2d, 0xbf, 0x09, 0x07, 0xd5, 0xca, 0xfc, 0x15, 0x9d, 0x40,
+  0x3b, 0x9f, 0xa0, 0x4e, 0x1f, 0x84, 0xe2, 0xaa, 0xe1, 0x8f, 0x6e, 0xcf,
+  0x62, 0x7b, 0x06, 0x86, 0x35, 0x2d, 0x88, 0x34, 0xf2, 0x62, 0x72, 0xb3,
+  0x3d, 0xa6, 0x7f, 0x9e, 0xec, 0x6c, 0x33, 0xf4, 0x60, 0xc9, 0x76, 0x32,
+  0xd0, 0xe4, 0xde, 0xde, 0xb3, 0x67, 0xbd, 0xa8, 0x03, 0xcb, 0x95, 0x75,
+  0x80, 0x23, 0x41, 0x27, 0xab, 0xd3, 0x56, 0x75, 0x6a, 0x3b, 0xbf, 0x1c,
+  0xe3, 0x3f, 0xbc, 0x66, 0x25, 0x77, 0x2e, 0x34, 0x61, 0x81, 0xd7, 0x61,
+  0x1e, 0x62, 0x8b, 0x18, 0x59, 0xdd, 0xd1, 0x3e, 0x98, 0x6d, 0x02, 0x6e,
+  0x88, 0x45, 0x92, 0x2d, 0xcc, 0xb1, 0x36, 0x5b, 0xe9, 0x75, 0xc3, 0x34,
+  0x16, 0x55, 0x92, 0x15, 0xaf, 0x25, 0x92, 0x48, 0x53, 0xc9, 0x8b, 0xe5,
+  0xa8, 0xaf, 0x39, 0x95, 0xa2, 0x6b, 0xa4, 0x74, 0x72, 0x67, 0xa8, 0x43,
+  0xad, 0x26, 0xe0, 0x06, 0x47, 0xfe, 0x22, 0xea, 0x28, 0x6d, 0xe1, 0xc7,
+  0x80, 0xfd, 0x62, 0xc9, 0x18, 0xd3, 0xc8, 0x5e, 0xe9, 0x1f, 0x7f, 0xf9,
+  0x0b, 0x35, 0xfb, 0x17, 0xb4, 0xf2, 0xea, 0x8f, 0x45, 0x79, 0x1d, 0x3c,
+  0xd3, 0x51, 0x82, 0x3f, 0xf6, 0x5e, 0x41, 0x8e, 0xf4, 0x61, 0x60, 0x4e,
+  0x4e, 0xfd, 0x79, 0x73, 0xa2, 0x1c, 0xb9, 0x17, 0xcc, 0x2f, 0xe5, 0xa4,
+  0x2c, 0x31, 0xbc, 0x39, 0x47, 0xfb, 0x17, 0xf0, 0xd8, 0x25, 0x48, 0xe6,
+  0x25, 0x2a, 0x64, 0xe4, 0xb5, 0x2d, 0x13, 0x31, 0x8e, 0xde, 0x7e, 0x73,
+  0x7c, 0x7e, 0xfa, 0xf6, 0xcd, 0xd1, 0xdb, 0x8b, 0xe8, 0x9b, 0xfd, 0xf3,
+  0xe3, 0xfd, 0x2f, 0x4e, 0x34, 0x67, 0x18, 0x53, 0x40, 0x7c, 0x84, 0x88,
+  0xde, 0x35, 0xdc, 0xcc, 0x20, 0x87, 0xa3, 0x15, 0x28, 0xbe, 0x56, 0x3c,
+  0xec, 0xbd, 0x22, 0x31, 0xb3, 0x8d, 0xf5, 0x3d, 0x17, 0x1b, 0xe8, 0xc1,
+  0xe9, 0xf7, 0xde, 0xea, 0x0e, 0xc0, 0x76, 0xb9, 0x0a, 0xb2, 0x50, 0x11,
+  0xba, 0x01, 0x2a, 0x35, 0xfe, 0xe4, 0xeb, 0x9c, 0x28, 0x94, 0xfd, 0x20,
+  0xfa, 0x52, 0x12, 0x99, 0x35, 0x88, 0xc8, 0xbd, 0xaa, 0x49, 0x35, 0x6a,
+  0xcb, 0x91, 0xff, 0xb9, 0x5f, 0xf6, 0x4f, 0x4e, 0x7c, 0x97, 0xfb, 0x22,
+  0xd8, 0xf6, 0x7d, 0x3e, 0xb0, 0x15, 0xe5, 0xe2, 0x9a, 0xf6, 0x02, 0x63,
+  0x23, 0xf9, 0x2f, 0xd7, 0x56, 0xae, 0xf3, 0x2a, 0xf3, 0xf0, 0xd2, 0xf3,
+  0x55, 0x88, 0x24, 0x8d, 0x4e, 0x69, 0x5b, 0x36, 0x05, 0x85, 0x00, 0xbe,
+  0x47, 0x3a, 0x48, 0x69, 0x71, 0xd3, 0x8b, 0xba, 0x7f, 0xec, 0x4a, 0x5e,
+  0x52, 0xc2, 0x30, 0xab, 0xdc, 0x7a, 0xe1, 0xeb, 0x05, 0x46, 0x6f, 0x4f,
+  0xfd, 0x98, 0x8e, 0x39, 0x0e, 0x1e, 0x44, 0xc5, 0x61, 0x8f, 0xb9, 0x83,
+  0xf0, 0x49, 0x34, 0x9f, 0xb7, 0xcf, 0xae, 0x6d, 0x09, 0xcf, 0xe6, 0x61,
+  0x5a, 0xcb, 0xde, 0x59, 0x5a, 0x24, 0x0e, 0xfb, 0x90, 0x91, 0x75, 0x49,
+  0x47, 0x8b, 0xc7, 0x01, 0x6a, 0xae, 0x98, 0x6e, 0xa0, 0xed, 0xf2, 0xb5,
+  0xaf, 0x55, 0x44, 0x65, 0x5d, 0x61, 0x14, 0x52, 0x7f, 0xd4, 0xb2, 0x50,
+  0x76, 0xc9, 0x24, 0x74, 0xbf, 0xad, 0xc0, 0xd5, 0xe2, 0xa4, 0x42, 0xdc,
+  0x74, 0x9e, 0x4e, 0x14, 0x84, 0xad, 0x95, 0x04, 0x06, 0xec, 0xdb, 0x38,
+  0x3f, 0x60, 0xc8, 0xea, 0x39, 0xaa, 0xcb, 0x38, 0x84, 0x7f, 0x89, 0xb1,
+  0x24, 0x96, 0x91, 0x23, 0x71, 0x69, 0xae, 0x12, 0x07, 0xc7, 0x2d, 0xb2,
+  0x3c, 0x1e, 0x5f, 0x65, 0x26, 0x6b, 0xc7, 0xce, 0xe1, 0x2a, 0x09, 0x49,
+  0x12, 0x92, 0x62, 0x22, 0x97, 0x43, 0x59, 0x72, 0x36, 0x2f, 0x76, 0xcd,
+  0x9a, 0x85, 0x19, 0x61, 0x38, 0x65, 0x00, 0x08, 0x5f, 0x04, 0xd9, 0xac,
+  0x3e, 0xca, 0x1b, 0x8c, 0x43, 0x9c, 0x92, 0x06, 0x7b, 0xc4, 0xe0, 0x52,
+  0x96, 0xfd, 0xca, 0x01, 0x61, 0x3c, 0x2c, 0x3c, 0xc8, 0x4d, 0x6a, 0x6c,
+  0x1f, 0x37, 0x69, 0xc6, 0x4f, 0x3a, 0x2a, 0x53, 0x24, 0xda, 0x18, 0xdb,
+  0x89, 0xa3, 0x51, 0x7a, 0x15, 0x99, 0xdd, 0x23, 0x02, 0x29, 0x30, 0x04,
+  0x56, 0x36, 0x4b, 0xb0, 0x55, 0x0c, 0x70, 0xc5, 0x82, 0xfa, 0x35, 0xaa,
+  0x2b, 0x7b, 0x44, 0x26, 0x9b, 0x49, 0x81, 0x40, 0xf4, 0xc0, 0x6e, 0xc6,
+  0xb6, 0xf3, 0x25, 0xd6, 0xd1, 0xa2, 0x76, 0x14, 0xbd, 0x59, 0x63, 0x98,
+  0x60, 0x94, 0x65, 0x2c, 0xb9, 0x39, 0x67, 0x4c, 0x58, 0xf6, 0x29, 0xaf,
+  0x83, 0xc5, 0x77, 0x82, 0x35, 0xb0, 0x29, 0x25, 0x99, 0x5e, 0x46, 0x9b,
+  0x0e, 0x7e, 0x99, 0x6b, 0x68, 0x0b, 0x7e, 0x25, 0x28, 0x5b, 0xc2, 0xaf,
+  0x2b, 0x65, 0x12, 0x6c, 0xb3, 0x14, 0x67, 0xe8, 0x52, 0x4a, 0x42, 0xd3,
+  0xf8, 0x36, 0x03, 0x2e, 0x33, 0x27, 0x12, 0x91, 0xc7, 0x44, 0x59, 0xd4,
+  0xbf, 0xfa, 0xe2, 0xaf, 0x8c, 0xad, 0xaa, 0x4f, 0xb1, 0xe5, 0x7d, 0xd6,
+  0x72, 0xe5, 0x83, 0x56, 0x25, 0x0d, 0x45, 0xc5, 0x62, 0xda, 0x2f, 0x33,
+  0x3d, 0x85, 0x96, 0xab, 0xc8, 0x12, 0x13, 0xa6, 0xd3, 0x00, 0x7f, 0x59,
+  0x6c, 0x0f, 0x71, 0x43, 0xd2, 0x70, 0xa5, 0x9d, 0xf7, 0x35, 0x44, 0x42,
+  0xb0, 0x5a, 0x83, 0x99, 0x68, 0xf0, 0x2d, 0x64, 0xb1, 0x9a, 0x41, 0x2c,
+  0x60, 0x5f, 0xe6, 0x5f, 0x0d, 0xaf, 0x21, 0x2d, 0x01, 0x90, 0xc6, 0x33,
+  0x91, 0x14, 0x3d, 0xf9, 0xcd, 0x56, 0x12, 0x9e, 0xb5, 0xb1, 0x71, 0xf0,
+  0x6e, 0x78, 0x71, 0xfa, 0x26, 0x3a, 0x7d, 0x77, 0x71, 0xf6, 0xee, 0x42,
+  0xef, 0xa9, 0x91, 0x04, 0xb0, 0x8a, 0x42, 0x28, 0x57, 0xbe, 0xed, 0xe6,
+  0x4c, 0x9d, 0xc6, 0x1c, 0x9e, 0x90, 0x31, 0xee, 0x5a, 0x00, 0xc2, 0xe2,
+  0x92, 0x57, 0x18, 0x93, 0x48, 0xe0, 0x5c, 0x79, 0xcd, 0xef, 0x68, 0xcd,
+  0x39, 0xf1, 0x90, 0x0d, 0x39, 0x96, 0x0b, 0xc3, 0x4a, 0x4e, 0x7b, 0x39,
+  0x8d, 0x55, 0x55, 0x69, 0x61, 0xf7, 0x6e, 0x15, 0xec, 0xc6, 0x07, 0x9c,
+  0x98, 0x21, 0xc7, 0xdb, 0x79, 0xc2, 0xd8, 0x37, 0x8e, 0xfa, 0x18, 0x97,
+  0x66, 0xbe, 0xb4, 0xf0, 0x43, 0x0e, 0x34, 0xa9, 0x66, 0x60, 0x85, 0x89,
+  0x60, 0x65, 0x46, 0x33, 0xbc, 0x76, 0xa1, 0xc3, 0x88, 0x92, 0xe6, 0x90,
+  0x29, 0x71, 0xc1, 0x23, 0x36, 0xc9, 0xea, 0x33, 0xdf, 0xc1, 0xe8, 0xdd,
+  0xb8, 0x53, 0xef, 0xa2, 0xee, 0xb7, 0x49, 0xd8, 0xe0, 0xef, 0xff, 0x81,
+  0xfc, 0xb6, 0xf7, 0xf6, 0xc9, 0x3f, 0xa5, 0xcb, 0x1f, 0xe7, 0x5d, 0x8e,
+  0x34, 0xaa, 0xfa, 0x5a, 0xbf, 0x3e, 0x3a, 0xff, 0xe2, 0xe8, 0xfc, 0x74,
+  0xc8, 0xf1, 0x26, 0x66, 0xdb, 0x6a, 0x12, 0xfb, 0x4d, 0x92, 0x8f, 0x92,
+  0x3c, 0xd3, 0x0a, 0x29, 0xf6, 0xd7, 0xb3, 0xed, 0x2f, 0x87, 0xc3, 0xfd,
+  0xb3, 0x63, 0x57, 0x4c, 0xc3, 0x65, 0xda, 0x88, 0x42, 0x34, 0x97, 0x5c,
+  0x30, 0xcc, 0xdf, 0x5e, 0x21, 0xba, 0x18, 0xdf, 0x48, 0x04, 0x66, 0xc3,
+  0xab, 0x69, 0x56, 0x59, 0xb8, 0x33, 0x35, 0x01, 0x0b, 0x0d, 0x1b, 0x78,
+  0xce, 0x46, 0x50, 0x9b, 0xfc, 0x35, 0x8c, 0xc8, 0x3d, 0x17, 0xa5, 0x74,
+  0x93, 0x8f, 0xfa, 0x44, 0xe8, 0x37, 0x56, 0x7c, 0x4e, 0x62, 0xc5, 0x89,
+  0x4d, 0x4a, 0x10, 0xa9, 0x37, 0x2a, 0xdc, 0xa0, 0x20, 0xe4, 0xf6, 0x0d,
+  0x8e, 0x06, 0xea, 0x3f, 0x4c, 0x07, 0xc2, 0xd9, 0xe5, 0x2c, 0x59, 0x64,
+  0x20, 0xd8, 0xeb, 0x43, 0xb9, 0xfc, 0xd4, 0x9b, 0x2b, 0x24, 0x24, 0x76,
+  0x2d, 0xfa, 0xe4, 0xa9, 0x03, 0x33, 0x0a, 0x6b, 0x05, 0x5e, 0x92, 0xa4,
+  0xbd, 0xb8, 0x9b, 0xe8, 0x05, 0xc2, 0xf8, 0xbd, 0x73, 0xb1, 0x6b, 0x0b,
+  0xff, 0xae, 0x7b, 0x37, 0x50, 0xf9, 0x88, 0x83, 0xda, 0x35, 0x64, 0x37,
+  0x1a, 0x4d, 0xe3, 0xf9, 0x0d, 0xdf, 0x64, 0x7c, 0x33, 0x41, 0xb7, 0x34,
+  0xa8, 0x1e, 0xd4, 0x89, 0x62, 0x67, 0x96, 0x66, 0xcf, 0xb3, 0xb4, 0x67,
+  0x75, 0x85, 0x61, 0xc8, 0x75, 0x88, 0x44, 0x81, 0xdb, 0x86, 0x4f, 0x92,
+  0x5f, 0x04, 0x98, 0x88, 0xb8, 0xd0, 0xba, 0x0b, 0xc4, 0x67, 0x5d, 0x5c,
+  0x2a, 0xa9, 0x5b, 0x38, 0x89, 0xe4, 0x9e, 0xa5, 0xcc, 0xc4, 0x84, 0x71,
+  0x18, 0xb4, 0x34, 0x3b, 0x1e, 0x98, 0x52, 0x38, 0xc5, 0xae, 0x70, 0x15,
+  0x18, 0x94, 0x6b, 0x6b, 0x59, 0xe9, 0xb2, 0x52, 0x90, 0x21, 0xac, 0xd6,
+  0xa1, 0x48, 0xd7, 0x07, 0x3e, 0x98, 0x24, 0xb6, 0xef, 0x64, 0x10, 0x5e,
+  0xfe, 0x74, 0xee, 0xa9, 0x4a, 0x06, 0xc0, 0xda, 0x6d, 0x92, 0xd7, 0xdb,
+  0xb4, 0x7d, 0x66, 0x80, 0xd4, 0x80, 0x18, 0xbb, 0x1d, 0x7a, 0x8a, 0x85,
+  0x75, 0x56, 0x43, 0x29, 0x6d, 0xe0, 0x03, 0xab, 0x5e, 0xcc, 0x01, 0x4f,
+  0xe2, 0x71, 0xe2, 0x30, 0x40, 0xbd, 0x7d, 0xcb, 0x09, 0x73, 0x9b, 0xbc,
+  0x02, 0xe3, 0x19, 0x46, 0x30, 0x4a, 0x82, 0x3f, 0xdb, 0x00, 0x25, 0xa6,
+  0x9d, 0xd5, 0x15, 0x27, 0xc8, 0xf6, 0xdf, 0xe2, 0xaa, 0xc8, 0xfa, 0xa3,
+  0x25, 0x2b, 0x60, 0x1e, 0x8a, 0x4a, 0xf3, 0xdc, 0x50, 0x0f, 0x94, 0xb1,
+  0xa7, 0xf8, 0x7b, 0x38, 0x32, 0x38, 0x83, 0x58, 0x7c, 0x1b, 0x9c, 0x52,
+  0x56, 0xc5, 0x25, 0x71, 0x68, 0x14, 0x12, 0xa7, 0xcd, 0xf1, 0xaa, 0x1a,
+  0x94, 0xab, 0x23, 0xd4, 0x4d, 0x76, 0x31, 0x66, 0x73, 0x2d, 0x67, 0xc6,
+  0x46, 0xf5, 0x6a, 0x54, 0x6a, 0xe9, 0xa0, 0xc0, 0x2f, 0x58, 0x44, 0x48,
+  0x14, 0x20, 0xdb, 0xc2, 0x4d, 0x2d, 0xb8, 0xfd, 0xb6, 0x44, 0xe1, 0x1b,
+  0x49, 0xa4, 0x8f, 0xa7, 0x52, 0xc2, 0x60, 0xed, 0x2d, 0x22, 0x87, 0xa9,
+  0xbc, 0xb8, 0xf8, 0xfe, 0xec, 0xe8, 0x95, 0xbd, 0xf9, 0xd0, 0x9e, 0x09,
+  0xbe, 0x14, 0x07, 0x5c, 0x24, 0x8a, 0xe4, 0x18, 0x14, 0xf8, 0x23, 0x22,
+  0xeb, 0x97, 0xe6, 0x08, 0x96, 0x6e, 0xfa, 0xd1, 0x77, 0x87, 0xc7, 0xc3,
+  0xb3, 0x93, 0xd3, 0x83, 0x57, 0x2f, 0xbf, 0x33, 0x6e, 0xfc, 0x19, 0x00,
+  0x55, 0x44, 0x46, 0x73, 0x9f, 0xf9, 0xfc, 0x77, 0x7d, 0xef, 0xed, 0xd1,
+  0xb7, 0xef, 0x49, 0x0d, 0x78, 0x05, 0xc4, 0xeb, 0xde, 0x6d, 0x3c, 0xd5,
+  0x97, 0xa0, 0x4b, 0xb5, 0xc8, 0x75, 0x41, 0xb6, 0x42, 0xdb, 0xc2, 0xba,
+  0x9a, 0xd6, 0x3e, 0x96, 0x7b, 0x65, 0x31, 0x58, 0x41, 0xe1, 0x9c, 0xb8,
+  0x92, 0x7a, 0xd8, 0x52, 0x35, 0x2f, 0x73, 0x37, 0x7f, 0xb7, 0x94, 0x58,
+  0x3c, 0xf8, 0x9f, 0x43, 0xb7, 0x2e, 0x47, 0x6e, 0xea, 0x37, 0x3e, 0xe6,
+  0x51, 0xb1, 0x65, 0x73, 0x44, 0x3f, 0x38, 0x8c, 0x3e, 0xe9, 0x58, 0x1c,
+  0xa6, 0x0a, 0xe4, 0xa7, 0x40, 0x35, 0x80, 0x27, 0xb0, 0x88, 0x63, 0x57,
+  0x80, 0x55, 0xc4, 0x17, 0x37, 0x96, 0x78, 0x3c, 0xa6, 0x1f, 0x00, 0x50,
+  0x44, 0xb1, 0x92, 0x33, 0x14, 0x64, 0x1e, 0x5e, 0x40, 0x5f, 0x3a, 0x38,
+  0x7d, 0xfb, 0xf6, 0xe8, 0xc0, 0x6c, 0xcd, 0x56, 0xeb, 0x8b, 0xf3, 0xda,
+  0xab, 0xc0, 0x8c, 0x61, 0x1d, 0x85, 0xca, 0x89, 0x76, 0x6c, 0xae, 0x9a,
+  0xe8, 0x06, 0x93, 0x81, 0x64, 0xcf, 0x41, 0x08, 0x15, 0x78, 0xd1, 0xf8,
+  0xd2, 0x0e, 0x70, 0xa6, 0xa4, 0x51, 0x2b, 0x27, 0xc0, 0xb5, 0x40, 0x78,
+  0x77, 0xa6, 0xe9, 0xc8, 0x5b, 0xc7, 0x6b, 0xbe, 0x47, 0xb8, 0xb6, 0x15,
+  0xd0, 0x20, 0x3c, 0x42, 0x66, 0xf7, 0xf6, 0xd9, 0xa3, 0x45, 0x66, 0x75,
+  0xed, 0x84, 0xf8, 0xd9, 0x2e, 0x1d, 0xe6, 0xf8, 0x39, 0x8d, 0x94, 0xd5,
+  0x10, 0x13, 0xd1, 0xdc, 0xa7, 0x41, 0xf0, 0xa2, 0x62, 0xe4, 0x30, 0xb0,
+  0xa7, 0xb2, 0x6c, 0x2e, 0x55, 0x2c, 0xd9, 0x3a, 0xb0, 0xa8, 0x90, 0xc0,
+  0xc2, 0xd9, 0xc7, 0x1c, 0x64, 0xa2, 0x33, 0x6b, 0x48, 0x1f, 0x2a, 0x36,
+  0x5e, 0x21, 0xcd, 0x87, 0x81, 0x88, 0x26, 0x10, 0xb5, 0xd8, 0xd4, 0x16,
+  0x76, 0x66, 0x37, 0x29, 0x56, 0xd0, 0xaa, 0x81, 0x8b, 0x1b, 0xd6, 0x8d,
+  0x5e, 0xea, 0x35, 0xf0, 0xc2, 0x73, 0x78, 0x5d, 0x9c, 0x33, 0xc2, 0x5f,
+  0xa9, 0x30, 0xda, 0xa6, 0xf4, 0x68, 0xac, 0xdc, 0xa0, 0x8a, 0x79, 0x62,
+  0x74, 0xa9, 0xc1, 0x2d, 0x0f, 0xae, 0xa8, 0x5b, 0x4d, 0x21, 0xdf, 0x3c,
+  0xb1, 0xa0, 0x17, 0xb1, 0x27, 0x14, 0x70, 0x2c, 0xcc, 0xc7, 0xee, 0x32,
+  0x46, 0x62, 0x06, 0x82, 0x3f, 0x72, 0xc5, 0x93, 0x59, 0xa2, 0x2e, 0xb2,
+  0x96, 0x76, 0xe4, 0xc2, 0x84, 0xf0, 0xae, 0x19, 0xd6, 0x98, 0x03, 0xe9,
+  0xd0, 0xe5, 0x0e, 0xc8, 0x4a, 0xec, 0xe8, 0x2b, 0xed, 0xd0, 0x25, 0x11,
+  0xdb, 0x66, 0xf5, 0x24, 0x27, 0x25, 0xe6, 0x14, 0x08, 0x33, 0xe0, 0x06,
+  0xa9, 0x74, 0x85, 0x26, 0x28, 0x3a, 0xcf, 0xa4, 0x30, 0x3c, 0xae, 0xc7,
+  0xe3, 0x53, 0x7a, 0x2a, 0x1e, 0x40, 0x92, 0x2c, 0x17, 0x5c, 0x5c, 0x66,
+  0xac, 0xf0, 0xda, 0x1c, 0xee, 0xe9, 0xda, 0xb3, 0x3b, 0xc4, 0xaf, 0x15,
+  0x2d, 0xea, 0x9b, 0x77, 0x27, 0x17, 0xc7, 0x67, 0xa1, 0x97, 0x31, 0xfa,
+  0xf6, 0xf8, 0xe2, 0x2b, 0x92, 0xd7, 0x51, 0x38, 0xf6, 0x04, 0xae, 0x9c,
+  0x37, 0x6f, 0xf6, 0xdf, 0x22, 0x01, 0xfb, 0x2d, 0x47, 0xc5, 0xed, 0xb3,
+  0xce, 0x00, 0x6e, 0x44, 0x2b, 0x0c, 0xd2, 0x41, 0x6a, 0x6e, 0xaf, 0xe9,
+  0x52, 0xa8, 0x9d, 0x3e, 0x66, 0x38, 0x38, 0x42, 0xe1, 0x1a, 0x61, 0xc3,
+  0x55, 0x27, 0x58, 0xc1, 0x80, 0xc3, 0xa7, 0x16, 0x7a, 0x16, 0xd6, 0xb9,
+  0x8e, 0xab, 0xcd, 0x69, 0x60, 0x22, 0x9b, 0xb3, 0x03, 0x55, 0xae, 0x6e,
+  0xef, 0xa6, 0xe0, 0x0d, 0x75, 0xe0, 0x9c, 0x1c, 0xa5, 0x4a, 0x22, 0xd3,
+  0x5c, 0x55, 0x1a, 0xb9, 0x2e, 0xab, 0x61, 0xd9, 0xd4, 0x23, 0x0f, 0x89,
+  0x5d, 0xc8, 0x99, 0xb7, 0xfc, 0x41, 0xd9, 0x84, 0xbe, 0x7c, 0x7e, 0x12,
+  0xde, 0xa7, 0x83, 0x4a, 0x35, 0x26, 0x0b, 0x2d, 0xbb, 0xca, 0x12, 0x7f,
+  0x70, 0xfb, 0xa7, 0x41, 0xd1, 0xd4, 0xd0, 0xaa, 0xfc, 0x42, 0xe4, 0xc6,
+  0x4a, 0x11, 0x60, 0xc6, 0x3c, 0x3d, 0x75, 0xef, 0x6a, 0x90, 0x02, 0xc7,
+  0xea, 0x6a, 0x6e, 0x87, 0xce, 0x8a, 0xd9, 0xa1, 0x3d, 0x56, 0x49, 0x4d,
+  0xad, 0x55, 0x22, 0xb6, 0xdc, 0x1e, 0xce, 0xe8, 0x03, 0x06, 0x89, 0x77,
+  0x81, 0x72, 0x59, 0xa9, 0x2c, 0x1b, 0x24, 0xf7, 0x09, 0xbc, 0x95, 0xf8,
+  0xf5, 0xaf, 0x8b, 0xab, 0x30, 0xed, 0x87, 0x67, 0xa3, 0xf9, 0xad, 0xed,
+  0x90, 0xb6, 0x22, 0xf7, 0x68, 0x71, 0xad, 0xca, 0x08, 0xb4, 0x62, 0xd6,
+  0xee, 0xba, 0x0e, 0xf5, 0xfb, 0xbd, 0xe6, 0xf7, 0x7b, 0x62, 0x40, 0x7c,
+  0xb3, 0x7f, 0x7c, 0x02, 0x7f, 0xf7, 0x09, 0x31, 0xf5, 0xa1, 0xad, 0x1d,
+  0x07, 0x05, 0xb0, 0xbf, 0x9e, 0xd4, 0x3b, 0x3a, 0xa0, 0x3d, 0x07, 0xc5,
+  0x6c, 0xb1, 0xb5, 0xcc, 0xa9, 0x60, 0xb7, 0x93, 0xcb, 0x5e, 0x91, 0x53,
+  0xe8, 0x8a, 0xa5, 0x05, 0x2c, 0x44, 0x43, 0x63, 0x80, 0x32, 0x20, 0x77,
+  0xb2, 0x8d, 0x94, 0x2f, 0x51, 0x09, 0x60, 0x60, 0xf4, 0xf7, 0x3c, 0x99,
+  0x26, 0xb7, 0xaa, 0x4a, 0x09, 0xdc, 0xd3, 0x97, 0x6a, 0x9e, 0x94, 0xea,
+  0x4f, 0xa5, 0xb7, 0xb2, 0x56, 0x2c, 0xa0, 0xe8, 0x73, 0x5b, 0x32, 0x65,
+  0x7d, 0x02, 0x24, 0xba, 0xf7, 0xd8, 0xa4, 0x66, 0x0d, 0xc6, 0x7b, 0x7d,
+  0xdc, 0x6a, 0x85, 0xac, 0xd8, 0xbb, 0x42, 0x73, 0xdc, 0xea, 0xa1, 0x45,
+  0xa2, 0x1d, 0x58, 0xf9, 0x10, 0xd1, 0xb4, 0x7b, 0x86, 0x22, 0x27, 0xf6,
+  0x01, 0x30, 0xc2, 0x1e, 0xb4, 0x32, 0x6e, 0xe9, 0x92, 0x58, 0x30, 0x80,
+  0x82, 0x7b, 0x92, 0x5f, 0xc1, 0x34, 0x4d, 0xba, 0x78, 0x2f, 0x62, 0x47,
+  0x29, 0xf8, 0x1f, 0x3f, 0x0b, 0x14, 0xac, 0x20, 0x7c, 0x81, 0xfe, 0x94,
+  0xd8, 0x39, 0xfd, 0x8b, 0x9b, 0xca, 0x97, 0x0c, 0xb6, 0xd6, 0xe3, 0x20,
+  0x56, 0xb6, 0x27, 0x6a, 0xbd, 0x62, 0x1e, 0xbd, 0x9a, 0xf3, 0x65, 0xfc,
+  0x87, 0x66, 0x6d, 0x36, 0xac, 0xab, 0x2c, 0xb7, 0xd5, 0x95, 0x5d, 0x18,
+  0x49, 0xb5, 0x97, 0x2f, 0x96, 0x30, 0x7c, 0x39, 0x34, 0x73, 0x8c, 0x62,
+  0x86, 0x2a, 0x4d, 0x89, 0x14, 0x56, 0x72, 0x8d, 0x83, 0x87, 0x2f, 0x69,
+  0x77, 0xa5, 0xf5, 0x93, 0xec, 0x0e, 0x65, 0xa1, 0x2e, 0x2f, 0x51, 0xa3,
+  0xf6, 0x74, 0xee, 0x41, 0xd5, 0x70, 0x66, 0xe4, 0xc1, 0x99, 0x41, 0xd1,
+  0xd3, 0xdc, 0xa2, 0xc5, 0x72, 0x34, 0x25, 0x35, 0xc1, 0xa2, 0x9f, 0x06,
+  0xd1, 0x3e, 0xaf, 0x12, 0xb1, 0x57, 0x6e, 0x4e, 0xcc, 0xf4, 0x7c, 0xc3,
+  0xd4, 0x82, 0x6d, 0xb4, 0x5c, 0x25, 0x8e, 0xe4, 0x8c, 0xeb, 0x63, 0x21,
+  0xa8, 0x64, 0x96, 0xcd, 0x2d, 0x76, 0x72, 0x59, 0x08, 0xc4, 0x8e, 0xd5,
+  0xb6, 0xdc, 0x10, 0x33, 0x44, 0x3a, 0x55, 0x4c, 0x4b, 0xbd, 0x8b, 0xf9,
+  0x8d, 0x70, 0x32, 0x93, 0xfe, 0xe2, 0x7a, 0x61, 0x3b, 0x6d, 0x4c, 0x5f,
+  0x62, 0xf7, 0x35, 0x5a, 0x8f, 0xcf, 0xd3, 0xd9, 0x57, 0x67, 0x83, 0xe8,
+  0x08, 0x2d, 0xc9, 0x98, 0x54, 0x54, 0x60, 0xa1, 0x8c, 0xbe, 0xa3, 0xc9,
+  0x5e, 0x21, 0x2b, 0xf7, 0x34, 0xc7, 0x5f, 0xdc, 0x9a, 0x7e, 0x29, 0x7a,
+  0x18, 0x7f, 0x5b, 0xed, 0x95, 0x1a, 0xca, 0xb4, 0xaa, 0xf1, 0x19, 0xff,
+  0x4e, 0x47, 0x85, 0xd4, 0x53, 0xb7, 0x4d, 0xbe, 0x87, 0x2c, 0xaf, 0x24,
+  0x24, 0xcb, 0x9b, 0xd1, 0x28, 0x15, 0x9d, 0x7f, 0xb1, 0xe2, 0xfd, 0x63,
+  0x19, 0x9e, 0xb3, 0xd8, 0x35, 0xdb, 0x45, 0x1a, 0x08, 0x48, 0x4b, 0xc9,
+  0xcf, 0x39, 0xe6, 0xe5, 0x5c, 0xe5, 0x92, 0x8a, 0x9b, 0x27, 0x1a, 0xc6,
+  0x90, 0xa9, 0x4d, 0x54, 0x44, 0x98, 0x22, 0xa9, 0x1d, 0xd7, 0x80, 0x63,
+  0xdb, 0x17, 0xb8, 0x67, 0x31, 0x96, 0xdb, 0x74, 0x42, 0x5b, 0x30, 0xd8,
+  0xf8, 0x5f, 0x3c, 0x60, 0xfe, 0x72, 0x59, 0xda, 0x01, 0x00,
 };
 /* Decompress and send to stdout a gzip-compressed buffer */
 void hugehelp(void)
 {
   unsigned char buf[0x10000];
   int status,headerlen;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/main.c	2007-10-03 16:00:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/main.c	2008-01-24 06:20:22.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: main.c,v 1.429 2007-10-03 08:00:43 bagder Exp $
+ * $Id: main.c,v 1.456 2008-01-23 06:11:11 yangtse Exp $
  ***************************************************************************/
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -82,12 +82,14 @@
 #ifdef HAVE_LIMITS_H
 #include <limits.h>
 #endif
 
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
+#elif defined(HAVE_POLL_H)
+#include <poll.h>
 #endif
 
 #ifdef HAVE_LOCALE_H
 #include <locale.h> /* for setlocale() */
 #endif
 
@@ -101,12 +103,19 @@
 /* set default codesets for iconv */
 #ifndef CURL_ICONV_CODESET_OF_NETWORK
 #define CURL_ICONV_CODESET_OF_NETWORK "ISO8859-1"
 #endif
 #endif /* CURL_DOES_CONVERSIONS && HAVE_ICONV */
 
+#ifdef HAVE_NETINET_IN_H
+#include <netinet/in.h> /* for IPPROTO_TCP */
+#endif
+#ifdef HAVE_NETINET_TCP_H
+#include <netinet/tcp.h> /* for TCP_KEEPIDLE, TCP_KEEPINTVL */
+#endif
+
 /* The last #include file should be: */
 #ifdef CURLDEBUG
 #ifndef CURLTOOLDEBUG
 #define MEMDEBUG_NODEFINES
 #endif
 /* This is low-level hard-hacking memory leak tracking and similar. Using
@@ -124,12 +133,18 @@
     #define SET_BINMODE(file) setmode(fileno(file),O_BINARY)
   #endif
 #else
   #define SET_BINMODE(file)   ((void)0)
 #endif
 
+#ifndef O_BINARY
+/* since O_BINARY as used in bitmasks, setting it to zero makes it usable in
+   source code but yet it doesn't ruin anything */
+#define O_BINARY 0
+#endif
+
 #ifdef MSDOS
 #include <dos.h>
 
 const char *msdosify(const char *);
 char *rename_if_dos_device_name(char *);
 
@@ -140,12 +155,24 @@
   (void)arg;
   return (char**)0;
 }
 #endif /* __DJGPP__ */
 #endif /* MSDOS */
 
+#ifndef STDIN_FILENO
+#define STDIN_FILENO  fileno(stdin)
+#endif
+
+#ifndef STDOUT_FILENO
+#define STDOUT_FILENO  fileno(stdout)
+#endif
+
+#ifndef STDERR_FILENO
+#define STDERR_FILENO  fileno(stderr)
+#endif
+
 #define CURL_PROGRESS_STATS 0 /* default progress display */
 #define CURL_PROGRESS_BAR   1
 
 /**
  * @def MIN
  * standard MIN macro
@@ -198,12 +225,13 @@
 #include "curlmsg_vms.h"
 #endif
 
 /* Support uploading and resuming of >2GB files
  */
 #if defined(WIN32) && (SIZEOF_CURL_OFF_T > 4)
+#define lseek(x,y,z) _lseeki64(x, y, z)
 #define struct_stat struct _stati64
 #define stat(file,st) _stati64(file,st)
 #else
 #define struct_stat struct stat
 #endif
 
@@ -320,27 +348,25 @@
  * Borland doesn't even support 64-bit types.
  */
 #ifdef __BORLANDC__
 #define _lseeki64(hnd,ofs,whence) lseek(hnd,ofs,whence)
 #endif
 
+#ifndef HAVE_FTRUNCATE
+#define HAVE_FTRUNCATE 1
+#endif
+
 static int ftruncate64 (int fd, curl_off_t where)
 {
-  curl_off_t curr;
-  int rc = 0;
-
-  if ((curr = _lseeki64(fd, 0, SEEK_CUR)) < 0)
-     return -1;
+  if(_lseeki64(fd, where, SEEK_SET) < 0)
+    return -1;
 
-  if (_lseeki64(fd, where, SEEK_SET) < 0)
-     return -1;
+  if(!SetEndOfFile((HANDLE)_get_osfhandle(fd)))
+    return -1;
 
-  if (write(fd, 0, 0) < 0)
-     rc = -1;
-  _lseeki64(fd, curr, SEEK_SET);
-  return rc;
+  return 0;
 }
 #define ftruncate(fd,where) ftruncate64(fd,where)
 #endif
 
 typedef enum {
     TRACE_BIN,   /* tcpdump inspired look */
@@ -354,12 +380,13 @@
   struct Configurable *config;
   curl_off_t bytes; /* amount written so far */
   curl_off_t init;  /* original size (non-zero when appending) */
 };
 
 struct Configurable {
+  CURL *easy; /* once we have one, we keep it here */
   bool remote_time;
   char *random_file;
   char *egd_file;
   char *useragent;
   char *cookie;     /* single line with specified cookies */
   char *cookiejar;  /* write to this file */
@@ -370,13 +397,13 @@
   bool use_resume;
   bool resume_from_current;
   bool disable_epsv;
   bool disable_eprt;
   curl_off_t resume_from;
   char *postfields;
-  long postfieldsize;
+  curl_off_t postfieldsize;
   char *referer;
   long timeout;
   long connecttimeout;
   long maxredirs;
   curl_off_t max_filesize;
   char *headerfile;
@@ -477,12 +504,15 @@
   bool ignorecl; /* --ignore-content-length */
   bool disable_sessionid;
 
   char *libcurl; /* output libcurl code to this file name */
   bool raw;
   bool post301;
+  bool nokeepalive; /* for keepalive needs */
+  long alivetime;
+
   struct OutStruct *outs;
 };
 
 #define WARN_PREFIX "Warning: "
 #define WARN_TEXTWIDTH (79 - (int)strlen(WARN_PREFIX))
 /* produce this text message to the user unless mute was selected */
@@ -602,145 +632,158 @@
 #define GETOUT_UPLOAD  (1<<3)   /* if set, -T has been used */
 #define GETOUT_NOUPLOAD  (1<<4) /* if set, -T "" has been used */
 
 static void help(void)
 {
   int i;
+  /* A few of these source lines are >80 columns wide, but that's only because
+     breaking the strings narrower makes this chunk look even worse!
+
+     Starting with 7.18.0, this list of command line options is sorted based
+     on the long option name. It is not done automatically, although a command
+     line like the following can help out:
+
+     curl --help | cut -c5- | grep "^-" | sort
+  */
   static const char * const helptext[]={
     "Usage: curl [options...] <url>",
     "Options: (H) means HTTP/HTTPS only, (F) means FTP only",
-    " -a/--append        Append to target file when uploading (F)",
-    " -A/--user-agent <string> User-Agent to send to server (H)",
     "    --anyauth       Pick \"any\" authentication method (H)",
-    " -b/--cookie <name=string/file> Cookie string or file to read cookies from (H)",
+    " -a/--append        Append to target file when uploading (F)",
     "    --basic         Use HTTP Basic Authentication (H)",
-    " -B/--use-ascii     Use ASCII/text transfer",
-    " -c/--cookie-jar <file> Write cookies to this file after operation (H)",
+    "    --cacert <file> CA certificate to verify peer against (SSL)",
+    "    --capath <directory> CA directory to verify peer against (SSL)",
+    " -E/--cert <cert[:passwd]> Client certificate file and password (SSL)",
+    "    --cert-type <type> Certificate file type (DER/PEM/ENG) (SSL)",
+    "    --ciphers <list> SSL ciphers to use (SSL)",
+    "    --compressed    Request compressed response (using deflate or gzip)",
+    " -K/--config        Specify which config file to read",
+    "    --connect-timeout <seconds> Maximum time allowed for connection",
     " -C/--continue-at <offset> Resumed transfer offset",
+    " -b/--cookie <name=string/file> Cookie string or file to read cookies from (H)",
+    " -c/--cookie-jar <file> Write cookies to this file after operation (H)",
+    "    --create-dirs   Create necessary local directory hierarchy",
+    "    --crlf          Convert LF to CRLF in upload",
     " -d/--data <data>   HTTP POST data (H)",
     "    --data-ascii <data>  HTTP POST ASCII data (H)",
     "    --data-binary <data> HTTP POST binary data (H)",
-    "    --negotiate     Use HTTP Negotiate Authentication (H)",
+    "    --data-urlencode <name=data/name@filename> HTTP POST data url encoded (H)",
     "    --digest        Use HTTP Digest Authentication (H)",
     "    --disable-eprt  Inhibit using EPRT or LPRT (F)",
     "    --disable-epsv  Inhibit using EPSV (F)",
     " -D/--dump-header <file> Write the headers to this file",
     "    --egd-file <file> EGD socket path for random data (SSL)",
-    "    --tcp-nodelay   Use the TCP_NODELAY option",
+    "    --engine <eng>  Crypto engine to use (SSL). \"--engine list\" for list",
 #ifdef USE_ENVIRONMENT
     "    --environment   Write results to environment variables (RISC OS)",
 #endif
-    " -e/--referer       Referer URL (H)",
-    " -E/--cert <cert[:passwd]> Client certificate file and password (SSL)",
-    "    --cert-type <type> Certificate file type (DER/PEM/ENG) (SSL)",
-    "    --key <key>     Private key file name (SSL/SSH)",
-    "    --key-type <type> Private key file type (DER/PEM/ENG) (SSL)",
-    "    --pass  <pass>  Pass phrase for the private key (SSL/SSH)",
-    "    --pubkey <key>  Public key file name (SSH)",
-    "    --engine <eng>  Crypto engine to use (SSL). \"--engine list\" for list",
-    "    --cacert <file> CA certificate to verify peer against (SSL)",
-    "    --capath <directory> CA directory (made using c_rehash) to verify",
-    "                    peer against (SSL)",
-    "    --hostpubmd5 <md5> Hex encoded MD5 string of the host public key. (SSH)",
-    "    --ciphers <list> SSL ciphers to use (SSL)",
-    "    --compressed    Request compressed response (using deflate or gzip)",
-    "    --connect-timeout <seconds> Maximum time allowed for connection",
-    "    --create-dirs   Create necessary local directory hierarchy",
-    "    --crlf          Convert LF to CRLF in upload",
     " -f/--fail          Fail silently (no output at all) on HTTP errors (H)",
+    " -F/--form <name=content> Specify HTTP multipart POST data (H)",
+    "    --form-string <name=string> Specify HTTP multipart POST data (H)",
     "    --ftp-account <data> Account data to send when requested by server (F)",
     "    --ftp-alternative-to-user String to replace \"USER [name]\" (F)",
     "    --ftp-create-dirs Create the remote dirs if not present (F)",
     "    --ftp-method [multicwd/nocwd/singlecwd] Control CWD usage (F)",
     "    --ftp-pasv      Use PASV/EPSV instead of PORT (F)",
+    " -P/--ftp-port <address> Use PORT with address instead of PASV (F)",
     "    --ftp-skip-pasv-ip Skip the IP address for PASV (F)\n"
     "    --ftp-ssl       Try SSL/TLS for ftp transfer (F)",
-    "    --ftp-ssl-control Require SSL/TLS for ftp login, clear for transfer (F)",
-    "    --ftp-ssl-reqd  Require SSL/TLS for ftp transfer (F)",
     "    --ftp-ssl-ccc   Send CCC after authenticating (F)",
     "    --ftp-ssl-ccc-mode [active/passive] Set CCC mode (F)",
-    " -F/--form <name=content> Specify HTTP multipart POST data (H)",
-    "    --form-string <name=string> Specify HTTP multipart POST data (H)",
-    " -g/--globoff       Disable URL sequences and ranges using {} and []",
+    "    --ftp-ssl-control Require SSL/TLS for ftp login, clear for transfer (F)",
+    "    --ftp-ssl-reqd  Require SSL/TLS for ftp transfer (F)",
     " -G/--get           Send the -d data with a HTTP GET (H)",
-    " -h/--help          This help text",
+    " -g/--globoff       Disable URL sequences and ranges using {} and []",
     " -H/--header <line> Custom header to pass to server (H)",
+    " -I/--head          Show document info only",
+    " -h/--help          This help text",
+    "    --hostpubmd5 <md5> Hex encoded MD5 string of the host public key. (SSH)",
+    " -0/--http1.0       Use HTTP 1.0 (H)",
     "    --ignore-content-length  Ignore the HTTP Content-Length header",
     " -i/--include       Include protocol headers in the output (H/F)",
-    " -I/--head          Show document info only",
-    " -j/--junk-session-cookies Ignore session cookies read from file (H)",
+    " -k/--insecure      Allow connections to SSL sites without certs (H)",
     "    --interface <interface> Specify network interface/address to use",
+    " -4/--ipv4          Resolve name to IPv4 address",
+    " -6/--ipv6          Resolve name to IPv6 address",
+    " -j/--junk-session-cookies Ignore session cookies read from file (H)",
+    "    --keepalive-time <seconds> Interval between keepalive probes",
+    "    --key <key>     Private key file name (SSL/SSH)",
+    "    --key-type <type> Private key file type (DER/PEM/ENG) (SSL)",
     "    --krb <level>   Enable kerberos with specified security level (F)",
-    " -k/--insecure      Allow connections to SSL sites without certs (H)",
-    " -K/--config        Specify which config file to read",
     "    --libcurl <file> Dump libcurl equivalent code of this command line",
-    " -l/--list-only     List only names of an FTP directory (F)",
     "    --limit-rate <rate> Limit transfer speed to this rate",
-    "    --local-port <num>[-num] Force use of these local port numbers\n",
+    " -l/--list-only     List only names of an FTP directory (F)",
+    "    --local-port <num>[-num] Force use of these local port numbers",
     " -L/--location      Follow Location: hints (H)",
-    "    --location-trusted Follow Location: and send authentication even ",
-    "                    to other hostnames (H)",
-    " -m/--max-time <seconds> Maximum time allowed for the transfer",
-    "    --max-redirs <num> Maximum number of redirects allowed (H)",
-    "    --max-filesize <bytes> Maximum file size to download (H/F)",
+    "    --location-trusted Follow Location: and send auth to other hosts (H)",
     " -M/--manual        Display the full manual",
+    "    --max-filesize <bytes> Maximum file size to download (H/F)",
+    "    --max-redirs <num> Maximum number of redirects allowed (H)",
+    " -m/--max-time <seconds> Maximum time allowed for the transfer",
+    "    --negotiate     Use HTTP Negotiate Authentication (H)",
     " -n/--netrc         Must read .netrc for user name and password",
     "    --netrc-optional Use either .netrc or URL; overrides -n",
-    "    --ntlm          Use HTTP NTLM authentication (H)",
     " -N/--no-buffer     Disable buffering of the output stream",
+    "    --no-keepalive  Disable keepalive use on the connection",
     "    --no-sessionid  Disable SSL session-ID reusing (SSL)",
+    "    --ntlm          Use HTTP NTLM authentication (H)",
     " -o/--output <file> Write output to <file> instead of stdout",
-    " -O/--remote-name   Write output to a file named as the remote file",
+    "    --pass  <pass>  Pass phrase for the private key (SSL/SSH)",
     "    --post301       Do not switch to GET after following a 301 redirect (H)",
-    " -p/--proxytunnel   Operate through a HTTP proxy tunnel (using CONNECT)",
+    " -#/--progress-bar  Display transfer progress as a progress bar",
+    " -x/--proxy <host[:port]> Use HTTP proxy on given port",
     "    --proxy-anyauth Pick \"any\" proxy authentication method (H)",
     "    --proxy-basic   Use Basic authentication on the proxy (H)",
     "    --proxy-digest  Use Digest authentication on the proxy (H)",
     "    --proxy-negotiate Use Negotiate authentication on the proxy (H)",
     "    --proxy-ntlm    Use NTLM authentication on the proxy (H)",
-    " -P/--ftp-port <address> Use PORT with address instead of PASV (F)",
-    " -q                 If used as the first parameter disables .curlrc",
+    " -U/--proxy-user <user[:password]> Set proxy user and password",
+    " -p/--proxytunnel   Operate through a HTTP proxy tunnel (using CONNECT)",
+    "    --pubkey <key>  Public key file name (SSH)",
     " -Q/--quote <cmd>   Send command(s) to server before file transfer (F/SFTP)",
-    " -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server",
     "    --random-file <file> File for reading random data from (SSL)",
+    " -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server",
     "    --raw           Pass HTTP \"raw\", without any transfer decoding (H)",
+    " -e/--referer       Referer URL (H)",
+    " -O/--remote-name   Write output to a file named as the remote file",
     " -R/--remote-time   Set the remote file's time on the local output",
+    " -X/--request <command> Specify request command to use",
     "    --retry <num>   Retry request <num> times if transient problems occur",
     "    --retry-delay <seconds> When retrying, wait this many seconds between each",
     "    --retry-max-time <seconds> Retry only within this period",
-    " -s/--silent        Silent mode. Don't output anything",
     " -S/--show-error    Show error. With -s, make curl show errors when they occur",
-    "    --socks4 <host[:port]> Use SOCKS4 proxy on given host + port",
-    "    --socks5 <host[:port]> Use SOCKS5 proxy on given host + port",
+    " -s/--silent        Silent mode. Don't output anything",
+    "    --socks4 <host[:port]> SOCKS4 proxy on given host + port",
+    "    --socks4a <host[:port]> SOCKS4a proxy on given host + port",
+    "    --socks5 <host[:port]> SOCKS5 proxy on given host + port",
+    "    --socks5-hostname <host[:port]> SOCKS5 proxy, pass host name to proxy",
+    " -Y/--speed-limit   Stop transfer if below speed-limit for 'speed-time' secs",
+    " -y/--speed-time    Time needed to trig speed-limit abort. Defaults to 30",
+    " -2/--sslv2         Use SSLv2 (SSL)",
+    " -3/--sslv3         Use SSLv3 (SSL)",
     "    --stderr <file> Where to redirect stderr. - means stdout",
+    "    --tcp-nodelay   Use the TCP_NODELAY option",
     " -t/--telnet-option <OPT=val> Set telnet option",
+    " -z/--time-cond <time> Transfer based on a time condition",
+    " -1/--tlsv1         Use TLSv1 (SSL)",
     "    --trace <file>  Write a debug trace to the given file",
     "    --trace-ascii <file> Like --trace but without the hex output",
     "    --trace-time    Add time stamps to trace/verbose output",
     " -T/--upload-file <file> Transfer <file> to remote site",
     "    --url <URL>     Set URL to work with",
+    " -B/--use-ascii     Use ASCII/text transfer",
     " -u/--user <user[:password]> Set server user and password",
-    " -U/--proxy-user <user[:password]> Set proxy user and password",
+    " -A/--user-agent <string> User-Agent to send to server (H)",
     " -v/--verbose       Make the operation more talkative",
     " -V/--version       Show version number and quit",
+
 #ifdef MSDOS
     "    --wdebug        Turn on Watt-32 debugging under DJGPP",
 #endif
     " -w/--write-out [format] What to output after completion",
-    " -x/--proxy <host[:port]> Use HTTP proxy on given port",
-    " -X/--request <command> Specify request command to use",
-    " -y/--speed-time    Time needed to trig speed-limit abort. Defaults to 30",
-    " -Y/--speed-limit   Stop transfer if below speed-limit for 'speed-time' secs",
-    " -z/--time-cond <time> Transfer based on a time condition",
-    " -0/--http1.0       Use HTTP 1.0 (H)",
-    " -1/--tlsv1         Use TLSv1 (SSL)",
-    " -2/--sslv2         Use SSLv2 (SSL)",
-    " -3/--sslv3         Use SSLv3 (SSL)",
-    " -4/--ipv4          Resolve name to IPv4 address",
-    " -6/--ipv6          Resolve name to IPv6 address",
-    " -#/--progress-bar  Display transfer progress as a progress bar",
+    " -q                 If used as the first parameter disables .curlrc",
     NULL
   };
   for(i=0; helptext[i]; i++) {
     puts(helptext[i]);
 #ifdef NETWARE
     if (i && ((i % 23) == 0))
@@ -771,77 +814,12 @@
   if(value)
     *string = strdup(value);
   else
     *string = NULL;
 }
 
-static char *file2string(FILE *file)
-{
-  char buffer[256];
-  char *ptr;
-  char *string=NULL;
-  size_t len=0;
-  size_t stringlen;
-
-  if(file) {
-    while(fgets(buffer, sizeof(buffer), file)) {
-      ptr= strchr(buffer, '\r');
-      if(ptr)
-        *ptr=0;
-      ptr= strchr(buffer, '\n');
-      if(ptr)
-        *ptr=0;
-      stringlen=strlen(buffer);
-      if(string)
-        string = realloc(string, len+stringlen+1);
-      else
-        string = malloc(stringlen+1);
-
-      strcpy(string+len, buffer);
-
-      len+=stringlen;
-    }
-    return string;
-  }
-  else
-    return NULL; /* no string */
-}
-
-static char *file2memory(FILE *file, long *size)
-{
-  char buffer[1024];
-  char *string=NULL;
-  char *newstring=NULL;
-  size_t len=0;
-  long stringlen=0;
-
-  if(file) {
-    while((len = fread(buffer, 1, sizeof(buffer), file))) {
-      if(string) {
-        newstring = realloc(string, len+stringlen+1);
-        if(newstring)
-          string = newstring;
-        else
-          break; /* no more strings attached! :-) */
-      }
-      else
-        string = malloc(len+1);
-      memcpy(&string[stringlen], buffer, len);
-      stringlen+=len;
-    }
-    if (string) {
-      /* NUL terminate the buffer in case it's treated as a string later */
-      string[stringlen] = 0;
-    }
-    *size = stringlen;
-    return string;
-  }
-  else
-    return NULL; /* no string */
-}
-
 static void clean_getout(struct Configurable *config)
 {
   struct getout *node=config->url_list;
   struct getout *next;
 
   while(node) {
@@ -1278,12 +1256,88 @@
     return "out of memory";
   default:
     return "unknown error";
   }
 }
 
+static ParameterError file2string(char **bufp, FILE *file)
+{
+  char buffer[256];
+  char *ptr;
+  char *string = NULL;
+  size_t stringlen = 0;
+  size_t buflen;
+
+  if(file) {
+    while(fgets(buffer, sizeof(buffer), file)) {
+      if((ptr = strchr(buffer, '\r')) != NULL)
+        *ptr = '\0';
+      if((ptr = strchr(buffer, '\n')) != NULL)
+        *ptr = '\0';
+      buflen = strlen(buffer);
+      if((ptr = realloc(string, stringlen+buflen+1)) == NULL) {
+        if(string)
+          free(string);
+        return PARAM_NO_MEM;
+      }
+      string = ptr;
+      strcpy(string+stringlen, buffer);
+      stringlen += buflen;
+    }
+  }
+  *bufp = string;
+  return PARAM_OK;
+}
+
+static ParameterError file2memory(char **bufp, size_t *size, FILE *file)
+{
+  char *newbuf;
+  char *buffer = NULL;
+  size_t alloc = 512;
+  size_t nused = 0;
+  size_t nread;
+
+  if(file) {
+    do {
+      if(!buffer || (alloc == nused)) {
+        /* size_t overflow detection for huge files */
+        if(alloc+1 > ((size_t)-1)/2) {
+          if(buffer)
+            free(buffer);
+          return PARAM_NO_MEM;
+        }
+        alloc *= 2;
+        /* allocate an extra char, reserved space, for null termination */
+        if((newbuf = realloc(buffer, alloc+1)) == NULL) {
+          if(buffer)
+            free(buffer);
+          return PARAM_NO_MEM;
+        }
+        buffer = newbuf;
+      }
+      nread = fread(buffer+nused, 1, alloc-nused, file);
+      nused += nread;
+    } while(nread);
+    /* null terminate the buffer in case it's used as a string later */
+    buffer[nused] = '\0';
+    /* free trailing slack space, if possible */
+    if(alloc != nused) {
+      if((newbuf = realloc(buffer, nused+1)) != NULL)
+        buffer = newbuf;
+    }
+    /* discard buffer if nothing was read */
+    if(!nused) {
+      free(buffer);
+      buffer = NULL; /* no string */
+    }
+  }
+  *size = nused;
+  *bufp = buffer;
+  return PARAM_OK;
+}
+
 static void cleanarg(char *str)
 {
 #ifdef HAVE_WRITABLE_ARGV
   /* now that GetStr has copied the contents of nextarg, wipe the next
    * argument out so that the username:password isn't displayed in the
    * system process list */
@@ -1427,12 +1481,63 @@
   if(curlx_strequal("active", str))
     return CURLFTPSSL_CCC_ACTIVE;
   warnf(config, "unrecognized ftp CCC method '%s', using default\n", str);
   return CURLFTPSSL_CCC_PASSIVE;
 }
 
+
+static int sockoptcallback(void *clientp, curl_socket_t curlfd,
+                           curlsocktype purpose)
+{
+  struct Configurable *config = (struct Configurable *)clientp;
+  int onoff = 1; /* this callback is only used if we ask for keepalives on the
+                    connection */
+#if defined(TCP_KEEPIDLE) || defined(TCP_KEEPINTVL)
+  int keepidle = (int)config->alivetime;
+#endif
+
+  switch (purpose) {
+  case CURLSOCKTYPE_IPCXN:
+    if(setsockopt(curlfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&onoff,
+                  sizeof(onoff)) < 0) {
+      /* don't abort operation, just issue a warning */
+      SET_SOCKERRNO(0);
+      warnf(clientp, "Could not set SO_KEEPALIVE!\n");
+      return 0;
+    }
+    else {
+      if (config->alivetime) {
+#ifdef TCP_KEEPIDLE
+        if(setsockopt(curlfd, IPPROTO_TCP, TCP_KEEPIDLE, (void *)&keepidle,
+                      sizeof(keepidle)) < 0) {
+          /* don't abort operation, just issue a warning */
+          SET_SOCKERRNO(0);
+          warnf(clientp, "Could not set TCP_KEEPIDLE!\n");
+          return 0;
+        }
+#endif
+#ifdef TCP_KEEPINTVL
+        if(setsockopt(curlfd, IPPROTO_TCP, TCP_KEEPINTVL, (void *)&keepidle,
+                      sizeof(keepidle)) < 0) {
+          /* don't abort operation, just issue a warning */
+          SET_SOCKERRNO(0);
+          warnf(clientp, "Could not set TCP_KEEPINTVL!\n");
+          return 0;
+        }
+#endif
+      }
+    }
+    break;
+  default:
+    break;
+  }
+
+  return 0;
+}
+
+
 static ParameterError getparameter(char *flag, /* f or -long-flag */
                                    char *nextarg, /* NULL if unset */
                                    bool *usedarg, /* set to TRUE if the arg
                                                      has been used */
                                    struct Configurable *config)
 {
@@ -1485,16 +1590,16 @@
     {"*x", "krb" ,        TRUE},
     {"*x", "krb4" ,       TRUE}, /* this is the previous name */
     {"*y", "max-filesize", TRUE},
     {"*z", "disable-eprt", FALSE},
     {"$a", "ftp-ssl",    FALSE},
     {"$b", "ftp-pasv",   FALSE},
-    {"$c", "socks5",     TRUE},
-    {"$c", "socks",      TRUE}, /* this is how the option was documented but
-                                   we prefer the --socks5 version for explicit
-                                   version */
+    {"$c", "socks5",   TRUE},
+    {"$c", "socks",      TRUE}, /* this is how the option once was documented
+                                   but we prefer the --socks5 version for
+                                   explicit version */
     {"$d", "tcp-nodelay",FALSE},
     {"$e", "proxy-digest", FALSE},
     {"$f", "proxy-basic", FALSE},
     {"$g", "retry",      TRUE},
     {"$h", "retry-delay", TRUE},
     {"$i", "retry-max-time", TRUE},
@@ -1504,21 +1609,25 @@
     {"$o", "trace-time", FALSE},
     {"$p", "ignore-content-length", FALSE},
     {"$q", "ftp-skip-pasv-ip", FALSE},
     {"$r", "ftp-method", TRUE},
     {"$s", "local-port", TRUE},
     {"$t", "socks4",     TRUE},
+    {"$T", "socks4a",    TRUE},
     {"$u", "ftp-alternative-to-user", TRUE},
     {"$v", "ftp-ssl-reqd", FALSE},
     {"$w", "no-sessionid", FALSE},
     {"$x", "ftp-ssl-control", FALSE},
     {"$y", "ftp-ssl-ccc", FALSE},
     {"$j", "ftp-ssl-ccc-mode", TRUE},
     {"$z", "libcurl",    TRUE},
     {"$#", "raw",        FALSE},
     {"$0", "post301",    FALSE},
+    {"$1", "no-keepalive",   FALSE},
+    {"$2", "socks5-hostname", TRUE},
+    {"$3", "keepalive-time",  TRUE},
 
     {"0", "http1.0",     FALSE},
     {"1", "tlsv1",       FALSE},
     {"2", "sslv2",       FALSE},
     {"3", "sslv3",       FALSE},
     {"4", "ipv4",       FALSE},
@@ -1529,12 +1638,13 @@
     {"B", "use-ascii",   FALSE},
     {"c", "cookie-jar",  TRUE},
     {"C", "continue-at", TRUE},
     {"d", "data",        TRUE},
     {"da", "data-ascii", TRUE},
     {"db", "data-binary", TRUE},
+    {"de", "data-urlencode", TRUE},
     {"D", "dump-header", TRUE},
     {"e", "referer",     TRUE},
     {"E", "cert",        TRUE},
     {"Ea", "cacert",     TRUE},
     {"Eb","cert-type",   TRUE},
     {"Ec","key",         TRUE},
@@ -1818,13 +1928,14 @@
       case 'w': /* --interface */
         /* interface */
         GetStr(&config->iface, nextarg);
         break;
       case 'x': /* --krb */
         /* kerberos level string */
-        if(curlinfo->features & (CURL_VERSION_KERBEROS4 | CURL_VERSION_GSSNEGOTIATE))
+        if(curlinfo->features & (CURL_VERSION_KERBEROS4 |
+                                 CURL_VERSION_GSSNEGOTIATE))
           GetStr(&config->krblevel, nextarg);
         else
           return PARAM_LIBCURL_DOESNT_SUPPORT;
         break;
       case 'y': /* --max-filesize */
         if(str2offset(&config->max_filesize, nextarg))
@@ -1868,20 +1979,30 @@
         break;
       case 'b': /* --ftp-pasv */
         if(config->ftpport)
           free(config->ftpport);
         config->ftpport = NULL;
         break;
-      case 'c': /* --socks5 specifies a socks5 proxy to use */
+      case 'c': /* --socks5 specifies a socks5 proxy to use, and resolves
+                   the name locally and passes on the resolved address */
         GetStr(&config->socksproxy, nextarg);
         config->socksver = CURLPROXY_SOCKS5;
         break;
       case 't': /* --socks4 specifies a socks4 proxy to use */
         GetStr(&config->socksproxy, nextarg);
         config->socksver = CURLPROXY_SOCKS4;
         break;
+      case 'T': /* --socks4a specifies a socks4a proxy to use */
+        GetStr(&config->socksproxy, nextarg);
+        config->socksver = CURLPROXY_SOCKS4A;
+        break;
+      case '2': /* --socks5-hostname specifies a socks5 proxy and enables name
+                   resolving with the proxy */
+        GetStr(&config->socksproxy, nextarg);
+        config->socksver = CURLPROXY_SOCKS5_HOSTNAME;
+        break;
       case 'd': /* --tcp-nodelay option */
         config->tcp_nodelay ^= TRUE;
         break;
       case 'e': /* --proxy-digest */
         config->proxydigest ^= TRUE;
         break;
@@ -1968,12 +2089,19 @@
       case '#': /* --raw */
         config->raw ^= TRUE;
         break;
       case '0': /* --post301 */
         config->post301 ^= TRUE;
         break;
+      case '1': /* --no-keepalive */
+        config->nokeepalive ^= TRUE;
+        break;
+      case '3': /* --keepalive-time */
+        if(str2num(&config->alivetime, nextarg))
+          return PARAM_BAD_NUMERIC;
+        break;
       }
       break;
     case '#': /* --progress-bar */
       config->progressmode ^= CURL_PROGRESS_BAR;
       break;
     case '0':
@@ -2042,18 +2170,98 @@
       config->use_resume=TRUE;
       break;
     case 'd':
       /* postfield data */
       {
         char *postdata=NULL;
+        FILE *file;
 
-        if('@' == *nextarg) {
+        if(subletter == 'e') { /* --data-urlencode*/
+          /* [name]=[content], we encode the content part only
+           * [name]@[file name]
+           *
+           * Case 2: we first load the file using that name and then encode
+           * the content.
+           */
+          char *p = strchr(nextarg, '=');
+          size_t size = 0;
+          size_t nlen;
+          char is_file;
+          if(!p)
+            /* there was no '=' letter, check for a '@' instead */
+            p = strchr(nextarg, '@');
+          if (p) {
+            nlen = p - nextarg; /* length of the name part */
+            is_file = *p++; /* pass the separator */
+          }
+          else {
+            /* neither @ nor =, so no name and it isn't a file */
+            nlen = is_file = 0;
+            p = nextarg;
+          }
+          if('@' == is_file) {
+            /* a '@' letter, it means that a file name or - (stdin) follows */
+
+            if(curlx_strequal("-", p)) {
+              file = stdin;
+              SET_BINMODE(stdin);
+            }
+            else {
+              file = fopen(p, "rb");
+              if(!file)
+                warnf(config,
+                      "Couldn't read data from file \"%s\", this makes "
+                      "an empty POST.\n", nextarg);
+            }
+
+            err = file2memory(&postdata, &size, file);
+
+            if(file && (file != stdin))
+              fclose(file);
+            if(err)
+              return err;
+          }
+          else {
+            GetStr(&postdata, p);
+            size = strlen(postdata);
+          }
+
+          if(!postdata) {
+            /* no data from the file, point to a zero byte string to make this
+               get sent as a POST anyway */
+            postdata=strdup("");
+          }
+          else {
+            char *enc = curl_easy_escape(config->easy, postdata, size);
+            if(enc) {
+              /* now make a string with the name from above and append the
+                 encoded string */
+              size_t outlen = nlen + strlen(enc) + 2;
+              char *n = malloc(outlen);
+              if(!n)
+                return PARAM_NO_MEM;
+              if (nlen > 0) /* only append '=' if we have a name */
+                snprintf(n, outlen, "%.*s=%s", nlen, nextarg, enc);
+              else
+                strcpy(n, enc);
+              curl_free(enc);
+              free(postdata);
+              if(n) {
+                postdata = n;
+              }
+              else
+                return PARAM_NO_MEM;
+            }
+            else
+              return PARAM_NO_MEM;
+          }
+        }
+        else if('@' == *nextarg) {
+          size_t size = 0;
           /* the data begins with a '@' letter, it means that a file name
              or - (stdin) follows */
-          FILE *file;
-
           nextarg++; /* pass the @ */
 
           if(curlx_strequal("-", nextarg)) {
             file = stdin;
             if(subletter == 'b') /* forced data-binary */
               SET_BINMODE(stdin);
@@ -2062,19 +2270,24 @@
             file = fopen(nextarg, "rb");
             if(!file)
               warnf(config, "Couldn't read data from file \"%s\", this makes "
                     "an empty POST.\n", nextarg);
           }
 
-          if(subletter == 'b') /* forced binary */
-            postdata = file2memory(file, &config->postfieldsize);
+          if(subletter == 'b') {
+            /* forced binary */
+            err = file2memory(&postdata, &size, file);
+            config->postfieldsize = (curl_off_t)size;
+          }
           else
-            postdata = file2string(file);
+            err = file2string(&postdata, file);
 
           if(file && (file != stdin))
             fclose(file);
+          if(err)
+            return err;
 
           if(!postdata) {
             /* no data from the file, point to a zero byte string to make this
                get sent as a POST anyway */
             postdata=strdup("");
           }
@@ -2531,17 +2744,19 @@
         FILE *file;
         nextarg++; /* pass the @ */
         if(curlx_strequal("-", nextarg))
           file = stdin;
         else
           file = fopen(nextarg, "r");
-        config->writeout = file2string(file);
-        if(!config->writeout)
-          warnf(config, "Failed to read %s", file);
+        err = file2string(&config->writeout, file);
         if(file && (file != stdin))
           fclose(file);
+        if(err)
+          return err;
+        if(!config->writeout)
+          warnf(config, "Failed to read %s", file);
       }
       else
         GetStr(&config->writeout, nextarg);
       break;
     case 'x':
       /* proxy */
@@ -2890,44 +3105,79 @@
     fflush(out->stream);
 
   return rc;
 }
 
 struct InStruct {
-  FILE *stream;
+  int fd;
   struct Configurable *config;
 };
 
-static curlioerr my_ioctl(CURL *handle, curliocmd cmd, void *userp)
+#define MAX_SEEK 2147483647
+
+#ifndef SIZEOF_OFF_T
+/* (Jan 11th 2008) this is a reasonably new define in the config.h so there
+   might be older handicrafted configs that don't define it properly and then
+   we assume 32bit off_t */
+#define SIZEOF_OFF_T 4
+#endif
+/*
+ * my_seek() is the CURLOPT_SEEKFUNCTION we use
+ */
+static int my_seek(void *stream, curl_off_t offset, int whence)
 {
-  struct InStruct *in=(struct InStruct *)userp;
-  (void)handle; /* not used in here */
+  struct InStruct *in=(struct InStruct *)stream;
 
-  switch(cmd) {
-  case CURLIOCMD_RESTARTREAD:
-    /* mr libcurl kindly asks as to rewind the read data stream to start */
-    if(-1 == fseek(in->stream, 0, SEEK_SET))
-      /* couldn't rewind, the reason is in errno but errno is just not
-         portable enough and we don't actually care that much why we failed. */
-      return CURLIOE_FAILRESTART;
+#if (SIZEOF_CURL_OFF_T > SIZEOF_OFF_T) && !defined(lseek)
+  /* The sizeof check following here is only interesting if curl_off_t is
+     larger than off_t, but also not on windows-like systems for which lseek
+     is a defined macro that works around the 32bit off_t-problem and thus do
+     64bit seeks correctly anyway */
+
+  if(offset > MAX_SEEK) {
+    /* Some precaution code to work around problems with different data sizes
+       to allow seeking >32bit even if off_t is 32bit. Should be very rare and
+       is really valid on weirdo-systems. */
+    curl_off_t left = offset;
 
-    break;
+    if(whence != SEEK_SET)
+      /* this code path doesn't support other types */
+      return 1;
+
+    if(-1 == lseek(in->fd, 0, SEEK_SET))
+      /* couldn't rewind to beginning */
+      return 1;
 
-  default: /* ignore unknown commands */
-    return CURLIOE_UNKNOWNCMD;
+    while(left) {
+      long step = (left>MAX_SEEK ? MAX_SEEK : (long)left);
+      if(-1 == lseek(in->fd, step, SEEK_CUR))
+        /* couldn't seek forwards the desired amount */
+        return 1;
+      left -= step;
+    }
+    return 0;
   }
-  return CURLIOE_OK;
+#endif
+  if(-1 == lseek(in->fd, offset, whence))
+    /* couldn't rewind, the reason is in errno but errno is just not
+       portable enough and we don't actually care that much why we failed. */
+    return 1;
+
+  return 0;
 }
 
 static size_t my_fread(void *buffer, size_t sz, size_t nmemb, void *userp)
 {
-  size_t rc;
+  ssize_t rc;
   struct InStruct *in=(struct InStruct *)userp;
 
-  rc = fread(buffer, sz, nmemb, in->stream);
-  return rc;
+  rc = read(in->fd, buffer, sz*nmemb);
+  if(rc < 0)
+    /* since size_t is unsigned we can't return negative values fine */
+    return 0;
+  return (size_t)rc;
 }
 
 struct ProgressData {
   int calls;
   curl_off_t prev;
   int width;
@@ -3331,12 +3581,15 @@
 
   curl_slist_free_all(config->quote); /* checks for config->quote == NULL */
   curl_slist_free_all(config->prequote);
   curl_slist_free_all(config->postquote);
   curl_slist_free_all(config->headers);
   curl_slist_free_all(config->telnet_options);
+
+  if(config->easy)
+    curl_easy_cleanup(config->easy);
 }
 
 #ifdef WIN32
 
 /* Function to find CACert bundle on a Win32 platform using SearchPath.
  * (SearchPath is already declared via inclusions done in setup header file)
@@ -3419,13 +3672,13 @@
       }
       else
         strcpy(value, "NULL");
     }
     /* attempt to figure out if it is a string (since the tag numerical doesn't
        offer this info) and then output it as a string if so */
-    else if(pval && isgraph(ptr[0]) && isgraph(ptr[1]) && isgraph(ptr[2]))
+    else if(pval && ISGRAPH(ptr[0]) && ISGRAPH(ptr[1]) && ISGRAPH(ptr[2]))
       snprintf(value, sizeof(value), "\"%s\"", (char *)ptr);
     else if(pval) {
       snprintf(value, sizeof(value), "%p", pval);
       remark = TRUE;
     }
     else {
@@ -3440,15 +3693,15 @@
     ret = curl_easy_setopt(curl, tag, oval);
   }
 
   if(config->libcurl) {
     /* we only use this for real if --libcurl was used */
 
-    bufp = curl_maprintf("%scurl_easy_setopt(hnd, %s, %s);%s",
-                         remark?"/* ":"", name, value,
-                         remark?" [REMARK] */":"");
+    bufp = curlx_maprintf("%scurl_easy_setopt(hnd, %s, %s);%s",
+                          remark?"/* ":"", name, value,
+                          remark?" [REMARK] */":"");
 
     if (!bufp || !curl_slist_append(easycode, bufp))
       ret = CURLE_OUT_OF_MEMORY;
     if (bufp)
       curl_free(bufp);
   }
@@ -3462,12 +3715,14 @@
   " * Lines with [REMARK] below might need to be modified to make this code ",
   " * usable. Add error code checking where appropriate.",
   " * Compile this with a suitable header include path. Then link with ",
   " * libcurl.",
   " * If you use any *_LARGE options, make sure your compiler figure",
   " * out the correct size for the curl_off_t variable.",
+  " * Read the details for all curl_easy_setopt() options online on:",
+  " * http://curlm.haxx.se/libcurl/c/curl_easy_setopt.html",
   " ************************************************************************/",
   "[m]",
   "#include <curl/curl.h>",
   "",
   "int main(int argc, char *argv[])",
   "{",
@@ -3509,14 +3764,15 @@
 
       while(ptr) {
         fprintf(out, "  %s\n", ptr->data);
         ptr = ptr->next;
       }
       fprintf(out,
+              "  return (int)ret;\n"
               "}\n"
-              "/* */\n");
+              "/**** End of sample code ****/\n");
       if(fopened)
         fclose(out);
     }
   }
   curl_slist_free_all(easycode);
 }
@@ -3518,17 +3774,18 @@
         fclose(out);
     }
   }
   curl_slist_free_all(easycode);
 }
 
+
 static int
 operate(struct Configurable *config, int argc, argv_item_t argv[])
 {
   char errorbuffer[CURL_ERROR_SIZE];
-  char useragent[128]; /* buah, we don't want a larger default user agent */
+  char useragent[256]; /* buah, we don't want a larger default user agent */
   struct ProgressData progressbar;
   struct getout *urlnode;
   struct getout *nextnode;
 
   struct OutStruct outs;
   struct OutStruct heads;
@@ -3537,14 +3794,14 @@
   URLGlob *urls=NULL;
   URLGlob *inglob=NULL;
   int urlnum;
   int infilenum;
   char *uploadfile=NULL; /* a single file, never a glob */
 
-  FILE *infd = stdin;
-  bool infdfopen;
+  int infd = STDIN_FILENO;
+  bool infdopen;
   FILE *headerfilep = NULL;
   curl_off_t uploadfilesize; /* -1 means unknown */
   bool stillflags=TRUE;
 
   bool allocuseragent=FALSE;
 
@@ -3554,12 +3811,15 @@
   int res = 0;
   int i;
   long retry_sleep_default;
   long retry_sleep;
 
   char *env;
+
+  memset(&heads, 0, sizeof(struct OutStruct));
+
 #ifdef CURLDEBUG
   /* this sends all memory debug messages to a logfile named memdump */
   env = curlx_getenv("CURL_MEMDEBUG");
   if(env) {
     /* use the value as file name */
     char *s = strdup(env);
@@ -3574,12 +3834,23 @@
   if(env) {
     curl_memlimit(atoi(env));
     curl_free(env);
   }
 #endif
 
+  /*
+   * Get a curl handle to use for all forthcoming curl transfers.  Cleanup
+   * when all transfers are done.
+   */
+  curl = curl_easy_init();
+  if(!curl) {
+    clean_getout(config);
+    return CURLE_FAILED_INIT;
+  }
+  config->easy = curl;
+
   memset(&outs,0,sizeof(outs));
 
   config->outs = &outs;
 
   /* we get libcurl info right away */
   curlinfo = curl_version_info(CURLVERSION_NOW);
@@ -3730,22 +4001,12 @@
     else {
       if(SetHTTPrequest(config, HTTPREQ_SIMPLEPOST, &config->httpreq))
         return PARAM_BAD_USE;
     }
   }
 
-  /*
-   * Get a curl handle to use for all forthcoming curl transfers.  Cleanup
-   * when all transfers are done.
-   */
-  curl = curl_easy_init();
-  if(!curl) {
-    clean_getout(config);
-    return CURLE_FAILED_INIT;
-  }
-
   /* This is the first entry added to easycode and it initializes the slist */
   easycode = curl_slist_append(easycode, "CURL *hnd = curl_easy_init();");
   if(!easycode) {
     clean_getout(config);
     res = CURLE_OUT_OF_MEMORY;
     goto quit_curl;
@@ -3956,13 +4217,13 @@
             }
           }
           else {
             outs.stream = NULL; /* open when needed */
           }
         }
-        infdfopen=FALSE;
+        infdopen=FALSE;
         if(uploadfile && !curlx_strequal(uploadfile, "-")) {
           /*
            * We have specified a file to upload and it isn't "-".
            */
           struct_stat fileinfo;
 
@@ -4024,17 +4285,17 @@
            * for VARiable record files the records need to be counted!  for
            * every record add 1 for linefeed and subtract 2 for the record
            * header for VARIABLE header files only the bare record data needs
            * to be considered with one appended if implied CC
            */
 
-          infd=(FILE *) fopen(uploadfile, "rb");
-          if (!infd || stat(uploadfile, &fileinfo)) {
+          infd= open(uploadfile, O_RDONLY | O_BINARY);
+          if ((infd == -1) || stat(uploadfile, &fileinfo)) {
             helpf("Can't open '%s'!\n", uploadfile);
-            if(infd)
-              fclose(infd);
+            if(infd != -1)
+              close(infd);
 
             /* Free the list of remaining URLs and globbed upload files
              * to force curl to exit immediately
              */
             if(urls) {
               glob_cleanup(urls);
@@ -4045,19 +4306,19 @@
               inglob = NULL;
             }
 
             res = CURLE_READ_ERROR;
             goto quit_urls;
           }
-          infdfopen=TRUE;
+          infdopen=TRUE;
           uploadfilesize=fileinfo.st_size;
 
         }
         else if(uploadfile && curlx_strequal(uploadfile, "-")) {
           SET_BINMODE(stdin);
-          infd = stdin;
+          infd = STDIN_FILENO;
         }
 
         if(uploadfile && config->resume_from_current)
           config->resume_from = -1; /* -1 will then force get-it-yourself */
 
         if(output_expected(url, uploadfile)
@@ -4113,35 +4374,36 @@
         }
 
         if(!config->errors)
           config->errors = stderr;
 
         if(!outfile && !(config->conf & CONF_GETTEXT)) {
-          /* We get the output to stdout and we have not got the ASCII/text flag,
-             then set stdout to be binary */
+          /* We get the output to stdout and we have not got the ASCII/text
+             flag, then set stdout to be binary */
           SET_BINMODE(stdout);
         }
 
         if(1 == config->tcp_nodelay)
           my_setopt(curl, CURLOPT_TCP_NODELAY, 1);
 
         /* where to store */
         my_setopt(curl, CURLOPT_WRITEDATA, (FILE *)&outs);
         /* what call to write */
         my_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
 
         /* for uploads */
-        input.stream = infd;
+        input.fd = infd;
         input.config = config;
         my_setopt(curl, CURLOPT_READDATA, &input);
         /* what call to read */
         my_setopt(curl, CURLOPT_READFUNCTION, my_fread);
 
-        /* libcurl 7.12.3 business: */
-        my_setopt(curl, CURLOPT_IOCTLDATA, &input);
-        my_setopt(curl, CURLOPT_IOCTLFUNCTION, my_ioctl);
+        /* in 7.18.0, the CURLOPT_SEEKFUNCTION/DATA pair is taking over what
+           CURLOPT_IOCTLFUNCTION/DATA pair previously provided for seeking */
+        my_setopt(curl, CURLOPT_SEEKDATA, &input);
+        my_setopt(curl, CURLOPT_SEEKFUNCTION, my_seek);
 
         if(config->recvpersecond)
           /* tell libcurl to use a smaller sized buffer as it allows us to
              make better sleeps! 7.9.9 stuff! */
           my_setopt(curl, CURLOPT_BUFFERSIZE, config->recvpersecond);
 
@@ -4177,13 +4439,13 @@
         my_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
         my_setopt(curl, CURLOPT_TIMEOUT, config->timeout);
 
         switch(config->httpreq) {
         case HTTPREQ_SIMPLEPOST:
           my_setopt(curl, CURLOPT_POSTFIELDS, config->postfields);
-          my_setopt(curl, CURLOPT_POSTFIELDSIZE, config->postfieldsize);
+          my_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, config->postfieldsize);
           break;
         case HTTPREQ_POST:
           my_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
           break;
         default:
           break;
@@ -4207,18 +4469,19 @@
         my_setopt(curl, CURLOPT_SSLCERT, config->cert);
         my_setopt(curl, CURLOPT_SSLCERTTYPE, config->cert_type);
         my_setopt(curl, CURLOPT_SSLKEY, config->key);
         my_setopt(curl, CURLOPT_SSLKEYTYPE, config->key_type);
         my_setopt(curl, CURLOPT_KEYPASSWD, config->key_passwd);
 
-        /* SSH private key uses the same command-line option as SSL private key */
+        /* SSH private key uses the same command-line option as SSL private
+           key */
         my_setopt(curl, CURLOPT_SSH_PRIVATE_KEYFILE, config->key);
         my_setopt(curl, CURLOPT_SSH_PUBLIC_KEYFILE, config->pubkey);
 
         /* SSH host key md5 checking allows us to fail if we are
-         * not talking to who we think we should 
+         * not talking to who we think we should
          */
         my_setopt(curl, CURLOPT_SSH_HOST_PUBLIC_KEY_MD5, config->hostpubmd5);
 
 
         /* default to strict verifyhost */
         my_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2);
@@ -4405,12 +4668,16 @@
           my_setopt(curl, CURLOPT_HTTP_CONTENT_DECODING, FALSE);
           my_setopt(curl, CURLOPT_HTTP_TRANSFER_DECODING, FALSE);
         }
 
         /* curl 7.17.1 */
         my_setopt(curl, CURLOPT_POST301, config->post301);
+        if (!config->nokeepalive) {
+          my_setopt(curl, CURLOPT_SOCKOPTFUNCTION, sockoptcallback);
+          my_setopt(curl, CURLOPT_SOCKOPTDATA, config);
+        }
 
         retry_numretries = config->req_retry;
 
         retrystart = cutil_tvnow();
 
         do {
@@ -4612,14 +4879,14 @@
         if(url)
           free(url);
 
         if(outfile)
           free(outfile);
 
-        if(infdfopen)
-          fclose(infd);
+        if(infdopen)
+          close(infd);
 
       } /* loop to the next URL */
 
       if(urls) {
         /* cleanup memory used for URL globbing patterns */
         glob_cleanup(urls);
@@ -4660,12 +4927,13 @@
 
   if (config->engine)
     free(config->engine);
 
   /* cleanup the curl handle! */
   curl_easy_cleanup(curl);
+  config->easy = NULL; /* cleanup now */
   if (easycode)
     curl_slist_append(easycode, "curl_easy_cleanup(hnd);");
 
   if(config->headerfile && !headerfilep && heads.stream)
     fclose(heads.stream);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.am	2007-02-17 22:32:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.am	2007-12-20 06:10:42.000000000 +0800
@@ -15,13 +15,13 @@
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.am,v 1.55 2007-02-17 01:29:01 danf Exp $
+# $Id: Makefile.am,v 1.56 2007-12-19 21:19:01 danf Exp $
 ###########################################################################
 AUTOMAKE_OPTIONS = foreign nostdinc
 
 # we use srcdir/src for "private" includes
 # we use srcdir/include for the static global include files
 # we use builddir/src for the generated include files to get found
@@ -38,13 +38,15 @@
 include Makefile.inc
 
 curl_LDADD = ../lib/libcurl.la @CURL_LIBS@
 curl_DEPENDENCIES = ../lib/libcurl.la
 BUILT_SOURCES = hugehelp.c
 CLEANFILES = hugehelp.c
-NROFF=@NROFF@ @MANOPT@ # figured out by the configure script
+# Use the C locale to ensure that only ASCII characters appear in the
+# embedded text.
+NROFF=env LC_ALL=C @NROFF@ @MANOPT@ # figured out by the configure script
 
 EXTRA_DIST = mkhelp.pl makefile.dj Makefile.vc6 Makefile.b32 Makefile.m32 \
 	Makefile.riscos config.h.in macos/curl.mcp.xml.sit.hqx		  \
 	macos/MACINSTALL.TXT macos/src/curl_GUSIConfig.cpp		  \
 	macos/src/macos_main.cpp config-amigaos.h makefile.amiga curl.rc  \
 	Makefile.netware Makefile.inc Makefile.Watcom
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -141,13 +141,15 @@
 MAKEINFO = @MAKEINFO@
 MANOPT = @MANOPT@
 MIMPURE_FALSE = @MIMPURE_FALSE@
 MIMPURE_TRUE = @MIMPURE_TRUE@
 NO_UNDEFINED_FALSE = @NO_UNDEFINED_FALSE@
 NO_UNDEFINED_TRUE = @NO_UNDEFINED_TRUE@
-NROFF = @NROFF@ @MANOPT@ # figured out by the configure script
+# Use the C locale to ensure that only ASCII characters appear in the
+# embedded text.
+NROFF = env LC_ALL=C @NROFF@ @MANOPT@ # figured out by the configure script
 OBJDUMP = @OBJDUMP@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 PACKAGE_NAME = @PACKAGE_NAME@
 PACKAGE_STRING = @PACKAGE_STRING@
@@ -162,12 +164,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
@@ -239,13 +244,13 @@
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.am,v 1.55 2007-02-17 01:29:01 danf Exp $
+# $Id: Makefile.am,v 1.56 2007-12-19 21:19:01 danf Exp $
 ###########################################################################
 AUTOMAKE_OPTIONS = foreign nostdinc
 
 # we use srcdir/src for "private" includes
 # we use srcdir/include for the static global include files
 # we use builddir/src for the generated include files to get found
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.m32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.m32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.m32	2007-08-27 21:01:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.m32	2008-01-17 17:22:36.000000000 +0800
@@ -1,8 +1,8 @@
 #########################################################################
-# $Id: Makefile.m32,v 1.41 2007-08-25 12:08:38 gknauf Exp $
+# $Id: Makefile.m32,v 1.42 2008-01-17 01:25:46 gknauf Exp $
 #
 ## Makefile for building curl.exe with MingW32 (GCC-3.2) and
 ## optionally OpenSSL (0.9.8), libssh2 (0.17), zlib (1.2.3)
 ##
 ## Usage:
 ## mingw32-make -f Makefile.m32 [SSL=1] [SSH2=1] [ZLIB=1] [SSPI=1] [IPV6=1] [DYN=1]
@@ -18,17 +18,17 @@
 # Edit the path below to point to the base of your Zlib sources.
 ifndef ZLIB_PATH
 ZLIB_PATH = ../../zlib-1.2.3
 endif
 # Edit the path below to point to the base of your OpenSSL package.
 ifndef OPENSSL_PATH
-OPENSSL_PATH = ../../openssl-0.9.8e
+OPENSSL_PATH = ../../openssl-0.9.8g
 endif
 # Edit the path below to point to the base of your LibSSH2 package.
 ifndef LIBSSH2_PATH
-LIBSSH2_PATH = ../../libssh2-0.17
+LIBSSH2_PATH = ../../libssh2-0.18
 endif
 # Edit the path below to point to the base of your Novell LDAP NDK.
 ifndef LDAP_SDK
 LDAP_SDK = c:/novell/ndk/cldapsdk/win32
 endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.netware /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.netware
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.netware	2007-10-12 16:15:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.netware	2008-01-26 06:11:15.000000000 +0800
@@ -1,8 +1,8 @@
 #################################################################
-# $Id: Makefile.netware,v 1.60 2007-10-09 20:15:27 gknauf Exp $
+# $Id: Makefile.netware,v 1.64 2008-01-24 15:28:47 gknauf Exp $
 #
 ## Makefile for building curl.nlm (NetWare version - gnu make)
 ## Use: make -f Makefile.netware
 ##
 ## Comments to: Guenter Knauf http://www.gknw.de/phpbb
 #
@@ -17,28 +17,28 @@
 ifndef ZLIB_PATH
 ZLIB_PATH = ../../zlib-1.2.3
 endif
 
 # Edit the path below to point to the base of your OpenSSL package.
 ifndef OPENSSL_PATH
-OPENSSL_PATH = ../../openssl-0.9.8e
+OPENSSL_PATH = ../../openssl-0.9.8g
 endif
 
 # Edit the path below to point to the base of your LibSSH2 package.
 ifndef LIBSSH2_PATH
-LIBSSH2_PATH = ../../libssh2-0.16
+LIBSSH2_PATH = ../../libssh2-0.18
 endif
 
 ifndef INSTDIR
 INSTDIR	= ..$(DS)curl-$(LIBCURL_VERSION_STR)-bin-nw
 endif
 
 # Edit the vars below to change NLM target settings.
 TARGET  = curl
 VERSION	= $(LIBCURL_VERSION)
-COPYR	= Copyright (C) 1996 - 2007, Daniel Stenberg, <daniel@haxx.se>
+COPYR	= Copyright (C) $(LIBCURL_COPYRIGHT_STR)
 DESCR	= cURL $(LIBCURL_VERSION_STR) ($(LIBARCH)) - http://curl.haxx.se
 MTSAFE	= YES
 STACK	= 64000
 SCREEN	= $(TARGET) commandline utility
 # Comment the line below if you dont want to load protected automatically.
 #LDRING	= 3
@@ -70,13 +70,13 @@
 	MWCW_PATH = $(subst \,/,$(METROWERKS))/Novell Support/Metrowerks Support
 	CC = mwccnlm
 else
 	CC = gcc
 endif
 # a native win32 awk can be downloaded from here:
-# http://www.gknw.net/development/prgtools/awk-20050424.zip
+# http://www.gknw.net/development/prgtools/awk-20070501.zip
 AWK	= awk
 CP	= cp -afv
 # RM	= rm -f
 # if you want to mark the target as MTSAFE you will need a tool for
 # generating the xdc data for the linker; here's a minimal tool:
 # http://www.gknw.net/development/prgtools/mkxdc.zip
@@ -321,15 +321,15 @@
 ifdef EXPORTS
 	@echo $(DL)export $(EXPORTS)$(DL) >> $@
 endif
 ifdef IMPORTS
 	@echo $(DL)import $(IMPORTS)$(DL) >> $@
 endif
-ifeq ($(LD),nlmconv)
-	@echo $(DL)input $(OBJS)$(DL) >> $@
+ifeq ($(findstring nlmconv,$(LD)),nlmconv)
 	@echo $(DL)input $(PRELUDE)$(DL) >> $@
+	@echo $(DL)input $(OBJS)$(DL) >> $@
 ifdef LDLIBS
 	@echo $(DL)input $(LDLIBS)$(DL) >> $@
 endif
 	@echo $(DL)output $(TARGET).nlm$(DL) >> $@
 endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.vc6	2007-10-24 17:24:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.vc6	2008-01-24 06:20:22.000000000 +0800
@@ -19,13 +19,13 @@
 
 !IFNDEF ZLIB_PATH
 ZLIB_PATH = ../../zlib-1.2.3
 !ENDIF
 
 !IFNDEF OPENSSL_PATH
-OPENSSL_PATH = ../../openssl-0.9.8e
+OPENSSL_PATH = ../../openssl-0.9.8g
 !ENDIF
 
 !IFNDEF MACHINE
 MACHINE  = X86
 !ENDIF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.vc8 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.vc8
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.vc8	2007-10-29 22:49:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.vc8	2008-01-29 01:29:23.000000000 +0800
@@ -19,13 +19,13 @@
 
 !IFNDEF ZLIB_PATH
 ZLIB_PATH = ../../zlib-1.2.3
 !ENDIF
 
 !IFNDEF OPENSSL_PATH
-OPENSSL_PATH = ../../openssl-0.9.8e
+OPENSSL_PATH = ../../openssl-0.9.8g
 !ENDIF
 
 !IFNDEF MACHINE
 MACHINE  = X86
 !ENDIF
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.Watcom /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.Watcom
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/Makefile.Watcom	2007-08-08 16:40:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/Makefile.Watcom	2007-12-09 18:52:32.000000000 +0800
@@ -1,34 +1,20 @@
 #
 #  Watcom / OpenWatcom / Win32 makefile for cURL.
-#  G. Vanem <giva@bgnett.no>
+#  G. Vanem <gvanem@broadpark.no>
 #
-# $Id: Makefile.Watcom,v 1.8 2007-08-07 17:40:56 gknauf Exp $
-
-#
-# Set to 1 to use static lib.
-# Set to 0 to use DLL and import lib.
-#
-STATIC = 0
+# $Id: Makefile.Watcom,v 1.9 2007-12-09 09:58:56 giva Exp $
 
 CC = wcc386
 
 CFLAGS = -3r -mf -d3 -hc -zff -zgf -zq -zm -s -fr=con -w2 -fpi -oilrtfm     &
          -bt=nt -d+ -dWIN32 -dHAVE_STRTOLL -dWITHOUT_MM_LIB                 &
          -dSIZEOF_CURL_OFF_T=8 -dCURLDEBUG -dENABLE_IPV6 -dHAVE_WINSOCK2_H  &
          -I..\include -I..\lib
 
-!ifeq STATIC 0
-LIBCURL = ..\lib\libcurl_wc_imp.lib
-
-!else
-CFLAGS += -dCURL_STATICLIB
-LIBCURL = ..\lib\libcurl_wc.lib
-!endif
-
-OBJ_DIR = Watcom_obj
+OBJ_DIR = WC_Win32.obj
 
 OBJS = $(OBJ_DIR)\getpass.obj  $(OBJ_DIR)\homedir.obj $(OBJ_DIR)\hugehelp.obj &
        $(OBJ_DIR)\main.obj     $(OBJ_DIR)\urlglob.obj $(OBJ_DIR)\writeenv.obj &
        $(OBJ_DIR)\writeout.obj $(OBJ_DIR)\curlutil.obj
 
 RESOURCE = $(OBJ_DIR)\curl.res
@@ -43,13 +29,13 @@
 	mkdir $(OBJ_DIR)
 
 curl.exe: $(OBJS) $(RESOURCE)
 	wlink name $@ system nt file { $(OBJS) }                   &
 	  option quiet, map, caseexact, eliminate, res=$(RESOURCE) &
 	  libpath $(%watcom)\lib386;$(%watcom)\lib386\nt           &
-	  library $(LIBCURL), clib3r.lib, ws2_32.lib
+	  library ..\lib\libcurl_wc_imp.lib, clib3r.lib, ws2_32.lib
 
 clean: .SYMBOLIC
 	- rm -f $(OBJS) $(RESOURCE)
 
 vclean realclean: clean .SYMBOLIC
  	- rm -f curl.exe curl.map hugehelp.c
@@ -58,13 +44,12 @@
 $(RESOURCE): curl.rc
 	wrc -dCURLDEBUG=1 -q -r -zm -I..\include -fo=$@ curl.rc
 
 .ERASE
 .c{$(OBJ_DIR)}.obj:
 	$(CC) $[@ $(CFLAGS) -fo=$@
-	@echo .
 
 #
 # Dependencies based on "gcc -MM .."
 #
 $(OBJ_DIR)\getpass.obj: getpass.c setup.h config-win32.h ..\lib\setup.h &
   ..\lib\config-win32.h getpass.h ..\lib\memdebug.h ..\lib\setup.h &
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/setup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/setup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/setup.h	2007-07-01 22:37:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/setup.h	2007-11-10 21:16:23.000000000 +0800
@@ -17,24 +17,22 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: setup.h,v 1.51 2007-06-30 23:45:57 gknauf Exp $
+ * $Id: setup.h,v 1.52 2007-11-08 18:13:55 yangtse Exp $
  ***************************************************************************/
 
 #define CURL_NO_OLDIES
 
-#if !defined(WIN32) && defined(__WIN32__)
-/* Borland fix */
-#define WIN32
-#endif
+/*
+ * Define WIN32 when build target is Win32 API
+ */
 
-#if !defined(WIN32) && defined(_WIN32)
-/* VS2005 on x64 fix */
+#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
 #define WIN32
 #endif
 
 /*
  * Include configuration script results or hand-crafted
  * configuration file for platforms which lack config tool.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/src/version.h	2007-10-29 22:49:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/src/version.h	2008-01-29 01:29:23.000000000 +0800
@@ -4,32 +4,33 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2004, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  * 
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: version.h,v 1.92 2004/03/24 07:27:58 bagder Exp $
+ * $Id: version.h,v 1.94 2008-01-24 14:15:49 gknauf Exp $
  ***************************************************************************/
 
 #include <curl/curlver.h>
 
 #define CURL_NAME "curl"
-#define CURL_VERSION "7.17.1"
+#define CURL_COPYRIGHT LIBCURL_COPYRIGHT
+#define CURL_VERSION "7.18.0"
 #define CURL_VERSION_MAJOR LIBCURL_VERSION_MAJOR
 #define CURL_VERSION_MINOR LIBCURL_VERSION_MINOR
 #define CURL_VERSION_PATCH LIBCURL_VERSION_PATCH
 #define CURL_ID CURL_NAME " " CURL_VERSION " (" OS ") "
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/Makefile.am	2007-10-26 05:14:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/Makefile.am	2008-01-26 08:13:12.000000000 +0800
@@ -25,31 +25,33 @@
  test170 test171 test172 test204 test205 test173 test174 test175 test176   \
  test177 test513 test514 test178 test179 test180 test181 test182 test183   \
  test184 test185 test186 test187 test188 test189 test191 test192 test193   \
  test194 test195 test196 test197 test198 test515 test516 test517 test518   \
  test210 test211 test212 test220 test221 test222 test223 test224 test206   \
  test207 test208 test209 test213 test240 test241 test242 test519 test214   \
- test215 test216 test217 test218 test199 test225 test226 test227	   \
- test228 test229 test233 test234 test235 test236 test520		   \
- test237 test238 test239 test243 test245 test246 test247 test248 test249   \
- test250 test251 test252 test253 test254 test255 test521 test522 test523   \
- test256 test257 test258 test259 test260 test261 test262 test263 test264   \
- test265 test266 test267 test268 test269 test270 test271 test272 test273   \
- test274 test275 test524 test525 test276 test277 test526 test527 test528   \
- test530 DISABLED test278 test279 test531 test280 test529 test532 test533  \
- test534 test535 test281 test537 test282 test283 test284 test538 test285   \
- test286 test307 test308 test287 test400 test288 test600 test601 test602   \
- test603 test401 test402 test290 test291 test292 test293 test403 test404   \
- test405 test604 test605 test606 test607 test608 test609 test294 test295   \
- test296 test297 test298 test610 test611 test612 test406 test407 test408   \
- test409 test613 test614 test700 test701 test702 test704 test705 test703   \
- test706 test707 test350 test351 test352 test353 test289 test540 test354   \
- test231 test1000 test1001 test1002 test1003 test1004 test1005 test1006    \
- test615 test1007 test541 test1010 test1011 test1012 test542 test543       \
- test536 test1008 test1009 test2000 test2001 test2002 test2003 test35      \
- test544 test545 test2004
+ test215 test216 test217 test218 test199 test225 test226 test227 test228   \
+ test229 test233 test234 test235 test236 test520 test237 test238 test239   \
+ test243 test245 test246 test247 test248 test249 test250 test251 test252   \
+ test253 test254 test255 test521 test522 test523 test256 test257 test258   \
+ test259 test260 test261 test262 test263 test264 test265 test266 test267   \
+ test268 test269 test270 test271 test272 test273 test274 test275 test524   \
+ test525 test276 test277 test526 test527 test528 test530 DISABLED test278  \
+ test279 test531 test280 test529 test532 test533 test534 test535 test281   \
+ test537 test282 test283 test284 test538 test285 test286 test307 test308   \
+ test287 test400 test288 test600 test601 test602 test603 test401 test402   \
+ test290 test291 test292 test293 test403 test404 test405 test604 test605   \
+ test606 test607 test608 test609 test294 test295 test296 test297 test298   \
+ test610 test611 test612 test406 test407 test408 test409 test613 test614   \
+ test700 test701 test702 test704 test705 test703 test706 test707 test350   \
+ test351 test352 test353 test289 test540 test354 test231 test1000 test1001 \
+ test1002 test1003 test1004 test1005 test1006 test615 test1007 test541	   \
+ test1010 test1011 test1012 test542 test543 test536 test1008 test1009	   \
+ test2000 test2001 test2002 test2003 test35 test544 test545 test2004	   \
+ test546 test1013 test1014 test1015 test547 test548 test549 test550	   \
+ test551 test552 test1016 test1017 test1018 test1019 test1020 test553      \
+ test1021
 
 filecheck:
 	@mkdir test-place; \
 	cp "$(top_srcdir)"/tests/data/test[0-9]* test-place/; \
 	for f in $(EXTRA_DIST); do \
 	  if test -f "$(top_srcdir)/tests/data/$$f"; then \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -135,12 +135,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
@@ -217,31 +220,33 @@
  test170 test171 test172 test204 test205 test173 test174 test175 test176   \
  test177 test513 test514 test178 test179 test180 test181 test182 test183   \
  test184 test185 test186 test187 test188 test189 test191 test192 test193   \
  test194 test195 test196 test197 test198 test515 test516 test517 test518   \
  test210 test211 test212 test220 test221 test222 test223 test224 test206   \
  test207 test208 test209 test213 test240 test241 test242 test519 test214   \
- test215 test216 test217 test218 test199 test225 test226 test227	   \
- test228 test229 test233 test234 test235 test236 test520		   \
- test237 test238 test239 test243 test245 test246 test247 test248 test249   \
- test250 test251 test252 test253 test254 test255 test521 test522 test523   \
- test256 test257 test258 test259 test260 test261 test262 test263 test264   \
- test265 test266 test267 test268 test269 test270 test271 test272 test273   \
- test274 test275 test524 test525 test276 test277 test526 test527 test528   \
- test530 DISABLED test278 test279 test531 test280 test529 test532 test533  \
- test534 test535 test281 test537 test282 test283 test284 test538 test285   \
- test286 test307 test308 test287 test400 test288 test600 test601 test602   \
- test603 test401 test402 test290 test291 test292 test293 test403 test404   \
- test405 test604 test605 test606 test607 test608 test609 test294 test295   \
- test296 test297 test298 test610 test611 test612 test406 test407 test408   \
- test409 test613 test614 test700 test701 test702 test704 test705 test703   \
- test706 test707 test350 test351 test352 test353 test289 test540 test354   \
- test231 test1000 test1001 test1002 test1003 test1004 test1005 test1006    \
- test615 test1007 test541 test1010 test1011 test1012 test542 test543       \
- test536 test1008 test1009 test2000 test2001 test2002 test2003 test35      \
- test544 test545 test2004
+ test215 test216 test217 test218 test199 test225 test226 test227 test228   \
+ test229 test233 test234 test235 test236 test520 test237 test238 test239   \
+ test243 test245 test246 test247 test248 test249 test250 test251 test252   \
+ test253 test254 test255 test521 test522 test523 test256 test257 test258   \
+ test259 test260 test261 test262 test263 test264 test265 test266 test267   \
+ test268 test269 test270 test271 test272 test273 test274 test275 test524   \
+ test525 test276 test277 test526 test527 test528 test530 DISABLED test278  \
+ test279 test531 test280 test529 test532 test533 test534 test535 test281   \
+ test537 test282 test283 test284 test538 test285 test286 test307 test308   \
+ test287 test400 test288 test600 test601 test602 test603 test401 test402   \
+ test290 test291 test292 test293 test403 test404 test405 test604 test605   \
+ test606 test607 test608 test609 test294 test295 test296 test297 test298   \
+ test610 test611 test612 test406 test407 test408 test409 test613 test614   \
+ test700 test701 test702 test704 test705 test703 test706 test707 test350   \
+ test351 test352 test353 test289 test540 test354 test231 test1000 test1001 \
+ test1002 test1003 test1004 test1005 test1006 test615 test1007 test541	   \
+ test1010 test1011 test1012 test542 test543 test536 test1008 test1009	   \
+ test2000 test2001 test2002 test2003 test35 test544 test545 test2004	   \
+ test546 test1013 test1014 test1015 test547 test548 test549 test550	   \
+ test551 test552 test1016 test1017 test1018 test1019 test1020 test553      \
+ test1021
 
 all: all-am
 
 .SUFFIXES:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test1008 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test1008
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test1008	2007-09-18 05:17:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test1008	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,16 @@
 <testcase>
+<info>
+<keywords>
+HTTP
+HTTP GET
+HTTP proxy
+HTTP proxy NTLM auth
+CONNECT
+</keywords>
+</info>
 # Server-side
 <reply>
 
 # this is returned first since we get no proxy-auth
 <data1001>
 HTTP/1.1 407 Authorization Required to proxy me my dear
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1013
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1014
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1015
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1016
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1017
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1018
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1019
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1020
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test1021
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test137 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test137
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test137	2007-04-19 04:24:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test137	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,14 @@
 <testcase>
+<info>
+<keywords>
+FTP
+RETR
+--data-binary
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 this is file contents
 </data>
 <servercmd>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test138 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test138
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test138	2007-04-19 04:24:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test138	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,13 @@
 <testcase>
+<info>
+<keywords>
+FTP
+RETR
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 this is file contents
 </data>
 <size>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test139 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test139
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test139	2007-02-14 06:40:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test139	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,14 @@
 <testcase>
+<info>
+<keywords>
+FTP
+RETR
+-z
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 this is file contents
 </data>
 <mdtm>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test140 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test140
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test140	2007-02-14 06:40:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test140	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,14 @@
 <testcase>
+<info>
+<keywords>
+FTP
+-z
+--data-binary
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 </data>
 <mdtm>
 213 20030409102659
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test141 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test141
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test141	2007-07-29 05:50:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test141	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,13 @@
 <testcase>
+<info>
+<keywords>
+FTP
+-I
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 </data>
 <size>
 42
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test142 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test142
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test142	2007-02-14 06:40:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test142	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,12 @@
 <testcase>
+<info>
+<keywords>
+FTP
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 many parts there are
 </data>
 </reply>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test143 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test143
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test143	2007-02-14 06:40:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test143	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,14 @@
 <testcase>
+<info>
+<keywords>
+FTP
+RETR
+type=
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 bla bla bla
 </data>
 </reply>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test144 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test144
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test144	2007-09-18 16:11:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test144	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,15 @@
 <testcase>
+<info>
+<keywords>
+FTP
+PORT
+NLST
+--data-binary
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 </data>
 <servercmd>
 REPLY NLST 450 No files found
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test145 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test145
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test145	2007-09-18 16:11:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test145	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,14 @@
 <testcase>
+<info>
+<keywords>
+FTP
+NLST
+PORT
+</keywords>
+</info>
 # Server-side
 <reply>
 <servercmd>
 REPLY NLST 550 Have a taste on this!
 </servercmd>
 <data>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test146 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test146
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test146	2007-09-18 16:11:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test146	2007-12-09 07:03:52.000000000 +0800
@@ -1,7 +1,14 @@
 <testcase>
+<info>
+<keywords>
+FTP
+RETR
+persistant connection
+</keywords>
+</info>
 # Server-side
 <reply>
 <data>
 this is file contents
 </data>
 </reply>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test200 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test200
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test200	2007-03-10 05:52:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test200	2008-01-05 20:07:11.000000000 +0800
@@ -1,8 +1,13 @@
 <testcase>
-# Server-side
+<info>
+<keywords>
+FILE
+</keywords>
+</info>
+
 <reply>
 <data>
 foo
    bar
 bar
    foo
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test208 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test208
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test208	2007-09-16 04:50:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test208	2007-12-03 17:49:42.000000000 +0800
@@ -41,13 +41,13 @@
 # Verify data after the test has been "shot"
 <verify>
 <strip>
 ^User-Agent:.*
 </strip>
 <protocol>
-PUT ftp://daniel:mysecret@host.com/we/want/208;type=i HTTP/1.1
+PUT ftp://daniel:mysecret@host.com/we/want/208 HTTP/1.1
 Authorization: Basic ZGFuaWVsOm15c2VjcmV0
 Host: host.com:21
 Pragma: no-cache
 Accept: */*
 Proxy-Connection: Keep-Alive
 Content-Length: 78
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test289 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test289
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test289	2007-07-11 06:23:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test289	2008-01-08 05:23:22.000000000 +0800
@@ -11,13 +11,13 @@
 # Client-side
 <client>
 <server>
 ftp
 </server>
  <name>
-FTP resume upload but denied access to remote file
+FTP resume upload but denied access to local file
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/289 -T log/illegal-nonexistent-file -C -
 </command>
 </client>
 
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test35 and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test35 differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test530 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test530
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test530	2007-04-19 04:24:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test530	2008-01-19 18:13:12.000000000 +0800
@@ -4,24 +4,27 @@
 HTTP
 Pipelining
 </keywords>
 </info>
 # Server-side
 <reply>
-<servercmd>
-pipe: 4
-</servercmd>
-<data>
+<data1>
 HTTP/1.1 200 OK
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 Content-Length: 47
 
 file contents should appear once for each file
+</data1>
+<data2>
 HTTP/1.1 200 OK
+</data2>
+<data3>
 Date: Thu, 09 Nov 2010 14:49:00 GMT
+</data3>
+<data4>
 Server: test-server/fake
 Content-Length: 47
 
 file contents should appear once for each file
 HTTP/1.1 200 OK
 Date: Thu, 09 Nov 2010 14:49:00 GMT
@@ -32,13 +35,13 @@
 HTTP/1.1 200 OK
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 Content-Length: 47
 
 file contents should appear once for each file
-</data>
+</data4>
 </reply>
 
 # Client-side
 <client>
 <server>
 http
@@ -54,25 +57,25 @@
 </command>
 </client>
 
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
-GET /path/530 HTTP/1.1
+GET /path/5300001 HTTP/1.1
 Host: %HOSTIP:%HTTPPORT
 Accept: */*
 
-GET /path/530 HTTP/1.1
+GET /path/5300002 HTTP/1.1
 Host: %HOSTIP:%HTTPPORT
 Accept: */*
 
-GET /path/530 HTTP/1.1
+GET /path/5300003 HTTP/1.1
 Host: %HOSTIP:%HTTPPORT
 Accept: */*
 
-GET /path/530 HTTP/1.1
+GET /path/5300004 HTTP/1.1
 Host: %HOSTIP:%HTTPPORT
 Accept: */*
 
 </protocol>
 </verify>
 </testcase>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test546
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test547
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test548
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test549
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test550
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test551
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test552
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data: test553
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test79 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test79
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/data/test79	2007-09-16 04:50:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/data/test79	2007-12-03 17:49:34.000000000 +0800
@@ -42,13 +42,13 @@
 # Verify data after the test has been "shot"
 <verify>
 <strip>
 ^User-Agent:.*
 </strip>
 <protocol>
-GET ftp://%HOSTIP:%HTTPPORT/we/want/that/page/79;type=i HTTP/1.1
+GET ftp://%HOSTIP:%HTTPPORT/we/want/that/page/79 HTTP/1.1
 Host: %HOSTIP:%HTTPPORT
 Pragma: no-cache
 Accept: */*
 Proxy-Connection: Keep-Alive
 
 </protocol>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/FILEFORMAT /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/FILEFORMAT
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/FILEFORMAT	2007-10-27 21:31:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/FILEFORMAT	2008-01-05 08:04:04.000000000 +0800
@@ -272,17 +272,20 @@
 <protocol [nonewline="yes"]>
 the protocol dump curl should transmit, if 'nonewline' is set, we will cut
 off the trailing newline of this given data before comparing with the one
 actually sent by the client
 Variables are substituted as in the <command> section.
 </protocol>
-<stdout [mode="text"]>
+<stdout [mode="text"] [nonewline="yes"]>
 This verifies that this data was passed to stdout.
 
 Use the mode="text" attribute if the output is in text mode on platforms that
 have a text/binary difference.
+
+If 'nonewline' is set, we will cut off the trailing newline of this given data
+before comparing with the one actually received by the client
 </stdout>
 <file name="log/filename" [mode="text"]>
 The file's contents must be identical to this after the test is complete.
 Use the mode="text" attribute if the output is in text mode on platforms that
 have a text/binary difference.
 Variables are substituted as in the <command> section.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/ftpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/ftpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/ftpserver.pl	2007-10-27 21:31:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/ftpserver.pl	2007-11-24 06:05:13.000000000 +0800
@@ -16,13 +16,13 @@
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: ftpserver.pl,v 1.91 2007-10-27 01:02:57 danf Exp $
+# $Id: ftpserver.pl,v 1.93 2007-11-23 09:50:45 yangtse Exp $
 ###########################################################################
 
 # This is the FTP server designed for the curl test suite.
 #
 # It is meant to exercise curl, it is not meant to be a fully working
 # or even very standard compliant server.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/httpsserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/httpsserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/httpsserver.pl	2007-03-09 05:56:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/httpsserver.pl	2007-12-23 06:23:29.000000000 +0800
@@ -1,14 +1,15 @@
 #!/usr/bin/env perl
 #
-# $Id: httpsserver.pl,v 1.9 2007-03-08 02:38:49 danf Exp $
+# $Id: httpsserver.pl,v 1.11 2007-12-22 18:25:52 danf Exp $
 # This is the HTTPS and FTPS server designed for the curl test suite.
 #
 # It is actually just a layer that runs stunnel properly.
 
 use strict;
+use Cwd;
 
 my $stunnel = "stunnel";
 
 #
 # -p pemfile
 # -P pid dir
@@ -18,14 +19,13 @@
 
 my $verbose=0; # set to 1 for debugging
 
 my $port = 8991;        # just our default, weird enough
 my $target_port = 8999; # default test http-server port
 
-my $path = `pwd`;
-chomp $path;
+my $path = getcwd();
 
 my $srcdir=$path;
 
 my $proto='https';
 
 do {
@@ -57,13 +57,13 @@
 } while(shift @ARGV);
 
 my $conffile="$path/stunnel.conf";	# stunnel configuration data
 my $certfile="$srcdir/stunnel.pem";	# stunnel server certificate
 my $pidfile="$path/.$proto.pid";	# stunnel process pid file
 
-open(CONF, ">$conffile") || return 1;
+open(CONF, ">$conffile") || exit 1;
 print CONF "
 	CApath=$path
 	cert = $certfile
 	pid = $pidfile
 	debug = 0
 	output = /dev/null
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/lib518.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/lib518.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/lib518.c	2007-10-01 07:01:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/lib518.c	2008-01-18 07:04:22.000000000 +0800
@@ -2,13 +2,13 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: lib518.c,v 1.33 2007-09-30 01:27:39 yangtse Exp $
+ * $Id: lib518.c,v 1.34 2008-01-17 18:57:50 yangtse Exp $
  */
 
 #include "test.h"
 
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
@@ -150,18 +150,33 @@
    * point the resulting soft limit is our limit. Trying to
    * open more than soft limit file descriptors will fail.
    */
 
   if (rl.rlim_cur != rl.rlim_max) {
 
+#ifdef OPEN_MAX
+    if ((rl.rlim_cur > 0) &&
+        (rl.rlim_cur < OPEN_MAX)) {
+      fprintf(stderr, "raising soft limit up to OPEN_MAX\n");
+      rl.rlim_cur = OPEN_MAX;
+      if (setrlimit(RLIMIT_NOFILE, &rl) != 0) {
+        /* on failure don't abort just issue a warning */
+        store_errmsg("setrlimit() failed", ERRNO);
+        fprintf(stderr, "%s\n", msgbuff);
+        msgbuff[0] = '\0';
+      }
+    }
+#endif
+
     fprintf(stderr, "raising soft limit up to hard limit\n");
     rl.rlim_cur = rl.rlim_max;
     if (setrlimit(RLIMIT_NOFILE, &rl) != 0) {
+      /* on failure don't abort just issue a warning */
       store_errmsg("setrlimit() failed", ERRNO);
       fprintf(stderr, "%s\n", msgbuff);
-      return -2;
+      msgbuff[0] = '\0';
     }
 
     /* get current open file limits */
 
     if (getrlimit(RLIMIT_NOFILE, &rl) != 0) {
       store_errmsg("getrlimit() failed", ERRNO);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/lib530.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/lib530.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/lib530.c	2007-03-10 19:54:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/lib530.c	2008-01-21 19:43:23.000000000 +0800
@@ -2,19 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: lib530.c,v 1.13 2007-03-10 00:19:05 yangtse Exp $
+ * $Id: lib530.c,v 1.16 2008-01-21 05:35:08 yangtse Exp $
  */
 
 #include "test.h"
 
+#ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_STAT_H
 #include <sys/stat.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
 
 #include "testutil.h"
 
 #define MAIN_LOOP_HANG_TIMEOUT     90 * 1000
 #define MULTI_PERFORM_HANG_TIMEOUT 60 * 1000
 
@@ -29,12 +36,13 @@
   CURLM *m;
   int i, j;
   struct timeval ml_start;
   struct timeval mp_start;
   char ml_timedout = FALSE;
   char mp_timedout = FALSE;
+  char target_url[256];
 
   if (curl_global_init(CURL_GLOBAL_ALL) != CURLE_OK) {
     fprintf(stderr, "curl_global_init() failed\n");
     return TEST_ERR_MAJOR_BAD;
   }
 
@@ -55,13 +63,15 @@
         curl_easy_cleanup(curl[j]);
       }
       curl_multi_cleanup(m);
       curl_global_cleanup();
       return TEST_ERR_MAJOR_BAD + i;
     }
-    curl_easy_setopt(curl[i], CURLOPT_URL, URL);
+    sprintf(target_url, "%s%04i", URL, i + 1);
+    target_url[sizeof(target_url) - 1] = '\0';
+    curl_easy_setopt(curl[i], CURLOPT_URL, target_url);
 
     /* go verbose */
     curl_easy_setopt(curl[i], CURLOPT_VERBOSE, 1);
 
     /* include headers */
     curl_easy_setopt(curl[i], CURLOPT_HEADER, 1);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/lib537.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/lib537.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/lib537.c	2007-10-01 07:01:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/lib537.c	2008-01-18 07:04:22.000000000 +0800
@@ -2,13 +2,13 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: lib537.c,v 1.18 2007-09-30 01:27:39 yangtse Exp $
+ * $Id: lib537.c,v 1.19 2008-01-17 18:57:50 yangtse Exp $
  */
 
 #include "test.h"
 
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
@@ -145,18 +145,33 @@
    * point the resulting soft limit is our limit. Trying to
    * open more than soft limit file descriptors will fail.
    */
 
   if (rl.rlim_cur != rl.rlim_max) {
 
+#ifdef OPEN_MAX
+    if ((rl.rlim_cur > 0) &&
+        (rl.rlim_cur < OPEN_MAX)) {
+      fprintf(stderr, "raising soft limit up to OPEN_MAX\n");
+      rl.rlim_cur = OPEN_MAX;
+      if (setrlimit(RLIMIT_NOFILE, &rl) != 0) {
+        /* on failure don't abort just issue a warning */
+        store_errmsg("setrlimit() failed", ERRNO);
+        fprintf(stderr, "%s\n", msgbuff);
+        msgbuff[0] = '\0';
+      }
+    }
+#endif
+
     fprintf(stderr, "raising soft limit up to hard limit\n");
     rl.rlim_cur = rl.rlim_max;
     if (setrlimit(RLIMIT_NOFILE, &rl) != 0) {
+      /* on failure don't abort just issue a warning */
       store_errmsg("setrlimit() failed", ERRNO);
       fprintf(stderr, "%s\n", msgbuff);
-      return -2;
+      msgbuff[0] = '\0';
     }
 
     /* get current open file limits */
 
     if (getrlimit(RLIMIT_NOFILE, &rl) != 0) {
       store_errmsg("getrlimit() failed", ERRNO);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest: lib547.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest: lib549.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest: lib552.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest: lib553.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/Makefile.am	2007-10-26 04:25:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/Makefile.am	2008-01-21 19:43:23.000000000 +0800
@@ -2,26 +2,26 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.am,v 1.56 2007-10-25 19:40:05 patrickm Exp $
+# $Id: Makefile.am,v 1.63 2008-01-21 05:35:08 yangtse Exp $
 ###########################################################################
 AUTOMAKE_OPTIONS = foreign nostdinc
 
 # $(top_srcdir)/include/curl is for the main curl include files, to make it
 # easier to include this specific set of curl headers, and NOT the ones
 # possibly already installed in the system.
@@ -32,26 +32,26 @@
 INCLUDES = -I$(top_srcdir)/include/curl \
            -I$(top_builddir)/lib   \
            -I$(top_srcdir)/lib 
 
 LIBDIR = $(top_builddir)/lib
 
-EXTRA_DIST = test75.pl test307.pl test610.pl test613.pl
+EXTRA_DIST = test75.pl test307.pl test610.pl test613.pl test1013.pl
 
 # files used only in some libcurl test programs
 TESTUTIL = testutil.c testutil.h
 
 # these files are used in every single test program below
 SUPPORTFILES = first.c test.h
 
 # These are all libcurl test programs
 noinst_PROGRAMS = lib500 lib501 lib502 lib503 lib504 lib505 lib506	\
   lib507 lib508 lib509 lib510 lib511 lib512 lib513 lib514 lib515 lib516	\
   lib517 lib518 lib519 lib520 lib521 lib523 lib524 lib525 lib526 lib527	\
   lib529 lib530 lib532 lib533 lib536 lib537 lib540 lib541 lib542 lib543 \
-  lib544 lib545
+  lib544 lib545 lib547 lib548 lib549 lib552 lib553
 
 # Dependencies (may need to be overriden)
 LDADD = $(LIBDIR)/libcurl.la
 DEPENDENCIES = $(LIBDIR)/libcurl.la
 
 
@@ -135,6 +135,17 @@
 lib543_SOURCES = lib543.c $(SUPPORTFILES)
 
 lib544_SOURCES = lib544.c $(SUPPORTFILES)
 
 lib545_SOURCES = lib544.c $(SUPPORTFILES)
 lib545_CFLAGS = -DLIB545
+
+lib547_SOURCES = lib547.c $(SUPPORTFILES)
+
+lib548_SOURCES = lib547.c $(SUPPORTFILES)
+lib548_CFLAGS = -DLIB548
+
+lib549_SOURCES = lib549.c $(SUPPORTFILES)
+
+lib552_SOURCES = lib552.c $(SUPPORTFILES)
+
+lib553_SOURCES = lib553.c $(SUPPORTFILES)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/Makefile.in	2008-01-28 19:59:51.000000000 +0800
@@ -45,13 +45,15 @@
 	lib518$(EXEEXT) lib519$(EXEEXT) lib520$(EXEEXT) \
 	lib521$(EXEEXT) lib523$(EXEEXT) lib524$(EXEEXT) \
 	lib525$(EXEEXT) lib526$(EXEEXT) lib527$(EXEEXT) \
 	lib529$(EXEEXT) lib530$(EXEEXT) lib532$(EXEEXT) \
 	lib533$(EXEEXT) lib536$(EXEEXT) lib537$(EXEEXT) \
 	lib540$(EXEEXT) lib541$(EXEEXT) lib542$(EXEEXT) \
-	lib543$(EXEEXT) lib544$(EXEEXT) lib545$(EXEEXT)
+	lib543$(EXEEXT) lib544$(EXEEXT) lib545$(EXEEXT) \
+	lib547$(EXEEXT) lib548$(EXEEXT) lib549$(EXEEXT) \
+	lib552$(EXEEXT) lib553$(EXEEXT)
 subdir = tests/libtest
 DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
 	$(top_srcdir)/configure.ac
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
@@ -232,12 +234,33 @@
 lib544_DEPENDENCIES = $(LIBDIR)/libcurl.la
 am__objects_13 = lib545-first.$(OBJEXT)
 am_lib545_OBJECTS = lib545-lib544.$(OBJEXT) $(am__objects_13)
 lib545_OBJECTS = $(am_lib545_OBJECTS)
 lib545_LDADD = $(LDADD)
 lib545_DEPENDENCIES = $(LIBDIR)/libcurl.la
+am_lib547_OBJECTS = lib547.$(OBJEXT) $(am__objects_1)
+lib547_OBJECTS = $(am_lib547_OBJECTS)
+lib547_LDADD = $(LDADD)
+lib547_DEPENDENCIES = $(LIBDIR)/libcurl.la
+am__objects_14 = lib548-first.$(OBJEXT)
+am_lib548_OBJECTS = lib548-lib547.$(OBJEXT) $(am__objects_14)
+lib548_OBJECTS = $(am_lib548_OBJECTS)
+lib548_LDADD = $(LDADD)
+lib548_DEPENDENCIES = $(LIBDIR)/libcurl.la
+am_lib549_OBJECTS = lib549.$(OBJEXT) $(am__objects_1)
+lib549_OBJECTS = $(am_lib549_OBJECTS)
+lib549_LDADD = $(LDADD)
+lib549_DEPENDENCIES = $(LIBDIR)/libcurl.la
+am_lib552_OBJECTS = lib552.$(OBJEXT) $(am__objects_1)
+lib552_OBJECTS = $(am_lib552_OBJECTS)
+lib552_LDADD = $(LDADD)
+lib552_DEPENDENCIES = $(LIBDIR)/libcurl.la
+am_lib553_OBJECTS = lib553.$(OBJEXT) $(am__objects_1)
+lib553_OBJECTS = $(am_lib553_OBJECTS)
+lib553_LDADD = $(LDADD)
+lib553_DEPENDENCIES = $(LIBDIR)/libcurl.la
 DEFAULT_INCLUDES = 
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
@@ -255,26 +278,30 @@
 	$(lib518_SOURCES) $(lib519_SOURCES) $(lib520_SOURCES) \
 	$(lib521_SOURCES) $(lib523_SOURCES) $(lib524_SOURCES) \
 	$(lib525_SOURCES) $(lib526_SOURCES) $(lib527_SOURCES) \
 	$(lib529_SOURCES) $(lib530_SOURCES) $(lib532_SOURCES) \
 	$(lib533_SOURCES) $(lib536_SOURCES) $(lib537_SOURCES) \
 	$(lib540_SOURCES) $(lib541_SOURCES) $(lib542_SOURCES) \
-	$(lib543_SOURCES) $(lib544_SOURCES) $(lib545_SOURCES)
+	$(lib543_SOURCES) $(lib544_SOURCES) $(lib545_SOURCES) \
+	$(lib547_SOURCES) $(lib548_SOURCES) $(lib549_SOURCES) \
+	$(lib552_SOURCES) $(lib553_SOURCES)
 DIST_SOURCES = $(lib500_SOURCES) $(lib501_SOURCES) $(lib502_SOURCES) \
 	$(lib503_SOURCES) $(lib504_SOURCES) $(lib505_SOURCES) \
 	$(lib506_SOURCES) $(lib507_SOURCES) $(lib508_SOURCES) \
 	$(lib509_SOURCES) $(lib510_SOURCES) $(lib511_SOURCES) \
 	$(lib512_SOURCES) $(lib513_SOURCES) $(lib514_SOURCES) \
 	$(lib515_SOURCES) $(lib516_SOURCES) $(lib517_SOURCES) \
 	$(lib518_SOURCES) $(lib519_SOURCES) $(lib520_SOURCES) \
 	$(lib521_SOURCES) $(lib523_SOURCES) $(lib524_SOURCES) \
 	$(lib525_SOURCES) $(lib526_SOURCES) $(lib527_SOURCES) \
 	$(lib529_SOURCES) $(lib530_SOURCES) $(lib532_SOURCES) \
 	$(lib533_SOURCES) $(lib536_SOURCES) $(lib537_SOURCES) \
 	$(lib540_SOURCES) $(lib541_SOURCES) $(lib542_SOURCES) \
-	$(lib543_SOURCES) $(lib544_SOURCES) $(lib545_SOURCES)
+	$(lib543_SOURCES) $(lib544_SOURCES) $(lib545_SOURCES) \
+	$(lib547_SOURCES) $(lib548_SOURCES) $(lib549_SOURCES) \
+	$(lib552_SOURCES) $(lib553_SOURCES)
 ETAGS = etags
 CTAGS = ctags
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 ACLOCAL = @ACLOCAL@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
@@ -361,12 +388,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
@@ -425,26 +455,26 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.am,v 1.56 2007-10-25 19:40:05 patrickm Exp $
+# $Id: Makefile.am,v 1.63 2008-01-21 05:35:08 yangtse Exp $
 ###########################################################################
 AUTOMAKE_OPTIONS = foreign nostdinc
 
 # $(top_srcdir)/include/curl is for the main curl include files, to make it
 # easier to include this specific set of curl headers, and NOT the ones
 # possibly already installed in the system.
@@ -453,13 +483,13 @@
 # setup.h file
 INCLUDES = -I$(top_srcdir)/include/curl \
            -I$(top_builddir)/lib   \
            -I$(top_srcdir)/lib 
 
 LIBDIR = $(top_builddir)/lib
-EXTRA_DIST = test75.pl test307.pl test610.pl test613.pl
+EXTRA_DIST = test75.pl test307.pl test610.pl test613.pl test1013.pl
 
 # files used only in some libcurl test programs
 TESTUTIL = testutil.c testutil.h
 
 # these files are used in every single test program below
 SUPPORTFILES = first.c test.h
@@ -509,12 +539,18 @@
 lib541_SOURCES = lib541.c $(SUPPORTFILES)
 lib542_SOURCES = lib542.c $(SUPPORTFILES)
 lib543_SOURCES = lib543.c $(SUPPORTFILES)
 lib544_SOURCES = lib544.c $(SUPPORTFILES)
 lib545_SOURCES = lib544.c $(SUPPORTFILES)
 lib545_CFLAGS = -DLIB545
+lib547_SOURCES = lib547.c $(SUPPORTFILES)
+lib548_SOURCES = lib547.c $(SUPPORTFILES)
+lib548_CFLAGS = -DLIB548
+lib549_SOURCES = lib549.c $(SUPPORTFILES)
+lib552_SOURCES = lib552.c $(SUPPORTFILES)
+lib553_SOURCES = lib553.c $(SUPPORTFILES)
 all: all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .lo .o .obj
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
@@ -666,12 +702,27 @@
 lib544$(EXEEXT): $(lib544_OBJECTS) $(lib544_DEPENDENCIES) 
 	@rm -f lib544$(EXEEXT)
 	$(LINK) $(lib544_LDFLAGS) $(lib544_OBJECTS) $(lib544_LDADD) $(LIBS)
 lib545$(EXEEXT): $(lib545_OBJECTS) $(lib545_DEPENDENCIES) 
 	@rm -f lib545$(EXEEXT)
 	$(LINK) $(lib545_LDFLAGS) $(lib545_OBJECTS) $(lib545_LDADD) $(LIBS)
+lib547$(EXEEXT): $(lib547_OBJECTS) $(lib547_DEPENDENCIES) 
+	@rm -f lib547$(EXEEXT)
+	$(LINK) $(lib547_LDFLAGS) $(lib547_OBJECTS) $(lib547_LDADD) $(LIBS)
+lib548$(EXEEXT): $(lib548_OBJECTS) $(lib548_DEPENDENCIES) 
+	@rm -f lib548$(EXEEXT)
+	$(LINK) $(lib548_LDFLAGS) $(lib548_OBJECTS) $(lib548_LDADD) $(LIBS)
+lib549$(EXEEXT): $(lib549_OBJECTS) $(lib549_DEPENDENCIES) 
+	@rm -f lib549$(EXEEXT)
+	$(LINK) $(lib549_LDFLAGS) $(lib549_OBJECTS) $(lib549_LDADD) $(LIBS)
+lib552$(EXEEXT): $(lib552_OBJECTS) $(lib552_DEPENDENCIES) 
+	@rm -f lib552$(EXEEXT)
+	$(LINK) $(lib552_LDFLAGS) $(lib552_OBJECTS) $(lib552_LDADD) $(LIBS)
+lib553$(EXEEXT): $(lib553_OBJECTS) $(lib553_DEPENDENCIES) 
+	@rm -f lib553$(EXEEXT)
+	$(LINK) $(lib553_LDFLAGS) $(lib553_OBJECTS) $(lib553_LDADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
 
 distclean-compile:
 	-rm -f *.tab.c
@@ -724,12 +775,18 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib541.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib542.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib543.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib544.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib545-first.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib545-lib544.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib547.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib548-first.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib548-lib547.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib549.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib552.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lib553.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/testutil.Po@am__quote@
 
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" -c -o $@ $<; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -985,12 +1042,40 @@
 @am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib545_CFLAGS) $(CFLAGS) -MT lib545-first.obj -MD -MP -MF "$(DEPDIR)/lib545-first.Tpo" -c -o lib545-first.obj `if test -f 'first.c'; then $(CYGPATH_W) 'first.c'; else $(CYGPATH_W) '$(srcdir)/first.c'; fi`; \
 @am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/lib545-first.Tpo" "$(DEPDIR)/lib545-first.Po"; else rm -f "$(DEPDIR)/lib545-first.Tpo"; exit 1; fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='first.c' object='lib545-first.obj' libtool=no @AMDEPBACKSLASH@
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 @am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib545_CFLAGS) $(CFLAGS) -c -o lib545-first.obj `if test -f 'first.c'; then $(CYGPATH_W) 'first.c'; else $(CYGPATH_W) '$(srcdir)/first.c'; fi`
 
+lib548-lib547.o: lib547.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -MT lib548-lib547.o -MD -MP -MF "$(DEPDIR)/lib548-lib547.Tpo" -c -o lib548-lib547.o `test -f 'lib547.c' || echo '$(srcdir)/'`lib547.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/lib548-lib547.Tpo" "$(DEPDIR)/lib548-lib547.Po"; else rm -f "$(DEPDIR)/lib548-lib547.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='lib547.c' object='lib548-lib547.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -c -o lib548-lib547.o `test -f 'lib547.c' || echo '$(srcdir)/'`lib547.c
+
+lib548-lib547.obj: lib547.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -MT lib548-lib547.obj -MD -MP -MF "$(DEPDIR)/lib548-lib547.Tpo" -c -o lib548-lib547.obj `if test -f 'lib547.c'; then $(CYGPATH_W) 'lib547.c'; else $(CYGPATH_W) '$(srcdir)/lib547.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/lib548-lib547.Tpo" "$(DEPDIR)/lib548-lib547.Po"; else rm -f "$(DEPDIR)/lib548-lib547.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='lib547.c' object='lib548-lib547.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -c -o lib548-lib547.obj `if test -f 'lib547.c'; then $(CYGPATH_W) 'lib547.c'; else $(CYGPATH_W) '$(srcdir)/lib547.c'; fi`
+
+lib548-first.o: first.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -MT lib548-first.o -MD -MP -MF "$(DEPDIR)/lib548-first.Tpo" -c -o lib548-first.o `test -f 'first.c' || echo '$(srcdir)/'`first.c; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/lib548-first.Tpo" "$(DEPDIR)/lib548-first.Po"; else rm -f "$(DEPDIR)/lib548-first.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='first.c' object='lib548-first.o' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -c -o lib548-first.o `test -f 'first.c' || echo '$(srcdir)/'`first.c
+
+lib548-first.obj: first.c
+@am__fastdepCC_TRUE@	if $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -MT lib548-first.obj -MD -MP -MF "$(DEPDIR)/lib548-first.Tpo" -c -o lib548-first.obj `if test -f 'first.c'; then $(CYGPATH_W) 'first.c'; else $(CYGPATH_W) '$(srcdir)/first.c'; fi`; \
+@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/lib548-first.Tpo" "$(DEPDIR)/lib548-first.Po"; else rm -f "$(DEPDIR)/lib548-first.Tpo"; exit 1; fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='first.c' object='lib548-first.obj' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib548_CFLAGS) $(CFLAGS) -c -o lib548-first.obj `if test -f 'first.c'; then $(CYGPATH_W) 'first.c'; else $(CYGPATH_W) '$(srcdir)/first.c'; fi`
+
 mostlyclean-libtool:
 	-rm -f *.lo
 
 clean-libtool:
 	-rm -rf .libs _libs
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest: test1013.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/test613.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/test613.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/libtest/test613.pl	2007-09-18 04:27:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/libtest/test613.pl	2007-11-07 00:01:14.000000000 +0800
@@ -66,33 +66,37 @@
 		# -r--r--r--   12 ausername grp            47 Dec 31  2000 rofile.txt
 		# -r--r--r--   1  1234  4321         47 Dec 31  2000 rofile.txt
 		# The "canonical" format is similar to the first (which is
 		# the one generated on a typical Linux installation):
 		# -r-?r-?r-?   12 U         U              47 Dec 31  2000 rofile.txt
 
-		my $newfile = $logfile . ".new";
+		my @canondir;
 		open(IN, "<$logfile") || die "$!";
-		open(OUT, ">$newfile") || die "$!";
 		while (<IN>) {
 			/^(.)(..).(..).(..).\s*(\S+)\s+\S+\s+\S+\s+(\S+)\s+(\S+\s+\S+\s+\S+)(.*)$/;
 			if ($1 eq "d") {
 				# Erase all directory metadata except for the name, as it is not
 				# consistent for across all test systems and filesystems
-				print OUT "d?????????    N U         U               N ???  N NN:NN$8\n";
+				push @canondir, "d?????????    N U         U               N ???  N NN:NN$8\n";
 			} elsif ($1 eq "-") {
 				# Erase user and group names, as they are not consistent across
 				# all test systems
-				printf OUT "%s%s?%s?%s?%5d U         U %15d %s%s\n", $1,$2,$3,$4,$5,$6,$7,$8;
+				my $line = sprintf("%s%s?%s?%s?%5d U         U %15d %s%s\n", $1,$2,$3,$4,$5,$6,$7,$8);
+				push @canondir, $line;
 			} else {
 				# Unexpected format; just pass it through and let the test fail
-				print OUT $_;
+				push @canondir, $_;
 			}
 		}
+		close(IN);
 
+		@canondir = sort {substr($a,57) cmp substr($b,57)} @canondir;
+		my $newfile = $logfile . ".new";
+		open(OUT, ">$newfile") || die "$!";
+		print OUT join('', @canondir);
 		close(OUT);
-		close(IN);
 
 		unlink $logfile;
 		rename $newfile, $logfile;
 	}
 
 	exit 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/Makefile.am	2007-07-07 04:13:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/Makefile.am	2008-01-04 05:48:35.000000000 +0800
@@ -2,34 +2,34 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2005, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.am,v 1.46 2007-07-05 01:38:00 danf Exp $
+# $Id: Makefile.am,v 1.47 2008-01-03 20:48:22 yangtse Exp $
 ###########################################################################
 
 HTMLPAGES = testcurl.html runtests.html
 PDFPAGES = testcurl.pdf runtests.pdf
 
 EXTRA_DIST = ftpserver.pl httpserver.pl httpsserver.pl runtests.pl getpart.pm \
  FILEFORMAT README stunnel.pem memanalyze.pl testcurl.pl valgrind.pm ftp.pm   \
- sshserver.pl testcurl.1 runtests.1 $(HTMLPAGES) $(PDFPAGES)
+ sshserver.pl sshhelp.pm testcurl.1 runtests.1 $(HTMLPAGES) $(PDFPAGES)
 
 SUBDIRS = data server libtest
 
 PERLFLAGS = -I$(srcdir)
 
 CLEANFILES = .http.pid .https.pid .ftp.pid .ftps.pid
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/Makefile.in	2007-10-27 06:25:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/Makefile.in	2008-01-28 19:59:50.000000000 +0800
@@ -18,26 +18,26 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2005, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.am,v 1.46 2007-07-05 01:38:00 danf Exp $
+# $Id: Makefile.am,v 1.47 2008-01-03 20:48:22 yangtse Exp $
 ###########################################################################
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -167,12 +167,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
@@ -227,13 +230,13 @@
 sysconfdir = @sysconfdir@
 target_alias = @target_alias@
 HTMLPAGES = testcurl.html runtests.html
 PDFPAGES = testcurl.pdf runtests.pdf
 EXTRA_DIST = ftpserver.pl httpserver.pl httpsserver.pl runtests.pl getpart.pm \
  FILEFORMAT README stunnel.pem memanalyze.pl testcurl.pl valgrind.pm ftp.pm   \
- sshserver.pl testcurl.1 runtests.1 $(HTMLPAGES) $(PDFPAGES)
+ sshserver.pl sshhelp.pm testcurl.1 runtests.1 $(HTMLPAGES) $(PDFPAGES)
 
 SUBDIRS = data server libtest
 PERLFLAGS = -I$(srcdir)
 CLEANFILES = .http.pid .https.pid .ftp.pid .ftps.pid
 MAN2HTML = roffit < $< >$@
 @CROSSCOMPILING_FALSE@TEST = srcdir=$(srcdir) $(PERL) $(PERLFLAGS) $(srcdir)/runtests.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/runtests.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/runtests.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/runtests.pl	2007-10-27 06:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/runtests.pl	2008-01-19 05:50:46.000000000 +0800
@@ -3,26 +3,26 @@
 #                                  _   _ ____  _
 #  Project                     ___| | | |  _ \| |
 #                             / __| | | | |_) | |
 #                            | (__| |_| |  _ <| |___
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # This software is licensed as described in the file COPYING, which
 # you should have received as part of this distribution. The terms
 # are also available at http://curl.haxx.se/docs/copyright.html.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: runtests.pl,v 1.255 2007-10-26 19:26:04 danf Exp $
+# $Id: runtests.pl,v 1.284 2008-01-18 09:18:59 yangtse Exp $
 ###########################################################################
 
 # Experimental hooks are available to run tests remotely on machines that
 # are able to run curl but are unable to run the test harness.  
 # The following sections need to be modified:
 #
@@ -53,17 +53,35 @@
 # fixed. As long as the -g option is never given, and the -n is always
 # given, this won't be a problem.
 
 
 # These should be the only variables that might be needed to get edited:
 
+BEGIN {
+    @INC=(@INC, $ENV{'srcdir'}, ".");
+}
+
 use strict;
 #use Time::HiRes qw( gettimeofday );
 #use warnings;
+use Cwd;
 
-@INC=(@INC, $ENV{'srcdir'}, ".");
+# Variables and subs imported from sshhelp module
+use sshhelp qw(
+    $sshdexe
+    $sshexe
+    $sshconfig
+    $sshlog
+    display_sshdconfig
+    display_sshconfig
+    display_sshdlog
+    display_sshlog
+    find_sshd
+    find_ssh
+    sshversioninfo
+    );
 
 require "getpart.pm"; # array functions
 require "valgrind.pm"; # valgrind report parser
 require "ftp.pm";
 
 my $HOSTIP="127.0.0.1";   # address on which the test server listens
@@ -130,14 +148,13 @@
 # name of the file that the memory debugging creates:
 my $memdump="$LOGDIR/memdump";
 
 # the path to the script that analyzes the memory debug output file:
 my $memanalyze="$perl $srcdir/memanalyze.pl";
 
-my $pwd;          # current working directory
-chomp($pwd = `pwd`);
+my $pwd = getcwd();          # current working directory
 
 my $start;
 my $forkserver=0;
 my $ftpchecktime; # time it took to verify our test FTP server
 
 my $stunnel = checkcmd("stunnel4") || checkcmd("stunnel");
@@ -170,12 +187,17 @@
 
 my $skipped=0;  # number of tests skipped; reported in main loop
 my %skipped;    # skipped{reason}=counter, reasons for skip
 my @teststat;   # teststat[testnum]=reason, reasons for skip
 my %disabled_keywords;	# key words of tests to skip
 
+my $sshdid;      # for socks server, ssh daemon version id
+my $sshdvernum;  # for socks server, ssh daemon version number
+my $sshdverstr;  # for socks server, ssh daemon version string
+my $sshderror;   # for socks server, ssh daemon version error
+
 #######################################################################
 # variables the command line options may set
 #
 
 my $short;
 my $verbose;
@@ -184,12 +206,13 @@
 my $gdbthis;      # run test case with gdb debugger
 my $keepoutfiles; # keep stdout and stderr files after tests
 my $listonly;     # only list the tests
 my $postmortem;   # display detailed info about failed tests
 
 my %run;	  # running server
+my %doesntrun;    # servers that don't work, identified by pidfile
 
 # torture test variables
 my $torture;
 my $tortnum;
 my $tortalloc;
 
@@ -254,30 +277,33 @@
 #######################################################################
 # Check if a given child process has just died. Reaps it if so.
 #
 sub checkdied {
     use POSIX ":sys_wait_h";
     my $pid = $_[0];
+    if(not defined $pid || $pid <= 0) {
+        return 0;
+    }
     my $rc = waitpid($pid, &WNOHANG);
-    return $rc == $pid;
+    return ($rc == $pid)?1:0;
 }
 
 #######################################################################
 # Start a new thread/process and run the given command line in there.
 # Return the pids (yes plural) of the new child process to the parent.
 #
 sub startnew {
-    my ($cmd, $pidfile,$fake)=@_;
+    my ($cmd, $pidfile, $timeout, $fake)=@_;
 
     logmsg "startnew: $cmd\n" if ($verbose);
 
     my $child = fork();
-    my $pid2;
+    my $pid2 = 0;
 
     if(not defined $child) {
-        logmsg "fork() failure detected\n";
+        logmsg "startnew: fork() failure detected\n";
         return (-1,-1);
     }
 
     if(0 == $child) {
         # Here we are the child. Run the given command.
 
@@ -287,41 +313,47 @@
 
         # exec() should never return back here to this process. We protect
         # ourselves by calling die() just in case something goes really bad.
         die "error: exec() has returned";
     }
 
-
-    # Ugly hack but ssh doesn't support pid files
+    # Ugly hack but ssh client doesn't support pid files
     if ($fake) {
-        logmsg "$pidfile faked with pid=$child\n" if($verbose);
-        open(OUT, ">$pidfile");
-        print OUT $child . "\n";
-        close(OUT);
+        if(open(OUT, ">$pidfile")) {
+            print OUT $child . "\n";
+            close(OUT);
+            logmsg "startnew: $pidfile faked with pid=$child\n" if($verbose);
+        }
+        else {
+            logmsg "startnew: failed to write fake $pidfile with pid=$child\n";
+        }
 	# could/should do a while connect fails sleep a bit and loop
-	sleep 5;
+        sleep $timeout;
         if (checkdied($child)) {
-            logmsg "startnew: Warning: child process has failed to start\n" if($verbose);
+            logmsg "startnew: child process has failed to start\n" if($verbose);
             return (-1,-1);
         }
     }
-    my $count=12;
+
+    my $count = $timeout;
     while($count--) {
-        if(-f $pidfile) {
-            open(PID, "<$pidfile");
+        if(-f $pidfile && -s $pidfile && open(PID, "<$pidfile")) {
             $pid2 = 0 + <PID>;
             close(PID);
-            if($pid2 && kill(0, $pid2)) {
+            if(($pid2 > 0) && kill(0, $pid2)) {
                 # if $pid2 is valid, then make sure this pid is alive, as
                 # otherwise it is just likely to be the _previous_ pidfile or
                 # similar!
                 last;
             }
+            # invalidate $pid2 if not actually alive
+            $pid2 = 0;
         }
         if (checkdied($child)) {
-            logmsg "startnew: Warning: child process has died\n" if($verbose);
+            logmsg "startnew: child process has died, server might start up\n"
+                if($verbose);
             # We can't just abort waiting for the server with a
             # return (-1,-1);
             # because the server might have forked and could still start
             # up normally. Instead, just reduce the amount of time we remain
             # waiting.
             $count >>= 2;
@@ -338,14 +370,14 @@
 
 #######################################################################
 # Check for a command in the PATH of the test server.
 #
 sub checkcmd {
     my ($cmd)=@_;
-    my @paths=("/usr/sbin", "/usr/local/sbin", "/sbin", "/usr/bin",
-               "/usr/local/bin", split(":", $ENV{'PATH'}));
+    my @paths=(split(":", $ENV{'PATH'}), "/usr/sbin", "/usr/local/sbin",
+               "/sbin", "/usr/bin", "/usr/local/bin" );
     for(@paths) {
         if( -x "$_/$cmd") {
             return "$_/$cmd";
         }
     }
 }
@@ -627,26 +659,50 @@
 
 #######################################################################
 # STUB for verifying scp/sftp
 
 sub verifyssh {
     my ($proto, $ip, $port) = @_;
-    open(FILE, "<$SSHPIDFILE");
-    my $pid=0+<FILE>;
-    close(FILE);
+    my $pid = 0;
+    if(open(FILE, "<$SSHPIDFILE")) {
+        $pid=0+<FILE>;
+        close(FILE);
+    }
+    if($pid > 0) {
+        # if we have a pid it is actually our ssh server,
+        # since runsshserver() unlinks previous pidfile
+        if(!kill(0, $pid)) {
+            logmsg "RUN: SSH server has died after starting up\n";
+            checkdied($pid);
+            unlink($SSHPIDFILE);
+            $pid = -1;
+        }
+    }
     return $pid;
 }
 
 #######################################################################
 # STUB for verifying socks
 
 sub verifysocks {
     my ($proto, $ip, $port) = @_;
-    open(FILE, "<$SOCKSPIDFILE");
-    my $pid=0+<FILE>;
-    close(FILE);
+    my $pid = 0;
+    if(open(FILE, "<$SOCKSPIDFILE")) {
+        $pid=0+<FILE>;
+        close(FILE);
+    }
+    if($pid > 0) {
+        # if we have a pid it is actually our socks server,
+        # since runsocksserver() unlinks previous pidfile
+        if(!kill(0, $pid)) {
+            logmsg "RUN: SOCKS server has died after starting up\n";
+            checkdied($pid);
+            unlink($SOCKSPIDFILE);
+            $pid = -1;
+        }
+    }
     return $pid;
 }
 
 #######################################################################
 # Verify that the server that runs on $ip, $port is our server.
 # Retry over several seconds before giving up.  The ssh server in
@@ -705,12 +761,17 @@
         $pidfile = $HTTP6PIDFILE;
         $port = $HTTP6PORT;
         $ip = $HOST6IP;
         $nameext="-ipv6";
     }
 
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
     $pid = checkserver($pidfile);
 
     if($pid > 0) {
         stopserver($pid);
     }
 
@@ -719,26 +780,27 @@
     if($dir) {
         $flag .= "-d \"$dir\" ";
     }
 
     my $cmd="$perl $srcdir/httpserver.pl -p $pidfile $fork$flag $port $ipv6";
     my ($httppid, $pid2) =
-        startnew($cmd, $pidfile,0); # start the server in a new process
+        startnew($cmd, $pidfile, 15, 0); # start the server in a new process
 
     if($httppid <= 0 || !kill(0, $httppid)) {
         # it is NOT alive
-        logmsg "RUN: failed to start the HTTP server\n";
-        stopservers($verbose);
+        logmsg "RUN: failed to start the HTTP$nameext server\n";
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     # Server is up. Verify that we can speak to it.
     if(!verifyserver("http", $ip, $port)) {
         logmsg "RUN: HTTP$nameext server failed verification\n";
         # failed to talk to it properly. Kill the server and return failure
         stopserver("$httppid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     if($verbose) {
         logmsg "RUN: HTTP$nameext server is now running PID $httppid\n";
     }
@@ -753,46 +815,54 @@
 #
 sub runhttpsserver {
     my ($verbose, $ipv6) = @_;
     my $STATUS;
     my $RUNNING;
     my $ip = $HOSTIP;
+    my $pidfile = $HTTPSPIDFILE;
 
     if(!$stunnel) {
         return 0;
     }
 
     if($ipv6) {
         # not complete yet
         $ip = $HOST6IP;
     }
 
-    my $pid=checkserver($HTTPSPIDFILE);
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
+    my $pid=checkserver($pidfile);
 
     if($pid > 0) {
         # kill previous stunnel!
         stopserver($pid);
     }
 
     my $flag=$debugprotocol?"-v ":"";
     my $cmd="$perl $srcdir/httpsserver.pl $flag -p https -s \"$stunnel\" -d $srcdir -r $HTTPPORT $HTTPSPORT";
 
-    my ($httpspid, $pid2) = startnew($cmd, $HTTPSPIDFILE,0);
+    my ($httpspid, $pid2) = startnew($cmd, $pidfile, 15, 0);
 
     if($httpspid <= 0 || !kill(0, $httpspid)) {
         # it is NOT alive
         logmsg "RUN: failed to start the HTTPS server\n";
         stopservers($verbose);
+        $doesntrun{$pidfile} = 1;
         return(0,0);
     }
 
     # Server is up. Verify that we can speak to it.
     if(!verifyserver("https", $ip, $HTTPSPORT)) {
         logmsg "RUN: HTTPS server failed verification\n";
         # failed to talk to it properly. Kill the server and return failure
         stopserver("$httpspid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     if($verbose) {
         logmsg "RUN: HTTPS server is now running PID $httpspid\n";
     }
@@ -821,12 +891,17 @@
         $pidfile = $FTP6PIDFILE;
         $port = $FTP6PORT;
         $ip = $HOST6IP;
         $nameext="-ipv6";
     }
 
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
     my $pid = checkserver($pidfile);
     if($pid >= 0) {
         stopserver($pid);
     }
 
     # start our server:
@@ -843,25 +918,27 @@
         $addr = $HOSTIP;
     }
     $cmd="$perl $srcdir/ftpserver.pl --pidfile $pidfile $flag --port $port --addr \"$addr\"";
 
     unlink($pidfile);
 
-    my ($ftppid, $pid2) = startnew($cmd, $pidfile,0);
+    my ($ftppid, $pid2) = startnew($cmd, $pidfile, 15, 0);
 
     if($ftppid <= 0 || !kill(0, $ftppid)) {
         # it is NOT alive
         logmsg "RUN: failed to start the FTP$id$nameext server\n";
-        return -1;
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
     }
 
     # Server is up. Verify that we can speak to it.
     if(!verifyserver("ftp", $ip, $port)) {
         logmsg "RUN: FTP$id$nameext server failed verification\n";
         # failed to talk to it properly. Kill the server and return failure
         stopserver("$ftppid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     if($verbose) {
         logmsg "RUN: FTP$id$nameext server is now running PID $ftppid\n";
     }
@@ -876,46 +953,54 @@
 #
 sub runftpsserver {
     my ($verbose, $ipv6) = @_;
     my $STATUS;
     my $RUNNING;
     my $ip = $HOSTIP;
+    my $pidfile = $FTPSPIDFILE;
 
     if(!$stunnel) {
         return 0;
     }
 
     if($ipv6) {
         # not complete yet
         $ip = $HOST6IP;
     }
 
-    my $pid=checkserver($FTPSPIDFILE);
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
+    my $pid=checkserver($pidfile);
 
     if($pid > 0) {
         # kill previous stunnel!
         stopserver($pid);
     }
 
     my $flag=$debugprotocol?"-v ":"";
     my $cmd="$perl $srcdir/httpsserver.pl $flag -p ftps -s \"$stunnel\" -d $srcdir -r $FTPPORT $FTPSPORT";
 
-    my ($ftpspid, $pid2) = startnew($cmd, $FTPSPIDFILE,0);
+    my ($ftpspid, $pid2) = startnew($cmd, $pidfile, 15, 0);
 
     if($ftpspid <= 0 || !kill(0, $ftpspid)) {
         # it is NOT alive
         logmsg "RUN: failed to start the FTPS server\n";
         stopservers($verbose);
+        $doesntrun{$pidfile} = 1;
         return(0,0);
     }
 
     # Server is up. Verify that we can speak to it.
     if(!verifyserver("ftps", $ip, $FTPSPORT)) {
         logmsg "RUN: FTPS server failed verification\n";
         # failed to talk to it properly. Kill the server and return failure
         stopserver("$ftpspid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     if($verbose) {
         logmsg "RUN: FTPS server is now running PID $ftpspid\n";
     }
@@ -944,12 +1029,17 @@
         $pidfile = $TFTP6PIDFILE;
         $port = $TFTP6PORT;
         $ip = $HOST6IP;
         $nameext="-ipv6";
     }
 
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
     my $pid = checkserver($pidfile);
     if($pid >= 0) {
         stopserver($pid);
     }
 
     # start our server:
@@ -962,25 +1052,27 @@
         $flag .="--ipv6 ";
     }
     $cmd="./server/tftpd --pidfile $pidfile $flag $port";
 
     unlink($pidfile);
 
-    my ($tftppid, $pid2) = startnew($cmd, $pidfile,0);
+    my ($tftppid, $pid2) = startnew($cmd, $pidfile, 15, 0);
 
     if($tftppid <= 0 || !kill(0, $tftppid)) {
         # it is NOT alive
-        logmsg "RUN: failed to start the FTP$id$nameext server\n";
-        return -1;
+        logmsg "RUN: failed to start the TFTP$id$nameext server\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
     }
 
     # Server is up. Verify that we can speak to it.
     if(!verifyserver("tftp", $ip, $port)) {
         logmsg "RUN: TFTP$id$nameext server failed verification\n";
         # failed to talk to it properly. Kill the server and return failure
         stopserver("$tftppid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     if($verbose) {
         logmsg "RUN: TFTP$id$nameext server is now running PID $tftppid\n";
     }
@@ -995,38 +1087,60 @@
 # Start the scp/sftp server
 #
 sub runsshserver {
     my ($id, $verbose, $ipv6) = @_;
     my $ip=$HOSTIP;
     my $port = $SSHPORT;
+    my $socksport = $SOCKSPORT;
     my $pidfile = $SSHPIDFILE;
 
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
     my $pid = checkserver($pidfile);
     if($pid > 0) {
         stopserver($pid);
     }
+    unlink($pidfile);
 
-    my $flag=$debugprotocol?"-v ":"";
-    my $cmd="$perl $srcdir/sshserver.pl $flag-u $USER -l $HOSTIP -d $srcdir $port";
-    my ($sshpid, $pid2) =
-        startnew($cmd, $pidfile,0); # start the server in a new process
+    my $flag=$verbose?'-v ':'';
+    $flag .= '-d ' if($debugprotocol);
+
+    my $cmd="$perl $srcdir/sshserver.pl ${flag}-u $USER -l $ip -p $port -s $socksport";
+    my ($sshpid, $pid2) = startnew($cmd, $pidfile, 60, 0);
+
+    # on loaded systems sshserver start up can take longer than the timeout
+    # passed to startnew, when this happens startnew completes without being
+    # able to read the pidfile and consequently returns a zero pid2 above.
 
     if($sshpid <= 0 || !kill(0, $sshpid)) {
         # it is NOT alive
         logmsg "RUN: failed to start the SSH server\n";
-        # failed to talk to it properly. Kill the server and return failure
-        stopserver("$sshpid $pid2");
-        return -1;
+        stopserver("$pid2");
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
     }
 
-    if (!verifyserver('ssh',$ip,$port)) {
+    # server verification allows some extra time for the server to start up
+    # and gives us the opportunity of recovering the pid from the pidfile,
+    # which will be assigned to pid2 ONLY if pid2 was not already positive.
+
+    my $pid3 = verifyserver("ssh",$ip,$port);
+    if(!$pid3) {
         logmsg "RUN: SSH server failed verification\n";
+        # failed to talk to it properly. Kill the server and return failure
+        stopserver("$sshpid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
+    $pid2 = $pid3 if($pid2 <= 0);
+
     if($verbose) {
-        logmsg "RUN: SSH server is now running PID $sshpid\n";
+        logmsg "RUN: SSH server is now running PID $pid2\n";
     }
 
     return ($pid2, $sshpid);
 }
 
 #######################################################################
@@ -1035,32 +1149,120 @@
 sub runsocksserver {
     my ($id, $verbose, $ipv6) = @_;
     my $ip=$HOSTIP;
     my $port = $SOCKSPORT;
     my $pidfile = $SOCKSPIDFILE;
 
-    my $flag=$debugprotocol?"-v ":"";
-    my $cmd="ssh -D ${HOSTIP}:$SOCKSPORT -N -F curl_ssh_config ${USER}\@${HOSTIP} -p ${SSHPORT} -vv >log/ssh.log 2>&1";
-    my ($sshpid, $pid2) =
-        startnew($cmd, $pidfile,1); # start the server in a new process
+    # don't retry if the server doesn't work
+    if ($doesntrun{$pidfile}) {
+        return (0,0);
+    }
+
+    my $pid = checkserver($pidfile);
+    if($pid > 0) {
+        stopserver($pid);
+    }
+    unlink($pidfile);
+
+    # The ssh server must be already running
+    if(!$run{'ssh'}) {
+        logmsg "RUN: SOCKS server cannot find running SSH server\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+
+    # Find out ssh daemon canonical file name
+    my $sshd = find_sshd();
+    if(!$sshd) {
+        logmsg "RUN: SOCKS server cannot find $sshdexe\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+
+    # Find out ssh daemon version info
+    ($sshdid, $sshdvernum, $sshdverstr, $sshderror) = sshversioninfo($sshd);
+    if(!$sshdid) {
+        # Not an OpenSSH or SunSSH ssh daemon
+        logmsg "$sshderror\n" if($verbose);
+        logmsg "SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+    logmsg "ssh server found $sshd is $sshdverstr\n" if($verbose);
+
+    # Find out ssh client canonical file name
+    my $ssh = find_ssh();
+    if(!$ssh) {
+        logmsg "RUN: SOCKS server cannot find $sshexe\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+
+    # Find out ssh client version info
+    my ($sshid, $sshvernum, $sshverstr, $ssherror) = sshversioninfo($ssh);
+    if(!$sshid) {
+        # Not an OpenSSH or SunSSH ssh client
+        logmsg "$ssherror\n" if($verbose);
+        logmsg "SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+
+    # Verify minimum ssh client version
+    if((($sshid =~ /OpenSSH/) && ($sshvernum < 299)) ||
+       (($sshid =~ /SunSSH/)  && ($sshvernum < 100))) {
+        logmsg "ssh client found $ssh is $sshverstr\n";
+        logmsg "SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+    logmsg "ssh client found $ssh is $sshverstr\n" if($verbose);
+
+    # Verify if ssh client and ssh daemon versions match
+    if(($sshdid ne $sshid) || ($sshdvernum != $sshvernum)) {
+        # Our test harness might work with slightly mismatched versions
+        logmsg "Warning: version mismatch: sshd $sshdverstr - ssh $sshverstr\n"
+            if($verbose);
+    }
+
+    # Config file options for ssh client are previously set from sshserver.pl
+    if(! -e $sshconfig) {
+        logmsg "RUN: SOCKS server cannot find $sshconfig\n";
+        $doesntrun{$pidfile} = 1;
+        return (0,0);
+    }
+
+    # start our socks server
+    my $cmd="$ssh -N -F $sshconfig $ip > $sshlog 2>&1";
+    my ($sshpid, $pid2) = startnew($cmd, $pidfile, 30, 1);
 
     if($sshpid <= 0 || !kill(0, $sshpid)) {
         # it is NOT alive
         logmsg "RUN: failed to start the SOCKS server\n";
-        # failed to talk to it properly. Kill the server and return failure
-        stopserver("$sshpid $pid2");
+        display_sshlog();
+        display_sshconfig();
+        display_sshdlog();
+        display_sshdconfig();
+        stopserver("$pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
 
     # Ugly hack but ssh doesn't support pid files
-    if (!verifyserver('socks',$ip,$port)) {
+    my $pid3 = verifyserver("socks",$ip,$port);
+    if(!$pid3) {
         logmsg "RUN: SOCKS server failed verification\n";
+        # failed to talk to it properly. Kill the server and return failure
+        stopserver("$sshpid $pid2");
+        $doesntrun{$pidfile} = 1;
         return (0,0);
     }
+    $pid2 = $pid3 if($pid2 <= 0);
+
     if($verbose) {
-        logmsg "RUN: SOCKS server is now running PID $sshpid\n";
+        logmsg "RUN: SOCKS server is now running PID $pid2\n";
     }
 
     return ($pid2, $sshpid);
 }
 
 #######################################################################
@@ -1829,13 +2031,13 @@
     $cmd = $postcheck[0];
     chomp $cmd;
     subVariables \$cmd;
     if($cmd) {
 	my $rc = runclient("$cmd");
 	if($rc != 0) {
-	    logmsg "postcheck failure\n";
+	    logmsg " postcheck FAILED\n";
 	    return 1;
 	}
 	logmsg "postchecked $cmd\n" if($verbose);
     }
 
     # remove the special FTP command file after each test!
@@ -1869,12 +2071,18 @@
         my $filemode=$hash{'mode'};
         if(($filemode eq "text") && $has_textaware) {
             # text mode when running on windows: fix line endings
             map s/\r\n/\n/g, @actual;
         }
 
+        if($hash{'nonewline'}) {
+            # Yes, we must cut off the final newline from the final line
+            # of the protocol data
+            chomp($validstdout[$#validstdout]);
+        }
+
         $res = compare("stdout", \@actual, \@validstdout);
         if($res) {
             return 1;
         }
         $ok .= "s";
     }
@@ -2320,35 +2528,39 @@
                 if($pid <= 0) {
                     return "failed starting SSH server";
                 }
                 printf ("* pid ssh => %d %d\n", $pid, $pid2) if($verbose);
                 $run{'ssh'}="$pid $pid2";
             }
-	    if ($what eq "socks4" || $what eq "socks5") {
-                if (!checkcmd("ssh")) {
-                   return "failed to find SSH client for socks support";
-		}
+            if($what eq "socks4" || $what eq "socks5") {
             	if(!$run{'socks'}) {
-		    my $sshversion=`ssh -V 2>&1`;
-                    if ($sshversion =~ /SSH_(\d+)\.(\d+)/i) {
-                       if ($1*10+$2 < 37) {
-		       # need 3.7 for socks5 - http://www.openssh.com/txt/release-3.7
-                           return "ssh version ($1.$2) insufficient; need at least 3.7";
-		       }
-                    } else {
-                       return "Unsupported ssh client\n";
-                    }
-
                     ($pid, $pid2) = runsocksserver("", $verbose);
                     if($pid <= 0) {
                         return "failed starting socks server";
                     }
                     printf ("* pid socks => %d %d\n", $pid, $pid2) if($verbose);
                     $run{'socks'}="$pid $pid2";
 		}
 	    }
+            if($what eq "socks5") {
+                if(!$sshdid) {
+                    # Not an OpenSSH or SunSSH ssh daemon
+                    logmsg "Not OpenSSH or SunSSH; socks5 tests need at least OpenSSH 3.7\n";
+                    return "failed starting socks5 server";
+                }
+                elsif(($sshdid =~ /OpenSSH/) && ($sshdvernum < 370)) {
+                    # Need OpenSSH 3.7 for socks5 - http://www.openssh.com/txt/release-3.7
+                    logmsg "$sshdverstr insufficient; socks5 tests need at least OpenSSH 3.7\n";
+                    return "failed starting socks5 server";
+                }
+                elsif(($sshdid =~ /SunSSH/)  && ($sshdvernum < 100)) {
+                    # Need SunSSH 1.0 for socks5
+                    logmsg "$sshdverstr insufficient; socks5 tests need at least SunSSH 1.0\n";
+                    return "failed starting socks5 server";
+                }
+            }
         }
         elsif($what eq "none") {
             logmsg "* starts no server\n" if ($verbose);
         }
         else {
             warn "we don't support a server for $what";
@@ -2790,12 +3002,14 @@
 #
 close(CMDLOG);
 
 # Tests done, stop the servers
 stopservers($verbose);
 
+unlink($SOCKSPIDFILE);
+
 my $all = $total + $skipped;
 
 if($total) {
     logmsg sprintf("TESTDONE: $ok tests out of $total reported OK: %d%%\n",
                    $ok/$total*100);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/Makefile.in	2007-10-27 06:25:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/Makefile.in	2008-01-28 19:59:51.000000000 +0800
@@ -195,12 +195,15 @@
 RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 REQUIRE_LIB_DEPS = @REQUIRE_LIB_DEPS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
+SSL_ENABLED = @SSL_ENABLED@
+STATICLIB_FALSE = @STATICLIB_FALSE@
+STATICLIB_TRUE = @STATICLIB_TRUE@
 STRIP = @STRIP@
 TEST_SERVER_LIBS = @TEST_SERVER_LIBS@
 USE_GNUTLS = @USE_GNUTLS@
 USE_LIBSSH2 = @USE_LIBSSH2@
 USE_MANUAL_FALSE = @USE_MANUAL_FALSE@
 USE_MANUAL_TRUE = @USE_MANUAL_TRUE@
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/sws.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/sws.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/sws.c	2007-10-27 06:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/sws.c	2008-01-26 06:11:16.000000000 +0800
@@ -15,13 +15,13 @@
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sws.c,v 1.108 2007-10-26 00:36:36 yangtse Exp $
+ * $Id: sws.c,v 1.110 2008-01-25 05:08:53 yangtse Exp $
  ***************************************************************************/
 
 /* sws.c: simple (silly?) web server
 
    This code was originally graciously donated to the project by Juergen
    Wilke. Thanks a bunch!
@@ -104,12 +104,14 @@
   size_t cl;      /* Content-Length of the incoming request */
   bool digest;    /* Authorization digest header found */
   bool ntlm;      /* Authorization ntlm header found */
   int pipe;       /* if non-zero, expect this many requests to do a "piped"
                      request/response */
   int rcmd;       /* doing a special command, see defines above */
+  int prot_version; /* HTTP version * 10 */
+  bool pipelining; /* true if request is pipelined */
 };
 
 int ProcessRequest(struct httprequest *req);
 void storerequest(char *reqbuf, ssize_t totalsize);
 
 #define DEFAULT_PORT 8999
@@ -212,12 +214,14 @@
             request,
             doc,
             &prot_major,
             &prot_minor) == 4) {
     char *ptr;
 
+    req->prot_version = prot_major*10 + prot_minor;
+
     /* find the last slash */
     ptr = strrchr(doc, '/');
 
     /* get the number after it */
     if(ptr) {
       FILE *stream;
@@ -312,13 +316,13 @@
       if(sscanf(req->reqbuf, "CONNECT %" MAXDOCNAMELEN_TXT "s HTTP/%d.%d",
                 doc, &prot_major, &prot_minor) == 3) {
         sprintf(logbuf, "Received a CONNECT %s HTTP/%d.%d request",
                 doc, prot_major, prot_minor);
         logmsg("%s", logbuf);
 
-        if(prot_major*10+prot_minor == 10)
+        if(req->prot_version == 10)
           req->open = FALSE; /* HTTP 1.0 closes connection by default */
 
         if(!strncmp(doc, "bad", 3))
           /* if the host name starts with bad, we fake an error here */
           req->testno = DOCNUMBER_BADCONNECT;
         else if(!strncmp(doc, "test", 4)) {
@@ -424,12 +428,25 @@
     req->ntlm = TRUE; /* NTLM found */
     logmsg("Received NTLM type-1, sending back data %d", req->partno);
   }
   if(strstr(req->reqbuf, "Connection: close"))
     req->open = FALSE; /* close connection after this request */
 
+  if(!req->pipe &&
+     req->open &&
+     req->prot_version >= 11 &&
+     end &&
+     req->reqbuf + req->offset > end + strlen(END_OF_HEADERS) &&
+     (!strncmp(req->reqbuf, "GET", strlen("GET")) ||
+      !strncmp(req->reqbuf, "HEAD", strlen("HEAD")))) {
+    /* If we have a persistent connection, HTTP version >= 1.1
+       and GET/HEAD request, enable pipelining. */
+    req->checkindex = (end - req->reqbuf) + strlen(END_OF_HEADERS);
+    req->pipelining = TRUE;
+  }
+
   while(req->pipe) {
     /* scan for more header ends within this chunk */
     line = &req->reqbuf[req->checkindex];
     end = strstr(line, END_OF_HEADERS);
     if(!end)
       break;
@@ -509,25 +526,41 @@
 /* return 0 on success, non-zero on failure */
 static int get_request(curl_socket_t sock, struct httprequest *req)
 {
   int fail= FALSE;
   char *reqbuf = req->reqbuf;
 
+  char pipereq[REQBUFSIZ];
+  int pipereq_length;
+  if(req->pipelining) {
+    pipereq_length = req->offset - req->checkindex;
+    memcpy(pipereq, reqbuf + req->checkindex, pipereq_length);
+  }
+  else
+    pipereq_length = 0;
+
   /*** Init the httpreqest structure properly for the upcoming request ***/
   memset(req, 0, sizeof(struct httprequest));
 
   /* here's what should not be 0 from the start */
   req->testno = DOCNUMBER_NOTHING; /* safe default */
   req->open = TRUE; /* connection should remain open and wait for more
                        commands */
   req->pipe = 0;
 
   /*** end of httprequest init ***/
 
   while (req->offset < REQBUFSIZ) {
-    ssize_t got = sread(sock, reqbuf + req->offset, REQBUFSIZ - req->offset);
+    ssize_t got;
+    if(pipereq_length) {
+      memcpy(reqbuf, pipereq, pipereq_length);
+      got = pipereq_length;
+      pipereq_length = 0;
+    }
+    else
+      got = sread(sock, reqbuf + req->offset, REQBUFSIZ - req->offset);
     if (got <= 0) {
       if (got < 0) {
         logmsg("recv() returned error: %d", SOCKERRNO);
         return DOCNUMBER_INTERNAL;
       }
       logmsg("Connection closed by client");
@@ -560,13 +593,13 @@
     /* dump the request to an external file anyway */
   }
   else
     reqbuf[req->offset]=0;
 
   /* dump the request to an external file */
-  storerequest(reqbuf, req->offset);
+  storerequest(reqbuf, req->pipelining ? req->checkindex : req->offset);
 
   return fail; /* success */
 }
 
 /* returns -1 on failure */
 static int send_doc(curl_socket_t sock, struct httprequest *req)
@@ -965,12 +998,22 @@
     if (setsockopt(msgsock, IPPROTO_TCP, TCP_NODELAY,
                    (void *)&flag, sizeof(flag)) == -1) {
       logmsg("====> TCP_NODELAY failed");
     }
 #endif
 
+  /* full initialization for new request after connection */
+  memset(&req, 0, sizeof(req));
+  req.testno = DOCNUMBER_NOTHING;
+  req.open = TRUE;
+  req.auth_req = FALSE;
+  req.auth = FALSE;
+  req.digest = FALSE;
+  req.ntlm = FALSE;
+  req.pipelining = FALSE;
+
   do {
       if(get_request(msgsock, &req))
         /* non-zero means error, break out of loop */
         break;
 
       if(prevbounce) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/tftpd.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/tftpd.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/tftpd.c	2007-10-25 15:39:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/tftpd.c	2007-11-16 06:40:48.000000000 +0800
@@ -2,13 +2,13 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: tftpd.c,v 1.29 2007-10-24 22:48:23 danf Exp $
+ * $Id: tftpd.c,v 1.30 2007-11-15 13:20:18 yangtse Exp $
  *
  * Trivial file transfer protocol server.
  *
  * This code includes many modifications by Jim Guyton <guyton@rand-unix>
  *
  * This source file was started based on netkit-tftpd 0.17
@@ -617,13 +617,13 @@
     goto again;
   }
   /* store input protocol */
   fprintf(server, "filename: %s\n", filename);
 
   for (cp = mode; *cp; cp++)
-    if (isupper((int)*cp))
+    if(ISUPPER(*cp))
       *cp = (char)tolower((int)*cp);
 
   /* store input protocol */
   fprintf(server, "mode: %s\n", mode);
   fclose(server);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/tftp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/tftp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/tftp.h	2006-01-09 21:17:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/tftp.h	2007-11-10 21:16:23.000000000 +0800
@@ -4,29 +4,29 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2006, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: tftp.h,v 1.2 2006/01/09 13:17:14 bagder Exp $
+ * $Id: tftp.h,v 1.3 2007-11-08 16:32:31 yangtse Exp $
  ***************************************************************************/
 
-/* This file is a rewrite/clone of the arpa/telnet.h file for systems without
+/* This file is a rewrite/clone of the arpa/tftp.h file for systems without
    it. */
 
 #define	SEGSIZE 512 /* data segment size */
 
 #ifndef __GNUC__
 #define __attribute__(x)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/server/util.c	2007-07-13 00:57:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/server/util.c	2008-01-24 06:20:22.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _
  *  Project                     ___| | | |  _ \| |
  *                             / __| | | | |_) | |
  *                            | (__| |_| |  _ <| |___
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * This software is licensed as described in the file COPYING, which
  * you should have received as part of this distribution. The terms
  * are also available at http://curl.haxx.se/docs/copyright.html.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the COPYING file.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: util.c,v 1.17 2007-07-12 01:07:49 gknauf Exp $
+ * $Id: util.c,v 1.18 2008-01-22 14:52:54 yangtse Exp $
  ***************************************************************************/
 #include "setup.h" /* portability help from the lib directory */
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -44,12 +44,14 @@
 #endif
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_SYS_POLL_H
 #include <sys/poll.h>
+#elif defined(HAVE_POLL_H)
+#include <poll.h>
 #endif
 
 #define ENABLE_CURLX_PRINTF
 /* make the curlx header define all printf() functions to use the curlx_*
    versions instead */
 #include "curlx.h" /* from the private lib dir */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests: sshhelp.pm
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/sshserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/sshserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/sshserver.pl	2007-09-18 16:11:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/sshserver.pl	2008-01-28 06:52:22.000000000 +0800
@@ -1,257 +1,872 @@
-#/usr/bin/env perl
-# $Id: sshserver.pl,v 1.21 2007-09-17 21:39:34 danf Exp $
+#!/usr/bin/env perl
+#***************************************************************************
+#                                  _   _ ____  _
+#  Project                     ___| | | |  _ \| |
+#                             / __| | | | |_) | |
+#                            | (__| |_| |  _ <| |___
+#                             \___|\___/|_| \_\_____|
+#
+# Copyright (C) 1998 - 2008, Daniel Stenberg, <daniel@haxx.se>, et al.
+#
+# This software is licensed as described in the file COPYING, which
+# you should have received as part of this distribution. The terms
+# are also available at http://curl.haxx.se/docs/copyright.html.
+#
+# You may opt to use, copy, modify, merge, publish, distribute and/or sell
+# copies of the Software, and permit persons to whom the Software is
+# furnished to do so, under the terms of the COPYING file.
+#
+# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+# KIND, either express or implied.
+#
+# $Id: sshserver.pl,v 1.44 2008-01-27 02:35:20 yangtse Exp $
+#***************************************************************************
+
 # Starts sshd for use in the SCP, SFTP and SOCKS curl test harness tests.
-# Also creates the ssh configuration files (this could be moved to a
-# separate script).
+# Also creates the ssh configuration files needed for these tests.
 
 # Options:
-# -u user
+#
 # -v
-# target_port
+# -d
+# -u user
+# -l listen address
+# -p SCP/SFTP server port
+# -s SOCKS4/5 server port
 
 use strict;
-use File::Spec;
+#use warnings;
+use Cwd;
+
+#***************************************************************************
+# Variables and subs imported from sshhelp module
+#
+use sshhelp qw(
+    $sshdexe
+    $sshexe
+    $sftpexe
+    $sshkeygenexe
+    $sshdconfig
+    $sshconfig
+    $knownhosts
+    $sshdlog
+    $sshlog
+    $hstprvkeyf
+    $hstpubkeyf
+    $cliprvkeyf
+    $clipubkeyf
+    display_sshdconfig
+    display_sshconfig
+    display_sshdlog
+    display_sshlog
+    dump_array
+    find_sshd
+    find_ssh
+    find_sftp
+    find_sshkeygen
+    logmsg
+    sshversioninfo
+    );
+
+
+#***************************************************************************
+
+my $verbose = 0;              # set to 1 for debugging
+my $debugprotocol = 0;        # set to 1 for protocol debugging
+my $port = 8999;              # our default SCP/SFTP server port
+my $socksport = $port + 1;    # our default SOCKS4/5 server port
+my $listenaddr = '127.0.0.1'; # default address on which to listen
+my $path = getcwd();          # current working directory
+my $username = $ENV{USER};    # default user
+
+my $error;
+my @cfgarr;
+
+
+#***************************************************************************
+# Parse command line options
+#
+while(@ARGV) {
+    if($ARGV[0] eq '-v') {
+        $verbose = 1;
+    }
+    elsif($ARGV[0] eq '-d') {
+        $verbose = 1;
+        $debugprotocol = 1;
+    }
+    elsif($ARGV[0] eq '-u') {
+        $username = $ARGV[1];
+        shift @ARGV;
+    }
+    elsif($ARGV[0] eq '-l') {
+        $listenaddr = $ARGV[1];
+        shift @ARGV;
+    }
+    elsif($ARGV[0] eq '-p') {
+        if($ARGV[1] =~ /^(\d+)$/) {
+            $port = $1;
+        }
+        shift @ARGV;
+    }
+    elsif($ARGV[0] eq '-s') {
+        if($ARGV[1] =~ /^(\d+)$/) {
+            $socksport = $1;
+        }
+        shift @ARGV;
+    }
+    shift @ARGV;
+};
 
-my $verbose=0; # set to 1 for debugging
 
-my $port = 8999;        # just our default, weird enough
-my $listenaddr = "127.0.0.1"; # address on which to listen
+#***************************************************************************
+# Logging level for ssh server and client
+#
+my $loglevel = $debugprotocol?'DEBUG3':'DEBUG2';
 
-my $path = `pwd`;
-chomp $path;
 
-my $exeext;
-if ($^O eq 'MSWin32' || $^O eq 'cygwin' || $^O eq 'msys' || $^O eq 'dos' || $^O eq 'os2') {
-    $exeext = '.exe';
+#***************************************************************************
+# Validate username
+#
+if(!$username) {
+    $error = 'Will not run ssh server without a user name';
 }
+elsif($username eq 'root') {
+    $error = 'Will not run ssh server as root to mitigate security risks';
+}
+if($error) {
+    logmsg $error;
+    exit 1;
+}
+
 
-# Where to look for sftp-server
-my @sftppath=qw(/usr/lib/openssh /usr/libexec/openssh /usr/libexec /usr/local/libexec /opt/local/libexec /usr/lib/ssh /usr/libexec/ssh /usr/sbin /usr/lib /usr/lib/ssh/openssh /usr/lib64/ssh /usr/lib64/misc /usr/lib/misc);
+#***************************************************************************
+# Find out ssh daemon canonical file name
+#
+my $sshd = find_sshd();
+if(!$sshd) {
+    logmsg "cannot find $sshdexe";
+    exit 1;
+}
 
-my $username = $ENV{USER};
 
-# Find a file somewhere in the given path
-sub searchpath {
-  my $fn = $_[0] . $exeext;
-  shift;
-  my @path = @_;
-  foreach (@path) {
-      my $file = File::Spec->catfile($_, $fn);
-      if (-e $file) {
-          return $file;
-      }
-  }
+#***************************************************************************
+# Find out ssh daemon version info
+#
+my ($sshdid, $sshdvernum, $sshdverstr, $sshderror) = sshversioninfo($sshd);
+if(!$sshdid) {
+    # Not an OpenSSH or SunSSH ssh daemon
+    logmsg $sshderror if($verbose);
+    logmsg 'SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later';
+    exit 1;
+}
+logmsg "ssh server found $sshd is $sshdverstr" if($verbose);
+
+
+#***************************************************************************
+#  ssh daemon command line options we might use and version support
+#
+#  -e:  log stderr           : OpenSSH 2.9.0 and later
+#  -f:  sshd config file     : OpenSSH 1.2.1 and later
+#  -D:  no daemon forking    : OpenSSH 2.5.0 and later
+#  -o:  command-line option  : OpenSSH 3.1.0 and later
+#  -t:  test config file     : OpenSSH 2.9.9 and later
+#  -?:  sshd version info    : OpenSSH 1.2.1 and later
+#
+#  -e:  log stderr           : SunSSH 1.0.0 and later
+#  -f:  sshd config file     : SunSSH 1.0.0 and later
+#  -D:  no daemon forking    : SunSSH 1.0.0 and later
+#  -o:  command-line option  : SunSSH 1.0.0 and later
+#  -t:  test config file     : SunSSH 1.0.0 and later
+#  -?:  sshd version info    : SunSSH 1.0.0 and later
+
+
+#***************************************************************************
+# Verify minimum ssh daemon version
+#
+if((($sshdid =~ /OpenSSH/) && ($sshdvernum < 299)) ||
+   (($sshdid =~ /SunSSH/)  && ($sshdvernum < 100))) {
+    logmsg 'SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later';
+    exit 1;
 }
 
-# Parse options
-do {
-    if($ARGV[0] eq "-v") {
-        $verbose=1;
-    }
-    elsif($ARGV[0] eq "-u") {
-        $username=$ARGV[1];
-        shift @ARGV;
-    }
-    elsif($ARGV[0] eq "-l") {
-        $listenaddr=$ARGV[1];
-        shift @ARGV;
-    }
-    elsif($ARGV[0] =~ /^(\d+)$/) {
-        $port = $1;
-    }
-} while(shift @ARGV);
 
-my $conffile="curl_sshd_config";    # sshd configuration data
-my $conffile_ssh="curl_ssh_config";    # ssh configuration data
-my $knownhostsfile="curl_client_knownhosts";    # ssh knownhosts file
+#***************************************************************************
+# Find out sftp server plugin canonical file name
+#
+my $sftp = find_sftp();
+if(!$sftp) {
+    logmsg "cannot find $sftpexe";
+    exit 1;
+}
+logmsg "sftp server plugin found $sftp" if($verbose);
+
+
+#***************************************************************************
+# Find out ssh keygen canonical file name
+#
+my $sshkeygen = find_sshkeygen();
+if(!$sshkeygen) {
+    logmsg "cannot find $sshkeygenexe";
+    exit 1;
+}
+logmsg "ssh keygen found $sshkeygen" if($verbose);
 
-# Searching for sshd and sftp-server will be done first
-# in the PATH and afterwards in other common locations.
-my @spath;
-push(@spath, File::Spec->path()); 
-push(@spath, @sftppath); 
 
-# sshd insists on being called with an absolute path.
-my $sshd = searchpath("sshd", @spath);
-if (!$sshd) {
-    print "sshd$exeext not found\n";
+#***************************************************************************
+# Find out ssh client canonical file name
+#
+my $ssh = find_ssh();
+if(!$ssh) {
+    logmsg "cannot find $sshexe";
     exit 1;
 }
-if ($verbose) {
-    print STDERR "SSH server found at $sshd\n";
+
+
+#***************************************************************************
+# Find out ssh client version info
+#
+my ($sshid, $sshvernum, $sshverstr, $ssherror) = sshversioninfo($ssh);
+if(!$sshid) {
+    # Not an OpenSSH or SunSSH ssh client
+    logmsg $ssherror if($verbose);
+    logmsg 'SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later';
+    exit 1;
 }
+logmsg "ssh client found $ssh is $sshverstr" if($verbose);
+
 
-my $sftp = searchpath("sftp-server", @spath);
-if (!$sftp) {
-    print "Could not find sftp-server$exeext plugin\n";
+#***************************************************************************
+#  ssh client command line options we might use and version support
+#
+#  -D:  dynamic app port forwarding  : OpenSSH 2.9.9 and later
+#  -F:  ssh config file              : OpenSSH 2.9.9 and later
+#  -N:  no shell/command             : OpenSSH 2.1.0 and later
+#  -p:  connection port              : OpenSSH 1.2.1 and later
+#  -v:  verbose messages             : OpenSSH 1.2.1 and later
+# -vv:  increase verbosity           : OpenSSH 2.3.0 and later
+#  -V:  ssh version info             : OpenSSH 1.2.1 and later
+#
+#  -D:  dynamic app port forwarding  : SunSSH 1.0.0 and later
+#  -F:  ssh config file              : SunSSH 1.0.0 and later
+#  -N:  no shell/command             : SunSSH 1.0.0 and later
+#  -p:  connection port              : SunSSH 1.0.0 and later
+#  -v:  verbose messages             : SunSSH 1.0.0 and later
+# -vv:  increase verbosity           : SunSSH 1.0.0 and later
+#  -V:  ssh version info             : SunSSH 1.0.0 and later
+
+
+#***************************************************************************
+# Verify minimum ssh client version
+#
+if((($sshid =~ /OpenSSH/) && ($sshvernum < 299)) ||
+   (($sshid =~ /SunSSH/)  && ($sshvernum < 100))) {
+    logmsg 'SCP, SFTP and SOCKS tests require OpenSSH 2.9.9 or later';
     exit 1;
 }
-if ($verbose) {
-    print STDERR "SFTP server plugin found at $sftp\n";
+
+
+#***************************************************************************
+#  ssh keygen command line options we actually use and version support
+#
+#  -C:  identity comment : OpenSSH 1.2.1 and later
+#  -f:  key filename     : OpenSSH 1.2.1 and later
+#  -N:  new passphrase   : OpenSSH 1.2.1 and later
+#  -q:  quiet keygen     : OpenSSH 1.2.1 and later
+#  -t:  key type         : OpenSSH 2.5.0 and later
+#
+#  -C:  identity comment : SunSSH 1.0.0 and later
+#  -f:  key filename     : SunSSH 1.0.0 and later
+#  -N:  new passphrase   : SunSSH 1.0.0 and later
+#  -q:  quiet keygen     : SunSSH 1.0.0 and later
+#  -t:  key type         : SunSSH 1.0.0 and later
+
+
+#***************************************************************************
+# Generate host and client key files for curl's tests
+#
+if((! -e $hstprvkeyf) || (! -e $hstpubkeyf) ||
+   (! -e $cliprvkeyf) || (! -e $clipubkeyf)) {
+    # Make sure all files are gone so ssh-keygen doesn't complain
+    unlink($hstprvkeyf, $hstpubkeyf, $cliprvkeyf, $clipubkeyf);
+    logmsg 'generating host keys...' if($verbose);
+    if(system "$sshkeygen -q -t dsa -f $hstprvkeyf -C 'curl test server' -N ''") {
+        logmsg 'Could not generate host key';
+        exit 1;
+    }
+    logmsg 'generating client keys...' if($verbose);
+    if(system "$sshkeygen -q -t dsa -f $cliprvkeyf -C 'curl test client' -N ''") {
+        logmsg 'Could not generate client key';
+        exit 1;
+    }
 }
 
-if ($username eq "root") {
-    print "Will not run ssh daemon as root to mitigate security risks\n";
+
+#***************************************************************************
+#  ssh daemon configuration file options we might use and version support
+#
+#  AFSTokenPassing                  : OpenSSH 1.2.1 and later [1]
+#  AcceptEnv                        : OpenSSH 3.9.0 and later
+#  AddressFamily                    : OpenSSH 4.0.0 and later
+#  AllowGroups                      : OpenSSH 1.2.1 and later
+#  AllowTcpForwarding               : OpenSSH 2.3.0 and later
+#  AllowUsers                       : OpenSSH 1.2.1 and later
+#  AuthorizedKeysFile               : OpenSSH 2.9.9 and later
+#  Banner                           : OpenSSH 2.5.0 and later
+#  ChallengeResponseAuthentication  : OpenSSH 2.5.0 and later
+#  Ciphers                          : OpenSSH 2.1.0 and later [3]
+#  ClientAliveCountMax              : OpenSSH 2.9.0 and later
+#  ClientAliveInterval              : OpenSSH 2.9.0 and later
+#  Compression                      : OpenSSH 3.3.0 and later
+#  DenyGroups                       : OpenSSH 1.2.1 and later
+#  DenyUsers                        : OpenSSH 1.2.1 and later
+#  ForceCommand                     : OpenSSH 4.4.0 and later [3]
+#  GatewayPorts                     : OpenSSH 2.1.0 and later
+#  GSSAPIAuthentication             : OpenSSH 3.7.0 and later [1]
+#  GSSAPICleanupCredentials         : OpenSSH 3.8.0 and later [1]
+#  HostbasedAuthentication          : OpenSSH 2.9.0 and later
+#  HostbasedUsesNameFromPacketOnly  : OpenSSH 2.9.0 and later
+#  HostKey                          : OpenSSH 1.2.1 and later
+#  IgnoreRhosts                     : OpenSSH 1.2.1 and later
+#  IgnoreUserKnownHosts             : OpenSSH 1.2.1 and later
+#  KeepAlive                        : OpenSSH 1.2.1 and later
+#  KerberosAuthentication           : OpenSSH 1.2.1 and later [1]
+#  KerberosGetAFSToken              : OpenSSH 3.8.0 and later [1]
+#  KerberosOrLocalPasswd            : OpenSSH 1.2.1 and later [1]
+#  KerberosTgtPassing               : OpenSSH 1.2.1 and later [1]
+#  KerberosTicketCleanup            : OpenSSH 1.2.1 and later [1]
+#  KeyRegenerationInterval          : OpenSSH 1.2.1 and later
+#  ListenAddress                    : OpenSSH 1.2.1 and later
+#  LoginGraceTime                   : OpenSSH 1.2.1 and later
+#  LogLevel                         : OpenSSH 1.2.1 and later
+#  MACs                             : OpenSSH 2.5.0 and later [3]
+#  Match                            : OpenSSH 4.4.0 and later [3]
+#  MaxAuthTries                     : OpenSSH 3.9.0 and later
+#  MaxStartups                      : OpenSSH 2.2.0 and later
+#  PAMAuthenticationViaKbdInt
+#  PasswordAuthentication           : OpenSSH 1.2.1 and later
+#  PermitEmptyPasswords             : OpenSSH 1.2.1 and later
+#  PermitOpen                       : OpenSSH 4.4.0 and later [3]
+#  PermitRootLogin                  : OpenSSH 1.2.1 and later
+#  PermitTunnel                     : OpenSSH 4.3.0 and later
+#  PermitUserEnvironment            : OpenSSH 3.5.0 and later
+#  PidFile                          : OpenSSH 2.1.0 and later
+#  Port                             : OpenSSH 1.2.1 and later
+#  PrintLastLog                     : OpenSSH 2.9.0 and later
+#  PrintMotd                        : OpenSSH 1.2.1 and later
+#  Protocol                         : OpenSSH 2.1.0 and later
+#  PubkeyAuthentication             : OpenSSH 2.5.0 and later
+#  RhostsRSAAuthentication          : OpenSSH 1.2.1 and later
+#  RSAAuthentication                : OpenSSH 1.2.1 and later
+#  ServerKeyBits                    : OpenSSH 1.2.1 and later
+#  SkeyAuthentication               : OpenSSH 1.2.1 and later [1]
+#  StrictModes                      : OpenSSH 1.2.1 and later
+#  Subsystem                        : OpenSSH 2.2.0 and later
+#  SyslogFacility                   : OpenSSH 1.2.1 and later
+#  TCPKeepAlive                     : OpenSSH 3.8.0 and later
+#  UseDNS                           : OpenSSH 3.7.0 and later
+#  UseLogin                         : OpenSSH 1.2.1 and later
+#  UsePAM                           : OpenSSH 3.7.0 and later [1][2]
+#  UsePrivilegeSeparation           : OpenSSH 3.2.2 and later
+#  X11DisplayOffset                 : OpenSSH 1.2.1 and later [3]
+#  X11Forwarding                    : OpenSSH 1.2.1 and later
+#  X11UseLocalhost                  : OpenSSH 3.1.0 and later
+#  XAuthLocation                    : OpenSSH 2.1.1 and later [3]
+#
+#  [1] Option only available if activated at compile time
+#  [2] Option specific for portable versions
+#  [3] Option not used in our ssh server config file
+
+
+#***************************************************************************
+# Initialize sshd config with options actually supported in OpenSSH 2.9.9
+#
+logmsg 'generating ssh server config file...' if($verbose);
+@cfgarr = ();
+push @cfgarr, '# This is a generated file.  Do not edit.';
+push @cfgarr, "# $sshdverstr sshd configuration file for curl testing";
+push @cfgarr, '#';
+push @cfgarr, "DenyUsers !$username";
+push @cfgarr, "AllowUsers $username";
+push @cfgarr, 'DenyGroups';
+push @cfgarr, 'AllowGroups';
+push @cfgarr, '#';
+push @cfgarr, "AuthorizedKeysFile $path/$clipubkeyf";
+push @cfgarr, "HostKey $path/$hstprvkeyf";
+push @cfgarr, "PidFile $path/.ssh.pid";
+push @cfgarr, '#';
+push @cfgarr, "Port $port";
+push @cfgarr, "ListenAddress $listenaddr";
+push @cfgarr, 'Protocol 2';
+push @cfgarr, '#';
+push @cfgarr, 'AllowTcpForwarding yes';
+push @cfgarr, 'Banner none';
+push @cfgarr, 'ChallengeResponseAuthentication no';
+push @cfgarr, 'ClientAliveCountMax 3';
+push @cfgarr, 'ClientAliveInterval 0';
+push @cfgarr, 'GatewayPorts no';
+push @cfgarr, 'HostbasedAuthentication no';
+push @cfgarr, 'HostbasedUsesNameFromPacketOnly no';
+push @cfgarr, 'IgnoreRhosts yes';
+push @cfgarr, 'IgnoreUserKnownHosts yes';
+push @cfgarr, 'KeyRegenerationInterval 0';
+push @cfgarr, 'LoginGraceTime 30';
+push @cfgarr, "LogLevel $loglevel";
+push @cfgarr, 'MaxStartups 5';
+push @cfgarr, 'PasswordAuthentication no';
+push @cfgarr, 'PermitEmptyPasswords no';
+push @cfgarr, 'PermitRootLogin no';
+push @cfgarr, 'PrintLastLog no';
+push @cfgarr, 'PrintMotd no';
+push @cfgarr, 'PubkeyAuthentication yes';
+push @cfgarr, 'RhostsRSAAuthentication no';
+push @cfgarr, 'RSAAuthentication no';
+push @cfgarr, 'ServerKeyBits 768';
+push @cfgarr, 'StrictModes no';
+push @cfgarr, "Subsystem sftp $sftp";
+push @cfgarr, 'SyslogFacility AUTH';
+push @cfgarr, 'UseLogin no';
+push @cfgarr, 'X11Forwarding no';
+push @cfgarr, '#';
+
+
+#***************************************************************************
+# Write out initial sshd configuration file for curl's tests
+#
+$error = dump_array($sshdconfig, @cfgarr);
+if($error) {
+    logmsg $error;
     exit 1;
 }
 
-# Find out sshd version.
-my $tmpstr;
-my $ssh_daemon;
-my $ssh_ver_major;
-my $ssh_ver_minor;
-my $ssh_ver_patch;
-chomp($tmpstr = qx($sshd -V 2>&1 | grep OpenSSH));
-if ($tmpstr =~ /OpenSSH[_-](\d+)\.(\d+)(\.(\d+))*/) {
-    ($ssh_ver_major, $ssh_ver_minor, $ssh_ver_patch) = ($1, $2, $4);
-    $ssh_daemon = 'OpenSSH';
+
+#***************************************************************************
+# Verifies at run time if sshd supports a given configuration file option
+#
+sub sshd_supports_opt {
+    my ($option, $value) = @_;
+    my $err;
+    #
+    if((($sshdid =~ /OpenSSH/) && ($sshdvernum >= 310)) ||
+        ($sshdid =~ /SunSSH/)) {
+        # ssh daemon supports command line options -t -f and -o
+        $err = grep /((Unsupported)|(Bad configuration)|(Deprecated)) option.*$option/,
+                    qx($sshd -t -f $sshdconfig -o $option=$value 2>&1);
+        return !$err;
+    }
+    if(($sshdid =~ /OpenSSH/) && ($sshdvernum >= 299)) {
+        # ssh daemon supports command line options -t and -f
+        $err = dump_array($sshdconfig, (@cfgarr, "$option $value"));
+        if($err) {
+            logmsg $err;
+            return 0;
+        }
+        $err = grep /((Unsupported)|(Bad configuration)|(Deprecated)) option.*$option/,
+                    qx($sshd -t -f $sshdconfig 2>&1);
+        unlink $sshdconfig;
+        return !$err;
+    }
+    return 0;
+}
+
+
+#***************************************************************************
+# Kerberos Authentication support may have not been built into sshd
+#
+if(sshd_supports_opt('KerberosAuthentication','no')) {
+    push @cfgarr, 'KerberosAuthentication no';
+}
+if(sshd_supports_opt('KerberosGetAFSToken','no')) {
+    push @cfgarr, 'KerberosGetAFSToken no';
+}
+if(sshd_supports_opt('KerberosOrLocalPasswd','no')) {
+    push @cfgarr, 'KerberosOrLocalPasswd no';
 }
-if ($verbose) {
-    print STDERR "ssh_daemon: $ssh_daemon\n";
-    print STDERR "ssh_ver_major: $ssh_ver_major\n";
-    print STDERR "ssh_ver_minor: $ssh_ver_minor\n";
-    print STDERR "ssh_ver_patch: $ssh_ver_patch\n";
+if(sshd_supports_opt('KerberosTgtPassing','no')) {
+    push @cfgarr, 'KerberosTgtPassing no';
+}
+if(sshd_supports_opt('KerberosTicketCleanup','yes')) {
+    push @cfgarr, 'KerberosTicketCleanup yes';
+}
+
+
+#***************************************************************************
+# Andrew File System support may have not been built into sshd
+#
+if(sshd_supports_opt('AFSTokenPassing','no')) {
+    push @cfgarr, 'AFSTokenPassing no';
+}
+
+
+#***************************************************************************
+# S/Key authentication support may have not been built into sshd
+#
+if(sshd_supports_opt('SkeyAuthentication','no')) {
+    push @cfgarr, 'SkeyAuthentication no';
 }
 
-# Verify minimum OpenSSH version.
-if (($ssh_daemon !~ /OpenSSH/) || (10 * $ssh_ver_major + $ssh_ver_minor < 37)) {
-    print "SCP, SFTP and SOCKS tests require OpenSSH 3.7 or later\n";
+
+#***************************************************************************
+# GSSAPI Authentication support may have not been built into sshd
+#
+my $sshd_builtwith_GSSAPI;
+if(sshd_supports_opt('GSSAPIAuthentication','no')) {
+    push @cfgarr, 'GSSAPIAuthentication no';
+    $sshd_builtwith_GSSAPI = 1;
+}
+if(sshd_supports_opt('GSSAPICleanupCredentials','yes')) {
+    push @cfgarr, 'GSSAPICleanupCredentials yes';
+}
+push @cfgarr, '#';
+
+
+#***************************************************************************
+# Options that might be supported or not in sshd OpenSSH 2.9.9 and later
+#
+if(sshd_supports_opt('AcceptEnv','')) {
+    push @cfgarr, 'AcceptEnv';
+}
+if(sshd_supports_opt('AddressFamily','any')) {
+    # Address family must be specified before ListenAddress
+    splice @cfgarr, 13, 0, 'AddressFamily any';
+}
+if(sshd_supports_opt('Compression','no')) {
+    push @cfgarr, 'Compression no';
+}
+if(sshd_supports_opt('KeepAlive','no')) {
+    push @cfgarr, 'KeepAlive no';
+}
+if(sshd_supports_opt('MaxAuthTries','10')) {
+    push @cfgarr, 'MaxAuthTries 10';
+}
+if(sshd_supports_opt('PAMAuthenticationViaKbdInt','no')) {
+    push @cfgarr, 'PAMAuthenticationViaKbdInt no';
+}
+if(sshd_supports_opt('PermitTunnel','no')) {
+    push @cfgarr, 'PermitTunnel no';
+}
+if(sshd_supports_opt('PermitUserEnvironment','no')) {
+    push @cfgarr, 'PermitUserEnvironment no';
+}
+if(sshd_supports_opt('TCPKeepAlive','no')) {
+    push @cfgarr, 'TCPKeepAlive no';
+}
+if(sshd_supports_opt('UseDNS','no')) {
+    push @cfgarr, 'UseDNS no';
+}
+if(sshd_supports_opt('UsePAM','no')) {
+    push @cfgarr, 'UsePAM no';
+}
+if(sshd_supports_opt('UsePrivilegeSeparation','no')) {
+    push @cfgarr, 'UsePrivilegeSeparation no';
+}
+if(sshd_supports_opt('X11UseLocalhost','yes')) {
+    push @cfgarr, 'X11UseLocalhost yes';
+}
+push @cfgarr, '#';
+
+
+#***************************************************************************
+# Write out resulting sshd configuration file for curl's tests
+#
+$error = dump_array($sshdconfig, @cfgarr);
+if($error) {
+    logmsg $error;
     exit 1;
 }
 
-# Initialize sshd configuration file for curl's tests.
-open(CONF, ">$conffile") || die "Could not write $conffile";
-print CONF "# This is a generated file!  Do not edit!\n";
-print CONF "# OpenSSH sshd configuration file for curl testing\n";
-close CONF;
 
-# Support for some options might have not been built into sshd.  On some
-# platforms specifying an unsupported option prevents sshd from starting.
-# Check here for possible unsupported options, avoiding its use in sshd.
-sub sshd_supports_opt($) {
-    my ($option) = @_;
-    my $err = grep /Unsupported .* $option/, qx($sshd -t -f $conffile -o $option=no 2>&1);
-    return !$err;
+#***************************************************************************
+# Verify that sshd actually supports our generated configuration file
+#
+if(system "$sshd -t -f $sshdconfig > $sshdlog 2>&1") {
+    logmsg "sshd configuration file $sshdconfig failed verification";
+    display_sshdlog();
+    display_sshdconfig();
+    exit 1;
 }
 
-my $supports_UsePAM = sshd_supports_opt('UsePAM');
-my $supports_UseDNS = sshd_supports_opt('UseDNS');
-my $supports_ChReAu = sshd_supports_opt('ChallengeResponseAuthentication');
-if ($verbose) {
-    print STDERR "sshd supports UsePAM: ";
-    print STDERR $supports_UsePAM ? "yes\n" : "no\n";
-    print STDERR "sshd supports UseDNS: ";
-    print STDERR $supports_UseDNS ? "yes\n" : "no\n";
-    print STDERR "sshd supports ChallengeResponseAuthentication: ";
-    print STDERR $supports_ChReAu ? "yes\n" : "no\n";
+
+#***************************************************************************
+# Generate ssh client host key database file for curl's tests
+#
+if(! -e $knownhosts) {
+    logmsg 'generating ssh client known hosts file...' if($verbose);
+    if(open(DSAKEYFILE, "<$hstpubkeyf")) {
+        my @dsahostkey = do { local $/ = ' '; <DSAKEYFILE> };
+        if(close(DSAKEYFILE)) {
+            if(open(KNOWNHOSTS, ">$knownhosts")) {
+                print KNOWNHOSTS "$listenaddr ssh-dss $dsahostkey[1]\n";
+                if(!close(KNOWNHOSTS)) {
+                    $error = "Error: cannot close file $knownhosts";
+                }
+            }
+            else {
+                $error = "Error: cannot write file $knownhosts";
+            }
+        }
+        else {
+            $error = "Error: cannot close file $hstpubkeyf";
+        }
+    }
+    else {
+        $error = "Error: cannot read file $hstpubkeyf";
+    }
+    if($error) {
+        logmsg $error;
+        exit 1;
+    }
 }
 
-if (! -e "curl_client_key.pub") {
-    if ($verbose) {
-        print STDERR "Generating host and client keys...\n";
+
+#***************************************************************************
+#  ssh client configuration file options we might use and version support
+#
+#  AddressFamily                     : OpenSSH 3.7.0 and later
+#  BatchMode                         : OpenSSH 1.2.1 and later
+#  BindAddress                       : OpenSSH 2.9.9 and later
+#  ChallengeResponseAuthentication   : OpenSSH 2.5.0 and later
+#  CheckHostIP                       : OpenSSH 1.2.1 and later
+#  Cipher                            : OpenSSH 1.2.1 and later [3]
+#  Ciphers                           : OpenSSH 2.1.0 and later [3]
+#  ClearAllForwardings               : OpenSSH 2.9.9 and later
+#  Compression                       : OpenSSH 1.2.1 and later
+#  CompressionLevel                  : OpenSSH 1.2.1 and later [3]
+#  ConnectionAttempts                : OpenSSH 1.2.1 and later
+#  ConnectTimeout                    : OpenSSH 3.7.0 and later
+#  ControlMaster                     : OpenSSH 3.9.0 and later
+#  ControlPath                       : OpenSSH 3.9.0 and later
+#  DynamicForward                    : OpenSSH 2.9.0 and later
+#  EnableSSHKeysign                  : OpenSSH 3.6.0 and later
+#  EscapeChar                        : OpenSSH 1.2.1 and later [3]
+#  ExitOnForwardFailure              : OpenSSH 4.4.0 and later
+#  ForwardAgent                      : OpenSSH 1.2.1 and later
+#  ForwardX11                        : OpenSSH 1.2.1 and later
+#  ForwardX11Trusted                 : OpenSSH 3.8.0 and later
+#  GatewayPorts                      : OpenSSH 1.2.1 and later
+#  GlobalKnownHostsFile              : OpenSSH 1.2.1 and later
+#  GSSAPIAuthentication              : OpenSSH 3.7.0 and later [1]
+#  GSSAPIDelegateCredentials         : OpenSSH 3.7.0 and later [1]
+#  HashKnownHosts                    : OpenSSH 4.0.0 and later
+#  Host                              : OpenSSH 1.2.1 and later
+#  HostbasedAuthentication           : OpenSSH 2.9.0 and later
+#  HostKeyAlgorithms                 : OpenSSH 2.9.0 and later [3]
+#  HostKeyAlias                      : OpenSSH 2.5.0 and later [3]
+#  HostName                          : OpenSSH 1.2.1 and later
+#  IdentitiesOnly                    : OpenSSH 3.9.0 and later
+#  IdentityFile                      : OpenSSH 1.2.1 and later
+#  KeepAlive                         : OpenSSH 1.2.1 and later
+#  KbdInteractiveAuthentication      : OpenSSH 2.3.0 and later
+#  KbdInteractiveDevices             : OpenSSH 2.3.0 and later [3]
+#  LocalCommand                      : OpenSSH 4.3.0 and later [3]
+#  LocalForward                      : OpenSSH 1.2.1 and later [3]
+#  LogLevel                          : OpenSSH 1.2.1 and later
+#  MACs                              : OpenSSH 2.5.0 and later [3]
+#  NoHostAuthenticationForLocalhost  : OpenSSH 3.0.0 and later
+#  NumberOfPasswordPrompts           : OpenSSH 1.2.1 and later
+#  PasswordAuthentication            : OpenSSH 1.2.1 and later
+#  PermitLocalCommand                : OpenSSH 4.3.0 and later
+#  Port                              : OpenSSH 1.2.1 and later
+#  PreferredAuthentications          : OpenSSH 2.5.2 and later
+#  Protocol                          : OpenSSH 2.1.0 and later
+#  ProxyCommand                      : OpenSSH 1.2.1 and later [3]
+#  PubkeyAuthentication              : OpenSSH 2.5.0 and later
+#  RekeyLimit                        : OpenSSH 3.7.0 and later
+#  RemoteForward                     : OpenSSH 1.2.1 and later [3]
+#  RhostsRSAAuthentication           : OpenSSH 1.2.1 and later
+#  RSAAuthentication                 : OpenSSH 1.2.1 and later
+#  SendEnv                           : OpenSSH 3.9.0 and later
+#  ServerAliveCountMax               : OpenSSH 3.8.0 and later
+#  ServerAliveInterval               : OpenSSH 3.8.0 and later
+#  SmartcardDevice                   : OpenSSH 2.9.9 and later [1][3]
+#  StrictHostKeyChecking             : OpenSSH 1.2.1 and later
+#  TCPKeepAlive                      : OpenSSH 3.8.0 and later
+#  Tunnel                            : OpenSSH 4.3.0 and later
+#  TunnelDevice                      : OpenSSH 4.3.0 and later [3]
+#  UsePAM                            : OpenSSH 3.7.0 and later [1][2][3]
+#  UsePrivilegedPort                 : OpenSSH 1.2.1 and later
+#  User                              : OpenSSH 1.2.1 and later
+#  UserKnownHostsFile                : OpenSSH 1.2.1 and later
+#  VerifyHostKeyDNS                  : OpenSSH 3.8.0 and later
+#  XAuthLocation                     : OpenSSH 2.1.1 and later [3]
+#
+#  [1] Option only available if activated at compile time
+#  [2] Option specific for portable versions
+#  [3] Option not used in our ssh client config file
+
+
+#***************************************************************************
+# Initialize ssh config with options actually supported in OpenSSH 2.9.9
+#
+logmsg 'generating ssh client config file...' if($verbose);
+@cfgarr = ();
+push @cfgarr, '# This is a generated file.  Do not edit.';
+push @cfgarr, "# $sshverstr ssh client configuration file for curl testing";
+push @cfgarr, '#';
+push @cfgarr, 'Host *';
+push @cfgarr, '#';
+push @cfgarr, "Port $port";
+push @cfgarr, "HostName $listenaddr";
+push @cfgarr, "User $username";
+push @cfgarr, 'Protocol 2';
+push @cfgarr, '#';
+push @cfgarr, "BindAddress $listenaddr";
+push @cfgarr, "DynamicForward $socksport";
+push @cfgarr, '#';
+push @cfgarr, "IdentityFile $path/curl_client_key";
+push @cfgarr, "UserKnownHostsFile $path/$knownhosts";
+push @cfgarr, '#';
+push @cfgarr, 'BatchMode yes';
+push @cfgarr, 'ChallengeResponseAuthentication no';
+push @cfgarr, 'CheckHostIP no';
+push @cfgarr, 'ClearAllForwardings no';
+push @cfgarr, 'Compression no';
+push @cfgarr, 'ConnectionAttempts 3';
+push @cfgarr, 'ForwardAgent no';
+push @cfgarr, 'ForwardX11 no';
+push @cfgarr, 'GatewayPorts no';
+push @cfgarr, 'GlobalKnownHostsFile /dev/null';
+push @cfgarr, 'HostbasedAuthentication no';
+push @cfgarr, 'KbdInteractiveAuthentication no';
+push @cfgarr, "LogLevel $loglevel";
+push @cfgarr, 'NumberOfPasswordPrompts 0';
+push @cfgarr, 'PasswordAuthentication no';
+push @cfgarr, 'PreferredAuthentications publickey';
+push @cfgarr, 'PubkeyAuthentication yes';
+push @cfgarr, 'RhostsRSAAuthentication no';
+push @cfgarr, 'RSAAuthentication no';
+push @cfgarr, 'StrictHostKeyChecking yes';
+push @cfgarr, 'UsePrivilegedPort no';
+push @cfgarr, '#';
+
+
+#***************************************************************************
+# Options supported in ssh client newer than OpenSSH 2.9.9
+#
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 370)) {
+    push @cfgarr, 'AddressFamily any';
+}
+
+if((($sshid =~ /OpenSSH/) && ($sshvernum >= 370)) ||
+   (($sshid =~ /SunSSH/) && ($sshvernum >= 120))) {
+    push @cfgarr, 'ConnectTimeout 30';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 390)) {
+    push @cfgarr, 'ControlMaster no';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 420)) {
+    push @cfgarr, 'ControlPath none';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 360)) {
+    push @cfgarr, 'EnableSSHKeysign no';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 440)) {
+    push @cfgarr, 'ExitOnForwardFailure yes';
+}
+
+if((($sshid =~ /OpenSSH/) && ($sshvernum >= 380)) ||
+   (($sshid =~ /SunSSH/) && ($sshvernum >= 120))) {
+    push @cfgarr, 'ForwardX11Trusted no';
+}
+
+if(($sshd_builtwith_GSSAPI) && ($sshdid eq $sshid) &&
+   ($sshdvernum == $sshvernum)) {
+    push @cfgarr, 'GSSAPIAuthentication no';
+    push @cfgarr, 'GSSAPIDelegateCredentials no';
+    if($sshid =~ /SunSSH/) {
+        push @cfgarr, 'GSSAPIKeyExchange no';
     }
-    # Make sure all files are gone so ssh-keygen doesn't complain
-    unlink("curl_host_dsa_key", "curl_client_key","curl_host_dsa_key.pub", "curl_client_key.pub"); 
-    system "ssh-keygen -q -t dsa -f curl_host_dsa_key -C 'curl test server' -N ''" and die "Could not generate host key";
-    system "ssh-keygen -q -t dsa -f curl_client_key -C 'curl test client' -N ''" and die "Could not generate client key";
-}
-
-open(FILE, ">>$conffile") || die "Could not write $conffile";
-print FILE <<EOFSSHD
-AllowUsers $username
-DenyUsers
-DenyGroups
-AuthorizedKeysFile $path/curl_client_key.pub
-HostKey $path/curl_host_dsa_key
-PidFile $path/.ssh.pid
-Port $port
-ListenAddress $listenaddr
-Protocol 2
-AllowTcpForwarding yes
-GatewayPorts no
-HostbasedAuthentication no
-IgnoreRhosts yes
-IgnoreUserKnownHosts yes
-KeepAlive no
-PasswordAuthentication no
-PermitEmptyPasswords no
-PermitUserEnvironment no
-PermitRootLogin no
-PrintLastLog no
-PrintMotd no
-StrictModes no
-Subsystem sftp $sftp
-UseLogin no
-PrintLastLog no
-X11Forwarding no
-UsePrivilegeSeparation no
-# Newer OpenSSH options
-EOFSSHD
-;
-close FILE ||  die "Could not close $conffile";
-
-sub set_sshd_option {
-    my ($string) = @_;
-    if (open(FILE, ">>$conffile")) {
-        print FILE "$string\n";
-        close FILE;
-    }
-}
-
-if ($supports_UsePAM) {
-    set_sshd_option('UsePAM no');
-}
-if ($supports_UseDNS) {
-    set_sshd_option('UseDNS no');
-}
-if ($supports_ChReAu) {
-    set_sshd_option('ChallengeResponseAuthentication no');
-}
-
-
-# Now, set up some configuration files for the ssh client
-open(DSAKEYFILE, "<curl_host_dsa_key.pub") || die 'Could not read curl_host_dsa_key.pub';
-my @dsahostkey = do { local $/ = ' '; <DSAKEYFILE> };
-close DSAKEYFILE || die "Could not close DSAKEYFILE";
-
-open(KNOWNHOSTS, ">$knownhostsfile") || die "Could not write $knownhostsfile";
-print KNOWNHOSTS "[$listenaddr]:$port ssh-dss $dsahostkey[1]\n" || die 'Could not write to KNOWNHOSTS';
-close KNOWNHOSTS || die "Could not close KNOWNHOSTS";
-
-open(SSHFILE, ">$conffile_ssh") || die "Could not write $conffile_ssh";
-print SSHFILE <<EOFSSH
-IdentityFile $path/curl_client_key
-UserKnownHostsFile $path/$knownhostsfile
-StrictHostKeyChecking no
-Protocol 2
-BatchMode yes
-CheckHostIP no
-Compression no
-ConnectTimeout 20
-ForwardX11 no
-HostbasedAuthentication yes
-NoHostAuthenticationForLocalhost no
-# Newer OpenSSH options
-#SetupTimeOut 20
-EOFSSH
-;
-close SSHFILE ||  die "Could not close $conffile_ssh";
-
-
-if (system "$sshd -t -q -f $conffile") {
-    # This is likely due to missing support for UsePam
-    print "$sshd is too old and is not supported\n";
-    unlink $conffile;
-    exit 1;
-}
-
-# Start the server
-my $rc = system "$sshd -e -D -f $conffile > log/sshd.log 2>&1";
-$rc >>= 8;
-if($rc && $verbose) {
-    print STDERR "$sshd exited with $rc!\n";
 }
 
-unlink $conffile;
+if((($sshid =~ /OpenSSH/) && ($sshvernum >= 400)) ||
+   (($sshid =~ /SunSSH/) && ($sshvernum >= 120))) {
+    push @cfgarr, 'HashKnownHosts no';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 390)) {
+    push @cfgarr, 'IdentitiesOnly yes';
+}
+
+if((($sshid =~ /OpenSSH/) && ($sshvernum < 380)) ||
+    ($sshid =~ /SunSSH/)) {
+    push @cfgarr, 'KeepAlive no';
+}
+
+if((($sshid =~ /OpenSSH/) && ($sshvernum >= 300)) ||
+    ($sshid =~ /SunSSH/)) {
+    push @cfgarr, 'NoHostAuthenticationForLocalhost no';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 430)) {
+    push @cfgarr, 'PermitLocalCommand no';
+}
+
+if((($sshid =~ /OpenSSH/) && ($sshvernum >= 370)) ||
+   (($sshid =~ /SunSSH/) && ($sshvernum >= 120))) {
+    push @cfgarr, 'RekeyLimit 1G';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 390)) {
+    push @cfgarr, 'SendEnv';
+}
+
+if((($sshid =~ /OpenSSH/) && ($sshvernum >= 380)) ||
+   (($sshid =~ /SunSSH/) && ($sshvernum >= 120))) {
+    push @cfgarr, 'ServerAliveCountMax 3';
+    push @cfgarr, 'ServerAliveInterval 0';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 380)) {
+    push @cfgarr, 'TCPKeepAlive no';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 430)) {
+    push @cfgarr, 'Tunnel no';
+}
+
+if(($sshid =~ /OpenSSH/) && ($sshvernum >= 380)) {
+    push @cfgarr, 'VerifyHostKeyDNS no';
+}
+
+push @cfgarr, '#';
+
+
+#***************************************************************************
+# Write out resulting ssh client configuration file for curl's tests
+#
+$error = dump_array($sshconfig, @cfgarr);
+if($error) {
+    logmsg $error;
+    exit 1;
+}
+@cfgarr = ();
+
+
+#***************************************************************************
+# Start the ssh server daemon without forking it
+#
+my $rc = system "$sshd -e -D -f $sshdconfig > $sshdlog 2>&1";
+if($rc == -1) {
+    logmsg "$sshd failed with: $!";
+}
+elsif($rc & 127) {
+    logmsg sprintf("$sshd died with signal %d, and %s coredump",
+                   ($rc & 127), ($rc & 128)?'a':'no');
+}
+elsif($verbose && ($rc >> 8)) {
+    logmsg sprintf("$sshd exited with %d", $rc >> 8);
+}
+
+
+#***************************************************************************
+# Clean up once the server has stopped
+#
+unlink($hstprvkeyf, $hstpubkeyf, $cliprvkeyf, $clipubkeyf, $knownhosts);
+unlink($sshdconfig, $sshconfig);
+
 
-exit $rc;
+exit 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/testcurl.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/testcurl.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/testcurl.pl	2007-06-30 04:50:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/testcurl.pl	2007-12-21 05:23:03.000000000 +0800
@@ -16,13 +16,13 @@
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: testcurl.pl,v 1.53 2007-06-28 22:31:18 gknauf Exp $
+# $Id: testcurl.pl,v 1.54 2007-12-20 21:21:43 danf Exp $
 ###########################################################################
 
 ###########################
 #  What is This Script?
 ###########################
 
@@ -65,13 +65,13 @@
             $buildlogname $configurebuild $targetos $confsuffix $binext
             $libext);
 use vars qw($name $email $desc $confopts $runtestopts $setupfile $mktarball
             $nocvsup $nobuildconf $crosscompile $timestamp);
 
 # version of this script
-$version='$Revision: 1.53 $';
+$version='$Revision: 1.54 $';
 $fixed=0;
 
 # Determine if we're running from CVS or a canned copy of curl,
 # or if we got a specific target option or setup file option.
 $CURLDIR="curl";
 $CVS=1;
@@ -291,13 +291,13 @@
 logit "date = $timestamp";  # When the test build starts
 
 $str1066os = undef;
 
 # Make $pwd to become the path without newline. We'll use that in order to cut
 # off that path from all possible logs and error messages etc.
-$pwd = cwd();
+$pwd = getcwd();
 
 if (-d $CURLDIR) {
   if ($CVS && -d "$CURLDIR/CVS") {
     logit "$CURLDIR is verified to be a fine source dir";
     # remove the generated sources to force them to be re-generated each
     # time we run this test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/valgrind.pm /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/valgrind.pm
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.17.1/tests/valgrind.pm	2005-02-10 16:50:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.18.0/tests/valgrind.pm	2007-11-01 17:18:26.000000000 +0800
@@ -15,15 +15,17 @@
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the COPYING file.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: valgrind.pm,v 1.1 2005/02/10 08:50:33 bagder Exp $
+# $Id: valgrind.pm,v 1.2 2007-10-31 18:32:06 danf Exp $
 ###########################################################################
 
+use File::Basename;
+
 sub valgrindparse {
     my ($srcdir,     # the dir in which the runtests script resides
         $sslenabled,
         $file) = @_;
     my $leak;
     my $invalidread;
@@ -41,19 +43,19 @@
         if($bt) {
             # back trace parsing
             if($_ =~ /^==(\d+)== *(at|by) 0x([0-9A-F]+): (.*)/) {
                 my $w = $4;
                 if($w =~ /(.*) \(([^:]*):(\d+)/) {
                     my ($func, $source, $line)=($1, $2, $3);
-
-                    if(-f "$srcdir/../src/$source" ||
-                       -f "$srcdir/../lib/$source") {
+                    my $sourcename = basename($source);
+                    if(-f "$srcdir/../src/$sourcename" ||
+                       -f "$srcdir/../lib/$sourcename") {
                         # this is our source
  #                       print "$func() at $source:$line\n";
                         $us++;
-                    }
+                    } #else {print "Not our source: $func, $source, $line\n";}
                 }
             }
             else {
                 if($us) {
                     # the stack trace included source details about us
 
