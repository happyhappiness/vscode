diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/acconfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/acconfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/acconfig.h	2001-05-21 20:28:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/acconfig.h	2002-06-11 19:12:11.000000000 +0800
@@ -51,6 +51,37 @@
 
 /* Define this to your Entropy Gathering Daemon socket pathname */
 #undef EGD_SOCKET
 
 /* Define if you have a working OpenSSL installation */
 #undef OPENSSL_ENABLED
+
+/* Define the one correct non-blocking socket method below */
+#undef HAVE_FIONBIO
+#undef HAVE_IOCTLSOCKET
+#undef HAVE_IOCTLSOCKET_CASE
+#undef HAVE_O_NONBLOCK
+#undef HAVE_DISABLED_NONBLOCKING
+
+/* Define this to 'int' if in_addr_t is not an available typedefed type */
+#undef in_addr_t
+
+/* Define to disable DICT */
+#undef CURL_DISABLE_DICT
+
+/* Define to disable FILE */
+#undef CURL_DISABLE_FILE
+
+/* Define to disable FTP */
+#undef CURL_DISABLE_FTP
+
+/* Define to disable GOPHER */
+#undef CURL_DISABLE_GOPHER
+
+/* Define to disable HTTP */
+#undef CURL_DISABLE_HTTP
+
+/* Define to disable LDAP */
+#undef CURL_DISABLE_LDAP
+
+/* Define to disable TELNET */
+#undef CURL_DISABLE_TELNET
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/acinclude.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/acinclude.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/acinclude.m4	2001-08-20 14:51:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/acinclude.m4	2002-01-31 15:52:18.000000000 +0800
@@ -1,6 +1,110 @@
+dnl Check for how to set a socket to non-blocking state. There seems to exist
+dnl four known different ways, with the one used almost everywhere being POSIX
+dnl and XPG3, while the other different ways for different systems (old BSD,
+dnl Windows and Amiga).
+dnl
+dnl There are two known platforms (AIX 3.x and SunOS 4.1.x) where the
+dnl O_NONBLOCK define is found but does not work. This condition is attempted
+dnl to get caught in this script by using an excessive number of #ifdefs...
+dnl
+AC_DEFUN(CURL_CHECK_NONBLOCKING_SOCKET,
+[
+  AC_MSG_CHECKING([non-blocking sockets style])
+
+  AC_TRY_COMPILE([
+/* headers for O_NONBLOCK test */
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+],[
+/* try to compile O_NONBLOCK */
+
+#if defined(sun) || defined(__sun__) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+# if defined(__SVR4) || defined(__srv4__)
+#  define PLATFORM_SOLARIS
+# else
+#  define PLATFORM_SUNOS4
+# endif
+#endif
+#if (defined(_AIX) || defined(__xlC__)) && !defined(_AIX4)
+# define PLATFORM_AIX_V3
+#endif
+
+#if defined(PLATFORM_SUNOS4) || defined(PLATFORM_AIX_V3)
+#error "O_NONBLOCK does not work on this platform"
+#endif
+  int socket;
+  int flags = fcntl(socket, F_SETFL, flags | O_NONBLOCK);
+],[
+dnl the O_NONBLOCK test was fine
+nonblock="O_NONBLOCK"
+AC_DEFINE(HAVE_O_NONBLOCK)
+],[
+dnl the code was bad, try a different program now, test 2
+
+  AC_TRY_COMPILE([
+/* headers for FIONBIO test */
+#include <unistd.h>
+#include <stropts.h>
+],[
+/* FIONBIO source test */
+ int flags = ioctl(socket, FIONBIO, &flags);
+],[
+dnl FIONBIO test was good
+nonblock="FIONBIO"
+AC_DEFINE(HAVE_FIONBIO)
+],[
+dnl FIONBIO test was also bad
+dnl the code was bad, try a different program now, test 3
+
+  AC_TRY_COMPILE([
+/* headers for ioctlsocket test (cygwin?) */
+#include <windows.h>
+],[
+/* ioctlsocket source code */
+ int flags = ioctlsocket(socket, FIONBIO, &flags);
+],[
+dnl ioctlsocket test was good
+nonblock="ioctlsocket"
+AC_DEFINE(HAVE_IOCTLSOCKET)
+],[
+dnl ioctlsocket didnt compile!
+
+  AC_TRY_COMPILE([
+/* headers for IoctlSocket test (Amiga?) */
+#include <sys/ioctl.h>
+],[
+/* IoctlSocket source code */
+ int flags = IoctlSocket(socket, FIONBIO, (long)1);
+],[
+dnl ioctlsocket test was good
+nonblock="IoctlSocket"
+AC_DEFINE(HAVE_IOCTLSOCKET_CASE)
+],[
+dnl ioctlsocket didnt compile!
+nonblock="nada"
+AC_DEFINE(HAVE_DISABLED_NONBLOCKING)
+])
+dnl end of forth test
+
+])
+dnl end of third test
+
+])
+dnl end of second test
+
+])
+dnl end of non-blocking try-compile test
+  AC_MSG_RESULT($nonblock)
+
+  if test "$nonblock" = "nada"; then
+    AC_MSG_WARN([non-block sockets disabled])
+  fi
+])
+
 dnl Check for socklen_t: historically on BSD it is an int, and in
 dnl POSIX 1g it is a type of its own, but some platforms use different
 dnl types for the argument to getsockopt, getpeername, etc.  So we
 dnl have to test to find something that will work.
 AC_DEFUN([TYPE_SOCKLEN_T],
 [
@@ -36,12 +140,49 @@
       AC_DEFINE_UNQUOTED(socklen_t, $curl_cv_socklen_t_equiv,
 			[type to use in place of socklen_t if not defined])],
       [#include <sys/types.h>
 #include <sys/socket.h>])
 ])
 
+dnl Check for in_addr_t: it is used to receive the return code of inet_addr()
+dnl and a few other things. If not found, we set it to unsigned int, as even
+dnl 64-bit implementations use to set it to a 32-bit type.
+AC_DEFUN([TYPE_IN_ADDR_T],
+[
+   AC_CHECK_TYPE([in_addr_t], ,[
+      AC_MSG_CHECKING([for in_addr_t equivalent])
+      AC_CACHE_VAL([curl_cv_in_addr_t_equiv],
+      [
+         # Systems have either "struct sockaddr *" or
+         # "void *" as the second argument to getpeername
+         curl_cv_in_addr_t_equiv=
+         for t in int size_t unsigned long "unsigned long"; do
+            AC_TRY_COMPILE([
+               #include <sys/types.h>
+               #include <sys/socket.h>
+               #include <arpa/inet.h>
+            ],[
+               $t data = inet_addr ("1.2.3.4");
+            ],[
+               curl_cv_in_addr_t_equiv="$t"
+               break
+            ])
+         done
+
+         if test "x$curl_cv_in_addr_t_equiv" = x; then
+            AC_MSG_ERROR([Cannot find a type to use in place of in_addr_t])
+         fi
+      ])
+      AC_MSG_RESULT($curl_cv_in_addr_t_equiv)
+      AC_DEFINE_UNQUOTED(in_addr_t, $curl_cv_in_addr_t_equiv,
+			[type to use in place of in_addr_t if not defined])],
+      [#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>])
+])
+
 dnl ************************************************************
 dnl check for "localhost", if it doesn't exist, we can't do the
 dnl gethostbyname_r tests!
 dnl 
 
 AC_DEFUN(CURL_CHECK_WORKING_RESOLVER,[
@@ -226,88 +364,72 @@
 
 AC_DEFUN(CURL_CHECK_GETHOSTBYNAME_R,
 [
   dnl check for number of arguments to gethostbyname_r. it might take
   dnl either 3, 5, or 6 arguments.
   AC_CHECK_FUNCS(gethostbyname_r,[
-    AC_MSG_CHECKING(if gethostbyname_r takes 3 arguments)
-    AC_TRY_RUN([
+    AC_MSG_CHECKING([if gethostbyname_r takes 3 arguments])
+    AC_TRY_COMPILE([
 #include <string.h>
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
 int
-main () {
-struct hostent h;
-struct hostent_data hdata;
-char *name = "localhost";
-int rc;
-memset(&h, 0, sizeof(struct hostent));
-memset(&hdata, 0, sizeof(struct hostent_data));
-rc = gethostbyname_r(name, &h, &hdata);
-exit (rc != 0 ? 1 : 0); }],[
+gethostbyname_r(const char *, struct hostent *, struct hostent_data *);],[
+struct hostent_data data;
+gethostbyname_r(NULL, NULL, NULL);],[
       AC_MSG_RESULT(yes)
       AC_DEFINE(HAVE_GETHOSTBYNAME_R_3)
       ac_cv_gethostbyname_args=3],[
       AC_MSG_RESULT(no)
-      AC_MSG_CHECKING(if gethostbyname_r with -D_REENTRANT takes 3 arguments)
-      AC_TRY_RUN([
+      AC_MSG_CHECKING([if gethostbyname_r with -D_REENTRANT takes 3 arguments])
+      AC_TRY_COMPILE([
 #define _REENTRANT
 
 #include <string.h>
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
 int
-main () {
-struct hostent h;
-struct hostent_data hdata;
-char *name = "localhost";
-int rc;
-memset(&h, 0, sizeof(struct hostent));
-memset(&hdata, 0, sizeof(struct hostent_data));
-rc = gethostbyname_r(name, &h, &hdata);
-exit (rc != 0 ? 1 : 0); }],[
+gethostbyname_r(const char *,struct hostent *, struct hostent_data *);],[
+struct hostent_data data;
+gethostbyname_r(NULL, NULL, NULL);],[
 	AC_MSG_RESULT(yes)
 	AC_DEFINE(HAVE_GETHOSTBYNAME_R_3)
 	AC_DEFINE(NEED_REENTRANT)
 	ac_cv_gethostbyname_args=3],[
 	AC_MSG_RESULT(no)
-	AC_MSG_CHECKING(if gethostbyname_r takes 5 arguments)
-	AC_TRY_RUN([
+	AC_MSG_CHECKING([if gethostbyname_r takes 5 arguments])
+	AC_TRY_COMPILE([
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
-int
-main () {
-struct hostent *hp;
-struct hostent h;
-char *name = "localhost";
-char buffer[8192];
-int h_errno;
-hp = gethostbyname_r(name, &h, buffer, 8192, &h_errno);
-exit (hp == NULL ? 1 : 0); }],[
+struct hostent *
+gethostbyname_r(const char *, struct hostent *, char *, int, int *);],[
+gethostbyname_r(NULL, NULL, NULL, 0, NULL);],[
 	  AC_MSG_RESULT(yes)
 	  AC_DEFINE(HAVE_GETHOSTBYNAME_R_5)
           ac_cv_gethostbyname_args=5],[
 	  AC_MSG_RESULT(no)
-	  AC_MSG_CHECKING(if gethostbyname_r takes 6 arguments)
-	  AC_TRY_RUN([
+	  AC_MSG_CHECKING([if gethostbyname_r takes 6 arguments])
+	  AC_TRY_COMPILE([
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
 int
-main () {
-struct hostent h;
-struct hostent *hp;
-char *name = "localhost";
-char buf[8192];
-int rc;
-int h_errno;
-rc = gethostbyname_r(name, &h, buf, 8192, &hp, &h_errno);
-exit (rc != 0 ? 1 : 0); }],[
+gethostbyname_r(const char *, struct hostent *, char *, size_t,
+struct hostent **, int *);],[
+gethostbyname_r(NULL, NULL, NULL, 0, NULL, NULL);],[
 	    AC_MSG_RESULT(yes)
 	    AC_DEFINE(HAVE_GETHOSTBYNAME_R_6)
             ac_cv_gethostbyname_args=6],[
 	    AC_MSG_RESULT(no)
 	    have_missing_r_funcs="$have_missing_r_funcs gethostbyname_r"],
 	    [ac_cv_gethostbyname_args=0])],
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/aclocal.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/aclocal.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/aclocal.m4	2001-09-17 14:06:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/aclocal.m4	2002-06-11 23:16:30.000000000 +0800
@@ -8,12 +8,116 @@
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
+dnl Check for how to set a socket to non-blocking state. There seems to exist
+dnl four known different ways, with the one used almost everywhere being POSIX
+dnl and XPG3, while the other different ways for different systems (old BSD,
+dnl Windows and Amiga).
+dnl
+dnl There are two known platforms (AIX 3.x and SunOS 4.1.x) where the
+dnl O_NONBLOCK define is found but does not work. This condition is attempted
+dnl to get caught in this script by using an excessive number of #ifdefs...
+dnl
+AC_DEFUN(CURL_CHECK_NONBLOCKING_SOCKET,
+[
+  AC_MSG_CHECKING([non-blocking sockets style])
+
+  AC_TRY_COMPILE([
+/* headers for O_NONBLOCK test */
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+],[
+/* try to compile O_NONBLOCK */
+
+#if defined(sun) || defined(__sun__) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+# if defined(__SVR4) || defined(__srv4__)
+#  define PLATFORM_SOLARIS
+# else
+#  define PLATFORM_SUNOS4
+# endif
+#endif
+#if (defined(_AIX) || defined(__xlC__)) && !defined(_AIX4)
+# define PLATFORM_AIX_V3
+#endif
+
+#if defined(PLATFORM_SUNOS4) || defined(PLATFORM_AIX_V3)
+#error "O_NONBLOCK does not work on this platform"
+#endif
+  int socket;
+  int flags = fcntl(socket, F_SETFL, flags | O_NONBLOCK);
+],[
+dnl the O_NONBLOCK test was fine
+nonblock="O_NONBLOCK"
+AC_DEFINE(HAVE_O_NONBLOCK)
+],[
+dnl the code was bad, try a different program now, test 2
+
+  AC_TRY_COMPILE([
+/* headers for FIONBIO test */
+#include <unistd.h>
+#include <stropts.h>
+],[
+/* FIONBIO source test */
+ int flags = ioctl(socket, FIONBIO, &flags);
+],[
+dnl FIONBIO test was good
+nonblock="FIONBIO"
+AC_DEFINE(HAVE_FIONBIO)
+],[
+dnl FIONBIO test was also bad
+dnl the code was bad, try a different program now, test 3
+
+  AC_TRY_COMPILE([
+/* headers for ioctlsocket test (cygwin?) */
+#include <windows.h>
+],[
+/* ioctlsocket source code */
+ int flags = ioctlsocket(socket, FIONBIO, &flags);
+],[
+dnl ioctlsocket test was good
+nonblock="ioctlsocket"
+AC_DEFINE(HAVE_IOCTLSOCKET)
+],[
+dnl ioctlsocket didnt compile!
+
+  AC_TRY_COMPILE([
+/* headers for IoctlSocket test (Amiga?) */
+#include <sys/ioctl.h>
+],[
+/* IoctlSocket source code */
+ int flags = IoctlSocket(socket, FIONBIO, (long)1);
+],[
+dnl ioctlsocket test was good
+nonblock="IoctlSocket"
+AC_DEFINE(HAVE_IOCTLSOCKET_CASE)
+],[
+dnl ioctlsocket didnt compile!
+nonblock="nada"
+AC_DEFINE(HAVE_DISABLED_NONBLOCKING)
+])
+dnl end of forth test
+
+])
+dnl end of third test
+
+])
+dnl end of second test
+
+])
+dnl end of non-blocking try-compile test
+  AC_MSG_RESULT($nonblock)
+
+  if test "$nonblock" = "nada"; then
+    AC_MSG_WARN([non-block sockets disabled])
+  fi
+])
+
 dnl Check for socklen_t: historically on BSD it is an int, and in
 dnl POSIX 1g it is a type of its own, but some platforms use different
 dnl types for the argument to getsockopt, getpeername, etc.  So we
 dnl have to test to find something that will work.
 AC_DEFUN([TYPE_SOCKLEN_T],
 [
@@ -49,12 +153,49 @@
       AC_DEFINE_UNQUOTED(socklen_t, $curl_cv_socklen_t_equiv,
 			[type to use in place of socklen_t if not defined])],
       [#include <sys/types.h>
 #include <sys/socket.h>])
 ])
 
+dnl Check for in_addr_t: it is used to receive the return code of inet_addr()
+dnl and a few other things. If not found, we set it to unsigned int, as even
+dnl 64-bit implementations use to set it to a 32-bit type.
+AC_DEFUN([TYPE_IN_ADDR_T],
+[
+   AC_CHECK_TYPE([in_addr_t], ,[
+      AC_MSG_CHECKING([for in_addr_t equivalent])
+      AC_CACHE_VAL([curl_cv_in_addr_t_equiv],
+      [
+         # Systems have either "struct sockaddr *" or
+         # "void *" as the second argument to getpeername
+         curl_cv_in_addr_t_equiv=
+         for t in int size_t unsigned long "unsigned long"; do
+            AC_TRY_COMPILE([
+               #include <sys/types.h>
+               #include <sys/socket.h>
+               #include <arpa/inet.h>
+            ],[
+               $t data = inet_addr ("1.2.3.4");
+            ],[
+               curl_cv_in_addr_t_equiv="$t"
+               break
+            ])
+         done
+
+         if test "x$curl_cv_in_addr_t_equiv" = x; then
+            AC_MSG_ERROR([Cannot find a type to use in place of in_addr_t])
+         fi
+      ])
+      AC_MSG_RESULT($curl_cv_in_addr_t_equiv)
+      AC_DEFINE_UNQUOTED(in_addr_t, $curl_cv_in_addr_t_equiv,
+			[type to use in place of in_addr_t if not defined])],
+      [#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>])
+])
+
 dnl ************************************************************
 dnl check for "localhost", if it doesn't exist, we can't do the
 dnl gethostbyname_r tests!
 dnl 
 
 AC_DEFUN(CURL_CHECK_WORKING_RESOLVER,[
@@ -239,88 +377,72 @@
 
 AC_DEFUN(CURL_CHECK_GETHOSTBYNAME_R,
 [
   dnl check for number of arguments to gethostbyname_r. it might take
   dnl either 3, 5, or 6 arguments.
   AC_CHECK_FUNCS(gethostbyname_r,[
-    AC_MSG_CHECKING(if gethostbyname_r takes 3 arguments)
-    AC_TRY_RUN([
+    AC_MSG_CHECKING([if gethostbyname_r takes 3 arguments])
+    AC_TRY_COMPILE([
 #include <string.h>
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
 int
-main () {
-struct hostent h;
-struct hostent_data hdata;
-char *name = "localhost";
-int rc;
-memset(&h, 0, sizeof(struct hostent));
-memset(&hdata, 0, sizeof(struct hostent_data));
-rc = gethostbyname_r(name, &h, &hdata);
-exit (rc != 0 ? 1 : 0); }],[
+gethostbyname_r(const char *, struct hostent *, struct hostent_data *);],[
+struct hostent_data data;
+gethostbyname_r(NULL, NULL, NULL);],[
       AC_MSG_RESULT(yes)
       AC_DEFINE(HAVE_GETHOSTBYNAME_R_3)
       ac_cv_gethostbyname_args=3],[
       AC_MSG_RESULT(no)
-      AC_MSG_CHECKING(if gethostbyname_r with -D_REENTRANT takes 3 arguments)
-      AC_TRY_RUN([
+      AC_MSG_CHECKING([if gethostbyname_r with -D_REENTRANT takes 3 arguments])
+      AC_TRY_COMPILE([
 #define _REENTRANT
 
 #include <string.h>
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
 int
-main () {
-struct hostent h;
-struct hostent_data hdata;
-char *name = "localhost";
-int rc;
-memset(&h, 0, sizeof(struct hostent));
-memset(&hdata, 0, sizeof(struct hostent_data));
-rc = gethostbyname_r(name, &h, &hdata);
-exit (rc != 0 ? 1 : 0); }],[
+gethostbyname_r(const char *,struct hostent *, struct hostent_data *);],[
+struct hostent_data data;
+gethostbyname_r(NULL, NULL, NULL);],[
 	AC_MSG_RESULT(yes)
 	AC_DEFINE(HAVE_GETHOSTBYNAME_R_3)
 	AC_DEFINE(NEED_REENTRANT)
 	ac_cv_gethostbyname_args=3],[
 	AC_MSG_RESULT(no)
-	AC_MSG_CHECKING(if gethostbyname_r takes 5 arguments)
-	AC_TRY_RUN([
+	AC_MSG_CHECKING([if gethostbyname_r takes 5 arguments])
+	AC_TRY_COMPILE([
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
-int
-main () {
-struct hostent *hp;
-struct hostent h;
-char *name = "localhost";
-char buffer[8192];
-int h_errno;
-hp = gethostbyname_r(name, &h, buffer, 8192, &h_errno);
-exit (hp == NULL ? 1 : 0); }],[
+struct hostent *
+gethostbyname_r(const char *, struct hostent *, char *, int, int *);],[
+gethostbyname_r(NULL, NULL, NULL, 0, NULL);],[
 	  AC_MSG_RESULT(yes)
 	  AC_DEFINE(HAVE_GETHOSTBYNAME_R_5)
           ac_cv_gethostbyname_args=5],[
 	  AC_MSG_RESULT(no)
-	  AC_MSG_CHECKING(if gethostbyname_r takes 6 arguments)
-	  AC_TRY_RUN([
+	  AC_MSG_CHECKING([if gethostbyname_r takes 6 arguments])
+	  AC_TRY_COMPILE([
 #include <sys/types.h>
 #include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
 int
-main () {
-struct hostent h;
-struct hostent *hp;
-char *name = "localhost";
-char buf[8192];
-int rc;
-int h_errno;
-rc = gethostbyname_r(name, &h, buf, 8192, &hp, &h_errno);
-exit (rc != 0 ? 1 : 0); }],[
+gethostbyname_r(const char *, struct hostent *, char *, size_t,
+struct hostent **, int *);],[
+gethostbyname_r(NULL, NULL, NULL, 0, NULL, NULL);],[
 	    AC_MSG_RESULT(yes)
 	    AC_DEFINE(HAVE_GETHOSTBYNAME_R_6)
             ac_cv_gethostbyname_args=6],[
 	    AC_MSG_RESULT(no)
 	    have_missing_r_funcs="$have_missing_r_funcs gethostbyname_r"],
 	    [ac_cv_gethostbyname_args=0])],
Binary files /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/build_vms.com and /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/build_vms.com differ
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/CHANGES	2001-09-24 14:18:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/CHANGES	2002-06-13 22:29:50.000000000 +0800
@@ -3,1391 +3,945 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
                                History of Changes
 
-Daniel (23 September 2001)
-- Found and removed a 'socket leak' that would occur on IPv6 enabled hosts
-  when FTP RETR failed.
+Version 7.9.8
 
-- Made the FTP upload tests run fine on machines with IPv6 enabled.
+Daniel (13 Jun 2002)
+- Time to let this baby go.
 
-Version 7.9-pre8
-
-Daniel (19 September 2001)
-- Vojtech Minarik set up a special-purpose test server and provided me with
-  test certificates in order for me to repeat the bug reports #440068 and
-  #440373. It turned out we didn't check all the error codes properly. We do
-  now, and connecting with a unacceptable certificate will make libcurl fail
-  to connect with an error code returned.
-
-- Ramana Mokkapati found a case when the Location: following code did wrong.
-  I wrote a test case for this (45).
-
-Version 7.9-pre7
-
-Daniel (17 September 2001)
-- Linus Nielsen Feltzing fixed telnet for win32. It makes libcurl require
-  winsock 2.0.
-
-Version 7.9-pre6
-
-- libtool 1.4.2 is now in use!
-
-Version 7.9-pre5
-
-Daniel (14 September 2001)
-- Added another 14 ftp tests.
-
-Daniel (13 September 2001)
-- Added curl_easy_duphandle() to the easy.h header file. It has now been
-  tested and proved to work in a real-world tests by T Bharath. We still need
-  to write up some docs for this function.
-
-- Added four more ftp tests to the test suite.
-
-Daniel (12 September 2001)
-- CURLOPT_SSL_CIPHER_LIST was added, and the curl tool option is named
-  --ciphers. Use them to specify a list of ciphers to use in the SSL
-  connection.
-
-- T. Bharath found a memory leak in libcurl's windows version. It turned out
-  to be the new duphandle() that didn't quite work yet.
-
-Version 7.9-pre4
-
-Daniel (11 September 2001)
-- Added verbose output for SSL connections that output the server
-  certificate's start and expire dates. As suggested by Paul Harrington.
-
-- Heikki Korpela found problems in the perl ftp server used for the test
-  suite, when he runs on on OpenBSD with perl 5.6. Some changes have been
-  made, but nothing really certain.
-
-- T. Bharath has experienced problems with libcurl's stack usage on windows
-  and works on reducing it.
-
-Daniel (10 September 2001)
-- Cris Bailiff fixed the perl interface. It stopped working since the changed
-  behavior with WRITEHEADER and NULL pointers.
-
-- The "output cookies" function could dump core if no cookies were enabled.
-
-Daniel (7 September 2001)
-- SM pointed out that the SSL code didn't compile any longer if SSL was
-  disabled... Also, we needed to correct the #include for the utime stuff on
-  windows.
-
-Daniel (6 September 2001)
-- T. Bharath pointed out a flaw in the SSL session cache code that made it
-  sometimes read from a NULL pointer.
-
-Version 7.9-pre3
-
-Daniel (3 September 2001)
-- Added the -R/--remote-time option, that uses the remote file's datestamp to
-  set the local file's datestamp. Thus, when you get a remote file your local
-  file will get the same time and date. Note that this only works when you use
-  -o or -O.
-
-- Installed libtool 1.4.1, libtoolized and everything.
-
-Daniel (1 September 2001)
-- Heikki Korpela pointed out that I did not ship the proper libtool stuff in 
-  the pre-releases, even though that was my intention. libtoolize has now
-  been re-run.
-
-- Heikki also patched away the bad use of 'make -C' in the test suite
-  makefile. make -C is not very portable and is now banned from here.
-
-Version 7.9-pre2
-
-Daniel (31 August 2001)
-- I just made a huge internal struct rehaul, and all the big internally used
-  structs have been renamed, redesigned and stuff have been moved around a bit
-  to make the source easier to follow, more logically grouped and to hopefully
-  decrease future bugs. I also hope that this will make new functions to get
-  easier to add, and make it less likely that we have bugs left like the URL-
-  free bug from August 23.
-
-Version 7.9-pre1
-
-Daniel (29 August 2001)
-- The new cookie code have enabled the brand new '-c/--cookie-jar' option. Use
-  that to specify the file name in which you want to have all cookies curl
-  knows of, dumped to. It'll be written using the netscape cookie format.
-
-  This is internally done with the new CURLOPT_COOKIEJAR option to libcurl,
-  which in turn dumps this information when curl_easy_cleanup() is invoked.
-  There might be reasons to re-consider my choice of putting it there. Perhaps
-  it is better placed to get done just before *_perform() is done. It is all
-  of course depending on how you guys want to use this feature...
-
-- Added ftpupload.c in the source examples section, based on source code posted
-  by Erick Nuwendam.
-
-Daniel (28 August 2001)
-- Now running libtool CVS branch-1-4 to generate stuff. Should fix problems
-  on OpenBSD and hopefully on FreeBSD as well!
-
-- Georg Huettenegger modified the curl_formadd() functionality slightly, and
-  added support for error code 417 when doing form post and using the Expect:
-  header. Great work!
-
-- Made some tests with cached SSL session IDs, and they seem to work. There
-  should be a significant speed improvement in the SSL connection phase, but
-  in my tiny tests it just isn't possible to notice any difference. Like other
-  caching in libcurl, you must reuse the same handle for the caching to take
-  effect. SSL session ID caching is done on a per host-name and destination
-  port number basis.
-
-  Set verbose, and you'll get informational tests when libcurl detects and
-  uses a previous SSL session ID.
-
-- Upgraded to automake 1.5 on my development/release machine.
-
-Daniel (27 August 2001)
-- Slowly started writing SSL session ID caching code
-
-Daniel (24 August 2001)
-- T. Bharath removed compiler warnings on windows and updated the MS project
-  files.
-
-- Kevin Roth reported two kinds of command line constructs with the new -G that
-  curl didn't really deal with the way one would like.
-
-- Tim Costello patched away a use of strcasecmp() in the SSL code. We have our
-  own portable version named strequal() that should be used!
-
-- Tim also pointed out a problem in the lib/Makefile.vc6 file that made it mix
-  debug object modules causing confusions.
-
-Daniel (23 August 2001)
-- T. Bharath accurately found a libcurl bug that would happen when doing a
-  second invoke of curl_easy_perform() with a new URL when the previous invoke
-  followed a Location: header.
-
-- Started the improvement work on the cookie engine:
-  - Now keeps cookies in the same order as the cookie file
-  - A write to the possibly static string was removed
-  - Added a function that can output all cookies
-  - Now supports reading multiple cookie files
-
-- Steve Lhomme corrected a DLL naming issue in the MSVC++ project file.
-
-- Split up the monster function in lib/ftp.c to use more smallish functions to
-  increase readability and maintainability.
-
-Daniel (21 August 2001)
-- Georg Huettenegger's big patch was applied. Now we have:
-  o "Expect: 100-continue" support. We will from now on send that header in
-    all rfc1867-posts, as that makes us abort much faster when the server
-    rejects our POST. Posting without the Expect: header is still possible in
-    the standard replace-internal-header style.
-  o curl_formadd() is a new formpost building function that is introduced to
-    replace the now deprecated curl_formparse() function. The latter function
-    will still hang around for a while, but the curl_formadd() is the new way
-    and correct way to build form posts.
-  o Documentation has been updated to reflect these changes
-
-  These changes are reason enough to name the next curl release 7.9...
-
-- We now convert man pages to HTML pages and include them in the release
-  archive. For the pleasure of everyone without nroff within reach.
-
-- Andrés García's suggested flushing of the progress meter output stream was
-  added. It should make the progress meter look better on Windows.
-
-- Troy Engel pointed out a mistake in the configure script that made it fail
-  on many Red Hat boxes!
-
-Daniel (20 August 2001)
-- We need an updated libtool to make a better build environment for OpenBSD
-  as well as FreeBSD
-
-Version 7.8.1
-
-Daniel (20 August 2001)
-- Brad pointed out that we ship two extra libtool files in the tarballs that
-  we really don't need to! Removing them makes the gz-archive about 60K
-  smaller!
-
-- Albert Chin brought fixes for the configure script to detect socklen_t
-  properly as well as moving lots of our custom autoconf macros to
-  acinclude.m4.
-
-Daniel (19 August 2001)
-- Moonesamy improved his -G feature for host names only URLs...
-
-Daniel (17 August 2001)
-- Finally cleaned up the kerberos code to use Curl_ prefixes on all global
-  symbols and to not use global variables.
-
-Version 7.8.1-pre6
-
-Daniel (16 August 2001)
-- S. Moonesamy added the -G option to curl, that converts the data specified
-  with -d to a GET request. Default action when using -d is POST. When -G is
-  used, the -d specified data will be appended to the URL with a '?'
-  separator. As suggested previously by Kevin Roth.
-
-- curl-config --libs should now display all linker options required to link
-  with libcurl. It includes the path and options for libcurl itself.
-  curl-config --cflags displays the compiler option(s) needed to compile
-  source files that use libcurl functions. Basically, that sets the include
-  path correct.
-
-Daniel (15 August 2001)
-- Arkadiusz Miskiewicz pointed out a mistake in how IPv6-style IP-addresses
-  were parsed and used. (RFC2732-format)
-
-- Bug #12733 over on php.net identified a problem in libcurl that made it core
-  dump if you used CURLOPT_POST without setting any data to post with
-  CURLOPT_POSTFIELDS! This is no longer the case. Not using CURLOPT_POSTFIELDS
-  now equals setting it to no data at all.
-
-- Ramana Mokkapati reported that curl with '-w %{http_code}' didn't work
-  properly when used for multiple URLs on a single command line. Indeed, the
-  variable was not reset between the requests. This is now fixed.
-
-- David James fixed the Borland makefile so that libcurl still compiles and
-  builds with that compiler.
-
-Daniel (14 August 2001)
-- Oops. I ruined Nico's socklen_t define in config-vms.h, corrected it now.
-
-- An older item not mentioned here before: CURL_GLOBAL_WIN32 is a define for
-  windows users to curl_global_init(), that makes libcurl init the winsock
-  stuff. If libcurl is all socket stuff you do, then allowing it to fiddle
-  with this is a comfortable shortcut to fame.
-
-Version 7.8.1-pre5
-
-Daniel (14 August 2001)
-- Nico Baggus provided more feedback from his VMS porting efforts and a few
-  minor changes were necessary.
-
-- I modified configure.in so that --enable-debug sets more picky gcc options.
-  I then removed almost all the new warnings that appeared, and by doing so I
-  corrected the size_t-treated-as-signed problem that has been discussed on
-  the mailing list previously. I also removed a bunch of the just recently
-  added #ifdef VMS lines.
-
-- I removed the use of a global variable in the SSL code. It was once
-  necessary but hasn't been needed since OpenSSL 0.9.4. The old code should
-  (hopefully) still work if libcurl is built against an ancient version of
-  OpenSSL.
-
-Daniel (13 August 2001)
-- Peter Todd posted a patch that now allows non-file rc1867-style form posts
-  to be larger than 4K.
-
-Daniel (10 August 2001)
-- S. Moonesamy fixed bugs for building debug and SSL lib in VC makefile
-
-Daniel (9 August 2001)
-- The redirected error stream was closed before the curl_easy_cleanup() call
-  was made, and when VERBOSE was enabled, the cleanup function tried to use
-  the stream. It could lead to a segmentation fault. Also, the stream was
-  closed even if we looped to get more files.  Corrects Dustin Boswell's bug
-  report #441610
-
-- Now generates the release configure script with autoconf 2.52
-
-Version 7.8.1-pre4
-
-Daniel (8 August 2001)
-- curl -E uses a colon to separate a file name from a passphrase. This turned
-  out really bad for the windows people who wants to include a drive letter in
-  the file name like "c:\cert.pem". There's now a win32 work-around
-  implemented that tries work around that, when the colon seems to be used for
-  this kind of construct.
-
-- Patrick Bihan-Faou introduced CURLOPT_SSL_VERIFYHOST, which makes curl
-  verify the server's CN field when talking https://. If --cacert is not used,
-  any failures in matching is only displayed as information (-v).
-
-Daniel (7 August 2001)
-- Wrote up nine more test cases, more or less converted from the former test
-  suite.
-
-Daniel (6 August 2001)
-- Heikki Korpela posted a patch that makes 'curl-config --libs' include the
-  directory in which libcurl itself is installed in. While this wasn't my
-  initial intention with this option, it makes sense and makes linking with
-  libcurl easier.
-
-- Stefan Ulrich pointed out to us that other tools and libraries treat file://
-  URLs with only one slash after the host name slighly different than libcurl
-  does. Since all the others seem to agree, we better follow them.
-
-- Nico Baggus provided us with a huge set of fixes to make curl compile and
-  build under OpenVMS.
-
-Version 7.8.1-pre3
-
-Daniel (6 August 2001)
-- Jonathan Hseu noticed that you couldn't get a header callback unless you
-  set CURLOPT_WRITEHEADER to non-NULL, even if you didn't care about that
-  data. This is now fixed.
-
-Daniel (5 August 2001)
-- Sergio Ballestrero provided a patch for reading responses from NCSA httpd
-  1.5.x servers, as they return really screwed up response headers when asked
-  for with HTTP 1.1.
-
-- curl_escape() no longer treats already encoded characters in the input
-  string especially.
-
-Daniel (3 August 2001)
-- I replaced the former lib/arpa_telnet.h file with one I wrote myself, to
-  avoid the BSD annoucement clause of the license in the former file.
-
-- Andrew Francis provided a new version of base64.c to work around the license
-  boiler plate that came with the previous one. I patched it, but the glory
-  should go to Andrew for his heads up.
-
-- Tomasz Lacki noticed that when you do repeated transfers with libcurl you
-  couldn't always reliably change HTTP request. This has now been fixed and a
-  new libcurl option was added: CURLOPT_HTTPGET, that can force the HTTP
-  requestr (back) to GET.
-
-- Linus Nielsen Feltzing pointed out that httpsserver.pl wasn't included in
-  release archives. It should be now.
-
-Daniel (2 August 2001)
-- Frank Keeney pointed out a manual mistake for certificate convertions.
-
-- Tomasz Lacki pointed out a problem in the transfer loop that could make the
-  select() loop use far too much CPU.
-
-- Pawel A. Gajda pointed out an output mistake done when using libcurl's
-  progress callback.
-
-Daniel (29 June 2001)
-- Naveen Noel noticed that the Borland library makefile wasn't updated.
-
-- Nic Roets brought a fix for the certificate verification when using SSL.
-
-Daniel (27 June 2001)
-- Made the FTP tests run OK even on machines running curl IPv6-enabled.
-
-- Troy Engel corrected some RPM package details.
-
-Version 7.8.1-pre2
-
-Daniel (25 June 2001)
-- Björn Stenberg correctly identified a problem that occurred when downloading
-  several files with curl, and using resume. The first file's resume index was
-  then used for all files, resulting in weird results...
-
-- Anton Kalmykov provided a fix that makes curl work with form field names
-  with spaces like when -F is used.
-
-Version 7.8.1-pre1
-
-Daniel (20 June 2001)
-- Mike Bytnar provided a fine report that proved that the --with-ssl option
-  for configure needed tweaking. It no longer searches the default directories
-  for OpenSSL libs or directories when a specified path is given.
-
-Daniel (19 June 2001)
-- When an FTP transfer is cut off during transfer, curl could present a truly
-  garbaged error message and in worst case dump core. Thanks to detailed
-  reports from Shawn Poulson we nailed this.
-
-Daniel (12 June 2001)
-- Salvador Dávila provided a fix for FTP range downloads.
-
-- Added a few more test cases from the former test suite to the new file
-  format. We're now at a total of 26 tests.
-
-Daniel (11 June 2001)
-- libcurl's version-info was wrong, as noted by both Domenico Andreoli and
-  David Odin.
+Daniel (12 Jun 2002)
+- Chris Combes added three new options for curl_formadd(): CURLFORM_BUFFER,
+  CURLFORM_BUFFERPTR, CURLFORM_BUFFERLENGTH.  They are used to create a
+  multipart that appears as a regular file upload, but the data is provided
+  with a pointer and length.
+  
+- Nico Baggus made the VMS version use sigsetjmp() too.
 
-Daniel (7 June 2001)
-- Jörn fixed the curl_unescape duplicate entry in lib/libcurl.def
+- Jörn Hartroth fixed the mingw32 build using the mm lib.
 
-- I made SSL certificate failure messages to be more detailed.
+- Applied patches by Kris Kennaway that correct format string problems in
+  lib/ftp.c and lib/ldap.c.
 
-Version 7.8
+Version 7.9.8-pre3
 
-Daniel (7 June 2001)
-- SDavila provided a resumed download fix.
+Daniel (11 Jun 2002)
+- James Cone brought the idea of using sigsetjmp() in the signal handler to
+  make the time-out of name lookups to work, even when the underlying name
+  resolver library traps EINTR. The use of sigsetjmp() and siglongjmp() for
+  this may be a bit drastic, and also not likely to exist on all platforms.  I
+  added careful checking for this in the configure script, even checks for it
+  being a macro (which seems to be the case in for example Linux).
 
-Version 7.8-pre4
+  sigsetjmp() seems to be mentioned in the Single Unix specification.
 
-Daniel (1 June 2001)
-- Sterling provided some new PHP examples.
+- Miklos Nemeth brought a patch that allows libcurl to get built with specific
+  protocols disabled. This is done by running ./configure
+  --disable-[protocol].
 
-- Changed the CVS hierarchy and the older checkout instruction does no longer
-  work. We moved the entire source code into a CVS module named 'curl'.
+- FTP range downloads could make CURLE_FTP_WRITE_ERROR get returned. We now
+  make precautions to not return this for range downloads.
 
-Daniel (31 May 2001)
-- CURLOPT_MUTE does not exist anymore. It is still present in the include file
-  to not cause compiler errors for applications using it, but it isn't used
-  anywhere in the library.
+  Added test case 135 that makes an ftp range download. Had to tweak the
+  runtests.pl script a bit too.
 
-Version 7.8-pre3
+- Bug report #566835 identified a strlen() on a NULL pointer. Added additional
+  check to prevent this.
 
-Daniel (31 May 2001)
-- Once and for all fixed the _REENTRANT mess for Solaris compiles to present
-  less warnings.
+Daniel (10 Jun 2002)
+- Found and corrected a connect failure problem that didn't create a human
+  error text.
 
-- Sterling Hughes tirelessly points out and corrects my mistakes...! So,
-  curl_global_init() now lets the argument flags *SET* what parts to
-  init. CURL_GLOBAL_DEFAULT makes a nice default, CURL_GLOBAL_ALL inits all
-  known subsystems and CURL_GLOBAL_NONE inits nothing more than absolutely
-  necessary. Man page updated accordingly.
+- Added code to compile with OpenSSL 0.9.7. Based on patch from Jacob Meuser
+  and comments from Götz Babin-Ebell.
 
-- Fixed the strtok.h include file as it wouldn't compile on all platforms!
+- Gautam Mani found a socket descriptor leak that happened when FTP transfers
+  failed and you reinvoked curl_easy_perform().
 
-Daniel (30 May 2001)
-- Made libcurl by default act as if CURLOPT_MUTE and CURLOPT_NOPROGRESS were
-  set TRUE. Set them to FALSE to make libcurl more talkative. The *_MUTE
-  option is subject for complete removal...
+Daniel (5 Jun 2002)
+- Gustaf Hui corrected curl_multi_remove_handle() so that it won't crash no
+  matter when you decide to remove the CURL handle.
 
-Version 7.8-pre2
+- HAVE_RAND_STATUS was added to lib/config-win32.h by Andreas Olsson, as it
+  makes windows builds stop complaining about "weak seeding" when it in fact
+  isn't.
 
-Daniel (30 May 2001)
-- Cris Bailiff wrote a makefile for building Solaris packages.
+- Another 64bit architecture crash that was introduced in 7.9.7 was now
+  removed, as bug report #564585 clarified. This happened due to our attempts
+  to only allocate only as much memory as is actually needed for name
+  resolving (using realloc) which called for a function that could 'move' a
+  hostent struct in memory.
 
-- Sterling Hughes brought fixes for 'buildconf' (the build-from-CVS tool) and
-  we discussed and added a few CURL_GLOBAL_* flags in include/curl.h
+Version 7.9.8-pre2
 
-- Kjetil Jacobsen privately announced his python interface to libcurl,
-  available at http://pycurl.sourceforge.net/
+Daniel (3 Jun 2002)
+- T. Bharath fixed the CURLINFO_REDIRECT_TIME to return a correct time and
+  made the CURLINFO_REQUEST_SIZE return the correct total request size. He
+  also made the win32 timers use higher resolution than before.
 
-Daniel (29 May 2001)
-- Sterling Hughes fixed a strtok() problem in libcurl. It is not a thread-
-  safe function. Now configure checks for a thread-safe version, and
-  lib/strtok.c offers one for the systems that don't come with one included!
+Daniel (29 May 2002)
+- Renaud Chaillat made me aware of the fact that libcurl returned an error if
+  you tried to get an empty FTP file. This seemed like a wrong thing to do, so
+  now it no longer does that! I just hope that no one built anything fancy
+  upon this unexpected behavior...
 
-- Mettgut Jamalla correctly pointed out that the -# progress bar was written
-  to stderr even though --stderr redirection was used. This is now corrected.
+Daniel (28 May 2002)
+- Cris Bailiff brought CURLOPT_CAPATH that works like CURLOPT_CAINFO but
+  specifies a path to a directory with certificates rather than a single file
+  with them all concatenated. --capath was added to the command line tool
+  for the same function.
 
-- I moved out the list of contributors from the curl.1 man page and made a
-  separate docs/THANKS file. It makes the list easier to find, and made it
-  easier for me to make a separate web page with that same information.
+  Windows users need to pay attention that the directory should be setup with
+  the c_rehash tool of the OpenSSL package, and that creates symlinks by
+  default that need to be replaced with actual copies to work on Windows.
 
-  I really do want all you guys mentioned in there to feel you get the credit
-  you deserve.
+- Gustaf Hui provided new code that changes how curl_multi_info_read()
+  messages are stored, so that they don't have to be kept around for the multi
+  handle's entire life time. He also made it return failure codes properly
+  which it didn't do before.
 
-- lib/easy.c didn't compile properly in the 7.8-pre1 due to a silly mistake
+Daniel (27 May 2002)
+- Gustaf Hui pointed out that running curl_multi_perform() without doing
+  curl_multi_fdset() first was not really a working combo. I added an internal
+  check for this and have some extra select() code without timeout to make the
+  library internals work identically nevertheless. We might need to somehow
+  either document that once you've used the *_fdset() you should remain using
+  them in select() or you should blank them somehow so that libcurl won't go
+  crazy.
 
-Version 7.8-pre1
+Version 7.9.8-pre1
 
-Daniel (28 May 2001)
-- curl-config now supports '--vernum' that outputs a plain hexadecimal version
-  of the libcurl version number (using 8 bits for each 3 numbers). Version
-  7.7.4 appears as 070704
+Daniel (22 May 2002)
+- James Cone brought an excellent patch, including several tests and docs!
+  CURLOPT_NETRC now takes an enum as argument instead of the previous boolean.
+  --netrc-optional was introduced as an addition to --netrc to allow the
+  command line client to take use of all that new netrc stuff.
 
-- Wrote man pages for curl_global_init and curl_global_cleanup...
+- Bug report #558888 showed a case where libcurl re-used the previous host
+  name when a connection over a proxy was re-used but to a different target
+  host.
 
-- T. Bharath brought news about the usage of the OpenSSL interface that was
-  not previously taken into consideration and thus caused libcurl to leak
-  memory.  The only somewhat sane approach to fix this dilemma, is adding two
-  two new functions curl_global_init() and curl_global_cleanup() that should
-  be called *ONCE* by the application using libcurl. The init should be done
-  only at startup, no matter how many threads the application is gonna use,
-  and the cleanup should be called when the application has finished using
-  libcurl completely.
+Daniel (21 May 2002)
+- Edin Kadribasic helped me sort out a problem to made libcurl crash when
+  trying to HTTP POST an empty string.
 
-  *** UPGRADE NOTICE ***
+- Clarified that Juergen Wilke donated the original tests/server/sws.c code.
 
-  If you write applications using libcurl, you really want to use the two
-  functions mentioned above !!!
+- Jean-Philippe Barrette-LaPierre made curl_formadd() return a typedef named
+  CURLFORMcode instead of the previous 'int', and the various return codes are
+  now globally exported. It allows applications to better figure out what goes
+  wrong when curl_formadd() returns errors.
 
-  I can't say I think this is a very beautiful solution, but as OpenSSL
-  insists on making lots of stuff on a "global" scope, we're forced to walk
-  the path they point us to.
+Daniel (20 May 2002)
+- Roland Zimmermann pointed out that SSL_CTX_use_certificate_chain_file()
+  is prefered to SSL_CTX_use_certificate_file().
 
-- Moving more test cases into the new file format.
+Daniel (17 May 2002)
+- Bug report #556869 pointed out that src/writeout.c didn't compile on freebsd
+  after my AIX fixes the other week.
 
-Version 7.7.4-pre3
+- Bug report #556930 pointed out a FreeBSD core dump introduced in 7.9.7 in
+  the DNS struct realloc stuff. Actually, this crash could happen on all
+  systems that made the pack_hostent() function get invoked.
 
-Daniel (23 May 2001)
-- Introduced a new file format for storing test cases, and thus I had to
-  modify all the perl test scripts and more (I added a new one). I have not
-  "ported" all the old test cases to the new format yet, but it'll come.
+- I removed several compiler warnings in the test suite's HTTP server.
 
-  The main advantage of this new format is that all test data for each test
-  case is stored in a single file. It gives a better overview for each test
-  case and a lot less files.
+Version 7.9.7
 
-- Andrés García brought a fix for the netscape/mozilla cookie file parsing
-  function, as it turns out it doesn't always store the path!
+Daniel (10 May 2002)
+- Kevin Roth adjusted the --trace-ascii output slightly.
 
-Daniel (22 May 2001)
-- As was reported anonymously, when FAILONERROR was used, the httpcode was
-  not stored properly and thus wasn't possibly to read after a transfer with
-  the curl_easy_getinfo() function. This is now corrected.
+- Paul Harrington found out that src/writeout.c needed an additional header
+  file included for AIX builds
 
-- Installed and made use of the following tool versions:
-    autoconf 2.50
-    libtool 1.4
-    automake 1.4-p1
+Version 7.9.7-pre2
 
-  I wouldn't recommend any developer to try to generate things with older
-  versions than these. Building from CVS will probably more or less require
-  at least these versions.
+Daniel (7 May 2002)
+- Updated the man page with --trace-ascii and -j/--junk-session-cookies.
 
-  As a result of this, the configure script grew to more than double its
-  previous size!
+- Made --trace-ascii do pretty much the same as --trace but without the hex
+  part in the output.
 
-  Arkadiusz Miskiewicz helped me by pointing out I had to remove my
-  acinclude.m4 file before I could get it working!
+- Added CURLOPT_COOKIESESSION that when enabled makes libcurl ignore session
+  cookies read from a file. This option is enforced by the curl command line
+  tool using the new -j/--junk-session-cookies option. After discussions with
+  Kevin Roth. This makes it easier to use curl to fully emulate a browser's
+  behavior, even when it comes to "session cookies". Session cookies are
+  cookies that a normal browser discards when the browser is shut
+  down. They're identified by not having any expire date/time.
 
-Daniel (21 May 2001)
-- I made ftps:// work. Added test case 400 to the release archive, as the
-  first ftps:// test case. Requires stunnel.
+- When CURLOPT_DEBUGDATA was set, it ruined the CURLOPT_STDERR setting and
+  this was discovered when --trace was made to crash.
 
-- Also made the test cases that runs ssl tests not run if libcurl isn't built
-  with ssl support.
+- Using -v and --trace at the same time confused matters. -v is now pretty
+  much ignored when --trace or --trace-ascii is used.
 
-Daniel (19 May 2001)
-- Made the configure not add any extra -L LDFLAGS or -I CPPFLAGS unless they
-  are actually needed. Albert Chin's and Domenico Andreoli's suggestions
-  helped out.
+- Made --trace (and --trace-ascii) support - as file name to pass output to
+  stdout instead. It makes it consistent with how other options work.
 
-Version 7.7.4-pre2
+Version 7.9.7-pre1
 
-Daniel (18 May 2001)
-- Nicer configure-check for the OpenSSL headers, which then sets the proper
-  variable to have curl-config be good. (Albert Chin provided the fix)
+Daniel (6 May 2002)
+- Added multi-post.c to the examples directory. I got the basic source for
+  this from Gustaf Hui.
 
-- For systems that don't have theiw own 'strlcat()' libcurl provides its own.
-  It was now renamed to prevent collides with other libs. (After discussions
-  with Sterling Hughes and the implications this had on PHP builds.)
+Daniel (3 May 2002)
+- CURL_MAX_WRITE_SIZE is now an exported #define in the curl/curl.h header and
+  can be used to figure out the maximum buffer size your write callback can
+  get.
 
-Daniel (17 May 2001)
-- Colm Buckley posted a detailed bug report on (the debianized) 7.7.3, that
-  turned out to be a problem with the debian-built 7.7.3-package that
-  contained files from the 7.7.2 release!
+- CURLOPT_READDATA is now an alias for CURLOPT_INFILE and CURLOPT_WRITEDATE is
+  an alias for CURLOPT_FILE. These two were added for conformity. Most other
+  callback function's userdata are provided with options using a similar name-
+  scheme.
 
-- I added the CURLE_ALREADY_COMPLETE again, but with a fake value, just to
-  make programs that use it, not fail when compiling against this version of
-  libcurl.
+- Added "--trace [file]" to the command line tool. It makes a very detailed
+  trace dump get stored, with a full protocol dump that includes all received
+  and transmitted data. This could be a very effective tool for debugging what
+  goes wrong. This dump includes every byte the way it is sent to/received
+  from the server. The dump is the plain-text version, so SSL transfers will
+  still be readable.
 
-Daniel (14 May 2001)
-- Pawel A. Gajda fixed a problem with resumed transfers on re-used persistent
-  connections.
+- I found out that the DEBUGFUNCTION was not called properly everywhere as we
+  wanted it to. I fixed it.
 
-Version 7.7.4-pre1
+- -D now stores all headers to the same file if multiple URLs are given on the
+  command line! Kevin Roth made me aware of that it didn't already do this!
 
-Daniel (14 May 2001)
-- Jun-ichiro itojun Hagino fixed FTP PORT for IPv6-enabled libcurl.
+- Gustaf Hui wrote an excellent formpost example that used the multi
+  interface.  Unfortunately, it didn't work due to several bugs in how
+  transfers were made when the multi interface was used.
 
-- Added the first HTTPS test to the test suite in the release archive.
+Daniel (2 May 2002)
+- Hanno Kranzhoff found out that when doing multiple transfers on the same
+  easy handle, the progress meter would show a bad "currently downloaded
+  value" when the transfer starts.
 
-Daniel (12 May 2001)
-- Jukka Pihl suggested that if (lib)curl is told to verify the peer's
-  certificate and the peer can't be verified, it should fail and return a
-  proper error code. I added a brand new error code named
-  CURLE_SSL_PEER_CERTIFICATE for this purpose.
+Daniel (1 May 2002)
+- Applied another patch by Jacky Lam to make the name resolve info realloc()
+  stuff work properly.
 
-Daniel (11 May 2001)
-- As was discussed with Frederic Lepied a while ago, I now made libcurl not
-  return error even though no data was transfered on upload/download resume
-  when the no transfer is needed. The CURLE_ALREADY_COMPLETE error was removed
-  from the header file to make any implemenator that uses that to be aware of
-  the fact that it can't be returned anymore!
+Daniel (28 April 2002)
+- curl_multi_info_read() is now implemented!
 
-- Improved general header-parsing to better allow white spaces and more.
+Daniel (27 April 2002)
+- Updated BUGS, TODO, FAQ, INSTALL and added BINDINGS.
 
-- Rodney Simmons proved the fix I did yesterday was bad and I had to post
-  another one.
+- I think I fixed the DNS cache prune crach Jacky Lam found and reported.
 
-- Ingo Wilken patched away two redirect problems more!
-  
-Daniel (10 May 2001)
-- Cris Bailiff correctly noted that the space-after-header problem with
-  Location: is present on several other places in the libcurl sources.
-
-- Ingo Wilken patched away a problem libcurl had when following Location:
-  headers with an extra space after the colon.
-
-- Rodney Simmons found out that multiple FTP transfers did not treat relative
-  directories correctly.
-
-Daniel (9 May 2001)
-- Getting an FTP file with CURLOPT_NOBODY set (or -I from the command line),
-  makes curl use the non-standard ftp command "SIZE". If it failed, libcurl
-  returned error. Starting now, it just don't output the file size instead.
-  Anonymous bug report.
+- I cleaned up the name prefix stuff in the hash and llist modules.
 
-- stunnel.pm was accidentally left out from the release archive, it is now
-  added (stunnel is needed to run the https-tests in the test suite)
-  
-Daniel (7 May 2001)
-- Corrected two minor compiler warnings due to the FILE * to void * conversion
-  that I missed at two places. Jörn Hartroth brought me patches. Sander Gates
-  filed a bug report on this.
+- FTP responses should now be better on timing out properly. The timeout value
+  is maximum timeout for the entire request operation, but before this, the
+  timeout was used as a maximum allowed time between two reads...
 
-Version 7.7.3
+Daniel (26 April 2002)
+- Fixed the test suite http server to not use snprintf() anymore due to better
+  portability.
 
-Daniel (4 May 2001)
-- All callback functions now take 'void *' instead of 'FILE *'. This is made
-  this way to make it more obvious to people that anything can be passed to
-  them (by using the apropriate option). After discussions with Sterling
-  Hughes.
+Daniel (25 April 2002)
+- With Sterling Hughes' new DNS pruning, Jacky Lam asked if this wouldn't
+  cause problems since the pruning is only checking the entry time, and it
+  sure could cause problems. Therefor, I've now added and changed code so that
+  this should not be a problem. Nowhere in the code will be store name
+  resolved information around so that a sunsequent DNS cache prune should
+  cause a problem. This of course called for some mild internal changes.
 
-Daniel (3 May 2001)
-- Cris Bailiff fixed a chunked transfer encoding problem with persistent
-  connection that made libcurl fail if the persistent connection used mixed
-  chunked and non-chunked transfers.
+Daniel (23 April 2002)
+- Improved the 'no_proxy' check, as using port numbers in the URL confused it
+  previously. Reported by Erwan Legrand in bug report #547484.
 
-- Cris Bailiff fixed a bad treatment of 304-replies, as they would not be
-  treated as content-length 0 replies but would cause a "hang" until the
-  server timed-out and closed the connection.
+- The --interface option now works even on IPv6 enabled builds. Reported by
+  'thor'.
 
-- Brad Burdick found a minor problem in the docs/examples/Makefile.am
+Daniel (22 April 2002)
+- The #defines names starting with TIMECOND now has CURL_ prefixes. (The old
+  names are still #defined too.) Pointed out by Robert Olson.
 
-Daniel (27 April 2001)
-- Updated the INTERALS document again. It was lagging a bit. I think I made it
-  more easy to follow now as well.
+- Jacky Lam brought code that lets the name resolve function only use as much
+  memory as it actually needs. This only works on certain operating systems,
+  but is totally transparant to all users.
 
-- Brad Burdick found a problem with persistent connections when curl received
-  a "Content-Length: 0" header.
+Daniel (19 April 2002)
+- Bjorn Reese fixed pack_hostent to work properly with 64 bit pointers.
 
-- Giuseppe D'Ambrosio was first out to report that TELNET doesn't work in curl
-  compiled/built on win32. It seems to work for unixes though!
+Daniel (18 April 2002)
+- Sterling Hughes added code to prune old DNS cache entries, since Jacky Lam
+  experienced very big caches.
 
-- Dave Hamilton reported weird problems with CURL/PHP that I really can't
-  explain at the moment. I'm hoping on some help from the PHP crew.
+Daniel (17 April 2002)
+- Dirk Manske patched the 301 response to work against the RFC but more like
+  common browsers do. If a POST get a 301 back, it'll switch to GET in the
+  next request (if location-following is enabled).
 
-Daniel (26 April 2001)
-- I rewrote the FTP command response function. I had to do it to make ftps
-  work, as the OpenSSL read()-function didn't work the same way the normal
-  unix read() does, but it was also a huge performance boost. Previously the
-  function read one byte at a time, now it reads very large chunks, and it
-  makes a notable speed difference.
+Daniel (16 April 2002)
+- Dirk Manske posted a patch originally written by Ingo Wilken that introduced
+  two new CURLINFO_* values: CURLINFO_REDIRECT_TIME and
+  CURLINFO_REDIRECT_COUNT.
 
-Daniel (25 April 2001)
-- Connection re-use when not using a proxy didn't work properly for
-  non-default port numbers.
+Daniel (15 April 2002)
+- Jonatan Lander patched the verbose text 'Disables POST, goes with GET' to
+  reflect reality better, like when the first request isn't POST and when
+  the second isn't GET... :-)
 
-Daniel (24 April 2001)
-- I've noticed that FTPS doesn't work. We attempt to use ssl even for the
-  data transfer, which causes the transfer to 'hang'... We need to fix this.
+- Craig Davison pointed out that when curl_formadd()ing a file that doesn't
+  exist, libcurl doesn't return error. Now, curl_easy_perform() will return
+  CURLE_READ_ERROR if that is the case. Test 41 was added to verify this.
 
-- Improved the test suite to use 'stunnel' to do HTTPS and FTPS testing on
-  the alredy written perl servers easily.
+Version 7.9.6
 
-Daniel (23 April 2001)
-- The OpenSSL version string recently modified didn't zero terminate one
-  of the generated strings properly, which could lead to a crash or simply
-  weird version string output!
+Daniel (14 April 2002)
+- Dirk Manske brought a fix that makes libcurl strip off white spaces from the
+  beginning of cookie contents.
 
-Version 7.7.2
+- Had to patch include/curl/curl.h since MSVC doesn't set the __STDC__ define.
+  Moonesamy pointed out the problem, Bjorn Reese the solution.
 
-Daniel (22 April 2001)
-- Rosimildo da Silva updated the Makefiles for Borland/Windows.
+Version 7.9.6-pre5
 
-- Eric Rautman pointed out a problem with persistent connections that would
-  lead to broken Host: headers in the second HTTP request.
+Daniel (12 April 2002)
+- Fixed the TIMER_CONNECT to be more accurate for FTP transfers. Previously
+  FTP transfers got the "connect done" time set after the initial FTP commands
+  and not directly after the TCP/IP connect as it should.
 
-Daniel (20 April 2001)
-- Added man pages for the curl_strequal() and curl_mprintf() families. Wrote
-  a 'libcurl overview' man page.
+  I also made the time stamp get set even if the connect itself fails, which
+  it didn't do previously.
 
-- Spell-fixed some documents.
+- Jean-Philippe Barrette-LaPierre provided his patch that introduces
+  CURLOPT_DEBUGFUNCTION and CURLOPT_DEBUGDATA. They allow a program to a set a
+  callback to receive debug/information data. That includes headers and data
+  that is received and sent. CURLOPT_VERBOSE still controls it.
 
-- S. Moonesamy corrected mistakes in the man page.
+  By default, there is an internal debugfunction that will make things look
+  and work as before if not changed.
 
-- Cris Bailiff fixed the curl_slists options in the perl interface, present
-  separately in the Curl::easy 1.1.4 package.
+Daniel (10 April 2002)
+- Sebastien Willemijns found out that -x didn't use the default port number as
+  is documented. It does now.
 
-Daniel (19 April 2001)
-- Linus Nielsen Feltzing removed the decimals from the size variables in the
-  --write-out output. We hardly ever get fraction of bytes! :-)
+- libcurl-errors.3 is a new man page attempting to document all libcurl error
+  codes
 
-Version 7.7.2-pre1
+- Added two new error codes and changed the behaviour of two old ones
+  slightly:
 
-Daniel (19 April 2001)
+  CURLE_WRITE_ERROR
+   This error was returned *both* for errors that occured when writing
+   received data to a local file, as well as when we get problems writing data
+   to a remote server. CURLE_SEND_ERROR has now been added for the latter
+   error.
 
-- Albert Chin provided a configure patch for the AC_SYS_LARGEFILE macro.
+  CURLE_READ_ERROR
+   This error was similarly returned *both* for errors when reading a local
+   file, as well as when getting problems when reading network data.
+   CURLE_RECV_ERROR has now been added for the latter error.
 
-Daniel (18 April 2001)
-- Input from Michael Mealling made me add --feature to curl-config. It
-  displays a list of features that have been built-in in the current
-  libcurl. The currently available features that can be listed are: SSL, KRB4
-  and IPv6.
+ (Two test cases were adjusted accordingly.)
 
-- I committed Cris and Georg's perl interface work. They've got callbacks
-  working and options that receives those slist pointers.
+Daniel (9 April 2002)
+- runtests.pl now sets the HOME variable before running curl, to prevent any
+  actual ~/.curlrc file to fool the tests!
 
-- Puneet Pawaia detected a problem with resumed downloads that use persistent
-  connections and I made a rather large writeup to correct this. It is
-  important that all session-data is stored in the connectdata struct and not
-  in the main struct as this previously did.
+Version 7.9.6-pre4
 
-Daniel (17 April 2001)
-- Frederic Lepied fixed a ftp resumed download problem and introduced a new
-  error code that lets applications be able to detect when a resumed download
-  actually didn't download anything since the whole file is already present.
-  Should this return OK instead?
+Daniel (8 April 2002)
+- Michael Curtis provided new functionality for curl on some platforms. Using
+  the --environment option, curl will *set* a bunch of environment variables
+  to values. The names are the same ones as for the -w/--writeout option.
 
-- I added 'curl-config.in' to the root dir and configure script. Now, a
-  curl-config script is made when curl is built. The script can be used to
-  figure out compile time options used when libcurl was built, which in turn
-  should be options YOU should use to build applications that use libcurl.
+  For now, this only works on the RISC OS version, as this feature relies on
+  both OS support and that it matches OS paradigms.
 
-  This *-config style is not a new idea, but something that has been used
-  successfully in other (library based) projects.
+- Jacky Lam provided a fix for getting headers-only when the reply is HTTP/1.0
+  and 304, I edited it slightly.
 
-- Phil Karn pointed out that libcurl wrongly did not always use GMT time zone
-  for the If-Modified-Since style headers.
+Daniel (5 April 2002)
+- As requested by Jay Graves, the '.curlrc' file (or _curlrc as it is called
+  when used in windows), is now loaded from the current directory if the HOME
+  environment variable isn't set (or if it is too long). I also enlarged the
+  array used to store the full file path in, to 512 bytes.
 
-- Georg Schwarz pointed out an extra needed #include file needed in src/main.c
-  for curl to build on Ultrix.
+- Kevin Roth pointed out to me why the "19 March" change regarding -G and -I
+  was stupid and the change was reverted. Added test case 48 to verify the
+  functionality.
 
-Daniel (11 April 2001)
-- Cris Bailiff pointed out two problems that I corrected. First, libcurl's use
-  of the environment variable HTTP_PROXY in uppercase may become a security
-  hazard when people use libcurl in a server/cgi situation where the server
-  sets the HTTP_*-variables according to incoming headers in the HTTP
-  request. Thus, a "Proxy:"-header would set that environment variable!
+Version 7.9.6-pre3
 
-  Then, invoking curl_easy_perform() without having an URL set caused a crash.
+Daniel (4 April 2002)
+- Jonatan Lander brought a patch that makes curl/curl.h compile nicely on
+  pre-ISO compilers, like when using gcc -traditional.
 
-- S. Moonesamy brought a patch that make curl use non-blocking connects on
-  windows when connection timeout is set, as it allows windows users to set
-  that timeout!
+Daniel (3 April 2002)
+- Jacky Lam identified a glitch when getting headers-only, where libcurl would
+  "hang" 1 second in vain in the select() loop before returning back.
 
-- Hirotaka Matsuyuki wrote a Ruby interface to libcurl!
+- Tor Arntsen brought a patch for multipart formposts. It turned out that the
+  "CGI_Lite Perl package" makes some bad assumptions on what letters that may
+  be used in boundary strings and thus curl could confuse it by including '+'
+  and '/'. While this is standards-compliant, we change the behavior to work
+  smoothly with existing software based on that package.
 
-- Cris Bailiff, Forrest Cahoon and Georg Horn work on the Perl interface.
+Daniel (2 April 2002)
+- Gerhard Herre filed bug report #536238 where he pointed out a crash in
+  verbose FTP passive transfers for AIX.
 
-- I've written a first shot at a Java interface to libcurl. Many thanks to
-  Daniel Marell for tirelessly answering to all my basic Java questions. It
-  works, but it is still very basic.
+- Clarence Gardner pointed out a minor flaw in how libcurl didn't properly
+  take care of all errors that SSL_read() could return.
 
-Daniel (10 April 2001)
-- The progress display could get silly when doing multiple file transfers, as
-  it wasn't properly reset between transfers!
+- Jacky Lam fixed a MALLOCDEBUG problem in lib/getinfo.c
 
-- Discussions with Cris Bailiff who writes a Perl interface to libcurl, made
-  me add CURLOPT_HEADERFUNCTION. It can be used to set a separate callback
-  function for writing headers. Previously you could only set a different FILE
-  * when headers are written from within libcurl.
+Daniel (27 March 2002)
+- T. Bharath pointed out a flaw in the connection re-use function that didn't
+  check proxy connections properly for "deadness" before they were re-used.
 
-Daniel (7 April 2001)
-- Andrés García fixed a problem in curl_escape() and pointed out a flaw in
-  the curl_easy_setopt man page.
+- Pedro Neves found out that HTTP POSTing with --data-binary did not properly
+  work under Windows as the file specified wasn't read fully binary!
 
-Daniel (6 April 2001)
-- Adjusted the version code to properly display OpenSSL 0.9.6a. They sure
-  change their version define format often...
+Daniel (25 March 2002)
+- Jacky Lam brought a fix that improves treatment of cookies using identical
+  domains but with leading dots properly.
 
-- curl_formfree() now accepts a NULL pointer without crashing!
+Daniel (22 March 2002)
+- Miklos Nemeth updated the windows section of the docs/INSTALL file and the
+  windows makefiles.
 
-Version 7.7.1
+- Jon Dillon provided us with several good-looking curl images for
+  promotion. View them here http://curl.haxx.se/icons.html
 
-Daniel (3 April 2001)
-- Puneet Pawaia pointed out two serious problems. Libcurl would attempt to
-  read bad memory during situations when an (ftp) connection attempt failed.
-  Also, the lib/Makefile.vc6 was corrected.
+Daniel (20 March 2002)
+- Peter Verhas found out that CRLF replacement in uploads was not working. I
+  fixed it, and added test case 128 that verifies the functionality.
 
-- More investigations in the Location: following code made me realize that
-  it was not clean enough to work transparantly with persistent and non-
-  persistent connections. I think I've fixed it now.
+- The list formerly known as curl-main is now named curl-users and is hosted
+  by sourceforge. Susbcribe to the new list, get off the old one.
 
-Daniel (29 March 2001)
-- Georg Horn mailed me some corrections for the Curl::easy perl interface.
+Version 7.9.6-pre2
 
-- Experimental ftps:// support added. It is basically FTP over SSL for the
-  control connection. It still makes all data transfers going over unencrypted
-  connections. Rainer Weikusat's ftpd-ssl server hack supports this and I used
-  that to verify the functionality.
+Daniel (19 March 2002)
+- Made -G and -I on the same command line cause an error.
 
-Daniel (27 March 2001)
-- Guenole Bescon discovered that if you set a CURLOPT_TIMEOUT and then tried
-  to get a file from a site and it fails, the SIGALRM would still be sent
-  after the timeout-time, quite inexpectedly!
+- Moved the multi.h file to the "public" include directory and made it get
+  included by curl.h so that no extra include files will be necessary to use
+  it.
 
-- I added an ftp transfer example to docs/examples/ and I also wrote a tiny
-  example makefile that can be used as a start when building one of the
-  examples.
+  Added docs and man pages for the multi interface to the release archive.
+  Added the three example source codes too.
 
-Version 7.7.1-beta1
+  Necessary steps in my campaign to sneak in the multi interface... ;-)
 
-Daniel (26 March 2001)
-- Mohamed Lrhazi reported problems with 7.6.1 and persistent HTTP/1.0
-  connections (when the server replied a Connection: Keep-Alive) and this
-  problem was not properly dealt with in 7.7 either. A patch was posted to the
-  curl-and-php mailing list.
+- Updated the year in all copyright notices in all C and H files.
 
-Daniel (24 March 2001)
-- Colin Watson reported about a problem and brought a patch that corrected it,
-  which was about the man page and lines starting with a single quote (') in a
-  way that gnroff doesn't like.
+Daniel (18 March 2002)
+- Tomas Szepe found out that -d and -G didn't mix as they should. I broke this
+  in 7.9.5... Added test case 32 for this.
 
-Daniel (23 March 2001)
-- Peter Bray reported correctly that the root makefile used make instead of
-  $(MAKE) for the test target.
+Version 7.9.6-pre1
 
-- Corrected the Curl::easy perl interface to use curl_easy_setopt() and not
-  curl_setopt() which was removed in 7.7!
+Daniel (16 March 2002)
+- Peter Verhas pointed out that the curl_escape and curl_unscape man pages
+  contained factual errors.
 
-- S. Moonesamy provided updates on three documents (MANUAL, INSTALL and FAQ).
+- Albert Choy found and corrected a problem with the verbose output when doing
+  PASV ftp transfers. It could make libcurl crash.
 
-- When following a Location:, libcurl would sometimes write to the URL string
-  in a way it shouldn't. As the pointer is passed-in to libcurl from an
-  application, we can't be allowed to write to it. The particular bug report
-  from 'nk' that brought this up was because he had a read-only URL that then
-  caused a libcurl crash!
+  Details in bug report #530562:
+  http://sourceforge.net/tracker/?func=detail&atid=100976&aid=530562&group_id=976
 
-- No longer reads HEAD responses longer than to the last header. Previously,
-  curl would read the full reply if the connection was a "close" one.
+Daniel (15 March 2002)
+- Jun-ichiro itojun Hagino filed bug report #530204 that clearly pointed out
+  the PF_INET fix from February 19 as a not-very-good fix as it broke IPv6
+  capability! That patch is now reverted.
 
-- libcurl did re-use connections way too much. Doing "curl
-  http://www.{microsoft,ibm}.com" would make it re-use the connection which
-  made the second request return very odd results.
+  The problem with slow name lookups with getaddrinfo() on non-IPv6 enabled
+  hosts are instead made by first checking if the stack is IPv6-enabled and if
+  not, the PF_INET is used and otherwise we go with the full PF_UNSPEC.
 
-Daniel (22 March 2001)
-- Edin Kadribasic made me aware that curl should not re-send POST requests
-  when following 302-redirects. I made 302 work like 303 which means curl uses
-  GET in the following request(s).
+- T. Bharath pointed out that when we return an "error" from a WRITEFUNCTION
+  as described in the man page, libcurl did not return the documented error
+  code (CURLE_WRITE_ERROR) but would instead return CURLE_READ_ERROR. This is
+  now corrected.
 
-- libcurl now reset the "followed-location" counter on each invoke of
-  curl_easy_perform() as it otherwise would sum up all redirects on the same
-  connection and thus could reach the maxredirs counter wrongly.
+Daniel (14 March 2002)
+- Setting CURLOPT_POST without setting CURLOPT_POSTFIELDS now read the POST-
+  data from the callback.
 
-- Jim Drash suggested curl_escape() should not re-encode what already looks
-  like an encoded sequence and I think that's a fair suggestion.
+- The GOPHER support seems to be broken. I don't think I'll even start fixing
+  it until someone else finds out... :-)
 
-Version 7.7
+Daniel (13 March 2002)
+- Trying 'curl -I ftp.sunet.se' or similar did a SIZE on a silly "(nil)"
+  string. If such a file would be present, curl returned the size of it! Now
+  we prevent this.
 
-Daniel (22 March 2001)
-- The configure script now fails with an error message if gethostbyname_r() is
-  detected but it couldn't figure out how to invoke it (what amount of
-  arguments it is supposed to get). Reports from Andrés García made me aware
-  of this need.
+- Curl_sendf() was fixed to deal with situation where Curl_write() would've
+  blocked and thus return -1.
 
-- Talking with Jim Drash made me finally put the curl_escape and curl_unescape
-  functions in the curl.h include file and write man pages for them. The
-  escape function was modified to use the same interface as the unescape one
-  had.
+- Setting CURLOPT_PROGRESSFUNCTION to NULL now restores the internal function.
 
-- No bug reports at all on the latest betas. Release time coming up.
+- All CURLFORM_* options can now be used in a CURLFORM_ARRAY except the
+  CURLFORM_ARRAY itself. This was necessary since we couldn't expand the
+  CURLFORM_* list proprely and unrestricted until this was the case. It was
+  also a bit peculiar to users why some options could be used in an array
+  while others couldn't.
 
-Version 7.7-beta5
+- Removed some silly CRLF lines that had accidentally slipped into src/main.c
+  Nico Baggus pointed them out to me.
 
-Daniel (19 March 2001)
-- Georg Ottinger reported problems with using -C together with -L in the sense
-  that the -C info got lost when it was redirected. I could not repeat this
-  problem on the 7.7 branch why I leave this for the moment. Test case 39 was
-  added to do exactly this, and it seems to do right.
+Daniel (11 March 2002)
+- CURLFORM_FILENAME was added. This can be set when creating a file upload
+  part, to set the 'filename' field to a custom value. If this isn't used,
+  the actually used filename will be included instead (as libcurl always has
+  done). curl was adjusted accordingly, and now -F accepts a 'filename=' field
+  too, and allows constructs such as:
 
-- Christian Robottom Reis reported how his 7.7 beta didn't successfully do
-  form posts as elegantly as 7.6.1 did. Indeed, this was a flaw in the header
-  engine, as HTTP 1.1 has introduced a new 100 "transient" return code for PUT
-  and POST operations that I need to add support for. Section 8.2.3 in RFC2616
-  has all the details. Seems to work now!
+    -F 'name=@filename;filename=/dev/null'
 
-Daniel (16 March 2001)
-- After having experienced another machine break-down, we're back.
+  and this can be combined with type= too, in a manner similar to:
 
-- Georg Horn's perl interface Curl::easy is now included in the curl release
-  archive. The perl/ directory is now present. Please help me with docs,
-  examples and updates you think fit.
+   -F "file=@log/test39.txt;filename=fakerfile;type=moo/foobar"
 
-- Made a new php/ directory in the release archive and moved the PHP examples
-  into a subdirectory in there. Not much PHP info yet, but I plan to. Please
-  help me here as well!
+  Test case 39 was added to verify this functionality.
 
-- Made libcurl return error if a transfer is aborted in the middle of a
-  "chunk". It actually enables libcurl to discover premature transfer aborts
-  even if the Content-Length: size is unknown.
+- The struct formerly known as HttpPost is now named curl_httppost to properly
+  use the curl name space. I added a #define for the old name to make existing
+  programs compile even when this new include file is used.
 
-Daniel (15 March 2001)
-- Added --connect-timeout to curl, which sets the new CURLOPT_CONNECTTIMEOUT
-  option in libcurl. It limits the time curl is allowed to spend in the
-  connection phase. This differs from -m/--max-time that limits the entire
-  file transfer operation. Requested by Larry Fahnoe and others.
+Daniel (8 March 2002)
+- Clifford also discovered that if the client code failed early, as when doing
+  "curl -O" only, it would do fclose(NULL) which caused a segmentation fault
+  on some systems.
 
-  I also updated the curl.1 and curl_easy_setopt.3 man pages and removed the
-  item from the TODO.
+- Clifford Wolf provided a patch that made --progress-bar work again.
 
-Version 7.7-beta4
+- I closed bug report #527032 by making sure that we add a newline after a
+  transfer when --progress-bar has been used. Before, without the newline, it
+  made the subsequent text come out wrong.
 
-Daniel (14 March 2001)
-- Made curl grok IPv6 with HTTP proxies and got everything to compile nicely
-  again when ENABLE_IPV6 is set.
+Version 7.9.5
 
-  I need to remake things in the test suite. I can't test the FTP parts with
-  curl built for IPv6 as it uses a different set of FTP commands then!
+Daniel (7 March 2002)
+- Added docs/KNOWN_BUGS to the release archive.
 
-- I fell onto a bug report on php.net (posted by Lars Torben Wilson) that was
-  a report meant for our project. Anyway, it said the .netrc parsing didn't
-  work as supposed, and as I agreed with Lars, I made the netrc parser use
-  getpwuid() to figure out the home directory of the effective user and try
-  that netrc. It still uses the environment variable HOME for those that don't
-  have that function or if the user doesn't return valid pwd info.
+Daniel (6 March 2002)
+- Kevin Roth corrected a flaw in the curl client globbing code that made it
+  mess up backslashes. This was most notable on windows (cygwin) machines when
+  using file://.
 
-- Edin Kadribaic posted a bug report where he got a crash when a fetch with
-  user+password in the URL followed a Location: to a second URL (absolute,
-  without name+password). This bug has been around for a long while and
-  crashes due to a read at address zero. Fixed now. Wrote test case 38, that
-  tests this.
+- Brad provided another fix for building outside the source-tree.
 
-- Modified the test suite's httpserver slightly to append all client request
-  data to its log file so that the test script now better can verify a range
-  of requests and not only the last one, as it did previously.
+- Ralph Mitchell patched away a few compiler warnings in tests/server/sws.c
 
-- Updated the curl man page with --random-file and --egd-file details.
+Daniel (5 March 2002)
+- I noticed that the typedef in curl.h for the progress callback prototype was
+  wrong and thus applications that used it would not get the proper input
+  data. It used size_t where the implementation actually uses doubles!
 
-Version 7.7-beta3
+  I wish I could blame someone else, but this was my fault. Again.
 
-Daniel (14 March 2001)
-- Björn Stenberg provided similar fixes as Jörn did and some additional patches
-  for non-SSL compiles.
+Version 7.9.5-pre6
 
-- I increased the interface number for libcurl as I've removed the low level
-  functions from the interface. I also took this opportunity to rename the
-  Curl_strequal function to curl_strequal and Curl_strnequal to
-  curl_strnequal, as they're public libcurl functions (even if they're still
-  undocumented).
+Daniel (4 March 2002)
+- Cut off the changes done during 2001 from this changelog file and put them
+  in a separate file (CHANGES.2001), available from CVS of course.
 
-  This will make older programs not capable of using the new libcurl with
-  just a drop-in replacement.
+- I removed the multi directory. The example sources were moved to the
+  docs/examples directory where they belong.
 
-- Jörn Hartroth updated stuff for win32 compiles:
-  o config-win32.h was fixed for socklen_t
-  o lib/ssluse.c had a bad #endif placement
-  o lib/file.c was made to compile on win32 again
-  o lib/Makefile.m32 was updated with the new files
-  o lib/libcurl.def matches the current interface state
+- Wrote 7 new man pages for the current functions in the new multi interface.
+  They're all still pretty basic, but we can use them as a start and add more
+  contents to them when we figure out what to write. The large amount of man
+  pages for libcurl now present made me decide to put them in a new separate
+  subdirectory in the docs directory. Named libcurl.
 
-Daniel (13 March 2001)
-- It only took an hour or so before Jörn Hartroth found a problem in the
-  chunked transfer-encoding. Given his fine example-site, I could easily spot
-  the problem and when I re-read the spec (the part I have pasted in the top
-  of the http_chunks.h file), I realized I had made my state-machine slightly
-  wrong and didn't expect/handle the trailing CRLF that comes after the data
-  in each chunk (and those extra two bytes sure feel wasted).
+- Giuseppe Corbelli provided a template file for the EPM package manager, it
+  gets generated nicely by the configure script now.
 
-  Had to modify test case 34 to match this as well.
+Version 7.9.5-pre5
 
-Version 7.7-beta2
+Daniel (1 March 2002)
+- Moved the memanalyze.pl script into the tests/ dir and added it to the
+  release archives. It was previously only present in the CVS tree.
 
-Daniel (13 March 2001)
-- Added the policy stuff to the curl_easy_setopt man page for the two supported
-  policies.
+- Modified the February 17th Host: fix, as bug report #523718 pointed out that
+  it caused crashes!
 
-- Implemented some support for the CURLOPT_CLOSEPOLICY option. The policies
-  CURLCLOSEPOLICY_LEAST_RECENTLY_USED and CURLCLOSEPOLICY_OLDEST are now
-  supported, and the "least recently used" is used as default if no policy
-  is chosen.
+- Nico Baggus added more error codes to the VMS stuff.
 
-Daniel (12 March 2001)
-- Added CURLOPT_RANDOM_FILE and CURLOPT_EGDSOCKET to libcurl for seeding the
-  SSL random engine. The random seeding support was also brought to the curl
-  client with the new options --random-file <file> and --egd-file <file>. I
-  need some people to really test this to know they work as supposed. Remember
-  that libcurl now informs (if verbose is on) if the random seed is considered
-  weak (HTTPS connections).
+- Wesley Laxton brought the code that introduced the new CURLOPT_PREQUOTE
+  option. It is just another FTP quote option that allows the user to specify
+  a list of FTP commands to issue *just before* the transfer command (RETR or
+  STOR etc). It has turned up a few systems that really need this.
 
-- Made the chunked transfer-encoding engine detected bad formatted data length
-  and return error if so (we can't possibly extract sensible data if this is
-  the case). Added a test case that detects this. Number 36. Now there are 60
-  test cases.
+  The curl command line tool can also take advantage of this by prefixing the
+  quote commands with a plus (+) in similar style that post transfer quote
+  commands are specified.
 
-- Added 5 new libcurl options to curl/curl.h that can be used to control the
-  persistent connection support in libcurl. They're also documented (fairly
-  thoroughly) in the curl_easy_setopt.3 man page. Three of them are now
-  implemented, although not really tested at this point... Anyway, the new
-  implemented options are named CURLOPT_MAXCONNECTS, CURLOPT_FRESH_CONNECT,
-  CURLOPT_FORBID_REUSE. The ones still left to write code for are:
-  CURLOPT_CLOSEPOLICY and its related option CURLOPT_CLOSEFUNCTION.
+  This is not yet documented. There is no test case for this yet.
 
-- Made curl (the actual command line tool) use the new libcurl 7.7 persistent
-  connection support by re-using the same curl handle for every specified file
-  transfer and after some more test case tweaking we have 100% test case OK.
-  I made some test cases return HTTP/1.0 now to make sure that works as well.
+Daniel (28 February 2002)
+- Ralph Mitchell made some serious efforts and put a lot of sweat in setting
+  up scripts and things for me to be able to repeat his problems, and I
+  finally could.  I found a problem with the header byte counter that wasn't
+  increased properly and thus we could return CURLE_GOT_NOTHING when we in
+  fact had received data.
 
-- Had to add 'Connection: close' to the headers of a bunch of test cases so
-  that curl behaves "old-style" since the test http server doesn't do multiple
-  connections... Now I get 100% test case OK.
+Daniel (27 February 2002)
+- I had to revert the non-space parsing cookie fix I posted to the mailing
+  list. Expire dates do have spaces and still need to get parsed properly!
+  Instead we just ignore trailing white space and it seems to work...
 
-- The curl.haxx.se site, the main curl mailing list and my personal email are
-  all dead today due to power blackout in the area where the main servers are
-  located. Horrible.
+Daniel (26 February 2002)
+- Made the cookie property 'Max-Age' work, just since we already tried to
+  support it, it is better to do it right. No one uses this anyway.
 
-- I've made persistance work over a squid HTTP proxy. I find it disturbing
-  that it uses headers that aren't present in any HTTP standard though
-  (Proxy-Connection:) and that makes me feel that I'm now on the edge of what
-  the standard actually defines. I need to get this code excercised on a lot
-  of different HTTP proxies before I feel safe.
+- The cookie parser could crash if a really weird (illegal) cookie line was
+  received. I also made it better discard really oddly formatted lines better.
 
-  Now I'm facing the problem with my test suite servers (both FTP and HTTP)
-  not supporting persistent connections and libcurl is doing them now. I have
-  to fix the test servers to get all the test cases do OK.
+  Made the cookie jar store the second field from the left using the syntax
+  that Netscape and Mozilla probably like. Curl itself ignores it.
 
-Daniel (8 March 2001)
-- Guenole Bescon reported that libcurl did output errors to stderr even if
-  MUTE and NOPROGRESS was set. It turned out to be a bug and happens if
-  there's an error and no ERRORBUFFER is set. This is now corrected.
+  Added test case 31 for these cases.
 
-Version 7.7-beta1
+  Clay Loveless' email regarding some cookie issues started my cleanup.
 
-Daniel (8 March 2001)
-- "Transfer-Encoding: chunked" is no longer any trouble for libcurl. I've
-  added two source files and I've run some test downloads that look fine.
+- Kevin Roth pointed out that my automake fiddles broke the ability to build
+  outside the source-tree and I posted a patch to the mailing list that brings
+  this ability back.
 
-- HTTP HEAD works too, even on 1.1 servers.
+Version 7.9.5-pre4
 
-Daniel (5 March 2001)
-- The current 57 test cases now pass OK. It would suggest that libcurl works
-  using the old-style with one connection per handle. The test suite doesn't
-  handle multiple connections yet so there are no test cases for this.
+Daniel (25 February 2002)
+- Fiddled with the automake files to make all source files in the lib
+  directory not have ../src in the include path, and the src sources shouldn't
+  have ../lib!
 
-- I patched the telnet.c heavily to not use any global variables anymore. It
-  should make it a lot nicer library-wise.
+- All 79 test cases ran OK under Linux and Solaris using the new HTTP server
+  in the test suite. The new HTTP server was first donated by Georg Horn and
+  subsequently modified to work with the test suite. It is currently still not
+  portable enough to run on "all over" but this is a start and I can run all
+  curl tests on my machines. This is an important requirement for the upcoming
+  public release.
 
-- The file:// support was modified slightly to use the internal connect-first-
-  then-do approach.
+- Using -d and -I on the same command line now reports an error, as it implies
+  two different HTTP requests that can't be mixed.
 
-Daniel (4 March 2001)
-- More bugs erased.
+- Jeffrey Pohlmeyer provided a patch that made the -w/--write-out option
+  support %{content_type} to get the content type of the recent download.
 
-Version 7.7-alpha2
+- Kevin Roth reported that pre2 and pre3 didn't compile properly on cygwin,
+  and this was because I used #ifdef HAVE_WINSOCK_H in lib/multi.h to figure
+  out if we could include winsock.h which turns out not to be a wise choice to
+  do on cygwin since it has the file but can't include it!
 
-Daniel (4 March 2001)
-- Now, there's even a basic check that a re-used connection is still alive
-  before it is assumed so. A few first tests have proven that libcurl will
-  then re-connect instead of re-use the dead connection!
+Daniel (22 February 2002)
+- Added src/config-vms.h to the release archive.
 
-Daniel (2 March 2001)
-- Now they work intermixed as well. Major coolness!
+- Fixed the connection timeout value again, the change from February 18 wasn't
+  complete.
 
-- More fiddling around, my 'tiny' client I have for testing purposes now has
-  proved to download both FTP and HTTP with persistent connections. They do
-  not work intermixed yet though.
+Version 7.9.5-pre3
 
-Daniel (1 March 2001)
-- Wilfredo Sanchez pointed out a minor spelling mistake in a man page and that
-  curl_slist_append() should take a const char * as second argument. It does
-  now.
+Daniel (21 February 2002)
+- Kevin Roth and Andrés García both found out that lib/config.h.in was missing
+  in the pre-release archive and thus the configure script failed.
 
-Daniel (22 February 2001)
-- The persistent connections start to look good for HTTP. On a subsequent
-  request, it seems that libcurl now can pick an already existing connection
-  if a suitable one exists, or it opens a new one.
+Version 7.9.5-pre2
 
-- Douglas R. Horner mailed me corrections to the curl_formparse() man page
-  that I applied.
+Daniel (20 February 2002)
+- Andrés García provided a solution to bug report #515228. the total time
+  counter was not set correctly when -I was used during some conditions (all
+  headers were read in one single read).
 
-Daniel (20 February 2001)
-- Added the docs/examples/win32sockets.c file for our windows friends.
+- Nico Baggus provided a huge patch with minor tweaks all over to make curl
+  compile nicely on VMS.
 
-- Linus Nielsen Feltzing provided brand new TELNET functionality and
-  improvements:
+Daniel (19 February 2002)
+- Rick Richardson found out that by replacing PF_UNSPEC with PF_INET in the
+  getaddrinfo() calls, he could speed up some name resolving calls with an
+  order of magnitudes on his Redhat Linux 7.2.
 
-  * Negotiation is now passive. Curl does not negotiate until the peer does.
-  * Possibility to set negotiation options on the command line, currently only
-    XDISPLOC, TTYPE and NEW_ENVIRON (called NEW_ENV).
-  * Now sends the USER environment variable if the -u switch is used.
-  * Use -t to set telnet options (Linus even updated the man page, awesome!)
+- Philip Gladstone found a second INADDR_NONE problem where we used long
+  intead of in_addr_t which caused 64bit problemos. We really shouldn't define
+  that on two different places.
 
-- Haven't done this big changes to curl for a while. Moved around a lot of
-  struct fields and stuff to make multiple connections get connection specific
-  data in separate structs so that they can co-exist in a nice way. See the
-  mailing lists for discussions around how this is gonna be implemented. Docs
-  and more will follow.
+Daniel (18 February 2002)
+- Philip Gladstone found a problem in how HTTP requests were sent if the
+  request couldn't be sent all at once.
 
-  Studied the HTTP RFC to find out better how persistent connections should
-  work. Seems cool enough.
+- Emil found and corrected a bad connection timeout comparison that made curl
+  use the longest of connect-timeout and timout as a timeout value, instead of
+  the shortest as it was supposed to!
 
-Daniel (19 February 2001)
-- Bob Schader brought me two files that help set up a MS VC++ libcurl project
-  easier. He also provided me with an up-to-date libcurl.def file.
+- Aron Roberts provided updated information about LDAP URL syntax to go into
+  the manual as a replacement for the old references.
 
-- I moved a bunch of prototypes from the public <curl/curl.h> file to the
-  library private urldata.h. This is because of the upcoming changes. The
-  low level interface is no longer being planned to become reality.
+Daniel (17 February 2002)
+- Philip Gladstone pointed out two missing include files that made curl core
+  dump on 64bit architectures. We need to pay more attention on these details.
+  It is *lethal* to for example forget the malloc() prototype, as 'int' is
+  32bit and malloc() must return a 64bit pointer on these platforms.
 
-Daniel (15 February 2001)
-- CURLOPT_POST is not required anymore. Just setting the POST string with
-  CURLOPT_POSTFIELDS will switch on the HTTP POST. Most other things in
-  libcurl already works this way, i.e they require only the parameter to
-  switch on a feature so I think this works well with the rest. Setting a NULL
-  string switches off the POST again.
+- Giaslas Georgios fixed a problem with Host: headers on repeated requests on
+  the same handle using a proxy.
 
-- Excellent suggestions from Rich Gray, Rick Jones, Johan Nilsson and Bjorn
-  Reese helped me define a way how to incorporate persistent connections into
-  libcurl in a very smooth way. If done right, no change may have to be made
-  to older programs and they will just start using persistent connections when
-  applicable!
+Daniel (8 February 2002)
+- Hanno L. Kranzhoff accurately found out that disabling the Expect: header
+  when doing multipart formposts didn't work very well. It disabled other
+  parts of the request header too, resulting in a broken header. When I fixed
+  this, I also noticed that the Content-Type wasn't possible to disable. It is
+  now, even though it probably is really stupid to try to do this (because of
+  the boundary string that is included in the internally generated header,
+  used as form part separator.)
 
-Daniel (13 February 2001)
-- Changed the word 'timeouted' to 'timed out' in two different error messages.
-  Suggested by Larry Fahnoe.
+Daniel (7 February 2002)
+- I moved the config*.h files from the root directory to the lib/ directory.
 
-Version 7.6.1
+- I've added the new test suite HTTP server to the CVS repository, It seems to
+  work pretty good now, but we must make it get used by the test scripts
+  properly and then we need to make sure that it compiles, builds and runs on
+  most operating systems.
 
-Daniel (9 February 2001)
-- Frank Reid and Cain Hopwood provided information and research around a HTTPS
-  PUT/upload problem we seem to have. No solution found yet.
+Version 7.9.5-pre1
 
-Daniel (8 February 2001)
-- An interesting discussion is how to specify an empty password without having
-  curl ask for it interactively? The current implmentation takes an empty
-  password as a request for a password prompt. However, I still want to
-  support a blank user field. Thus, today if you enter "-u :" (without user
-  and password) curl will prompt for the password. Tricky. How would you
-  specify you want the prompt otherwise?
+Daniel (6 February 2002)
+- Miklos Nemeth provided updated windows makefiles and INSTALL docs.
 
-- Made the netrc parse result possible to use for other protocols than FTP and
-  HTTP (such as the upcoming TELNET fixes).
+- Mr Larry Fahnoe found a problem with formposts and I managed to track down
+  and patch this bug. This was actually two bugs, as the posted size was also
+  said to be two bytes too large.
 
-- The previously mentioned "MSVC++ problems" turned out to be a non-issue.
+- Brent Beardsley found out and brought a correction for the
+  CURLINFO_CONTENT_TYPE parser that was off one byte. This was my fault, I
+  accidentaly broke Giaslas Georgios' patch.
 
-- Added a HTTP file upload code example in the docs/examples/ section on
-  request.
+Daniel (5 February 2002)
+- Kevin Roth found yet another SSL download problem.
 
-- Adjusted the FTP response fix slightly.
+Version 7.9.4
 
-Version 7.6.1-pre3
+- no changes since pre-release
 
-Daniel (7 February 2001)
-- S. Moonesamy found a flaw in the response reading function for FTP that
-  could make libcurl not get out of the loop properly when it should, if
-  libcurl got -1 returned when reading the socket.
+Version 7.9.4-pre2
 
-- I found a similar mistake in http.c when using a proxy and reading the
-  results from the proxy connection.
+Daniel (3 February 2002)
+- Eric Melville provided a few spelling corrections in the curl man page.
 
-Daniel (6 February 2001)
-- S. Moonesamy pointed out that the VC makefile in src/ needed the libpath set
-  for the debug build to work.
+Daniel (1 February 2002)
+- Andreas Damm corrected the unconditional use of gmtime() in getdate, it now
+  uses gmtime_r() on all hosts that have it.
 
-- Daniel Gehriger stepped in to assist with the VC++ stuff Robert Weaver
-  brought up yesterday.
+Daniel (31 January 2002)
+- An anonymous bug report identified a problem in the DNS caching which made it
+  sometimes allocate one byte too little to store the cache entry in. This
+  happened when the port number started with 1!
 
-Daniel (5 February 2001)
-- Jun-ichiro itojun Hagino brought a big patch that brings IPv6-awareness to
-  a bunch of different areas within libcurl.
+- Albert Chin provided a patch that improves the gethostbyname_r() configure
+  check on HP-UX 11.00.
 
-- Robert Weaver told me about the problems the MS VC++ 6.0 compiler has with
-  the 'static' keyword on a number of libcurl functions. I might need to add a
-  patch that redefines static when libcurl is compiled with that compiler.
-  How do I know when VC++ compiles, anyone?
+Version 7.9.4-pre1
 
-Daniel (4 February 2001)
-- curl_getinfo() was extended with two new options:
-  CURLINFO_CONTENT_LENGTH_DOWNLOAD and CURLINFO_CONTENT_LENGTH_UPLOAD. They
-  return the full assumed content length of the transfer in the given
-  direction. The CURLINFO_CONTENT_LENGTH_DOWNLOAD will be the Content-Length:
-  size of a HTTP download. Added descriptions to the man page as well. This
-  was done after discussions with Bob Schader.
+Daniel (30 January 2002)
+- Georg Horn found another way the SSL reading failed due to the non-blocking
+  state of the sockets! I fixed.
 
-Daniel (3 February 2001)
-- Ingo Ralf Blum provided another fix that makes curl build under the more
-  recent cygwin installations. It seems they've changed the preset defines to
-  not include WIN32 anymore.
+Daniel (29 January 2002)
+- Multipart formposts now send the full request properly, including the CRLF.
+  They were previously treated as part of the post data.
 
-Version 7.6.1-pre2
+- The upload byte counter bugged.
 
-Daniel (31 January 2001)
-- Curl_read() and curl_read() now return a ssize_t for the size, as it had to
-  be able to return -1. The telnet support crashed due to this and there was a
-  possibility to weird behavior all over. Linus Nielsen Feltzing helped me
-  find this.
+- T. Bharath pointed out that we seed SSL on every connect, which is a time-
+  consuming operation that should only be needed to do once. We patched
+  libcurl to now only seed on the first connect when unseeded. The seeded
+  status is global so it'll now only happen once during a program's life time.
 
-- Added a configure.in check for a working getaddrinfo() if IPv6 is requested.
-  I also made the configure script feature --enable-debug which sets a couple
-  of compiler options when used. It assumes gcc.
+  If the random_file or egdsocket is set, the seed will be re-made though.
 
-Daniel (30 January 2001)
-- I finally took a stab at the long-term FIXME item I've had on myself, and
-  now libcurl will properly work when doing a HTTP range-request that follows
-  a Location:. Previously that would make libcurl fail saying that the server
-  doesn't seem to support range requests.
+- Giaslas Georgios introduced CURLINFO_CONTENT_TYPE that lets
+  curl_easy_getinfo() read the content-type from the previous request.
 
-Daniel (29 January 2001)
-- I added a test case for the HTTP PUT resume thing (test case 33).
+Daniel (28 January 2002)
+- Kjetil Jacobsen found a way to crash curl and after much debugging, it
+  turned out it was a IPv4-linux only problem introduced in 7.9.3 related to
+  name resolving.
 
-Version 7.6.1-pre1
+- Andreas Damm posted a huge patch that made the curl_getdate() function fully
+  reentrant!
 
-Daniel (29 January 2001)
-- Yet another Content-Range change. Ok now? Bob Schader checks from his end 
-  and it works for him.
+- Steve Marx pointed out that you couldn't mix CURLOPT_CUSTOMREQUEST with
+  CURLOPT_POSTFIELDS. You can now!
 
-Daniel (27 January 2001)
-- So the HTTP PUT resume fix wasn't good. There should appearantly be a
-  Content-Range header when resuming a PUT.
+Daniel (25 January 2002)
+- Krishnendu Majumdar pointed out that the header length counter was not reset
+  between multiple requests on the same handle.
 
-- I noticed I broke the download-check that verifies that a resumed HTTP
-  download is actually resumed. It got broke because my new 'httpreq' field
-  in the main curl struct. I should get slapped. I added a test case for
-  this now, so I won't be able to ruin this again without noticing.
+- Pedro Neves rightfully questioned why curl always append \r\n to the data
+  that is sent in HTTP POST requests. Unfortunately, this broke the test suite
+  as the test HTTP server is lame enough not to deal with this... :-O
 
-- Added a test case for content-length verifying when downloading HTTP.
+- Following Location: headers when the connection didn't close didn't work as
+  libcurl didn't properly stop reading. This problem was added in 7.9.3 due to
+  the restructured internals. 'Frank' posted a bug report about this.
 
-- Made the progress meter title say if the transfer is being transfered. It
-  makes the output slightly better for resumes.
+Daniel (24 January 2002)
+- Kevin Roth very quickly spotted that we wrongly installed the example
+  programs that were built in the multi directory, when 'make install' was
+  used. :-/
 
-- When dealing with Location: and HTTP return codes, libcurl will not attempt
-  to follow the spirit of RFC2616 better. It means that when POSTing to a
-  URL that is being following to a second place, the standard will judge on
-  what to do. All HTTP codes except 303 and 305 will cause curl to make a
-  second POST operation. 303 will make a GET and 305 is not yet supported.
+Version 7.9.3
 
-  I also wrote two test cases for this POST/GET/Location stuff.
+Daniel (23 January 2002)
+- Andrés García found a persistancy problem when doing HTTP HEAD, that made
+  curl "hang" until the connection was closed by the server. This problem has
+  been introduced in 7.9.3 due to internal rewrites, this was not present in
+  7.9.2.
 
-Version 7.6
+Version 7.9.3-pre4
 
-Daniel (26 January 2001)
-- Lots of mails back and forth with Bob Schader finally made me add a small
-  piece of code in the HTTP engine so that HTTP upload resume works. You can
-  now do an operation like 'curl -T file -C <offset> <URL>' and curl will PUT
-  the ending part of the file starting at given offet to the specified URL.
+Daniel (19 January 2002)
+- Antonio filed bug report #505514 and provided a fix! When doing multipart
+  formposts, libcurl would include an error text in the actual post if a
+  specified file wasn't found. This is not libcurl's job. Instead we add an
+  empty part.
 
-Version 7.6-pre4
+Daniel (18 January 2002)
+- Played around with stricter compiler warnings for gcc (when ./configure
+  --enable-debug is used) and changed some minor things to stop the warnings.
 
-Daniel (25 January 2001)
-- I took hold of Rick Jones' question why we don't use recv() and send() for
-  reading/writing to the sockets and I've now modified the sread() and
-  swrite() macros to use them instead. If nothing else, they could be tested
-  in the next beta-round coming right up.
+- Commented out the 'long long' and 'long double' checks in configure.in, as
+  we don't currently use them anyway and the code in lib/mprintf.c that use
+  them causes warnings.
 
-- Jeff Morrow found a problem with libcurl's usage of SSL_read() and supplied
-  his research results in how to fix this. It turns out we have to invoke the
-  function several times in some cases. The same goes for the SSL_write().
+- Saul Good and jonatan pointed out Mac OS X build problems with pre3 and how
+  to correct them. Two compiler warnings were removed as well.
 
-  I made some rather drastic changes all over libcurl to make all writes and
-  reads get done on one single place so that this repeated-attempts thing
-  would only have to be implemented at one point.
+- Andrés García fixed two minor mingw32 building problems.
 
-- Rick Jones spotted that the 'total time' counter really didn't measure the
-  total time very accurate on subsecond levels.
+Version 7.9.3-pre3
 
-- Johan Nilsson pointed out the need to more clearly specify that the timeout
-  value you set for a download is for the *entire* download. There's currently
-  no option available that sets a timeout for the connection phase only.
+Daniel (17 January 2002)
+- docs/libcurl-the-guide is a new tutorial for our libcurl programming
+  friends.
 
-Daniel (24 January 2001)
-- Ingo Ralf Blum submitted a series of patches required to get curl to compile
-  properly with cygwin.
+- Richard Archer brought back the ability to compile and build with OpenSSL
+  versions before 0.9.5.
+  [http://sourceforge.net/tracker/?func=detail&atid=100976&aid=504163&group_id=976]
 
-- Robert Weaver posted a fix for the win32 section of the curl_getenv() code
-  that corrected a potential memory leak.
+- The DNS cache code didn't take the port number into account, which made it
+  work rather bad on IPv6-enabled hosts (especially when doing passive
+  FTP). Sterling fixed it.
 
-- Added comments in a few files in a sudden attempt to make the sources more
-  easy to read and understand!
+Daniel (16 January 2002)
+- Georg Horn could make a transfer time-out without error text. I found it and
+  corrected it.
 
-Daniel (23 January 2001)
-- Added simple IPv6 detection in the configure script and made the version
-  string add 'ipv6' to the enable section in that case. ENABLE_IPV6 will be
-  set if curl is compiled with IPv6 support enabled.
+- SSL writes didn't work, they return an uninitialized value that caused
+  havoc all over. Georg Horn experienced this.
 
-- Added a parser for IPv6-style specified IP-addresses in a URL. Thus, when
-  IPv6 gets enabled soon, we can use URLs like '[0::1]:80'...
+- Kevin Roth patched the curl_version() function to use the proper OpenSSL
+  function for version information. This way, curl will report the version of
+  the SSL library actually running right now, not the one that had its headers
+  installed when libcurl was built. Mainly intersting when running with shared
+  OpenSSL libraries.  
 
-- Made the URL globbing in the client possible to fail silently if there's an
-  error in the globbing. It makes it almost intuitive, so when you don't
-  follow the syntax rules, globbing is simply switched off and the raw string
-  is used instead.
+Version 7.9.3-pre2
 
-  I still think we'll get problems with IPv6-style IP-addresses when we *want*
-  globbing on parts of the URL as the initial part of the URL will for sure
-  seriously confuse the globber.
+Daniel (16 January 2002)
+- Mofied the main transfer loop and related stuff to deal with non-blocking
+  sockets in the upload section. While doing this, I've now separated the
+  connection oriented buffers to have one for downloads and one for uploads
+  (as two can happen simultaneously). I also shrunk the buffers to 20K
+  each. As we have a scratch buffer twice the size of the upload buffer, we
+  arrived at 80K for buffers compared with the previous 150K.
 
-Daniel (22 January 2001)
-- Björn Stenberg supplied a progress meter patch that makes it look better even
-  during slow starts. Previously it made some silly assumptions...
+- Added the --cc option to curl-config command as it enables so very cool
+  one-liners. Have a go a this one, building the simple.c example:
 
-- Added two FTP tests for -Q and -Q - stuff since it was being discussed on
-  the mailing list. Had to correct the ftpserver.pl too as it bugged slightly.
+        $ `curl-config --cc --cflags --libs` -o example simple.c
 
-Daniel (19 January 2001)
-- Made the Location: parsers deal with any-length URLs. Thus I removed the last
-  code that restricts the length of URLs that curl supports.
+Daniel (14 January 2002)
+- I made all socket reads (recv) handle EWOULDBLOCK. I hope nicely. Now we
+  only need to address all writes (send) too and then I'm ready for another
+  pre-release...
 
-- Added a --globoff test case (#28) and it quickly identified a memory problem
-  in src/main.c that I took care of.
+- Stoned Elipot patched the in_addr_t configure test to make it work better on
+  more platforms.
 
-Version 7.6-pre3
+Daniel (9 January 2002)
+- Cris Bailiff found out that filling up curl's SSL session cache caused a
+  crash!
 
-Daniel (17 January 2001)
-- Made the two former files lib/download.c and lib/highlevel.c become the new
-  lib/transfer.c which makes more sense. I also did the rename from Transfer()
-  to Curl_Transfer() in the other source files that use the transfer function
-  in the spirit of using Curl_ prefix for library-scoped global symbols.
+- Posted the curl questionnaire on the web site. If you haven't posted your
+  opinions there yet, go there and do it now while it is still there:
 
-Daniel (11 January 2001)
-- Added -g/--globoff that switches OFF the URL globbing and thus enables {}[]
-  letters to be part of the URL. Do note that RFC2396 section 2.4.3 explicitly
-  mention these letters to be escaped. This was posted as a feature request by
-  Jorge Gutierrez and as a bug by Terry.
+        http://curl.haxx.se/q/
 
-- Short options to curl that requires parameters can now be specified without
-  having the option and its parameter space separated. -ofile works as good as
-  -o file. -m20 is equal to -m 20. Do note that this goes for single-letter
-  options only, verbose --long-style options still must be separated with
-  space from their parameters.
+- Georg Horn quickly found out that the SSL reading no longer worked as
+  supposed since the switch to non-blocking sockets. I've made a quick patch
+  (for reading only) but we should improve it even further.
 
-Daniel (8 January 2001)
-- Francis Dagenais reported that the SCO compiler still fails when compiling
-  curl due to that getpass_r() prototype. I've now put it around #ifndef
-  HAVE_GETPASS_R in an attempt to please the SCO systems.
+Version 7.9.3-pre1
 
-- Made some minor corrections to get the client to cleanup properly and I made
-  the separator work again when getting multiple globbed URLs to stdout.
+Daniel (7 January 2002)
+- I made the 'bool' typedef use an "unsigned char". It makes it the same on
+  all platforms, no matter what the platform thinks the default format for
+  char is. This was noticed since we made a silly comparison involving such a
+  bool variable, and only one compiler/platform combination (on Debian Linux)
+  complained about it (that happened to have its char unsigned by default).
 
-- Worked with Loic Dachary to get the make dist and make distcheck work
-  correctly. The 'maketgz' script is now using the automake generated 'make
-  dist' when creating release archives. Loic successfully made 'make rpms'
-  automatically build RPMs!
+- Bug report #495290 identified a cookie parsing problem that was corrected.
+  When a Set-Cookie: line is received without a trailing semicolon, libcurl
+  didn't read the last "name=value" pair of the line, leading to confusions...
 
-Loic Dachary (6 January 2001)
-- Automated generation of rpm packages, no need to be root.
+- Sterling committed his updated DNS cache code.
 
-- make distcheck generates a proper distribution (EXTRA_DIST
-  in all Makefile.am modified to match FILES).
+- I worked with Georg Horn and comments from Götz Babin-Ebell and switched
+  curl's socket operations completely over to non-blocking for the entire
+  operation (previously we used non-blocking only for the connection phase).
+  We had to do this to make the SSL connection phase timeout properly without
+  the use of signals. A little extra code to deal with this was added.
 
-Daniel (5 January 2001)
-- Huge client-side hack: now multiple URLs are supported. Any number of URLs
-  can be specified on the command line, and they'll all be downloaded. There
-  must be a corresponding -o or -O for each URL or the data will be written to
-  stdout. This needs more testing, time to release a 7.6-pre package.
+- T. Bharath pointed out a slightly obscure cookie engine flaw.
 
-- The krb4 support was broken in the release. Fixed now.
+- Pete Su pointed out that libcurl didn't treat HTTP code 204 as it should.
+  204-replies never provides a response-body. This resulted in bad persistant
+  behavior when 204 was received.
 
-- Huge internal symbol rename operation. All non-static but still lib-internal
-  symbols should now be prefixed with 'Curl_' to prevent collisions with other
-  libs. All public symbols should be prefixed with 'curl_' and the rest should
-  be static and thus invisible to the outside world. I updated the INTERNALS
-  document to say this as well.
+Daniel (5 January 2002)
+- SM updated the VC++ library Makefiles for the new source files.
 
-Version 7.5.2
+Daniel (4 January 2002)
+- I discovered that we wrongly used inet_ntoa() (instead of inet_ntoa_r() in
+  two places in the source code). One happened with VERBOSE set on connects,
+  and the other when VERBOSE was on and krb4 over nat was used... I honestly
+  don't think anyone has suffered from these mistakes.
 
-Daniel (4 January 2001)
-- As Kevin P Roth suggested, I've added text to the man page for every command
-  line option and what happens when you specify that option more than
-  once. That hasn't been exactly crystal clear before.
+- I replaced a lot of silly occurances of printf() to instead use the more
+  appropriate Curl_infof() or Curl_failf(). The krb4 and telnet code were
+  affected.
 
-- Made the configure script possible to run from outside the source-tree. For
-  odd reasons I can't build curl properly outside though. It has to do with
-  curl's dependencies on libcurl...
+- Philip Gladstone found a few more problems with 64-bit archs (the 64-bit
+  sparc on solaris 8).
 
-- Cut off all older (dated 1999 and earlier) CHANGES entries from this file.
-  The older piece is named CHANGES.0 and is added to the CVS repository in
-  case anyone would need it.
+- After discussions on the libcurl list with Raoul Cridlig, I just made FTP
+  response lines get passed to the header callback if such a one is
+  registered. It'll make it possible for any application to get all the
+  responses an FTP server sends to libcurl.
 
-- I added another file 'CVS-INFO' to the CVS. It contains information about
-  files in the CVS that aren't included in release archives and how to build
-  curl when you get the sources off CVS.
+Daniel (3 January 2002)
+- Sterling Hughes brought a few buckets of code. Now, libcurl will
+  automatically cache DNS lookups and re-use the previous results first if any
+  such is available. It greatly improves speed when doing many repeated
+  operations to the same host.
 
-- Updated CONTRIBUTE and FAQ due to the new license.
+- As the test case uses --include and then --head, I had to modify src/main.c
+  to deal with this situation slightly better than previously. When done, we
+  have 100% good tests again in the main branch.
 
-Daniel (3 January 2001)
-- Renamed README.libcurl to LIBCURL
+Daniel (2 January 2002)
+- Made test case 25 run again in the multi-dev branch. But it seems that the
+  changes done on dec-20 made test case 104 cease to work (in both branches).
 
-- Changed headers in all sources files to the new dual license concept of
-  curl: use the MIT/X derivate license *or* MPL. The LEGAL file was updated
-  accordingly and the MPL 1.1 and MIT/X derivate licenses are now part of the
-  release archive.
+- Philip Gladstone pointed out a few portability problems in the source code
+  that didn't compile on 64-bit sparcs using Sun's native 
\ No newline at end of file
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9: config.h.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9: config-riscos.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/configure	2001-09-17 14:07:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/configure	2002-06-11 23:16:54.000000000 +0800
@@ -832,17 +832,33 @@
   --enable-dependency-tracking  Do not reject slow dependency extractors
   --disable-largefile     omit support for large files
   --enable-shared=PKGS  build shared libraries default=yes
   --enable-static=PKGS  build static libraries default=yes
   --enable-fast-install=PKGS  optimize for fast installation default=yes
   --disable-libtool-lock  avoid locking (might break parallel builds)
-  --enable-debug		Enable pedantic debug options
-  --disable-debug		Disable debug options
+  --enable-http		Enable HTTP support
+  --disable-http	Disable HTTP support
+  --enable-ftp		Enable FTP support
+  --disable-ftp	Disable FTP support
+  --enable-gopher		Enable GOPHER support
+  --disable-gopher	Disable GOPHER support
+  --enable-file		Enable FILE support
+  --disable-file	Disable FILE support
+  --enable-ldap		Enable LDAP support
+  --disable-ldap	Disable LDAP support
+  --enable-dict		Enable DICT support
+  --disable-dict	Disable DICT support
+  --enable-telnet		Enable TELNET support
+  --disable-telnet	Disable TELNET support
   --enable-ipv6		Enable ipv6 (with ipv4) support
-  --disable-ipv6		Disable ipv6 support
+  --disable-ipv6	Disable ipv6 support
+  --enable-nonblocking  Makes the script detect how to do it
+  --disable-nonblocking Makes the script disable non-blocking sockets
   --disable-thread       tell configure to not look for thread-safe functions
+  --enable-debug	Enable pedantic debug options
+  --disable-debug	Disable debug options
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-gnu-ld           assume the C compiler uses GNU ld default=no
   --with-pic              try to use only PIC/non-PIC objects default=use both
@@ -1043,32 +1059,32 @@
   else
     CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
   fi
 fi
 for ac_site_file in $CONFIG_SITE; do
   if test -r "$ac_site_file"; then
-    { echo "$as_me:1049: loading site script $ac_site_file" >&5
+    { echo "$as_me:1065: loading site script $ac_site_file" >&5
 echo "$as_me: loading site script $ac_site_file" >&6;}
     cat "$ac_site_file" >&5
     . "$ac_site_file"
   fi
 done
 
 if test -r "$cache_file"; then
   # Some versions of bash will fail to source /dev/null (special
   # files actually), so we avoid doing that.
   if test -f "$cache_file"; then
-    { echo "$as_me:1060: loading cache $cache_file" >&5
+    { echo "$as_me:1076: loading cache $cache_file" >&5
 echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
       [\\/]* | ?:[\\/]* ) . $cache_file;;
       *)                      . ./$cache_file;;
     esac
   fi
 else
-  { echo "$as_me:1068: creating cache $cache_file" >&5
+  { echo "$as_me:1084: creating cache $cache_file" >&5
 echo "$as_me: creating cache $cache_file" >&6;}
   >$cache_file
 fi
 
 # Check that the precious variables saved in the cache have kept the same
 # value.
@@ -1078,27 +1094,27 @@
   eval ac_old_set=\$ac_cv_env_${ac_var}_set
   eval ac_new_set=\$ac_env_${ac_var}_set
   eval ac_old_val="\$ac_cv_env_${ac_var}_value"
   eval ac_new_val="\$ac_env_${ac_var}_value"
   case $ac_old_set,$ac_new_set in
     set,)
-      { echo "$as_me:1084: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+      { echo "$as_me:1100: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
 echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,set)
-      { echo "$as_me:1088: error: \`$ac_var' was not set in the previous run" >&5
+      { echo "$as_me:1104: error: \`$ac_var' was not set in the previous run" >&5
 echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
       ac_cache_corrupted=: ;;
     ,);;
     *)
       if test "x$ac_old_val" != "x$ac_new_val"; then
-        { echo "$as_me:1094: error: \`$ac_var' has changed since the previous run:" >&5
+        { echo "$as_me:1110: error: \`$ac_var' has changed since the previous run:" >&5
 echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-        { echo "$as_me:1096:   former value:  $ac_old_val" >&5
+        { echo "$as_me:1112:   former value:  $ac_old_val" >&5
 echo "$as_me:   former value:  $ac_old_val" >&2;}
-        { echo "$as_me:1098:   current value: $ac_new_val" >&5
+        { echo "$as_me:1114:   current value: $ac_new_val" >&5
 echo "$as_me:   current value: $ac_new_val" >&2;}
         ac_cache_corrupted=:
       fi;;
   esac
   # Pass precious variables to config.status.  It doesn't matter if
   # we pass some twice (in addition to the command line arguments).
@@ -1111,15 +1127,15 @@
     *) ac_configure_args="$ac_configure_args $ac_var=$ac_new_val"
        ;;
     esac
   fi
 done
 if $ac_cache_corrupted; then
-  { echo "$as_me:1117: error: changes in the environment can compromise the build" >&5
+  { echo "$as_me:1133: error: changes in the environment can compromise the build" >&5
 echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  { { echo "$as_me:1119: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
+  { { echo "$as_me:1135: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
 echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -1133,28 +1149,30 @@
   *c*,*  ) ECHO_N=-n ECHO_C= ECHO_T= ;;
   *)      ECHO_N= ECHO_C='\c' ECHO_T= ;;
 esac
 echo "#! $SHELL" >conftest.sh
 echo  "exit 0"   >>conftest.sh
 chmod +x conftest.sh
-if { (echo "$as_me:1139: PATH=\".;.\"; conftest.sh") >&5
+if { (echo "$as_me:1155: PATH=\".;.\"; conftest.sh") >&5
   (PATH=".;."; conftest.sh) 2>&5
   ac_status=$?
-  echo "$as_me:1142: \$? = $ac_status" >&5
+  echo "$as_me:1158: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   ac_path_separator=';'
 else
   ac_path_separator=:
 fi
 PATH_SEPARATOR="$ac_path_separator"
 rm -f conftest.sh
 
-		    		    		    ac_config_headers="$ac_config_headers config.h"
+		    		    		    ac_config_headers="$ac_config_headers lib/config.h"
 
 		    		    		    ac_config_headers="$ac_config_headers src/config.h"
 
+		    		    		    ac_config_headers="$ac_config_headers tests/server/config.h"
+
 VERSION=`sed -ne 's/^#define LIBCURL_VERSION "\(.*\)"/\1/p' ${srcdir}/include/curl/curl.h`
 ac_aux_dir=
 for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
   if test -f $ac_dir/install-sh; then
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/install-sh -c"
@@ -1167,13 +1185,13 @@
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/shtool install -c"
     break
   fi
 done
 if test -z "$ac_aux_dir"; then
-  { { echo "$as_me:1173: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
+  { { echo "$as_me:1191: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&5
 echo "$as_me: error: cannot find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." >&2;}
    { (exit 1); exit 1; }; }
 fi
 ac_config_guess="$SHELL $ac_aux_dir/config.guess"
 ac_config_sub="$SHELL $ac_aux_dir/config.sub"
 ac_configure="$SHELL $ac_aux_dir/configure" # This should be Cygnus configure.
@@ -1187,13 +1205,13 @@
 # AIX /bin/install
 # AmigaOS /C/install, which installs bootblocks on floppy discs
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
-echo "$as_me:1193: checking for a BSD compatible install" >&5
+echo "$as_me:1211: checking for a BSD compatible install" >&5
 echo $ECHO_N "checking for a BSD compatible install... $ECHO_C" >&6
 if test -z "$INSTALL"; then
 if test "${ac_cv_path_install+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
     ac_save_IFS=$IFS; IFS=$ac_path_separator
@@ -1236,24 +1254,24 @@
     # path for INSTALL within a source directory, because that will
     # break other packages using the cache if that directory is
     # removed, or if the path is relative.
     INSTALL=$ac_install_sh
   fi
 fi
-echo "$as_me:1242: result: $INSTALL" >&5
+echo "$as_me:1260: result: $INSTALL" >&5
 echo "${ECHO_T}$INSTALL" >&6
 
 # Use test -z because SunOS4 sh mishandles braces in ${var-val}.
 # It thinks the first close brace ends the variable substitution.
 test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
 
 test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
-echo "$as_me:1253: checking whether build environment is sane" >&5
+echo "$as_me:1271: checking whether build environment is sane" >&5
 echo $ECHO_N "checking whether build environment is sane... $ECHO_C" >&6
 # Just in case
 sleep 1
 echo timestamp > conftest.file
 # Do `set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
@@ -1271,32 +1289,32 @@
       && test "$*" != "X conftest.file $srcdir/configure"; then
 
       # If neither matched, then we have a broken ls.  This can happen
       # if, for instance, CONFIG_SHELL is bash and it inherits a
       # broken ls alias from the environment.  This has actually
       # happened.  Such a system could not be considered "sane".
-      { { echo "$as_me:1277: error: ls -t appears to fail.  Make sure there is not a broken
+      { { echo "$as_me:1295: error: ls -t appears to fail.  Make sure there is not a broken
 alias in your environment" >&5
 echo "$as_me: error: ls -t appears to fail.  Make sure there is not a broken
 alias in your environment" >&2;}
    { (exit 1); exit 1; }; }
    fi
 
    test "$2" = conftest.file
    )
 then
    # Ok.
    :
 else
-   { { echo "$as_me:1290: error: newly created file is older than distributed files!
+   { { echo "$as_me:1308: error: newly created file is older than distributed files!
 Check your system clock" >&5
 echo "$as_me: error: newly created file is older than distributed files!
 Check your system clock" >&2;}
    { (exit 1); exit 1; }; }
 fi
-echo "$as_me:1296: result: yes" >&5
+echo "$as_me:1314: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 test "$program_prefix" != NONE &&
   program_transform_name="s,^,$program_prefix,;$program_transform_name"
 # Use a double $ so make ignores it.
 test "$program_suffix" != NONE &&
   program_transform_name="s,\$,$program_suffix,;$program_transform_name"
@@ -1315,21 +1333,21 @@
 # Use eval to expand $SHELL
 if eval "$MISSING --run true"; then
   am_missing_run="$MISSING --run "
 else
   am_missing_run=
   am_backtick='`'
-  { echo "$as_me:1321: WARNING: ${am_backtick}missing' script is too old or missing" >&5
+  { echo "$as_me:1339: WARNING: ${am_backtick}missing' script is too old or missing" >&5
 echo "$as_me: WARNING: ${am_backtick}missing' script is too old or missing" >&2;}
 fi
 
 for ac_prog in mawk gawk nawk awk
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-echo "$as_me:1329: checking for $ac_word" >&5
+echo "$as_me:1347: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_AWK+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$AWK"; then
   ac_cv_prog_AWK="$AWK" # Let the user override the test.
@@ -1338,31 +1356,31 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_AWK="$ac_prog"
-echo "$as_me:1344: found $ac_dir/$ac_word" >&5
+echo "$as_me:1362: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 AWK=$ac_cv_prog_AWK
 if test -n "$AWK"; then
-  echo "$as_me:1352: result: $AWK" >&5
+  echo "$as_me:1370: result: $AWK" >&5
 echo "${ECHO_T}$AWK" >&6
 else
-  echo "$as_me:1355: result: no" >&5
+  echo "$as_me:1373: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   test -n "$AWK" && break
 done
 
-echo "$as_me:1362: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "$as_me:1380: checking whether ${MAKE-make} sets \${MAKE}" >&5
 echo $ECHO_N "checking whether ${MAKE-make} sets \${MAKE}... $ECHO_C" >&6
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,./+-,__p_,'`
 if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.make <<\EOF
@@ -1376,17 +1394,17 @@
 else
   eval ac_cv_prog_make_${ac_make}_set=no
 fi
 rm -f conftest.make
 fi
 if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
-  echo "$as_me:1382: result: yes" >&5
+  echo "$as_me:1400: result: yes" >&5
 echo "${ECHO_T}yes" >&6
   SET_MAKE=
 else
-  echo "$as_me:1386: result: no" >&5
+  echo "$as_me:1404: result: no" >&5
 echo "${ECHO_T}no" >&6
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
 # Check whether --enable-dependency-tracking or --disable-dependency-tracking was given.
 if test "${enable_dependency_tracking+set}" = set; then
@@ -1416,13 +1434,13 @@
 fi
 rmdir .deps 2>/dev/null
 
 # test to see if srcdir already configured
 if test "`CDPATH=:; cd $srcdir && pwd`" != "`pwd`" &&
    test -f $srcdir/config.status; then
-  { { echo "$as_me:1422: error: source directory already configured; run \"make distclean\" there first" >&5
+  { { echo "$as_me:1440: error: source directory already configured; run \"make distclean\" there first" >&5
 echo "$as_me: error: source directory already configured; run \"make distclean\" there first" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 # Define the identity of the package.
 PACKAGE=curl
@@ -1473,56 +1491,56 @@
 PKGADD_PKG="HAXXcurl"
 PKGADD_NAME="cURL - a client that groks URLs"
 PKGADD_VENDOR="curl.haxx.se"
 
 # Make sure we can run config.sub.
 $ac_config_sub sun4 >/dev/null 2>&1 ||
-  { { echo "$as_me:1479: error: cannot run $ac_config_sub" >&5
+  { { echo "$as_me:1497: error: cannot run $ac_config_sub" >&5
 echo "$as_me: error: cannot run $ac_config_sub" >&2;}
    { (exit 1); exit 1; }; }
 
-echo "$as_me:1483: checking build system type" >&5
+echo "$as_me:1501: checking build system type" >&5
 echo $ECHO_N "checking build system type... $ECHO_C" >&6
 if test "${ac_cv_build+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_build_alias=$build_alias
 test -z "$ac_cv_build_alias" &&
   ac_cv_build_alias=`$ac_config_guess`
 test -z "$ac_cv_build_alias" &&
-  { { echo "$as_me:1492: error: cannot guess build type; you must specify one" >&5
+  { { echo "$as_me:1510: error: cannot guess build type; you must specify one" >&5
 echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
    { (exit 1); exit 1; }; }
 ac_cv_build=`$ac_config_sub $ac_cv_build_alias` ||
-  { { echo "$as_me:1496: error: $ac_config_sub $ac_cv_build_alias failed." >&5
+  { { echo "$as_me:1514: error: $ac_config_sub $ac_cv_build_alias failed." >&5
 echo "$as_me: error: $ac_config_sub $ac_cv_build_alias failed." >&2;}
    { (exit 1); exit 1; }; }
 
 fi
-echo "$as_me:1501: result: $ac_cv_build" >&5
+echo "$as_me:1519: result: $ac_cv_build" >&5
 echo "${ECHO_T}$ac_cv_build" >&6
 build=$ac_cv_build
 build_cpu=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 build_vendor=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 build_os=`echo $ac_cv_build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 
-echo "$as_me:1508: checking host system type" >&5
+echo "$as_me:1526: checking host system type" >&5
 echo $ECHO_N "checking host system type... $ECHO_C" >&6
 if test "${ac_cv_host+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_host_alias=$host_alias
 test -z "$ac_cv_host_alias" &&
   ac_cv_host_alias=$ac_cv_build_alias
 ac_cv_host=`$ac_config_sub $ac_cv_host_alias` ||
-  { { echo "$as_me:1517: error: $ac_config_sub $ac_cv_host_alias failed" >&5
+  { { echo "$as_me:1535: error: $ac_config_sub $ac_cv_host_alias failed" >&5
 echo "$as_me: error: $ac_config_sub $ac_cv_host_alias failed" >&2;}
    { (exit 1); exit 1; }; }
 
 fi
-echo "$as_me:1522: result: $ac_cv_host" >&5
+echo "$as_me:1540: result: $ac_cv_host" >&5
 echo "${ECHO_T}$ac_cv_host" >&6
 host=$ac_cv_host
 host_cpu=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 host_vendor=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 host_os=`echo $ac_cv_host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 
@@ -1535,13 +1553,13 @@
 am_make=${MAKE-make}
 cat > confinc << 'END'
 doit:
 	@echo done
 END
 # If we don't find an include directive, just comment out the code.
-echo "$as_me:1541: checking for style of include used by $am_make" >&5
+echo "$as_me:1559: checking for style of include used by $am_make" >&5
 echo $ECHO_N "checking for style of include used by $am_make... $ECHO_C" >&6
 am__include='#'
 am__quote=
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
@@ -1562,25 +1580,25 @@
       am__include=.include
       am__quote='"'
       _am_result=BSD
    fi
 fi
 
-echo "$as_me:1568: result: $_am_result" >&5
+echo "$as_me:1586: result: $_am_result" >&5
 echo "${ECHO_T}$_am_result" >&6
 rm -f confinc confmf
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-echo "$as_me:1580: checking for $ac_word" >&5
+echo "$as_me:1598: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1589,33 +1607,33 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_CC="${ac_tool_prefix}gcc"
-echo "$as_me:1595: found $ac_dir/$ac_word" >&5
+echo "$as_me:1613: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:1603: result: $CC" >&5
+  echo "$as_me:1621: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:1606: result: no" >&5
+  echo "$as_me:1624: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-echo "$as_me:1615: checking for $ac_word" >&5
+echo "$as_me:1633: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -1624,37 +1642,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_CC="gcc"
-echo "$as_me:1630: found $ac_dir/$ac_word" >&5
+echo "$as_me:1648: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  echo "$as_me:1638: result: $ac_ct_CC" >&5
+  echo "$as_me:1656: result: $ac_ct_CC" >&5
 echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  echo "$as_me:1641: result: no" >&5
+  echo "$as_me:1659: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   CC=$ac_ct_CC
 else
   CC="$ac_cv_prog_CC"
 fi
 
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-echo "$as_me:1654: checking for $ac_word" >&5
+echo "$as_me:1672: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1663,33 +1681,33 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_CC="${ac_tool_prefix}cc"
-echo "$as_me:1669: found $ac_dir/$ac_word" >&5
+echo "$as_me:1687: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:1677: result: $CC" >&5
+  echo "$as_me:1695: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:1680: result: no" >&5
+  echo "$as_me:1698: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-echo "$as_me:1689: checking for $ac_word" >&5
+echo "$as_me:1707: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -1698,37 +1716,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_CC="cc"
-echo "$as_me:1704: found $ac_dir/$ac_word" >&5
+echo "$as_me:1722: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  echo "$as_me:1712: result: $ac_ct_CC" >&5
+  echo "$as_me:1730: result: $ac_ct_CC" >&5
 echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  echo "$as_me:1715: result: no" >&5
+  echo "$as_me:1733: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   CC=$ac_ct_CC
 else
   CC="$ac_cv_prog_CC"
 fi
 
 fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-echo "$as_me:1728: checking for $ac_word" >&5
+echo "$as_me:1746: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1742,13 +1760,13 @@
   $as_executable_p "$ac_dir/$ac_word" || continue
 if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
   ac_prog_rejected=yes
   continue
 fi
 ac_cv_prog_CC="cc"
-echo "$as_me:1748: found $ac_dir/$ac_word" >&5
+echo "$as_me:1766: found $ac_dir/$ac_word" >&5
 break
 done
 
 if test $ac_prog_rejected = yes; then
   # We found a bogon in the path, so make sure we never use it.
   set dummy $ac_cv_prog_CC
@@ -1764,27 +1782,27 @@
   fi
 fi
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:1770: result: $CC" >&5
+  echo "$as_me:1788: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:1773: result: no" >&5
+  echo "$as_me:1791: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
   for ac_prog in cl
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-echo "$as_me:1784: checking for $ac_word" >&5
+echo "$as_me:1802: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -1793,37 +1811,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-echo "$as_me:1799: found $ac_dir/$ac_word" >&5
+echo "$as_me:1817: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:1807: result: $CC" >&5
+  echo "$as_me:1825: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:1810: result: no" >&5
+  echo "$as_me:1828: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
     test -n "$CC" && break
   done
 fi
 if test -z "$CC"; then
   ac_ct_CC=$CC
   for ac_prog in cl
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-echo "$as_me:1823: checking for $ac_word" >&5
+echo "$as_me:1841: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -1832,61 +1850,61 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_CC="$ac_prog"
-echo "$as_me:1838: found $ac_dir/$ac_word" >&5
+echo "$as_me:1856: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  echo "$as_me:1846: result: $ac_ct_CC" >&5
+  echo "$as_me:1864: result: $ac_ct_CC" >&5
 echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  echo "$as_me:1849: result: no" >&5
+  echo "$as_me:1867: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   test -n "$ac_ct_CC" && break
 done
 
   CC=$ac_ct_CC
 fi
 
 fi
 
-test -z "$CC" && { { echo "$as_me:1861: error: no acceptable cc found in \$PATH" >&5
+test -z "$CC" && { { echo "$as_me:1879: error: no acceptable cc found in \$PATH" >&5
 echo "$as_me: error: no acceptable cc found in \$PATH" >&2;}
    { (exit 1); exit 1; }; }
 
 # Provide some information about the compiler.
-echo "$as_me:1866:" \
+echo "$as_me:1884:" \
      "checking for C compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
-{ (eval echo "$as_me:1869: \"$ac_compiler --version </dev/null >&5\"") >&5
+{ (eval echo "$as_me:1887: \"$ac_compiler --version </dev/null >&5\"") >&5
   (eval $ac_compiler --version </dev/null >&5) 2>&5
   ac_status=$?
-  echo "$as_me:1872: \$? = $ac_status" >&5
+  echo "$as_me:1890: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (eval echo "$as_me:1874: \"$ac_compiler -v </dev/null >&5\"") >&5
+{ (eval echo "$as_me:1892: \"$ac_compiler -v </dev/null >&5\"") >&5
   (eval $ac_compiler -v </dev/null >&5) 2>&5
   ac_status=$?
-  echo "$as_me:1877: \$? = $ac_status" >&5
+  echo "$as_me:1895: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (eval echo "$as_me:1879: \"$ac_compiler -V </dev/null >&5\"") >&5
+{ (eval echo "$as_me:1897: \"$ac_compiler -V </dev/null >&5\"") >&5
   (eval $ac_compiler -V </dev/null >&5) 2>&5
   ac_status=$?
-  echo "$as_me:1882: \$? = $ac_status" >&5
+  echo "$as_me:1900: \$? = $ac_status" >&5
   (exit $ac_status); }
 
 cat >conftest.$ac_ext <<_ACEOF
-#line 1886 "configure"
+#line 1904 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
@@ -1896,19 +1914,19 @@
 _ACEOF
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files a.out a.exe"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-echo "$as_me:1902: checking for C compiler default output" >&5
+echo "$as_me:1920: checking for C compiler default output" >&5
 echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
 ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-if { (eval echo "$as_me:1905: \"$ac_link_default\"") >&5
+if { (eval echo "$as_me:1923: \"$ac_link_default\"") >&5
   (eval $ac_link_default) 2>&5
   ac_status=$?
-  echo "$as_me:1908: \$? = $ac_status" >&5
+  echo "$as_me:1926: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   # Find the output, starting from the most likely.  This scheme is
 # not robust to junk in `.', hence go to wildcards (a.*) only as a last
 # resort.
 for ac_file in `ls a.exe conftest.exe 2>/dev/null;
                 ls a.out conftest 2>/dev/null;
@@ -1925,65 +1943,65 @@
     * ) break;;
   esac
 done
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-{ { echo "$as_me:1931: error: C compiler cannot create executables" >&5
+{ { echo "$as_me:1949: error: C compiler cannot create executables" >&5
 echo "$as_me: error: C compiler cannot create executables" >&2;}
    { (exit 77); exit 77; }; }
 fi
 
 ac_exeext=$ac_cv_exeext
-echo "$as_me:1937: result: $ac_file" >&5
+echo "$as_me:1955: result: $ac_file" >&5
 echo "${ECHO_T}$ac_file" >&6
 
 # Check the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-echo "$as_me:1942: checking whether the C compiler works" >&5
+echo "$as_me:1960: checking whether the C compiler works" >&5
 echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6
 # FIXME: These cross compiler hacks should be removed for Autoconf 3.0
 # If not cross compiling, check that we can run a simple program.
 if test "$cross_compiling" != yes; then
   if { ac_try='./$ac_file'
-  { (eval echo "$as_me:1948: \"$ac_try\"") >&5
+  { (eval echo "$as_me:1966: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:1951: \$? = $ac_status" >&5
+  echo "$as_me:1969: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
     cross_compiling=no
   else
     if test "$cross_compiling" = maybe; then
 	cross_compiling=yes
     else
-	{ { echo "$as_me:1958: error: cannot run C compiled programs.
+	{ { echo "$as_me:1976: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'." >&5
 echo "$as_me: error: cannot run C compiled programs.
 If you meant to cross compile, use \`--host'." >&2;}
    { (exit 1); exit 1; }; }
     fi
   fi
 fi
-echo "$as_me:1966: result: yes" >&5
+echo "$as_me:1984: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 
 rm -f a.out a.exe conftest$ac_cv_exeext
 ac_clean_files=$ac_clean_files_save
 # Check the compiler produces executables we can run.  If not, either
 # the compiler is broken, or we cross compile.
-echo "$as_me:1973: checking whether we are cross compiling" >&5
+echo "$as_me:1991: checking whether we are cross compiling" >&5
 echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6
-echo "$as_me:1975: result: $cross_compiling" >&5
+echo "$as_me:1993: result: $cross_compiling" >&5
 echo "${ECHO_T}$cross_compiling" >&6
 
-echo "$as_me:1978: checking for executable suffix" >&5
+echo "$as_me:1996: checking for executable suffix" >&5
 echo $ECHO_N "checking for executable suffix... $ECHO_C" >&6
-if { (eval echo "$as_me:1980: \"$ac_link\"") >&5
+if { (eval echo "$as_me:1998: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:1983: \$? = $ac_status" >&5
+  echo "$as_me:2001: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   # If both `conftest.exe' and `conftest' are `present' (well, observable)
 # catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
 # work properly (i.e., refer to `conftest.exe'), while it won't with
 # `rm'.
 for ac_file in `(ls conftest.exe; ls conftest; ls conftest.*) 2>/dev/null`; do
@@ -1993,75 +2011,75 @@
           export ac_cv_exeext
           break;;
     * ) break;;
   esac
 done
 else
-  { { echo "$as_me:1999: error: cannot compute EXEEXT: cannot compile and link" >&5
+  { { echo "$as_me:2017: error: cannot compute EXEEXT: cannot compile and link" >&5
 echo "$as_me: error: cannot compute EXEEXT: cannot compile and link" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 rm -f conftest$ac_cv_exeext
-echo "$as_me:2005: result: $ac_cv_exeext" >&5
+echo "$as_me:2023: result: $ac_cv_exeext" >&5
 echo "${ECHO_T}$ac_cv_exeext" >&6
 
 rm -f conftest.$ac_ext
 EXEEXT=$ac_cv_exeext
 ac_exeext=$EXEEXT
-echo "$as_me:2011: checking for object suffix" >&5
+echo "$as_me:2029: checking for object suffix" >&5
 echo $ECHO_N "checking for object suffix... $ECHO_C" >&6
 if test "${ac_cv_objext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 2017 "configure"
+#line 2035 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.o conftest.obj
-if { (eval echo "$as_me:2029: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2047: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2032: \$? = $ac_status" >&5
+  echo "$as_me:2050: \$? = $ac_status" >&5
   (exit $ac_status); }; then
   for ac_file in `(ls conftest.o conftest.obj; ls conftest.*) 2>/dev/null`; do
   case $ac_file in
     *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb ) ;;
     *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
        break;;
   esac
 done
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-{ { echo "$as_me:2044: error: cannot compute OBJEXT: cannot compile" >&5
+{ { echo "$as_me:2062: error: cannot compute OBJEXT: cannot compile" >&5
 echo "$as_me: error: cannot compute OBJEXT: cannot compile" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 rm -f conftest.$ac_cv_objext conftest.$ac_ext
 fi
-echo "$as_me:2051: result: $ac_cv_objext" >&5
+echo "$as_me:2069: result: $ac_cv_objext" >&5
 echo "${ECHO_T}$ac_cv_objext" >&6
 OBJEXT=$ac_cv_objext
 ac_objext=$OBJEXT
-echo "$as_me:2055: checking whether we are using the GNU C compiler" >&5
+echo "$as_me:2073: checking whether we are using the GNU C compiler" >&5
 echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
 if test "${ac_cv_c_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 2061 "configure"
+#line 2079 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 #ifndef __GNUC__
@@ -2070,77 +2088,77 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2076: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2094: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2079: \$? = $ac_status" >&5
+  echo "$as_me:2097: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2082: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2100: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2085: \$? = $ac_status" >&5
+  echo "$as_me:2103: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_compiler_gnu=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_compiler_gnu=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-echo "$as_me:2097: result: $ac_cv_c_compiler_gnu" >&5
+echo "$as_me:2115: result: $ac_cv_c_compiler_gnu" >&5
 echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
 GCC=`test $ac_compiler_gnu = yes && echo yes`
 ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
 CFLAGS="-g"
-echo "$as_me:2103: checking whether $CC accepts -g" >&5
+echo "$as_me:2121: checking whether $CC accepts -g" >&5
 echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
 if test "${ac_cv_prog_cc_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 2109 "configure"
+#line 2127 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2121: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2139: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2124: \$? = $ac_status" >&5
+  echo "$as_me:2142: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2127: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2145: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2130: \$? = $ac_status" >&5
+  echo "$as_me:2148: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_prog_cc_g=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_prog_cc_g=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:2140: result: $ac_cv_prog_cc_g" >&5
+echo "$as_me:2158: result: $ac_cv_prog_cc_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
   if test "$GCC" = yes; then
     CFLAGS="-g -O2"
@@ -2161,87 +2179,87 @@
 cat >conftest.$ac_ext <<_ACEOF
 #ifndef __cplusplus
   choke me
 #endif
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2167: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2185: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2170: \$? = $ac_status" >&5
+  echo "$as_me:2188: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2173: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2191: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2176: \$? = $ac_status" >&5
+  echo "$as_me:2194: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   for ac_declaration in \
    ''\
    '#include <stdlib.h>' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
    'extern "C" void exit (int);' \
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
-#line 2188 "configure"
+#line 2206 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 $ac_declaration
 int
 main ()
 {
 exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2201: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2219: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2204: \$? = $ac_status" >&5
+  echo "$as_me:2222: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2207: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2225: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2210: \$? = $ac_status" >&5
+  echo "$as_me:2228: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   :
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 continue
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line 2220 "configure"
+#line 2238 "configure"
 #include "confdefs.h"
 $ac_declaration
 int
 main ()
 {
 exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2232: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2250: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2235: \$? = $ac_status" >&5
+  echo "$as_me:2253: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2238: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2256: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2241: \$? = $ac_status" >&5
+  echo "$as_me:2259: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
@@ -2264,13 +2282,13 @@
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 depcc="$CC"   am_compiler_list=
 
-echo "$as_me:2270: checking dependency style of $depcc" >&5
+echo "$as_me:2288: checking dependency style of $depcc" >&5
 echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6
 if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
   # We make a subdir and do the tests there.  Otherwise we can end up
@@ -2326,22 +2344,22 @@
   rm -rf conftest.dir
 else
   am_cv_CC_dependencies_compiler_type=none
 fi
 
 fi
-echo "$as_me:2332: result: $am_cv_CC_dependencies_compiler_type" >&5
+echo "$as_me:2350: result: $am_cv_CC_dependencies_compiler_type" >&5
 echo "${ECHO_T}$am_cv_CC_dependencies_compiler_type" >&6
 CCDEPMODE="depmode=$am_cv_CC_dependencies_compiler_type"
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
-echo "$as_me:2341: checking how to run the C preprocessor" >&5
+echo "$as_me:2359: checking how to run the C preprocessor" >&5
 echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
@@ -2356,24 +2374,24 @@
 do
   # Use a header file that comes with gcc, so configuring glibc
   # with a fresh cross-compiler works.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line 2362 "configure"
+#line 2380 "configure"
 #include "confdefs.h"
 #include <assert.h>
                      Syntax error
 _ACEOF
-if { (eval echo "$as_me:2367: \"$ac_cpp conftest.$ac_ext\"") >&5
+if { (eval echo "$as_me:2385: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   egrep -v '^ *\+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:2373: \$? = $ac_status" >&5
+  echo "$as_me:2391: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
   else
     ac_cpp_err=
   fi
@@ -2390,23 +2408,23 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line 2396 "configure"
+#line 2414 "configure"
 #include "confdefs.h"
 #include <ac_nonexistent.h>
 _ACEOF
-if { (eval echo "$as_me:2400: \"$ac_cpp conftest.$ac_ext\"") >&5
+if { (eval echo "$as_me:2418: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   egrep -v '^ *\+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:2406: \$? = $ac_status" >&5
+  echo "$as_me:2424: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
   else
     ac_cpp_err=
   fi
@@ -2437,34 +2455,34 @@
 
 fi
   CPP=$ac_cv_prog_CPP
 else
   ac_cv_prog_CPP=$CPP
 fi
-echo "$as_me:2443: result: $CPP" >&5
+echo "$as_me:2461: result: $CPP" >&5
 echo "${ECHO_T}$CPP" >&6
 ac_preproc_ok=false
 for ac_c_preproc_warn_flag in '' yes
 do
   # Use a header file that comes with gcc, so configuring glibc
   # with a fresh cross-compiler works.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line 2453 "configure"
+#line 2471 "configure"
 #include "confdefs.h"
 #include <assert.h>
                      Syntax error
 _ACEOF
-if { (eval echo "$as_me:2458: \"$ac_cpp conftest.$ac_ext\"") >&5
+if { (eval echo "$as_me:2476: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   egrep -v '^ *\+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:2464: \$? = $ac_status" >&5
+  echo "$as_me:2482: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
   else
     ac_cpp_err=
   fi
@@ -2481,23 +2499,23 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line 2487 "configure"
+#line 2505 "configure"
 #include "confdefs.h"
 #include <ac_nonexistent.h>
 _ACEOF
-if { (eval echo "$as_me:2491: \"$ac_cpp conftest.$ac_ext\"") >&5
+if { (eval echo "$as_me:2509: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   egrep -v '^ *\+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:2497: \$? = $ac_status" >&5
+  echo "$as_me:2515: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
   else
     ac_cpp_err=
   fi
@@ -2519,56 +2537,56 @@
 done
 # Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
 rm -f conftest.err conftest.$ac_ext
 if $ac_preproc_ok; then
   :
 else
-  { { echo "$as_me:2525: error: C preprocessor \"$CPP\" fails sanity check" >&5
+  { { echo "$as_me:2543: error: C preprocessor \"$CPP\" fails sanity check" >&5
 echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
-echo "$as_me:2536: checking for AIX" >&5
+echo "$as_me:2554: checking for AIX" >&5
 echo $ECHO_N "checking for AIX... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line 2539 "configure"
+#line 2557 "configure"
 #include "confdefs.h"
 #ifdef _AIX
   yes
 #endif
 
 _ACEOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "yes" >/dev/null 2>&1; then
-  echo "$as_me:2548: result: yes" >&5
+  echo "$as_me:2566: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 cat >>confdefs.h <<\EOF
 #define _ALL_SOURCE 1
 EOF
 
 else
-  echo "$as_me:2555: result: no" >&5
+  echo "$as_me:2573: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 rm -f conftest*
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}gcc; ac_word=$2
-echo "$as_me:2568: checking for $ac_word" >&5
+echo "$as_me:2586: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -2577,33 +2595,33 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_CC="${ac_tool_prefix}gcc"
-echo "$as_me:2583: found $ac_dir/$ac_word" >&5
+echo "$as_me:2601: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:2591: result: $CC" >&5
+  echo "$as_me:2609: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:2594: result: no" >&5
+  echo "$as_me:2612: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
-echo "$as_me:2603: checking for $ac_word" >&5
+echo "$as_me:2621: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -2612,37 +2630,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_CC="gcc"
-echo "$as_me:2618: found $ac_dir/$ac_word" >&5
+echo "$as_me:2636: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  echo "$as_me:2626: result: $ac_ct_CC" >&5
+  echo "$as_me:2644: result: $ac_ct_CC" >&5
 echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  echo "$as_me:2629: result: no" >&5
+  echo "$as_me:2647: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   CC=$ac_ct_CC
 else
   CC="$ac_cv_prog_CC"
 fi
 
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
 set dummy ${ac_tool_prefix}cc; ac_word=$2
-echo "$as_me:2642: checking for $ac_word" >&5
+echo "$as_me:2660: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -2651,33 +2669,33 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_CC="${ac_tool_prefix}cc"
-echo "$as_me:2657: found $ac_dir/$ac_word" >&5
+echo "$as_me:2675: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:2665: result: $CC" >&5
+  echo "$as_me:2683: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:2668: result: no" >&5
+  echo "$as_me:2686: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$ac_cv_prog_CC"; then
   ac_ct_CC=$CC
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-echo "$as_me:2677: checking for $ac_word" >&5
+echo "$as_me:2695: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -2686,37 +2704,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_CC="cc"
-echo "$as_me:2692: found $ac_dir/$ac_word" >&5
+echo "$as_me:2710: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  echo "$as_me:2700: result: $ac_ct_CC" >&5
+  echo "$as_me:2718: result: $ac_ct_CC" >&5
 echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  echo "$as_me:2703: result: no" >&5
+  echo "$as_me:2721: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   CC=$ac_ct_CC
 else
   CC="$ac_cv_prog_CC"
 fi
 
 fi
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
-echo "$as_me:2716: checking for $ac_word" >&5
+echo "$as_me:2734: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -2730,13 +2748,13 @@
   $as_executable_p "$ac_dir/$ac_word" || continue
 if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
   ac_prog_rejected=yes
   continue
 fi
 ac_cv_prog_CC="cc"
-echo "$as_me:2736: found $ac_dir/$ac_word" >&5
+echo "$as_me:2754: found $ac_dir/$ac_word" >&5
 break
 done
 
 if test $ac_prog_rejected = yes; then
   # We found a bogon in the path, so make sure we never use it.
   set dummy $ac_cv_prog_CC
@@ -2752,27 +2770,27 @@
   fi
 fi
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:2758: result: $CC" >&5
+  echo "$as_me:2776: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:2761: result: no" >&5
+  echo "$as_me:2779: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$CC"; then
   if test -n "$ac_tool_prefix"; then
   for ac_prog in cl
   do
     # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
 set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-echo "$as_me:2772: checking for $ac_word" >&5
+echo "$as_me:2790: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
@@ -2781,37 +2799,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-echo "$as_me:2787: found $ac_dir/$ac_word" >&5
+echo "$as_me:2805: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 CC=$ac_cv_prog_CC
 if test -n "$CC"; then
-  echo "$as_me:2795: result: $CC" >&5
+  echo "$as_me:2813: result: $CC" >&5
 echo "${ECHO_T}$CC" >&6
 else
-  echo "$as_me:2798: result: no" >&5
+  echo "$as_me:2816: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
     test -n "$CC" && break
   done
 fi
 if test -z "$CC"; then
   ac_ct_CC=$CC
   for ac_prog in cl
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-echo "$as_me:2811: checking for $ac_word" >&5
+echo "$as_me:2829: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_CC"; then
   ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
@@ -2820,66 +2838,66 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_CC="$ac_prog"
-echo "$as_me:2826: found $ac_dir/$ac_word" >&5
+echo "$as_me:2844: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 ac_ct_CC=$ac_cv_prog_ac_ct_CC
 if test -n "$ac_ct_CC"; then
-  echo "$as_me:2834: result: $ac_ct_CC" >&5
+  echo "$as_me:2852: result: $ac_ct_CC" >&5
 echo "${ECHO_T}$ac_ct_CC" >&6
 else
-  echo "$as_me:2837: result: no" >&5
+  echo "$as_me:2855: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   test -n "$ac_ct_CC" && break
 done
 
   CC=$ac_ct_CC
 fi
 
 fi
 
-test -z "$CC" && { { echo "$as_me:2849: error: no acceptable cc found in \$PATH" >&5
+test -z "$CC" && { { echo "$as_me:2867: error: no acceptable cc found in \$PATH" >&5
 echo "$as_me: error: no acceptable cc found in \$PATH" >&2;}
    { (exit 1); exit 1; }; }
 
 # Provide some information about the compiler.
-echo "$as_me:2854:" \
+echo "$as_me:2872:" \
      "checking for C compiler version" >&5
 ac_compiler=`set X $ac_compile; echo $2`
-{ (eval echo "$as_me:2857: \"$ac_compiler --version </dev/null >&5\"") >&5
+{ (eval echo "$as_me:2875: \"$ac_compiler --version </dev/null >&5\"") >&5
   (eval $ac_compiler --version </dev/null >&5) 2>&5
   ac_status=$?
-  echo "$as_me:2860: \$? = $ac_status" >&5
+  echo "$as_me:2878: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (eval echo "$as_me:2862: \"$ac_compiler -v </dev/null >&5\"") >&5
+{ (eval echo "$as_me:2880: \"$ac_compiler -v </dev/null >&5\"") >&5
   (eval $ac_compiler -v </dev/null >&5) 2>&5
   ac_status=$?
-  echo "$as_me:2865: \$? = $ac_status" >&5
+  echo "$as_me:2883: \$? = $ac_status" >&5
   (exit $ac_status); }
-{ (eval echo "$as_me:2867: \"$ac_compiler -V </dev/null >&5\"") >&5
+{ (eval echo "$as_me:2885: \"$ac_compiler -V </dev/null >&5\"") >&5
   (eval $ac_compiler -V </dev/null >&5) 2>&5
   ac_status=$?
-  echo "$as_me:2870: \$? = $ac_status" >&5
+  echo "$as_me:2888: \$? = $ac_status" >&5
   (exit $ac_status); }
 
-echo "$as_me:2873: checking whether we are using the GNU C compiler" >&5
+echo "$as_me:2891: checking whether we are using the GNU C compiler" >&5
 echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
 if test "${ac_cv_c_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 2879 "configure"
+#line 2897 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 #ifndef __GNUC__
@@ -2888,77 +2906,77 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2894: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2912: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2897: \$? = $ac_status" >&5
+  echo "$as_me:2915: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2900: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2918: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2903: \$? = $ac_status" >&5
+  echo "$as_me:2921: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_compiler_gnu=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_compiler_gnu=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
-echo "$as_me:2915: result: $ac_cv_c_compiler_gnu" >&5
+echo "$as_me:2933: result: $ac_cv_c_compiler_gnu" >&5
 echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
 GCC=`test $ac_compiler_gnu = yes && echo yes`
 ac_test_CFLAGS=${CFLAGS+set}
 ac_save_CFLAGS=$CFLAGS
 CFLAGS="-g"
-echo "$as_me:2921: checking whether $CC accepts -g" >&5
+echo "$as_me:2939: checking whether $CC accepts -g" >&5
 echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
 if test "${ac_cv_prog_cc_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 2927 "configure"
+#line 2945 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2939: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:2957: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2942: \$? = $ac_status" >&5
+  echo "$as_me:2960: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2945: \"$ac_try\"") >&5
+  { (eval echo "$as_me:2963: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2948: \$? = $ac_status" >&5
+  echo "$as_me:2966: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_prog_cc_g=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_prog_cc_g=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:2958: result: $ac_cv_prog_cc_g" >&5
+echo "$as_me:2976: result: $ac_cv_prog_cc_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
   if test "$GCC" = yes; then
     CFLAGS="-g -O2"
@@ -2979,87 +2997,87 @@
 cat >conftest.$ac_ext <<_ACEOF
 #ifndef __cplusplus
   choke me
 #endif
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:2985: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3003: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:2988: \$? = $ac_status" >&5
+  echo "$as_me:3006: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:2991: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3009: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:2994: \$? = $ac_status" >&5
+  echo "$as_me:3012: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   for ac_declaration in \
    ''\
    '#include <stdlib.h>' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
    'extern "C" void exit (int);' \
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
-#line 3006 "configure"
+#line 3024 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 $ac_declaration
 int
 main ()
 {
 exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3019: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3037: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3022: \$? = $ac_status" >&5
+  echo "$as_me:3040: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3025: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3043: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3028: \$? = $ac_status" >&5
+  echo "$as_me:3046: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   :
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 continue
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line 3038 "configure"
+#line 3056 "configure"
 #include "confdefs.h"
 $ac_declaration
 int
 main ()
 {
 exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3050: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3068: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3053: \$? = $ac_status" >&5
+  echo "$as_me:3071: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3056: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3074: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3059: \$? = $ac_status" >&5
+  echo "$as_me:3077: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
@@ -3082,13 +3100,13 @@
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 depcc="$CC"   am_compiler_list=
 
-echo "$as_me:3088: checking dependency style of $depcc" >&5
+echo "$as_me:3106: checking dependency style of $depcc" >&5
 echo $ECHO_N "checking dependency style of $depcc... $ECHO_C" >&6
 if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
   # We make a subdir and do the tests there.  Otherwise we can end up
@@ -3144,36 +3162,36 @@
   rm -rf conftest.dir
 else
   am_cv_CC_dependencies_compiler_type=none
 fi
 
 fi
-echo "$as_me:3150: result: $am_cv_CC_dependencies_compiler_type" >&5
+echo "$as_me:3168: result: $am_cv_CC_dependencies_compiler_type" >&5
 echo "${ECHO_T}$am_cv_CC_dependencies_compiler_type" >&6
 CCDEPMODE="depmode=$am_cv_CC_dependencies_compiler_type"
 
 # Check whether --enable-largefile or --disable-largefile was given.
 if test "${enable_largefile+set}" = set; then
   enableval="$enable_largefile"
 
 fi;
 if test "$enable_largefile" != no; then
 
-  echo "$as_me:3161: checking for special C compiler options needed for large files" >&5
+  echo "$as_me:3179: checking for special C compiler options needed for large files" >&5
 echo $ECHO_N "checking for special C compiler options needed for large files... $ECHO_C" >&6
 if test "${ac_cv_sys_largefile_CC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_sys_largefile_CC=no
      if test "$GCC" != yes; then
        ac_save_CC=$CC
        while :; do
      	 # IRIX 6.2 and later do not support large files by default,
      	 # so use the C compiler's -n32 option if that helps.
          cat >conftest.$ac_ext <<_ACEOF
-#line 3173 "configure"
+#line 3191 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
@@ -3187,41 +3205,41 @@
 
   ;
   return 0;
 }
 _ACEOF
      	 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3193: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3211: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3196: \$? = $ac_status" >&5
+  echo "$as_me:3214: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3199: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3217: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3202: \$? = $ac_status" >&5
+  echo "$as_me:3220: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
 rm -f conftest.$ac_objext
      	 CC="$CC -n32"
      	 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3212: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3230: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3215: \$? = $ac_status" >&5
+  echo "$as_me:3233: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3218: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3236: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3221: \$? = $ac_status" >&5
+  echo "$as_me:3239: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_largefile_CC=' -n32'; break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
@@ -3229,27 +3247,27 @@
          break
        done
        CC=$ac_save_CC
        rm -f conftest.$ac_ext
     fi
 fi
-echo "$as_me:3235: result: $ac_cv_sys_largefile_CC" >&5
+echo "$as_me:3253: result: $ac_cv_sys_largefile_CC" >&5
 echo "${ECHO_T}$ac_cv_sys_largefile_CC" >&6
   if test "$ac_cv_sys_largefile_CC" != no; then
     CC=$CC$ac_cv_sys_largefile_CC
   fi
 
-  echo "$as_me:3241: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+  echo "$as_me:3259: checking for _FILE_OFFSET_BITS value needed for large files" >&5
 echo $ECHO_N "checking for _FILE_OFFSET_BITS value needed for large files... $ECHO_C" >&6
 if test "${ac_cv_sys_file_offset_bits+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   while :; do
   ac_cv_sys_file_offset_bits=no
   cat >conftest.$ac_ext <<_ACEOF
-#line 3249 "configure"
+#line 3267 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
@@ -3263,31 +3281,31 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3269: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3287: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3272: \$? = $ac_status" >&5
+  echo "$as_me:3290: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3275: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3293: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3278: \$? = $ac_status" >&5
+  echo "$as_me:3296: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line 3287 "configure"
+#line 3305 "configure"
 #include "confdefs.h"
 #define _FILE_OFFSET_BITS 64
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
@@ -3302,51 +3320,51 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3308: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3326: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3311: \$? = $ac_status" >&5
+  echo "$as_me:3329: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3314: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3332: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3317: \$? = $ac_status" >&5
+  echo "$as_me:3335: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_file_offset_bits=64; break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   break
 done
 fi
-echo "$as_me:3328: result: $ac_cv_sys_file_offset_bits" >&5
+echo "$as_me:3346: result: $ac_cv_sys_file_offset_bits" >&5
 echo "${ECHO_T}$ac_cv_sys_file_offset_bits" >&6
 if test "$ac_cv_sys_file_offset_bits" != no; then
 
 cat >>confdefs.h <<EOF
 #define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
 EOF
 
 fi
 rm -f conftest*
-  echo "$as_me:3338: checking for _LARGE_FILES value needed for large files" >&5
+  echo "$as_me:3356: checking for _LARGE_FILES value needed for large files" >&5
 echo $ECHO_N "checking for _LARGE_FILES value needed for large files... $ECHO_C" >&6
 if test "${ac_cv_sys_large_files+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   while :; do
   ac_cv_sys_large_files=no
   cat >conftest.$ac_ext <<_ACEOF
-#line 3346 "configure"
+#line 3364 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
@@ -3360,31 +3378,31 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3366: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3384: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3369: \$? = $ac_status" >&5
+  echo "$as_me:3387: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3372: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3390: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3375: \$? = $ac_status" >&5
+  echo "$as_me:3393: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line 3384 "configure"
+#line 3402 "configure"
 #include "confdefs.h"
 #define _LARGE_FILES 1
 #include <sys/types.h>
  /* Check that off_t can represent 2**63 - 1 correctly.
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
@@ -3399,33 +3417,33 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:3405: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:3423: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3408: \$? = $ac_status" >&5
+  echo "$as_me:3426: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:3411: \"$ac_try\"") >&5
+  { (eval echo "$as_me:3429: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:3414: \$? = $ac_status" >&5
+  echo "$as_me:3432: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_large_files=1; break
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   break
 done
 fi
-echo "$as_me:3425: result: $ac_cv_sys_large_files" >&5
+echo "$as_me:3443: result: $ac_cv_sys_large_files" >&5
 echo "${ECHO_T}$ac_cv_sys_large_files" >&6
 if test "$ac_cv_sys_large_files" != no; then
 
 cat >>confdefs.h <<EOF
 #define _LARGE_FILES $ac_cv_sys_large_files
 EOF
@@ -3518,13 +3536,13 @@
 else
   with_gnu_ld=no
 fi;
 ac_prog=ld
 if test "$GCC" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
-  echo "$as_me:3524: checking for ld used by GCC" >&5
+  echo "$as_me:3542: checking for ld used by GCC" >&5
 echo $ECHO_N "checking for ld used by GCC... $ECHO_C" >&6
   case $host in
   *-*-mingw*)
     # gcc leaves a trailing carriage return which upsets mingw
     ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
   *)
@@ -3548,16 +3566,16 @@
   *)
     # If it is relative, then search for the first ld in PATH.
     with_gnu_ld=unknown
     ;;
   esac
 elif test "$with_gnu_ld" = yes; then
-  echo "$as_me:3554: checking for GNU ld" >&5
+  echo "$as_me:3572: checking for GNU ld" >&5
 echo $ECHO_N "checking for GNU ld... $ECHO_C" >&6
 else
-  echo "$as_me:3557: checking for non-GNU ld" >&5
+  echo "$as_me:3575: checking for non-GNU ld" >&5
 echo $ECHO_N "checking for non-GNU ld... $ECHO_C" >&6
 fi
 if test "${lt_cv_path_LD+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -z "$LD"; then
@@ -3581,50 +3599,50 @@
   lt_cv_path_LD="$LD" # Let the user override the test with a path.
 fi
 fi
 
 LD="$lt_cv_path_LD"
 if test -n "$LD"; then
-  echo "$as_me:3587: result: $LD" >&5
+  echo "$as_me:3605: result: $LD" >&5
 echo "${ECHO_T}$LD" >&6
 else
-  echo "$as_me:3590: result: no" >&5
+  echo "$as_me:3608: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
-test -z "$LD" && { { echo "$as_me:3593: error: no acceptable ld found in \$PATH" >&5
+test -z "$LD" && { { echo "$as_me:3611: error: no acceptable ld found in \$PATH" >&5
 echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
    { (exit 1); exit 1; }; }
-echo "$as_me:3596: checking if the linker ($LD) is GNU ld" >&5
+echo "$as_me:3614: checking if the linker ($LD) is GNU ld" >&5
 echo $ECHO_N "checking if the linker ($LD) is GNU ld... $ECHO_C" >&6
 if test "${lt_cv_prog_gnu_ld+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   # I'd rather use --version here, but apparently some GNU ld's only accept -v.
 if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
   lt_cv_prog_gnu_ld=yes
 else
   lt_cv_prog_gnu_ld=no
 fi
 fi
-echo "$as_me:3608: result: $lt_cv_prog_gnu_ld" >&5
+echo "$as_me:3626: result: $lt_cv_prog_gnu_ld" >&5
 echo "${ECHO_T}$lt_cv_prog_gnu_ld" >&6
 with_gnu_ld=$lt_cv_prog_gnu_ld
 
-echo "$as_me:3612: checking for $LD option to reload object files" >&5
+echo "$as_me:3630: checking for $LD option to reload object files" >&5
 echo $ECHO_N "checking for $LD option to reload object files... $ECHO_C" >&6
 if test "${lt_cv_ld_reload_flag+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   lt_cv_ld_reload_flag='-r'
 fi
-echo "$as_me:3619: result: $lt_cv_ld_reload_flag" >&5
+echo "$as_me:3637: result: $lt_cv_ld_reload_flag" >&5
 echo "${ECHO_T}$lt_cv_ld_reload_flag" >&6
 reload_flag=$lt_cv_ld_reload_flag
 test -n "$reload_flag" && reload_flag=" $reload_flag"
 
-echo "$as_me:3624: checking for BSD-compatible nm" >&5
+echo "$as_me:3642: checking for BSD-compatible nm" >&5
 echo $ECHO_N "checking for BSD-compatible nm... $ECHO_C" >&6
 if test "${lt_cv_path_NM+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$NM"; then
   # Let the user override the test.
@@ -3654,27 +3672,27 @@
   IFS="$ac_save_ifs"
   test -z "$lt_cv_path_NM" && lt_cv_path_NM=nm
 fi
 fi
 
 NM="$lt_cv_path_NM"
-echo "$as_me:3660: result: $NM" >&5
+echo "$as_me:3678: result: $NM" >&5
 echo "${ECHO_T}$NM" >&6
 
-echo "$as_me:3663: checking whether ln -s works" >&5
+echo "$as_me:3681: checking whether ln -s works" >&5
 echo $ECHO_N "checking whether ln -s works... $ECHO_C" >&6
 LN_S=$as_ln_s
 if test "$LN_S" = "ln -s"; then
-  echo "$as_me:3667: result: yes" >&5
+  echo "$as_me:3685: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 else
-  echo "$as_me:3670: result: no, using $LN_S" >&5
+  echo "$as_me:3688: result: no, using $LN_S" >&5
 echo "${ECHO_T}no, using $LN_S" >&6
 fi
 
-echo "$as_me:3674: checking how to recognise dependant libraries" >&5
+echo "$as_me:3692: checking how to recognise dependant libraries" >&5
 echo $ECHO_N "checking how to recognise dependant libraries... $ECHO_C" >&6
 if test "${lt_cv_deplibs_check_method+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   lt_cv_file_magic_cmd='$MAGIC_CMD'
 lt_cv_file_magic_test_file=
@@ -3846,19 +3864,19 @@
     ;;
   esac
   ;;
 esac
 
 fi
-echo "$as_me:3852: result: $lt_cv_deplibs_check_method" >&5
+echo "$as_me:3870: result: $lt_cv_deplibs_check_method" >&5
 echo "${ECHO_T}$lt_cv_deplibs_check_method" >&6
 file_magic_cmd=$lt_cv_file_magic_cmd
 deplibs_check_method=$lt_cv_deplibs_check_method
 
 # Check for command to grab the raw symbol name followed by C symbol from nm.
-echo "$as_me:3858: checking command to parse $NM output" >&5
+echo "$as_me:3876: checking command to parse $NM output" >&5
 echo $ECHO_N "checking command to parse $NM output... $ECHO_C" >&6
 if test "${lt_cv_sys_global_symbol_pipe+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
 # These are sane defaults that work on at least a few old systems.
@@ -3933,23 +3951,23 @@
 #ifdef __cplusplus
 }
 #endif
 int main(){nm_test_var='a';nm_test_func();return(0);}
 EOF
 
-  if { (eval echo "$as_me:3939: \"$ac_compile\"") >&5
+  if { (eval echo "$as_me:3957: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:3942: \$? = $ac_status" >&5
+  echo "$as_me:3960: \$? = $ac_status" >&5
   (exit $ac_status); }; then
     # Now try to grab the symbols.
     nlist=conftest.nm
-    if { (eval echo "$as_me:3946: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\"") >&5
+    if { (eval echo "$as_me:3964: \"$NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist\"") >&5
   (eval $NM conftest.$ac_objext \| $lt_cv_sys_global_symbol_pipe \> $nlist) 2>&5
   ac_status=$?
-  echo "$as_me:3949: \$? = $ac_status" >&5
+  echo "$as_me:3967: \$? = $ac_status" >&5
   (exit $ac_status); } && test -s "$nlist"; then
       # Try sorting and uniquifying the output.
       if sort "$nlist" | uniq > "$nlist"T; then
 	mv -f "$nlist"T "$nlist"
       else
 	rm -f "$nlist"T
@@ -3995,16 +4013,16 @@
 	  # Now try linking the two files.
 	  mv conftest.$ac_objext conftstm.$ac_objext
 	  save_LIBS="$LIBS"
 	  save_CFLAGS="$CFLAGS"
 	  LIBS="conftstm.$ac_objext"
 	  CFLAGS="$CFLAGS$no_builtin_flag"
-	  if { (eval echo "$as_me:4001: \"$ac_link\"") >&5
+	  if { (eval echo "$as_me:4019: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:4004: \$? = $ac_status" >&5
+  echo "$as_me:4022: \$? = $ac_status" >&5
   (exit $ac_status); } && test -s conftest; then
 	    pipe_works=yes
 	  fi
 	  LIBS="$save_LIBS"
 	  CFLAGS="$save_CFLAGS"
 	else
@@ -4039,39 +4057,39 @@
 else
   global_symbol_to_cdecl="$lt_cv_global_symbol_to_cdecl"
   global_symbol_to_c_name_address="$lt_cv_global_symbol_to_c_name_address"
 fi
 if test -z "$global_symbol_pipe$global_symbol_to_cdec$global_symbol_to_c_name_address";
 then
-  echo "$as_me:4045: result: failed" >&5
+  echo "$as_me:4063: result: failed" >&5
 echo "${ECHO_T}failed" >&6
 else
-  echo "$as_me:4048: result: ok" >&5
+  echo "$as_me:4066: result: ok" >&5
 echo "${ECHO_T}ok" >&6
 fi
 
 for ac_header in dlfcn.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:4055: checking for $ac_header" >&5
+echo "$as_me:4073: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 4061 "configure"
+#line 4079 "configure"
 #include "confdefs.h"
 #include <$ac_header>
 _ACEOF
-if { (eval echo "$as_me:4065: \"$ac_cpp conftest.$ac_ext\"") >&5
+if { (eval echo "$as_me:4083: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   egrep -v '^ *\+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:4071: \$? = $ac_status" >&5
+  echo "$as_me:4089: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
   else
     ac_cpp_err=
   fi
@@ -4084,13 +4102,13 @@
   echo "$as_me: failed program was:" >&5
   cat conftest.$ac_ext >&5
   eval "$as_ac_Header=no"
 fi
 rm -f conftest.err conftest.$ac_ext
 fi
-echo "$as_me:4090: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "$as_me:4108: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<EOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
 EOF
 
@@ -4098,13 +4116,13 @@
 done
 
 # Only perform the check for file, if the check method requires it
 case $deplibs_check_method in
 file_magic*)
   if test "$file_magic_cmd" = '$MAGIC_CMD'; then
-    echo "$as_me:4104: checking for ${ac_tool_prefix}file" >&5
+    echo "$as_me:4122: checking for ${ac_tool_prefix}file" >&5
 echo $ECHO_N "checking for ${ac_tool_prefix}file... $ECHO_C" >&6
 if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   case $MAGIC_CMD in
   /*)
@@ -4153,22 +4171,22 @@
   ;;
 esac
 fi
 
 MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
 if test -n "$MAGIC_CMD"; then
-  echo "$as_me:4159: result: $MAGIC_CMD" >&5
+  echo "$as_me:4177: result: $MAGIC_CMD" >&5
 echo "${ECHO_T}$MAGIC_CMD" >&6
 else
-  echo "$as_me:4162: result: no" >&5
+  echo "$as_me:4180: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 if test -z "$lt_cv_path_MAGIC_CMD"; then
   if test -n "$ac_tool_prefix"; then
-    echo "$as_me:4168: checking for file" >&5
+    echo "$as_me:4186: checking for file" >&5
 echo $ECHO_N "checking for file... $ECHO_C" >&6
 if test "${lt_cv_path_MAGIC_CMD+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   case $MAGIC_CMD in
   /*)
@@ -4217,16 +4235,16 @@
   ;;
 esac
 fi
 
 MAGIC_CMD="$lt_cv_path_MAGIC_CMD"
 if test -n "$MAGIC_CMD"; then
-  echo "$as_me:4223: result: $MAGIC_CMD" >&5
+  echo "$as_me:4241: result: $MAGIC_CMD" >&5
 echo "${ECHO_T}$MAGIC_CMD" >&6
 else
-  echo "$as_me:4226: result: no" >&5
+  echo "$as_me:4244: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   else
     MAGIC_CMD=:
   fi
@@ -4236,13 +4254,13 @@
   ;;
 esac
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
-echo "$as_me:4242: checking for $ac_word" >&5
+echo "$as_me:4260: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_RANLIB+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$RANLIB"; then
   ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
@@ -4251,33 +4269,33 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
-echo "$as_me:4257: found $ac_dir/$ac_word" >&5
+echo "$as_me:4275: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 RANLIB=$ac_cv_prog_RANLIB
 if test -n "$RANLIB"; then
-  echo "$as_me:4265: result: $RANLIB" >&5
+  echo "$as_me:4283: result: $RANLIB" >&5
 echo "${ECHO_T}$RANLIB" >&6
 else
-  echo "$as_me:4268: result: no" >&5
+  echo "$as_me:4286: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$ac_cv_prog_RANLIB"; then
   ac_ct_RANLIB=$RANLIB
   # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
-echo "$as_me:4277: checking for $ac_word" >&5
+echo "$as_me:4295: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_RANLIB"; then
   ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
@@ -4286,37 +4304,37 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_RANLIB="ranlib"
-echo "$as_me:4292: found $ac_dir/$ac_word" >&5
+echo "$as_me:4310: found $ac_dir/$ac_word" >&5
 break
 done
 
   test -z "$ac_cv_prog_ac_ct_RANLIB" && ac_cv_prog_ac_ct_RANLIB=":"
 fi
 fi
 ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
 if test -n "$ac_ct_RANLIB"; then
-  echo "$as_me:4301: result: $ac_ct_RANLIB" >&5
+  echo "$as_me:4319: result: $ac_ct_RANLIB" >&5
 echo "${ECHO_T}$ac_ct_RANLIB" >&6
 else
-  echo "$as_me:4304: result: no" >&5
+  echo "$as_me:4322: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   RANLIB=$ac_ct_RANLIB
 else
   RANLIB="$ac_cv_prog_RANLIB"
 fi
 
 if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
-echo "$as_me:4316: checking for $ac_word" >&5
+echo "$as_me:4334: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_STRIP+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$STRIP"; then
   ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
@@ -4325,33 +4343,33 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_STRIP="${ac_tool_prefix}strip"
-echo "$as_me:4331: found $ac_dir/$ac_word" >&5
+echo "$as_me:4349: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 STRIP=$ac_cv_prog_STRIP
 if test -n "$STRIP"; then
-  echo "$as_me:4339: result: $STRIP" >&5
+  echo "$as_me:4357: result: $STRIP" >&5
 echo "${ECHO_T}$STRIP" >&6
 else
-  echo "$as_me:4342: result: no" >&5
+  echo "$as_me:4360: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 fi
 if test -z "$ac_cv_prog_STRIP"; then
   ac_ct_STRIP=$STRIP
   # Extract the first word of "strip", so it can be a program name with args.
 set dummy strip; ac_word=$2
-echo "$as_me:4351: checking for $ac_word" >&5
+echo "$as_me:4369: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$ac_ct_STRIP"; then
   ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
@@ -4360,35 +4378,35 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_ac_ct_STRIP="strip"
-echo "$as_me:4366: found $ac_dir/$ac_word" >&5
+echo "$as_me:4384: found $ac_dir/$ac_word" >&5
 break
 done
 
   test -z "$ac_cv_prog_ac_ct_STRIP" && ac_cv_prog_ac_ct_STRIP=":"
 fi
 fi
 ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
 if test -n "$ac_ct_STRIP"; then
-  echo "$as_me:4375: result: $ac_ct_STRIP" >&5
+  echo "$as_me:4393: result: $ac_ct_STRIP" >&5
 echo "${ECHO_T}$ac_ct_STRIP" >&6
 else
-  echo "$as_me:4378: result: no" >&5
+  echo "$as_me:4396: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   STRIP=$ac_ct_STRIP
 else
   STRIP="$ac_cv_prog_STRIP"
 fi
 
 enable_dlopen=no
-enable_win32_dll=no
+enable_win32_dll=yes
 
 # Check whether --enable-libtool-lock or --disable-libtool-lock was given.
 if test "${enable_libtool_lock+set}" = set; then
   enableval="$enable_libtool_lock"
 
 fi;
@@ -4396,17 +4414,17 @@
 
 # Some flags need to be propagated to the compiler or linker for good
 # libtool support.
 case $host in
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 4402 "configure"' > conftest.$ac_ext
-  if { (eval echo "$as_me:4403: \"$ac_compile\"") >&5
+  echo '#line 4420 "configure"' > conftest.$ac_ext
+  if { (eval echo "$as_me:4421: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:4406: \$? = $ac_status" >&5
+  echo "$as_me:4424: \$? = $ac_status" >&5
   (exit $ac_status); }; then
     case `/usr/bin/file conftest.$ac_objext` in
     *32-bit*)
       LD="${LD-ld} -32"
       ;;
     *N32*)
@@ -4421,47 +4439,47 @@
   ;;
 
 *-*-sco3.2v5*)
   # On SCO OpenServer 5, we need -belf to get full-featured binaries.
   SAVE_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -belf"
-  echo "$as_me:4427: checking whether the C compiler needs -belf" >&5
+  echo "$as_me:4445: checking whether the C compiler needs -belf" >&5
 echo $ECHO_N "checking whether the C compiler needs -belf... $ECHO_C" >&6
 if test "${lt_cv_cc_needs_belf+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
      ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
      cat >conftest.$ac_ext <<_ACEOF
-#line 4440 "configure"
+#line 4458 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:4452: \"$ac_link\"") >&5
+if { (eval echo "$as_me:4470: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:4455: \$? = $ac_status" >&5
+  echo "$as_me:4473: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:4458: \"$ac_try\"") >&5
+  { (eval echo "$as_me:4476: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:4461: \$? = $ac_status" >&5
+  echo "$as_me:4479: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   lt_cv_cc_needs_belf=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 lt_cv_cc_needs_belf=no
@@ -4471,20 +4489,339 @@
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 fi
-echo "$as_me:4477: result: $lt_cv_cc_needs_belf" >&5
+echo "$as_me:4495: result: $lt_cv_cc_needs_belf" >&5
 echo "${ECHO_T}$lt_cv_cc_needs_belf" >&6
   if test x"$lt_cv_cc_needs_belf" != x"yes"; then
     # this is probably gcc 2.8.0, egcs 1.0 or newer; no need for -belf
     CFLAGS="$SAVE_CFLAGS"
   fi
   ;;
 
+*-*-cygwin* | *-*-mingw* | *-*-pw32*)
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}dlltool", so it can be a program name with args.
+set dummy ${ac_tool_prefix}dlltool; ac_word=$2
+echo "$as_me:4507: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_DLLTOOL+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$DLLTOOL"; then
+  ac_cv_prog_DLLTOOL="$DLLTOOL" # Let the user override the test.
+else
+  ac_save_IFS=$IFS; IFS=$ac_path_separator
+ac_dummy="$PATH"
+for ac_dir in $ac_dummy; do
+  IFS=$ac_save_IFS
+  test -z "$ac_dir" && ac_dir=.
+  $as_executable_p "$ac_dir/$ac_word" || continue
+ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
+echo "$as_me:4522: found $ac_dir/$ac_word" >&5
+break
+done
+
+fi
+fi
+DLLTOOL=$ac_cv_prog_DLLTOOL
+if test -n "$DLLTOOL"; then
+  echo "$as_me:4530: result: $DLLTOOL" >&5
+echo "${ECHO_T}$DLLTOOL" >&6
+else
+  echo "$as_me:4533: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_DLLTOOL"; then
+  ac_ct_DLLTOOL=$DLLTOOL
+  # Extract the first word of "dlltool", so it can be a program name with args.
+set dummy dlltool; ac_word=$2
+echo "$as_me:4542: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_DLLTOOL+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_DLLTOOL"; then
+  ac_cv_prog_ac_ct_DLLTOOL="$ac_ct_DLLTOOL" # Let the user override the test.
+else
+  ac_save_IFS=$IFS; IFS=$ac_path_separator
+ac_dummy="$PATH"
+for ac_dir in $ac_dummy; do
+  IFS=$ac_save_IFS
+  test -z "$ac_dir" && ac_dir=.
+  $as_executable_p "$ac_dir/$ac_word" || continue
+ac_cv_prog_ac_ct_DLLTOOL="dlltool"
+echo "$as_me:4557: found $ac_dir/$ac_word" >&5
+break
+done
+
+  test -z "$ac_cv_prog_ac_ct_DLLTOOL" && ac_cv_prog_ac_ct_DLLTOOL="false"
+fi
+fi
+ac_ct_DLLTOOL=$ac_cv_prog_ac_ct_DLLTOOL
+if test -n "$ac_ct_DLLTOOL"; then
+  echo "$as_me:4566: result: $ac_ct_DLLTOOL" >&5
+echo "${ECHO_T}$ac_ct_DLLTOOL" >&6
+else
+  echo "$as_me:4569: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  DLLTOOL=$ac_ct_DLLTOOL
+else
+  DLLTOOL="$ac_cv_prog_DLLTOOL"
+fi
+
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}as", so it can be a program name with args.
+set dummy ${ac_tool_prefix}as; ac_word=$2
+echo "$as_me:4581: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_AS+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$AS"; then
+  ac_cv_prog_AS="$AS" # Let the user override the test.
+else
+  ac_save_IFS=$IFS; IFS=$ac_path_separator
+ac_dummy="$PATH"
+for ac_dir in $ac_dummy; do
+  IFS=$ac_save_IFS
+  test -z "$ac_dir" && ac_dir=.
+  $as_executable_p "$ac_dir/$ac_word" || continue
+ac_cv_prog_AS="${ac_tool_prefix}as"
+echo "$as_me:4596: found $ac_dir/$ac_word" >&5
+break
+done
+
+fi
+fi
+AS=$ac_cv_prog_AS
+if test -n "$AS"; then
+  echo "$as_me:4604: result: $AS" >&5
+echo "${ECHO_T}$AS" >&6
+else
+  echo "$as_me:4607: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_AS"; then
+  ac_ct_AS=$AS
+  # Extract the first word of "as", so it can be a program name with args.
+set dummy as; ac_word=$2
+echo "$as_me:4616: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_AS+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_AS"; then
+  ac_cv_prog_ac_ct_AS="$ac_ct_AS" # Let the user override the test.
+else
+  ac_save_IFS=$IFS; IFS=$ac_path_separator
+ac_dummy="$PATH"
+for ac_dir in $ac_dummy; do
+  IFS=$ac_save_IFS
+  test -z "$ac_dir" && ac_dir=.
+  $as_executable_p "$ac_dir/$ac_word" || continue
+ac_cv_prog_ac_ct_AS="as"
+echo "$as_me:4631: found $ac_dir/$ac_word" >&5
+break
+done
+
+  test -z "$ac_cv_prog_ac_ct_AS" && ac_cv_prog_ac_ct_AS="false"
+fi
+fi
+ac_ct_AS=$ac_cv_prog_ac_ct_AS
+if test -n "$ac_ct_AS"; then
+  echo "$as_me:4640: result: $ac_ct_AS" >&5
+echo "${ECHO_T}$ac_ct_AS" >&6
+else
+  echo "$as_me:4643: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  AS=$ac_ct_AS
+else
+  AS="$ac_cv_prog_AS"
+fi
+
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
+set dummy ${ac_tool_prefix}objdump; ac_word=$2
+echo "$as_me:4655: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_OBJDUMP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$OBJDUMP"; then
+  ac_cv_prog_OBJDUMP="$OBJDUMP" # Let the user override the test.
+else
+  ac_save_IFS=$IFS; IFS=$ac_path_separator
+ac_dummy="$PATH"
+for ac_dir in $ac_dummy; do
+  IFS=$ac_save_IFS
+  test -z "$ac_dir" && ac_dir=.
+  $as_executable_p "$ac_dir/$ac_word" || continue
+ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
+echo "$as_me:4670: found $ac_dir/$ac_word" >&5
+break
+done
+
+fi
+fi
+OBJDUMP=$ac_cv_prog_OBJDUMP
+if test -n "$OBJDUMP"; then
+  echo "$as_me:4678: result: $OBJDUMP" >&5
+echo "${ECHO_T}$OBJDUMP" >&6
+else
+  echo "$as_me:4681: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+fi
+if test -z "$ac_cv_prog_OBJDUMP"; then
+  ac_ct_OBJDUMP=$OBJDUMP
+  # Extract the first word of "objdump", so it can be a program name with args.
+set dummy objdump; ac_word=$2
+echo "$as_me:4690: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_ac_ct_OBJDUMP+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$ac_ct_OBJDUMP"; then
+  ac_cv_prog_ac_ct_OBJDUMP="$ac_ct_OBJDUMP" # Let the user override the test.
+else
+  ac_save_IFS=$IFS; IFS=$ac_path_separator
+ac_dummy="$PATH"
+for ac_dir in $ac_dummy; do
+  IFS=$ac_save_IFS
+  test -z "$ac_dir" && ac_dir=.
+  $as_executable_p "$ac_dir/$ac_word" || continue
+ac_cv_prog_ac_ct_OBJDUMP="objdump"
+echo "$as_me:4705: found $ac_dir/$ac_word" >&5
+break
+done
+
+  test -z "$ac_cv_prog_ac_ct_OBJDUMP" && ac_cv_prog_ac_ct_OBJDUMP="false"
+fi
+fi
+ac_ct_OBJDUMP=$ac_cv_prog_ac_ct_OBJDUMP
+if test -n "$ac_ct_OBJDUMP"; then
+  echo "$as_me:4714: result: $ac_ct_OBJDUMP" >&5
+echo "${ECHO_T}$ac_ct_OBJDUMP" >&6
+else
+  echo "$as_me:4717: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  OBJDUMP=$ac_ct_OBJDUMP
+else
+  OBJDUMP="$ac_cv_prog_OBJDUMP"
+fi
+
+  # recent cygwin and mingw systems supply a stub DllMain which the user
+  # can override, but on older systems we have to supply one
+  echo "$as_me:4728: checking if libtool should supply DllMain function" >&5
+echo $ECHO_N "checking if libtool should supply DllMain function... $ECHO_C" >&6
+if test "${lt_cv_need_dllmain+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 4734 "configure"
+#include "confdefs.h"
+
+int
+main ()
+{
+extern int __attribute__((__stdcall__)) DllMain(void*, int, void*);
+      DllMain (0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:4747: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:4750: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:4753: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:4756: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  lt_cv_need_dllmain=no
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+lt_cv_need_dllmain=yes
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:4766: result: $lt_cv_need_dllmain" >&5
+echo "${ECHO_T}$lt_cv_need_dllmain" >&6
+
+  case $host/$CC in
+  *-*-cygwin*/gcc*-mno-cygwin*|*-*-mingw*)
+    # old mingw systems require "-dll" to link a DLL, while more recent ones
+    # require "-mdll"
+    SAVE_CFLAGS="$CFLAGS"
+    CFLAGS="$CFLAGS -mdll"
+    echo "$as_me:4775: checking how to link DLLs" >&5
+echo $ECHO_N "checking how to link DLLs... $ECHO_C" >&6
+if test "${lt_cv_cc_dll_switch+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 4781 "configure"
+#include "confdefs.h"
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:4793: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:4796: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:4799: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:4802: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  lt_cv_cc_dll_switch=-mdll
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+lt_cv_cc_dll_switch=-dll
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:4812: result: $lt_cv_cc_dll_switch" >&5
+echo "${ECHO_T}$lt_cv_cc_dll_switch" >&6
+    CFLAGS="$SAVE_CFLAGS" ;;
+  *-*-cygwin* | *-*-pw32*)
+    # cygwin systems need to pass --dll to the linker, and not link
+    # crt.o which will require a WinMain@16 definition.
+    lt_cv_cc_dll_switch="-Wl,--dll -nostartfiles" ;;
+  esac
+  ;;
+
 esac
 
 # Sed substitution that helps us do robust quoting.  It backslashifies
 # metacharacters that are still active within double-quoted strings.
 Xsed='sed -e s/^X//'
 sed_quote_subst='s/\([\\"\\`$\\\\]\)/\\\1/g'
@@ -4571,24 +4908,24 @@
 fi
 
 # Allow CC to be a program name with arguments.
 set dummy $CC
 compiler="$2"
 
-echo "$as_me:4577: checking for objdir" >&5
+echo "$as_me:4914: checking for objdir" >&5
 echo $ECHO_N "checking for objdir... $ECHO_C" >&6
 rm -f .libs 2>/dev/null
 mkdir .libs 2>/dev/null
 if test -d .libs; then
   objdir=.libs
 else
   # MS-DOS does not allow filenames that begin with a dot.
   objdir=_libs
 fi
 rmdir .libs 2>/dev/null
-echo "$as_me:4588: result: $objdir" >&5
+echo "$as_me:4925: result: $objdir" >&5
 echo "${ECHO_T}$objdir" >&6
 
 # Check whether --with-pic or --without-pic was given.
 if test "${with_pic+set}" = set; then
   withval="$with_pic"
   pic_mode="$withval"
@@ -4597,13 +4934,13 @@
 fi;
 test -z "$pic_mode" && pic_mode=default
 
 # We assume here that the value for lt_cv_prog_cc_pic will not be cached
 # in isolation, and that seeing it set (from the cache) indicates that
 # the associated values are set (in the cache) correctly too.
-echo "$as_me:4603: checking for $compiler option to produce PIC" >&5
+echo "$as_me:4940: checking for $compiler option to produce PIC" >&5
 echo $ECHO_N "checking for $compiler option to produce PIC... $ECHO_C" >&6
 if test "${lt_cv_prog_cc_pic+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
    lt_cv_prog_cc_pic=
   lt_cv_prog_cc_shlib=
@@ -4744,49 +5081,49 @@
     esac
   fi
 
 fi
 
 if test -z "$lt_cv_prog_cc_pic"; then
-  echo "$as_me:4750: result: none" >&5
+  echo "$as_me:5087: result: none" >&5
 echo "${ECHO_T}none" >&6
 else
-  echo "$as_me:4753: result: $lt_cv_prog_cc_pic" >&5
+  echo "$as_me:5090: result: $lt_cv_prog_cc_pic" >&5
 echo "${ECHO_T}$lt_cv_prog_cc_pic" >&6
 
   # Check to make sure the pic_flag actually works.
-  echo "$as_me:4757: checking if $compiler PIC flag $lt_cv_prog_cc_pic works" >&5
+  echo "$as_me:5094: checking if $compiler PIC flag $lt_cv_prog_cc_pic works" >&5
 echo $ECHO_N "checking if $compiler PIC flag $lt_cv_prog_cc_pic works... $ECHO_C" >&6
   if test "${lt_cv_prog_cc_pic_works+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
       save_CFLAGS="$CFLAGS"
     CFLAGS="$CFLAGS $lt_cv_prog_cc_pic -DPIC"
     cat >conftest.$ac_ext <<_ACEOF
-#line 4765 "configure"
+#line 5102 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:4777: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:5114: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:4780: \$? = $ac_status" >&5
+  echo "$as_me:5117: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:4783: \"$ac_try\"") >&5
+  { (eval echo "$as_me:5120: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:4786: \$? = $ac_status" >&5
+  echo "$as_me:5123: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
         case $host_os in
       hpux9* | hpux10* | hpux11*)
 	# On HP-UX, both CC and GCC only warn that PIC is supported... then
 	# they create non-PIC objects.  So, if there were any warnings, we
 	# assume that PIC is not supported.
@@ -4816,59 +5153,59 @@
     lt_cv_prog_cc_pic=
     lt_cv_prog_cc_can_build_shared=no
   else
     lt_cv_prog_cc_pic=" $lt_cv_prog_cc_pic"
   fi
 
-  echo "$as_me:4822: result: $lt_cv_prog_cc_pic_works" >&5
+  echo "$as_me:5159: result: $lt_cv_prog_cc_pic_works" >&5
 echo "${ECHO_T}$lt_cv_prog_cc_pic_works" >&6
 fi
 
 # Check for any special shared library compilation flags.
 if test -n "$lt_cv_prog_cc_shlib"; then
-  { echo "$as_me:4828: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&5
+  { echo "$as_me:5165: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&5
 echo "$as_me: WARNING: \`$CC' requires \`$lt_cv_prog_cc_shlib' to build shared libraries" >&2;}
   if echo "$old_CC $old_CFLAGS " | egrep -e "[ 	]$lt_cv_prog_cc_shlib[ 	]" >/dev/null; then :
   else
-   { echo "$as_me:4832: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&5
+   { echo "$as_me:5169: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&5
 echo "$as_me: WARNING: add \`$lt_cv_prog_cc_shlib' to the CC or CFLAGS env variable and reconfigure" >&2;}
     lt_cv_prog_cc_can_build_shared=no
   fi
 fi
 
-echo "$as_me:4838: checking if $compiler static flag $lt_cv_prog_cc_static works" >&5
+echo "$as_me:5175: checking if $compiler static flag $lt_cv_prog_cc_static works" >&5
 echo $ECHO_N "checking if $compiler static flag $lt_cv_prog_cc_static works... $ECHO_C" >&6
 if test "${lt_cv_prog_cc_static_works+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
     lt_cv_prog_cc_static_works=no
   save_LDFLAGS="$LDFLAGS"
   LDFLAGS="$LDFLAGS $lt_cv_prog_cc_static"
   cat >conftest.$ac_ext <<_ACEOF
-#line 4847 "configure"
+#line 5184 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:4859: \"$ac_link\"") >&5
+if { (eval echo "$as_me:5196: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:4862: \$? = $ac_status" >&5
+  echo "$as_me:5199: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:4865: \"$ac_try\"") >&5
+  { (eval echo "$as_me:5202: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:4868: \$? = $ac_status" >&5
+  echo "$as_me:5205: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   lt_cv_prog_cc_static_works=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
@@ -4876,24 +5213,24 @@
   LDFLAGS="$save_LDFLAGS"
 
 fi
 
 # Belt *and* braces to stop my trousers falling down:
 test "X$lt_cv_prog_cc_static_works" = Xno && lt_cv_prog_cc_static=
-echo "$as_me:4882: result: $lt_cv_prog_cc_static_works" >&5
+echo "$as_me:5219: result: $lt_cv_prog_cc_static_works" >&5
 echo "${ECHO_T}$lt_cv_prog_cc_static_works" >&6
 
 pic_flag="$lt_cv_prog_cc_pic"
 special_shlib_compile_flags="$lt_cv_prog_cc_shlib"
 wl="$lt_cv_prog_cc_wl"
 link_static_flag="$lt_cv_prog_cc_static"
 no_builtin_flag="$lt_cv_prog_cc_no_builtin"
 can_build_shared="$lt_cv_prog_cc_can_build_shared"
 
 # Check to see if options -o and -c are simultaneously supported by compiler
-echo "$as_me:4893: checking if $compiler supports -c -o file.$ac_objext" >&5
+echo "$as_me:5230: checking if $compiler supports -c -o file.$ac_objext" >&5
 echo $ECHO_N "checking if $compiler supports -c -o file.$ac_objext... $ECHO_C" >&6
 if test "${lt_cv_compiler_c_o+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
 $rm -r conftest 2>/dev/null
@@ -4907,13 +5244,13 @@
 # to fail, enabling locking or at least warning the user not to do parallel
 # builds.
 chmod -w .
 save_CFLAGS="$CFLAGS"
 CFLAGS="$CFLAGS -o out/conftest2.$ac_objext"
 compiler_c_o=no
-if { (eval echo configure:4913: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>out/conftest.err; } && test -s out/conftest2.$ac_objext; then
+if { (eval echo configure:5250: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>out/conftest.err; } && test -s out/conftest2.$ac_objext; then
   # The compiler can only warn and ignore the option if not recognized
   # So say no if there are warnings
   if test -s out/conftest.err; then
     lt_cv_compiler_c_o=no
   else
     lt_cv_compiler_c_o=yes
@@ -4931,51 +5268,51 @@
 rmdir conftest
 $rm -r conftest 2>/dev/null
 
 fi
 
 compiler_c_o=$lt_cv_compiler_c_o
-echo "$as_me:4937: result: $compiler_c_o" >&5
+echo "$as_me:5274: result: $compiler_c_o" >&5
 echo "${ECHO_T}$compiler_c_o" >&6
 
 if test x"$compiler_c_o" = x"yes"; then
   # Check to see if we can write to a .lo
-  echo "$as_me:4942: checking if $compiler supports -c -o file.lo" >&5
+  echo "$as_me:5279: checking if $compiler supports -c -o file.lo" >&5
 echo $ECHO_N "checking if $compiler supports -c -o file.lo... $ECHO_C" >&6
   if test "${lt_cv_compiler_o_lo+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
   lt_cv_compiler_o_lo=no
   save_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -c -o conftest.lo"
   save_objext="$ac_objext"
   ac_objext=lo
   cat >conftest.$ac_ext <<_ACEOF
-#line 4954 "configure"
+#line 5291 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 int some_variable = 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:4966: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:5303: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:4969: \$? = $ac_status" >&5
+  echo "$as_me:5306: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:4972: \"$ac_try\"") >&5
+  { (eval echo "$as_me:5309: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:4975: \$? = $ac_status" >&5
+  echo "$as_me:5312: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
       # The compiler can only warn and ignore the option if not recognized
     # So say no if there are warnings
     if test -s conftest.err; then
       lt_cv_compiler_o_lo=no
     else
@@ -4990,72 +5327,72 @@
   ac_objext="$save_objext"
   CFLAGS="$save_CFLAGS"
 
 fi
 
   compiler_o_lo=$lt_cv_compiler_o_lo
-  echo "$as_me:4996: result: $compiler_o_lo" >&5
+  echo "$as_me:5333: result: $compiler_o_lo" >&5
 echo "${ECHO_T}$compiler_o_lo" >&6
 else
   compiler_o_lo=no
 fi
 
 # Check to see if we can do hard links to lock some files if needed
 hard_links="nottested"
 if test "$compiler_c_o" = no && test "$need_locks" != no; then
   # do not overwrite the value of need_locks provided by the user
-  echo "$as_me:5006: checking if we can lock with hard links" >&5
+  echo "$as_me:5343: checking if we can lock with hard links" >&5
 echo $ECHO_N "checking if we can lock with hard links... $ECHO_C" >&6
   hard_links=yes
   $rm conftest*
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
   touch conftest.a
   ln conftest.a conftest.b 2>&5 || hard_links=no
   ln conftest.a conftest.b 2>/dev/null && hard_links=no
-  echo "$as_me:5014: result: $hard_links" >&5
+  echo "$as_me:5351: result: $hard_links" >&5
 echo "${ECHO_T}$hard_links" >&6
   if test "$hard_links" = no; then
-    { echo "$as_me:5017: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
+    { echo "$as_me:5354: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&5
 echo "$as_me: WARNING: \`$CC' does not support \`-c -o', so \`make -j' may be unsafe" >&2;}
     need_locks=warn
   fi
 else
   need_locks=no
 fi
 
 if test "$GCC" = yes; then
   # Check to see if options -fno-rtti -fno-exceptions are supported by compiler
-  echo "$as_me:5027: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
+  echo "$as_me:5364: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
 echo $ECHO_N "checking if $compiler supports -fno-rtti -fno-exceptions... $ECHO_C" >&6
   echo "int some_variable = 0;" > conftest.$ac_ext
   save_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -fno-rtti -fno-exceptions -c conftest.$ac_ext"
   compiler_rtti_exceptions=no
   cat >conftest.$ac_ext <<_ACEOF
-#line 5034 "configure"
+#line 5371 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 int some_variable = 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:5046: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:5383: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:5049: \$? = $ac_status" >&5
+  echo "$as_me:5386: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:5052: \"$ac_try\"") >&5
+  { (eval echo "$as_me:5389: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:5055: \$? = $ac_status" >&5
+  echo "$as_me:5392: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
       # The compiler can only warn and ignore the option if not recognized
     # So say no if there are warnings
     if test -s conftest.err; then
       compiler_rtti_exceptions=no
     else
@@ -5065,24 +5402,24 @@
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
   CFLAGS="$save_CFLAGS"
-  echo "$as_me:5071: result: $compiler_rtti_exceptions" >&5
+  echo "$as_me:5408: result: $compiler_rtti_exceptions" >&5
 echo "${ECHO_T}$compiler_rtti_exceptions" >&6
 
   if test "$compiler_rtti_exceptions" = "yes"; then
     no_builtin_flag=' -fno-builtin -fno-rtti -fno-exceptions'
   else
     no_builtin_flag=' -fno-builtin'
   fi
 fi
 
 # See if the linker supports building shared libraries.
-echo "$as_me:5082: checking whether the linker ($LD) supports shared libraries" >&5
+echo "$as_me:5419: checking whether the linker ($LD) supports shared libraries" >&5
 echo $ECHO_N "checking whether the linker ($LD) supports shared libraries... $ECHO_C" >&6
 
 allow_undefined_flag=
 no_undefined_flag=
 need_lib_prefix=unknown
 need_version=unknown
@@ -5756,18 +6093,18 @@
 
   *)
     ld_shlibs=no
     ;;
   esac
 fi
-echo "$as_me:5762: result: $ld_shlibs" >&5
+echo "$as_me:6099: result: $ld_shlibs" >&5
 echo "${ECHO_T}$ld_shlibs" >&6
 test "$ld_shlibs" = no && can_build_shared=no
 
 # Check hardcoding attributes.
-echo "$as_me:5767: checking how to hardcode library paths into programs" >&5
+echo "$as_me:6104: checking how to hardcode library paths into programs" >&5
 echo $ECHO_N "checking how to hardcode library paths into programs... $ECHO_C" >&6
 hardcode_action=
 if test -n "$hardcode_libdir_flag_spec" || \
    test -n "$runpath_var"; then
 
   # We can hardcode non-existant directories.
@@ -5785,34 +6122,34 @@
   fi
 else
   # We cannot hardcode anything, or else we can only hardcode existing
   # directories.
   hardcode_action=unsupported
 fi
-echo "$as_me:5791: result: $hardcode_action" >&5
+echo "$as_me:6128: result: $hardcode_action" >&5
 echo "${ECHO_T}$hardcode_action" >&6
 
 striplib=
 old_striplib=
-echo "$as_me:5796: checking whether stripping libraries is possible" >&5
+echo "$as_me:6133: checking whether stripping libraries is possible" >&5
 echo $ECHO_N "checking whether stripping libraries is possible... $ECHO_C" >&6
 if test -n "$STRIP" && $STRIP -V 2>&1 | grep "GNU strip" >/dev/null; then
   test -z "$old_striplib" && old_striplib="$STRIP --strip-debug"
   test -z "$striplib" && striplib="$STRIP --strip-unneeded"
-  echo "$as_me:5801: result: yes" >&5
+  echo "$as_me:6138: result: yes" >&5
 echo "${ECHO_T}yes" >&6
 else
-  echo "$as_me:5804: result: no" >&5
+  echo "$as_me:6141: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 reload_cmds='$LD$reload_flag -o $output$reload_objs'
 test -z "$deplibs_check_method" && deplibs_check_method=unknown
 
 # PORTME Fill in your ld.so characteristics
-echo "$as_me:5812: checking dynamic linker characteristics" >&5
+echo "$as_me:6149: checking dynamic linker characteristics" >&5
 echo $ECHO_N "checking dynamic linker characteristics... $ECHO_C" >&6
 library_names_spec=
 libname_spec='lib$name'
 soname_spec=
 postinstall_cmds=
 postuninstall_cmds=
@@ -6199,23 +6536,23 @@
   ;;
 
 *)
   dynamic_linker=no
   ;;
 esac
-echo "$as_me:6205: result: $dynamic_linker" >&5
+echo "$as_me:6542: result: $dynamic_linker" >&5
 echo "${ECHO_T}$dynamic_linker" >&6
 test "$dynamic_linker" = no && can_build_shared=no
 
 # Report the final consequences.
-echo "$as_me:6210: checking if libtool supports shared libraries" >&5
+echo "$as_me:6547: checking if libtool supports shared libraries" >&5
 echo $ECHO_N "checking if libtool supports shared libraries... $ECHO_C" >&6
-echo "$as_me:6212: result: $can_build_shared" >&5
+echo "$as_me:6549: result: $can_build_shared" >&5
 echo "${ECHO_T}$can_build_shared" >&6
 
-echo "$as_me:6215: checking whether to build shared libraries" >&5
+echo "$as_me:6552: checking whether to build shared libraries" >&5
 echo $ECHO_N "checking whether to build shared libraries... $ECHO_C" >&6
 test "$can_build_shared" = "no" && enable_shared=no
 
 # On AIX, shared libraries and static libraries use the same namespace, and
 # are all built from PIC.
 case "$host_os" in
@@ -6230,20 +6567,20 @@
 aix4*)
   if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
     test "$enable_shared" = yes && enable_static=no
   fi
   ;;
 esac
-echo "$as_me:6236: result: $enable_shared" >&5
+echo "$as_me:6573: result: $enable_shared" >&5
 echo "${ECHO_T}$enable_shared" >&6
 
-echo "$as_me:6239: checking whether to build static libraries" >&5
+echo "$as_me:6576: checking whether to build static libraries" >&5
 echo $ECHO_N "checking whether to build static libraries... $ECHO_C" >&6
 # Make sure either enable_shared or enable_static is yes.
 test "$enable_shared" = yes || enable_static=yes
-echo "$as_me:6243: result: $enable_static" >&5
+echo "$as_me:6580: result: $enable_static" >&5
 echo "${ECHO_T}$enable_static" >&6
 
 if test "$hardcode_action" = relink; then
   # Fast installation is not supported
   enable_fast_install=no
 elif test "$shlibpath_overrides_runpath" = yes ||
@@ -6275,19 +6612,19 @@
   cygwin* | mingw* | pw32*)
     lt_cv_dlopen="LoadLibrary"
     lt_cv_dlopen_libs=
    ;;
 
   *)
-    echo "$as_me:6281: checking for shl_load" >&5
+    echo "$as_me:6618: checking for shl_load" >&5
 echo $ECHO_N "checking for shl_load... $ECHO_C" >&6
 if test "${ac_cv_func_shl_load+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 6287 "configure"
+#line 6624 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char shl_load (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -6312,45 +6649,45 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:6318: \"$ac_link\"") >&5
+if { (eval echo "$as_me:6655: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6321: \$? = $ac_status" >&5
+  echo "$as_me:6658: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:6324: \"$ac_try\"") >&5
+  { (eval echo "$as_me:6661: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:6327: \$? = $ac_status" >&5
+  echo "$as_me:6664: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_shl_load=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_shl_load=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:6337: result: $ac_cv_func_shl_load" >&5
+echo "$as_me:6674: result: $ac_cv_func_shl_load" >&5
 echo "${ECHO_T}$ac_cv_func_shl_load" >&6
 if test $ac_cv_func_shl_load = yes; then
   lt_cv_dlopen="shl_load"
 else
-  echo "$as_me:6342: checking for shl_load in -ldld" >&5
+  echo "$as_me:6679: checking for shl_load in -ldld" >&5
 echo $ECHO_N "checking for shl_load in -ldld... $ECHO_C" >&6
 if test "${ac_cv_lib_dld_shl_load+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldld  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 6350 "configure"
+#line 6687 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -6363,44 +6700,44 @@
 shl_load ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:6369: \"$ac_link\"") >&5
+if { (eval echo "$as_me:6706: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6372: \$? = $ac_status" >&5
+  echo "$as_me:6709: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:6375: \"$ac_try\"") >&5
+  { (eval echo "$as_me:6712: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:6378: \$? = $ac_status" >&5
+  echo "$as_me:6715: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_dld_shl_load=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_dld_shl_load=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:6389: result: $ac_cv_lib_dld_shl_load" >&5
+echo "$as_me:6726: result: $ac_cv_lib_dld_shl_load" >&5
 echo "${ECHO_T}$ac_cv_lib_dld_shl_load" >&6
 if test $ac_cv_lib_dld_shl_load = yes; then
   lt_cv_dlopen="shl_load" lt_cv_dlopen_libs="-dld"
 else
-  echo "$as_me:6394: checking for dlopen" >&5
+  echo "$as_me:6731: checking for dlopen" >&5
 echo $ECHO_N "checking for dlopen... $ECHO_C" >&6
 if test "${ac_cv_func_dlopen+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 6400 "configure"
+#line 6737 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -6425,45 +6762,45 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:6431: \"$ac_link\"") >&5
+if { (eval echo "$as_me:6768: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6434: \$? = $ac_status" >&5
+  echo "$as_me:6771: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:6437: \"$ac_try\"") >&5
+  { (eval echo "$as_me:6774: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:6440: \$? = $ac_status" >&5
+  echo "$as_me:6777: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_dlopen=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_dlopen=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:6450: result: $ac_cv_func_dlopen" >&5
+echo "$as_me:6787: result: $ac_cv_func_dlopen" >&5
 echo "${ECHO_T}$ac_cv_func_dlopen" >&6
 if test $ac_cv_func_dlopen = yes; then
   lt_cv_dlopen="dlopen"
 else
-  echo "$as_me:6455: checking for dlopen in -ldl" >&5
+  echo "$as_me:6792: checking for dlopen in -ldl" >&5
 echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
 if test "${ac_cv_lib_dl_dlopen+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldl  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 6463 "configure"
+#line 6800 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -6476,46 +6813,46 @@
 dlopen ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:6482: \"$ac_link\"") >&5
+if { (eval echo "$as_me:6819: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6485: \$? = $ac_status" >&5
+  echo "$as_me:6822: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:6488: \"$ac_try\"") >&5
+  { (eval echo "$as_me:6825: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:6491: \$? = $ac_status" >&5
+  echo "$as_me:6828: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_dl_dlopen=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_dl_dlopen=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:6502: result: $ac_cv_lib_dl_dlopen" >&5
+echo "$as_me:6839: result: $ac_cv_lib_dl_dlopen" >&5
 echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
 if test $ac_cv_lib_dl_dlopen = yes; then
   lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-ldl"
 else
-  echo "$as_me:6507: checking for dlopen in -lsvld" >&5
+  echo "$as_me:6844: checking for dlopen in -lsvld" >&5
 echo $ECHO_N "checking for dlopen in -lsvld... $ECHO_C" >&6
 if test "${ac_cv_lib_svld_dlopen+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsvld  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 6515 "configure"
+#line 6852 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -6528,46 +6865,46 @@
 dlopen ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:6534: \"$ac_link\"") >&5
+if { (eval echo "$as_me:6871: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6537: \$? = $ac_status" >&5
+  echo "$as_me:6874: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:6540: \"$ac_try\"") >&5
+  { (eval echo "$as_me:6877: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:6543: \$? = $ac_status" >&5
+  echo "$as_me:6880: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_svld_dlopen=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_svld_dlopen=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:6554: result: $ac_cv_lib_svld_dlopen" >&5
+echo "$as_me:6891: result: $ac_cv_lib_svld_dlopen" >&5
 echo "${ECHO_T}$ac_cv_lib_svld_dlopen" >&6
 if test $ac_cv_lib_svld_dlopen = yes; then
   lt_cv_dlopen="dlopen" lt_cv_dlopen_libs="-lsvld"
 else
-  echo "$as_me:6559: checking for dld_link in -ldld" >&5
+  echo "$as_me:6896: checking for dld_link in -ldld" >&5
 echo $ECHO_N "checking for dld_link in -ldld... $ECHO_C" >&6
 if test "${ac_cv_lib_dld_dld_link+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldld  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 6567 "configure"
+#line 6904 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -6580,33 +6917,33 @@
 dld_link ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:6586: \"$ac_link\"") >&5
+if { (eval echo "$as_me:6923: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6589: \$? = $ac_status" >&5
+  echo "$as_me:6926: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:6592: \"$ac_try\"") >&5
+  { (eval echo "$as_me:6929: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:6595: \$? = $ac_status" >&5
+  echo "$as_me:6932: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_dld_dld_link=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_dld_dld_link=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:6606: result: $ac_cv_lib_dld_dld_link" >&5
+echo "$as_me:6943: result: $ac_cv_lib_dld_dld_link" >&5
 echo "${ECHO_T}$ac_cv_lib_dld_dld_link" >&6
 if test $ac_cv_lib_dld_dld_link = yes; then
   lt_cv_dlopen="dld_link" lt_cv_dlopen_libs="-dld"
 fi
 
 fi
@@ -6636,24 +6973,24 @@
     save_LDFLAGS="$LDFLAGS"
     eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
 
     save_LIBS="$LIBS"
     LIBS="$lt_cv_dlopen_libs $LIBS"
 
-    echo "$as_me:6642: checking whether a program can dlopen itself" >&5
+    echo "$as_me:6979: checking whether a program can dlopen itself" >&5
 echo $ECHO_N "checking whether a program can dlopen itself... $ECHO_C" >&6
 if test "${lt_cv_dlopen_self+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self=cross
 else
     lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 6653 "configure"
+#line 6990 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -6708,16 +7045,16 @@
       /* dlclose (self); */
     }
 
     exit (status);
 }
 EOF
-  if { (eval echo "$as_me:6714: \"$ac_link\"") >&5
+  if { (eval echo "$as_me:7051: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6717: \$? = $ac_status" >&5
+  echo "$as_me:7054: \$? = $ac_status" >&5
   (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) 2>/dev/null
     lt_status=$?
     case x$lt_status in
       x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
       x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
@@ -6728,29 +7065,29 @@
     lt_cv_dlopen_self=no
   fi
 fi
 rm -fr conftest*
 
 fi
-echo "$as_me:6734: result: $lt_cv_dlopen_self" >&5
+echo "$as_me:7071: result: $lt_cv_dlopen_self" >&5
 echo "${ECHO_T}$lt_cv_dlopen_self" >&6
 
     if test "x$lt_cv_dlopen_self" = xyes; then
       LDFLAGS="$LDFLAGS $link_static_flag"
-      echo "$as_me:6739: checking whether a statically linked program can dlopen itself" >&5
+      echo "$as_me:7076: checking whether a statically linked program can dlopen itself" >&5
 echo $ECHO_N "checking whether a statically linked program can dlopen itself... $ECHO_C" >&6
 if test "${lt_cv_dlopen_self_static+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   	  if test "$cross_compiling" = yes; then :
   lt_cv_dlopen_self_static=cross
 else
     lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<EOF
-#line 6750 "configure"
+#line 7087 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
 #include <dlfcn.h>
 #endif
 
@@ -6805,16 +7142,16 @@
       /* dlclose (self); */
     }
 
     exit (status);
 }
 EOF
-  if { (eval echo "$as_me:6811: \"$ac_link\"") >&5
+  if { (eval echo "$as_me:7148: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:6814: \$? = $ac_status" >&5
+  echo "$as_me:7151: \$? = $ac_status" >&5
   (exit $ac_status); } && test -s conftest${ac_exeext} 2>/dev/null; then
     (./conftest; exit; ) 2>/dev/null
     lt_status=$?
     case x$lt_status in
       x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
       x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
@@ -6825,13 +7162,13 @@
     lt_cv_dlopen_self_static=no
   fi
 fi
 rm -fr conftest*
 
 fi
-echo "$as_me:6831: result: $lt_cv_dlopen_self_static" >&5
+echo "$as_me:7168: result: $lt_cv_dlopen_self_static" >&5
 echo "${ECHO_T}$lt_cv_dlopen_self_static" >&6
     fi
 
     CPPFLAGS="$save_CPPFLAGS"
     LDFLAGS="$save_LDFLAGS"
     LIBS="$save_LIBS"
@@ -6855,24 +7192,24 @@
     # FIXME: we may have to deal with multi-command sequences.
     ;;
   '$CC '*)
     # Test whether the compiler implicitly links with -lc since on some
     # systems, -lgcc has to come before -lc. If gcc already passes -lc
     # to ld, don't add -lc before -lgcc.
-    echo "$as_me:6861: checking whether -lc should be explicitly linked in" >&5
+    echo "$as_me:7198: checking whether -lc should be explicitly linked in" >&5
 echo $ECHO_N "checking whether -lc should be explicitly linked in... $ECHO_C" >&6
     if test "${lt_cv_archive_cmds_need_lc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   $rm conftest*
     echo 'static int dummy;' > conftest.$ac_ext
 
-    if { (eval echo "$as_me:6869: \"$ac_compile\"") >&5
+    if { (eval echo "$as_me:7206: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:6872: \$? = $ac_status" >&5
+  echo "$as_me:7209: \$? = $ac_status" >&5
   (exit $ac_status); }; then
       soname=conftest
       lib=conftest
       libobjs=conftest.$ac_objext
       deplibs=
       wl=$lt_cv_prog_cc_wl
@@ -6880,29 +7217,29 @@
       linker_flags=-v
       verstring=
       output_objdir=.
       libname=conftest
       save_allow_undefined_flag=$allow_undefined_flag
       allow_undefined_flag=
-      if { (eval echo "$as_me:6886: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\"") >&5
+      if { (eval echo "$as_me:7223: \"$archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1\"") >&5
   (eval $archive_cmds 2\>\&1 \| grep \" -lc \" \>/dev/null 2\>\&1) 2>&5
   ac_status=$?
-  echo "$as_me:6889: \$? = $ac_status" >&5
+  echo "$as_me:7226: \$? = $ac_status" >&5
   (exit $ac_status); }
       then
 	lt_cv_archive_cmds_need_lc=no
       else
 	lt_cv_archive_cmds_need_lc=yes
       fi
       allow_undefined_flag=$save_allow_undefined_flag
     else
       cat conftest.err 1>&5
     fi
 fi
 
-    echo "$as_me:6902: result: $lt_cv_archive_cmds_need_lc" >&5
+    echo "$as_me:7239: result: $lt_cv_archive_cmds_need_lc" >&5
 echo "${ECHO_T}$lt_cv_archive_cmds_need_lc" >&6
     ;;
   esac
 fi
 need_lc=${lt_cv_archive_cmds_need_lc-yes}
 
@@ -7461,13 +7798,13 @@
 
 # Always use our own libtool.
 LIBTOOL='$(SHELL) $(top_builddir)/libtool'
 
 # Prevent multiple expansion
 
-echo "$as_me:7467: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "$as_me:7804: checking whether ${MAKE-make} sets \${MAKE}" >&5
 echo $ECHO_N "checking whether ${MAKE-make} sets \${MAKE}... $ECHO_C" >&6
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y,./+-,__p_,'`
 if eval "test \"\${ac_cv_prog_make_${ac_make}_set+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.make <<\EOF
@@ -7481,123 +7818,268 @@
 else
   eval ac_cv_prog_make_${ac_make}_set=no
 fi
 rm -f conftest.make
 fi
 if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
-  echo "$as_me:7487: result: yes" >&5
+  echo "$as_me:7824: result: yes" >&5
 echo "${ECHO_T}yes" >&6
   SET_MAKE=
 else
-  echo "$as_me:7491: result: no" >&5
+  echo "$as_me:7828: result: no" >&5
 echo "${ECHO_T}no" >&6
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
-echo "$as_me:7496: checking whether to enable debug options" >&5
-echo $ECHO_N "checking whether to enable debug options... $ECHO_C" >&6
-# Check whether --enable-debug or --disable-debug was given.
-if test "${enable_debug+set}" = set; then
-  enableval="$enable_debug"
+echo "$as_me:7833: checking whether to support http" >&5
+echo $ECHO_N "checking whether to support http... $ECHO_C" >&6
+# Check whether --enable-http or --disable-http was given.
+if test "${enable_http+set}" = set; then
+  enableval="$enable_http"
    case "$enableval" in
   no)
-       echo "$as_me:7503: result: no" >&5
+       echo "$as_me:7840: result: no" >&5
 echo "${ECHO_T}no" >&6
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_HTTP 1
+EOF
+
+       { echo "$as_me:7846: WARNING: disable HTTP disables FTP over proxy and GOPHER too" >&5
+echo "$as_me: WARNING: disable HTTP disables FTP over proxy and GOPHER too" >&2;}
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_GOPHER 1
+EOF
+
        ;;
-  *)   echo "$as_me:7506: result: yes" >&5
+  *)   echo "$as_me:7853: result: yes" >&5
 echo "${ECHO_T}yes" >&6
-
-    CPPFLAGS="$CPPFLAGS -DMALLOCDEBUG"
-    CFLAGS="-W -Wall -Wwrite-strings -pedantic -g"
        ;;
   esac
 else
-  echo "$as_me:7514: result: no" >&5
-echo "${ECHO_T}no" >&6
+  echo "$as_me:7858: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 
 fi;
-
-echo "$as_me:7519: checking whether to enable ipv6" >&5
-echo $ECHO_N "checking whether to enable ipv6... $ECHO_C" >&6
-# Check whether --enable-ipv6 or --disable-ipv6 was given.
-if test "${enable_ipv6+set}" = set; then
-  enableval="$enable_ipv6"
+echo "$as_me:7862: checking whether to support ftp" >&5
+echo $ECHO_N "checking whether to support ftp... $ECHO_C" >&6
+# Check whether --enable-ftp or --disable-ftp was given.
+if test "${enable_ftp+set}" = set; then
+  enableval="$enable_ftp"
    case "$enableval" in
   no)
-       echo "$as_me:7526: result: no" >&5
+       echo "$as_me:7869: result: no" >&5
 echo "${ECHO_T}no" >&6
-       ipv6=no
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_FTP 1
+EOF
+
        ;;
-  *)   echo "$as_me:7530: result: yes" >&5
+  *)   echo "$as_me:7876: result: yes" >&5
 echo "${ECHO_T}yes" >&6
-       ipv6=yes
        ;;
   esac
 else
-  if test "$cross_compiling" = yes; then
-  echo "$as_me:7537: result: no" >&5
-echo "${ECHO_T}no" >&6
-  ipv6=no
+  echo "$as_me:7881: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 7543 "configure"
-#include "confdefs.h"
- /* is AF_INET6 available? */
-#include <sys/types.h>
-#include <sys/socket.h>
-main()
-{
- if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
-   exit(1);
- else
-   exit(0);
-}
+fi;
+echo "$as_me:7885: checking whether to support gopher" >&5
+echo $ECHO_N "checking whether to support gopher... $ECHO_C" >&6
+# Check whether --enable-gopher or --disable-gopher was given.
+if test "${enable_gopher+set}" = set; then
+  enableval="$enable_gopher"
+   case "$enableval" in
+  no)
+       echo "$as_me:7892: result: no" >&5
+echo "${ECHO_T}no" >&6
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_GOPHER 1
+EOF
 
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:7558: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:7561: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:7563: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:7566: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  echo "$as_me:7568: result: yes" >&5
+       ;;
+  *)   echo "$as_me:7899: result: yes" >&5
 echo "${ECHO_T}yes" >&6
-  ipv6=yes
+       ;;
+  esac
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-echo "$as_me:7575: result: no" >&5
-echo "${ECHO_T}no" >&6
-  ipv6=no
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
+  echo "$as_me:7904: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+fi;
+echo "$as_me:7908: checking whether to support file" >&5
+echo $ECHO_N "checking whether to support file... $ECHO_C" >&6
+# Check whether --enable-file or --disable-file was given.
+if test "${enable_file+set}" = set; then
+  enableval="$enable_file"
+   case "$enableval" in
+  no)
+       echo "$as_me:7915: result: no" >&5
+echo "${ECHO_T}no" >&6
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_FILE 1
+EOF
+
+       ;;
+  *)   echo "$as_me:7922: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+       ;;
+  esac
+else
+  echo "$as_me:7927: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+fi;
+echo "$as_me:7931: checking whether to support ldap" >&5
+echo $ECHO_N "checking whether to support ldap... $ECHO_C" >&6
+# Check whether --enable-ldap or --disable-ldap was given.
+if test "${enable_ldap+set}" = set; then
+  enableval="$enable_ldap"
+   case "$enableval" in
+  no)
+       echo "$as_me:7938: result: no" >&5
+echo "${ECHO_T}no" >&6
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_LDAP 1
+EOF
+
+       ;;
+  *)   echo "$as_me:7945: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+       ;;
+  esac
+else
+  echo "$as_me:7950: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+fi;
+echo "$as_me:7954: checking whether to support dict" >&5
+echo $ECHO_N "checking whether to support dict... $ECHO_C" >&6
+# Check whether --enable-dict or --disable-dict was given.
+if test "${enable_dict+set}" = set; then
+  enableval="$enable_dict"
+   case "$enableval" in
+  no)
+       echo "$as_me:7961: result: no" >&5
+echo "${ECHO_T}no" >&6
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_DICT 1
+EOF
+
+       ;;
+  *)   echo "$as_me:7968: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+       ;;
+  esac
+else
+  echo "$as_me:7973: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+fi;
+echo "$as_me:7977: checking whether to support telnet" >&5
+echo $ECHO_N "checking whether to support telnet... $ECHO_C" >&6
+# Check whether --enable-telnet or --disable-telnet was given.
+if test "${enable_telnet+set}" = set; then
+  enableval="$enable_telnet"
+   case "$enableval" in
+  no)
+       echo "$as_me:7984: result: no" >&5
+echo "${ECHO_T}no" >&6
+       cat >>confdefs.h <<\EOF
+#define CURL_DISABLE_TELNET 1
+EOF
+
+       ;;
+  *)   echo "$as_me:7991: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+       ;;
+  esac
+else
+  echo "$as_me:7996: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+fi;
+
+echo "$as_me:8001: checking whether to enable ipv6" >&5
+echo $ECHO_N "checking whether to enable ipv6... $ECHO_C" >&6
+# Check whether --enable-ipv6 or --disable-ipv6 was given.
+if test "${enable_ipv6+set}" = set; then
+  enableval="$enable_ipv6"
+   case "$enableval" in
+  no)
+       echo "$as_me:8008: result: no" >&5
+echo "${ECHO_T}no" >&6
+       ipv6=no
+       ;;
+  *)   echo "$as_me:8012: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+       ipv6=yes
+       ;;
+  esac
+else
+  if test "$cross_compiling" = yes; then
+  echo "$as_me:8019: result: no" >&5
+echo "${ECHO_T}no" >&6
+  ipv6=no
+
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 8025 "configure"
+#include "confdefs.h"
+ /* is AF_INET6 available? */
+#include <sys/types.h>
+#include <sys/socket.h>
+main()
+{
+ if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+   exit(1);
+ else
+   exit(0);
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:8040: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:8043: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:8045: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:8048: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:8050: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+  ipv6=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+echo "$as_me:8057: result: no" >&5
+echo "${ECHO_T}no" >&6
+  ipv6=no
+fi
+rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
 fi;
 
 if test "$ipv6" = "yes"; then
 
-  echo "$as_me:7585: checking for working getaddrinfo" >&5
+  echo "$as_me:8067: checking for working getaddrinfo" >&5
 echo $ECHO_N "checking for working getaddrinfo... $ECHO_C" >&6
 if test "${ac_cv_working_getaddrinfo+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
   if test "$cross_compiling" = yes; then
 
   ac_cv_working_getaddrinfo="yes"
 
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 7597 "configure"
+#line 8079 "configure"
 #include "confdefs.h"
 
 #include <netdb.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 
@@ -7616,21 +8098,21 @@
         exit(0);
     }
 }
 
 _ACEOF
 rm -f conftest$ac_exeext
-if { (eval echo "$as_me:7622: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8104: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:7625: \$? = $ac_status" >&5
+  echo "$as_me:8107: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:7627: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8109: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:7630: \$? = $ac_status" >&5
+  echo "$as_me:8112: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
 
   ac_cv_working_getaddrinfo="yes"
 
 else
   echo "$as_me: program exited with status $ac_status" >&5
@@ -7640,13 +8122,13 @@
   ac_cv_working_getaddrinfo="no"
 
 fi
 rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
-echo "$as_me:7646: result: $ac_cv_working_getaddrinfo" >&5
+echo "$as_me:8128: result: $ac_cv_working_getaddrinfo" >&5
 echo "${ECHO_T}$ac_cv_working_getaddrinfo" >&6
 if test "$ac_cv_working_getaddrinfo" = "yes"; then
 
 cat >>confdefs.h <<\EOF
 #define HAVE_GETADDRINFO 1
 EOF
@@ -7658,19 +8140,19 @@
   IPV6_ENABLED=1
 
 fi
 
 fi
 
-echo "$as_me:7664: checking for gethostbyname" >&5
+echo "$as_me:8146: checking for gethostbyname" >&5
 echo $ECHO_N "checking for gethostbyname... $ECHO_C" >&6
 if test "${ac_cv_func_gethostbyname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 7670 "configure"
+#line 8152 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -7695,46 +8177,46 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:7701: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8183: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:7704: \$? = $ac_status" >&5
+  echo "$as_me:8186: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:7707: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8189: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:7710: \$? = $ac_status" >&5
+  echo "$as_me:8192: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_gethostbyname=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_gethostbyname=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:7720: result: $ac_cv_func_gethostbyname" >&5
+echo "$as_me:8202: result: $ac_cv_func_gethostbyname" >&5
 echo "${ECHO_T}$ac_cv_func_gethostbyname" >&6
 if test $ac_cv_func_gethostbyname = yes; then
   :
 else
 
-echo "$as_me:7726: checking for gethostbyname in -lnsl" >&5
+echo "$as_me:8208: checking for gethostbyname in -lnsl" >&5
 echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
 if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnsl  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 7734 "configure"
+#line 8216 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -7747,33 +8229,33 @@
 gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:7753: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8235: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:7756: \$? = $ac_status" >&5
+  echo "$as_me:8238: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:7759: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8241: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:7762: \$? = $ac_status" >&5
+  echo "$as_me:8244: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_nsl_gethostbyname=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_nsl_gethostbyname=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:7773: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "$as_me:8255: result: $ac_cv_lib_nsl_gethostbyname" >&5
 echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
 if test $ac_cv_lib_nsl_gethostbyname = yes; then
   cat >>confdefs.h <<EOF
 #define HAVE_LIBNSL 1
 EOF
 
@@ -7781,19 +8263,19 @@
 
 fi
 
 fi
 
 if test "$ac_cv_lib_nsl_gethostbyname" != "yes" -a "$ac_cv_func_gethostbyname" != "yes"; then
-    echo "$as_me:7787: checking for gethostbyname" >&5
+    echo "$as_me:8269: checking for gethostbyname" >&5
 echo $ECHO_N "checking for gethostbyname... $ECHO_C" >&6
 if test "${ac_cv_func_gethostbyname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 7793 "configure"
+#line 8275 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -7818,46 +8300,46 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:7824: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8306: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:7827: \$? = $ac_status" >&5
+  echo "$as_me:8309: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:7830: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8312: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:7833: \$? = $ac_status" >&5
+  echo "$as_me:8315: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_gethostbyname=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_gethostbyname=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:7843: result: $ac_cv_func_gethostbyname" >&5
+echo "$as_me:8325: result: $ac_cv_func_gethostbyname" >&5
 echo "${ECHO_T}$ac_cv_func_gethostbyname" >&6
 if test $ac_cv_func_gethostbyname = yes; then
   :
 else
 
-echo "$as_me:7849: checking for gethostbyname in -lsocket" >&5
+echo "$as_me:8331: checking for gethostbyname in -lsocket" >&5
 echo $ECHO_N "checking for gethostbyname in -lsocket... $ECHO_C" >&6
 if test "${ac_cv_lib_socket_gethostbyname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsocket  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 7857 "configure"
+#line 8339 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -7870,33 +8352,33 @@
 gethostbyname ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:7876: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8358: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:7879: \$? = $ac_status" >&5
+  echo "$as_me:8361: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:7882: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8364: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:7885: \$? = $ac_status" >&5
+  echo "$as_me:8367: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_socket_gethostbyname=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_socket_gethostbyname=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:7896: result: $ac_cv_lib_socket_gethostbyname" >&5
+echo "$as_me:8378: result: $ac_cv_lib_socket_gethostbyname" >&5
 echo "${ECHO_T}$ac_cv_lib_socket_gethostbyname" >&6
 if test $ac_cv_lib_socket_gethostbyname = yes; then
   cat >>confdefs.h <<EOF
 #define HAVE_LIBSOCKET 1
 EOF
 
@@ -7906,68 +8388,68 @@
 
 fi
 
 fi
 
 if test "$ac_cv_lib_nsl_gethostbyname" = "$ac_cv_func_gethostbyname"; then
-  echo "$as_me:7912: checking trying both nsl and socket libs" >&5
+  echo "$as_me:8394: checking trying both nsl and socket libs" >&5
 echo $ECHO_N "checking trying both nsl and socket libs... $ECHO_C" >&6
   my_ac_save_LIBS=$LIBS
   LIBS="-lnsl -lsocket $LIBS"
   cat >conftest.$ac_ext <<_ACEOF
-#line 7917 "configure"
+#line 8399 "configure"
 #include "confdefs.h"
 
 int
 main ()
 {
 gethostbyname();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:7929: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8411: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:7932: \$? = $ac_status" >&5
+  echo "$as_me:8414: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:7935: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8417: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:7938: \$? = $ac_status" >&5
+  echo "$as_me:8420: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   my_ac_link_result=success
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 my_ac_link_result=failure
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 
   if test "$my_ac_link_result" = "failure"; then
-    echo "$as_me:7949: result: no" >&5
+    echo "$as_me:8431: result: no" >&5
 echo "${ECHO_T}no" >&6
-    { { echo "$as_me:7951: error: couldn't find libraries for gethostbyname()" >&5
+    { { echo "$as_me:8433: error: couldn't find libraries for gethostbyname()" >&5
 echo "$as_me: error: couldn't find libraries for gethostbyname()" >&2;}
    { (exit 1); exit 1; }; }
         LIBS=$my_ac_save_LIBS
   else
-    echo "$as_me:7956: result: yes" >&5
+    echo "$as_me:8438: result: yes" >&5
 echo "${ECHO_T}yes" >&6
   fi
 fi
 
-echo "$as_me:7961: checking for strcasecmp" >&5
+echo "$as_me:8443: checking for strcasecmp" >&5
 echo $ECHO_N "checking for strcasecmp... $ECHO_C" >&6
 if test "${ac_cv_func_strcasecmp+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 7967 "configure"
+#line 8449 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char strcasecmp (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -7992,46 +8474,46 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:7998: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8480: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8001: \$? = $ac_status" >&5
+  echo "$as_me:8483: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8004: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8486: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8007: \$? = $ac_status" >&5
+  echo "$as_me:8489: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_strcasecmp=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_strcasecmp=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:8017: result: $ac_cv_func_strcasecmp" >&5
+echo "$as_me:8499: result: $ac_cv_func_strcasecmp" >&5
 echo "${ECHO_T}$ac_cv_func_strcasecmp" >&6
 if test $ac_cv_func_strcasecmp = yes; then
   :
 else
 
-echo "$as_me:8023: checking for strcasecmp in -lresolve" >&5
+echo "$as_me:8505: checking for strcasecmp in -lresolve" >&5
 echo $ECHO_N "checking for strcasecmp in -lresolve... $ECHO_C" >&6
 if test "${ac_cv_lib_resolve_strcasecmp+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lresolve  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 8031 "configure"
+#line 8513 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -8044,33 +8526,33 @@
 strcasecmp ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8050: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8532: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8053: \$? = $ac_status" >&5
+  echo "$as_me:8535: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8056: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8538: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8059: \$? = $ac_status" >&5
+  echo "$as_me:8541: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_resolve_strcasecmp=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_resolve_strcasecmp=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:8070: result: $ac_cv_lib_resolve_strcasecmp" >&5
+echo "$as_me:8552: result: $ac_cv_lib_resolve_strcasecmp" >&5
 echo "${ECHO_T}$ac_cv_lib_resolve_strcasecmp" >&6
 if test $ac_cv_lib_resolve_strcasecmp = yes; then
   cat >>confdefs.h <<EOF
 #define HAVE_LIBRESOLVE 1
 EOF
 
@@ -8078,21 +8560,21 @@
 
 fi
 
 fi
 
 if test "$ac_cv_lib_resolve_strcasecmp" = "$ac_cv_func_strcasecmp"; then
-  echo "$as_me:8084: checking for strcasecmp in -lresolve" >&5
+  echo "$as_me:8566: checking for strcasecmp in -lresolve" >&5
 echo $ECHO_N "checking for strcasecmp in -lresolve... $ECHO_C" >&6
 if test "${ac_cv_lib_resolve_strcasecmp+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lresolve -lnsl $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 8092 "configure"
+#line 8574 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -8105,47 +8587,47 @@
 strcasecmp ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8111: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8593: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8114: \$? = $ac_status" >&5
+  echo "$as_me:8596: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8117: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8599: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8120: \$? = $ac_status" >&5
+  echo "$as_me:8602: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_resolve_strcasecmp=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_resolve_strcasecmp=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:8131: result: $ac_cv_lib_resolve_strcasecmp" >&5
+echo "$as_me:8613: result: $ac_cv_lib_resolve_strcasecmp" >&5
 echo "${ECHO_T}$ac_cv_lib_resolve_strcasecmp" >&6
 if test $ac_cv_lib_resolve_strcasecmp = yes; then
   LIBS="-lresolve $LIBS"
 fi
 
 fi
 
-echo "$as_me:8139: checking for connect" >&5
+echo "$as_me:8621: checking for connect" >&5
 echo $ECHO_N "checking for connect... $ECHO_C" >&6
 if test "${ac_cv_func_connect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 8145 "configure"
+#line 8627 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char connect (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -8170,46 +8652,46 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8176: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8658: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8179: \$? = $ac_status" >&5
+  echo "$as_me:8661: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8182: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8664: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8185: \$? = $ac_status" >&5
+  echo "$as_me:8667: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_connect=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_connect=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:8195: result: $ac_cv_func_connect" >&5
+echo "$as_me:8677: result: $ac_cv_func_connect" >&5
 echo "${ECHO_T}$ac_cv_func_connect" >&6
 if test $ac_cv_func_connect = yes; then
   :
 else
 
-echo "$as_me:8201: checking for connect in -lsocket" >&5
+echo "$as_me:8683: checking for connect in -lsocket" >&5
 echo $ECHO_N "checking for connect in -lsocket... $ECHO_C" >&6
 if test "${ac_cv_lib_socket_connect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsocket  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 8209 "configure"
+#line 8691 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -8222,52 +8704,52 @@
 connect ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8228: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8710: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8231: \$? = $ac_status" >&5
+  echo "$as_me:8713: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8234: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8716: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8237: \$? = $ac_status" >&5
+  echo "$as_me:8719: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_socket_connect=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_socket_connect=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:8248: result: $ac_cv_lib_socket_connect" >&5
+echo "$as_me:8730: result: $ac_cv_lib_socket_connect" >&5
 echo "${ECHO_T}$ac_cv_lib_socket_connect" >&6
 if test $ac_cv_lib_socket_connect = yes; then
   cat >>confdefs.h <<EOF
 #define HAVE_LIBSOCKET 1
 EOF
 
   LIBS="-lsocket $LIBS"
 
 fi
 
 fi
 
-echo "$as_me:8261: checking for gethostname" >&5
+echo "$as_me:8743: checking for gethostname" >&5
 echo $ECHO_N "checking for gethostname... $ECHO_C" >&6
 if test "${ac_cv_func_gethostname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 8267 "configure"
+#line 8749 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostname (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -8292,46 +8774,46 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8298: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8780: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8301: \$? = $ac_status" >&5
+  echo "$as_me:8783: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8304: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8786: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8307: \$? = $ac_status" >&5
+  echo "$as_me:8789: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_gethostname=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_gethostname=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:8317: result: $ac_cv_func_gethostname" >&5
+echo "$as_me:8799: result: $ac_cv_func_gethostname" >&5
 echo "${ECHO_T}$ac_cv_func_gethostname" >&6
 if test $ac_cv_func_gethostname = yes; then
   :
 else
 
-echo "$as_me:8323: checking for gethostname in -lucb" >&5
+echo "$as_me:8805: checking for gethostname in -lucb" >&5
 echo $ECHO_N "checking for gethostname in -lucb... $ECHO_C" >&6
 if test "${ac_cv_lib_ucb_gethostname+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lucb  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 8331 "configure"
+#line 8813 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -8344,52 +8826,52 @@
 gethostname ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8350: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8832: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8353: \$? = $ac_status" >&5
+  echo "$as_me:8835: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8356: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8838: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8359: \$? = $ac_status" >&5
+  echo "$as_me:8841: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_ucb_gethostname=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_ucb_gethostname=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:8370: result: $ac_cv_lib_ucb_gethostname" >&5
+echo "$as_me:8852: result: $ac_cv_lib_ucb_gethostname" >&5
 echo "${ECHO_T}$ac_cv_lib_ucb_gethostname" >&6
 if test $ac_cv_lib_ucb_gethostname = yes; then
   cat >>confdefs.h <<EOF
 #define HAVE_LIBUCB 1
 EOF
 
   LIBS="-lucb $LIBS"
 
 fi
 
 fi
 
-echo "$as_me:8383: checking for dlclose" >&5
+echo "$as_me:8865: checking for dlclose" >&5
 echo $ECHO_N "checking for dlclose... $ECHO_C" >&6
 if test "${ac_cv_func_dlclose+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 8389 "configure"
+#line 8871 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlclose (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -8414,46 +8896,46 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8420: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8902: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8423: \$? = $ac_status" >&5
+  echo "$as_me:8905: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8426: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8908: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8429: \$? = $ac_status" >&5
+  echo "$as_me:8911: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_func_dlclose=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_func_dlclose=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:8439: result: $ac_cv_func_dlclose" >&5
+echo "$as_me:8921: result: $ac_cv_func_dlclose" >&5
 echo "${ECHO_T}$ac_cv_func_dlclose" >&6
 if test $ac_cv_func_dlclose = yes; then
   :
 else
 
-echo "$as_me:8445: checking for dlopen in -ldl" >&5
+echo "$as_me:8927: checking for dlopen in -ldl" >&5
 echo $ECHO_N "checking for dlopen in -ldl... $ECHO_C" >&6
 if test "${ac_cv_lib_dl_dlopen+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-ldl  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 8453 "configure"
+#line 8935 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
@@ -8466,995 +8948,880 @@
 dlopen ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8472: \"$ac_link\"") >&5
+if { (eval echo "$as_me:8954: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:8475: \$? = $ac_status" >&5
+  echo "$as_me:8957: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8478: \"$ac_try\"") >&5
+  { (eval echo "$as_me:8960: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8481: \$? = $ac_status" >&5
+  echo "$as_me:8963: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_lib_dl_dlopen=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_lib_dl_dlopen=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:8492: result: $ac_cv_lib_dl_dlopen" >&5
+echo "$as_me:8974: result: $ac_cv_lib_dl_dlopen" >&5
 echo "${ECHO_T}$ac_cv_lib_dl_dlopen" >&6
 if test $ac_cv_lib_dl_dlopen = yes; then
   cat >>confdefs.h <<EOF
 #define HAVE_LIBDL 1
 EOF
 
   LIBS="-ldl $LIBS"
 
 fi
 
 fi
 
-# Check whether --with-egd-socket or --without-egd-socket was given.
-if test "${with_egd_socket+set}" = set; then
-  withval="$with_egd_socket"
-   EGD_SOCKET="$withval"
-
-fi;
-if test -n "$EGD_SOCKET" ; then
-	cat >>confdefs.h <<EOF
-#define EGD_SOCKET "$EGD_SOCKET"
-EOF
-
-fi
-
-# Check whether --with-random or --without-random was given.
-if test "${with_random+set}" = set; then
-  withval="$with_random"
-   RANDOM_FILE="$withval"
-else
-
-                echo "$as_me:8524: checking for \"/dev/urandom\"" >&5
-echo $ECHO_N "checking for \"/dev/urandom\"... $ECHO_C" >&6
-if test "${ac_cv_file___dev_urandom_+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  test "$cross_compiling" = yes &&
-  { { echo "$as_me:8530: error: cannot check for file existence when cross compiling" >&5
-echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-if test -r ""/dev/urandom""; then
-  ac_cv_file___dev_urandom_=yes
-else
-  ac_cv_file___dev_urandom_=no
-fi
-fi
-echo "$as_me:8539: result: $ac_cv_file___dev_urandom_" >&5
-echo "${ECHO_T}$ac_cv_file___dev_urandom_" >&6
-if test $ac_cv_file___dev_urandom_ = yes; then
-
-                RANDOM_FILE="/dev/urandom";
-
-fi
-
-fi;
-if test -n "$RANDOM_FILE" ; then
+# Check whether --enable-nonblocking or --disable-nonblocking was given.
+if test "${enable_nonblocking+set}" = set; then
+  enableval="$enable_nonblocking"
 
-	cat >>confdefs.h <<EOF
-#define RANDOM_FILE "$RANDOM_FILE"
+  if test "$enableval" = "no" ; then
+    { echo "$as_me:8992: WARNING: non-blocking sockets disabled" >&5
+echo "$as_me: WARNING: non-blocking sockets disabled" >&2;}
+    cat >>confdefs.h <<\EOF
+#define HAVE_DISABLED_NONBLOCKING 1
 EOF
 
-fi
-
-# Check whether --with-krb4-includes or --without-krb4-includes was given.
-if test "${with_krb4_includes+set}" = set; then
-  withval="$with_krb4_includes"
-
- CPPFLAGS="$CPPFLAGS -I$withval"
- KRB4INC="$withval"
- want_krb4=yes
-
-fi;
-
-# Check whether --with-krb4-libs or --without-krb4-libs was given.
-if test "${with_krb4_libs+set}" = set; then
-  withval="$with_krb4_libs"
+  else
 
- LDFLAGS="$LDFLAGS -L$withval"
- KRB4LIB="$withval"
- want_krb4=yes
+  echo "$as_me:9000: checking non-blocking sockets style" >&5
+echo $ECHO_N "checking non-blocking sockets style... $ECHO_C" >&6
 
-fi;
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9004 "configure"
+#include "confdefs.h"
 
-OPT_KRB4=off
+/* headers for O_NONBLOCK test */
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
 
-# Check whether --with-krb4 or --without-krb4 was given.
-if test "${with_krb4+set}" = set; then
-  withval="$with_krb4"
+int
+main ()
+{
 
-  OPT_KRB4="$withval"
-  if test X"$OPT_KRB4" != Xyes
-  then
-    LDFLAGS="$LDFLAGS -L$OPT_KRB4/lib"
-    KRB4LIB="$OPT_KRB4/lib"
-    CPPFLAGS="$CPPFLAGS -I$OPT_KRB4/include"
-    KRB4INC="$OPT_KRB4/include"
-  fi
-  want_krb4="yes"
+/* try to compile O_NONBLOCK */
 
-fi;
+#if defined(sun) || defined(__sun__) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+# if defined(__SVR4) || defined(__srv4__)
+#  define PLATFORM_SOLARIS
+# else
+#  define PLATFORM_SUNOS4
+# endif
+#endif
+#if (defined(_AIX) || defined(__xlC__)) && !defined(_AIX4)
+# define PLATFORM_AIX_V3
+#endif
 
-echo "$as_me:8594: checking if Kerberos4 support is requested" >&5
-echo $ECHO_N "checking if Kerberos4 support is requested... $ECHO_C" >&6
+#if defined(PLATFORM_SUNOS4) || defined(PLATFORM_AIX_V3)
+#error "O_NONBLOCK does not work on this platform"
+#endif
+  int socket;
+  int flags = fcntl(socket, F_SETFL, flags | O_NONBLOCK);
 
-if test "$want_krb4" = yes
-then
-  if test "$ipv6" = "yes"; then
-    echo krb4 is not compatible with IPv6
-    exit 1
-  fi
-  echo "$as_me:8603: result: yes" >&5
-echo "${ECHO_T}yes" >&6
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9040: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:9043: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9046: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:9049: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
 
-  echo "$as_me:8606: checking where to look for Kerberos4" >&5
-echo $ECHO_N "checking where to look for Kerberos4... $ECHO_C" >&6
-  if test X"$OPT_KRB4" = Xyes
-  then
-    echo "$as_me:8610: result: defaults" >&5
-echo "${ECHO_T}defaults" >&6
-  else
-    echo "$as_me:8613: result: libs in $KRB4LIB, headers in $KRB4INC" >&5
-echo "${ECHO_T}libs in $KRB4LIB, headers in $KRB4INC" >&6
-  fi
+nonblock="O_NONBLOCK"
+cat >>confdefs.h <<\EOF
+#define HAVE_O_NONBLOCK 1
+EOF
 
-    echo "$as_me:8617: checking for des_pcbc_encrypt in -ldes" >&5
-echo $ECHO_N "checking for des_pcbc_encrypt in -ldes... $ECHO_C" >&6
-if test "${ac_cv_lib_des_des_pcbc_encrypt+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-ldes  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-#line 8625 "configure"
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9062 "configure"
 #include "confdefs.h"
 
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char des_pcbc_encrypt ();
+/* headers for FIONBIO test */
+#include <unistd.h>
+#include <stropts.h>
+
 int
 main ()
 {
-des_pcbc_encrypt ();
+
+/* FIONBIO source test */
+ int flags = ioctl(socket, FIONBIO, &flags);
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8644: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9081: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:8647: \$? = $ac_status" >&5
+  echo "$as_me:9084: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8650: \"$ac_try\"") >&5
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9087: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8653: \$? = $ac_status" >&5
+  echo "$as_me:9090: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_des_des_pcbc_encrypt=yes
+
+nonblock="FIONBIO"
+cat >>confdefs.h <<\EOF
+#define HAVE_FIONBIO 1
+EOF
+
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_des_des_pcbc_encrypt=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:8664: result: $ac_cv_lib_des_des_pcbc_encrypt" >&5
-echo "${ECHO_T}$ac_cv_lib_des_des_pcbc_encrypt" >&6
-if test $ac_cv_lib_des_des_pcbc_encrypt = yes; then
 
-for ac_header in des.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:8671: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
   cat >conftest.$ac_ext <<_ACEOF
-#line 8677 "configure"
+#line 9103 "configure"
 #include "confdefs.h"
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:8681: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:8687: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  eval "$as_ac_Header=yes"
-else
-  echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  eval "$as_ac_Header=no"
-fi
-rm -f conftest.err conftest.$ac_ext
-fi
-echo "$as_me:8706: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-EOF
 
-fi
-done
-
-        echo "$as_me:8716: checking for res_search" >&5
-echo $ECHO_N "checking for res_search... $ECHO_C" >&6
-if test "${ac_cv_func_res_search+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 8722 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char res_search (); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char res_search ();
-char (*f) ();
+/* headers for ioctlsocket test (cygwin?) */
+#include <windows.h>
 
 int
 main ()
 {
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_res_search) || defined (__stub___res_search)
-choke me
-#else
-f = res_search;
-#endif
+
+/* ioctlsocket source code */
+ int flags = ioctlsocket(socket, FIONBIO, &flags);
 
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8753: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9121: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:8756: \$? = $ac_status" >&5
+  echo "$as_me:9124: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8759: \"$ac_try\"") >&5
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9127: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8762: \$? = $ac_status" >&5
+  echo "$as_me:9130: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_func_res_search=yes
+
+nonblock="ioctlsocket"
+cat >>confdefs.h <<\EOF
+#define HAVE_IOCTLSOCKET 1
+EOF
+
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_func_res_search=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-fi
-echo "$as_me:8772: result: $ac_cv_func_res_search" >&5
-echo "${ECHO_T}$ac_cv_func_res_search" >&6
-if test $ac_cv_func_res_search = yes; then
-  :
-else
 
-echo "$as_me:8778: checking for res_search in -lresolv" >&5
-echo $ECHO_N "checking for res_search in -lresolv... $ECHO_C" >&6
-if test "${ac_cv_lib_resolv_res_search+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lresolv  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-#line 8786 "configure"
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9143 "configure"
 #include "confdefs.h"
 
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char res_search ();
+/* headers for IoctlSocket test (Amiga?) */
+#include <sys/ioctl.h>
+
 int
 main ()
 {
-res_search ();
+
+/* IoctlSocket source code */
+ int flags = IoctlSocket(socket, FIONBIO, (long)1);
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8805: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9161: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:8808: \$? = $ac_status" >&5
+  echo "$as_me:9164: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8811: \"$ac_try\"") >&5
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9167: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8814: \$? = $ac_status" >&5
+  echo "$as_me:9170: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_resolv_res_search=yes
+
+nonblock="IoctlSocket"
+cat >>confdefs.h <<\EOF
+#define HAVE_IOCTLSOCKET_CASE 1
+EOF
+
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_resolv_res_search=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:8825: result: $ac_cv_lib_resolv_res_search" >&5
-echo "${ECHO_T}$ac_cv_lib_resolv_res_search" >&6
-if test $ac_cv_lib_resolv_res_search = yes; then
-  cat >>confdefs.h <<EOF
-#define HAVE_LIBRESOLV 1
+
+nonblock="nada"
+cat >>confdefs.h <<\EOF
+#define HAVE_DISABLED_NONBLOCKING 1
 EOF
 
-  LIBS="-lresolv $LIBS"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  echo "$as_me:9198: result: $nonblock" >&5
+echo "${ECHO_T}$nonblock" >&6
+
+  if test "$nonblock" = "nada"; then
+    { echo "$as_me:9202: WARNING: non-block sockets disabled" >&5
+echo "$as_me: WARNING: non-block sockets disabled" >&2;}
+  fi
+
+  fi
 
-        echo "$as_me:8838: checking for krb_net_read in -lkrb" >&5
-echo $ECHO_N "checking for krb_net_read in -lkrb... $ECHO_C" >&6
-if test "${ac_cv_lib_krb_krb_net_read+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lkrb  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-#line 8846 "configure"
+
+  echo "$as_me:9210: checking non-blocking sockets style" >&5
+echo $ECHO_N "checking non-blocking sockets style... $ECHO_C" >&6
+
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9214 "configure"
 #include "confdefs.h"
 
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char krb_net_read ();
+/* headers for O_NONBLOCK test */
+#include <sys/types.h>
+#include <unistd.h>
+#include <fcntl.h>
+
 int
 main ()
 {
-krb_net_read ();
+
+/* try to compile O_NONBLOCK */
+
+#if defined(sun) || defined(__sun__) || defined(__SUNPRO_C) || defined(__SUNPRO_CC)
+# if defined(__SVR4) || defined(__srv4__)
+#  define PLATFORM_SOLARIS
+# else
+#  define PLATFORM_SUNOS4
+# endif
+#endif
+#if (defined(_AIX) || defined(__xlC__)) && !defined(_AIX4)
+# define PLATFORM_AIX_V3
+#endif
+
+#if defined(PLATFORM_SUNOS4) || defined(PLATFORM_AIX_V3)
+#error "O_NONBLOCK does not work on this platform"
+#endif
+  int socket;
+  int flags = fcntl(socket, F_SETFL, flags | O_NONBLOCK);
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8865: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9250: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:8868: \$? = $ac_status" >&5
+  echo "$as_me:9253: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8871: \"$ac_try\"") >&5
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9256: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8874: \$? = $ac_status" >&5
+  echo "$as_me:9259: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_krb_krb_net_read=yes
+
+nonblock="O_NONBLOCK"
+cat >>confdefs.h <<\EOF
+#define HAVE_O_NONBLOCK 1
+EOF
+
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_krb_krb_net_read=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:8885: result: $ac_cv_lib_krb_krb_net_read" >&5
-echo "${ECHO_T}$ac_cv_lib_krb_krb_net_read" >&6
-if test $ac_cv_lib_krb_krb_net_read = yes; then
 
-for ac_header in krb.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:8892: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
   cat >conftest.$ac_ext <<_ACEOF
-#line 8898 "configure"
+#line 9272 "configure"
 #include "confdefs.h"
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:8902: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:8908: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  eval "$as_ac_Header=yes"
-else
-  echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  eval "$as_ac_Header=no"
-fi
-rm -f conftest.err conftest.$ac_ext
-fi
-echo "$as_me:8927: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-EOF
-
-fi
-done
-
-            LIBS="-lkrb -ldes $LIBS"
 
-for ac_func in krb_get_our_ip_for_realm
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:8942: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 8948 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-char (*f) ();
+/* headers for FIONBIO test */
+#include <unistd.h>
+#include <stropts.h>
 
 int
 main ()
 {
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-f = $ac_func;
-#endif
+
+/* FIONBIO source test */
+ int flags = ioctl(socket, FIONBIO, &flags);
 
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:8979: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9291: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:8982: \$? = $ac_status" >&5
+  echo "$as_me:9294: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:8985: \"$ac_try\"") >&5
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9297: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:8988: \$? = $ac_status" >&5
+  echo "$as_me:9300: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+
+nonblock="FIONBIO"
+cat >>confdefs.h <<\EOF
+#define HAVE_FIONBIO 1
+EOF
+
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-eval "$as_ac_var=no"
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-fi
-echo "$as_me:8998: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-EOF
 
-fi
-done
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9313 "configure"
+#include "confdefs.h"
 
-            cat >>confdefs.h <<\EOF
-#define KRB4 1
-EOF
+/* headers for ioctlsocket test (cygwin?) */
+#include <windows.h>
 
-            KRB4_ENABLED=1
+int
+main ()
+{
+
+/* ioctlsocket source code */
+ int flags = ioctlsocket(socket, FIONBIO, &flags);
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9331: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:9334: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9337: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:9340: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+nonblock="ioctlsocket"
+cat >>confdefs.h <<\EOF
+#define HAVE_IOCTLSOCKET 1
+EOF
 
-for ac_func in strlcpy
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:9017: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+
   cat >conftest.$ac_ext <<_ACEOF
-#line 9023 "configure"
+#line 9353 "configure"
 #include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-char (*f) ();
+
+/* headers for IoctlSocket test (Amiga?) */
+#include <sys/ioctl.h>
 
 int
 main ()
 {
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-f = $ac_func;
-#endif
+
+/* IoctlSocket source code */
+ int flags = IoctlSocket(socket, FIONBIO, (long)1);
 
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9054: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:9371: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:9057: \$? = $ac_status" >&5
+  echo "$as_me:9374: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9060: \"$ac_try\"") >&5
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:9377: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9063: \$? = $ac_status" >&5
+  echo "$as_me:9380: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+
+nonblock="IoctlSocket"
+cat >>confdefs.h <<\EOF
+#define HAVE_IOCTLSOCKET_CASE 1
+EOF
+
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-eval "$as_ac_var=no"
+
+nonblock="nada"
+cat >>confdefs.h <<\EOF
+#define HAVE_DISABLED_NONBLOCKING 1
+EOF
+
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest.$ac_ext
+
 fi
-echo "$as_me:9073: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-EOF
+rm -f conftest.$ac_objext conftest.$ac_ext
 
 fi
-done
+rm -f conftest.$ac_objext conftest.$ac_ext
 
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+  echo "$as_me:9408: result: $nonblock" >&5
+echo "${ECHO_T}$nonblock" >&6
+
+  if test "$nonblock" = "nada"; then
+    { echo "$as_me:9412: WARNING: non-block sockets disabled" >&5
+echo "$as_me: WARNING: non-block sockets disabled" >&2;}
+  fi
+
+fi;
+
+# Check whether --with-egd-socket or --without-egd-socket was given.
+if test "${with_egd_socket+set}" = set; then
+  withval="$with_egd_socket"
+   EGD_SOCKET="$withval"
+
+fi;
+if test -n "$EGD_SOCKET" ; then
+	cat >>confdefs.h <<EOF
+#define EGD_SOCKET "$EGD_SOCKET"
+EOF
 
 fi
 
+# Check whether --with-random or --without-random was given.
+if test "${with_random+set}" = set; then
+  withval="$with_random"
+   RANDOM_FILE="$withval"
+else
+
+                echo "$as_me:9437: checking for \"/dev/urandom\"" >&5
+echo $ECHO_N "checking for \"/dev/urandom\"... $ECHO_C" >&6
+if test "${ac_cv_file___dev_urandom_+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  echo "$as_me:9088: result: no" >&5
-echo "${ECHO_T}no" >&6
+  test "$cross_compiling" = yes &&
+  { { echo "$as_me:9443: error: cannot check for file existence when cross compiling" >&5
+echo "$as_me: error: cannot check for file existence when cross compiling" >&2;}
+   { (exit 1); exit 1; }; }
+if test -r ""/dev/urandom""; then
+  ac_cv_file___dev_urandom_=yes
+else
+  ac_cv_file___dev_urandom_=no
 fi
+fi
+echo "$as_me:9452: result: $ac_cv_file___dev_urandom_" >&5
+echo "${ECHO_T}$ac_cv_file___dev_urandom_" >&6
+if test $ac_cv_file___dev_urandom_ = yes; then
 
-OPT_SSL=off
+                RANDOM_FILE="/dev/urandom";
 
-# Check whether --with-ssl or --without-ssl was given.
-if test "${with_ssl+set}" = set; then
-  withval="$with_ssl"
-  OPT_SSL=$withval
+fi
 
 fi;
+if test -n "$RANDOM_FILE" ; then
 
-if test X"$OPT_SSL" = Xno
-then
-  { echo "$as_me:9103: WARNING: SSL/https support disabled" >&5
-echo "$as_me: WARNING: SSL/https support disabled" >&2;}
-else
+	cat >>confdefs.h <<EOF
+#define RANDOM_FILE "$RANDOM_FILE"
+EOF
 
-    CLEANLDFLAGS="$LDFLAGS"
-  CLEANCPPFLAGS="$CPPFLAGS"
+fi
 
-  case "$OPT_SSL" in
-  yes)
-    EXTRA_SSL=/usr/local/ssl ;;
-  off)
-    EXTRA_SSL= ;;
-  *)
-        EXTRA_SSL=$OPT_SSL
-    LDFLAGS="$LDFLAGS -L$EXTRA_SSL/lib"
-    CPPFLAGS="$CPPFLAGS -I$EXTRA_SSL/include/openssl -I$EXTRA_SSL/include"
-    ;;
-  esac
+# Check whether --with-krb4-includes or --without-krb4-includes was given.
+if test "${with_krb4_includes+set}" = set; then
+  withval="$with_krb4_includes"
 
-  echo "$as_me:9122: checking for CRYPTO_lock in -lcrypto" >&5
-echo $ECHO_N "checking for CRYPTO_lock in -lcrypto... $ECHO_C" >&6
-if test "${ac_cv_lib_crypto_CRYPTO_lock+set}" = set; then
+ CPPFLAGS="$CPPFLAGS -I$withval"
+ KRB4INC="$withval"
+ want_krb4=yes
+
+fi;
+
+# Check whether --with-krb4-libs or --without-krb4-libs was given.
+if test "${with_krb4_libs+set}" = set; then
+  withval="$with_krb4_libs"
+
+ LDFLAGS="$LDFLAGS -L$withval"
+ KRB4LIB="$withval"
+ want_krb4=yes
+
+fi;
+
+OPT_KRB4=off
+
+# Check whether --with-krb4 or --without-krb4 was given.
+if test "${with_krb4+set}" = set; then
+  withval="$with_krb4"
+
+  OPT_KRB4="$withval"
+  if test X"$OPT_KRB4" != Xyes
+  then
+    LDFLAGS="$LDFLAGS -L$OPT_KRB4/lib"
+    KRB4LIB="$OPT_KRB4/lib"
+    CPPFLAGS="$CPPFLAGS -I$OPT_KRB4/include"
+    KRB4INC="$OPT_KRB4/include"
+  fi
+  want_krb4="yes"
+
+fi;
+
+echo "$as_me:9507: checking if Kerberos4 support is requested" >&5
+echo $ECHO_N "checking if Kerberos4 support is requested... $ECHO_C" >&6
+
+if test "$want_krb4" = yes
+then
+  if test "$ipv6" = "yes"; then
+    echo krb4 is not compatible with IPv6
+    exit 1
+  fi
+  echo "$as_me:9516: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+  echo "$as_me:9519: checking where to look for Kerberos4" >&5
+echo $ECHO_N "checking where to look for Kerberos4... $ECHO_C" >&6
+  if test X"$OPT_KRB4" = Xyes
+  then
+    echo "$as_me:9523: result: defaults" >&5
+echo "${ECHO_T}defaults" >&6
+  else
+    echo "$as_me:9526: result: libs in $KRB4LIB, headers in $KRB4INC" >&5
+echo "${ECHO_T}libs in $KRB4LIB, headers in $KRB4INC" >&6
+  fi
+
+    echo "$as_me:9530: checking for des_pcbc_encrypt in -ldes" >&5
+echo $ECHO_N "checking for des_pcbc_encrypt in -ldes... $ECHO_C" >&6
+if test "${ac_cv_lib_des_des_pcbc_encrypt+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcrypto  $LIBS"
+LIBS="-ldes  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 9130 "configure"
+#line 9538 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char CRYPTO_lock ();
+char des_pcbc_encrypt ();
 int
 main ()
 {
-CRYPTO_lock ();
+des_pcbc_encrypt ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9149: \"$ac_link\"") >&5
+if { (eval echo "$as_me:9557: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9152: \$? = $ac_status" >&5
+  echo "$as_me:9560: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9155: \"$ac_try\"") >&5
+  { (eval echo "$as_me:9563: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9158: \$? = $ac_status" >&5
+  echo "$as_me:9566: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_crypto_CRYPTO_lock=yes
+  ac_cv_lib_des_des_pcbc_encrypt=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_crypto_CRYPTO_lock=no
+ac_cv_lib_des_des_pcbc_encrypt=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:9169: result: $ac_cv_lib_crypto_CRYPTO_lock" >&5
-echo "${ECHO_T}$ac_cv_lib_crypto_CRYPTO_lock" >&6
-if test $ac_cv_lib_crypto_CRYPTO_lock = yes; then
-
-     HAVECRYPTO="yes"
-
-else
+echo "$as_me:9577: result: $ac_cv_lib_des_des_pcbc_encrypt" >&5
+echo "${ECHO_T}$ac_cv_lib_des_des_pcbc_encrypt" >&6
+if test $ac_cv_lib_des_des_pcbc_encrypt = yes; then
 
-     OLDLDFLAGS="$LDFLAGS"
-     OLDCPPFLAGS="$CPPFLAGS"
-     LDFLAGS="$CLEANLDFLAGS -L$EXTRA_SSL/lib"
-     CPPFLAGS="$CLEANCPPFLAGS -I$EXTRA_SSL/include/openssl -I$EXTRA_SSL/include"
-     echo "$as_me:9181: checking for CRYPTO_add_lock in -lcrypto" >&5
-echo $ECHO_N "checking for CRYPTO_add_lock in -lcrypto... $ECHO_C" >&6
-if test "${ac_cv_lib_crypto_CRYPTO_add_lock+set}" = set; then
+for ac_header in des.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:9584: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcrypto  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-#line 9189 "configure"
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9590 "configure"
 #include "confdefs.h"
-
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char CRYPTO_add_lock ();
-int
-main ()
-{
-CRYPTO_add_lock ();
-  ;
-  return 0;
-}
+#include <$ac_header>
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9208: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:9211: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9214: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
+if { (eval echo "$as_me:9594: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  echo "$as_me:9217: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_crypto_CRYPTO_add_lock=yes
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:9600: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_cv_lib_crypto_CRYPTO_add_lock=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+  ac_cpp_err=yes
 fi
-echo "$as_me:9228: result: $ac_cv_lib_crypto_CRYPTO_add_lock" >&5
-echo "${ECHO_T}$ac_cv_lib_crypto_CRYPTO_add_lock" >&6
-if test $ac_cv_lib_crypto_CRYPTO_add_lock = yes; then
-
-       HAVECRYPTO="yes"
+if test -z "$ac_cpp_err"; then
+  eval "$as_ac_Header=yes"
 else
-
-       LDFLAGS="$OLDLDFLAGS"
-       CPPFLAGS="$OLDCPPFLAGS"
-
+  echo "$as_me: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  eval "$as_ac_Header=no"
 fi
-
+rm -f conftest.err conftest.$ac_ext
 fi
+echo "$as_me:9619: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+EOF
 
-  if test "$HAVECRYPTO" = "yes"; then
+fi
+done
 
-echo "$as_me:9244: checking for CRYPTO_add_lock in -lcrypto" >&5
-echo $ECHO_N "checking for CRYPTO_add_lock in -lcrypto... $ECHO_C" >&6
-if test "${ac_cv_lib_crypto_CRYPTO_add_lock+set}" = set; then
+        echo "$as_me:9629: checking for res_search" >&5
+echo $ECHO_N "checking for res_search... $ECHO_C" >&6
+if test "${ac_cv_func_res_search+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lcrypto  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-#line 9252 "configure"
+  cat >conftest.$ac_ext <<_ACEOF
+#line 9635 "configure"
 #include "confdefs.h"
-
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char res_search (); below.  */
+#include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char CRYPTO_add_lock ();
+char res_search ();
+char (*f) ();
+
 int
 main ()
 {
-CRYPTO_add_lock ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_res_search) || defined (__stub___res_search)
+choke me
+#else
+f = res_search;
+#endif
+
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9271: \"$ac_link\"") >&5
+if { (eval echo "$as_me:9666: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9274: \$? = $ac_status" >&5
+  echo "$as_me:9669: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9277: \"$ac_try\"") >&5
+  { (eval echo "$as_me:9672: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9280: \$? = $ac_status" >&5
+  echo "$as_me:9675: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_crypto_CRYPTO_add_lock=yes
+  ac_cv_func_res_search=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_crypto_CRYPTO_add_lock=no
+ac_cv_func_res_search=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-echo "$as_me:9291: result: $ac_cv_lib_crypto_CRYPTO_add_lock" >&5
-echo "${ECHO_T}$ac_cv_lib_crypto_CRYPTO_add_lock" >&6
-if test $ac_cv_lib_crypto_CRYPTO_add_lock = yes; then
-  cat >>confdefs.h <<EOF
-#define HAVE_LIBCRYPTO 1
-EOF
-
-  LIBS="-lcrypto $LIBS"
-
 fi
+echo "$as_me:9685: result: $ac_cv_func_res_search" >&5
+echo "${ECHO_T}$ac_cv_func_res_search" >&6
+if test $ac_cv_func_res_search = yes; then
+  :
+else
 
-echo "$as_me:9302: checking for SSL_connect in -lssl" >&5
-echo $ECHO_N "checking for SSL_connect in -lssl... $ECHO_C" >&6
-if test "${ac_cv_lib_ssl_SSL_connect+set}" = set; then
+echo "$as_me:9691: checking for res_search in -lresolv" >&5
+echo $ECHO_N "checking for res_search in -lresolv... $ECHO_C" >&6
+if test "${ac_cv_lib_resolv_res_search+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lssl  $LIBS"
+LIBS="-lresolv  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 9310 "configure"
+#line 9699 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char SSL_connect ();
+char res_search ();
 int
 main ()
 {
-SSL_connect ();
+res_search ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9329: \"$ac_link\"") >&5
+if { (eval echo "$as_me:9718: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9332: \$? = $ac_status" >&5
+  echo "$as_me:9721: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9335: \"$ac_try\"") >&5
+  { (eval echo "$as_me:9724: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9338: \$? = $ac_status" >&5
+  echo "$as_me:9727: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_ssl_SSL_connect=yes
+  ac_cv_lib_resolv_res_search=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_ssl_SSL_connect=no
+ac_cv_lib_resolv_res_search=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:9349: result: $ac_cv_lib_ssl_SSL_connect" >&5
-echo "${ECHO_T}$ac_cv_lib_ssl_SSL_connect" >&6
-if test $ac_cv_lib_ssl_SSL_connect = yes; then
+echo "$as_me:9738: result: $ac_cv_lib_resolv_res_search" >&5
+echo "${ECHO_T}$ac_cv_lib_resolv_res_search" >&6
+if test $ac_cv_lib_resolv_res_search = yes; then
   cat >>confdefs.h <<EOF
-#define HAVE_LIBSSL 1
+#define HAVE_LIBRESOLV 1
 EOF
 
-  LIBS="-lssl $LIBS"
+  LIBS="-lresolv $LIBS"
 
 fi
 
-    if test "$ac_cv_lib_ssl_SSL_connect" != yes; then
-                echo "$as_me:9361: checking for ssl with RSAglue/rsaref libs in use" >&5
-echo $ECHO_N "checking for ssl with RSAglue/rsaref libs in use... $ECHO_C" >&6;
-        OLIBS=$LIBS
-        LIBS="$LIBS -lRSAglue -lrsaref"
+fi
 
-echo "$as_me:9366: checking for SSL_connect in -lssl" >&5
-echo $ECHO_N "checking for SSL_connect in -lssl... $ECHO_C" >&6
-if test "${ac_cv_lib_ssl_SSL_connect+set}" = set; then
+        echo "$as_me:9751: checking for krb_net_read in -lkrb" >&5
+echo $ECHO_N "checking for krb_net_read in -lkrb... $ECHO_C" >&6
+if test "${ac_cv_lib_krb_krb_net_read+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lssl  $LIBS"
+LIBS="-lkrb  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line 9374 "configure"
+#line 9759 "configure"
 #include "confdefs.h"
 
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char SSL_connect ();
+char krb_net_read ();
 int
 main ()
 {
-SSL_connect ();
+krb_net_read ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9393: \"$ac_link\"") >&5
+if { (eval echo "$as_me:9778: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9396: \$? = $ac_status" >&5
+  echo "$as_me:9781: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9399: \"$ac_try\"") >&5
+  { (eval echo "$as_me:9784: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9402: \$? = $ac_status" >&5
+  echo "$as_me:9787: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_ssl_SSL_connect=yes
+  ac_cv_lib_krb_krb_net_read=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_lib_ssl_SSL_connect=no
+ac_cv_lib_krb_krb_net_read=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:9413: result: $ac_cv_lib_ssl_SSL_connect" >&5
-echo "${ECHO_T}$ac_cv_lib_ssl_SSL_connect" >&6
-if test $ac_cv_lib_ssl_SSL_connect = yes; then
-  cat >>confdefs.h <<EOF
-#define HAVE_LIBSSL 1
-EOF
-
-  LIBS="-lssl $LIBS"
-
-fi
-
-        if test "$ac_cv_lib_ssl_SSL_connect" != yes; then
-                        echo "$as_me:9425: result: no" >&5
-echo "${ECHO_T}no" >&6
-            LIBS=$OLIBS
-        else
-            echo "$as_me:9429: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-        fi
-    fi
+echo "$as_me:9798: result: $ac_cv_lib_krb_krb_net_read" >&5
+echo "${ECHO_T}$ac_cv_lib_krb_krb_net_read" >&6
+if test $ac_cv_lib_krb_krb_net_read = yes; then
 
-for ac_header in openssl/x509.h openssl/rsa.h openssl/crypto.h \
-                     openssl/pem.h openssl/ssl.h openssl/err.h
+for ac_header in krb.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:9438: checking for $ac_header" >&5
+echo "$as_me:9805: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 9444 "configure"
+#line 9811 "configure"
 #include "confdefs.h"
 #include <$ac_header>
 _ACEOF
-if { (eval echo "$as_me:9448: \"$ac_cpp conftest.$ac_ext\"") >&5
+if { (eval echo "$as_me:9815: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   egrep -v '^ *\+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
-  echo "$as_me:9454: \$? = $ac_status" >&5
+  echo "$as_me:9821: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
   else
     ac_cpp_err=
   fi
@@ -9467,95 +9834,34 @@
   echo "$as_me: failed program was:" >&5
   cat conftest.$ac_ext >&5
   eval "$as_ac_Header=no"
 fi
 rm -f conftest.err conftest.$ac_ext
 fi
-echo "$as_me:9473: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "$as_me:9840: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<EOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
 EOF
- OPENSSL_ENABLED=1
-fi
-done
 
-    if test $ac_cv_header_openssl_x509_h = no; then
-
-for ac_header in x509.h rsa.h crypto.h pem.h ssl.h err.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:9488: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9494 "configure"
-#include "confdefs.h"
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:9498: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:9504: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  eval "$as_ac_Header=yes"
-else
-  echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  eval "$as_ac_Header=no"
-fi
-rm -f conftest.err conftest.$ac_ext
-fi
-echo "$as_me:9523: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-EOF
- OPENSSL_ENABLED=1
 fi
 done
 
-    fi
-
-  fi
-
-  if test X"$OPT_SSL" != Xoff &&
-     test "$OPENSSL_ENABLED" != "1"; then
-    { { echo "$as_me:9539: error: OpenSSL libs and/or directories were not found where specified!" >&5
-echo "$as_me: error: OpenSSL libs and/or directories were not found where specified!" >&2;}
-   { (exit 1); exit 1; }; }
-  fi
+            LIBS="-lkrb -ldes $LIBS"
 
-for ac_func in RAND_status \
-                  RAND_screen \
-                  RAND_egd
+for ac_func in krb_get_our_ip_for_realm
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:9549: checking for $ac_func" >&5
+echo "$as_me:9855: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 9555 "configure"
+#line 9861 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -9580,122 +9886,57 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9586: \"$ac_link\"") >&5
+if { (eval echo "$as_me:9892: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9589: \$? = $ac_status" >&5
+  echo "$as_me:9895: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9592: \"$ac_try\"") >&5
+  { (eval echo "$as_me:9898: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9595: \$? = $ac_status" >&5
+  echo "$as_me:9901: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:9605: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "$as_me:9911: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<EOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 EOF
 
 fi
 done
 
-fi
-
-OPT_THREAD=on
-# Check whether --enable-thread or --disable-thread was given.
-if test "${enable_thread+set}" = set; then
-  enableval="$enable_thread"
-  OPT_THREAD=off
-
-fi;
-
-if test X"$OPT_THREAD" = Xoff
-then
-  { echo "$as_me:9627: WARNING: libcurl will not get built using thread-safe functions" >&5
-echo "$as_me: WARNING: libcurl will not get built using thread-safe functions" >&2;}
-
-cat >>confdefs.h <<\EOF
-#define DISABLED_THREADSAFE 1
+            cat >>confdefs.h <<\EOF
+#define KRB4 1
 EOF
 
-else
+            KRB4_ENABLED=1
 
-echo "$as_me:9636: checking if \"localhost\" resolves" >&5
-echo $ECHO_N "checking if \"localhost\" resolves... $ECHO_C" >&6
-if test "$cross_compiling" = yes; then
-  { { echo "$as_me:9639: error: cannot run test program while cross compiling" >&5
-echo "$as_me: error: cannot run test program while cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9644 "configure"
-#include "confdefs.h"
-
-#include <string.h>
-#include <sys/types.h>
-#include <netdb.h>
-
-int
-main () {
-struct hostent *h;
-h = gethostbyname("localhost");
-exit (h == NULL ? 1 : 0); }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:9658: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:9661: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:9663: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:9666: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-
-      echo "$as_me:9669: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-
-      echo "$as_me:9676: result: no" >&5
-echo "${ECHO_T}no" >&6
-      { { echo "$as_me:9678: error: can't figure out gethostbyname_r() since localhost doesn't resolve" >&5
-echo "$as_me: error: can't figure out gethostbyname_r() since localhost doesn't resolve" >&2;}
-   { (exit 1); exit 1; }; }
-
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-for ac_func in gethostbyname_r
+for ac_func in strlcpy
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:9689: checking for $ac_func" >&5
+echo "$as_me:9930: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 9695 "configure"
+#line 9936 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -9720,682 +9961,562 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:9726: \"$ac_link\"") >&5
+if { (eval echo "$as_me:9967: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9729: \$? = $ac_status" >&5
+  echo "$as_me:9970: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:9732: \"$ac_try\"") >&5
+  { (eval echo "$as_me:9973: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9735: \$? = $ac_status" >&5
+  echo "$as_me:9976: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:9745: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "$as_me:9986: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<EOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 EOF
 
-    echo "$as_me:9752: checking if gethostbyname_r takes 3 arguments" >&5
-echo $ECHO_N "checking if gethostbyname_r takes 3 arguments... $ECHO_C" >&6
-    if test "$cross_compiling" = yes; then
-  ac_cv_gethostbyname_args=0
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9758 "configure"
-#include "confdefs.h"
-
-#include <string.h>
-#include <sys/types.h>
-#include <netdb.h>
+fi
+done
 
-int
-main () {
-struct hostent h;
-struct hostent_data hdata;
-char *name = "localhost";
-int rc;
-memset(&h, 0, sizeof(struct hostent));
-memset(&hdata, 0, sizeof(struct hostent_data));
-rc = gethostbyname_r(name, &h, &hdata);
-exit (rc != 0 ? 1 : 0); }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:9777: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:9780: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:9782: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:9785: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+fi
 
-      echo "$as_me:9788: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-      cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYNAME_R_3 1
-EOF
+fi
 
-      ac_cv_gethostbyname_args=3
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-
-      echo "$as_me:9800: result: no" >&5
+  echo "$as_me:10001: result: no" >&5
 echo "${ECHO_T}no" >&6
-      echo "$as_me:9802: checking if gethostbyname_r with -D_REENTRANT takes 3 arguments" >&5
-echo $ECHO_N "checking if gethostbyname_r with -D_REENTRANT takes 3 arguments... $ECHO_C" >&6
-      if test "$cross_compiling" = yes; then
-  ac_cv_gethostbyname_args=0
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9808 "configure"
-#include "confdefs.h"
-
-#define _REENTRANT
-
-#include <string.h>
-#include <sys/types.h>
-#include <netdb.h>
-
-int
-main () {
-struct hostent h;
-struct hostent_data hdata;
-char *name = "localhost";
-int rc;
-memset(&h, 0, sizeof(struct hostent));
-memset(&hdata, 0, sizeof(struct hostent_data));
-rc = gethostbyname_r(name, &h, &hdata);
-exit (rc != 0 ? 1 : 0); }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:9829: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:9832: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:9834: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:9837: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+fi
 
-	echo "$as_me:9840: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-	cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYNAME_R_3 1
-EOF
+OPT_SSL=off
 
-	cat >>confdefs.h <<\EOF
-#define NEED_REENTRANT 1
-EOF
+# Check whether --with-ssl or --without-ssl was given.
+if test "${with_ssl+set}" = set; then
+  withval="$with_ssl"
+  OPT_SSL=$withval
 
-	ac_cv_gethostbyname_args=3
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+fi;
 
-	echo "$as_me:9856: result: no" >&5
-echo "${ECHO_T}no" >&6
-	echo "$as_me:9858: checking if gethostbyname_r takes 5 arguments" >&5
-echo $ECHO_N "checking if gethostbyname_r takes 5 arguments... $ECHO_C" >&6
-	if test "$cross_compiling" = yes; then
-  ac_cv_gethostbyname_args=0
+if test X"$OPT_SSL" = Xno
+then
+  { echo "$as_me:10016: WARNING: SSL/https support disabled" >&5
+echo "$as_me: WARNING: SSL/https support disabled" >&2;}
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9864 "configure"
-#include "confdefs.h"
 
-#include <sys/types.h>
-#include <netdb.h>
-
-int
-main () {
-struct hostent *hp;
-struct hostent h;
-char *name = "localhost";
-char buffer[8192];
-int h_errno;
-hp = gethostbyname_r(name, &h, buffer, 8192, &h_errno);
-exit (hp == NULL ? 1 : 0); }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:9881: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:9884: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:9886: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:9889: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-
-	  echo "$as_me:9892: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-	  cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYNAME_R_5 1
-EOF
+    CLEANLDFLAGS="$LDFLAGS"
+  CLEANCPPFLAGS="$CPPFLAGS"
 
-          ac_cv_gethostbyname_args=5
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+  case "$OPT_SSL" in
+  yes)
+    EXTRA_SSL=/usr/local/ssl ;;
+  off)
+    EXTRA_SSL= ;;
+  *)
+        EXTRA_SSL=$OPT_SSL
+    LDFLAGS="$LDFLAGS -L$EXTRA_SSL/lib"
+    CPPFLAGS="$CPPFLAGS -I$EXTRA_SSL/include/openssl -I$EXTRA_SSL/include"
+    ;;
+  esac
 
-	  echo "$as_me:9904: result: no" >&5
-echo "${ECHO_T}no" >&6
-	  echo "$as_me:9906: checking if gethostbyname_r takes 6 arguments" >&5
-echo $ECHO_N "checking if gethostbyname_r takes 6 arguments... $ECHO_C" >&6
-	  if test "$cross_compiling" = yes; then
-  ac_cv_gethostbyname_args=0
+  echo "$as_me:10035: checking for CRYPTO_lock in -lcrypto" >&5
+echo $ECHO_N "checking for CRYPTO_lock in -lcrypto... $ECHO_C" >&6
+if test "${ac_cv_lib_crypto_CRYPTO_lock+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9912 "configure"
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcrypto  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line 10043 "configure"
 #include "confdefs.h"
 
-#include <sys/types.h>
-#include <netdb.h>
-
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char CRYPTO_lock ();
 int
-main () {
-struct hostent h;
-struct hostent *hp;
-char *name = "localhost";
-char buf[8192];
-int rc;
-int h_errno;
-rc = gethostbyname_r(name, &h, buf, 8192, &hp, &h_errno);
-exit (rc != 0 ? 1 : 0); }
+main ()
+{
+CRYPTO_lock ();
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:9930: \"$ac_link\"") >&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:10062: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:9933: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:9935: \"$ac_try\"") >&5
+  echo "$as_me:10065: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:10068: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:9938: \$? = $ac_status" >&5
+  echo "$as_me:10071: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-
-	    echo "$as_me:9941: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-	    cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYNAME_R_6 1
-EOF
-
-            ac_cv_gethostbyname_args=6
+  ac_cv_lib_crypto_CRYPTO_lock=yes
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-
-	    echo "$as_me:9953: result: no" >&5
-echo "${ECHO_T}no" >&6
-	    have_missing_r_funcs="$have_missing_r_funcs gethostbyname_r"
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+ac_cv_lib_crypto_CRYPTO_lock=no
 fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-done
+echo "$as_me:10082: result: $ac_cv_lib_crypto_CRYPTO_lock" >&5
+echo "${ECHO_T}$ac_cv_lib_crypto_CRYPTO_lock" >&6
+if test $ac_cv_lib_crypto_CRYPTO_lock = yes; then
 
-if test "$ac_cv_func_gethostbyname_r" = "yes"; then
-  if test "$ac_cv_gethostbyname_args" = "0"; then
-            { { echo "$as_me:9973: error: couldn't figure out how to use gethostbyname_r()" >&5
-echo "$as_me: error: couldn't figure out how to use gethostbyname_r()" >&2;}
-   { (exit 1); exit 1; }; }
-  fi
-fi
+     HAVECRYPTO="yes"
 
-for ac_func in gethostbyaddr_r
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:9982: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
+else
+
+     OLDLDFLAGS="$LDFLAGS"
+     OLDCPPFLAGS="$CPPFLAGS"
+     LDFLAGS="$CLEANLDFLAGS -L$EXTRA_SSL/lib"
+     CPPFLAGS="$CLEANCPPFLAGS -I$EXTRA_SSL/include/openssl -I$EXTRA_SSL/include"
+     echo "$as_me:10094: checking for CRYPTO_add_lock in -lcrypto" >&5
+echo $ECHO_N "checking for CRYPTO_add_lock in -lcrypto... $ECHO_C" >&6
+if test "${ac_cv_lib_crypto_CRYPTO_add_lock+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 9988 "configure"
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcrypto  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line 10102 "configure"
 #include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-char (*f) ();
-
+char CRYPTO_add_lock ();
 int
 main ()
 {
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-f = $ac_func;
-#endif
-
+CRYPTO_add_lock ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:10019: \"$ac_link\"") >&5
+if { (eval echo "$as_me:10121: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:10022: \$? = $ac_status" >&5
+  echo "$as_me:10124: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:10025: \"$ac_try\"") >&5
+  { (eval echo "$as_me:10127: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10028: \$? = $ac_status" >&5
+  echo "$as_me:10130: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  ac_cv_lib_crypto_CRYPTO_add_lock=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-eval "$as_ac_var=no"
+ac_cv_lib_crypto_CRYPTO_add_lock=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:10038: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-EOF
+echo "$as_me:10141: result: $ac_cv_lib_crypto_CRYPTO_add_lock" >&5
+echo "${ECHO_T}$ac_cv_lib_crypto_CRYPTO_add_lock" >&6
+if test $ac_cv_lib_crypto_CRYPTO_add_lock = yes; then
 
-    echo "$as_me:10045: checking if gethostbyaddr_r takes 5 arguments" >&5
-echo $ECHO_N "checking if gethostbyaddr_r takes 5 arguments... $ECHO_C" >&6
-    cat >conftest.$ac_ext <<_ACEOF
-#line 10048 "configure"
-#include "confdefs.h"
+       HAVECRYPTO="yes"
+else
 
-#include <sys/types.h>
-#include <netdb.h>
-int
-main ()
-{
+       LDFLAGS="$OLDLDFLAGS"
+       CPPFLAGS="$OLDCPPFLAGS"
 
-char * address;
-int length;
-int type;
-struct hostent h;
-struct hostent_data hdata;
-int rc;
-rc = gethostbyaddr_r(address, length, type, &h, &hdata);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10069: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:10072: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10075: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:10078: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+fi
 
-      echo "$as_me:10081: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-      cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYADDR_R_5 1
-EOF
+fi
 
-      ac_cv_gethostbyaddr_args=5
-else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
+  if test "$HAVECRYPTO" = "yes"; then
 
-      echo "$as_me:10092: result: no" >&5
-echo "${ECHO_T}no" >&6
-      echo "$as_me:10094: checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments" >&5
-echo $ECHO_N "checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments... $ECHO_C" >&6
-      cat >conftest.$ac_ext <<_ACEOF
-#line 10097 "configure"
+echo "$as_me:10157: checking for CRYPTO_add_lock in -lcrypto" >&5
+echo $ECHO_N "checking for CRYPTO_add_lock in -lcrypto... $ECHO_C" >&6
+if test "${ac_cv_lib_crypto_CRYPTO_add_lock+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lcrypto  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line 10165 "configure"
 #include "confdefs.h"
 
-#define _REENTRANT
-#include <sys/types.h>
-#include <netdb.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char CRYPTO_add_lock ();
 int
 main ()
 {
-
-char * address;
-int length;
-int type;
-struct hostent h;
-struct hostent_data hdata;
-int rc;
-rc = gethostbyaddr_r(address, length, type, &h, &hdata);
+CRYPTO_add_lock ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10119: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:10184: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:10122: \$? = $ac_status" >&5
+  echo "$as_me:10187: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10125: \"$ac_try\"") >&5
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:10190: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10128: \$? = $ac_status" >&5
+  echo "$as_me:10193: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-
-	echo "$as_me:10131: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-	cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYADDR_R_5 1
-EOF
-
-	cat >>confdefs.h <<\EOF
-#define NEED_REENTRANT 1
-EOF
-
-	ac_cv_gethostbyaddr_args=5
+  ac_cv_lib_crypto_CRYPTO_add_lock=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
+ac_cv_lib_crypto_CRYPTO_add_lock=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:10204: result: $ac_cv_lib_crypto_CRYPTO_add_lock" >&5
+echo "${ECHO_T}$ac_cv_lib_crypto_CRYPTO_add_lock" >&6
+if test $ac_cv_lib_crypto_CRYPTO_add_lock = yes; then
+  cat >>confdefs.h <<EOF
+#define HAVE_LIBCRYPTO 1
+EOF
 
-	echo "$as_me:10146: result: no" >&5
-echo "${ECHO_T}no" >&6
-	echo "$as_me:10148: checking if gethostbyaddr_r takes 7 arguments" >&5
-echo $ECHO_N "checking if gethostbyaddr_r takes 7 arguments... $ECHO_C" >&6
-	cat >conftest.$ac_ext <<_ACEOF
-#line 10151 "configure"
-#include "confdefs.h"
-
-#include <sys/types.h>
-#include <netdb.h>
-int
-main ()
-{
-
-char * address;
-int length;
-int type;
-struct hostent h;
-char buffer[8192];
-int h_errnop;
-struct hostent * hp;
-
-hp = gethostbyaddr_r(address, length, type, &h,
-                     buffer, 8192, &h_errnop);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10175: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:10178: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10181: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:10184: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
+  LIBS="-lcrypto $LIBS"
 
-	  echo "$as_me:10187: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-	  cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYADDR_R_7 1
-EOF
+fi
 
-	  ac_cv_gethostbyaddr_args=7
+echo "$as_me:10215: checking for SSL_connect in -lssl" >&5
+echo $ECHO_N "checking for SSL_connect in -lssl... $ECHO_C" >&6
+if test "${ac_cv_lib_ssl_SSL_connect+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-
-	  echo "$as_me:10198: result: no" >&5
-echo "${ECHO_T}no" >&6
-	  echo "$as_me:10200: checking if gethostbyaddr_r takes 8 arguments" >&5
-echo $ECHO_N "checking if gethostbyaddr_r takes 8 arguments... $ECHO_C" >&6
-	  cat >conftest.$ac_ext <<_ACEOF
-#line 10203 "configure"
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lssl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line 10223 "configure"
 #include "confdefs.h"
 
-#include <sys/types.h>
-#include <netdb.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char SSL_connect ();
 int
 main ()
 {
-
-char * address;
-int length;
-int type;
-struct hostent h;
-char buffer[8192];
-int h_errnop;
-struct hostent * hp;
-int rc;
-
-rc = gethostbyaddr_r(address, length, type, &h,
-                     buffer, 8192, &hp, &h_errnop);
+SSL_connect ();
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10228: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:10242: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:10231: \$? = $ac_status" >&5
+  echo "$as_me:10245: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10234: \"$ac_try\"") >&5
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:10248: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10237: \$? = $ac_status" >&5
+  echo "$as_me:10251: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-
-	    echo "$as_me:10240: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-	    cat >>confdefs.h <<\EOF
-#define HAVE_GETHOSTBYADDR_R_8 1
-EOF
-
-	    ac_cv_gethostbyaddr_args=8
+  ac_cv_lib_ssl_SSL_connect=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-
-	    echo "$as_me:10251: result: no" >&5
-echo "${ECHO_T}no" >&6
-	    have_missing_r_funcs="$have_missing_r_funcs gethostbyaddr_r"
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+ac_cv_lib_ssl_SSL_connect=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:10262: result: $ac_cv_lib_ssl_SSL_connect" >&5
+echo "${ECHO_T}$ac_cv_lib_ssl_SSL_connect" >&6
+if test $ac_cv_lib_ssl_SSL_connect = yes; then
+  cat >>confdefs.h <<EOF
+#define HAVE_LIBSSL 1
+EOF
+
+  LIBS="-lssl $LIBS"
+
 fi
-done
 
-for ac_func in inet_ntoa_r
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:10268: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
+    if test "$ac_cv_lib_ssl_SSL_connect" != yes; then
+                echo "$as_me:10274: checking for ssl with RSAglue/rsaref libs in use" >&5
+echo $ECHO_N "checking for ssl with RSAglue/rsaref libs in use... $ECHO_C" >&6;
+        OLIBS=$LIBS
+        LIBS="$LIBS -lRSAglue -lrsaref"
+
+echo "$as_me:10279: checking for SSL_connect in -lssl" >&5
+echo $ECHO_N "checking for SSL_connect in -lssl... $ECHO_C" >&6
+if test "${ac_cv_lib_ssl_SSL_connect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 10274 "configure"
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lssl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line 10287 "configure"
 #include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.  */
-#include <assert.h>
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-char (*f) ();
-
+char SSL_connect ();
 int
 main ()
 {
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-f = $ac_func;
-#endif
-
+SSL_connect ();
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:10305: \"$ac_link\"") >&5
+if { (eval echo "$as_me:10306: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:10308: \$? = $ac_status" >&5
+  echo "$as_me:10309: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:10311: \"$ac_try\"") >&5
+  { (eval echo "$as_me:10312: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10314: \$? = $ac_status" >&5
+  echo "$as_me:10315: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  ac_cv_lib_ssl_SSL_connect=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-eval "$as_ac_var=no"
+ac_cv_lib_ssl_SSL_connect=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:10324: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
+echo "$as_me:10326: result: $ac_cv_lib_ssl_SSL_connect" >&5
+echo "${ECHO_T}$ac_cv_lib_ssl_SSL_connect" >&6
+if test $ac_cv_lib_ssl_SSL_connect = yes; then
   cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+#define HAVE_LIBSSL 1
 EOF
 
-    echo "$as_me:10331: checking whether inet_ntoa_r is declared" >&5
-echo $ECHO_N "checking whether inet_ntoa_r is declared... $ECHO_C" >&6
-    cat >conftest.$ac_ext <<_ACEOF
-#line 10334 "configure"
-#include "confdefs.h"
-
-#include <arpa/inet.h>
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "inet_ntoa_r" >/dev/null 2>&1; then
+  LIBS="-lssl $LIBS"
 
-      cat >>confdefs.h <<\EOF
-#define HAVE_INET_NTOA_R_DECL 1
-EOF
+fi
 
-      echo "$as_me:10346: result: yes" >&5
+        if test "$ac_cv_lib_ssl_SSL_connect" != yes; then
+                        echo "$as_me:10338: result: no" >&5
+echo "${ECHO_T}no" >&6
+            LIBS=$OLIBS
+        else
+            echo "$as_me:10342: result: yes" >&5
 echo "${ECHO_T}yes" >&6
-else
+        fi
+    fi
 
-      echo "$as_me:10350: result: no" >&5
-echo "${ECHO_T}no" >&6
-      echo "$as_me:10352: checking whether inet_ntoa_r with -D_REENTRANT is declared" >&5
-echo $ECHO_N "checking whether inet_ntoa_r with -D_REENTRANT is declared... $ECHO_C" >&6
-      cat >conftest.$ac_ext <<_ACEOF
-#line 10355 "configure"
+for ac_header in openssl/x509.h openssl/rsa.h openssl/crypto.h \
+                     openssl/pem.h openssl/ssl.h openssl/err.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:10351: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 10357 "configure"
 #include "confdefs.h"
-
-#define _REENTRANT
-#include <arpa/inet.h>
+#include <$ac_header>
 _ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "inet_ntoa_r" >/dev/null 2>&1; then
-
-	cat >>confdefs.h <<\EOF
-#define HAVE_INET_NTOA_R_DECL 1
+if { (eval echo "$as_me:10361: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:10367: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+echo "$as_me:10386: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
 EOF
+ OPENSSL_ENABLED=1
+fi
+done
 
-	cat >>confdefs.h <<\EOF
-#define NEED_REENTRANT 1
-EOF
+    if test $ac_cv_header_openssl_x509_h = no; then
 
-	echo "$as_me:10372: result: yes" >&5
-echo "${ECHO_T}yes" >&6
+for ac_header in x509.h rsa.h crypto.h pem.h ssl.h err.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:10401: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  echo "$as_me:10375: result: no" >&5
-echo "${ECHO_T}no" >&6
+  cat >conftest.$ac_ext <<_ACEOF
+#line 10407 "configure"
+#include "confdefs.h"
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:10411: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:10417: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
 fi
-rm -f conftest*
+if test -z "$ac_cpp_err"; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+echo "$as_me:10436: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+EOF
+ OPENSSL_ENABLED=1
+fi
+done
+
+    fi
 
+for ac_header in openssl/engine.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:10451: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 10457 "configure"
+#include "confdefs.h"
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:10461: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:10467: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
 fi
-rm -f conftest*
+if test -z "$ac_cpp_err"; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  eval "$as_ac_Header=no"
+fi
+rm -f conftest.err conftest.$ac_ext
+fi
+echo "$as_me:10486: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+EOF
 
 fi
 done
 
-for ac_func in localtime_r
+  fi
+
+  if test X"$OPT_SSL" != Xoff &&
+     test "$OPENSSL_ENABLED" != "1"; then
+    { { echo "$as_me:10500: error: OpenSSL libs and/or directories were not found where specified!" >&5
+echo "$as_me: error: OpenSSL libs and/or directories were not found where specified!" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+
+for ac_func in RAND_status \
+                  RAND_screen \
+                  RAND_egd
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:10389: checking for $ac_func" >&5
+echo "$as_me:10510: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 10395 "configure"
+#line 10516 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -10420,1122 +10541,1506 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:10426: \"$ac_link\"") >&5
+if { (eval echo "$as_me:10547: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:10429: \$? = $ac_status" >&5
+  echo "$as_me:10550: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:10432: \"$ac_try\"") >&5
+  { (eval echo "$as_me:10553: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10435: \$? = $ac_status" >&5
+  echo "$as_me:10556: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:10445: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "$as_me:10566: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<EOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 EOF
 
-    echo "$as_me:10452: checking whether localtime_r is declared" >&5
-echo $ECHO_N "checking whether localtime_r is declared... $ECHO_C" >&6
-    cat >conftest.$ac_ext <<_ACEOF
-#line 10455 "configure"
-#include "confdefs.h"
+fi
+done
 
-#include <time.h>
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "localtime_r" >/dev/null 2>&1; then
+fi
 
-      echo "$as_me:10463: result: yes" >&5
-echo "${ECHO_T}yes" >&6
-else
+OPT_THREAD=on
+# Check whether --enable-thread or --disable-thread was given.
+if test "${enable_thread+set}" = set; then
+  enableval="$enable_thread"
+  OPT_THREAD=off
 
-      echo "$as_me:10467: result: no" >&5
-echo "${ECHO_T}no" >&6
-      echo "$as_me:10469: checking whether localtime_r with -D_REENTRANT is declared" >&5
-echo $ECHO_N "checking whether localtime_r with -D_REENTRANT is declared... $ECHO_C" >&6
-      cat >conftest.$ac_ext <<_ACEOF
-#line 10472 "configure"
-#include "confdefs.h"
+fi;
 
-#define _REENTRANT
-#include <time.h>
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "localtime_r" >/dev/null 2>&1; then
+if test X"$OPT_THREAD" = Xoff
+then
+  { echo "$as_me:10588: WARNING: libcurl will not get built using thread-safe functions" >&5
+echo "$as_me: WARNING: libcurl will not get built using thread-safe functions" >&2;}
 
-	cat >>confdefs.h <<\EOF
-#define NEED_REENTRANT 1
+cat >>confdefs.h <<\EOF
+#define DISABLED_THREADSAFE 1
 EOF
 
-	echo "$as_me:10485: result: yes" >&5
-echo "${ECHO_T}yes" >&6
 else
-  echo "$as_me:10488: result: no" >&5
-echo "${ECHO_T}no" >&6
-fi
-rm -f conftest*
-
-fi
-rm -f conftest*
-
-fi
-done
-
-fi
 
-echo "$as_me:10501: checking for ANSI C header files" >&5
-echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
-if test "${ac_cv_header_stdc+set}" = set; then
+for ac_func in gethostbyname_r
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:10600: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 10507 "configure"
+#line 10606 "configure"
 #include "confdefs.h"
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+char (*f) ();
 
-_ACEOF
-if { (eval echo "$as_me:10515: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:10521: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_cv_header_stdc=yes
+int
+main ()
+{
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+f = $ac_func;
+#endif
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:10637: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:10640: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:10643: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:10646: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  ac_cv_header_stdc=no
+cat conftest.$ac_ext >&5
+eval "$as_ac_var=no"
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:10656: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+EOF
 
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-#line 10543 "configure"
+    echo "$as_me:10663: checking if gethostbyname_r takes 3 arguments" >&5
+echo $ECHO_N "checking if gethostbyname_r takes 3 arguments... $ECHO_C" >&6
+    cat >conftest.$ac_ext <<_ACEOF
+#line 10666 "configure"
 #include "confdefs.h"
+
 #include <string.h>
+#include <sys/types.h>
+#include <netdb.h>
+#undef NULL
+#define NULL (void *)0
 
+int
+gethostbyname_r(const char *, struct hostent *, struct hostent_data *);
+int
+main ()
+{
+
+struct hostent_data data;
+gethostbyname_r(NULL, NULL, NULL);
+  ;
+  return 0;
+}
 _ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "memchr" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:10688: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:10691: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:10694: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:10697: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
 
-fi
+      echo "$as_me:10700: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+      cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYNAME_R_3 1
+EOF
 
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-#line 10561 "configure"
+      ac_cv_gethostbyname_args=3
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+
+      echo "$as_me:10711: result: no" >&5
+echo "${ECHO_T}no" >&6
+      echo "$as_me:10713: checking if gethostbyname_r with -D_REENTRANT takes 3 arguments" >&5
+echo $ECHO_N "checking if gethostbyname_r with -D_REENTRANT takes 3 arguments... $ECHO_C" >&6
+      cat >conftest.$ac_ext <<_ACEOF
+#line 10716 "configure"
 #include "confdefs.h"
-#include <stdlib.h>
 
+#define _REENTRANT
+
+#include <string.h>
+#include <sys/types.h>
+#include <netdb.h>
+#undef NULL
+#define NULL (void *)0
+
+int
+gethostbyname_r(const char *,struct hostent *, struct hostent_data *);
+int
+main ()
+{
+
+struct hostent_data data;
+gethostbyname_r(NULL, NULL, NULL);
+  ;
+  return 0;
+}
 _ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  egrep "free" >/dev/null 2>&1; then
-  :
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:10740: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:10743: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:10746: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:10749: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+	echo "$as_me:10752: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYNAME_R_3 1
+EOF
+
+	cat >>confdefs.h <<\EOF
+#define NEED_REENTRANT 1
+EOF
+
+	ac_cv_gethostbyname_args=3
 else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
 
-fi
+	echo "$as_me:10767: result: no" >&5
+echo "${ECHO_T}no" >&6
+	echo "$as_me:10769: checking if gethostbyname_r takes 5 arguments" >&5
+echo $ECHO_N "checking if gethostbyname_r takes 5 arguments... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+#line 10772 "configure"
+#include "confdefs.h"
 
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
-  :
+#include <sys/types.h>
+#include <netdb.h>
+#undef NULL
+#define NULL (void *)0
+
+struct hostent *
+gethostbyname_r(const char *, struct hostent *, char *, int, int *);
+int
+main ()
+{
+
+gethostbyname_r(NULL, NULL, NULL, 0, NULL);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:10792: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:10795: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:10798: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:10801: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+	  echo "$as_me:10804: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	  cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYNAME_R_5 1
+EOF
+
+          ac_cv_gethostbyname_args=5
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 10582 "configure"
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+
+	  echo "$as_me:10815: result: no" >&5
+echo "${ECHO_T}no" >&6
+	  echo "$as_me:10817: checking if gethostbyname_r takes 6 arguments" >&5
+echo $ECHO_N "checking if gethostbyname_r takes 6 arguments... $ECHO_C" >&6
+	  cat >conftest.$ac_ext <<_ACEOF
+#line 10820 "configure"
 #include "confdefs.h"
-#include <ctype.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) (('a' <= (c) && (c) <= 'i') \
-                     || ('j' <= (c) && (c) <= 'r') \
-                     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
 
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
+#include <sys/types.h>
+#include <netdb.h>
+#undef NULL
+#define NULL (void *)0
+
+int
+gethostbyname_r(const char *, struct hostent *, char *, size_t,
+struct hostent **, int *);
 int
 main ()
 {
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-        || toupper (i) != TOUPPER (i))
-      exit(2);
-  exit (0);
+
+gethostbyname_r(NULL, NULL, NULL, 0, NULL, NULL);
+  ;
+  return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:10608: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:10841: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:10611: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:10613: \"$ac_try\"") >&5
+  echo "$as_me:10844: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:10847: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10616: \$? = $ac_status" >&5
+  echo "$as_me:10850: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  :
+
+	    echo "$as_me:10853: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	    cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYNAME_R_6 1
+EOF
+
+            ac_cv_gethostbyname_args=6
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_header_stdc=no
+
+	    echo "$as_me:10864: result: no" >&5
+echo "${ECHO_T}no" >&6
+	    have_missing_r_funcs="$have_missing_r_funcs gethostbyname_r"
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:10629: result: $ac_cv_header_stdc" >&5
-echo "${ECHO_T}$ac_cv_header_stdc" >&6
-if test $ac_cv_header_stdc = yes; then
-
-cat >>confdefs.h <<\EOF
-#define STDC_HEADERS 1
-EOF
-
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
+done
 
-for ac_header in \
-        unistd.h \
-        malloc.h \
-        stdlib.h \
-        arpa/inet.h \
-        net/if.h \
-        netinet/in.h \
-	netinet/if_ether.h \
-        netdb.h \
-        sys/select.h \
-        sys/socket.h \
-        sys/sockio.h \
-        sys/stat.h \
-        sys/types.h \
-        sys/time.h \
-        getopt.h \
-        sys/param.h \
-        termios.h \
-        termio.h \
-        sgtty.h \
-        fcntl.h \
-        dlfcn.h \
-        alloca.h \
-        winsock.h \
-        time.h \
-        io.h \
-        pwd.h \
-        utime.h \
-        sys/utime.h
+if test "$ac_cv_func_gethostbyname_r" = "yes"; then
+  if test "$ac_cv_gethostbyname_args" = "0"; then
+            { { echo "$as_me:10880: error: couldn't figure out how to use gethostbyname_r()" >&5
+echo "$as_me: error: couldn't figure out how to use gethostbyname_r()" >&2;}
+   { (exit 1); exit 1; }; }
+  fi
+fi
 
+for ac_func in gethostbyaddr_r
 do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:10671: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:10889: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 10677 "configure"
+#line 10895 "configure"
 #include "confdefs.h"
-#include <$ac_header>
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+char (*f) ();
+
+int
+main ()
+{
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+f = $ac_func;
+#endif
+
+  ;
+  return 0;
+}
 _ACEOF
-if { (eval echo "$as_me:10681: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:10926: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
-  egrep -v '^ *\+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:10687: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  eval "$as_ac_Header=yes"
+  echo "$as_me:10929: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:10932: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:10935: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  eval "$as_ac_Header=no"
+cat conftest.$ac_ext >&5
+eval "$as_ac_var=no"
 fi
-rm -f conftest.err conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:10706: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
+echo "$as_me:10945: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 EOF
 
-fi
-done
-
-echo "$as_me:10716: checking for $CC option to accept ANSI C" >&5
-echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
-if test "${ac_cv_prog_cc_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_prog_cc_stdc=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-#line 10724 "configure"
+    echo "$as_me:10952: checking if gethostbyaddr_r takes 5 arguments" >&5
+echo $ECHO_N "checking if gethostbyaddr_r takes 5 arguments... $ECHO_C" >&6
+    cat >conftest.$ac_ext <<_ACEOF
+#line 10955 "configure"
 #include "confdefs.h"
-#include <stdarg.h>
-#include <stdio.h>
+
 #include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
+#include <netdb.h>
+int
+main ()
 {
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
+
+char * address;
+int length;
+int type;
+struct hostent h;
+struct hostent_data hdata;
+int rc;
+rc = gethostbyaddr_r(address, length, type, &h, &hdata);
+  ;
+  return 0;
 }
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:10976: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:10979: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:10982: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:10985: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+      echo "$as_me:10988: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+      cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYADDR_R_5 1
+EOF
+
+      ac_cv_gethostbyaddr_args=5
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+
+      echo "$as_me:10999: result: no" >&5
+echo "${ECHO_T}no" >&6
+      echo "$as_me:11001: checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments" >&5
+echo $ECHO_N "checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments... $ECHO_C" >&6
+      cat >conftest.$ac_ext <<_ACEOF
+#line 11004 "configure"
+#include "confdefs.h"
+
+#define _REENTRANT
+#include <sys/types.h>
+#include <netdb.h>
 int
 main ()
 {
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
+
+char * address;
+int length;
+int type;
+struct hostent h;
+struct hostent_data hdata;
+int rc;
+rc = gethostbyaddr_r(address, length, type, &h, &hdata);
   ;
   return 0;
 }
-_ACEOF
-# Don't try gcc -ansi; that turns off useful extensions and
-# breaks some systems' header files.
-# AIX			-qlanglvl=ansi
-# Ultrix and OSF/1	-std1
-# HP-UX 10.20 and later	-Ae
-# HP-UX older versions	-Aa -D_HPUX_SOURCE
-# SVR4			-Xc -D__EXTENSIONS__
-for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10773: \"$ac_compile\"") >&5
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:11026: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:10776: \$? = $ac_status" >&5
+  echo "$as_me:11029: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10779: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11032: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10782: \$? = $ac_status" >&5
+  echo "$as_me:11035: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_prog_cc_stdc=$ac_arg
-break
-else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-fi
-rm -f conftest.$ac_objext
-done
-rm -f conftest.$ac_ext conftest.$ac_objext
-CC=$ac_save_CC
 
-fi
+	echo "$as_me:11038: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYADDR_R_5 1
+EOF
 
-case "x$ac_cv_prog_cc_stdc" in
-  x|xno)
-    echo "$as_me:10799: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6 ;;
-  *)
-    echo "$as_me:10802: result: $ac_cv_prog_cc_stdc" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
-    CC="$CC $ac_cv_prog_cc_stdc" ;;
-esac
+	cat >>confdefs.h <<\EOF
+#define NEED_REENTRANT 1
+EOF
 
-echo "$as_me:10807: checking for an ANSI C-conforming const" >&5
-echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
-if test "${ac_cv_c_const+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+	ac_cv_gethostbyaddr_args=5
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 10813 "configure"
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+
+	echo "$as_me:11053: result: no" >&5
+echo "${ECHO_T}no" >&6
+	echo "$as_me:11055: checking if gethostbyaddr_r takes 7 arguments" >&5
+echo $ECHO_N "checking if gethostbyaddr_r takes 7 arguments... $ECHO_C" >&6
+	cat >conftest.$ac_ext <<_ACEOF
+#line 11058 "configure"
 #include "confdefs.h"
 
+#include <sys/types.h>
+#include <netdb.h>
 int
 main ()
 {
-/* FIXME: Include the comments suggested by Paul. */
-#ifndef __cplusplus
-  /* Ultrix mips cc rejects this.  */
-  typedef int charset[2];
-  const charset x;
-  /* SunOS 4.1.1 cc rejects this.  */
-  char const *const *ccp;
-  char **p;
-  /* NEC SVR4.0.2 mips cc rejects this.  */
-  struct point {int x, y;};
-  static struct point const zero = {0,0};
-  /* AIX XL C 1.02.0.0 rejects this.
-     It does not let you subtract one const X* pointer from another in
-     an arm of an if-expression whose if-part is not a constant
-     expression */
-  const char *g = "string";
-  ccp = &g + (g ? g-g : 0);
-  /* HPUX 7.0 cc rejects these. */
-  ++ccp;
-  p = (char**) ccp;
-  ccp = (char const *const *) p;
-  { /* SCO 3.2v4 cc rejects this.  */
-    char *t;
-    char const *s = 0 ? (char *) 0 : (char const *) 0;
 
-    *t++ = 0;
-  }
-  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
-    int x[] = {25, 17};
-    const int *foo = &x[0];
-    ++foo;
-  }
-  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
-    typedef const int *iptr;
-    iptr p = 0;
-    ++p;
-  }
-  { /* AIX XL C 1.02.0.0 rejects this saying
-       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
-    struct s { int j; const int *ap[3]; };
-    struct s *b; b->j = 5;
-  }
-  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
-    const int foo = 10;
-  }
-#endif
+char * address;
+int length;
+int type;
+struct hostent h;
+char buffer[8192];
+int h_errnop;
+struct hostent * hp;
 
+hp = gethostbyaddr_r(address, length, type, &h,
+                     buffer, 8192, &h_errnop);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10871: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:11082: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:10874: \$? = $ac_status" >&5
+  echo "$as_me:11085: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10877: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11088: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10880: \$? = $ac_status" >&5
+  echo "$as_me:11091: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_c_const=yes
+
+	  echo "$as_me:11094: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	  cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYADDR_R_7 1
+EOF
+
+	  ac_cv_gethostbyaddr_args=7
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_c_const=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-fi
-echo "$as_me:10890: result: $ac_cv_c_const" >&5
-echo "${ECHO_T}$ac_cv_c_const" >&6
-if test $ac_cv_c_const = no; then
 
-cat >>confdefs.h <<\EOF
-#define const
-EOF
+	  echo "$as_me:11105: result: no" >&5
+echo "${ECHO_T}no" >&6
+	  echo "$as_me:11107: checking if gethostbyaddr_r takes 8 arguments" >&5
+echo $ECHO_N "checking if gethostbyaddr_r takes 8 arguments... $ECHO_C" >&6
+	  cat >conftest.$ac_ext <<_ACEOF
+#line 11110 "configure"
+#include "confdefs.h"
 
-fi
+#include <sys/types.h>
+#include <netdb.h>
+int
+main ()
+{
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+char * address;
+int length;
+int type;
+struct hostent h;
+char buffer[8192];
+int h_errnop;
+struct hostent * hp;
+int rc;
 
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-                  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:10906: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line 10912 "configure"
-#include "confdefs.h"
-$ac_includes_default
-#include <$ac_header>
+rc = gethostbyaddr_r(address, length, type, &h,
+                     buffer, 8192, &hp, &h_errnop);
+  ;
+  return 0;
+}
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10918: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:11135: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:10921: \$? = $ac_status" >&5
+  echo "$as_me:11138: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10924: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11141: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10927: \$? = $ac_status" >&5
+  echo "$as_me:11144: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_Header=yes"
+
+	    echo "$as_me:11147: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+	    cat >>confdefs.h <<\EOF
+#define HAVE_GETHOSTBYADDR_R_8 1
+EOF
+
+	    ac_cv_gethostbyaddr_args=8
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-eval "$as_ac_Header=no"
+
+	    echo "$as_me:11158: result: no" >&5
+echo "${ECHO_T}no" >&6
+	    have_missing_r_funcs="$have_missing_r_funcs gethostbyaddr_r"
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:10937: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<EOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-EOF
-
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
 done
 
-echo "$as_me:10947: checking for size_t" >&5
-echo $ECHO_N "checking for size_t... $ECHO_C" >&6
-if test "${ac_cv_type_size_t+set}" = set; then
+for ac_func in inet_ntoa_r
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:11175: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 10953 "configure"
+#line 11181 "configure"
 #include "confdefs.h"
-$ac_includes_default
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+char (*f) ();
+
 int
 main ()
 {
-if ((size_t *) 0)
-  return 0;
-if (sizeof (size_t))
-  return 0;
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+f = $ac_func;
+#endif
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:10968: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:11212: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:10971: \$? = $ac_status" >&5
+  echo "$as_me:11215: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:10974: \"$ac_try\"") >&5
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:11218: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:10977: \$? = $ac_status" >&5
+  echo "$as_me:11221: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_type_size_t=yes
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:11231: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+EOF
+
+    echo "$as_me:11238: checking whether inet_ntoa_r is declared" >&5
+echo $ECHO_N "checking whether inet_ntoa_r is declared... $ECHO_C" >&6
+    cat >conftest.$ac_ext <<_ACEOF
+#line 11241 "configure"
+#include "confdefs.h"
+
+#include <arpa/inet.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "inet_ntoa_r" >/dev/null 2>&1; then
+
+      cat >>confdefs.h <<\EOF
+#define HAVE_INET_NTOA_R_DECL 1
+EOF
+
+      echo "$as_me:11253: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+
+      echo "$as_me:11257: result: no" >&5
+echo "${ECHO_T}no" >&6
+      echo "$as_me:11259: checking whether inet_ntoa_r with -D_REENTRANT is declared" >&5
+echo $ECHO_N "checking whether inet_ntoa_r with -D_REENTRANT is declared... $ECHO_C" >&6
+      cat >conftest.$ac_ext <<_ACEOF
+#line 11262 "configure"
+#include "confdefs.h"
+
+#define _REENTRANT
+#include <arpa/inet.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "inet_ntoa_r" >/dev/null 2>&1; then
+
+	cat >>confdefs.h <<\EOF
+#define HAVE_INET_NTOA_R_DECL 1
+EOF
+
+	cat >>confdefs.h <<\EOF
+#define NEED_REENTRANT 1
+EOF
+
+	echo "$as_me:11279: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_cv_type_size_t=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+  echo "$as_me:11282: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-echo "$as_me:10987: result: $ac_cv_type_size_t" >&5
-echo "${ECHO_T}$ac_cv_type_size_t" >&6
-if test $ac_cv_type_size_t = yes; then
-  :
-else
+rm -f conftest*
 
-cat >>confdefs.h <<EOF
-#define size_t unsigned
-EOF
+fi
+rm -f conftest*
 
 fi
+done
 
-echo "$as_me:10999: checking whether time.h and sys/time.h may both be included" >&5
-echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
-if test "${ac_cv_header_time+set}" = set; then
+for ac_func in localtime_r
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:11296: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11005 "configure"
+#line 11302 "configure"
 #include "confdefs.h"
-#include <sys/types.h>
-#include <sys/time.h>
-#include <time.h>
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+char (*f) ();
 
 int
 main ()
 {
-if ((struct tm *) 0)
-return 0;
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+f = $ac_func;
+#endif
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11021: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:11333: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:11024: \$? = $ac_status" >&5
+  echo "$as_me:11336: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11027: \"$ac_try\"") >&5
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:11339: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11030: \$? = $ac_status" >&5
+  echo "$as_me:11342: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_header_time=yes
+  eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_header_time=no
+eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:11040: result: $ac_cv_header_time" >&5
-echo "${ECHO_T}$ac_cv_header_time" >&6
-if test $ac_cv_header_time = yes; then
+echo "$as_me:11352: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+EOF
 
-cat >>confdefs.h <<\EOF
-#define TIME_WITH_SYS_TIME 1
+    echo "$as_me:11359: checking whether localtime_r is declared" >&5
+echo $ECHO_N "checking whether localtime_r is declared... $ECHO_C" >&6
+    cat >conftest.$ac_ext <<_ACEOF
+#line 11362 "configure"
+#include "confdefs.h"
+
+#include <time.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "localtime_r" >/dev/null 2>&1; then
+
+      echo "$as_me:11370: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+
+      echo "$as_me:11374: result: no" >&5
+echo "${ECHO_T}no" >&6
+      echo "$as_me:11376: checking whether localtime_r with -D_REENTRANT is declared" >&5
+echo $ECHO_N "checking whether localtime_r with -D_REENTRANT is declared... $ECHO_C" >&6
+      cat >conftest.$ac_ext <<_ACEOF
+#line 11379 "configure"
+#include "confdefs.h"
+
+#define _REENTRANT
+#include <time.h>
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "localtime_r" >/dev/null 2>&1; then
+
+	cat >>confdefs.h <<\EOF
+#define NEED_REENTRANT 1
 EOF
 
+	echo "$as_me:11392: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+else
+  echo "$as_me:11395: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
+rm -f conftest*
 
-# mprintf() checks:
+fi
+rm -f conftest*
 
-# check for 'long double'
-echo "$as_me:11053: checking for long double" >&5
-echo $ECHO_N "checking for long double... $ECHO_C" >&6
-if test "${ac_cv_type_long_double+set}" = set; then
+fi
+done
+
+for ac_func in gmtime_r
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:11409: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11059 "configure"
+#line 11415 "configure"
 #include "confdefs.h"
-$ac_includes_default
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.  */
+#include <assert.h>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+char (*f) ();
+
 int
 main ()
 {
-if ((long double *) 0)
-  return 0;
-if (sizeof (long double))
-  return 0;
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+f = $ac_func;
+#endif
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11074: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:11446: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:11077: \$? = $ac_status" >&5
+  echo "$as_me:11449: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11080: \"$ac_try\"") >&5
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:11452: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11083: \$? = $ac_status" >&5
+  echo "$as_me:11455: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_type_long_double=yes
+  eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_cv_type_long_double=no
+eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:11465: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+EOF
+
+fi
+done
+
 fi
-echo "$as_me:11093: result: $ac_cv_type_long_double" >&5
-echo "${ECHO_T}$ac_cv_type_long_double" >&6
 
-echo "$as_me:11096: checking size of long double" >&5
-echo $ECHO_N "checking size of long double... $ECHO_C" >&6
-if test "${ac_cv_sizeof_long_double+set}" = set; then
+echo "$as_me:11477: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test "$ac_cv_type_long_double" = yes; then
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-#line 11105 "configure"
-#include "confdefs.h"
-$ac_includes_default
-int
-main ()
-{
-int _array_ [1 - 2 * !((sizeof (long double)) >= 0)]
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11117: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:11120: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11123: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:11126: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-#line 11131 "configure"
+  cat >conftest.$ac_ext <<_ACEOF
+#line 11483 "configure"
 #include "confdefs.h"
-$ac_includes_default
-int
-main ()
-{
-int _array_ [1 - 2 * !((sizeof (long double)) <= $ac_mid)]
-  ;
-  return 0;
-}
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
+
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11143: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:11146: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11149: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
+if { (eval echo "$as_me:11491: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  echo "$as_me:11152: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:11497: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
+  ac_cpp_err=yes
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-  done
+if test -z "$ac_cpp_err"; then
+  ac_cv_header_stdc=yes
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-#line 11168 "configure"
+  cat conftest.$ac_ext >&5
+  ac_cv_header_stdc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line 11519 "configure"
 #include "confdefs.h"
-$ac_includes_default
-int
-main ()
-{
-int _array_ [1 - 2 * !((sizeof (long double)) >= $ac_mid)]
-  ;
-  return 0;
-}
+#include <string.h>
+
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11180: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:11183: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11186: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:11189: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "memchr" >/dev/null 2>&1; then
+  :
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
+  ac_cv_header_stdc=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-  done
+rm -f conftest*
+
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
+
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line 11205 "configure"
+#line 11537 "configure"
 #include "confdefs.h"
-$ac_includes_default
-int
-main ()
-{
-int _array_ [1 - 2 * !((sizeof (long double)) <= $ac_mid)]
-  ;
-  return 0;
-}
+#include <stdlib.h>
+
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11217: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:11220: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11223: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:11226: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "free" >/dev/null 2>&1; then
+  :
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_lo=`expr $ac_mid + 1`
+  ac_cv_header_stdc=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-done
-ac_cv_sizeof_long_double=$ac_lo
-else
+rm -f conftest*
+
+fi
+
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:11239: error: cannot run test program while cross compiling" >&5
-echo "$as_me: error: cannot run test program while cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
+  :
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11244 "configure"
+#line 11558 "configure"
 #include "confdefs.h"
-$ac_includes_default
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
+#else
+# define ISLOWER(c) (('a' <= (c) && (c) <= 'i') \
+                     || ('j' <= (c) && (c) <= 'r') \
+                     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
+#endif
+
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int
 main ()
 {
-FILE *f = fopen ("conftest.val", "w");
-if (!f)
-  exit (1);
-fprintf (f, "%d", (sizeof (long double)));
-fclose (f);
-  ;
-  return 0;
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+        || toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
 }
 _ACEOF
 rm -f conftest$ac_exeext
-if { (eval echo "$as_me:11260: \"$ac_link\"") >&5
+if { (eval echo "$as_me:11584: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:11263: \$? = $ac_status" >&5
+  echo "$as_me:11587: \$? = $ac_status" >&5
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:11265: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11589: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11268: \$? = $ac_status" >&5
+  echo "$as_me:11592: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_sizeof_long_double=`cat conftest.val`
+  :
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
+ac_cv_header_stdc=no
 fi
 rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
-rm -f conftest.val
-else
-  ac_cv_sizeof_long_double=0
-fi
 fi
-echo "$as_me:11284: result: $ac_cv_sizeof_long_double" >&5
-echo "${ECHO_T}$ac_cv_sizeof_long_double" >&6
-cat >>confdefs.h <<EOF
-#define SIZEOF_LONG_DOUBLE $ac_cv_sizeof_long_double
+echo "$as_me:11605: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\EOF
+#define STDC_HEADERS 1
 EOF
 
-# check for 'long long'
-echo "$as_me:11291: checking for long long" >&5
-echo $ECHO_N "checking for long long... $ECHO_C" >&6
-if test "${ac_cv_type_long_long+set}" = set; then
+fi
+
+for ac_header in \
+        unistd.h \
+        malloc.h \
+        stdlib.h \
+        arpa/inet.h \
+        net/if.h \
+        netinet/in.h \
+	netinet/if_ether.h \
+        netdb.h \
+        sys/select.h \
+        sys/socket.h \
+        sys/sockio.h \
+        sys/stat.h \
+        sys/types.h \
+        sys/time.h \
+        sys/param.h \
+        termios.h \
+        termio.h \
+        sgtty.h \
+        fcntl.h \
+        dlfcn.h \
+        alloca.h \
+        winsock.h \
+        time.h \
+        io.h \
+        pwd.h \
+        utime.h \
+        sys/utime.h \
+        setjmp.h
+
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:11647: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11297 "configure"
+#line 11653 "configure"
 #include "confdefs.h"
-$ac_includes_default
-int
-main ()
-{
-if ((long long *) 0)
-  return 0;
-if (sizeof (long long))
-  return 0;
-  ;
-  return 0;
-}
+#include <$ac_header>
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11312: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:11315: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11318: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
+if { (eval echo "$as_me:11657: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
-  echo "$as_me:11321: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_long_long=yes
+  egrep -v '^ *\+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:11663: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  eval "$as_ac_Header=yes"
 else
   echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_cv_type_long_long=no
+  cat conftest.$ac_ext >&5
+  eval "$as_ac_Header=no"
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_ext
+fi
+echo "$as_me:11682: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+EOF
+
 fi
-echo "$as_me:11331: result: $ac_cv_type_long_long" >&5
-echo "${ECHO_T}$ac_cv_type_long_long" >&6
+done
 
-echo "$as_me:11334: checking size of long long" >&5
-echo $ECHO_N "checking size of long long... $ECHO_C" >&6
-if test "${ac_cv_sizeof_long_long+set}" = set; then
+echo "$as_me:11692: checking for $CC option to accept ANSI C" >&5
+echo $ECHO_N "checking for $CC option to accept ANSI C... $ECHO_C" >&6
+if test "${ac_cv_prog_cc_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test "$ac_cv_type_long_long" = yes; then
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
+  ac_cv_prog_cc_stdc=no
+ac_save_CC=$CC
 cat >conftest.$ac_ext <<_ACEOF
-#line 11343 "configure"
+#line 11700 "configure"
 #include "confdefs.h"
-$ac_includes_default
+#include <stdarg.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
+struct buf { int x; };
+FILE * (*rcsopen) (struct buf *, struct stat *, int);
+static char *e (p, i)
+     char **p;
+     int i;
+{
+  return p[i];
+}
+static char *f (char * (*g) (char **, int), char **p, ...)
+{
+  char *s;
+  va_list v;
+  va_start (v,p);
+  s = g (p, va_arg (v,int));
+  va_end (v);
+  return s;
+}
+int test (int i, double x);
+struct s1 {int (*f) (int a);};
+struct s2 {int (*f) (double a);};
+int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
+int argc;
+char **argv;
 int
 main ()
 {
-int _array_ [1 - 2 * !((sizeof (long long)) >= 0)]
+return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11355: \"$ac_compile\"") >&5
+# Don't try gcc -ansi; that turns off useful extensions and
+# breaks some systems' header files.
+# AIX			-qlanglvl=ansi
+# Ultrix and OSF/1	-std1
+# HP-UX 10.20 and later	-Ae
+# HP-UX older versions	-Aa -D_HPUX_SOURCE
+# SVR4			-Xc -D__EXTENSIONS__
+for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
+do
+  CC="$ac_save_CC $ac_arg"
+  rm -f conftest.$ac_objext
+if { (eval echo "$as_me:11749: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11358: \$? = $ac_status" >&5
+  echo "$as_me:11752: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11361: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11755: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11364: \$? = $ac_status" >&5
+  echo "$as_me:11758: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-#line 11369 "configure"
+  ac_cv_prog_cc_stdc=$ac_arg
+break
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+fi
+rm -f conftest.$ac_objext
+done
+rm -f conftest.$ac_ext conftest.$ac_objext
+CC=$ac_save_CC
+
+fi
+
+case "x$ac_cv_prog_cc_stdc" in
+  x|xno)
+    echo "$as_me:11775: result: none needed" >&5
+echo "${ECHO_T}none needed" >&6 ;;
+  *)
+    echo "$as_me:11778: result: $ac_cv_prog_cc_stdc" >&5
+echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6
+    CC="$CC $ac_cv_prog_cc_stdc" ;;
+esac
+
+echo "$as_me:11783: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
+if test "${ac_cv_c_const+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 11789 "configure"
 #include "confdefs.h"
-$ac_includes_default
+
 int
 main ()
 {
-int _array_ [1 - 2 * !((sizeof (long long)) <= $ac_mid)]
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset x;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *ccp;
+  char **p;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  ccp = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+  }
+#endif
+
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11381: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:11847: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11384: \$? = $ac_status" >&5
+  echo "$as_me:11850: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11387: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11853: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11390: \$? = $ac_status" >&5
+  echo "$as_me:11856: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
+  ac_cv_c_const=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_lo=`expr $ac_mid + 1`; ac_mid=`expr 2 '*' $ac_mid + 1`
+ac_cv_c_const=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
-  done
+fi
+echo "$as_me:11866: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
+if test $ac_cv_c_const = no; then
+
+cat >>confdefs.h <<\EOF
+#define const
+EOF
+
+fi
+
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+                  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:11882: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  echo "$as_me: failed program was:" >&5
-cat conftest.$ac_ext >&5
-ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-#line 11406 "configure"
+  cat >conftest.$ac_ext <<_ACEOF
+#line 11888 "configure"
 #include "confdefs.h"
 $ac_includes_default
-int
-main ()
-{
-int _array_ [1 - 2 * !((sizeof (long long)) >= $ac_mid)]
-  ;
-  return 0;
-}
+#include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11418: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:11894: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11421: \$? = $ac_status" >&5
+  echo "$as_me:11897: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11424: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11900: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11427: \$? = $ac_status" >&5
+  echo "$as_me:11903: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
+  eval "$as_ac_Header=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_hi=`expr $ac_mid - 1`; ac_mid=`expr 2 '*' $ac_mid`
+eval "$as_ac_Header=no"
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
-  done
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
+echo "$as_me:11913: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<EOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+EOF
+
+fi
+done
+
+echo "$as_me:11923: checking for size_t" >&5
+echo $ECHO_N "checking for size_t... $ECHO_C" >&6
+if test "${ac_cv_type_size_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11443 "configure"
+#line 11929 "configure"
 #include "confdefs.h"
 $ac_includes_default
 int
 main ()
 {
-int _array_ [1 - 2 * !((sizeof (long long)) <= $ac_mid)]
+if ((size_t *) 0)
+  return 0;
+if (sizeof (size_t))
+  return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11455: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:11944: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11458: \$? = $ac_status" >&5
+  echo "$as_me:11947: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11461: \"$ac_try\"") >&5
+  { (eval echo "$as_me:11950: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11464: \$? = $ac_status" >&5
+  echo "$as_me:11953: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
+  ac_cv_type_size_t=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
-ac_lo=`expr $ac_mid + 1`
+ac_cv_type_size_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
-done
-ac_cv_sizeof_long_long=$ac_lo
+fi
+echo "$as_me:11963: result: $ac_cv_type_size_t" >&5
+echo "${ECHO_T}$ac_cv_type_size_t" >&6
+if test $ac_cv_type_size_t = yes; then
+  :
 else
-  if test "$cross_compiling" = yes; then
-  { { echo "$as_me:11477: error: cannot run test program while cross compiling" >&5
-echo "$as_me: error: cannot run test program while cross compiling" >&2;}
-   { (exit 1); exit 1; }; }
+
+cat >>confdefs.h <<EOF
+#define size_t unsigned
+EOF
+
+fi
+
+echo "$as_me:11975: checking whether time.h and sys/time.h may both be included" >&5
+echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
+if test "${ac_cv_header_time+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11482 "configure"
+#line 11981 "configure"
 #include "confdefs.h"
-$ac_includes_default
+#include <sys/types.h>
+#include <sys/time.h>
+#include <time.h>
+
 int
 main ()
 {
-FILE *f = fopen ("conftest.val", "w");
-if (!f)
-  exit (1);
-fprintf (f, "%d", (sizeof (long long)));
-fclose (f);
+if ((struct tm *) 0)
+return 0;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:11498: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:11997: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11501: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (eval echo "$as_me:11503: \"$ac_try\"") >&5
+  echo "$as_me:12000: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:12003: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11506: \$? = $ac_status" >&5
+  echo "$as_me:12006: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_sizeof_long_long=`cat conftest.val`
+  ac_cv_header_time=yes
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
+ac_cv_header_time=no
 fi
-rm -f core core.* *.core conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
-rm -f conftest.val
-else
-  ac_cv_sizeof_long_long=0
-fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:11522: result: $ac_cv_sizeof_long_long" >&5
-echo "${ECHO_T}$ac_cv_sizeof_long_long" >&6
-cat >>confdefs.h <<EOF
-#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
+echo "$as_me:12016: result: $ac_cv_header_time" >&5
+echo "${ECHO_T}$ac_cv_header_time" >&6
+if test $ac_cv_header_time = yes; then
+
+cat >>confdefs.h <<\EOF
+#define TIME_WITH_SYS_TIME 1
 EOF
 
+fi
+
+# mprintf() checks:
+
+# check for 'long double'
+# AC_CHECK_SIZEOF(long double, 8)
+# check for 'long long'
+# AC_CHECK_SIZEOF(long long, 4)
+
 # check for ssize_t
-echo "$as_me:11529: checking for ssize_t" >&5
+echo "$as_me:12034: checking for ssize_t" >&5
 echo $ECHO_N "checking for ssize_t... $ECHO_C" >&6
 if test "${ac_cv_type_ssize_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11535 "configure"
+#line 12040 "configure"
 #include "confdefs.h"
 $ac_includes_default
 int
 main ()
 {
 if ((ssize_t *) 0)
@@ -11544,50 +12049,50 @@
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11550: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:12055: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11553: \$? = $ac_status" >&5
+  echo "$as_me:12058: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11556: \"$ac_try\"") >&5
+  { (eval echo "$as_me:12061: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11559: \$? = $ac_status" >&5
+  echo "$as_me:12064: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_ssize_t=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_type_ssize_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:11569: result: $ac_cv_type_ssize_t" >&5
+echo "$as_me:12074: result: $ac_cv_type_ssize_t" >&5
 echo "${ECHO_T}$ac_cv_type_ssize_t" >&6
 if test $ac_cv_type_ssize_t = yes; then
   :
 else
 
 cat >>confdefs.h <<EOF
 #define ssize_t int
 EOF
 
 fi
 
-   echo "$as_me:11581: checking for socklen_t" >&5
+   echo "$as_me:12086: checking for socklen_t" >&5
 echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
 if test "${ac_cv_type_socklen_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11587 "configure"
+#line 12092 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/socket.h>
 
 int
 main ()
@@ -11598,50 +12103,50 @@
   return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11604: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:12109: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11607: \$? = $ac_status" >&5
+  echo "$as_me:12112: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11610: \"$ac_try\"") >&5
+  { (eval echo "$as_me:12115: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11613: \$? = $ac_status" >&5
+  echo "$as_me:12118: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_socklen_t=yes
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_type_socklen_t=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:11623: result: $ac_cv_type_socklen_t" >&5
+echo "$as_me:12128: result: $ac_cv_type_socklen_t" >&5
 echo "${ECHO_T}$ac_cv_type_socklen_t" >&6
 if test $ac_cv_type_socklen_t = yes; then
   :
 else
 
-      echo "$as_me:11629: checking for socklen_t equivalent" >&5
+      echo "$as_me:12134: checking for socklen_t equivalent" >&5
 echo $ECHO_N "checking for socklen_t equivalent... $ECHO_C" >&6
       if test "${curl_cv_socklen_t_equiv+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
          # Systems have either "struct sockaddr *" or
          # "void *" as the second argument to getpeername
          curl_cv_socklen_t_equiv=
          for arg2 in "struct sockaddr" void; do
             for t in int size_t unsigned long "unsigned long"; do
                cat >conftest.$ac_ext <<_ACEOF
-#line 11641 "configure"
+#line 12146 "configure"
 #include "confdefs.h"
 
                   #include <sys/types.h>
                   #include <sys/socket.h>
 
                   int getpeername (int, $arg2 *, $t *);
@@ -11655,22 +12160,22 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11661: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:12166: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11664: \$? = $ac_status" >&5
+  echo "$as_me:12169: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11667: \"$ac_try\"") >&5
+  { (eval echo "$as_me:12172: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11670: \$? = $ac_status" >&5
+  echo "$as_me:12175: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
 
                   curl_cv_socklen_t_equiv="$t"
                   break
 
 else
@@ -11679,35 +12184,152 @@
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
             done
          done
 
          if test "x$curl_cv_socklen_t_equiv" = x; then
-            { { echo "$as_me:11685: error: Cannot find a type to use in place of socklen_t" >&5
+            { { echo "$as_me:12190: error: Cannot find a type to use in place of socklen_t" >&5
 echo "$as_me: error: Cannot find a type to use in place of socklen_t" >&2;}
    { (exit 1); exit 1; }; }
          fi
 
 fi
 
-      echo "$as_me:11692: result: $curl_cv_socklen_t_equiv" >&5
+      echo "$as_me:12197: result: $curl_cv_socklen_t_equiv" >&5
 echo "${ECHO_T}$curl_cv_socklen_t_equiv" >&6
 
 cat >>confdefs.h <<EOF
 #define socklen_t $curl_cv_socklen_t_equiv
 EOF
 
 fi
 
-echo "$as_me:11701: checking return type of signal handlers" >&5
+   echo "$as_me:12206: checking for in_addr_t" >&5
+echo $ECHO_N "checking for in_addr_t... $ECHO_C" >&6
+if test "${ac_cv_type_in_addr_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line 12212 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+int
+main ()
+{
+if ((in_addr_t *) 0)
+  return 0;
+if (sizeof (in_addr_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:12230: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:12233: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:12236: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:12239: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_in_addr_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+ac_cv_type_in_addr_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:12249: result: $ac_cv_type_in_addr_t" >&5
+echo "${ECHO_T}$ac_cv_type_in_addr_t" >&6
+if test $ac_cv_type_in_addr_t = yes; then
+  :
+else
+
+      echo "$as_me:12255: checking for in_addr_t equivalent" >&5
+echo $ECHO_N "checking for in_addr_t equivalent... $ECHO_C" >&6
+      if test "${curl_cv_in_addr_t_equiv+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+         # Systems have either "struct sockaddr *" or
+         # "void *" as the second argument to getpeername
+         curl_cv_in_addr_t_equiv=
+         for t in int size_t unsigned long "unsigned long"; do
+            cat >conftest.$ac_ext <<_ACEOF
+#line 12266 "configure"
+#include "confdefs.h"
+
+               #include <sys/types.h>
+               #include <sys/socket.h>
+               #include <arpa/inet.h>
+
+int
+main ()
+{
+
+               $t data = inet_addr ("1.2.3.4");
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:12284: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:12287: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:12290: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:12293: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+
+               curl_cv_in_addr_t_equiv="$t"
+               break
+
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+         done
+
+         if test "x$curl_cv_in_addr_t_equiv" = x; then
+            { { echo "$as_me:12307: error: Cannot find a type to use in place of in_addr_t" >&5
+echo "$as_me: error: Cannot find a type to use in place of in_addr_t" >&2;}
+   { (exit 1); exit 1; }; }
+         fi
+
+fi
+
+      echo "$as_me:12314: result: $curl_cv_in_addr_t_equiv" >&5
+echo "${ECHO_T}$curl_cv_in_addr_t_equiv" >&6
+
+cat >>confdefs.h <<EOF
+#define in_addr_t $curl_cv_in_addr_t_equiv
+EOF
+
+fi
+
+echo "$as_me:12323: checking return type of signal handlers" >&5
 echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
 if test "${ac_cv_type_signal+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11707 "configure"
+#line 12329 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
 #ifdef signal
 # undef signal
 #endif
@@ -11723,32 +12345,32 @@
 int i;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
-if { (eval echo "$as_me:11729: \"$ac_compile\"") >&5
+if { (eval echo "$as_me:12351: \"$ac_compile\"") >&5
   (eval $ac_compile) 2>&5
   ac_status=$?
-  echo "$as_me:11732: \$? = $ac_status" >&5
+  echo "$as_me:12354: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:11735: \"$ac_try\"") >&5
+  { (eval echo "$as_me:12357: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11738: \$? = $ac_status" >&5
+  echo "$as_me:12360: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_type_signal=void
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 ac_cv_type_signal=int
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:11748: result: $ac_cv_type_signal" >&5
+echo "$as_me:12370: result: $ac_cv_type_signal" >&5
 echo "${ECHO_T}$ac_cv_type_signal" >&6
 
 cat >>confdefs.h <<EOF
 #define RETSIGTYPE $ac_cv_type_signal
 EOF
 
@@ -11761,13 +12383,12 @@
                 uname \
                 strcasecmp \
                 stricmp \
                 strcmpi \
                 gethostname \
                 gethostbyaddr \
-                getservbyname \
                 gettimeofday \
                 inet_addr \
                 inet_ntoa \
                 tcsetattr \
                 tcgetattr \
                 perror \
@@ -11777,23 +12398,24 @@
                 signal \
                 getpass_r \
                 strlcat \
                 getpwuid \
                 geteuid \
                 dlopen \
-                utime
+                utime \
+                sigsetjmp
 
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:11787: checking for $ac_func" >&5
+echo "$as_me:12409: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line 11793 "configure"
+#line 12415 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
@@ -11818,55 +12440,99 @@
 
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:11824: \"$ac_link\"") >&5
+if { (eval echo "$as_me:12446: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
-  echo "$as_me:11827: \$? = $ac_status" >&5
+  echo "$as_me:12449: \$? = $ac_status" >&5
   (exit $ac_status); } &&
          { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:11830: \"$ac_try\"") >&5
+  { (eval echo "$as_me:12452: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
-  echo "$as_me:11833: \$? = $ac_status" >&5
+  echo "$as_me:12455: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   eval "$as_ac_var=yes"
 else
   echo "$as_me: failed program was:" >&5
 cat conftest.$ac_ext >&5
 eval "$as_ac_var=no"
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 fi
-echo "$as_me:11843: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "$as_me:12465: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<EOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 EOF
 
 fi
 done
 
+if test "$ac_cv_func_sigsetjmp" != "yes"; then
+  echo "$as_me:12476: checking for sigsetjmp defined as macro" >&5
+echo $ECHO_N "checking for sigsetjmp defined as macro... $ECHO_C" >&6
+  cat >conftest.$ac_ext <<_ACEOF
+#line 12479 "configure"
+#include "confdefs.h"
+#include <setjmp.h>
+int
+main ()
+{
+sigjmp_buf jmpenv;
+                sigsetjmp(jmpenv, 1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:12492: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:12495: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:12498: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:12501: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  echo "$as_me:12503: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+               cat >>confdefs.h <<\EOF
+#define HAVE_SIGSETJMP 1
+EOF
+
+else
+  echo "$as_me: failed program was:" >&5
+cat conftest.$ac_ext >&5
+echo "$as_me:12512: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+
 if test "$ac_cv_func_select" != "yes"; then
-  { { echo "$as_me:11854: error: Can't work without an existing select() function" >&5
+  { { echo "$as_me:12520: error: Can't work without an existing select() function" >&5
 echo "$as_me: error: Can't work without an existing select() function" >&2;}
    { (exit 1); exit 1; }; }
 fi
 if test "$ac_cv_func_socket" != "yes"; then
-  { { echo "$as_me:11859: error: Can't work without an existing socket() function" >&5
+  { { echo "$as_me:12525: error: Can't work without an existing socket() function" >&5
 echo "$as_me: error: Can't work without an existing socket() function" >&2;}
    { (exit 1); exit 1; }; }
 fi
 
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
-echo "$as_me:11866: checking for $ac_word" >&5
+echo "$as_me:12532: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_path_PERL+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   case $PERL in
   [\\/]* | ?:[\\/]*)
@@ -11877,35 +12543,35 @@
 ac_dummy="$PATH:/usr/local/bin/perl:/usr/bin/:/usr/local/bin "
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   if $as_executable_p "$ac_dir/$ac_word"; then
    ac_cv_path_PERL="$ac_dir/$ac_word"
-   echo "$as_me:11883: found $ac_dir/$ac_word" >&5
+   echo "$as_me:12549: found $ac_dir/$ac_word" >&5
    break
 fi
 done
 
   ;;
 esac
 fi
 PERL=$ac_cv_path_PERL
 
 if test -n "$PERL"; then
-  echo "$as_me:11894: result: $PERL" >&5
+  echo "$as_me:12560: result: $PERL" >&5
 echo "${ECHO_T}$PERL" >&6
 else
-  echo "$as_me:11897: result: no" >&5
+  echo "$as_me:12563: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
 for ac_prog in gnroff nroff
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-echo "$as_me:11905: checking for $ac_word" >&5
+echo "$as_me:12571: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_path_NROFF+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   case $NROFF in
   [\\/]* | ?:[\\/]*)
@@ -11916,38 +12582,38 @@
 ac_dummy="$PATH:/usr/bin/:/usr/local/bin "
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   if $as_executable_p "$ac_dir/$ac_word"; then
    ac_cv_path_NROFF="$ac_dir/$ac_word"
-   echo "$as_me:11922: found $ac_dir/$ac_word" >&5
+   echo "$as_me:12588: found $ac_dir/$ac_word" >&5
    break
 fi
 done
 
   ;;
 esac
 fi
 NROFF=$ac_cv_path_NROFF
 
 if test -n "$NROFF"; then
-  echo "$as_me:11933: result: $NROFF" >&5
+  echo "$as_me:12599: result: $NROFF" >&5
 echo "${ECHO_T}$NROFF" >&6
 else
-  echo "$as_me:11936: result: no" >&5
+  echo "$as_me:12602: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   test -n "$NROFF" && break
 done
 
 for ac_prog in 'bison -y' byacc
 do
   # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
-echo "$as_me:11947: checking for $ac_word" >&5
+echo "$as_me:12613: checking for $ac_word" >&5
 echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
 if test "${ac_cv_prog_YACC+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test -n "$YACC"; then
   ac_cv_prog_YACC="$YACC" # Let the user override the test.
@@ -11956,32 +12622,55 @@
 ac_dummy="$PATH"
 for ac_dir in $ac_dummy; do
   IFS=$ac_save_IFS
   test -z "$ac_dir" && ac_dir=.
   $as_executable_p "$ac_dir/$ac_word" || continue
 ac_cv_prog_YACC="$ac_prog"
-echo "$as_me:11962: found $ac_dir/$ac_word" >&5
+echo "$as_me:12628: found $ac_dir/$ac_word" >&5
 break
 done
 
 fi
 fi
 YACC=$ac_cv_prog_YACC
 if test -n "$YACC"; then
-  echo "$as_me:11970: result: $YACC" >&5
+  echo "$as_me:12636: result: $YACC" >&5
 echo "${ECHO_T}$YACC" >&6
 else
-  echo "$as_me:11973: result: no" >&5
+  echo "$as_me:12639: result: no" >&5
 echo "${ECHO_T}no" >&6
 fi
 
   test -n "$YACC" && break
 done
 test -n "$YACC" || YACC="yacc"
 
-ac_config_files="$ac_config_files Makefile docs/Makefile docs/examples/Makefile include/Makefile include/curl/Makefile src/Makefile lib/Makefile tests/Makefile tests/data/Makefile packages/Makefile packages/Win32/Makefile packages/Linux/Makefile packages/Linux/RPM/Makefile packages/Linux/RPM/curl.spec packages/Linux/RPM/curl-ssl.spec packages/Solaris/Makefile curl-config"
+echo "$as_me:12647: checking whether to enable debug options" >&5
+echo $ECHO_N "checking whether to enable debug options... $ECHO_C" >&6
+# Check whether --enable-debug or --disable-debug was given.
+if test "${enable_debug+set}" = set; then
+  enableval="$enable_debug"
+   case "$enableval" in
+  no)
+       echo "$as_me:12654: result: no" >&5
+echo "${ECHO_T}no" >&6
+       ;;
+  *)   echo "$as_me:12657: result: yes" >&5
+echo "${ECHO_T}yes" >&6
+
+    CPPFLAGS="$CPPFLAGS -DMALLOCDEBUG"
+    CFLAGS="-W -Wall -Wwrite-strings -pedantic -Wundef -Wpointer-arith -Wcast-align -Wnested-externs -g"
+       ;;
+  esac
+else
+  echo "$as_me:12665: result: no" >&5
+echo "${ECHO_T}no" >&6
+
+fi;
+
+ac_config_files="$ac_config_files Makefile docs/Makefile docs/examples/Makefile docs/libcurl/Makefile include/Makefile include/curl/Makefile src/Makefile lib/Makefile tests/Makefile tests/data/Makefile tests/server/Makefile packages/Makefile packages/Win32/Makefile packages/Win32/cygwin/Makefile packages/Linux/Makefile packages/Linux/RPM/Makefile packages/Linux/RPM/curl.spec packages/Linux/RPM/curl-ssl.spec packages/Solaris/Makefile packages/EPM/curl.list packages/EPM/Makefile curl-config"
 
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
 # scripts and configure runs, see configure's option --config-cache.
 # It is not useful on other systems.  If it contains results you don't
@@ -12056,13 +12745,13 @@
 
 DEFS=-DHAVE_CONFIG_H
 
 : ${CONFIG_STATUS=./config.status}
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ echo "$as_me:12062: creating $CONFIG_STATUS" >&5
+{ echo "$as_me:12751: creating $CONFIG_STATUS" >&5
 echo "$as_me: creating $CONFIG_STATUS" >&6;}
 cat >$CONFIG_STATUS <<_ACEOF
 #! $SHELL
 # Generated automatically by configure.
 # Run this file to recreate the current configuration.
 # Compiler output produced by configure, useful for debugging
@@ -12232,13 +12921,13 @@
 EOF
 cat >>$CONFIG_STATUS <<\EOF
   --version | --vers* | -V )
     echo "$ac_cs_version"; exit 0 ;;
   --he | --h)
     # Conflict between --help and --header
-    { { echo "$as_me:12238: error: ambiguous option: $1
+    { { echo "$as_me:12927: error: ambiguous option: $1
 Try \`$0 --help' for more information." >&5
 echo "$as_me: error: ambiguous option: $1
 Try \`$0 --help' for more information." >&2;}
    { (exit 1); exit 1; }; };;
   --help | --hel | -h )
     echo "$ac_cs_usage"; exit 0 ;;
@@ -12251,13 +12940,13 @@
   --header | --heade | --head | --hea )
     shift
     CONFIG_HEADERS="$CONFIG_HEADERS $1"
     ac_need_defaults=false;;
 
   # This is an error.
-  -*) { { echo "$as_me:12257: error: unrecognized option: $1
+  -*) { { echo "$as_me:12946: error: unrecognized option: $1
 Try \`$0 --help' for more information." >&5
 echo "$as_me: error: unrecognized option: $1
 Try \`$0 --help' for more information." >&2;}
    { (exit 1); exit 1; }; } ;;
 
   *) ac_config_targets="$ac_config_targets $1" ;;
@@ -12299,30 +12988,36 @@
 do
   case "$ac_config_target" in
   # Handling of arguments.
   "Makefile" ) CONFIG_FILES="$CONFIG_FILES Makefile" ;;
   "docs/Makefile" ) CONFIG_FILES="$CONFIG_FILES docs/Makefile" ;;
   "docs/examples/Makefile" ) CONFIG_FILES="$CONFIG_FILES docs/examples/Makefile" ;;
+  "docs/libcurl/Makefile" ) CONFIG_FILES="$CONFIG_FILES docs/libcurl/Makefile" ;;
   "include/Makefile" ) CONFIG_FILES="$CONFIG_FILES include/Makefile" ;;
   "include/curl/Makefile" ) CONFIG_FILES="$CONFIG_FILES include/curl/Makefile" ;;
   "src/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
   "lib/Makefile" ) CONFIG_FILES="$CONFIG_FILES lib/Makefile" ;;
   "tests/Makefile" ) CONFIG_FILES="$CONFIG_FILES tests/Makefile" ;;
   "tests/data/Makefile" ) CONFIG_FILES="$CONFIG_FILES tests/data/Makefile" ;;
+  "tests/server/Makefile" ) CONFIG_FILES="$CONFIG_FILES tests/server/Makefile" ;;
   "packages/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/Makefile" ;;
   "packages/Win32/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/Win32/Makefile" ;;
+  "packages/Win32/cygwin/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/Win32/cygwin/Makefile" ;;
   "packages/Linux/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/Linux/Makefile" ;;
   "packages/Linux/RPM/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/Linux/RPM/Makefile" ;;
   "packages/Linux/RPM/curl.spec" ) CONFIG_FILES="$CONFIG_FILES packages/Linux/RPM/curl.spec" ;;
   "packages/Linux/RPM/curl-ssl.spec" ) CONFIG_FILES="$CONFIG_FILES packages/Linux/RPM/curl-ssl.spec" ;;
   "packages/Solaris/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/Solaris/Makefile" ;;
+  "packages/EPM/curl.list" ) CONFIG_FILES="$CONFIG_FILES packages/EPM/curl.list" ;;
+  "packages/EPM/Makefile" ) CONFIG_FILES="$CONFIG_FILES packages/EPM/Makefile" ;;
   "curl-config" ) CONFIG_FILES="$CONFIG_FILES curl-config" ;;
   "default-1" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
-  "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
+  "lib/config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS lib/config.h" ;;
   "src/config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS src/config.h" ;;
-  *) { { echo "$as_me:12322: error: invalid argument: $ac_config_target" >&5
+  "tests/server/config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS tests/server/config.h" ;;
+  *) { { echo "$as_me:13017: error: invalid argument: $ac_config_target" >&5
 echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
    { (exit 1); exit 1; }; };;
   esac
 done
 
 # If the user did not use the arguments to specify the items to instantiate,
@@ -12446,13 +13141,26 @@
 s,@LN_S@,$LN_S,;t t
 s,@ECHO@,$ECHO,;t t
 s,@RANLIB@,$RANLIB,;t t
 s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
 s,@STRIP@,$STRIP,;t t
 s,@ac_ct_STRIP@,$ac_ct_STRIP,;t t
+s,@DLLTOOL@,$DLLTOOL,;t t
+s,@ac_ct_DLLTOOL@,$ac_ct_DLLTOOL,;t t
+s,@AS@,$AS,;t t
+s,@ac_ct_AS@,$ac_ct_AS,;t t
+s,@OBJDUMP@,$OBJDUMP,;t t
+s,@ac_ct_OBJDUMP@,$ac_ct_OBJDUMP,;t t
 s,@LIBTOOL@,$LIBTOOL,;t t
+s,@CURL_DISABLE_HTTP@,$CURL_DISABLE_HTTP,;t t
+s,@CURL_DISABLE_GOPHER@,$CURL_DISABLE_GOPHER,;t t
+s,@CURL_DISABLE_FTP@,$CURL_DISABLE_FTP,;t t
+s,@CURL_DISABLE_FILE@,$CURL_DISABLE_FILE,;t t
+s,@CURL_DISABLE_LDAP@,$CURL_DISABLE_LDAP,;t t
+s,@CURL_DISABLE_DICT@,$CURL_DISABLE_DICT,;t t
+s,@CURL_DISABLE_TELNET@,$CURL_DISABLE_TELNET,;t t
 s,@IPV6_ENABLED@,$IPV6_ENABLED,;t t
 s,@RANDOM_FILE@,$RANDOM_FILE,;t t
 s,@KRB4_ENABLED@,$KRB4_ENABLED,;t t
 s,@OPENSSL_ENABLED@,$OPENSSL_ENABLED,;t t
 s,@PERL@,$PERL,;t t
 s,@NROFF@,$NROFF,;t t
@@ -12568,13 +13276,13 @@
   case $INSTALL in
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
   *) ac_INSTALL=$ac_dots$INSTALL ;;
   esac
 
   if test x"$ac_file" != x-; then
-    { echo "$as_me:12574: creating $ac_file" >&5
+    { echo "$as_me:13282: creating $ac_file" >&5
 echo "$as_me: creating $ac_file" >&6;}
     rm -f "$ac_file"
   fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated automatically by config.status.  */
@@ -12586,26 +13294,26 @@
   ac_file_inputs=`IFS=:
     for f in $ac_file_in; do
       case $f in
       -) echo $tmp/stdin ;;
       [\\/$]*)
          # Absolute (can't be DOS-style, as IFS=:)
-         test -f "$f" || { { echo "$as_me:12592: error: cannot find input file: $f" >&5
+         test -f "$f" || { { echo "$as_me:13300: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
          echo $f;;
       *) # Relative
          if test -f "$f"; then
            # Build tree
            echo $f
          elif test -f "$srcdir/$f"; then
            # Source tree
            echo $srcdir/$f
          else
            # /dev/null tree
-           { { echo "$as_me:12605: error: cannot find input file: $f" >&5
+           { { echo "$as_me:13313: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
          fi;;
       esac
     done` || { (exit 1); exit 1; }
 EOF
@@ -12660,37 +13368,37 @@
         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   *:* ) ac_file_in=`echo "$ac_file" | sed 's,[^:]*:,,'`
         ac_file=`echo "$ac_file" | sed 's,:.*,,'` ;;
   * )   ac_file_in=$ac_file.in ;;
   esac
 
-  test x"$ac_file" != x- && { echo "$as_me:12666: creating $ac_file" >&5
+  test x"$ac_file" != x- && { echo "$as_me:13374: creating $ac_file" >&5
 echo "$as_me: creating $ac_file" >&6;}
 
   # First look for the input files in the build tree, otherwise in the
   # src tree.
   ac_file_inputs=`IFS=:
     for f in $ac_file_in; do
       case $f in
       -) echo $tmp/stdin ;;
       [\\/$]*)
          # Absolute (can't be DOS-style, as IFS=:)
-         test -f "$f" || { { echo "$as_me:12677: error: cannot find input file: $f" >&5
+         test -f "$f" || { { echo "$as_me:13385: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
          echo $f;;
       *) # Relative
          if test -f "$f"; then
            # Build tree
            echo $f
          elif test -f "$srcdir/$f"; then
            # Source tree
            echo $srcdir/$f
          else
            # /dev/null tree
-           { { echo "$as_me:12690: error: cannot find input file: $f" >&5
+           { { echo "$as_me:13398: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
          fi;;
       esac
     done` || { (exit 1); exit 1; }
   # Remove the trailing spaces.
@@ -12801,13 +13509,13 @@
     echo "/* $ac_file.  Generated automatically by configure.  */" >$tmp/config.h
   fi
   cat $tmp/in >>$tmp/config.h
   rm -f $tmp/in
   if test x"$ac_file" != x-; then
     if cmp -s $ac_file $tmp/config.h 2>/dev/null; then
-      { echo "$as_me:12807: $ac_file is unchanged" >&5
+      { echo "$as_me:13515: $ac_file is unchanged" >&5
 echo "$as_me: $ac_file is unchanged" >&6;}
     else
       ac_dir=`$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
          X"$ac_file" : 'X\(//\)[^/]' \| \
          X"$ac_file" : 'X\(//\)$' \| \
          X"$ac_file" : 'X\(/\)' \| \
@@ -12842,18 +13550,21 @@
   else
     cat $tmp/config.h
     rm -f $tmp/config.h
   fi
   # Run the commands associated with the file.
   case $ac_file in
-    config.h ) # update the timestamp
-echo timestamp >"./stamp-h1"
+    lib/config.h ) # update the timestamp
+echo timestamp >"lib/stamp-h1"
  ;;
     src/config.h ) # update the timestamp
 echo timestamp >"src/stamp-h2"
  ;;
+    tests/server/config.h ) # update the timestamp
+echo timestamp >"tests/server/stamp-h3"
+ ;;
   esac
 done
 EOF
 cat >>$CONFIG_STATUS <<\EOF
 
 #
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/configure.in	2001-09-12 19:31:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/configure.in	2002-06-11 23:10:37.000000000 +0800
@@ -1,12 +1,19 @@
-dnl $Id: configure.in,v 1.79 2001/09/12 11:31:58 bagder Exp $
+dnl $Id: configure.in,v 1.99 2002/06/11 15:10:18 bagder Exp $
 dnl Process this file with autoconf to produce a configure script.
+
+dnl Ensure that this file is processed with autoconf 2.50 or newer
+dnl Don't even think about removing this check!
+AC_PREREQ(2.50)
+
+dnl First some basic init macros
 AC_INIT
 AC_CONFIG_SRCDIR([lib/urldata.h])
-AM_CONFIG_HEADER(config.h src/config.h)
+AM_CONFIG_HEADER(lib/config.h src/config.h tests/server/config.h)
 
+dnl figure out the libcurl version
 VERSION=`sed -ne 's/^#define LIBCURL_VERSION "\(.*\)"/\1/p' ${srcdir}/include/curl/curl.h`
 AM_INIT_AUTOMAKE(curl,$VERSION)
 
 dnl
 dnl we extract the numerical version for curl-config only
 VERSIONNUM=`sed -ne 's/^#define LIBCURL_VERSION_NUM 0x\(.*\)/\1/p' ${srcdir}/include/curl/curl.h`
@@ -35,46 +42,143 @@
 dnl Checks for programs.
 AC_PROG_CC
 
 dnl check for how to do large files
 AC_SYS_LARGEFILE
 
+dnl check for cygwin stuff
+AC_LIBTOOL_WIN32_DLL
+
+dnl libtool setup
 AM_PROG_LIBTOOL
 
 dnl The install stuff has already been taken care of by the automake stuff
 dnl AC_PROG_INSTALL
 AC_PROG_MAKE_SET
 
 dnl ************************************************************
-dnl lame option to switch on debug options
+dnl switch off particular protocols
 dnl
-AC_MSG_CHECKING([whether to enable debug options])
-AC_ARG_ENABLE(debug,
-[  --enable-debug		Enable pedantic debug options
-  --disable-debug		Disable debug options],
+AC_MSG_CHECKING([whether to support http])
+AC_ARG_ENABLE(http,
+[  --enable-http		Enable HTTP support
+  --disable-http	Disable HTTP support],
 [ case "$enableval" in
   no)
        AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_HTTP)
+       AC_MSG_WARN([disable HTTP disables FTP over proxy and GOPHER too])
+       AC_DEFINE(CURL_DISABLE_GOPHER)
+       AC_SUBST(CURL_DISABLE_HTTP)
+       AC_SUBST(CURL_DISABLE_GOPHER)
        ;;
   *)   AC_MSG_RESULT(yes)
-
-    CPPFLAGS="$CPPFLAGS -DMALLOCDEBUG"
-    CFLAGS="-W -Wall -Wwrite-strings -pedantic -g" 
        ;;
   esac ],
+       AC_MSG_RESULT(yes)
+)
+AC_MSG_CHECKING([whether to support ftp])
+AC_ARG_ENABLE(ftp,
+[  --enable-ftp		Enable FTP support
+  --disable-ftp	Disable FTP support],
+[ case "$enableval" in
+  no)
        AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_FTP)
+       AC_SUBST(CURL_DISABLE_FTP)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       ;;
+  esac ],
+       AC_MSG_RESULT(yes)
 )
+AC_MSG_CHECKING([whether to support gopher])
+AC_ARG_ENABLE(gopher,
+[  --enable-gopher		Enable GOPHER support
+  --disable-gopher	Disable GOPHER support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_GOPHER)
+       AC_SUBST(CURL_DISABLE_GOPHER)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       ;;
+  esac ],
+       AC_MSG_RESULT(yes)
+)
+AC_MSG_CHECKING([whether to support file])
+AC_ARG_ENABLE(file,
+[  --enable-file		Enable FILE support
+  --disable-file	Disable FILE support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_FILE)
+       AC_SUBST(CURL_DISABLE_FILE)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       ;;
+  esac ],
+       AC_MSG_RESULT(yes)
+)
+AC_MSG_CHECKING([whether to support ldap])
+AC_ARG_ENABLE(ldap,
+[  --enable-ldap		Enable LDAP support
+  --disable-ldap	Disable LDAP support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_LDAP)
+       AC_SUBST(CURL_DISABLE_LDAP)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       ;;
+  esac ],
+       AC_MSG_RESULT(yes)
+)
+AC_MSG_CHECKING([whether to support dict])
+AC_ARG_ENABLE(dict,
+[  --enable-dict		Enable DICT support
+  --disable-dict	Disable DICT support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_DICT)
+       AC_SUBST(CURL_DISABLE_DICT)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       ;;
+  esac ],
+       AC_MSG_RESULT(yes)
+)
+AC_MSG_CHECKING([whether to support telnet])
+AC_ARG_ENABLE(telnet,
+[  --enable-telnet		Enable TELNET support
+  --disable-telnet	Disable TELNET support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       AC_DEFINE(CURL_DISABLE_TELNET)
+       AC_SUBST(CURL_DISABLE_TELNET)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       ;;
+  esac ],
+       AC_MSG_RESULT(yes)
+)
+
 
 dnl **********************************************************************
 dnl Checks for IPv6
 dnl **********************************************************************
 
 AC_MSG_CHECKING([whether to enable ipv6])
 AC_ARG_ENABLE(ipv6,
 [  --enable-ipv6		Enable ipv6 (with ipv4) support
-  --disable-ipv6		Disable ipv6 support],
+  --disable-ipv6	Disable ipv6 support],
 [ case "$enableval" in
   no)
        AC_MSG_RESULT(no)
        ipv6=no
        ;;
   *)   AC_MSG_RESULT(yes)
@@ -156,12 +260,30 @@
 AC_CHECK_FUNC(gethostname, , AC_CHECK_LIB(ucb, gethostname))
 
 dnl dl lib?
 AC_CHECK_FUNC(dlclose, , AC_CHECK_LIB(dl, dlopen))
 
 dnl **********************************************************************
+dnl Check how non-blocking sockets are set
+dnl **********************************************************************
+AC_ARG_ENABLE(nonblocking,
+[  --enable-nonblocking  Makes the script detect how to do it
+  --disable-nonblocking Makes the script disable non-blocking sockets],
+[
+  if test "$enableval" = "no" ; then
+    AC_MSG_WARN([non-blocking sockets disabled])
+    AC_DEFINE(HAVE_DISABLED_NONBLOCKING)
+  else
+    CURL_CHECK_NONBLOCKING_SOCKET
+  fi
+],
+[
+  CURL_CHECK_NONBLOCKING_SOCKET
+])
+
+dnl **********************************************************************
 dnl Check for the random seed preferences 
 dnl **********************************************************************
 
 AC_ARG_WITH(egd-socket,
     [  --with-egd-socket=FILE  Entropy Gathering Daemon socket pathname],
     [ EGD_SOCKET="$withval" ]
@@ -360,12 +482,16 @@
 
     if test $ac_cv_header_openssl_x509_h = no; then
       AC_CHECK_HEADERS(x509.h rsa.h crypto.h pem.h ssl.h err.h,
         OPENSSL_ENABLED=1)
     fi
 
+    dnl Check for the OpenSSL engine header, it is kind of "separated"
+    dnl from the main SSL check
+    AC_CHECK_HEADERS(openssl/engine.h)
+
     AC_SUBST(OPENSSL_ENABLED)
 
   fi
 
   if test X"$OPT_SSL" != Xoff &&
      test "$OPENSSL_ENABLED" != "1"; then
@@ -425,27 +551,26 @@
 then
   AC_MSG_WARN(libcurl will not get built using thread-safe functions)
   AC_DEFINE(DISABLED_THREADSAFE, 1, \
 Set to explicitly specify we don't want to use thread-safe functions)
 else
 
-  dnl check that 'localhost' resolves first
-  CURL_CHECK_WORKING_RESOLVER
-
   dnl dig around for gethostbyname_r()
   CURL_CHECK_GETHOSTBYNAME_R()
 
   dnl dig around for gethostbyaddr_r()
   CURL_CHECK_GETHOSTBYADDR_R()
 
   dnl poke around for inet_ntoa_r()
   CURL_CHECK_INET_NTOA_R()
 
   dnl is there a localtime_r()
   CURL_CHECK_LOCALTIME_R()
 
+  AC_CHECK_FUNCS( gmtime_r )
+
 fi
 
 dnl **********************************************************************
 dnl Back to "normal" configuring
 dnl **********************************************************************
 
@@ -463,26 +588,26 @@
         sys/select.h \
         sys/socket.h \
         sys/sockio.h \
         sys/stat.h \
         sys/types.h \
         sys/time.h \
-        getopt.h \
         sys/param.h \
         termios.h \
         termio.h \
         sgtty.h \
         fcntl.h \
         dlfcn.h \
         alloca.h \
         winsock.h \
         time.h \
         io.h \
         pwd.h \
         utime.h \
-        sys/utime.h
+        sys/utime.h \
+        setjmp.h
 )
 
 dnl Check for libz header
 dnl AC_CHECK_HEADERS(zlib.h)
 
 dnl Checks for typedefs, structures, and compiler characteristics.
@@ -490,20 +615,21 @@
 AC_TYPE_SIZE_T
 AC_HEADER_TIME
 
 # mprintf() checks:
 
 # check for 'long double'
-AC_CHECK_SIZEOF(long double, 8)
+# AC_CHECK_SIZEOF(long double, 8)
 # check for 'long long'
-AC_CHECK_SIZEOF(long long, 4)
+# AC_CHECK_SIZEOF(long long, 4)
 
 # check for ssize_t
 AC_CHECK_TYPE(ssize_t, int)
 
 TYPE_SOCKLEN_T
+TYPE_IN_ADDR_T
 
 dnl Checks for library functions.
 dnl AC_PROG_GCC_TRADITIONAL
 AC_TYPE_SIGNAL
 dnl AC_FUNC_VPRINTF
 AC_CHECK_FUNCS( socket \
@@ -515,13 +641,12 @@
                 uname \
                 strcasecmp \
                 stricmp \
                 strcmpi \
                 gethostname \
                 gethostbyaddr \
-                getservbyname \
                 gettimeofday \
                 inet_addr \
                 inet_ntoa \
                 tcsetattr \
                 tcgetattr \
                 perror \
@@ -531,15 +656,29 @@
                 signal \
                 getpass_r \
                 strlcat \
                 getpwuid \
                 geteuid \
                 dlopen \
-                utime
+                utime \
+                sigsetjmp
 )
 
+dnl sigsetjmp() might be a macro and no function so if it isn't found already
+dnl we make an extra check here!
+if test "$ac_cv_func_sigsetjmp" != "yes"; then
+  AC_MSG_CHECKING([for sigsetjmp defined as macro])
+  AC_TRY_LINK( [#include <setjmp.h>],
+               [sigjmp_buf jmpenv;
+                sigsetjmp(jmpenv, 1);],
+               AC_MSG_RESULT(yes)
+               AC_DEFINE(HAVE_SIGSETJMP),
+               AC_MSG_RESULT(no)
+               )
+fi
+
 dnl removed 'getpass' check on October 26, 2000
 
 if test "$ac_cv_func_select" != "yes"; then
   AC_MSG_ERROR(Can't work without an existing select() function)
 fi
 if test "$ac_cv_func_socket" != "yes"; then
@@ -557,26 +696,51 @@
 AC_PROG_YACC
 
 dnl AC_PATH_PROG( RANLIB, ranlib, /usr/bin/ranlib, 
 dnl   $PATH:/usr/bin/:/usr/local/bin )
 dnl AC_SUBST(RANLIB)
 
+dnl ************************************************************
+dnl lame option to switch on debug options
+dnl
+AC_MSG_CHECKING([whether to enable debug options])
+AC_ARG_ENABLE(debug,
+[  --enable-debug	Enable pedantic debug options
+  --disable-debug	Disable debug options],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       ;;
+  *)   AC_MSG_RESULT(yes)
+
+    CPPFLAGS="$CPPFLAGS -DMALLOCDEBUG"
+    CFLAGS="-W -Wall -Wwrite-strings -pedantic -Wundef -Wpointer-arith -Wcast-align -Wnested-externs -g" 
+       ;;
+  esac ],
+       AC_MSG_RESULT(no)
+)
+
 AC_CONFIG_FILES([Makefile \
 	   docs/Makefile \
            docs/examples/Makefile \
+           docs/libcurl/Makefile \
 	   include/Makefile \
 	   include/curl/Makefile \
 	   src/Makefile \
            lib/Makefile \
            tests/Makefile \
            tests/data/Makefile \
+           tests/server/Makefile \
 	   packages/Makefile \
 	   packages/Win32/Makefile \
+	   packages/Win32/cygwin/Makefile \
 	   packages/Linux/Makefile \
 	   packages/Linux/RPM/Makefile \
 	   packages/Linux/RPM/curl.spec \
 	   packages/Linux/RPM/curl-ssl.spec \
            packages/Solaris/Makefile \
+           packages/EPM/curl.list \
+           packages/EPM/Makefile \
            curl-config
 ])
 AC_OUTPUT
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9: config-vms.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9: config-win32.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/curl-config.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/curl-config.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/curl-config.in	2001-08-16 21:09:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/curl-config.in	2002-06-11 19:13:29.000000000 +0800
@@ -1,24 +1,25 @@
 #! /bin/sh
 #
 # The idea to this kind of setup info script was stolen from numerous
 # other packages, such as neon, libxml and gnome.
 #
-# $Id: curl-config.in,v 1.11 2001/08/16 13:09:20 bagder Exp $
+# $Id: curl-config.in,v 1.13 2002/06/11 11:13:29 bagder Exp $
 #
 prefix=@prefix@
 exec_prefix=@exec_prefix@
 includedir=@includedir@
 
 usage()
 {
     cat <<EOF
 Usage: curl-config [OPTION]
 
 Available values for OPTION include:
 
+  --cc        compiler
   --cflags    pre-processor and compiler flags
   --feature   newline separated list of enabled features
   --help      display this help and exit
   --libs      library linking information
   --prefix    curl install prefix
   --version   output version information
@@ -39,12 +40,16 @@
     # [not currently used]
     -*=*) value=`echo "$1" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
     *) value= ;;
     esac
 
     case "$1" in
+    --cc)
+	echo @CC@
+	;;
+
     --prefix)
 	echo $prefix
 	;;
 
     --feature)
 	if test "@OPENSSL_ENABLED@" = "1"; then
@@ -53,12 +58,33 @@
 	if test "@KRB4_ENABLED@" = "1"; then
           echo "KRB4"
         fi
 	if test "@IPV6_ENABLED@" = "1"; then
           echo "IPv6"
         fi
+	if test "@CURL_DISABLE_HTTP@" = "1"; then
+          echo "HTTP-disabled"
+        fi
+	if test "@CURL_DISABLE_FTP@" = "1"; then
+          echo "FTP-disabled"
+        fi
+	if test "@CURL_DISABLE_GOPHER@" = "1"; then
+          echo "GOPHER-disabled"
+        fi
+	if test "@CURL_DISABLE_FILE@" = "1"; then
+          echo "FILE-disabled"
+        fi
+	if test "@CURL_DISABLE_TELNET@" = "1"; then
+          echo "TELNET-disabled"
+        fi
+	if test "@CURL_DISABLE_LDAP@" = "1"; then
+          echo "LDAP-disabled"
+        fi
+	if test "@CURL_DISABLE_DICT@" = "1"; then
+          echo "DICT-disabled"
+        fi
 	;;
 
     --version)
 	echo libcurl @VERSION@
 	exit 0
 	;;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8: depcomp
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs: BINDINGS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/BUGS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/BUGS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/BUGS	2001-03-13 20:35:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/BUGS	2002-04-29 19:57:24.000000000 +0800
@@ -1,57 +1,79 @@
+$Id: BUGS,v 1.5 2002/04/27 18:31:49 bagder Exp $
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
 BUGS
 
   Curl and libcurl have grown substantially since the beginning. At the time
-  of writing (mid March 2001), there are 23000 lines of source code, and by
+  of writing (end of April 2002), there are 32000 lines of source code, and by
   the time you read this it has probably grown even more.
 
   Of course there are lots of bugs left. And lots of misfeatures.
 
   To help us make curl the stable and solid product we want it to be, we need
-  bug reports and bug fixes. If you can't fix a bug yourself and submit a fix
-  for it, try to report an as detailed report as possible to the curl mailing
-  list to allow one of us to have a go at a solution. You should also post
-  your bug/problem at curl's bug tracking system over at
+  bug reports and bug fixes.
+
+WHERE TO REPORT
+
+  If you can't fix a bug yourself and submit a fix for it, try to report an as
+  detailed report as possible to the curl mailing list to allow one of us to
+  have a go at a solution. You should also post your bug/problem at curl's bug
+  tracking system over at
 
         http://sourceforge.net/bugs/?group_id=976
 
+  (but please read the section below first before doing that)
+
+WHAT TO REPORT
+
   When reporting a bug, you should include information that will help us
-  understand what's wrong, what you expected to happen and how to repeat the
-  bad behaviour. You therefore need to supply your operating system's name and
-  version number (uname -a under a unix is fine), what version of curl you're
-  using (curl -V is fine), what URL you were working with and anything else
-  you think matters.
+  understand what's wrong what you expected to happen and how to repeat the
+  bad behavior. You therefore need to tell us:
+
+   - your operating system's name and version number (uname -a under a unix
+     is fine)
+   - what version of curl you're using (curl -V is fine)
+   - what URL you were working with (if possible), at least which protocol
+
+  and anything and everything else you think matters. Tell us what you
+  expected to happen, tell use what did happen, tell us how you could make it
+  work another way. Dig around, try out, test. Then include all the tiny bits
+  and pieces in your report. You will benefit from this yourself, as it will
+  enable us to help you quicker and more accurately.
+
+  Since curl deals with networks, it often helps us if you include a protocol
+  debug dump with your bug report. The output you get by using the -v
+  flag. Usually, you also get more info by using -i so that is likely to be
+  useful when reporting bugs as well.
 
   If curl crashed, causing a core dump (in unix), there is hardly any use to
   send that huge file to anyone of us. Unless we have an exact same system
   setup as you, we can't do much with it. What we instead ask of you is to get
   a stack trace and send that (much smaller) output to us instead!
 
   The address and how to subscribe to the mailing list is detailed in the
   MANUAL file.
 
-  HOW TO GET A STACK TRACE with a common unix debugger
-  ====================================================
+HOW TO GET A STACK TRACE
 
   First, you must make sure that you compile all sources with -g and that you
-  don't 'strip' the final executable.
+  don't 'strip' the final executable. Try to avoid optimizing the code as
+  well, remove -O, -O2 etc from the compiler options.
 
-  Run the program until it bangs.
+  Run the program until it dumps core.
 
   Run your debugger on the core file, like '<debugger> curl core'. <debugger>
   should be replaced with the name of your debugger, in most cases that will
   be 'gdb', but 'dbx' and others also occur.
 
   When the debugger has finished loading the core file and presents you a
-  prompt, you can give the compiler instructions. Enter 'where' (without the
-  quotes) and press return.
+  prompt, enter 'where' (without the quotes) and press return.
 
   The list that is presented is the stack trace. If everything worked, it is
   supposed to contain the chain of functions that were called when curl
-  crashed.
+  crashed. Include the stack trace with your detailed bug report. It'll help a
+  lot.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl.1	2001-09-12 07:05:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl.1	2002-05-28 16:58:52.000000000 +0800
@@ -1,14 +1,13 @@
 .\" You can view this file with:
 .\" nroff -man curl.1
 .\" Written by Daniel Stenberg
 .\"
-.TH curl 1 "12 Sep 2001" "Curl 7.9" "Curl Manual"
+.TH curl 1 "7 May 2002" "Curl 7.9.7" "Curl Manual"
 .SH NAME
-curl \- get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE, HTTP or
-HTTPS syntax.
+curl \- transfer a URL
 .SH SYNOPSIS
 .B curl [options]
 .I [URL...]
 .SH DESCRIPTION
 .B curl
 is a client to get documents/files from or send documents to a server, using
@@ -97,16 +96,13 @@
 .I http://www.openssl.org/docs/apps/ciphers.html (Option added in curl 7.9)
 
 If this option is used severl times, the last one will override the others.
 .IP "--connect-timeout <seconds>"
 Maximum time in seconds that you allow the connection to the server to take.
 This only limits the connection phase, once curl has connected this option is
-of no more use. This option didn't work in win32 systems until 7.7.2.  See
-also the
-.I "--max-time"
-option.
+of no more use. See also the \fI--max-time\fP option.
 
 If this option is used several times, the last one will be used.
 .IP "-c/--cookie-jar <file name>"
 Specify to which file you want curl to write all cookies after a completed
 operation. Curl writes all cookies previously read from a specified file as
 well as all cookies received from remote server(s). If no cookies are known,
@@ -114,21 +110,25 @@
 file format. If you set the file name to a single dash, "-", the cookies will
 be written to stdout. (Option added in curl 7.9)
 
 If this option is used several times, the last specfied file name will be
 used.
 .IP "-C/--continue-at <offset>"
-Continue/Resume a previous file transfer at the given offset. The
-given offset is the exact number of bytes that will be skipped
-counted from the beginning of the source file before it is transfered
-to the destination.
-If used with uploads, the ftp server command SIZE will not be used by
-curl. Upload resume is for FTP only.
-HTTP resume is only possible with HTTP/1.1 or later servers.
+Continue/Resume a previous file transfer at the given offset. The given offset
+is the exact number of bytes that will be skipped counted from the beginning
+of the source file before it is transfered to the destination.  If used with
+uploads, the ftp server command SIZE will not be used by curl.
+
+Use "-C -" to tell curl to automatically find out where/how to resume the
+transfer. It then uses the given output/input files to figure that out.
 
 If this option is used several times, the last one will be used.
+.IP "--crlf"
+(FTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).
+
+If this option is used twice, the second will again disable crlf converting.
 .IP "-d/--data <data>"
 (HTTP) Sends the specified data in a POST request to the HTTP server, in a way
 that can emulate as if a user has filled in a HTML form and pressed the submit
 button. Note that the data is sent exactly as specified with no extra
 processing (with all newlines cut off).  The data is expected to be
 "url-encoded". This will cause curl to pass the data to the server using the
@@ -158,35 +158,46 @@
 .IP "--data-binary <data>"
 (HTTP) This posts data in a similar manner as --data-ascii does, although when
 using this option the entire context of the posted data is kept as-is. If you
 want to post a binary file without the strip-newlines feature of the
 --data-ascii option, this is for you.
 
-If this option is used several times, the last one will be used.
-
 If this option is used several times, the ones following the first will
 append data.
+.IP "--disable-epsv"
+(FTP) Tell curl to disable the use of the EPSV command when doing passive FTP
+downloads. Curl will normally always first attempt to use EPSV before PASV,
+but with this option, it will not try using EPSV.
+
+If this option is used several times, each occurrence will toggle this on/off.
 .IP "-D/--dump-header <file>"
-(HTTP/FTP)
-Write the HTTP headers to this file. Write the FTP file info to this
-file if -I/--head is used.
+Write the protocol headers to the specified file.
 
 This option is handy to use when you want to store the cookies that a HTTP
 site sends to you. The cookies could then be read in a second curl invoke by
 using the -b/--cookie option!
 
+When used on FTP, the ftp server response lines are considered being "headers"
+and thus are saved there.
+
 If this option is used several times, the last one will be used.
 .IP "-e/--referer <URL>"
 (HTTP) Sends the "Referer Page" information to the HTTP server. This can also
 be set with the -H/--header flag of course.  When used with
 .I -L/--location 
 you can append ";auto" to the referer URL to make curl automatically set the
 previous URL when it follows a Location: header. The ";auto" string can be
 used alone, even if you don't set an initial referer.
 
 If this option is used several times, the last one will be used.
+.IP "--environment"
+(RISC OS ONLY) Sets a range of environment variables, using the names the -w
+option supports, to easier allow extraction of useful information after having
+run curl.
+
+If this option is used several times, each occurrence will toggle this on/off.
 .IP "--egd-file <file>"
 (HTTPS) Specify the path name to the Entropy Gathering Daemon socket. The
 socket is used to seed the random engine for SSL connections. See also the
 .I "--random-file"
 option.
 .IP "-E/--cert <certificate[:password]>"
@@ -197,23 +208,31 @@
 the terminal. Note that this certificate is the private key and the private
 certificate concatenated!
 
 If this option is used several times, the last one will be used.
 .IP "--cacert <CA certificate>"
 (HTTPS) Tells curl to use the specified certificate file to verify the
-peer. The certificate must be in PEM format.
+peer. The file may contain multiple CA certificates. The certificate(s) must
+be in PEM format.
+
+If this option is used several times, the last one will be used.
+.IP "--capath <CA certificate directory>"
+(HTTPS) Tells curl to use the specified certificate directory to verify the
+peer. The certificates must be in PEM format, and the directory must have been 
+processed using the c_rehash utility supplied with openssl. Certificate directories
+are not supported under Windows (because c_rehash uses symbolink links to
+create them). Using --capath can allow curl to make https connections much
+more efficiently than using --cacert if the --cacert file contains many CA certificates.
 
 If this option is used several times, the last one will be used.
 .IP "-f/--fail"
-(HTTP)
-Fail silently (no output at all) on server errors. This is mostly done
-like this to better enable scripts etc to better deal with failed
-attempts. In normal cases when a HTTP server fails to deliver a
-document, it returns a HTML document stating so (which often also
-describes why and more). This flag will prevent curl from
-outputting that and fail silently instead.
+(HTTP) Fail silently (no output at all) on server errors. This is mostly done
+like this to better enable scripts etc to better deal with failed attempts. In
+normal cases when a HTTP server fails to deliver a document, it returns a HTML
+document stating so (which often also describes why and more). This flag will
+prevent curl from outputting that and fail silently instead.
 
 If this option is used twice, the second will again disable silent failure.
 .IP "-F/--form <name=content>"
 (HTTP) This lets curl emulate a filled in form in which a user has pressed the
 submit button. This causes curl to POST data using the content-type
 multipart/form-data according to RFC1867. This enables uploading of binary
@@ -235,32 +254,36 @@
 
 This option can be used multiple times.
 .IP "-g/--globoff"
 This option switches off the "URL globbing parser". When you set this option,
 you can specify URLs that contain the letters {}[] without having them being
 interpreted by curl itself. Note that these letters are not normal legal URL
-contents but they should be encoded according to the URI standard. (Option
-added in curl 7.6)
+contents but they should be encoded according to the URI standard.
 .IP "-G/--get"
 When used, this option will make all data specified with -d/--data or
 --data-binary to be used in a HTTP GET request instead of the POST request
 that otherwise would be used. The data will be appended to the URL with a '?'
 separator. (Option added in curl 7.9)
+
+If used in combination with -I, the POST data will instead be appended to the
+URL with a HEAD request.
+
+If used multiple times, nothing special happens.
 .IP "-h/--help"
 Usage help.
 .IP "-H/--header <header>"
 (HTTP) Extra header to use when getting a web page. You may specify any number
 of extra headers. Note that if you should add a custom header that has the
 same name as one of the internal ones curl would use, your externally set
 header will be used instead of the internal one. This allows you to make even
 trickier stuff than curl would normally do. You should not replace internally
 set headers without knowing perfectly well what you're doing. Replacing an
 internal header with one without content on the right side of the colon will
 prevent that header from appearing.
 
-This option can be used multiple times.
+This option can be used multiple times to add/replace/remove multiple headers.
 .IP "-i/--include"
 (HTTP)
 Include the HTTP-header in the output. The HTTP-header includes things
 like server-name, date of the document, HTTP-version and more...
 
 If this option is used twice, the second will again disable header include.
@@ -275,12 +298,19 @@
 (HTTP/FTP)
 Fetch the HTTP-header only! HTTP-servers feature the command HEAD
 which this uses to get nothing but the header of a document. When used
 on a FTP file, curl displays the file size only.
 
 If this option is used twice, the second will again disable header only.
+.IP "-j/--junk-session-cookies"
+(HTTP) When curl is told to read cookies from a given file, this option will
+make it discard all "session cookies". This will basicly have the same effect
+as if a new session is started. Typical browsers always discard session
+cookies when they're closed down. (Added in 7.9.7)
+
+If this option is used several times, each occurrence will toggle this on/off.
 .IP "--krb4 <level>"
 (FTP) Enable kerberos4 authentication and use. The level must be entered and
 should be one of 'clear', 'safe', 'confidential' or 'private'. Should you use
 a level that is not one of these, 'private' will instead be used.
 
 If this option is used several times, the last one will be used.
@@ -292,20 +322,30 @@
 to contain white spaces, the parameter must be inclosed within quotes.  If the
 first column of a config line is a '#' character, the rest of the line will be
 treated as a comment.
 
 Specify the filename as '-' to make curl read the file from stdin.
 
+Note that to be able to specify a URL in the config file, you need to specify
+it using the --url option, and not by simply writing the URL on its own
+line. So, it could look similar to this:
+
+url = "http://curl.haxx.se/docs/"
+
 This option can be used multiple times.
 .IP "-l/--list-only"
 (FTP)
 When listing an FTP directory, this switch forces a name-only view.
 Especially useful if you want to machine-parse the contents of an FTP
 directory since the normal directory view doesn't use a standard look
 or format.
 
+This option causes an FTP NLST command to be sent.  Some FTP servers
+list only files in their response to NLST; they do not include
+subdirectories and symbolic links.
+
 If this option is used twice, the second will again disable list only.
 .IP "-L/--location"
 (HTTP/HTTPS) If the server reports that the requested page has a different
 location (indicated with the header line Location:) this flag will let curl
 attempt to reattempt the get on the new place. If used together with -i or -I,
 headers from all requested pages will be shown. If this flag is used when
@@ -313,16 +353,14 @@
 POST has been done.
 
 If this option is used twice, the second will again disable location following.
 .IP "-m/--max-time <seconds>"
 Maximum time in seconds that you allow the whole operation to take.  This is
 useful for preventing your batch jobs from hanging for hours due to slow
-networks or links going down.  This doesn't work fully in win32 systems.
-See also the
-.I "--connect-timeout"
-option.
+networks or links going down.  This doesn't work fully in win32 systems.  See
+also the \fI--connect-timeout\fP option.
 
 If this option is used several times, the last one will be used.
 .IP "-M/--manual"
 Manual. Display the huge help text.
 .IP "-n/--netrc"
 Makes curl scan the
@@ -473,43 +511,68 @@
 
 If this option is used twice, the second will again disable mute.
 .IP "-S/--show-error"
 When used with -s it makes curl show error message if it fails.
 
 If this option is used twice, the second will again disable show error.
+.IP "--stderr <file>"
+Redirect all writes to stderr to the specified file instead. If the file name
+is a plain '-', it is instead written to stdout. This option has no point when
+you're using a shell with decent redirecting capabilities.
+
+If this option is used several times, the last one will be used.
 .IP "-t/--telnet-option <OPT=val>"
 Pass options to the telnet protocol. Supported options are:
 
 TTYPE=<term> Sets the terminal type.
 
 XDISPLOC=<X display> Sets the X display location.
 
 NEW_ENV=<var,val> Sets an environment variable.
 .IP "-T/--upload-file <file>"
-Like -t, but this transfers the specified local file. If there is no
-file part in the specified URL, Curl will append the local file
-name. NOTE that you must use a trailing / on the last directory to
-really prove to Curl that there is no file name or curl will
-think that your last directory name is the remote file name to
-use. That will most likely cause the upload operation to fail. If
+This transfers the specified local file to the remote URL. If there is no file
+part in the specified URL, Curl will append the local file name. NOTE that you
+must use a trailing / on the last directory to really prove to Curl that there
+is no file name or curl will think that your last directory name is the remote
+file name to use. That will most likely cause the upload operation to fail. If
 this is used on a http(s) server, the PUT command will be used.
 
+Use the file name "-" (a single dash) to use stdin instead of a given file.
+
 If this option is used several times, the last one will be used.
+.IP "--trace <file>"
+Enables a full trace dump of all incoming and outgoing data, including
+descriptive information, to the given output file. Use "-" as filename to have
+the output sent to stdout.
+
+If this option is used several times, the last one will be used. (Added in
+curl 7.9.7)
+.IP "--trace-ascii <file>"
+Enables a full trace dump of all incoming and outgoing data, including
+descriptive information, to the given output file. Use "-" as filename to have
+the output sent to stdout.
+
+This is very similar to --trace, but leaves out the hex part and only shows
+the ASCII part of the dump. It makes smaller output that might be easier to
+read for untrained humans.
+
+If this option is used several times, the last one will be used. (Added in
+curl 7.9.7)
 .IP "-u/--user <user:password>"
 Specify user and password to use when fetching. See README.curl for detailed
 examples of how to use this. If no password is specified, curl will
 ask for it interactively.
 
 If this option is used several times, the last one will be used.
 .IP "-U/--proxy-user <user:password>"
 Specify user and password to use for Proxy authentication. If no
 password is specified, curl will ask for it interactively.
 
 If this option is used several times, the last one will be used.
 .IP "--url <URL>"
-Specify a URL to fetch. This option is mostly handy when you wanna specify
+Specify a URL to fetch. This option is mostly handy when you want to specify
 URL(s) in a config file.
 
 This option may be used any number of times. To control where this URL is written, use the
 .I -o
 or the
 .I -O
@@ -531,13 +594,13 @@
 specify it "@filename" and to tell curl to read the format from stdin you
 write "@-".
 
 The variables present in the output format will be substituted by the value or
 text that curl thinks fit, as described below. All variables are specified
 like %{variable_name} and to output a normal % you just write them like
-%%. You can output a newline by using \\n, a carrige return with \\r and a tab
+%%. You can output a newline by using \\n, a carriage return with \\r and a tab
 space with \\t.
 
 .B NOTE:
 The %-letter is a special letter in the win32-environment, where all
 occurrences of % must be doubled when using this option.
 
@@ -565,12 +628,17 @@
 .TP
 .B time_pretransfer
 The time, in seconds, it took from the start until the file transfer is just
 about to begin. This includes all pre-transfer commands and negotiations that
 are specific to the particular protocol(s) involved.
 .TP
+.B time_starttransfer
+The time, in seconds, it took from the start until the first byte is just about
+to be transfered. This includes time_pretransfer and also the time the
+server needs to calculate the result.
+.TP
 .B size_download
 The total amount of bytes that were downloaded.
 .TP
 .B size_upload
 The total amount of bytes that were uploaded.
 .TP
@@ -582,18 +650,26 @@
 .TP
 .B speed_download
 The average download speed that curl measured for the complete download.
 .TP
 .B speed_upload
 The average upload speed that curl measured for the complete upload.
+.TP
+.B content_type
+The Content-Type of the requested document, if there was any. (Added in 7.9.5)
 .RE
 
 If this option is used several times, the last one will be used.
 .IP "-x/--proxy <proxyhost[:port]>"
-Use specified proxy. If the port number is not specified, it is assumed at
-port 1080.
+Use specified HTTP proxy. If the port number is not specified, it is assumed
+at port 1080.
+
+\fBNote\fP that all operations that are performed over a HTTP proxy will
+transparantly be converted to HTTP. It means that certain protocol specific
+operations might not be available. This is not the case if you can tunnel
+through the proxy, as done with the \fI-p/--proxytunnel\fP option.
 
 If this option is used several times, the last one will be used.
 .IP "-X/--request <command>"
 (HTTP)
 Specifies a custom request to use when communicating with the HTTP server.
 The specified request will be used instead of the standard GET. Read the
@@ -629,55 +705,51 @@
 
 Start the date expression with a dash (-) to make it request for a document
 that is older than the given date/time, default is a document that is newer
 than the specified date/time.
 
 If this option is used several times, the last one will be used.
+.IP "-Z/--max-redirs <num>"
+Set maximum number of redirection-followings allowed. If -L/--location is
+used, this option can be used to prevent curl from following redirections "in
+absurdum".
+
+If this option is used several times, the last one will be used.
 .IP "-3/--sslv3"
 (HTTPS)
 Forces curl to use SSL version 3 when negotiating with a remote SSL server.
 .IP "-2/--sslv2"
 (HTTPS)
 Forces curl to use SSL version 2 when negotiating with a remote SSL server.
+.IP "-0/--http1.0"
+(HTTP) Forces curl to issue its requests using HTTP 1.0 instead of using its
+internally preferred: HTTP 1.1.
 .IP "-#/--progress-bar"
 Make curl display progress information as a progress bar instead of the
 default statistics.
 
 If this option is used twice, the second will again disable the progress bar.
-.IP "--crlf"
-(FTP) Convert LF to CRLF in upload. Useful for MVS (OS/390).
-
-If this option is used twice, the second will again disable crlf converting.
-.IP "--stderr <file>"
-Redirect all writes to stderr to the specified file instead. If the file name
-is a plain '-', it is instead written to stdout. This option has no point when
-you're using a shell with decent redirecting capabilities.
-
-If this option is used several times, the last one will be used.
 .SH FILES
 .I ~/.curlrc
 .RS
 Default config file.
 
 .SH ENVIRONMENT
-.IP "HTTP_PROXY [protocol://]<host>[:port]"
+.IP "http_proxy [protocol://]<host>[:port]"
 Sets proxy server to use for HTTP.
 .IP "HTTPS_PROXY [protocol://]<host>[:port]"
 Sets proxy server to use for HTTPS.
 .IP "FTP_PROXY [protocol://]<host>[:port]"
 Sets proxy server to use for FTP.
 .IP "GOPHER_PROXY [protocol://]<host>[:port]"
 Sets proxy server to use for GOPHER.
 .IP "ALL_PROXY [protocol://]<host>[:port]"
 Sets proxy server to use if no protocol-specific proxy is set.
 .IP "NO_PROXY <comma-separated list of hosts>"
-list of host names that shouldn't go through any proxy. If set to a
-asterisk '*' only, it matches all hosts.
-.IP "COLUMNS <integer>"
-The width of the terminal.  This variable only affects curl when the
---progress-bar option is used.
+list of host names that shouldn't go through any proxy. If set to a asterisk
+'*' only, it matches all hosts.
 .SH EXIT CODES
 There exists a bunch of different error codes and their corresponding error
 messages that may appear during bad conditions. At the time of this writing,
 the exit codes are:
 .IP 1
 Unsupported protocol. This build of curl has no support for this protocol.
@@ -771,19 +843,23 @@
 Internal error. A function was called with a bad parameter.
 .IP 44
 Internal error. A function was called in a bad order.
 .IP 45
 Interface error. A specified outgoing interface could not be used.
 .IP 46
-Bad password entered. An error was signalled when the password was entered.
+Bad password entered. An error was signaled when the password was entered.
 .IP 47
 Too many redirects. When following redirects, curl hit the maximum amount.
 .IP 48
 Unknown TELNET option specified.
 .IP 49
 Malformed telnet option.
+.IP 51
+The remote peer's SSL certificate wasn't ok
+.IP 52
+The server didn't reply anything, which here is considered an error.
 .IP XX
 There will appear more error codes here in future releases. The existing ones
 are meant to never change.
 .SH BUGS
 If you do find bugs, mail them to curl-bug@haxx.se.
 .SH AUTHORS / CONTRIBUTORS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl-config.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl-config.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl-config.1	2001-08-16 21:10:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl-config.1	2002-01-21 22:56:51.000000000 +0800
@@ -1,19 +1,21 @@
 .\" You can view this file with:
 .\" nroff -man curl-config.1
 .\" Written by Daniel Stenberg
 .\"
-.TH curl-config 1 "16 August 2001" "Curl 7.8.1" "curl-config manual"
+.TH curl-config 1 "21 January 2002" "Curl 7.9.3" "curl-config manual"
 .SH NAME
 curl-config \- Get information about a libcurl installation
 .SH SYNOPSIS
 .B curl-config [options]
 .SH DESCRIPTION
 .B curl-config
 displays information about a previous curl and libcurl installation.
 .SH OPTIONS
+.IP "--cc"
+Displays the compiler used to build libcurl.
 .IP "--cflags"
 Set of compiler options (CFLAGS) to use when compiling files that use
 libcurl. Currently that is only thw include path to the curl include files.
 .IP "--feature"
 Lists what particular main features the installed libcurl was built with. At
 the time of writing, this list may include SSL, KRB4 or IPv6. Do not assume
@@ -35,21 +37,26 @@
 This outputs the version number, in hexadecimal, with 8 bits for each part;
 major, minor, patch. So that libcurl 7.7.4 would appear as 070704 and libcurl
 12.13.14 would appear as 0c0d0e...
 .SH "EXAMPLES"
 What linker options do I need when I link with libcurl?
 
-  curl-config --libs
+  $ curl-config --libs
 
 What compiler options do I need when I compile using libcurl functions?
 
-  curl-config --cflags
+  $ curl-config --cflags
 
 How do I know if libcurl was built with SSL support?
 
-  curl-config --feature | grep SSL
+  $ curl-config --feature | grep SSL
 
 What's the installed libcurl version?
 
-  curl-config --version
+  $ curl-config --version
+
+How do I build a single file with a one-line command?
+
+  $ `curl-config --cc --cflags --libs` -o example example.c
+
 .SH "SEE ALSO"
 .BR curl (1)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl-config.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl-config.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl-config.html	2001-08-21 16:55:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl-config.html	2002-03-04 18:07:13.000000000 +0800
@@ -18,12 +18,14 @@
      <B>curl-config</B>  displays  information about a previous curl and
      libcurl installation.
 
 
 </PRE>
 <H2>OPTIONS</H2><PRE>
+     --cc Displays the compiler used to build libcurl.
+
      --cflags
           Set of compiler options (CFLAGS) to use when  compiling
           files  that  use  libcurl.  Currently  that is only thw
           include path to the curl include files.
 
      --feature
@@ -61,39 +63,37 @@
           0c0d0e...
 
 
 </PRE>
 <H2>EXAMPLES</H2><PRE>
      What linker options do I need when I link with libcurl?
-       curl-config --libs
+
+       $ curl-config --libs
 
      What compiler options do I need when I compile using libcurl
      functions?
 
-       curl-config --cflags
+       $ curl-config --cflags
 
      How do I know if libcurl was built with SSL support?
 
-       curl-config --feature | grep SSL
+       $ curl-config --feature | grep SSL
 
      What's the installed libcurl version?
 
-       curl-config --version
-
-
-</PRE>
-<H2>SEE ALSO</H2><PRE>
-     <B>curl(1)</B>
-
-
-
+       $ curl-config --version
 
+     How do I build a single file with a one-line command?
 
+       $ `curl-config --cc --cflags --libs` -o example example.c
 
 
 
+</PRE>
+<H2>SEE ALSO</H2><PRE>
+     <B>curl(1)</B>
 
 
 
 
 
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_cleanup.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_cleanup.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_duphandle.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_duphandle.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_getinfo.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_getinfo.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_init.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_init.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_perform.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_perform.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_setopt.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_easy_setopt.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_escape.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_escape.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_formadd.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_formadd.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_formfree.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_formfree.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_formparse.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_formparse.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_getdate.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_getdate.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_getenv.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_getenv.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_global_cleanup.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_global_cleanup.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_global_init.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_global_init.html
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl.html /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl.html
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/curl.html	2001-09-14 20:54:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/curl.html	2002-06-04 20:05:58.000000000 +0800
@@ -2,70 +2,70 @@
 <BODY>
 <PRE>
 <!-- Manpage converted by man2html 3.0.1 -->
 
 </PRE>
 <H2>NAME</H2><PRE>
-     curl - get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE,
-     HTTP or HTTPS syntax.
+     curl - transfer a URL
 
 
 </PRE>
 <H2>SYNOPSIS</H2><PRE>
      <B>curl</B> <B>[options]</B> <I>[URL...]</I>
 
 
 </PRE>
 <H2>DESCRIPTION</H2><PRE>
-     <B>curl</B> is a client to get documents/files from or  send  docu­
-     ments  to  a  server,  using  any of the supported protocols
-     (HTTP, HTTPS, FTP, GOPHER, DICT, TELNET, LDAP or FILE).  The
-     command  is designed to work without user interaction or any
+     <B>curl</B>  is  a client to get documents/files from or send docu­
+     ments to a server, using  any  of  the  supported  protocols
+     (HTTP,  HTTPS, FTP, GOPHER, DICT, TELNET, LDAP or FILE). The
+     command is designed to work without user interaction or  any
      kind of interactivity.
 
-     curl offers a busload of useful tricks like  proxy  support,
-     user  authentication,  ftp  upload,  HTTP post, SSL (https:)
+     curl  offers  a busload of useful tricks like proxy support,
+     user authentication, ftp upload,  HTTP  post,  SSL  (https:)
      connections, cookies, file transfer resume and more.
 
 
 </PRE>
 <H2>URL</H2><PRE>
      The URL syntax is protocol dependent. You'll find a detailed
      description in RFC 2396.
 
-     You  can  specify  multiple URLs or parts of URLs by writing
+     You can specify multiple URLs or parts of  URLs  by  writing
      part sets within braces as in:
 
       http://site.{one,two,three}.com
 
-     or you can get sequences of alphanumeric series by using  []
+     or  you can get sequences of alphanumeric series by using []
      as in:
 
       ftp://ftp.numericals.com/file[1-100].txt
       ftp://ftp.numericals.com/file[001-100].txt    (with leading
      zeros)
       ftp://ftp.letters.com/file[a-z].txt
 
-     It is possible to specify up to 9 sets or series for a  URL,
+     It  is possible to specify up to 9 sets or series for a URL,
      but no nesting is supported at the moment:
 
       http://www.any.org/archive[1996-1999]/vol­
      ume[1-4]part{a,b,c,index}.html
 
      You can specify any amount of URLs on the command line. They
-     will  be  fetched  in  a  sequential manner in the specified
+     will be fetched in a  sequential  manner  in  the  specified
      order.
 
-     Curl will attempt to re-use connections  for  multiple  file
-     transfers,  so  that getting many files from the same server
-     will not do multiple connects /  handshakes.  This  improves
-     speed.  Of  course this is only done on files specified on a
+     Curl  will  attempt  to re-use connections for multiple file
+     transfers, so that getting many files from the  same  server
+     will  not  do  multiple connects / handshakes. This improves
+     speed. Of course this is only done on files specified  on  a
      single command line and cannot be used between separate curl
      invokes.
 
 
+
 </PRE>
 <H2>OPTIONS</H2><PRE>
      -a/--append
           (FTP) When used in a ftp upload, this will tell curl to
           append to the target file instead of overwriting it. If
           the file doesn't exist, it will be created.
@@ -67,75 +67,74 @@
 <H2>OPTIONS</H2><PRE>
      -a/--append
           (FTP) When used in a ftp upload, this will tell curl to
           append to the target file instead of overwriting it. If
           the file doesn't exist, it will be created.
 
-          If  this option is used twice, the second one will dis­
+          If this option is used twice, the second one will  dis­
           able append mode again.
 
      -A/--user-agent &lt;agent string&gt;
-          (HTTP) Specify the User-Agent string  to  send  to  the
-          HTTP  server.  Some badly done CGIs fail if its not set
+          (HTTP)  Specify  the  User-Agent  string to send to the
+          HTTP server. Some badly done CGIs fail if its  not  set
           to "Mozilla/4.0".  To encode blanks in the string, sur­
-          round  the  string  with  single quote marks.  This can
+          round the string with single  quote  marks.   This  can
           also be set with the -H/--header flag of course.
 
           If this option is set more than once, the last one will
           be the one that's used.
 
      -b/--cookie &lt;name=data&gt;
           (HTTP) Pass the data to the HTTP server as a cookie. It
-          is supposedly the data  previously  received  from  the
-          server  in a "Set-Cookie:" line.  The data should be in
+          is  supposedly  the  data  previously received from the
+          server in a "Set-Cookie:" line.  The data should be  in
           the format "NAME1=VALUE1; NAME2=VALUE2".
 
-          If no '=' letter is used in the line, it is treated  as
-          a  filename  to  use  to  read previously stored cookie
-          lines from, which should be used  in  this  session  if
+          If  no '=' letter is used in the line, it is treated as
+          a filename to use  to  read  previously  stored  cookie
+          lines  from,  which  should  be used in this session if
           they  match.  Using  this  method  also  activates  the
-          "cookie parser" which will make  curl  record  incoming
+          "cookie  parser"  which  will make curl record incoming
           cookies too, which may be handy if you're using this in
-          combination with the  -L/--location  option.  The  file
+          combination  with  the  -L/--location  option. The file
           format of the file to read cookies from should be plain
-          HTTP headers or the Netscape/Mozilla cookie  file  for­
+          HTTP  headers  or the Netscape/Mozilla cookie file for­
           mat.
 
-          <B>NOTE</B>  that  the file specified with -b/--cookie is only
-          used as input. No cookies will be stored in  the  file.
+          <B>NOTE</B> that the file specified with -b/--cookie  is  only
+          used  as  input. No cookies will be stored in the file.
           To store cookies, save the HTTP headers to a file using
           -D/--dump-header!
 
           If this option is set more than once, the last one will
           be the one that's used.
 
      -B/--use-ascii
-          Use  ASCII  transfer  when  getting an FTP file or LDAP
-          info. For FTP, this can also be enforced  by  using  an
-          URL  that  ends with ";type=A". This option causes data
+          Use ASCII transfer when getting an  FTP  file  or  LDAP
+          info.  For  FTP,  this can also be enforced by using an
+          URL that ends with ";type=A". This option  causes  data
           sent to stdout to be in text mode for win32 systems.
 
-          If this option is used twice, the second one will  dis­
+          If  this option is used twice, the second one will dis­
           able ASCII usage.
 
      --ciphers &lt;list of ciphers&gt;
           (SSL) Specifies which ciphers to use in the connection.
-          The list of ciphers must be using valid  ciphers.  Read
-          up   on   SSL   cipher   list   details  on  this  URL:
+          The  list  of ciphers must be using valid ciphers. Read
+          up  on  SSL  cipher   list   details   on   this   URL:
           <I>http://www.openssl.org/docs/apps/ciphers.html</I>   <I>(Option</I>
           <I>added</I> <I>in</I> <I>curl</I> <I>7.9)</I>
 
-          If  this option is used severl times, the last one will
+          If this option is used severl times, the last one  will
           override the others.
 
      --connect-timeout &lt;seconds&gt;
-          Maximum time in seconds that you allow  the  connection
+          Maximum  time  in seconds that you allow the connection
           to the server to take.  This only limits the connection
-          phase, once curl has connected this  option  is  of  no
-          more  use.  This  option  didn't  work in win32 systems
-          until 7.7.2.  See also the <I>--max-time</I> option.
+          phase,  once  curl  has  connected this option is of no
+          more use. See also the <I>--max-time</I> option.
 
           If this option is used several times, the last one will
           be used.
 
      -c/--cookie-jar &lt;file name&gt;
           Specify  to which file you want curl to write all cook­
@@ -154,19 +153,28 @@
      -C/--continue-at &lt;offset&gt;
           Continue/Resume a previous file transfer at  the  given
           offset.  The  given offset is the exact number of bytes
           that will be skipped counted from the beginning of  the
           source file before it is transfered to the destination.
           If used with uploads, the ftp server command SIZE  will
-          not  be  used  by  curl. Upload resume is for FTP only.
-          HTTP resume is only possible  with  HTTP/1.1  or  later
-          servers.
+          not be used by curl.
+
+          Use  "-C  -"  to  tell  curl  to automatically find out
+          where/how to resume the  transfer.  It  then  uses  the
+          given output/input files to figure that out.
 
           If this option is used several times, the last one will
           be used.
 
+     --crlf
+          (FTP) Convert LF to CRLF  in  upload.  Useful  for  MVS
+          (OS/390).
+
+          If  this  option  is  used twice, the second will again
+          disable crlf converting.
+
      -d/--data &lt;data&gt;
           (HTTP) Sends the specified data in a  POST  request  to
           the HTTP server, in a way that can emulate as if a user
           has filled in a HTML form and pressed the  submit  but­
           ton.  Note  that  the data is sent exactly as specified
           with no extra processing (with all newlines  cut  off).
@@ -205,63 +213,95 @@
           (HTTP)  This  posts data in a similar manner as --data-
           ascii does, although when using this option the  entire
           context  of  the posted data is kept as-is. If you want
           to post a binary file without the  strip-newlines  fea­
           ture of the --data-ascii option, this is for you.
 
-          If this option is used several times, the last one will
-          be used.
-
-          If this option is used several times, the ones  follow­
+          If  this option is used several times, the ones follow­
           ing the first will append data.
 
+     --disable-epsv
+          (FTP) Tell curl to disable the use of the EPSV  command
+          when  doing  passive  FTP downloads. Curl will normally
+          always first attempt to use EPSV before PASV, but  with
+          this option, it will not try using EPSV.
+
+          If  this  option is used several times, each occurrence
+          will toggle this on/off.
+
      -D/--dump-header &lt;file&gt;
-          (HTTP/FTP)  Write  the HTTP headers to this file. Write
-          the FTP file info to this file if -I/--head is used.
+          Write the protocol headers to the specified file.
 
           This option is handy to use when you want to store  the
           cookies  that  a  HTTP  site  sends to you. The cookies
           could then be read in a second curl invoke by using the
           -b/--cookie option!
 
+          When  used  on  FTP,  the ftp server response lines are
+          considered being "headers" and thus are saved there.
+
           If this option is used several times, the last one will
           be used.
 
      -e/--referer &lt;URL&gt;
           (HTTP) Sends the "Referer Page" information to the HTTP
-          server.  This can also be set with the -H/--header flag
+          server. This can also be set with the -H/--header  flag
           of course.  When used with <I>-L/--location</I> you can append
-          ";auto"  to  the referer URL to make curl automatically
-          set the  previous  URL  when  it  follows  a  Location:
-          header.  The  ";auto" string can be used alone, even if
+          ";auto" to the referer URL to make  curl  automatically
+          set  the  previous  URL  when  it  follows  a Location:
+          header. The ";auto" string can be used alone,  even  if
           you don't set an initial referer.
 
           If this option is used several times, the last one will
           be used.
 
+     --environment
+          (RISC OS ONLY) Sets a range of  environment  variables,
+          using the names the -w option supports, to easier allow
+          extraction of useful information after having run curl.
+
+          If  this  option is used several times, each occurrence
+          will toggle this on/off.
+
      --egd-file &lt;file&gt;
-          (HTTPS)  Specify the path name to the Entropy Gathering
-          Daemon socket. The socket is used to  seed  the  random
-          engine  for SSL connections. See also the <I>--random-file</I>
+          (HTTPS) Specify the path name to the Entropy  Gathering
+          Daemon  socket.  The  socket is used to seed the random
+          engine for SSL connections. See also the  <I>--random-file</I>
           option.
 
      -E/--cert &lt;certificate[:password]&gt;
-          (HTTPS) Tells curl to  use  the  specified  certificate
-          file  when  getting  a file with HTTPS. The certificate
-          must be in PEM format.  If the optional password  isn't
+          (HTTPS)  Tells  curl  to  use the specified certificate
+          file when getting a file with  HTTPS.  The  certificate
+          must  be in PEM format.  If the optional password isn't
           specified, it will be queried for on the terminal. Note
-          that this certificate is the private key and  the  pri­
+          that  this  certificate is the private key and the pri­
           vate certificate concatenated!
 
           If this option is used several times, the last one will
           be used.
 
      --cacert &lt;CA certificate&gt;
-          (HTTPS) Tells curl to  use  the  specified  certificate
-          file to verify the peer. The certificate must be in PEM
-          format.
+          (HTTPS)  Tells  curl  to  use the specified certificate
+          file to verify the peer. The file may contain  multiple
+          CA certificates. The certificate(s) must be in PEM for­
+          mat.
+
+          If this option is used several times, the last one will
+          be used.
+
+     --capath &lt;CA certificate directory&gt;
+          (HTTPS)  Tells  curl  to  use the specified certificate
+          directory to verify the peer. The certificates must  be
+          in  PEM  format,  and the directory must have been pro­
+          cessed  using  the  c_rehash  utility   supplied   with
+          openssl.  Certificate  directories  are  not  supported
+          under Windows (because c_rehash uses symbolink links to
+          create  them).  Using  --capath  can allow curl to make
+          https connections  much  more  efficiently  than  using
+          --cacert if the --cacert file contains many CA certifi­
+          cates.
 
           If this option is used several times, the last one will
           be used.
 
      -f/--fail
           (HTTP)  Fail  silently  (no  output  at  all) on server
@@ -304,245 +344,272 @@
      -g/--globoff
           This  option  switches  off  the "URL globbing parser".
           When you set this option, you  can  specify  URLs  that
           contain  the  letters  {}[]  without  having them being
           interpreted by curl itself. Note that these letters are
           not  normal  legal  URL  contents  but  they  should be
-          encoded according to the URI standard. (Option added in
-          curl 7.6)
+          encoded according to the URI standard.
 
      -G/--get
-          When  used,  this  option  will make all data specified
-          with -d/--data or --data-binary to be used  in  a  HTTP
-          GET  request instead of the POST request that otherwise
-          would be used. The data will be  appended  to  the  URL
+          When used, this option will  make  all  data  specified
+          with  -d/--data  or  --data-binary to be used in a HTTP
+          GET request instead of the POST request that  otherwise
+          would  be  used.  The  data will be appended to the URL
           with a '?'  separator. (Option added in curl 7.9)
 
+          If used in combination with  -I,  the  POST  data  will
+          instead be appended to the URL with a HEAD request.
+
+          If used multiple times, nothing special happens.
+
      -h/--help
           Usage help.
 
      -H/--header &lt;header&gt;
           (HTTP) Extra header to use when getting a web page. You
           may specify any number of extra headers. Note  that  if
           you  should  add a custom header that has the same name
-          as one of  the  internal  ones  curl  would  use,  your
-          externally  set  header  will  be  used  instead of the
-          internal one. This allows you  to  make  even  trickier
-          stuff  than  curl  would  normally  do.  You should not
-          replace internally set  headers  without  knowing  per­
-          fectly  well  what  you're doing. Replacing an internal
-          header with one without content on the  right  side  of
-          the colon will prevent that header from appearing.
+          as one of the internal ones curl would use, your exter­
+          nally  set  header will be used instead of the internal
+          one. This allows you to make even trickier  stuff  than
+          curl  would  normally do. You should not replace inter­
+          nally set headers without knowing perfectly  well  what
+          you're  doing.  Replacing  an  internal header with one
+          without content on the right side  of  the  colon  will
+          prevent that header from appearing.
 
-          This option can be used multiple times.
+          This   option   can   be   used   multiple   times   to
+          add/replace/remove multiple headers.
 
      -i/--include
           (HTTP) Include the HTTP-header in the output. The HTTP-
-          header includes things like server-name,  date  of  the
+          header  includes  things  like server-name, date of the
           document, HTTP-version and more...
 
-          If  this  option  is  used twice, the second will again
+          If this option is used twice,  the  second  will  again
           disable header include.
 
      --interface &lt;name&gt;
-          Perform an operation using a specified  interface.  You
-          can  enter  interface name, IP address or host name. An
+          Perform  an  operation using a specified interface. You
+          can enter interface name, IP address or host  name.  An
           example could look like:
 
           <B>curl</B> <B>--interface</B> <B>eth0:1</B> <B>http://www.netscape.com/</B>
 
           If this option is used several times, the last one will
           be used.
 
      -I/--head
-          (HTTP/FTP)  Fetch  the  HTTP-header  only! HTTP-servers
+          (HTTP/FTP) Fetch  the  HTTP-header  only!  HTTP-servers
           feature the command HEAD which this uses to get nothing
-          but  the header of a document. When used on a FTP file,
+          but the header of a document. When used on a FTP  file,
           curl displays the file size only.
 
-          If this option is used twice,  the  second  will  again
+          If  this  option  is  used twice, the second will again
           disable header only.
 
+     -j/--junk-session-cookies
+          (HTTP) When curl is told to read cookies from  a  given
+          file,  this  option  will  make it discard all "session
+          cookies". This will basicly have the same effect as  if
+          a  new session is started. Typical browsers always dis­
+          card session cookies when they're closed  down.  (Added
+          in 7.9.7)
+
+          If  this  option is used several times, each occurrence
+          will toggle this on/off.
+
      --krb4 &lt;level&gt;
-          (FTP)  Enable  kerberos4  authentication  and  use. The
-          level must be entered and should  be  one  of  'clear',
-          'safe',  'confidential'  or 'private'. Should you use a
-          level that is not one of these, 'private' will  instead
+          (FTP) Enable  kerberos4  authentication  and  use.  The
+          level  must  be  entered  and should be one of 'clear',
+          'safe', 'confidential' or 'private'. Should you  use  a
+          level  that is not one of these, 'private' will instead
           be used.
 
           If this option is used several times, the last one will
           be used.
 
      -K/--config &lt;config file&gt;
-          Specify which config file to read curl arguments  from.
-          The  config  file  is a text file in which command line
-          arguments can be written which then will be used as  if
-          they  were  written on the actual command line. Options
+          Specify  which config file to read curl arguments from.
+          The config file is a text file in  which  command  line
+          arguments  can be written which then will be used as if
+          they were written on the actual command  line.  Options
           and their parameters must be specified on the same con­
-          fig  file  line.  If  the parameter is to contain white
-          spaces, the parameter must be inclosed  within  quotes.
-          If  the  first column of a config line is a '#' charac­
+          fig file line. If the parameter  is  to  contain  white
+          spaces,  the  parameter must be inclosed within quotes.
+          If the first column of a config line is a  '#'  charac­
           ter, the rest of the line will be treated as a comment.
 
-          Specify  the filename as '-' to make curl read the file
+          Specify the filename as '-' to make curl read the  file
           from stdin.
 
+          Note  that  to  be  able to specify a URL in the config
+          file, you need to specify it using  the  --url  option,
+          and  not by simply writing the URL on its own line. So,
+          it could look similar to this:
+
+          url = "http://curl.haxx.se/docs/"
+
           This option can be used multiple times.
 
      -l/--list-only
           (FTP) When listing an FTP directory, this switch forces
           a  name-only  view.   Especially  useful if you want to
           machine-parse the contents of an  FTP  directory  since
           the  normal  directory view doesn't use a standard look
           or format.
 
-          If this option is used twice,  the  second  will  again
+          This option causes an FTP  NLST  command  to  be  sent.
+          Some  FTP  servers list only files in their response to
+          NLST; they do not include subdirectories  and  symbolic
+          links.
+
+          If  this  option  is  used twice, the second will again
           disable list only.
 
      -L/--location
-          (HTTP/HTTPS)  If  the server reports that the requested
-          page has  a  different  location  (indicated  with  the
-          header  line Location:) this flag will let curl attempt
+          (HTTP/HTTPS) If the server reports that  the  requested
+          page  has  a  different  location  (indicated  with the
+          header line Location:) this flag will let curl  attempt
           to reattempt the get on the new place. If used together
           with -i or -I, headers from all requested pages will be
-          shown. If this flag is used when making  a  HTTP  POST,
+          shown.  If  this  flag is used when making a HTTP POST,
           curl will automatically switch to GET after the initial
           POST has been done.
 
-          If this option is used twice,  the  second  will  again
+          If  this  option  is  used twice, the second will again
           disable location following.
 
      -m/--max-time &lt;seconds&gt;
-          Maximum time in seconds that you allow the whole opera­
-          tion to take.  This is useful for preventing your batch
-          jobs  from  hanging  for  hours due to slow networks or
-          links going down.  This doesn't  work  fully  in  win32
+          Maximum time  in  seconds  that  you  allow  the  whole
+          operation  to take.  This is useful for preventing your
+          batch jobs from hanging for hours due to slow  networks
+          or  links going down.  This doesn't work fully in win32
           systems.  See also the <I>--connect-timeout</I> option.
 
           If this option is used several times, the last one will
           be used.
 
      -M/--manual
           Manual. Display the huge help text.
 
      -n/--netrc
-          Makes curl scan the <I>.netrc</I>  file  in  the  user's  home
-          directory  for  login  name and password. This is typi­
-          cally used for ftp on unix. If  used  with  http,  curl
+          Makes  curl  scan  the  <I>.netrc</I>  file in the user's home
+          directory for login name and password.  This  is  typi­
+          cally  used  for  ftp  on unix. If used with http, curl
           will enable user authentication. See <B>netrc(4)</B> or <B>ftp(1)</B>
-          for details on the file format. Curl will not  complain
-          if  that  file  hasn't the right permissions (it should
+          for  details on the file format. Curl will not complain
+          if that file hasn't the right  permissions  (it  should
           not be world nor group readable). The environment vari­
           able "HOME" is used to find the home directory.
 
-          A  quick  and  very  simple  example  of how to setup a
-          <I>.netrc</I>  to  allow  curl   to   ftp   to   the   machine
-          host.domain.com  with  user  name 'myself' and password
+          A quick and very simple  example  of  how  to  setup  a
+          <I>.netrc</I>   to   allow   curl   to   ftp  to  the  machine
+          host.domain.com with user name  'myself'  and  password
           'secret' should look similar to:
 
           <B>machine</B> <B>host.domain.com</B> <B>login</B> <B>myself</B> <B>password</B> <B>secret</B>
 
-          If this option is used twice,  the  second  will  again
+          If  this  option  is  used twice, the second will again
           disable netrc usage.
 
      -N/--no-buffer
-          Disables  the buffering of the output stream. In normal
+          Disables the buffering of the output stream. In  normal
           work situations, curl will use a standard buffered out­
-          put  stream that will have the effect that it will out­
-          put the data in chunks, not  necessarily  exactly  when
-          the  data arrives.  Using this option will disable that
+          put stream that will have the effect that it will  out­
+          put  the  data  in chunks, not necessarily exactly when
+          the data arrives.  Using this option will disable  that
           buffering.
 
-          If this option is used twice,  the  second  will  again
+          If  this  option  is  used twice, the second will again
           switch on buffering.
 
      -o/--output &lt;file&gt;
-          Write  output  to  &lt;file&gt; instead of stdout. If you are
+          Write output to &lt;file&gt; instead of stdout.  If  you  are
           using {} or [] to fetch multiple documents, you can use
-          '#'  followed by a number in the &lt;file&gt; specifier. That
-          variable will be replaced with the current  string  for
+          '#' followed by a number in the &lt;file&gt; specifier.  That
+          variable  will  be replaced with the current string for
           the URL being fetched. Like in:
 
             curl http://{one,two}.site.com -o "file_#1.txt"
 
           or use several variables like:
-
             curl http://{site,host}.host[1-5].com -o "#1_#2"
 
-          You  may use this option as many times as you have num­
+          You may use this option as many times as you have  num­
           ber of URLs.
 
      -O/--remote-name
           Write output to a local file named like the remote file
           we get. (Only the file part of the remote file is used,
           the path is cut off.)
 
-          You may use this option as many times as you have  num­
+          You  may use this option as many times as you have num­
           ber of URLs.
 
      -p/--proxytunnel
           When an HTTP proxy is used, this option will cause non-
-          HTTP protocols to attempt to tunnel through  the  proxy
-          instead  of merely using it to do HTTP-like operations.
+          HTTP  protocols  to attempt to tunnel through the proxy
+          instead of merely using it to do HTTP-like  operations.
           The tunnel approach is made with the HTTP proxy CONNECT
-          request  and requires that the proxy allows direct con­
-          nect to the remote port number  curl  wants  to  tunnel
+          request and requires that the proxy allows direct  con­
+          nect  to  the  remote  port number curl wants to tunnel
           through to.
 
-          If  this  option  is  used twice, the second will again
+          If this option is used twice,  the  second  will  again
           disable proxy tunnel.
 
      -P/--ftpport &lt;address&gt;
-          (FTP) Reverses the initiator/listener roles  when  con­
-          necting  with  ftp. This switch makes Curl use the PORT
-          command instead of PASV. In practice,  PORT  tells  the
+          (FTP)  Reverses  the initiator/listener roles when con­
+          necting with ftp. This switch makes Curl use  the  PORT
+          command  instead  of  PASV. In practice, PORT tells the
           server to connect to the client's specified address and
-          port, while PASV asks the server for an ip address  and
+          port,  while PASV asks the server for an ip address and
           port to connect to. &lt;address&gt; should be one of:
 
-          <B>interface</B>   i.e  "eth0" to specify which interface's IP
+          <B>interface</B>   i.e "eth0" to specify which interface's  IP
                       address you want to use  (Unix only)
 
           <B>IP</B> <B>address</B>  i.e "192.168.10.1" to specify exact IP num­
                       ber
 
           <B>host</B> <B>name</B>   i.e "my.host.domain" to specify machine
 
-          <B>-</B>           (any  single-letter string) to make it pick
+          <B>-</B>           (any single-letter string) to make it  pick
                       the machine's default
 
-     If this option is used several times, the last one  will  be
+     If  this  option is used several times, the last one will be
      used.
 
      -q   If used as the first parameter on the command line, the
-          <I>$HOME/.curlrc</I> file will not be read and used as a  con­
+          <I>$HOME/.curlrc</I>  file will not be read and used as a con­
           fig file.
 
      -Q/--quote &lt;comand&gt;
-          (FTP)  Send  an  arbitrary  command  to  the remote FTP
-          server, by using the QUOTE command of the  server.  Not
-          all  servers support this command, and the set of QUOTE
-          commands are server specific! Quote commands  are  sent
-          BEFORE  the  transfer is taking place. To make commands
-          take place after a  successful  transfer,  prefix  them
+          (FTP) Send an  arbitrary  command  to  the  remote  FTP
+          server,  by  using the QUOTE command of the server. Not
+          all servers support this command, and the set of  QUOTE
+          commands  are  server specific! Quote commands are sent
+          BEFORE the transfer is taking place. To  make  commands
+          take  place  after  a  successful transfer, prefix them
           with a dash '-'. You may specify any amount of commands
-          to be run before and after the transfer. If the  server
-          returns  failure  for  one  of the commands, the entire
+          to  be run before and after the transfer. If the server
+          returns failure for one of  the  commands,  the  entire
           operation will be aborted.
 
           This option can be used multiple times.
 
      --random-file &lt;file&gt;
-          (HTTPS) Specify the path name to file  containing  what
-          will  be considered as random data. The data is used to
-          seed the random engine for SSL connections.   See  also
+          (HTTPS)  Specify  the path name to file containing what
+          will be considered as random data. The data is used  to
+          seed  the  random engine for SSL connections.  See also
           the <I>--edg-file</I> option.
 
      -r/--range &lt;range&gt;
-          (HTTP/FTP)  Retrieve  a byte range (i.e a partial docu­
-          ment) from a HTTP/1.1 or  FTP  server.  Ranges  can  be
+          (HTTP/FTP) Retrieve a byte range (i.e a  partial  docu­
+          ment)  from  a  HTTP/1.1  or  FTP server. Ranges can be
           specified in a number of ways.
 
           <B>0-499</B>     specifies the first 500 bytes
 
           <B>500-999</B>   specifies the second 500 bytes
 
@@ -556,125 +623,159 @@
           <B>500-700,600-799</B>
                     specifies 300 bytes from offset 500(H)
 
           <B>100-199,500-599</B>
                     specifies two separate 100 bytes ranges(*)(H)
 
-     (*)  =  NOTE that this will cause the server to reply with a
+     (*) = NOTE that this will cause the server to reply  with  a
      multipart response!
 
-     You should also be aware that many HTTP/1.1 servers  do  not
+     You  should  also be aware that many HTTP/1.1 servers do not
      have this feature enabled, so that when you attempt to get a
      range, you'll instead get the whole document.
 
-     FTP range downloads only support the simple  syntax  'start-
-     stop'  (optionally  with  one  of  the  numbers omitted). It
+     FTP  range  downloads only support the simple syntax 'start-
+     stop' (optionally with  one  of  the  numbers  omitted).  It
      depends on the non-RFC command SIZE.
 
-     If this option is used several times, the last one  will  be
+     If  this  option is used several times, the last one will be
      used.
 
      -R/--remote-time
           When used, this will make libcurl attempt to figure out
           the timestamp of the remote file, and if that is avail­
           able make the local file get that same timestamp.
 
-          If  this option is used twice, the second time disables
+          If this option is used twice, the second time  disables
           this again.
 
      -s/--silent
-          Silent mode. Don't show progress meter  or  error  mes­
+          Silent  mode.  Don't  show progress meter or error mes­
           sages.  Makes Curl mute.
 
-          If  this  option  is  used twice, the second will again
+          If this option is used twice,  the  second  will  again
           disable mute.
 
      -S/--show-error
-          When used with -s it makes curl show error  message  if
+          When  used  with -s it makes curl show error message if
           it fails.
 
-          If  this  option  is  used twice, the second will again
+          If this option is used twice,  the  second  will  again
           disable show error.
 
+     --stderr &lt;file&gt;
+          Redirect  all  writes  to  stderr to the specified file
+          instead. If the file name is a plain '-', it is instead
+          written to stdout. This option has no point when you're
+          using a shell with decent redirecting capabilities.
+
+          If this option is used several times, the last one will
+          be used.
+
      -t/--telnet-option &lt;OPT=val&gt;
-          Pass options to the telnet protocol. Supported  options
+          Pass  options to the telnet protocol. Supported options
           are:
 
           TTYPE=&lt;term&gt; Sets the terminal type.
 
           XDISPLOC=&lt;X display&gt; Sets the X display location.
 
           NEW_ENV=&lt;var,val&gt; Sets an environment variable.
 
      -T/--upload-file &lt;file&gt;
-          Like  -t,  but this transfers the specified local file.
-          If there is no file part in  the  specified  URL,  Curl
-          will append the local file name. NOTE that you must use
-          a trailing / on the last directory to really  prove  to
-          Curl that there is no file name or curl will think that
-          your last directory name is the  remote  file  name  to
-          use.  That  will most likely cause the upload operation
-          to fail. If this is used on a http(s) server,  the  PUT
-          command will be used.
+          This transfers the specified local file to  the  remote
+          URL.  If  there  is  no file part in the specified URL,
+          Curl will append the local file  name.  NOTE  that  you
+          must  use  a trailing / on the last directory to really
+          prove to Curl that there is no file name or  curl  will
+          think  that your last directory name is the remote file
+          name to use. That will most  likely  cause  the  upload
+          operation to fail. If this is used on a http(s) server,
+          the PUT command will be used.
+
+          Use the file name "-" (a  single  dash)  to  use  stdin
+          instead of a given file.
 
           If this option is used several times, the last one will
           be used.
 
+     --trace &lt;file&gt;
+          Enables a full trace dump of all incoming and  outgoing
+          data,  including  descriptive information, to the given
+          output file. Use "-" as filename  to  have  the  output
+          sent to stdout.
+
+          If this option is used several times, the last one will
+          be used. (Added in curl 7.9.7)
+
+     --trace-ascii &lt;file&gt;
+          Enables a full trace dump of all incoming and  outgoing
+          data,  including  descriptive information, to the given
+          output file. Use "-" as filename  to  have  the  output
+          sent to stdout.
+
+          This is very similar to --trace, but leaves out the hex
+          part and only shows the ASCII  part  of  the  dump.  It
+          makes  smaller  output that might be easier to read for
+          untrained humans.
+
+          If this option is used several times, the last one will
+          be used. (Added in curl 7.9.7)
+
      -u/--user &lt;user:password&gt;
-          Specify user and password to  use  when  fetching.  See
-          README.curl  for  detailed examples of how to use this.
-          If no password is  specified,  curl  will  ask  for  it
+          Specify  user  and  password  to use when fetching. See
+          README.curl for detailed examples of how to  use  this.
+          If  no  password  is  specified,  curl  will ask for it
           interactively.
 
           If this option is used several times, the last one will
           be used.
 
      -U/--proxy-user &lt;user:password&gt;
-          Specify user and password to use for Proxy  authentica­
+          Specify  user and password to use for Proxy authentica­
           tion. If no password is specified, curl will ask for it
           interactively.
 
           If this option is used several times, the last one will
           be used.
 
      --url &lt;URL&gt;
-          Specify  a  URL  to  fetch. This option is mostly handy
-          when you wanna specify URL(s) in a config file.
-
+          Specify a URL to fetch. This  option  is  mostly  handy
+          when you want to specify URL(s) in a config file.
           This option may be used any number of times. To control
-          where  this  URL  is  written,  use  the  <I>-o</I>  or the <I>-O</I>
+          where this URL  is  written,  use  the  <I>-o</I>  or  the  <I>-O</I>
           options.
 
      -v/--verbose
-          Makes  the  fetching  more  verbose/talkative.   Mostly
-          usable  for  debugging.  Lines  starting with '&gt;' means
+          Makes   the  fetching  more  verbose/talkative.  Mostly
+          usable for debugging. Lines  starting  with  '&gt;'  means
           data sent by curl, '&lt;' means data received by curl that
-          is  hidden  in normal cases and lines starting with '*'
+          is hidden in normal cases and lines starting  with  '*'
           means additional info provided by curl.
 
-          If this option is used twice,  the  second  will  again
+          If  this  option  is  used twice, the second will again
           disable verbose.
 
      -V/--version
-          Displays  the  full  version of curl, libcurl and other
+          Displays the full version of curl,  libcurl  and  other
           3rd party libraries linked with the executable.
 
      -w/--write-out &lt;format&gt;
-          Defines what to display after a completed and  success­
-          ful  operation. The format is a string that may contain
-          plain text mixed with  any  number  of  variables.  The
+          Defines  what to display after a completed and success­
+          ful operation. The format is a string that may  contain
+          plain  text  mixed  with  any  number of variables. The
           string can be specified as "string", to get read from a
-          particular file you specify it "@filename" and to  tell
+          particular  file you specify it "@filename" and to tell
           curl to read the format from stdin you write "@-".
 
           The variables present in the output format will be sub­
-          stituted by the value or text that curl thinks fit,  as
+          stituted  by the value or text that curl thinks fit, as
           described  below.  All  variables  are  specified  like
-          %{variable_name} and to output  a  normal  %  you  just
-          write  them  like %%. You can output a newline by using
-          \n, a carrige return with \r and a tab space with \t.
+          %{variable_name}  and  to  output  a  normal % you just
+          write them like %%. You can output a newline  by  using
+          \n,  a carriage return with \r and a tab space with \t.
 
           <B>NOTE:</B>  The  %-letter  is  a  special  letter   in   the
           win32-environment,  where  all occurrences of % must be
           doubled when using this option.
 
           Available variables are at this point:
@@ -704,12 +805,19 @@
                          start until the file  transfer  is  just
                          about  to  begin. This includes all pre-
                          transfer commands and negotiations  that
                          are  specific  to  the particular proto­
                          col(s) involved.
 
+          <B>time_starttransfer</B>
+                         The time, in seconds, it took  from  the
+                         start until the first byte is just about
+                         to   be   transfered.   This    includes
+                         time_pretransfer  and  also the time the
+                         server needs to calculate the result.
+
           <B>size_download</B>  The total  amount  of  bytes  that  were
                          downloaded.
 
           <B>size_upload</B>    The  total  amount  of  bytes  that were
                          uploaded.
 
@@ -722,110 +830,116 @@
           <B>speed_download</B> The average  download  speed  that  curl
                          measured for the complete download.
 
           <B>speed_upload</B>   The  average upload speed that curl mea­
                          sured for the complete upload.
 
+          <B>content_type</B>   The Content-Type of the requested  docu­
+                         ment, if there was any. (Added in 7.9.5)
+
      If this option is used several times, the last one  will  be
      used.
 
      -x/--proxy &lt;proxyhost[:port]&gt;
-          Use  specified  proxy. If the port number is not speci­
-          fied, it is assumed at port 1080.
+          Use  specified  HTTP  proxy.  If the port number is not
+          specified, it is assumed at port 1080.
+
+          <B>Note</B> that all operations that are performed over a HTTP
+          proxy will transparantly be converted to HTTP. It means
+          that certain protocol specific operations might not  be
+          available.  This  is  not  the  case  if you can tunnel
+          through the proxy, as done  with  the  <I>-p/--proxytunnel</I>
+          option.
 
           If this option is used several times, the last one will
           be used.
 
      -X/--request &lt;command&gt;
-          (HTTP)  Specifies a custom request to use when communi­
-          cating with the HTTP  server.   The  specified  request
+          (HTTP) Specifies a custom request to use when  communi­
+          cating  with  the  HTTP  server.  The specified request
           will be used instead of the standard GET. Read the HTTP
           1.1 specification for details and explanations.
 
-          (FTP) Specifies a custom FTP command to use instead  of
+          (FTP)  Specifies a custom FTP command to use instead of
           LIST when doing file lists with ftp.
 
           If this option is used several times, the last one will
           be used.
 
      -y/--speed-time &lt;time&gt;
           If a download is slower than speed-limit bytes per sec­
-          ond  during  a  speed-time  period,  the  download gets
+          ond during  a  speed-time  period,  the  download  gets
           aborted. If speed-time is used, the default speed-limit
           will be 1 unless set with -y.
 
           If this option is used several times, the last one will
           be used.
 
      -Y/--speed-limit &lt;speed&gt;
           If a download is slower than this given speed, in bytes
-          per  second,  for  speed-time  seconds it gets aborted.
+          per second, for speed-time  seconds  it  gets  aborted.
           speed-time is set with -Y and is 30 if not set.
 
           If this option is used several times, the last one will
           be used.
 
      -z/--time-cond &lt;date expression&gt;
-          (HTTP)  Request  to  get  a file that has been modified
-          later than the given time and date,  or  one  that  has
+          (HTTP) Request to get a file  that  has  been  modified
+          later  than  the  given  time and date, or one that has
           been modified before that time. The date expression can
           be all sorts of date strings or if it doesn't match any
-          internal  ones,  it  tries to get the time from a given
-          file name instead! See the  <B>GNU</B>  <B>date(1)</B>  or  <B>curl_get­</B>
+          internal ones, it tries to get the time  from  a  given
+          file  name  instead!  See  the <B>GNU</B> <B>date(1)</B> or <B>curl_get­</B>
           <B>date(3)</B> man pages for date expression details.
 
-          Start  the  date  expression with a dash (-) to make it
-          request for a document that is  older  than  the  given
+          Start the date expression with a dash (-)  to  make  it
+          request  for  a  document  that is older than the given
           date/time, default is a document that is newer than the
           specified date/time.
 
           If this option is used several times, the last one will
           be used.
 
+     -Z/--max-redirs &lt;num&gt;
+          Set maximum number of  redirection-followings  allowed.
+          If  -L/--location  is  used, this option can be used to
+          prevent curl from following redirections "in absurdum".
+
+          If this option is used several times, the last one will
+          be used.
+
      -3/--sslv3
           (HTTPS) Forces curl to use SSL version 3 when negotiat­
           ing with a remote SSL server.
 
      -2/--sslv2
           (HTTPS) Forces curl to use SSL version 2 when negotiat­
           ing with a remote SSL server.
 
+     -0/--http1.0
+          (HTTP) Forces curl to issue its requests using HTTP 1.0
+          instead of using its internally preferred: HTTP 1.1.
+
      -#/--progress-bar
           Make  curl  display  progress information as a progress
           bar instead of the default statistics.
 
           If this option is used twice,  the  second  will  again
           disable the progress bar.
 
-     --crlf
-          (FTP)  Convert  LF  to  CRLF  in upload. Useful for MVS
-          (OS/390).
-
-          If this option is used twice,  the  second  will  again
-          disable crlf converting.
-
-     --stderr &lt;file&gt;
-          Redirect  all  writes  to  stderr to the specified file
-          instead. If the file name is a plain '-', it is instead
-          written to stdout. This option has no point when you're
-          using a shell with decent redirecting capabilities.
-
-          If this option is used several times, the last one will
-          be used.
-
 
 </PRE>
 <H2>FILES</H2><PRE>
      <I>~/.curlrc</I>
           Default config file.
 
 
 
 </PRE>
 <H2>ENVIRONMENT</H2><PRE>
-     HTTP_PROXY [protocol://]&lt;host&gt;[:port]
+     http_proxy [protocol://]&lt;host&gt;[:port]
           Sets proxy server to use for HTTP.
 
      HTTPS_PROXY [protocol://]&lt;host&gt;[:port]
           Sets proxy server to use for HTTPS.
 
      FTP_PROXY [protocol://]&lt;host&gt;[:port]
@@ -837,24 +951,21 @@
      ALL_PROXY [protocol://]&lt;host&gt;[:port]
           Sets  proxy server to use if no protocol-specific proxy
           is set.
 
      NO_PROXY &lt;comma-separated list of hosts&gt;
           list of host names that shouldn't go through any proxy.
-          If set to a asterisk '*' only, it matches all hosts.
-
-     COLUMNS &lt;integer&gt;
-          The  width of the terminal.  This variable only affects
-          curl when the --progress-bar option is used.
+          If set to a asterisk
 
 
 </PRE>
 <H2>EXIT CODES</H2><PRE>
      There exists a bunch of different error codes and their cor­
-     responding  error messages that may appear during bad condi­
+     responding error messages that may appear during bad  condi­
      tions. At the time of this writing, the exit codes are:
+
      1    Unsupported protocol. This build of curl has no support
           for this protocol.
 
      2    Failed to initialize.
 
      3    URL malformat. The syntax was not correct.
@@ -856,133 +967,139 @@
           for this protocol.
 
      2    Failed to initialize.
 
      3    URL malformat. The syntax was not correct.
 
-     4    URL  user malformatted. The user-part of the URL syntax
+     4    URL user malformatted. The user-part of the URL  syntax
           was not correct.
 
-     5    Couldn't resolve proxy. The given proxy host could  not
+     5    Couldn't  resolve proxy. The given proxy host could not
           be resolved.
 
-     6    Couldn't  resolve  host.  The given remote host was not
+     6    Couldn't resolve host. The given remote  host  was  not
           resolved.
 
      7    Failed to connect to host.
 
-     8    FTP weird server  reply.  The  server  sent  data  curl
+     8    FTP  weird  server  reply.  The  server  sent data curl
           couldn't parse.
 
      9    FTP access denied. The server denied login.
 
-     10   FTP  user/password  incorrect.  Either one or both were
+     10   FTP user/password incorrect. Either one  or  both  were
           not accepted by the server.
 
-     11   FTP weird PASS reply. Curl  couldn't  parse  the  reply
+     11   FTP  weird  PASS  reply.  Curl couldn't parse the reply
           sent to the PASS request.
 
-     12   FTP  weird  USER  reply.  Curl couldn't parse the reply
+     12   FTP weird USER reply. Curl  couldn't  parse  the  reply
           sent to the USER request.
 
-     13   FTP weird PASV reply, Curl  couldn't  parse  the  reply
+     13   FTP  weird  PASV  reply,  Curl couldn't parse the reply
           sent to the PASV request.
 
-     14   FTP  weird 227 format. Curl couldn't parse the 227-line
+     14   FTP weird 227 format. Curl couldn't parse the  227-line
           the server sent.
 
      15   FTP can't get host. Couldn't resolve the host IP we got
           in the 227-line.
 
-     16   FTP  can't  reconnect.  Couldn't connect to the host we
+     16   FTP can't reconnect. Couldn't connect to  the  host  we
           got in the 227-line.
 
      17   FTP  couldn't  set  binary.  Couldn't  change  transfer
           method to binary.
 
      18   Partial file. Only a part of the file was transfered.
 
      19   FTP couldn't RETR file. The RETR command failed.
 
-     20   FTP  write  error. The transfer was reported bad by the
+     20   FTP write error. The transfer was reported bad  by  the
           server.
 
-     21   FTP quote error. A quote command  returned  error  from
+     21   FTP  quote  error.  A quote command returned error from
           the server.
 
-     22   HTTP  not found. The requested page was not found. This
+     22   HTTP not found. The requested page was not found.  This
           return code only appears if --fail is used.
 
-     23   Write error.  Curl  couldn't  write  data  to  a  local
+     23   Write  error.  Curl  couldn't  write  data  to  a local
           filesystem or similar.
 
      24   Malformat user. User name badly specified.
 
-     25   FTP  couldn't  STOR  file.  The  server denied the STOR
+     25   FTP couldn't STOR file.  The  server  denied  the  STOR
           operation.
 
      26   Read error. Various reading problems.
 
      27   Out of memory. A memory allocation request failed.
 
-     28   Operation timeout. The specified  time-out  period  was
+     28   Operation  timeout.  The  specified time-out period was
           reached according to the conditions.
 
-     29   FTP  couldn't set ASCII. The server returned an unknown
+     29   FTP couldn't set ASCII. The server returned an  unknown
           reply.
 
      30   FTP PORT failed. The PORT command failed.
 
      31   FTP couldn't use REST. The REST command failed.
 
-     32   FTP couldn't use SIZE. The  SIZE  command  failed.  The
-          command  is  an  extension to the original FTP spec RFC
+     32   FTP  couldn't  use  SIZE.  The SIZE command failed. The
+          command is an extension to the original  FTP  spec  RFC
           959.
 
      33   HTTP range error. The range "command" didn't work.
 
-     34   HTTP  post  error.  Internal  post-request   generation
+     34   HTTP   post  error.  Internal  post-request  generation
           error.
 
      35   SSL connect error. The SSL handshaking failed.
 
-     36   FTP  bad  download resume. Couldn't continue an earlier
+     36   FTP bad download resume. Couldn't continue  an  earlier
           aborted download.
 
-     37   FILE couldn't read file. Failed to open the file.  Per­
+     37   FILE  couldn't read file. Failed to open the file. Per­
           missions?
 
      38   LDAP cannot bind. LDAP bind operation failed.
 
      39   LDAP search failed.
 
      40   Library not found. The LDAP library was not found.
-     41   Function  not  found.  A required LDAP function was not
+
+     41   Function not found. A required LDAP  function  was  not
           found.
 
-     42   Aborted by callback. An application told curl to  abort
+     42   Aborted  by callback. An application told curl to abort
           the operation.
 
      43   Internal error. A function was called with a bad param­
           eter.
 
      44   Internal error. A function was called in a bad order.
 
-     45   Interface error. A specified outgoing  interface  could
+     45   Interface  error.  A specified outgoing interface could
           not be used.
 
-     46   Bad  password  entered. An error was signalled when the
+     46   Bad password entered. An error was  signaled  when  the
           password was entered.
 
-     47   Too many redirects. When following redirects, curl  hit
+     47   Too  many redirects. When following redirects, curl hit
           the maximum amount.
 
      48   Unknown TELNET option specified.
 
      49   Malformed telnet option.
 
+     51   The remote peer's SSL certificate wasn't ok
+
+     52   The server didn't reply anything, which here is consid­
+          ered an error.
+
      XX   There  will  appear  more  error  codes  here in future
           releases. The existing ones are meant to never  change.
 
 
 </PRE>
 <H2>BUGS</H2><PRE>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_mprintf.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_mprintf.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_slist_append.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_slist_append.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_slist_free_all.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_slist_free_all.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_strequal.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_strequal.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_strnequal.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_strnequal.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_unescape.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_unescape.html
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_version.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: curl_version.html
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/curlgtk.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/curlgtk.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/curlgtk.c	2001-02-20 21:56:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/curlgtk.c	2002-03-11 23:00:57.000000000 +0800
@@ -2,13 +2,13 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: curlgtk.c,v 1.2 2001/02/20 13:56:39 bagder Exp $
+ * $Id: curlgtk.c,v 1.3 2002/03/11 15:00:57 bagder Exp $
  */
 /* Copyright (c) 2000 David Odin (aka DindinX) for MandrakeSoft */
 /* an attempt to use the curl library in concert with a gtk-threaded application */
 
 #include <stdio.h>
 #include <gtk/gtk.h>
@@ -23,13 +23,17 @@
 
 size_t my_read_func(void *ptr, size_t size, size_t nmemb, FILE *stream)
 {
   return fread(ptr, size, nmemb, stream);
 }
 
-int my_progress_func(GtkWidget *Bar, int t, int d)
+int my_progress_func(GtkWidget *Bar,
+                     double t, /* dltotal */
+                     double d, /* dlnow */
+                     double ultotal,
+                     double ulnow)
 {
 /*  printf("%d / %d (%g %%)\n", d, t, d*100.0/t);*/
   gdk_threads_enter();
   gtk_progress_set_value(GTK_PROGRESS(Bar), d*100.0/t);
   gdk_threads_leave();
   return 0;
@@ -47,12 +51,13 @@
   {
     outfile = fopen("/tmp/test.curl", "w");
 
     curl_easy_setopt(curl, CURLOPT_URL, url);
     curl_easy_setopt(curl, CURLOPT_FILE, outfile);
     curl_easy_setopt(curl, CURLOPT_READFUNCTION, my_read_func);
+    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, FALSE);
     curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, my_progress_func);
     curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, Bar);
     
     res = curl_easy_perform(curl);
 
     fclose(outfile);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: fopen.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/ftpget.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/ftpget.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/ftpget.c	2001-03-27 17:00:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/ftpget.c	2002-01-08 21:05:44.000000000 +0800
@@ -2,43 +2,82 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: ftpget.c,v 1.1 2001/03/27 09:00:18 bagder Exp $
+ * $Id: ftpget.c,v 1.2 2002/01/08 13:05:44 bagder Exp $
  */
 
 #include <stdio.h>
 
 #include <curl/curl.h>
 #include <curl/types.h>
 #include <curl/easy.h>
 
-/* to make this work under windows, use the win32-functions from the
-   win32socket.c file as well */
+/*
+ * This is an example showing how to get a single file from an FTP server.
+ * It delays the actual destination file creation until the first write
+ * callback so that it won't create an empty file in case the remote file
+ * doesn't exist or something else fails.
+ */
+
+struct FtpFile {
+  char *filename;
+  FILE *stream;
+};
+
+int my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)
+{
+  struct FtpFile *out=(struct FtpFile *)stream;
+  if(out && !out->stream) {
+    /* open file for writing */
+    out->stream=fopen(out->filename, "wb");
+    if(!out->stream)
+      return -1; /* failure, can't open file to write */
+  }
+  return fwrite(buffer, size, nmemb, out->stream);
+}
+
 
-int main(int argc, char **argv)
+int main(void)
 {
   CURL *curl;
   CURLcode res;
-  FILE *ftpfile;
-  
-  /* local file name to store the file as */
-  ftpfile = fopen("curl.tar.gz", "wb"); /* b is binary for win */
+  struct FtpFile ftpfile={
+    "curl.tar.gz", /* name to store the file as if succesful */
+    NULL
+  };
 
+  curl_global_init(CURL_GLOBAL_DEFAULT);
+  
   curl = curl_easy_init();
   if(curl) {
-    /* Get curl 7.7 from sunet.se's FTP site: */
+    /* Get curl 7.9.2 from sunet.se's FTP site: */
     curl_easy_setopt(curl, CURLOPT_URL,
-                     "ftp://ftp.sunet.se/pub/www/utilities/curl/curl-7.7.tar.gz");
-    curl_easy_setopt(curl, CURLOPT_FILE, ftpfile);
+                     "ftp://ftp.sunet.se/pub/www/utilities/curl/curl-7.9.2.tar.gz");
+    /* Define our callback to get called when there's data to be written */
+    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
+    /* Set a pointer to our struct to pass to the callback */
+    curl_easy_setopt(curl, CURLOPT_FILE, &ftpfile);
+
+    /* Switch on full protocol/debug output */
+    curl_easy_setopt(curl, CURLOPT_VERBOSE, TRUE);
+
     res = curl_easy_perform(curl);
 
     /* always cleanup */
     curl_easy_cleanup(curl);
+
+    if(CURLE_OK != res) {
+      /* we failed */
+      fprintf(stderr, "curl told us %d\n", res);
+    }
   }
 
-  fclose(ftpfile); /* close the local file */
+  if(ftpfile.stream)
+    fclose(ftpfile.stream); /* close the local file */
+
+  curl_global_cleanup();
 
   return 0;
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: ftpgetresp.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: http-post.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/Makefile.am	2001-09-25 13:55:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/Makefile.am	2002-05-13 15:29:22.000000000 +0800
@@ -1,12 +1,15 @@
 #
-# $Id: Makefile.am,v 1.13 2001/09/25 05:55:56 bagder Exp $
+# $Id: Makefile.am,v 1.22 2002/05/13 07:29:22 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-EXTRA_DIST = README curlgtk.c sepheaders.c simple.c postit.c postit2.c \
-	     win32sockets.c persistant.c ftpget.c Makefile.example \
-	     multithread.c getinmemory.c ftpupload.c httpput.c
+EXTRA_DIST = README curlgtk.c sepheaders.c simple.c postit2.c		\
+	     persistant.c ftpget.c Makefile.example			\
+	     multithread.c getinmemory.c ftpupload.c httpput.c		\
+	     simplessl.c ftpgetresp.c http-post.c post-callback.c	\
+	     multi-app.c multi-double.c multi-single.c multi-post.c	\
+	     fopen.c
 
 all:
 	@echo "done"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/Makefile.in	2001-09-25 14:14:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/Makefile.in	2002-06-11 23:18:54.000000000 +0800
@@ -11,13 +11,13 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.13 2001/09/25 05:55:56 bagder Exp $
+# $Id: Makefile.am,v 1.22 2002/05/13 07:29:22 bagder Exp $
 #
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
@@ -62,12 +62,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -92,19 +99,24 @@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-EXTRA_DIST = README curlgtk.c sepheaders.c simple.c postit.c postit2.c \
-	     win32sockets.c persistant.c ftpget.c Makefile.example \
-	     multithread.c getinmemory.c ftpupload.c httpput.c
+EXTRA_DIST = README curlgtk.c sepheaders.c simple.c postit2.c		\
+	     persistant.c ftpget.c Makefile.example			\
+	     multithread.c getinmemory.c ftpupload.c httpput.c		\
+	     simplessl.c ftpgetresp.c http-post.c post-callback.c	\
+	     multi-app.c multi-double.c multi-single.c multi-post.c	\
+	     fopen.c
 
 subdir = docs/examples
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 depcomp =
 DIST_SOURCES =
 DIST_COMMON = README Makefile.am Makefile.in
 all: all-am
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: multi-app.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: multi-double.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: multi-post.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: multi-single.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: post-callback.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples: postit.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/README	2001-04-12 19:12:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/README	2002-01-16 22:13:25.000000000 +0800
@@ -7,12 +7,16 @@
 If you end up with other small but still useful example sources, please mail
 them for submission in future packages and on the web site.
 
 The Makefile.example is an example makefile that could be used to build these
 examples. Just edit the file according to your system and requirements first.
 
+Most examples should build fine using a command line like this:
+
+  $ gcc `curl-config --cflags` `curl-config --libs` -o example example.c
+
 Try the php/examples/ directory for PHP programming snippets!
 
   *PLEASE* do not use the curl.haxx.se site as a test target for your libcurl
   applications/experiments. Even if the examples in this directory use that
   site as an example URL at some places, it doesn't mean that the URLs work or
   that we expect you to actually torture our web site with your tests! Thanks.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/simple.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/simple.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples/simple.c	2001-02-20 21:56:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples/simple.c	2002-01-09 21:23:01.000000000 +0800
@@ -2,37 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * $Id: simple.c,v 1.2 2001/02/20 13:56:39 bagder Exp $
+ * $Id: simple.c,v 1.5 2002/01/09 13:23:01 bagder Exp $
  */
 
 #include <stdio.h>
-
 #include <curl/curl.h>
-#include <curl/types.h>
-#include <curl/easy.h>
-
-/* to make this work under windows, use the win32-functions from the
-   win32socket.c file as well */
 
-int main(int argc, char **argv)
+int main(void)
 {
   CURL *curl;
   CURLcode res;
-  FILE *headerfile;
-
-  headerfile = fopen("dumpit", "w");
 
   curl = curl_easy_init();
   if(curl) {
-    /* what call to write: */
     curl_easy_setopt(curl, CURLOPT_URL, "curl.haxx.se");
-    curl_easy_setopt(curl, CURLOPT_WRITEHEADER, headerfile);
     res = curl_easy_perform(curl);
 
     /* always cleanup */
     curl_easy_cleanup(curl);
   }
   return 0;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/examples: simplessl.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/examples: win32sockets.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/FAQ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/FAQ
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/FAQ	2001-08-23 19:11:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/FAQ	2002-05-28 22:18:54.000000000 +0800
@@ -1,7 +1,7 @@
-Updated: August 23, 2001 (http://curl.haxx.se/docs/faq.shtml)
+Updated: May 23, 2002 (http://curl.haxx.se/docs/faq.html)
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -12,12 +12,13 @@
   1.2 What is libcurl?
   1.3 What is cURL not?
   1.4 When will you make curl do XXXX ?
   1.5 Who makes cURL?
   1.6 What do you get for making cURL?
   1.7 What about CURL from curl.com?
+  1.8 I have a problem who do I mail?
 
  2. Install Related Problems
   2.1 configure doesn't find OpenSSL even when it is installed
    2.1.1. native linker doesn't find openssl
    2.1.2. only the libssl lib is missing
   2.2 Does curl work/build with other SSL libraries?
@@ -27,34 +28,39 @@
  3. Usage Problems
   3.1 curl: (1) SSL is disabled, https: not supported
   3.2 How do I tell curl to resume a transfer?
   3.3 Why doesn't my posting using -F work?
   3.4 How do I tell curl to run custom FTP commands?
   3.5 How can I disable the Pragma: nocache header?
-  3.6 Does curl support javascript, ASP, XML, XHTML or HTML version Y?
+  3.6 Does curl support ASP, XML, XHTML or HTML version Y?
   3.7 Can I use curl to delete/rename a file through FTP?
   3.8 How do I tell curl to follow HTTP redirects?
-  3.9 How do I use curl in PHP, Perl, Tcl, Ruby or Java?
+  3.9 How do I use curl in my favorite programming language?
   3.10 What about SOAP, WebDAV, XML-RPC or similar protocols over HTTP?
   3.11 How do I POST with a different Content-Type?
+  3.12 Why do FTP specific features over HTTP proxy fail?
+  3.13 Why does my single/double quotes fail?
+  3.14 Does curl support javascript or pac (automated proxy config)?
 
  4. Running Problems
   4.1 Problems connecting to SSL servers.
   4.2 Why do I get problems when I use & or % in the URL?
   4.3 How can I use {, }, [ or ] to specify multiple URLs?
   4.4 Why do I get downloaded data even though the web page doesn't exist?
   4.5 Why do I get return code XXX from a HTTP server?
    4.5.1 "400 Bad Request"
    4.5.2 "401 Unauthorized"
    4.5.3 "403 Forbidden"
    4.5.4 "404 Not Found"
    4.5.5 "405 Method Not Allowed"
+   4.5.6 "301 Moved Permanently"
   4.6 Can you tell me what error code 142 means?
   4.7 How do I keep user names and passwords secret in Curl command lines?
   4.8 I found a bug!
   4.9 Curl can't authenticate to the server that requires NTLM?
+  4.10 My HTTP request using HEAD, PUT or DELETE doesn't work!
 
  5. libcurl Issues
   5.1 Is libcurl thread-safe?
   5.2 How can I receive all data into a large memory chunk?
   5.3 How do I fetch multiple files with libcurl?
   5.4 Does libcurl do Winsock initing on win32 systems?
@@ -93,16 +99,15 @@
 
   You can use libcurl for free in your application even if it is commercial
   or closed-source.
 
   1.3 What is cURL not?
   
-  Curl is *not*, I repeat, *not* a wget clone even though that is a very
-  common misconception. Never, during curl's development, have I intended curl
-  to replace wget or compete on its market. Curl is targeted at single-shot
-  file transfers.
+  Curl is *not* a wget clone even though that is a very common misconception.
+  Never, during curl's development, have we intended curl to replace wget or
+  compete on its market. Curl is targeted at single-shot file transfers.
 
   Curl is not a web site mirroring program. If you wanna use curl to mirror
   something: fine, go ahead and write a script that wraps around curl to make
   it reality (like curlmirror.pl does).
 
   Curl is not an FTP site mirroring program. Sure, get and send FTP with curl
@@ -131,13 +136,13 @@
   * We do not add things to curl that other small and available tools already
     do very fine at the side. Curl's output is fine to pipe into another
     program or redirect to another file for the next program to interpret.
 
   * We focus on protocol related issues and improvements. If you wanna do more
     magic with the supported protocols than curl currently does, chances are
-    big I will agree. If you wanna add more protocols, I may very well
+    big we will agree. If you wanna add more protocols, we may very well
     agree.
 
   * If you want someone else to make all the work while you wait for us to
     implement it for you, that is not a very friendly attitude. We spend a
     considerable time already on maintaining and developing curl. In order to
     get more out of us, you should consider trading in some of your time and
@@ -151,32 +156,33 @@
   cURL and libcurl are not made by any single individual. Sure, Daniel
   Stenberg writes the major parts, but various people's submissions are
   important and crucial. Anyone can post their changes and improvements and
   have them inserted in the main sources (of course on the condition that
   developers agree on that the fixes are good).
 
-  The list of contributors in the bottom of the man page is only a small part
-  of all the people that every day provide us with bug reports, suggestions,
-  ideas and source code.
+  The list of contributors in the docs/THANKS file is only a small part of all
+  the people that every day provide us with bug reports, suggestions, ideas
+  and source code.
 
   curl is developed by a community, with Daniel at the wheel.
 
   1.6 What do you get for making cURL?
 
-  Project cURL is entirely free and open, without any commercial interests or
-  money involved. No person gets paid in any way for developing curl. We all
-  do this voluntarily on our spare time.
+  Project cURL is entirely free and open. No person gets paid in any way for
+  developing curl. We all do this voluntarily on our spare time.
 
   We get some help from companies. Contactor Data hosts the curl web site and
   the main mailing list, Haxx owns the curl web site's domain and
   sourceforge.net hosts several project tools we take advantage from like the
   bug tracker, mailing lists and more.
 
-  If you feel you want to show support our project with a donation, a very
-  nice way of doing that would be to buy "gift certificates" at useful online
-  shopping sites, such as amazon.com or thinkgeek.com.
+  If you want to support our project with a donation or similar, one way of
+  doing that would be to buy "gift certificates" at useful online shopping
+  sites, such as amazon.com or thinkgeek.com. Another way would be to sponsor
+  us through a banner-program or by simply helping us coding, documenting,
+  testing etc.
 
   1.7 What about CURL from curl.com?
 
   During the summer 2001, curl.com has been busy advertising their client-side
   programming language for the web, named CURL.
 
@@ -187,12 +193,27 @@
   first computer related project to use the name "curl" and do not claim any
   first-hand rights to the name.
 
   We recognize that we will be living in parallel with curl.com and wish them
   every success.
 
+  1.8 I have a problem who do I mail?
+
+  Please do not attempt to mail any single individual unless you really need
+  to. Keep curl-related questions on a suitable mailing list. All available
+  mailing lists are listed in the MANUAL document and online at
+  http://curl.haxx.se/mail/
+
+  Keeping curl-related questions and discussions on mailing lists allows others
+  to join in and help, to share their ideas, contribute their suggestions and
+  spread their wisdom. Keeping discussions on public mailing lists also allows
+  for others to learn from this (both current and future users thanks to the
+  web based archives of the mailing lists), thus saving us from having to
+  repeat ourselves even more. Thanks for respecting this.
+
+
 2. Install Related Problems
 
   2.1. configure doesn't find OpenSSL even when it is installed
 
   This may be because of several reasons.
 
@@ -302,22 +323,20 @@
   3.5. How can I disable the Pragma: nocache header?
 
   You can change all internally generated headers by adding a replacement with
   the -H/--header option. By adding a header with empty contents you safely
   disable that one. Use -H "Pragma:" to disable that specific header.
 
-  3.6. Does curl support javascript, ASP, XML, XHTML or HTML version Y?
+  3.6. Does curl support ASP, XML, XHTML or HTML version Y?
 
   To curl, all contents are alike. It doesn't matter how the page was
   generated. It may be ASP, PHP, Perl, shell-script, SSI or plain
   HTML-files. There's no difference to curl and it doesn't even know what kind
   of language that generated the page.
 
-  Javascript is slightly different since that is code embedded in the HTML
-  that is sent for the client to interpret and curl has no javascript
-  interpreter.
+  See also item 3.14 regarding javascript.
 
   3.7. Can I use curl to delete/rename a file through FTP?
 
   Yes. You specify custom FTP commands with -Q/--quote.
 
   One example would be to delete a file after you have downloaded it:
@@ -329,37 +348,27 @@
   Curl does not follow so-called redirects by default. The Location: header
   that informs the client about this is only interpreted if you're using the
   -L/--location option. As in:
 
      curl -L http://redirector.com
 
-  3.9 How do I use curl in PHP, Perl, Tcl, Ruby or Java?
+  3.9 How do I use curl in my favorite programming language?
 
-  There exist many language-interfaces for curl that integrates it better with
-  various languages. If you are fluid in a script language, you may very well
-  opt to use such an interface instead of using the command line tool.
-
-  At the time of writing, there are bindings for the five language mentioned
-  above, but chances are there are even more by the time you read this. Or you
-  may be able you write your own wrapper for a not-yet supported language!
+  There exist many language interfaces/bindings for curl that integrates it
+  better with various languages. If you are fluid in a script language, you
+  may very well opt to use such an interface instead of using the command line
+  tool.
 
   Find out more about which languages that support curl directly, and how to
   install and use them, in the libcurl section of the curl web site:
 
         http://curl.haxx.se/libcurl/
-  
-  PHP4 has the ability to use libcurl as an internal module if built with that
-  option enabled. You then get a set of extra functions that can be used
-  within your PHP programs. You find all details about those functions in the
-  curl section in the PHP manual, see the online version at:
-
-        http://www.php.net/manual/ref.curl.php
-
-  PHP also offers the option to run a command line, and then you can of course
-  invoke the curl tool using a command line. This is the way to use curl if
-  you're using PHP3 or PHP4 built without curl module support.
+
+  In December 2001, there are interfaces available for the following
+  languages: C/C++, Cocoa, Dylan, Java, Perl, PHP, Python, Rexx, Ruby, Scheme
+  and Tcl. By the time you read this, additional ones may have appeared!
 
   3.10 What about SOAP, WebDAV, XML-RPC or similar protocols over HTTP?
 
   Curl adheres to the HTTP spec, which basically means you can play with *any*
   protocol that is built on top of HTTP. Protocols such as SOAP, WEBDAV and
   XML-RPC are all such ones. You can use -X to set custom requests and -H to
@@ -372,12 +381,72 @@
 
   You can always replace the internally generated headers with -H/--header.
   To make a simple HTTP POST with text/xml as content-type, do something like:
 
         curl -d "datatopost" -H "Content-Type: text/xml" [URL]
 
+  3.12 Why do FTP specific features over HTTP proxy fail?
+
+  Because when you use a HTTP proxy, the protocol spoken on the network will
+  be HTTP, even if you specify a FTP URL. This effectively means that you
+  normally can't use FTP specific features such as FTP upload and FTP quote
+  etc.
+
+  There is one exception to this rule, and that is if you can "tunnel through"
+  the given HTTP proxy. Proxy tunneling is enabled with a special option (-p)
+  and is generally not available as proxy admins usually disable tunneling to
+  other ports than 443 (which is used for HTTPS access through proxies).
+
+  3.13 Why does my single/double quotes fail?
+
+  To specify a command line option that includes spaces, you might need to
+  put the entire option within quotes. Like in:
+
+   curl -d " with spaces " url.com
+  
+  or perhaps
+
+   curl -d ' with spaces ' url.com
+
+  Exactly what kind of quotes and how to do this is entirely up to the shell
+  or command line interpreter that you are using. For most unix shells, you
+  can more or less pick either single (') or double (") quotes. For
+  Windows/DOS prompts I believe you're forced to use double (") quotes.
+
+  Please study the documentation for your particular environment. Examples in
+  the curl docs will use a mix of both these ones as shown above. You must
+  adjust them to work in your environment.
+
+  Remember that curl works and runs on more operating systems than most single
+  individuals have ever tried.
+
+  3.14 Does curl support javascript or pac (automated proxy config)?
+
+  Many web pages do magic stuff using embedded javascript. Curl and libcurl
+  have no built-in support for that, so it will be treated just like any other
+  contents.
+
+  .pac files are a netscape invention and are sometimes used by organizations
+  to allow them to differentiate which proxies to use. The .pac contents is
+  just a javascript program that gets invoked by the browser and that returns
+  the name of the proxy to connect to. Since curl doesn't support javascript,
+  it can't support .pac proxy configuration either.
+
+  Some work-arounds usually suggested to overcome this javascript dependency:
+
+    - Depending on the javascript complexity, write up a script that
+      translates it to another language and execute that.
+
+    - Read the javascript code and rewrite the same logic in another language.
+
+    - Implement a javascript interpreted, people have successfully used the
+      Mozilla javascript engine in the past.
+
+    - Ask your admins to stop this, for a static proxy setup or similar.
+
+
 4. Running Problems
 
   4.1. Problems connecting to SSL servers.
 
   It took a very long time before we could sort out why curl had problems to
   connect to certain SSL servers when using SSLeay or OpenSSL v0.9+.  The
@@ -461,17 +530,28 @@
     4.5.5 "405 Method Not Allowed"
 
     The method specified in the Request-Line is not allowed for the resource
     identified by the Request-URI. The response MUST include an Allow header
     containing a list of valid methods for the requested resource.
 
+    4.5.6 "301 Moved Permanently"
+ 
+    If you get this return code and an HTML output similar to this:
+
+       <H1>Moved Permanently</H1> The document has moved <A
+       HREF="http://same_url_now_with_a_trailing_slash/">here</A>.
+
+    it might be because you request a directory URL but without the trailing
+    slash. Try the same operation again _with_ the trailing URL, or use the
+    -L/--location option to follow the redirection.
+
   4.6. Can you tell me what error code 142 means?
 
   All error codes that are larger than the highest documented error code means
   that curl has exited due to a crash. This is a serious error, and we
-  appriciate a detailed bug report from you that describes how we could go
+  appreciate a detailed bug report from you that describes how we could go
   ahead and repeat this!
 
   4.7. How do I keep user names and passwords secret in Curl command lines?
 
   This problem has two sides:
 
@@ -494,25 +574,33 @@
   It is not a bug if the behavior is documented. Read the docs first.
 
   If it is a problem with a binary you've downloaded or a package for your
   particular platform, try contacting the person who built the package/archive
   you have.
 
-  If there is a bug, post a bug report in the Curl Bug Track System over at
-  http://sourceforge.net/bugs/?group_id=976
-
-  Always include as many details you can think of, including curl version,
-  operating system name and version and complete instructions how to repeat
-  the bug.
+  If there is a bug, read the BUGS document first. Then report it as described
+  in there.
 
   4.9. Curl can't authenticate to the server that requires NTLM?
 
   NTLM is a Microsoft proprietary protocol. Unfortunately, curl does not
   currently support that. Proprietary formats are evil. You should not use
   such ones.
 
+  4.10 My HTTP request using HEAD, PUT or DELETE doesn't work!
+
+  Many web servers allow or demand that the administrator configures the
+  server properly for these requests to work on the web server.
+
+  Some servers seem to support HEAD only on certain kinds of URLs.
+
+  To fully grasp this, try the documentation for the particular server
+  software you're trying to interact with. This is not anything curl can do
+  anything about.
+
+
 5. libcurl Issues
 
   5.1. Is libcurl thread-safe?
 
   Yes.
 
@@ -570,19 +658,13 @@
   For libcurl prior to 7.7, there was no multiple file support. The only
   available way to do multiple requests was to init/perform/cleanup for each
   transfer.
 
   5.4 Does libcurl do Winsock initialization on win32 systems?
 
-  No.
-
-  On win32 systems, you need to init the winsock stuff manually, libcurl will
-  not do that for you. WSAStartup() and WSACleanup() should be used
-  accordingly. The reason for this is of course that a single application may
-  use several different libraries and parts, and there's no reason for every
-  single library to do this.
+  Yes (since 7.8.1) if told to in the curl_global_init() call.
 
   5.5 Does CURLOPT_FILE and CURLOPT_INFILE work on win32 ?
 
   Yes, but you cannot open a FILE * and pass the pointer to a DLL and have
   that DLL use the FILE *. If you set CURLOPT_FILE you must also use
   CURLOPT_WRITEFUNCTION as well to set a function that writes the file, even
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/FEATURES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/FEATURES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/FEATURES	2001-03-13 20:35:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/FEATURES	2001-12-03 17:50:34.000000000 +0800
@@ -53,13 +53,13 @@
  - via http-proxy
 
 FTP
  - download
  - authentication
  - kerberos security
- - PORT or PASV
+ - active/passive using PORT, EPRT, PASV or EPSV
  - single file size information (compare to HTTP HEAD)
  - 'type=' URL support
  - dir listing
  - dir listing names-only
  - upload
  - upload append
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/INSTALL	2001-08-08 14:01:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/INSTALL	2002-06-12 15:25:43.000000000 +0800
@@ -5,15 +5,18 @@
                              \___|\___/|_| \_\_____|
 
                                 How To Compile
 
 Curl has been compiled and built on numerous different operating systems.
 
-If you're using Windows (95/98/NT/ME/2000 or whatever), VMS, RISC OS or OS/2,
-you should continue reading from one the paragraphs further down. All other
-systems should be capable of being installed as described below.
+Most systems build curl the same way (unix-style). Continue reading below for
+more details if you're one of them.
+
+If you're using Windows (95/98/NT/ME/2000/XP or similar), VMS, RISC OS or OS/2
+or cross-compile, you should continue reading from one the paragraphs further
+down.
 
 UNIX
 ====
 
    A normal unix installation is made in three or four steps (after you've
    unpacked the source archive):
@@ -30,29 +33,28 @@
 
         ./configure --prefix=/path/to/curl/tree
 
    The configure script always tries to find a working SSL library unless
    explicitly told not to. If you have OpenSSL installed in the default search
    path for your compiler/linker, you don't need to do anything special. If
-   you have OpenSSL installed in e.g /usr/local/ssl, you can run configure
-   like:
+   you have OpenSSL installed in /usr/local/ssl, you can run configure like:
 
 	./configure --with-ssl
 
    If you have OpenSSL installed somewhere else (for example, /opt/OpenSSL,)
    you can run configure like this:
 
 	./configure --with-ssl=/opt/OpenSSL
 
-   If you insist on forcing a build *without* SSL support, even though you may
-   have it installed in your system, you can run configure like this:
+   If you insist on forcing a build without SSL support, even though you may
+   have OpenSSL installed in your system, you can run configure like this:
 
         ./configure --without-ssl
 
    If you have OpenSSL installed, but with the libraries in one place and the
-   header files somewhere else, you'll have to set the LDFLAGS and CPPFLAGS
+   header files somewhere else, you have to set the LDFLAGS and CPPFLAGS
    environment variables prior to running configure.  Something like this
    should work:
 
      (with the Bourne shell and its clones):
 
        CPPFLAGS="-I/path/to/ssl/include" LDFLAGS="-L/path/to/ssl/lib" \
@@ -66,13 +68,13 @@
    If your SSL library was compiled with rsaref (usually for use in the United
    States), you may also need to set:
 
      LIBS=-lRSAglue -lrsaref
      (as suggested by Doug Kaufman)
 
-   KNOWN PROBLEMS
+   KNOWN PROBLEMS (these ones should not happen anymore)
 
      If you happen to have autoconf installed, but a version older than 2.12
      you will get into trouble. Then you can still build curl by issuing these
      commands (note that this requires curl to be built staticly): (from Ralph
      Beckmann)
 
@@ -95,14 +97,14 @@
      Then make autoheader a symbolic link to the same script and make sure
      they're executable and set to appear in the path *BEFORE* the actual (but
      obsolete) autoconf and autoheader scripts.
 
    MORE OPTIONS
 
-     Remember, to force configure to use the standard cc compiler if both
-     cc and gcc are present, run configure like
+     To force configure to use the standard cc compiler if both cc and gcc are
+     present, run configure like
 
        CC=cc ./configure
          or
        env Cc=cc ./configure
 
      To force a static library compile, disable the shared library creation
@@ -124,17 +126,12 @@
           --with-krb4[=DIR]            where to look for Kerberos4
 
      In most cases, /usr/athena is the install prefix and then it works with
 
        ./configure --with-krb4=/usr/athena
 
-     If your system support shared libraries, but you want to built a static
-     version only, you can disable building the shared version by using:
-
-       ./configure --disable-shared
-
      If you're a curl developer and use gcc, you might want to enable more
      debug options with the --enable-debug option.
 
 Win32
 =====
  
@@ -171,22 +168,22 @@
         files in a static lib "project" (all .c and .h files that is).
         (you should name it libcurl or similar)
 
         Make the sources in the src/ drawer be a "win32 console application"
         project. Name it curl.
 
-        With VC++, add 'wsock32.lib' to the link libs when you build curl!
-        Borland seems to do that itself magically. Of course you have to
-        make sure it links with the libcurl too!
+        With VC++, add 'ws2_32.lib' to the link libs when you build curl!
+        Borland seems to do that itself magically. Of course you have to make
+        sure it links with the libcurl too!
 
         For VC++ 6, there's an included Makefile.vc6 that should be possible
         to use out-of-the-box.
 
-        Microsoft note: add /Zm200 to the compiler options to increase the 
-		compiler's memory allocation limit, as the hugehelp.c won't compile
-		due to "too long puts string".
+        Microsoft note: add /Zm200 to the compiler options to increase the
+        compiler's memory allocation limit, as the hugehelp.c won't compile
+        due to "too long puts string".
 
 
    With SSL:
 
       MingW32 (GCC-2.95) style
       ------------------------
@@ -201,23 +198,40 @@
       ------------
         Haven't done, nor got any reports on how to do. It should although be
         identical to the unix setup for the same purpose. See above.
 
       Microsoft command line style
       ----------------------------
-        Please read the OpenSSL documentation on how to compile and install
-        the OpenSSL library.  This generates the libeay32.dll and ssleay32.dll
-        files.
 
-        Run the 'vcvars32.bat' file to get the proper environment variables
-        set. Edit the makefile.vc6 in the lib directory and define
-        OPENSSL_PATH.  Set the location of the OpenSSL library and run 'nmake
-        vc-ssl' in the root directory.
-
-        The vcvars32.bat file is part of the Microsoft development
-        environment.
+        Please read the OpenSSL documentation on how to compile and install
+        the OpenSSL libraries.  The build process of OpenSSL generates the
+        libeay32.dll and ssleay32.dll files in the out32dll subdirectory in
+        the OpenSSL home directory.  OpenSSL static libraries (libeay32.lib,
+        ssleay32.lib, RSAglue.lib) are created in the out32 subdirectory.
+
+        Run the 'vcvars32.bat' file to get a proper environment. The
+        vcvars32.bat file is part of the Microsoft development environment and
+        you may find it in 'C:\Program Files\Microsoft Visual Studio\vc98\bin'
+        provided that you installed Visual C/C++ 6 in the default directory.
+
+        Before running nmake define the OPENSSL_PATH environment variable with
+        the root/base directory of OpenSSL, for example:
+
+          set OPENSSL_PATH=c:\openssl-0.9.6b
+
+        Then run 'nmake vc-ssl' or 'nmake vc-ssl-dll' in curl's root
+        directory.  'nmake vc-ssl' will create a libcurl static and dynamic
+        libraries in the lib subdirectory, as well as a statically linked
+        version of curl.exe in the src subdirectory.  This statically linked
+        version is a standalone executable not requiring any DLL at
+        runtime. This make method requires that you have the static OpenSSL
+        libraries available in OpenSSL's out32 subdirectory.
+	'nmake vc-ssl-dll' creates the libcurl dynamic library and
+	links curl.exe against libcurl and OpenSSL dynamically.
+	This executable requires libcurl.dll and the OpenSSL DLLs
+	at runtime.
 
       Microsoft / Borland style
       -------------------------
         If you have OpenSSL, and want curl to take advantage of it, edit your
         project properties to use the SSL include path, link with the SSL libs
         and define the USE_SSLEAY symbol.
@@ -322,48 +336,113 @@
 	Compaq C V6.2-003 on OpenVMS Alpha V7.1-1H2
 
    So far for porting notes as of:
    13-jul-2001
    N. Baggus
 
+QNX
+===
+   (This section was graciously brought to us by David Bentham)
+
+   As QNX is targetted for resource constrained environments, the QNX headers
+   set conservative limits. This includes the FD_SETSIZE macro, set by default
+   to 32. Socket descriptors returned within the CURL library may exceed this,
+   resulting in memory faults/SIGSEGV crashes when passed into select(..)
+   calls using fd_set macros.
+
+   A good all-round solution to this is to override the default when building
+   libcurl, by overriding CFLAGS during configure, example
+   #  configure CFLAGS='-DFD_SETSIZE=64 -g -O2'
+
+CROSS COMPILE
+=============
+
+   (This section was graciously brought to us by Jim Duey, 23-oct-2001)
+
+   Download and unpack the cURL package.  Version should be 7.9.1 or later.
+
+   'cd' to the new directory. (ie. curl-7.9.1-pre4)
+
+   Set environment variables to point to the cross-compile toolchain and call
+   configure with any options you need.  Be sure and specify the '--host' and
+   '--build' parameters at configuration time.  The following script is an
+   example of cross-compiling for the IBM 405GP PowerPC processor using the
+   toolchain from MonteVista for Hardhat Linux.
+
+   (begin script)
+
+   #! /bin/sh
+
+   export PATH=$PATH:/opt/hardhat/devkit/ppc/405/bin
+   export CPPFLAGS="-I/opt/hardhat/devkit/ppc/405/target/usr/include"
+   export AR=ppc_405-ar
+   export AS=ppc_405-as
+   export LD=ppc_405-ld
+   export RANLIB=ppc_405-ranlib
+   export CC=ppc_405-gcc
+   export NM=ppc_405-nm
+
+   configure --target=powerpc-hardhat-linux \
+	--host=powerpc-hardhat-linux \
+	--build=i586-pc-linux-gnu \
+	--prefix=/opt/hardhat/devkit/ppc/405/target/usr/local \
+	--exec-prefix=/usr/local
+
+   (end script)
+
+   The '--prefix' parameter specifies where cURL will be installed.  If
+   'configure' completes successfully, do 'make' and 'make install' as usual.
+
 PORTS
 =====
    This is a probably incomplete list of known hardware and operating systems
-   that curl has been compiled for:
+   that curl has been compiled for. If you know a system curl compiles and
+   runs on, that isn't listed, please let us know!
 
-        - Ultrix 4.3a
-        - SINIX-Z v5
         - Alpha DEC OSF 4
         - Alpha Digital UNIX v3.2
-        - Alpha FreeBSD 4.1
-        - Alpha Linux 2.2.16
+        - Alpha FreeBSD 4.1, 4.5
+        - Alpha Linux 2.2, 2.4
+        - Alpha NetBSD 1.5.2
+        - Alpha OpenBSD 3.0
         - Alpha OpenVMS V7.1-1H2
         - Alpha Tru64 v5.0 5.1
         - HP-PA HP-UX 9.X 10.X 11.X
+        - HP-PA Linux
         - MIPS IRIX 6.2, 6.5
-        - Power AIX 4.2, 4.3.1, 4.3.2
+        - MIPS Linux
+        - Pocket PC/Win CE 3.0
+        - Power AIX 4.2, 4.3.1, 4.3.2, 5.1
         - PowerPC Darwin 1.0
         - PowerPC Linux
+        - PowerPC Mac OS 9
         - PowerPC Mac OS X
+        - SINIX-Z v5
         - Sparc Linux
         - Sparc Solaris 2.4, 2.5, 2.5.1, 2.6, 7, 8
         - Sparc SunOS 4.1.X
+        - StrongARM (and other ARM) RISC OS 3.1, 4.02
+        - StrongARM Linux 2.4
+        - StrongARM NetBSD 1.4.1
+        - Ultrix 4.3a
         - i386 BeOS
         - i386 FreeBSD
+        - i386 HURD
         - i386 Linux 1.3, 2.0, 2.2, 2.3, 2.4
         - i386 NetBSD
         - i386 OS/2
         - i386 OpenBSD
         - i386 SCO unix
         - i386 Solaris 2.7
         - i386 Windows 95, 98, ME, NT, 2000
+        - i386 QNX 6
         - ia64 Linux 2.3.99
         - m68k AmigaOS 3
+        - m68k Linux
         - m68k OpenBSD
-        - StrongARM NetBSD 1.4.1
-        - StrongARM (and other ARM) RISC OS 3.1, 4.02
+        - s390 Linux 
 
 OpenSSL
 =======
 
    You'll find OpenSSL information at:
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/INTERNALS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/INTERNALS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/INTERNALS	2001-05-29 21:02:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/INTERNALS	2002-02-26 22:04:05.000000000 +0800
@@ -1,7 +1,7 @@
-                                       Updated for curl 7.8 on May 29, 2001
+                                    Updated for curl 7.9.1 on November 2, 2001
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -51,13 +51,13 @@
 
    We set stdout to binary under windows
 
  Inside the source code, We make an effort to avoid '#ifdef [Your OS]'. All
  conditionals that deal with features *should* instead be in the format
  '#ifdef HAVE_THAT_WEIRD_FUNCTION'. Since Windows can't run configure scripts,
- we maintain two config-win32.h files (one in / and one in src/) that are
+ we maintain two config-win32.h files (one in lib/ and one in src/) that are
  supposed to look exactly as a config.h file would have looked like on a
  Windows machine!
 
  Generally speaking: always remember that this will be compiled on dozens of
  operating systems. Don't walk on the edge.
 
@@ -66,30 +66,30 @@
 
  There are plenty of entry points to the library, namely each publicly defined
  function that libcurl offers to applications. All of those functions are
  rather small and easy-to-follow. All the ones prefixed with 'curl_easy' are
  put in the lib/easy.c file.
 
- Starting with libcurl 7.8, curl_global_init_() and curl_global_cleanup() were
- introduced. They should be called by the application to initialize and clean
- up global stuff in the library. As of today, they just do the global SSL
- initing if SSL is enabled. libcurl itself has no "global" scope.
+ curl_global_init_() and curl_global_cleanup() should be called by the
+ application to initialize and clean up global stuff in the library. As of
+ today, it can handle the global SSL initing if SSL is enabled and it can init
+ the socket layer on windows machines. libcurl itself has no "global" scope.
 
  All printf()-style functions use the supplied clones in lib/mprintf.c. This
  makes sure we stay absolutely platform independent.
 
  curl_easy_init() allocates an internal struct and makes some initializations.
- The returned handle does not reveal internals. This is the 'UrlData' struct
- which works as a global "anchor" struct. All connections performed will get
- connect-specific data allocated that should be used for things related to
- particular connections/requests.
+ The returned handle does not reveal internals. This is the 'SessionHandle'
+ struct which works as an "anchor" struct for all curl_easy functions. All
+ connections performed will get connect-specific data allocated that should be
+ used for things related to particular connections/requests.
 
  curl_easy_setopt() takes three arguments, where the option stuff must be
  passed in pairs: the parameter-ID and the parameter-value. The list of
  options is documented in the man page. This function mainly sets things in
- the 'UrlData' struct.
+ the 'SessionHandle' struct.
 
  curl_easy_perform() does a whole lot of things:
 
  It starts off in the lib/easy.c file by calling Curl_perform() and the main
  work then continues in lib/url.c. The flow continues with a call to
  Curl_connect() to connect to the remote site.
@@ -103,13 +103,13 @@
    When Curl_connect is done, we are connected to the remote site. Then it is
    time to tell the server to get a document/file. Curl_do() arranges this.
 
    This function makes sure there's an allocated and initiated 'connectdata'
    struct that is used for this particular connection only (although there may
    be several requests performed on the same connect). A bunch of things are
-   inited/inherited from the UrlData struct.
+   inited/inherited from the SessionHandle struct.
 
  o Curl_do()
 
    Curl_do() makes sure the proper protocol-specific function is called. The
    functions are named after the protocols they handle. Curl_ftp(),
    Curl_http(), Curl_dict(), etc. They all reside in their respective files
@@ -120,12 +120,19 @@
    negotiations and setup. They have access to the Curl_sendf() (from
    lib/sendf.c) function to send printf-style formatted data to the remote
    host and when they're ready to make the actual file transfer they call the
    Curl_Transfer() function (in lib/transfer.c) to setup the transfer and
    returns.
 
+   Starting in 7.9.1, if this DO function fails and the connection is being
+   re-used, libcurl will then close this connection, setup a new connection
+   and re-issue the DO request on that. This is because there is no way to be
+   perfectly sure that we have discovered a dead connection before the DO
+   function and thus we might wrongly be re-using a connection that was closed
+   by the remote peer.
+
  o Transfer()
 
    Curl_perform() then calls Transfer() in lib/transfer.c that performs
    the entire file transfer.
 
    During transfer, the progress functions in lib/progress.c are called at a
@@ -141,13 +148,13 @@
    the same connection (in a persistent connection case). It might also soon
    be closed with Curl_disconnect().
 
  o Curl_disconnect()
 
    When doing normal connections and transfers, no one ever tries to close any
-   connection so this is not normally called when curl_easy_perform() is
+   connections so this is not normally called when curl_easy_perform() is
    used. This function is only used when we are certain that no more transfers
    is going to be made on the connection. It can be also closed by force, or
    it can be called to make sure that libcurl doesn't keep too many
    connections alive at the same time (there's a default amount of 5 but that
    can be changed with the CURLOPT_MAXCONNECTS option).
 
@@ -255,18 +262,18 @@
 Persistent Connections
 ======================
 
  The persistent connection support in libcurl requires some considerations on
  how to do things inside of the library.
 
- o The 'UrlData' struct returned in the curl_easy_init() call must never
-   hold connection-oriented data. It is meant to hold the root data as well
-   as all the options etc that the library-user may choose.
- o The 'UrlData' struct holds the "connection cache" (an array of pointers to
-   'connectdata' structs). There's one connectdata struct allocated for each
-   connection that libcurl knows about.
+ o The 'SessionHandle' struct returned in the curl_easy_init() call must never
+   hold connection-oriented data. It is meant to hold the root data as well as
+   all the options etc that the library-user may choose.
+ o The 'SessionHandle' struct holds the "connection cache" (an array of
+   pointers to 'connectdata' structs). There's one connectdata struct
+   allocated for each connection that libcurl knows about.
  o This also enables the 'curl handle' to be reused on subsequent transfers,
    something that was illegal before libcurl 7.7.
  o When we are about to perform a transfer with curl_easy_perform(), we first
    check for an already existing connection in the cache that we can use,
    otherwise we create a new one and add to the cache. If the cache is full
    already when we add a new connection, we close one of the present ones. We
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs: KNOWN_BUGS
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs: libcurl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: libcurl.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs: libcurl.html
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/Makefile.am	2001-09-18 06:25:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/Makefile.am	2002-04-29 19:57:24.000000000 +0800
@@ -1,76 +1,32 @@
 #
-# $Id: Makefile.am,v 1.15 2001/09/17 22:24:35 bagder Exp $
+# $Id: Makefile.am,v 1.20 2002/04/27 17:02:38 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 man_MANS = \
 	curl.1 \
-	curl-config.1 \
-	curl_easy_cleanup.3 \
-	curl_easy_getinfo.3 \
-	curl_easy_init.3 \
-	curl_easy_perform.3 \
-	curl_easy_setopt.3 \
-	curl_easy_duphandle.3 \
-	curl_formparse.3 \
-	curl_formadd.3 \
-	curl_formfree.3 \
-	curl_getdate.3 \
-	curl_getenv.3 \
-	curl_slist_append.3 \
-	curl_slist_free_all.3 \
-	curl_version.3 \
-	curl_escape.3 \
-	curl_unescape.3 \
-	curl_strequal.3 \
-	curl_strnequal.3 \
-	curl_mprintf.3 \
-	curl_global_init.3 \
-	curl_global_cleanup.3 \
-	libcurl.3
-
-SUBDIRS = examples
+	curl-config.1
 
 HTMLPAGES = \
 	curl.html \
-	curl-config.html \
-	curl_easy_cleanup.html \
-	curl_easy_getinfo.html \
-	curl_easy_init.html \
-	curl_easy_perform.html \
-	curl_easy_setopt.html \
-	curl_easy_duphandle.html \
-	curl_formadd.html \
-	curl_formparse.html \
-	curl_formfree.html \
-	curl_getdate.html \
-	curl_getenv.html \
-	curl_slist_append.html \
-	curl_slist_free_all.html \
-	curl_version.html \
-	curl_escape.html \
-	curl_unescape.html \
-	curl_strequal.html \
-	curl_strnequal.html \
-	curl_mprintf.html \
-	curl_global_init.html \
-	curl_global_cleanup.html \
-	libcurl.html
-
-EXTRA_DIST = $(man_MANS) \
-	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS \
-	README.win32 RESOURCES TODO TheArtOfHttpScripting THANKS \
-	$(HTMLPAGES)
+	curl-config.html
+
+SUBDIRS = examples libcurl
+
+EXTRA_DIST = MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS		\
+	     README.win32 RESOURCES TODO TheArtOfHttpScripting THANKS	\
+	     VERSIONS KNOWN_BUGS BINDINGS $(man_MANS) $(HTMLPAGES)
 
 MAN2HTML= gnroff -man $< | man2html >$@
 
 SUFFIXES = .1 .3 .html
 
 html: $(HTMLPAGES)
+	cd libcurl; make html
 
 .3.html:
 	$(MAN2HTML)
 
 .1.html:
 	$(MAN2HTML)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/Makefile.in	2001-09-18 06:25:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/Makefile.in	2002-06-11 23:18:51.000000000 +0800
@@ -11,13 +11,13 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.15 2001/09/17 22:24:35 bagder Exp $
+# $Id: Makefile.am,v 1.20 2002/04/27 17:02:38 bagder Exp $
 #
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
@@ -62,12 +62,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -94,78 +101,35 @@
 install_sh = @install_sh@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 man_MANS = \
 	curl.1 \
-	curl-config.1 \
-	curl_easy_cleanup.3 \
-	curl_easy_getinfo.3 \
-	curl_easy_init.3 \
-	curl_easy_perform.3 \
-	curl_easy_setopt.3 \
-	curl_easy_duphandle.3 \
-	curl_formparse.3 \
-	curl_formadd.3 \
-	curl_formfree.3 \
-	curl_getdate.3 \
-	curl_getenv.3 \
-	curl_slist_append.3 \
-	curl_slist_free_all.3 \
-	curl_version.3 \
-	curl_escape.3 \
-	curl_unescape.3 \
-	curl_strequal.3 \
-	curl_strnequal.3 \
-	curl_mprintf.3 \
-	curl_global_init.3 \
-	curl_global_cleanup.3 \
-	libcurl.3
+	curl-config.1
 
 
-SUBDIRS = examples
-
 HTMLPAGES = \
 	curl.html \
-	curl-config.html \
-	curl_easy_cleanup.html \
-	curl_easy_getinfo.html \
-	curl_easy_init.html \
-	curl_easy_perform.html \
-	curl_easy_setopt.html \
-	curl_easy_duphandle.html \
-	curl_formadd.html \
-	curl_formparse.html \
-	curl_formfree.html \
-	curl_getdate.html \
-	curl_getenv.html \
-	curl_slist_append.html \
-	curl_slist_free_all.html \
-	curl_version.html \
-	curl_escape.html \
-	curl_unescape.html \
-	curl_strequal.html \
-	curl_strnequal.html \
-	curl_mprintf.html \
-	curl_global_init.html \
-	curl_global_cleanup.html \
-	libcurl.html
-
-
-EXTRA_DIST = $(man_MANS) \
-	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS \
-	README.win32 RESOURCES TODO TheArtOfHttpScripting THANKS \
-	$(HTMLPAGES)
+	curl-config.html
+
+
+SUBDIRS = examples libcurl
+
+EXTRA_DIST = MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS		\
+	     README.win32 RESOURCES TODO TheArtOfHttpScripting THANKS	\
+	     VERSIONS KNOWN_BUGS BINDINGS $(man_MANS) $(HTMLPAGES)
 
 
 MAN2HTML = gnroff -man $< | man2html >$@
 
 SUFFIXES = .1 .3 .html
 subdir = docs
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 depcomp =
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
@@ -242,51 +206,12 @@
 	  inst=`echo $$inst | sed -e 's/^.*\///'`; \
 	  inst=`echo $$inst | sed '$(transform)'`.$$ext; \
 	  echo " rm -f $(DESTDIR)$(man1dir)/$$inst"; \
 	  rm -f $(DESTDIR)$(man1dir)/$$inst; \
 	done
 
-man3dir = $(mandir)/man3
-install-man3: $(man3_MANS) $(man_MANS)
-	@$(NORMAL_INSTALL)
-	$(mkinstalldirs) $(DESTDIR)$(man3dir)
-	@list='$(man3_MANS) $(dist_man3_MANS) $(nodist_man3_MANS)'; \
-	l2='$(man_MANS) $(dist_man_MANS) $(nodist_man_MANS)'; \
-	for i in $$l2; do \
-	  case "$$i" in \
-	    *.3*) list="$$list $$i" ;; \
-	  esac; \
-	done; \
-	for i in $$list; do \
-	  if test -f $(srcdir)/$$i; then file=$(srcdir)/$$i; \
-	  else file=$$i; fi; \
-	  ext=`echo $$i | sed -e 's/^.*\\.//'`; \
-	  inst=`echo $$i | sed -e 's/\\.[0-9a-z]*$$//'`; \
-	  inst=`echo $$inst | sed -e 's/^.*\///'`; \
-	  inst=`echo $$inst | sed '$(transform)'`.$$ext; \
-	  echo " $(INSTALL_DATA) $$file $(DESTDIR)$(man3dir)/$$inst"; \
-	  $(INSTALL_DATA) $$file $(DESTDIR)$(man3dir)/$$inst; \
-	done
-uninstall-man3:
-	@$(NORMAL_UNINSTALL)
-	@list='$(man3_MANS) $(dist_man3_MANS) $(nodist_man3_MANS)'; \
-	l2='$(man_MANS) $(dist_man_MANS) $(nodist_man_MANS)'; \
-	for i in $$l2; do \
-	  case "$$i" in \
-	    *.3*) list="$$list $$i" ;; \
-	  esac; \
-	done; \
-	for i in $$list; do \
-	  ext=`echo $$i | sed -e 's/^.*\\.//'`; \
-	  inst=`echo $$i | sed -e 's/\\.[0-9a-z]*$$//'`; \
-	  inst=`echo $$inst | sed -e 's/^.*\///'`; \
-	  inst=`echo $$inst | sed '$(transform)'`.$$ext; \
-	  echo " rm -f $(DESTDIR)$(man3dir)/$$inst"; \
-	  rm -f $(DESTDIR)$(man3dir)/$$inst; \
-	done
-
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
 # To change the values of `make' variables: instead of editing Makefiles,
 # (1) if the variable is set in `config.status', edit `config.status'
 #     (which will cause the Makefiles to be regenerated when you run `make');
 # (2) otherwise, pass the desired values on the `make' command line.
@@ -412,13 +337,13 @@
 	done
 check-am: all-am
 check: check-recursive
 all-am: Makefile $(MANS)
 installdirs: installdirs-recursive
 installdirs-am:
-	$(mkinstalldirs) $(DESTDIR)$(man1dir) $(DESTDIR)$(man3dir)
+	$(mkinstalldirs) $(DESTDIR)$(man1dir)
 
 install: install-recursive
 install-exec: install-exec-recursive
 install-data: install-data-recursive
 uninstall: uninstall-recursive
 
@@ -460,13 +385,13 @@
 install-data-am: install-man
 
 install-exec-am:
 
 install-info: install-info-recursive
 
-install-man: install-man1 install-man3
+install-man: install-man1
 
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
 
 maintainer-clean-am: distclean-am maintainer-clean-generic
@@ -476,33 +401,34 @@
 mostlyclean-am: mostlyclean-generic mostlyclean-libtool
 
 uninstall-am: uninstall-info-am uninstall-man
 
 uninstall-info: uninstall-info-recursive
 
-uninstall-man: uninstall-man1 uninstall-man3
+uninstall-man: uninstall-man1
 
 .PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
 	clean-generic clean-libtool clean-recursive distclean \
 	distclean-generic distclean-libtool distclean-recursive \
 	distclean-tags distdir dvi dvi-am dvi-recursive info info-am \
 	info-recursive install install-am install-data install-data-am \
 	install-data-recursive install-exec install-exec-am \
 	install-exec-recursive install-info install-info-am \
-	install-info-recursive install-man install-man1 install-man3 \
+	install-info-recursive install-man install-man1 \
 	install-recursive install-strip installcheck installcheck-am \
 	installdirs installdirs-am installdirs-recursive \
 	maintainer-clean maintainer-clean-generic \
 	maintainer-clean-recursive mostlyclean mostlyclean-generic \
 	mostlyclean-libtool mostlyclean-recursive tags tags-recursive \
 	uninstall uninstall-am uninstall-info-am \
 	uninstall-info-recursive uninstall-man uninstall-man1 \
-	uninstall-man3 uninstall-recursive
+	uninstall-recursive
 
 
 html: $(HTMLPAGES)
+	cd libcurl; make html
 
 .3.html:
 	$(MAN2HTML)
 
 .1.html:
 	$(MAN2HTML)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/MANUAL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/MANUAL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/MANUAL	2001-08-03 01:10:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/MANUAL	2002-05-22 06:23:01.000000000 +0800
@@ -129,13 +129,13 @@
 UPLOADING
 
  FTP
 
   Upload all data on stdin to a specified ftp site:
 
-        curl -t ftp://ftp.upload.com/myfile
+        curl -T - ftp://ftp.upload.com/myfile
 
   Upload data from a specified file, login with user and password:
 
         curl -T uploadfile -u user:passwd ftp://ftp.upload.com/myfile
 
   Upload a local file to the remote site, and use the local file name remote
@@ -154,13 +154,13 @@
         curl --proxytunnel -x proxy:port -T localfile ftp.upload.com
 
  HTTP
 
   Upload all data on stdin to a specified http site:
 
-        curl -t http://www.upload.com/myfile
+        curl -T - http://www.upload.com/myfile
 
   Note that the http server must've been configured to accept PUT before this
   can be done successfully.
 
   For other ways to do http data upload, see the POST section below.
 
@@ -243,31 +243,31 @@
   understood by CGI's and similar, curl also supports the more capable
   multipart/form-data type. This latter type supports things like file upload.
 
   -F accepts parameters like -F "name=contents". If you want the contents to
   be read from a file, use <@filename> as contents. When specifying a file,
   you can also specify the file content type by appending ';type=<mime type>'
-  to the file name. You can also post the contents of several files in one field.
-  For example, the field name 'coolfiles' is used to send three  files, with
-  different content types using the following syntax:
+  to the file name. You can also post the contents of several files in one
+  field.  For example, the field name 'coolfiles' is used to send three files,
+  with different content types using the following syntax:
 
         curl -F "coolfiles=@fil1.gif;type=image/gif,fil2.txt,fil3.html" \
         http://www.post.com/postit.cgi
 
   If the content-type is not specified, curl will try to guess from the file
-  extension  (it only knows a few), or use the previously specified type
-  (from an earlier file if several files are specified in a list) or else it
-  will  using the default type 'text/plain'.
+  extension (it only knows a few), or use the previously specified type (from
+  an earlier file if several files are specified in a list) or else it will
+  using the default type 'text/plain'.
 
   Emulate a fill-in form with -F. Let's say you fill in three fields in a
   form. One field is a file name which to post, one field is your name and one
   field is a file description. We want to post the file we have written named
   "cooltext.txt". To let curl do the posting of this data instead of your
-  favourite browser, you have to read the HTML source of the form page and find
-  the names of the input fields. In our example, the input field names are
-  'file', 'yourname' and 'filedescription'.
+  favourite browser, you have to read the HTML source of the form page and
+  find the names of the input fields. In our example, the input field names
+  are 'file', 'yourname' and 'filedescription'.
 
         curl -F "file=@cooltext.txt" -F "yourname=Daniel" \
              -F "filedescription=Cool text file with cool text inside" \
              http://www.post.com/postit.cgi
 
   To send two files in one post you can do it in two ways:
@@ -598,21 +598,21 @@
 
  To continue a file transfer where it was previously aborted, curl supports
  resume on http(s) downloads as well as ftp uploads and downloads.
 
  Continue downloading a document:
 
-        curl -c -o file ftp://ftp.server.com/path/file
+        curl -C - -o file ftp://ftp.server.com/path/file
 
  Continue uploading a document(*1):
 
-        curl -c -T file ftp://ftp.server.com/path/file
+        curl -C - -T file ftp://ftp.server.com/path/file
 
  Continue downloading a document from a web server(*2):
 
-        curl -c -o file http://www.server.com/
+        curl -C - -o file http://www.server.com/
 
  (*1) = This requires that the ftp server supports the non-standard command
         SIZE. If it doesn't, curl will say so.
 
  (*2) = This requires that the web server supports at least HTTP/1.1. If it
         doesn't, curl will say so.
@@ -665,14 +665,20 @@
 LDAP
 
   If you have installed the OpenLDAP library, curl can take advantage of it
   and offer ldap:// support.
 
   LDAP is a complex thing and writing an LDAP query is not an easy task. I do
-  advice you to dig up the syntax description for that elsewhere, RFC 1959 if
-  no other place is better.
+  advice you to dig up the syntax description for that elsewhere. Two places
+  that might suit you are:
+
+  Netscape's "Netscape Directory SDK 3.0 for C Programmer's Guide Chapter 10:
+  Working with LDAP URLs":
+  http://developer.netscape.com/docs/manuals/dirsdk/csdk30/url.htm
+
+  RFC 2255, "The LDAP URL Format" http://www.rfc-editor.org/rfc/rfc2255.txt
 
   To show you an example, this is now I can get all people from my local LDAP
   server that has a certain sub-domain in their email address:
 
         curl -B "ldap://ldap.frontec.se/o=frontec??sub?mail=*sth.frontec.se"
 
@@ -680,13 +686,13 @@
   (enforce ASCII) flag.
 
 ENVIRONMENT VARIABLES
 
   Curl reads and understands the following environment variables:
 
-        HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, GOPHER_PROXY
+        http_proxy, HTTPS_PROXY, FTP_PROXY, GOPHER_PROXY
 
   They should be set for protocol-specific proxies. General proxy should be
   set with
         
         ALL_PROXY
 
@@ -707,15 +713,15 @@
   to specify name and password for commonly visited ftp sites in a file so
   that you don't have to type them in each time you visit those sites. You
   realize this is a big security risk if someone else gets hold of your
   passwords, so therefor most unix programs won't read this file unless it is
   only readable by yourself (curl doesn't care though).
 
-  Curl supports .netrc files if told so (using the -n/--netrc option). This is
-  not restricted to only ftp, but curl can use it for all protocols where
-  authentication is used.
+  Curl supports .netrc files if told so (using the -n/--netrc and
+  --netrc-optional options). This is not restricted to only ftp,
+  but curl can use it for all protocols where authentication is used.
 
   A very simple .netrc file could look something like:
 
         machine curl.haxx.se login iamdaniel password mysecret
 
 CUSTOM OUTPUT
@@ -753,12 +759,23 @@
   And enter the data to pass to the server on stdin. The result will be sent
   to stdout or to the file you specify with -o.
 
   You might want the -N/--no-buffer option to switch off the buffered output
   for slow connections or similar.
 
+  Pass options to the telnet protocol negotiation, by using the -t option. To
+  tell the server we use a vt100 terminal, try something like:
+
+        curl -tTTYPE=vt100 telnet://remote.server.com
+
+  Other interesting options for it -t include:
+
+   - XDISPLOC=<X display> Sets the X display location.
+
+   - NEW_ENV=<var,val> Sets an environment variable.
+
   NOTE: the telnet protocol does not specify any way to login with a specified
   user and password so curl can't do that automatically. To do that, you need
   to track when the login prompt is received and send the username and
   password accordingly.
 
 PERSISTANT CONNECTIONS
@@ -780,22 +797,42 @@
 
   Persistant connections were introduced in curl 7.7.
 
 MAILING LISTS
 
   For your convenience, we have several open mailing lists to discuss curl,
-  its development and things relevant to this.
+  its development and things relevant to this. Get all info at
+  http://curl.haxx.se/mail/. The lists available are:
+
+  curl-users
+
+    Users of the command line tool. How to use it, what doesn't work, new
+    features, related tools, questions, news, installations, compilations,
+    running, porting etc.
+
+  curl-library
+
+    Developers using or developing libcurl. Bugs, extensions, improvements.
+
+  curl-announce
+
+    Low-traffic. Only announcements of new public versions.
+
+  curl-and-PHP
+
+    Using the curl functions in PHP. Everything curl with a PHP angle. Or PHP
+    with a curl angle.
 
-  To subscribe to the main curl list, mail curl-request@contactor.se with
-  "subscribe <fill in your email address>" in the body.
+  curl-commits
 
-  To subscribe to the curl-library users/deverlopers list, follow the
-  instructions at http://curl.haxx.se/mail/
+    Receives notifications on all CVS commits done to the curl source module.
+    This can become quite a large amount of mails during intense development,
+    be aware. This is for us who liks email...
 
-  To subscribe to the curl-announce list, to only get information about new
-  releases, follow the instructions at http://curl.haxx.se/mail/
+  curl-www-commits
 
-  To subscribe to the curl-and-PHP list in which curl using with PHP is
-  discussed, follow the instructions at http://curl.haxx.se/mail/
+    Receives notifications on all CVS commits done to the curl www module
+    (basicly the web site).  This can become quite a large amount of mails
+    during intense changing, be aware. This is for us who liks email...
 
   Please direct curl questions, feature requests and trouble reports to one of
   these mailing lists instead of mailing any individual.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/README.win32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/README.win32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/README.win32	2001-04-23 19:42:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/README.win32	2001-12-03 17:59:12.000000000 +0800
@@ -9,21 +9,14 @@
   Read the README file first.
 
   Curl has been compiled, built and run on all sorts of Windows and win32
   systems. While not being the main develop target, a fair share of curl users
   are win32-based.
 
-  Some documentation in this archive will be tricky to read for Windows
-  people, as they come in unix-style man pages. You can either download a
-  freely available nroff binary for win32 (*pointers appriciated*), convert
-  the files into plain-text on your neighbor's unix machine or run over to the
-  curl web site and view them as plain HTML.
+  The unix-style man pages are tricky to read on windows, so therefore are all
+  those pages also converted to HTML and those are also included in the
+  release archives.
 
-  The main curl.1 man page is "built-in". Use a command line similar to this
-  in order to extract a separate text file:
+  The main curl.1 man page is also "built-in" in the command line tool. Use a
+  command line similar to this in order to extract a separate text file:
 
         curl -M >manual.txt
-
-  Download all the libcurl man pages in HTML format using the link on the
-  bottom of this page:
-
-        http://curl.haxx.se/libcurl/c/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/RESOURCES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/RESOURCES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/RESOURCES	2001-01-15 20:11:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/RESOURCES	2002-04-29 19:57:24.000000000 +0800
@@ -2,16 +2,15 @@
   Project                     ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
 
-This document has been introduced in order to let you find documents that
-specify standards used by curl, software that extends curl, web pages with
-"competing" utilities and information pages that describe some of the tools
-that we use to build/compile/develop curl.
+This document lists documents that specify standards used by curl, software
+that extends curl, web pages with similar utilities and information pages that
+describe some of the tools that we use to build/compile/develop curl.
 
 Standards
 ---------
 
   RFC 959  - Defines how FTP works
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/THANKS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/THANKS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/THANKS	2001-08-08 15:22:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/THANKS	2002-04-08 14:56:38.000000000 +0800
@@ -50,13 +50,13 @@
  - Kristian Köhntopp <kris@koehntopp.de>
  - Fred Noz <FNoz@siac.com>
  - Caolan McNamara <caolan@csn.ul.ie>
  - Albert Chin-A-Young <china@thewrittenword.com>
  - Stephen Kick <skick@epicrealm.com>
  - Martin Hedenfalk <mhe@stacken.kth.se>
- - Richard Prescott
+ - Richard Prescott <rip at step.polymtl.ca>
  - Jason S. Priebe <priebe@wral-tv.com>
  - T. Bharath <TBharath@responsenetworks.com>
  - Alexander Kourakos <awk@users.sourceforge.net>
  - James Griffiths <griffiths_james@yahoo.com>
  - Loic Dachary <loic@senga.org>
  - Robert Weaver <robert.weaver@sabre.com>
@@ -72,6 +72,12 @@
  - Patrick Bihan-Faou
  - Nico Baggus <Nico.Baggus@mail.ing.nl>
  - Sergio Ballestrero
  - Andrew Francis <locust@familyhealth.com.au>
  - Tomasz Lacki <Tomasz.Lacki@primark.pl>
  - Georg Huettenegger <georg@ist.org>
+ - John Lask <johnlask@hotmail.com>
+ - Eric Lavigne <erlavigne@wanadoo.fr>
+ - Marcus Webster <marcus.webster@phocis.com>
+ - Götz Babin-Ebell <babin­ebell@trustcenter.de>
+ - Andreas Damm <andreas-sourceforge@radab.org>
+ - Jacky Lam <sylam@emsoftltd.com>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/TheArtOfHttpScripting /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/TheArtOfHttpScripting
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/TheArtOfHttpScripting	2001-08-20 21:21:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/TheArtOfHttpScripting	2001-10-31 21:32:01.000000000 +0800
@@ -1,10 +1,10 @@
 Online:  http://curl.haxx.se/docs/httpscripting.shtml
 Author:  Daniel Stenberg <daniel@haxx.se>
-Date:    August 20, 2001
-Version: 0.4
+Date:    October 31, 2001
+Version: 0.5
 
                 The Art Of Scripting HTTP Requests Using Curl
                 =============================================
 
  This document will assume that you're familiar with HTML and general
  networking.
@@ -45,21 +45,21 @@
  useful option when it comes to debug or even understand the curl<->server
  interaction.
 
 2. URL
 
  The Uniform Resource Locator format is how you specify the address of a
- particular resource on the internet. You know these, you've seen URLs like
+ particular resource on the Internet. You know these, you've seen URLs like
  http://curl.haxx.se or https://yourbank.com a million times.
 
 3. GET a page
 
  The simplest and most common request/operation made using HTTP is to get a
  URL. The URL could itself refer to a web page, an image or a file. The client
  issues a GET request to the server and receives the document it asked for.
- If you isse the command line
+ If you issue the command line
 
         curl http://curl.haxx.se
 
  you get a web page returned in your terminal window. The entire HTML document
  that that URL holds.
 
@@ -86,13 +86,13 @@
 
         <form method="GET" action="junk.cgi">
           <input type=text name="birthyear">
           <input type=submit name=press value="OK">
         </form>
 
-  In your favourite browser, this form will appear with a text box to fill in
+  In your favorite browser, this form will appear with a text box to fill in
   and a press-button labeled "OK". If you fill in '1905' and press the OK
   button, your browser will then create a new URL to get for you. The URL will
   get "junk.cgi?birthyear=1905&press=OK" appended to the path part of the
   previous URL.
 
   If the original form was seen on the page "www.hotmail.com/when/birth.html",
@@ -133,14 +133,14 @@
   This kind of POST will use the Content-Type
   application/x-www-form-urlencoded and is the most widely used POST kind.
 
  4.3 FILE UPLOAD POST
 
   Back in late 1995 they defined a new way to post data over HTTP. It was
-  documented in the RFC 1867, why this method sometimes is refered to as
-  a rfc1867-posting.
+  documented in the RFC 1867, why this method sometimes is referred to as
+  a RFC1867-posting.
 
   This method is mainly designed to better support file uploads. A form that
   allows a user to upload a file could be written like this in HTML:
 
     <form method="POST" enctype='multipart/form-data' action="upload.cgi">
       <input type=file name=upload>
@@ -179,13 +179,13 @@
 
   When you're about fill in a form and send to a server by using curl instead
   of a browser, you're of course very interested in sending a POST exactly the
   way your browser does.
 
   An easy way to get to see this, is to save the HTML page with the form on
-  your local disk, mofidy the 'method' to a GET, and press the submit button
+  your local disk, modify the 'method' to a GET, and press the submit button
   (you could also change the action URL if you want to).
 
   You will then clearly see the data get appended to the URL, separated with a
   '?'-letter as GET forms are supposed to.
 
 5. PUT
@@ -211,13 +211,13 @@
 
         curl -u name:password www.secrets.com
  
  Sometimes your HTTP access is only available through the use of a HTTP
  proxy. This seems to be especially common at various companies. A HTTP proxy
  may require its own user and password to allow the client to get through to
- the internet. To specify those with curl, run something like:
+ the Internet. To specify those with curl, run something like:
 
         curl -U proxyuser:proxypassword curl.haxx.se
 
  If you use any one these user+password options but leave out the password
  part, curl will prompt for the password interactively.
 
@@ -291,13 +291,13 @@
 
  When a client communicates with a server with a name and path as previously
  specified in a received cookie, the client sends back the cookies and their
  contents to the server, unless of course they are expired.
 
  Many applications and servers use this method to connect a series of requests
- into a single logical session. To be able to use curl in such occations, we
+ into a single logical session. To be able to use curl in such occasions, we
  must be able to record and send back cookies the way the web application
  expects them. The same way browsers deal with them.
 
  The simplest way to send a few cookies to the server when getting a page with
  curl is to add them on the command line like:
 
@@ -322,12 +322,21 @@
  exist. Example, if you want to let curl understand cookies from a page and
  follow a location (and thus possibly send back cookies it received), you can
  invoke it like:
 
         curl -b nada -L www.cookiesite.com
 
+ Curl has the ability to read and write cookie files that use the same file
+ format that Netscape and Mozilla do. It is a convenient way to share cookies
+ between browsers and automatic scripts. The -b switch automatically detects
+ if a given file is such a cookie file and parses it, and by using the
+ -c/--cookie-jar option you'll make curl write a new cookie file at the end of
+ an operation:
+
+        curl -b cookies.txt -c newcookies.txt www.cookiesite.com
+
 11. HTTPS
 
  There are a few ways to do secure HTTP transfers. The by far most common
  protocol for doing this is what is generally known as HTTPS, HTTP over
  SSL. SSL encrypts all the data that is sent and received over the network and
  thus makes it harder for attackers to spy on sensitive information.
@@ -346,22 +355,24 @@
   In the HTTPS world, you use certificates to validate that you are the one
   you you claim to be, as an addition to normal passwords. Curl supports
   client-side certificates. All certificates are locked with a PIN-code, why
   you need to enter the unlock-code before the certificate can be used by
   curl. The PIN-code can be specified on the command line or if not, entered
   interactively when curl queries for it. Use a certificate with curl on a
-  https server like:
+  HTTPS server like:
 
         curl -E mycert.pem https://that.secure.server.com
 
 12. REFERENCES
 
  RFC 2616 is a must to read if you want in-depth understanding of the HTTP
  protocol.
 
- RFC 2396 explains the URL syntax
+ RFC 2396 explains the URL syntax.
 
  RFC 2109 defines how cookies are supposed to work.
 
+ RFC 1867 defines the HTTP post upload format.
+
  http://www.openssl.org is the home of the OpenSSL project
 
  http://curl.haxx.se is the home of the cURL project
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/docs/TODO	2001-09-19 22:48:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs/TODO	2002-06-12 16:16:13.000000000 +0800
@@ -7,91 +7,196 @@
 TODO
 
  Things to do in project cURL. Please tell me what you think, contribute and
  send me patches that improve things! Also check the http://curl.haxx.se/dev
  web section for various development notes.
 
-To do in a future release (random order):
-
- * FTP ASCII upload does not follow RFC959 section 3.1.1.1: 
-    "The sender converts the data from an internal character representation to
-    the standard 8-bit NVT-ASCII representation (see the Telnet
-    specification).  The receiver will convert the data from the standard form
-    to his own internal form."
-
- * Make the connect non-blocking so that timeouts work for connect in 
-   multi-threaded programs 
+ LIBCURL
 
  * Consider an interface to libcurl that allows applications to easier get to
    know what cookies that are sent back in the response headers.
 
- * HTTP PUT for files passed on stdin *OR* when the --crlf option is
-   used. Requires libcurl to send the file with chunked content
-   encoding. http://curl.haxx.se/dev/HTTP-PUT-stdin.txt
+ * Make content encoding/decoding internally be made using a filter system.
 
  * Introduce another callback interface for upload/download that makes one
    less copy of data and thus a faster operation.
-   http://curl.haxx.se/dev/no_copy_callbacks.txt
+   [http://curl.haxx.se/dev/no_copy_callbacks.txt]
 
- * An option to only download remote FTP files if they're newer than the local
-   one is a good idea, and it would fit right into the same syntax as the
-   already working http dito works. It of course requires that 'MDTM' works,
-   and it isn't a standard FTP command.
+ * Add asynchronous name resolving. http://curl.haxx.se/dev/async-resolver.txt
+   This should be made to work on most of the supported platforms, or
+   otherwise it isn't really interesting.
 
- * Suggested on the mailing list: CURLOPT_FTP_MKDIR...!
+ * Data sharing. Tell which easy handles within a multi handle that should
+   share cookies, connection cache, dns cache, ssl session cache.  Full
+   suggestion found here: http://curl.haxx.se/dev/sharing.txt
 
- * Add configure options that disables certain protocols in libcurl to
-   decrease footprint.  '--disable-[protocol]' where protocol is http, ftp,
-   telnet, ldap, dict or file.
+ * Mutexes. By adding mutex callback support, the 'data sharing' mentioned
+   above can be made between several easy handles running in different threads
+   too. The actual mutex implementations will be left for the application to
+   implement, libcurl will merely call 'getmutex' and 'leavemutex' callbacks.
+   Part of the sharing suggestion at: http://curl.haxx.se/dev/sharing.txt
 
- * Extend the test suite to include telnet. The telnet could just do ftp or
-   http operations (for which we have test servers).
+ * No-faster-then-this transfers. Many people have limited bandwidth and they
+   want the ability to make sure their transfers never use more bandwith than
+   they think is good.
 
- * Make TELNET work on windows!
+ * Set the SO_KEEPALIVE socket option to make libcurl notice and disconnect
+   very long time idle connections.
 
- * Make curl's SSL layer option capable of using other free SSL libraries.
-   Such as the Mozilla Security Services
-   (http://www.mozilla.org/projects/security/pki/nss/) and GNUTLS
-   (http://gnutls.hellug.gr/)
+ * Make sure we don't ever loop because of non-blocking sockets return
+   EWOULDBLOCK or similar. This concerns the HTTP request sending (and
+   especially regular HTTP POST), the FTP command sending etc.
+
+ * Go through the code and verify that libcurl deals with big files >2GB and
+   >4GB all over. Bug reports (and source reviews) indicate that it doesn't
+   currently work properly.
+
+ * Make the built-in progress meter use its own dedicated output stream, and
+   make it possible to set it. Use stderr by default.
+
+ * CURLOPT_MAXFILESIZE. Prevent downloads that are larger than the specified
+   size. CURLE_FILESIZE_EXCEEDED would then be returned. Gautam Mani
+   requested.
+
+ DOCUMENTATION
+
+
+ FTP
+
+ * FTP ASCII upload does not follow RFC959 section 3.1.1.1: "The sender
+   converts the data from an internal character representation to the standard
+   8-bit NVT-ASCII representation (see the Telnet specification).  The
+   receiver will convert the data from the standard form to his own internal
+   form."
+
+ * An option to only download remote FTP files if they're newer than the local
+   one is a good idea, and it would fit right into the same syntax as the
+   already working http dito works. It of course requires that 'MDTM' works,
+   and it isn't a standard FTP command.
+
+ * Add FTPS support with SSL for the data connection too.  This should be made
+   according to the specs written in draft-murray-auth-ftp-ssl-08.txt,
+   "Securing FTP with TLS"
 
- * Add asynchronous name resolving, as this enables full timeout support for
-   fork() systems. http://curl.haxx.se/dev/async-resolver.txt
+ HTTP
 
- * Move non-URL related functions that are used by both the lib and the curl
-   application to a separate "portability lib".
+ * HTTP PUT for files passed on stdin *OR* when the --crlf option is
+   used. Requires libcurl to send the file with chunked content
+   encoding. [http://curl.haxx.se/dev/HTTP-PUT-stdin.txt] When the filter
+   system mentioned above gets real, it'll be a piece of cake to add.
 
- * Add libcurl support/interfaces for more languages. C++ wrapper perhaps?
+ * Pass a list of host name to libcurl to which we allow the user name and
+   password to get sent to. Currently, it only get sent to the host name that
+   the first URL uses (to prevent others from being able to read it), but this
+   also prevents the authentication info from getting sent when following
+   locations to legitimate other host names.
 
  * "Content-Encoding: compress/gzip/zlib" HTTP 1.1 clearly defines how to get
    and decode compressed documents. There is the zlib that is pretty good at
    decompressing stuff. This work was started in October 1999 but halted again
    since it proved more work than we thought. It is still a good idea to
-   implement though.
+   implement though. This requires the filter system mentioned above.
 
  * Authentication: NTLM. Support for that MS crap called NTLM
    authentication. MS proxies and servers sometime require that. Since that
    protocol is a proprietary one, it involves reverse engineering and network
    sniffing. This should however be a library-based functionality. There are a
    few different efforts "out there" to make open source HTTP clients support
    this and it should be possible to take advantage of other people's hard
    work. http://modntlm.sourceforge.net/ is one. There's a web page at
    http://www.innovation.ch/java/ntlm.html that contains detailed reverse-
    engineered info.
 
- * RFC2617 compliance, "Digest Access Authentication"
-   A valid test page seem to exist at:
-   http://hopf.math.nwu.edu/testpage/digest/
-   And some friendly person's server source code is available at
-   http://hopf.math.nwu.edu/digestauth/index.html
-   Then there's the Apache mod_digest source code too of course.  It seems as
-   if Netscape doesn't support this, and not many servers do. Although this is
-   a lot better authentication method than the more common "Basic". Basic
-   sends the password in cleartext over the network, this "Digest" method uses
-   a challange-response protocol which increases security quite a lot.
-
- * Other proxies
-   Ftp-kind proxy, Socks5, whatever kind of proxies are there?
-
- * Full IPv6 Awareness and support. (This is partly done.)  RFC 2428 "FTP
-   Extensions for IPv6 and NATs" is interesting. PORT should be replaced with
-   EPRT for IPv6 (done), and EPSV instead of PASV.
+ * RFC2617 compliance, "Digest Access Authentication" A valid test page seem
+   to exist at: http://hopf.math.nwu.edu/testpage/digest/ And some friendly
+   person's server source code is available at
+   http://hopf.math.nwu.edu/digestauth/index.html Then there's the Apache
+   mod_digest source code too of course.  It seems as if Netscape doesn't
+   support this, and not many servers do. Although this is a lot better
+   authentication method than the more common "Basic". Basic sends the
+   password in cleartext over the network, this "Digest" method uses a
+   challange-response protocol which increases security quite a lot.
+
+ * Pipelining. Sending multiple requests before the previous one(s) are done.
+   This could possibly be implemented using the multi interface to queue
+   requests and the response data.
+
+ TELNET
+
+ * Make TELNET work on windows98!
+
+ * Reading input (to send to the remote server) on stdin is a crappy solution
+   for library purposes. We need to invent a good way for the application to
+   be able to provide the data to send.
+
+ * Move the telnet support's network select() loop go away and merge the code
+   into the main transfer loop. Until this is done, the multi interface won't
+   work for telnet.
+
+ SSL
+
+ * If you really want to improve the SSL situation, you should probably have a
+   look at SSL cafile loading as well - quick traces look to me like these are
+   done on every request as well, when they should only be necessary once per
+   ssl context (or once per handle). Even better would be to support the SSL
+   CAdir option - instead of loading all of the root CA certs for every
+   request, this option allows you to only read the CA chain that is actually
+   required (into the cache)...
+
+ * Add an interface to libcurl that enables "session IDs" to get
+   exported/imported. Cris Bailiff said: "OpenSSL has functions which can
+   serialise the current SSL state to a buffer of your choice, and
+   recover/reset the state from such a buffer at a later date - this is used
+   by mod_ssl for apache to implement and SSL session ID cache". This whole
+   idea might become moot if we enable the 'data sharing' as mentioned in the
+   LIBCURL label above.
+
+ * OpenSSL supports a callback for customised verification of the peer
+   certificate, but this doesn't seem to be exposed in the libcurl APIs. Could
+   it be? There's so much that could be done if it were! (brought by Chris
+   Clark)
+
+ * Make curl's SSL layer option capable of using other free SSL libraries.
+   Such as the Mozilla Security Services
+   (http://www.mozilla.org/projects/security/pki/nss/) and GNUTLS
+   (http://gnutls.hellug.gr/)
+
+ LDAP
+
+ * Look over the implementation. The looping will have to "go away" from the
+   lib/ldap.c source file and get moved to the main network code so that the
+   multi interface and friends will work for LDAP as well.
+
+ CLIENT
+
+ * "curl ftp://site.com/*.txt"
+
+ * Several URLs can be specified to get downloaded. We should be able to use
+   the same syntax to specify several files to get uploaded (using the same
+   persistant connection), using -T.
+
+ * When the multi interface has been implemented and proved to work, the
+   client could be told to use maximum N simultaneous transfers and then just
+   make sure that happens. It should of course not make more than one
+   connection to the same remote host.
+
+ * Extending the capabilities of the multipart formposting. How about leaving
+   the ';type=foo' syntax as it is and adding an extra tag (headers) which
+   works like this: curl -F "coolfiles=@fil1.txt;headers=@fil1.hdr" where
+   fil1.hdr contains extra headers like
+
+     Content-Type: text/plain; charset=KOI8-R"
+     Content-Transfer-Encoding: base64
+     X-User-Comment: Please don't use browser specific HTML code
+
+   which should overwrite the program reasonable defaults (plain/text,
+   8bit...) (Idea brough to us by kromJx)
+
+ TEST SUITE
+
+ * Extend the test suite to include more protocols. The telnet could just do
+   ftp or http operations (for which we have test servers).
+
+ * Make the test suite work on more platforms. OpenBSD and Mac OS. Remove
+   fork()s and it should become even more portable.
 
+ * Introduce a test suite that tests libcurl better and more explicitly.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/docs: VERSIONS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/curl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/curl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/curl.h	2001-09-25 14:15:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/curl.h	2002-06-13 22:30:03.000000000 +0800
@@ -4,40 +4,40 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curl.h,v 1.99 2001/09/17 14:10:38 bagder Exp $
+ * $Id: curl.h,v 1.150 2002/06/12 21:40:59 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 /* The include stuff here is mainly for time_t! */
 #ifdef vms
 # include <types.h>
 # include <time.h>
 #else
 # include <sys/types.h>
-# if TIME_WITH_SYS_TIME
+# ifdef TIME_WITH_SYS_TIME
 #  include <sys/time.h>
 #  include <time.h>
 # else
-#  if HAVE_SYS_TIME_H
+#  ifdef HAVE_SYS_TIME_H
 #   include <sys/time.h>
 #  else
 #   include <time.h>
 #  endif
 # endif
 #endif /* defined (vms) */
@@ -52,35 +52,54 @@
 #include <curl/types.h>
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
-struct HttpPost {
-  struct HttpPost *next; /* next entry in the list */
+/* stupid #define trick to preserve functionality with older code, but
+   making it use our name space for the future */
+#define HttpPost curl_httppost
+
+struct curl_httppost {
+  struct curl_httppost *next; /* next entry in the list */
   char *name;     /* pointer to allocated name */
   long namelength; /* length of name length */
   char *contents; /* pointer to allocated data contents */
   long contentslength; /* length of contents field */
+
+	/* CMC: Added support for buffer uploads */
+	char *buffer; /* pointer to allocated buffer contents */
+	long bufferlength; /* length of buffer field */
+
   char *contenttype; /* Content-Type */
-  struct HttpPost *more; /* if one field name has more than one file, this
-			    link should link to following files */
+  struct curl_slist* contentheader; /* list of extra headers for this form */
+  struct curl_httppost *more; /* if one field name has more than one file, this
+                                 link should link to following files */
   long flags;     /* as defined below */
 #define HTTPPOST_FILENAME (1<<0) /* specified content is a file name */
 #define HTTPPOST_READFILE (1<<1) /* specified content is a file name */
 #define HTTPPOST_PTRNAME (1<<2) /* name is only stored pointer
                                    do not free in formfree */
 #define HTTPPOST_PTRCONTENTS (1<<3) /* contents is only stored pointer
                                        do not free in formfree */
+
+/* CMC: Added support for buffer uploads */
+#define HTTPPOST_BUFFER (1<<4) /* upload file from buffer */
+#define HTTPPOST_PTRBUFFER (1<<5) /* upload file from pointer contents */
+
+  char *showfilename; /* The file name to show. If not set, the actual
+                         file name will be used (if this is a file part) */
 };
 
 typedef int (*curl_progress_callback)(void *clientp,
-                                      size_t dltotal,
-                                      size_t dlnow,
-                                      size_t ultotal,
-                                      size_t ulnow);
+                                      double dltotal,
+                                      double dlnow,
+                                      double ultotal,
+                                      double ulnow);
+
+#define CURL_MAX_WRITE_SIZE 20480
 
 typedef size_t (*curl_write_callback)(char *buffer,
                                       size_t size,
                                       size_t nitems,
                                       void *outstream);
 
@@ -91,12 +110,29 @@
 
 typedef int (*curl_passwd_callback)(void *clientp,
                                     const char *prompt,
                                     char *buffer,
                                     int buflen);
 
+/* the kind of data that is passed to information_callback*/
+typedef enum {
+  CURLINFO_TEXT = 0,
+  CURLINFO_HEADER_IN,    /* 1 */
+  CURLINFO_HEADER_OUT,   /* 2 */
+  CURLINFO_DATA_IN,      /* 3 */
+  CURLINFO_DATA_OUT,     /* 4 */
+  CURLINFO_END
+} curl_infotype;
+
+typedef int (*curl_debug_callback)
+       (CURL *handle,      /* the handle/transfer this concerns */
+        curl_infotype type, /* what kind of data */
+        char *data,        /* points to the data */
+        size_t size,       /* size of the data pointed to */
+        void *userp);      /* whatever the user please */
+  
 /* All possible error codes from all sorts of curl functions. Future versions
    may return other values, stay prepared.
 
    Always add new return codes last. Never *EVER* remove any. The return
    codes must remain the same!
  */
@@ -151,13 +187,18 @@
   CURLE_BAD_PASSWORD_ENTERED,    /* 46 - my_getpass() returns fail */
   CURLE_TOO_MANY_REDIRECTS ,     /* 47 - catch endless re-direct loops */
   CURLE_UNKNOWN_TELNET_OPTION,   /* 48 - User specified an unknown option */
   CURLE_TELNET_OPTION_SYNTAX ,   /* 49 - Malformed telnet option */
   CURLE_OBSOLETE,	         /* 50 - removed after 7.7.3 */
   CURLE_SSL_PEER_CERTIFICATE,    /* 51 - peer's certificate wasn't ok */
-  
+  CURLE_GOT_NOTHING,             /* 52 - when this is a specific error */
+  CURLE_SSL_ENGINE_NOTFOUND,     /* 53 - SSL crypto engine not found */
+  CURLE_SSL_ENGINE_SETFAILED,    /* 54 - can not set SSL crypto engine as default */
+  CURLE_SEND_ERROR,              /* 55 - failed sending network data */
+  CURLE_RECV_ERROR,              /* 56 - failure in receiving network data */
+
   CURL_LAST /* never use! */
 } CURLcode;
 
 /* this was the error code 50 in 7.7.3 and a few earlier versions, this
    is no longer used by libcurl but is instead #defined here only to not
    make programs break */
@@ -165,25 +206,33 @@
 
 /* This is just to make older programs not break: */
 #define CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE
 
 #define CURL_ERROR_SIZE 256
 
+/* long may be 32 or 64 bits, but we should never depend on anything else
+   but 32 */
+#define CURLOPTTYPE_LONG          0
+#define CURLOPTTYPE_OBJECTPOINT   10000
+#define CURLOPTTYPE_FUNCTIONPOINT 20000
+
 /* name is uppercase CURLOPT_<name>,
    type is one of the defined CURLOPTTYPE_<type>
    number is unique identifier */
 #ifdef CINIT
 #undef CINIT
 #endif
+#if defined(__STDC__) || defined(_MSC_VER)
 #define CINIT(name,type,number) CURLOPT_ ## name = CURLOPTTYPE_ ## type + number
-
-/* long may be 32 or 64 bits, but we should never depend on anything else
-   but 32 */
-#define CURLOPTTYPE_LONG          0
-#define CURLOPTTYPE_OBJECTPOINT   10000
-#define CURLOPTTYPE_FUNCTIONPOINT 20000
+#else
+/* The macro "##" is ISO C, we assume pre-ISO C doesn't support it. */
+#define LONG          CURLOPTTYPE_LONG
+#define OBJECTPOINT   CURLOPTTYPE_OBJECTPOINT
+#define FUNCTIONPOINT CURLOPTTYPE_FUNCTIONPOINT
+#define CINIT(name,type,number) CURLOPT_/**/name = type + number
+#endif
 
 typedef enum {
   CINIT(NOTHING, LONG, 0), /********* the first one is unused ************/
   
   /* This is the FILE * or void * the regular output should be written to. */
   CINIT(FILE, OBJECTPOINT, 1),
@@ -208,16 +257,14 @@
   CINIT(PROXYUSERPWD, OBJECTPOINT, 6),
 
   /* Range to get, specified as an ASCII string. Specify the CONF_RANGE flag
      in the CURLOPT_FLAGS to activate this */
   CINIT(RANGE, OBJECTPOINT, 7),
 
-#if 0
-  /* Configuration flags */
-  CINIT(FLAGS, LONG, 8),
-#endif
+  /* not used */
+
   /* Specified file stream to upload from (use as input): */
   CINIT(INFILE, OBJECTPOINT, 9),
 
   /* Buffer to receive error messages in, must be at least CURL_ERROR_SIZE
    * bytes big. If this is not used, error messages go to stderr instead: */
   CINIT(ERRORBUFFER, OBJECTPOINT, 10),
@@ -267,23 +314,25 @@
   /* Set the continuation offset */
   CINIT(RESUME_FROM, LONG, 21),
 
   /* Set cookie in request: */
   CINIT(COOKIE, OBJECTPOINT, 22),
 
-  /* This points to a linked list of headers, struct HttpHeader kind */
+  /* This points to a linked list of headers, struct curl_slist kind */
   CINIT(HTTPHEADER, OBJECTPOINT, 23),
 
   /* This points to a linked list of post entries, struct HttpPost */
   CINIT(HTTPPOST, OBJECTPOINT, 24),
 
   /* name of the file keeping your private SSL-certificate */
   CINIT(SSLCERT, OBJECTPOINT, 25),
 
-  /* password for the SSL-certificate */
+  /* password for the SSL-private key, keep this for compatibility */
   CINIT(SSLCERTPASSWD, OBJECTPOINT, 26),
+  /* password for the SSL private key */
+  CINIT(SSLKEYPASSWD, OBJECTPOINT, 26),
   
   /* send TYPE parameter? */
   CINIT(CRLF, LONG, 27),
 
   /* send linked-list of QUOTE commands */
   CINIT(QUOTE, OBJECTPOINT, 28),
@@ -294,13 +343,13 @@
 
   /* point to a file to read the initial cookies from, also enables
      "cookie awareness" */
   CINIT(COOKIEFILE, OBJECTPOINT, 31),
 
   /* What version to specifly try to use.
-     3 = SSLv3, 2 = SSLv2, all else makes it try v3 first then v2 */
+     See CURL_SSLVERSION defines below. */
   CINIT(SSLVERSION, LONG, 32),
 
   /* What kind of HTTP time condition to use, see defines */
   CINIT(TIMECONDITION, LONG, 33),
 
   /* Time to use with the above condition. Specified in number of seconds
@@ -317,17 +366,14 @@
      */
   CINIT(CUSTOMREQUEST, OBJECTPOINT, 36),
 
   /* HTTP request, for odd commands like DELETE, TRACE and others */
   CINIT(STDERR, OBJECTPOINT, 37),
 
-#if 0
-  /* Progress mode set alternative progress mode displays. Alternative
-     ones should now be made by the client, not the lib! */     
-  CINIT(PROGRESSMODE, LONG, 38),
-#endif
+  /* 38 is not used */
+
   /* send linked-list of post-transfer QUOTE commands */
   CINIT(POSTQUOTE, OBJECTPOINT, 39),
 
   /* Pass a pointer to string of the output using full variable-replacement
      as described elsewhere. */
   CINIT(WRITEINFO, OBJECTPOINT, 40),
@@ -340,13 +386,17 @@
   CINIT(FAILONERROR, LONG, 45),  /* no output on http error codes >= 300 */
   CINIT(UPLOAD, LONG, 46),       /* this is an upload */
   CINIT(POST, LONG, 47),         /* HTTP POST method */
   CINIT(FTPLISTONLY, LONG, 48),  /* Use NLST when listing ftp dir */
 
   CINIT(FTPAPPEND, LONG, 50),    /* Append instead of overwrite on upload! */
-  CINIT(NETRC, LONG, 51),        /* read user+password from .netrc */
+
+  /* Specify whether to read the user+password from the .netrc or the URL.
+   * This must be one of the CURL_NETRC_* enums below. */
+  CINIT(NETRC, LONG, 51),
+
   CINIT(FOLLOWLOCATION, LONG, 52),  /* use Location: Luke! */
 
   /* This FTPASCII name is now obsolete, to be removed, use the TRANSFERTEXT
      instead. It goes for more protocols than just ftp... */
   CINIT(FTPASCII, LONG, 53),     /* use TYPE A for transfer */
 
@@ -457,25 +507,122 @@
   /* Specify which file name to write all known cookies in after completed
      operation. Set file name to "-" (dash) to make it go to stdout. */
   CINIT(COOKIEJAR, OBJECTPOINT, 82),
 
   /* Specify which SSL ciphers to use */
   CINIT(SSL_CIPHER_LIST, OBJECTPOINT, 83),
+
+  /* Specify which HTTP version to use! This must be set to one of the
+     CURL_HTTP_VERSION* enums set below. */
+  CINIT(HTTP_VERSION, LONG, 84),
+
+  /* Specificly switch on or off the FTP engine's use of the EPSV command. By
+     default, that one will always be attempted before the more traditional
+     PASV command. */     
+  CINIT(FTP_USE_EPSV, LONG, 85),
+
+  /* type of the file keeping your SSL-certificate ("DER", "PEM", "ENG") */
+  CINIT(SSLCERTTYPE, OBJECTPOINT, 86),
+
+  /* name of the file keeping your private SSL-key */
+  CINIT(SSLKEY, OBJECTPOINT, 87),
+
+  /* type of the file keeping your private SSL-key ("DER", "PEM", "ENG") */
+  CINIT(SSLKEYTYPE, OBJECTPOINT, 88),
+
+  /* crypto engine for the SSL-sub system */
+  CINIT(SSLENGINE, OBJECTPOINT, 89),
+
+  /* set the crypto engine for the SSL-sub system as default
+     the param has no meaning...
+   */
+  CINIT(SSLENGINE_DEFAULT, LONG, 90),
+
+  /* Non-zero value means to use the global dns cache */
+  CINIT(DNS_USE_GLOBAL_CACHE, LONG, 91),
+
+  /* DNS cache timeout */
+  CINIT(DNS_CACHE_TIMEOUT, LONG, 92),
+
+  /* send linked-list of pre-transfer QUOTE commands (Wesley Laxton)*/
+  CINIT(PREQUOTE, OBJECTPOINT, 93),
+
+  /* set the debug function */
+  CINIT(DEBUGFUNCTION, FUNCTIONPOINT, 94),
+
+  /* set the data for the debug function */
+  CINIT(DEBUGDATA, OBJECTPOINT, 95),
+
+  /* mark this as start of a cookie session */
+  CINIT(COOKIESESSION, LONG, 96),
+
+  /* The CApath directory used to validate the peer certificate
+     this option is used only if SSL_VERIFYPEER is true */
+  CINIT(CAPATH, OBJECTPOINT, 97),
   
   CURLOPT_LASTENTRY /* the last unusued */
 } CURLoption;
 
-typedef enum {
-  TIMECOND_NONE,
+  /* two convenient "aliases" that follow the name scheme better */
+#define CURLOPT_WRITEDATA CURLOPT_FILE
+#define CURLOPT_READDATA  CURLOPT_INFILE 
+
+
+  /* These enums are for use with the CURLOPT_HTTP_VERSION option. */
+enum {
+  CURL_HTTP_VERSION_NONE, /* setting this means we don't care, and that we'd
+                             like the library to choose the best possible
+                             for us! */
+  CURL_HTTP_VERSION_1_0,  /* please use HTTP 1.0 in the request */
+  CURL_HTTP_VERSION_1_1,  /* please use HTTP 1.1 in the request */
+  
+  CURL_HTTP_VERSION_LAST /* *ILLEGAL* http version */
+};
+
+  /* These enums are for use with the CURLOPT_NETRC option. */
+enum CURL_NETRC_OPTION {
+  CURL_NETRC_IGNORED,     /* The .netrc will never be read.
+                           * This is the default. */
+  CURL_NETRC_OPTIONAL,    /* A user:password in the URL will be preferred
+                           * to one in the .netrc. */
+  CURL_NETRC_REQUIRED,    /* A user:password in the URL will be ignored.
+                           * Unless one is set programmatically, the .netrc
+                           * will be queried. */
+  CURL_NETRC_LAST
+};
+
+enum {
+  CURL_SSLVERSION_DEFAULT,
+  CURL_SSLVERSION_TLSv1,
+  CURL_SSLVERSION_SSLv2,
+  CURL_SSLVERSION_SSLv3,
+
+  CURL_SSLVERSION_LAST /* never use, keep last */
+};
 
-  TIMECOND_IFMODSINCE,
-  TIMECOND_IFUNMODSINCE,
-  TIMECOND_LASTMOD,
 
-  TIMECOND_LAST
-} TimeCond;
+typedef enum {
+  CURL_TIMECOND_NONE,
+
+  CURL_TIMECOND_IFMODSINCE,
+  CURL_TIMECOND_IFUNMODSINCE,
+  CURL_TIMECOND_LASTMOD,
+
+  CURL_TIMECOND_LAST
+} curl_TimeCond;
+
+/* for backwards compatibility */
+#ifndef TIMECOND_IFMODSINCE
+#define TIMECOND_IFMODSINCE CURL_TIMECOND_IFMODSINCE
+#endif
+#ifndef TIMECOND_IFUNMODSINCE
+#define TIMECOND_IFUNMODSINCE CURL_TIMECOND_IFUNMODSINCE
+#endif
+#ifndef TIMECOND_LASTMOD
+#define TIMECOND_LASTMOD CURL_TIMECOND_LASTMOD
+#endif
 
 #ifdef __BEOS__
 #include <support/SupportDefs.h>
 #endif
 
 
@@ -488,47 +635,99 @@
  */
 extern int (curl_strequal)(const char *s1, const char *s2);
 extern int (curl_strnequal)(const char *s1, const char *s2, size_t n);
 #define strequal(a,b) curl_strequal(a,b)
 #define strnequal(a,b,c) curl_strnequal(a,b,c)
 
-/* external form function */
-int curl_formparse(char *string,
-                   struct HttpPost **httppost,
-                   struct HttpPost **last_post);
+/* DEPRECATED function to build formdata */
+int curl_formparse(char *, struct curl_httppost **,
+                   struct curl_httppost **_post);
 
 /* name is uppercase CURLFORM_<name> */
 #ifdef CFINIT
 #undef CFINIT
 #endif
+
+#if defined(__STDC__) || defined(_MSC_VER)
 #define CFINIT(name) CURLFORM_ ## name
+#else
+/* The macro "##" is ISO C, we assume pre-ISO C doesn't support it. */
+#define CFINIT(name) CURLFORM_/**/name
+#endif
 
 typedef enum {
   CFINIT(NOTHING),        /********* the first one is unused ************/
   
   /*  */
   CFINIT(COPYNAME),
   CFINIT(PTRNAME),
   CFINIT(NAMELENGTH),
   CFINIT(COPYCONTENTS),
   CFINIT(PTRCONTENTS),
   CFINIT(CONTENTSLENGTH),
+  CFINIT(FILECONTENT),
+  CFINIT(ARRAY),
+  CFINIT(OBSOLETE),
   CFINIT(FILE),
+
+  CFINIT(BUFFER),
+  CFINIT(BUFFERPTR),
+  CFINIT(BUFFERLENGTH),
+
   CFINIT(CONTENTTYPE),
+  CFINIT(CONTENTHEADER),
+  CFINIT(FILENAME),
   CFINIT(END),
+  CFINIT(OBSOLETE2),
 
   CURLFORM_LASTENTRY /* the last unusued */
 } CURLformoption;
 
-/* new external form function */
-int curl_formadd(struct HttpPost **httppost,
-                 struct HttpPost **last_post,
+#undef CFINIT /* done */
+
+/* structure to be used as parameter for CURLFORM_ARRAY */
+struct curl_forms {
+	CURLformoption		option;
+	const char		*value;
+};
+
+/* use this for multipart formpost building */
+/* Returns code for curl_formadd()
+ * 
+ * Returns:
+ * CURL_FORMADD_OK             on success
+ * CURL_FORMADD_MEMORY         if the FormInfo allocation fails
+ * CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form
+ * CURL_FORMADD_NULL           if a null pointer was given for a char
+ * CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed
+ * CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used
+ * CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or error)
+ * CURL_FORMADD_MEMORY         if a HttpPost struct cannot be allocated
+ * CURL_FORMADD_MEMORY         if some allocation for string copying failed.
+ * CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array
+ *
+ ***************************************************************************/
+typedef enum {
+  CURL_FORMADD_OK, /* first, no error */
+
+  CURL_FORMADD_MEMORY,
+  CURL_FORMADD_OPTION_TWICE,
+  CURL_FORMADD_NULL,
+  CURL_FORMADD_UNKNOWN_OPTION,
+  CURL_FORMADD_INCOMPLETE,
+  CURL_FORMADD_ILLEGAL_ARRAY,
+
+  CURL_FORMADD_LAST /* last */
+} CURLFORMcode;
+
+CURLFORMcode curl_formadd(struct curl_httppost **httppost,
+                 struct curl_httppost **last_post,
                  ...);
 
 /* cleanup a form: */
-void curl_formfree(struct HttpPost *form);
+void curl_formfree(struct curl_httppost *form);
 
 /* Unix and Win32 getenv function call, this returns a malloc()'ed string that
    MUST be free()ed after usage is complete. */
 char *curl_getenv(const char *variable);
 
 /* Returns a static ascii string of the libcurl version. */
@@ -545,14 +744,14 @@
 
 /* curl_global_cleanup() should be invoked exactly once for each application
    that uses libcurl */
 void curl_global_cleanup(void);
 
 /* This is the version number */
-#define LIBCURL_VERSION "7.9"
-#define LIBCURL_VERSION_NUM 0x070900
+#define LIBCURL_VERSION "7.9.8"
+#define LIBCURL_VERSION_NUM 0x070908
 
 /* linked-list structure for the CURLOPT_QUOTE option (and other) */
 struct curl_slist {
 	char			*data;
 	struct curl_slist	*next;
 };
@@ -596,18 +795,28 @@
   CURLINFO_SSL_VERIFYRESULT = CURLINFO_LONG   + 13,
   CURLINFO_FILETIME         = CURLINFO_LONG   + 14,
 
   CURLINFO_CONTENT_LENGTH_DOWNLOAD   = CURLINFO_DOUBLE + 15,
   CURLINFO_CONTENT_LENGTH_UPLOAD     = CURLINFO_DOUBLE + 16,
 
-  CURLINFO_LASTONE          = 17
+  CURLINFO_STARTTRANSFER_TIME = CURLINFO_DOUBLE + 17,
+
+  CURLINFO_CONTENT_TYPE = CURLINFO_STRING + 18,
+
+  CURLINFO_REDIRECT_TIME   = CURLINFO_DOUBLE + 19,
+  CURLINFO_REDIRECT_COUNT  = CURLINFO_LONG + 20,
+
+  /* Fill in new entries here! */
+
+  CURLINFO_LASTONE          = 21
 } CURLINFO;
 
-/* unfortunately, the easy.h include file needs the options and info stuff
-   before it can be included! */
+/* unfortunately, the easy.h and multi.h include files need options and info
+  stuff before they can be included! */
 #include <curl/easy.h> /* nothing in curl is fun without the easy stuff */
+#include <curl/multi.h>
 
 typedef enum {
   CURLCLOSEPOLICY_NONE, /* first, never use this */
 
   CURLCLOSEPOLICY_OLDEST,
   CURLCLOSEPOLICY_LEAST_RECENTLY_USED,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/easy.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/easy.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/easy.h	2001-09-13 22:50:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/easy.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: easy.h,v 1.5 2001/09/13 14:50:04 bagder Exp $
+ * $Id: easy.h,v 1.6 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
 CURL *curl_easy_init(void);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/Makefile.am	2000-08-01 06:24:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/Makefile.am	2002-03-19 18:34:47.000000000 +0800
@@ -1,7 +1,8 @@
 pkginclude_HEADERS = \
 	curl.h \
 	easy.h \
 	mprintf.h \
 	stdcheaders.h \
-	types.h
+	types.h \
+	multi.h
 pkgincludedir= $(includedir)/curl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/Makefile.in	2001-09-12 19:56:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/Makefile.in	2002-06-11 23:22:15.000000000 +0800
@@ -57,12 +57,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -91,17 +98,20 @@
 
 pkginclude_HEADERS = \
 	curl.h \
 	easy.h \
 	mprintf.h \
 	stdcheaders.h \
-	types.h
+	types.h \
+	multi.h
 
 subdir = include/curl
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 HEADERS = $(pkginclude_HEADERS)
 
 DIST_COMMON = $(pkginclude_HEADERS) Makefile.am Makefile.in
 all: all-am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl: multi.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/stdcheaders.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/stdcheaders.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/stdcheaders.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/stdcheaders.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: stdcheaders.h,v 1.3 2001/01/03 09:29:34 bagder Exp $
+ * $Id: stdcheaders.h,v 1.4 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/types.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/types.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/curl/types.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/curl/types.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,25 +4,25 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: types.h,v 1.3 2001/01/03 09:29:34 bagder Exp $
+ * $Id: types.h,v 1.4 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 typedef void CURL;
 typedef void CURLconnect;
 
 #endif /* __CURL_TYPES_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/include/Makefile.in	2001-09-12 19:56:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/include/Makefile.in	2002-06-11 23:22:12.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -93,13 +100,15 @@
 
 EXTRA_DIST = README
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 subdir = include
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 depcomp =
 DIST_SOURCES =
 
 RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
 	uninstall-info-recursive all-recursive install-data-recursive \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/LEGAL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/LEGAL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/LEGAL	2001-01-03 17:18:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/LEGAL	2001-12-03 18:00:06.000000000 +0800
@@ -1,7 +1,7 @@
- Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ Copyright (C) 1998-2001, Daniel Stenberg, <daniel@haxx.se>, et al.
 
  Everyone is permitted to copy and distribute verbatim copies of this license
  document, but changing it is not allowed.
 
  In order to be useful for every potential user, the curl and libcurl are
  dual-licensed under the MPL and the MIT/X-derivate licenses.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/arpa_telnet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/arpa_telnet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/arpa_telnet.h	2001-08-14 16:16:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/arpa_telnet.h	2002-06-11 19:13:01.000000000 +0800
@@ -4,28 +4,28 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: arpa_telnet.h,v 1.4 2001/08/14 08:16:53 bagder Exp $
+ * $Id: arpa_telnet.h,v 1.7 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
-
+#ifndef CURL_DISABLE_TELNET
 /*
  * Telnet option defines. Add more here if in need.
  */
 #define TELOPT_BINARY   0  /* binary 8bit data */
 #define TELOPT_SGA      3  /* Supress Go Ahead */
 #define TELOPT_EXOPL  255  /* EXtended OPtions List */
@@ -39,13 +39,13 @@
 /*
  * The telnet options represented as strings
  */
 static const char *telnetoptions[]=
 {
   "BINARY",      "ECHO",           "RCP",           "SUPPRESS GO AHEAD",
-  "NAME",        "STATUS"          "TIMING MARK",   "RCTE",
+  "NAME",        "STATUS",         "TIMING MARK",   "RCTE",
   "NAOL",        "NAOP",           "NAOCRD",        "NAOHTS",
   "NAOHTD",      "NAOFFD",         "NAOVTS",        "NAOVTD",
   "NAOLFD",      "EXTEND ASCII",   "LOGOUT",        "BYTE MACRO",
   "DE TERMINAL", "SUPDUP",         "SUPDUP OUTPUT", "SEND LOCATION",
   "TERM TYPE",   "END OF RECORD",  "TACACS UID",    "OUTPUT MARKING",
   "TTYLOC",      "3270 REGIME",    "X3 PAD",        "NAWS",
@@ -94,8 +94,8 @@
 #define TELQUAL_INFO 2
 #define TELQUAL_NAME 3
 
 #define TELCMD_OK(x) ( ((unsigned int)(x) >= TELCMD_MINIMUM) && \
                        ((unsigned int)(x) <= TELCMD_MAXIMUM) )
 #define TELCMD(x)    telnetcmds[(x)-TELCMD_MINIMUM]
-
+#endif
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/base64.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/base64.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/base64.c	2001-09-07 14:05:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/base64.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Andrew Francis and Daniel Stenberg
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: base64.c,v 1.11 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: base64.c,v 1.13 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 /* Base64 encoding/decoding
  *
  * Test harnesses down the bottom - compile with -DTEST_ENCODE for
  * a program that will read in raw data from stdin and write out
@@ -262,9 +262,9 @@
 
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/base64.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/base64.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/base64.h	2001-08-03 21:52:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/base64.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,24 +4,24 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: base64.h,v 1.7 2001/08/03 13:52:06 bagder Exp $
+ * $Id: base64.h,v 1.8 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 int Curl_base64_encode(const void *data, int size, char **str);
 int Curl_base64_decode(const char *str, void *data);
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: config.h.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: config-mac.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: config-riscos.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: config-vms.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: config-win32.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: connect.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: connect.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/cookie.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/cookie.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/cookie.c	2001-09-10 15:43:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/cookie.c	2002-06-11 19:13:01.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: cookie.c,v 1.20 2001/09/10 07:43:08 bagder Exp $
+ * $Id: cookie.c,v 1.36 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
 
 /***
 
 
 RECEIVING COOKIE INFORMATION
@@ -76,12 +76,14 @@
     Session_Key@6791a9e0-901a-11d0-a1c8-9b012c88aa77=none;expires=Monday,
     13-Jun-1988 03:04:55 GMT; domain=.fidelity.com; path=/; secure
 ****/
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_HTTP
+
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 
 #include "cookie.h"
 #include "getdate.h"
@@ -90,24 +92,40 @@
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
+static void
+free_cookiemess(struct Cookie *co)
+{
+  if(co->domain)
+    free(co->domain);
+  if(co->path)
+    free(co->path);
+  if(co->name)
+    free(co->name);
+  if(co->value)
+    free(co->value);
+
+  free(co);
+}
+
 /****************************************************************************
  *
  * Curl_cookie_add()
  *
  * Add a single cookie line to the cookie keeping object.
  *
  ***************************************************************************/
 
 struct Cookie *
 Curl_cookie_add(struct CookieInfo *c,
                 bool httpheader, /* TRUE if HTTP header-style line */
-                char *lineptr) /* first non-space of the line */
+                char *lineptr,   /* first non-space of the line */
+                char *domain)    /* default domain */
 {
   struct Cookie *clist;
   char what[MAX_COOKIE_LINE];
   char name[MAX_NAME];
   char *ptr;
   char *semiptr;
@@ -123,53 +141,76 @@
 
   /* clear the whole struct first */
   memset(co, 0, sizeof(struct Cookie));
 	    
   if(httpheader) {
     /* This line was read off a HTTP-header */
-
+    char *sep;
     semiptr=strchr(lineptr, ';'); /* first, find a semicolon */
     ptr = lineptr;
     do {
       /* we have a <what>=<this> pair or a 'secure' word here */
-      if(strchr(ptr, '=')) {
+      sep = strchr(ptr, '=');
+      if(sep && (!semiptr || (semiptr>sep)) ) {
+        /*
+         * There is a = sign and if there was a semicolon too, which make sure
+         * that the semicolon comes _after_ the equal sign.
+         */
+
         name[0]=what[0]=0; /* init the buffers */
-        if(1 <= sscanf(ptr, "%" MAX_NAME_TXT "[^=]=%"
+        if(1 <= sscanf(ptr, "%" MAX_NAME_TXT "[^;=]=%"
                        MAX_COOKIE_LINE_TXT "[^;\r\n]",
                        name, what)) {
-          /* this is a legal <what>=<this> pair */
+          /* this is a <name>=<what> pair */
+
+          char *whatptr;
+
+          /* Strip off trailing whitespace from the 'what' */
+          int len=strlen(what);
+          while(len && isspace((int)what[len-1])) {
+            what[len-1]=0;
+            len--;
+          }
+
+          /* Skip leading whitespace from the 'what' */
+          whatptr=what;
+          while(isspace((int)*whatptr)) {
+            whatptr++;
+          }
+
           if(strequal("path", name)) {
-            co->path=strdup(what);
+            co->path=strdup(whatptr);
           }
           else if(strequal("domain", name)) {
-            co->domain=strdup(what);
+            co->domain=strdup(whatptr);
+            co->field1= (whatptr[0]=='.')?2:1;
           }
           else if(strequal("version", name)) {
-            co->version=strdup(what);
+            co->version=strdup(whatptr);
           }
           else if(strequal("max-age", name)) {
             /* Defined in RFC2109:
 
                Optional.  The Max-Age attribute defines the lifetime of the
                cookie, in seconds.  The delta-seconds value is a decimal non-
                negative integer.  After delta-seconds seconds elapse, the
                client should discard the cookie.  A value of zero means the
                cookie should be discarded immediately.
 
              */
-            co->maxage = strdup(what);
+            co->maxage = strdup(whatptr);
             co->expires =
-              atoi((*co->maxage=='\"')?&co->maxage[1]:&co->maxage[0]);
+              atoi((*co->maxage=='\"')?&co->maxage[1]:&co->maxage[0]) + now;
           }
           else if(strequal("expires", name)) {
-            co->expirestr=strdup(what);
+            co->expirestr=strdup(whatptr);
             co->expires = curl_getdate(what, &now);
           }
           else if(!co->name) {
             co->name = strdup(name);
-            co->value = strdup(what);
+            co->value = strdup(whatptr);
           }
           /*
             else this is the second (or more) name we don't know
             about! */
         }
         else {
@@ -183,20 +224,46 @@
             co->secure = TRUE;
           /* else,
              unsupported keyword without assign! */
 
         }
       }
-      if(!semiptr)
-        continue; /* we already know there are no more cookies */
+      if(!semiptr || !*semiptr) {
+        /* we already know there are no more cookies */
+        semiptr = NULL;
+        continue;
+      }
 
       ptr=semiptr+1;
       while(ptr && *ptr && isspace((int)*ptr))
         ptr++;
       semiptr=strchr(ptr, ';'); /* now, find the next semicolon */
+
+      if(!semiptr && *ptr)
+        /* There are no more semicolons, but there's a final name=value pair
+           coming up */
+        semiptr=strchr(ptr, '\0');
     } while(semiptr);
+
+    if(NULL == co->name) {
+      /* we didn't get a cookie name, this is an illegal line, bail out */
+      if(co->domain)
+        free(co->domain);
+      if(co->path)
+        free(co->path);
+      if(co->name)
+        free(co->name);
+      if(co->value)
+        free(co->value);
+      free(co);
+      return NULL;
+    }
+
+    if(NULL == co->domain)
+      /* no domain given in the header line, set the default now */
+      co->domain=domain?strdup(domain):NULL;
   }
   else {
     /* This line is NOT a HTTP header style line, we do offer support for
        reading the odd netscape cookies-file format here */
     char *firstptr;
     char *tok_buf;
@@ -273,28 +340,25 @@
       }
     }
 
     if(7 != fields) {
       /* we did not find the sufficient number of fields to recognize this
          as a valid line, abort and go home */
-
-      if(co->domain)
-        free(co->domain);
-      if(co->path)
-        free(co->path);
-      if(co->name)
-        free(co->name);
-      if(co->value)
-        free(co->value);
-
-      free(co);
+      free_cookiemess(co);
       return NULL;
     }
 
   }
 
+  if(!c->running &&    /* read from a file */
+     c->newsession &&  /* clean session cookies */
+     !co->expires) {   /* this is a session cookie since it doesn't expire! */
+    free_cookiemess(co);
+    return NULL;
+  }
+
   co->livecookie = c->running;
 
   /* now, we have parsed the incoming line, we must now check if this
      superceeds an already existing cookie, which it may if the previous have
      the same domain and path as this */
 
@@ -302,13 +366,19 @@
   replace_old = FALSE;
   while(clist) {
     if(strequal(clist->name, co->name)) {
       /* the names are identical */
 
       if(clist->domain && co->domain) {
-        if(strequal(clist->domain, co->domain))
+        if(strequal(clist->domain, co->domain) ||
+           (clist->domain[0]=='.' &&
+            strequal(&(clist->domain[1]), co->domain)) ||
+           (co->domain[0]=='.' &&
+            strequal(clist->domain, &(co->domain[1]))) )
+          /* The domains are identical, or at least identical if you skip the
+             preceeding dot */
           replace_old=TRUE;
       }
       else if(!clist->domain && !co->domain)
         replace_old = TRUE;
 
       if(replace_old) {
@@ -366,14 +436,24 @@
         if(clist->version)
           free(clist->version);
         if(clist->maxage)
           free(clist->maxage);
 
         *clist = *co;  /* then store all the new data */
-      }
 
+        free(co);   /* free the newly alloced memory */
+        co = clist; /* point to the previous struct instead */
+
+        /* We have replaced a cookie, now skip the rest of the list but
+           make sure the 'lastc' pointer is properly set */
+        do {
+          lastc = clist;
+          clist = clist->next;
+        } while(clist);
+        break;
+      }
     }
     lastc = clist;
     clist = clist->next;
   }
 
   if(!replace_old) {
@@ -393,14 +473,18 @@
  *
  * Curl_cookie_init()
  *
  * Inits a cookie struct to read data from a local file. This is always
  * called before any cookies are set. File may be NULL.
  *
+ * If 'newsession' is TRUE, discard all "session cookies" on read from file.
+ *
  ****************************************************************************/
-struct CookieInfo *Curl_cookie_init(char *file, struct CookieInfo *inc)
+struct CookieInfo *Curl_cookie_init(char *file,
+                                    struct CookieInfo *inc,
+                                    bool newsession)
 {
   char line[MAX_COOKIE_LINE];
   struct CookieInfo *c;
   FILE *fp;
   bool fromfile=TRUE;
   
@@ -415,19 +499,21 @@
   else {
     /* we got an already existing one, use that */
     c = inc;
   }
   c->running = FALSE; /* this is not running, this is init */
 
-  if(strequal(file, "-")) {
+  if(file && strequal(file, "-")) {
     fp = stdin;
     fromfile=FALSE;
   }
   else
     fp = file?fopen(file, "r"):NULL;
 
+  c->newsession = newsession; /* new session? */
+
   if(fp) {
     char *lineptr;
     bool headerline;
     while(fgets(line, MAX_COOKIE_LINE, fp)) {
       if(strnequal("Set-Cookie:", line, 11)) {
         /* This is a cookie line, get it! */
@@ -438,19 +524,19 @@
         lineptr=line;
         headerline=FALSE;
       }
       while(*lineptr && isspace((int)*lineptr))
         lineptr++;
 
-      Curl_cookie_add(c, headerline, lineptr);
+      Curl_cookie_add(c, headerline, lineptr, NULL);
     }
     if(fromfile)
       fclose(fp);
   }
 
-  c->running = TRUE; /* now, we're running */
+  c->running = TRUE;          /* now, we're running */
 
   return c;
 }
 
 /*****************************************************************************
  *
@@ -616,32 +702,32 @@
       return 1; /* failure */
   }
 
   if(c) {
     fputs("# Netscape HTTP Cookie File\n"
           "# http://www.netscape.com/newsref/std/cookie_spec.html\n"
-          "# This is generated by libcurl! Edit on your own risk.\n\n",
+          "# This file was generated by libcurl! Edit at your own risk.\n\n",
           out);
     co = c->cookies;
      
     while(co) {
       fprintf(out,
               "%s\t" /* domain */
               "%s\t" /* field1 */
               "%s\t" /* path */
               "%s\t" /* secure */
               "%u\t" /* expires */
               "%s\t" /* name */
               "%s\n", /* value */
-              co->domain,
+              co->domain?co->domain:"unknown",
               co->field1==2?"TRUE":"FALSE",
-              co->path,
+              co->path?co->path:"/",
               co->secure?"TRUE":"FALSE",
               (unsigned int)co->expires,
               co->name,
-              co->value);
+              co->value?co->value:"");
 
       co=co->next;
     }
   }
 
   if(!use_stdout)
@@ -674,13 +760,15 @@
   }
   return 1;
 }
 
 #endif
 
+#endif /* CURL_DISABLE_HTTP */
+
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/cookie.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/cookie.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/cookie.h	2001-08-29 17:32:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/cookie.h	2002-05-07 17:58:14.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: cookie.h,v 1.6 2001/08/29 09:32:18 bagder Exp $
+ * $Id: cookie.h,v 1.10 2002/05/07 09:58:14 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #ifdef WIN32
 #include <time.h>
 #else
@@ -35,13 +35,13 @@
 struct Cookie {
   struct Cookie *next; /* next in the chain */
   char *name;        /* <this> = value */
   char *value;       /* name = <this> */
   char *path;	      /* path = <this> */
   char *domain;      /* domain = <this> */
-  time_t expires;    /* expires = <this> */
+  long expires;    /* expires = <this> */
   char *expirestr;   /* the plain text version */
 
   char field1;       /* read from a cookie file, 1 => FALSE, 2=> TRUE */
   
   /* RFC 2109 keywords. Version=1 means 2109-compliant cookie sending */
   char *version;     /* Version = <value> */
@@ -52,27 +52,34 @@
 };
 
 struct CookieInfo {
   /* linked list of cookies we know of */
   struct Cookie *cookies;
 
-  char *filename; /* file we read from/write to */
-  bool running;   /* state info, for cookie adding information */
+  char *filename;  /* file we read from/write to */
+  bool running;    /* state info, for cookie adding information */
   long numcookies; /* number of cookies in the "jar" */
+  bool newsession; /* new session, discard session cookies on load */
 };
 
 /* This is the maximum line length we accept for a cookie line */
 #define MAX_COOKIE_LINE 2048
 #define MAX_COOKIE_LINE_TXT "2047"
 
 /* This is the maximum length of a cookie name we deal with: */
 #define MAX_NAME 256
 #define MAX_NAME_TXT "255"
 
-struct Cookie *Curl_cookie_add(struct CookieInfo *, bool, char *);
-struct CookieInfo *Curl_cookie_init(char *, struct CookieInfo *);
+/*
+ * Add a cookie to the internal list of cookies. The domain argument is only
+ * used if the header boolean is TRUE.
+ */
+struct Cookie *Curl_cookie_add(struct CookieInfo *, bool header, char *line,
+                               char *domain);
+
+struct CookieInfo *Curl_cookie_init(char *, struct CookieInfo *, bool);
 struct Cookie *Curl_cookie_getlist(struct CookieInfo *, char *, char *, bool);
 void Curl_cookie_freelist(struct Cookie *);
 void Curl_cookie_cleanup(struct CookieInfo *);
 int Curl_cookie_output(struct CookieInfo *, char *);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/curllib.dsp /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/curllib.dsp
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/curllib.dsp	2001-08-24 15:44:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/curllib.dsp	2002-06-03 20:47:58.000000000 +0800
@@ -1,378 +1,394 @@
-# Microsoft Developer Studio Project File - Name="curllib" - Package Owner=<4>
-# Microsoft Developer Studio Generated Build File, Format Version 6.00
-# ** DO NOT EDIT **
-
-# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
-
-CFG=curllib - Win32 Debug
-!MESSAGE This is not a valid makefile. To build this project using NMAKE,
-!MESSAGE use the Export Makefile command and run
-!MESSAGE 
-!MESSAGE NMAKE /f "curllib.mak".
-!MESSAGE 
-!MESSAGE You can specify a configuration when running NMAKE
-!MESSAGE by defining the macro CFG on the command line. For example:
-!MESSAGE 
-!MESSAGE NMAKE /f "curllib.mak" CFG="curllib - Win32 Debug"
-!MESSAGE 
-!MESSAGE Possible choices for configuration are:
-!MESSAGE 
-!MESSAGE "curllib - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE "curllib - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
-!MESSAGE 
-
-# Begin Project
-# PROP AllowPerConfigDependencies 0
-# PROP Scc_ProjName ""
-# PROP Scc_LocalPath ""
-CPP=cl.exe
-MTL=midl.exe
-RSC=rc.exe
-
-!IF  "$(CFG)" == "curllib - Win32 Release"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 0
-# PROP BASE Output_Dir "Release"
-# PROP BASE Intermediate_Dir "Release"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 0
-# PROP Output_Dir "Release"
-# PROP Intermediate_Dir "Release"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /YX /FD /c
-# ADD CPP /nologo /MD /W3 /GX /Zi /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /FR /FD /c
-# SUBTRACT CPP /YX
-# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x409 /d "NDEBUG"
-# ADD RSC /l 0x409 /d "NDEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
-# ADD LINK32 kernel32.lib wsock32.lib /nologo /dll /map /debug /machine:I386 /out:"Release/libcurl.dll"
-
-!ELSEIF  "$(CFG)" == "curllib - Win32 Debug"
-
-# PROP BASE Use_MFC 0
-# PROP BASE Use_Debug_Libraries 1
-# PROP BASE Output_Dir "Debug"
-# PROP BASE Intermediate_Dir "Debug"
-# PROP BASE Target_Dir ""
-# PROP Use_MFC 0
-# PROP Use_Debug_Libraries 1
-# PROP Output_Dir "Debug"
-# PROP Intermediate_Dir "Debug"
-# PROP Ignore_Export_Lib 0
-# PROP Target_Dir ""
-# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /YX /FD /GZ /c
-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /FR /FD /GZ /c
-# SUBTRACT CPP /WX /YX
-# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
-# ADD BASE RSC /l 0x409 /d "_DEBUG"
-# ADD RSC /l 0x409 /d "_DEBUG"
-BSC32=bscmake.exe
-# ADD BASE BSC32 /nologo
-# ADD BSC32 /nologo
-LINK32=link.exe
-# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib wsock32.lib /nologo /dll /incremental:no /map /debug /machine:I386 /out:"Debug/libcurl.dll" /pdbtype:sept
-# SUBTRACT LINK32 /nodefaultlib
-
-!ENDIF 
-
-# Begin Target
-
-# Name "curllib - Win32 Release"
-# Name "curllib - Win32 Debug"
-# Begin Group "Source Files"
-
-# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
-# Begin Source File
-
-SOURCE=.\base64.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\cookie.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\dict.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\dllinit.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\easy.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\escape.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\file.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\formdata.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\ftp.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\getdate.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\getenv.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\getinfo.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\getpass.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\hostip.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\http.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\http_chunks.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\if2ip.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\krb4.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\ldap.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\libcurl.def
-# End Source File
-# Begin Source File
-
-SOURCE=.\memdebug.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\mprintf.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\netrc.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\progress.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\security.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\sendf.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\speedcheck.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\ssluse.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\strequal.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\strtok.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\telnet.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\timeval.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\transfer.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\url.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\version.c
-# End Source File
-# End Group
-# Begin Group "Header Files"
-
-# PROP Default_Filter "h;hpp;hxx;hm;inl"
-# Begin Source File
-
-SOURCE=.\arpa_telnet.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\base64.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\cookie.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\dict.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\escape.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\file.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\formdata.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\ftp.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\getdate.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\getenv.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\getpass.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\hostip.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\http.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\http_chunks.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\if2ip.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\inet_ntoa_r.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\krb4.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\ldap.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\memdebug.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\netrc.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\progress.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\security.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\sendf.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\setup.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\speedcheck.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\ssluse.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\strequal.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\strtok.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\telnet.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\timeval.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\transfer.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\url.h
-# End Source File
-# Begin Source File
-
-SOURCE=.\urldata.h
-# End Source File
-# End Group
-# Begin Group "Resource Files"
-
-# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
-# End Group
-# End Target
-# End Project
+# Microsoft Developer Studio Project File - Name="curllib" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=curllib - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "curllib.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "curllib.mak" CFG="curllib - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "curllib - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "curllib - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "curllib - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GX /Zi /O2 /I "..\include" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x409 /d "NDEBUG"
+# ADD RSC /l 0x409 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib ws2_32.lib winmm.lib /nologo /dll /map /debug /machine:I386 /out:"Release/libcurl.dll"
+
+!ELSEIF  "$(CFG)" == "curllib - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "..\include" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CURLLIB_EXPORTS" /FR /FD /GZ /c
+# SUBTRACT CPP /WX /YX
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x409 /d "_DEBUG"
+# ADD RSC /l 0x409 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib ws2_32.lib winmm.lib /nologo /dll /incremental:no /map /debug /machine:I386 /out:"Debug/libcurl.dll" /pdbtype:sept
+# SUBTRACT LINK32 /nodefaultlib
+
+!ENDIF 
+
+# Begin Target
+
+# Name "curllib - Win32 Release"
+# Name "curllib - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\base64.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\connect.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\cookie.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\dict.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\dllinit.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\easy.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\escape.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\file.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\formdata.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\ftp.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\getdate.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\getenv.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\getinfo.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\getpass.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\hash.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\hostip.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\http.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\http_chunks.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\if2ip.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\krb4.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\ldap.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libcurl.def
+# End Source File
+# Begin Source File
+
+SOURCE=.\llist.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\memdebug.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mprintf.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\netrc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\progress.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\security.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\sendf.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\speedcheck.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\ssluse.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\strequal.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\strtok.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\telnet.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\timeval.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\transfer.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\url.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\version.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\arpa_telnet.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\base64.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\connect.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\cookie.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\dict.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\escape.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\file.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\formdata.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ftp.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\getdate.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\getenv.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\getpass.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\hostip.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\http.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\http_chunks.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\if2ip.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\inet_ntoa_r.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\krb4.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ldap.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\memdebug.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\netrc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\progress.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\security.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\sendf.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\setup.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\speedcheck.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ssluse.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\strequal.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\strtok.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\telnet.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\timeval.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\transfer.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\url.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\urldata.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# End Group
+# End Target
+# End Project
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/curllib.dsw /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/curllib.dsw
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/curllib.dsw	2001-08-24 15:43:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/curllib.dsw	2002-06-03 20:47:51.000000000 +0800
@@ -1,29 +1,29 @@
-Microsoft Developer Studio Workspace File, Format Version 6.00
-# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
-
-###############################################################################
-
-Project: "curllib"=".\curllib.dsp" - Package Owner=<4>
-
-Package=<5>
-{{{
-}}}
-
-Package=<4>
-{{{
-}}}
-
-###############################################################################
-
-Global:
-
-Package=<5>
-{{{
-}}}
-
-Package=<3>
-{{{
-}}}
-
-###############################################################################
-
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "curllib"=".\curllib.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/dict.c	2001-09-07 14:05:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/dict.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: dict.c,v 1.17 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: dict.c,v 1.21 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -118,13 +118,13 @@
           }
         }
       }
     }
       
     if ((word == NULL) || (*word == (char)0)) {
-      failf(data, "lookup word is missing\n");
+      failf(data, "lookup word is missing");
     }
     if ((database == NULL) || (*database == (char)0)) {
       database = (char *)"!";
     }
     if ((strategy == NULL) || (*strategy == (char)0)) {
       strategy = (char *)".";
@@ -133,31 +133,31 @@
       nth = 0;
     }
     else {
       nth = atoi(nthdef);
     }
       
-    Curl_sendf(conn->firstsocket, conn,
-               "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
-               "MATCH "
-               "%s "    /* database */
-               "%s "    /* strategy */
-               "%s\n"   /* word */
-               "QUIT\n",
-	    
-               database,
-               strategy,
-               word
-               );
-    
-    result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
-                           -1, NULL); /* no upload */
-      
+    result = Curl_sendf(conn->firstsocket, conn,
+                        "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
+                        "MATCH "
+                        "%s "    /* database */
+                        "%s "    /* strategy */
+                        "%s\n"   /* word */
+                        "QUIT\n",
+                        
+                        database,
+                        strategy,
+                        word
+                        );
+    if(result)
+      failf(data, "Failed sending DICT request");
+    else
+      result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
+                             -1, NULL); /* no upload */      
     if(result)
       return result;
-    
   }
   else if (strnequal(path, DICT_DEFINE, sizeof(DICT_DEFINE)-1) ||
            strnequal(path, DICT_DEFINE2, sizeof(DICT_DEFINE2)-1) ||
            strnequal(path, DICT_DEFINE3, sizeof(DICT_DEFINE3)-1)) {
     
     word = strchr(path, ':');
@@ -171,37 +171,37 @@
           *nthdef++ = (char)0;
         }
       }
     }
       
     if ((word == NULL) || (*word == (char)0)) {
-      failf(data, "lookup word is missing\n");
+      failf(data, "lookup word is missing");
     }
     if ((database == NULL) || (*database == (char)0)) {
       database = (char *)"!";
     }
     if ((nthdef == NULL) || (*nthdef == (char)0)) {
       nth = 0;
     }
     else {
       nth = atoi(nthdef);
     }
       
-    Curl_sendf(conn->firstsocket, conn,
-               "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
-               "DEFINE "
-               "%s "     /* database */
-               "%s\n"    /* word */
-               "QUIT\n",
-               
-               database,
-               word
-               );
-    
-    result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
-                           -1, NULL); /* no upload */
+    result = Curl_sendf(conn->firstsocket, conn,
+                        "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
+                        "DEFINE "
+                        "%s "     /* database */
+                        "%s\n"    /* word */
+                        "QUIT\n",
+                        database,
+                        word);
+    if(result)
+      failf(data, "Failed sending DICT request");
+    else
+      result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
+                             -1, NULL); /* no upload */
     
     if(result)
       return result;
       
   }
   else {
@@ -212,31 +212,30 @@
 	
       ppath++;
       for (i = 0; ppath[i]; i++) {
         if (ppath[i] == ':')
           ppath[i] = ' ';
       }
-      Curl_sendf(conn->firstsocket, conn,
-                 "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
-                 "%s\n"
-                 "QUIT\n",
-                 ppath);
-      
-      result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
-                             -1, NULL);
-      
+      result = Curl_sendf(conn->firstsocket, conn,
+                          "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
+                          "%s\n"
+                          "QUIT\n", ppath);
+      if(result)
+        failf(data, "Failed sending DICT request");
+      else
+        result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
+                               -1, NULL);
       if(result)
         return result;
-      
     }
   }
 
   return CURLE_OK;
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/dict.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/dict.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/dict.h	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/dict.h	2002-06-11 19:13:01.000000000 +0800
@@ -5,25 +5,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: dict.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
+ * $Id: dict.h,v 1.8 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
+#ifndef CURL_DISABLE_DICT
 CURLcode Curl_dict(struct connectdata *conn);
 CURLcode Curl_dict_done(struct connectdata *conn);
-
+#endif
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/dllinit.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/dllinit.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/dllinit.c	2001-09-07 14:05:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/dllinit.c	2002-02-20 20:38:14.000000000 +0800
@@ -78,15 +78,19 @@
 
     case DLL_THREAD_DETACH:
       break;
     }
   return TRUE;
 }
+#else
+#ifdef VMS
+int VOID_VAR_DLLINIT;	
+#endif
 #endif
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/easy.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/easy.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/easy.c	2001-09-17 22:10:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/easy.c	2002-05-07 17:58:14.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: easy.c,v 1.24 2001/09/17 14:10:38 bagder Exp $
+ * $Id: easy.c,v 1.31 2002/05/07 09:58:14 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -73,12 +73,13 @@
 #include "urldata.h"
 #include <curl/curl.h>
 #include "transfer.h"
 #include "ssluse.h"
 #include "url.h"
 #include "getinfo.h"
+#include "hostip.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 
 /* Silly win32 socket initialization functions */
@@ -136,13 +137,13 @@
  * the different features to initialize.
  */
 CURLcode curl_global_init(long flags)
 {
   if (initialized)
     return CURLE_OK;
- 
+
   if (flags & CURL_GLOBAL_SSL)
     Curl_SSL_init();
 
   if (flags & CURL_GLOBAL_WIN32)
     if (win32_init() != CURLE_OK)
       return CURLE_FAILED_INIT;
@@ -159,12 +160,14 @@
  */
 void curl_global_cleanup(void)
 {
   if (!initialized)
     return;
 
+  Curl_global_host_cache_dtor();
+
   if (init_flags & CURL_GLOBAL_SSL)
     Curl_SSL_cleanup();
 
   if (init_flags & CURL_GLOBAL_WIN32)
     win32_cleanup();
 
@@ -227,18 +230,30 @@
 }
 
 CURLcode curl_easy_perform(CURL *curl)
 {
   struct SessionHandle *data = (struct SessionHandle *)curl;
 
+  if (!data->hostcache) {
+    if (Curl_global_host_cache_use(data)) {
+      data->hostcache = Curl_global_host_cache_get();
+    }
+    else {
+      data->hostcache = Curl_hash_alloc(7, Curl_freeaddrinfo);
+    }
+  }
+
   return Curl_perform(data);
 }
 
 void curl_easy_cleanup(CURL *curl)
 {
   struct SessionHandle *data = (struct SessionHandle *)curl;
+  if (!Curl_global_host_cache_use(data)) {
+    Curl_hash_destroy(data->hostcache);
+  }
   Curl_close(data);
 }
 
 CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ...)
 {
   va_list arg;
@@ -290,12 +305,19 @@
   memset(outcurl->state.connects, 0,
          sizeof(struct connectdata *)*outcurl->state.numconnects);
 
   outcurl->progress.flags    = data->progress.flags;
   outcurl->progress.callback = data->progress.callback;
 
+  if(data->cookies)
+    /* If cookies are enabled in the parent handle, we enable them
+       in the clone as well! */
+    outcurl->cookies = Curl_cookie_init(data->cookies->filename,
+                                        outcurl->cookies,
+                                        data->set.cookiesession);
+
   /* duplicate all values in 'change' */
   if(data->change.url) {
     outcurl->change.url = strdup(data->change.url);
     outcurl->change.url_alloc = TRUE;
   }
   if(data->change.proxy) {
@@ -311,9 +333,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/escape.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/escape.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/escape.c	2001-09-07 14:05:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/escape.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: escape.c,v 1.17 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: escape.c,v 1.19 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 /* Escape and unescape URL encoding in strings. The functions return a new
  * allocated string or NULL if an error occurred.  */
 
 #include "setup.h"
@@ -112,9 +112,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/escape.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/escape.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/escape.h	2001-08-21 21:18:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/escape.h	2002-03-19 15:54:55.000000000 +0800
@@ -5,26 +5,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: escape.h,v 1.7 2001/08/21 13:18:07 bagder Exp $
+ * $Id: escape.h,v 1.8 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 /* Escape and unescape URL encoding in strings. The functions return a new
  * allocated string or NULL if an error occurred.  */
 
 char *curl_escape(const char *string, int length);
 char *curl_unescape(const char *string, int length);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/file.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/file.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/file.c	2001-09-07 14:05:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/file.c	2002-06-11 19:13:01.000000000 +0800
@@ -2,30 +2,31 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.c,v 1.21 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: file.c,v 1.25 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_FILE
 /* -- WIN32 approved -- */
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -137,13 +138,13 @@
      RFC 1738. Only local files (reachable via the standard file system)
      are supported. This means that files on remotely mounted directories
      (via NFS, Samba, NT sharing) can be accessed through a file:// URL
   */
   CURLcode res = CURLE_OK;
   struct stat statbuf;
-  ssize_t expected_size=-1;
+  double expected_size=-1;
   ssize_t nread;
   struct SessionHandle *data = conn->data;
   char *buf = data->state.buffer;
   int bytecount = 0;
   struct timeval start = Curl_tvnow();
   struct timeval now = start;
@@ -152,13 +153,13 @@
   /* get the fd from the connection phase */
   fd = conn->proto.file->fd;
 
 /*VMS?? -- This only works reliable for STREAMLF files */
   if( -1 != fstat(fd, &statbuf)) {
     /* we could stat it, then read out the size */
-    expected_size = statbuf.st_size;
+    expected_size = (double)statbuf.st_size;
   }
 
   /* The following is a shortcut implementation of file reading
      this is both more efficient than the former call to download() and
      it avoids problems with select() and recv() on file descriptors
      in Winsock */
@@ -198,9 +199,10 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/file.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/file.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/file.h	2001-03-05 21:39:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/file.h	2002-06-11 19:13:01.000000000 +0800
@@ -5,24 +5,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.h,v 1.6 2001/03/05 13:39:01 bagder Exp $
+ * $Id: file.h,v 1.8 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
+#ifndef CURL_DISABLE_FILE
 CURLcode Curl_file(struct connectdata *conn);
 CURLcode Curl_file_connect(struct connectdata *conn);
 #endif
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/formdata.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/formdata.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/formdata.c	2001-09-07 14:05:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/formdata.c	2002-06-13 05:40:59.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: formdata.c,v 1.22 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: formdata.c,v 1.40 2002/06/12 21:40:59 bagder Exp $
  *****************************************************************************/
 
 /*
   Debug the form generator stand-alone by compiling this source file with:
 
   gcc -DHAVE_CONFIG_H -I../ -g -D_FORM_DEBUG -o formdata -I../include formdata.c strequal.c
@@ -77,24 +77,43 @@
 Content-Type: text/plain
 ...
 Content-Disposition: attachment; filename="inet_ntoa_r.h"
 Content-Type: text/plain
 ...
 
+
+Content-Disposition: form-data; name="ARRAY: FILE1_+_FILE2_+_FILE3"
+Content-Type: multipart/mixed, boundary=curlirkYPmPwu6FrJ1vJ1u1BmtIufh1
+...
+Content-Disposition: attachment; filename="inet_ntoa_r.h"
+Content-Type: text/plain
+...
+Content-Disposition: attachment; filename="Makefile.b32.resp"
+Content-Type: text/plain
+...
+Content-Disposition: attachment; filename="inet_ntoa_r.h"
+Content-Type: text/plain
+...
+
+Content-Disposition: form-data; name="FILECONTENT"
+...
+
   For the old FormParse used by curl_formparse use:
 
   gcc -DHAVE_CONFIG_H -I../ -g -D_OLD_FORM_DEBUG -o formdata -I../include formdata.c strequal.c
 
   run the 'formdata' executable and make sure the output is ok!
 
   try './formdata "name=Daniel" "poo=noo" "foo=bar"' and similarly
 
  */
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_HTTP
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 
 #include <time.h>
@@ -151,14 +170,14 @@
 
 #define FORM_FILE_SEPARATOR ','
 #define FORM_TYPE_SEPARATOR ';'
 
 static
 int FormParse(char *input,
-	      struct HttpPost **httppost,
-	      struct HttpPost **last_post)
+	      struct curl_httppost **httppost,
+	      struct curl_httppost **last_post)
 {
   /* nextarg MUST be a string in the format 'name=contents' and we'll
      build a linked list with the info */
   char name[256];
   char *contents;
   char major[128];
@@ -166,14 +185,14 @@
   long flags = 0;
   char *contp;
   const char *type = NULL;
   char *prevtype = NULL;
   char *sep;
   char *sep2;
-  struct HttpPost *post;
-  struct HttpPost *subpost; /* a sub-node */
+  struct curl_httppost *post;
+  struct curl_httppost *subpost; /* a sub-node */
   unsigned int i;
 
   /* Preallocate contents to the length of input to make sure we don't
      overwrite anything. */
   contents = malloc(strlen(input));
   contents[0] = '\000';
@@ -215,13 +234,12 @@
 
 	  if(type) {
 	    type += strlen("type=");
 	    
 	    if(2 != sscanf(type, "%127[^/]/%127[^,\n]",
 			   major, minor)) {
-	      fprintf(stderr, "Illegally formatted content-type field!\n");
               free(contents);
 	      return 2; /* illegal content-type syntax! */
 	    }
 	    /* now point beyond the content-type specifier */
 	    sep = (char *)type + strlen(major)+strlen(minor)+1;
 
@@ -277,15 +295,15 @@
 	}
 
 	if(NULL == post) {
 	  /* For the first file name, we allocate and initiate the main list
 	     node */
 
-	  post = (struct HttpPost *)malloc(sizeof(struct HttpPost));
+	  post = (struct curl_httppost *)malloc(sizeof(struct curl_httppost));
 	  if(post) {
-	    memset(post, 0, sizeof(struct HttpPost));
+	    memset(post, 0, sizeof(struct curl_httppost));
 	    GetStr(&post->name, name);      /* get the name */
 	    GetStr(&post->contents, contp); /* get the contents */
             post->contentslength = 0;
 	    post->flags = flags;
 	    if(type) {
 	      GetStr(&post->contenttype, (char *)type); /* get type */
@@ -301,15 +319,16 @@
 	  }
 
 	}
 	else {
 	  /* we add a file name to the previously allocated node, known as
              'post' now */
-	  subpost =(struct HttpPost *)malloc(sizeof(struct HttpPost));
+	  subpost =(struct curl_httppost *)
+            malloc(sizeof(struct curl_httppost));
 	  if(subpost) {
-	     memset(subpost, 0, sizeof(struct HttpPost));
+	     memset(subpost, 0, sizeof(struct curl_httppost));
 	     GetStr(&subpost->name, name);      /* get the name */
 	     GetStr(&subpost->contents, contp); /* get the contents */
              subpost->contentslength = 0;
 	     subpost->flags = flags;
 	     if(type) {
 	       GetStr(&subpost->contenttype, (char *)type); /* get type */
@@ -323,15 +342,15 @@
 	  }
 	}
 	contp = sep; /* move the contents pointer to after the separator */
       } while(sep && *sep); /* loop if there's another file name */
     }
     else {
-      post = (struct HttpPost *)malloc(sizeof(struct HttpPost));
+      post = (struct curl_httppost *)malloc(sizeof(struct curl_httppost));
       if(post) {
-	memset(post, 0, sizeof(struct HttpPost));
+	memset(post, 0, sizeof(struct curl_httppost));
 	GetStr(&post->name, name);      /* get the name */
 	if( contp[0]=='<' ) {
 	  GetStr(&post->contents, contp+1); /* get the contents */
           post->contentslength = 0;
 	  post->flags = HTTPPOST_READFILE;
 	}
@@ -351,23 +370,22 @@
       }
 
     }
 
   }
   else {
-    fprintf(stderr, "Illegally formatted input field!\n");
     free(contents);
     return 1;
   }
   free(contents);
   return 0;
 }
 
 int curl_formparse(char *input,
-                   struct HttpPost **httppost,
-                   struct HttpPost **last_post)
+                   struct curl_httppost **httppost,
+                   struct curl_httppost **last_post)
 {
   return FormParse(input, httppost, last_post);
 }
 
 /***************************************************************************
  *
@@ -376,31 +394,43 @@
  * Adds a HttpPost structure to the list, if parent_post is given becomes
  * a subpost of parent_post instead of a direct list element.
  *
  * Returns newly allocated HttpPost on success and NULL if malloc failed.
  *
  ***************************************************************************/
-static struct HttpPost * AddHttpPost (char * name,
-                                      long namelength,
-                                      char * value,
-                                      long contentslength,
-				      char *contenttype,
-                                      long flags,
-                                      struct HttpPost *parent_post,
-                                      struct HttpPost **httppost,
-                                      struct HttpPost **last_post)
+static struct curl_httppost *
+AddHttpPost(char * name, long namelength,
+            char * value, long contentslength,
+
+            /* CMC: Added support for buffer uploads */
+            char * buffer, long bufferlength,
+
+            char *contenttype,
+            long flags,
+            struct curl_slist* contentHeader,
+            char *showfilename,
+            struct curl_httppost *parent_post,
+            struct curl_httppost **httppost,
+            struct curl_httppost **last_post)
 {
-  struct HttpPost *post;
-  post = (struct HttpPost *)malloc(sizeof(struct HttpPost));
+  struct curl_httppost *post;
+  post = (struct curl_httppost *)malloc(sizeof(struct curl_httppost));
   if(post) {
-    memset(post, 0, sizeof(struct HttpPost));
+    memset(post, 0, sizeof(struct curl_httppost));
     post->name = name;
-    post->namelength = namelength;
+    post->namelength = name?(namelength?namelength:(long)strlen(name)):0;
     post->contents = value;
     post->contentslength = contentslength;
+
+    /* CMC: Added support for buffer uploads */
+    post->buffer = buffer;
+    post->bufferlength = bufferlength;
+
     post->contenttype = contenttype;
+    post->contentheader = contentHeader;
+    post->showfilename = showfilename;
     post->flags = flags;
   }
   else
     return NULL;
   
   if (parent_post) {
@@ -429,15 +459,15 @@
  * Adds a FormInfo structure to the list presented by parent_form_info.
  *
  * Returns newly allocated FormInfo on success and NULL if malloc failed/
  * parent_form_info is NULL.
  *
  ***************************************************************************/
-static FormInfo * AddFormInfo (char *value,
-			       char *contenttype,
-			       FormInfo *parent_form_info)
+static FormInfo * AddFormInfo(char *value,
+                              char *contenttype,
+                              FormInfo *parent_form_info)
 {
   FormInfo *form_info;
   form_info = (FormInfo *)malloc(sizeof(FormInfo));
   if(form_info) {
     memset(form_info, 0, sizeof(FormInfo));
     if (value)
@@ -469,13 +499,13 @@
  * Provides content type for filename if one of the known types (else
  * (either the prevtype or the default is returned).
  *
  * Returns some valid contenttype for filename.
  *
  ***************************************************************************/
-static const char * ContentTypeForFilename (char *filename,
+static const char * ContentTypeForFilename (const char *filename,
 					    const char *prevtype)
 {
   const char *contenttype = NULL;
   unsigned int i;
   /*
    * No type was specified, we scan through a few well-known
@@ -525,22 +555,27 @@
  *
  * Returns 0 on success and 1 if the malloc failed.
  *
  ***************************************************************************/
 static int AllocAndCopy (char **buffer, int buffer_length)
 {
-  char *src = *buffer;
-  int length;
+  const char *src = *buffer;
+  int length, add = 0;
   if (buffer_length)
     length = buffer_length;
-  else
+  else {
     length = strlen(*buffer);
-  *buffer = (char*)malloc(length);
+    add = 1;
+  }
+  *buffer = (char*)malloc(length+add);
   if (!*buffer)
     return 1;
   memcpy(*buffer, src, length);
+  /* if length unknown do null termination */
+  if (add)
+    (*buffer)[length] = '\0';
   return 0;
 }
 
 /***************************************************************************
  *
  * FormAdd()
@@ -558,236 +593,411 @@
  * using CURLFORM_FILE).
  *
  * Examples:
  *
  * Simple name/value pair with copied contents:
  * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
- * CURLFORM_COPYCONTENTS, "value");
+ * CURLFORM_COPYCONTENTS, "value", CURLFORM_END);
  *
  * name/value pair where only the content pointer is remembered:
  * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
- * CURLFORM_PTRCONTENTS, ptr, CURLFORM_CONTENTSLENGTH, 10);
+ * CURLFORM_PTRCONTENTS, ptr, CURLFORM_CONTENTSLENGTH, 10, CURLFORM_END);
  * (if CURLFORM_CONTENTSLENGTH is missing strlen () is used)
  *
  * storing a filename (CONTENTTYPE is optional!):
  * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
  * CURLFORM_FILE, "filename1", CURLFORM_CONTENTTYPE, "plain/text",
  * CURLFORM_END);
  *
  * storing multiple filenames:
  * curl_formadd (&post, &last, CURLFORM_COPYNAME, "name",
  * CURLFORM_FILE, "filename1", CURLFORM_FILE, "filename2", CURLFORM_END);
  *
- * Returns 0 on success, 1 if the FormInfo allocation fails, 2 if one
- * option is given twice for one Form, 3 if a null pointer was given for
- * a char *, 4 if the allocation of a FormInfo struct failed, 5 if an
- * unknown option was used, 6 if the some FormInfo is not complete (or
- * has an error), 7 if a HttpPost struct cannot be allocated, and 8
- * if some allocation for string copying failed.
+ * Returns:
+ * CURL_FORMADD_OK             on success
+ * CURL_FORMADD_MEMORY         if the FormInfo allocation fails
+ * CURL_FORMADD_OPTION_TWICE   if one option is given twice for one Form
+ * CURL_FORMADD_NULL           if a null pointer was given for a char
+ * CURL_FORMADD_MEMORY         if the allocation of a FormInfo struct failed
+ * CURL_FORMADD_UNKNOWN_OPTION if an unknown option was used
+ * CURL_FORMADD_INCOMPLETE     if the some FormInfo is not complete (or an error)
+ * CURL_FORMADD_MEMORY         if a HttpPost struct cannot be allocated
+ * CURL_FORMADD_MEMORY         if some allocation for string copying failed.
+ * CURL_FORMADD_ILLEGAL_ARRAY  if an illegal option is used in an array
  *
  ***************************************************************************/
 
 static
-int FormAdd(struct HttpPost **httppost,
-            struct HttpPost **last_post,
-            va_list params)
+CURLFORMcode FormAdd(struct curl_httppost **httppost,
+                     struct curl_httppost **last_post,
+                     va_list params)
 {
-  FormInfo *first_form_info, *current_form_info, *form_info;
-  int return_value = 0;
+  FormInfo *first_form, *current_form, *form;
+  CURLFORMcode return_value = CURL_FORMADD_OK;
   const char *prevtype = NULL;
-  struct HttpPost *post = NULL;
-  CURLformoption next_option;
+  struct curl_httppost *post = NULL;
+  CURLformoption option;
+  struct curl_forms *forms = NULL;
+  char *array_value; /* value read from an array */
+
+  /* This is a state variable, that if TRUE means that we're parsing an
+     array that we got passed to us. If FALSE we're parsing the input
+     va_list arguments. */
+  bool array_state = FALSE;
 
-  first_form_info = (FormInfo *)malloc(sizeof(struct FormInfo));
-  if(first_form_info) {
-    memset(first_form_info, 0, sizeof(FormInfo));
-    current_form_info = first_form_info;
+  /*
+   * We need to allocate the first struct to fill in.
+   */
+  first_form = (FormInfo *)malloc(sizeof(struct FormInfo));
+  if(first_form) {
+    memset(first_form, 0, sizeof(FormInfo));
+    current_form = first_form;
   }
   else
-    return 1;
+    return CURL_FORMADD_MEMORY;
 
-  /** TODO: first check whether char * is not NULL
-      TODO: transfer.c
-  */
-  while ( ((next_option = va_arg(params, CURLformoption)) != CURLFORM_END) &&
-          (return_value == 0) )
-  {
-    switch (next_option)
-    {
-      case CURLFORM_PTRNAME:
-        current_form_info->flags |= HTTPPOST_PTRNAME; /* fall through */
-      case CURLFORM_COPYNAME:
-        if (current_form_info->name)
-          return_value = 2;
-        else {
-          if (next_option == CURLFORM_PTRNAME)
-            current_form_info->name = va_arg(params, char *);
-          else {
-	    char *name = va_arg(params, char *);
-	    if (name)
-	      current_form_info->name = name; /* store for the moment */
-	    else
-	      return_value = 3;
-	  }
-        }
+  /*
+   * Loop through all the options set.
+   */
+  while (1) {
+
+    /* break if we have an error to report */
+    if (return_value != CURL_FORMADD_OK)
+      break;
+
+    /* first see if we have more parts of the array param */
+    if ( array_state ) {
+      /* get the upcoming option from the given array */
+      option = forms->option;
+      array_value = (char *)forms->value;
+
+      forms++; /* advance this to next entry */
+      if (CURLFORM_END == option) {
+        /* end of array state */
+        array_state = FALSE;
+        continue;
+      }
+    }
+    else {
+      /* This is not array-state, get next option */
+      option = va_arg(params, CURLformoption);
+      if (CURLFORM_END == option)
         break;
-      case CURLFORM_NAMELENGTH:
-        if (current_form_info->namelength)
-          return_value = 2;
+    }
+
+    switch (option) {
+    case CURLFORM_ARRAY:
+      if(array_state)
+        /* we don't support an array from within an array */
+        return_value = CURL_FORMADD_ILLEGAL_ARRAY;
+      else {
+        forms = va_arg(params, struct curl_forms *);
+        if (forms)
+          array_state = TRUE;
         else
-          current_form_info->namelength = va_arg(params, long);
-        break;
-      case CURLFORM_PTRCONTENTS:
-        current_form_info->flags |= HTTPPOST_PTRCONTENTS; /* fall through */
-      case CURLFORM_COPYCONTENTS:
-        if (current_form_info->value)
-          return_value = 2;
-        else {
-          if (next_option == CURLFORM_PTRCONTENTS)
-            current_form_info->value = va_arg(params, char *);
-          else {
-	    char *value = va_arg(params, char *);
-	    if (value)
-	      current_form_info->value = value; /* store for the moment */
+          return_value = CURL_FORMADD_NULL;
+      }
+      break;
+
+      /*
+       * Set the Name property.
+       */
+    case CURLFORM_PTRNAME:
+      current_form->flags |= HTTPPOST_PTRNAME; /* fall through */
+    case CURLFORM_COPYNAME:
+      if (current_form->name)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else {
+        char *name = array_state?
+          array_value:va_arg(params, char *);
+        if (name)
+          current_form->name = name; /* store for the moment */
+        else
+          return_value = CURL_FORMADD_NULL;
+      }
+      break;
+    case CURLFORM_NAMELENGTH:
+      if (current_form->namelength)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else
+        current_form->namelength =
+          array_state?(long)array_value:va_arg(params, long);
+      break;
+
+      /*
+       * Set the contents property.
+       */
+    case CURLFORM_PTRCONTENTS:
+      current_form->flags |= HTTPPOST_PTRCONTENTS; /* fall through */
+    case CURLFORM_COPYCONTENTS:
+      if (current_form->value)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else {
+        char *value =
+          array_state?array_value:va_arg(params, char *);
+        if (value)
+          current_form->value = value; /* store for the moment */
+        else
+          return_value = CURL_FORMADD_NULL;
+      }
+      break;
+    case CURLFORM_CONTENTSLENGTH:
+      if (current_form->contentslength)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else
+        current_form->contentslength =
+          array_state?(long)array_value:va_arg(params, long);
+      break;
+
+      /* Get contents from a given file name */
+    case CURLFORM_FILECONTENT:
+      if (current_form->flags != 0)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else {
+        char *filename = array_state?
+          array_value:va_arg(params, char *);
+        if (filename) {
+          current_form->value = strdup(filename);
+          current_form->flags |= HTTPPOST_READFILE;
+        }
+        else
+          return_value = CURL_FORMADD_NULL;
+      }
+      break;
+
+      /* We upload a file */
+    case CURLFORM_FILE:
+      {
+        char *filename = array_state?array_value:
+          va_arg(params, char *);
+
+        if (current_form->value) {
+          if (current_form->flags & HTTPPOST_FILENAME) {
+            if (filename) {
+              if (!(current_form = AddFormInfo(strdup(filename),
+                                               NULL, current_form)))
+                return_value = CURL_FORMADD_MEMORY;
+            }
 	    else
-	      return_value = 3;
+              return_value = CURL_FORMADD_NULL;
 	  }
+          else
+            return_value = CURL_FORMADD_OPTION_TWICE;
+        }
+        else {
+          if (filename)
+            current_form->value = strdup(filename);
+          else
+            return_value = CURL_FORMADD_NULL;
+          current_form->flags |= HTTPPOST_FILENAME;
         }
         break;
-      case CURLFORM_CONTENTSLENGTH:
-        if (current_form_info->contentslength)
-          return_value = 2;
-        else
-          current_form_info->contentslength = va_arg(params, long);
-        break;
-      case CURLFORM_FILE: {
-	char *filename = va_arg(params, char *);
-	if (current_form_info->value) {
-          if (current_form_info->flags & HTTPPOST_FILENAME) {
+      }
+
+    /* CMC: Added support for buffer uploads */
+    case CURLFORM_BUFFER:
+      {
+        char *filename = array_state?array_value:
+          va_arg(params, char *);
+
+        if (current_form->value) {
+          if (current_form->flags & HTTPPOST_BUFFER) {
 	    if (filename) {
-	      if (!(current_form_info = AddFormInfo (strdup(filename),
-						     NULL, current_form_info)))
-		return_value = 4;
+              if (!(current_form = AddFormInfo(strdup(filename),
+                                               NULL, current_form)))
+                return_value = CURL_FORMADD_MEMORY;
 	    }
 	    else
-	      return_value = 3;
+              return_value = CURL_FORMADD_NULL;
           }
           else
-            return_value = 2;
+            return_value = CURL_FORMADD_OPTION_TWICE;
         }
         else {
 	  if (filename)
-	    current_form_info->value = strdup(filename);
+            current_form->value = strdup(filename);
 	  else
-	    return_value = 3;
-          current_form_info->flags |= HTTPPOST_FILENAME;
+            return_value = CURL_FORMADD_NULL;
+          current_form->flags |= HTTPPOST_BUFFER;
         }
         break;
       }
-      case CURLFORM_CONTENTTYPE: {
-	char *contenttype = va_arg(params, char *);
-        if (current_form_info->contenttype) {
-          if (current_form_info->flags & HTTPPOST_FILENAME) {
+      
+    /* CMC: Added support for buffer uploads */
+    case CURLFORM_BUFFERPTR:
+        current_form->flags |= HTTPPOST_PTRBUFFER;
+      if (current_form->buffer)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else {
+        char *buffer =
+          array_state?array_value:va_arg(params, char *);
+        if (buffer)
+          current_form->buffer = buffer; /* store for the moment */
+        else
+          return_value = CURL_FORMADD_NULL;
+      }
+      break;
+
+    /* CMC: Added support for buffer uploads */
+    case CURLFORM_BUFFERLENGTH:
+      if (current_form->bufferlength)
+        return_value = CURL_FORMADD_OPTION_TWICE;
+      else
+        current_form->bufferlength =
+          array_state?(long)array_value:va_arg(params, long);
+      break;
+
+    case CURLFORM_CONTENTTYPE:
+      {
+        char *contenttype =
+          array_state?array_value:va_arg(params, char *);
+        if (current_form->contenttype) {
+          if (current_form->flags & HTTPPOST_FILENAME) {
             if (contenttype) {
-              if (!(current_form_info = AddFormInfo (NULL,
-                                                     strdup(contenttype),
-                                                     current_form_info)))
-                return_value = 4;
+              if (!(current_form = AddFormInfo(NULL,
+                                               strdup(contenttype),
+                                               current_form)))
+                return_value = CURL_FORMADD_MEMORY;
             }
 	    else
-	      return_value = 3;
+	      return_value = CURL_FORMADD_NULL;
           }
           else
-            return_value = 2;
+            return_value = CURL_FORMADD_OPTION_TWICE;
         }
         else {
 	  if (contenttype)
-	    current_form_info->contenttype = strdup(contenttype);
+	    current_form->contenttype = strdup(contenttype);
 	  else
-	    return_value = 3;
+	    return_value = CURL_FORMADD_NULL;
 	}
         break;
       }
-      default:
-        fprintf (stderr, "got unknown CURLFORM_OPTION: %d\n", next_option);
-        return_value = 5;
-    };
-  };
-
-  /* go through the list, check for copleteness and if everything is
-   * alright add the HttpPost item otherwise set return_value accordingly */
-  form_info = first_form_info;
-  while (form_info != NULL)
-  {
-    if ( (!first_form_info->name) ||
-         (!form_info->value) ||
-         ( (!form_info->namelength) &&
-           (form_info->flags & HTTPPOST_PTRNAME) ) ||
-	 ( (form_info->contentslength) &&
-	   (form_info->flags & HTTPPOST_FILENAME) ) ||
-	 ( (form_info->flags & HTTPPOST_FILENAME) &&
-	   (form_info->flags & HTTPPOST_PTRCONTENTS) )
-         ) {
-      return_value = 6;
-      break;
+    case CURLFORM_CONTENTHEADER:
+      {
+        /* this "cast increases required alignment of target type" but
+           we consider it OK anyway */
+        struct curl_slist* list = array_state?
+          (struct curl_slist*)array_value:
+          va_arg(params, struct curl_slist*);
+        
+        if( current_form->contentheader )
+          return_value = CURL_FORMADD_OPTION_TWICE;
+        else
+          current_form->contentheader = list;
+        
+        break;
+      }
+    case CURLFORM_FILENAME:
+      {
+        char *filename = array_state?array_value:
+          va_arg(params, char *);
+        if( current_form->showfilename )
+          return_value = CURL_FORMADD_OPTION_TWICE;
+        else
+          current_form->showfilename = strdup(filename);
+        break;
+      }
+    default:
+      return_value = CURL_FORMADD_UNKNOWN_OPTION;
     }
-    else {
-      if ( (form_info->flags & HTTPPOST_FILENAME) &&
-	   (!form_info->contenttype) ) {
-	/* our contenttype is missing */
-	form_info->contenttype
-	  = strdup(ContentTypeForFilename(form_info->value, prevtype));
-      }
-      if ( !(form_info->flags & HTTPPOST_PTRNAME) &&
-	   (form_info == first_form_info) ) {
-	/* copy name (without strdup; possibly contains null characters) */
-	if (AllocAndCopy(&form_info->name, form_info->namelength)) {
-	  return_value = 8;
-	  break;
-	}
-      }
-      if ( !(form_info->flags & HTTPPOST_FILENAME) &&
-	   !(form_info->flags & HTTPPOST_PTRCONTENTS) ) {
-	/* copy value (without strdup; possibly contains null characters) */
-	if (AllocAndCopy(&form_info->value, form_info->contentslength)) {
-	  return_value = 8;
-	  break;
-	}
-      }
-      if ( (post = AddHttpPost (form_info->name, form_info->namelength,
-                                form_info->value, form_info->contentslength,
-                                form_info->contenttype, form_info->flags,
-				post, httppost,
-                                last_post)) == NULL) {
-        return_value = 7;
+  }
+
+  if(CURL_FORMADD_OK == return_value) {
+    /* go through the list, check for copleteness and if everything is
+     * alright add the HttpPost item otherwise set return_value accordingly */
+    
+    post = NULL;
+    for(form = first_form;
+        form != NULL;
+        form = form->more) {
+      if ( ((!form->name || !form->value) && !post) ||
+           ( (form->contentslength) &&
+             (form->flags & HTTPPOST_FILENAME) ) ||
+           ( (form->flags & HTTPPOST_FILENAME) &&
+             (form->flags & HTTPPOST_PTRCONTENTS) ) ||
+
+           /* CMC: Added support for buffer uploads */
+           ( (!form->buffer) &&
+             (form->flags & HTTPPOST_BUFFER) &&
+             (form->flags & HTTPPOST_PTRBUFFER) ) ||
+
+           ( (form->flags & HTTPPOST_READFILE) &&
+             (form->flags & HTTPPOST_PTRCONTENTS) )
+           ) {
+        return_value = CURL_FORMADD_INCOMPLETE;
+        break;
+      }
+      else {
+        if ( ((form->flags & HTTPPOST_FILENAME) ||
+              (form->flags & HTTPPOST_BUFFER)) &&
+             !form->contenttype ) {
+          /* our contenttype is missing */
+          form->contenttype
+            = strdup(ContentTypeForFilename(form->value, prevtype));
+        }
+        if ( !(form->flags & HTTPPOST_PTRNAME) &&
+             (form == first_form) ) {
+          /* copy name (without strdup; possibly contains null characters) */
+          if (AllocAndCopy(&form->name, form->namelength)) {
+            return_value = CURL_FORMADD_MEMORY;
+            break;
+          }
+        }
+        if ( !(form->flags & HTTPPOST_FILENAME) &&
+             !(form->flags & HTTPPOST_READFILE) && 
+             !(form->flags & HTTPPOST_PTRCONTENTS) &&
+
+             /* CMC: Added support for buffer uploads */
+             !(form->flags & HTTPPOST_PTRBUFFER) ) {
+
+          /* copy value (without strdup; possibly contains null characters) */
+          if (AllocAndCopy(&form->value, form->contentslength)) {
+            return_value = CURL_FORMADD_MEMORY;
+            break;
+          }
+        }
+        post = AddHttpPost(form->name, form->namelength,
+                           form->value, form->contentslength,
+
+                           /* CMC: Added support for buffer uploads */
+                           form->buffer, form->bufferlength,
+
+                           form->contenttype, form->flags,
+                           form->contentheader, form->showfilename,
+                           post, httppost,
+                           last_post);
+        
+        if(!post)
+          return_value = CURL_FORMADD_MEMORY;
+
+        if (form->contenttype)
+          prevtype = form->contenttype;
       }
-      if (form_info->contenttype)
-	prevtype = form_info->contenttype;
     }
-    form_info = form_info->more;
-  };
+  }
 
-  /* and finally delete the allocated memory */
-  form_info = first_form_info;
-  while (form_info != NULL) {
-    FormInfo *delete_form_info;
+  /* always delete the allocated memory before returning */
+  form = first_form;
+  while (form != NULL) {
+    FormInfo *delete_form;
     
-    delete_form_info = form_info;
-    form_info = form_info->more;
-    free (delete_form_info);
-  };
+    delete_form = form;
+    form = form->more;
+    free (delete_form);
+  }
 
   return return_value;
 }
 
-int curl_formadd(struct HttpPost **httppost,
-                 struct HttpPost **last_post,
+CURLFORMcode curl_formadd(struct curl_httppost **httppost,
+                 struct curl_httppost **last_post,
                  ...)
 {
   va_list arg;
-  int result;
+  CURLFORMcode result;
   va_start(arg, last_post);
   result = FormAdd(httppost, last_post, arg);
   va_end(arg);
   return result;
 }
 
@@ -801,13 +1011,13 @@
 
   /* we make it easier for plain strings: */
   if(!length)
     length = strlen((char *)line);
 
   newform->line = (char *)malloc(length+1);
-  memcpy(newform->line, line, length+1);
+  memcpy(newform->line, line, length);
   newform->length = length;
   newform->line[length]=0; /* zero terminate for easier debugging */
   
   if(*formp) {
     (*formp)->next = newform;
     *formp = newform;
@@ -836,26 +1046,26 @@
 {
   char *retstring;
   static int randomizer=0; /* this is just so that two boundaries within
 			      the same form won't be identical */
   int i;
 
-  static char table64[]=
-    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+  static char table62[]=
+    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
 
   retstring = (char *)malloc(BOUNDARY_LENGTH);
 
   if(!retstring)
     return NULL; /* failed */
 
   srand(time(NULL)+randomizer++); /* seed */
 
   strcpy(retstring, "curl"); /* bonus commercials 8*) */
 
   for(i=4; i<(BOUNDARY_LENGTH-1); i++) {
-    retstring[i] = table64[rand()%64];
+    retstring[i] = table62[rand()%62];
   }
   retstring[BOUNDARY_LENGTH-1]=0; /* zero terminate */
 
   return retstring;
 }
 
@@ -870,15 +1080,15 @@
     free(form);       /* free the struct */
   
   } while((form=next)); /* continue */
 }
 
 /* external function to free up a whole form post chain */
-void curl_formfree(struct HttpPost *form)
+void curl_formfree(struct curl_httppost *form)
 {
-  struct HttpPost *next;
+  struct curl_httppost *next;
 
   if(!form)
     /* no form to free, just get out of this */
     return;
 
   do {
@@ -891,31 +1101,37 @@
     if( !(form->flags & HTTPPOST_PTRNAME) && form->name)
       free(form->name); /* free the name */
     if( !(form->flags & HTTPPOST_PTRCONTENTS) && form->contents)
       free(form->contents); /* free the contents */
     if(form->contenttype)
       free(form->contenttype); /* free the content type */
+    if(form->showfilename)
+      free(form->showfilename); /* free the faked file name */
     free(form);       /* free the struct */
 
   } while((form=next)); /* continue */
 }
 
-struct FormData *Curl_getFormData(struct HttpPost *post,
-                                  int *sizep)
+CURLcode Curl_getFormData(struct FormData **finalform,
+                          struct curl_httppost *post,
+                          int *sizep)
 {
   struct FormData *form = NULL;
   struct FormData *firstform;
-
-  struct HttpPost *file;
+  struct curl_httppost *file;
+  CURLcode result = CURLE_OK;
 
   int size =0;
   char *boundary;
   char *fileboundary=NULL;
+  struct curl_slist* curList;
+
+  *finalform=NULL; /* default form is empty */
 
   if(!post)
-    return NULL; /* no input => no output! */
+    return result; /* no input => no output! */
 
   boundary = Curl_FormBoundary();
   
   /* Make the first line of the output */
   AddFormDataf(&form,
                "Content-Type: multipart/form-data;"
@@ -924,14 +1140,17 @@
   /* we DO NOT count that line since that'll be part of the header! */
 
   firstform = form;
   
   do {
 
+    if(size)
+      size += AddFormDataf(&form, "\r\n");
+
     /* boundary */
-    size += AddFormDataf(&form, "\r\n--%s\r\n", boundary);
+    size += AddFormDataf(&form, "--%s\r\n", boundary);
 
     size += AddFormData(&form,
                         "Content-Disposition: form-data; name=\"", 0);
 
     size += AddFormData(&form, post->name, post->namelength);
 
@@ -949,31 +1168,51 @@
 			   fileboundary);
     }
 
     file = post;
 
     do {
+
+      /* If 'showfilename' is set, that is a faked name passed on to us
+         to use to in the formpost. If that is not set, the actually used
+         local file name should be added. */
+
       if(post->more) {
 	/* if multiple-file */
 	size += AddFormDataf(&form,
-			     "\r\n--%s\r\nContent-Disposition: attachment; filename=\"%s\"",
-			     fileboundary, file->contents);
+                             "\r\n--%s\r\nContent-Disposition: "
+                             "attachment; filename=\"%s\"",
+                             fileboundary,
+                             (file->showfilename?file->showfilename:
+                              file->contents));
       }
-      else if(post->flags & HTTPPOST_FILENAME) {
+      else if((post->flags & HTTPPOST_FILENAME) ||
+
+              /* CMC: Added support for buffer uploads */
+              (post->flags & HTTPPOST_BUFFER)) {
+
 	size += AddFormDataf(&form,
 			     "; filename=\"%s\"",
-			     post->contents);
+                             (post->showfilename?post->showfilename:
+                              post->contents));
       }
       
       if(file->contenttype) {
 	/* we have a specified type */
 	size += AddFormDataf(&form,
 			     "\r\nContent-Type: %s",
 			     file->contenttype);
       }
 
+      curList = file->contentheader;
+      while( curList ) {
+        /* Process the additional headers specified for this form */
+        size += AddFormDataf( &form, "\r\n%s", curList->data );
+        curList = curList->next;
+      }
+
 #if 0
       /* The header Content-Transfer-Encoding: seems to confuse some receivers
        * (like the built-in PHP engine). While I can't see any reason why it
        * should, I can just as well skip this to the benefit of the users who
        * are using such confused receivers.
        */
@@ -993,27 +1232,40 @@
 	FILE *fileread;
 	char buffer[1024];
 	int nread;
 
 	fileread = strequal("-", file->contents)?stdin:
           /* binary read for win32 crap */
-/*VMS??*/ fopen(file->contents, "rb");  /* ONLY ALLOWS FOR STREAM FILES ON VMS */
-/*VMS?? Stream files are OK, as are FIXED & VAR files WITHOUT implied CC */
-/*VMS?? For implied CC, every record needs to have a \n appended & 1 added to SIZE */
+          /*VMS??*/ fopen(file->contents, "rb");  /* ONLY ALLOWS FOR STREAM FILES ON VMS */
+        /*VMS?? Stream files are OK, as are FIXED & VAR files WITHOUT implied CC */
+        /*VMS?? For implied CC, every record needs to have a \n appended & 1 added to SIZE */
 	if(fileread) {
-	  while((nread = fread(buffer, 1, 1024, fileread))) {
-	    size += AddFormData(&form,
-				buffer,
-				nread);
-	  }
+          while((nread = fread(buffer, 1, 1024, fileread)))
+            size += AddFormData(&form, buffer, nread);
+
           if(fileread != stdin)
             fclose(fileread);
-	} else {
-	  size += AddFormData(&form, "[File wasn't found by client]", 0);
 	}
-      } else {
+        else {
+#if 0
+          /* File wasn't found, add a nothing field! */
+          size += AddFormData(&form, "", 0);
+#endif
+          Curl_formclean(firstform);
+          free(boundary);
+          *finalform = NULL;
+          return CURLE_READ_ERROR;
+        }
+
+        /* CMC: Added support for buffer uploads */
+      } else if (post->flags & HTTPPOST_BUFFER) {
+          /* include contents of buffer */
+          size += AddFormData(&form, post->buffer, post->bufferlength);
+      }
+
+      else {
 	/* include the contents we got */
 	size += AddFormData(&form, post->contents, post->contentslength);
       }
     } while((file = file->more)); /* for each specified file for this field */
 
     if(post->more) {
@@ -1033,13 +1285,15 @@
 		       boundary);
 
   *sizep = size;
 
   free(boundary);
 
-  return firstform;
+  *finalform=firstform;
+
+  return result;
 }
 
 int Curl_FormInit(struct Form *form, struct FormData *formdata )
 {
   if(!formdata)
     return 1; /* error */
@@ -1140,14 +1394,14 @@
   return gotsize;
 }
 
 
 #ifdef _FORM_DEBUG
 int FormAddTest(const char * errormsg,
-                 struct HttpPost **httppost,
-                 struct HttpPost **last_post,
+                 struct curl_httppost **httppost,
+                 struct curl_httppost **last_post,
                  ...)
 {
   int result;
   va_list arg;
   va_start(arg, last_post);
   if ((result = FormAdd(httppost, last_post, arg)))
@@ -1166,12 +1420,14 @@
   char name4[] = "simple_PTRCONTENTS";
   char name5[] = "PTRCONTENTS_+_CONTENTSLENGTH";
   char name6[] = "PTRCONTENTS_+_CONTENTSLENGTH_+_CONTENTTYPE";
   char name7[] = "FILE1_+_CONTENTTYPE";
   char name8[] = "FILE1_+_FILE2";
   char name9[] = "FILE1_+_FILE2_+_FILE3";
+  char name10[] = "ARRAY: FILE1_+_FILE2_+_FILE3";
+  char name11[] = "FILECONTENT";
   char value1[] = "value for simple COPYCONTENTS";
   char value2[] = "value for COPYCONTENTS + CONTENTTYPE";
   char value3[] = "value for PTRNAME + NAMELENGTH + COPYNAME + CONTENTSLENGTH";
   char value4[] = "value for simple PTRCONTENTS";
   char value5[] = "value for PTRCONTENTS + CONTENTSLENGTH";
   char value6[] = "value for PTRCOTNENTS + CONTENTSLENGTH + CONTENTTYPE";
@@ -1185,14 +1441,15 @@
   int value5length = strlen(value4);
   int value6length = strlen(value5);
   int errors = 0;
   int size;
   int nread;
   char buffer[4096];
-  struct HttpPost *httppost=NULL;
-  struct HttpPost *last_post=NULL;
+  struct curl_httppost *httppost=NULL;
+  struct curl_httppost *last_post=NULL;
+  struct curl_forms forms[4];
 
   struct FormData *form;
   struct Form formread;
 
   if (FormAddTest("simple COPYCONTENTS test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name1, CURLFORM_COPYCONTENTS, value1,
@@ -1241,29 +1498,44 @@
                   CURLFORM_FILE, value8, CURLFORM_END))
     ++errors;
   if (FormAddTest("FILE1 + FILE2 + FILE3 test", &httppost, &last_post,
                   CURLFORM_COPYNAME, name9, CURLFORM_FILE, value7,
                   CURLFORM_FILE, value8, CURLFORM_FILE, value7, CURLFORM_END))
     ++errors;
+  forms[0].option = CURLFORM_FILE;
+  forms[0].value  = value7;
+  forms[1].option = CURLFORM_FILE;
+  forms[1].value  = value8;
+  forms[2].option = CURLFORM_FILE;
+  forms[2].value  = value7;
+  forms[3].option  = CURLFORM_END;
+  if (FormAddTest("FILE1 + FILE2 + FILE3 ARRAY test", &httppost, &last_post,
+                  CURLFORM_COPYNAME, name10, CURLFORM_ARRAY, forms,
+                  CURLFORM_END))
+    ++errors;
+  if (FormAddTest("FILECONTENT test", &httppost, &last_post,
+                  CURLFORM_COPYNAME, name11, CURLFORM_FILECONTENT, value7,
+                  CURLFORM_END))
+    ++errors;
 
   form=Curl_getFormData(httppost, &size);
 
   Curl_FormInit(&formread, form);
 
   do {
     nread = Curl_FormReader(buffer, 1, sizeof(buffer),
                             (FILE *)&formread);
 
     if(-1 == nread)
       break;
-    fwrite(buffer, nread, 1, stderr);
+    fwrite(buffer, nread, 1, stdout);
   } while(1);
 
-  fprintf(stderr, "size: %d\n", size);
+  fprintf(stdout, "size: %d\n", size);
   if (errors)
-    fprintf(stderr, "\n==> %d Test(s) failed!\n", errors);
+    fprintf(stdout, "\n==> %d Test(s) failed!\n", errors);
   else
     fprintf(stdout, "\nAll Tests seem to have worked (please check output)\n");
 
   return 0;
 }
 
@@ -1279,15 +1551,15 @@
     "name2 = number two data",
     "test = @upload"
   };
 #endif
   int i;
   char *nextarg;
-  struct HttpPost *httppost=NULL;
-  struct HttpPost *last_post=NULL;
-  struct HttpPost *post;
+  struct curl_httppost *httppost=NULL;
+  struct curl_httppost *last_post=NULL;
+  struct curl_httppost *post;
   int size;
   int nread;
   char buffer[4096];
 
   struct FormData *form;
   struct Form formread;
@@ -1320,13 +1592,15 @@
 
   return 0;
 }
 
 #endif
 
+#endif /* CURL_DISABLE_HTTP */
+
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/formdata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/formdata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/formdata.h	2001-08-28 16:54:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/formdata.h	2002-06-13 05:40:59.000000000 +0800
@@ -5,26 +5,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: formdata.h,v 1.8 2001/08/28 08:54:33 bagder Exp $
+ * $Id: formdata.h,v 1.13 2002/06/12 21:40:59 bagder Exp $
  *****************************************************************************/
 /* plain and simple linked list with lines to send */
 struct FormData {
   struct FormData *next;
   char *line;
   long length;
@@ -41,19 +41,29 @@
   char *name;
   long namelength;
   char *value;
   long contentslength;
   char *contenttype;
   long flags;
+
+		/* CMC: Added support for buffer uploads */
+  char *buffer;      /* pointer to existing buffer used for file upload */
+	long bufferlength;   
+
+  char *showfilename; /* The file name to show. If not set, the actual
+                         file name will be used */
+  struct curl_slist* contentheader;
   struct FormInfo *more;
 } FormInfo;
 
 int Curl_FormInit(struct Form *form, struct FormData *formdata );
 
-struct FormData *Curl_getFormData(struct HttpPost *post,
-                                  int *size);
+CURLcode
+Curl_getFormData(struct FormData **,
+                 struct HttpPost *post,
+                 int *size);
 
 /* fread() emulation */
 int Curl_FormReader(char *buffer,
                     size_t size,
                     size_t nitems,
                     FILE *mydata);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ftp.c	2001-09-24 20:37:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ftp.c	2002-06-13 17:21:08.000000000 +0800
@@ -2,30 +2,32 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.c,v 1.91 2001/09/23 12:47:07 bagder Exp $
+ * $Id: ftp.c,v 1.147 2002/06/13 09:21:08 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
+/* MN 06/07/02 */
+#ifndef CURL_DISABLE_FTP
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <ctype.h>
 #include <errno.h>
@@ -52,12 +54,13 @@
 #endif
 #include <sys/utsname.h>
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef	VMS
+#include <in.h>
 #include <inet.h>
 #endif
 #endif
 
 #if defined(WIN32) && defined(__GNUC__) || defined(__MINGW32__)
 #include <errno.h>
@@ -79,28 +82,42 @@
 #include "security.h"
 #include "krb4.h"
 #endif
 
 #include "strequal.h"
 #include "ssluse.h"
+#include "connect.h"
+
+#if defined(HAVE_INET_NTOA_R) && !defined(HAVE_INET_NTOA_R_DECL)
+#include "inet_ntoa_r.h"
+#endif
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 /* Local API functions */
-static CURLcode _ftp_sendquote(struct connectdata *conn, struct curl_slist *quote);
-static CURLcode _ftp_cwd(struct connectdata *conn, char *path);
+static CURLcode ftp_sendquote(struct connectdata *conn, struct curl_slist *quote);
+static CURLcode ftp_cwd(struct connectdata *conn, char *path);
 
 /* easy-to-use macro: */
-#define ftpsendf Curl_ftpsendf
+#define FTPSENDF(x,y,z) if((result = Curl_ftpsendf(x,y,z))) return result
 
+/***********************************************************************
+ *
+ * AllowServerConnect()
+ *
+ * When we've issue the PORT command, we have told the server to connect
+ * to us. This function will sit and wait here until the server has
+ * connected.
+ *
+ */
 static CURLcode AllowServerConnect(struct SessionHandle *data,
                                    struct connectdata *conn,
                                    int sock)
 {
   fd_set rdset;
   struct timeval dt;
@@ -154,24 +171,24 @@
 /*
  * Curl_GetFTPResponse() is supposed to be invoked after each command sent to
  * a remote FTP server. This function will wait and read all lines of the
  * response and extract the relevant return code for the invoking function.
  */
 
-int Curl_GetFTPResponse(int sockfd,
-                        char *buf,
+int Curl_GetFTPResponse(char *buf,
                         struct connectdata *conn,
                         int *ftpcode)
 {
   /* Brand new implementation.
    * We cannot read just one byte per read() and then go back to select()
    * as it seems that the OpenSSL read() stuff doesn't grok that properly.
    *
    * Alas, read as much as possible, split up into lines, use the ending
    * line in a response or continue reading.  */
 
+  int sockfd = conn->firstsocket;
   int nread;   /* total size read */
   int perline; /* count bytes per line */
   bool keepon=TRUE;
   ssize_t gotbytes;
   char *ptr;
   int timeout = 3600; /* default timeout in seconds */
@@ -179,30 +196,25 @@
   fd_set rkeepfd;
   fd_set readfd;
   struct SessionHandle *data = conn->data;
   char *line_start;
   int code=0; /* default "error code" to return */
 
-#define SELECT_OK      0
-#define SELECT_ERROR   1
-#define SELECT_TIMEOUT 2
+#define SELECT_OK       0
+#define SELECT_ERROR    1 /* select() problems */
+#define SELECT_TIMEOUT  2 /* took too long */
+#define SELECT_MEMORY   3 /* no available memory */
+#define SELECT_CALLBACK 4 /* aborted by callback */
+
   int error = SELECT_OK;
 
+  struct FTP *ftp = conn->proto.ftp;
+
   if (ftpcode)
     *ftpcode = 0; /* 0 for errors */
 
-  if(data->set.timeout) {
-    /* if timeout is requested, find out how much remaining time we have */
-    timeout = data->set.timeout - /* timeout time */
-      (Curl_tvlong(Curl_tvnow()) - Curl_tvlong(conn->now)); /* spent time */
-    if(timeout <=0 ) {
-      failf(data, "Transfer aborted due to timeout");
-      return -SELECT_TIMEOUT; /* already too little time */
-    }
-  }
-
   FD_ZERO (&readfd);		/* clear it */
   FD_SET (sockfd, &readfd);     /* read socket */
 
   /* get this in a backup variable to be able to restore it on each lap in the
      select() loop */
   rkeepfd = readfd;
@@ -212,33 +224,70 @@
 
   nread=0;
   perline=0;
   keepon=TRUE;
 
   while((nread<BUFSIZE) && (keepon && !error)) {
-    readfd = rkeepfd;		   /* set every lap */
-    interval.tv_sec = timeout;
-    interval.tv_usec = 0;
-
-    switch (select (sockfd+1, &readfd, NULL, NULL, &interval)) {
-    case -1: /* select() error, stop reading */
-      error = SELECT_ERROR;
-      failf(data, "Transfer aborted due to select() error");
-      break;
-    case 0: /* timeout */
-      error = SELECT_TIMEOUT;
-      failf(data, "Transfer aborted due to timeout");
-      break;
-    default:
+    /* check and reset timeout value every lap */
+    if(data->set.timeout) {
+      /* if timeout is requested, find out how much remaining time we have */
+      timeout = data->set.timeout - /* timeout time */
+        Curl_tvdiff(Curl_tvnow(), conn->now)/1000; /* spent time */
+      if(timeout <=0 ) {
+        failf(data, "Transfer aborted due to timeout");
+        return -SELECT_TIMEOUT; /* already too little time */
+      }
+    }
+
+    if(!ftp->cache) {
+      readfd = rkeepfd;		   /* set every lap */
+      interval.tv_sec = timeout;
+      interval.tv_usec = 0;
+
+      switch (select (sockfd+1, &readfd, NULL, NULL, &interval)) {
+      case -1: /* select() error, stop reading */
+        error = SELECT_ERROR;
+        failf(data, "Transfer aborted due to select() error");
+        break;
+      case 0: /* timeout */
+        error = SELECT_TIMEOUT;
+        failf(data, "Transfer aborted due to timeout");
+        break;
+      default:
+        error = SELECT_OK;
+        break;
+      }
+    }
+    if(SELECT_OK == error) {
       /*
        * This code previously didn't use the kerberos sec_read() code
        * to read, but when we use Curl_read() it may do so. Do confirm
        * that this is still ok and then remove this comment!
        */
-      if(CURLE_OK != Curl_read(conn, sockfd, ptr, BUFSIZE-nread, &gotbytes))
-        keepon = FALSE;
+      if(ftp->cache) {
+        /* we had data in the "cache", copy that instead of doing an actual
+           read */
+        memcpy(ptr, ftp->cache, ftp->cache_size);
+        gotbytes = ftp->cache_size;
+        free(ftp->cache);    /* free the cache */
+        ftp->cache = NULL;   /* clear the pointer */
+        ftp->cache_size = 0; /* zero the size just in case */
+      }
+      else {
+        int res = Curl_read(conn, sockfd, ptr,
+                            BUFSIZE-nread, &gotbytes);
+        if(res < 0)
+          /* EWOULDBLOCK */
+          continue; /* go looping again */
+
+        if(CURLE_OK != res)
+          keepon = FALSE;
+      }
+
+      if(!keepon)
+        ;
       else if(gotbytes <= 0) {
         keepon = FALSE;
         error = SELECT_ERROR;
         failf(data, "Connection aborted");
       }
       else {
@@ -250,48 +299,71 @@
         nread += gotbytes;
         for(i = 0; i < gotbytes; ptr++, i++) {
           perline++;
           if(*ptr=='\n') {
             /* a newline is CRLF in ftp-talk, so the CR is ignored as
                the line isn't really terminated until the LF comes */
+            CURLcode result;
 
             /* output debug output if that is requested */
-            if(data->set.verbose) {
-              fputs("< ", data->set.err);
-              fwrite(line_start, perline, 1, data->set.err);
-              /* no need to output LF here, it is part of the data */
-            }
+            if(data->set.verbose)
+              Curl_debug(data, CURLINFO_HEADER_IN, line_start, perline);
 
+            /*
+             * We pass all response-lines to the callback function registered
+             * for "headers". The response lines can be seen as a kind of
+             * headers.
+             */
+            result = Curl_client_write(data, CLIENTWRITE_HEADER,
+                                       line_start, perline);
+            if(result)
+              return -SELECT_CALLBACK;
+                                       
 #define lastline(line) (isdigit((int)line[0]) && isdigit((int)line[1]) && \
 			isdigit((int)line[2]) && (' ' == line[3]))
 
             if(perline>3 && lastline(line_start)) {
               /* This is the end of the last line, copy the last
                * line to the start of the buffer and zero terminate,
                * for old times sake (and krb4)! */
               char *meow;
-              int i;
-              for(meow=line_start, i=0; meow<ptr; meow++, i++)
-                buf[i] = *meow;
-              meow[i]=0; /* zero terminate */
+              int n;
+              for(meow=line_start, n=0; meow<ptr; meow++, n++)
+                buf[n] = *meow;
+              *meow=0; /* zero terminate */
               keepon=FALSE;
+              line_start = ptr+1; /* advance pointer */
+              i++; /* skip this before getting out */
               break;
             }
             perline=0; /* line starts over here */
             line_start = ptr+1;
           }
         }
-      }
-      break;
-    } /* switch */
+        if(!keepon && (i != gotbytes)) {
+          /* We found the end of the response lines, but we didn't parse the
+             full chunk of data we have read from the server. We therefore
+             need to store the rest of the data to be checked on the next
+             invoke as it may actually contain another end of response
+             already!  Cleverly figured out by Eric Lavigne in December
+             2001. */
+          ftp->cache_size = gotbytes - i;
+          ftp->cache = (char *)malloc(ftp->cache_size);
+          if(ftp->cache)
+            memcpy(ftp->cache, line_start, ftp->cache_size);
+          else
+            return -SELECT_MEMORY; /**BANG**/
+        }
+      } /* there was data */
+    } /* if(no error) */
   } /* while there's buffer left and loop is requested */
 
   if(!error)
     code = atoi(buf);
 
-#if KRB4
+#ifdef KRB4
   /* handle the security-oriented responses 6xx ***/
   /* FIXME: some errorchecking perhaps... ***/
   switch(code) {
   case 631:
     Curl_sec_read_msg(conn, buf, prot_safe);
     break;
@@ -313,12 +385,17 @@
   if(ftpcode)
     *ftpcode=code; /* return the initial number like this */
 
   return nread; /* total amount of bytes read */
 }
 
+#ifndef ENABLE_IPV6
+/*
+ * This function is only used by code that works on IPv4. When we add proper
+ * support for that functionality with IPv6, this function can go in again.
+ */
 /* -- who are we? -- */
 static char *getmyhost(char *buf, int buf_size)
 {
 #if defined(HAVE_GETHOSTNAME)
   gethostname(buf, buf_size);
 #elif defined(HAVE_UNAME)
@@ -330,26 +407,27 @@
   strncpy(buf, "localhost", buf_size);
   buf[buf_size - 1] = '\0';
 #endif
   return buf;
 }
 
+#endif /* ipv4-only function */
+
+
 /* ftp_connect() should do everything that is to be considered a part
    of the connection phase. */
 CURLcode Curl_ftp_connect(struct connectdata *conn)
 {
   /* this is FTP and no proxy */
   int nread;
   struct SessionHandle *data=conn->data;
   char *buf = data->state.buffer; /* this is our buffer */
   struct FTP *ftp;
   CURLcode result;
   int ftpcode;
 
-  myalarm(0); /* switch off the alarm stuff */
-
   ftp = (struct FTP *)malloc(sizeof(struct FTP));
   if(!ftp)
     return CURLE_OUT_OF_MEMORY;
 
   memset(ftp, 0, sizeof(struct FTP));
   conn->proto.ftp = ftp;
@@ -379,13 +457,13 @@
     if(result)
       return result;
   }
 
 
   /* The first thing we do is wait for the "220*" line: */
-  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode != 220) {
     failf(data, "This doesn't seem like a nice ftp-server response");
     return CURLE_FTP_WEIRD_SERVER_REPLY;
@@ -407,30 +485,30 @@
     else
       infof(data, "Authentication successful\n");
   }
 #endif
   
   /* send USER */
-  ftpsendf(conn->firstsocket, conn, "USER %s", ftp->user);
+  FTPSENDF(conn, "USER %s", ftp->user);
 
   /* wait for feedback */
-  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode == 530) {
     /* 530 User ... access denied
        (the server denies to log the specified user) */
     failf(data, "Access denied: %s", &buf[4]);
     return CURLE_FTP_ACCESS_DENIED;
   }
   else if(ftpcode == 331) {
     /* 331 Password required for ...
        (the server requires to send the user's password too) */
-    ftpsendf(conn->firstsocket, conn, "PASS %s", ftp->passwd);
-    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+    FTPSENDF(conn, "PASS %s", ftp->passwd);
+    nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode == 530) {
       /* 530 Login incorrect.
          (the username and/or the password are incorrect) */
@@ -469,16 +547,16 @@
   else {
     failf(data, "Odd return code after USER");
     return CURLE_FTP_WEIRD_USER_REPLY;
   }
 
   /* send PWD to discover our entry point */
-  ftpsendf(conn->firstsocket, conn, "PWD");
+  FTPSENDF(conn, "PWD", NULL);
 
   /* wait for feedback */
-  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode == 257) {
     char *dir = (char *)malloc(nread+1);
     char *store=dir;
@@ -523,90 +601,114 @@
     /* We couldn't read the PWD response! */
   }
 
   return CURLE_OK;
 }
 
-
-/* argument is already checked for validity */
+/***********************************************************************
+ *
+ * Curl_ftp_done()
+ *
+ * The DONE function. This does what needs to be done after a single DO has
+ * performed.
+ *
+ * Input argument is already checked for validity.
+ */
 CURLcode Curl_ftp_done(struct connectdata *conn)
 {
   struct SessionHandle *data = conn->data;
   struct FTP *ftp = conn->proto.ftp;
   ssize_t nread;
   char *buf = data->state.buffer; /* this is our buffer */
   int ftpcode;
+  CURLcode result=CURLE_OK;
 
   if(data->set.upload) {
-    if((-1 != data->set.infilesize) && (data->set.infilesize != *ftp->bytecountp)) {
-      failf(data, "Wrote only partial file (%d out of %d bytes)",
+    if((-1 != data->set.infilesize) &&
+       (data->set.infilesize != *ftp->bytecountp) &&
+       !data->set.crlf) {
+      failf(data, "Uploaded unaligned file size (%d out of %d bytes)",
             *ftp->bytecountp, data->set.infilesize);
       return CURLE_PARTIAL_FILE;
     }
   }
   else {
     if((-1 != conn->size) && (conn->size != *ftp->bytecountp) &&
        (conn->maxdownload != *ftp->bytecountp)) {
       failf(data, "Received only partial file: %d bytes", *ftp->bytecountp);
       return CURLE_PARTIAL_FILE;
     }
-    else if(!conn->bits.resume_done &&
-            !data->set.no_body &&
-            (0 == *ftp->bytecountp)) {
+    else if(!ftp->dont_check &&
+            !*ftp->bytecountp &&
+            (conn->size>0)) {
+      /* We consider this an error, but there's no true FTP error received
+         why we need to continue to "read out" the server response too.
+         We don't want to leave a "waiting" server reply if we'll get told
+         to make a second request on this same connection! */
       failf(data, "No data was received!");
-      return CURLE_FTP_COULDNT_RETR_FILE;
+      result = CURLE_FTP_COULDNT_RETR_FILE;
     }
   }
 
 #ifdef KRB4
   Curl_sec_fflush_fd(conn, conn->secondarysocket);
 #endif
   /* shut down the socket to inform the server we're done */
   sclose(conn->secondarysocket);
   conn->secondarysocket = -1;
 
-  if(!data->set.no_body && !conn->bits.resume_done) {  
-    /* now let's see what the server says about the transfer we
-       just performed: */
-    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  if(!data->set.no_body && !ftp->dont_check) {
+    /* now let's see what the server says about the transfer we just
+       performed: */
+    nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     /* 226 Transfer complete, 250 Requested file action okay, completed. */
     if((ftpcode != 226) && (ftpcode != 250)) {
       failf(data, "server did not report OK, got %d", ftpcode);
       return CURLE_FTP_WRITE_ERROR;
     }
   }
+  if(ftp->dont_check) {
+    /* if we don't check, we can't re-use this connection as it leaves the
+       control connection in a weird status */
+    conn->bits.close = TRUE;
+  }
 
   conn->bits.resume_done = FALSE; /* clean this for next connection */
 
   /* Send any post-transfer QUOTE strings? */
-  if(data->set.postquote) {
-    CURLcode result = _ftp_sendquote(conn, data->set.postquote);
-    return result;
-  }
+  if(!result && data->set.postquote)
+    result = ftp_sendquote(conn, data->set.postquote);
 
-  return CURLE_OK;
+  return result;
 }
 
+/***********************************************************************
+ *
+ * ftp_sendquote()
+ *
+ * Where a 'quote' means a list of custom commands to send to the server.
+ * The quote list is passed as an argument.
+ */
 
 static 
-CURLcode _ftp_sendquote(struct connectdata *conn, struct curl_slist *quote)
+CURLcode ftp_sendquote(struct connectdata *conn, struct curl_slist *quote)
 {
   struct curl_slist *item;
-  ssize_t            nread;
-  int                ftpcode;
+  ssize_t nread;
+  int ftpcode;
+  CURLcode result;
 
   item = quote;
   while (item) {
     if (item->data) {
-      ftpsendf(conn->firstsocket, conn, "%s", item->data);
+      FTPSENDF(conn, "%s", item->data);
 
-      nread = Curl_GetFTPResponse(conn->firstsocket, 
-                                  conn->data->state.buffer, conn, &ftpcode);
+      nread = Curl_GetFTPResponse(conn->data->state.buffer, conn, &ftpcode);
       if (nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 
       if (ftpcode >= 400) {
         failf(conn->data, "QUOT string not accepted: %s", item->data);
         return CURLE_FTP_QUOTE_ERROR;
@@ -616,45 +718,59 @@
     item = item->next;
   }
 
   return CURLE_OK;
 }
 
+/***********************************************************************
+ *
+ * ftp_cwd()
+ *
+ * Send 'CWD' to the remote server to Change Working Directory.
+ * It is the ftp version of the unix 'cd' command.
+ */
 static 
-CURLcode _ftp_cwd(struct connectdata *conn, char *path)
+CURLcode ftp_cwd(struct connectdata *conn, char *path)
 {
   ssize_t nread;
   int     ftpcode;
+  CURLcode result;
   
-  ftpsendf(conn->firstsocket, conn, "CWD %s", path);
-  nread = Curl_GetFTPResponse(conn->firstsocket, 
+  FTPSENDF(conn, "CWD %s", path);
+  nread = Curl_GetFTPResponse(
                               conn->data->state.buffer, conn, &ftpcode);
   if (nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if (ftpcode != 250) {
     failf(conn->data, "Couldn't cd to %s", path);
     return CURLE_FTP_ACCESS_DENIED;
   }
 
   return CURLE_OK;
 }
 
+/***********************************************************************
+ *
+ * ftp_getfiletime()
+ *
+ * Get the timestamp of the given file.
+ */
 static
-CURLcode _ftp_getfiletime(struct connectdata *conn, char *file)
+CURLcode ftp_getfiletime(struct connectdata *conn, char *file)
 {
   CURLcode result=CURLE_OK;
   int ftpcode; /* for ftp status */
   ssize_t nread;
   char *buf = conn->data->state.buffer;
 
   /* we have requested to get the modified-time of the file, this is yet
      again a grey area as the MDTM is not kosher RFC959 */
-  ftpsendf(conn->firstsocket, conn, "MDTM %s", file);
+  FTPSENDF(conn, "MDTM %s", file);
 
-  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode == 213) {
     /* we got a time. Format should be: "YYYYMMDDHHMMSS[.sss]" where the
        last .sss part is optional and means fractions of a second */
@@ -672,46 +788,62 @@
       infof(conn->data, "unsupported MDTM reply format\n");
     }
   }
   return  result;
 }
 
-static CURLcode _ftp_transfertype(struct connectdata *conn,
+/***********************************************************************
+ *
+ * ftp_transfertype()
+ *
+ * Set transfer type. We only deal with ASCII or BINARY so this function
+ * sets one of them.
+ */
+static CURLcode ftp_transfertype(struct connectdata *conn,
                                   bool ascii)
 {
   struct SessionHandle *data = conn->data;
   int ftpcode;
   ssize_t nread;
   char *buf=data->state.buffer;
+  CURLcode result;
 
-  ftpsendf(conn->firstsocket, conn, "TYPE %s", ascii?"A":"I");
+  FTPSENDF(conn, "TYPE %s", ascii?"A":"I");
 
-  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
   
   if(ftpcode != 200) {
     failf(data, "Couldn't set %s mode",
           ascii?"ASCII":"binary");
     return ascii? CURLE_FTP_COULDNT_SET_ASCII:CURLE_FTP_COULDNT_SET_BINARY;
   }
 
   return CURLE_OK;
 }
 
+/***********************************************************************
+ *
+ * ftp_getsize()
+ *
+ * Returns the file size (in bytes) of the given remote file.
+ */
+
 static
-CURLcode _ftp_getsize(struct connectdata *conn, char *file,
+CURLcode ftp_getsize(struct connectdata *conn, char *file,
                       ssize_t *size)
 {
   struct SessionHandle *data = conn->data;
   int ftpcode;
   ssize_t nread;
   char *buf=data->state.buffer;
+  CURLcode result;
 
-  ftpsendf(conn->firstsocket, conn, "SIZE %s", file);
-  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  FTPSENDF(conn, "SIZE %s", file);
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode == 213) {
     /* get the size from the ascii string: */
     *size = atoi(buf+4);
@@ -719,672 +851,794 @@
   else
     return CURLE_FTP_COULDNT_GET_SIZE;
 
   return CURLE_OK;
 }
 
-
-static
-CURLcode _ftp(struct connectdata *conn)
+/***************************************************************************
+ *
+ * ftp_pasv_verbose()
+ *
+ * This function only outputs some informationals about this second connection
+ * when we've issued a PASV command before and thus we have connected to a
+ * possibly new IP address.
+ *
+ */
+static void
+ftp_pasv_verbose(struct connectdata *conn,
+                 Curl_ipconnect *addr,
+                 char *newhost, /* ascii version */
+                 int port)
 {
-  /* this is FTP and no proxy */
-  ssize_t nread;
-  CURLcode result;
-  struct SessionHandle *data=conn->data;
-  char *buf = data->state.buffer; /* this is our buffer */
-  /* for the ftp PORT mode */
-  int portsock=-1;
-#if defined (HAVE_INET_NTOA_R)
-  char ntoa_buf[64];
-#endif
-#ifdef ENABLE_IPV6
-  struct addrinfo *ai;
-#else
-  struct sockaddr_in serv_addr;
-  char hostent_buf[8192];
-#endif
-
-  /* the ftp struct is already inited in ftp_connect() */
-  struct FTP *ftp = conn->proto.ftp;
-
-  long *bytecountp = ftp->bytecountp;
-  int ftpcode; /* for ftp status */
-
-  /* Send any QUOTE strings? */
-  if(data->set.quote) {
-    if ((result = _ftp_sendquote(conn, data->set.quote)) != CURLE_OK)
-      return result;
-  }
-    
-  /* This is a re-used connection. Since we change directory to where the
-     transfer is taking place, we must now get back to the original dir
-     where we ended up after login: */
-  if (conn->bits.reuse) {
-    if ((result = _ftp_cwd(conn, ftp->entrypath)) != CURLE_OK)
-      return result;
-  }
-
-  /* change directory first! */
-  if(ftp->dir && ftp->dir[0]) {
-    if ((result = _ftp_cwd(conn, ftp->dir)) != CURLE_OK)
-        return result;
-  }
-
-  /* Requested time of file? */
-  if(data->set.get_filetime && ftp->file) {
-    result = _ftp_getfiletime(conn, ftp->file);
-    if(result)
-      return result;
-  }
-
-  /* If we have selected NOBODY, it means that we only want file information.
-     Which in FTP can't be much more than the file size! */
-  if(data->set.no_body) {
-    /* The SIZE command is _not_ RFC 959 specified, and therefor many servers
-       may not support it! It is however the only way we have to get a file's
-       size! */
-    ssize_t filesize;
+#ifndef ENABLE_IPV6
+  /*****************************************************************
+   *
+   * IPv4-only code section
+   */
 
-    /* Some servers return different sizes for different modes, and thus we
-       must set the proper type before we check the size */
-    result = _ftp_transfertype(conn, data->set.ftp_ascii);
-    if(result)
-      return result;
+  struct in_addr in;
+  struct hostent * answer;
 
-    /* failing to get size is not a serious error */
-    result = _ftp_getsize(conn, ftp->file, &filesize);
+#ifdef HAVE_INET_NTOA_R
+  char ntoa_buf[64];
+#endif
+  /* The array size trick below is to make this a large chunk of memory
+     suitably 8-byte aligned on 64-bit platforms. This was thoughtfully
+     suggested by Philip Gladstone. */
+  long bigbuf[9000 / sizeof(long)];
 
-    if(CURLE_OK == result) {
-      sprintf(buf, "Content-Length: %d\r\n", filesize);
-      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
-      if(result)
-        return result;
-    }
+#if defined(HAVE_INET_ADDR)
+  in_addr_t address;
+# if defined(HAVE_GETHOSTBYADDR_R)
+  int h_errnop;
+# endif
+  char *hostent_buf = (char *)bigbuf; /* get a char * to the buffer */
 
-    /* If we asked for a time of the file and we actually got one as
-       well, we "emulate" a HTTP-style header in our output. */
+  address = inet_addr(newhost);
+# ifdef HAVE_GETHOSTBYADDR_R
 
-#ifdef HAVE_STRFTIME
-    if(data->set.get_filetime && data->info.filetime) {
-      struct tm *tm;
-#ifdef HAVE_LOCALTIME_R
-      struct tm buffer;
-      tm = (struct tm *)localtime_r(&data->info.filetime, &buffer);
+#  ifdef HAVE_GETHOSTBYADDR_R_5
+  /* AIX, Digital Unix (OSF1, Tru64) style:
+     extern int gethostbyaddr_r(char *addr, size_t len, int type,
+     struct hostent *htent, struct hostent_data *ht_data); */
+
+  /* Fred Noz helped me try this out, now it at least compiles! */
+
+  /* Bjorn Reese (November 28 2001):
+     The Tru64 man page on gethostbyaddr_r() says that
+     the hostent struct must be filled with zeroes before the call to
+     gethostbyaddr_r(). */
+
+  memset(hostent_buf, 0, sizeof(struct hostent));
+
+  if(gethostbyaddr_r((char *) &address,
+                     sizeof(address), AF_INET,
+                     (struct hostent *)hostent_buf,
+                     (struct hostent_data *)(hostent_buf + sizeof(*answer))))
+    answer=NULL;
+  else
+    answer=(struct hostent *)hostent_buf;
+                           
+#  endif
+#  ifdef HAVE_GETHOSTBYADDR_R_7
+  /* Solaris and IRIX */
+  answer = gethostbyaddr_r((char *) &address, sizeof(address), AF_INET,
+                           (struct hostent *)bigbuf,
+                           hostent_buf + sizeof(*answer),
+                           sizeof(bigbuf) - sizeof(*answer),
+                           &h_errnop);
+#  endif
+#  ifdef HAVE_GETHOSTBYADDR_R_8
+  /* Linux style */
+  if(gethostbyaddr_r((char *) &address, sizeof(address), AF_INET,
+                     (struct hostent *)hostent_buf,
+                     hostent_buf + sizeof(*answer),
+                     sizeof(bigbuf) - sizeof(*answer),
+                     &answer,
+                     &h_errnop))
+    answer=NULL; /* error */
+#  endif
+        
+# else
+  answer = gethostbyaddr((char *) &address, sizeof(address), AF_INET);
+# endif
 #else
-      tm = localtime(&data->info.filetime);
+  answer = NULL;
 #endif
-      /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
-      strftime(buf, BUFSIZE-1, "Last-Modified: %a, %d %b %Y %H:%M:%S %Z\r\n",
-               tm);
-      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
-      if(result)
-        return result;
-    }
+  (void) memcpy(&in.s_addr, addr, sizeof (Curl_ipconnect));
+  infof(conn->data, "Connecting to %s (%s) port %u\n",
+        answer?answer->h_name:newhost,
+#if defined(HAVE_INET_NTOA_R)
+        inet_ntoa_r(in, ntoa_buf, sizeof(ntoa_buf)),
+#else
+        inet_ntoa(in),
 #endif
+        port);
 
-    return CURLE_OK;
-  }
-
-  /* We have chosen to use the PORT command */
-  if(data->set.ftp_use_port) {
-#ifdef ENABLE_IPV6
-    struct addrinfo hints, *res, *ai;
-    struct sockaddr_storage ss;
-    socklen_t sslen;
-    char hbuf[NI_MAXHOST];
-
-    struct sockaddr *sa=(struct sockaddr *)&ss;
+#else
+  /*****************************************************************
+   *
+   * IPv6-only code section
+   */
+  char hbuf[NI_MAXHOST]; /* ~1KB */
+  char nbuf[NI_MAXHOST]; /* ~1KB */
+  char sbuf[NI_MAXSERV]; /* around 32 */
 #ifdef NI_WITHSCOPEID
-    const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
+  const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
 #else
-    const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;
+  const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;
+#endif
+  port = 0; /* unused, prevent warning */
+  if (getnameinfo(addr->ai_addr, addr->ai_addrlen,
+                  nbuf, sizeof(nbuf), sbuf, sizeof(sbuf), niflags)) {
+    snprintf(nbuf, sizeof(nbuf), "?");
+    snprintf(sbuf, sizeof(sbuf), "?");
+  }
+        
+  if (getnameinfo(addr->ai_addr, addr->ai_addrlen,
+                  hbuf, sizeof(hbuf), NULL, 0, 0)) {
+    infof(conn->data, "Connecting to %s (%s) port %s\n", nbuf, newhost, sbuf);
+  }
+  else {
+    infof(conn->data, "Connecting to %s (%s) port %s\n", hbuf, nbuf, sbuf);
+  }
 #endif
-    unsigned char *ap;
-    unsigned char *pp;
-    int alen, plen;
-    char portmsgbuf[4096], tmp[4096];
+}
 
-    const char *mode[] = { "EPRT", "LPRT", "PORT", NULL };
-    char **modep;
+/***********************************************************************
+ *
+ * ftp_use_port()
+ *
+ * Send the proper PORT command. PORT is the ftp client's way of telling the
+ * server that *WE* open a port that we listen on an awaits the server to
+ * connect to. This is the opposite of PASV.
+ */
 
-    /*
-     * we should use Curl_if2ip?  given pickiness of recent ftpd,
-     * I believe we should use the same address as the control connection.
-     */
-    sslen = sizeof(ss);
-    if (getsockname(conn->firstsocket, (struct sockaddr *)&ss, &sslen) < 0)
-      return CURLE_FTP_PORT_FAILED;
+static
+CURLcode ftp_use_port(struct connectdata *conn)
+{
+  struct SessionHandle *data=conn->data;
+  int portsock=-1;
+  ssize_t nread;
+  char *buf = data->state.buffer; /* this is our buffer */
+  int ftpcode; /* receive FTP response codes in this */
+  CURLcode result;
 
-    if (getnameinfo((struct sockaddr *)&ss, sslen, hbuf, sizeof(hbuf), NULL, 0,
-                    niflags))
-      return CURLE_FTP_PORT_FAILED;
+#ifdef ENABLE_IPV6
+  /******************************************************************
+   *
+   * Here's a piece of IPv6-specific code coming up
+   *
+   */
 
-    memset(&hints, 0, sizeof(hints));
-    hints.ai_family = sa->sa_family;
-    /*hints.ai_family = ss.ss_family;
-      this way can be used if sockaddr_storage is properly defined, as glibc 
-      2.1.X doesn't do*/
-    hints.ai_socktype = SOCK_STREAM;
-    hints.ai_flags = AI_PASSIVE;
-    if (getaddrinfo(hbuf, "0", &hints, &res))
-      return CURLE_FTP_PORT_FAILED;
+  struct addrinfo hints, *res, *ai;
+  struct sockaddr_storage ss;
+  socklen_t sslen;
+  char hbuf[NI_MAXHOST];
 
-    portsock = -1;
-    for (ai = res; ai; ai = ai->ai_next) {
-      portsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
-      if (portsock < 0)
-        continue;
+  struct sockaddr *sa=(struct sockaddr *)&ss;
+#ifdef NI_WITHSCOPEID
+  const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
+#else
+  const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;
+#endif
+  unsigned char *ap;
+  unsigned char *pp;
+  int alen, plen;
+  char portmsgbuf[4096], tmp[4096];
+
+  const char *mode[] = { "EPRT", "LPRT", "PORT", NULL };
+  char **modep;
+
+  /*
+   * we should use Curl_if2ip?  given pickiness of recent ftpd,
+   * I believe we should use the same address as the control connection.
+   */
+  sslen = sizeof(ss);
+  if (getsockname(conn->firstsocket, (struct sockaddr *)&ss, &sslen) < 0)
+    return CURLE_FTP_PORT_FAILED;
+  
+  if (getnameinfo((struct sockaddr *)&ss, sslen, hbuf, sizeof(hbuf), NULL, 0,
+                  niflags))
+    return CURLE_FTP_PORT_FAILED;
 
-      if (bind(portsock, ai->ai_addr, ai->ai_addrlen) < 0) {
-        sclose(portsock);
-        portsock = -1;
-        continue;
-      }
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = sa->sa_family;
+  /*hints.ai_family = ss.ss_family;
+    this way can be used if sockaddr_storage is properly defined, as glibc 
+    2.1.X doesn't do*/
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_PASSIVE;
 
-      if (listen(portsock, 1) < 0) {
-        sclose(portsock);
-        portsock = -1;
-        continue;
-      }
+  if (getaddrinfo(hbuf, (char *)"0", &hints, &res))
+    return CURLE_FTP_PORT_FAILED;
+  
+  portsock = -1;
+  for (ai = res; ai; ai = ai->ai_next) {
+    portsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
+    if (portsock < 0)
+      continue;
 
-      break;
+    if (bind(portsock, ai->ai_addr, ai->ai_addrlen) < 0) {
+      sclose(portsock);
+      portsock = -1;
+      continue;
     }
-    if (portsock < 0) {
-      failf(data, strerror(errno));
-      freeaddrinfo(res);
-      return CURLE_FTP_PORT_FAILED;
+      
+    if (listen(portsock, 1) < 0) {
+      sclose(portsock);
+      portsock = -1;
+      continue;
     }
+    
+    break;
+  }
+  freeaddrinfo(res);
+  if (portsock < 0) {
+    failf(data, "%s", strerror(errno));
+    return CURLE_FTP_PORT_FAILED;
+  }
 
-    sslen = sizeof(ss);
-    if (getsockname(portsock, sa, &sslen) < 0) {
-      failf(data, strerror(errno));
-      freeaddrinfo(res);
-      return CURLE_FTP_PORT_FAILED;
+  sslen = sizeof(ss);
+  if (getsockname(portsock, sa, &sslen) < 0) {
+    failf(data, "%s", strerror(errno));
+    return CURLE_FTP_PORT_FAILED;
+  }
+
+  for (modep = (char **)mode; modep && *modep; modep++) {
+    int lprtaf, eprtaf;
+    
+    switch (sa->sa_family) {
+    case AF_INET:
+      ap = (unsigned char *)&((struct sockaddr_in *)&ss)->sin_addr;
+      alen = sizeof(((struct sockaddr_in *)&ss)->sin_addr);
+      pp = (unsigned char *)&((struct sockaddr_in *)&ss)->sin_port;
+      plen = sizeof(((struct sockaddr_in *)&ss)->sin_port);
+      lprtaf = 4;
+      eprtaf = 1;
+      break;
+    case AF_INET6:
+      ap = (unsigned char *)&((struct sockaddr_in6 *)&ss)->sin6_addr;
+      alen = sizeof(((struct sockaddr_in6 *)&ss)->sin6_addr);
+      pp = (unsigned char *)&((struct sockaddr_in6 *)&ss)->sin6_port;
+      plen = sizeof(((struct sockaddr_in6 *)&ss)->sin6_port);
+      lprtaf = 6;
+      eprtaf = 2;
+      break;
+    default:
+      ap = pp = NULL;
+      lprtaf = eprtaf = -1;
+      break;
     }
 
-    for (modep = (char *)mode; modep && *modep; modep++) {
-      int lprtaf, eprtaf;
+    if (strcmp(*modep, "EPRT") == 0) {
+      if (eprtaf < 0)
+        continue;
+      if (getnameinfo((struct sockaddr *)&ss, sslen,
+                      portmsgbuf, sizeof(portmsgbuf), tmp, sizeof(tmp), niflags))
+        continue;
 
-      switch (sa->sa_family) {
-      case AF_INET:
-        ap = (unsigned char *)&((struct sockaddr_in *)&ss)->sin_addr;
-        alen = sizeof(((struct sockaddr_in *)&ss)->sin_addr);
-        pp = (unsigned char *)&((struct sockaddr_in *)&ss)->sin_port;
-        plen = sizeof(((struct sockaddr_in *)&ss)->sin_port);
-        lprtaf = 4;
-        eprtaf = 1;
-        break;
-      case AF_INET6:
-        ap = (unsigned char *)&((struct sockaddr_in6 *)&ss)->sin6_addr;
-        alen = sizeof(((struct sockaddr_in6 *)&ss)->sin6_addr);
-        pp = (unsigned char *)&((struct sockaddr_in6 *)&ss)->sin6_port;
-        plen = sizeof(((struct sockaddr_in6 *)&ss)->sin6_port);
-        lprtaf = 6;
-        eprtaf = 2;
-        break;
-      default:
-        ap = pp = NULL;
-        lprtaf = eprtaf = -1;
-        break;
+      /* do not transmit IPv6 scope identifier to the wire */
+      if (sa->sa_family == AF_INET6) {
+        char *q = strchr(portmsgbuf, '%');
+          if (q)
+            *q = '\0';
       }
 
-      if (strcmp(*modep, "EPRT") == 0) {
-        if (eprtaf < 0)
-          continue;
-        if (getnameinfo((struct sockaddr *)&ss, sslen,
-                         portmsgbuf, sizeof(portmsgbuf), tmp, sizeof(tmp), niflags))
-          continue;
+      result = Curl_ftpsendf(conn, "%s |%d|%s|%s|", *modep, eprtaf,
+                             portmsgbuf, tmp);
+      if(result)
+        return result;
+    } else if (strcmp(*modep, "LPRT") == 0 ||
+               strcmp(*modep, "PORT") == 0) {
+      int i;
+      
+      if (strcmp(*modep, "LPRT") == 0 && lprtaf < 0)
+        continue;
+      if (strcmp(*modep, "PORT") == 0 && sa->sa_family != AF_INET)
+        continue;
 
-        /* do not transmit IPv6 scope identifier to the wire */
-      	if (sa->sa_family == AF_INET6) {
-          char *q = strchr(portmsgbuf, '%');
-          if (q)
-            *q = '\0';
+      portmsgbuf[0] = '\0';
+      if (strcmp(*modep, "LPRT") == 0) {
+        snprintf(tmp, sizeof(tmp), "%d,%d", lprtaf, alen);
+        if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >=
+            sizeof(portmsgbuf)) {
+          continue;
         }
+      }
 
-        ftpsendf(conn->firstsocket, conn, "%s |%d|%s|%s|", *modep, eprtaf,
-                 portmsgbuf, tmp);
-      } else if (strcmp(*modep, "LPRT") == 0 ||
-                 strcmp(*modep, "PORT") == 0) {
-        int i;
-
-        if (strcmp(*modep, "LPRT") == 0 && lprtaf < 0)
-          continue;
-        if (strcmp(*modep, "PORT") == 0 && sa->sa_family != AF_INET)
+      for (i = 0; i < alen; i++) {
+        if (portmsgbuf[0])
+          snprintf(tmp, sizeof(tmp), ",%u", ap[i]);
+        else
+          snprintf(tmp, sizeof(tmp), "%u", ap[i]);
+        
+        if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >=
+            sizeof(portmsgbuf)) {
           continue;
-
-        portmsgbuf[0] = '\0';
-        if (strcmp(*modep, "LPRT") == 0) {
-          snprintf(tmp, sizeof(tmp), "%d,%d", lprtaf, alen);
-          if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
-            continue;
-          }
-        }
-
-        for (i = 0; i < alen; i++) {
-          if (portmsgbuf[0])
-            snprintf(tmp, sizeof(tmp), ",%u", ap[i]);
-          else
-            snprintf(tmp, sizeof(tmp), "%u", ap[i]);
-
-          if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
-            continue;
-          }
-        }
-
-        if (strcmp(*modep, "LPRT") == 0) {
-          snprintf(tmp, sizeof(tmp), ",%d", plen);
-
-          if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf))
-            continue;
         }
+      }
+      
+      if (strcmp(*modep, "LPRT") == 0) {
+        snprintf(tmp, sizeof(tmp), ",%d", plen);
+        
+        if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf))
+          continue;
+      }
 
-        for (i = 0; i < plen; i++) {
-          snprintf(tmp, sizeof(tmp), ",%u", pp[i]);
-
-          if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
-              continue;
-          }
+      for (i = 0; i < plen; i++) {
+        snprintf(tmp, sizeof(tmp), ",%u", pp[i]);
+        
+        if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >=
+            sizeof(portmsgbuf)) {
+          continue;
         }
-
-        ftpsendf(conn->firstsocket, conn, "%s %s", *modep, portmsgbuf);
       }
-
-      nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
-      if(nread < 0)
-        return CURLE_OPERATION_TIMEOUTED;
-
-      if (ftpcode != 200) {
-        failf(data, "Server does not grok %s", *modep);
-        continue;
-      } else
-        break;
+      
+      result = Curl_ftpsendf(conn, "%s %s", *modep, portmsgbuf);
+      if(result)
+        return result;
     }
-
-    if (!*modep) {
-      sclose(portsock);
-      freeaddrinfo(res);
-      return CURLE_FTP_PORT_FAILED;
+    
+    nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
+    if(nread < 0)
+      return CURLE_OPERATION_TIMEOUTED;
+    
+    if (ftpcode != 200) {
+      failf(data, "Server does not grok %s", *modep);
+      continue;
     }
-    /* we set the secondary socket variable to this for now, it
-       is only so that the cleanup function will close it in case
-       we fail before the true secondary stuff is made */
-    conn->secondarysocket = portsock;
-
+    else
+      break;
+  }
+  
+  if (!*modep) {
+    sclose(portsock);
+    return CURLE_FTP_PORT_FAILED;
+  }
+  /* we set the secondary socket variable to this for now, it
+     is only so that the cleanup function will close it in case
+     we fail before the true secondary stuff is made */
+  conn->secondarysocket = portsock;
+  
 #else
-    struct sockaddr_in sa;
-    struct hostent *h=NULL;
-    char *hostdataptr=NULL;
-    size_t size;
-    unsigned short porttouse;
-    char myhost[256] = "";
-
-    if(data->set.ftpport) {
-      if(Curl_if2ip(data->set.ftpport, myhost, sizeof(myhost))) {
-        h = Curl_gethost(data, myhost, &hostdataptr);
-      }
-      else {
-        if(strlen(data->set.ftpport)>1)
-          h = Curl_gethost(data, data->set.ftpport, &hostdataptr);
-        if(h)
-          strcpy(myhost, data->set.ftpport); /* buffer overflow risk */
-      }
-    }
-    if(! *myhost) {
-      h=Curl_gethost(data,
-                     getmyhost(myhost, sizeof(myhost)),
-                     &hostdataptr);
-    }
-    infof(data, "We connect from %s\n", myhost);
-
-    if ( h ) {
-      if( (portsock = socket(AF_INET, SOCK_STREAM, 0)) >= 0 ) {
-
-        /* we set the secondary socket variable to this for now, it
-           is only so that the cleanup function will close it in case
-           we fail before the true secondary stuff is made */
-        conn->secondarysocket = portsock;
-
-        memset((char *)&sa, 0, sizeof(sa));
-        memcpy((char *)&sa.sin_addr,
-               h->h_addr,
-               h->h_length);
-        sa.sin_family = AF_INET;
-        sa.sin_addr.s_addr = INADDR_ANY;
-        sa.sin_port = 0;
-        size = sizeof(sa);
-
-        if(bind(portsock, (struct sockaddr *)&sa, size) >= 0) {
-          /* we succeeded to bind */
-          struct sockaddr_in add;
-          size = sizeof(add);
-
-          if(getsockname(portsock, (struct sockaddr *) &add,
-                         (socklen_t *)&size)<0) {
-            failf(data, "getsockname() failed");
-            return CURLE_FTP_PORT_FAILED;
-          }
-          porttouse = ntohs(add.sin_port);
-
-          if ( listen(portsock, 1) < 0 ) {
-            failf(data, "listen(2) failed on socket");
-            free(hostdataptr);
-            return CURLE_FTP_PORT_FAILED;
-          }
+  /******************************************************************
+   *
+   * Here's a piece of IPv4-specific code coming up
+   *
+   */
+  struct sockaddr_in sa;
+  struct hostent *h=NULL;
+  char *hostdataptr=NULL;
+  unsigned short porttouse;
+  char myhost[256] = "";
+
+  if(data->set.ftpport) {
+    if(Curl_if2ip(data->set.ftpport, myhost, sizeof(myhost))) {
+      h = Curl_resolv(data, myhost, 0);
+    }
+    else {
+      int len = strlen(data->set.ftpport);
+      if(len>1)
+        h = Curl_resolv(data, data->set.ftpport, 0);
+      if(h)
+        strcpy(myhost, data->set.ftpport); /* buffer overflow risk */
+    }
+  }
+  if(! *myhost) {
+    char *tmp_host = getmyhost(myhost, sizeof(myhost));
+    h=Curl_resolv(data, tmp_host, 0);
+  }
+  infof(data, "We connect from %s\n", myhost);
+  
+  if ( h ) {
+    if( (portsock = socket(AF_INET, SOCK_STREAM, 0)) >= 0 ) {
+      int size;
+      
+      /* we set the secondary socket variable to this for now, it
+         is only so that the cleanup function will close it in case
+         we fail before the true secondary stuff is made */
+      conn->secondarysocket = portsock;
+
+      memset((char *)&sa, 0, sizeof(sa));
+      memcpy((char *)&sa.sin_addr,
+             h->h_addr,
+             h->h_length);
+      sa.sin_family = AF_INET;
+      sa.sin_addr.s_addr = INADDR_ANY;
+      sa.sin_port = 0;
+      size = sizeof(sa);
+      
+      if(bind(portsock, (struct sockaddr *)&sa, size) >= 0) {
+        /* we succeeded to bind */
+        struct sockaddr_in add;
+        socklen_t socksize = sizeof(add);
+
+        if(getsockname(portsock, (struct sockaddr *) &add,
+                       &socksize)<0) {
+          failf(data, "getsockname() failed");
+          return CURLE_FTP_PORT_FAILED;
         }
-        else {
-          failf(data, "bind(2) failed on socket");
+        porttouse = ntohs(add.sin_port);
+        
+        if ( listen(portsock, 1) < 0 ) {
+          failf(data, "listen(2) failed on socket");
           free(hostdataptr);
           return CURLE_FTP_PORT_FAILED;
         }
       }
       else {
-        failf(data, "socket(2) failed (%s)");
+        failf(data, "bind(2) failed on socket");
         free(hostdataptr);
         return CURLE_FTP_PORT_FAILED;
       }
-      if(hostdataptr)
-        /* free the memory used for name lookup */
-        free(hostdataptr);
     }
     else {
-      failf(data, "could't find my own IP address (%s)", myhost);
+      failf(data, "socket(2) failed (%s)");
+      free(hostdataptr);
       return CURLE_FTP_PORT_FAILED;
     }
-    {
-      struct in_addr in;
-      unsigned short ip[5];
-      (void) memcpy(&in.s_addr, *h->h_addr_list, sizeof (in.s_addr));
-#if defined (HAVE_INET_NTOA_R)
-      /* ignore the return code from inet_ntoa_r() as it is int or
-         char * depending on system */
-      inet_ntoa_r(in, ntoa_buf, sizeof(ntoa_buf));
-      sscanf( ntoa_buf, "%hu.%hu.%hu.%hu",
-              &ip[0], &ip[1], &ip[2], &ip[3]);
+  }
+  else {
+    failf(data, "could't find my own IP address (%s)", myhost);
+    return CURLE_FTP_PORT_FAILED;
+  }
+  {
+#ifdef HAVE_INET_NTOA_R
+    char ntoa_buf[64];
+#endif
+    struct in_addr in;
+    unsigned short ip[5];
+    (void) memcpy(&in.s_addr, *h->h_addr_list, sizeof (in.s_addr));
+#ifdef HAVE_INET_NTOA_R
+    /* ignore the return code from inet_ntoa_r() as it is int or
+       char * depending on system */
+    inet_ntoa_r(in, ntoa_buf, sizeof(ntoa_buf));
+    sscanf( ntoa_buf, "%hu.%hu.%hu.%hu",
+            &ip[0], &ip[1], &ip[2], &ip[3]);
 #else
-      sscanf( inet_ntoa(in), "%hu.%hu.%hu.%hu",
-              &ip[0], &ip[1], &ip[2], &ip[3]);
+    sscanf( inet_ntoa(in), "%hu.%hu.%hu.%hu",
+            &ip[0], &ip[1], &ip[2], &ip[3]);
 #endif
-      ftpsendf(conn->firstsocket, conn, "PORT %d,%d,%d,%d,%d,%d",
-            ip[0], ip[1], ip[2], ip[3],
-            porttouse >> 8,
-            porttouse & 255);
-    }
+    result=Curl_ftpsendf(conn, "PORT %d,%d,%d,%d,%d,%d",
+                         ip[0], ip[1], ip[2], ip[3],
+                         porttouse >> 8,
+                         porttouse & 255);
+    if(result)
+      return result;
+  }
 
-    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
-    if(nread < 0)
-      return CURLE_OPERATION_TIMEOUTED;
+  nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
+  if(nread < 0)
+    return CURLE_OPERATION_TIMEOUTED;
 
-    if(ftpcode != 200) {
-      failf(data, "Server does not grok PORT, try without it!");
-      return CURLE_FTP_PORT_FAILED;
-    }     
-#endif /* ENABLE_IPV6 */
+  if(ftpcode != 200) {
+    failf(data, "Server does not grok PORT, try without it!");
+    return CURLE_FTP_PORT_FAILED;
   }
-  else { /* we use the PASV command */
+#endif /* end of ipv4-specific code */
+
+  return CURLE_OK;
+}
+
+/***********************************************************************
+ *
+ * ftp_use_pasv()
+ *
+ * Send the PASV command. PASV is the ftp client's way of asking the server to
+ * open a second port that we can connect to (for the data transfer). This is
+ * the opposite of PORT.
+ */
+
+static
+CURLcode ftp_use_pasv(struct connectdata *conn)
+{
+  struct SessionHandle *data = conn->data;
+  ssize_t nread;
+  char *buf = data->state.buffer; /* this is our buffer */
+  int ftpcode; /* receive FTP response codes in this */
+  CURLcode result;
+  Curl_addrinfo *addr=NULL;
+  Curl_ipconnect *conninfo;
+
+  /*
+    Here's the excecutive summary on what to do:
+
+    PASV is RFC959, expect:
+    227 Entering Passive Mode (a1,a2,a3,a4,p1,p2)
+
+    LPSV is RFC1639, expect:
+    228 Entering Long Passive Mode (4,4,a1,a2,a3,a4,2,p1,p2)
+
+    EPSV is RFC2428, expect:
+    229 Entering Extended Passive Mode (|||port|)
+
+  */
+
+#if 1
+  const char *mode[] = { "EPSV", "PASV", NULL };
+  int results[] = { 229, 227, 0 };
+#else
 #if 0
-    /* no support for IPv6 passive mode yet */
-    char *mode[] = { "EPSV", "LPSV", "PASV", NULL };
-    int results[] = { 229, 228, 227, 0 };
+  char *mode[] = { "EPSV", "LPSV", "PASV", NULL };
+  int results[] = { 229, 228, 227, 0 };
 #else
-    const char *mode[] = { "PASV", NULL };
-    int results[] = { 227, 0 };
+  const char *mode[] = { "PASV", NULL };
+  int results[] = { 227, 0 };
 #endif
-    int modeoff;
+#endif
+  int modeoff;
+  unsigned short connectport; /* the local port connect() should use! */
+  unsigned short newport; /* remote port, not necessary the local one */
+  
+  /* newhost must be able to hold a full IP-style address in ASCII, which
+     in the IPv6 case means 5*8-1 = 39 letters */
+  char newhost[48];
+  char *newhostp=NULL;
+  
+  for (modeoff = (data->set.ftp_use_epsv?0:1);
+       mode[modeoff]; modeoff++) {
+    result = Curl_ftpsendf(conn, "%s", mode[modeoff]);
+    if(result)
+      return result;
+    nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
+    if(nread < 0)
+      return CURLE_OPERATION_TIMEOUTED;
+    if (ftpcode == results[modeoff])
+      break;
+  }
 
-    for (modeoff = 0; mode[modeoff]; modeoff++) {
-      ftpsendf(conn->firstsocket, conn, mode[modeoff]);
-      nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
-      if(nread < 0)
-        return CURLE_OPERATION_TIMEOUTED;
+  if (!mode[modeoff]) {
+    failf(data, "Odd return code after PASV");
+    return CURLE_FTP_WEIRD_PASV_REPLY;
+  }
+  else if (227 == results[modeoff]) {
+    int ip[4];
+    int port[2];
+    char *str=buf;
 
-      if (ftpcode == results[modeoff])
+    /*
+     * New 227-parser June 3rd 1999.
+     * It now scans for a sequence of six comma-separated numbers and
+     * will take them as IP+port indicators.
+     *
+     * Found reply-strings include:
+     * "227 Entering Passive Mode (127,0,0,1,4,51)"
+     * "227 Data transfer will passively listen to 127,0,0,1,4,51"
+     * "227 Entering passive mode. 127,0,0,1,4,51"
+     */
+      
+    while(*str) {
+      if (6 == sscanf(str, "%d,%d,%d,%d,%d,%d",
+                      &ip[0], &ip[1], &ip[2], &ip[3],
+                      &port[0], &port[1]))
         break;
+      str++;
+    }
+
+    if(!*str) {
+      failf(data, "Couldn't interpret this 227-reply: %s", buf);
+      return CURLE_FTP_WEIRD_227_FORMAT;
     }
 
-    if (!mode[modeoff]) {
-      failf(data, "Odd return code after PASV");
+    sprintf(newhost, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
+    newhostp = newhost;
+    newport = (port[0]<<8) + port[1];
+  }
+#if 1
+  else if (229 == results[modeoff]) {
+    char *ptr = strchr(buf, '(');
+    if(ptr) {
+      unsigned int num;
+      char separator[4];
+      ptr++;
+      if(5  == sscanf(ptr, "%c%c%c%u%c",
+                      &separator[0],
+                      &separator[1],
+                      &separator[2],
+                      &num,
+                      &separator[3])) {
+        /* the four separators should be identical */
+        newport = num;
+
+        /* we should use the same host we already are connected to */
+        newhostp = conn->name;
+      }                      
+      else
+        ptr=NULL;
+    }
+    if(!ptr) {
+      failf(data, "Weirdly formatted EPSV reply");
       return CURLE_FTP_WEIRD_PASV_REPLY;
     }
-    else if (strcmp(mode[modeoff], "PASV") == 0) {
-      int ip[4];
-      int port[2];
-      unsigned short newport; /* remote port, not necessary the local one */
-      unsigned short connectport; /* the local port connect() should use! */
-      char newhost[32];
-#ifdef ENABLE_IPV6
-      struct addrinfo *res;
-#else
-      struct hostent *he;
-      char *hostdataptr=NULL;
-      char *ip_addr;
+  }
 #endif
-      char *str=buf;
+  else
+    return CURLE_FTP_CANT_RECONNECT;
 
-      /*
-       * New 227-parser June 3rd 1999.
-       * It now scans for a sequence of six comma-separated numbers and
-       * will take them as IP+port indicators.
-       *
-       * Found reply-strings include:
-       * "227 Entering Passive Mode (127,0,0,1,4,51)"
-       * "227 Data transfer will passively listen to 127,0,0,1,4,51"
-       * "227 Entering passive mode. 127,0,0,1,4,51"
-       */
-      
-      while(*str) {
-	      if (6 == sscanf(str, "%d,%d,%d,%d,%d,%d",
-                        &ip[0], &ip[1], &ip[2], &ip[3],
-                        &port[0], &port[1]))
-    	    break;
-        str++;
-      }
-
-      if(!*str) {
-        failf(data, "Couldn't interpret this 227-reply: %s", buf);
-        return CURLE_FTP_WEIRD_227_FORMAT;
-      }
-
-      sprintf(newhost, "%d.%d.%d.%d", ip[0], ip[1], ip[2], ip[3]);
-      newport = (port[0]<<8) + port[1];
-      if(data->change.proxy) {
-        /*
-         * This is a tunnel through a http proxy and we need to connect to the
-         * proxy again here. We already have the name info for it since the
-         * previous lookup.
-         */
-#ifdef ENABLE_IPV6
-        res = conn->hp;
-#else
-        he = conn->hp;
-#endif
-        connectport =
-          (unsigned short)conn->port; /* we connect to the proxy's port */
-      }
-      else {
-        /* normal, direct, ftp connection */
-#ifdef ENABLE_IPV6
-        res = Curl_getaddrinfo(data, newhost, newport);
-        if(!res)
-#else
-        he = Curl_gethost(data, newhost, &hostdataptr);
-        if(!he)
-#endif
-        {
-          failf(data, "Can't resolve new host %s", newhost);
-          return CURLE_FTP_CANT_GET_HOST;
-        }
-        connectport = newport; /* we connect to the remote port */
-      }
-	
-#ifdef ENABLE_IPV6
-      conn->secondarysocket = -1;
-      for (ai = res; ai; ai = ai->ai_next) {
-        /* XXX for now, we can do IPv4 only */
-        if (ai->ai_family != AF_INET)
-          continue;
+  if(data->change.proxy) {
+    /*
+     * This is a tunnel through a http proxy and we need to connect to the
+     * proxy again here.
+     *
+     * We don't want to rely on a former host lookup that might've expired
+     * now, instead we remake the lookup here and now!
+     */
+    addr = Curl_resolv(data, conn->proxyhost, conn->port);
+    connectport =
+      (unsigned short)conn->port; /* we connect to the proxy's port */    
 
-        conn->secondarysocket = socket(ai->ai_family, ai->ai_socktype,
-                                       ai->ai_protocol);
-        if (conn->secondarysocket < 0)
-          continue;
+  }
+  else {
+    /* normal, direct, ftp connection */
+    addr = Curl_resolv(data, newhostp, newport);
+    if(!addr) {
+      failf(data, "Can't resolve new host %s:%d", newhostp, newport);
+      return CURLE_FTP_CANT_GET_HOST;
+    }
+    connectport = newport; /* we connect to the remote port */
+  }
+    
+  result = Curl_connecthost(conn,
+                            addr,
+                            connectport,
+                            &conn->secondarysocket,
+                            &conninfo);
+  
+  if((CURLE_OK == result) &&       
+     data->set.verbose)
+    /* this just dumps information about this second connection */
+    ftp_pasv_verbose(conn, conninfo, newhostp, connectport);
+  
+  if(CURLE_OK != result)
+    return result;
 
-      	if(data->set.verbose) {
-          char hbuf[NI_MAXHOST];
-          char nbuf[NI_MAXHOST];
-          char sbuf[NI_MAXSERV];
-#ifdef NI_WITHSCOPEID
-          const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
-#else
-          const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;
-#endif
-          if (getnameinfo(res->ai_addr, res->ai_addrlen, nbuf, sizeof(nbuf),
-                          sbuf, sizeof(sbuf), niflags)) {
-            snprintf(nbuf, sizeof(nbuf), "?");
-            snprintf(sbuf, sizeof(sbuf), "?");
-          }
-        
-          if (getnameinfo(res->ai_addr, res->ai_addrlen, hbuf, sizeof(hbuf),
-                          NULL, 0, 0)) {
-            infof(data, "Connecting to %s port %s\n", nbuf, sbuf);
-          } else {
-            infof(data, "Connecting to %s (%s) port %s\n", hbuf, nbuf, sbuf);
-          }
-        }
+  if (data->set.tunnel_thru_httpproxy) {
+    /* We want "seamless" FTP operations through HTTP proxy tunnel */
+    result = Curl_ConnectHTTPProxyTunnel(conn, conn->secondarysocket,
+                                         newhostp, newport);
+    if(CURLE_OK != result)
+      return result;
+  }
 
-        if (connect(conn->secondarysocket, ai->ai_addr, ai->ai_addrlen) < 0) {
-          close(conn->secondarysocket);
-          conn->secondarysocket = -1;
-          continue;
-        }
+  return CURLE_OK;
+}
 
-      	break;
-      }
+/***********************************************************************
+ *
+ * ftp_perform()
+ *
+ * This is the actual DO function for FTP. Get a file/directory according to
+ * the options previously setup.
+ */
 
-      if (conn->secondarysocket < 0) {
-        failf(data, strerror(errno));
-        return CURLE_FTP_CANT_RECONNECT;
-      }
-#else
-      conn->secondarysocket = socket(AF_INET, SOCK_STREAM, 0);
+static
+CURLcode ftp_perform(struct connectdata *conn)
+{
+  /* this is FTP and no proxy */
+  ssize_t nread;
+  CURLcode result=CURLE_OK;
+  struct SessionHandle *data=conn->data;
+  char *buf = data->state.buffer; /* this is our buffer */
+
+  /* the ftp struct is already inited in ftp_connect() */
+  struct FTP *ftp = conn->proto.ftp;
+
+  long *bytecountp = ftp->bytecountp;
+  int ftpcode; /* for ftp status */
+
+  /* Send any QUOTE strings? */
+  if(data->set.quote) {
+    if ((result = ftp_sendquote(conn, data->set.quote)) != CURLE_OK)
+      return result;
+  }
+    
+  /* This is a re-used connection. Since we change directory to where the
+     transfer is taking place, we must now get back to the original dir
+     where we ended up after login: */
+  if (conn->bits.reuse) {
+    if ((result = ftp_cwd(conn, ftp->entrypath)) != CURLE_OK)
+      return result;
+  }
 
-      memset((char *) &serv_addr, '\0', sizeof(serv_addr));
-      memcpy((char *)&(serv_addr.sin_addr), he->h_addr, he->h_length);
-      serv_addr.sin_family = he->h_addrtype;
+  /* change directory first! */
+  if(ftp->dir && ftp->dir[0]) {
+    if ((result = ftp_cwd(conn, ftp->dir)) != CURLE_OK)
+        return result;
+  }
 
-      serv_addr.sin_port = htons(connectport);
+  /* Requested time of file? */
+  if(data->set.get_filetime && ftp->file) {
+    result = ftp_getfiletime(conn, ftp->file);
+    if(result)
+      return result;
+  }
 
-      if(data->set.verbose) {
-        struct in_addr in;
-        struct hostent * answer;
+  /* If we have selected NOBODY and HEADER, it means that we only want file
+     information. Which in FTP can't be much more than the file size and
+     date. */
+  if(data->set.no_body && data->set.include_header && ftp->file) {
+    /* The SIZE command is _not_ RFC 959 specified, and therefor many servers
+       may not support it! It is however the only way we have to get a file's
+       size! */
+    ssize_t filesize;
 
-#if defined(HAVE_INET_ADDR)
-        unsigned long address;
-# if defined(HAVE_GETHOSTBYADDR_R)
-        int h_errnop;
-# endif
+    /* Some servers return different sizes for different modes, and thus we
+       must set the proper type before we check the size */
+    result = ftp_transfertype(conn, data->set.ftp_ascii);
+    if(result)
+      return result;
 
-        address = inet_addr(newhost);
-# ifdef HAVE_GETHOSTBYADDR_R
+    /* failing to get size is not a serious error */
+    result = ftp_getsize(conn, ftp->file, &filesize);
 
-#  ifdef HAVE_GETHOSTBYADDR_R_5
-        /* AIX, Digital Unix style:
-           extern int gethostbyaddr_r(char *addr, size_t len, int type,
-           struct hostent *htent, struct hostent_data *ht_data); */
-
-        /* Fred Noz helped me try this out, now it at least compiles! */
-
-        if(gethostbyaddr_r((char *) &address,
-                           sizeof(address), AF_INET,
-                           (struct hostent *)hostent_buf,
-                           hostent_buf + sizeof(*answer)))
-           answer=NULL;
-                           
-#  endif
-#  ifdef HAVE_GETHOSTBYADDR_R_7
-        /* Solaris and IRIX */
-        answer = gethostbyaddr_r((char *) &address, sizeof(address), AF_INET,
-                                 (struct hostent *)hostent_buf,
-                                 hostent_buf + sizeof(*answer),
-                                 sizeof(hostent_buf) - sizeof(*answer),
-                                 &h_errnop);
-#  endif
-#  ifdef HAVE_GETHOSTBYADDR_R_8
-        /* Linux style */
-        if(gethostbyaddr_r((char *) &address, sizeof(address), AF_INET,
-                           (struct hostent *)hostent_buf,
-                           hostent_buf + sizeof(*answer),
-                           sizeof(hostent_buf) - sizeof(*answer),
-                           &answer,
-                           &h_errnop))
-           answer=NULL; /* error */
-#  endif
-        
-# else
-        answer = gethostbyaddr((char *) &address, sizeof(address), AF_INET);
-# endif
+    if(CURLE_OK == result) {
+      sprintf(buf, "Content-Length: %d\r\n", filesize);
+      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
+      if(result)
+        return result;
+    }
+
+    /* If we asked for a time of the file and we actually got one as
+       well, we "emulate" a HTTP-style header in our output. */
+
+#ifdef HAVE_STRFTIME
+    if(data->set.get_filetime && data->info.filetime) {
+      struct tm *tm;
+#ifdef HAVE_LOCALTIME_R
+      struct tm buffer;
+      tm = (struct tm *)localtime_r(&data->info.filetime, &buffer);
 #else
-        answer = NULL;
+      tm = localtime((unsigned long *)&data->info.filetime);
 #endif
-        (void) memcpy(&in.s_addr, *he->h_addr_list, sizeof (in.s_addr));
-        infof(data, "Connecting to %s (%s) port %u\n",
-              answer?answer->h_name:newhost,
-#if defined(HAVE_INET_NTOA_R)
-              inet_ntoa_r(in, ip_addr=ntoa_buf, sizeof(ntoa_buf)),
-#else
-              ip_addr = inet_ntoa(in),
+      /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
+      strftime(buf, BUFSIZE-1, "Last-Modified: %a, %d %b %Y %H:%M:%S %Z\r\n",
+               tm);
+      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
+      if(result)
+        return result;
+    }
 #endif
-              connectport);
-      }
-	
-      if(hostdataptr)
-        free(hostdataptr);
 
-      if (connect(conn->secondarysocket, (struct sockaddr *) &serv_addr,
-                  sizeof(serv_addr)) < 0) {
-        switch(errno) {
-#ifdef ECONNREFUSED
-          /* this should be made nicer */
-        case ECONNREFUSED:
-          failf(data, "Connection refused by ftp server");
-          break;
-#endif
-#ifdef EINTR
-        case EINTR:
-          failf(data, "Connection timed out to ftp server");
-          break;
-#endif
-        default:
-          failf(data, "Can't connect to ftp server");
-          break;
-        }
-        return CURLE_FTP_CANT_RECONNECT;
-      }
-#endif /*ENABLE_IPV6*/
+    return CURLE_OK;
+  }
 
-      if (data->set.tunnel_thru_httpproxy) {
-        /* We want "seamless" FTP operations through HTTP proxy tunnel */
-        result = Curl_ConnectHTTPProxyTunnel(conn, conn->secondarysocket,
-                                             newhost, newport);
-        if(CURLE_OK != result)
-          return result;
-      }
-    } else {
-      return CURLE_FTP_CANT_RECONNECT;
-    }
+  if(data->set.no_body)
+    /* don't transfer the data */
+    ftp->dont_check = TRUE;
+  /* Get us a second connection up and connected */
+  else if(data->set.ftp_use_port) {
+    /* We have chosen to use the PORT command */
+    result = ftp_use_port(conn);
+    if(CURLE_OK == result)
+      /* we have the data connection ready */
+      infof(data, "Connected the data stream with PORT!\n");
+  }
+  else {
+    /* We have chosen (this is default) to use the PASV command */
+    result = ftp_use_pasv(conn);
+    if(CURLE_OK == result)
+      infof(data, "Connected the data stream with PASV!\n");
   }
-  /* we have the (new) data connection ready */
-  infof(data, "Connected the data stream!\n");
+  
+  if(result)
+    return result;
 
   if(data->set.upload) {
 
     /* Set type to binary (unless specified ASCII) */
-    result = _ftp_transfertype(conn, data->set.ftp_ascii);
+    result = ftp_transfertype(conn, data->set.ftp_ascii);
     if(result)
       return result;
 
+    /* Send any PREQUOTE strings after transfer type is set? (Wesley Laxton)*/
+    if(data->set.prequote) {
+      if ((result = ftp_sendquote(conn, data->set.prequote)) != CURLE_OK)
+        return result;
+    }
+
     if(conn->resume_from) {
       /* we're about to continue the uploading of a file */
       /* 1. get already existing file's size. We use the SIZE
          command for this which may not exist in the server!
          The SIZE command is not in RFC959. */
 
@@ -1396,17 +1650,19 @@
       /* 4. lower the infilesize counter */
       /* => transfer as usual */
 
       if(conn->resume_from < 0 ) {
         /* we could've got a specified offset from the command line,
            but now we know we didn't */
+        ssize_t gottensize;
 
-        if(CURLE_OK != _ftp_getsize(conn, ftp->file, &conn->resume_from)) {
+        if(CURLE_OK != ftp_getsize(conn, ftp->file, &gottensize)) {
           failf(data, "Couldn't get remote file size");
           return CURLE_FTP_COULDNT_GET_SIZE;
         }
+        conn->resume_from = gottensize;
       }
 
       if(conn->resume_from) {
         /* do we still game? */
         int passed=0;
         /* enable append instead */
@@ -1425,13 +1681,13 @@
           actuallyread =
             data->set.fread(data->state.buffer, 1, readthisamountnow,
                             data->set.in);
 
           passed += actuallyread;
           if(actuallyread != readthisamountnow) {
-            failf(data, "Could only read %d bytes from the input\n", passed);
+            failf(data, "Could only read %d bytes from the input", passed);
             return CURLE_FTP_COULDNT_USE_REST;
           }
         }
         while(passed != conn->resume_from);
 
         /* now, decrease the size of the read */
@@ -1441,44 +1697,47 @@
           if(data->set.infilesize <= 0) {
             infof(data, "File already completely uploaded\n");
 
             /* no data to transfer */
             result=Curl_Transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
             
-            /* Set resume done so that we won't get any error in
-             * Curl_ftp_done() because we didn't transfer the amount of bytes
-             * that the local file file obviously is */
+            /* Set resume done and dont_check so that we won't get any error
+             * in Curl_ftp_done() because we didn't transfer the amount of
+             * bytes that the local file file obviously is */
             conn->bits.resume_done = TRUE; 
+            ftp->dont_check = TRUE;
 
             return CURLE_OK;
           }
         }
         /* we've passed, proceed as normal */
       }
     }
 
     /* Send everything on data->set.in to the socket */
-    if(data->set.ftp_append)
+    if(data->set.ftp_append) {
       /* we append onto the file instead of rewriting it */
-      ftpsendf(conn->firstsocket, conn, "APPE %s", ftp->file);
-    else
-      ftpsendf(conn->firstsocket, conn, "STOR %s", ftp->file);
+      FTPSENDF(conn, "APPE %s", ftp->file);
+    }
+    else {
+      FTPSENDF(conn, "STOR %s", ftp->file);
+    }
 
-    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode>=400) {
       failf(data, "Failed FTP upload:%s", buf+3);
       /* oops, we never close the sockets! */
       return CURLE_FTP_COULDNT_STOR_FILE;
     }
 
     if(data->set.ftp_use_port) {
       /* PORT means we are now awaiting the server to connect to us. */
-      result = AllowServerConnect(data, conn, portsock);
+      result = AllowServerConnect(data, conn, conn->secondarysocket);
       if( result )
         return result;
     }
 
     *bytecountp=0;
 
@@ -1490,13 +1749,13 @@
     result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
                       conn->secondarysocket, bytecountp);
     if(result)
       return result;
       
   }
-  else {
+  else if(!data->set.no_body) {
     /* Retrieve file or directory */
     bool dirlist=FALSE;
     long downloadsize=-1;
 
     if(conn->bits.use_range && conn->range) {
       long from, to;
@@ -1531,50 +1790,68 @@
         conn->resume_from = from;
         infof(data, "FTP RANGE from %d getting %d bytes\n", from,
               conn->maxdownload);
       }
       infof(data, "range-download from %d to %d, totally %d bytes\n",
             from, to, totalsize);
+      conn->bits.resume_done = TRUE; /* to prevent some error due to this */
+      ftp->dont_check = TRUE; /* dont check for successful transfer */
     }
 
     if((data->set.ftp_list_only) || !ftp->file) {
       /* The specified path ends with a slash, and therefore we think this
          is a directory that is requested, use LIST. But before that we
          need to set ASCII transfer mode. */
       dirlist = TRUE;
 
       /* Set type to ASCII */
-      result = _ftp_transfertype(conn, TRUE /* ASCII enforced */);
+      result = ftp_transfertype(conn, TRUE /* ASCII enforced */);
       if(result)
         return result;
 
       /* if this output is to be machine-parsed, the NLST command will be
          better used since the LIST command output is not specified or
          standard in any way */
 
-      ftpsendf(conn->firstsocket, conn, "%s",
+      FTPSENDF(conn, "%s",
             data->set.customrequest?data->set.customrequest:
             (data->set.ftp_list_only?"NLST":"LIST"));
     }
     else {
+      ssize_t foundsize;
+
       /* Set type to binary (unless specified ASCII) */
-      result = _ftp_transfertype(conn, data->set.ftp_ascii);
+      result = ftp_transfertype(conn, data->set.ftp_ascii);
       if(result)
         return result;
 
+      /* Send any PREQUOTE strings after transfer type is set? (Wesley Laxton)*/
+      if(data->set.prequote) {
+        if ((result = ftp_sendquote(conn, data->set.prequote)) != CURLE_OK)
+          return result;
+      }
+
+      /* Attempt to get the size, it'll be useful in some cases: for resumed
+         downloads and when talking to servers that don't give away the size
+         in the RETR response line. */
+      result = ftp_getsize(conn, ftp->file, &foundsize);
+      if(CURLE_OK == result)
+        downloadsize = foundsize;
+
       if(conn->resume_from) {
 
         /* Daniel: (August 4, 1999)
          *
          * We start with trying to use the SIZE command to figure out the size
          * of the file we're gonna get. If we can get the size, this is by far
-         * the best way to know if we're trying to resume beyond the EOF.  */
-        int foundsize=-1;
-        
-        result = _ftp_getsize(conn, ftp->file, &foundsize);
-
+         * the best way to know if we're trying to resume beyond the EOF.
+         *
+         * Daniel, November 28, 2001. We *always* get the size on downloads
+         * now, so it is done before this even when not doing resumes. I saved
+         * the comment above for nostalgical reasons! ;-)
+         */
         if(CURLE_OK != result) {
           infof(data, "ftp server doesn't support SIZE\n");
           /* We couldn't get the size and therefore we can't know if there
              really is a part of the file left to get, although the server
              will just close the connection when we start the connection so it
              won't cause us any harm, just not make us exit as nicely. */
@@ -1611,36 +1888,37 @@
           infof(data, "File already completely downloaded\n");
 
           /* Set resume done so that we won't get any error in Curl_ftp_done()
            * because we didn't transfer the amount of bytes that the remote
            * file obviously is */
           conn->bits.resume_done = TRUE; 
+          ftp->dont_check = TRUE;
 
           return CURLE_OK;
         }
 	
         /* Set resume file transfer offset */
         infof(data, "Instructs server to resume from offset %d\n",
               conn->resume_from);
 
-        ftpsendf(conn->firstsocket, conn, "REST %d", conn->resume_from);
+        FTPSENDF(conn, "REST %d", conn->resume_from);
 
-        nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 350) {
           failf(data, "Couldn't use REST: %s", buf+4);
           return CURLE_FTP_COULDNT_USE_REST;
         }
       }
 
-      ftpsendf(conn->firstsocket, conn, "RETR %s", ftp->file);
+      FTPSENDF(conn, "RETR %s", ftp->file);
     }
 
-    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if((ftpcode == 150) || (ftpcode == 125)) {
 
       /*
@@ -1698,13 +1976,13 @@
         }
       }
       else if(downloadsize > -1)
         size = downloadsize;
 
       if(data->set.ftp_use_port) {
-        result = AllowServerConnect(data, conn, portsock);
+        result = AllowServerConnect(data, conn, conn->secondarysocket);
         if( result )
           return result;
       }
 
       infof(data, "Getting file with size: %d\n", size);
 
@@ -1723,15 +2001,21 @@
   }
   /* end of transfer */
 
   return CURLE_OK;
 }
 
-/* -- deal with the ftp server!  -- */
-
-/* argument is already checked for validity */
+/***********************************************************************
+ *
+ * Curl_ftp()
+ *
+ * This function is registered as 'curl_do' function. It decodes the path
+ * parts etc as a wrapper to the actual DO function (ftp_perform).
+ *
+ * The input argument is already checked for validity.
+ */
 CURLcode Curl_ftp(struct connectdata *conn)
 {
   CURLcode retcode;
 
   struct SessionHandle *data = conn->data;
   struct FTP *ftp;
@@ -1775,68 +2059,98 @@
       return CURLE_OUT_OF_MEMORY; /* failure */
     }
   }
   else
     ftp->dir = NULL;
 
-  retcode = _ftp(conn);
+  retcode = ftp_perform(conn);
 
   /* clean up here, success or error doesn't matter */
   if(ftp->file)
     free(ftp->file);
   if(ftp->dir)
     free(ftp->dir);
 
   ftp->file = ftp->dir = NULL; /* zero */
 
   return retcode;
 }
 
-/*
- * ftpsendf() sends the formated string as a ftp command to a ftp server
+/***********************************************************************
+ *
+ * Curl_ftpsendf()
+ *
+ * Sends the formated string as a ftp command to a ftp server
  *
  * NOTE: we build the command in a fixed-length buffer, which sets length
  * restrictions on the command!
- *
  */
-size_t Curl_ftpsendf(int fd, struct connectdata *conn,
-                     const char *fmt, ...)
+CURLcode Curl_ftpsendf(struct connectdata *conn,
+                       const char *fmt, ...)
 {
-  size_t bytes_written;
+  ssize_t bytes_written;
   char s[256];
+  ssize_t write_len;
+  char *sptr=s;
+  CURLcode res = CURLE_OK;
 
   va_list ap;
   va_start(ap, fmt);
   vsnprintf(s, 250, fmt, ap);
   va_end(ap);
-
-  if(conn->data->set.verbose)
-    fprintf(conn->data->set.err, "> %s\n", s);
-
+  
   strcat(s, "\r\n"); /* append a trailing CRLF */
 
   bytes_written=0;
-  Curl_write(conn, fd, s, strlen(s), &bytes_written);
+  write_len = strlen(s);
 
-  return(bytes_written);
-}
+  do {
+    res = Curl_write(conn, conn->firstsocket, sptr, write_len,
+                     &bytes_written);
 
+    if(CURLE_OK != res)
+      break;
 
+    if(conn->data->set.verbose)
+      Curl_debug(conn->data, CURLINFO_HEADER_OUT, sptr, bytes_written);
+
+    if(bytes_written != write_len) {
+      write_len -= bytes_written;
+      sptr += bytes_written;
+    }
+    else
+      break;
+  } while(1);
+
+  return res;
+}
+
+/***********************************************************************
+ *
+ * Curl_ftp_disconnect()
+ *
+ * Disconnect from an FTP server. Cleanup protocol-specific per-connection
+ * resources
+ */
 CURLcode Curl_ftp_disconnect(struct connectdata *conn)
 {
   struct FTP *ftp= conn->proto.ftp;
 
   /* The FTP session may or may not have been allocated/setup at this point! */
   if(ftp) {
     if(ftp->entrypath)
       free(ftp->entrypath);
+    if(ftp->cache)
+      free(ftp->cache);
   }
   return CURLE_OK;
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+
+#endif /* CURL_DISABLE_FTP */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ftp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ftp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ftp.h	2001-08-14 16:25:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ftp.h	2002-06-11 19:13:01.000000000 +0800
@@ -5,34 +5,41 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.h,v 1.8 2001/08/14 08:25:08 bagder Exp $
+ * $Id: ftp.h,v 1.12 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
+
+/* MN 06/07/02 */
+#ifndef CURL_DISABLE_FTP
+
 CURLcode Curl_ftp(struct connectdata *conn);
 CURLcode Curl_ftp_done(struct connectdata *conn);
 CURLcode Curl_ftp_connect(struct connectdata *conn);
 CURLcode Curl_ftp_disconnect(struct connectdata *conn);
 
-size_t Curl_ftpsendf(int fd, struct connectdata *, const char *fmt, ...);
+CURLcode Curl_ftpsendf(struct connectdata *, const char *fmt, ...);
 
 /* The kerberos stuff needs this: */
-int Curl_GetFTPResponse(int sockfd, char *buf,
-                        struct connectdata *conn,
+int Curl_GetFTPResponse(char *buf, struct connectdata *conn,
                         int *ftpcode);
 
+/* MN 06/07/02 */
+#endif
+
+
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getdate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getdate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getdate.c	2001-09-07 14:05:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getdate.c	2002-02-27 15:27:50.000000000 +0800
@@ -31,21 +31,23 @@
 **
 **  This code is in the public domain and has no copyright.
 */
 
 #include "setup.h"
 
-#ifdef HAVE_CONFIG_H
-# include "config.h"
 # ifdef HAVE_ALLOCA_H
 #  include <alloca.h>
 # endif
 
 # ifdef HAVE_TIME_H
 #  include <time.h>
 # endif
+
+#ifndef YYDEBUG
+  /* to satisfy gcc -Wundef, we set this to 0 */
+#define YYDEBUG 0
 #endif
 
 /* Since the code of getdate.y is not included in the Emacs executable
    itself, there is no need to #define static in this file.  Even if
    the code were included in the Emacs executable, it probably
    wouldn't do any harm to #undef it here; this will only cause
@@ -189,44 +191,46 @@
 **  Meridian:  am, pm, or 24-hour style.
 */
 typedef enum _MERIDIAN {
     MERam, MERpm, MER24
 } MERIDIAN;
 
+/* parse results and input string */
+typedef struct _CONTEXT {
+    const char	*yyInput;
+    int		yyDayOrdinal;
+    int		yyDayNumber;
+    int		yyHaveDate;
+    int		yyHaveDay;
+    int		yyHaveRel;
+    int		yyHaveTime;
+    int		yyHaveZone;
+    int		yyTimezone;
+    int		yyDay;
+    int		yyHour;
+    int		yyMinutes;
+    int		yyMonth;
+    int		yySeconds;
+    int		yyYear;
+    MERIDIAN	yyMeridian;
+    int		yyRelDay;
+    int		yyRelHour;
+    int		yyRelMinutes;
+    int		yyRelMonth;
+    int		yyRelSeconds;
+    int		yyRelYear;
+} CONTEXT;
 
-/*
-**  Global variables.  We could get rid of most of these by using a good
-**  union as the yacc stack.  (This routine was originally written before
-**  yacc had the %union construct.)  Maybe someday; right now we only use
-**  the %union very rarely.
+/* enable use of extra argument to yyparse and yylex which can be used to pass
+**  in a user defined value (CONTEXT struct in our case)
 */
-static const char	*yyInput;
-static int	yyDayOrdinal;
-static int	yyDayNumber;
-static int	yyHaveDate;
-static int	yyHaveDay;
-static int	yyHaveRel;
-static int	yyHaveTime;
-static int	yyHaveZone;
-static int	yyTimezone;
-static int	yyDay;
-static int	yyHour;
-static int	yyMinutes;
-static int	yyMonth;
-static int	yySeconds;
-static int	yyYear;
-static MERIDIAN	yyMeridian;
-static int	yyRelDay;
-static int	yyRelHour;
-static int	yyRelMinutes;
-static int	yyRelMonth;
-static int	yyRelSeconds;
-static int	yyRelYear;
+#define YYPARSE_PARAM cookie
+#define YYLEX_PARAM cookie
+#define context ((CONTEXT *) cookie)
 
-
-#line 206 "getdate.y"
+#line 215 "getdate.y"
 typedef union {
     int			Number;
     enum _MERIDIAN	Meridian;
 } YYSTYPE;
 #include <stdio.h>
 
@@ -303,17 +307,17 @@
 };
 
 #endif
 
 #if YYDEBUG != 0
 static const short yyrline[] = { 0,
-   222,   223,   226,   229,   232,   235,   238,   241,   244,   250,
-   256,   265,   271,   283,   286,   289,   295,   299,   303,   309,
-   313,   331,   337,   343,   347,   352,   356,   363,   371,   374,
-   377,   380,   383,   386,   389,   392,   395,   398,   401,   404,
-   407,   410,   413,   416,   419,   422,   425,   430,   463,   467
+   231,   232,   235,   238,   241,   244,   247,   250,   253,   259,
+   265,   274,   280,   292,   295,   298,   304,   308,   312,   318,
+   322,   340,   346,   352,   356,   361,   365,   372,   380,   383,
+   386,   389,   392,   395,   398,   401,   404,   407,   410,   413,
+   416,   419,   422,   425,   428,   431,   434,   439,   473,   477
 };
 #endif
 
 
 #if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
 
@@ -387,12 +391,14 @@
     11,    12,    13,    14,    15,    16,    17,    18,     4,     5,
      7,     3,     8,    20,    10,    11,    12,    13,    14,    15,
     15,    17,    16,    19,     5,    21,    10,     8,    16,    16,
     11,    15,    13,    14,    16,    19,    17,    16,    21,     0,
     56
 };
+#define YYPURE 1
+
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
 #line 3 "/usr/local/share/bison.simple"
 /* This file comes from bison-1.28.  */
 
 /* Skeleton output parser for bison,
    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
@@ -931,368 +937,369 @@
 #endif
 
 
   switch (yyn) {
 
 case 3:
-#line 226 "getdate.y"
+#line 235 "getdate.y"
 {
-	    yyHaveTime++;
+	    context->yyHaveTime++;
 	;
     break;}
 case 4:
-#line 229 "getdate.y"
+#line 238 "getdate.y"
 {
-	    yyHaveZone++;
+	    context->yyHaveZone++;
 	;
     break;}
 case 5:
-#line 232 "getdate.y"
+#line 241 "getdate.y"
 {
-	    yyHaveDate++;
+	    context->yyHaveDate++;
 	;
     break;}
 case 6:
-#line 235 "getdate.y"
+#line 244 "getdate.y"
 {
-	    yyHaveDay++;
+	    context->yyHaveDay++;
 	;
     break;}
 case 7:
-#line 238 "getdate.y"
+#line 247 "getdate.y"
 {
-	    yyHaveRel++;
+	    context->yyHaveRel++;
 	;
     break;}
 case 9:
-#line 244 "getdate.y"
+#line 253 "getdate.y"
 {
-	    yyHour = yyvsp[-1].Number;
-	    yyMinutes = 0;
-	    yySeconds = 0;
-	    yyMeridian = yyvsp[0].Meridian;
+	    context->yyHour = yyvsp[-1].Number;
+	    context->yyMinutes = 0;
+	    context->yySeconds = 0;
+	    context->yyMeridian = yyvsp[0].Meridian;
 	;
     break;}
 case 10:
-#line 250 "getdate.y"
+#line 259 "getdate.y"
 {
-	    yyHour = yyvsp[-3].Number;
-	    yyMinutes = yyvsp[-1].Number;
-	    yySeconds = 0;
-	    yyMeridian = yyvsp[0].Meridian;
+	    context->yyHour = yyvsp[-3].Number;
+	    context->yyMinutes = yyvsp[-1].Number;
+	    context->yySeconds = 0;
+	    context->yyMeridian = yyvsp[0].Meridian;
 	;
     break;}
 case 11:
-#line 256 "getdate.y"
+#line 265 "getdate.y"
 {
-	    yyHour = yyvsp[-3].Number;
-	    yyMinutes = yyvsp[-1].Number;
-	    yyMeridian = MER24;
-	    yyHaveZone++;
-	    yyTimezone = (yyvsp[0].Number < 0
-			  ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
-			  : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
+	    context->yyHour = yyvsp[-3].Number;
+	    context->yyMinutes = yyvsp[-1].Number;
+	    context->yyMeridian = MER24;
+	    context->yyHaveZone++;
+	    context->yyTimezone = (yyvsp[0].Number < 0
+				   ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
+				   : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
 	;
     break;}
 case 12:
-#line 265 "getdate.y"
+#line 274 "getdate.y"
 {
-	    yyHour = yyvsp[-5].Number;
-	    yyMinutes = yyvsp[-3].Number;
-	    yySeconds = yyvsp[-1].Number;
-	    yyMeridian = yyvsp[0].Meridian;
+	    context->yyHour = yyvsp[-5].Number;
+	    context->yyMinutes = yyvsp[-3].Number;
+	    context->yySeconds = yyvsp[-1].Number;
+	    context->yyMeridian = yyvsp[0].Meridian;
 	;
     break;}
 case 13:
-#line 271 "getdate.y"
+#line 280 "getdate.y"
 {
-	    yyHour = yyvsp[-5].Number;
-	    yyMinutes = yyvsp[-3].Number;
-	    yySeconds = yyvsp[-1].Number;
-	    yyMeridian = MER24;
-	    yyHaveZone++;
-	    yyTimezone = (yyvsp[0].Number < 0
-			  ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
-			  : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
+	    context->yyHour = yyvsp[-5].Number;
+	    context->yyMinutes = yyvsp[-3].Number;
+	    context->yySeconds = yyvsp[-1].Number;
+	    context->yyMeridian = MER24;
+	    context->yyHaveZone++;
+	    context->yyTimezone = (yyvsp[0].Number < 0
+				   ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
+				   : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
 	;
     break;}
 case 14:
-#line 283 "getdate.y"
+#line 292 "getdate.y"
 {
-	    yyTimezone = yyvsp[0].Number;
+	    context->yyTimezone = yyvsp[0].Number;
 	;
     break;}
 case 15:
-#line 286 "getdate.y"
+#line 295 "getdate.y"
 {
-	    yyTimezone = yyvsp[0].Number - 60;
+	    context->yyTimezone = yyvsp[0].Number - 60;
 	;
     break;}
 case 16:
-#line 290 "getdate.y"
+#line 299 "getdate.y"
 {
-	    yyTimezone = yyvsp[-1].Number - 60;
+	    context->yyTimezone = yyvsp[-1].Number - 60;
 	;
     break;}
 case 17:
-#line 295 "getdate.y"
+#line 304 "getdate.y"
 {
-	    yyDayOrdinal = 1;
-	    yyDayNumber = yyvsp[0].Number;
+	    context->yyDayOrdinal = 1;
+	    context->yyDayNumber = yyvsp[0].Number;
 	;
     break;}
 case 18:
-#line 299 "getdate.y"
+#line 308 "getdate.y"
 {
-	    yyDayOrdinal = 1;
-	    yyDayNumber = yyvsp[-1].Number;
+	    context->yyDayOrdinal = 1;
+	    context->yyDayNumber = yyvsp[-1].Number;
 	;
     break;}
 case 19:
-#line 303 "getdate.y"
+#line 312 "getdate.y"
 {
-	    yyDayOrdinal = yyvsp[-1].Number;
-	    yyDayNumber = yyvsp[0].Number;
+	    context->yyDayOrdinal = yyvsp[-1].Number;
+	    context->yyDayNumber = yyvsp[0].Number;
 	;
     break;}
 case 20:
-#line 309 "getdate.y"
+#line 318 "getdate.y"
 {
-	    yyMonth = yyvsp[-2].Number;
-	    yyDay = yyvsp[0].Number;
+	    context->yyMonth = yyvsp[-2].Number;
+	    context->yyDay = yyvsp[0].Number;
 	;
     break;}
 case 21:
-#line 313 "getdate.y"
+#line 322 "getdate.y"
 {
 	  /* Interpret as YYYY/MM/DD if $1 >= 1000, otherwise as MM/DD/YY.
 	     The goal in recognizing YYYY/MM/DD is solely to support legacy
 	     machine-generated dates like those in an RCS log listing.  If
 	     you want portability, use the ISO 8601 format.  */
 	  if (yyvsp[-4].Number >= 1000)
 	    {
-	      yyYear = yyvsp[-4].Number;
-	      yyMonth = yyvsp[-2].Number;
-	      yyDay = yyvsp[0].Number;
+	      context->yyYear = yyvsp[-4].Number;
+	      context->yyMonth = yyvsp[-2].Number;
+	      context->yyDay = yyvsp[0].Number;
 	    }
 	  else
 	    {
-	      yyMonth = yyvsp[-4].Number;
-	      yyDay = yyvsp[-2].Number;
-	      yyYear = yyvsp[0].Number;
+	      context->yyMonth = yyvsp[-4].Number;
+	      context->yyDay = yyvsp[-2].Number;
+	      context->yyYear = yyvsp[0].Number;
 	    }
 	;
     break;}
 case 22:
-#line 331 "getdate.y"
+#line 340 "getdate.y"
 {
 	    /* ISO 8601 format.  yyyy-mm-dd.  */
-	    yyYear = yyvsp[-2].Number;
-	    yyMonth = -yyvsp[-1].Number;
-	    yyDay = -yyvsp[0].Number;
+	    context->yyYear = yyvsp[-2].Number;
+	    context->yyMonth = -yyvsp[-1].Number;
+	    context->yyDay = -yyvsp[0].Number;
 	;
     break;}
 case 23:
-#line 337 "getdate.y"
+#line 346 "getdate.y"
 {
 	    /* e.g. 17-JUN-1992.  */
-	    yyDay = yyvsp[-2].Number;
-	    yyMonth = yyvsp[-1].Number;
-	    yyYear = -yyvsp[0].Number;
+	    context->yyDay = yyvsp[-2].Number;
+	    context->yyMonth = yyvsp[-1].Number;
+	    context->yyYear = -yyvsp[0].Number;
 	;
     break;}
 case 24:
-#line 343 "getdate.y"
+#line 352 "getdate.y"
 {
-	    yyMonth = yyvsp[-1].Number;
-	    yyDay = yyvsp[0].Number;
+	    context->yyMonth = yyvsp[-1].Number;
+	    context->yyDay = yyvsp[0].Number;
 	;
     break;}
 case 25:
-#line 347 "getdate.y"
+#line 356 "getdate.y"
 {
-	    yyMonth = yyvsp[-3].Number;
-	    yyDay = yyvsp[-2].Number;
-	    yyYear = yyvsp[0].Number;
+	    context->yyMonth = yyvsp[-3].Number;
+	    context->yyDay = yyvsp[-2].Number;
+	    context->yyYear = yyvsp[0].Number;
 	;
     break;}
 case 26:
-#line 352 "getdate.y"
+#line 361 "getdate.y"
 {
-	    yyMonth = yyvsp[0].Number;
-	    yyDay = yyvsp[-1].Number;
+	    context->yyMonth = yyvsp[0].Number;
+	    context->yyDay = yyvsp[-1].Number;
 	;
     break;}
 case 27:
-#line 356 "getdate.y"
+#line 365 "getdate.y"
 {
-	    yyMonth = yyvsp[-1].Number;
-	    yyDay = yyvsp[-2].Number;
-	    yyYear = yyvsp[0].Number;
+	    context->yyMonth = yyvsp[-1].Number;
+	    context->yyDay = yyvsp[-2].Number;
+	    context->yyYear = yyvsp[0].Number;
 	;
     break;}
 case 28:
-#line 363 "getdate.y"
+#line 372 "getdate.y"
 {
-	    yyRelSeconds = -yyRelSeconds;
-	    yyRelMinutes = -yyRelMinutes;
-	    yyRelHour = -yyRelHour;
-	    yyRelDay = -yyRelDay;
-	    yyRelMonth = -yyRelMonth;
-	    yyRelYear = -yyRelYear;
+	    context->yyRelSeconds = -context->yyRelSeconds;
+	    context->yyRelMinutes = -context->yyRelMinutes;
+	    context->yyRelHour = -context->yyRelHour;
+	    context->yyRelDay = -context->yyRelDay;
+	    context->yyRelMonth = -context->yyRelMonth;
+	    context->yyRelYear = -context->yyRelYear;
 	;
     break;}
 case 30:
-#line 374 "getdate.y"
+#line 383 "getdate.y"
 {
-	    yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 31:
-#line 377 "getdate.y"
+#line 386 "getdate.y"
 {
-	    yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 32:
-#line 380 "getdate.y"
+#line 389 "getdate.y"
 {
-	    yyRelYear += yyvsp[0].Number;
+	    context->yyRelYear += yyvsp[0].Number;
 	;
     break;}
 case 33:
-#line 383 "getdate.y"
+#line 392 "getdate.y"
 {
-	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 34:
-#line 386 "getdate.y"
+#line 395 "getdate.y"
 {
-	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 35:
-#line 389 "getdate.y"
+#line 398 "getdate.y"
 {
-	    yyRelMonth += yyvsp[0].Number;
+	    context->yyRelMonth += yyvsp[0].Number;
 	;
     break;}
 case 36:
-#line 392 "getdate.y"
+#line 401 "getdate.y"
 {
-	    yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 37:
-#line 395 "getdate.y"
+#line 404 "getdate.y"
 {
-	    yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 38:
-#line 398 "getdate.y"
+#line 407 "getdate.y"
 {
-	    yyRelDay += yyvsp[0].Number;
+	    context->yyRelDay += yyvsp[0].Number;
 	;
     break;}
 case 39:
-#line 401 "getdate.y"
+#line 410 "getdate.y"
 {
-	    yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 40:
-#line 404 "getdate.y"
+#line 413 "getdate.y"
 {
-	    yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 41:
-#line 407 "getdate.y"
+#line 416 "getdate.y"
 {
-	    yyRelHour += yyvsp[0].Number;
+	    context->yyRelHour += yyvsp[0].Number;
 	;
     break;}
 case 42:
-#line 410 "getdate.y"
+#line 419 "getdate.y"
 {
-	    yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 43:
-#line 413 "getdate.y"
+#line 422 "getdate.y"
 {
-	    yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 44:
-#line 416 "getdate.y"
+#line 425 "getdate.y"
 {
-	    yyRelMinutes += yyvsp[0].Number;
+	    context->yyRelMinutes += yyvsp[0].Number;
 	;
     break;}
 case 45:
-#line 419 "getdate.y"
+#line 428 "getdate.y"
 {
-	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 46:
-#line 422 "getdate.y"
+#line 431 "getdate.y"
 {
-	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
+	    context->yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 47:
-#line 425 "getdate.y"
+#line 434 "getdate.y"
 {
-	    yyRelSeconds += yyvsp[0].Number;
+	    context->yyRelSeconds += yyvsp[0].Number;
 	;
     break;}
 case 48:
-#line 431 "getdate.y"
+#line 440 "getdate.y"
 {
-	    if (yyHaveTime && yyHaveDate && !yyHaveRel)
-	      yyYear = yyvsp[0].Number;
+	    if (context->yyHaveTime && context->yyHaveDate &&
+		!context->yyHaveRel)
+	      context->yyYear = yyvsp[0].Number;
 	    else
 	      {
 		if (yyvsp[0].Number>10000)
 		  {
-		    yyHaveDate++;
-		    yyDay= (yyvsp[0].Number)%100;
-		    yyMonth= (yyvsp[0].Number/100)%100;
-		    yyYear = yyvsp[0].Number/10000;
+		    context->yyHaveDate++;
+		    context->yyDay= (yyvsp[0].Number)%100;
+		    context->yyMonth= (yyvsp[0].Number/100)%100;
+		    context->yyYear = yyvsp[0].Number/10000;
 		  }
 		else
 		  {
-		    yyHaveTime++;
+		    context->yyHaveTime++;
 		    if (yyvsp[0].Number < 100)
 		      {
-			yyHour = yyvsp[0].Number;
-			yyMinutes = 0;
+			context->yyHour = yyvsp[0].Number;
+			context->yyMinutes = 0;
 		      }
 		    else
 		      {
-		    	yyHour = yyvsp[0].Number / 100;
-		    	yyMinutes = yyvsp[0].Number % 100;
+		    	context->yyHour = yyvsp[0].Number / 100;
+		    	context->yyMinutes = yyvsp[0].Number % 100;
 		      }
-		    yySeconds = 0;
-		    yyMeridian = MER24;
+		    context->yySeconds = 0;
+		    context->yyMeridian = MER24;
 		  }
 	      }
 	  ;
     break;}
 case 49:
-#line 464 "getdate.y"
+#line 474 "getdate.y"
 {
 	    yyval.Meridian = MER24;
 	  ;
     break;}
 case 50:
-#line 468 "getdate.y"
+#line 478 "getdate.y"
 {
 	    yyval.Meridian = yyvsp[0].Meridian;
 	  ;
     break;}
 }
    /* the action file gets copied in in place of this dollarsign */
@@ -1513,13 +1520,13 @@
 #ifdef YYLSP_NEEDED
       free (yyls);
 #endif
     }
   return 1;
 }
-#line 473 "getdate.y"
+#line 483 "getdate.y"
 
 
 /* Include this file down here because bison inserts code above which
    may define-away `const'.  We want the prototype for get_date to have
    the same signature as the function definition does. */
 #include "getdate.h"
@@ -1769,13 +1776,14 @@
     Year += 1900;
 
   return Year;
 }
 
 static int
-LookupWord (buff)
+LookupWord (yylval, buff)
+     YYSTYPE *yylval;
      char *buff;
 {
   register char *p;
   register char *q;
   register const TABLE *tp;
   int i;
@@ -1785,18 +1793,18 @@
   for (p = buff; *p; p++)
     if (ISUPPER ((unsigned char) *p))
       *p = tolower (*p);
 
   if (strcmp (buff, "am") == 0 || strcmp (buff, "a.m.") == 0)
     {
-      yylval.Meridian = MERam;
+      yylval->Meridian = MERam;
       return tMERIDIAN;
     }
   if (strcmp (buff, "pm") == 0 || strcmp (buff, "p.m.") == 0)
     {
-      yylval.Meridian = MERpm;
+      yylval->Meridian = MERpm;
       return tMERIDIAN;
     }
 
   /* See if we have an abbreviation for a month. */
   if (strlen (buff) == 3)
     abbrev = 1;
@@ -1811,68 +1819,68 @@
   for (tp = MonthDayTable; tp->name; tp++)
     {
       if (abbrev)
 	{
 	  if (strncmp (buff, tp->name, 3) == 0)
 	    {
-	      yylval.Number = tp->value;
+	      yylval->Number = tp->value;
 	      return tp->type;
 	    }
 	}
       else if (strcmp (buff, tp->name) == 0)
 	{
-	  yylval.Number = tp->value;
+	  yylval->Number = tp->value;
 	  return tp->type;
 	}
     }
 
   for (tp = TimezoneTable; tp->name; tp++)
     if (strcmp (buff, tp->name) == 0)
       {
-	yylval.Number = tp->value;
+	yylval->Number = tp->value;
 	return tp->type;
       }
 
   if (strcmp (buff, "dst") == 0)
     return tDST;
 
   for (tp = UnitsTable; tp->name; tp++)
     if (strcmp (buff, tp->name) == 0)
       {
-	yylval.Number = tp->value;
+	yylval->Number = tp->value;
 	return tp->type;
       }
 
   /* Strip off any plural and try the units table again. */
   i = strlen (buff) - 1;
   if (buff[i] == 's')
     {
       buff[i] = '\0';
       for (tp = UnitsTable; tp->name; tp++)
 	if (strcmp (buff, tp->name) == 0)
 	  {
-	    yylval.Number = tp->value;
+	    yylval->Number = tp->value;
 	    return tp->type;
 	  }
       buff[i] = 's';		/* Put back for "this" in OtherTable. */
     }
 
   for (tp = OtherTable; tp->name; tp++)
     if (strcmp (buff, tp->name) == 0)
       {
-	yylval.Number = tp->value;
+	yylval->Number = tp->value;
 	return tp->type;
       }
 
   /* Military timezones. */
   if (buff[1] == '\0' && ISALPHA ((unsigned char) *buff))
     {
       for (tp = MilitaryTable; tp->name; tp++)
 	if (strcmp (buff, tp->name) == 0)
 	  {
-	    yylval.Number = tp->value;
+	    yylval->Number = tp->value;
 	    return tp->type;
 	  }
     }
 
   /* Drop out any periods and try the timezone table again. */
   for (i = 0, p = q = buff; *q; q++)
@@ -1882,66 +1890,68 @@
       i++;
   *p = '\0';
   if (i)
     for (tp = TimezoneTable; tp->name; tp++)
       if (strcmp (buff, tp->name) == 0)
 	{
-	  yylval.Number = tp->value;
+	  yylval->Number = tp->value;
 	  return tp->type;
 	}
 
   return tID;
 }
 
 static int
-yylex ()
+yylex (yylval, cookie)
+     YYSTYPE *yylval;
+     void *cookie;
 {
   register unsigned char c;
   register char *p;
   char buff[20];
   int Count;
   int sign;
 
   for (;;)
     {
-      while (ISSPACE ((unsigned char) *yyInput))
-	yyInput++;
+      while (ISSPACE ((unsigned char) *context->yyInput))
+	context->yyInput++;
 
-      if (ISDIGIT (c = *yyInput) || c == '-' || c == '+')
+      if (ISDIGIT (c = *context->yyInput) || c == '-' || c == '+')
 	{
 	  if (c == '-' || c == '+')
 	    {
 	      sign = c == '-' ? -1 : 1;
-	      if (!ISDIGIT (*++yyInput))
+	      if (!ISDIGIT (*++context->yyInput))
 		/* skip the '-' sign */
 		continue;
 	    }
 	  else
 	    sign = 0;
-	  for (yylval.Number = 0; ISDIGIT (c = *yyInput++);)
-	    yylval.Number = 10 * yylval.Number + c - '0';
-	  yyInput--;
+	  for (yylval->Number = 0; ISDIGIT (c = *context->yyInput++);)
+	    yylval->Number = 10 * yylval->Number + c - '0';
+	  context->yyInput--;
 	  if (sign < 0)
-	    yylval.Number = -yylval.Number;
+	    yylval->Number = -yylval->Number;
 	  return sign ? tSNUMBER : tUNUMBER;
 	}
       if (ISALPHA (c))
 	{
-	  for (p = buff; (c = *yyInput++, ISALPHA (c)) || c == '.';)
+	  for (p = buff; (c = *context->yyInput++, ISALPHA (c)) || c == '.';)
 	    if (p < &buff[sizeof buff - 1])
 	      *p++ = c;
 	  *p = '\0';
-	  yyInput--;
-	  return LookupWord (buff);
+	  context->yyInput--;
+	  return LookupWord (yylval, buff);
 	}
       if (c != '(')
-	return *yyInput++;
+	return *context->yyInput++;
       Count = 0;
       do
 	{
-	  c = *yyInput++;
+	  c = *context->yyInput++;
 	  if (c == '\0')
 	    return c;
 	  if (c == '(')
 	    Count++;
 	  else if (c == ')')
 	    Count--;
@@ -1975,70 +1985,74 @@
 
 time_t
 curl_getdate (const char *p, const time_t *now)
 {
   struct tm tm, tm0, *tmp;
   time_t Start;
+  CONTEXT cookie;
 #ifdef HAVE_LOCALTIME_R
   struct tm keeptime;
 #endif
-  yyInput = p;
+  cookie.yyInput = p;
   Start = now ? *now : time ((time_t *) NULL);
 #ifdef HAVE_LOCALTIME_R
   tmp = (struct tm *)localtime_r(&Start, &keeptime);
 #else
   tmp = localtime (&Start);
 #endif
   if (!tmp)
     return -1;
-  yyYear = tmp->tm_year + TM_YEAR_ORIGIN;
-  yyMonth = tmp->tm_mon + 1;
-  yyDay = tmp->tm_mday;
-  yyHour = tmp->tm_hour;
-  yyMinutes = tmp->tm_min;
-  yySeconds = tmp->tm_sec;
+  cookie.yyYear = tmp->tm_year + TM_YEAR_ORIGIN;
+  cookie.yyMonth = tmp->tm_mon + 1;
+  cookie.yyDay = tmp->tm_mday;
+  cookie.yyHour = tmp->tm_hour;
+  cookie.yyMinutes = tmp->tm_min;
+  cookie.yySeconds = tmp->tm_sec;
   tm.tm_isdst = tmp->tm_isdst;
-  yyMeridian = MER24;
-  yyRelSeconds = 0;
-  yyRelMinutes = 0;
-  yyRelHour = 0;
-  yyRelDay = 0;
-  yyRelMonth = 0;
-  yyRelYear = 0;
-  yyHaveDate = 0;
-  yyHaveDay = 0;
-  yyHaveRel = 0;
-  yyHaveTime = 0;
-  yyHaveZone = 0;
-
-  if (yyparse ()
-      || yyHaveTime > 1 || yyHaveZone > 1 || yyHaveDate > 1 || yyHaveDay > 1)
+  cookie.yyMeridian = MER24;
+  cookie.yyRelSeconds = 0;
+  cookie.yyRelMinutes = 0;
+  cookie.yyRelHour = 0;
+  cookie.yyRelDay = 0;
+  cookie.yyRelMonth = 0;
+  cookie.yyRelYear = 0;
+  cookie.yyHaveDate = 0;
+  cookie.yyHaveDay = 0;
+  cookie.yyHaveRel = 0;
+  cookie.yyHaveTime = 0;
+  cookie.yyHaveZone = 0;
+
+  if (yyparse (&cookie)
+      || cookie.yyHaveTime > 1 || cookie.yyHaveZone > 1 ||
+      cookie.yyHaveDate > 1 || cookie.yyHaveDay > 1)
     return -1;
 
-  tm.tm_year = ToYear (yyYear) - TM_YEAR_ORIGIN + yyRelYear;
-  tm.tm_mon = yyMonth - 1 + yyRelMonth;
-  tm.tm_mday = yyDay + yyRelDay;
-  if (yyHaveTime || (yyHaveRel && !yyHaveDate && !yyHaveDay))
+  tm.tm_year = ToYear (cookie.yyYear) - TM_YEAR_ORIGIN + cookie.yyRelYear;
+  tm.tm_mon = cookie.yyMonth - 1 + cookie.yyRelMonth;
+  tm.tm_mday = cookie.yyDay + cookie.yyRelDay;
+  if (cookie.yyHaveTime ||
+      (cookie.yyHaveRel && !cookie.yyHaveDate && !cookie.yyHaveDay))
     {
-      tm.tm_hour = ToHour (yyHour, yyMeridian);
+      tm.tm_hour = ToHour (cookie.yyHour, cookie.yyMeridian);
       if (tm.tm_hour < 0)
 	return -1;
-      tm.tm_min = yyMinutes;
-      tm.tm_sec = yySeconds;
+      tm.tm_min = cookie.yyMinutes;
+      tm.tm_sec = cookie.yySeconds;
     }
   else
     {
       tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
     }
-  tm.tm_hour += yyRelHour;
-  tm.tm_min += yyRelMinutes;
-  tm.tm_sec += yyRelSeconds;
+  tm.tm_hour += cookie.yyRelHour;
+  tm.tm_min += cookie.yyRelMinutes;
+  tm.tm_sec += cookie.yyRelSeconds;
 
   /* Let mktime deduce tm_isdst if we have an absolute timestamp,
      or if the relative timestamp mentions days, months, or years.  */
-  if (yyHaveDate | yyHaveDay | yyHaveTime | yyRelDay | yyRelMonth | yyRelYear)
+  if (cookie.yyHaveDate | cookie.yyHaveDay | cookie.yyHaveTime |
+      cookie.yyRelDay | cookie.yyRelMonth | cookie.yyRelYear)
     tm.tm_isdst = -1;
 
   tm0 = tm;
 
   Start = mktime (&tm);
 
@@ -2050,48 +2064,55 @@
          time_t value is 1970-01-01 00:00:00 UTC and we are 8 hours ahead
          of UTC, then the min localtime value is 1970-01-01 08:00:00; if
          we apply mktime to 1970-01-01 00:00:00 we will get an error, so
          we apply mktime to 1970-01-02 08:00:00 instead and adjust the time
          zone by 24 hours to compensate.  This algorithm assumes that
          there is no DST transition within a day of the time_t boundaries.  */
-      if (yyHaveZone)
+      if (cookie.yyHaveZone)
 	{
 	  tm = tm0;
 	  if (tm.tm_year <= EPOCH - TM_YEAR_ORIGIN)
 	    {
 	      tm.tm_mday++;
-	      yyTimezone -= 24 * 60;
+	      cookie.yyTimezone -= 24 * 60;
 	    }
 	  else
 	    {
 	      tm.tm_mday--;
-	      yyTimezone += 24 * 60;
+	      cookie.yyTimezone += 24 * 60;
 	    }
 	  Start = mktime (&tm);
 	}
 
       if (Start == (time_t) -1)
 	return Start;
     }
 
-  if (yyHaveDay && !yyHaveDate)
+  if (cookie.yyHaveDay && !cookie.yyHaveDate)
     {
-      tm.tm_mday += ((yyDayNumber - tm.tm_wday + 7) % 7
-		     + 7 * (yyDayOrdinal - (0 < yyDayOrdinal)));
+      tm.tm_mday += ((cookie.yyDayNumber - tm.tm_wday + 7) % 7
+		     + 7 * (cookie.yyDayOrdinal - (0 < cookie.yyDayOrdinal)));
       Start = mktime (&tm);
       if (Start == (time_t) -1)
 	return Start;
     }
 
-  if (yyHaveZone)
+  if (cookie.yyHaveZone)
     {
       long delta;
-      struct tm *gmt = gmtime (&Start);
+      struct tm *gmt;
+#ifdef HAVE_GMTIME_R
+      /* thread-safe version */
+      struct tm keeptime;
+      gmt = (struct tm *)gmtime_r(&Start, &keeptime);
+#else
+      gmt = gmtime(&Start);
+#endif
       if (!gmt)
 	return -1;
-      delta = yyTimezone * 60L + difftm (&tm, gmt);
+      delta = cookie.yyTimezone * 60L + difftm (&tm, gmt);
       if ((Start + delta < Start) != (delta < 0))
 	return -1;		/* time_t overflow */
       Start += delta;
     }
 
   return Start;
@@ -2123,14 +2144,6 @@
       (void) fflush (stdout);
     }
   exit (0);
   /* NOTREACHED */
 }
 #endif /* defined (TEST) */
-
-/*
- * local variables:
- * eval: (load-file "../curl-mode.el")
- * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
- */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getdate.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getdate.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getdate.h	2000-05-22 22:12:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getdate.h	2002-02-20 20:38:14.000000000 +0800
@@ -4,15 +4,13 @@
 **  a couple of people on Usenet.  Completely overhauled by Rich $alz
 **  <rsalz@bbn.com> and Jim Berets <jberets@bbn.com> in August, 1990.
 **
 **  This code is in the public domain and has no copyright.
 */
 
-#if HAVE_CONFIG_H
-# include <config.h>
-#endif
+# include "setup.h"
 
 #ifndef PARAMS
 # if defined PROTOTYPES || (defined __STDC__ && __STDC__)
 #  define PARAMS(Args) Args
 # else
 #  define PARAMS(Args) ()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getdate.y /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getdate.y
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getdate.y	2001-08-24 15:38:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getdate.y	2002-02-27 15:27:47.000000000 +0800
@@ -7,21 +7,23 @@
 **
 **  This code is in the public domain and has no copyright.
 */
 
 #include "setup.h"
 
-#ifdef HAVE_CONFIG_H
-# include "config.h"
 # ifdef HAVE_ALLOCA_H
 #  include <alloca.h>
 # endif
 
 # ifdef HAVE_TIME_H
 #  include <time.h>
 # endif
+
+#ifndef YYDEBUG
+  /* to satisfy gcc -Wundef, we set this to 0 */
+#define YYDEBUG 0
 #endif
 
 /* Since the code of getdate.y is not included in the Emacs executable
    itself, there is no need to #define static in this file.  Even if
    the code were included in the Emacs executable, it probably
    wouldn't do any harm to #undef it here; this will only cause
@@ -165,47 +167,54 @@
 **  Meridian:  am, pm, or 24-hour style.
 */
 typedef enum _MERIDIAN {
     MERam, MERpm, MER24
 } MERIDIAN;
 
+/* parse results and input string */
+typedef struct _CONTEXT {
+    const char	*yyInput;
+    int		yyDayOrdinal;
+    int		yyDayNumber;
+    int		yyHaveDate;
+    int		yyHaveDay;
+    int		yyHaveRel;
+    int		yyHaveTime;
+    int		yyHaveZone;
+    int		yyTimezone;
+    int		yyDay;
+    int		yyHour;
+    int		yyMinutes;
+    int		yyMonth;
+    int		yySeconds;
+    int		yyYear;
+    MERIDIAN	yyMeridian;
+    int		yyRelDay;
+    int		yyRelHour;
+    int		yyRelMinutes;
+    int		yyRelMonth;
+    int		yyRelSeconds;
+    int		yyRelYear;
+} CONTEXT;
 
-/*
-**  Global variables.  We could get rid of most of these by using a good
-**  union as the yacc stack.  (This routine was originally written before
-**  yacc had the %union construct.)  Maybe someday; right now we only use
-**  the %union very rarely.
+/* enable use of extra argument to yyparse and yylex which can be used to pass
+**  in a user defined value (CONTEXT struct in our case)
 */
-static const char	*yyInput;
-static int	yyDayOrdinal;
-static int	yyDayNumber;
-static int	yyHaveDate;
-static int	yyHaveDay;
-static int	yyHaveRel;
-static int	yyHaveTime;
-static int	yyHaveZone;
-static int	yyTimezone;
-static int	yyDay;
-static int	yyHour;
-static int	yyMinutes;
-static int	yyMonth;
-static int	yySeconds;
-static int	yyYear;
-static MERIDIAN	yyMeridian;
-static int	yyRelDay;
-static int	yyRelHour;
-static int	yyRelMinutes;
-static int	yyRelMonth;
-static int	yyRelSeconds;
-static int	yyRelYear;
-
+#define YYPARSE_PARAM cookie
+#define YYLEX_PARAM cookie
+#define context ((CONTEXT *) cookie)
 %}
 
 /* This grammar has 13 shift/reduce conflicts. */
 %expect 13
 
+/* turn global variables into locals, additionally enable extra arguments
+** for yylex (pointer to yylval and user defined value)
+*/
+%pure_parser
+
 %union {
     int			Number;
     enum _MERIDIAN	Meridian;
 }
 
 %token	tAGO tDAY tDAY_UNIT tDAYZONE tDST tHOUR_UNIT tID
@@ -221,243 +230,244 @@
 
 spec	: /* NULL */
 	| spec item
 	;
 
 item	: time {
-	    yyHaveTime++;
+	    context->yyHaveTime++;
 	}
 	| zone {
-	    yyHaveZone++;
+	    context->yyHaveZone++;
 	}
 	| date {
-	    yyHaveDate++;
+	    context->yyHaveDate++;
 	}
 	| day {
-	    yyHaveDay++;
+	    context->yyHaveDay++;
 	}
 	| rel {
-	    yyHaveRel++;
+	    context->yyHaveRel++;
 	}
 	| number
 	;
 
 time	: tUNUMBER tMERIDIAN {
-	    yyHour = $1;
-	    yyMinutes = 0;
-	    yySeconds = 0;
-	    yyMeridian = $2;
+	    context->yyHour = $1;
+	    context->yyMinutes = 0;
+	    context->yySeconds = 0;
+	    context->yyMeridian = $2;
 	}
 	| tUNUMBER ':' tUNUMBER o_merid {
-	    yyHour = $1;
-	    yyMinutes = $3;
-	    yySeconds = 0;
-	    yyMeridian = $4;
+	    context->yyHour = $1;
+	    context->yyMinutes = $3;
+	    context->yySeconds = 0;
+	    context->yyMeridian = $4;
 	}
 	| tUNUMBER ':' tUNUMBER tSNUMBER {
-	    yyHour = $1;
-	    yyMinutes = $3;
-	    yyMeridian = MER24;
-	    yyHaveZone++;
-	    yyTimezone = ($4 < 0
-			  ? -$4 % 100 + (-$4 / 100) * 60
-			  : - ($4 % 100 + ($4 / 100) * 60));
+	    context->yyHour = $1;
+	    context->yyMinutes = $3;
+	    context->yyMeridian = MER24;
+	    context->yyHaveZone++;
+	    context->yyTimezone = ($4 < 0
+				   ? -$4 % 100 + (-$4 / 100) * 60
+				   : - ($4 % 100 + ($4 / 100) * 60));
 	}
 	| tUNUMBER ':' tUNUMBER ':' tUNUMBER o_merid {
-	    yyHour = $1;
-	    yyMinutes = $3;
-	    yySeconds = $5;
-	    yyMeridian = $6;
+	    context->yyHour = $1;
+	    context->yyMinutes = $3;
+	    context->yySeconds = $5;
+	    context->yyMeridian = $6;
 	}
 	| tUNUMBER ':' tUNUMBER ':' tUNUMBER tSNUMBER {
-	    yyHour = $1;
-	    yyMinutes = $3;
-	    yySeconds = $5;
-	    yyMeridian = MER24;
-	    yyHaveZone++;
-	    yyTimezone = ($6 < 0
-			  ? -$6 % 100 + (-$6 / 100) * 60
-			  : - ($6 % 100 + ($6 / 100) * 60));
+	    context->yyHour = $1;
+	    context->yyMinutes = $3;
+	    context->yySeconds = $5;
+	    context->yyMeridian = MER24;
+	    context->yyHaveZone++;
+	    context->yyTimezone = ($6 < 0
+				   ? -$6 % 100 + (-$6 / 100) * 60
+				   : - ($6 % 100 + ($6 / 100) * 60));
 	}
 	;
 
 zone	: tZONE {
-	    yyTimezone = $1;
+	    context->yyTimezone = $1;
 	}
 	| tDAYZONE {
-	    yyTimezone = $1 - 60;
+	    context->yyTimezone = $1 - 60;
 	}
 	|
 	  tZONE tDST {
-	    yyTimezone = $1 - 60;
+	    context->yyTimezone = $1 - 60;
 	}
 	;
 
 day	: tDAY {
-	    yyDayOrdinal = 1;
-	    yyDayNumber = $1;
+	    context->yyDayOrdinal = 1;
+	    context->yyDayNumber = $1;
 	}
 	| tDAY ',' {
-	    yyDayOrdinal = 1;
-	    yyDayNumber = $1;
+	    context->yyDayOrdinal = 1;
+	    context->yyDayNumber = $1;
 	}
 	| tUNUMBER tDAY {
-	    yyDayOrdinal = $1;
-	    yyDayNumber = $2;
+	    context->yyDayOrdinal = $1;
+	    context->yyDayNumber = $2;
 	}
 	;
 
 date	: tUNUMBER '/' tUNUMBER {
-	    yyMonth = $1;
-	    yyDay = $3;
+	    context->yyMonth = $1;
+	    context->yyDay = $3;
 	}
 	| tUNUMBER '/' tUNUMBER '/' tUNUMBER {
 	  /* Interpret as YYYY/MM/DD if $1 >= 1000, otherwise as MM/DD/YY.
 	     The goal in recognizing YYYY/MM/DD is solely to support legacy
 	     machine-generated dates like those in an RCS log listing.  If
 	     you want portability, use the ISO 8601 format.  */
 	  if ($1 >= 1000)
 	    {
-	      yyYear = $1;
-	      yyMonth = $3;
-	      yyDay = $5;
+	      context->yyYear = $1;
+	      context->yyMonth = $3;
+	      context->yyDay = $5;
 	    }
 	  else
 	    {
-	      yyMonth = $1;
-	      yyDay = $3;
-	      yyYear = $5;
+	      context->yyMonth = $1;
+	      context->yyDay = $3;
+	      context->yyYear = $5;
 	    }
 	}
 	| tUNUMBER tSNUMBER tSNUMBER {
 	    /* ISO 8601 format.  yyyy-mm-dd.  */
-	    yyYear = $1;
-	    yyMonth = -$2;
-	    yyDay = -$3;
+	    context->yyYear = $1;
+	    context->yyMonth = -$2;
+	    context->yyDay = -$3;
 	}
 	| tUNUMBER tMONTH tSNUMBER {
 	    /* e.g. 17-JUN-1992.  */
-	    yyDay = $1;
-	    yyMonth = $2;
-	    yyYear = -$3;
+	    context->yyDay = $1;
+	    context->yyMonth = $2;
+	    context->yyYear = -$3;
 	}
 	| tMONTH tUNUMBER {
-	    yyMonth = $1;
-	    yyDay = $2;
+	    context->yyMonth = $1;
+	    context->yyDay = $2;
 	}
 	| tMONTH tUNUMBER ',' tUNUMBER {
-	    yyMonth = $1;
-	    yyDay = $2;
-	    yyYear = $4;
+	    context->yyMonth = $1;
+	    context->yyDay = $2;
+	    context->yyYear = $4;
 	}
 	| tUNUMBER tMONTH {
-	    yyMonth = $2;
-	    yyDay = $1;
+	    context->yyMonth = $2;
+	    context->yyDay = $1;
 	}
 	| tUNUMBER tMONTH tUNUMBER {
-	    yyMonth = $2;
-	    yyDay = $1;
-	    yyYear = $3;
+	    context->yyMonth = $2;
+	    context->yyDay = $1;
+	    context->yyYear = $3;
 	}
 	;
 
 rel	: relunit tAGO {
-	    yyRelSeconds = -yyRelSeconds;
-	    yyRelMinutes = -yyRelMinutes;
-	    yyRelHour = -yyRelHour;
-	    yyRelDay = -yyRelDay;
-	    yyRelMonth = -yyRelMonth;
-	    yyRelYear = -yyRelYear;
+	    context->yyRelSeconds = -context->yyRelSeconds;
+	    context->yyRelMinutes = -context->yyRelMinutes;
+	    context->yyRelHour = -context->yyRelHour;
+	    context->yyRelDay = -context->yyRelDay;
+	    context->yyRelMonth = -context->yyRelMonth;
+	    context->yyRelYear = -context->yyRelYear;
 	}
 	| relunit
 	;
 
 relunit	: tUNUMBER tYEAR_UNIT {
-	    yyRelYear += $1 * $2;
+	    context->yyRelYear += $1 * $2;
 	}
 	| tSNUMBER tYEAR_UNIT {
-	    yyRelYear += $1 * $2;
+	    context->yyRelYear += $1 * $2;
 	}
 	| tYEAR_UNIT {
-	    yyRelYear += $1;
+	    context->yyRelYear += $1;
 	}
 	| tUNUMBER tMONTH_UNIT {
-	    yyRelMonth += $1 * $2;
+	    context->yyRelMonth += $1 * $2;
 	}
 	| tSNUMBER tMONTH_UNIT {
-	    yyRelMonth += $1 * $2;
+	    context->yyRelMonth += $1 * $2;
 	}
 	| tMONTH_UNIT {
-	    yyRelMonth += $1;
+	    context->yyRelMonth += $1;
 	}
 	| tUNUMBER tDAY_UNIT {
-	    yyRelDay += $1 * $2;
+	    context->yyRelDay += $1 * $2;
 	}
 	| tSNUMBER tDAY_UNIT {
-	    yyRelDay += $1 * $2;
+	    context->yyRelDay += $1 * $2;
 	}
 	| tDAY_UNIT {
-	    yyRelDay += $1;
+	    context->yyRelDay += $1;
 	}
 	| tUNUMBER tHOUR_UNIT {
-	    yyRelHour += $1 * $2;
+	    context->yyRelHour += $1 * $2;
 	}
 	| tSNUMBER tHOUR_UNIT {
-	    yyRelHour += $1 * $2;
+	    context->yyRelHour += $1 * $2;
 	}
 	| tHOUR_UNIT {
-	    yyRelHour += $1;
+	    context->yyRelHour += $1;
 	}
 	| tUNUMBER tMINUTE_UNIT {
-	    yyRelMinutes += $1 * $2;
+	    context->yyRelMinutes += $1 * $2;
 	}
 	| tSNUMBER tMINUTE_UNIT {
-	    yyRelMinutes += $1 * $2;
+	    context->yyRelMinutes += $1 * $2;
 	}
 	| tMINUTE_UNIT {
-	    yyRelMinutes += $1;
+	    context->yyRelMinutes += $1;
 	}
 	| tUNUMBER tSEC_UNIT {
-	    yyRelSeconds += $1 * $2;
+	    context->yyRelSeconds += $1 * $2;
 	}
 	| tSNUMBER tSEC_UNIT {
-	    yyRelSeconds += $1 * $2;
+	    context->yyRelSeconds += $1 * $2;
 	}
 	| tSEC_UNIT {
-	    yyRelSeconds += $1;
+	    context->yyRelSeconds += $1;
 	}
 	;
 
 number	: tUNUMBER
           {
-	    if (yyHaveTime && yyHaveDate && !yyHaveRel)
-	      yyYear = $1;
+	    if (context->yyHaveTime && context->yyHaveDate &&
+		!context->yyHaveRel)
+	      context->yyYear = $1;
 	    else
 	      {
 		if ($1>10000)
 		  {
-		    yyHaveDate++;
-		    yyDay= ($1)%100;
-		    yyMonth= ($1/100)%100;
-		    yyYear = $1/10000;
+		    context->yyHaveDate++;
+		    context->yyDay= ($1)%100;
+		    context->yyMonth= ($1/100)%100;
+		    context->yyYear = $1/10000;
 		  }
 		else
 		  {
-		    yyHaveTime++;
+		    context->yyHaveTime++;
 		    if ($1 < 100)
 		      {
-			yyHour = $1;
-			yyMinutes = 0;
+			context->yyHour = $1;
+			context->yyMinutes = 0;
 		      }
 		    else
 		      {
-		    	yyHour = $1 / 100;
-		    	yyMinutes = $1 % 100;
+		    	context->yyHour = $1 / 100;
+		    	context->yyMinutes = $1 % 100;
 		      }
-		    yySeconds = 0;
-		    yyMeridian = MER24;
+		    context->yySeconds = 0;
+		    context->yyMeridian = MER24;
 		  }
 	      }
 	  }
 	;
 
 o_merid	: /* NULL */
@@ -722,13 +732,14 @@
     Year += 1900;
 
   return Year;
 }
 
 static int
-LookupWord (buff)
+LookupWord (yylval, buff)
+     YYSTYPE *yylval;
      char *buff;
 {
   register char *p;
   register char *q;
   register const TABLE *tp;
   int i;
@@ -738,18 +749,18 @@
   for (p = buff; *p; p++)
     if (ISUPPER ((unsigned char) *p))
       *p = tolower (*p);
 
   if (strcmp (buff, "am") == 0 || strcmp (buff, "a.m.") == 0)
     {
-      yylval.Meridian = MERam;
+      yylval->Meridian = MERam;
       return tMERIDIAN;
     }
   if (strcmp (buff, "pm") == 0 || strcmp (buff, "p.m.") == 0)
     {
-      yylval.Meridian = MERpm;
+      yylval->Meridian = MERpm;
       return tMERIDIAN;
     }
 
   /* See if we have an abbreviation for a month. */
   if (strlen (buff) == 3)
     abbrev = 1;
@@ -764,68 +775,68 @@
   for (tp = MonthDayTable; tp->name; tp++)
     {
       if (abbrev)
 	{
 	  if (strncmp (buff, tp->name, 3) == 0)
 	    {
-	      yylval.Number = tp->value;
+	      yylval->Number = tp->value;
 	      return tp->type;
 	    }
 	}
       else if (strcmp (buff, tp->name) == 0)
 	{
-	  yylval.Number = tp->value;
+	  yylval->Number = tp->value;
 	  return tp->type;
 	}
     }
 
   for (tp = TimezoneTable; tp->name; tp++)
     if (strcmp (buff, tp->name) == 0)
       {
-	yylval.Number = tp->value;
+	yylval->Number = tp->value;
 	return tp->type;
       }
 
   if (strcmp (buff, "dst") == 0)
     return tDST;
 
   for (tp = UnitsTable; tp->name; tp++)
     if (strcmp (buff, tp->name) == 0)
       {
-	yylval.Number = tp->value;
+	yylval->Number = tp->value;
 	return tp->type;
       }
 
   /* Strip off any plural and try the units table again. */
   i = strlen (buff) - 1;
   if (buff[i] == 's')
     {
       buff[i] = '\0';
       for (tp = UnitsTable; tp->name; tp++)
 	if (strcmp (buff, tp->name) == 0)
 	  {
-	    yylval.Number = tp->value;
+	    yylval->Number = tp->value;
 	    return tp->type;
 	  }
       buff[i] = 's';		/* Put back for "this" in OtherTable. */
     }
 
   for (tp = OtherTable; tp->name; tp++)
     if (strcmp (buff, tp->name) == 0)
       {
-	yylval.Number = tp->value;
+	yylval->Number = tp->value;
 	return tp->type;
       }
 
   /* Military timezones. */
   if (buff[1] == '\0' && ISALPHA ((unsigned char) *buff))
     {
       for (tp = MilitaryTable; tp->name; tp++)
 	if (strcmp (buff, tp->name) == 0)
 	  {
-	    yylval.Number = tp->value;
+	    yylval->Number = tp->value;
 	    return tp->type;
 	  }
     }
 
   /* Drop out any periods and try the timezone table again. */
   for (i = 0, p = q = buff; *q; q++)
@@ -835,66 +846,68 @@
       i++;
   *p = '\0';
   if (i)
     for (tp = TimezoneTable; tp->name; tp++)
       if (strcmp (buff, tp->name) == 0)
 	{
-	  yylval.Number = tp->value;
+	  yylval->Number = tp->value;
 	  return tp->type;
 	}
 
   return tID;
 }
 
 static int
-yylex ()
+yylex (yylval, cookie)
+     YYSTYPE *yylval;
+     void *cookie;
 {
   register unsigned char c;
   register char *p;
   char buff[20];
   int Count;
   int sign;
 
   for (;;)
     {
-      while (ISSPACE ((unsigned char) *yyInput))
-	yyInput++;
+      while (ISSPACE ((unsigned char) *context->yyInput))
+	context->yyInput++;
 
-      if (ISDIGIT (c = *yyInput) || c == '-' || c == '+')
+      if (ISDIGIT (c = *context->yyInput) || c == '-' || c == '+')
 	{
 	  if (c == '-' || c == '+')
 	    {
 	      sign = c == '-' ? -1 : 1;
-	      if (!ISDIGIT (*++yyInput))
+	      if (!ISDIGIT (*++context->yyInput))
 		/* skip the '-' sign */
 		continue;
 	    }
 	  else
 	    sign = 0;
-	  for (yylval.Number = 0; ISDIGIT (c = *yyInput++);)
-	    yylval.Number = 10 * yylval.Number + c - '0';
-	  yyInput--;
+	  for (yylval->Number = 0; ISDIGIT (c = *context->yyInput++);)
+	    yylval->Number = 10 * yylval->Number + c - '0';
+	  context->yyInput--;
 	  if (sign < 0)
-	    yylval.Number = -yylval.Number;
+	    yylval->Number = -yylval->Number;
 	  return sign ? tSNUMBER : tUNUMBER;
 	}
       if (ISALPHA (c))
 	{
-	  for (p = buff; (c = *yyInput++, ISALPHA (c)) || c == '.';)
+	  for (p = buff; (c = *context->yyInput++, ISALPHA (c)) || c == '.';)
 	    if (p < &buff[sizeof buff - 1])
 	      *p++ = c;
 	  *p = '\0';
-	  yyInput--;
-	  return LookupWord (buff);
+	  context->yyInput--;
+	  return LookupWord (yylval, buff);
 	}
       if (c != '(')
-	return *yyInput++;
+	return *context->yyInput++;
       Count = 0;
       do
 	{
-	  c = *yyInput++;
+	  c = *context->yyInput++;
 	  if (c == '\0')
 	    return c;
 	  if (c == '(')
 	    Count++;
 	  else if (c == ')')
 	    Count--;
@@ -928,70 +941,74 @@
 
 time_t
 curl_getdate (const char *p, const time_t *now)
 {
   struct tm tm, tm0, *tmp;
   time_t Start;
+  CONTEXT cookie;
 #ifdef HAVE_LOCALTIME_R
   struct tm keeptime;
 #endif
-  yyInput = p;
+  cookie.yyInput = p;
   Start = now ? *now : time ((time_t *) NULL);
 #ifdef HAVE_LOCALTIME_R
   tmp = (struct tm *)localtime_r(&Start, &keeptime);
 #else
   tmp = localtime (&Start);
 #endif
   if (!tmp)
     return -1;
-  yyYear = tmp->tm_year + TM_YEAR_ORIGIN;
-  yyMonth = tmp->tm_mon + 1;
-  yyDay = tmp->tm_mday;
-  yyHour = tmp->tm_hour;
-  yyMinutes = tmp->tm_min;
-  yySeconds = tmp->tm_sec;
+  cookie.yyYear = tmp->tm_year + TM_YEAR_ORIGIN;
+  cookie.yyMonth = tmp->tm_mon + 1;
+  cookie.yyDay = tmp->tm_mday;
+  cookie.yyHour = tmp->tm_hour;
+  cookie.yyMinutes = tmp->tm_min;
+  cookie.yySeconds = tmp->tm_sec;
   tm.tm_isdst = tmp->tm_isdst;
-  yyMeridian = MER24;
-  yyRelSeconds = 0;
-  yyRelMinutes = 0;
-  yyRelHour = 0;
-  yyRelDay = 0;
-  yyRelMonth = 0;
-  yyRelYear = 0;
-  yyHaveDate = 0;
-  yyHaveDay = 0;
-  yyHaveRel = 0;
-  yyHaveTime = 0;
-  yyHaveZone = 0;
-
-  if (yyparse ()
-      || yyHaveTime > 1 || yyHaveZone > 1 || yyHaveDate > 1 || yyHaveDay > 1)
+  cookie.yyMeridian = MER24;
+  cookie.yyRelSeconds = 0;
+  cookie.yyRelMinutes = 0;
+  cookie.yyRelHour = 0;
+  cookie.yyRelDay = 0;
+  cookie.yyRelMonth = 0;
+  cookie.yyRelYear = 0;
+  cookie.yyHaveDate = 0;
+  cookie.yyHaveDay = 0;
+  cookie.yyHaveRel = 0;
+  cookie.yyHaveTime = 0;
+  cookie.yyHaveZone = 0;
+
+  if (yyparse (&cookie)
+      || cookie.yyHaveTime > 1 || cookie.yyHaveZone > 1 ||
+      cookie.yyHaveDate > 1 || cookie.yyHaveDay > 1)
     return -1;
 
-  tm.tm_year = ToYear (yyYear) - TM_YEAR_ORIGIN + yyRelYear;
-  tm.tm_mon = yyMonth - 1 + yyRelMonth;
-  tm.tm_mday = yyDay + yyRelDay;
-  if (yyHaveTime || (yyHaveRel && !yyHaveDate && !yyHaveDay))
+  tm.tm_year = ToYear (cookie.yyYear) - TM_YEAR_ORIGIN + cookie.yyRelYear;
+  tm.tm_mon = cookie.yyMonth - 1 + cookie.yyRelMonth;
+  tm.tm_mday = cookie.yyDay + cookie.yyRelDay;
+  if (cookie.yyHaveTime ||
+      (cookie.yyHaveRel && !cookie.yyHaveDate && !cookie.yyHaveDay))
     {
-      tm.tm_hour = ToHour (yyHour, yyMeridian);
+      tm.tm_hour = ToHour (cookie.yyHour, cookie.yyMeridian);
       if (tm.tm_hour < 0)
 	return -1;
-      tm.tm_min = yyMinutes;
-      tm.tm_sec = yySeconds;
+      tm.tm_min = cookie.yyMinutes;
+      tm.tm_sec = cookie.yySeconds;
     }
   else
     {
       tm.tm_hour = tm.tm_min = tm.tm_sec = 0;
     }
-  tm.tm_hour += yyRelHour;
-  tm.tm_min += yyRelMinutes;
-  tm.tm_sec += yyRelSeconds;
+  tm.tm_hour += cookie.yyRelHour;
+  tm.tm_min += cookie.yyRelMinutes;
+  tm.tm_sec += cookie.yyRelSeconds;
 
   /* Let mktime deduce tm_isdst if we have an absolute timestamp,
      or if the relative timestamp mentions days, months, or years.  */
-  if (yyHaveDate | yyHaveDay | yyHaveTime | yyRelDay | yyRelMonth | yyRelYear)
+  if (cookie.yyHaveDate | cookie.yyHaveDay | cookie.yyHaveTime |
+      cookie.yyRelDay | cookie.yyRelMonth | cookie.yyRelYear)
     tm.tm_isdst = -1;
 
   tm0 = tm;
 
   Start = mktime (&tm);
 
@@ -1003,48 +1020,55 @@
          time_t value is 1970-01-01 00:00:00 UTC and we are 8 hours ahead
          of UTC, then the min localtime value is 1970-01-01 08:00:00; if
          we apply mktime to 1970-01-01 00:00:00 we will get an error, so
          we apply mktime to 1970-01-02 08:00:00 instead and adjust the time
          zone by 24 hours to compensate.  This algorithm assumes that
          there is no DST transition within a day of the time_t boundaries.  */
-      if (yyHaveZone)
+      if (cookie.yyHaveZone)
 	{
 	  tm = tm0;
 	  if (tm.tm_year <= EPOCH - TM_YEAR_ORIGIN)
 	    {
 	      tm.tm_mday++;
-	      yyTimezone -= 24 * 60;
+	      cookie.yyTimezone -= 24 * 60;
 	    }
 	  else
 	    {
 	      tm.tm_mday--;
-	      yyTimezone += 24 * 60;
+	      cookie.yyTimezone += 24 * 60;
 	    }
 	  Start = mktime (&tm);
 	}
 
       if (Start == (time_t) -1)
 	return Start;
     }
 
-  if (yyHaveDay && !yyHaveDate)
+  if (cookie.yyHaveDay && !cookie.yyHaveDate)
     {
-      tm.tm_mday += ((yyDayNumber - tm.tm_wday + 7) % 7
-		     + 7 * (yyDayOrdinal - (0 < yyDayOrdinal)));
+      tm.tm_mday += ((cookie.yyDayNumber - tm.tm_wday + 7) % 7
+		     + 7 * (cookie.yyDayOrdinal - (0 < cookie.yyDayOrdinal)));
       Start = mktime (&tm);
       if (Start == (time_t) -1)
 	return Start;
     }
 
-  if (yyHaveZone)
+  if (cookie.yyHaveZone)
     {
       long delta;
-      struct tm *gmt = gmtime (&Start);
+      struct tm *gmt;
+#ifdef HAVE_GMTIME_R
+      /* thread-safe version */
+      struct tm keeptime;
+      gmt = (struct tm *)gmtime_r(&Start, &keeptime);
+#else
+      gmt = gmtime(&Start);
+#endif
       if (!gmt)
 	return -1;
-      delta = yyTimezone * 60L + difftm (&tm, gmt);
+      delta = cookie.yyTimezone * 60L + difftm (&tm, gmt);
       if ((Start + delta < Start) != (delta < 0))
 	return -1;		/* time_t overflow */
       Start += delta;
     }
 
   return Start;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getenv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getenv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getenv.c	2001-09-07 14:05:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getenv.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,28 +2,30 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getenv.c,v 1.13 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: getenv.c,v 1.17 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
+#include "setup.h"
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
 #ifdef WIN32
 #include <windows.h>
@@ -50,13 +52,12 @@
 #else
 #ifdef	VMS
   char *env = getenv(variable);
   if (env && strcmp("HOME",variable) == 0) {
 	env = decc$translate_vms(env);
   }
-/*  printf ("Getenv: %s=%s\n",variable,env); */
 #else
   /* no length control */
   char *env = getenv(variable);
 #endif
 #endif
   return (env && env[0])?strdup(env):NULL;
@@ -68,9 +69,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getinfo.c	2001-09-07 14:05:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getinfo.c	2002-04-16 15:59:20.000000000 +0800
@@ -2,55 +2,73 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getinfo.c,v 1.12 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: getinfo.c,v 1.21 2002/04/16 07:59:20 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
 #include "urldata.h"
 
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 
+#ifdef	VMS
+#include	<stdlib.h>
+#endif
+
+/* Make this the last #include */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 /*
  * This is supposed to be called in the beginning of a permform() session
  * and should reset all session-info variables
  */
 CURLcode Curl_initinfo(struct SessionHandle *data)
 {
   struct Progress *pro = &data->progress;
   struct PureInfo *info =&data->info;
 
   pro->t_nslookup = 0;
   pro->t_connect = 0;
   pro->t_pretransfer = 0;
+  pro->t_starttransfer = 0;
+  pro->timespent = 0;
+  pro->t_redirect = 0;
 
   info->httpcode = 0;
   info->httpversion=0;
-  info->filetime=0;
+  info->filetime=-1; /* -1 is an illegal time and thus means unknown */
+  
+  if (info->contenttype)
+    free(info->contenttype);
+  info->contenttype = NULL;
 
+  info->header_size = 0;
+  info->request_size = 0;
   return CURLE_OK;
 }
 
 CURLcode Curl_getinfo(struct SessionHandle *data, CURLINFO info, ...)
 {
   va_list arg;
@@ -104,12 +122,15 @@
   case CURLINFO_CONNECT_TIME:
     *param_doublep = data->progress.t_connect;
     break;
   case CURLINFO_PRETRANSFER_TIME:
     *param_doublep =  data->progress.t_pretransfer;
     break;
+  case CURLINFO_STARTTRANSFER_TIME:
+    *param_doublep = data->progress.t_starttransfer;
+    break;
   case CURLINFO_SIZE_UPLOAD:
     *param_doublep =  data->progress.uploaded;
     break;
   case CURLINFO_SIZE_DOWNLOAD:
     *param_doublep = data->progress.downloaded;
     break;
@@ -125,19 +146,28 @@
   case CURLINFO_CONTENT_LENGTH_DOWNLOAD:
     *param_doublep = data->progress.size_dl;
     break;
   case CURLINFO_CONTENT_LENGTH_UPLOAD:
     *param_doublep = data->progress.size_ul;
     break;
+  case CURLINFO_REDIRECT_TIME:
+    *param_doublep =  data->progress.t_redirect;
+    break;
+  case CURLINFO_REDIRECT_COUNT:
+    *param_longp = data->set.followlocation;
+    break;
+  case CURLINFO_CONTENT_TYPE:
+    *param_charp = data->info.contenttype;
+    break;
   default:
     return CURLE_BAD_FUNCTION_ARGUMENT;
   }
   return CURLE_OK;
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getinfo.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getinfo.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getinfo.h	2001-08-31 06:54:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getinfo.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,25 +4,25 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getinfo.h,v 1.2 2001/08/30 22:48:34 bagder Exp $
+ * $Id: getinfo.h,v 1.3 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 CURLcode Curl_getinfo(struct SessionHandle *data, CURLINFO info, ...);
 CURLcode Curl_initinfo(struct SessionHandle *data);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getpass.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getpass.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getpass.c	2001-09-07 14:05:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getpass.c	2002-03-19 15:54:55.000000000 +0800
@@ -1,8 +1,8 @@
 /* ============================================================================
- * Copyright (C) 1998 Angus Mackay. All rights reserved; 
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * Redistribution and use are freely permitted provided that:
  *
  *   1) This header remain in tact.
  *   2) The prototypes for getpass and getpass_r are not changed from:
  *         char *getpass(const char *prompt)
@@ -19,28 +19,26 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  * ============================================================================
  *
- * $Id: getpass.c,v 1.14 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: getpass.c,v 1.17 2002/03/19 07:54:55 bagder Exp $
  *
  * The spirit of this license is to allow use of this source code in any
  * project be it open or closed but still encourage the use of the open,
  * library based equivilents.
  *
  * Author(s):
  *   Angus Mackay <amackay@gus.ml.org>
  *
  * Contributor(s):
  *   Daniel Stenberg <daniel@haxx.se>
  */
 
-#ifdef HAVE_CONFIG_H
-#  include <config.h>
-#endif
+#include "setup.h" /* setup.h is required for read() prototype */
 
 #ifndef HAVE_GETPASS_R
 
 #ifndef WIN32
 #ifdef	VMS
 #include <stdio.h>
@@ -246,9 +244,9 @@
 #endif
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getpass.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getpass.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/getpass.h	2001-08-14 16:27:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/getpass.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getpass.h,v 1.8 2001/08/14 08:27:07 bagder Exp $
+ * $Id: getpass.h,v 1.9 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 #ifndef HAVE_GETPASS_R
 /* If there's a system-provided function named like this, we trust it is
    also found in one of the standard headers. */
 
 /*
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: hash.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: hash.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/hostip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/hostip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/hostip.c	2001-09-12 16:59:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/hostip.c	2002-06-11 23:10:38.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip.c,v 1.27 2001/09/12 08:59:00 bagder Exp $
+ * $Id: hostip.c,v 1.68 2002/06/11 15:10:19 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <errno.h>
@@ -44,155 +43,594 @@
 #ifdef HAVE_NETDB_H
 #include <netdb.h>
 #endif
 #ifdef HAVE_ARPA_INET_H
 #include <arpa/inet.h>
 #endif
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>	/* required for free() prototypes */
+#endif
 #ifdef	VMS
+#include <in.h>
 #include <inet.h>
 #include <stdlib.h>
 #endif
 #endif
 
+#ifdef HAVE_SETJMP_H
+#include <setjmp.h>
+#endif
+
 #include "urldata.h"
 #include "sendf.h"
+#include "hostip.h"
+#include "hash.h"
+
+#define _MPRINTF_REPLACE /* use our functions only */
+#include <curl/mprintf.h>
 
 #if defined(HAVE_INET_NTOA_R) && !defined(HAVE_INET_NTOA_R_DECL)
 #include "inet_ntoa_r.h"
 #endif
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
-/* --- resolve name or IP-number --- */
+static curl_hash hostname_cache;
+static int host_cache_initialized;
 
-static char *MakeIP(unsigned long num,char *addr, int addr_len)
+void Curl_global_host_cache_init(void)
 {
-#if defined(HAVE_INET_NTOA) || defined(HAVE_INET_NTOA_R)
-  struct in_addr in;
-  in.s_addr = htonl(num);
+  if (!host_cache_initialized) {
+    Curl_hash_init(&hostname_cache, 7, Curl_freeaddrinfo);
+    host_cache_initialized = 1;
+  }
+}
 
-#if defined(HAVE_INET_NTOA_R)
-  inet_ntoa_r(in,addr,addr_len);
-#else
-  strncpy(addr,inet_ntoa(in),addr_len);
+curl_hash *Curl_global_host_cache_get(void)
+{
+  return &hostname_cache;
+}
+
+void Curl_global_host_cache_dtor(void)
+{
+  if (host_cache_initialized) {
+    Curl_hash_clean(&hostname_cache);
+    host_cache_initialized = 0;
+  }
+}
+
+struct curl_dns_cache_entry {
+  Curl_addrinfo *addr;
+  time_t timestamp;
+};
+
+/* count the number of characters that an integer takes up */
+static int _num_chars(int i)
+{
+  int chars = 0;
+
+  /* While the number divided by 10 is greater than one, 
+   * re-divide the number by 10, and increment the number of 
+   * characters by 1.
+   *
+   * this relies on the fact that for every multiple of 10, 
+   * a new digit is added onto every number
+   */
+  do {
+    chars++;
+
+    i = (int) i / 10;
+  } while (i >= 1);
+
+  return chars;
+}
+
+/* Create a hostcache id */
+static char *
+_create_hostcache_id(char *server, int port, ssize_t *entry_len)
+{
+  char *id = NULL;
+
+  /* Get the length of the new entry id */
+  *entry_len = *entry_len +      /* Hostname length */
+               1 +               /* The ':' seperator */
+               _num_chars(port); /* The number of characters the port will take up */
+  
+  /* Allocate the new entry id */
+  id = malloc(*entry_len + 1);
+  if (!id) {
+    return NULL;
+  }
+
+  /* Create the new entry */
+  /* If sprintf() doesn't return the entry length, that signals failure */
+  if (sprintf(id, "%s:%d", server, port) != *entry_len) {
+    /* Free the allocated id, set length to zero and return NULL */
+    *entry_len = 0;
+    free(id);
+    return NULL;
+  }
+
+  return id;
+}
+
+struct hostcache_prune_data {
+  int cache_timeout;
+  int now;
+};
+
+static int
+_curl_hostcache_timestamp_remove(void *datap, void *hc)
+{
+  struct hostcache_prune_data *data = 
+    (struct hostcache_prune_data *) datap;
+  struct curl_dns_cache_entry *c = (struct curl_dns_cache_entry *) hc;
+  
+  if (data->now - c->timestamp < data->cache_timeout) {
+    return 0;
+  }
+  
+  return 1;
+}
+
+static void
+hostcache_prune(curl_hash *hostcache, int cache_timeout, int now)
+{
+  struct hostcache_prune_data user;
+
+  user.cache_timeout = cache_timeout;
+  user.now = now;
+  
+  Curl_hash_clean_with_criterium(hostcache, 
+                                 (void *) &user, 
+                                 _curl_hostcache_timestamp_remove);
+}
+
+/* Macro to save redundant free'ing of entry_id */
+#define _hostcache_return(__v) \
+{ \
+  free(entry_id); \
+  return (__v); \
+}
+
+#ifdef HAVE_SIGSETJMP
+/* Beware this is a global and unique instance */
+sigjmp_buf curl_jmpenv;
 #endif
-#else
-  unsigned char *paddr;
 
-  num = htonl(num);  /* htonl() added to avoid endian probs */
-  paddr = (unsigned char *)&num;
-  sprintf(addr, "%u.%u.%u.%u", paddr[0], paddr[1], paddr[2], paddr[3]);
+Curl_addrinfo *Curl_resolv(struct SessionHandle *data,
+                           char *hostname,
+                           int port)
+{
+  char *entry_id = NULL;
+  struct curl_dns_cache_entry *p = NULL;
+  ssize_t entry_len;
+  time_t now;
+  char *bufp;
+
+#ifdef HAVE_SIGSETJMP
+  if(sigsetjmp(curl_jmpenv, 1) != 0) {
+    /* this is coming from a siglongjmp() */
+    failf(data, "name lookup time-outed");
+    return NULL;
+  }
 #endif
-  return (addr);
+
+  /* If the host cache timeout is 0, we don't do DNS cach'ing
+     so fall through */
+  if (data->set.dns_cache_timeout == 0) {
+    return Curl_getaddrinfo(data, hostname, port, &bufp);
+  }
+
+  time(&now);
+
+  /* Remove outdated entries from the hostcache */
+  hostcache_prune(data->hostcache, 
+                  data->set.dns_cache_timeout, 
+                  now);
+
+  /* Create an entry id, based upon the hostname and port */
+  entry_len = strlen(hostname);
+  entry_id = _create_hostcache_id(hostname, port, &entry_len);
+  /* If we can't create the entry id, don't cache, just fall-through
+     to the plain Curl_getaddrinfo() */
+  if (!entry_id) {
+    return Curl_getaddrinfo(data, hostname, port, &bufp);
+  }
+  
+  /* See if its already in our dns cache */
+  if (entry_id &&
+      Curl_hash_find(data->hostcache, entry_id, entry_len+1, (void **) &p)) {
+    _hostcache_return(p->addr);
+  }
+
+  /* Create a new cache entry */
+  p = (struct curl_dns_cache_entry *)
+    malloc(sizeof(struct curl_dns_cache_entry));
+  if (!p) {
+   _hostcache_return(NULL);
+  }
+
+  p->addr = Curl_getaddrinfo(data, hostname, port, &bufp);
+  if (!p->addr) {
+    free(p);
+    _hostcache_return(NULL);
+  }
+  p->timestamp = now;
+
+  /* Save it in our host cache */
+  Curl_hash_update(data->hostcache, entry_id, entry_len+1, (const void *) p);
+
+  _hostcache_return(p->addr);
 }
 
+/*
+ * This is a wrapper function for freeing name information in a protocol
+ * independent way. This takes care of using the appropriate underlaying
+ * proper function.
+ */
+void Curl_freeaddrinfo(void *freethis)
+{
+  struct curl_dns_cache_entry *p = (struct curl_dns_cache_entry *) freethis;
+
+#ifdef ENABLE_IPV6
+  freeaddrinfo(p->addr);
+#else
+  free(p->addr);
+#endif
+
+  free(p);
+}
+
+/* --- resolve name or IP-number --- */
+
 #ifdef ENABLE_IPV6
-struct addrinfo *Curl_getaddrinfo(struct SessionHandle *data,
-			       char *hostname,
-			       int port)
+
+#ifdef MALLOCDEBUG
+/* These two are strictly for memory tracing and are using the same
+ * style as the family otherwise present in memdebug.c. I put these ones
+ * here since they require a bunch of struct types I didn't wanna include
+ * in memdebug.c
+ */
+int curl_getaddrinfo(char *hostname, char *service,
+                     struct addrinfo *hints,
+                     struct addrinfo **result,
+                     int line, const char *source)
+{
+  int res=(getaddrinfo)(hostname, service, hints, result);
+  if(0 == res) {
+    /* success */
+    if(logfile)
+      fprintf(logfile, "ADDR %s:%d getaddrinfo() = %p\n",
+              source, line, (void *)*result);
+  }
+  else {
+    if(logfile)
+      fprintf(logfile, "ADDR %s:%d getaddrinfo() failed\n",
+              source, line);
+  }
+  return res;
+}
+
+void curl_freeaddrinfo(struct addrinfo *freethis,
+                       int line, const char *source)
+{
+  (freeaddrinfo)(freethis);
+  if(logfile)
+    fprintf(logfile, "ADDR %s:%d freeaddrinfo(%p)\n",
+            source, line, (void *)freethis);
+}
+
+#endif
+
+/*
+ * Return name information about the given hostname and port number. If
+ * successful, the 'addrinfo' is returned and the forth argument will point to
+ * memory we need to free after use. That meory *MUST* be freed with
+ * Curl_freeaddrinfo(), nothing else.
+ */
+Curl_addrinfo *Curl_getaddrinfo(struct SessionHandle *data,
+                                char *hostname,
+                                int port,
+                                char **bufp)
 {
   struct addrinfo hints, *res;
   int error;
   char sbuf[NI_MAXSERV];
+  int s, pf = PF_UNSPEC;
 
+  /* see if we have an IPv6 stack */
+  s = socket(PF_INET6, SOCK_DGRAM, 0);
+  if (s < 0)
+    /* Some non-IPv6 stacks have been found to make very slow name resolves
+     * when PF_UNSPEC is used, so thus we switch to a mere PF_INET lookup if
+     * the stack seems to be a non-ipv6 one. */
+    pf = PF_INET;
+  else
+    /* This seems to be an IPv6-capable stack, use PF_UNSPEC for the widest
+     * possible checks. And close the socket again.
+     */
+    sclose(s);
+ 
   memset(&hints, 0, sizeof(hints));
-  hints.ai_family = PF_UNSPEC;
+  hints.ai_family = pf;
   hints.ai_socktype = SOCK_STREAM;
   hints.ai_flags = AI_CANONNAME;
   snprintf(sbuf, sizeof(sbuf), "%d", port);
   error = getaddrinfo(hostname, sbuf, &hints, &res);
   if (error) {
-    infof(data, "getaddrinfo(3) failed for %s\n", hostname);
+    infof(data, "getaddrinfo(3) failed for %s:%d\n", hostname, port);    
     return NULL;
   }
+  *bufp=(char *)res; /* make it point to the result struct */
+
   return res;
 }
+#else /* following code is IPv4-only */
+
+#ifndef HAVE_GETHOSTBYNAME_R
+static void hostcache_fixoffset(struct hostent *h, int offset);
+/**
+ * Performs a "deep" copy of a hostent into a buffer (returns a pointer to the
+ * copy). Make absolutely sure the destination buffer is big enough!
+ *
+ * Keith McGuigan 
+ * 10/3/2001 */
+static struct hostent* pack_hostent(char** buf, struct hostent* orig)
+{
+  char *bufptr;
+  char *newbuf;
+  struct hostent* copy;
+
+  int i;
+  char *str;
+  int len;
+
+  bufptr = *buf;
+  copy = (struct hostent*)bufptr;
+
+  bufptr += sizeof(struct hostent);
+  copy->h_name = bufptr;
+  len = strlen(orig->h_name) + 1;
+  strncpy(bufptr, orig->h_name, len);
+  bufptr += len;
+
+  /* we align on even 64bit boundaries for safety */
+#define MEMALIGN(x) ((x)+(8-(((unsigned long)(x))&0x7)))
+
+  /* This must be aligned properly to work on many CPU architectures! */
+  bufptr = MEMALIGN(bufptr);
+  
+  copy->h_aliases = (char**)bufptr;
+
+  /* Figure out how many aliases there are */
+  for (i = 0; orig->h_aliases[i] != NULL; ++i);
+
+  /* Reserve room for the array */
+  bufptr += (i + 1) * sizeof(char*);
+
+  /* Clone all known aliases */
+  for(i = 0; (str = orig->h_aliases[i]); i++) {
+    len = strlen(str) + 1;
+    strncpy(bufptr, str, len);
+    copy->h_aliases[i] = bufptr;
+    bufptr += len;
+  }
+  /* Terminate the alias list with a NULL */
+  copy->h_aliases[i] = NULL;
+
+  copy->h_addrtype = orig->h_addrtype;
+  copy->h_length = orig->h_length;
+    
+  /* align it for (at least) 32bit accesses */
+  bufptr = MEMALIGN(bufptr);
+
+  copy->h_addr_list = (char**)bufptr;
+
+  /* Figure out how many addresses there are */
+  for (i = 0; orig->h_addr_list[i] != NULL; ++i);
+
+  /* Reserve room for the array */
+  bufptr += (i + 1) * sizeof(char*);
+
+  i = 0;
+  len = orig->h_length;
+  str = orig->h_addr_list[i];
+  while (str != NULL) {
+    memcpy(bufptr, str, len);
+    copy->h_addr_list[i] = bufptr;
+    bufptr += len;
+    str = orig->h_addr_list[++i];
+  }
+  copy->h_addr_list[i] = NULL;
+
+  /* now, shrink the allocated buffer to the size we actually need, which
+     most often is only a fraction of the original alloc */
+  newbuf=(char *)realloc(*buf, (int)bufptr-(int)(*buf));
+
+  /* if the alloc moved, we need to adjust things again */
+  if(newbuf != *buf)
+    hostcache_fixoffset((struct hostent*)newbuf, (int)newbuf-(int)*buf);
+
+  /* setup the return */
+  *buf = newbuf;
+  copy = (struct hostent*)newbuf;
+
+  return copy;
+}
 #endif
 
-/* The original code to this function was once stolen from the Dancer source
-   code, written by Bjorn Reese, it has since been patched and modified
-   considerably. */
+static char *MakeIP(unsigned long num,char *addr, int addr_len)
+{
+#if defined(HAVE_INET_NTOA) || defined(HAVE_INET_NTOA_R)
+  struct in_addr in;
+  in.s_addr = htonl(num);
+
+#if defined(HAVE_INET_NTOA_R)
+  inet_ntoa_r(in,addr,addr_len);
+#else
+  strncpy(addr,inet_ntoa(in),addr_len);
+#endif
+#else
+  unsigned char *paddr;
+
+  num = htonl(num);  /* htonl() added to avoid endian probs */
+  paddr = (unsigned char *)&num;
+  sprintf(addr, "%u.%u.%u.%u", paddr[0], paddr[1], paddr[2], paddr[3]);
+#endif
+  return (addr);
+}
 
 #ifndef INADDR_NONE
-#define INADDR_NONE (unsigned long) ~0
+#define INADDR_NONE (in_addr_t) ~0
 #endif
 
-struct hostent *Curl_gethost(struct SessionHandle *data,
-                             char *hostname,
-                             char **bufp)
+static void hostcache_fixoffset(struct hostent *h, int offset)
+{
+  int i=0;
+  h->h_name=(char *)((long)h->h_name+offset);
+  h->h_aliases=(char **)((long)h->h_aliases+offset);
+  while(h->h_aliases[i]) {
+    h->h_aliases[i]=(char *)((long)h->h_aliases[i]+offset);
+    i++;
+  }
+  h->h_addr_list=(char **)((long)h->h_addr_list+offset);
+  i=0;
+  while(h->h_addr_list[i]) {
+    h->h_addr_list[i]=(char *)((long)h->h_addr_list[i]+offset);
+    i++;
+  }
+}
+
+/* The original code to this function was once stolen from the Dancer source
+   code, written by Bjorn Reese, it has since been patched and modified
+   considerably. */
+Curl_addrinfo *Curl_getaddrinfo(struct SessionHandle *data,
+                                char *hostname,
+                                int port,
+                                char **bufp)
 {
   struct hostent *h = NULL;
-  unsigned long in;
+  in_addr_t in;
   int ret; /* this variable is unused on several platforms but used on some */
 
 #define CURL_NAMELOOKUP_SIZE 9000
   /* Allocate enough memory to hold the full name information structs and
    * everything. OSF1 is known to require at least 8872 bytes. The buffer
    * required for storing all possible aliases and IP numbers is according to
    * Stevens' Unix Network Programming 2nd editor, p. 304: 8192 bytes! */
-  char *buf = (char *)malloc(CURL_NAMELOOKUP_SIZE);
-  if(!buf)
-    return NULL; /* major failure */
-  *bufp = buf;
-
+  port=0; /* unused in IPv4 code */
   ret = 0; /* to prevent the compiler warning */
 
   if ( (in=inet_addr(hostname)) != INADDR_NONE ) {
     struct in_addr *addrentry;
+    long *buf = (long *)malloc(sizeof(struct hostent)+128);
+    if(!buf)
+      return NULL; /* major failure */
+    *bufp = (char *)buf;
 
     h = (struct hostent*)buf;
     h->h_addr_list = (char**)(buf + sizeof(*h));
     addrentry = (struct in_addr*)(h->h_addr_list + 2);
     addrentry->s_addr = in;
     h->h_addr_list[0] = (char*)addrentry;
     h->h_addr_list[1] = NULL;
     h->h_addrtype = AF_INET;
     h->h_length = sizeof(*addrentry);
     h->h_name = *(h->h_addr_list) + h->h_length;
     /* bad one h->h_name = (char*)(h->h_addr_list + h->h_length); */
-    MakeIP(ntohl(in),h->h_name, CURL_NAMELOOKUP_SIZE - (long)(h->h_name) + (long)buf);
+    MakeIP(ntohl(in),h->h_name, sizeof(struct hostent)+128 -
+           (long)(h->h_name) + (long)buf);
   }
 #if defined(HAVE_GETHOSTBYNAME_R)
   else {
     int h_errnop;
+    int res=ERANGE;
+    int step_size=200;
+    int *buf = (int *)malloc(CURL_NAMELOOKUP_SIZE);
+    if(!buf)
+      return NULL; /* major failure */
+    *bufp=(char *)buf;
+
      /* Workaround for gethostbyname_r bug in qnx nto. It is also _required_
         for some of these functions. */
     memset(buf, 0, CURL_NAMELOOKUP_SIZE);
 #ifdef HAVE_GETHOSTBYNAME_R_5
     /* Solaris, IRIX and more */
-    if ((h = gethostbyname_r(hostname,
-                             (struct hostent *)buf,
-                             buf + sizeof(struct hostent),
-                             CURL_NAMELOOKUP_SIZE - sizeof(struct hostent),
-                             &h_errnop)) == NULL )
+    while(!h) {
+      h = gethostbyname_r(hostname,
+                          (struct hostent *)buf,
+                          (char *)buf + sizeof(struct hostent),
+                          step_size - sizeof(struct hostent),
+                          &h_errnop);
+
+      /* If the buffer is too small, it returns NULL and sets errno to
+         ERANGE. The errno is thread safe if this is compiled with
+         -D_REENTRANT as then the 'errno' variable is a macro defined to
+         get used properly for threads. */
+
+      if(h || (errno != ERANGE))
+        break;
+      
+      step_size+=200;
+    }
+
+#ifdef MALLOCDEBUG
+    infof(data, "gethostbyname_r() uses %d bytes\n", step_size);
+#endif
+
+    if(h) {
+      int offset;
+      h=(struct hostent *)realloc(buf, step_size);
+      offset=(long)h-(long)buf;
+      hostcache_fixoffset(h, offset);
+      buf=(int *)h;
+      *bufp=(char *)buf;
+    }
+    else
 #endif
 #ifdef HAVE_GETHOSTBYNAME_R_6
     /* Linux */
-    if( gethostbyname_r(hostname,
-                        (struct hostent *)buf,
-                        buf + sizeof(struct hostent),
-                        CURL_NAMELOOKUP_SIZE - sizeof(struct hostent),
-                        &h, /* DIFFERENCE */
-                        &h_errnop))
+    while((res=gethostbyname_r(hostname,
+                               (struct hostent *)buf,
+                               (char *)buf + sizeof(struct hostent),
+                               step_size - sizeof(struct hostent),
+                               &h, /* DIFFERENCE */
+                               &h_errnop))==ERANGE) {
+      step_size+=200;
+    }
+    
+#ifdef MALLOCDEBUG
+    infof(data, "gethostbyname_r() uses %d bytes\n", step_size);
+#endif
+    if(!res) {
+      int offset;
+      h=(struct hostent *)realloc(buf, step_size);
+      offset=(long)h-(long)buf;
+      hostcache_fixoffset(h, offset);
+      buf=(int *)h;
+      *bufp=(char *)buf;
+    }
+    else
 #endif
 #ifdef HAVE_GETHOSTBYNAME_R_3
     /* AIX, Digital Unix, HPUX 10, more? */
 
     if(CURL_NAMELOOKUP_SIZE >=
        (sizeof(struct hostent)+sizeof(struct hostent_data)))
 
       /* August 22nd, 2000: Albert Chin-A-Young brought an updated version
        * that should work! September 20: Richard Prescott worked on the buffer
        * size dilemma. */
 
       ret = gethostbyname_r(hostname,
-                          (struct hostent *)buf,
-                          (struct hostent_data *)(buf + sizeof(struct hostent)));
+                            (struct hostent *)buf,
+                            (struct hostent_data *)(buf + sizeof(struct hostent)));
     else
       ret = -1; /* failure, too smallish buffer size */
     
     /* result expected in h */
     h = (struct hostent*)buf;
     h_errnop= errno; /* we don't deal with this, but set it anyway */
@@ -205,21 +643,32 @@
       *bufp=NULL;
     }
 #else
   else {
     if ((h = gethostbyname(hostname)) == NULL ) {
       infof(data, "gethostbyname(2) failed for %s\n", hostname);
-      free(buf);
       *bufp=NULL;
     }
+    else 
+    {
+      char *buf=(char *)malloc(CURL_NAMELOOKUP_SIZE);
+      /* we make a copy of the hostent right now, right here, as the
+         static one we got a pointer to might get removed when we don't
+         want/expect that */
+      h = pack_hostent(&buf, h);
+      *bufp=(char *)buf;
+    }
 #endif
   }
   return (h);
 }
 
+#endif /* end of IPv4-specific code */
+
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+ 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/hostip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/hostip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/hostip.h	2001-08-31 06:54:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/hostip.h	2002-04-26 03:21:54.000000000 +0800
@@ -4,32 +4,56 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip.h,v 1.9 2001/08/30 22:48:34 bagder Exp $
+ * $Id: hostip.h,v 1.16 2002/04/25 19:00:59 bagder Exp $
  *****************************************************************************/
 
+#include "hash.h"
+
 struct addrinfo;
-struct addrinfo *Curl_getaddrinfo(struct SessionHandle *data,
-                             char *hostname,
-                             int port);
-
-struct hostent *Curl_gethost(struct SessionHandle *data,
-                             char *hostname,
-                             char **bufp);
+struct hostent;
+struct SessionHandle;
+
+void Curl_global_host_cache_init(void);
+void Curl_global_host_cache_dtor(void);
+curl_hash *Curl_global_host_cache_get(void);
+
+#define Curl_global_host_cache_use(__p) ((__p)->set.global_dns_cache)
+
+Curl_addrinfo *Curl_resolv(struct SessionHandle *data,
+			   char *hostname,
+			   int port);
+
+/* Get name info */
+Curl_addrinfo *Curl_getaddrinfo(struct SessionHandle *data,
+                                char *hostname,
+                                int port,
+                                char **bufp);
+/* free name info */
+void Curl_freeaddrinfo(void *freethis);
+
+#ifdef MALLOCDEBUG
+void curl_freeaddrinfo(struct addrinfo *freethis,
+                       int line, const char *source);
+int curl_getaddrinfo(char *hostname, char *service,
+                     struct addrinfo *hints,
+                     struct addrinfo **result,
+                     int line, const char *source);
+#endif
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http.c	2001-09-18 23:29:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http.c	2002-06-11 19:13:01.000000000 +0800
@@ -2,30 +2,31 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.c,v 1.72 2001/09/18 15:29:57 bagder Exp $
+ * $Id: http.c,v 1.100 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_HTTP
 /* -- WIN32 approved -- */
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -122,28 +123,51 @@
 }
 
 /*
  * add_buffer_send() sends a buffer and frees all associated memory.
  */
 static
-size_t add_buffer_send(int sockfd, struct connectdata *conn, send_buffer *in)
+CURLcode add_buffer_send(int sockfd, struct connectdata *conn, send_buffer *in,
+                         long *bytes_written)
 {
-  size_t amount;
-  if(conn->data->set.verbose) {
-    fputs("> ", conn->data->set.err);
-    /* this data _may_ contain binary stuff */
-    fwrite(in->buffer, in->size_used, 1, conn->data->set.err);
-  }
+  ssize_t amount;
+  CURLcode res;
+  char *ptr;
+  int size;
+
+  /* The looping below is required since we use non-blocking sockets, but due
+     to the circumstances we will just loop and try again and again etc */
+
+  ptr = in->buffer;
+  size = in->size_used;
+  do {
+    res = Curl_write(conn, sockfd, ptr, size, &amount);
 
-  Curl_write(conn, sockfd, in->buffer, in->size_used, &amount);
+    if(CURLE_OK != res)
+      break;
+
+    if(conn->data->set.verbose)
+      /* this data _may_ contain binary stuff */
+      Curl_debug(conn->data, CURLINFO_HEADER_OUT, ptr, amount);
+
+    if(amount != size) {
+      size -= amount;
+      ptr += amount;
+    }
+    else
+      break;
+
+  } while(1);
 
   if(in->buffer)
     free(in->buffer);
   free(in);
 
-  return amount;
+  *bytes_written += amount;
+
+  return res;
 }
 
 
 /* 
  * add_bufferf() builds a buffer from the formatted input
  */
@@ -197,34 +221,12 @@
 }
 
 /* end of the add_buffer functions */
 /* ------------------------------------------------------------------------- */
 
 /*
- * Read everything until a newline.
- */
-
-static
-int GetLine(int sockfd, char *ptr, struct connectdata *conn)
-{
-  ssize_t nread;
-
-  /* get us a full line, terminated with a newline */
-  for(nread=0; (nread<BUFSIZE); nread++, ptr++) {
-    if((CURLE_OK != Curl_read(conn, sockfd, ptr, 1, &nread)) ||
-       (nread <= 0) || (*ptr == '\n'))
-      break;
-  }
-  *ptr=0; /* zero terminate */
-  
-  return nread>0?nread:0;
-}
-
-
-
-/*
  * This function checks the linked list of custom HTTP headers for a particular
  * header (prefix).
  */
 static bool checkheaders(struct SessionHandle *data, const char *thisheader)
 {
   struct curl_slist *head;
@@ -248,46 +250,156 @@
                                      int tunnelsocket,
                                      char *hostname, int remote_port)
 {
   int httperror=0;
   int subversion=0;
   struct SessionHandle *data=conn->data;
+  CURLcode result;
+  int res;
+
+  int nread;   /* total size read */
+  int perline; /* count bytes per line */
+  bool keepon=TRUE;
+  ssize_t gotbytes;
+  char *ptr;
+  int timeout = 3600; /* default timeout in seconds */
+  struct timeval interval;
+  fd_set rkeepfd;
+  fd_set readfd;
+  char *line_start;
+
+#define SELECT_OK      0
+#define SELECT_ERROR   1
+#define SELECT_TIMEOUT 2
+  int error = SELECT_OK;
 
   infof(data, "Establish HTTP proxy tunnel to %s:%d\n", hostname, remote_port);
 
   /* OK, now send the connect request to the proxy */
-  Curl_sendf(tunnelsocket, conn,
-             "CONNECT %s:%d HTTP/1.0\015\012"
-             "%s"
-             "%s"
-             "\r\n",
-             hostname, remote_port,
-             (conn->bits.proxy_user_passwd)?conn->allocptr.proxyuserpwd:"",
-             (data->set.useragent?conn->allocptr.uagent:"")
-             );
-
-  /* wait for the proxy to send us a HTTP/1.0 200 OK header */
-  while(GetLine(tunnelsocket, data->state.buffer, conn)) {
-    if('\r' == data->state.buffer[0])
-      break; /* end of headers */
-    if(data->set.verbose)
-      fprintf(data->set.err, "< %s\n", data->state.buffer);
-
-    if(2 == sscanf(data->state.buffer, "HTTP/1.%d %d",
-                   &subversion,
-                   &httperror)) {
-      ;
+  result =
+    Curl_sendf(tunnelsocket, conn,
+               "CONNECT %s:%d HTTP/1.0\015\012"
+               "%s"
+               "%s"
+               "\r\n",
+               hostname, remote_port,
+               (conn->bits.proxy_user_passwd)?conn->allocptr.proxyuserpwd:"",
+               (data->set.useragent?conn->allocptr.uagent:"")
+               );
+  if(result) {
+    failf(data, "Failed sending CONNECT to proxy");
+    return result;
+  }
+
+  /* Now, read the full reply we get from the proxy */
+
+
+  if(data->set.timeout) {
+    /* if timeout is requested, find out how much remaining time we have */
+    timeout = data->set.timeout - /* timeout time */
+      Curl_tvdiff(Curl_tvnow(), conn->now)/1000; /* spent time */
+    if(timeout <=0 ) {
+      failf(data, "Transfer aborted due to timeout");
+      return -SELECT_TIMEOUT; /* already too little time */
     }
   }
+
+  FD_ZERO (&readfd);		/* clear it */
+  FD_SET (tunnelsocket, &readfd);     /* read socket */
+
+  /* get this in a backup variable to be able to restore it on each lap in the
+     select() loop */
+  rkeepfd = readfd;
+
+  ptr=data->state.buffer;
+  line_start = ptr;
+
+  nread=0;
+  perline=0;
+  keepon=TRUE;
+
+  while((nread<BUFSIZE) && (keepon && !error)) {
+    readfd = rkeepfd;		   /* set every lap */
+    interval.tv_sec = timeout;
+    interval.tv_usec = 0;
+
+    switch (select (tunnelsocket+1, &readfd, NULL, NULL, &interval)) {
+    case -1: /* select() error, stop reading */
+      error = SELECT_ERROR;
+      failf(data, "Transfer aborted due to select() error");
+      break;
+    case 0: /* timeout */
+      error = SELECT_TIMEOUT;
+      failf(data, "Transfer aborted due to timeout");
+      break;
+    default:
+      /*
+       * This code previously didn't use the kerberos sec_read() code
+       * to read, but when we use Curl_read() it may do so. Do confirm
+       * that this is still ok and then remove this comment!
+       */
+      res= Curl_read(conn, tunnelsocket, ptr, BUFSIZE-nread,
+                     &gotbytes);
+      if(res< 0)
+        /* EWOULDBLOCK */
+        continue; /* go loop yourself */
+      else if(res)
+        keepon = FALSE;
+      else if(gotbytes <= 0) {
+        keepon = FALSE;
+        error = SELECT_ERROR;
+        failf(data, "Connection aborted");
+      }
+      else {
+        /* we got a whole chunk of data, which can be anything from one
+         * byte to a set of lines and possibly just a piece of the last
+         * line */
+        int i;
+
+        nread += gotbytes;
+        for(i = 0; i < gotbytes; ptr++, i++) {
+          perline++; /* amount of bytes in this line so far */
+          if(*ptr=='\n') {
+            /* a newline is CRLF in ftp-talk, so the CR is ignored as
+               the line isn't really terminated until the LF comes */
+
+            /* output debug output if that is requested */
+            if(data->set.verbose)
+              Curl_debug(data, CURLINFO_DATA_IN, line_start, perline);
+            
+            if('\r' == line_start[0]) {
+              /* end of headers */
+              keepon=FALSE;
+              break; /* breaks out of loop, not switch */
+            }
+
+            if(2 == sscanf(line_start, "HTTP/1.%d %d",
+                           &subversion,
+                           &httperror)) {
+              ;
+            }
+
+            perline=0; /* line starts over here */
+            line_start = ptr+1;
+          }
+        }
+      }
+      break;
+    } /* switch */
+  } /* while there's buffer left and loop is requested */
+
+  if(error)
+    return CURLE_RECV_ERROR;
+
   if(200 != httperror) {
     if(407 == httperror)
       /* Added Nov 6 1998 */
       failf(data, "Proxy requires authorization!");
     else 
       failf(data, "Received error code %d from proxy", httperror);
-    return CURLE_READ_ERROR;
+    return CURLE_RECV_ERROR;
   }
 
   infof (data, "Proxy replied to CONNECT request\n");
   return CURLE_OK;
 }
 
@@ -304,21 +416,24 @@
   /* If we are not using a proxy and we want a secure connection,
    * perform SSL initialization & connection now.
    * If using a proxy with https, then we must tell the proxy to CONNECT
    * us to the host we want to talk to.  Only after the connect
    * has occured, can we start talking SSL
    */
-  if (conn->protocol & PROT_HTTPS) {
-    if (data->change.proxy) {
-      /* HTTPS through a proxy can only be done with a tunnel */
-      result = Curl_ConnectHTTPProxyTunnel(conn, conn->firstsocket,
-                                           conn->hostname, conn->remote_port);
-      if(CURLE_OK != result)
-        return result;
-    }
 
+  if(data->change.proxy &&
+     ((conn->protocol & PROT_HTTPS) || data->set.tunnel_thru_httpproxy)) {
+
+    /* either HTTPS over proxy, OR explicitly asked for a tunnel */
+    result = Curl_ConnectHTTPProxyTunnel(conn, conn->firstsocket,
+                                         conn->hostname, conn->remote_port);
+    if(CURLE_OK != result)
+      return result;
+  }    
+
+  if(conn->protocol & PROT_HTTPS) {
     /* now, perform the SSL initialization for this socket */
     result = Curl_SSLConnect(conn);
     if(result)
       return result;
   }
 
@@ -349,12 +464,19 @@
     data->set.in = http->in; /* restore */
   }
   else if(HTTPREQ_PUT == data->set.httpreq) {
     *bytecount = http->readbytecount + http->writebytecount;
   }
 
+  if(0 == (http->readbytecount + conn->headerbytecount)) {
+    /* nothing was read from the HTTP server, this can't be right
+       so we return an error here */
+    failf(data, "Empty reply from server");
+    return CURLE_GOT_NOTHING;
+  }
+
   return CURLE_OK;
 }
 
 
 CURLcode Curl_http(struct connectdata *conn)
 {
@@ -429,20 +551,28 @@
 
   if(data->cookies) {
     co = Curl_cookie_getlist(data->cookies,
                              host, ppath,
                              conn->protocol&PROT_HTTPS?TRUE:FALSE);
   }
-  if ((data->change.proxy) && !(conn->protocol&PROT_HTTPS))  {
+  if (data->change.proxy &&
+      !data->set.tunnel_thru_httpproxy &&
+      !(conn->protocol&PROT_HTTPS))  {
     /* The path sent to the proxy is in fact the entire URL */
     ppath = data->change.url;
   }
   if(HTTPREQ_POST_FORM == data->set.httpreq) {
     /* we must build the whole darned post sequence first, so that we have
        a size of the whole shebang before we start to send it */
-    http->sendit = Curl_getFormData(data->set.httppost, &http->postsize);
+     result = Curl_getFormData(&http->sendit, data->set.httppost,
+                               &http->postsize);
+     if(CURLE_OK != result) {
+       /* Curl_getFormData() doesn't use failf() */
+       failf(data, "failed creating formpost data");
+       return result;
+     }
   }
 
   if(!checkheaders(data, "Host:")) {
     /* if ptr_host is already set, it is almost OK since we only re-use
        connections to the very same host and port, but when we use a HTTP
        proxy we have a persistant connect and yet we must change the Host:
@@ -504,24 +634,24 @@
         actuallyread =
           data->set.fread(data->state.buffer, 1, readthisamountnow,
                           data->set.in);
 
         passed += actuallyread;
         if(actuallyread != readthisamountnow) {
-          failf(data, "Could only read %d bytes from the input\n",
+          failf(data, "Could only read %d bytes from the input",
                 passed);
           return CURLE_READ_ERROR;
         }
       } while(passed != conn->resume_from); /* loop until done */
 
       /* now, decrease the size of the read */
       if(data->set.infilesize>0) {
         data->set.infilesize -= conn->resume_from;
 
         if(data->set.infilesize <= 0) {
-          failf(data, "File already completely uploaded\n");
+          failf(data, "File already completely uploaded");
           return CURLE_PARTIAL_FILE;
         }
       }
       /* we've passed, proceed as normal */
     }
   }
@@ -552,22 +682,26 @@
                                       conn->range, data->set.infilesize);
       }
     }
   }
 
   do {
+    /* Use 1.1 unless the use specificly asked for 1.0 */
+    const char *httpstring=
+      data->set.httpversion==CURL_HTTP_VERSION_1_0?"1.0":"1.1";
+
     send_buffer *req_buffer;
     struct curl_slist *headers=data->set.headers;
 
     /* initialize a dynamic send-buffer */
     req_buffer = add_buffer_init();
 
     /* add the main request stuff */
     add_bufferf(req_buffer,
                 "%s " /* GET/HEAD/POST/PUT */
-                "%s HTTP/1.1\r\n" /* path */
+                "%s HTTP/%s\r\n" /* path */
                 "%s" /* proxyuserpwd */
                 "%s" /* userpwd */
                 "%s" /* range */
                 "%s" /* user agent */
                 "%s" /* cookie */
                 "%s" /* host */
@@ -577,13 +711,13 @@
 
                 data->set.customrequest?data->set.customrequest:
                 (data->set.no_body?"HEAD":
                  ((HTTPREQ_POST == data->set.httpreq) ||
                   (HTTPREQ_POST_FORM == data->set.httpreq))?"POST":
                  (HTTPREQ_PUT == data->set.httpreq)?"PUT":"GET"),
-                ppath,
+                ppath, httpstring,
                 (conn->bits.proxy_user_passwd &&
                  conn->allocptr.proxyuserpwd)?conn->allocptr.proxyuserpwd:"",
                 (conn->bits.user_passwd && conn->allocptr.userpwd)?
                 conn->allocptr.userpwd:"",
                 (conn->bits.use_range && conn->allocptr.rangeline)?
                 conn->allocptr.rangeline:"",
@@ -625,44 +759,42 @@
        * header family should have their times set in GMT as RFC2616 defines:
        * "All HTTP date/time stamps MUST be represented in Greenwich Mean Time
        * (GMT), without exception. For the purposes of HTTP, GMT is exactly
        * equal to UTC (Coordinated Universal Time)." (see page 20 of RFC2616).
        */
 
-#ifdef HAVE_LOCALTIME_R
+#ifdef HAVE_GMTIME_R
       /* thread-safe version */
-      /* We assume that the presense of localtime_r() proves the presense
-         of gmtime_r() which is a bit ugly but might work */
       struct tm keeptime;
       thistime = (struct tm *)gmtime_r(&data->set.timevalue, &keeptime);
 #else
       thistime = gmtime(&data->set.timevalue);
 #endif
       if(NULL == thistime) {
         failf(data, "localtime() failed!");
         return CURLE_OUT_OF_MEMORY;
       }
 
 #ifdef HAVE_STRFTIME
       /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
-      strftime(buf, BUFSIZE-1, "%a, %d %b %Y %H:%M:%S %Z", thistime);
+      strftime(buf, BUFSIZE-1, "%a, %d %b %Y %H:%M:%S GMT", thistime);
 #else
       /* TODO: Right, we *could* write a replacement here */
       strcpy(buf, "no strftime() support");
 #endif
       switch(data->set.timecondition) {
-      case TIMECOND_IFMODSINCE:
+      case CURL_TIMECOND_IFMODSINCE:
       default:
         add_bufferf(req_buffer,
                     "If-Modified-Since: %s\r\n", buf);
         break;
-      case TIMECOND_IFUNMODSINCE:
+      case CURL_TIMECOND_IFUNMODSINCE:
         add_bufferf(req_buffer,
                     "If-Unmodified-Since: %s\r\n", buf);
         break;
-      case TIMECOND_LASTMOD:
+      case CURL_TIMECOND_LASTMOD:
         add_bufferf(req_buffer,
                     "Last-Modified: %s\r\n", buf);
         break;
       }
     }
 
@@ -681,72 +813,86 @@
           add_bufferf(req_buffer, "%s\r\n", headers->data);
         }
       }
       headers = headers->next;
     }
 
-    if(HTTPREQ_POST_FORM == data->set.httpreq) {
-      char contentType[256];
-      int linelength=0;
+    switch(data->set.httpreq) {
+
+    case HTTPREQ_POST_FORM:
       if(Curl_FormInit(&http->form, http->sendit)) {
-        failf(data, "Internal HTTP POST error!\n");
+        failf(data, "Internal HTTP POST error!");
         return CURLE_HTTP_POST_ERROR;
       }
 
       http->storefread = data->set.fread; /* backup */
       http->in = data->set.in; /* backup */
           
       data->set.fread = (curl_read_callback)
         Curl_FormReader; /* set the read function to read from the
                             generated form data */
       data->set.in = (FILE *)&http->form;
 
       add_bufferf(req_buffer,
-                  "Content-Length: %d\r\n", http->postsize-2);
+                  "Content-Length: %d\r\n", http->postsize);
 
       if(!checkheaders(data, "Expect:")) {
         /* if not disabled explicitly we add a Expect: 100-continue
            to the headers which actually speeds up post operations (as
            there is one packet coming back from the web server) */
         add_bufferf(req_buffer,
                     "Expect: 100-continue\r\n");
         data->set.expect100header = TRUE;
+      }
 
+      if(!checkheaders(data, "Content-Type:")) {
         /* Get Content-Type: line from Curl_FormReadOneLine, which happens
            to always be the first line. We can know this for sure since
-           we always build the formpost linked list the same way! */
+           we always build the formpost linked list the same way!
+
+           The Content-Type header line also contains the MIME boundary
+           string etc why disabling this header is likely to not make things
+           work, but we support it anyway.
+        */
+        char contentType[256];
+        int linelength=0;
         linelength = Curl_FormReadOneLine (contentType,
                                            sizeof(contentType),
                                            1,
                                            (FILE *)&http->form);
         if(linelength == -1) {
-          failf(data, "Could not get Content-Type header line!\n");
+          failf(data, "Could not get Content-Type header line!");
           return CURLE_HTTP_POST_ERROR;
         }
         add_buffer(req_buffer, contentType, linelength);
       }
 
+      /* make the request end in a true CRLF */
+      add_buffer(req_buffer, "\r\n", 2);
+
       /* set upload size to the progress meter */
       Curl_pgrsSetUploadSize(data, http->postsize);
 
       /* fire away the whole request to the server */
-      data->info.request_size = 
-        add_buffer_send(conn->firstsocket, conn, req_buffer);
-
-      /* setup variables for the upcoming transfer */
-      result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE,
-                             &http->readbytecount,
-                             conn->firstsocket,
-                             &http->writebytecount);
+      result = add_buffer_send(conn->firstsocket, conn, req_buffer,
+                               &data->info.request_size);
+      if(result)
+        failf(data, "Failed sending POST request");
+      else
+        /* setup variables for the upcoming transfer */
+        result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE,
+                               &http->readbytecount,
+                               conn->firstsocket,
+                               &http->writebytecount);
       if(result) {
         Curl_formclean(http->sendit); /* free that whole lot */
         return result;
       }
-    }
-    else if(HTTPREQ_PUT == data->set.httpreq) {
-      /* Let's PUT the data to the server! */
+      break;
+
+    case HTTPREQ_PUT: /* Let's PUT the data to the server! */
 
       if(data->set.infilesize>0) {
         add_bufferf(req_buffer,
                     "Content-Length: %d\r\n\r\n", /* file size */
                     data->set.infilesize );
       }
@@ -754,75 +900,80 @@
         add_bufferf(req_buffer, "\015\012");
 
       /* set the upload size to the progress meter */
       Curl_pgrsSetUploadSize(data, data->set.infilesize);
 
       /* this sends the buffer and frees all the buffer resources */
-      data->info.request_size = 
-        add_buffer_send(conn->firstsocket, conn, req_buffer);
-
-      /* prepare for transfer */
-      result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE,
-                        &http->readbytecount,
-                        conn->firstsocket,
-                        &http->writebytecount);
+      result = add_buffer_send(conn->firstsocket, conn, req_buffer,
+                               &data->info.request_size);
+      if(result)
+        failf(data, "Faied sending POST request");
+      else
+        /* prepare for transfer */
+        result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE,
+                               &http->readbytecount,
+                               conn->firstsocket,
+                               &http->writebytecount);
       if(result)
         return result;
-      
-    }
-    else {
-      if(HTTPREQ_POST == data->set.httpreq) {
-        /* this is the simple POST, using x-www-form-urlencoded style */
-
-        if(!data->set.postfields) {
-          /*
-           * This is an attempt to do a POST without having anything to
-           * actually send. Let's make a NULL pointer equal "" here. Good/bad
-           * ?
-           */
-          data->set.postfields = (char *)"";
-          data->set.postfieldsize = 0; /* it might been set to something illegal,
-                                      anything > 0 would be! */
-        }
+      break;
 
-        if(!checkheaders(data, "Content-Length:"))
-          /* we allow replacing this header, although it isn't very wise to
-             actually set your own */
-          add_bufferf(req_buffer,
-                      "Content-Length: %d\r\n",
-                      (data->set.postfieldsize?data->set.postfieldsize:
-                       strlen(data->set.postfields)) );
+    case HTTPREQ_POST:
+      /* this is the simple POST, using x-www-form-urlencoded style */
 
-        if(!checkheaders(data, "Content-Type:"))
-          add_bufferf(req_buffer,
-                      "Content-Type: application/x-www-form-urlencoded\r\n");
+      if(!checkheaders(data, "Content-Length:"))
+        /* we allow replacing this header, although it isn't very wise to
+           actually set your own */
+        add_bufferf(req_buffer,
+                    "Content-Length: %d\r\n",
+                    data->set.postfieldsize?
+                    data->set.postfieldsize:
+                    (data->set.postfields?strlen(data->set.postfields):0) );
 
-        /* and here comes the actual data */
-        if(data->set.postfieldsize) {
-          add_buffer(req_buffer, "\r\n", 2);
-          add_buffer(req_buffer, data->set.postfields,
-                     data->set.postfieldsize);
-          add_buffer(req_buffer, "\r\n", 2);
-        }
-        else {
-          add_bufferf(req_buffer,
-                      "\r\n"
-                      "%s\r\n",
-                      data->set.postfields );
-        }
+      if(!checkheaders(data, "Content-Type:"))
+        add_bufferf(req_buffer,
+                    "Content-Type: application/x-www-form-urlencoded\r\n");
+
+      add_buffer(req_buffer, "\r\n", 2);
+
+      /* and here comes the actual data */
+      if(data->set.postfieldsize && data->set.postfields) {
+        add_buffer(req_buffer, data->set.postfields,
+                   data->set.postfieldsize);
       }
+      else if(data->set.postfields)
+        add_bufferf(req_buffer,
+                    "%s",
+                    data->set.postfields );
+
+      /* issue the request */
+      result = add_buffer_send(conn->firstsocket, conn, req_buffer,
+                               &data->info.request_size);
+
+      if(result)
+        failf(data, "Failed sending HTTP POST request");
       else
-        add_buffer(req_buffer, "\r\n", 2);
+        result =
+          Curl_Transfer(conn, conn->firstsocket, -1, TRUE, bytecount,
+                        data->set.postfields?-1:conn->firstsocket,
+                        data->set.postfields?NULL:&http->writebytecount);
+      break;
 
+    default:
+      add_buffer(req_buffer, "\r\n", 2);
+      
       /* issue the request */
-      data->info.request_size = 
-        add_buffer_send(conn->firstsocket, conn, req_buffer);
+      result = add_buffer_send(conn->firstsocket, conn, req_buffer,
+                               &data->info.request_size);
 
-      /* HTTP GET/HEAD download: */
-      result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE, bytecount,
-                        -1, NULL); /* nothing to upload */
+      if(result)
+        failf(data, "Failed sending HTTP request");
+      else
+        /* HTTP GET/HEAD download: */
+        result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE, bytecount,
+                               -1, NULL); /* nothing to upload */
     }
     if(result)
       return result;
   } while (0); /* this is just a left-over from the multiple document download
                   attempts */
 
@@ -831,9 +982,10 @@
 
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http_chunks.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http_chunks.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http_chunks.c	2001-09-07 14:05:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http_chunks.c	2002-06-11 19:13:01.000000000 +0800
@@ -2,29 +2,30 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http_chunks.c,v 1.8 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: http_chunks.c,v 1.11 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
 #include "setup.h"
 
+#ifndef CURL_DISABLE_HTTP
 /* -- WIN32 approved -- */
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -222,9 +223,10 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+#endif /* CURL_DISABLE_HTTP */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http_chunks.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http_chunks.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http_chunks.h	2001-03-14 06:16:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http_chunks.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http_chunks.h,v 1.4 2001/03/13 22:16:42 bagder Exp $
+ * $Id: http_chunks.h,v 1.5 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 /*
  * The longest possible hexadecimal number we support in a chunked transfer.
  * Weird enough, RFC2616 doesn't set a maximum size! Since we use strtoul()
  * to convert it, we "only" support 2^32 bytes chunk data.
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/http.h	2001-09-18 23:30:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/http.h	2002-06-11 19:13:01.000000000 +0800
@@ -5,28 +5,28 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.h,v 1.12 2001/09/18 15:30:59 bagder Exp $
+ * $Id: http.h,v 1.14 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
-
+#ifndef CURL_DISABLE_HTTP
 /* ftp can use this as well */
 CURLcode Curl_ConnectHTTPProxyTunnel(struct connectdata *conn,
                                      int tunnelsocket,
                                      char *hostname, int remote_port);
 
 /* protocol-specific functions set up to be called by the main engine */
@@ -35,8 +35,8 @@
 CURLcode Curl_http_connect(struct connectdata *conn);
 
 /* The following functions are defined in http_chunks.c */
 void Curl_httpchunk_init(struct connectdata *conn);
 CHUNKcode Curl_httpchunk_read(struct connectdata *conn, char *datap,
                               ssize_t length, ssize_t *wrote);
-
+#endif
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/if2ip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/if2ip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/if2ip.c	2001-09-07 14:05:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/if2ip.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: if2ip.c,v 1.18 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: if2ip.c,v 1.20 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -126,9 +126,9 @@
 #endif
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/if2ip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/if2ip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/if2ip.h	2001-02-05 03:00:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/if2ip.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: if2ip.h,v 1.7 2001/02/04 19:00:27 bagder Exp $
+ * $Id: if2ip.h,v 1.8 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 #include "setup.h"
 
 #if ! defined(WIN32) && ! defined(__BEOS__) && !defined(__CYGWIN32__)
 extern char *Curl_if2ip(char *interface, char *buf, int buf_size);
 #else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/krb4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/krb4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/krb4.c	2001-09-07 14:05:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/krb4.c	2002-06-11 17:09:58.000000000 +0800
@@ -37,12 +37,13 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.  */
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_FTP
 #ifdef KRB4
 
 #include "security.h"
 #include "base64.h"
 #include <stdlib.h>
 #include <netdb.h>
@@ -54,12 +55,16 @@
 #include <unistd.h> /* for getpid() */
 #endif
 
 #include "ftp.h"
 #include "sendf.h"
 
+#if defined(HAVE_INET_NTOA_R) && !defined(HAVE_INET_NTOA_R_DECL)
+#include "inet_ntoa_r.h"
+#endif
+
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 #define LOCAL_ADDR (&conn->local_addr)
@@ -190,100 +195,96 @@
   int len;
   KTEXT_ST adat;
   MSG_DAT msg_data;
   int checksum;
   u_int32_t cs;
   struct krb4_data *d = app_data;
-  struct sockaddr_in *localaddr  = (struct sockaddr_in *)LOCAL_ADDR;
-  char *host = conn->hp->h_name;
+  char *host = conn->hostname;
   ssize_t nread;
   int l = sizeof(conn->local_addr);
+  struct SessionHandle *data = conn->data;
 
   if(getsockname(conn->firstsocket,
                  (struct sockaddr *)LOCAL_ADDR, &l) < 0)
     perror("getsockname()");
 
   checksum = getpid();
   ret = mk_auth(d, &adat, "ftp", host, checksum);
   if(ret == KDC_PR_UNKNOWN)
     ret = mk_auth(d, &adat, "rcmd", host, checksum);
   if(ret) {
-    printf("%s\n", krb_get_err_text(ret));
+    Curl_infof(data, "%s\n", krb_get_err_text(ret));
     return AUTH_CONTINUE;
   }
   
 #ifdef HAVE_KRB_GET_OUR_IP_FOR_REALM
   if (krb_get_config_bool("nat_in_use")) {
+    struct sockaddr_in *localaddr  = (struct sockaddr_in *)LOCAL_ADDR;
     struct in_addr natAddr;
 
     if (krb_get_our_ip_for_realm(krb_realmofhost(host),
                                  &natAddr) != KSUCCESS
         && krb_get_our_ip_for_realm(NULL, &natAddr) != KSUCCESS)
-      printf("Can't get address for realm %s\n",
-             krb_realmofhost(host));
+      Curl_infof(data, "Can't get address for realm %s\n",
+                 krb_realmofhost(host));
     else {
       if (natAddr.s_addr != localaddr->sin_addr.s_addr) {
-        printf("Using NAT IP address (%s) for kerberos 4\n",
-               (char *)inet_ntoa(natAddr));
+#ifdef HAVE_INET_NTOA_R
+        char ntoa_buf[64];
+        char *ip = (char *)inet_ntoa_r(natAddr, ntoa_buf, sizeof(ntoa_buf));
+#else
+        char *ip = (char *)inet_ntoa(natAddr);
+#endif
+        Curl_infof(data, "Using NAT IP address (%s) for kerberos 4\n", ip);
         localaddr->sin_addr = natAddr;
-        
-        /*
-         * This not the best place to do this, but it is here we know that
-         * (probably) NAT is in use!  */
-
-        /*passivemode = 1;***/
-        /*printf("Setting: Passive mode on.\n");***/
       }
     }
   }
 #endif
 
-  /*printf("Local address is %s\n", inet_ntoa(localaddr->sin_addr));***/
-  /*printf("Remote address is %s\n", inet_ntoa(remoteaddr->sin_addr));***/
-
   if(Curl_base64_encode(adat.dat, adat.length, &p) < 0) {
-    printf("Out of memory base64-encoding.\n");
+    Curl_failf(data, "Out of memory base64-encoding");
     return AUTH_CONTINUE;
   }
 
-  Curl_ftpsendf(conn->firstsocket, conn, "ADAT %s", p);
+  if(Curl_ftpsendf(conn, "ADAT %s", p))
+    return -2;
 
-  nread = Curl_GetFTPResponse(conn->firstsocket,
-                              conn->data->state.buffer, conn, NULL);
+  nread = Curl_GetFTPResponse(data->state.buffer, conn, NULL);
   if(nread < 0)
-    return /*CURLE_OPERATION_TIMEOUTED*/-1;
+    return -1;
   free(p);
 
-  if(/*ret != COMPLETE*/conn->data->state.buffer[0] != '2'){
-    printf("Server didn't accept auth data.\n");
+  if(data->state.buffer[0] != '2'){
+    Curl_failf(data, "Server didn't accept auth data");
     return AUTH_ERROR;
   }
 
-  p = strstr(conn->data->state.buffer, "ADAT=");
-  if(!p){
-    printf("Remote host didn't send adat reply.\n");
+  p = strstr(data->state.buffer, "ADAT=");
+  if(!p) {
+    Curl_failf(data, "Remote host didn't send adat reply");
     return AUTH_ERROR;
   }
   p += 5;
   len = Curl_base64_decode(p, adat.dat);
-  if(len < 0){
-    printf("Failed to decode base64 from server.\n");
+  if(len < 0) {
+    Curl_failf(data, "Failed to decode base64 from server");
     return AUTH_ERROR;
   }
   adat.length = len;
   ret = krb_rd_safe(adat.dat, adat.length, &d->key, 
                     (struct sockaddr_in *)hisctladdr, 
                     (struct sockaddr_in *)myctladdr, &msg_data);
-  if(ret){
-    printf("Error reading reply from server: %s.\n", 
-           krb_get_err_text(ret));
+  if(ret) {
+    Curl_failf(data, "Error reading reply from server: %s", 
+               krb_get_err_text(ret));
     return AUTH_ERROR;
   }
   krb_get_int(msg_data.app_data, &cs, 4, 0);
-  if(cs - checksum != 1){
-    printf("Bad checksum returned from server.\n");
+  if(cs - checksum != 1) {
+    Curl_failf(data, "Bad checksum returned from server");
     return AUTH_ERROR;
   }
   return AUTH_OK;
 }
 
 struct Curl_sec_client_mech Curl_krb4_client_mech = {
@@ -310,46 +311,45 @@
   ssize_t nread;
 	
   int save;
 
   save = Curl_set_command_prot(conn, prot_private);
 
-  Curl_ftpsendf(conn->firstsocket, conn,
-                "SITE KAUTH %s", conn->data->state.user);
+  if(Curl_ftpsendf(conn, "SITE KAUTH %s", conn->data->state.user))
+    return;
 
-  nread = Curl_GetFTPResponse(conn->firstsocket, conn->data->state.buffer,
+  nread = Curl_GetFTPResponse(conn->data->state.buffer,
                               conn, NULL);
   if(nread < 0)
     return /*CURLE_OPERATION_TIMEOUTED*/;
 
-  if(/*ret != CONTINUE*/conn->data->state.buffer[0] != '3'){
+  if(conn->data->state.buffer[0] != '3'){
     Curl_set_command_prot(conn, save);
-    /*code = -1;***/
     return;
   }
 
   p = strstr(conn->data->state.buffer, "T=");
   if(!p) {
-    printf("Bad reply from server.\n");
+    Curl_failf(conn->data, "Bad reply from server");
     Curl_set_command_prot(conn, save);
     return;
   }
 
   p += 2;
   tmp = Curl_base64_decode(p, &tkt.dat);
   if(tmp < 0) {
-    printf("Failed to decode base64 in reply.\n");
+    Curl_failf(conn->data, "Failed to decode base64 in reply.\n");
     Curl_set_command_prot(conn, save);
     return;
   }
   tkt.length = tmp;
   tktcopy.length = tkt.length;
     
   p = strstr(conn->data->state.buffer, "P=");
   if(!p) {
-    printf("Bad reply from server.\n");
+    Curl_failf(conn->data, "Bad reply from server");
     Curl_set_command_prot(conn, save);
     return;
   }
   name = p + 2;
   for(; *p && *p != ' ' && *p != '\r' && *p != '\n'; p++);
   *p = 0;
@@ -360,43 +360,44 @@
   des_pcbc_encrypt((des_cblock*)tkt.dat, (des_cblock*)tktcopy.dat,
                    tkt.length,
                    schedule, &key, DES_DECRYPT);
   if (strcmp ((char*)tktcopy.dat + 8,
               KRB_TICKET_GRANTING_TICKET) != 0) {
     afs_string_to_key (passwd,
-                       krb_realmofhost(/*hostname*/conn->hp->h_name),
+                       krb_realmofhost(conn->hostname),
                        &key);
     des_key_sched (&key, schedule);
     des_pcbc_encrypt((des_cblock*)tkt.dat, (des_cblock*)tktcopy.dat,
                      tkt.length,
                      schedule, &key, DES_DECRYPT);
   }
   memset(key, 0, sizeof(key));
   memset(schedule, 0, sizeof(schedule));
   memset(passwd, 0, sizeof(passwd));
   if(Curl_base64_encode(tktcopy.dat, tktcopy.length, &p) < 0) {
-    failf(conn->data, "Out of memory base64-encoding.\n");
+    failf(conn->data, "Out of memory base64-encoding.");
     Curl_set_command_prot(conn, save);
     return;
   }
   memset (tktcopy.dat, 0, tktcopy.length);
 
-  Curl_ftpsendf(conn->firstsocket, conn,
-                "SITE KAUTH %s %s", name, p);
+  if(Curl_ftpsendf(conn, "SITE KAUTH %s %s", name, p))
+    return;
 
-  nread = Curl_GetFTPResponse(conn->firstsocket, conn->data->state.buffer,
+  nread = Curl_GetFTPResponse(conn->data->state.buffer,
                               conn, NULL);
   if(nread < 0)
     return /*CURLE_OPERATION_TIMEOUTED*/;
   free(p);
   Curl_set_command_prot(conn, save);
 }
 
 #endif /* KRB4 */
+#endif /* CURL_DISABLE_FTP */
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/krb4.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/krb4.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/krb4.h	2001-08-17 18:10:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/krb4.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,24 +4,24 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: krb4.h,v 1.3 2001/08/17 10:10:15 bagder Exp $
+ * $Id: krb4.h,v 1.4 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 void Curl_krb_kauth(struct connectdata *conn);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ldap.c	2001-09-07 14:05:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ldap.c	2002-06-12 15:45:11.000000000 +0800
@@ -2,30 +2,31 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ldap.c,v 1.15 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: ldap.c,v 1.22 2002/06/12 07:45:11 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_LDAP
 /* -- WIN32 approved -- */
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -44,12 +45,13 @@
 #endif
 
 #include "urldata.h"
 #include <curl/curl.h>
 #include "sendf.h"
 #include "escape.h"
+#include "transfer.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 
 #define DYNA_GET_FUNCTION(type, fnc) \
@@ -91,15 +93,17 @@
 
 static void DynaClose(void)
 {
 #if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)
   if (libldap) {
     dlclose(libldap);
+    libldap=NULL;
   }
   if (liblber) {
     dlclose(liblber);
+    liblber=NULL;
   }
 #endif
 }
 
 static void * DynaGetFunction(const char *name)
 {
@@ -141,13 +145,13 @@
   void *result;
   void *entryIterator;
 
   int ldaptext;
   struct SessionHandle *data=conn->data;
   
-  infof(data, "LDAP: %s %s\n", data->change.url);
+  infof(data, "LDAP: %s\n", data->change.url);
 
   DynaOpen();
   if (libldap == NULL) {
     failf(data, "The needed LDAP library/libraries couldn't be opened");
     return CURLE_LIBRARY_NOT_FOUND;
   }
@@ -170,13 +174,15 @@
   server = ldap_open(conn->hostname, conn->port);
   if (server == NULL) {
     failf(data, "LDAP: Cannot connect to %s:%d",
 	  conn->hostname, conn->port);
     status = CURLE_COULDNT_CONNECT;
   } else {
-    rc = ldap_simple_bind_s(server, data->state.user, data->state.passwd);
+    rc = ldap_simple_bind_s(server,
+                            conn->bits.user_passwd?data->state.user:NULL,
+                            conn->bits.user_passwd?data->state.passwd:NULL);
     if (rc != 0) {
       failf(data, "LDAP: %s", ldap_err2string(rc));
       status = CURLE_LDAP_CANNOT_BIND;
     } else {
       rc = ldap_url_search_s(server, data->change.url, 0, &result);
       if (rc != 0) {
@@ -207,17 +213,21 @@
 	  }
       }
       ldap_unbind_s(server);
     }
   }
   DynaClose();
+
+  /* no data to transfer */
+  Curl_Transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
   
   return status;
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ldap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ldap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ldap.h	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ldap.h	2002-06-11 19:13:01.000000000 +0800
@@ -5,25 +5,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ldap.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
+ * $Id: ldap.h,v 1.8 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
+#ifndef CURL_DISABLE_LDAP
 CURLcode Curl_ldap(struct connectdata *conn);
 CURLcode Curl_ldap_done(struct connectdata *conn);
-
+#endif
 #endif /* __LDAP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/libcurl.def /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/libcurl.def
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/libcurl.def	2001-09-13 22:49:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/libcurl.def	2001-10-29 21:28:44.000000000 +0800
@@ -29,7 +29,8 @@
  	curl_msprintf @ 20 ;
  	curl_msnprintf @ 21 ;
  	curl_mvfprintf @ 22 ;
 	curl_strequal @ 23 ;
 	curl_strnequal @ 24 ;
         curl_easy_duphandle @ 25 ;
+        curl_formadd @ 26 ;
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: llist.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: llist.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.am	2001-08-28 16:58:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.am	2002-04-11 04:54:21.000000000 +0800
@@ -1,25 +1,25 @@
 #
-# $Id: Makefile.am,v 1.26 2001/08/28 08:58:27 bagder Exp $
+# $Id: Makefile.am,v 1.38 2002/04/10 20:54:21 bagder Exp $
 #
 
-AUTOMAKE_OPTIONS = foreign no-dependencies
+AUTOMAKE_OPTIONS = foreign nostdinc
 
-EXTRA_DIST = getdate.y \
-       Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6 \
-       libcurl.def dllinit.c curllib.dsp curllib.dsw
+EXTRA_DIST = getdate.y Makefile.b32 Makefile.b32.resp Makefile.m32	    \
+       Makefile.vc6 Makefile.riscos libcurl.def dllinit.c curllib.dsp	    \
+       curllib.dsw config-vms.h config-win32.h config-riscos.h config-mac.h \
+       config.h.in
 
 lib_LTLIBRARIES = libcurl.la
 
-# Some flags needed when trying to cause warnings ;-)
-# CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
+# we use srcdir/include for the static global include files
+# we use builddir/lib for the generated lib/config.h file to get found
+# we use srcdir/lib for the lib-private header files
+INCLUDES = -I$(top_srcdir)/include -I$(top_builddir)/lib -I$(top_srcdir)/lib
 
-INCLUDES = -I$(top_srcdir)/include
-
-
-libcurl_la_LDFLAGS = -version-info 2:2:0
+libcurl_la_LDFLAGS = -no-undefined -version-info 2:2:0
 # This flag accepts an argument of the form current[:revision[:age]]. So,
 # passing -version-info 3:12:1 sets current to 3, revision to 12, and age to
 # 1.
 #
 # If either revision or age are omitted, they default to 0. Also note that age
 # must be less than or equal to the current interface number.
@@ -56,13 +56,15 @@
 getdate.h      ldap.c         ssluse.c       version.c \
 getenv.c       ldap.h         ssluse.h       \
 escape.c       mprintf.c      telnet.c       \
 escape.h       getpass.c      netrc.c        telnet.h       \
 getinfo.c getinfo.h transfer.c strequal.c strequal.h easy.c \
 security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h \
-http_chunks.c http_chunks.h strtok.c strtok.h
+http_chunks.c http_chunks.h strtok.c strtok.h connect.c connect.h \
+llist.c llist.h hash.c hash.h multi.c
+
 
 noinst_HEADERS = setup.h transfer.h
 
 # Say $(srcdir), so GNU make does not report an ambiguity with the .y.c rule.
 $(srcdir)/getdate.c: getdate.y
 	cd $(srcdir) && \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.b32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.b32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.b32	2001-08-09 17:10:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.b32	2001-11-20 04:09:02.000000000 +0800
@@ -1,8 +1,8 @@
 ############################################################
-# $Id: Makefile.b32,v 1.5 2001/08/09 09:10:13 bagder Exp $
+# $Id: Makefile.b32,v 1.7 2001/11/19 20:09:02 bagder Exp $
 #
 #  Makefile.b32 - Borland's C++ Compiler 5.X
 #
 #  'lib' directory
 #
 #  Requires 'Makefile.b32.resp'
@@ -20,13 +20,13 @@
 DEFINES    = -DLIBCURL_BIGENDIAN=0 -DNDEBUG -DWIN32 -DCONSOLE -DMBCS
 INCDIRS    = -I$(CURNTDIR);$(TOPDIR)/include/
 
 # 'BCCDIR' has to be set up in your c:\autoexec.bat
 # i.e. SET BCCDIR = c:\Borland\BCC55
 # where c:\Borland\BCC55 is the compiler is installed
-LINKLIB	   = $(BCCDIR)/lib/psdk/wsock32.lib
+LINKLIB	   = $(BCCDIR)/lib/psdk/ws2_32.lib
 LIBCURLLIB = libcurl.lib
 
 .SUFFIXES: .c
 
 SOURCES	   = \
 	base64.c \
@@ -55,13 +55,14 @@
 	url.c \
 	file.c \
 	getinfo.c \
 	version.c \
 	easy.c \
 	strequal.c \
-	strtok.c
+	strtok.c \
+	connect.c
 
 OBJECTS = $(SOURCES:.c=.obj)
 
 .c.obj:
 	$(CXX) -c $(INCDIRS) $(CXXFLAGS) $(DEFINES) $<
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.b32.resp /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.b32.resp
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.b32.resp	2001-08-15 14:13:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.b32.resp	2001-11-20 04:06:29.000000000 +0800
@@ -24,8 +24,8 @@
 +url.obj &
 +file.obj &
 +getinfo.obj &
 +version.obj &
 +easy.obj &
 +strequal.obj &
-+strtok.obj
-
++strtok.obj &
++connect.obj
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.in	2001-09-12 19:51:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.in	2002-06-11 23:19:02.000000000 +0800
@@ -11,13 +11,13 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.26 2001/08/28 08:58:27 bagder Exp $
+# $Id: Makefile.am,v 1.38 2002/04/10 20:54:21 bagder Exp $
 #
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
@@ -62,12 +62,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -90,27 +97,28 @@
 VERSIONNUM = @VERSIONNUM@
 YACC = @YACC@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
-AUTOMAKE_OPTIONS = foreign no-dependencies
+AUTOMAKE_OPTIONS = foreign nostdinc
 
-EXTRA_DIST = getdate.y \
-       Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6 \
-       libcurl.def dllinit.c curllib.dsp curllib.dsw
+EXTRA_DIST = getdate.y Makefile.b32 Makefile.b32.resp Makefile.m32	    \
+       Makefile.vc6 Makefile.riscos libcurl.def dllinit.c curllib.dsp	    \
+       curllib.dsw config-vms.h config-win32.h config-riscos.h config-mac.h \
+       config.h.in
 
 
 lib_LTLIBRARIES = libcurl.la
 
+# we use srcdir/include for the static global include files
+# we use builddir/lib for the generated lib/config.h file to get found
+# we use srcdir/lib for the lib-private header files
+INCLUDES = -I$(top_srcdir)/include -I$(top_builddir)/lib -I$(top_srcdir)/lib
 
-# Some flags needed when trying to cause warnings ;-)
-# CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
-INCLUDES = -I$(top_srcdir)/include
-
-libcurl_la_LDFLAGS = -version-info 2:2:0
+libcurl_la_LDFLAGS = -no-undefined -version-info 2:2:0
 
 # This flag accepts an argument of the form current[:revision[:age]]. So,
 # passing -version-info 3:12:1 sets current to 3, revision to 12, and age to
 # 1.
 #
 # If either revision or age are omitted, they default to 0. Also note that age
@@ -147,52 +155,76 @@
 getdate.h      ldap.c         ssluse.c       version.c \
 getenv.c       ldap.h         ssluse.h       \
 escape.c       mprintf.c      telnet.c       \
 escape.h       getpass.c      netrc.c        telnet.h       \
 getinfo.c getinfo.h transfer.c strequal.c strequal.h easy.c \
 security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h \
-http_chunks.c http_chunks.h strtok.c strtok.h
+http_chunks.c http_chunks.h strtok.c strtok.h connect.c connect.h \
+llist.c llist.h hash.c hash.h multi.c
 
 
 noinst_HEADERS = setup.h transfer.h
 subdir = lib
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = config.h $(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 LTLIBRARIES = $(lib_LTLIBRARIES)
 
 libcurl_la_LIBADD =
 am_libcurl_la_OBJECTS = file.lo timeval.lo base64.lo hostip.lo \
 	progress.lo formdata.lo cookie.lo http.lo sendf.lo ftp.lo \
 	url.lo dict.lo if2ip.lo speedcheck.lo getdate.lo ldap.lo \
 	ssluse.lo version.lo getenv.lo escape.lo mprintf.lo telnet.lo \
 	getpass.lo netrc.lo getinfo.lo transfer.lo strequal.lo easy.lo \
-	security.lo krb4.lo memdebug.lo http_chunks.lo strtok.lo
+	security.lo krb4.lo memdebug.lo http_chunks.lo strtok.lo \
+	connect.lo llist.lo hash.lo multi.lo
 libcurl_la_OBJECTS = $(am_libcurl_la_OBJECTS)
 
 DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir) -I$(top_builddir)/src
+DEFAULT_INCLUDES = 
 CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
-depcomp =
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+@AMDEP_TRUE@DEP_FILES = $(DEPDIR)/base64.Plo $(DEPDIR)/connect.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/cookie.Plo $(DEPDIR)/dict.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/easy.Plo $(DEPDIR)/escape.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/file.Plo $(DEPDIR)/formdata.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/ftp.Plo $(DEPDIR)/getdate.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/getenv.Plo $(DEPDIR)/getinfo.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/getpass.Plo $(DEPDIR)/hash.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/hostip.Plo $(DEPDIR)/http.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/http_chunks.Plo $(DEPDIR)/if2ip.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/krb4.Plo $(DEPDIR)/ldap.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/llist.Plo $(DEPDIR)/memdebug.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/mprintf.Plo $(DEPDIR)/multi.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/netrc.Plo $(DEPDIR)/progress.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/security.Plo $(DEPDIR)/sendf.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/speedcheck.Plo $(DEPDIR)/ssluse.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/strequal.Plo $(DEPDIR)/strtok.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/telnet.Plo $(DEPDIR)/timeval.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/transfer.Plo $(DEPDIR)/url.Plo \
+@AMDEP_TRUE@	$(DEPDIR)/version.Plo
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
 	$(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 CFLAGS = @CFLAGS@
 DIST_SOURCES = $(libcurl_la_SOURCES)
 HEADERS = $(noinst_HEADERS)
 
-DIST_COMMON = $(noinst_HEADERS) Makefile.am Makefile.in
+DIST_COMMON = $(noinst_HEADERS) ./stamp-h1.in Makefile.am Makefile.in \
+	config.h.in
 SOURCES = $(libcurl_la_SOURCES)
 
-all: all-am
+all: config.h
+	$(MAKE) $(AM_MAKEFLAGS) all-am
 
 .SUFFIXES:
 .SUFFIXES: .c .lo .o .obj
 
 mostlyclean-libtool:
 	-rm -f *.lo
@@ -206,12 +238,37 @@
 	cd $(top_srcdir) && \
 	  $(AUTOMAKE) --foreign  lib/Makefile
 Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
 	cd $(top_builddir) && \
 	  CONFIG_HEADERS= CONFIG_LINKS= \
 	  CONFIG_FILES=$(subdir)/$@ $(SHELL) ./config.status
+config.h: stamp-h1
+	@if test ! -f $@; then \
+		rm -f stamp-h1; \
+		$(MAKE) stamp-h1; \
+	else :; fi
+stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1 stamp-h1T
+	@echo timestamp > stamp-h1T 2> /dev/null
+	cd $(top_builddir) \
+	  && CONFIG_FILES= CONFIG_HEADERS=lib/config.h \
+	     $(SHELL) ./config.status
+	@mv stamp-h1T stamp-h1
+$(srcdir)/config.h.in:  $(srcdir)/./stamp-h1.in
+	@if test ! -f $@; then \
+		rm -f $(srcdir)/./stamp-h1.in; \
+		$(MAKE) $(srcdir)/./stamp-h1.in; \
+	else :; fi
+$(srcdir)/./stamp-h1.in: $(top_srcdir)/configure.in $(ACLOCAL_M4) $(top_srcdir)/acconfig.h
+	@rm -f $(srcdir)/./stamp-h1.in $(srcdir)/./stamp-h1.inT
+	@echo timestamp > $(srcdir)/./stamp-h1.inT 2> /dev/null
+	cd $(top_srcdir) && $(AUTOHEADER)
+	@mv $(srcdir)/./stamp-h1.inT $(srcdir)/./stamp-h1.in
+
+distclean-hdr:
+	-rm -f config.h
 install-libLTLIBRARIES: $(lib_LTLIBRARIES)
 	@$(NORMAL_INSTALL)
 	$(mkinstalldirs) $(DESTDIR)$(libdir)
 	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
 	  if test -f $$p; then \
 	    echo " $(LIBTOOL) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$p $(DESTDIR)$(libdir)/$$p"; \
@@ -234,20 +291,71 @@
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT) core *.core
 
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/base64.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/connect.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/cookie.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/dict.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/easy.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/escape.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/file.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/formdata.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ftp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getdate.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getenv.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getinfo.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/getpass.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/hash.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/hostip.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/http.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/http_chunks.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/if2ip.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/krb4.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ldap.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/llist.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/memdebug.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/mprintf.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/multi.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/netrc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/progress.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/security.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/sendf.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/speedcheck.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/ssluse.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strequal.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/strtok.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/telnet.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/timeval.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/transfer.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/url.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/version.Plo@am__quote@
+
+distclean-depend:
+	-rm -rf $(DEPDIR)
+
 .c.o:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 	$(COMPILE) -c `test -f $< || echo '$(srcdir)/'`$<
 
 .c.obj:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 	$(COMPILE) -c `cygpath -w $<`
 
 .c.lo:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 	$(LTCOMPILE) -c -o $@ `test -f $< || echo '$(srcdir)/'`$<
+CCDEPMODE = @CCDEPMODE@
 uninstall-info-am:
 
 tags: TAGS
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
@@ -255,24 +363,24 @@
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique $(LISP)
 
-TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+TAGS:  $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
-	  || etags $(ETAGS_ARGS) $$tags  $$unique $(LISP)
+	test -z "$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags" \
+	  || etags $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP)
 
 GTAGS:
 	here=`CDPATH=: && cd $(top_builddir) && pwd` \
 	  && cd $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) $$here
 
@@ -299,13 +407,13 @@
 	    || cp -p $$d/$$file $(distdir)/$$file \
 	    || exit 1; \
 	  fi; \
 	done
 check-am: all-am
 check: check-am
-all-am: Makefile $(LTLIBRARIES) $(HEADERS)
+all-am: Makefile $(LTLIBRARIES) $(HEADERS) config.h
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(libdir)
 
 install: install-am
 install-exec: install-exec-am
@@ -334,14 +442,15 @@
 
 clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
 	mostlyclean-am
 
 distclean: distclean-am
 
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-libtool distclean-tags
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-hdr distclean-libtool \
+	distclean-tags
 
 dvi: dvi-am
 
 dvi-am:
 
 info: info-am
@@ -368,21 +477,21 @@
 	mostlyclean-libtool
 
 uninstall-am: uninstall-info-am uninstall-libLTLIBRARIES
 
 .PHONY: GTAGS all all-am check check-am clean clean-generic \
 	clean-libLTLIBRARIES clean-libtool distclean distclean-compile \
-	distclean-generic distclean-libtool distclean-tags distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-libLTLIBRARIES install-man \
-	install-strip installcheck installcheck-am installdirs \
-	maintainer-clean maintainer-clean-generic mostlyclean \
-	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
-	tags uninstall uninstall-am uninstall-info-am \
-	uninstall-libLTLIBRARIES
+	distclean-depend distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-data install-data-am \
+	install-exec install-exec-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool tags uninstall \
+	uninstall-am uninstall-info-am uninstall-libLTLIBRARIES
 
 
 # Say $(srcdir), so GNU make does not report an ambiguity with the .y.c rule.
 $(srcdir)/getdate.c: getdate.y
 	cd $(srcdir) && \
 	  $(YACC) $(YFLAGS) getdate.y; \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.m32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.m32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.m32	2001-08-09 17:10:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.m32	2002-06-12 17:16:52.000000000 +0800
@@ -1,21 +1,20 @@
 #############################################################
-# $Id: Makefile.m32,v 1.10 2001/08/09 09:10:13 bagder Exp $
 #
 ## Makefile for building libcurl.a with MingW32 (GCC-2.95) and
 ## optionally OpenSSL (0.9.6)
 ## Use: make -f Makefile.m32
 ##
 ## Comments to: Troy Engel <tengel@sonic.net> or
 ##              Joern Hartroth <hartroth@acm.org>
 
 CC = gcc
 AR = ar
 RANLIB = ranlib
 STRIP = strip -g
-OPENSSL_PATH = ../../openssl-0.9.6
+OPENSSL_PATH = ../../openssl-0.9.6b
 
 ########################################################
 ## Nothing more to do below this line!
 
 INCLUDES = -I. -I.. -I../include -I../src
 CFLAGS = -g -O2 -DMINGW32
@@ -33,20 +32,20 @@
 	cookie.c formdata.h http.c sendf.c cookie.h ftp.c http.h sendf.h url.c dict.c	\
 	ftp.h if2ip.c speedcheck.c url.h dict.h getdate.c if2ip.h speedcheck.h		\
 	urldata.h transfer.c getdate.h ldap.c ssluse.c version.c transfer.h getenv.c	\
 	ldap.h ssluse.h escape.c getenv.h mprintf.c telnet.c escape.h getpass.c netrc.c	\
 	telnet.h getinfo.c strequal.c strequal.h easy.c security.h		\
 	security.c krb4.h krb4.c memdebug.h memdebug.c inet_ntoa_r.h http_chunks.h http_chunks.c \
-	strtok.c
+	strtok.c connect.c hash.c llist.c
 
 libcurl_a_OBJECTS =  file.o timeval.o base64.o hostip.o progress.o \
 	formdata.o cookie.o http.o sendf.o ftp.o url.o dict.o if2ip.o \
 	speedcheck.o getdate.o transfer.o ldap.o ssluse.o version.o \
 	getenv.o escape.o mprintf.o telnet.o getpass.o netrc.o getinfo.o \
 	strequal.o easy.o security.o krb4.o memdebug.o http_chunks.o \
-	strtok.o
+	strtok.o connect.o hash.o llist.o
 
 LIBRARIES =  $(libcurl_a_LIBRARIES)
 SOURCES = $(libcurl_a_SOURCES)
 OBJECTS = $(libcurl_a_OBJECTS)
 
 
@@ -59,13 +58,13 @@
 	$(STRIP) $@
 
 # remove the last line above to keep debug info
 
 libcurl.dll libcurldll.a: libcurl.a libcurl.def dllinit.o
 	-@erase $@
-	dllwrap --dllname $@ --output-lib libcurldll.a --export-all --def libcurl.def $(libcurl_a_LIBRARIES) dllinit.o -L$(OPENSSL_PATH)/out $(DLL_LIBS) -lwsock32
+	dllwrap --dllname $@ --output-lib libcurldll.a --export-all --def libcurl.def $(libcurl_a_LIBRARIES) dllinit.o -L$(OPENSSL_PATH)/out $(DLL_LIBS) -lwsock32 -lws2_32 -lwinmm
 	$(STRIP) $@
 
 # remove the last line above to keep debug info
 
 .c.o:
 	$(COMPILE) -c $<
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: Makefile.riscos
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/Makefile.vc6	2001-09-17 22:37:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/Makefile.vc6	2002-06-07 20:14:18.000000000 +0800
@@ -1,368 +1,223 @@
 #############################################################
 #
-## Makefile for building libcurl.lib with MSVC6
-## Use: nmake -f makefile.vc6 [release | release-ssl | debug]
-##      (default is release)
-##
-## Originally written by: Troy Engel <tengel@sonic.net>
-## Updated by: Craig Davison <cd@securityfocus.com>
-## Updated by: SM <sm@technologist.com>
-
-PROGRAM_NAME = libcurl.lib
-PROGRAM_NAME_DEBUG = libcurld.lib
-#OPENSSL_PATH = ../../openssl-0.9.6b
+# Makefile for building libcurl with MSVC6
+#
+# Usage: see usage message below
+#        Should be invoked from \lib directory
+#        Edit the paths and desired library name
+#        SSL path is only required if you intend compiling
+#        with SSL.
+#
+# This make file leaves the result either a .lib or .dll file
+# in the \lib directory. It should be called from the \lib
+# directory.
+#
+# An option would have been to allow the source directory to
+# be specified, but I saw no requirement.
+#
+# Another option would have been to leave the .lib and .dll
+# files in the "cfg" directory, but then the make file
+# in \src would need to be changed.
+#
+##############################################################
+# CHANGE LOG
+# ------------------------------------------------------------
+# 05.11.2001   John Lask   Initial Release
+# 02.05.2002   Miklos Nemeth OPENSSL_PATH environment; no need
+#              for OpenSSL libraries when creating a 
+#              static libcurl.lib
+#
+#
+##############################################################
 
-########################################################
-## Nothing more to do below this line!
+LIB_NAME       = libcurl
+LIB_NAME_DEBUG = libcurld
+!IFNDEF OPENSSL_PATH
+OPENSSL_PATH   = ../../openssl-0.9.6
+!ENDIF
 
-## Release
-CCR = cl.exe /MD /O2 /D "NDEBUG"
-LINKR = link.exe -lib /out:$(PROGRAM_NAME)
-
-## Debug
-CCD = cl.exe /MDd /Gm /ZI /Od /D "_DEBUG" /GZ
-LINKD = link.exe -lib /out:$(PROGRAM_NAME_DEBUG)
-
-## SSL Release
-CCRS = cl.exe /MD /O2 /D "NDEBUG" /D "USE_SSLEAY" /I "$(OPENSSL_PATH)/inc32" /I "$(OPENSSL_PATH)/inc32/openssl"
-LINKRS = link.exe -lib /out:$(PROGRAM_NAME) /LIBPATH:$(OPENSSL_PATH)/out32dll
+#############################################################
+## Nothing more to do below this line!
 
+CCNODBG   = cl.exe /MD /O2 /D "NDEBUG"
+CCDEBUG   = cl.exe /MDd /Od /Gm /Zi  /D "_DEBUG" /GZ
+CFLAGSSSL = /D "USE_SSLEAY" /I "$(OPENSSL_PATH)/inc32" /I "$(OPENSSL_PATH)/inc32/openssl"
 CFLAGS = /I "../include" /nologo /W3 /GX /D "WIN32" /D "VC6" /D "_MBCS" /D "_LIB" /YX /FD /c /D "MSDOS"
-LFLAGS = /nologo
-LINKLIBS = ws2_32.lib
-LINKSLIBS = libeay32.lib ssleay32.lib RSAglue.lib
-
-RELEASE_OBJS= \
-	base64r.obj \
-	cookier.obj \
-	transferr.obj \
-	escaper.obj \
-	formdatar.obj \
-	ftpr.obj \
-	httpr.obj \
-	http_chunksr.obj \
-	ldapr.obj \
-	dictr.obj \
-	telnetr.obj \
-	getdater.obj \
-	getenvr.obj \
-	getpassr.obj \
-	hostipr.obj \
-	if2ipr.obj \
-	mprintfr.obj \
-	netrcr.obj \
-	progressr.obj \
-	sendfr.obj \
-	speedcheckr.obj \
-	ssluser.obj \
-	timevalr.obj \
-	urlr.obj \
-	filer.obj \
-	getinfor.obj \
-	versionr.obj \
-	easyr.obj \
-	strequalr.obj \
-	strtokr.obj
-
-DEBUG_OBJS= \
-	base64d.obj \
-	cookied.obj \
-	transferd.obj \
-	escaped.obj \
-	formdatad.obj \
-	ftpd.obj \
-	httpd.obj \
-	http_chunksd.obj \
-	ldapd.obj \
-	dictd.obj \
-	telnetd.obj \
-	getdated.obj \
-	getenvd.obj \
-	getpassd.obj \
-	hostipd.obj \
-	if2ipd.obj \
-	mprintfd.obj \
-	netrcd.obj \
-	progressd.obj \
-	sendfd.obj \
-	speedcheckd.obj \
-	sslused.obj \
-	timevald.obj \
-	urld.obj \
-	filed.obj \
-	getinfod.obj \
-	versiond.obj  \
-	easyd.obj \
-	strequald.obj \
-	strtokd.obj
-
-RELEASE_SSL_OBJS= \
-	base64rs.obj \
-	cookiers.obj \
-	transferrs.obj \
-	escapers.obj \
-	formdatars.obj \
-	ftprs.obj \
-	httprs.obj \
-	http_chunksrs.obj \
-	ldaprs.obj \
-	dictrs.obj \
-	telnetrs.obj \
-	getdaters.obj \
-	getenvrs.obj \
-	getpassrs.obj \
-	hostiprs.obj \
-	if2iprs.obj \
-	mprintfrs.obj \
-	netrcrs.obj \
-	progressrs.obj \
-	sendfrs.obj \
-	speedcheckrs.obj \
-	sslusers.obj \
-	timevalrs.obj \
-	urlrs.obj \
-	filers.obj \
-	getinfors.obj \
-	versionrs.obj \
-	easyrs.obj \
-	strequalrs.obj \
-	strtokrs.obj
-
-LINK_OBJS= \
-	base64.obj \
-	cookie.obj \
-	transfer.obj \
-	escape.obj \
-	formdata.obj \
-	ftp.obj \
-	http.obj \
-	http_chunks.obj \
-	ldap.obj \
-	dict.obj \
-	telnet.obj \
-	getdate.obj \
-	getenv.obj \
-	getpass.obj \
-	hostip.obj \
-	if2ip.obj \
-	mprintf.obj \
-	netrc.obj \
-	progress.obj \
-	sendf.obj \
-	speedcheck.obj \
-	ssluse.obj \
-	timeval.obj \
-	url.obj \
-	file.obj \
-	getinfo.obj \
-	version.obj \
-	easy.obj \
-	strequal.obj \
-	strtok.obj
-
-all : release
-
-release: $(RELEASE_OBJS)
-	$(LINKR) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
-
-debug: $(DEBUG_OBJS)
-	$(LINKD) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
-
-release-ssl: $(RELEASE_SSL_OBJS)
-	$(LINKRS) $(LFLAGS) $(LINKLIBS) $(LINKSLIBS) $(LINK_OBJS)
-
-## Release
-base64r.obj: base64.c
-	$(CCR) $(CFLAGS) base64.c
-cookier.obj: cookie.c
-	$(CCR) $(CFLAGS) cookie.c
-transferr.obj: transfer.c
-	$(CCR) $(CFLAGS) transfer.c
-escaper.obj: escape.c
-	$(CCR) $(CFLAGS) escape.c
-formdatar.obj: formdata.c
-	$(CCR) $(CFLAGS) formdata.c
-ftpr.obj: ftp.c
-	$(CCR) $(CFLAGS) ftp.c
-httpr.obj: http.c
-	$(CCR) $(CFLAGS) http.c
-http_chunksr.obj: http_chunks.c
-	$(CCR) $(CFLAGS) http_chunks.c
-ldapr.obj: ldap.c
-	$(CCR) $(CFLAGS) ldap.c
-dictr.obj: dict.c
-	$(CCR) $(CFLAGS) dict.c
-telnetr.obj: telnet.c
-	$(CCR) $(CFLAGS) telnet.c
-getdater.obj: getdate.c
-	$(CCR) $(CFLAGS) getdate.c
-getenvr.obj: getenv.c
-	$(CCR) $(CFLAGS) getenv.c
-getpassr.obj: getpass.c
-	$(CCR) $(CFLAGS) getpass.c
-hostipr.obj: hostip.c
-	$(CCR) $(CFLAGS) hostip.c
-if2ipr.obj: if2ip.c
-	$(CCR) $(CFLAGS) if2ip.c
-mprintfr.obj: mprintf.c
-	$(CCR) $(CFLAGS) mprintf.c
-netrcr.obj: netrc.c
-	$(CCR) $(CFLAGS) netrc.c
-progressr.obj: progress.c
-	$(CCR) $(CFLAGS) progress.c
-sendfr.obj: sendf.c
-	$(CCR) $(CFLAGS) sendf.c
-speedcheckr.obj: speedcheck.c
-	$(CCR) $(CFLAGS) speedcheck.c
-ssluser.obj: ssluse.c
-	$(CCR) $(CFLAGS) ssluse.c
-timevalr.obj: timeval.c
-	$(CCR) $(CFLAGS) timeval.c
-urlr.obj: url.c
-	$(CCR) $(CFLAGS) url.c
-filer.obj: file.c
-	$(CCR) $(CFLAGS) file.c
-getinfor.obj: getinfo.c
-	$(CCR) $(CFLAGS) getinfo.c
-versionr.obj: version.c
-	$(CCR) $(CFLAGS) version.c
-easyr.obj: easy.c
-	$(CCR) $(CFLAGS) easy.c
-strequalr.obj: strequal.c
-	$(CCR) $(CFLAGS) strequal.c
-strtokr.obj:strtok.c
-	$(CCR) $(CFLAGS) strtok.c
-
-## Debug
-base64d.obj: base64.c
-	$(CCD) $(CFLAGS) base64.c
-cookied.obj: cookie.c
-	$(CCD) $(CFLAGS) cookie.c
-transferd.obj: transfer.c
-	$(CCD) $(CFLAGS) transfer.c
-escaped.obj: escape.c
-	$(CCD) $(CFLAGS) escape.c
-formdatad.obj: formdata.c
-	$(CCD) $(CFLAGS) formdata.c
-ftpd.obj: ftp.c
-	$(CCD) $(CFLAGS) ftp.c
-httpd.obj: http.c
-	$(CCD) $(CFLAGS) http.c
-http_chunksd.obj: http_chunks.c
-	$(CCD) $(CFLAGS) http_chunks.c
-ldapd.obj: ldap.c
-	$(CCD) $(CFLAGS) ldap.c
-dictd.obj: dict.c
-	$(CCD) $(CFLAGS) dict.c
-telnetd.obj: telnet.c
-	$(CCD) $(CFLAGS) telnet.c
-getdated.obj: getdate.c
-	$(CCD) $(CFLAGS) getdate.c
-getenvd.obj: getenv.c
-	$(CCD) $(CFLAGS) getenv.c
-getpassd.obj: getpass.c
-	$(CCD) $(CFLAGS) getpass.c
-hostipd.obj: hostip.c
-	$(CCD) $(CFLAGS) hostip.c
-if2ipd.obj: if2ip.c
-	$(CCD) $(CFLAGS) if2ip.c
-mprintfd.obj: mprintf.c
-	$(CCD) $(CFLAGS) mprintf.c
-netrcd.obj: netrc.c
-	$(CCD) $(CFLAGS) netrc.c
-progressd.obj: progress.c
-	$(CCD) $(CFLAGS) progress.c
-sendfd.obj: sendf.c
-	$(CCD) $(CFLAGS) sendf.c
-speedcheckd.obj: speedcheck.c
-	$(CCD) $(CFLAGS) speedcheck.c
-sslused.obj: ssluse.c
-	$(CCD) $(CFLAGS) ssluse.c
-timevald.obj: timeval.c
-	$(CCD) $(CFLAGS) timeval.c
-urld.obj: url.c
-	$(CCD) $(CFLAGS) url.c
-filed.obj: file.c
-	$(CCD) $(CFLAGS) file.c
-getinfod.obj: getinfo.c
-	$(CCD) $(CFLAGS) getinfo.c
-versiond.obj: version.c
-	$(CCD) $(CFLAGS) version.c
-easyd.obj: easy.c
-	$(CCD) $(CFLAGS) easy.c
-strequald.obj: strequal.c
-	$(CCD) $(CFLAGS) strequal.c
-strtokd.obj:strtok.c
-	$(CCD) $(CFLAGS) strtok.c
-
-## Release SSL
-base64rs.obj: base64.c
-	$(CCRS) $(CFLAGS) base64.c
-cookiers.obj: cookie.c
-	$(CCRS) $(CFLAGS) cookie.c
-transferrs.obj: transfer.c
-	$(CCRS) $(CFLAGS) transfer.c
-escapers.obj: escape.c
-	$(CCRS) $(CFLAGS) escape.c
-formdatars.obj: formdata.c
-	$(CCRS) $(CFLAGS) formdata.c
-ftprs.obj: ftp.c
-	$(CCRS) $(CFLAGS) ftp.c
-httprs.obj: http.c
-	$(CCRS) $(CFLAGS) http.c
-http_chunksrs.obj: http_chunks.c
-	$(CCRS) $(CFLAGS) http_chunks.c
-ldaprs.obj: ldap.c
-	$(CCRS) $(CFLAGS) ldap.c
-dictrs.obj: dict.c
-	$(CCRS) $(CFLAGS) dict.c
-telnetrs.obj: telnet.c
-	$(CCRS) $(CFLAGS) telnet.c
-getdaters.obj: getdate.c
-	$(CCRS) $(CFLAGS) getdate.c
-getenvrs.obj: getenv.c
-	$(CCRS) $(CFLAGS) getenv.c
-getpassrs.obj: getpass.c
-	$(CCRS) $(CFLAGS) getpass.c
-hostiprs.obj: hostip.c
-	$(CCRS) $(CFLAGS) hostip.c
-if2iprs.obj: if2ip.c
-	$(CCRS) $(CFLAGS) if2ip.c
-mprintfrs.obj: mprintf.c
-	$(CCRS) $(CFLAGS) mprintf.c
-netrcrs.obj: netrc.c
-	$(CCRS) $(CFLAGS) netrc.c
-progressrs.obj: progress.c
-	$(CCRS) $(CFLAGS) progress.c
-sendfrs.obj: sendf.c
-	$(CCRS) $(CFLAGS) sendf.c
-speedcheckrs.obj: speedcheck.c
-	$(CCRS) $(CFLAGS) speedcheck.c
-sslusers.obj: ssluse.c
-	$(CCRS) $(CFLAGS) ssluse.c
-timevalrs.obj: timeval.c
-	$(CCRS) $(CFLAGS) timeval.c
-urlrs.obj: url.c
-	$(CCRS) $(CFLAGS) url.c
-filers.obj: file.c
-	$(CCRS) $(CFLAGS) file.c
-getinfors.obj: getinfo.c
-	$(CCRS) $(CFLAGS) getinfo.c
-versionrs.obj: version.c
-	$(CCRS) $(CFLAGS) version.c
-easyrs.obj: easy.c
-	$(CCRS) $(CFLAGS) easy.c
-strequalrs.obj: strequal.c
-	$(CCRS) $(CFLAGS) strequal.c
-strtokrs.obj:strtok.c
-	$(CCRS) $(CFLAGS) strtok.c
 
+LNKDLL    = link.exe /DLL  /def:libcurl.def
+LNKLIB    = link.exe -lib
+LFLAGS    = /nologo
+LINKLIBS  = ws2_32.lib
+SSLLIBS   = libeay32.lib ssleay32.lib RSAglue.lib
+CFGSET    = FALSE
+
+######################
+# release
+
+!IF "$(CFG)" == "release"
+TARGET =$(LIB_NAME).lib
+DIROBJ =.\$(CFG)
+LNK    = $(LNKLIB) /out:$(TARGET)
+CC     = $(CCNODBG)
+CFGSET = TRUE
+!ENDIF
+
+######################
+# release-dll
+
+!IF "$(CFG)" == "release-dll"
+TARGET =$(LIB_NAME).dll
+DIROBJ =.\$(CFG)
+LNK    = $(LNKDLL) /out:$(TARGET) /IMPLIB:"$(LIB_NAME).lib"
+CC     = $(CCNODBG)
+CFGSET = TRUE
+!ENDIF
+
+######################
+# release-ssl
+
+!IF "$(CFG)" == "release-ssl"
+TARGET   =$(LIB_NAME).lib
+DIROBJ   =.\$(CFG)
+LFLAGSSSL = "/LIBPATH:$(OPENSSL_PATH)/out32"
+LNK      = $(LNKLIB) $(LFLAGSSSL) /out:$(TARGET)
+LINKLIBS = $(LINKLIBS)
+CC       = $(CCNODBG) $(CFLAGSSSL)
+CFGSET   = TRUE
+!ENDIF
+
+######################
+# release-ssl-dll
+
+!IF "$(CFG)" == "release-ssl-dll"
+TARGET   =$(LIB_NAME).dll
+DIROBJ   =.\$(CFG)
+LFLAGSSSL = "/LIBPATH:$(OPENSSL_PATH)/out32dll"
+LNK      = $(LNKDLL) $(LFLAGSSSL) /out:$(TARGET) /IMPLIB:"$(LIB_NAME).lib"
+LINKLIBS = $(LINKLIBS) $(SSLLIBS)
+CC       = $(CCNODBG)  $(CFLAGSSSL)
+CFGSET   = TRUE
+!ENDIF
+
+######################
+# debug
+
+!IF "$(CFG)" == "debug"
+TARGET =$(LIB_NAME_DEBUG).lib
+DIROBJ =.\$(CFG)
+LNK    = $(LNKLIB) /out:$(TARGET)
+CC     = $(CCDEBUG)
+CFGSET = TRUE
+!ENDIF
+
+######################
+# debug-dll
+
+!IF "$(CFG)" == "debug-dll"
+TARGET =$(LIB_NAME_DEBUG).dll
+DIROBJ =.\$(CFG)
+LNK    = $(LNKDLL) /out:$(TARGET) /IMPLIB:"$(LIB_NAME_DEBUG).lib"
+CC     = $(CCDEBUG)
+CFGSET = TRUE
+!ENDIF
+
+######################
+# debug-ssl
+#todo
+!IF "$(CFG)" == "debug-ssl"
+TARGET   = $(LIB_NAME_DEBUG).lib
+DIROBJ   =.\$(CFG)
+LNK      = $(LNKLIB) $(LFLAGSSSL) /out:$(TARGET)
+LINKLIBS = $(LINKLIBS)
+CC       = $(CCDEBUG) $(CFLAGSSSL)
+CFGSET   = TRUE
+!ENDIF
+
+######################
+# debug-ssl-dll
+
+!IF "$(CFG)" == "debug-ssl-dll"
+TARGET   =$(LIB_NAME_DEBUG).dll
+DIROBJ   =.\$(CFG)
+LNK      = $(LNKDLL) $(LFLAGSSSL) /out:$(TARGET) /IMPLIB:"$(LIB_NAME_DEBUG).lib"
+LINKLIBS = $(LINKLIBS) $(SSLLIBS)
+CC       = $(CCDEBUG) $(CFLAGSSSL)
+CFGSET   = TRUE
+!ENDIF
+
+#######################
+# Usage
+#
+!IF "$(CFGSET)" == "FALSE"
+!MESSAGE Usage: nmake -f makefile.vc6 CFG=<config> <target>
+!MESSAGE where <config> is one of:
+!MESSAGE   release          - release static library
+!MESSAGE   release-dll      - release dll
+!MESSAGE   release-ssl      - release static library with ssl
+!MESSAGE   release-ssl-dll  - release dll library with ssl
+!MESSAGE   debug            - debug static library
+!MESSAGE   debug-dll        - debug dll
+!MESSAGE   debug-ssl        - debug static library with ssl
+!MESSAGE   debug-ssl-dll    - debug dll library with ssl
+!MESSAGE <target> can be left blank in which case all is assumed
+!ERROR please choose a valid configuration "$(CFG)"
+!ENDIF
+
+#######################
+#
+X_OBJS= \
+	$(DIROBJ)\base64.obj \
+	$(DIROBJ)\cookie.obj \
+	$(DIROBJ)\transfer.obj \
+	$(DIROBJ)\escape.obj \
+	$(DIROBJ)\formdata.obj \
+	$(DIROBJ)\ftp.obj \
+	$(DIROBJ)\http.obj \
+	$(DIROBJ)\http_chunks.obj \
+	$(DIROBJ)\ldap.obj \
+	$(DIROBJ)\dict.obj \
+	$(DIROBJ)\telnet.obj \
+	$(DIROBJ)\getdate.obj \
+	$(DIROBJ)\getenv.obj \
+	$(DIROBJ)\getpass.obj \
+	$(DIROBJ)\hostip.obj \
+	$(DIROBJ)\if2ip.obj \
+	$(DIROBJ)\mprintf.obj \
+	$(DIROBJ)\netrc.obj \
+	$(DIROBJ)\progress.obj \
+	$(DIROBJ)\sendf.obj \
+	$(DIROBJ)\speedcheck.obj \
+	$(DIROBJ)\ssluse.obj \
+	$(DIROBJ)\timeval.obj \
+	$(DIROBJ)\url.obj \
+	$(DIROBJ)\file.obj \
+	$(DIROBJ)\getinfo.obj \
+	$(DIROBJ)\version.obj \
+	$(DIROBJ)\easy.obj \
+	$(DIROBJ)\strequal.obj \
+	$(DIROBJ)\strtok.obj \
+	$(DIROBJ)\connect.obj \
+	$(DIROBJ)\hash.obj \
+	$(DIROBJ)\llist.obj \
+	$(DIROBJ)\multi.obj
+
+all : $(TARGET)
+
+
+$(TARGET): $(X_OBJS)
+	$(LNK) $(LFLAGS) $(LINKLIBS) $(X_OBJS)
+
+$(X_OBJS): $(DIROBJ)
+
+$(DIROBJ):
+	@if not exist "$(DIROBJ)" mkdir $(DIROBJ)
+
+.SUFFIXES: .c .obj
+
+{.\}.c{$(DIROBJ)\}.obj:
+	$(CC) $(CFLAGS) /Fo"$@"  $<
 
 clean:
-	-@erase *.obj
+	-@erase $(DIROBJ)\*.obj
 	-@erase vc60.idb
 	-@erase vc60.pch
-
-distrib: clean
-	-@erase $(PROGRAM_NAME)
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/memdebug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/memdebug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/memdebug.c	2001-09-07 14:05:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/memdebug.c	2002-05-22 18:04:18.000000000 +0800
@@ -3,26 +3,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: memdebug.c,v 1.16 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: memdebug.c,v 1.25 2002/05/21 22:17:19 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
@@ -44,12 +44,19 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
 /* DONT include memdebug.h here! */
 
+struct memdebug {
+  int size;
+  double mem[1];
+  /* I'm hoping this is the thing with the strictest alignment
+   * requirements.  That also means we waste some space :-( */
+};
+
 /*
  * Note that these debug functions are very simple and they are meant to
  * remain so. For advanced analysis, record a log file and write perl scripts
  * to analyze them!
  *
  * Don't use these with multithreaded test programs!
@@ -57,22 +64,38 @@
 
 FILE *logfile;
 
 /* this sets the log file name */
 void curl_memdebug(const char *logname)
 {
-  logfile = fopen(logname, "w");
+  if(logname)
+    logfile = fopen(logname, "w");
+  else
+    logfile = stderr;
 }
 
 
-void *curl_domalloc(size_t size, int line, const char *source)
+void *curl_domalloc(size_t wantedsize, int line, const char *source)
 {
-  void *mem=(malloc)(size);
-  fprintf(logfile?logfile:stderr, "MEM %s:%d malloc(%d) = %p\n",
-          source, line, size, mem);
-  return mem;
+  struct memdebug *mem;
+  size_t size;
+
+  /* alloc at least 64 bytes */
+  size = sizeof(struct memdebug)+wantedsize;
+
+  mem=(struct memdebug *)(malloc)(size);
+  if(mem) {
+    /* fill memory with junk */
+    memset(mem->mem, 0xA5, wantedsize);
+    mem->size = wantedsize;
+  }
+
+  if(logfile && source)
+    fprintf(logfile, "MEM %s:%d malloc(%d) = %p\n",
+            source, line, wantedsize, mem->mem);
+  return mem->mem;
 }
 
 char *curl_dostrdup(const char *str, int line, const char *source)
 {
   char *mem;
   size_t len;
@@ -80,87 +103,129 @@
   if(NULL ==str) {
     fprintf(stderr, "ILLEGAL strdup() on NULL at %s:%d\n",
             source, line);
     exit(2);
   }
 
-  mem=(strdup)(str);
   len=strlen(str)+1;
-  fprintf(logfile?logfile:stderr, "MEM %s:%d strdup(%p) (%d) = %p\n",
-          source, line, str, len, mem);
+
+  mem=curl_domalloc(len, 0, NULL); /* NULL prevents logging */
+  memcpy(mem, str, len);
+
+  if(logfile)
+    fprintf(logfile, "MEM %s:%d strdup(%p) (%d) = %p\n",
+            source, line, str, len, mem);
+
   return mem;
 }
 
-void *curl_dorealloc(void *ptr, size_t size, int line, const char *source)
+void *curl_dorealloc(void *ptr, size_t wantedsize,
+                     int line, const char *source)
 {
-  void *mem=(realloc)(ptr, size);
-  fprintf(logfile?logfile:stderr, "MEM %s:%d realloc(%p, %d) = %p\n",
-          source, line, ptr, size, mem);
-  return mem;
+  struct memdebug *mem;
+
+  size_t size = sizeof(struct memdebug)+wantedsize;
+
+  mem = (struct memdebug *)((char *)ptr - offsetof(struct memdebug, mem));
+
+  mem=(struct memdebug *)(realloc)(mem, size);
+  if(logfile)
+    fprintf(logfile, "MEM %s:%d realloc(%p, %d) = %p\n",
+            source, line, ptr, wantedsize, mem?mem->mem:NULL);
+
+  if(mem) {
+    mem->size = wantedsize;
+    return mem->mem;
+  }
+
+  return NULL;
 }
 
 void curl_dofree(void *ptr, int line, const char *source)
 {
+  struct memdebug *mem;
+
   if(NULL == ptr) {
     fprintf(stderr, "ILLEGAL free() on NULL at %s:%d\n",
             source, line);
     exit(2);
   }
+  mem = (struct memdebug *)((char *)ptr - offsetof(struct memdebug, mem));
 
-  (free)(ptr);
+  /* destroy  */
+  memset(mem->mem, 0x13, mem->size);
+  
+  /* free for real */
+  (free)(mem);
 
-  fprintf(logfile?logfile:stderr, "MEM %s:%d free(%p)\n",
-          source, line, ptr);
+  if(logfile)
+    fprintf(logfile, "MEM %s:%d free(%p)\n", source, line, ptr);
 }
 
 int curl_socket(int domain, int type, int protocol, int line, char *source)
 {
   int sockfd=(socket)(domain, type, protocol);
-  fprintf(logfile?logfile:stderr, "FD %s:%d socket() = %d\n",
-          source, line, sockfd);
+  if(logfile)
+    fprintf(logfile, "FD %s:%d socket() = %d\n",
+            source, line, sockfd);
   return sockfd;
 }
 
 int curl_accept(int s, struct sockaddr *addr, socklen_t *addrlen,
                 int line, const char *source)
 {
   int sockfd=(accept)(s, addr, addrlen);
-  fprintf(logfile?logfile:stderr, "FD %s:%d accept() = %d\n",
-          source, line, sockfd);
+  if(logfile)
+    fprintf(logfile, "FD %s:%d accept() = %d\n",
+            source, line, sockfd);
   return sockfd;
 }
 
 /* this is our own defined way to close sockets on *ALL* platforms */
 int curl_sclose(int sockfd, int line, char *source)
 {
   int res=sclose(sockfd);
-  fprintf(logfile?logfile:stderr, "FD %s:%d sclose(%d)\n",
-          source, line, sockfd);
+  if(logfile)
+    fprintf(logfile, "FD %s:%d sclose(%d)\n",
+            source, line, sockfd);
   return res;
 }
 
 FILE *curl_fopen(const char *file, const char *mode,
                  int line, const char *source)
 {
   FILE *res=(fopen)(file, mode);
-  fprintf(logfile?logfile:stderr, "FILE %s:%d fopen(\"%s\") = %p\n",
-          source, line, file, res);
+  if(logfile)
+    fprintf(logfile, "FILE %s:%d fopen(\"%s\") = %p\n",
+            source, line, file, res);
   return res;
 }
 
 int curl_fclose(FILE *file, int line, const char *source)
 {
-  int res=(fclose)(file);
-  fprintf(logfile?logfile:stderr, "FILE %s:%d fclose(%p)\n",
-          source, line, file);
+  int res;
+
+  if(NULL == file) {
+    fprintf(stderr, "ILLEGAL flose() on NULL at %s:%d\n",
+            source, line);
+    exit(2);
+  }
+
+  res=(fclose)(file);
+  if(logfile)
+    fprintf(logfile, "FILE %s:%d fclose(%p)\n",
+            source, line, file);
   return res;
 }
-
+#else
+#ifdef VMS
+int VOID_VAR_MEMDEBUG;	
+#endif
 #endif /* MALLOCDEBUG */
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/memdebug.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/memdebug.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/memdebug.h	2001-08-14 17:13:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/memdebug.h	2002-03-19 15:54:55.000000000 +0800
@@ -1,14 +1,46 @@
 #ifdef MALLOCDEBUG
+/*****************************************************************************
+ *                                  _   _ ____  _     
+ *  Project                     ___| | | |  _ \| |    
+ *                             / __| | | | |_) | |    
+ *                            | (__| |_| |  _ <| |___ 
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * In order to be useful for every potential user, curl and libcurl are
+ * dual-licensed under the MPL and the MIT/X-derivate licenses.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the MPL or the MIT/X-derivate
+ * licenses. You may pick one of these licenses.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * $Id: memdebug.h,v 1.12 2002/03/19 07:54:55 bagder Exp $
+ *****************************************************************************/
 
+#include "setup.h"
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
+#endif
 #include <stdio.h>
 #ifdef HAVE_MEMORY_H
 #include <memory.h>
 #endif
 
+extern FILE *logfile;
+
 /* memory functions */
 void *curl_domalloc(size_t size, int line, const char *source);
 void *curl_dorealloc(void *ptr, size_t size, int line, const char *source);
 void curl_dofree(void *ptr, int line, const char *source);
 char *curl_dostrdup(const char *str, int line, const char *source);
 void curl_memdebug(const char *logname);
@@ -32,12 +64,17 @@
 
 #define socket(domain,type,protocol)\
  curl_socket(domain,type,protocol,__LINE__,__FILE__)
 #define accept(sock,addr,len)\
  curl_accept(sock,addr,len,__LINE__,__FILE__)
 
+#define getaddrinfo(host,serv,hint,res) \
+  curl_getaddrinfo(host,serv,hint,res,__LINE__,__FILE__)
+#define freeaddrinfo(data) \
+  curl_freeaddrinfo(data,__LINE__,__FILE__)
+
 /* sclose is probably already defined, redefine it! */
 #undef sclose
 #define sclose(sockfd) curl_sclose(sockfd,__LINE__,__FILE__)
 
 #undef fopen
 #define fopen(file,mode) curl_fopen(file,mode,__LINE__,__FILE__)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/mprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/mprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/mprintf.c	2001-09-07 14:05:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/mprintf.c	2002-05-22 05:54:39.000000000 +0800
@@ -1,9 +1,9 @@
 /****************************************************************************
  *
- * $Id: mprintf.c,v 1.12 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: mprintf.c,v 1.20 2002/05/21 17:59:57 bagder Exp $
  *
  *************************************************************************
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -21,95 +21,35 @@
  *  void * in 64-bit architectures).
  *
  * Current restrictions:
  * - Max 128 parameters
  * - No 'long double' support.
  *
- *************************************************************************
- *
- *
- * 1998/01/10  (v2.8)
- *   Daniel
- *   - Updated version number.
- *   - Corrected a static non-zero prefixed width problem.
- *
- * 1998/11/17 - Daniel
- *   Added daprintf() and dvaprintf() for allocated printf() and vprintf().
- *   They return an allocated buffer with the result inside. The result must
- *   be free()ed!
- *
- * 1998/08/23 - breese
- *
- *   Converted all non-printable (and non-whitespace) characters into
- *   their decimal ASCII value preceeded by a '\' character
- *   (this only applies to snprintf family so far)
- *
- *   Added %S (which is the same as %#s)
- *
- * 1998/05/05 (v2.7)
- *
- *   Fixed precision and width qualifiers (%.*s)
- *
- *   Added support for snprintf()
- *
- *   Quoting (%#s) is disabled for the (nil) pointer
- *
- * 1997/06/09 (v2.6)
- *
- *   %#s means that the string will be quoted with "
- *   (I was getting tired of writing \"%s\" all the time)
- *
- *   [ERR] for strings changed to (nil)
- *
- * v2.5
- * - Added C++ support
- * - Prepended all internal functions with dprintf_
- * - Defined the booleans
- *
- * v2.4
- * - Added dvsprintf(), dvfprintf() and dvprintf().
- * - Made the formatting function available with the name _formatf() to enable
- *   other *printf()-inspired functions. (I considered adding a dmsprintf()
- *   that works like sprintf() but allocates the destination string and
- *   possibly enlarges it itself, but things like that should be done with the
- *   new _formatf() instead.)
- *
- * v2.3
- * - Small modifications to make it compile nicely at both Daniel's and
- *   Bjorn's place.
- *
- * v2.2
- * - Made it work with text to the right of the last %!
- * - Introduced dprintf(), dsprintf() and dfprintf().
- * - Float/double support enabled. This system is currently using the ordinary
- *   sprintf() function. NOTE that positional parameters, widths and precisions
- *   will still work like it should since the d-system takes care of that and
- *   passes that information re-formatted to the old sprintf().
- *
- * v2.1
- * - Fixed space padding (i.e %d was extra padded previously)
- * - long long output is supported
- * - alternate output is done correct like in %#08x
- *
- ****************************************************************************/
-
-static const char rcsid[] = "@(#)$Id: mprintf.c,v 1.12 2001/09/07 04:01:32 bumblebury Exp $";
-
-/*
- * To test:
- *
- * Use WIDTH, PRECISION and NUMBERED ARGUMENT combined.
+ * If you ever want truly portable and good *printf() clones, the project that
+ * took on from here is named 'Trio' and you find more details on the trio web
+ * page at http://daniel.haxx.se/trio/
  */
 
+
+#include "setup.h"
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 #include <ctype.h>
 #include <string.h>
 
+#ifndef SIZEOF_LONG_LONG
+/* prevents warnings on picky compilers */
+#define SIZEOF_LONG_LONG 0
+#endif
+#ifndef SIZEOF_LONG_DOUBLE
+#define SIZEOF_LONG_DOUBLE 0
+#endif
+
+
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 #define BUFFSIZE 256 /* buffer for long-to-str and float-to-str calcs */
@@ -756,15 +696,14 @@
       /* Decimal integer.  */
       base = 10;
 
 #if SIZEOF_LONG_LONG
       if(p->flags & FLAGS_LONGLONG) {
 	 /* long long */
-	num = p->data.lnum;
-	is_neg = num < 0;
-	num = is_neg ? (- num) : num;
+	is_neg = p->data.lnum < 0;
+	num = is_neg ? (- p->data.lnum) : p->data.lnum;
       }
       else
 #endif
       {
 	signed_num = (long) num;
       
@@ -906,20 +845,20 @@
 	  num = (unsigned long) ptr;
 	  is_neg = 0;
 	  goto number;
 	}
 	else {
 	  /* Write "(nil)" for a nil pointer.  */
-	  static char nil[] = "(nil)";
+	  static char strnil[] = "(nil)";
 	  register char *point;
 	  
-	  width -= sizeof(nil) - 1;
+	  width -= sizeof(strnil) - 1;
 	  if (p->flags & FLAGS_LEFT)
 	    while (width-- > 0)
 	      OUTCHAR(' ');
-	  for (point = nil; *point != '\0'; ++point)
+	  for (point = strnil; *point != '\0'; ++point)
 	    OUTCHAR(*point);
 	  if (! (p->flags & FLAGS_LEFT))
 	    while (width-- > 0)
 	      OUTCHAR(' ');
 	}
       }
@@ -1102,37 +1040,47 @@
   info.len = 0;
   info.alloc = 0;
 
   va_start(ap_save, format);
   retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);
   va_end(ap_save);
-  if(info.len) {
+  if(-1 == retcode) {
+    if(info.alloc)
+      free(info.buffer);
+    return NULL;
+  }
+  if(info.alloc) {
     info.buffer[info.len] = 0; /* we terminate this with a zero byte */
     return info.buffer;
   }
   else
-    return NULL;
+    return strdup("");
 }
 
 char *curl_mvaprintf(const char *format, va_list ap_save)
 {
   int retcode;
   struct asprintf info;
 
   info.buffer = NULL;
   info.len = 0;
   info.alloc = 0;
 
   retcode = dprintf_formatf(&info, alloc_addbyter, format, ap_save);
-  info.buffer[info.len] = 0; /* we terminate this with a zero byte */
-  if(info.len) {
+  if(-1 == retcode) {
+    if(info.alloc)
+      free(info.buffer);
+    return NULL;
+  }
+
+  if(info.alloc) {
     info.buffer[info.len] = 0; /* we terminate this with a zero byte */
     return info.buffer;
   }
   else
-    return NULL;
+    return strdup("");
 }
 
 static int storebuffer(int output, FILE *data)
 {
   char **buffer = (char **)data;
   **buffer = (char)output;
@@ -1195,13 +1143,13 @@
 
 #ifdef DPRINTF_DEBUG
 int main()
 {
   char buffer[129];
   char *ptr;
-#ifdef SIZEOF_LONG_LONG
+#if SIZEOF_LONG_LONG>0
   long long hullo;
   dprintf("%3$12s %1$s %2$qd %4$d\n", "daniel", hullo, "stenberg", 65);
 #endif
 
   mprintf("%3d %5d\n", 10, 1998);
   
@@ -1234,9 +1182,9 @@
 #endif
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: multi.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/netrc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/netrc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/netrc.c	2001-09-07 14:05:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/netrc.c	2002-05-22 06:23:06.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: netrc.c,v 1.16 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: netrc.c,v 1.20 2002/05/21 22:17:19 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -75,18 +75,21 @@
                     char *login,
                     char *password)
 {
   FILE *file;
   char netrcbuffer[256];
   int retcode=1;
+
+  int specific_login = (login[0] != 0);
   
   char *home = NULL; 
   int state=NOTHING;
 
-  char state_login=0;
-  char state_password=0;
+  char state_login=0;      /* Found a login keyword */
+  char state_password=0;   /* Found a password keyword */
+  char state_our_login=0;  /* With specific_login, found *our* login name */
 
 #define NETRC DOT_CHAR "netrc"
 
 #if defined(HAVE_GETPWUID) && defined(HAVE_GETEUID)
   struct passwd *pw;
   pw= getpwuid(geteuid());
@@ -113,19 +116,47 @@
       free(home);
     return -1;
   }
 
   sprintf(netrcbuffer, "%s%s%s", home, DIR_CHAR, NETRC);
 
+#ifdef MALLOCDEBUG
+  {
+    /* This is a hack to allow testing.
+     * If compiled with --enable-debug and CURL_DEBUG_NETRC is defined,
+     * then it's the path to a substitute .netrc for testing purposes *only* */
+
+    char *override = curl_getenv("CURL_DEBUG_NETRC");
+
+    if (override != NULL) {
+      printf("NETRC: overridden .netrc file: %s\n", home);
+
+      if (strlen(override)+1 > sizeof(netrcbuffer)) {
+        free(override);
+        if(NULL==pw)
+          free(home);
+
+        return -1;
+      }
+      strcpy(netrcbuffer, override);
+      free(override);
+    }
+  }
+#endif /* MALLOCDEBUG */
+
   file = fopen(netrcbuffer, "r");
   if(file) {
     char *tok;
 	char *tok_buf;
     while(fgets(netrcbuffer, sizeof(netrcbuffer), file)) {
       tok=strtok_r(netrcbuffer, " \t\n", &tok_buf);
       while(tok) {
+
+        if (login[0] && password[0])
+          goto done;
+
 	switch(state) {
 	case NOTHING:
 	  if(strequal("machine", tok)) {
 	    /* the next tok is the machine name, this is in itself the
 	       delimiter that starts the stuff entered for this machine,
 	       after this we need to search for 'login' and
@@ -146,39 +177,48 @@
 	    /* not our host */
 	    state=NOTHING;
 	  break;
 	case HOSTVALID:
 	  /* we are now parsing sub-keywords concerning "our" host */
 	  if(state_login) {
-	    strncpy(login, tok, LOGINSIZE-1);
+            if (specific_login) {
+              state_our_login = strequal(login, tok);
+            }else{
+              strncpy(login, tok, LOGINSIZE-1);
 #ifdef _NETRC_DEBUG
-	    printf("LOGIN: %s\n", login);
+	      printf("LOGIN: %s\n", login);
 #endif
+            }
 	    state_login=0;
 	  }
 	  else if(state_password) {
-	    strncpy(password, tok, PASSWORDSIZE-1);
-#if _NETRC_DEBUG
-	    printf("PASSWORD: %s\n", password);
+            if (state_our_login || !specific_login) {
+              strncpy(password, tok, PASSWORDSIZE-1);
+#ifdef _NETRC_DEBUG
+              printf("PASSWORD: %s\n", password);
 #endif
+            }
 	    state_password=0;
 	  }
 	  else if(strequal("login", tok))
 	    state_login=1;
 	  else if(strequal("password", tok))
 	    state_password=1;
 	  else if(strequal("machine", tok)) {
 	    /* ok, there's machine here go => */
 	    state = HOSTFOUND;
+            state_our_login = 0;
 	  }
 	  break;
 	} /* switch (state) */
+
 	tok = strtok_r(NULL, " \t\n", &tok_buf);
       } /* while (tok) */
     } /* while fgets() */
 
+done:
     fclose(file);
   }
 
   if(NULL==pw)
     free(home);
 
@@ -203,9 +243,9 @@
 #endif
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/netrc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/netrc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/netrc.h	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/netrc.h	2002-05-22 06:23:06.000000000 +0800
@@ -4,25 +4,30 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: netrc.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
+ * $Id: netrc.h,v 1.7 2002/05/21 22:17:19 bagder Exp $
  *****************************************************************************/
 int Curl_parsenetrc(char *host,
                     char *login,
                     char *password);
+  /* Assume: password[0]=0, host[0] != 0.
+   * If login[0] = 0, search for login and password within a machine section
+   * in the netrc.
+   * If login[0] != 0, search for password within machine and login.
+   */
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/progress.c	2001-09-07 14:05:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/progress.c	2002-06-03 20:46:04.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: progress.c,v 1.30 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: progress.c,v 1.40 2002/06/03 12:46:04 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
@@ -42,12 +42,16 @@
 #include <curl/curl.h>
 #include "urldata.h"
 #include "sendf.h"
 
 #include "progress.h"
 
+#define _MPRINTF_REPLACE /* use our functions only */
+#include <curl/mprintf.h>
+
+
 static void time2str(char *r, int t)
 {
   int h = (t/3600);
   int m = (t-(h*3600))/60;
   int s = (t-(h*3600)-(m*60));
   sprintf(r,"%2d:%02d:%02d",h,m,s);
@@ -67,13 +71,13 @@
   if(bytes < (9999*ONE_KILOBYTE)) {
     sprintf(max5, "%4dk", (int)bytes/ONE_KILOBYTE);
     return max5;
   }
   if(bytes < (100*ONE_MEGABYTE)) {
     /* 'XX.XM' is good as long as we're less than 100 megs */
-    sprintf(max5, "%2.1fM", bytes/ONE_MEGABYTE);
+    sprintf(max5, "%4.1fM", bytes/ONE_MEGABYTE);
     return max5;
   }
   sprintf(max5, "%4dM", (int)bytes/ONE_MEGABYTE);
   return max5;
 }
 
@@ -100,41 +104,56 @@
     if(!data->progress.callback)
       /* only output if we don't use progress callback */
       fprintf(data->set.err, "\n");
   }
 }
 
+/* reset all times except redirect */
+void Curl_pgrsResetTimes(struct SessionHandle *data)
+{
+  data->progress.t_nslookup = 0.0;
+  data->progress.t_connect = 0.0;
+  data->progress.t_pretransfer = 0.0;
+  data->progress.t_starttransfer = 0.0;
+}
+
 void Curl_pgrsTime(struct SessionHandle *data, timerid timer)
 {
   switch(timer) {
   default:
   case TIMER_NONE:
     /* mistake filter */
     break;
   case TIMER_STARTSINGLE:
-    /* This is set at the start of a single fetch, there may be several
-       fetches within an operation, why we add all other times relative
-       to this one */
+    /* This is set at the start of a single fetch */
     data->progress.t_startsingle = Curl_tvnow();
     break;
 
   case TIMER_NAMELOOKUP:
-    data->progress.t_nslookup += Curl_tvdiff(Curl_tvnow(),
-                                        data->progress.t_startsingle);
+    data->progress.t_nslookup =
+      (double)Curl_tvdiff(Curl_tvnow(), data->progress.t_startsingle)/1000.0;
     break;
   case TIMER_CONNECT:
-    data->progress.t_connect += Curl_tvdiff(Curl_tvnow(),
-                                       data->progress.t_startsingle);
+    data->progress.t_connect =
+      (double)Curl_tvdiff(Curl_tvnow(), data->progress.t_startsingle)/1000.0;
     break;
   case TIMER_PRETRANSFER:
-    data->progress.t_pretransfer += Curl_tvdiff(Curl_tvnow(),
-                                           data->progress.t_startsingle);
+    data->progress.t_pretransfer =
+      (double)Curl_tvdiff(Curl_tvnow(), data->progress.t_startsingle)/1000.0;
+    break;
+  case TIMER_STARTTRANSFER:
+    data->progress.t_starttransfer =
+      (double)Curl_tvdiff(Curl_tvnow(), data->progress.t_startsingle)/1000.0;
     break;
   case TIMER_POSTRANSFER:
     /* this is the normal end-of-transfer thing */
     break;
+  case TIMER_REDIRECT:
+    data->progress.t_redirect =
+      (double)Curl_tvdiff(Curl_tvnow(), data->progress.start)/1000.0;
+    break;
   }
 }
 
 void Curl_pgrsStartNow(struct SessionHandle *data)
 {
   data->progress.speeder_c = 0; /* reset the progress meter display */
@@ -184,18 +203,20 @@
   double dlpercen=0;
   double ulpercen=0;
   double total_percen=0;
 
   double total_transfer;
   double total_expected_transfer;
+  double timespent;
 
   struct SessionHandle *data = conn->data;
 
   int nowindex = data->progress.speeder_c% CURR_TIME;
   int checkindex;
-  int count;
+
+  int countindex; /* amount of seconds stored in the speeder array */
 
   char time_left[10];
   char time_total[10];
   char time_current[10];
       
   double ulestimate=0;
@@ -219,74 +240,112 @@
     }
     data->progress.flags |= PGRS_HEADERS_OUT; /* headers are shown */
   }
 
   now = Curl_tvnow(); /* what time is it */
 
-  /* The exact time spent so far */
-  data->progress.timespent = Curl_tvdiff (now, data->progress.start);
+  /* The exact time spent so far (from the start) */
+  timespent = (double)Curl_tvdiff (now, data->progress.start)/1000;
+
+  data->progress.timespent = timespent;
 
   /* The average download speed this far */
-  data->progress.dlspeed = data->progress.downloaded/(data->progress.timespent!=0.0?data->progress.timespent:1.0);
+  data->progress.dlspeed =
+    data->progress.downloaded/(timespent>0.01?timespent:1);
 
   /* The average upload speed this far */
-  data->progress.ulspeed = data->progress.uploaded/(data->progress.timespent!=0.0?data->progress.timespent:1.0);
+  data->progress.ulspeed =
+    data->progress.uploaded/(timespent>0.01?timespent:1);
 
   if(data->progress.lastshow == Curl_tvlong(now))
     return 0; /* never update this more than once a second if the end isn't 
                  reached */
   data->progress.lastshow = now.tv_sec;
 
   /* Let's do the "current speed" thing, which should use the fastest
-         of the dl/ul speeds */
+     of the dl/ul speeds. Store the fasted speed at entry 'nowindex'. */
   data->progress.speeder[ nowindex ] =
     data->progress.downloaded>data->progress.uploaded?
     data->progress.downloaded:data->progress.uploaded;
-  data->progress.speeder_c++; /* increase */
-  count = ((data->progress.speeder_c>=CURR_TIME)?
-           CURR_TIME:data->progress.speeder_c) - 1;
-  checkindex = (data->progress.speeder_c>=CURR_TIME)?
-    data->progress.speeder_c%CURR_TIME:0;
-
-  /* find out the average speed the last CURR_TIME seconds */
-  data->progress.current_speed =
-    (data->progress.speeder[nowindex]-
-     data->progress.speeder[checkindex])/(count?count:1);
+
+  /* remember the exact time for this moment */
+  data->progress.speeder_time [ nowindex ] = now;
+
+  /* advance our speeder_c counter, which is increased every time we get
+     here and we expect it to never wrap as 2^32 is a lot of seconds! */
+  data->progress.speeder_c++;
+
+  /* figure out how many index entries of data we have stored in our speeder
+     array. With N_ENTRIES filled in, we have about N_ENTRIES-1 seconds of
+     transfer. Imagine, after one second we have filled in two entries,
+     after two seconds we've filled in three entries etc. */
+  countindex = ((data->progress.speeder_c>=CURR_TIME)?
+                CURR_TIME:data->progress.speeder_c) - 1;
+
+  /* first of all, we don't do this if there's no counted seconds yet */
+  if(countindex) {
+    long span_ms;
+
+    /* Get the index position to compare with the 'nowindex' position.
+       Get the oldest entry possible. While we have less than CURR_TIME
+       entries, the first entry will remain the oldest. */
+    checkindex = (data->progress.speeder_c>=CURR_TIME)?
+      data->progress.speeder_c%CURR_TIME:0;
+
+    /* Figure out the exact time for the time span */
+    span_ms = Curl_tvdiff(now,
+                          data->progress.speeder_time[checkindex]);
+    if(0 == span_ms)
+      span_ms=1; /* at least one millisecond MUST have passed */
+
+    /* Calculate the average speed the last 'countindex' seconds */
+    data->progress.current_speed =
+      (data->progress.speeder[nowindex]-
+       data->progress.speeder[checkindex])/((double)span_ms/1000);
+  }
+  else
+    /* the first second we use the main average */
+    data->progress.current_speed =
+      (data->progress.ulspeed>data->progress.dlspeed)?
+      data->progress.ulspeed:data->progress.dlspeed;
 
   if(data->progress.flags & PGRS_HIDE)
     return 0;
+
   else if(data->set.fprogress) {
+    /* There's a callback set, so we call that instead of writing
+       anything ourselves. This really is the way to go. */
     result= data->set.fprogress(data->set.progress_client,
                                 data->progress.size_dl,
                                 data->progress.downloaded,
                                 data->progress.size_ul,
                                 data->progress.uploaded);
     if(result)
       failf(data, "Callback aborted");
     return result;
   }
 
-      /* Figure out the estimated time of arrival for the upload */
+  /* Figure out the estimated time of arrival for the upload */
   if((data->progress.flags & PGRS_UL_SIZE_KNOWN) && data->progress.ulspeed){
     ulestimate = data->progress.size_ul / data->progress.ulspeed;
     ulpercen = (data->progress.uploaded / data->progress.size_ul)*100;
   }
 
   /* ... and the download */
   if((data->progress.flags & PGRS_DL_SIZE_KNOWN) && data->progress.dlspeed) {
     dlestimate = data->progress.size_dl / data->progress.dlspeed;
     dlpercen = (data->progress.downloaded / data->progress.size_dl)*100;
   }
     
   /* Now figure out which of them that is slower and use for the for
-         total estimate! */
+     total estimate! */
   total_estimate = ulestimate>dlestimate?ulestimate:dlestimate;
 
 
   /* If we have a total estimate, we can display that and the expected
-         time left */
+     time left */
   if(total_estimate) {
     time2str(time_left, total_estimate-(int) data->progress.timespent); 
     time2str(time_total, total_estimate);
   }
   else {
     /* otherwise we blank those times */
@@ -334,9 +393,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/progress.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/progress.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/progress.h	2001-08-31 06:54:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/progress.h	2002-04-16 15:59:20.000000000 +0800
@@ -4,48 +4,51 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: progress.h,v 1.13 2001/08/30 22:48:34 bagder Exp $
+ * $Id: progress.h,v 1.16 2002/04/16 07:59:20 bagder Exp $
  *****************************************************************************/
 
 #include "timeval.h"
 
 
 typedef enum {
   TIMER_NONE,
   TIMER_NAMELOOKUP,
   TIMER_CONNECT,
   TIMER_PRETRANSFER,
+  TIMER_STARTTRANSFER,
   TIMER_POSTRANSFER,
   TIMER_STARTSINGLE,
+  TIMER_REDIRECT,
   TIMER_LAST /* must be last */
 } timerid;
   
 void Curl_pgrsDone(struct connectdata *);
 void Curl_pgrsStartNow(struct SessionHandle *data);
 void Curl_pgrsSetDownloadSize(struct SessionHandle *data, double size);
 void Curl_pgrsSetUploadSize(struct SessionHandle *data, double size);
 void Curl_pgrsSetDownloadCounter(struct SessionHandle *data, double size);
 void Curl_pgrsSetUploadCounter(struct SessionHandle *data, double size);
 int Curl_pgrsUpdate(struct connectdata *);
+void Curl_pgrsResetTimes(struct SessionHandle *data);
 void Curl_pgrsTime(struct SessionHandle *data, timerid timer);
 
 
 /* Don't show progress for sizes smaller than: */
 #define LEAST_SIZE_PROGRESS BUFSIZE
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/security.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/security.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/security.c	2001-09-07 14:05:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/security.c	2002-06-11 17:09:59.000000000 +0800
@@ -37,12 +37,13 @@
  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.  */
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_FTP
 #ifdef KRB4
 
 #define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "security.h"
@@ -359,17 +360,17 @@
     buf = aprintf(fmt, ap);
     len = (conn->mech->encode)(conn->app_data, buf, strlen(buf),
                                conn->command_prot, &enc,
                                conn);
     free(buf);
     if(len < 0) {
-	failf(conn->data, "Failed to encode command.\n");
+	failf(conn->data, "Failed to encode command.");
 	return -1;
     }
     if(Curl_base64_encode(enc, len, &buf) < 0){
-      failf(conn->data, "Out of memory base64-encoding.\n");
+      failf(conn->data, "Out of memory base64-encoding.");
       return -1;
     }
     if(conn->command_prot == prot_safe)
 	ret = fprintf(f, "MIC %s", buf);
     else if(conn->command_prot == prot_private)
 	ret = fprintf(f, "ENC %s", buf);
@@ -410,40 +411,41 @@
   if(!conn->sec_complete){
     infof(conn->data, "No security data exchange has taken place.\n");
     return -1;
   }
 
   if(level){
-    Curl_ftpsendf(conn->firstsocket, conn,
-                  "PBSZ %u", s);
-    /* wait for feedback */
-    nread = Curl_GetFTPResponse(conn->firstsocket,
-                                conn->data->state.buffer, conn, NULL);
+    if(Curl_ftpsendf(conn, "PBSZ %u", s))
+      return -1;
+
+    nread = Curl_GetFTPResponse(conn->data->state.buffer, conn, NULL);
     if(nread < 0)
-      return /*CURLE_OPERATION_TIMEOUTED*/-1;
-    if(/*ret != COMPLETE*/conn->data->state.buffer[0] != '2'){
-      failf(conn->data, "Failed to set protection buffer size.\n");
+      return -1;
+
+    if(conn->data->state.buffer[0] != '2'){
+      failf(conn->data, "Failed to set protection buffer size.");
       return -1;
     }
     conn->buffer_size = s;
-    p = strstr(/*reply_string*/conn->data->state.buffer, "PBSZ=");
+
+    p = strstr(conn->data->state.buffer, "PBSZ=");
     if(p)
       sscanf(p, "PBSZ=%u", &s);
     if(s < conn->buffer_size)
       conn->buffer_size = s;
   }
 
-  Curl_ftpsendf(conn->firstsocket, conn,
-                "PROT %c", level["CSEP"]);
-  /* wait for feedback */
-  nread = Curl_GetFTPResponse(conn->firstsocket,
-                              conn->data->state.buffer, conn, NULL);
+  if(Curl_ftpsendf(conn, "PROT %c", level["CSEP"]))
+    return -1;
+
+  nread = Curl_GetFTPResponse(conn->data->state.buffer, conn, NULL);
   if(nread < 0)
-    return /*CURLE_OPERATION_TIMEOUTED*/-1;
-  if(/*ret != COMPLETE*/conn->data->state.buffer[0] != '2'){
-    failf(conn->data, "Failed to set protection level.\n");
+    return -1;
+
+  if(conn->data->state.buffer[0] != '2'){
+    failf(conn->data, "Failed to set protection level.");
     return -1;
   }
     
   conn->data_prot = (enum protection_level)level;
   return 0;
 }
@@ -470,12 +472,13 @@
 Curl_sec_login(struct connectdata *conn)
 {
   int ret;
   struct Curl_sec_client_mech **m;
   ssize_t nread;
   struct SessionHandle *data=conn->data;
+  int ftpcode;
 
   for(m = mechs; *m && (*m)->name; m++) {
     void *tmp;
 
     tmp = realloc(conn->app_data, (*m)->size);
     if (tmp == NULL) {
@@ -486,37 +489,41 @@
 	    
     if((*m)->init && (*(*m)->init)(conn->app_data) != 0) {
       infof(data, "Skipping %s...\n", (*m)->name);
       continue;
     }
     infof(data, "Trying %s...\n", (*m)->name);
-    /*ret = command("AUTH %s", (*m)->name);***/
-    Curl_ftpsendf(conn->firstsocket, conn,
-                  "AUTH %s", (*m)->name);
-    /* wait for feedback */
-    nread = Curl_GetFTPResponse(conn->firstsocket,
-                                conn->data->state.buffer, conn, NULL);
+
+    if(Curl_ftpsendf(conn, "AUTH %s", (*m)->name))
+      return -1;
+
+    nread = Curl_GetFTPResponse(conn->data->state.buffer, conn, &ftpcode);
     if(nread < 0)
-      return /*CURLE_OPERATION_TIMEOUTED*/-1;
-    if(/*ret != CONTINUE*/conn->data->state.buffer[0] != '3'){
-      if(/*code == 504*/strncmp(conn->data->state.buffer,"504",3) == 0) {
+      return -1;
+
+    if(conn->data->state.buffer[0] != '3'){
+      switch(ftpcode) {
+      case 504:
         infof(data,
               "%s is not supported by the server.\n", (*m)->name);
-      }
-      else if(/*code == 534*/strncmp(conn->data->state.buffer,"534",3) == 0) {
+        break;
+      case 534:
         infof(data, "%s rejected as security mechanism.\n", (*m)->name);
-      }
-      else if(/*ret == ERROR*/conn->data->state.buffer[0] == '5') {
-        infof(data, "The server doesn't support the FTP "
-              "security extensions.\n");
-        return -1;
+        break;
+      default:
+        if(conn->data->state.buffer[0] == '5') {
+          infof(data, "The server doesn't support the FTP "
+                "security extensions.\n");
+          return -1;
+        }
+        break;
       }
       continue;
     }
 
-    ret = (*(*m)->auth)(conn->app_data, /*host***/conn);
+    ret = (*(*m)->auth)(conn->app_data, conn);
 	
     if(ret == AUTH_CONTINUE)
       continue;
     else if(ret != AUTH_OK){
       /* mechanism is supposed to output error string */
       return -1;
@@ -543,14 +550,15 @@
   conn->sec_complete = 0;
   conn->data_prot = (enum protection_level)0;
   conn->mech=NULL;
 }
 
 #endif /* KRB4 */
+#endif /* CURL_DISABLE_FTP */
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/security.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/security.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/security.h	2001-08-17 18:14:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/security.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: security.h,v 1.5 2001/08/17 10:14:06 bagder Exp $
+ * $Id: security.h,v 1.6 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 /* this is a re-write */
 
 #include <stdarg.h>
 #include "urldata.h"  /* for struct connectdata * */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/sendf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/sendf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/sendf.c	2001-09-07 14:05:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/sendf.c	2002-05-06 21:33:39.000000000 +0800
@@ -2,33 +2,42 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.c,v 1.29 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: sendf.c,v 1.50 2002/05/04 15:36:07 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdarg.h>
 #include <stdlib.h>
+#include <errno.h>
+
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#ifdef HAVE_SYS_SOCKET_H
+#include <sys/socket.h>	/* required for send() & recv() prototypes */
+#endif
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #if defined(WIN32) && !defined(__GNUC__) || defined(__MINGW32__)
 #include <winsock.h>
@@ -123,98 +132,145 @@
 /* Curl_infof() is for info message along the way */
 
 void Curl_infof(struct SessionHandle *data, const char *fmt, ...)
 {
   va_list ap;
   if(data->set.verbose) {
+    char print_buffer[1024 + 1];
     va_start(ap, fmt);
-    fputs("* ", data->set.err);
-    vfprintf(data->set.err, fmt, ap);
+    vsnprintf(print_buffer, 1024, fmt, ap);
     va_end(ap);
+    Curl_debug(data, CURLINFO_TEXT, print_buffer, strlen(print_buffer));
   }
 }
 
-/* Curl_failf() is for messages stating why we failed, the LAST one will be
-   returned for the user (if requested) */
+/* Curl_failf() is for messages stating why we failed.
+ * The message SHALL NOT include any LF or CR.
+ */
 
 void Curl_failf(struct SessionHandle *data, const char *fmt, ...)
 {
   va_list ap;
   va_start(ap, fmt);
-  if(data->set.errorbuffer)
+  if(data->set.errorbuffer && !data->state.errorbuf) {
     vsnprintf(data->set.errorbuffer, CURL_ERROR_SIZE, fmt, ap);
+    data->state.errorbuf = TRUE; /* wrote error string */
+  }
   va_end(ap);
 }
 
 /* Curl_sendf() sends formated data to the server */
-size_t Curl_sendf(int sockfd, struct connectdata *conn,
-                  const char *fmt, ...)
+CURLcode Curl_sendf(int sockfd, struct connectdata *conn,
+                    const char *fmt, ...)
 {
   struct SessionHandle *data = conn->data;
-  size_t bytes_written;
+  ssize_t bytes_written;
+  ssize_t write_len;
+  CURLcode res;
   char *s;
+  char *sptr;
   va_list ap;
   va_start(ap, fmt);
   s = vaprintf(fmt, ap); /* returns an allocated string */
   va_end(ap);
   if(!s)
-    return 0; /* failure */
-  if(data->set.verbose)
-    fprintf(data->set.err, "> %s", s);
+    return CURLE_OUT_OF_MEMORY; /* failure */
+
+  bytes_written=0;
+  write_len = strlen(s);
+  sptr = s;
+
+  do {
+    /* Write the buffer to the socket */
+    res = Curl_write(conn, sockfd, sptr, write_len, &bytes_written);
+
+    if(CURLE_OK != res)
+      break;
+
+    if(data->set.verbose)
+      Curl_debug(data, CURLINFO_DATA_OUT, sptr, bytes_written);
+
+    if(bytes_written != write_len) {
+      /* if not all was written at once, we must advance the pointer, decrease
+         the size left and try again! */
+      write_len -= bytes_written;
+      sptr += bytes_written;
+    }
+    else
+      break;
 
-  /* Write the buffer to the socket */
-  Curl_write(conn, sockfd, s, strlen(s), &bytes_written);
+  } while(1);
 
   free(s); /* free the output string */
 
-  return bytes_written;
+  return res;
 }
 
 /*
  * Curl_write() is an internal write function that sends plain (binary) data
  * to the server. Works with plain sockets, SSL or kerberos.
  *
  */
 CURLcode Curl_write(struct connectdata *conn, int sockfd,
                     void *mem, size_t len,
-                    size_t *written)
+                    ssize_t *written)
 {
-  size_t bytes_written;
+  ssize_t bytes_written;
 
 #ifdef USE_SSLEAY
   /* SSL_write() is said to return 'int' while write() and send() returns
      'size_t' */
-  int ssl_bytes;
   if (conn->ssl.use) {
-    int loop=100; /* just a precaution to never loop endlessly */
-    while(loop--) {
-      ssl_bytes = SSL_write(conn->ssl.handle, mem, len);
-      if((0 >= ssl_bytes) ||
-         (SSL_ERROR_WANT_WRITE != SSL_get_error(conn->ssl.handle,
-                                                ssl_bytes) )) {
-        /* this converts from signed to unsigned... */
-        bytes_written = ssl_bytes;
-        break;
+    int err;
+    int rc = SSL_write(conn->ssl.handle, mem, len);
+
+    if(rc < 0) {
+      err = SSL_get_error(conn->ssl.handle, rc);
+    
+      switch(err) {
+      case SSL_ERROR_WANT_READ:
+      case SSL_ERROR_WANT_WRITE:
+        /* this is basicly the EWOULDBLOCK equivalent */
+        *written = 0;
+        return CURLE_OK;
       }
+      /* a true error */
+      failf(conn->data, "SSL_write() return error %d\n", err);
+      return CURLE_SEND_ERROR;
     }
+    bytes_written = rc;
   }
   else {
 #endif
 #ifdef KRB4
     if(conn->sec_complete) {
       bytes_written = Curl_sec_write(conn, sockfd, mem, len);
     }
     else
 #endif /* KRB4 */
+    {
       bytes_written = swrite(sockfd, mem, len);
+    }
+    if(-1 == bytes_written) {
+#ifdef WIN32
+      if(WSAEWOULDBLOCK == GetLastError())
+#else
+      if(EWOULDBLOCK == errno)
+#endif
+      {
+        /* this is just a case of EWOULDBLOCK */
+        *written=0;
+        return CURLE_OK;
+      }
+    }
 #ifdef USE_SSLEAY
   }
 #endif
 
   *written = bytes_written;
-  return CURLE_OK;
+  return (-1 != bytes_written)?CURLE_OK:CURLE_SEND_ERROR;
 }
 
 /* client_write() sends data to the write callback(s)
 
    The bit pattern defines to what "streams" to write to. Body and/or header.
    The defines are in sendf.h of course.
@@ -252,50 +308,107 @@
     }
   }
   
   return CURLE_OK;
 }
 
-
 /*
  * Internal read-from-socket function. This is meant to deal with plain
  * sockets, SSL sockets and kerberos sockets.
+ *
+ * If the read would block (EWOULDBLOCK) we return -1. Otherwise we return
+ * a regular CURLcode value.
  */
-CURLcode Curl_read(struct connectdata *conn, int sockfd,
-                   char *buf, size_t buffersize,
-                   ssize_t *n)
+int Curl_read(struct connectdata *conn,
+              int sockfd,
+              char *buf,
+              size_t buffersize,
+              ssize_t *n)
 {
   ssize_t nread;
 
 #ifdef USE_SSLEAY
   if (conn->ssl.use) {
-    int loop=100; /* just a precaution to never loop endlessly */
-    while(loop--) {
+    bool loop=TRUE;
+    int err;
+    do {
       nread = SSL_read(conn->ssl.handle, buf, buffersize);
-      if((-1 != nread) ||
-         (SSL_ERROR_WANT_READ != SSL_get_error(conn->ssl.handle, nread) ))
+
+      if(nread >= 0)
+        /* successful read */
         break;
-    }
+
+      err = SSL_get_error(conn->ssl.handle, nread);
+
+      switch(err) {
+      case SSL_ERROR_NONE: /* this is not an error */
+      case SSL_ERROR_ZERO_RETURN: /* no more data */
+        loop=0; /* get out of loop */
+        break;
+      case SSL_ERROR_WANT_READ:
+      case SSL_ERROR_WANT_WRITE:
+        /* if there's data pending, then we re-invoke SSL_read() */
+        break;
+      default:
+        failf(conn->data, "SSL read error: %d", err);
+        return CURLE_RECV_ERROR;
+      }
+    } while(loop);
+    if(loop && SSL_pending(conn->ssl.handle))
+      return -1; /* basicly EWOULDBLOCK */
   }
   else {
 #endif
 #ifdef KRB4
     if(conn->sec_complete)
       nread = Curl_sec_read(conn, sockfd, buf, buffersize);
     else
 #endif
       nread = sread (sockfd, buf, buffersize);
+
+    if(-1 == nread) {
+#ifdef WIN32
+      if(WSAEWOULDBLOCK == GetLastError())
+#else
+      if(EWOULDBLOCK == errno)
+#endif
+        return -1;
+    }
+
 #ifdef USE_SSLEAY
   }
 #endif /* USE_SSLEAY */
   *n = nread;
   return CURLE_OK;
 }
 
+/* return 0 on success */
+int Curl_debug(struct SessionHandle *data, curl_infotype type,
+               char *ptr, size_t size)
+{
+  static const char * const s_infotype[CURLINFO_END] = {
+    "* ", "< ", "> ", "{ ", "} " };
+
+  if(data->set.fdebug)
+    return (*data->set.fdebug)(data, type, ptr, size,
+                               data->set.debugdata);
+
+  switch(type) {
+  case CURLINFO_TEXT:
+  case CURLINFO_HEADER_OUT:
+    fwrite(s_infotype[type], 2, 1, data->set.err);
+    fwrite(ptr, size, 1, data->set.err);
+    break;
+  default: /* nada */
+    break;
+  }
+  return 0;
+}
+
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/sendf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/sendf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/sendf.h	2001-08-31 06:54:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/sendf.h	2002-04-12 15:21:11.000000000 +0800
@@ -4,29 +4,29 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.h,v 1.13 2001/08/30 22:48:34 bagder Exp $
+ * $Id: sendf.h,v 1.18 2002/04/12 07:21:11 bagder Exp $
  *****************************************************************************/
 
-size_t Curl_sendf(int fd, struct connectdata *, const char *fmt, ...);
+CURLcode Curl_sendf(int fd, struct connectdata *, const char *fmt, ...);
 void Curl_infof(struct SessionHandle *, const char *fmt, ...);
 void Curl_failf(struct SessionHandle *, const char *fmt, ...);
 
 #define infof Curl_infof
 #define failf Curl_failf
 
@@ -42,15 +42,20 @@
 #define CLIENTWRITE_BOTH   (CLIENTWRITE_BODY|CLIENTWRITE_HEADER)
 
 CURLcode Curl_client_write(struct SessionHandle *data, int type, char *ptr,
                            size_t len);
 
 /* internal read-function, does plain socket, SSL and krb4 */
-CURLcode Curl_read(struct connectdata *conn, int sockfd,
-                   char *buf, size_t buffersize,
-                   ssize_t *n);
+int Curl_read(struct connectdata *conn, int sockfd,
+              char *buf, size_t buffersize,
+              ssize_t *n);
 /* internal write-function, does plain socket, SSL and krb4 */
 CURLcode Curl_write(struct connectdata *conn, int sockfd,
                     void *mem, size_t len,
-                    size_t *written);
+                    ssize_t *written);
+
+/* the function used to output verbose information */
+int Curl_debug(struct SessionHandle *handle, curl_infotype type,
+               char *data, size_t size);
+
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/setup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/setup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/setup.h	2001-08-24 15:24:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/setup.h	2002-06-11 19:13:01.000000000 +0800
@@ -4,29 +4,39 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: setup.h,v 1.13 2001/08/24 07:24:34 bagder Exp $
+ * $Id: setup.h,v 1.23 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
 
-
+/* MN 06/07/02 */
+/* #define HTTP_ONLY
+*/
+#ifdef HTTP_ONLY
+#define CURL_DISABLE_FTP
+#define CURL_DISABLE_LDAP
+#define CURL_DISABLE_TELNET
+#define CURL_DISABLE_DICT
+#define CURL_DISABLE_FILE
+#define CURL_DISABLE_GOPHER
+#endif
 
 #if !defined(WIN32) && defined(_WIN32)
 /* This _might_ be a good Borland fix. Please report whether this works or
    not! */
 #define WIN32
 #endif
@@ -38,19 +48,25 @@
 #else
 #include "config.h" /* the configure script results */
 #endif
 
 #else
 #ifdef WIN32
-/* include the hand-modified win32 adjusted config.h! */
-#include "../config-win32.h"
+/* hand-modified win32 config.h! */
+#include "config-win32.h"
+#endif
+#ifdef macintosh
+/* hand-modified MacOS config.h! */
+#include "config-mac.h"
 #endif
+
 #endif
 
 #ifndef __cplusplus        /* (rabe) */
-typedef char bool;
+typedef unsigned char bool;
+#define typedef_bool
 #endif                     /* (rabe) */
 
 #ifdef NEED_REENTRANT
 /* Solaris machines needs _REENTRANT set for a few function prototypes and
    things to appear in the #include files. We need to #define it before all
    #include files */
@@ -85,17 +101,18 @@
 #endif
 
 #ifndef STDC_HEADERS /* no standard C headers! */
 #ifdef	VMS
 #include "../include/curl/stdcheaders.h"
 #else
-#include "curl/stdcheaders.h"
+#include <curl/stdcheaders.h>
 #endif
+
 #else
 #ifdef _AIX
-#include "curl/stdcheaders.h"
+#include <curl/stdcheaders.h>
 #endif
 #endif
 
 /* Below we define four functions. They should
    1. close a socket
    2. read from a socket
@@ -107,30 +124,30 @@
 
 #ifdef WIN32
 #if !defined(__GNUC__) || defined(__MINGW32__)
 #define sclose(x) closesocket(x)
 #define sread(x,y,z) recv(x,y,z,0)
 #define swrite(x,y,z) (size_t)send(x,y,z,0)
-#define myalarm(x) /* win32 is a silly system */
+#undef HAVE_ALARM
 #else
      /* gcc-for-win is still good :) */
 #define sclose(x) close(x)
 #define sread(x,y,z) recv(x,y,z,0)
 #define swrite(x,y,z) send(x,y,z,0)
-#define myalarm(x) alarm(x)
+#define HAVE_ALARM
 #endif
 
 #define PATH_CHAR     ";"
 #define DIR_CHAR      "\\"
 #define DOT_CHAR      "_"
 
 #else
 #define sclose(x) close(x)
-#define sread(x,y,z) read(x,y,z)
-#define swrite(x,y,z) write(x,y,z)
-#define myalarm(x) alarm(x)
+#define sread(x,y,z) recv(x,y,z,0)
+#define swrite(x,y,z) send(x,y,z,0)
+#define HAVE_ALARM
 
 #define PATH_CHAR     ":"
 #define DIR_CHAR      "/"
 #define DOT_CHAR      "."
 
 #ifdef HAVE_STRCASECMP
@@ -141,7 +158,22 @@
 int fileno( FILE *stream);
 #endif
 #endif
 
 #endif
 
+/*
+ * Curl_addrinfo MUST be used for name resolving information.
+ * Information regarding a single IP witin a Curl_addrinfo MUST be stored in
+ * a Curl_ipconnect struct.
+ */
+#ifdef ENABLE_IPV6
+typedef struct addrinfo Curl_addrinfo;
+typedef struct addrinfo Curl_ipconnect;
+#else
+typedef struct hostent Curl_addrinfo;
+typedef struct in_addr Curl_ipconnect;
+#endif
+
+
+
 #endif /* __CONFIG_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/speedcheck.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/speedcheck.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/speedcheck.c	2001-09-07 14:05:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/speedcheck.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: speedcheck.c,v 1.11 2001/09/07 04:01:32 bumblebury Exp $
+ * $Id: speedcheck.c,v 1.14 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <string.h>
@@ -48,13 +48,14 @@
      (data->progress.current_speed < data->set.low_speed_limit)) {
 
     /* We are now below the "low speed limit". If we are below it
        for "low speed time" seconds we consider that enough reason
        to abort the download. */
     
-    if( Curl_tvdiff(now, data->state.keeps_speed) > data->set.low_speed_time) {
+    if( (Curl_tvdiff(now, data->state.keeps_speed)/1000) >
+        data->set.low_speed_time) {
       /* we have been this slow for long enough, now die */
       failf(data,
 	    "Operation too slow. "
 	    "Less than %d bytes/sec transfered the last %d seconds",
 	    data->set.low_speed_limit,
 	    data->set.low_speed_time);
@@ -69,9 +70,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/speedcheck.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/speedcheck.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/speedcheck.h	2001-08-31 06:54:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/speedcheck.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: speedcheck.h,v 1.8 2001/08/30 22:48:34 bagder Exp $
+ * $Id: speedcheck.h,v 1.9 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include "timeval.h"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ssluse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ssluse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ssluse.c	2001-09-20 05:49:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ssluse.c	2002-06-10 21:24:15.000000000 +0800
@@ -2,34 +2,35 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.c,v 1.38 2001/09/19 21:49:11 bagder Exp $
+ * $Id: ssluse.c,v 1.53 2002/06/10 12:38:10 bagder Exp $
  *****************************************************************************/
 
 /*
- * The original SSL code was written by
+ * The original SSL code for curl was written by
  * Linas Vepstas <linas@linas.org> and Sampo Kellomaki <sampo@iki.fi>
  */
 
 #include "setup.h"
+
 #include <string.h>
 #include <stdlib.h>
 
 #include "urldata.h"
 #include "sendf.h"
 #include "formdata.h" /* for the boundary function */
@@ -39,18 +40,33 @@
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x0090581fL
+#define HAVE_SSL_GET1_SESSION 1
+#else
+#undef HAVE_SSL_GET1_SESSION
+#endif
+
 #if OPENSSL_VERSION_NUMBER >= 0x00904100L
 #define HAVE_USERDATA_IN_PWD_CALLBACK 1
 #else
 #undef HAVE_USERDATA_IN_PWD_CALLBACK
 #endif
 
+#if OPENSSL_VERSION_NUMBER >= 0x00907001L
+/* ENGINE_load_private_key() takes four arguments */
+#define HAVE_ENGINE_LOAD_FOUR_ARGS
+#else
+/* ENGINE_load_private_key() takes three arguments */
+#undef HAVE_ENGINE_LOAD_FOUR_ARGS
+#endif
+
+
 #ifndef HAVE_USERDATA_IN_PWD_CALLBACK
 static char global_passwd[64];
 #endif
 
 static int passwd_callback(char *buf, int num, int verify
 #if HAVE_USERDATA_IN_PWD_CALLBACK
@@ -70,16 +86,14 @@
     }
   }  
   return 0;
 }
 
 static
-bool seed_enough(struct connectdata *conn, /* unused for now */
-                 int nread)
+bool seed_enough(int nread)
 {
-  conn = NULL; /* to prevent compiler warnings */
 #ifdef HAVE_RAND_STATUS
   nread = 0; /* to prevent compiler warnings */
 
   /* only available in OpenSSL 0.9.5a and later */
   if(RAND_status())
     return TRUE;
@@ -89,17 +103,16 @@
     return TRUE;
 #endif
   return FALSE; /* not enough */
 }
 
 static
-int random_the_seed(struct connectdata *conn)
+int random_the_seed(struct SessionHandle *data)
 {
-  char *buf = conn->data->state.buffer; /* point to the big buffer */
+  char *buf = data->state.buffer; /* point to the big buffer */
   int nread=0;
-  struct SessionHandle *data=conn->data;
 
   /* Q: should we add support for a random file name as a libcurl option?
      A: Yes, it is here */
 
 #ifndef RANDOM_FILE
   /* if RANDOM_FILE isn't defined, we only perform this if an option tells
@@ -109,13 +122,13 @@
 #endif
   {
     /* let the option override the define */
     nread += RAND_load_file((data->set.ssl.random_file?
                              data->set.ssl.random_file:RANDOM_FILE),
                             16384);
-    if(seed_enough(conn, nread))
+    if(seed_enough(nread))
       return nread;
   }
 
 #if defined(HAVE_RAND_EGD)
   /* only available in OpenSSL 0.9.5 and later */
   /* EGD_SOCKET is set at configure time or not at all */
@@ -128,13 +141,13 @@
   {
     /* If there's an option and a define, the option overrides the
        define */
     int ret = RAND_egd(data->set.ssl.egdsocket?data->set.ssl.egdsocket:EGD_SOCKET);
     if(-1 != ret) {
       nread += ret;
-      if(seed_enough(conn, nread))
+      if(seed_enough(nread))
         return nread;
     }
   }
 #endif
 
   /* If we get here, it means we need to seed the PRNG using a "silly"
@@ -160,63 +173,158 @@
   /* generates a default path for the random seed file */
   buf[0]=0; /* blank it first */
   RAND_file_name(buf, BUFSIZE);
   if ( buf[0] ) {
     /* we got a file name to try */
     nread += RAND_load_file(buf, 16384);
-    if(seed_enough(conn, nread))
+    if(seed_enough(nread))
       return nread;
   }
 
-  infof(conn->data, "Your connection is using a weak random seed!\n");
+  infof(data, "libcurl is now using a weak random seed!\n");
   return nread;
 }
 
+#ifndef SSL_FILETYPE_ENGINE
+#define SSL_FILETYPE_ENGINE 42
+#endif
+static int do_file_type(const char *type)
+{
+  if (!type || !type[0])
+    return SSL_FILETYPE_PEM;
+  if (curl_strequal(type, "PEM"))
+    return SSL_FILETYPE_PEM;
+  if (curl_strequal(type, "DER"))
+    return SSL_FILETYPE_ASN1;
+  if (curl_strequal(type, "ENG"))
+    return SSL_FILETYPE_ENGINE;
+  return -1;
+}
+
 static
 int cert_stuff(struct connectdata *conn,
                char *cert_file,
-               char *key_file)
+               const char *cert_type,
+               char *key_file,
+               const char *key_type)
 {
   struct SessionHandle *data = conn->data;
+  int file_type;
+
   if (cert_file != NULL) {
     SSL *ssl;
     X509 *x509;
 
-    if(data->set.cert_passwd) {
+    if(data->set.key_passwd) {
 #ifndef HAVE_USERDATA_IN_PWD_CALLBACK
       /*
        * If password has been given, we store that in the global
        * area (*shudder*) for a while:
        */
-      strcpy(global_passwd, data->set.cert_passwd);
+      strcpy(global_passwd, data->set.key_passwd);
 #else
       /*
        * We set the password in the callback userdata
        */
-      SSL_CTX_set_default_passwd_cb_userdata(conn->ssl.ctx, data->set.cert_passwd);
+      SSL_CTX_set_default_passwd_cb_userdata(conn->ssl.ctx,
+                                             data->set.key_passwd);
 #endif
       /* Set passwd callback: */
       SSL_CTX_set_default_passwd_cb(conn->ssl.ctx, passwd_callback);
     }
 
-    if (SSL_CTX_use_certificate_file(conn->ssl.ctx,
-				     cert_file,
-				     SSL_FILETYPE_PEM) != 1) {
-      failf(data, "unable to set certificate file (wrong password?)\n");
-      return(0);
-    }
-    if (key_file == NULL)
-      key_file=cert_file;
+    file_type = do_file_type(cert_type);
 
-    if (SSL_CTX_use_PrivateKey_file(conn->ssl.ctx,
-				    key_file,
-				    SSL_FILETYPE_PEM) != 1) {
-      failf(data, "unable to set public key file\n");
-      return(0);
+    switch(file_type) {
+    case SSL_FILETYPE_PEM:
+      /* SSL_CTX_use_certificate_chain_file() only works on PEM files */
+      if (SSL_CTX_use_certificate_chain_file(conn->ssl.ctx,
+                                             cert_file) != 1) {
+        failf(data, "unable to set certificate file (wrong password?)");
+        return 0;
+      }
+      break;
+
+    case SSL_FILETYPE_ASN1:
+      /* SSL_CTX_use_certificate_file() works with either PEM or ASN1, but
+         we use the case above for PEM so this can only be performed with
+         ASN1 files. */
+      if (SSL_CTX_use_certificate_file(conn->ssl.ctx,
+                                       cert_file,
+                                       file_type) != 1) {
+        failf(data, "unable to set certificate file (wrong password?)");
+        return 0;
+      }
+      break;
+    case SSL_FILETYPE_ENGINE:
+      failf(data, "file type ENG for certificate not implemented");
+      return 0;
+
+    default:
+      failf(data, "not supported file type '%s' for certificate", cert_type);
+      return 0;
+    }
+
+    file_type = do_file_type(key_type);
+
+    switch(file_type) {
+    case SSL_FILETYPE_PEM:
+      if (key_file == NULL)
+        /* cert & key can only be in PEM case in the same file */
+        key_file=cert_file;
+    case SSL_FILETYPE_ASN1:
+      if (SSL_CTX_use_PrivateKey_file(conn->ssl.ctx,
+                                      key_file,
+                                      file_type) != 1) {
+        failf(data, "unable to set private key file\n");
+        return 0;
+      }
+      break;
+    case SSL_FILETYPE_ENGINE:
+#ifdef HAVE_OPENSSL_ENGINE_H
+      {                         /* XXXX still needs some work */
+        EVP_PKEY *priv_key = NULL;
+        if (conn && conn->data && conn->data->engine) {
+#ifdef HAVE_ENGINE_LOAD_FOUR_ARGS
+          UI_METHOD *ui_method = UI_OpenSSL();
+#endif
+          if (!key_file || !key_file[0]) {
+            failf(data, "no key set to load from crypto engine\n");
+            return 0;
+          }
+          priv_key = ENGINE_load_private_key(conn->data->engine,key_file,
+#ifdef HAVE_ENGINE_LOAD_FOUR_ARGS
+                                             ui_method,
+#endif
+                                             data->set.key_passwd);
+          if (!priv_key) {
+            failf(data, "failed to load private key from crypto engine\n");
+            return 0;
+          }
+          if (SSL_CTX_use_PrivateKey(conn->ssl.ctx, priv_key) != 1) {
+            failf(data, "unable to set private key\n");
+            EVP_PKEY_free(priv_key);
+            return 0;
+          }
+          EVP_PKEY_free(priv_key);  /* we don't need the handle any more... */
+        }
+        else {
+          failf(data, "crypto engine not set, can't load private key\n");
+          return 0;
+        }
+      }
+#else
+      failf(data, "file type ENG for private key not supported\n");
+      return 0;
+#endif
+      break;
+    default:
+      failf(data, "not supported file type for private key\n");
+      return 0;
     }
-    
+
     ssl=SSL_new(conn->ssl.ctx);
     x509=SSL_get_certificate(ssl);
     
     if (x509 != NULL)
       EVP_PKEY_copy_parameters(X509_get_pubkey(x509),
 			       SSL_get_privatekey(ssl));
@@ -226,13 +334,13 @@
      * the private key */
 		
     
     /* Now we know that a key and cert have been set against
      * the SSL context */
     if (!SSL_CTX_check_private_key(conn->ssl.ctx)) {
-      failf(data, "Private key does not match the certificate public key\n");
+      failf(data, "Private key does not match the certificate public key");
       return(0);
     }
 #ifndef HAVE_USERDATA_IN_PWD_CALLBACK    
     /* erase it now */
     memset(global_passwd, 0, sizeof(global_passwd));
 #endif
@@ -254,24 +362,32 @@
 
 #endif
 
 #ifdef USE_SSLEAY
 /* "global" init done? */
 static int init_ssl=0;
+
+/* we have the "SSL is seeded" boolean global for the application to
+   prevent multiple time-consuming seedings in vain */
+static bool ssl_seeded = FALSE;
 #endif
 
 /* Global init */
 void Curl_SSL_init(void)
 {
 #ifdef USE_SSLEAY
   /* make sure this is only done once */
   if(0 != init_ssl)
     return;
 
   init_ssl++; /* never again */
 
+#ifdef HAVE_ENGINE_LOAD_BUILTIN_ENGINES
+  ENGINE_load_builtin_engines();
+#endif
+
   /* Lets get nice error messages */
   SSL_load_error_strings();
 
   /* Setup all the global SSL stuff */
   SSLeay_add_ssl_algorithms();
 #else
@@ -289,12 +405,18 @@
     /* Free the SSL error strings */
     ERR_free_strings();
   
     /* EVP_cleanup() removes all ciphers and digests from the
        table. */
     EVP_cleanup();
+
+#ifdef HAVE_ENGINE_cleanup
+    ENGINE_cleanup();
+#endif
+
+    init_ssl=0; /* not inited any more */
   }
 #else
   /* SSL disabled, do nothing */
 #endif
 }
 
@@ -423,38 +545,61 @@
       /* the single-killer function handles empty table slots */
       Kill_Single_Session(&data->state.session[i]);
     
     /* free the cache data */
     free(data->state.session);
   }
+#ifdef HAVE_OPENSSL_ENGINE_H
+  if (data->engine)
+  {
+    ENGINE_free(data->engine);
+    data->engine = NULL;
+  }
+#endif
   return 0;
 }
 
 /*
  * Extract the session id and store it in the session cache.
  */
 static int Store_SSL_Session(struct connectdata *conn)
 {
   SSL_SESSION *ssl_sessionid;
-  struct curl_ssl_session *store;
   int i;
   struct SessionHandle *data=conn->data; /* the mother of all structs */
+  struct curl_ssl_session *store = &data->state.session[0];
   int oldest_age=data->state.session[0].age; /* zero if unused */
 
   /* ask OpenSSL, say please */
+
+#ifdef HAVE_SSL_GET1_SESSION
   ssl_sessionid = SSL_get1_session(conn->ssl.handle);
 
   /* SSL_get1_session() will increment the reference
      count and the session will stay in memory until explicitly freed with
-     SSL_SESSION_free(3), regardless of its state. */
+     SSL_SESSION_free(3), regardless of its state. 
+     This function was introduced in openssl 0.9.5a. */
+#else
+  ssl_sessionid = SSL_get_session(conn->ssl.handle);
+
+  /* if SSL_get1_session() is unavailable, use SSL_get_session().
+     This is an inferior option because the session can be flushed
+     at any time by openssl. It is included only so curl compiles
+     under versions of openssl < 0.9.5a.
+     
+     WARNING: How curl behaves if it's session is flushed is
+     untested. 
+  */
+#endif
 
   /* Now we should add the session ID and the host name to the cache, (remove
      the oldest if necessary) */
 
   /* find an empty slot for us, or find the oldest */
-  for(i=0; (i<data->set.ssl.numsessions) && data->state.session[i].sessionid; i++) {
+  for(i=1; (i<data->set.ssl.numsessions) &&
+        data->state.session[i].sessionid; i++) {
     if(data->state.session[i].age < oldest_age) {
       oldest_age = data->state.session[i].age;
       store = &data->state.session[i];
     }
   }
   if(i == data->set.ssl.numsessions)
@@ -535,58 +680,72 @@
   SSL_SESSION *ssl_sessionid=NULL;
   ASN1_TIME *certdate;
 
   /* mark this is being ssl enabled from here on out. */
   conn->ssl.use = TRUE;
 
-  /* Make funny stuff to get random input */
-  random_the_seed(conn);
-    
+  if(!ssl_seeded || data->set.ssl.random_file || data->set.ssl.egdsocket) {
+    /* Make funny stuff to get random input */
+    random_the_seed(data);
+
+    ssl_seeded = TRUE;
+  }
+
+  /* check to see if we've been told to use an explicit SSL/TLS version */
   switch(data->set.ssl.version) {
   default:
+  case CURL_SSLVERSION_DEFAULT:
+    /* we try to figure out version */
     req_method = SSLv23_client_method();
     break;
-  case 2:
+  case CURL_SSLVERSION_TLSv1:
+    req_method = TLSv1_client_method();
+    break;
+  case CURL_SSLVERSION_SSLv2:
     req_method = SSLv2_client_method();
     break;
-  case 3:
+  case CURL_SSLVERSION_SSLv3:
     req_method = SSLv3_client_method();
     break;
   }
     
   conn->ssl.ctx = SSL_CTX_new(req_method);
 
   if(!conn->ssl.ctx) {
     failf(data, "SSL: couldn't create a context!");
     return CURLE_OUT_OF_MEMORY;
   }
     
   if(data->set.cert) {
-    if (!cert_stuff(conn, data->set.cert, data->set.cert)) {
+    if (!cert_stuff(conn,
+                    data->set.cert,
+                    data->set.cert_type,
+                    data->set.key,
+                    data->set.key_type)) {
       /* failf() is already done in cert_stuff() */
       return CURLE_SSL_CONNECT_ERROR;
     }
   }
 
   if(data->set.ssl.cipher_list) {
     if (!SSL_CTX_set_cipher_list(conn->ssl.ctx,
                                  data->set.ssl.cipher_list)) {
-      failf(data, "failed setting cipher list\n");
+      failf(data, "failed setting cipher list");
       return CURLE_SSL_CONNECT_ERROR;
     }
   }
 
   if(data->set.ssl.verifypeer){
     SSL_CTX_set_verify(conn->ssl.ctx,
                        SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
                        SSL_VERIFY_CLIENT_ONCE,
                        cert_verify_callback);
     if (!SSL_CTX_load_verify_locations(conn->ssl.ctx,
                                        data->set.ssl.CAfile,
                                        data->set.ssl.CApath)) {
-      failf(data,"error setting cerficate verify locations\n");
+      failf(data,"error setting cerficate verify locations");
       return CURLE_SSL_CONNECT_ERROR;
     }
   }
   else
     SSL_CTX_set_verify(conn->ssl.ctx, SSL_VERIFY_NONE, cert_verify_callback);
 
@@ -606,14 +765,86 @@
       /* Informational message */
       infof (data, "SSL re-using session ID\n");
     }
   }
 
   /* pass the raw socket into the SSL layers */
-  SSL_set_fd (conn->ssl.handle, conn->firstsocket);
-  err = SSL_connect (conn->ssl.handle);
+  SSL_set_fd(conn->ssl.handle, conn->firstsocket);
+
+  do {
+    int what;
+    fd_set writefd;
+    fd_set readfd;
+    struct timeval interval;
+    long timeout_ms;
+
+    err = SSL_connect(conn->ssl.handle);
+
+    what = SSL_get_error(conn->ssl.handle, err);
+
+    FD_ZERO(&writefd);
+    FD_ZERO(&readfd);
+
+    if(SSL_ERROR_WANT_READ == what)
+      FD_SET(conn->firstsocket, &readfd);
+    else if(SSL_ERROR_WANT_WRITE == what)
+      FD_SET(conn->firstsocket, &writefd);
+    else
+      break; /* untreated error */
+
+    /* Find out if any timeout is set. If not, use 300 seconds.
+       Otherwise, figure out the most strict timeout of the two possible one
+       and then how much time that has elapsed to know how much time we
+       allow for the connect call */
+    if(data->set.timeout || data->set.connecttimeout) {
+      double has_passed;
+
+      /* Evaluate in milliseconds how much time that has passed */
+      has_passed = Curl_tvdiff(Curl_tvnow(), data->progress.start);
+
+#ifndef min
+#define min(a, b)   ((a) < (b) ? (a) : (b))
+#endif
+
+      /* get the most strict timeout of the ones converted to milliseconds */
+      if(data->set.timeout &&
+         (data->set.timeout>data->set.connecttimeout))
+        timeout_ms = data->set.timeout*1000;
+      else
+        timeout_ms = data->set.connecttimeout*1000;
+      
+      /* subtract the passed time */
+      timeout_ms -= (long)has_passed;
+      
+      if(timeout_ms < 0) {
+        /* a precaution, no need to continue if time already is up */
+        failf(data, "SSL connection timeout");
+        return CURLE_OPERATION_TIMEOUTED;
+      }
+    }
+    else
+      /* no particular time-out has been set */
+      timeout_ms=300000; /* milliseconds, default to five minutes */
+
+    interval.tv_sec = timeout_ms/1000;
+    timeout_ms -= interval.tv_sec*1000;
+
+    interval.tv_usec = timeout_ms*1000;
+
+    what = select(conn->firstsocket+1, &readfd, &writefd, NULL, &interval);
+    if(what > 0)
+      /* reabable or writable, go loop yourself */
+      continue;
+    else if(0 == what) {
+      /* timeout */
+      failf(data, "SSL connection timeout");
+      return CURLE_OPERATION_TIMEOUTED;
+    }
+    else
+      break; /* get out of loop */
+  } while(1);
 
   /* 1  is fine
      0  is "not successful but was shut down controlled"
      <0 is "handshake was not successful, because a fatal error occurred" */
   if (err <= 0) {
     err = ERR_get_error(); 
@@ -702,13 +933,13 @@
   /* We could do all sorts of certificate verification stuff here before
      deallocating the certificate. */
 
   if(data->set.ssl.verifypeer) {
     data->set.ssl.certverifyresult=SSL_get_verify_result(conn->ssl.handle);
     if (data->set.ssl.certverifyresult != X509_V_OK) {
-      failf(data, "SSL certificate verify result: %d\n",
+      failf(data, "SSL certificate verify result: %d",
             data->set.ssl.certverifyresult);
       retcode = CURLE_SSL_PEER_CERTIFICATE;
     }
   }
   else
     data->set.ssl.certverifyresult=0;
@@ -722,9 +953,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ssluse.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ssluse.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/ssluse.h	2001-09-07 17:40:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/ssluse.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.h,v 1.11 2001/09/07 09:40:46 bagder Exp $
+ * $Id: ssluse.h,v 1.12 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 #include "urldata.h"
 CURLcode Curl_SSLConnect(struct connectdata *conn);
 
 void Curl_SSL_init(void);    /* Global SSL init */
 void Curl_SSL_cleanup(void); /* Global SSL cleanup */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib: stamp-h1.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strequal.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strequal.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strequal.c	2001-09-07 14:05:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strequal.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,31 +2,32 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.c,v 1.15 2001/09/07 04:01:33 bumblebury Exp $
+ * $Id: strequal.c,v 1.19 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
+#include <ctype.h>
 
 int curl_strequal(const char *first, const char *second)
 {
 #if defined(HAVE_STRCASECMP)
   return !(strcasecmp)(first, second);
 #elif defined(HAVE_STRCMPI)
@@ -59,12 +60,15 @@
       break;
     }
     max--;
     first++;
     second++;
   }
+  if(0 == max)
+    return 1; /* they are equal this far */
+
   return toupper(*first) == toupper(*second);
 #endif
 }
 
 #ifndef HAVE_STRLCAT
 /*
@@ -109,9 +113,9 @@
 #endif
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strequal.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strequal.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strequal.h	2001-05-18 20:03:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strequal.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.h,v 1.8 2001/05/18 12:03:30 bagder Exp $
+ * $Id: strequal.h,v 1.9 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 /*
  * These two actually are public functions.
  */
 int curl_strequal(const char *first, const char *second);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strtok.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strtok.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strtok.c	2001-09-07 14:05:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strtok.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strtok.c,v 1.6 2001/09/07 04:01:33 bumblebury Exp $
+ * $Id: strtok.c,v 1.8 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #ifndef HAVE_STRTOK_R
 #include <stddef.h>
@@ -66,9 +66,9 @@
 #endif /* this was only compiled if strtok_r wasn't present */
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strtok.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strtok.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/strtok.h	2001-08-26 22:24:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/strtok.h	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strtok.h,v 1.5 2001/05/31 07:02:13 bagder Exp $
+ * $Id: strtok.h,v 1.6 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #ifndef _CURL_STRTOK_R_H
 #define _CURL_STRTOK_R_H
 
 #include "setup.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/telnet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/telnet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/telnet.c	2001-09-17 22:10:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/telnet.c	2002-06-11 19:13:01.000000000 +0800
@@ -2,30 +2,31 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: telnet.c,v 1.23 2001/09/17 14:10:38 bagder Exp $
+ * $Id: telnet.c,v 1.30 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
+#ifndef CURL_DISABLE_TELNET
 /* -- WIN32 approved -- */
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <ctype.h>
@@ -223,15 +224,15 @@
    
   if (data->set.verbose)
   {
     if (cmd == IAC)
     {
       if (TELCMD_OK(option))
-        printf("%s IAC %s\n", direction, TELCMD(option));
+        Curl_infof(data, "%s IAC %s\n", direction, TELCMD(option));
       else
-        printf("%s IAC %d\n", direction, option);
+        Curl_infof(data, "%s IAC %d\n", direction, option);
     }
     else
     {
       fmt = (cmd == WILL) ? "WILL" : (cmd == WONT) ? "WONT" :
         (cmd == DO) ? "DO" : (cmd == DONT) ? "DONT" : 0;
       if (fmt)
@@ -241,18 +242,18 @@
         else if (option == TELOPT_EXOPL)
           opt = "EXOPL";
         else
           opt = NULL;
 
         if(opt)
-          printf("%s %s %s\n", direction, fmt, opt);
+          Curl_infof(data, "%s %s %s\n", direction, fmt, opt);
         else
-          printf("%s %s %d\n", direction, fmt, option);
+          Curl_infof(data, "%s %s %d\n", direction, fmt, option);
       }
       else
-        printf("%s %d %d\n", direction, cmd, option);
+        Curl_infof(data, "%s %d %d\n", direction, cmd, option);
     }
   }
 }
 
 static void send_negotiation(struct connectdata *conn, int cmd, int option)
 {
@@ -635,109 +636,109 @@
   int i = 0;
 
   if (data->set.verbose)
   {
     if (direction)
     {
-      printf("%s IAC SB ", (direction == '<')? "RCVD":"SENT");
+      Curl_infof(data, "%s IAC SB ", (direction == '<')? "RCVD":"SENT");
       if (length >= 3)
       {
         int j;
 
         i = pointer[length-2];
         j = pointer[length-1];
 
         if (i != IAC || j != SE)
         {
-          printf("(terminated by ");
+          Curl_infof(data, "(terminated by ");
           if (TELOPT_OK(i))
-            printf("%s ", TELOPT(i));
+            Curl_infof(data, "%s ", TELOPT(i));
           else if (TELCMD_OK(i))
-            printf("%s ", TELCMD(i));
+            Curl_infof(data, "%s ", TELCMD(i));
           else
-            printf("%d ", i);
+            Curl_infof(data, "%d ", i);
           if (TELOPT_OK(j))
-            printf("%s", TELOPT(j));
+            Curl_infof(data, "%s", TELOPT(j));
           else if (TELCMD_OK(j))
-            printf("%s", TELCMD(j));
+            Curl_infof(data, "%s", TELCMD(j));
           else
-            printf("%d", j);
-          printf(", not IAC SE!) ");
+            Curl_infof(data, "%d", j);
+          Curl_infof(data, ", not IAC SE!) ");
         }
       }
       length -= 2;
     }
     if (length < 1)
     {
-      printf("(Empty suboption?)");
+      Curl_infof(data, "(Empty suboption?)");
       return;
     }
 
     if (TELOPT_OK(pointer[0])) {
       switch(pointer[0]) {
         case TELOPT_TTYPE:
         case TELOPT_XDISPLOC:
         case TELOPT_NEW_ENVIRON:
-          printf("%s", TELOPT(pointer[0]));
+          Curl_infof(data, "%s", TELOPT(pointer[0]));
           break;
         default:
-          printf("%s (unsupported)", TELOPT(pointer[0]));
+          Curl_infof(data, "%s (unsupported)", TELOPT(pointer[0]));
           break;
       }
     }
     else
-      printf("%d (unknown)", pointer[i]);
+      Curl_infof(data, "%d (unknown)", pointer[i]);
 
     switch(pointer[1]) {
       case TELQUAL_IS:
-        printf(" IS");
+        Curl_infof(data, " IS");
         break;
       case TELQUAL_SEND:
-        printf(" SEND");
+        Curl_infof(data, " SEND");
         break;
       case TELQUAL_INFO:
-        printf(" INFO/REPLY");
+        Curl_infof(data, " INFO/REPLY");
         break;
       case TELQUAL_NAME:
-        printf(" NAME");
+        Curl_infof(data, " NAME");
         break;
     }
       
     switch(pointer[0]) {
       case TELOPT_TTYPE:
       case TELOPT_XDISPLOC:
         pointer[length] = 0;
-        printf(" \"%s\"", &pointer[2]);
+        Curl_infof(data, " \"%s\"", &pointer[2]);
         break;
       case TELOPT_NEW_ENVIRON:
         if(pointer[1] == TELQUAL_IS) {
-          printf(" ");
+          Curl_infof(data, " ");
           for(i = 3;i < length;i++) {
             switch(pointer[i]) {
               case NEW_ENV_VAR:
-                printf(", ");
+                Curl_infof(data, ", ");
                 break;
               case NEW_ENV_VALUE:
-                printf(" = ");
+                Curl_infof(data, " = ");
                 break;
               default:
-                printf("%c", pointer[i]);
+                Curl_infof(data, "%c", pointer[i]);
                 break;
             }
           }
         }
         break;
       default:
         for (i = 2; i < length; i++)
-          printf(" %.2x", pointer[i]);
+          Curl_infof(data, " %.2x", pointer[i]);
         break;
     }
       
     if (direction)
     {
-      printf("\n");
+      Curl_infof(data, "\n");
     }
   }
 }
 
 static int check_telnet_options(struct connectdata *conn)
 {
@@ -1087,13 +1088,13 @@
     switch(waitret - WAIT_OBJECT_0)
     {
       case 0:
       {
         unsigned char outbuf[2];
         int out_count = 0;
-        size_t bytes_written;
+        ssize_t bytes_written;
         char *buffer = buf;
               
         if(!ReadFile(stdin_handle, buf, 255, &nread, NULL)) {
           keepon = FALSE;
           break;
         }
@@ -1113,12 +1114,13 @@
       case 1:
         if(WSAEnumNetworkEvents(sockfd, event_handle, &events)
            != SOCKET_ERROR)
         {
           if(events.lNetworkEvents & FD_READ)
           {
+            /* This reallu OUGHT to check its return code. */
             Curl_read(conn, sockfd, buf, BUFSIZE - 1, &nread);
             
             telrcv(conn, (unsigned char *)buf, nread);
             
             fflush(stdout);
             
@@ -1139,13 +1141,13 @@
         break;
     }
   }
 #else
   FD_ZERO (&readfd);		/* clear it */
   FD_SET (sockfd, &readfd);
-  FD_SET (1, &readfd);
+  FD_SET (0, &readfd);
 
   keepfd = readfd;
 
   while (keepon) {
     readfd = keepfd;		/* set this every lap in the loop */
 
@@ -1153,19 +1155,19 @@
     case -1:			/* error, stop reading */
       keepon = FALSE;
       continue;
     case 0:			/* timeout */
       break;
     default:			/* read! */
-      if(FD_ISSET(1, &readfd)) { /* read from stdin */
+      if(FD_ISSET(0, &readfd)) { /* read from stdin */
         unsigned char outbuf[2];
         int out_count = 0;
-        size_t bytes_written;
+        ssize_t bytes_written;
         char *buffer = buf;
         
-        nread = read(1, buf, 255);
+        nread = read(0, buf, 255);
 
         while(nread--) {
           outbuf[0] = *buffer++;
           out_count = 1;
           if(outbuf[0] == IAC)
             outbuf[out_count++] = IAC;
@@ -1173,12 +1175,13 @@
           Curl_write(conn, conn->firstsocket, outbuf,
                      out_count, &bytes_written);
         }
       }
 
       if(FD_ISSET(sockfd, &readfd)) {
+        /* This OUGHT to check the return code... */
         Curl_read(conn, sockfd, buf, BUFSIZE - 1, &nread);
 
         /* if we receive 0 or less here, the server closed the connection and
            we bail out from this! */
         if (nread <= 0) {
           keepon = FALSE;
@@ -1203,9 +1206,10 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/telnet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/telnet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/telnet.h	2001-01-05 18:11:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/telnet.h	2002-06-11 19:13:01.000000000 +0800
@@ -5,25 +5,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: telnet.h,v 1.6 2001/01/05 10:11:43 bagder Exp $
+ * $Id: telnet.h,v 1.8 2002/06/11 11:13:01 bagder Exp $
  *****************************************************************************/
+#ifndef CURL_DISABLE_TELNET
 CURLcode Curl_telnet(struct connectdata *conn);
 CURLcode Curl_telnet_done(struct connectdata *conn);
-
+#endif
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/timeval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/timeval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/timeval.c	2001-09-07 14:05:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/timeval.c	2002-06-03 20:46:32.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: timeval.c,v 1.7 2001/09/07 04:01:33 bumblebury Exp $
+ * $Id: timeval.c,v 1.13 2002/06/03 12:46:32 bagder Exp $
  *****************************************************************************/
 
 #ifdef WIN32
 #include <windows.h>
 #endif
 #include "timeval.h"
@@ -29,28 +29,42 @@
 #ifndef HAVE_GETTIMEOFDAY
 
 #ifdef WIN32
 int
 gettimeofday (struct timeval *tp, void *nothing)
 {
- SYSTEMTIME st;
- time_t tt;
- struct tm tmtm;
- /* mktime converts local to UTC */
- GetLocalTime (&st);
- tmtm.tm_sec = st.wSecond;
- tmtm.tm_min = st.wMinute;
- tmtm.tm_hour = st.wHour;
- tmtm.tm_mday = st.wDay;
- tmtm.tm_mon = st.wMonth - 1;
- tmtm.tm_year = st.wYear - 1900;
- tmtm.tm_isdst = -1;
- tt = mktime (&tmtm);
- tp->tv_sec = tt;
- tp->tv_usec = st.wMilliseconds * 1000;
- return 1;
+#ifdef WITHOUT_MM_LIB
+  SYSTEMTIME st;
+  time_t tt;
+  struct tm tmtm;
+  /* mktime converts local to UTC */
+  GetLocalTime (&st);
+  tmtm.tm_sec = st.wSecond;
+  tmtm.tm_min = st.wMinute;
+  tmtm.tm_hour = st.wHour;
+  tmtm.tm_mday = st.wDay;
+  tmtm.tm_mon = st.wMonth - 1;
+  tmtm.tm_year = st.wYear - 1900;
+  tmtm.tm_isdst = -1;
+  tt = mktime (&tmtm);
+  tp->tv_sec = tt;
+  tp->tv_usec = st.wMilliseconds * 1000;
+#else
+  /**
+   ** The earlier time calculations using GetLocalTime
+   ** had a time resolution of 10ms.The timeGetTime, part
+   ** of multimedia apis offer a better time resolution
+   ** of 1ms.Need to link against winmm.lib for this
+   **/
+  unsigned long Ticks = 0;
+  Ticks = timeGetTime();
+  tp->tv_sec = Ticks%1000;
+  tp->tv_usec = (Ticks - (tp->tv_sec*1000))*1000;
+  
+#endif
+  return 1;
 }
 #define HAVE_GETTIMEOFDAY
 #endif
 #endif
 
 struct timeval Curl_tvnow (void)
@@ -62,23 +76,28 @@
  now.tv_sec = (long) time(NULL);
  now.tv_usec = 0;
 #endif
  return now;
 }
 
-double Curl_tvdiff (struct timeval t1, struct timeval t2)
+/*
+ * Make sure that the first argument is the more recent time, as otherwise
+ * we'll get a weird negative time-diff back...
+ */
+long Curl_tvdiff (struct timeval newer, struct timeval older)
 {
- return (double)(t1.tv_sec - t2.tv_sec) + ((t1.tv_usec-t2.tv_usec)/1000000.0);
+  return (newer.tv_sec-older.tv_sec)*1000+
+    (499+newer.tv_usec-older.tv_usec)/1000;
 }
 
 long Curl_tvlong (struct timeval t1)
 {
  return t1.tv_sec;
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/timeval.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/timeval.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/timeval.h	2001-08-06 20:30:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/timeval.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: timeval.h,v 1.7 2001/01/05 10:11:43 bagder Exp $
+ * $Id: timeval.h,v 1.10 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #if defined(WIN32) && !defined(__GNUC__) || defined(__MINGW32__)
 #include <time.h>
@@ -39,11 +39,14 @@
  long tv_sec;
  long tv_usec;
 };
 #endif
 #endif
 
-struct timeval Curl_tvnow ();
-double Curl_tvdiff (struct timeval t1, struct timeval t2);
+struct timeval Curl_tvnow (void);
+
+/* the diff is from now on returned in number of milliseconds! */
+long Curl_tvdiff (struct timeval t1, struct timeval t2);
+
 long Curl_tvlong (struct timeval t1);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/transfer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/transfer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/transfer.c	2001-09-12 20:02:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/transfer.c	2002-06-13 16:12:22.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.c,v 1.55 2001/09/12 12:02:12 bagder Exp $
+ * $Id: transfer.c,v 1.101 2002/06/12 22:04:25 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -103,12 +103,19 @@
 #endif
 
 #ifndef min
 #define min(a, b)   ((a) < (b) ? (a) : (b))
 #endif
 
+enum {
+  KEEP_NONE,
+  KEEP_READ,
+  KEEP_WRITE
+};
+
+
 /*
  * compareheader()
  *
  * Returns TRUE if 'headerline' contains the 'header' with given 'content'.
  * Pass headers WITH the colon.
  */
@@ -158,754 +165,948 @@
       return TRUE; /* match! */
   }
 
   return FALSE; /* no match */
 }
 
-/*
- * Transfer()
- *
- * This function is what performs the actual transfer. It is capable of
- * doing both ways simultaneously.
- * The transfer must already have been setup by a call to Curl_Transfer().
- *
- * Note that headers are created in a preallocated buffer of a default size.
- * That buffer can be enlarged on demand, but it is never shrinken again.
- *
- * Parts of this function was once written by the friendly Mark Butler
- * <butlerm@xmission.com>.
- */
+/* We keep this static and global since this is read-only and NEVER
+   changed. It should just remain a blanked-out timeout value. */
+static struct timeval notimeout={0,0};
 
-static CURLcode
-Transfer(struct connectdata *c_conn)
+CURLcode Curl_readwrite(struct connectdata *conn,
+                        bool *done)
 {
-  ssize_t nread;                /* number of bytes read */
-  int bytecount = 0;            /* total number of bytes read */
-  int writebytecount = 0;       /* number of bytes written */
-  long contentlength=0;         /* size of incoming data */
-  struct timeval start = Curl_tvnow();
-  struct timeval now = start;   /* current time */
-  bool header = TRUE;		/* incoming data has HTTP header */
-  int headerline = 0;		/* counts header lines to better track the
-                                   first one */
-  char *hbufp;			/* points at *end* of header line */
-  int hbuflen = 0;
-  char *str;			/* within buf */
-  char *str_start;		/* within buf */
-  char *end_ptr;		/* within buf */
-  char *p;			/* within headerbuff */
-  bool content_range = FALSE;	/* set TRUE if Content-Range: was found */
-  int offset = 0;		/* possible resume offset read from the
-                                   Content-Range: header */
-  int httpcode = 0;		/* error code from the 'HTTP/1.? XXX' line */
-  int httpversion = -1;			/* the HTTP version*10 */
-  bool write_after_100_header = FALSE;  /* should we enable the write after
-                                           we received a 100-continue/timeout
-                                           or directly */
-
-  /* for the low speed checks: */
-  CURLcode urg;
-  time_t timeofdoc=0;
-  long bodywrites=0;
-  int writetype;
-
-  /* the highest fd we use + 1 */
-  struct SessionHandle *data;
-  struct connectdata *conn = (struct connectdata *)c_conn;
-  char *buf;
-  int maxfd;
+  struct Curl_transfer_keeper *k = &conn->keep;
+  struct SessionHandle *data = conn->data;
+  int result;
+  ssize_t nread; /* number of bytes read */
+  int didwhat=0;
+  
+  /* These two are used only if no other select() or _fdset() have been
+     invoked before this. This typicly happens if you use the multi interface
+     and call curl_multi_perform() without calling curl_multi_fdset()
+     first. */
+  fd_set extrareadfd;
+  fd_set extrawritefd;
+
+  fd_set *readfdp = k->readfdp;
+  fd_set *writefdp = k->writefdp;
+  
+  if((k->keepon & KEEP_READ) && !readfdp) {
+    /* reading is requested, but no socket descriptor pointer was set */
+    FD_ZERO(&extrareadfd);
+    FD_SET(conn->sockfd, &extrareadfd);
+    readfdp = &extrareadfd;
 
-  data = conn->data; /* there's the root struct */
-  buf = data->state.buffer;
-  maxfd = (conn->sockfd>conn->writesockfd?conn->sockfd:conn->writesockfd)+1;
-
-  hbufp = data->state.headerbuff;
-
-  myalarm (0);			/* switch off the alarm-style timeout */
-
-  now = Curl_tvnow();
-  start = now;
-
-#define KEEP_READ  1
-#define KEEP_WRITE 2
-
-  Curl_pgrsTime(data, TIMER_PRETRANSFER);
-  Curl_speedinit(data);
-
-  if((conn->sockfd == -1) &&
-     (conn->writesockfd == -1)) {
-    /* nothing to read, nothing to write, we're already OK! */
-    return CURLE_OK;
+    /* no write, no exceptions, no timeout */
+    select(conn->sockfd+1, readfdp, NULL, NULL, &notimeout);
   }
+  if((k->keepon & KEEP_WRITE) && !writefdp) {
+    /* writing is requested, but no socket descriptor pointer was set */
+    FD_ZERO(&extrawritefd);
+    FD_SET(conn->writesockfd, &extrawritefd);
+    writefdp = &extrawritefd;
 
-  if (!conn->getheader) {
-    header = FALSE;
-    if(conn->size > 0)
-      Curl_pgrsSetDownloadSize(data, conn->size);
+    /* no read, no exceptions, no timeout */
+    select(conn->writesockfd+1, NULL, writefdp, NULL, &notimeout);
   }
-  /* we want header and/or body, if neither then don't do this! */
-  if(conn->getheader ||
-     !data->set.no_body) {
-    fd_set readfd;
-    fd_set writefd;
-    fd_set rkeepfd;
-    fd_set wkeepfd;
-    struct timeval interval;
-    int keepon=0;
-
-    /* timeout every X second
-       - makes a better progress meter (i.e even when no data is read, the
-       meter can be updated and reflect reality)
-       - allows removal of the alarm() crap
-       - variable timeout is easier
-     */
-
-    FD_ZERO (&readfd);		/* clear it */
-    if(conn->sockfd != -1) {
-      FD_SET (conn->sockfd, &readfd); /* read socket */
-      keepon |= KEEP_READ;
-    }
-
-    FD_ZERO (&writefd);		/* clear it */
-    if(conn->writesockfd != -1) {
-      if (data->set.expect100header)
-        /* wait with write until we either got 100-continue or a timeout */
-        write_after_100_header = TRUE;
-      else {
-        FD_SET (conn->writesockfd, &writefd); /* write socket */
-        keepon |= KEEP_WRITE;
-      }
-    }
 
-    /* get these in backup variables to be able to restore them on each lap in
-       the select() loop */
-    rkeepfd = readfd;
-    wkeepfd = writefd;
-
-    while (keepon) {
-      readfd = rkeepfd;		/* set those every lap in the loop */
-      writefd = wkeepfd;
-      interval.tv_sec = 1;
-      interval.tv_usec = 0;
-
-      switch (select (maxfd, &readfd, &writefd, NULL, &interval)) {
-      case -1:			/* select() error, stop reading */
-#ifdef EINTR
-        /* The EINTR is not serious, and it seems you might get this more
-           ofen when using the lib in a multi-threaded environment! */
-        if(errno == EINTR)
-          ;
-        else
-#endif
-          keepon = 0; /* no more read or write */
-	continue;
-      case 0:			/* timeout */
-        if (write_after_100_header) {
-          write_after_100_header = FALSE;
-          FD_SET (conn->writesockfd, &writefd); /* write socket */
-          keepon |= KEEP_WRITE;
-          wkeepfd = writefd;
-        }
+  do {
+    /* If we still have reading to do, we check if we have a readable
+       socket. Sometimes the reafdp is NULL, it no fd_set was done using
+       the multi interface and then we can do nothing but to attempt a
+       read to be sure. */
+    if((k->keepon & KEEP_READ) &&
+       (FD_ISSET(conn->sockfd, readfdp))) {
+
+      /* read! */
+      result = Curl_read(conn, conn->sockfd, k->buf,
+                         BUFSIZE -1, &nread);
+
+      if(0>result)
+        break; /* get out of loop */
+      if(result>0)
+        return result;
+
+      if ((k->bytecount == 0) && (k->writebytecount == 0))
+        Curl_pgrsTime(data, TIMER_STARTTRANSFER);
+
+      didwhat |= KEEP_READ;
+
+      /* NULL terminate, allowing string ops to be used */
+      if (0 < nread)
+        k->buf[nread] = 0;
+
+      /* if we receive 0 or less here, the server closed the connection and
+         we bail out from this! */
+      else if (0 >= nread) {
+        k->keepon &= ~KEEP_READ;
+        FD_ZERO(&k->rkeepfd);
 	break;
-      default:
-        if((keepon & KEEP_READ) && FD_ISSET(conn->sockfd, &readfd)) {
-          /* read! */
-          urg = Curl_read(conn, conn->sockfd, buf, BUFSIZE -1, &nread);
-
-          /* NULL terminate, allowing string ops to be used */
-          if (0 < (signed int) nread)
-            buf[nread] = 0;
-
-          /* if we receive 0 or less here, the server closed the connection and
-             we bail out from this! */
-          else if (0 >= (signed int) nread) {
-            keepon &= ~KEEP_READ;
-            FD_ZERO(&rkeepfd);
-            break;
-          }
-
-          str = buf;		/* Default buffer to use when we write the
-                                   buffer, it may be changed in the flow below
-                                   before the actual storing is done. */
-
-          /* Since this is a two-state thing, we check if we are parsing
-             headers at the moment or not. */
-          
-          if (header) {
-            /* we are in parse-the-header-mode */
+      }
 
-            /* header line within buffer loop */
-            do {
-              int hbufp_index;
+      /* Default buffer to use when we write the buffer, it may be changed
+         in the flow below before the actual storing is done. */
+      k->str = k->buf;
+
+      /* Since this is a two-state thing, we check if we are parsing
+         headers at the moment or not. */          
+      if (k->header) {
+        /* we are in parse-the-header-mode */
+        bool stop_reading = FALSE;
+
+        /* header line within buffer loop */
+        do {
+          int hbufp_index;
               
-              str_start = str;	/* str_start is start of line within buf */
+          /* str_start is start of line within buf */
+          k->str_start = k->str;
               
-              end_ptr = strchr (str_start, '\n');
+          k->end_ptr = strchr (k->str_start, '\n');
               
-              if (!end_ptr) {
-                /* no more complete header lines within buffer */
-                /* copy what is remaining into headerbuff */
-                int str_length = (int)strlen(str);
-
-                /*
-                 * We enlarge the header buffer if it seems to be too
-                 * smallish
-                 */
-                if (hbuflen + (int)str_length >= data->state.headersize) {
-                  char *newbuff;
-                  long newsize=MAX((hbuflen+str_length)*3/2,
-                                   data->state.headersize*2);
-                  hbufp_index = hbufp - data->state.headerbuff;
-                  newbuff = (char *)realloc(data->state.headerbuff, newsize);
-                  if(!newbuff) {
-                    failf (data, "Failed to alloc memory for big header!");
-                    return CURLE_READ_ERROR;
-                  }
-                  data->state.headersize=newsize;
-                  data->state.headerbuff = newbuff;
-                  hbufp = data->state.headerbuff + hbufp_index;
-                }
-                strcpy (hbufp, str);
-                hbufp += strlen (str);
-                hbuflen += strlen (str);
-                break;		/* read more and try again */
+          if (!k->end_ptr) {
+            /* no more complete header lines within buffer */
+            /* copy what is remaining into headerbuff */
+            int str_length = (int)strlen(k->str);
+
+            /*
+             * We enlarge the header buffer if it seems to be too
+             * smallish
+             */
+            if (k->hbuflen + (int)str_length >=
+                data->state.headersize) {
+              char *newbuff;
+              long newsize=MAX((k->hbuflen+str_length)*3/2,
+                               data->state.headersize*2);
+              hbufp_index = k->hbufp - data->state.headerbuff;
+              newbuff = (char *)realloc(data->state.headerbuff, newsize);
+              if(!newbuff) {
+                failf (data, "Failed to alloc memory for big header!");
+                return CURLE_OUT_OF_MEMORY;
               }
+              data->state.headersize=newsize;
+              data->state.headerbuff = newbuff;
+              k->hbufp = data->state.headerbuff + hbufp_index;
+            }
+            strcpy (k->hbufp, k->str);
+            k->hbufp += strlen (k->str);
+            k->hbuflen += strlen (k->str);
+            break;		/* read more and try again */
+          }
 
-              str = end_ptr + 1;	/* move just past new line */
+          k->str = k->end_ptr + 1; /* move past new line */
 
-              /*
-               * We're about to copy a chunk of data to the end of the
-               * already received header. We make sure that the full string
-               * fit in the allocated header buffer, or else we enlarge 
-               * it.
-               */
-              if (hbuflen + (str - str_start) >= data->state.headersize) {
-                char *newbuff;
-                long newsize=MAX((hbuflen+(str-str_start))*3/2,
-                                 data->state.headersize*2);
-                hbufp_index = hbufp - data->state.headerbuff;
-                newbuff = (char *)realloc(data->state.headerbuff, newsize);
-                if(!newbuff) {
-                  failf (data, "Failed to alloc memory for big header!");
-                  return CURLE_READ_ERROR;
-                }
-                data->state.headersize= newsize;
-                data->state.headerbuff = newbuff;
-                hbufp = data->state.headerbuff + hbufp_index;
-              }
+          /*
+           * We're about to copy a chunk of data to the end of the
+           * already received header. We make sure that the full string
+           * fit in the allocated header buffer, or else we enlarge 
+           * it.
+           */
+          if (k->hbuflen + (k->str - k->str_start) >=
+              data->state.headersize) {
+            char *newbuff;
+            long newsize=MAX((k->hbuflen+
+                              (k->str-k->str_start))*3/2,
+                             data->state.headersize*2);
+            hbufp_index = k->hbufp - data->state.headerbuff;
+            newbuff = (char *)realloc(data->state.headerbuff, newsize);
+            if(!newbuff) {
+              failf (data, "Failed to alloc memory for big header!");
+              return CURLE_OUT_OF_MEMORY;
+            }
+            data->state.headersize= newsize;
+            data->state.headerbuff = newbuff;
+            k->hbufp = data->state.headerbuff + hbufp_index;
+          }
 
-              /* copy to end of line */
-              strncpy (hbufp, str_start, str - str_start);
-              hbufp += str - str_start;
-              hbuflen += str - str_start;
-              *hbufp = 0;
+          /* copy to end of line */
+          strncpy (k->hbufp, k->str_start, k->str - k->str_start);
+          k->hbufp += k->str - k->str_start;
+          k->hbuflen += k->str - k->str_start;
+          *k->hbufp = 0;
               
-              p = data->state.headerbuff;
+          k->p = data->state.headerbuff;
               
-              /****
-               * We now have a FULL header line that p points to
-               *****/
-
-              if (('\n' == *p) || ('\r' == *p)) {
-                /* Zero-length header line means end of headers! */
-
-                if ('\r' == *p)
-                  p++;		/* pass the \r byte */
-                if ('\n' == *p)
-                  p++;		/* pass the \n byte */
-
-                if(100 == httpcode) {
-                  /*
-                   * we have made a HTTP PUT or POST and this is 1.1-lingo
-                   * that tells us that the server is OK with this and ready
-                   * to receive our stuff.
-                   * However, we'll get more headers now so we must get
-                   * back into the header-parsing state!
-                   */
-                  header = TRUE;
-                  headerline = 0; /* we restart the header line counter */
-                  /* if we did wait for this do enable write now! */
-                  if (write_after_100_header) {
-                    write_after_100_header = FALSE;
-                    FD_SET (conn->writesockfd, &writefd); /* write socket */
-                    keepon |= KEEP_WRITE;
-                    wkeepfd = writefd;
-                  }
-                }
-		else
-                  header = FALSE;	/* no more header to parse! */
-
-		if (417 == httpcode) {
-		  /*
-		   * we got: "417 Expectation Failed" this means:
-		   * we have made a HTTP call and our Expect Header
-		   * seems to cause a problem => abort the write operations
-		   * (or prevent them from starting
-		   */
-		  write_after_100_header = FALSE;
-		  keepon &= ~KEEP_WRITE;
-		  FD_ZERO(&wkeepfd);
-		}
-
-                /* now, only output this if the header AND body are requested:
-                 */
-                writetype = CLIENTWRITE_HEADER;
-                if (data->set.http_include_header)
-                  writetype |= CLIENTWRITE_BODY;
-
-                urg = Curl_client_write(data, writetype, data->state.headerbuff,
-                                        p - data->state.headerbuff);
-                if(urg)
-                  return urg;
-
-                data->info.header_size += p - data->state.headerbuff;
-
-                if(!header) {
-                  /*
-                   * really end-of-headers.
-                   *
-                   * If we requested a "no body", this is a good time to get
-                   * out and return home.
-                   */
-                  if(data->set.no_body)
-                    return CURLE_OK;
-
-                  if(!conn->bits.close) {
-                    /* If this is not the last request before a close, we must
-                       set the maximum download size to the size of the
-                       expected document or else, we won't know when to stop
-                       reading! */
-                    if(-1 != conn->size)
-                      conn->maxdownload = conn->size;
-
-                    /* If max download size is *zero* (nothing) we already
-                       have nothing and can safely return ok now! */
-                    if(0 == conn->maxdownload)
-                      return CURLE_OK;
-                    
-                    /* What to do if the size is *not* known? */
-                  }
-                  break;		/* exit header line loop */
-                }
+          /****
+           * We now have a FULL header line that p points to
+           *****/
+
+          if (('\n' == *k->p) || ('\r' == *k->p)) {
+            int headerlen;
+            /* Zero-length header line means end of headers! */
+
+            if ('\r' == *k->p)
+              k->p++; /* pass the \r byte */
+            if ('\n' == *k->p)
+              k->p++; /* pass the \n byte */
 
-                /* We continue reading headers, so reset the line-based
-                   header parsing variables hbufp && hbuflen */
-                hbufp = data->state.headerbuff;
-                hbuflen = 0;
-                continue;
+            if(100 == k->httpcode) {
+              /*
+               * we have made a HTTP PUT or POST and this is 1.1-lingo
+               * that tells us that the server is OK with this and ready
+               * to receive our stuff.
+               * However, we'll get more headers now so we must get
+               * back into the header-parsing state!
+               */
+              k->header = TRUE;
+              k->headerline = 0; /* restart the header line counter */
+              /* if we did wait for this do enable write now! */
+              if (k->write_after_100_header) {
+
+                k->write_after_100_header = FALSE;
+                FD_SET (conn->writesockfd, &k->writefd); /* write */
+                k->keepon |= KEEP_WRITE;
+                k->wkeepfd = k->writefd;
               }
+            }
+            else
+              k->header = FALSE; /* no more header to parse! */
 
+            if (417 == k->httpcode) {
               /*
-               * Checks for special headers coming up.
+               * we got: "417 Expectation Failed" this means:
+               * we have made a HTTP call and our Expect Header
+               * seems to cause a problem => abort the write operations
+               * (or prevent them from starting
                */
-              
-              if (!headerline++) {
-                /* This is the first header, it MUST be the error code line
-                   or else we consiser this to be the body right away! */
-                int httpversion_major;
-                int nc=sscanf (p, " HTTP/%d.%d %3d",
-                               &httpversion_major ,&httpversion, &httpcode);
-                if (nc==3) {
-                  httpversion+=10*httpversion_major;
-                }
-                else {
-                  /* this is the real world, not a Nirvana
-                     NCSA 1.5.x returns this crap when asked for HTTP/1.1
-                  */
-                  nc=sscanf (p, " HTTP %3d", &httpcode);
-                  httpversion = 10;
-                }
-
-                if (nc) {
-                  data->info.httpcode = httpcode;
-                  data->info.httpversion = httpversion;
-
-                  /* 404 -> URL not found! */
-                  if (
-                      ( ((data->set.http_follow_location) &&
-                         (httpcode >= 400))
-                        ||
-                        (!data->set.http_follow_location &&
-                         (httpcode >= 300)))
-                      && (data->set.http_fail_on_error)) {
-                    /* If we have been told to fail hard on HTTP-errors,
-                       here is the check for that: */
-                    /* serious error, go home! */
-                    failf (data, "The requested file was not found");
-                    return CURLE_HTTP_NOT_FOUND;
-                  }
+              k->write_after_100_header = FALSE;
+              k->keepon &= ~KEEP_WRITE;
+              FD_ZERO(&k->wkeepfd);
+            }
 
-                  if(httpversion == 10)
-                    /* Default action for HTTP/1.0 must be to close, unless
-                       we get one of those fancy headers that tell us the
-                       server keeps it open for us! */
-                    conn->bits.close = TRUE;
-
-                  if (httpcode == 304)
-                    /* (quote from RFC2616, section 10.3.5):
-                     *  The 304 response MUST NOT contain a
-                     * message-body, and thus is always
-                     * terminated by the first empty line
-                     * after the header fields.
-                     */
-                    conn->size=0;
-                }
-                else {
-                  header = FALSE;	/* this is not a header line */
-                  break;
-                }
-              }
-              /* check for Content-Length: header lines to get size */
-              if (strnequal("Content-Length:", p, 15) &&
-                  sscanf (p+15, " %ld", &contentlength)) {
-                conn->size = contentlength;
-                Curl_pgrsSetDownloadSize(data, contentlength);
-              }
-              else if((httpversion == 10) &&
-                      conn->bits.httpproxy &&
-                      compareheader(p, "Proxy-Connection:", "keep-alive")) {
-                /*
-                 * When a HTTP/1.0 reply comes when using a proxy, the
-                 * 'Proxy-Connection: keep-alive' line tells us the
-                 * connection will be kept alive for our pleasure.
-                 * Default action for 1.0 is to close.
-                 */
-                conn->bits.close = FALSE; /* don't close when done */
-                infof(data, "HTTP/1.0 proxy connection set to keep alive!\n");
-              }
-              else if((httpversion == 10) &&
-                      compareheader(p, "Connection:", "keep-alive")) {
-                /*
-                 * A HTTP/1.0 reply with the 'Connection: keep-alive' line
-                 * tells us the connection will be kept alive for our
-                 * pleasure.  Default action for 1.0 is to close.
-                 *
-                 * [RFC2068, section 19.7.1] */
-                conn->bits.close = FALSE; /* don't close when done */
-                infof(data, "HTTP/1.0 connection set to keep alive!\n");
-              }
-              else if (compareheader(p, "Connection:", "close")) {
-                /*
-                 * [RFC 2616, section 8.1.2.1]
-                 * "Connection: close" is HTTP/1.1 language and means that
-                 * the connection will close when this request has been
-                 * served.
-                 */
-                conn->bits.close = TRUE; /* close when done */
-              }
-              else if (compareheader(p, "Transfer-Encoding:", "chunked")) {
-                /*
-                 * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
-                 * means that the server will send a series of "chunks". Each
-                 * chunk starts with line with info (including size of the
-                 * coming block) (terminated with CRLF), then a block of data
-                 * with the previously mentioned size. There can be any amount
-                 * of chunks, and a chunk-data set to zero signals the
-                 * end-of-chunks. */
-                conn->bits.chunk = TRUE; /* chunks coming our way */
+            /* now, only output this if the header AND body are requested:
+             */
+            k->writetype = CLIENTWRITE_HEADER;
+            if (data->set.http_include_header)
+              k->writetype |= CLIENTWRITE_BODY;
+
+            headerlen = k->p - data->state.headerbuff;
+
+            result = Curl_client_write(data, k->writetype,
+                                       data->state.headerbuff,
+                                       headerlen);
+            if(result)
+              return result;
+
+            data->info.header_size += headerlen;
+            conn->headerbytecount += headerlen;
 
-                /* init our chunky engine */
-                Curl_httpchunk_init(conn);
+            if(!k->header) {
+              /*
+               * really end-of-headers.
+               *
+               * If we requested a "no body", this is a good time to get
+               * out and return home.
+               */
+              if(data->set.no_body)
+                stop_reading = TRUE;
+              else if(!conn->bits.close) {
+                /* If this is not the last request before a close, we must
+                   set the maximum download size to the size of the
+                   expected document or else, we won't know when to stop
+                   reading! */
+                if(-1 != conn->size)
+                  conn->maxdownload = conn->size;
               }
-              else if (strnequal("Content-Range:", p, 14)) {
-                if (sscanf (p+14, " bytes %d-", &offset) ||
-                    sscanf (p+14, " bytes: %d-", &offset)) {
-                  /* This second format was added August 1st 2000 by Igor
-                     Khristophorov since Sun's webserver JavaWebServer/1.1.1
-                     obviously sends the header this way! :-( */
-                  if (conn->resume_from == offset) {
-                    /* we asked for a resume and we got it */
-                    content_range = TRUE;
-                  }
-                }
+              /* If max download size is *zero* (nothing) we already
+                 have nothing and can safely return ok now! */
+              if(0 == conn->maxdownload)
+                stop_reading = TRUE;
+                    
+              if(stop_reading) {
+                /* we make sure that this socket isn't read more now */
+                k->keepon &= ~KEEP_READ;
+                FD_ZERO(&k->rkeepfd);
               }
-              else if(data->cookies &&
-                      strnequal("Set-Cookie:", p, 11)) {
-                Curl_cookie_add(data->cookies, TRUE, &p[12]);
+
+              break;		/* exit header line loop */
+            }
+
+            /* We continue reading headers, so reset the line-based
+               header parsing variables hbufp && hbuflen */
+            k->hbufp = data->state.headerbuff;
+            k->hbuflen = 0;
+            continue;
+          }
+
+          /*
+           * Checks for special headers coming up.
+           */
+              
+          if (!k->headerline++) {
+            /* This is the first header, it MUST be the error code line
+               or else we consiser this to be the body right away! */
+            int httpversion_major;
+            int nc=sscanf (k->p, " HTTP/%d.%d %3d",
+                           &httpversion_major,
+                           &k->httpversion,
+                           &k->httpcode);
+            if (nc==3) {
+              k->httpversion += 10 * httpversion_major;
+            }
+            else {
+              /* this is the real world, not a Nirvana
+                 NCSA 1.5.x returns this crap when asked for HTTP/1.1
+              */
+              nc=sscanf (k->p, " HTTP %3d", &k->httpcode);
+              k->httpversion = 10;
+            }
+
+            if (nc) {
+              data->info.httpcode = k->httpcode;
+              data->info.httpversion = k->httpversion;
+
+              /* 404 -> URL not found! */
+              if (data->set.http_fail_on_error &&
+                  (k->httpcode >= 400)) {
+                /* If we have been told to fail hard on HTTP-errors,
+                   here is the check for that: */
+                /* serious error, go home! */
+                failf (data, "The requested file was not found");
+                return CURLE_HTTP_NOT_FOUND;
               }
-              else if(strnequal("Last-Modified:", p,
-                                strlen("Last-Modified:")) &&
-                      (data->set.timecondition || data->set.get_filetime) ) {
-                time_t secs=time(NULL);
-                timeofdoc = curl_getdate(p+strlen("Last-Modified:"), &secs);
-                if(data->set.get_filetime)
-                  data->info.filetime = timeofdoc;
+
+              if(k->httpversion == 10)
+                /* Default action for HTTP/1.0 must be to close, unless
+                   we get one of those fancy headers that tell us the
+                   server keeps it open for us! */
+                conn->bits.close = TRUE;
+
+              switch(k->httpcode) {
+              case 204:
+                /* (quote from RFC2616, section 10.2.5): The server has
+                 * fulfilled the request but does not need to return an
+                 * entity-body ... The 204 response MUST NOT include a
+                 * message-body, and thus is always terminated by the first
+                 * empty line after the header fields. */
+                /* FALLTHROUGH */
+              case 304:
+                /* (quote from RFC2616, section 10.3.5): The 304 response MUST
+                 * NOT contain a message-body, and thus is always terminated
+                 * by the first empty line after the header fields.  */
+                conn->size=0;
+                conn->maxdownload=0;
+                break;
+              default:
+                /* nothing */
+                break;
               }
-              else if ((httpcode >= 300 && httpcode < 400) &&
-                       (data->set.http_follow_location) &&
-                       strnequal("Location:", p, 9)) {
-                /* this is the URL that the server advices us to get instead */
-                char *ptr;
-                char *start=p;
-                char backup;
-
-                start += 9; /* pass "Location:" */
-
-                /* Skip spaces and tabs. We do this to support multiple
-                   white spaces after the "Location:" keyword. */
-                while(*start && isspace((int)*start ))
-                  start++;
-                ptr = start; /* start scanning here */
-
-                /* scan through the string to find the end */
-                while(*ptr && !isspace((int)*ptr))
-                  ptr++;
-                backup = *ptr; /* store the ending letter */
-                *ptr = '\0';   /* zero terminate */
-                conn->newurl = strdup(start); /* clone string */
-                *ptr = backup; /* restore ending letter */
+            }
+            else {
+              k->header = FALSE;	/* this is not a header line */
+              break;
+            }
+          }
+          /* check for Content-Length: header lines to get size */
+          if (strnequal("Content-Length:", k->p, 15) &&
+              sscanf (k->p+15, " %ld", &k->contentlength)) {
+            conn->size = k->contentlength;
+            Curl_pgrsSetDownloadSize(data, k->contentlength);
+          }
+          /* check for Content-Type: header lines to get the mime-type */
+          else if (strnequal("Content-Type:", k->p, 13)) {
+            char *start;
+            char *end;
+            int len;
+
+            /* Find the first non-space letter */
+            for(start=k->p+14;
+                *start && isspace((int)*start);
+                start++);
+
+            /* count all non-space letters following */
+            for(end=start, len=0;
+                *end && !isspace((int)*end);
+                end++, len++);
+
+            /* allocate memory of a cloned copy */
+            data->info.contenttype = malloc(len + 1);
+            if (NULL == data->info.contenttype)
+	      return CURLE_OUT_OF_MEMORY;
+
+            /* copy the content-type string */
+	    memcpy(data->info.contenttype, start, len);
+            data->info.contenttype[len] = 0; /* zero terminate */
+          }
+          else if((k->httpversion == 10) &&
+                  conn->bits.httpproxy &&
+                  compareheader(k->p, "Proxy-Connection:", "keep-alive")) {
+            /*
+             * When a HTTP/1.0 reply comes when using a proxy, the
+             * 'Proxy-Connection: keep-alive' line tells us the
+             * connection will be kept alive for our pleasure.
+             * Default action for 1.0 is to close.
+             */
+            conn->bits.close = FALSE; /* don't close when done */
+            infof(data, "HTTP/1.0 proxy connection set to keep alive!\n");
+          }
+          else if((k->httpversion == 10) &&
+                  compareheader(k->p, "Connection:", "keep-alive")) {
+            /*
+             * A HTTP/1.0 reply with the 'Connection: keep-alive' line
+             * tells us the connection will be kept alive for our
+             * pleasure.  Default action for 1.0 is to close.
+             *
+             * [RFC2068, section 19.7.1] */
+            conn->bits.close = FALSE; /* don't close when done */
+            infof(data, "HTTP/1.0 connection set to keep alive!\n");
+          }
+          else if (compareheader(k->p, "Connection:", "close")) {
+            /*
+             * [RFC 2616, section 8.1.2.1]
+             * "Connection: close" is HTTP/1.1 language and means that
+             * the connection will close when this request has been
+             * served.
+             */
+            conn->bits.close = TRUE; /* close when done */
+          }
+          else if (compareheader(k->p, "Transfer-Encoding:", "chunked")) {
+            /*
+             * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
+             * means that the server will send a series of "chunks". Each
+             * chunk starts with line with info (including size of the
+             * coming block) (terminated with CRLF), then a block of data
+             * with the previously mentioned size. There can be any amount
+             * of chunks, and a chunk-data set to zero signals the
+             * end-of-chunks. */
+            conn->bits.chunk = TRUE; /* chunks coming our way */
+
+            /* init our chunky engine */
+            Curl_httpchunk_init(conn);
+          }
+          else if (strnequal("Content-Range:", k->p, 14)) {
+            if (sscanf (k->p+14, " bytes %d-", &k->offset) ||
+                sscanf (k->p+14, " bytes: %d-", &k->offset)) {
+              /* This second format was added August 1st 2000 by Igor
+                 Khristophorov since Sun's webserver JavaWebServer/1.1.1
+                 obviously sends the header this way! :-( */
+              if (conn->resume_from == k->offset) {
+                /* we asked for a resume and we got it */
+                k->content_range = TRUE;
               }
+            }
+          }
+          else if(data->cookies &&
+                  strnequal("Set-Cookie:", k->p, 11)) {
+            Curl_cookie_add(data->cookies, TRUE, k->p+12, conn->name);
+          }
+          else if(strnequal("Last-Modified:", k->p,
+                            strlen("Last-Modified:")) &&
+                  (data->set.timecondition || data->set.get_filetime) ) {
+            time_t secs=time(NULL);
+            k->timeofdoc = curl_getdate(k->p+strlen("Last-Modified:"),
+                                        &secs);
+            if(data->set.get_filetime)
+              data->info.filetime = k->timeofdoc;
+          }
+          else if ((k->httpcode >= 300 && k->httpcode < 400) &&
+                   (data->set.http_follow_location) &&
+                   strnequal("Location:", k->p, 9)) {
+            /* this is the URL that the server advices us to get instead */
+            char *ptr;
+            char *start=k->p;
+            char backup;
+
+            start += 9; /* pass "Location:" */
+
+            /* Skip spaces and tabs. We do this to support multiple
+               white spaces after the "Location:" keyword. */
+            while(*start && isspace((int)*start ))
+              start++;
+            ptr = start; /* start scanning here */
+
+            /* scan through the string to find the end */
+            while(*ptr && !isspace((int)*ptr))
+              ptr++;
+            backup = *ptr; /* store the ending letter */
+            *ptr = '\0';   /* zero terminate */
+            conn->newurl = strdup(start); /* clone string */
+            *ptr = backup; /* restore ending letter */
+          }
 
-              /*
-               * End of header-checks. Write them to the client.
-               */
+          /*
+           * End of header-checks. Write them to the client.
+           */
 
-              writetype = CLIENTWRITE_HEADER;
-              if (data->set.http_include_header)
-                writetype |= CLIENTWRITE_BODY;
-
-              urg = Curl_client_write(data, writetype, p, hbuflen);
-              if(urg)
-                return urg;
+          k->writetype = CLIENTWRITE_HEADER;
+          if (data->set.http_include_header)
+            k->writetype |= CLIENTWRITE_BODY;
+
+          if(data->set.verbose)
+            Curl_debug(data, CURLINFO_HEADER_IN,
+                       k->p, k->hbuflen);
+
+          result = Curl_client_write(data, k->writetype, k->p,
+                                     k->hbuflen);
+          if(result)
+            return result;
 
-              data->info.header_size += hbuflen;
+          data->info.header_size += k->hbuflen;
+          conn->headerbytecount += k->hbuflen;
               
-              /* reset hbufp pointer && hbuflen */
-              hbufp = data->state.headerbuff;
-              hbuflen = 0;
-            }
-            while (*str);		/* header line within buffer */
+          /* reset hbufp pointer && hbuflen */
+          k->hbufp = data->state.headerbuff;
+          k->hbuflen = 0;
+        }
+        while (!stop_reading && *k->str); /* header line within buffer */
 
-            /* We might have reached the end of the header part here, but
-               there might be a non-header part left in the end of the read
-               buffer. */
-
-            if (!header) {
-              /* the next token and forward is not part of
-                 the header! */
+        if(stop_reading)
+          /* We've stopped dealing with input, get out of the do-while loop */
+          break;
 
-              /* we subtract the remaining header size from the buffer */
-              nread -= (str - buf);
-            }
+        /* We might have reached the end of the header part here, but
+           there might be a non-header part left in the end of the read
+           buffer. */
+
+        if (!k->header) {
+          /* the next token and forward is not part of
+             the header! */
 
-          }			/* end if header mode */
+          /* we subtract the remaining header size from the buffer */
+          nread -= (k->str - k->buf);
+        }
+
+      }			/* end if header mode */
 
-          /* This is not an 'else if' since it may be a rest from the header
-             parsing, where the beginning of the buffer is headers and the end
-             is non-headers. */
-          if (str && !header && ((signed int)nread > 0)) {
+      /* This is not an 'else if' since it may be a rest from the header
+         parsing, where the beginning of the buffer is headers and the end
+         is non-headers. */
+      if (k->str && !k->header && (nread > 0)) {
             
-            if(0 == bodywrites) {
-              /* These checks are only made the first time we are about to
-                 write a piece of the body */
-              if(conn->protocol&PROT_HTTP) {
-                /* HTTP-only checks */
-                if (conn->newurl) {
-                  /* abort after the headers if "follow Location" is set */
-                  infof (data, "Follow to new URL: %s\n", conn->newurl);
-                  return CURLE_OK;
-                }
-                else if (conn->resume_from &&
-                         !content_range &&
-                         (data->set.httpreq==HTTPREQ_GET)) {
-                  /* we wanted to resume a download, although the server
-                     doesn't seem to support this and we did this with a GET
-                     (if it wasn't a GET we did a POST or PUT resume) */
-                  failf (data, "HTTP server doesn't seem to support "
-                         "byte ranges. Cannot resume.");
-                  return CURLE_HTTP_RANGE_ERROR;
-                }
-                else if(data->set.timecondition && !conn->range) {
-                  /* A time condition has been set AND no ranges have been
-                     requested. This seems to be what chapter 13.3.4 of
-                     RFC 2616 defines to be the correct action for a
-                     HTTP/1.1 client */
-                  if((timeofdoc > 0) && (data->set.timevalue > 0)) {
-                    switch(data->set.timecondition) {
-                    case TIMECOND_IFMODSINCE:
-                    default:
-                      if(timeofdoc < data->set.timevalue) {
-                        infof(data,
-                              "The requested document is not new enough\n");
-                        return CURLE_OK;
-                      }
-                      break;
-                    case TIMECOND_IFUNMODSINCE:
-                      if(timeofdoc > data->set.timevalue) {
-                        infof(data,
-                              "The requested document is not old enough\n");
-                        return CURLE_OK;
-                      }
-                      break;
-                    } /* switch */
-                  } /* two valid time strings */
-                } /* we have a time condition */
-
-              } /* this is HTTP */
-            } /* this is the first time we write a body part */
-            bodywrites++;
+        if(0 == k->bodywrites) {
+          /* These checks are only made the first time we are about to
+             write a piece of the body */
+          if(conn->protocol&PROT_HTTP) {
+            /* HTTP-only checks */
+            if (conn->newurl) {
+              /* abort after the headers if "follow Location" is set */
+              infof (data, "Follow to new URL: %s\n", conn->newurl);
+                k->keepon &= ~KEEP_READ;
+                FD_ZERO(&k->rkeepfd);
+              return CURLE_OK;
+            }
+            else if (conn->resume_from &&
+                     !k->content_range &&
+                     (data->set.httpreq==HTTPREQ_GET)) {
+              /* we wanted to resume a download, although the server
+                 doesn't seem to support this and we did this with a GET
+                 (if it wasn't a GET we did a POST or PUT resume) */
+              failf (data, "HTTP server doesn't seem to support "
+                     "byte ranges. Cannot resume.");
+              return CURLE_HTTP_RANGE_ERROR;
+            }
+            else if(data->set.timecondition && !conn->range) {
+              /* A time condition has been set AND no ranges have been
+                 requested. This seems to be what chapter 13.3.4 of
+                 RFC 2616 defines to be the correct action for a
+                 HTTP/1.1 client */
+              if((k->timeofdoc > 0) && (data->set.timevalue > 0)) {
+                switch(data->set.timecondition) {
+                case TIMECOND_IFMODSINCE:
+                default:
+                  if(k->timeofdoc < data->set.timevalue) {
+                    infof(data,
+                          "The requested document is not new enough\n");
+                    return CURLE_OK;
+                  }
+                  break;
+                case TIMECOND_IFUNMODSINCE:
+                  if(k->timeofdoc > data->set.timevalue) {
+                    infof(data,
+                          "The requested document is not old enough\n");
+                    return CURLE_OK;
+                  }
+                  break;
+                } /* switch */
+              } /* two valid time strings */
+            } /* we have a time condition */
+
+          } /* this is HTTP */
+        } /* this is the first time we write a body part */
+        k->bodywrites++;
+
+        /* pass data to the debug function before it gets "dechunked" */
+        if(data->set.verbose)
+          Curl_debug(data, CURLINFO_DATA_IN, k->str, nread);
 
-            if(conn->bits.chunk) {
-              /*
-               * Bless me father for I have sinned. Here comes a chunked
-               * transfer flying and we need to decode this properly.  While
-               * the name says read, this function both reads and writes away
-               * the data. The returned 'nread' holds the number of actual
-               * data it wrote to the client.  */
-              CHUNKcode res =
-                Curl_httpchunk_read(conn, str, nread, &nread);
-
-              if(CHUNKE_OK < res) {
-                failf(data, "Receeived problem in the chunky parser");
-                return CURLE_READ_ERROR;
-              }
-              else if(CHUNKE_STOP == res) {
-                /* we're done reading chunks! */
-                keepon &= ~KEEP_READ; /* read no more */
-                FD_ZERO(&rkeepfd);
-
-                /* There are now possibly N number of bytes at the end of the
-                   str buffer that weren't written to the client, but we don't
-                   care about them right now. */
-              }
-              /* If it returned OK, we just keep going */
+        if(conn->bits.chunk) {
+          /*
+           * Bless me father for I have sinned. Here comes a chunked
+           * transfer flying and we need to decode this properly.  While
+           * the name says read, this function both reads and writes away
+           * the data. The returned 'nread' holds the number of actual
+           * data it wrote to the client.  */
+          CHUNKcode res =
+            Curl_httpchunk_read(conn, k->str, nread, &nread);
+
+          if(CHUNKE_OK < res) {
+            if(CHUNKE_WRITE_ERROR == res) {
+              failf(data, "Failed writing data");
+              return CURLE_WRITE_ERROR;
             }
+            failf(data, "Received problem in the chunky parser");
+            return CURLE_RECV_ERROR;
+          }
+          else if(CHUNKE_STOP == res) {
+            /* we're done reading chunks! */
+            k->keepon &= ~KEEP_READ; /* read no more */
+            FD_ZERO(&k->rkeepfd);
+
+            /* There are now possibly N number of bytes at the end of the
+               str buffer that weren't written to the client, but we don't
+               care about them right now. */
+          }
+          /* If it returned OK, we just keep going */
+        }
 
-            if((-1 != conn->maxdownload) &&
-               (bytecount + nread >= conn->maxdownload)) {
-              nread = conn->maxdownload - bytecount;
-              if((signed int)nread < 0 ) /* this should be unusual */
-                nread = 0;
+        if((-1 != conn->maxdownload) &&
+           (k->bytecount + nread >= conn->maxdownload)) {
+          nread = conn->maxdownload - k->bytecount;
+          if(nread < 0 ) /* this should be unusual */
+            nread = 0;
 
-              keepon &= ~KEEP_READ; /* we're done reading */
-              FD_ZERO(&rkeepfd);
-            }
+          k->keepon &= ~KEEP_READ; /* we're done reading */
+          FD_ZERO(&k->rkeepfd);
+        }
 
-            bytecount += nread;
+        k->bytecount += nread;
 
-            Curl_pgrsSetDownloadCounter(data, (double)bytecount);
+        Curl_pgrsSetDownloadCounter(data, (double)k->bytecount);
             
-            if(!conn->bits.chunk && nread) {
-              /* If this is chunky transfer, it was already written */
-              urg = Curl_client_write(data, CLIENTWRITE_BODY, str, nread);
-              if(urg)
-                return urg;
-            }
+        if(!conn->bits.chunk && nread) {
+          /* If this is chunky transfer, it was already written */
+          result = Curl_client_write(data, CLIENTWRITE_BODY, k->str,
+                                     nread);
+          if(result)
+            return result;
+        }
 
-          } /* if (! header and data to read ) */
-        } /* if( read from socket ) */
+      } /* if (! header and data to read ) */
+    } /* if( read from socket ) */
 
-        if((keepon & KEEP_WRITE) && FD_ISSET(conn->writesockfd, &writefd)) {
-          /* write */
+    /* If we still have writing to do, we check if we have a writable
+       socket. Sometimes the writefdp is NULL, it no fd_set was done using
+       the multi interface and then we can do nothing but to attempt a
+       write to be sure. */
+    if((k->keepon & KEEP_WRITE) &&
+       (FD_ISSET(conn->writesockfd, writefdp)) ) {
+      /* write */
+
+      int i, si;
+      ssize_t bytes_written;
+
+      if ((k->bytecount == 0) && (k->writebytecount == 0))
+        Curl_pgrsTime(data, TIMER_STARTTRANSFER);
+
+      didwhat |= KEEP_WRITE;
+
+      /* only read more data if there's no upload data already
+         present in the upload buffer */
+      if(0 == conn->upload_present) {
+        /* init the "upload from here" pointer */
+        conn->upload_fromhere = k->uploadbuf;
+
+        nread = data->set.fread(conn->upload_fromhere, 1,
+                                BUFSIZE, data->set.in);
+
+        /* the signed int typecase of nread of for systems that has
+           unsigned size_t */
+        if (nread<=0) {
+          /* done */
+          k->keepon &= ~KEEP_WRITE; /* we're done writing */
+          FD_ZERO(&k->wkeepfd);
+          break;
+        }
 
-          int i, si;
-          size_t bytes_written;
+        /* store number of bytes available for upload */
+        conn->upload_present = nread;
 
-          nread = data->set.fread(buf, 1, conn->upload_bufsize, data->set.in);
-
-          /* the signed int typecase of nread of for systems that has
-             unsigned size_t */
-          if ((signed int)nread<=0) {
-            /* done */
-            keepon &= ~KEEP_WRITE; /* we're done writing */
-            FD_ZERO(&wkeepfd);
-            break;
-          }
-          writebytecount += nread;
-          Curl_pgrsSetUploadCounter(data, (double)writebytecount);            
-
-          /* convert LF to CRLF if so asked */
-          if (data->set.crlf) {
-            for(i = 0, si = 0; i < (int)nread; i++, si++) {
-              if (buf[i] == 0x0a) {
-                data->state.scratch[si++] = 0x0d;
-                data->state.scratch[si] = 0x0a;
-              }
-              else {
-                data->state.scratch[si] = buf[i];
-              }
+        /* convert LF to CRLF if so asked */
+        if (data->set.crlf) {
+          for(i = 0, si = 0; i < nread; i++, si++) {
+            if (conn->upload_fromhere[i] == 0x0a) {
+              data->state.scratch[si++] = 0x0d;
+              data->state.scratch[si] = 0x0a;
             }
-            nread = si;
-            buf = data->state.scratch; /* point to the new buffer */
+            else
+              data->state.scratch[si] = conn->upload_fromhere[i];
           }
+          if(si != nread) {
+            /* only perform the special operation if we really did replace
+               anything */
+            nread = si;
 
-          /* write to socket */
-          urg = Curl_write(conn, conn->writesockfd, buf, nread,
-                           &bytes_written);
+            /* upload from the new (replaced) buffer instead */
+            conn->upload_fromhere = data->state.scratch;
 
-          if(nread != (int)bytes_written) {
-            failf(data, "Failed uploading data");
-            return CURLE_WRITE_ERROR;
+            /* set the new amount too */
+            conn->upload_present = nread;
           }
-          if(data->set.crlf)
-            buf = data->state.buffer; /* put it back on the buffer */
-
         }
-
-        break;
       }
-
-      now = Curl_tvnow();
-      if(Curl_pgrsUpdate(conn))
-        urg = CURLE_ABORTED_BY_CALLBACK;
-      else
-        urg = Curl_speedcheck (data, now);
-      if (urg)
-	return urg;
-
-      if(data->progress.ulspeed > conn->upload_bufsize) {
-        /* If we're transfering more data per second than fits in our buffer,
-           we increase the buffer size to adjust to the current
-           speed. However, we must not set it larger than BUFSIZE. We don't
-           adjust it downwards again since we don't see any point in that!
-        */
-        conn->upload_bufsize=(long)min(data->progress.ulspeed, BUFSIZE);
+      else {
+        /* We have a partial buffer left from a previous "round". Use
+           that instead of reading more data */
       }
 
-      if (data->set.timeout && (Curl_tvdiff (now, start) > data->set.timeout)) {
-	failf (data, "Operation timed out with %d out of %d bytes received",
-	       bytecount, conn->size);
-	return CURLE_OPERATION_TIMEOUTED;
+      /* write to socket */
+      result = Curl_write(conn,
+                          conn->writesockfd,
+                          conn->upload_fromhere,
+                          conn->upload_present,
+                          &bytes_written);
+      if(result)
+        return result;
+      else if(conn->upload_present != bytes_written) {
+        /* we only wrote a part of the buffer (if anything), deal with it! */
+
+        /* store the amount of bytes left in the buffer to write */
+        conn->upload_present -= bytes_written;
+
+        /* advance the pointer where to find the buffer when the next send
+           is to happen */
+        conn->upload_fromhere += bytes_written;
       }
+      else {
+        /* we've uploaded that buffer now */
+        conn->upload_fromhere = k->uploadbuf;
+        conn->upload_present = 0; /* no more bytes left */
+      }
+
+      if(data->set.verbose)
+        Curl_debug(data, CURLINFO_DATA_OUT, conn->upload_fromhere,
+                   bytes_written);
+      
+
+      k->writebytecount += bytes_written;
+      Curl_pgrsSetUploadCounter(data, (double)k->writebytecount);
+
     }
-  }
 
-  /*
-   * The tranfer has been performed. Just make some general checks before
-   * returning.
-   */
+  } while(0); /* just to break out from! */
 
-  if(!(data->set.no_body) && contentlength &&
-     (bytecount != contentlength)) {
-    failf(data, "transfer closed with %d bytes remaining to read",
-          contentlength-bytecount);
-    return CURLE_PARTIAL_FILE;
+  if(didwhat) {
+    /* Update read/write counters */
+    if(conn->bytecountp)
+      *conn->bytecountp = k->bytecount; /* read count */
+    if(conn->writebytecountp)
+      *conn->writebytecountp = k->writebytecount; /* write count */
   }
-  else if(conn->bits.chunk && conn->proto.http->chunk.datasize) {
-    failf(data, "transfer closed with at least %d bytes remaining",
-          conn->proto.http->chunk.datasize);
-    return CURLE_PARTIAL_FILE;
+  else {
+    /* no read no write, this is a timeout? */
+    if (k->write_after_100_header) {
+      /* This should allow some time for the header to arrive, but only a
+         very short time as otherwise it'll be too much wasted times too
+         often. */
+      k->write_after_100_header = FALSE;
+      FD_SET (conn->writesockfd, &k->writefd); /* write socket */
+      k->keepon |= KEEP_WRITE;
+      k->wkeepfd = k->writefd;
+    }    
   }
+
+  k->now = Curl_tvnow();
   if(Curl_pgrsUpdate(conn))
-    return CURLE_ABORTED_BY_CALLBACK;
+    result = CURLE_ABORTED_BY_CALLBACK;
+  else
+    result = Curl_speedcheck (data, k->now);
+  if (result)
+    return result;
+    
+  if (data->set.timeout &&
+      ((Curl_tvdiff(k->now, k->start)/1000) >= data->set.timeout)) {
+    failf (data, "Operation timed out with %d out of %d bytes received",
+           k->bytecount, conn->size);
+    return CURLE_OPERATION_TIMEOUTED;
+  }
+
+  if(!k->keepon) {
+    /*
+     * The transfer has been performed. Just make some general checks before
+     * returning.
+     */
+
+    if(!(data->set.no_body) && k->contentlength &&
+       (k->bytecount != k->contentlength) &&
+       !conn->newurl) {
+      failf(data, "transfer closed with %d bytes remaining to read",
+            k->contentlength-k->bytecount);
+      return CURLE_PARTIAL_FILE;
+    }
+    else if(conn->bits.chunk && conn->proto.http->chunk.datasize) {
+      failf(data, "transfer closed with at least %d bytes remaining",
+            conn->proto.http->chunk.datasize);
+      return CURLE_PARTIAL_FILE;
+    }
+    if(Curl_pgrsUpdate(conn))
+      return CURLE_ABORTED_BY_CALLBACK;
+  }
 
-  if(conn->bytecountp)
-    *conn->bytecountp = bytecount; /* read count */
-  if(conn->writebytecountp)
-    *conn->writebytecountp = writebytecount; /* write count */
+  /* Now update the "done" boolean we return */
+  *done = !k->keepon;
 
   return CURLE_OK;
 }
 
-CURLcode Curl_perform(struct SessionHandle *data)
+CURLcode Curl_readwrite_init(struct connectdata *conn)
 {
-  CURLcode res;
-  struct connectdata *conn=NULL;
-  bool port=TRUE; /* allow data->set.use_port to set port to use */
-  char *newurl = NULL; /* possibly a new URL to follow to! */
+  struct SessionHandle *data = conn->data;
+  struct Curl_transfer_keeper *k = &conn->keep;
+
+  memset(k, 0, sizeof(struct Curl_transfer_keeper));
+
+  k->start = Curl_tvnow(); /* start time */
+  k->now = k->start;   /* current time is now */
+  k->header = TRUE; /* assume header */
+  k->httpversion = -1; /* unknown at this point */
+  k->conn = (struct connectdata *)conn; /* store the connection */
+
+  data = conn->data; /* there's the root struct */
+  k->buf = data->state.buffer;
+  k->uploadbuf = data->state.uploadbuffer;
+  k->maxfd = (conn->sockfd>conn->writesockfd?
+              conn->sockfd:conn->writesockfd)+1;
+  k->hbufp = data->state.headerbuff;
 
+  Curl_pgrsTime(data, TIMER_PRETRANSFER);
+  Curl_speedinit(data);
+
+  Curl_pgrsSetUploadCounter(data, 0);
+  Curl_pgrsSetDownloadCounter(data, 0);
+
+  if (!conn->getheader) {
+    k->header = FALSE;
+    if(conn->size > 0)
+      Curl_pgrsSetDownloadSize(data, conn->size);
+  }
+  /* we want header and/or body, if neither then don't do this! */
+  if(conn->getheader || !data->set.no_body) {
+
+    FD_ZERO (&k->readfd);		/* clear it */
+    if(conn->sockfd != -1) {
+      FD_SET (conn->sockfd, &k->readfd); /* read socket */
+      k->keepon |= KEEP_READ;
+    }
+
+    FD_ZERO (&k->writefd);		/* clear it */
+    if(conn->writesockfd != -1) {
+      if (data->set.expect100header)
+        /* wait with write until we either got 100-continue or a timeout */
+        k->write_after_100_header = TRUE;
+      else {
+        FD_SET (conn->writesockfd, &k->writefd); /* write socket */
+        k->keepon |= KEEP_WRITE;
+      }
+    }
+
+    /* get these in backup variables to be able to restore them on each lap in
+       the select() loop */
+    k->rkeepfd = k->readfd;
+    k->wkeepfd = k->writefd;
+
+  }
+
+  return CURLE_OK;
+}
+
+void Curl_single_fdset(struct connectdata *conn,
+                       fd_set *read_fd_set,
+                       fd_set *write_fd_set,
+                       fd_set *exc_fd_set,
+                       int *max_fd)
+{
+  *max_fd = -1; /* init */
+  if(conn->keep.keepon & KEEP_READ) {
+    FD_SET(conn->sockfd, read_fd_set);
+    *max_fd = conn->sockfd;
+    conn->keep.readfdp = read_fd_set; /* store the address of the set */
+  }
+  if(conn->keep.keepon & KEEP_WRITE) {
+    FD_SET(conn->writesockfd, write_fd_set);
+    if(conn->writesockfd > *max_fd)
+      *max_fd = conn->writesockfd;
+    conn->keep.writefdp = write_fd_set; /* store the address of the set */
+  }
+  /* we don't use exceptions, only touch that one to prevent compiler
+     warnings! */
+  *exc_fd_set = *exc_fd_set;
+}
+
+
+/*
+ * Transfer()
+ *
+ * This function is what performs the actual transfer. It is capable of
+ * doing both ways simultaneously.
+ * The transfer must already have been setup by a call to Curl_Transfer().
+ *
+ * Note that headers are created in a preallocated buffer of a default size.
+ * That buffer can be enlarged on demand, but it is never shrinken again.
+ *
+ * Parts of this function was once written by the friendly Mark Butler
+ * <butlerm@xmission.com>.
+ */
+
+static CURLcode
+Transfer(struct connectdata *conn)
+{
+  struct SessionHandle *data = conn->data;
+  CURLcode result;
+  struct Curl_transfer_keeper *k = &conn->keep;
+  bool done=FALSE;
+
+  Curl_readwrite_init(conn);
+
+  if((conn->sockfd == -1) && (conn->writesockfd == -1))
+    /* nothing to read, nothing to write, we're already OK! */
+    return CURLE_OK;
+
+  /* we want header and/or body, if neither then don't do this! */
+  if(!conn->getheader && data->set.no_body)
+    return CURLE_OK;
+
+  k->writefdp = &k->writefd; /* store the address of the set */
+  k->readfdp = &k->readfd;   /* store the address of the set */
+
+  while (!done) {
+    struct timeval interval;
+    k->readfd = k->rkeepfd;  /* set these every lap in the loop */
+    k->writefd = k->wkeepfd;
+    interval.tv_sec = 1;
+    interval.tv_usec = 0;
+
+    switch (select (k->maxfd, k->readfdp, k->writefdp, NULL, &interval)) {
+    case -1: /* select() error, stop reading */
+#ifdef EINTR
+      /* The EINTR is not serious, and it seems you might get this more
+         ofen when using the lib in a multi-threaded environment! */
+      if(errno == EINTR)
+        ;
+      else
+#endif
+        done = TRUE; /* no more read or write */
+      continue;
+    case 0:  /* timeout */
+      result = Curl_readwrite(conn, &done);
+      break;
+
+    default: /* readable descriptors */
+      result = Curl_readwrite(conn, &done);
+      break;
+    }
+    if(result)
+      return result;
+    
+    /* "done" signals to us if the transfer(s) are ready */
+  }
+
+  return CURLE_OK;
+}
+
+CURLcode Curl_pretransfer(struct SessionHandle *data)
+{
   if(!data->change.url)
     /* we can't do anything wihout URL */
     return CURLE_URL_MALFORMAT;
 
 #ifdef USE_SSLEAY
   /* Init the SSL session ID cache here. We do it here since we want to
@@ -913,40 +1114,103 @@
      before any transfer. */
   Curl_SSL_InitSessions(data, data->set.ssl.numsessions);
 #endif
 
   data->set.followlocation=0; /* reset the location-follow counter */
   data->state.this_is_a_follow = FALSE; /* reset this */
+  data->state.errorbuf = FALSE; /* no error has occurred */
 
-  Curl_initinfo(data); /* reset session-specific information "variables" */
+ /* Allow data->set.use_port to set which port to use. This needs to be
+  * disabled for example when we follow Location: headers to URLs using
+  * different ports! */
+  data->state.allow_port = TRUE;
+
+#if defined(HAVE_SIGNAL) && defined(SIGPIPE)
+  /*************************************************************
+   * Tell signal handler to ignore SIGPIPE
+   *************************************************************/
+  data->state.prev_signal = signal(SIGPIPE, SIG_IGN);
+#endif  
 
+  Curl_initinfo(data); /* reset session-specific information "variables" */
   Curl_pgrsStartNow(data);
 
+  return CURLE_OK;
+}
+
+CURLcode Curl_posttransfer(struct SessionHandle *data)
+{
+#if defined(HAVE_SIGNAL) && defined(SIGPIPE)
+  /* restore the signal handler for SIGPIPE before we get back */
+  signal(SIGPIPE, data->state.prev_signal);
+#endif  
+
+  return CURLE_OK;
+}
+
+CURLcode Curl_perform(struct SessionHandle *data)
+{
+  CURLcode res;
+  CURLcode res2;
+  struct connectdata *conn=NULL;
+  char *newurl = NULL; /* possibly a new URL to follow to! */
+
+  res = Curl_pretransfer(data);
+  if(res)
+    return res;
+
+  /*
+   * It is important that there is NO 'return' from this function any any
+   * other place than falling down the bottom! This is because we have cleanup
+   * stuff that must be done before we get back, and that is only performed
+   * after this do-while loop.
+   */
+
   do {
     Curl_pgrsTime(data, TIMER_STARTSINGLE);
-    res = Curl_connect(data, &conn, port);
+    res = Curl_connect(data, &conn);
     if(res == CURLE_OK) {
-      res = Curl_do(conn);
+      res = Curl_do(&conn);
+
       if(res == CURLE_OK) {
+        CURLcode res2; /* just a local extra result container */
+
         if(conn->protocol&PROT_FTPS)
           /* FTPS, disable ssl while transfering data */
           conn->ssl.use = FALSE;
         res = Transfer(conn); /* now fetch that URL please */
         if(conn->protocol&PROT_FTPS)
           /* FTPS, enable ssl again after havving transferred data */
           conn->ssl.use = TRUE;
 
-        if(res == CURLE_OK) {
+        if(res == CURLE_OK)
           /*
            * We must duplicate the new URL here as the connection data
            * may be free()ed in the Curl_done() function.
            */
           newurl = conn->newurl?strdup(conn->newurl):NULL;
-
-          res = Curl_done(conn);
+        else {
+          /* The transfer phase returned error, we mark the connection to get
+           * closed to prevent being re-used. This is becasue we can't
+           * possibly know if the connection is in a good shape or not now. */
+          conn->bits.close = TRUE;
+
+          if(-1 !=conn->secondarysocket) {
+            /* if we failed anywhere, we must clean up the secondary socket if
+               it was used */
+            sclose(conn->secondarysocket);
+            conn->secondarysocket=-1;
+          }
         }
+
+        /* Always run Curl_done(), even if some of the previous calls
+           failed, but return the previous (original) error code */
+        res2 = Curl_done(conn);
+
+        if(CURLE_OK == res)
+          res = res2;
       }
 
       /*
        * Important: 'conn' cannot be used here, since it may have been closed
        * in 'Curl_done' or other functions.
        */
@@ -956,15 +1220,12 @@
  
            This is assumed to happen for HTTP(S) only!
         */
         char prot[16]; /* URL protocol string storage */
         char letter;   /* used for a silly sscanf */
 
-        port=TRUE; /* by default we use the user set port number even after
-                      a Location: */
-
 	if (data->set.maxredirs && (data->set.followlocation >= data->set.maxredirs)) {
 	  failf(data,"Maximum (%d) redirects followed", data->set.maxredirs);
           res=CURLE_TOO_MANY_REDIRECTS;
 	  break;
 	}
 
@@ -983,13 +1244,13 @@
             free(data->change.referer);
 
           data->change.referer = strdup(data->change.url);
           data->change.referer_alloc = TRUE; /* yes, free this later */
         }
 
-        if(2 != sscanf(newurl, "%15[^:]://%c", prot, &letter)) {
+        if(2 != sscanf(newurl, "%15[^?&/:]://%c", prot, &letter)) {
           /***
            *DANG* this is an RFC 2068 violation. The URL is supposed
            to be absolute and this doesn't seem to be that!
            ***
            Instead, we have to TRY to append this new path to the old URL
            to the right of the host part. Oh crap, this is doomed to cause
@@ -1000,14 +1261,16 @@
           char *newest;
 
           /* we must make our own copy of the URL to play with, as it may
              point to read-only data */
           char *url_clone=strdup(data->change.url);
 
-          if(!url_clone)
-            return CURLE_OUT_OF_MEMORY;
+          if(!url_clone) {
+            res = CURLE_OUT_OF_MEMORY;
+            break; /* skip out of this loop NOW */
+          }
 
           /* protsep points to the start of the host name */
           protsep=strstr(url_clone, "//");
           if(!protsep)
             protsep=url_clone;
           else
@@ -1035,24 +1298,25 @@
           }
 
           newest=(char *)malloc( strlen(url_clone) +
                                  1 + /* possible slash */
                                  strlen(newurl) + 1/* zero byte */);
 
-          if(!newest)
-            return CURLE_OUT_OF_MEMORY;
+          if(!newest) {
+            res = CURLE_OUT_OF_MEMORY;
+            break; /* go go go out from this loop */
+          }
           sprintf(newest, "%s%s%s", url_clone, ('/' == newurl[0])?"":"/",
                   newurl);
           free(newurl);
           free(url_clone);
           newurl = newest;
         }
-        else {
-          /* This is an absolute URL, don't use the custom port number */
-          port = FALSE;
-        }
+        else
+          /* This is an absolute URL, don't allow the custom port number */
+          data->state.allow_port = FALSE;
 
         if(data->change.url_alloc)
           free(data->change.url);
         else
           data->change.url_alloc = TRUE; /* the URL is allocated */
       
@@ -1067,20 +1331,40 @@
          * differently based on exactly what return code there was.
          * Discussed on the curl mailing list and posted about on the 26th
          * of January 2001.
          */
         switch(data->info.httpcode) {
         case 300: /* Multiple Choices */
-        case 301: /* Moved Permanently */
         case 306: /* Not used */
         case 307: /* Temporary Redirect */
         default:  /* for all unknown ones */
           /* These are explicitly mention since I've checked RFC2616 and they
            * seem to be OK to POST to.
            */
           break;
+        case 301: /* Moved Permanently */
+          /* (quote from RFC2616, section 10.3.2):
+           * 
+           *  Note: When automatically redirecting a POST request after
+           *  receiving a 301 status code, some existing HTTP/1.0 user agents
+           *  will erroneously change it into a GET request.
+           *
+           * ----
+           * Warning: Because most of importants user agents do this clear
+           * RFC2616 violation, many webservers expect this misbehavior. So
+           * these servers often answers to a POST request with an error page.
+           * To be sure that libcurl gets the page that most user agents
+           * would get, libcurl has to force GET:
+           */
+          if( data->set.httpreq == HTTPREQ_POST
+              || data->set.httpreq == HTTPREQ_POST_FORM) {
+            infof(data,
+                  "Violate RFC 2616/10.3.2 and switch from POST to GET\n");
+            data->set.httpreq = HTTPREQ_GET;
+          }
+          break;
         case 302: /* Found */
           /* (From 10.3.3)
 
             Note: RFC 1945 and RFC 2068 specify that the client is not allowed
             to change the method on the redirected request.  However, most
             existing user agent implementations treat 302 as if it were a 303
@@ -1096,14 +1380,17 @@
             302 status code may be used instead, since most user agents react
             to a 302 response as described here for 303.             
           */
         case 303: /* See Other */
           /* Disable both types of POSTs, since doing a second POST when
            * following isn't what anyone would want! */
-          data->set.httpreq = HTTPREQ_GET; /* enforce GET request */
-          infof(data, "Disables POST, goes with GET\n");
+          if(data->set.httpreq != HTTPREQ_GET) {
+            data->set.httpreq = HTTPREQ_GET; /* enforce GET request */
+            infof(data, "Disables POST, goes with %s\n",
+                  data->set.no_body?"HEAD":"GET");
+          }
           break;
         case 304: /* Not Modified */
           /* 304 means we did a conditional request and it was "Not modified".
            * We shouldn't get any Location: header in this response!
            */
           break;
@@ -1114,25 +1401,29 @@
            * proxy.  The recipient is expected to repeat this single request
            * via the proxy. 305 responses MUST only be generated by origin
            * servers."
            */
           break;
         }
+        Curl_pgrsTime(data, TIMER_REDIRECT);
+        Curl_pgrsResetTimes(data);
         continue;
       }
     }
     break; /* it only reaches here when this shouldn't loop */
 
   } while(1); /* loop if Location: */
 
   if(newurl)
     free(newurl);
 
-  /* make sure the alarm is switched off! */
-  if(data->set.timeout || data->set.connecttimeout)
-    myalarm(0);
+  /* run post-transfer uncondionally, but don't clobber the return code if
+     we already have an error code recorder */
+  res2 = Curl_posttransfer(data);
+  if(!res && res2)
+    res = res2;
 
   return res;
 }
 
 CURLcode 
 Curl_Transfer(struct connectdata *c_conn, /* connection data */
@@ -1163,9 +1454,9 @@
 }
           
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/transfer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/transfer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/transfer.h	2001-08-31 06:54:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/transfer.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,29 +4,40 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.h,v 1.5 2001/08/30 22:48:34 bagder Exp $
+ * $Id: transfer.h,v 1.7 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 CURLcode Curl_perform(struct SessionHandle *data);
 
+CURLcode Curl_pretransfer(struct SessionHandle *data);
+CURLcode Curl_posttransfer(struct SessionHandle *data);
+
+CURLcode Curl_readwrite(struct connectdata *conn, bool *done);
+void Curl_single_fdset(struct connectdata *conn, 
+                       fd_set *read_fd_set,
+                       fd_set *write_fd_set,
+                       fd_set *exc_fd_set,
+                       int *max_fd);
+CURLcode Curl_readwrite_init(struct connectdata *conn);
+
 /* This sets up a forthcoming transfer */
 CURLcode 
 Curl_Transfer (struct connectdata *data,
                int sockfd,		/* socket to read from or -1 */
                int size,		/* -1 if unknown at this point */
                bool getheader,     	/* TRUE if header parsing is wanted */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/url.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/url.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/url.c	2001-09-19 14:20:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/url.c	2002-06-11 23:47:01.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.c,v 1.151 2001/09/18 18:33:25 bagder Exp $
+ * $Id: url.c,v 1.215 2002/06/11 15:47:01 bagder Exp $
  *****************************************************************************/
 
 /* -- WIN32 approved -- */
 
 #include "setup.h"
 
@@ -69,12 +69,15 @@
 
 #ifdef	VMS
 #include <in.h>
 #include <inet.h>
 #endif
 
+#ifdef HAVE_SETJMP_H
+#include <setjmp.h>
+#endif
 
 #ifndef HAVE_SELECT
 #error "We can't compile without select() support!"
 #endif
 #ifndef HAVE_SOCKET
 #error "We can't compile without socket() support!"
@@ -104,15 +107,20 @@
 #include "dict.h"
 #include "telnet.h"
 #include "http.h"
 #include "file.h"
 #include "ldap.h"
 #include "url.h"
+#include "connect.h"
 
 #include <curl/types.h>
 
+#if defined(HAVE_INET_NTOA_R) && !defined(HAVE_INET_NTOA_R_DECL)
+#include "inet_ntoa_r.h"
+#endif
+
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 #ifdef KRB4
 #include "security.h"
 #endif
@@ -131,28 +140,44 @@
 
 
 #if !defined(WIN32)||defined(__CYGWIN32__)
 #ifndef RETSIGTYPE
 #define RETSIGTYPE void
 #endif
+#ifdef HAVE_SIGSETJMP
+extern sigjmp_buf curl_jmpenv;
+#endif
 static
 RETSIGTYPE alarmfunc(int signal)
 {
   /* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
   (void)signal;
+#ifdef HAVE_SIGSETJMP
+  siglongjmp(curl_jmpenv, 1);
+#endif
   return;
 }
 #endif
 
+
+/*
+ * This is the internal function curl_easy_cleanup() calls. This should
+ * cleanup and free all resources associated with this sessionhandle.
+ *
+ * NOTE: if we ever add something that attempts to write to a socket or
+ * similar here, we must ignore SIGPIPE first. It is currently only done
+ * when curl_easy_perform() is invoked.
+ */
+
 CURLcode Curl_close(struct SessionHandle *data)
 {
   /* Loop through all open connections and kill them one by one */
   while(-1 != ConnectionKillOne(data));
 
 #ifdef USE_SSLEAY
-  /* Close down all open info open SSL and sessions */
+  /* Close down all open SSL info and sessions */
   Curl_SSL_Close_All(data);
 #endif
 
   if(data->state.auth_host)
     free(data->state.auth_host);
 
@@ -165,21 +190,26 @@
   if(data->change.url_alloc)
     free(data->change.url);
 
   if(data->state.headerbuff)
     free(data->state.headerbuff);
 
+#ifndef CURL_DISABLE_HTTP
   if(data->set.cookiejar)
     /* we have a "destination" for all the cookies to get dumped to */
     Curl_cookie_output(data->cookies, data->set.cookiejar);
     
   Curl_cookie_cleanup(data->cookies);
+#endif
 
   /* free the connection cache */
   free(data->state.connects);
 
+  if(data->info.contenttype)
+    free(data->info.contenttype);
+
   free(data);
   return CURLE_OK;
 }
 
 static
 int my_getpass(void *clientp, const char *prompt, char* buffer, int buflen )
@@ -196,106 +226,100 @@
 
 
 CURLcode Curl_open(struct SessionHandle **curl)
 {
   /* We don't yet support specifying the URL at this point */
   struct SessionHandle *data;
-#ifdef HAVE_SIGACTION
-  struct sigaction sigact;
-#endif
-
   /* Very simple start-up: alloc the struct, init it with zeroes and return */
   data = (struct SessionHandle *)malloc(sizeof(struct SessionHandle));
-  if(data) {
-    memset(data, 0, sizeof(struct SessionHandle));
-
-    /* We do some initial setup here, all those fields that can't be just 0 */
-
-    data->state.headerbuff=(char*)malloc(HEADERSIZE);
-    if(!data->state.headerbuff) {
-      free(data); /* free the memory again */
-      return CURLE_OUT_OF_MEMORY;
-    }
-
-    data->state.headersize=HEADERSIZE;
-
-    data->set.out = stdout; /* default output to stdout */
-    data->set.in  = stdin;  /* default input from stdin */
-    data->set.err  = stderr;  /* default stderr to stderr */
-
-    /* use fwrite as default function to store output */
-    data->set.fwrite = (curl_write_callback)fwrite;
-
-    /* use fread as default function to read input */
-    data->set.fread = (curl_read_callback)fread;
-
-    /* set the default passwd function */
-    data->set.fpasswd = my_getpass;
-
-    data->set.infilesize = -1; /* we don't know any size */
+  if(!data)
+    /* this is a very serious error */
+    return CURLE_OUT_OF_MEMORY;
+  
+  memset(data, 0, sizeof(struct SessionHandle));
 
-    data->state.current_speed = -1; /* init to negative == impossible */
+  /* We do some initial setup here, all those fields that can't be just 0 */
 
-    data->set.httpreq = HTTPREQ_GET; /* Default HTTP request */
+  data->state.headerbuff=(char*)malloc(HEADERSIZE);
+  if(!data->state.headerbuff) {
+    free(data); /* free the memory again */
+    return CURLE_OUT_OF_MEMORY;
+  }
 
-    /* make libcurl quiet by default: */
-    data->set.hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */
-    data->progress.flags |= PGRS_HIDE;
+  data->state.headersize=HEADERSIZE;
 
-    /* Set the default size of the SSL session ID cache */
-    data->set.ssl.numsessions = 5;
+  data->set.out = stdout; /* default output to stdout */
+  data->set.in  = stdin;  /* default input from stdin */
+  data->set.err  = stderr;  /* default stderr to stderr */
+  
+  /* use fwrite as default function to store output */
+  data->set.fwrite = (curl_write_callback)fwrite;
 
-    /* create an array with connection data struct pointers */
-    data->state.numconnects = 5; /* hard-coded right now */
-    data->state.connects = (struct connectdata **)
-      malloc(sizeof(struct connectdata *) * data->state.numconnects);
+  /* use fread as default function to read input */
+  data->set.fread = (curl_read_callback)fread;
+  
+  /* set the default passwd function */
+  data->set.fpasswd = my_getpass;
 
-    if(!data->state.connects) {
-      free(data);
-      return CURLE_OUT_OF_MEMORY;
-    }
+  data->set.infilesize = -1; /* we don't know any size */
 
-    memset(data->state.connects, 0,
-           sizeof(struct connectdata *)*data->state.numconnects);
+  data->state.current_speed = -1; /* init to negative == impossible */
 
-    *curl = data;
+  data->set.httpreq = HTTPREQ_GET; /* Default HTTP request */
+  data->set.ftp_use_epsv = TRUE;   /* FTP defaults to EPSV operations */
 
-    /*************************************************************
-     * Set signal handler
-     *************************************************************/
-#ifdef HAVE_SIGACTION
-    sigaction(SIGALRM, NULL, &sigact);
-    sigact.sa_handler = alarmfunc;
-#ifdef SA_RESTART
-    /* HPUX doesn't have SA_RESTART but defaults to that behaviour! */
-    sigact.sa_flags &= ~SA_RESTART;
-#endif
-    sigaction(SIGALRM, &sigact, NULL);
-#else
-    /* no sigaction(), revert to the much lamer signal() */
-#ifdef HAVE_SIGNAL
-    signal(SIGALRM, alarmfunc);
-#endif
+  data->set.dns_cache_timeout = 60; /* Timeout every 60 seconds by default */
+  
+  /* make libcurl quiet by default: */
+  data->set.hide_progress = TRUE;  /* CURLOPT_NOPROGRESS changes these */
+  data->progress.flags |= PGRS_HIDE;
 
-#endif
+  /* Set the default size of the SSL session ID cache */
+  data->set.ssl.numsessions = 5;
 
-    return CURLE_OK;
+  data->set.proxyport = 1080;
+  
+  /* create an array with connection data struct pointers */
+  data->state.numconnects = 5; /* hard-coded right now */
+  data->state.connects = (struct connectdata **)
+    malloc(sizeof(struct connectdata *) * data->state.numconnects);
+  
+  if(!data->state.connects) {
+    free(data);
+    return CURLE_OUT_OF_MEMORY;
   }
+  
+  memset(data->state.connects, 0,
+         sizeof(struct connectdata *)*data->state.numconnects);
 
-  /* this is a very serious error */
-  return CURLE_OUT_OF_MEMORY;
+  *curl = data;
+
+  return CURLE_OK;
 }
 
 CURLcode Curl_setopt(struct SessionHandle *data, CURLoption option, ...)
 {
   va_list param;
   char *cookiefile;
 
   va_start(param, option);
 
   switch(option) {
+  case CURLOPT_DNS_CACHE_TIMEOUT:
+    data->set.dns_cache_timeout = va_arg(param, int);
+    break;
+  case CURLOPT_DNS_USE_GLOBAL_CACHE: 
+    {
+      int use_cache = va_arg(param, int);
+      if (use_cache) {
+        Curl_global_host_cache_init();
+      }
+
+      data->set.global_dns_cache = use_cache;
+    }
+    break;
   case CURLOPT_SSL_CIPHER_LIST:
     /* set a list of cipher we want to use in the SSL connection */
     data->set.ssl.cipher_list = va_arg(param, char *);
     break;
 
   case CURLOPT_RANDOM_FILE:
@@ -427,20 +451,27 @@
     data->set.ftp_append = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_NETRC:
     /*
      * Parse the $HOME/.netrc file
      */
-    data->set.use_netrc = va_arg(param, long)?TRUE:FALSE;
+    data->set.use_netrc = va_arg(param, long);
     break;
   case CURLOPT_FOLLOWLOCATION:
     /*
      * Follow Location: header hints on a HTTP-server.
      */
     data->set.http_follow_location = va_arg(param, long)?TRUE:FALSE;
     break;
+  case CURLOPT_HTTP_VERSION:
+    /*
+     * This sets a requested HTTP version to be used. The value is one of
+     * the listed enums in curl/curl.h.
+     */
+    data->set.httpversion = va_arg(param, long);
+    break;
   case CURLOPT_TRANSFERTEXT:
     /*
      * This option was previously named 'FTPASCII'. Renamed to work with
      * more protocols than merely FTP.
      *
      * Transfer using ASCII (instead of BINARY).
@@ -452,21 +483,12 @@
      * Use the HTTP PUT request to transfer data if this is TRUE.  If this is
      * FALSE, don't set the httpreq. We can't know what to revert it to!
      */
     if(va_arg(param, long))
       data->set.httpreq = HTTPREQ_PUT;
     break;
-#if 0
-    /* obsolete stuff, kept here a while for informational purposes */
-  case CURLOPT_MUTE:
-    /*
-     * Stay absolutely quiet.
-     */
-    data->set.mute = va_arg(param, long)?TRUE:FALSE;
-    break;
-#endif
   case CURLOPT_TIMECONDITION:
     /*
      * Set HTTP time condition. This must be one of the defines in the
      * curl/curl.h header file.
      */
     data->set.timecondition = va_arg(param, long);
@@ -483,27 +505,57 @@
      * Set explicit SSL version to try to connect with, as some SSL
      * implementations are lame.
      */
     data->set.ssl.version = va_arg(param, long);
     break;
 
+  case CURLOPT_COOKIESESSION:
+    /*
+     * Set this option to TRUE to start a new "cookie session". It will
+     * prevent the forthcoming read-cookies-from-file actions to accept
+     * cookies that are marked as being session cookies, as they belong to a
+     * previous session.
+     *
+     * In the original Netscape cookie spec, "session cookies" are cookies
+     * with no expire date set. RFC2109 describes the same action if no
+     * 'Max-Age' is set and RFC2965 includes the RFC2109 description and adds
+     * a 'Discard' action that can enforce the discard even for cookies that
+     * have a Max-Age.
+     *
+     * We run mostly with the original cookie spec, as hardly anyone implements
+     * anything else.
+     */
+    data->set.cookiesession = (bool)va_arg(param, long);
+    break;
+
+#ifndef CURL_DISABLE_HTTP
   case CURLOPT_COOKIEFILE:
     /*
      * Set cookie file to read and parse. Can be used multiple times.
      */
     cookiefile = (char *)va_arg(param, void *);
     if(cookiefile)
-      data->cookies = Curl_cookie_init(cookiefile, data->cookies);
+      data->cookies = Curl_cookie_init(cookiefile, data->cookies,
+                                       data->set.cookiesession);
     break;
 
   case CURLOPT_COOKIEJAR:
     /*
      * Set cookie file name to dump all cookies to when we're done.
      */
-    data->set.cookiejar = cookiefile = (char *)va_arg(param, void *);
+    data->set.cookiejar = (char *)va_arg(param, void *);
+
+    /*
+     * Activate the cookie parser. This may or may not already
+     * have been made.
+     */
+    data->cookies = Curl_cookie_init(NULL, data->cookies,
+                                     data->set.cookiesession);
     break;
+#endif
+
   case CURLOPT_WRITEHEADER:
     /*
      * Custom pointer to pass the header write callback function
      */
     data->set.writeheader = (void *)va_arg(param, void *);
     break;
@@ -530,25 +582,33 @@
     /*
      * Use FTP PORT, this also specifies which IP address to use
      */
     data->set.ftpport = va_arg(param, char *);
     data->set.ftp_use_port = data->set.ftpport?1:0;
     break;
+
+  case CURLOPT_FTP_USE_EPSV:
+    data->set.ftp_use_epsv = va_arg(param, long)?TRUE:FALSE;
+    break;
+
   case CURLOPT_HTTPHEADER:
     /*
      * Set a list with HTTP headers to use (or replace internals with)
      */
     data->set.headers = va_arg(param, struct curl_slist *);
     break;
   case CURLOPT_CUSTOMREQUEST:
     /*
      * Set a custom string to use as request
      */
     data->set.customrequest = va_arg(param, char *);
-    if(data->set.customrequest)
-      data->set.httpreq = HTTPREQ_CUSTOM;
+
+    /* we don't set
+       data->set.httpreq = HTTPREQ_CUSTOM;
+       here, we continue as if we were using the already set type
+       and this just changes the actual request keyword */
     break;
   case CURLOPT_HTTPPOST:
     /*
      * Set to make us do HTTP POST
      */
     data->set.httppost = va_arg(param, struct HttpPost *);
@@ -557,14 +617,16 @@
     break;
 
   case CURLOPT_HTTPGET:
     /*
      * Set to force us do HTTP GET
      */
-    if(va_arg(param, long))
+    if(va_arg(param, long)) {
       data->set.httpreq = HTTPREQ_GET;
+      data->set.upload = FALSE; /* switch off upload */
+    }
     break;
 
   case CURLOPT_INFILE:
     /*
      * FILE pointer to read the file to be uploaded from. Or possibly
      * used as argument to the read callback.
@@ -608,14 +670,15 @@
     /*
      * The port number to use when getting the URL
      */
     data->set.use_port = va_arg(param, long);
     break;
   case CURLOPT_POST:
-    /* Does this option serve a purpose anymore? */
-
+    /* Does this option serve a purpose anymore? Yes it does, when
+       CURLOPT_POSTFIELDS isn't used and the POST data is read off the
+       callback! */
     if(va_arg(param, long))
       data->set.httpreq = HTTPREQ_POST;
     break;
   case CURLOPT_POSTFIELDS:
     /*
      * A string with POST data. Makes curl HTTP POST.
@@ -709,36 +772,53 @@
   case CURLOPT_POSTQUOTE:
     /*
      * List of RAW FTP commands to use after a transfer 
      */
     data->set.postquote = va_arg(param, struct curl_slist *);
     break;
+  case CURLOPT_PREQUOTE:
+    /*
+     * List of RAW FTP commands to use prior to RETR (Wesley Laxton)
+     */
+    data->set.prequote = va_arg(param, struct curl_slist *);
+    break;
   case CURLOPT_QUOTE:
     /*
      * List of RAW FTP commands to use before a transfer 
      */
     data->set.quote = va_arg(param, struct curl_slist *);
     break;
   case CURLOPT_PROGRESSFUNCTION:
     /*
      * Progress callback function
      */
     data->set.fprogress = va_arg(param, curl_progress_callback);
-    data->progress.callback = TRUE; /* no longer internal */
+    if(data->set.fprogress)
+      data->progress.callback = TRUE; /* no longer internal */
+    else
+      data->progress.callback = FALSE; /* NULL enforces internal */
+
     break;
   case CURLOPT_PROGRESSDATA:
     /*
      * Custom client data to pass to the progress callback
      */
     data->set.progress_client = va_arg(param, void *);
     break;
   case CURLOPT_PASSWDFUNCTION:
     /*
      * Password prompt callback
      */
     data->set.fpasswd = va_arg(param, curl_passwd_callback);
+    /*
+     * if the callback provided is null, reset the default callback
+     */
+    if(!data->set.fpasswd)
+    {
+      data->set.fpasswd = my_getpass;
+    }
     break;
   case CURLOPT_PASSWDDATA:
     /*
      * Custom client data to pass to the password callback
      */
     data->set.passwd_client = va_arg(param, void *);
@@ -758,18 +838,36 @@
   case CURLOPT_RESUME_FROM:
     /*
      * Resume transfer at the give file position
      */
     data->set.set_resume_from = va_arg(param, long);
     break;
+  case CURLOPT_DEBUGFUNCTION:
+    /*
+     * stderr write callback.
+     */
+    data->set.fdebug = va_arg(param, curl_debug_callback);
+    /*
+     * if the callback provided is NULL, it'll use the default callback
+     */
+    break;
+  case CURLOPT_DEBUGDATA:
+    /*
+     * Set to a void * that should receive all error writes. This
+     * defaults to CURLOPT_STDERR for normal operations.
+     */
+    data->set.debugdata = va_arg(param, void *);
+    break;
   case CURLOPT_STDERR:
     /*
      * Set to a FILE * that should receive all error writes. This
      * defaults to stderr for normal operations.
      */
     data->set.err = va_arg(param, FILE *);
+    if(!data->set.err)
+      data->set.err = stderr;
     break;
   case CURLOPT_HEADERFUNCTION:
     /*
      * Set header write callback
      */
     data->set.fwrite_header = va_arg(param, curl_write_callback);
@@ -789,17 +887,81 @@
   case CURLOPT_SSLCERT:
     /*
      * String that holds file name of the SSL certificate to use
      */
     data->set.cert = va_arg(param, char *);
     break;
-  case CURLOPT_SSLCERTPASSWD:
+  case CURLOPT_SSLCERTTYPE:
+    /*
+     * String that holds file type of the SSL certificate to use
+     */
+    data->set.cert_type = va_arg(param, char *);
+    break;
+  case CURLOPT_SSLKEY:
+    /*
+     * String that holds file name of the SSL certificate to use
+     */
+    data->set.key = va_arg(param, char *);
+    break;
+  case CURLOPT_SSLKEYTYPE:
+    /*
+     * String that holds file type of the SSL certificate to use
+     */
+    data->set.key_type = va_arg(param, char *);
+    break;
+  case CURLOPT_SSLKEYPASSWD:
+    /*
+     * String that holds the SSL private key password.
+     */
+    data->set.key_passwd = va_arg(param, char *);
+    break;
+  case CURLOPT_SSLENGINE:
+    /*
+     * String that holds the SSL crypto engine.
+     */
+#ifdef HAVE_OPENSSL_ENGINE_H
+    {
+      const char *cpTemp = va_arg(param, char *);
+      ENGINE     *e;
+      if (cpTemp && cpTemp[0]) {
+        e = ENGINE_by_id(cpTemp);
+        if (e) {
+          if (data->engine) {
+            ENGINE_free(data->engine);
+          }
+          data->engine = e;
+        }
+        else {
+          failf(data, "SSL Engine '%s' not found", cpTemp);
+          return CURLE_SSL_ENGINE_NOTFOUND;
+        }
+      }
+    }
+#else
+    return CURLE_SSL_ENGINE_NOTFOUND;
+#endif
+    break;
+  case CURLOPT_SSLENGINE_DEFAULT:
     /*
-     * String that holds the SSL certificate password.
+     * flag to set engine as default.
      */
-    data->set.cert_passwd = va_arg(param, char *);
+#ifdef HAVE_OPENSSL_ENGINE_H
+    if (data->engine) {
+      if (ENGINE_set_default(data->engine, ENGINE_METHOD_ALL) > 0) {
+#ifdef DEBUG
+        fprintf(stderr,"set default crypto engine\n");
+#endif
+      }
+      else {
+#ifdef DEBUG
+        failf(data, "set default crypto engine failed");
+#endif
+        return CURLE_SSL_ENGINE_SETFAILED;
+      }
+    }
+#endif
     break;
   case CURLOPT_CRLF:
     /*
      * Kludgy option to enable CRLF convertions. Subject for removal.
      */
     data->set.crlf = va_arg(param, long)?TRUE:FALSE;
@@ -832,23 +994,29 @@
     break;
   case CURLOPT_CAINFO:
     /*
      * Set CA info for SSL connection. Specify file name of the CA certificate
      */
     data->set.ssl.CAfile = va_arg(param, char *);
-    data->set.ssl.CApath = NULL; /*This does not work on windows.*/
+    break;
+  case CURLOPT_CAPATH:
+    /*
+     * Set CA path info  for SSL connection. Specify directory name of the CA certificates
+     * which have been prepared using openssl c_rehash utility.
+     */
+    data->set.ssl.CApath = va_arg(param, char *); /*This does not work on windows.*/
     break;
   case CURLOPT_TELNETOPTIONS:
     /*
      * Set a linked list of telnet options
      */
     data->set.telnet_options = va_arg(param, struct curl_slist *);
     break;
   default:
     /* unknown tag and its companion, just ignore: */
-    return CURLE_READ_ERROR; /* correct this */
+    return CURLE_FAILED_INIT; /* correct this */
   }
   return CURLE_OK;
 }
 
 CURLcode Curl_disconnect(struct connectdata *conn)
 {
@@ -864,31 +1032,23 @@
     free(conn->range);
     conn->bits.rangestringalloc = FALSE;
   }
 
   if(-1 != conn->connectindex) {
     /* unlink ourselves! */
-    infof(conn->data, "Closing live connection (#%d)\n", conn->connectindex);
+    infof(conn->data, "Closing connection #%d\n", conn->connectindex);
     conn->data->state.connects[conn->connectindex] = NULL;
   }
 
   if(conn->curl_disconnect)
     /* This is set if protocol-specific cleanups should be made */
     conn->curl_disconnect(conn);
 
   if(conn->proto.generic)
     free(conn->proto.generic);
 
-#ifdef ENABLE_IPV6
-  if(conn->hp) /* host name info */
-    freeaddrinfo(conn->hp);
-#else
-  if(conn->hostent_buf) /* host name info */
-    free(conn->hostent_buf);
-#endif
-
   if(conn->newurl)
     free(conn->newurl);
 
   if(conn->path) /* the URL path part */
     free(conn->path);
 
@@ -941,79 +1101,92 @@
   FD_SET(sock,&check_set); 
 
   to.tv_sec = 0; 
   to.tv_usec = 1; 
 
   sval = select(sock + 1, &check_set, 0, 0, &to);
-  if(sval == 0) 
+  if(sval == 0)
     /* timeout */
-    ret_val = FALSE; 
+    ret_val = FALSE;
   
   return ret_val;
 }
 
 /*
- * Given one filled in connection struct, this function should detect if there
- * already is one that have all the significant details exactly the same and
- * thus should be used instead.
+ * Given one filled in connection struct (named needle), this function should
+ * detect if there already is one that have all the significant details
+ * exactly the same and thus should be used instead.
  */
 static bool
 ConnectionExists(struct SessionHandle *data,
                  struct connectdata *needle,
                  struct connectdata **usethis)
 {
   long i;
   struct connectdata *check;
 
   for(i=0; i< data->state.numconnects; i++) {
+    bool match = FALSE;
     /*
      * Note that if we use a HTTP proxy, we check connections to that
      * proxy and not to the actual remote server.
      */
     check = data->state.connects[i];
     if(!check)
       /* NULL pointer means not filled-in entry */
       continue;
-    if(!needle->bits.httpproxy) {
-      /* The requested connection does not use a HTTP proxy */
+    if(!needle->bits.httpproxy || needle->protocol&PROT_SSL) {
+      /* The requested connection does not use a HTTP proxy or it
+         uses SSL. */
+
+      if(!(needle->protocol&PROT_SSL) && check->bits.httpproxy)
+        /* we don't do SSL but the cached connection has a proxy,
+           then don't match this */
+        continue;
 
       if(strequal(needle->protostr, check->protostr) &&
          strequal(needle->name, check->name) &&
          (needle->remote_port == check->remote_port) ) {
-        bool dead;
         if(strequal(needle->protostr, "FTP")) {
           /* This is FTP, verify that we're using the same name and
              password as well */
           if(!strequal(needle->data->state.user, check->proto.ftp->user) ||
              !strequal(needle->data->state.passwd, check->proto.ftp->passwd)) {
             /* one of them was different */
             continue;
           }
         }
-        dead = SocketIsDead(check->firstsocket);
-        if(dead) {
-          infof(data, "Connection %d seems to be dead!\n", i);
-          Curl_disconnect(check); /* disconnect resources */
-          data->state.connects[i]=NULL; /* nothing here */
-          continue; /* try another one now */
-        }
-
-        *usethis = check;
-        return TRUE; /* yes, we found one to use! */
-        
+        match = TRUE;
       }
     }
     else { /* The requested needle connection is using a proxy,
               is the checked one using the same? */
       if(check->bits.httpproxy &&
          strequal(needle->proxyhost, check->proxyhost) &&
          needle->port == check->port) {
         /* This is the same proxy connection, use it! */
-        *usethis = check;
-        return TRUE;
+        match = TRUE;
+      }
+    }
+
+    if(match) {
+      bool dead = SocketIsDead(check->firstsocket);
+      if(dead) {
+        /*
+         */
+        infof(data, "Connection %d seems to be dead!\n", i);
+        Curl_disconnect(check); /* disconnect resources */
+        data->state.connects[i]=NULL; /* nothing here */
+
+        /* There's no need to continue searching, because we only store
+           one connection for each unique set of identifiers */
+        return FALSE;
       }
+
+      *usethis = check;
+      return TRUE; /* yes, we found one to use! */
     }
   }
   return FALSE; /* no matching connecting exists */
 }
 
 /*
@@ -1047,20 +1220,20 @@
     case CURLCLOSEPOLICY_LEAST_RECENTLY_USED:
     default:
       /*
        * Set higher score for the age passed since the connection
        * was used.
        */
-      score = Curl_tvlong(now) - Curl_tvlong(conn->now);
+      score = Curl_tvdiff(now, conn->now);
       break;
     case CURLCLOSEPOLICY_OLDEST:
       /*
        * Set higher score for the age passed since the connection
        * was created.
        */
-      score = Curl_tvlong(now) - Curl_tvlong(conn->created);
+      score = Curl_tvdiff(now, conn->created);
       break;
     }
 
     if(score > highscore) {
       highscore = score;
       connindex = i;
@@ -1109,270 +1282,114 @@
     conn->connectindex = i; /* make the child know where the pointer to this
                                particular data is stored */
   }
   return i;
 }
 
-static CURLcode ConnectPlease(struct SessionHandle *data,
-                              struct connectdata *conn)
+static CURLcode ConnectPlease(struct connectdata *conn,
+                              Curl_addrinfo *hostaddr)
 {
-#if defined(WIN32)
-  unsigned long nonblock = 0;
-  fd_set connectfd;
-  struct timeval conntimeout;
-#endif
+  CURLcode result;
+  Curl_ipconnect *addr;
 
-#ifndef ENABLE_IPV6
-  conn->firstsocket = socket(AF_INET, SOCK_STREAM, 0);
-
-  memset((char *) &conn->serv_addr, '\0', sizeof(conn->serv_addr));
-  memcpy((char *)&(conn->serv_addr.sin_addr),
-         conn->hp->h_addr, conn->hp->h_length);
-  conn->serv_addr.sin_family = conn->hp->h_addrtype;
-  conn->serv_addr.sin_port = htons(conn->port);
+  /*************************************************************
+   * Connect to server/proxy
+   *************************************************************/
+  result= Curl_connecthost(conn,
+                           hostaddr,
+                           conn->port,
+                           &conn->firstsocket,
+                           &addr);
+  if(CURLE_OK == result) {
+    /* All is cool, then we store the current information from the hostaddr
+       struct to the serv_addr, as it might be needed later. The address
+       returned from the function above is crucial here. */
+#ifdef ENABLE_IPV6
+    conn->serv_addr = addr;
 #else
-  /* IPv6-style */
-  struct addrinfo *ai;
+    memset((char *) &conn->serv_addr, '\0', sizeof(conn->serv_addr));
+    memcpy((char *)&(conn->serv_addr.sin_addr),
+           (struct in_addr *)addr, sizeof(struct in_addr));
+    conn->serv_addr.sin_family = hostaddr->h_addrtype;
+    conn->serv_addr.sin_port = htons(conn->port);
 #endif
+  }
 
-#if !defined(WIN32)||defined(__CYGWIN32__)
-  /* We don't generally like checking for OS-versions, we should make this
-     HAVE_XXXX based, although at the moment I don't have a decent test for
-     this! */
-
-#ifdef HAVE_INET_NTOA
+  return result;
+}
 
-#ifndef INADDR_NONE
-#define INADDR_NONE (unsigned long) ~0
+static void verboseconnect(struct connectdata *conn,
+                           Curl_addrinfo *hostaddr)
+{
+#ifdef HAVE_INET_NTOA_R
+  char ntoa_buf[64];
 #endif
+  struct SessionHandle *data = conn->data;
 
-#ifndef ENABLE_IPV6
-  /*************************************************************
-   * Select device to bind socket to
-   *************************************************************/
-  if (data->set.device && (strlen(data->set.device)<255)) {
-    struct sockaddr_in sa;
-    struct hostent *h=NULL;
-    char *hostdataptr=NULL;
-    size_t size;
-    char myhost[256] = "";
-    unsigned long in;
-
-    if(Curl_if2ip(data->set.device, myhost, sizeof(myhost))) {
-      h = Curl_gethost(data, myhost, &hostdataptr);
-    }
-    else {
-      if(strlen(data->set.device)>1) {
-        h = Curl_gethost(data, data->set.device, &hostdataptr);
-      }
-      if(h) {
-        /* we know data->set.device is shorter than the myhost array */
-        strcpy(myhost, data->set.device);
-      }
-    }
-
-    if(! *myhost) {
-      /* need to fix this
-         h=Curl_gethost(data,
-         getmyhost(*myhost,sizeof(myhost)),
-         hostent_buf,
-         sizeof(hostent_buf));
-      */
-      printf("in here\n");
-    }
-
-    infof(data, "We connect from %s\n", myhost);
-
-    if ( (in=inet_addr(myhost)) != INADDR_NONE ) {
-
-      if ( h ) {
-        memset((char *)&sa, 0, sizeof(sa));
-        memcpy((char *)&sa.sin_addr,
-               h->h_addr,
-               h->h_length);
-        sa.sin_family = AF_INET;
-        sa.sin_addr.s_addr = in;
-        sa.sin_port = 0; /* get any port */
-	
-        if( bind(conn->firstsocket, (struct sockaddr *)&sa, sizeof(sa)) >= 0) {
-          /* we succeeded to bind */
-          struct sockaddr_in add;
-	
-          size = sizeof(add);
-          if(getsockname(conn->firstsocket, (struct sockaddr *) &add,
-                         (socklen_t *)&size)<0) {
-            failf(data, "getsockname() failed");
-            return CURLE_HTTP_PORT_FAILED;
-          }
-        }
-        else {
-          switch(errno) {
-          case EBADF:
-            failf(data, "Invalid descriptor: %d", errno);
-            break;
-          case EINVAL:
-            failf(data, "Invalid request: %d", errno);
-            break;
-          case EACCES:
-            failf(data, "Address is protected, user not superuser: %d", errno);
-            break;
-          case ENOTSOCK:
-            failf(data,
-                  "Argument is a descriptor for a file, not a socket: %d",
-                  errno);
-            break;
-          case EFAULT:
-            failf(data, "Inaccessable memory error: %d", errno);
-            break;
-          case ENAMETOOLONG:
-            failf(data, "Address too long: %d", errno);
-            break;
-          case ENOMEM:
-            failf(data, "Insufficient kernel memory was available: %d", errno);
-            break;
-          default:
-            failf(data,"errno %d\n");
-          } /* end of switch */
-	
-          return CURLE_HTTP_PORT_FAILED;
-        } /* end of else */
-	
-      } /* end of if  h */
-      else {
-	failf(data,"could't find my own IP address (%s)", myhost);
-	return CURLE_HTTP_PORT_FAILED;
-      }
-    } /* end of inet_addr */
-
-    else {
-      failf(data, "could't find my own IP address (%s)", myhost);
-      return CURLE_HTTP_PORT_FAILED;
-    }
-
-    if(hostdataptr)
-      free(hostdataptr); /* allocated by Curl_gethost() */
-
-  } /* end of device selection support */
-#endif  /* end of HAVE_INET_NTOA */
-#endif /* end of not WIN32 */
-#endif /*ENABLE_IPV6*/
-
-  /*************************************************************
-   * Connect to server/proxy
-   *************************************************************/
+  /* Figure out the ip-number and display the first host name it shows: */
 #ifdef ENABLE_IPV6
-  conn->firstsocket = -1;
-  for (ai = conn->hp; ai; ai = ai->ai_next) {
-    conn->firstsocket = socket(ai->ai_family,
-                               ai->ai_socktype,
-                               ai->ai_protocol);
-    if (conn->firstsocket < 0)
-      continue;
+  (void)hostaddr; /* not used in the IPv6 enabled version */
+  {
+    char hbuf[NI_MAXHOST];
+#ifdef NI_WITHSCOPEID
+    const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
+#else
+    const int niflags = NI_NUMERICHOST;
+#endif
+    struct addrinfo *ai = conn->serv_addr;
 
-    if (connect(conn->firstsocket, ai->ai_addr, ai->ai_addrlen) < 0) {
-      sclose(conn->firstsocket);
-      conn->firstsocket = -1;
-      continue;
+    if (getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, sizeof(hbuf), NULL, 0,
+	niflags)) {
+      snprintf(hbuf, sizeof(hbuf), "?");
+    }
+    if (ai->ai_canonname) {
+      infof(data, "Connected to %s (%s) port %d\n", ai->ai_canonname, hbuf,
+            conn->port);
+    } else {
+      infof(data, "Connected to %s port %d\n", hbuf, conn->port);
     }
-
-    break;
-  }
-  conn->ai = ai;
-  if (conn->firstsocket < 0) {
-    failf(data, strerror(errno));
-    return CURLE_COULDNT_CONNECT;
   }
 #else
-  /* non-zero nonblock value sets socket as nonblocking under Win32 */
-#if defined(WIN32)
-  FD_ZERO (&connectfd);
-  FD_SET(conn->firstsocket, &connectfd);
-  if (conn->data->set.connecttimeout > 0) {
-    nonblock = 1;
-  }
-  ioctlsocket(conn->firstsocket, FIONBIO, &nonblock);
-#endif
-  if (connect(conn->firstsocket,
-              (struct sockaddr *) &(conn->serv_addr),
-              sizeof(conn->serv_addr)
-              ) < 0) {
-#if defined(WIN32)
-    conntimeout.tv_sec = conn->data->set.connecttimeout;
-    conntimeout.tv_usec = 0;	
-    if(-1 != select (conn->firstsocket + 1, NULL, &connectfd, NULL, &conntimeout)) {
-      if (FD_ISSET(conn->firstsocket, &connectfd)) {
-        /* shut off non-blocking again */
-        nonblock = 0;
-        ioctlsocket(conn->firstsocket, FIONBIO, &nonblock);
-        return CURLE_OK;
-      }
-      else
-        errno = EINTR;
-    }
-#endif
-    switch(errno) {
-#ifdef ECONNREFUSED
-      /* this should be made nicer */
-    case ECONNREFUSED:
-      failf(data, "Connection refused");
-      break;
-    case EFAULT:
-      failf(data, "Invalid socket address: %d",errno);
-      break;
-    case EISCONN:
-      failf(data, "Socket already connected: %d",errno);
-      break;
-    case ETIMEDOUT:
-      failf(data, "Timeout while accepting connection, server busy: %d",errno);
-      break;
-    case ENETUNREACH:
-      failf(data, "Network is unreachable: %d",errno);
-      break;
-    case EADDRINUSE:
-      failf(data, "Local address already in use: %d",errno);
-      break;
-    case EINPROGRESS:
-      failf(data, "Socket is nonblocking and connection can not be completed immediately: %d",errno);
-      break;
-    case EALREADY:
-      failf(data, "Socket is nonblocking and a previous connection attempt not completed: %d",errno);
-      break;
-    case EAGAIN:
-      failf(data, "No more free local ports: %d",errno);
-      break;
-    case EACCES:
-    case EPERM:
-      failf(data, "Attempt to connect to broadcast address without socket broadcast flag or local firewall rule violated: %d",errno);
-      break;
+  {
+    struct in_addr in;
+    (void) memcpy(&in.s_addr, &conn->serv_addr.sin_addr, sizeof (in.s_addr));
+    infof(data, "Connected to %s (%s) port %d\n",
+          hostaddr?hostaddr->h_name:"[re-used]",
+#if defined(HAVE_INET_NTOA_R)
+          inet_ntoa_r(in, ntoa_buf, sizeof(ntoa_buf)),
+#else
+          inet_ntoa(in),
 #endif
-    case EINTR:
-      failf(data, "Connection timed out");
-      break;
-    default:
-      failf(data, "Can't connect to server: %d", errno);
-      break;
-    }
-    return CURLE_COULDNT_CONNECT;
+          conn->port);
   }
 #endif
-
-  return CURLE_OK;
 }
 
-static CURLcode Connect(struct SessionHandle *data,
-                        struct connectdata **in_connect,
-                        bool allow_port) /* allow data->set.use_port ? */
+static CURLcode CreateConnection(struct SessionHandle *data,
+                                 struct connectdata **in_connect)
 {
   char *tmp;
   char *buf;
-  CURLcode result;
+  CURLcode result=CURLE_OK;
   char resumerange[40]="";
   struct connectdata *conn;
   struct connectdata *conn_temp;
-  char endbracket;
   int urllen;
+  Curl_addrinfo *hostaddr;
+#ifdef HAVE_ALARM
+  unsigned int prev_alarm;
+#endif
+
+#ifdef HAVE_SIGACTION
+  struct sigaction keep_sigact;   /* store the old struct here */
+  bool keep_copysig;              /* did copy it? */
+#else
+#ifdef HAVE_SIGNAL
+  void *keep_sigact;              /* store the old handler here */
+#endif
+#endif
 
   /*************************************************************
    * Check input data
    *************************************************************/
 
   if(!data->change.url)
@@ -1395,26 +1412,25 @@
 
   /* we have to init the struct */
   memset(conn, 0, sizeof(struct connectdata));
 
   /* and we setup a few fields in case we end up actually using this struct */
   conn->data = data;           /* remember our daddy */
-  conn->upload_bufsize = UPLOAD_BUFSIZE; /* default upload buffer size */
   conn->firstsocket = -1;     /* no file descriptor */
   conn->secondarysocket = -1; /* no file descriptor */
   conn->connectindex = -1;    /* no index */
   conn->bits.httpproxy = data->change.proxy?TRUE:FALSE; /* proxy-or-not */
   conn->bits.use_range = data->set.set_range?TRUE:FALSE; /* range status */
   conn->range = data->set.set_range;               /* clone the range setting */
   conn->resume_from = data->set.set_resume_from;   /* inherite resume_from */
 
   /* Default protocol-independent behavior doesn't support persistant
      connections, so we set this to force-close. Protocols that support
      this need to set this to FALSE in their "curl_do" functions. */
   conn->bits.close = TRUE;
-  
+
   /* inherite initial knowledge from the data struct */
   conn->bits.user_passwd = data->set.userpwd?1:0;
   conn->bits.proxy_user_passwd = data->set.proxyuserpwd?1:0;
 
   /* maxdownload must be -1 on init, as 0 is a valid value! */
   conn->maxdownload = -1;  /* might have been used previously! */
@@ -1487,20 +1503,20 @@
   else {
     /* Set default host and default path */
     strcpy(conn->gname, "curl.haxx.se");
     strcpy(conn->path, "/");
 
     if (2 > sscanf(data->change.url,
-                   "%64[^\n:]://%256[^\n/]%[^\n]",
+                   "%64[^\n:]://%512[^\n/]%[^\n]",
                    conn->protostr, conn->gname, conn->path)) {
       
       /*
        * The URL was badly formatted, let's try the browser-style _without_
        * protocol specified like 'http://'.
        */
-      if((1 > sscanf(data->change.url, "%256[^\n/]%[^\n]",
+      if((1 > sscanf(data->change.url, "%512[^\n/]%[^\n]",
                      conn->gname, conn->path)) ) {
         /*
          * We couldn't even get this format.
          */
         failf(data, "<url> malformed");
         return CURLE_URL_MALFORMAT;
@@ -1535,38 +1551,18 @@
       conn->protocol |= PROT_MISSING; /* not given in URL */
     }
   }
 
   buf = data->state.buffer; /* this is our buffer */
 
-  /*************************************************************
-   * Take care of user and password authentication stuff
-   *************************************************************/
-
-  if(conn->bits.user_passwd && !data->set.use_netrc) {
-    data->state.user[0] =0;
-    data->state.passwd[0]=0;
-
-    if(*data->set.userpwd != ':') {
-      /* the name is given, get user+password */
-      sscanf(data->set.userpwd, "%127[^:]:%127[^\n]",
-             data->state.user, data->state.passwd);
-    }
-    else
-      /* no name given, get the password only */
-      sscanf(data->set.userpwd+1, "%127[^\n]", data->state.passwd);
-
-    /* check for password, if no ask for one */
-    if( !data->state.passwd[0] ) {
-      if(!data->set.fpasswd ||
-         data->set.fpasswd(data->set.passwd_client,
-                       "password:", data->state.passwd,
-                           sizeof(data->state.passwd)))
-        return CURLE_BAD_PASSWORD_ENTERED;
-    }
-  }
+  /*
+   * So if the URL was A://B/C,
+   *   conn->protostr is A
+   *   conn->gname is B
+   *   conn->path is /C
+   */
 
   /*************************************************************
    * Take care of proxy authentication stuff
    *************************************************************/
   if(conn->bits.proxy_user_passwd) {
     data->state.proxyuser[0] =0;
@@ -1584,14 +1580,16 @@
     /* check for password, if no ask for one */
     if( !data->state.proxypasswd[0] ) {
       if(!data->set.fpasswd ||
          data->set.fpasswd( data->set.passwd_client,
                         "proxy password:",
                         data->state.proxypasswd,
-                        sizeof(data->state.proxypasswd)))
+                        sizeof(data->state.proxypasswd))) {
+        failf(data, "Bad password from password callback");
         return CURLE_BAD_PASSWORD_ENTERED;
+      }
     }
 
   }
 
   /*************************************************************
    * Set a few convenience pointers 
@@ -1635,15 +1633,22 @@
     if(!no_proxy || !strequal("*", no_proxy)) {
       /* NO_PROXY wasn't specified or it wasn't just an asterisk */
       char *nope;
 
       nope=no_proxy?strtok_r(no_proxy, ", ", &no_proxy_tok_buf):NULL;
       while(nope) {
-        if(strlen(nope) <= strlen(conn->name)) {
+        unsigned int namelen;
+        char *endptr = strchr(conn->name, ':');
+        if(endptr)
+          namelen=endptr-conn->name;
+        else
+          namelen=strlen(conn->name);
+
+        if(strlen(nope) <= namelen) {
           char *checkn=
-            conn->name + strlen(conn->name) - strlen(nope);
+            conn->name + namelen - strlen(nope);
           if(strnequal(nope, checkn, strlen(nope))) {
             /* no proxy for this host! */
             break;
           }
         }
 	nope=strtok_r(NULL, ", ", &no_proxy_tok_buf);
@@ -1693,12 +1698,13 @@
 	}
 
         if(proxy && *proxy) {
           /* we have a proxy here to set */
           data->change.proxy = proxy;
           data->change.proxy_alloc=TRUE; /* this needs to be freed later */
+          conn->bits.httpproxy = TRUE;
         }
       } /* if (!nope) - it wasn't specified non-proxy */
     } /* NO_PROXY wasn't specified or '*' */
     if(no_proxy)
       free(no_proxy);
   } /* if not using proxy */
@@ -1719,12 +1725,13 @@
 
     data->change.url = reurl;
     data->change.url_alloc = TRUE; /* free this later */
     conn->protocol &= ~PROT_MISSING; /* switch that one off again */
   }
 
+#ifndef CURL_DISABLE_HTTP
   /************************************************************
    * RESUME on a HTTP page is a tricky business. First, let's just check that
    * 'range' isn't used, then set the range parameter and leave the resume as
    * it is to inform about this situation for later use. We will then
    * "attempt" to resume, and if we're talking to a HTTP/1.1 (or later)
    * server, we will get the document resumed. If we talk to a HTTP/1.0
@@ -1737,85 +1744,88 @@
       snprintf(resumerange, sizeof(resumerange), "%d-", conn->resume_from);
       conn->range=strdup(resumerange); /* tell ourselves to fetch this range */
       conn->bits.rangestringalloc = TRUE; /* mark as allocated */
       conn->bits.use_range = 1; /* switch on range usage */
     }
   }
-
-  /*************************************************************
-   * Set timeout if that is being used
-   *************************************************************/
-  if(data->set.timeout || data->set.connecttimeout) {
-    /* We set the timeout on the connection/resolving phase first, separately
-     * from the download/upload part to allow a maximum time on everything */
-
-    /* myalarm() makes a signal get sent when the timeout fires off, and that
-       will abort system calls */
-    if(data->set.connecttimeout)
-      myalarm(data->set.connecttimeout);
-    else
-      myalarm(data->set.timeout);
-  }
-
+#endif
   /*************************************************************
    * Setup internals depending on protocol
    *************************************************************/
 
   if (strequal(conn->protostr, "HTTP")) {
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port:PORT_HTTP;
+#ifndef CURL_DISABLE_HTTP
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port:PORT_HTTP;
     conn->remote_port = PORT_HTTP;
     conn->protocol |= PROT_HTTP;
     conn->curl_do = Curl_http;
     conn->curl_done = Curl_http_done;
+    conn->curl_connect = Curl_http_connect;
+#else
+    failf(data, LIBCURL_NAME
+          " was built with HTTP disabled, http: not supported!");
+    return CURLE_UNSUPPORTED_PROTOCOL;
+#endif
   }
   else if (strequal(conn->protostr, "HTTPS")) {
-#ifdef USE_SSLEAY
+#if defined(USE_SSLEAY) && !defined(CURL_DISABLE_HTTP)
 
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port:PORT_HTTPS;
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port:PORT_HTTPS;
     conn->remote_port = PORT_HTTPS;
-    conn->protocol |= PROT_HTTP;
-    conn->protocol |= PROT_HTTPS;
+    conn->protocol |= PROT_HTTP|PROT_HTTPS|PROT_SSL;
 
     conn->curl_do = Curl_http;
     conn->curl_done = Curl_http_done;
     conn->curl_connect = Curl_http_connect;
 
 #else /* USE_SSLEAY */
     failf(data, LIBCURL_NAME
           " was built with SSL disabled, https: not supported!");
     return CURLE_UNSUPPORTED_PROTOCOL;
 #endif /* !USE_SSLEAY */
   }
   else if (strequal(conn->protostr, "GOPHER")) {
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port:PORT_GOPHER;
+#ifndef CURL_DISABLE_GOPHER
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port:PORT_GOPHER;
     conn->remote_port = PORT_GOPHER;
     /* Skip /<item-type>/ in path if present */
     if (isdigit((int)conn->path[1])) {
       conn->ppath = strchr(&conn->path[1], '/');
       if (conn->ppath == NULL)
 	conn->ppath = conn->path;
       }
     conn->protocol |= PROT_GOPHER;
     conn->curl_do = Curl_http;
     conn->curl_done = Curl_http_done;
+#else
+    failf(data, LIBCURL_NAME
+          " was built with GOPHER disabled, gopher: not supported!");
+#endif
   }
   else if(strequal(conn->protostr, "FTP") ||
           strequal(conn->protostr, "FTPS")) {
+
+/* MN 06/07/02 */
+#ifndef CURL_DISABLE_FTP
     char *type;
 
     if(strequal(conn->protostr, "FTPS")) {
 #ifdef USE_SSLEAY
-      conn->protocol |= PROT_FTPS;
+      conn->protocol |= PROT_FTPS|PROT_SSL;
 #else
       failf(data, LIBCURL_NAME
             " was built with SSL disabled, ftps: not supported!");
       return CURLE_UNSUPPORTED_PROTOCOL;
 #endif /* !USE_SSLEAY */
     }
 
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port:PORT_FTP;
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port:PORT_FTP;
     conn->remote_port = PORT_FTP;
     conn->protocol |= PROT_FTP;
 
     if(data->change.proxy &&
        !data->set.tunnel_thru_httpproxy) {
       /* Unless we have asked to tunnel ftp operations through the proxy, we
@@ -1823,14 +1833,19 @@
       if(conn->protocol & PROT_FTPS) {
         /* FTPS is a hacked protocol and does not work through your
            ordinary http proxy! */
         failf(data, "ftps does not work through http proxy!");
         return CURLE_UNSUPPORTED_PROTOCOL;
       }
+#ifndef CURL_DISABLE_HTTP
       conn->curl_do = Curl_http;
       conn->curl_done = Curl_http_done;
+#else
+      failf(data, "FTP over http proxy requires HTTP support built-in!");
+      return CURLE_UNSUPPORTED_PROTOCOL;
+#endif
     }
     else {
       conn->curl_do = Curl_ftp;
       conn->curl_done = Curl_ftp_done;
       conn->curl_connect = Curl_ftp_connect;
       conn->curl_disconnect = Curl_ftp_disconnect;
@@ -1843,13 +1858,13 @@
     type=strstr(conn->ppath, ";type=");
     if(!type) {
       type=strstr(conn->gname, ";type=");
     }
     if(type) {
       char command;
-      *type=0;
+      *type=0;                     /* it was in the middle of the hostname */
       command = toupper(type[6]);
       switch(command) {
       case 'A': /* ASCII mode */
 	data->set.ftp_ascii = 1;
 	break;
       case 'D': /* directory mode */
@@ -1859,37 +1874,63 @@
       default:
 	/* switch off ASCII */
 	data->set.ftp_ascii = 0;
 	break;
       }
     }
+
+/* MN 06/07/02 */
+#else /* CURL_DISABLE_FTP */
+    failf(data, LIBCURL_NAME
+          " was built with FTP disabled, ftp/ftps: not supported!");
+    return CURLE_UNSUPPORTED_PROTOCOL;
+#endif
   }
   else if(strequal(conn->protostr, "TELNET")) {
+#ifndef CURL_DISABLE_TELNET
     /* telnet testing factory */
     conn->protocol |= PROT_TELNET;
 
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port: PORT_TELNET;
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port: PORT_TELNET;
     conn->remote_port = PORT_TELNET;
     conn->curl_do = Curl_telnet;
     conn->curl_done = Curl_telnet_done;
+#else
+    failf(data, LIBCURL_NAME
+          " was built with TELNET disabled!");
+#endif
   }
   else if (strequal(conn->protostr, "DICT")) {
+#ifndef CURL_DISABLE_DICT
     conn->protocol |= PROT_DICT;
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port:PORT_DICT;
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port:PORT_DICT;
     conn->remote_port = PORT_DICT;
     conn->curl_do = Curl_dict;
     conn->curl_done = NULL; /* no DICT-specific done */
+#else
+    failf(data, LIBCURL_NAME
+          " was built with DICT disabled!");
+#endif
   }
   else if (strequal(conn->protostr, "LDAP")) {
+#ifndef CURL_DISABLE_LDAP
     conn->protocol |= PROT_LDAP;
-    conn->port = (data->set.use_port && allow_port)?data->set.use_port:PORT_LDAP;
+    conn->port = (data->set.use_port && data->state.allow_port)?
+      data->set.use_port:PORT_LDAP;
     conn->remote_port = PORT_LDAP;
     conn->curl_do = Curl_ldap;
     conn->curl_done = NULL; /* no LDAP-specific done */
+#else
+    failf(data, LIBCURL_NAME
+          " was built with LDAP disabled!");
+#endif
   }
   else if (strequal(conn->protostr, "FILE")) {
+#ifndef CURL_DISABLE_FILE
     conn->protocol |= PROT_FILE;
 
     conn->curl_do = Curl_file;
     /* no done() function */
 
     /* anyway, this is supposed to be the connect function so we better
@@ -1900,133 +1941,58 @@
     if(CURLE_OK == result) {
       result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
                              -1, NULL); /* no upload */
     }
 
     return result;
+#else
+    failf(data, LIBCURL_NAME
+          " was built with FILE disabled!");
+#endif
   }
   else {
     /* We fell through all checks and thus we don't support the specified
        protocol */
     failf(data, "Unsupported protocol: %s", conn->protostr);
     return CURLE_UNSUPPORTED_PROTOCOL;
   }
 
   /*************************************************************
-   * .netrc scanning coming up
-   *************************************************************/
-  if(data->set.use_netrc) {
-    if(Curl_parsenetrc(conn->hostname,
-                       data->state.user,
-                       data->state.passwd)) {
-      infof(data, "Couldn't find host %s in the .netrc file, using defaults",
-            conn->hostname);
-    }
-    else
-      conn->bits.user_passwd = 1; /* enable user+password */
-
-    /* weather we failed or not, we don't know which fields that were filled
-       in anyway */
-    if(!data->state.user[0])
-      strcpy(data->state.user, CURL_DEFAULT_USER);
-    if(!data->state.passwd[0])
-      strcpy(data->state.passwd, CURL_DEFAULT_PASSWORD);
-  }
-  else if(!(conn->bits.user_passwd) &&
-	  (conn->protocol & (PROT_FTP|PROT_HTTP)) ) {
-    /* This is a FTP or HTTP URL, and we haven't got the user+password in
-     * the extra parameter, we will now try to extract the possible
-     * user+password pair in a string like:
-     * ftp://user:password@ftp.my.site:8021/README */
-    char *ptr=NULL; /* assign to remove possible warnings */
-    if((ptr=strchr(conn->name, '@'))) {
-      /* there's a user+password given here, to the left of the @ */
-
-      data->state.user[0] =0;
-      data->state.passwd[0]=0;
-
-      if(*conn->name != ':') {
-        /* the name is given, get user+password */
-        sscanf(conn->name, "%127[^:@]:%127[^@]",
-               data->state.user, data->state.passwd);
-      }
-      else
-        /* no name given, get the password only */
-        sscanf(conn->name+1, "%127[^@]", data->state.passwd);
-
-      if(data->state.user[0]) {
-        char *newname=curl_unescape(data->state.user, 0);
-        if(strlen(newname) < sizeof(data->state.user)) {
-          strcpy(data->state.user, newname);
-        }
-        /* if the new name is longer than accepted, then just use
-           the unconverted name, it'll be wrong but what the heck */
-        free(newname);
-      }
-
-      /* check for password, if no ask for one */
-      if( !data->state.passwd[0] ) {
-        if(!data->set.fpasswd ||
-           data->set.fpasswd(data->set.passwd_client,
-                             "password:", data->state.passwd,
-                             sizeof(data->state.passwd)))
-          return CURLE_BAD_PASSWORD_ENTERED;
-      }
-      else {
-        /* we have a password found in the URL, decode it! */
-        char *newpasswd=curl_unescape(data->state.passwd, 0);
-        if(strlen(newpasswd) < sizeof(data->state.passwd)) {
-          strcpy(data->state.passwd, newpasswd);
-        }
-        free(newpasswd);
-      }
-
-      conn->name = ++ptr;
-      conn->bits.user_passwd=TRUE; /* enable user+password */
-    }
-    else {
-      strcpy(data->state.user, CURL_DEFAULT_USER);
-      strcpy(data->state.passwd, CURL_DEFAULT_PASSWORD);
-    }
-  }
-
-  /*************************************************************
    * Figure out the remote port number
    *
    * No matter if we use a proxy or not, we have to figure out the remote
    * port number of various reasons.
    *
    * To be able to detect port number flawlessly, we must not confuse them
-   * IPv6-specified addresses in the [0::1] style.
+   * IPv6-specified addresses in the [0::1] style. (RFC2732)
+   *
+   * The conn->name is currently [user:passwd@]host[:port] where host could
+   * be a hostname, IPv4 address or IPv6 address.
    *************************************************************/
 
-  if((1 == sscanf(conn->name, "[%*39[0-9a-fA-F:.]%c", &endbracket)) &&
-     (']' == endbracket)) {
-    /* this is a IPv6-style specified IP-address */
-#ifndef ENABLE_IPV6
-    failf(data, "You haven't enabled IPv6 support");
-    return CURLE_URL_MALFORMAT;
-#else
-    conn->name++; /* pass the starting bracket */
+  tmp = strrchr(conn->name, ':');
 
-    tmp = strchr(conn->name, ']');
-    *tmp = 0; /* zero terminate */
+  if (tmp) {
+    char *rest;
+    unsigned long port;
 
-    tmp++; /* pass the ending bracket */
-    if(':' != *tmp)
-      tmp = NULL; /* no port number available */
-#endif
-  }
-  else {
-    /* traditional IPv4-style port-extracting */
-    tmp = strchr(conn->name, ':');
-  }
+    port=strtoul(tmp+1, &rest, 10);  /* Port number must be decimal */
 
-  if (tmp) {
-    *tmp++ = '\0'; /* cut off the name there */
-    conn->remote_port = atoi(tmp);
+    if (rest != (tmp+1) && *rest == '\0') {
+      /* The colon really did have only digits after it,
+       * so it is either a port number or a mistake */
+
+      if (port > 0xffff) {   /* Single unix standard says port numbers are
+                              * 16 bits long */
+        failf(data, "Port number too large: %lu", port);
+        return CURLE_URL_MALFORMAT;
+      }
+
+      *tmp = '\0'; /* cut off the name there */
+      conn->remote_port = port;
+    }
   }
 
   if(data->change.proxy) {
     /* If this is supposed to use a proxy, we need to figure out the proxy
        host name name, so that we can re-use an existing connection
        that may exist registered to the same proxy host. */
@@ -2075,12 +2041,144 @@
     conn->proxyhost = strdup(proxyptr);
 
     free(proxydup); /* free the duplicate pointer and not the modified */
   }
 
   /*************************************************************
+   * Take care of user and password authentication stuff
+   *************************************************************/
+
+  /*
+   * Inputs: data->set.userpwd   (CURLOPT_USERPWD)
+   *         data->set.fpasswd   (CURLOPT_PASSWDFUNCTION)
+   *         data->set.use_netrc (CURLOPT_NETRC)
+   *         conn->hostname
+   *         netrc file
+   *         hard-coded defaults
+   *
+   * Outputs: (almost :- all currently undefined)
+   *          conn->bits.user_passwd  - non-zero if non-default passwords exist
+   *          conn->state.user        - non-zero length if defined
+   *          conn->state.passwd      -   ditto
+   *          conn->hostname          - remove user name and password
+   */
+
+  /* At this point, we're hoping all the other special cases have
+   * been taken care of, so conn->hostname is at most
+   *    [user[:password]]@]hostname
+   *
+   * We need somewhere to put the embedded details, so do that first.
+   */
+
+  data->state.user[0] =0;   /* to make everything well-defined */
+  data->state.passwd[0]=0;
+  
+  if (conn->protocol & (PROT_FTP|PROT_HTTP)) {
+    /* This is a FTP or HTTP URL, we will now try to extract the possible
+     * user+password pair in a string like:
+     * ftp://user:password@ftp.my.site:8021/README */
+    char *ptr=strchr(conn->name, '@');
+    char *userpass = conn->name;
+    if(ptr != NULL) {
+      /* there's a user+password given here, to the left of the @ */
+
+      conn->name = conn->hostname = ++ptr;
+
+      /* So the hostname is sane.  Only bother interpreting the
+       * results if we could care.  It could still be wasted
+       * work because it might be overtaken by the programmatically
+       * set user/passwd, but doing that first adds more cases here :-(
+       */
+
+      if (data->set.use_netrc != CURL_NETRC_REQUIRED) {
+        /* We could use the one in the URL */
+
+        conn->bits.user_passwd = 1; /* enable user+password */
+
+        if(*userpass != ':') {
+          /* the name is given, get user+password */
+          sscanf(userpass, "%127[^:@]:%127[^@]",
+                 data->state.user, data->state.passwd);
+        }
+        else
+          /* no name given, get the password only */
+          sscanf(userpass, ":%127[^@]", data->state.passwd);
+
+        if(data->state.user[0]) {
+          char *newname=curl_unescape(data->state.user, 0);
+          if(strlen(newname) < sizeof(data->state.user)) {
+            strcpy(data->state.user, newname);
+          }
+          /* if the new name is longer than accepted, then just use
+             the unconverted name, it'll be wrong but what the heck */
+          free(newname);
+        }
+        if (data->state.passwd[0]) {
+          /* we have a password found in the URL, decode it! */
+          char *newpasswd=curl_unescape(data->state.passwd, 0);
+          if(strlen(newpasswd) < sizeof(data->state.passwd)) {
+            strcpy(data->state.passwd, newpasswd);
+          }
+          free(newpasswd);
+        }
+      }
+    }
+  }
+
+  /* Programmatically set password:
+   *   - always applies, if available
+   *   - takes precedence over the values we just set above
+   * so scribble it over the top.
+   * User-supplied passwords are assumed not to need unescaping.
+   *
+   * user_password is set in "inherite initial knowledge' above,
+   * so it doesn't have to be set in this block
+   */
+  if (data->set.userpwd != NULL) {
+    if(*data->set.userpwd != ':') {
+      /* the name is given, get user+password */
+      sscanf(data->set.userpwd, "%127[^:]:%127[^\n]",
+             data->state.user, data->state.passwd);
+    }
+    else
+      /* no name given, get the password only */
+      sscanf(data->set.userpwd+1, "%127[^\n]", data->state.passwd);
+  }
+
+  if (data->set.use_netrc != CURL_NETRC_IGNORED &&
+      data->state.passwd[0] == '\0' ) {  /* need passwd */
+    if(Curl_parsenetrc(conn->hostname,
+                       data->state.user,
+                       data->state.passwd)) {
+      infof(data, "Couldn't find host %s in the .netrc file, using defaults",
+            conn->hostname);
+    } else
+      conn->bits.user_passwd = 1; /* enable user+password */
+  }
+
+  /* if we have a user but no password, ask for one */
+  if(conn->bits.user_passwd &&
+     !data->state.passwd[0] ) {
+    if(!data->set.fpasswd ||
+      data->set.fpasswd(data->set.passwd_client,
+                       "password:", data->state.passwd,
+                           sizeof(data->state.passwd)))
+      return CURLE_BAD_PASSWORD_ENTERED;
+  }
+
+  /* So we could have a password but no user; that's just too bad. */
+
+  /* If our protocol needs a password and we have none, use the defaults */
+  if ( (conn->protocol & (PROT_FTP|PROT_HTTP)) &&
+       !conn->bits.user_passwd) {
+    strcpy(data->state.user, CURL_DEFAULT_USER);
+    strcpy(data->state.passwd, CURL_DEFAULT_PASSWORD);
+    /* This is the default password, so DON'T set conn->bits.user_passwd */
+  }
+
+  /*************************************************************
    * Check the current list of connections to see if we can
    * re-use an already existing one or if we have to create a
    * new one.
    *************************************************************/
 
   /* reuse_fresh is set TRUE if we are told to use a fresh connection
@@ -2097,15 +2195,19 @@
     char *path = old_conn->path; /* setup the current path pointer properly */
     char *ppath = old_conn->ppath; /* this is the modified path pointer */
     if(old_conn->proxyhost)
       free(old_conn->proxyhost);
     conn = conn_temp;        /* use this connection from now on */
 
+    /* If we speak over a proxy, we need to copy the host name too, as it
+       might be another remote host even when re-using a connection */
+    strcpy(conn->gname, old_conn->gname); /* safe strcpy() */
+
     /* we need these pointers if we speak over a proxy */
-    conn->name = conn->gname;
-    conn->hostname = old_conn->gname;
+    conn->hostname = conn->gname;
+    conn->name = &conn->gname[old_conn->name - old_conn->gname];
 
     free(conn->path);    /* free the previously allocated path pointer */
 
     /* 'path' points to the allocated data, 'ppath' may have been advanced
        to point somewhere within the 'path' area. */
     conn->path = path; 
@@ -2151,52 +2253,131 @@
      * cache of ours!
      */
     ConnectionStore(data, conn);
   }
 
   /*************************************************************
+   * Set timeout if that is being used
+   *************************************************************/
+  if(data->set.timeout || data->set.connecttimeout) {
+    /*************************************************************
+     * Set signal handler to catch SIGALRM
+     * Store the old value to be able to set it back later!
+     *************************************************************/
+
+#ifdef HAVE_SIGACTION
+    struct sigaction sigact;
+    sigaction(SIGALRM, NULL, &sigact);
+    keep_sigact = sigact;
+    keep_copysig = TRUE; /* yes, we have a copy */
+    sigact.sa_handler = alarmfunc;
+#ifdef SA_RESTART
+    /* HPUX doesn't have SA_RESTART but defaults to that behaviour! */
+    sigact.sa_flags &= ~SA_RESTART;
+#endif
+    /* now set the new struct */
+    sigaction(SIGALRM, &sigact, NULL);
+#else
+    /* no sigaction(), revert to the much lamer signal() */
+#ifdef HAVE_SIGNAL
+    keep_sigact = signal(SIGALRM, alarmfunc);
+#endif
+#endif
+
+    /* We set the timeout on the name resolving phase first, separately from
+     * the download/upload part to allow a maximum time on everything. This is
+     * a signal-based timeout, why it won't work and shouldn't be used in
+     * multi-threaded environments. */
+
+#ifdef HAVE_ALARM
+    /* alarm() makes a signal get sent when the timeout fires off, and that
+       will abort system calls */
+    prev_alarm = alarm(data->set.connecttimeout?
+                       data->set.connecttimeout:
+                       data->set.timeout);
+    /* We can expect the conn->created time to be "now", as that was just
+       recently set in the beginning of this function and nothing slow
+       has been done since then until now. */
+#endif
+  }
+
+  /*************************************************************
    * Resolve the name of the server or proxy
    *************************************************************/
-  if(!data->change.proxy) {
+  if(conn->bits.reuse) {
+    /* re-used connection, no resolving is necessary */
+    hostaddr = NULL;
+  }
+  else if(!data->change.proxy) {
     /* If not connecting via a proxy, extract the port from the URL, if it is
      * there, thus overriding any defaults that might have been set above. */
     conn->port =  conn->remote_port; /* it is the same port */
 
     /* Resolve target host right on */
-    if(!conn->hp) {
-#ifdef ENABLE_IPV6
-      /* it might already be set if reusing a connection */
-      conn->hp = Curl_getaddrinfo(data, conn->name, conn->port);
-#else
-      /* it might already be set if reusing a connection */
-      conn->hp = Curl_gethost(data, conn->name, &conn->hostent_buf);
-#endif
-    }
-    if(!conn->hp)
-    {
+    hostaddr = Curl_resolv(data, conn->name, conn->port);
+
+    if(!hostaddr) {
       failf(data, "Couldn't resolve host '%s'", conn->name);
-      return CURLE_COULDNT_RESOLVE_HOST;
+      result =  CURLE_COULDNT_RESOLVE_HOST;
+      /* don't return yet, we need to clean up the timeout first */
     }
   }
-  else if(!conn->hp) {
-    /* This is a proxy that hasn't been resolved yet. It may be resolved
-       if we're reusing an existing connection. */
+  else {
+    /* This is a proxy that hasn't been resolved yet. */
 
     /* resolve proxy */
-#ifdef ENABLE_IPV6
-      /* it might already be set if reusing a connection */
-    conn->hp = Curl_getaddrinfo(data, conn->proxyhost, conn->port);
-#else
-    conn->hp = Curl_gethost(data, conn->proxyhost, &conn->hostent_buf);
-#endif
-    if(!conn->hp) {
+    hostaddr = Curl_resolv(data, conn->proxyhost, conn->port);
+
+    if(!hostaddr) {
       failf(data, "Couldn't resolve proxy '%s'", conn->proxyhost);
-      return CURLE_COULDNT_RESOLVE_PROXY;
+      result = CURLE_COULDNT_RESOLVE_PROXY;
+      /* don't return yet, we need to clean up the timeout first */
     }
   }
   Curl_pgrsTime(data, TIMER_NAMELOOKUP);
+#ifdef HAVE_ALARM
+  if(data->set.timeout || data->set.connecttimeout) {
+#ifdef HAVE_SIGACTION
+    if(keep_copysig) {
+      /* we got a struct as it looked before, now put that one back nice
+         and clean */
+      sigaction(SIGALRM, &keep_sigact, NULL); /* put it back */
+    }
+#else
+#ifdef HAVE_SIGNAL
+    /* restore the previous SIGALRM handler */
+    signal(SIGALRM, keep_sigact);
+#endif
+#endif
+    /* switch back the alarm() to either zero or to what it was before minus
+       the time we spent until now! */
+    if(prev_alarm) {
+      /* there was an alarm() set before us, now put it back */
+      long elapsed_ms = Curl_tvdiff(Curl_tvnow(), conn->created);
+      long alarm_set;
+
+      /* the alarm period is counted in even number of seconds */
+      alarm_set = prev_alarm - elapsed_ms/1000;
+
+      if(alarm_set<=0) {
+        /* if it turned negative, we should fire off a SIGALRM here, but we
+           won't, and zero would be to switch it off so we never set it to
+           less than 1! */
+        alarm(1);
+        result = CURLE_OPERATION_TIMEOUTED;
+        failf(data, "Previous alarm fired off!");
+      }
+      else
+        alarm(alarm_set);
+    }
+    else
+      alarm(0); /* just shut it off */
+  }
+#endif
+  if(result)
+    return result;
 
   /*************************************************************
    * Proxy authentication
    *************************************************************/
   if(conn->bits.proxy_user_passwd) {
     char *authorization;
@@ -2222,66 +2403,48 @@
         free(conn->allocptr.uagent);
       conn->allocptr.uagent =
         aprintf("User-Agent: %s\015\012", data->set.useragent);
     }
   }
 
+  conn->bytecount = 0;
+  conn->headerbytecount = 0;
+  
   if(-1 == conn->firstsocket) {
     /* Connect only if not already connected! */
-    result = ConnectPlease(data, conn);
+    result = ConnectPlease(conn, hostaddr);
+    Curl_pgrsTime(data, TIMER_CONNECT); /* connect done, good or bad */
+
     if(CURLE_OK != result)
       return result;
 
+    if(data->set.verbose)
+      verboseconnect(conn, hostaddr);
+
     if(conn->curl_connect) {
-      /* is there a connect() procedure? */
+      /* is there a protocol-specific connect() procedure? */
 
       /* set start time here for timeout purposes in the
        * connect procedure, it is later set again for the
        * progress meter purpose */
       conn->now = Curl_tvnow();
 
       /* Call the protocol-specific connect function */
       result = conn->curl_connect(conn);
       if(result != CURLE_OK)
         return result; /* pass back errors */
     }
   }
-
-  Curl_pgrsTime(data, TIMER_CONNECT); /* we're connected */
-
-  conn->now = Curl_tvnow(); /* time this *after* the connect is done */
-  conn->bytecount = 0;
-  
-  /* Figure out the ip-number and display the first host name it shows: */
-#ifdef ENABLE_IPV6
-  {
-    char hbuf[NI_MAXHOST];
-#ifdef NI_WITHSCOPEID
-    const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
-#else
-    const int niflags = NI_NUMERICHOST;
-#endif
-    struct addrinfo *ai = conn->ai;
-
-    if (getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, sizeof(hbuf), NULL, 0,
-	niflags)) {
-      snprintf(hbuf, sizeof(hbuf), "?");
-    }
-    if (ai->ai_canonname) {
-      infof(data, "Connected to %s (%s)\n", ai->ai_canonname, hbuf);
-    } else {
-      infof(data, "Connected to %s\n", hbuf);
-    }
-  }
-#else
-  {
-    struct in_addr in;
-    (void) memcpy(&in.s_addr, *conn->hp->h_addr_list, sizeof (in.s_addr));
-    infof(data, "Connected to %s (%s)\n", conn->hp->h_name, inet_ntoa(in));
+  else {
+    Curl_pgrsTime(data, TIMER_CONNECT); /* we're connected already */
+    if(data->set.verbose)
+      verboseconnect(conn, hostaddr);
   }
-#endif
+
+  conn->now = Curl_tvnow(); /* time this *after* the connect is done, we
+                               set this here perhaps a second time */
 
 #ifdef __EMX__
   /* 20000330 mgs
    * the check is quite a hack...
    * we're calling _fsetmode to fix the problem with fwrite converting newline
    * characters (you get mangled text files, and corrupted binary files when
@@ -2293,20 +2456,19 @@
 #endif
 
   return CURLE_OK;
 }
 
 CURLcode Curl_connect(struct SessionHandle *data,
-                      struct connectdata **in_connect,
-                      bool allow_port)
+                      struct connectdata **in_connect)
 {
   CURLcode code;
   struct connectdata *conn;
 
   /* call the stuff that needs to be called */
-  code = Connect(data, in_connect, allow_port);
+  code = CreateConnection(data, in_connect);
 
   if(CURLE_OK != code) {
     /* We're not allowed to return failure with memory left allocated
        in the connectdata struct, free those here */
     conn = (struct connectdata *)*in_connect;
     if(conn) {
@@ -2351,29 +2513,53 @@
      closed in spite of all our efforts to be nice, due to protocol
      restrictions in our or the server's end */
   if(data->set.reuse_forbid ||
      ((CURLE_OK == result) && conn->bits.close))
     result = Curl_disconnect(conn); /* close the connection */
   else
-    infof(data, "Connection (#%d) left alive\n", conn->connectindex);
+    infof(data, "Connection #%d left intact\n", conn->connectindex);
 
   return result;
 }
 
-CURLcode Curl_do(struct connectdata *conn)
+CURLcode Curl_do(struct connectdata **connp)
 {
   CURLcode result=CURLE_OK;
+  struct connectdata *conn = *connp;
+  struct SessionHandle *data=conn->data;
 
-  if(conn->curl_do)
+  if(conn->curl_do) {
     /* generic protocol-specific function pointer set in curl_connect() */
     result = conn->curl_do(conn);
 
+    /* This was formerly done in transfer.c, but we better do it here */
+    
+    if((CURLE_SEND_ERROR == result) && conn->bits.reuse) {
+      /* This was a re-use of a connection and we got a write error in the
+       * DO-phase. Then we DISCONNECT this connection and have another attempt
+       * to CONNECT and then DO again! The retry cannot possibly find another
+       * connection to re-use, since we only keep one possible connection for
+       * each.  */
+
+      infof(data, "Re-used connection seems dead, get a new one\n");
+
+      conn->bits.close = TRUE; /* enforce close of this connetion */
+      result = Curl_done(conn);   /* we are so done with this */
+      if(CURLE_OK == result) {
+        /* Now, redo the connect and get a new connection */
+        result = Curl_connect(data, connp);
+        if(CURLE_OK == result)
+          /* ... finally back to actually retry the DO phase */
+          result = conn->curl_do(*connp);
+      }
+    }
+  }
   return result;
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/urldata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/urldata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/urldata.h	2001-09-12 20:02:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/urldata.h	2002-06-13 17:21:09.000000000 +0800
@@ -4,31 +4,33 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urldata.h,v 1.78 2001/09/12 12:02:12 bagder Exp $
+ * $Id: urldata.h,v 1.112 2002/06/13 09:21:09 bagder Exp $
  *****************************************************************************/
 
 /* This file is for lib internal stuff */
 
 #include "setup.h"
+#include "hostip.h"
+#include "hash.h"
 
 #define PORT_FTP 21
 #define PORT_TELNET 23
 #define PORT_GOPHER 70
 #define PORT_HTTP 80
 #define PORT_HTTPS 443
@@ -54,12 +56,15 @@
 #include "openssl/rsa.h"
 #include "openssl/crypto.h"
 #include "openssl/x509.h"
 #include "openssl/pem.h"
 #include "openssl/ssl.h"
 #include "openssl/err.h"
+#ifdef HAVE_OPENSSL_ENGINE_H
+#include <openssl/engine.h>
+#endif
 #else
 #include "rsa.h"
 #include "crypto.h"
 #include "x509.h"
 #include "pem.h"
 #include "ssl.h"
@@ -75,18 +80,13 @@
 
 #include <curl/curl.h>
 
 #include "http_chunks.h" /* for the structs and enum stuff */
 
 /* Download buffer size, keep it fairly big for speed reasons */
-#define BUFSIZE (1024*50)
-
-/* Defaul upload buffer size, keep it smallish to get faster progress meter
-   updates. This is just default, it is dynamic and adjusts to the upload
-   speed. */
-#define UPLOAD_BUFSIZE (1024*2)
+#define BUFSIZE CURL_MAX_WRITE_SIZE
 
 /* Initial size of the buffer to store headers in, it'll be enlarged in case
    of need. */
 #define HEADERSIZE 256
 
 /* Just a convenience macro to get the larger value out of two given */
@@ -107,12 +107,15 @@
     prot_safe, 
     prot_confidential, 
     prot_private 
 };
 #endif
 
+#ifndef HAVE_OPENSSL_ENGINE_H
+typedef void ENGINE;
+#endif
 /* struct for data related to SSL and SSL connections */
 struct ssl_connect_data {
   bool use;              /* use ssl encrypted communications TRUE/FALSE */
 #ifdef USE_SSLEAY
   /* these ones requires specific SSL-types */
   SSL_CTX* ctx;
@@ -171,12 +174,17 @@
   char *passwd;  /* password string */
   char *urlpath; /* the originally given path part of the URL */
   char *dir;     /* decoded directory */
   char *file;    /* decoded file */
 
   char *entrypath; /* the PWD reply when we logged on */
+
+  char *cache;       /* data cache between getresponse()-calls */
+  size_t cache_size; /* size of cache in bytes */
+  bool dont_check;  /* set to TRUE to prevent the final (post-transfer)
+                       file size and 226/250 status check */
 };
 
 /****************************************************************************
  * FILE unique setup
  ***************************************************************************/
 struct FILE {
@@ -199,12 +207,68 @@
 
   bool resume_done; /* nothing was transfered, resumed transfer already
                        complete */
 };
 
 /*
+ * This struct is all the previously local variables from Curl_perform() moved
+ * to struct to allow the function to return and get re-invoked better without
+ * losing state.
+ */
+
+struct Curl_transfer_keeper {
+  int bytecount;                /* total number of bytes read */
+  int writebytecount;           /* number of bytes written */
+  long contentlength;           /* size of incoming data */
+  struct timeval start;         /* transfer started at this time */
+  struct timeval now;           /* current time */
+  bool header;	                /* incoming data has HTTP header */
+  int headerline;		/* counts header lines to better track the
+                                   first one */
+  char *hbufp;			/* points at *end* of header line */
+  int hbuflen;
+  char *str;			/* within buf */
+  char *str_start;		/* within buf */
+  char *end_ptr;		/* within buf */
+  char *p;			/* within headerbuff */
+  bool content_range;      	/* set TRUE if Content-Range: was found */
+  int offset;	                /* possible resume offset read from the
+                                   Content-Range: header */
+  int httpcode;		        /* error code from the 'HTTP/1.? XXX' line */
+  int httpversion;		/* the HTTP version*10 */
+  bool write_after_100_header;  /* should we enable the write after
+                                   we received a 100-continue/timeout
+                                   or directly */
+
+  /* for the low speed checks: */
+  time_t timeofdoc;
+  long bodywrites;
+  int writetype;
+
+  /* the highest fd we use + 1 */
+  struct SessionHandle *data;
+  struct connectdata *conn;
+  char *buf;
+  char *uploadbuf;
+  int maxfd;
+
+  /* pointers to the actual descriptors we check */
+  fd_set *readfdp;
+  fd_set *writefdp;
+
+  /* the file descriptors to play with */
+  fd_set readfd;
+  fd_set writefd;
+  fd_set rkeepfd;
+  fd_set wkeepfd;
+  int keepon;
+
+};
+
+
+/*
  * The connectdata struct contains all fields and variables that should be
  * unique for an entire connection.
  */
 struct connectdata {
   /**** Fields set when inited and not modified again */
   struct SessionHandle *data; /* link to the root CURL struct */
@@ -219,46 +283,41 @@
 #define PROT_FTP     (1<<4)
 #define PROT_TELNET  (1<<5)
 #define PROT_DICT    (1<<6)
 #define PROT_LDAP    (1<<7)
 #define PROT_FILE    (1<<8)
 #define PROT_FTPS    (1<<9)
+#define PROT_SSL     (1<<10) /* protocol requires SSL */
 
 #ifdef ENABLE_IPV6
-  struct addrinfo *hp; /* host info pointer list */
-  struct addrinfo *ai; /* the particular host we use */
+  struct addrinfo *serv_addr;   /* the particular host we use */
 #else
-  char *hostent_buf; /* pointer to allocated memory for name info */
-  struct hostent *hp;
   struct sockaddr_in serv_addr;
 #endif
   char protostr[64];  /* store the protocol string in this buffer */
-  char gname[257]; /* store the hostname in this buffer */
+  char gname[513]; /* store the hostname in this buffer */
   char *name;      /* host name pointer to fool around with */
   char *path;      /* allocated buffer to store the URL's path part in */
   char *hostname;  /* hostname to connect, as parsed from url */
   long port;       /* which port to use locally */
   unsigned short remote_port; /* what remote port to connect to,
                                  not the proxy port! */
   char *ppath;
   long bytecount;
+  long headerbytecount;  /* only count received headers */
 
   char *range; /* range, if used. See README for detailed specification on
                   this syntax. */
-  int resume_from; /* continue [ftp] transfer from here */
+  ssize_t resume_from; /* continue [ftp] transfer from here */
 
   char *proxyhost; /* name of the http proxy host */
 
   struct timeval now;     /* "current" time */
   struct timeval created; /* creation time */
   int firstsocket;     /* the main socket to use */
   int secondarysocket; /* for i.e ftp transfers */
-
-  long upload_bufsize; /* adjust as you see fit, never bigger than BUFSIZE
-                          never smaller than UPLOAD_BUFSIZE */
-
   long maxdownload; /* in bytes, the maximum amount of data to fetch, 0
                        means unlimited */
   
   struct ssl_connect_data ssl; /* this is for ssl-stuff */
 
   struct ConnectBits bits;    /* various state-flags for this connection */
@@ -340,24 +399,38 @@
     struct LDAP *ldap;
     struct DICT *dict;
 #endif
     void *generic;
   } proto;
 
+  /* This struct is inited when needed */
+  struct Curl_transfer_keeper keep;
+
+  /* 'upload_present' is used to keep a byte counter of how much data there is
+     still left in the buffer, aimed for upload. */
+  int upload_present;
+
+   /* 'upload_fromhere' is used as a read-pointer when we uploaded parts of a
+      buffer, so the next read should read from where this pointer points to,
+      and the 'upload_present' contains the number of bytes available at this
+      position */
+  char *upload_fromhere;                                   
 };
 
 /*
  * Struct to keep statistical and informational data.
  */
 struct PureInfo {
   int httpcode;
   int httpversion;
-  time_t filetime; /* If requested, this is might get set. It may be 0 if
-                      the time was unretrievable */
+  long filetime; /* If requested, this is might get set. Set to -1 if
+                    the time was unretrievable */
   long header_size;  /* size of read header(s) in bytes */
   long request_size; /* the amount of bytes sent in the request(s) */
+
+  char *contenttype; /* the content type of the object */
 };
 
 
 struct Progress {
   long lastshow; /* time() of the last displayed progress meter or NULL to
                     force redraw at next call */
@@ -375,18 +450,21 @@
   double dlspeed;
   double ulspeed;
 
   double t_nslookup;
   double t_connect;
   double t_pretransfer;
+  double t_starttransfer;
+  double t_redirect;
 
   struct timeval start;
   struct timeval t_startsingle;
-#define CURR_TIME 5
+#define CURR_TIME (5+1) /* 6 entries for 5 seconds */
 
   double speeder[ CURR_TIME ];
+  struct timeval speeder_time[ CURR_TIME ];
   int speeder_c;
 };
 
 typedef enum {
   HTTPREQ_NONE, /* first in list */
   HTTPREQ_GET,
@@ -422,14 +500,14 @@
   struct connectdata **connects;
   long numconnects; /* size of the 'connects' array */
 
   char *headerbuff; /* allocated buffer to store headers in */
   int headersize;   /* size of the allocation */
 
-  char buffer[BUFSIZE+1]; /* buffer with size BUFSIZE */
-
+  char buffer[BUFSIZE+1]; /* download buffer */
+  char uploadbuffer[BUFSIZE+1]; /* upload buffer */
   double current_speed;  /* the ProgressShow() funcion sets this */
 
   bool this_is_a_follow; /* this is a followed Location: request */
 
   char *auth_host; /* if set, this should be the host name that we will
                       sent authorization to, no else. Used to make Location:
@@ -438,12 +516,22 @@
                     */
 
   struct curl_ssl_session *session; /* array of 'numsessions' size */
   long sessionage;                  /* number of the most recent session */
 
   char scratch[BUFSIZE*2]; /* huge buffer when doing upload CRLF replacing */
+  bool errorbuf; /* Set to TRUE if the error buffer is already filled in.
+                    This must be set to FALSE every time _easy_perform() is
+                    called. */
+
+#ifdef HAVE_SIGNAL
+  /* storage for the previous bag^H^H^HSIGPIPE signal handler :-) */
+  void (*prev_signal)(int sig);
+#endif
+  bool allow_port; /* Is set.use_port allowed to take effect or not. This
+                      is always set TRUE when curl_easy_perform() is called. */
 };
 
 
 /*
  * This 'DynamicStatic' struct defines dynamic states that actually change
  * values in the 'UserDefined' area, which MUST be taken into consideration
@@ -466,13 +554,14 @@
  * calculated internally for the "session handle" MUST be defined within the
  * 'struct urlstate' instead. The only exceptions MUST note the changes in
  * the 'DynamicStatic' struct.
  */
 
 struct UserDefined {
-  FILE *err;    /* the stderr writes goes here */
+  FILE *err;         /* the stderr user data goes here */
+  void *debugdata;   /* the data that will be passed to fdebug */
   char *errorbuffer; /* store failure messages in here */
   char *proxyuserpwd;  /* Proxy <user:password>, if used */
   long proxyport; /* If non-zero, use this port number by default. If the
                      proxy string features a ":[port]" that one will override
                      this. */  
   void *out;         /* the fetched file goes here */
@@ -497,43 +586,54 @@
   char *ftpport;     /* port to send with the FTP PORT command */
   char *device;      /* network interface to use */
   curl_write_callback fwrite;        /* function that stores the output */
   curl_write_callback fwrite_header; /* function that stores headers */
   curl_read_callback fread;          /* function that reads the input */
   curl_progress_callback fprogress;  /* function for progress information */
+  curl_debug_callback fdebug;      /* function that write informational data */
   void *progress_client; /* pointer to pass to the progress callback */
   curl_passwd_callback fpasswd;      /* call for password */
   void *passwd_client;               /* pass to the passwd callback */
   long timeout;         /* in seconds, 0 means no timeout */
   long connecttimeout;  /* in seconds, 0 means no timeout */
   long infilesize;      /* size of file to upload, -1 means unknown */
   long low_speed_limit; /* bytes/second */
   long low_speed_time;  /* number of seconds */
   int set_resume_from;  /* continue [ftp] transfer from here */
   char *cookie;         /* HTTP cookie string to send */
   struct curl_slist *headers; /* linked list of extra headers */
   struct HttpPost *httppost;  /* linked list of POST data */
-  char *cert;           /* PEM-formatted certificate */
-  char *cert_passwd;    /* plain text certificate password */
+  char *cert;           /* certificate */
+  char *cert_type;      /* format for certificate (default: PEM) */
+  char *key;            /* private key */
+  char *key_type;       /* format for private key (default: PEM) */
+  char *key_passwd;     /* plain text private key password */
+  char *crypto_engine;  /* name of the crypto engine to use */
   char *cookiejar;      /* dump all cookies to this file */
+  bool cookiesession;   /* new cookie session? */
   bool crlf;            /* convert crlf on ftp upload(?) */
-  struct curl_slist *quote;     /* before the transfer */
+  struct curl_slist *quote;     /* after connection is established */
   struct curl_slist *postquote; /* after the transfer */
+  struct curl_slist *prequote; /* before the transfer, after type (Wesley Laxton)*/
   struct curl_slist *telnet_options; /* linked list of telnet options */
-  TimeCond timecondition; /* kind of time/date comparison */
+  curl_TimeCond timecondition; /* kind of time/date comparison */
   time_t timevalue;       /* what time to compare with */
   curl_closepolicy closepolicy; /* connection cache close concept */
   Curl_HttpReq httpreq;   /* what kind of HTTP request (if any) is this */
   char *customrequest;    /* HTTP/FTP request to use */
+  long httpversion; /* when non-zero, a specific HTTP version requested to
+                       be used in the library's request(s) */
   char *auth_host; /* if set, this is the allocated string to the host name
                     * to which to send the authorization data to, and no other
                     * host (which location-following otherwise could lead to)
                     */
   char *krb4_level; /* what security level */
   struct ssl_config_data ssl;  /* user defined SSL stuff */
 
+  int dns_cache_timeout; /* DNS cache timeout */
+  
 /* Here follows boolean settings that define how to behave during
    this session. They are STATIC, set by libcurl users or at least initially
    and they don't change during operations. */
 
   bool get_filetime;
   bool tunnel_thru_httpproxy;
@@ -541,24 +641,30 @@
   bool ftp_ascii;
   bool ftp_list_only;
   bool ftp_use_port;
   bool hide_progress;
   bool http_fail_on_error;
   bool http_follow_location;
-  bool http_include_header;
+  bool include_header;
+#define http_include_header include_header /* former name */
+
   bool http_set_referer;
   bool http_auto_referer; /* set "correct" referer when following location: */
   bool no_body;
   bool set_port;
   bool upload;
-  bool use_netrc;
+  enum CURL_NETRC_OPTION
+       use_netrc;        /* defined in include/curl.h */
   bool verbose;
   bool krb4;             /* kerberos4 connection requested */
   bool reuse_forbid;     /* forbidden to be reused, close after use */
   bool reuse_fresh;      /* do not re-use an existing connection  */
   bool expect100header;  /* TRUE if we added Expect: 100-continue */
+  bool ftp_use_epsv;     /* if EPSV is to be attempted or not */
+
+  bool global_dns_cache;
 };
 
 /*
  * In August 2001, this struct was redesigned and is since stricter than
  * before. The 'connectdata' struct MUST have all the connection oriented
  * stuff as we may now have several simultaneous connections and connection
@@ -567,19 +673,23 @@
  * From now on, the 'SessionHandle' must only contain data that is set once to
  * go for many (perhaps) independent connections. Values that are generated or
  * calculated internally for the "session handle" must be defined within the
  * 'struct urlstate' instead.  */
 
 struct SessionHandle {
+  curl_hash          *hostcache;
   struct UserDefined set;      /* values set by the libcurl user */
   struct DynamicStatic change; /* possibly modified userdefined data */
 
   struct CookieInfo *cookies;  /* the cookies, read from files and servers */
   struct Progress progress;    /* for all the progress meter data */
   struct UrlState state;       /* struct for fields used for state info and
                                   other dynamic purposes */
   struct PureInfo info;        /* stats, reports and info data */
+#ifdef USE_SSLEAY
+  ENGINE*  engine;
+#endif /* USE_SSLEAY */
 };
 
 #define LIBCURL_NAME "libcurl"
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/url.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/url.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/url.h	2001-08-31 06:54:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/url.h	2002-04-11 22:19:02.000000000 +0800
@@ -4,37 +4,35 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.h,v 1.7 2001/08/30 22:48:34 bagder Exp $
+ * $Id: url.h,v 1.9 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 /*
  * Prototypes for library-wide functions provided by url.c
  */
 
 CURLcode Curl_open(struct SessionHandle **curl);
 CURLcode Curl_setopt(struct SessionHandle *data, CURLoption option, ...);
-CURLcode Curl_close(struct SessionHandle *data); /* the opposite of curl_open() */
-CURLcode Curl_connect(struct SessionHandle *,
-                      struct connectdata **,
-                      bool allow_port);
-CURLcode Curl_do(struct connectdata *);
+CURLcode Curl_close(struct SessionHandle *data); /* opposite of curl_open() */
+CURLcode Curl_connect(struct SessionHandle *, struct connectdata **);
+CURLcode Curl_do(struct connectdata **);
 CURLcode Curl_done(struct connectdata *);
 CURLcode Curl_disconnect(struct connectdata *);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/version.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/version.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/lib/version.c	2001-09-07 14:05:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/lib/version.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: version.c,v 1.13 2001/09/07 04:01:33 bumblebury Exp $
+ * $Id: version.c,v 1.16 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <stdio.h>
@@ -35,26 +35,34 @@
   char *ptr;
   strcpy(version, LIBCURL_NAME " " LIBCURL_VERSION );
   ptr=strchr(version, '\0');
 
 #ifdef USE_SSLEAY
 
-#if (SSLEAY_VERSION_NUMBER >= 0x906000)
+#if (SSLEAY_VERSION_NUMBER >= 0x905000)
   {
     char sub[2];
+    unsigned long ssleay_value;
     sub[1]='\0';
-    if(SSLEAY_VERSION_NUMBER&0xff0) {
-      sub[0]=((SSLEAY_VERSION_NUMBER>>4)&0xff) + 'a' -1;
-    }
-    else
+    ssleay_value=SSLeay();
+    if(ssleay_value < 0x906000) {
+      ssleay_value=SSLEAY_VERSION_NUMBER;
       sub[0]='\0';
+    }
+    else {
+      if(ssleay_value&0xff0) {
+        sub[0]=((ssleay_value>>4)&0xff) + 'a' -1;
+      }
+      else
+        sub[0]='\0';
+    }
 
     sprintf(ptr, " (OpenSSL %lx.%lx.%lx%s)",
-            (SSLEAY_VERSION_NUMBER>>28)&0xf,
-            (SSLEAY_VERSION_NUMBER>>20)&0xff,
-            (SSLEAY_VERSION_NUMBER>>12)&0xff,
+            (ssleay_value>>28)&0xf,
+            (ssleay_value>>20)&0xff,
+            (ssleay_value>>12)&0xff,
             sub);
   }
 
 #else
 #if (SSLEAY_VERSION_NUMBER >= 0x900000)
   sprintf(ptr, " (SSL %lx.%lx.%lx)",
@@ -105,9 +113,9 @@
 }
 
 /*
  * local variables:
  * eval: (load-file "../curl-mode.el")
  * end:
- * vim600: et sw=2 ts=2 sts=2 tw=78 fdm=marker
- * vim<600: et sw=2 ts=2 sts=2 tw=78
+ * vim600: fdm=marker
+ * vim: et sw=2 ts=2 sts=2 tw=78
  */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/ltmain.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/ltmain.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/ltmain.sh	2001-09-17 14:06:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/ltmain.sh	2002-03-22 19:01:39.000000000 +0800
@@ -53,13 +53,13 @@
 modename="$progname"
 
 # Constants.
 PROGRAM=ltmain.sh
 PACKAGE=libtool
 VERSION=1.4.2
-TIMESTAMP=" (1.922.2.53 2001/09/11 03:18:52)"
+TIMESTAMP=" (1.922.2.54 2001/09/11 03:33:37)"
 
 default_mode=
 help="Try \`$progname --help' for more information."
 magic="%%%MAGIC variable%%%"
 mkdir="mkdir"
 mv="mv -f"
@@ -1040,20 +1040,20 @@
 	    continue
 	    ;;
 	  *-*-mingw* | *-*-os2*)
 	    # These systems don't actually have a C library (as such)
 	    test "X$arg" = "X-lc" && continue
 	    ;;
-	  *-*-openbsd*)
+	  *-*-openbsd* | *-*-freebsd*)
 	    # Do not include libc due to us having libc/libc_r.
 	    test "X$arg" = "X-lc" && continue
 	    ;;
 	  esac
 	 elif test "X$arg" = "X-lc_r"; then
 	  case $host in
-	  *-*-openbsd*)
+	  *-*-openbsd* | *-*-freebsd*)
 	    # Do not include libc_r directly, use -pthread flag.
 	    continue
 	    ;;
 	  esac
 	fi
 	deplibs="$deplibs $arg"
@@ -2438,13 +2438,13 @@
 	    # Rhapsody C library is in the System framework
 	    deplibs="$deplibs -framework System"
 	    ;;
 	  *-*-netbsd*)
 	    # Don't link with libc until the a.out ld.so is fixed.
 	    ;;
-	  *-*-openbsd*)
+	  *-*-openbsd* | *-*-freebsd*)
 	    # Do not include libc due to us having libc/libc_r.
 	    ;;
 	  *)
 	    # Add libc to deplibs on all other systems if necessary.
 	    if test $build_libtool_need_lc = "yes"; then
 	      deplibs="$deplibs -lc"
@@ -4270,25 +4270,37 @@
 	else
 	  destfile=`$echo "X$file" | $Xsed -e 's%^.*/%%'`
 	  destfile="$destdir/$destfile"
 	fi
 
 	# Do a test to see if this is really a libtool program.
-	if (sed -e '4q' $file | egrep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+	#if (sed -e '4q' $file | egrep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+	case $host in
+	*cygwin*|*mingw*)
+	    wrapper=`echo $file | sed -e 's,.exe$,,'`
+	    ;;
+	*)
+	    wrapper=$file
+	    ;;
+	esac
+	if (sed -e '4q' $wrapper | egrep "^# Generated by .*$PACKAGE") >/dev/null 2>&1; then
+
 	  notinst_deplibs=
 	  relink_command=
 
 	  # If there is no directory component, then add one.
 	  case $file in
-	  */* | *\\*) . $file ;;
-	  *) . ./$file ;;
+	  #*/* | *\\*) . $file ;;
+	  #*) . ./$file ;;
+	  */* | *\\*) . $wrapper ;;
+	  *) . ./$wrapper ;;
 	  esac
 
 	  # Check the variables that should have been set.
 	  if test -z "$notinst_deplibs"; then
-	    $echo "$modename: invalid libtool wrapper script \`$file'" 1>&2
+	    $echo "$modename: invalid libtool wrapper script \`$wrapper'" 1>&2
 	    exit 1
 	  fi
 
 	  finalize=yes
 	  for lib in $notinst_deplibs; do
 	    # Check to see that each library is installed.
@@ -4307,14 +4319,16 @@
 	    fi
 	  done
 
 	  relink_command=
 	  # If there is no directory component, then add one.
 	  case $file in
-	  */* | *\\*) . $file ;;
-	  *) . ./$file ;;
+	  #*/* | *\\*) . $file ;;
+	  #*) . ./$file ;;
+	  */* | *\\*) . $wrapper ;;
+	  *) . ./$wrapper ;;
 	  esac
 
 	  outputname=
 	  if test "$fast_install" = no && test -n "$relink_command"; then
 	    if test "$finalize" = yes && test -z "$run"; then
 	      tmpdir="/tmp"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile	2001-09-25 14:18:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile	2002-06-13 22:32:43.000000000 +0800
@@ -2,26 +2,26 @@
 #                                  _   _ ____  _     
 #  Project                     ___| | | |  _ \| |    
 #                             / __| | | | |_) | |    
 #                            | (__| |_| |  _ <| |___ 
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # In order to be useful for every potential user, curl and libcurl are
 # dual-licensed under the MPL and the MIT/X-derivate licenses.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the MPL or the MIT/X-derivate
 # licenses. You may pick one of these licenses.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.dist,v 1.8 2001/03/15 12:34:40 bagder Exp $
+# $Id: Makefile.dist,v 1.11 2002/02/25 13:25:33 bagder Exp $
 #############################################################################
 
 all:
 	./configure
 	make
 
@@ -40,19 +40,25 @@
 mingw32-ssl:
 	cd lib & make -f Makefile.m32 SSL=1
 	cd src & make -f Makefile.m32 SSL=1
 
 vc:
 	cd lib
-	nmake -f Makefile.vc6
+	nmake -f Makefile.vc6 cfg=release
 	cd ..\src
 	nmake -f Makefile.vc6
 
 vc-ssl:
 	cd lib
-	nmake -f Makefile.vc6 release-ssl
+	nmake -f Makefile.vc6 cfg=release-ssl
+	cd ..\src
+	nmake -f Makefile.vc6 cfg=release-ssl
+
+vc-ssl-dll:
+	cd lib
+	nmake -f Makefile.vc6 cfg=release-ssl-dll
 	cd ..\src
 	nmake -f Makefile.vc6
 
 cygwin:
 	./configure
 	make
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile.am	2001-09-11 18:15:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile.am	2002-04-05 16:51:58.000000000 +0800
@@ -1,17 +1,15 @@
 #
-# $Id: Makefile.am,v 1.24 2001/09/11 10:15:40 bagder Exp $
+# $Id: Makefile.am,v 1.31 2002/03/04 10:15:12 bagder Exp $
 #
 
-AUTOMAKE_OPTIONS = foreign no-dependencies
+AUTOMAKE_OPTIONS = foreign
 
 EXTRA_DIST =						\
 	CHANGES LEGAL maketgz MITX.txt MPL-1.1.txt	\
-	config-win32.h reconf Makefile.dist		\
-	curl-config.in build_vms.com config-riscos.h	\
-	config-vms.h curl-mode.el
+	reconf Makefile.dist curl-config.in build_vms.com curl-mode.el
 
 bin_SCRIPTS = curl-config
 
 SUBDIRS = docs lib src include tests packages
 
 # create a root makefile in the distribution:
@@ -64,6 +62,12 @@
 # gak - libtool requires an absoulte directory, hence the pwd below...
 pkgadd:
 	umask 022 ; \
 	make install DESTDIR=`/bin/pwd`/packages/Solaris/root ; \
 	cat LEGAL MITX.txt MPL-1.1.txt > $(srcdir)/packages/Solaris/copyright ; \
 	cd $(srcdir)/packages/Solaris && $(MAKE) package
+
+#
+# Build a cygwin binary tarball installation file
+# resulting .tar.bz2 file will end up at packages/Win32/cygwin
+cygwinbin:
+	$(MAKE) -C packages/Win32/cygwin cygwinbin
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile.dist /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile.dist
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile.dist	2001-03-15 20:34:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile.dist	2002-02-25 21:25:33.000000000 +0800
@@ -2,26 +2,26 @@
 #                                  _   _ ____  _     
 #  Project                     ___| | | |  _ \| |    
 #                             / __| | | | |_) | |    
 #                            | (__| |_| |  _ <| |___ 
 #                             \___|\___/|_| \_\_____|
 #
-# Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+# Copyright (C) 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
 #
 # In order to be useful for every potential user, curl and libcurl are
 # dual-licensed under the MPL and the MIT/X-derivate licenses.
 #
 # You may opt to use, copy, modify, merge, publish, distribute and/or sell
 # copies of the Software, and permit persons to whom the Software is
 # furnished to do so, under the terms of the MPL or the MIT/X-derivate
 # licenses. You may pick one of these licenses.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.dist,v 1.8 2001/03/15 12:34:40 bagder Exp $
+# $Id: Makefile.dist,v 1.11 2002/02/25 13:25:33 bagder Exp $
 #############################################################################
 
 all:
 	./configure
 	make
 
@@ -40,19 +40,25 @@
 mingw32-ssl:
 	cd lib & make -f Makefile.m32 SSL=1
 	cd src & make -f Makefile.m32 SSL=1
 
 vc:
 	cd lib
-	nmake -f Makefile.vc6
+	nmake -f Makefile.vc6 cfg=release
 	cd ..\src
 	nmake -f Makefile.vc6
 
 vc-ssl:
 	cd lib
-	nmake -f Makefile.vc6 release-ssl
+	nmake -f Makefile.vc6 cfg=release-ssl
+	cd ..\src
+	nmake -f Makefile.vc6 cfg=release-ssl
+
+vc-ssl-dll:
+	cd lib
+	nmake -f Makefile.vc6 cfg=release-ssl-dll
 	cd ..\src
 	nmake -f Makefile.vc6
 
 cygwin:
 	./configure
 	make
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/Makefile.in	2001-09-25 14:17:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/Makefile.in	2002-06-13 22:31:49.000000000 +0800
@@ -11,13 +11,13 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.24 2001/09/11 10:15:40 bagder Exp $
+# $Id: Makefile.am,v 1.31 2002/03/04 10:15:12 bagder Exp $
 #
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
@@ -62,12 +62,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -90,45 +97,43 @@
 VERSIONNUM = @VERSIONNUM@
 YACC = @YACC@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
-AUTOMAKE_OPTIONS = foreign no-dependencies
+AUTOMAKE_OPTIONS = foreign
 
 EXTRA_DIST = \
 	CHANGES LEGAL maketgz MITX.txt MPL-1.1.txt	\
-	config-win32.h reconf Makefile.dist		\
-	curl-config.in build_vms.com config-riscos.h	\
-	config-vms.h curl-mode.el
+	reconf Makefile.dist curl-config.in build_vms.com curl-mode.el
 
 
 bin_SCRIPTS = curl-config
 
 SUBDIRS = docs lib src include tests packages
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES = curl-config
 SCRIPTS = $(bin_SCRIPTS)
 
-depcomp =
 DIST_SOURCES =
 
 RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
 	uninstall-info-recursive all-recursive install-data-recursive \
 	install-exec-recursive installdirs-recursive install-recursive \
 	uninstall-recursive check-recursive installcheck-recursive
-DIST_COMMON = README ./stamp-h1.in Makefile.am Makefile.in acconfig.h \
-	acinclude.m4 aclocal.m4 config.guess config.h.in config.sub \
-	configure configure.in curl-config.in install-sh ltmain.sh \
-	missing mkinstalldirs
+DIST_COMMON = README Makefile.am Makefile.in acconfig.h acinclude.m4 \
+	aclocal.m4 config.guess config.sub configure configure.in \
+	curl-config.in depcomp install-sh ltmain.sh missing \
+	mkinstalldirs
 DIST_SUBDIRS = $(SUBDIRS)
-all: config.h
-	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+all: all-recursive
 
 .SUFFIXES:
 
 mostlyclean-libtool:
 	-rm -f *.lo
 
@@ -149,37 +154,12 @@
 	$(SHELL) ./config.status --recheck
 $(srcdir)/configure:  $(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
 	cd $(srcdir) && $(AUTOCONF)
 
 $(ACLOCAL_M4):  configure.in acinclude.m4
 	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
-config.h: stamp-h1
-	@if test ! -f $@; then \
-		rm -f stamp-h1; \
-		$(MAKE) stamp-h1; \
-	else :; fi
-stamp-h1: $(srcdir)/config.h.in $(top_builddir)/config.status
-	@rm -f stamp-h1 stamp-h1T
-	@echo timestamp > stamp-h1T 2> /dev/null
-	cd $(top_builddir) \
-	  && CONFIG_FILES= CONFIG_HEADERS=config.h \
-	     $(SHELL) ./config.status
-	@mv stamp-h1T stamp-h1
-$(srcdir)/config.h.in:  $(srcdir)/./stamp-h1.in
-	@if test ! -f $@; then \
-		rm -f $(srcdir)/./stamp-h1.in; \
-		$(MAKE) $(srcdir)/./stamp-h1.in; \
-	else :; fi
-$(srcdir)/./stamp-h1.in: $(top_srcdir)/configure.in $(ACLOCAL_M4) $(top_srcdir)/acconfig.h
-	@rm -f $(srcdir)/./stamp-h1.in $(srcdir)/./stamp-h1.inT
-	@echo timestamp > $(srcdir)/./stamp-h1.inT 2> /dev/null
-	cd $(top_srcdir) && $(AUTOHEADER)
-	@mv $(srcdir)/./stamp-h1.inT $(srcdir)/./stamp-h1.in
-
-distclean-hdr:
-	-rm -f config.h
 curl-config: $(top_builddir)/config.status curl-config.in
 	cd $(top_builddir) && CONFIG_FILES=$@ CONFIG_HEADERS= CONFIG_LINKS= $(SHELL) ./config.status
 install-binSCRIPTS: $(bin_SCRIPTS)
 	@$(NORMAL_INSTALL)
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
 	@list='$(bin_SCRIPTS)'; for p in $$list; do \
@@ -265,13 +245,13 @@
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
 	mkid -fID $$unique $(LISP)
 
-TAGS: tags-recursive $(HEADERS) $(SOURCES) config.h.in $(TAGS_DEPENDENCIES) \
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
 	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
@@ -280,14 +260,14 @@
 	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
 	  $(AWK) '    { files[$$0] = 1; } \
 	       END { for (i in files) print i; }'`; \
-	test -z "$(ETAGS_ARGS)config.h.in$$unique$(LISP)$$tags" \
-	  || etags $(ETAGS_ARGS) $$tags config.h.in $$unique $(LISP)
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || etags $(ETAGS_ARGS) $$tags  $$unique $(LISP)
 
 GTAGS:
 	here=`CDPATH=: && cd $(top_builddir) && pwd` \
 	  && cd $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) $$here
 
@@ -302,13 +282,13 @@
 
 GZIP_ENV = --best
 
 distdir: $(DISTFILES)
 	-chmod -R a+w $(distdir) >/dev/null 2>&1; rm -rf $(distdir)
 	mkdir $(distdir)
-	$(mkinstalldirs) $(distdir)/. $(distdir)/packages/Linux/RPM
+	$(mkinstalldirs) $(distdir)/. $(distdir)/packages/EPM $(distdir)/packages/Linux/RPM
 	@for file in $(DISTFILES); do \
 	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    $(mkinstalldirs) "$(distdir)/$$dir"; \
 	  fi; \
@@ -376,13 +356,13 @@
 	         exit 1) )
 	-chmod -R a+w $(distdir) > /dev/null 2>&1; rm -rf $(distdir)
 	@echo "$(distdir).tar.gz is ready for distribution" | \
 	  sed 'h;s/./=/g;p;x;p;x'
 check-am: all-am
 check: check-recursive
-all-am: Makefile $(SCRIPTS) config.h
+all-am: Makefile $(SCRIPTS)
 installdirs: installdirs-recursive
 installdirs-am:
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
 
 install: install-recursive
 install-exec: install-exec-recursive
@@ -413,13 +393,13 @@
 
 dist-all: distdir
 	$(AMTAR) chof - $(distdir) | GZIP=$(GZIP_ENV) gzip -c >$(distdir).tar.gz
 	-chmod -R a+w $(distdir) >/dev/null 2>&1; rm -rf $(distdir)
 distclean: distclean-recursive
 	-rm -f config.status config.cache config.log
-distclean-am: clean-am distclean-generic distclean-hdr distclean-libtool \
+distclean-am: clean-am distclean-generic distclean-libtool \
 	distclean-tags
 
 dvi: dvi-recursive
 
 dvi-am:
 
@@ -448,16 +428,16 @@
 uninstall-am: uninstall-binSCRIPTS uninstall-info-am
 
 uninstall-info: uninstall-info-recursive
 
 .PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
 	clean-generic clean-libtool clean-recursive dist dist-all \
-	distcheck distclean distclean-generic distclean-hdr \
-	distclean-libtool distclean-recursive distclean-tags distdir \
-	dvi dvi-am dvi-recursive info info-am info-recursive install \
-	install-am install-binSCRIPTS install-data install-data-am \
+	distcheck distclean distclean-generic distclean-libtool \
+	distclean-recursive distclean-tags distdir dvi dvi-am \
+	dvi-recursive info info-am info-recursive install install-am \
+	install-binSCRIPTS install-data install-data-am \
 	install-data-recursive install-exec install-exec-am \
 	install-exec-recursive install-info install-info-am \
 	install-info-recursive install-man install-recursive \
 	install-strip installcheck installcheck-am installdirs \
 	installdirs-am installdirs-recursive maintainer-clean \
 	maintainer-clean-generic maintainer-clean-recursive mostlyclean \
@@ -516,9 +496,15 @@
 # gak - libtool requires an absoulte directory, hence the pwd below...
 pkgadd:
 	umask 022 ; \
 	make install DESTDIR=`/bin/pwd`/packages/Solaris/root ; \
 	cat LEGAL MITX.txt MPL-1.1.txt > $(srcdir)/packages/Solaris/copyright ; \
 	cd $(srcdir)/packages/Solaris && $(MAKE) package
+
+#
+# Build a cygwin binary tarball installation file
+# resulting .tar.bz2 file will end up at packages/Win32/cygwin
+cygwinbin:
+	$(MAKE) -C packages/Win32/cygwin cygwinbin
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/maketgz /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/maketgz
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/maketgz	2001-08-21 16:58:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/maketgz	2001-09-27 20:38:47.000000000 +0800
@@ -58,33 +58,71 @@
 
 ############################################################################
 #
 # Enforce a rerun of configure (updates the VERSION)
 #
 
-./config.status --recheck
+echo "Re-running config.status"
+./config.status --recheck >/dev/null
 
 ############################################################################
 #
 # automake is needed to run to make a non-GNU Makefile.in if Makefile.am has
 # been modified.
 #
 
 if { findprog automake >/dev/null 2>/dev/null; } then
   echo "- Could not find or run automake, I hope you know what you're doing!"
 else
   echo "Runs automake --include-deps"
-  automake --include-deps Makefile
+  automake --include-deps Makefile >/dev/null
 fi
 
 ############################################################################
 #
 # Make sure we have updated HTML versions of all man pages:
 #
 make html
 
 ############################################################################
 #
-# Now run make dist
+# Now run make dist to generate a tar.gz archive
 #
 
+targz="curl-$version.tar.gz"
 make dist
+
+############################################################################
+#
+# Now make a bz2 archive from the tar.gz original
+#
+
+bzip2="curl-$version.tar.bz2"
+echo "Generating $bzip2"
+gzip -dc $targz | bzip2 - > $bzip2
+
+############################################################################
+#
+# Now make a zip archive from the tar.gz original
+#
+makezip ()
+{
+  rm -rf $tempdir
+  mkdir $tempdir
+  cd $tempdir
+  gzip -dc ../$targz | tar -xf -
+  find . | zip $zip -@ >/dev/null
+  mv $zip ../
+  cd ..
+  rm -rf $tempdir
+}
+
+zip="curl-$version.zip"
+echo "Generating $zip"
+tempdir=".builddir"
+makezip
+
+echo "------------------"
+echo "maketgz report:"
+echo ""
+ls -l $targz $bzip2 $zip
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/MITX.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/MITX.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/MITX.txt	2001-08-09 14:06:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/MITX.txt	2001-10-30 23:32:08.000000000 +0800
@@ -7,14 +7,13 @@
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, and/or sell copies of the
 Software, and to permit persons to whom the Software is furnished to do so,
 provided that the above copyright notice(s) and this permission notice appear
-in all copies of the Software and that both the above copyright notice(s) and
-this permission notice appear in supporting documentation.
+in all copies of the Software.
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS. IN
 NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN THIS NOTICE BE
 LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages: EPM
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Linux/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Linux/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Linux/Makefile.in	2001-09-12 19:57:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Linux/Makefile.in	2002-06-11 23:23:19.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -89,13 +96,15 @@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
 SUBDIRS = RPM
 subdir = packages/Linux
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 
 RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
 	uninstall-info-recursive all-recursive install-data-recursive \
 	install-exec-recursive installdirs-recursive install-recursive \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Linux/RPM/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Linux/RPM/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Linux/RPM/Makefile.in	2001-09-12 19:57:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Linux/RPM/Makefile.in	2002-06-11 23:23:22.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -89,13 +96,15 @@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
 EXTRA_DIST = README curl-ssl.spec.in curl.spec.in make_curl_rpm
 subdir = packages/Linux/RPM
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES = curl.spec curl-ssl.spec
 DIST_SOURCES =
 DIST_COMMON = README Makefile.am Makefile.in curl-ssl.spec.in \
 	curl.spec.in
 all: all-am
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Makefile.am	2001-05-30 16:36:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Makefile.am	2002-03-04 15:44:06.000000000 +0800
@@ -1,3 +1,3 @@
-SUBDIRS = Win32 Linux Solaris
+SUBDIRS = Win32 Linux Solaris EPM
 
 EXTRA_DIST = README
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Makefile.in	2001-09-12 19:57:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Makefile.in	2002-06-11 23:23:07.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -86,18 +93,20 @@
 VERSIONNUM = @VERSIONNUM@
 YACC = @YACC@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
-SUBDIRS = Win32 Linux Solaris
+SUBDIRS = Win32 Linux Solaris EPM
 
 EXTRA_DIST = README
 subdir = packages
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 
 RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
 	uninstall-info-recursive all-recursive install-data-recursive \
 	install-exec-recursive installdirs-recursive install-recursive \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Solaris/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Solaris/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Solaris/Makefile.in	2001-09-12 19:57:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Solaris/Makefile.in	2002-06-11 23:23:29.000000000 +0800
@@ -62,12 +62,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -98,13 +105,15 @@
 PKGADD_CLASSES = none
 PKGADD_BASEDIR = /
 
 PKGADD_FILE = ${PKGADD_PKG}-@PACKAGE@-@VERSION@-@host@.pkg
 subdir = packages/Solaris
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 DIST_COMMON = Makefile.am Makefile.in
 all: all-am
 
 .SUFFIXES:
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Win32: cygwin
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Win32/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Win32/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Win32/Makefile.am	2001-01-09 00:10:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Win32/Makefile.am	2001-10-29 18:29:46.000000000 +0800
@@ -1 +1,3 @@
+SUBDIRS = cygwin
+
 EXTRA_DIST = README
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Win32/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Win32/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/packages/Win32/Makefile.in	2001-09-12 19:57:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/packages/Win32/Makefile.in	2002-06-11 23:23:10.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -86,20 +93,30 @@
 VERSIONNUM = @VERSIONNUM@
 YACC = @YACC@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
+SUBDIRS = cygwin
+
 EXTRA_DIST = README
 subdir = packages/Win32
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
+
+RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
+	uninstall-info-recursive all-recursive install-data-recursive \
+	install-exec-recursive installdirs-recursive install-recursive \
+	uninstall-recursive check-recursive installcheck-recursive
 DIST_COMMON = README Makefile.am Makefile.in
-all: all-am
+DIST_SUBDIRS = $(SUBDIRS)
+all: all-recursive
 
 .SUFFIXES:
 
 mostlyclean-libtool:
 	-rm -f *.lo
 
@@ -113,15 +130,104 @@
 	  $(AUTOMAKE) --gnu  packages/Win32/Makefile
 Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
 	cd $(top_builddir) && \
 	  CONFIG_HEADERS= CONFIG_LINKS= \
 	  CONFIG_FILES=$(subdir)/$@ $(SHELL) ./config.status
 uninstall-info-am:
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+
 tags: TAGS
-TAGS:
 
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique $(LISP)
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || etags $(ETAGS_ARGS) $$tags  $$unique $(LISP)
+
+GTAGS:
+	here=`CDPATH=: && cd $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH
 
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 
 top_distdir = ../..
 distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
 
@@ -138,27 +244,40 @@
 	  else \
 	    test -f $(distdir)/$$file \
 	    || cp -p $$d/$$file $(distdir)/$$file \
 	    || exit 1; \
 	  fi; \
 	done
+	for subdir in $(SUBDIRS); do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$(top_distdir)" \
+	        distdir=../$(distdir)/$$subdir \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
 check-am: all-am
-check: check-am
+check: check-recursive
 all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
 
-installdirs:
-
-install: install-am
-install-exec: install-exec-am
-install-data: install-data-am
-uninstall: uninstall-am
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
 
 install-am: all-am
 	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
 
-installcheck: installcheck-am
+installcheck: installcheck-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
 	  `test -z '$(STRIP)' || \
 	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
 mostlyclean-generic:
 
@@ -167,54 +286,63 @@
 distclean-generic:
 	-rm -f Makefile $(CONFIG_CLEAN_FILES) stamp-h stamp-h[0-9]*
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
 	@echo "it deletes files that may require special tools to rebuild."
-clean: clean-am
+clean: clean-recursive
 
 clean-am: clean-generic clean-libtool mostlyclean-am
 
-distclean: distclean-am
+distclean: distclean-recursive
 
-distclean-am: clean-am distclean-generic distclean-libtool
+distclean-am: clean-am distclean-generic distclean-libtool \
+	distclean-tags
 
-dvi: dvi-am
+dvi: dvi-recursive
 
 dvi-am:
 
-info: info-am
+info: info-recursive
 
 info-am:
 
 install-data-am:
 
 install-exec-am:
 
-install-info: install-info-am
+install-info: install-info-recursive
 
 install-man:
 
 installcheck-am:
 
-maintainer-clean: maintainer-clean-am
+maintainer-clean: maintainer-clean-recursive
 
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
-mostlyclean: mostlyclean-am
+mostlyclean: mostlyclean-recursive
 
 mostlyclean-am: mostlyclean-generic mostlyclean-libtool
 
 uninstall-am: uninstall-info-am
 
-.PHONY: all all-am check check-am clean clean-generic clean-libtool \
-	distclean distclean-generic distclean-libtool distdir dvi \
-	dvi-am info info-am install install-am install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-generic \
-	mostlyclean-libtool uninstall uninstall-am uninstall-info-am
+uninstall-info: uninstall-info-recursive
+
+.PHONY: $(RECURSIVE_TARGETS) GTAGS all all-am check check-am clean \
+	clean-generic clean-libtool clean-recursive distclean \
+	distclean-generic distclean-libtool distclean-recursive \
+	distclean-tags distdir dvi dvi-am dvi-recursive info info-am \
+	info-recursive install install-am install-data install-data-am \
+	install-data-recursive install-exec install-exec-am \
+	install-exec-recursive install-info install-info-am \
+	install-info-recursive install-man install-recursive \
+	install-strip installcheck installcheck-am installdirs \
+	installdirs-am installdirs-recursive maintainer-clean \
+	maintainer-clean-generic maintainer-clean-recursive mostlyclean \
+	mostlyclean-generic mostlyclean-libtool mostlyclean-recursive \
+	tags tags-recursive uninstall uninstall-am uninstall-info-am \
+	uninstall-info-recursive uninstall-recursive
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/README	2001-08-22 17:17:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/README	2002-04-05 17:00:20.000000000 +0800
@@ -16,19 +16,21 @@
   find out how!
 
   You find answers to the most frequent questions we get in the FAQ document.
 
   Study the LEGAL file for distribution terms and similar.
 
-  Always try the Curl web site for the latest news:
+  Visit the curl web site or mirror for the latest news:
 
-        http://curl.haxx.se
+        http://curl.haxx.se/
+        http://curl.sf.net/
 
   The official download mirror sites are:
 
         Sweden    -- ftp://ftp.sunet.se/pub/www/utilities/curl/
+        Sweden    -- http://cool.haxx.se/curl/
         Germany   -- ftp://ftp.fu-berlin.de/pub/unix/network/curl/
 
   To download the very latest source off the CVS server do this:
 
     cvs -d :pserver:anonymous@cvs.curl.sourceforge.net:/cvsroot/curl login
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/config.h.in	2001-09-07 17:45:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/config.h.in	2002-06-11 17:27:13.000000000 +0800
@@ -14,8 +14,14 @@
 /* Define if you have utime() */
 #undef HAVE_UTIME
 
 /* Define if you have the <utime.h> header file */
 #undef HAVE_UTIME_H
 
-/* Define if you have thhe <sys/utime.h> header file */
+/* Define if you have the <sys/utime.h> header file */
 #undef HAVE_SYS_UTIME_H
+
+/* Define if you have the <sys/types.h> header file */
+#undef HAVE_SYS_TYPES_H
+
+/* Define if you have the <sys/select.h> header file */
+#undef HAVE_SYS_SELECT_H
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: config-mac.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: config-riscos.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: config-vms.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/curlmsg.msg /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/curlmsg.msg
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/curlmsg.msg	2001-08-06 21:17:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/curlmsg.msg	2002-03-07 07:18:02.000000000 +0800
@@ -45,7 +45,12 @@
 LDAPNOFUNC		<LDAP Function not found>			
 ABORTCB			<Callback aborted operation>			
 BADPARAM		<Internal Error, Bad parameter to function>	
 BADORDER		<Internal Error, Bad function calling order>	
 BADPWD			<Bad password entered>				
 MNYREDIR		<Too many redirects>				
+UNKTELNET		<Unknown TELNET option specified>
+UNKMSG			<Unknown message (50)>
+BADSSLCERT		<Remote peer's SSL certificate wasn't OK>
+SRVNOERR		<The Server didn't reply anything, which here is considered an error>
+MAXMSG			<This is the LAST KNOWN MESSAGE, appearantly more have been added>
 .END
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/hugehelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/hugehelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/hugehelp.c	2001-09-18 22:04:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/hugehelp.c	2002-06-11 17:53:00.000000000 +0800
@@ -6,640 +6,717 @@
 "                                  _   _ ____  _     \n"
 "  Project                     ___| | | |  _ \\| |    \n"
 "                             / __| | | | |_) | |    \n"
 "                            | (__| |_| |  _ <| |___ \n"
 "                             \\___|\\___/|_| \\_\\_____|\n"
 "NAME\n"
-"     curl - get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE,\n"
-"     HTTP or HTTPS syntax.\n"
+"     curl - transfer a URL\n"
 "\n"
 "SYNOPSIS\n"
 "     curl [options] [URL...]\n"
 "\n"
 "DESCRIPTION\n"
-"     curl is a client to get documents/files from or  send  docu­\n"
+"     curl  is  a client to get documents/files from or send docu­\n"
+"     ments to a server, using  any  of  the  supported  protocols\n"
 );
  puts(
-"     ments  to  a  server,  using  any of the supported protocols\n"
-"     (HTTP, HTTPS, FTP, GOPHER, DICT, TELNET, LDAP or FILE).  The\n"
-"     command  is designed to work without user interaction or any\n"
+"     (HTTP,  HTTPS, FTP, GOPHER, DICT, TELNET, LDAP or FILE). The\n"
+"     command is designed to work without user interaction or  any\n"
 "     kind of interactivity.\n"
 "\n"
-"     curl offers a busload of useful tricks like  proxy  support,\n"
-"     user  authentication,  ftp  upload,  HTTP post, SSL (https:)\n"
+"     curl  offers  a busload of useful tricks like proxy support,\n"
+"     user authentication, ftp upload,  HTTP  post,  SSL  (https:)\n"
 "     connections, cookies, file transfer resume and more.\n"
 "\n"
 "URL\n"
 "     The URL syntax is protocol dependent. You'll find a detailed\n"
-);
- puts(
 "     description in RFC 2396.\n"
 "\n"
-"     You  can  specify  multiple URLs or parts of URLs by writing\n"
+);
+ puts(
+"     You can specify multiple URLs or parts of  URLs  by  writing\n"
 "     part sets within braces as in:\n"
 "\n"
 "      http://site.{one,two,three}.com\n"
 "\n"
-"     or you can get sequences of alphanumeric series by using  []\n"
+"     or  you can get sequences of alphanumeric series by using []\n"
 "     as in:\n"
 "\n"
 "      ftp://ftp.numericals.com/file[1-100].txt\n"
 "      ftp://ftp.numericals.com/file[001-100].txt    (with leading\n"
 "     zeros)\n"
 "      ftp://ftp.letters.com/file[a-z].txt\n"
 "\n"
-"     It is possible to specify up to 9 sets or series for a  URL,\n"
+"     It  is possible to specify up to 9 sets or series for a URL,\n"
 );
  puts(
 "     but no nesting is supported at the moment:\n"
 "\n"
 "      http://www.any.org/archive[1996-1999]/vol­\n"
 "     ume[1-4]part{a,b,c,index}.html\n"
 "\n"
 "     You can specify any amount of URLs on the command line. They\n"
-"     will  be  fetched  in  a  sequential manner in the specified\n"
+"     will be fetched in a  sequential  manner  in  the  specified\n"
 "     order.\n"
 "\n"
-"     Curl will attempt to re-use connections  for  multiple  file\n"
-"     transfers,  so  that getting many files from the same server\n"
-"     will not do multiple connects /  handshakes.  This  improves\n"
+"     Curl  will  attempt  to re-use connections for multiple file\n"
+"     transfers, so that getting many files from the  same  server\n"
+"     will  not  do  multiple connects / handshakes. This improves\n"
 );
  puts(
-"     speed.  Of  course this is only done on files specified on a\n"
+"     speed. Of course this is only done on files specified  on  a\n"
 "     single command line and cannot be used between separate curl\n"
 "     invokes.\n"
 "OPTIONS\n"
 "     -a/--append\n"
 "          (FTP) When used in a ftp upload, this will tell curl to\n"
 "          append to the target file instead of overwriting it. If\n"
 "          the file doesn't exist, it will be created.\n"
 "\n"
-"          If  this option is used twice, the second one will dis­\n"
+"          If this option is used twice, the second one will  dis­\n"
 "          able append mode again.\n"
 "\n"
 "     -A/--user-agent <agent string>\n"
 );
  puts(
-"          (HTTP) Specify the User-Agent string  to  send  to  the\n"
-"          HTTP  server.  Some badly done CGIs fail if its not set\n"
+"          (HTTP)  Specify  the  User-Agent  string to send to the\n"
+"          HTTP server. Some badly done CGIs fail if its  not  set\n"
 "          to \"Mozilla/4.0\".  To encode blanks in the string, sur­\n"
-"          round  the  string  with  single quote marks.  This can\n"
+"          round the string with single  quote  marks.   This  can\n"
 "          also be set with the -H/--header flag of course.\n"
 "\n"
 "          If this option is set more than once, the last one will\n"
 "          be the one that's used.\n"
 "\n"
 "     -b/--cookie <name=data>\n"
 );
  puts(
 "          (HTTP) Pass the data to the HTTP server as a cookie. It\n"
-"          is supposedly the data  previously  received  from  the\n"
-"          server  in a \"Set-Cookie:\" line.  The data should be in\n"
+"          is  supposedly  the  data  previously received from the\n"
+"          server in a \"Set-Cookie:\" line.  The data should be  in\n"
 "          the format \"NAME1=VALUE1; NAME2=VALUE2\".\n"
 "\n"
-"          If no '=' letter is used in the line, it is treated  as\n"
-"          a  filename  to  use  to  read previously stored cookie\n"
-"          lines from, which should be used  in  this  session  if\n"
+"          If  no '=' letter is used in the line, it is treated as\n"
+"          a filename to use  to  read  previously  stored  cookie\n"
+"          lines  from,  which  should  be used in this session if\n"
 );
  puts(
 "          they  match.  Using  this  method  also  activates  the\n"
-"          \"cookie parser\" which will make  curl  record  incoming\n"
+"          \"cookie  parser\"  which  will make curl record incoming\n"
 "          cookies too, which may be handy if you're using this in\n"
-"          combination with the  -L/--location  option.  The  file\n"
+"          combination  with  the  -L/--location  option. The file\n"
 "          format of the file to read cookies from should be plain\n"
-"          HTTP headers or the Netscape/Mozilla cookie  file  for­\n"
+"          HTTP  headers  or the Netscape/Mozilla cookie file for­\n"
 "          mat.\n"
 "\n"
-"          NOTE  that  the file specified with -b/--cookie is only\n"
+"          NOTE that the file specified with -b/--cookie  is  only\n"
 );
  puts(
-"          used as input. No cookies will be stored in  the  file.\n"
+"          used  as  input. No cookies will be stored in the file.\n"
 "          To store cookies, save the HTTP headers to a file using\n"
 "          -D/--dump-header!\n"
 "\n"
 "          If this option is set more than once, the last one will\n"
 "          be the one that's used.\n"
 "\n"
 "     -B/--use-ascii\n"
-"          Use  ASCII  transfer  when  getting an FTP file or LDAP\n"
-"          info. For FTP, this can also be enforced  by  using  an\n"
-"          URL  that  ends with \";type=A\". This option causes data\n"
+"          Use ASCII transfer when getting an  FTP  file  or  LDAP\n"
+"          info.  For  FTP,  this can also be enforced by using an\n"
+"          URL that ends with \";type=A\". This option  causes  data\n"
 );
  puts(
 "          sent to stdout to be in text mode for win32 systems.\n"
 "\n"
-"          If this option is used twice, the second one will  dis­\n"
+"          If  this option is used twice, the second one will dis­\n"
 "          able ASCII usage.\n"
 "     --ciphers <list of ciphers>\n"
 "          (SSL) Specifies which ciphers to use in the connection.\n"
-"          The list of ciphers must be using valid  ciphers.  Read\n"
-"          up   on   SSL   cipher   list   details  on  this  URL:\n"
+"          The  list  of ciphers must be using valid ciphers. Read\n"
+"          up  on  SSL  cipher   list   details   on   this   URL:\n"
 "          http://www.openssl.org/docs/apps/ciphers.html   (Option\n"
 "          added in curl 7.9)\n"
 "\n"
 );
  puts(
-"          If  this option is used severl times, the last one will\n"
+"          If this option is used severl times, the last one  will\n"
 "          override the others.\n"
 "\n"
 "     --connect-timeout <seconds>\n"
-"          Maximum time in seconds that you allow  the  connection\n"
+"          Maximum  time  in seconds that you allow the connection\n"
 "          to the server to take.  This only limits the connection\n"
-"          phase, once curl has connected this  option  is  of  no\n"
-"          more  use.  This  option  didn't  work in win32 systems\n"
-"          until 7.7.2.  See also the --max-time option.\n"
+"          phase,  once  curl  has  connected this option is of no\n"
+"          more use. See also the --max-time option.\n"
 "\n"
-);
- puts(
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
+);
+ puts(
 "     -c/--cookie-jar <file name>\n"
 "          Specify  to which file you want curl to write all cook­\n"
 "          ies after a completed operation. Curl writes all  cook­\n"
 "          ies  previously  read  from a specified file as well as\n"
 "          all cookies received from remote server(s). If no cook­\n"
 "          ies  are  known, no file will be written. The file will\n"
-);
- puts(
 "          be written using the Netscape cookie  file  format.  If\n"
 "          you  set the file name to a single dash, \"-\", the cook­\n"
+);
+ puts(
 "          ies will be written to stdout. (Option  added  in  curl\n"
 "          7.9)\n"
 "\n"
 "          If this option is used several times, the last specfied\n"
 "          file name will be used.\n"
 "\n"
 "     -C/--continue-at <offset>\n"
 "          Continue/Resume a previous file transfer at  the  given\n"
 "          offset.  The  given offset is the exact number of bytes\n"
-);
- puts(
 "          that will be skipped counted from the beginning of  the\n"
 "          source file before it is transfered to the destination.\n"
+);
+ puts(
 "          If used with uploads, the ftp server command SIZE  will\n"
-"          not  be  used  by  curl. Upload resume is for FTP only.\n"
-"          HTTP resume is only possible  with  HTTP/1.1  or  later\n"
-"          servers.\n"
+"          not be used by curl.\n"
+"\n"
+"          Use  \"-C  -\"  to  tell  curl  to automatically find out\n"
+"          where/how to resume the  transfer.  It  then  uses  the\n"
+"          given output/input files to figure that out.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
-"     -d/--data <data>\n"
+"     --crlf\n"
+"          (FTP) Convert LF to CRLF  in  upload.  Useful  for  MVS\n"
+"          (OS/390).\n"
 );
  puts(
+"          If  this  option  is  used twice, the second will again\n"
+"          disable crlf converting.\n"
+"\n"
+"     -d/--data <data>\n"
 "          (HTTP) Sends the specified data in a  POST  request  to\n"
 "          the HTTP server, in a way that can emulate as if a user\n"
 "          has filled in a HTML form and pressed the  submit  but­\n"
 "          ton.  Note  that  the data is sent exactly as specified\n"
 "          with no extra processing (with all newlines  cut  off).\n"
-"          The  data  is  expected  to be \"url-encoded\". This will\n"
-"          cause curl to pass the data to  the  server  using  the\n"
 );
  puts(
+"          The  data  is  expected  to be \"url-encoded\". This will\n"
+"          cause curl to pass the data to  the  server  using  the\n"
 "          content-type application/x-www-form-urlencoded. Compare\n"
 "          to -F. If more than one -d/--data option is used on the\n"
 "          same  command  line,  the data pieces specified will be\n"
 "          merged together with a separating &-letter. Thus, using\n"
 "          '-d  name=daniel  -d skill=lousy' would generate a post\n"
+);
+ puts(
 "          chunk that looks like 'name=daniel&skill=lousy'.\n"
 "\n"
 "          If you start the data  with  the  letter  @,  the  rest\n"
-);
- puts(
 "          should  be  a  file name to read the data from, or - if\n"
 "          you want curl to read the data from  stdin.   The  con­\n"
 "          tents of the file must already be url-encoded. Multiple\n"
 "          files can also be specified. Posting data from  a  file\n"
 "          named  'foobar'  would  thus be done with \"--data @foo­\n"
 "          bar\".\n"
 "\n"
+);
+ puts(
 "          To post data purely binary, you should instead use  the\n"
 "          --data-binary option.\n"
 "\n"
 "          -d/--data is the same as --data-ascii.\n"
 "\n"
-);
- puts(
 "          If  this option is used several times, the ones follow­\n"
 "          ing the first will append data.\n"
 "\n"
 "     --data-ascii <data>\n"
 "          (HTTP) This is an alias for the -d/--data option.\n"
 "\n"
 "          If this option is used several times, the ones  follow­\n"
 "          ing the first will append data.\n"
 "\n"
 "     --data-binary <data>\n"
-"          (HTTP)  This  posts data in a similar manner as --data-\n"
-"          ascii does, although when using this option the  entire\n"
 );
  puts(
+"          (HTTP)  This  posts data in a similar manner as --data-\n"
+"          ascii does, although when using this option the  entire\n"
 "          context  of  the posted data is kept as-is. If you want\n"
 "          to post a binary file without the  strip-newlines  fea­\n"
 "          ture of the --data-ascii option, this is for you.\n"
 "\n"
-"          If this option is used several times, the last one will\n"
-"          be used.\n"
-"\n"
-"          If this option is used several times, the ones  follow­\n"
+"          If  this option is used several times, the ones follow­\n"
 "          ing the first will append data.\n"
 "\n"
-"     -D/--dump-header <file>\n"
-"          (HTTP/FTP)  Write  the HTTP headers to this file. Write\n"
+"     --disable-epsv\n"
 );
  puts(
-"          the FTP file info to this file if -I/--head is used.\n"
+"          (FTP) Tell curl to disable the use of the EPSV  command\n"
+"          when  doing  passive  FTP downloads. Curl will normally\n"
+"          always first attempt to use EPSV before PASV, but  with\n"
+"          this option, it will not try using EPSV.\n"
+"\n"
+"          If  this  option is used several times, each occurrence\n"
+"          will toggle this on/off.\n"
 "\n"
+"     -D/--dump-header <file>\n"
+"          Write the protocol headers to the specified file.\n"
+"\n"
+);
+ puts(
 "          This option is handy to use when you want to store  the\n"
 "          cookies  that  a  HTTP  site  sends to you. The cookies\n"
 "          could then be read in a second curl invoke by using the\n"
 "          -b/--cookie option!\n"
 "\n"
+"          When  used  on  FTP,  the ftp server response lines are\n"
+"          considered being \"headers\" and thus are saved there.\n"
+"\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -e/--referer <URL>\n"
-"          (HTTP) Sends the \"Referer Page\" information to the HTTP\n"
 );
  puts(
-"          server.  This can also be set with the -H/--header flag\n"
+"          (HTTP) Sends the \"Referer Page\" information to the HTTP\n"
+"          server. This can also be set with the -H/--header  flag\n"
 "          of course.  When used with -L/--location you can append\n"
-"          \";auto\"  to  the referer URL to make curl automatically\n"
-"          set the  previous  URL  when  it  follows  a  Location:\n"
-"          header.  The  \";auto\" string can be used alone, even if\n"
+"          \";auto\" to the referer URL to make  curl  automatically\n"
+"          set  the  previous  URL  when  it  follows  a Location:\n"
+"          header. The \";auto\" string can be used alone,  even  if\n"
 "          you don't set an initial referer.\n"
 "\n"
+);
+ puts(
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
+"     --environment\n"
+"          (RISC OS ONLY) Sets a range of  environment  variables,\n"
+"          using the names the -w option supports, to easier allow\n"
+"          extraction of useful information after having run curl.\n"
+"\n"
+"          If  this  option is used several times, each occurrence\n"
+"          will toggle this on/off.\n"
+"\n"
 "     --egd-file <file>\n"
+"          (HTTPS) Specify the path name to the Entropy  Gathering\n"
 );
  puts(
-"          (HTTPS)  Specify the path name to the Entropy Gathering\n"
-"          Daemon socket. The socket is used to  seed  the  random\n"
-"          engine  for SSL connections. See also the --random-file\n"
+"          Daemon  socket.  The  socket is used to seed the random\n"
+"          engine for SSL connections. See also the  --random-file\n"
 "          option.\n"
 "\n"
 "     -E/--cert <certificate[:password]>\n"
-"          (HTTPS) Tells curl to  use  the  specified  certificate\n"
-"          file  when  getting  a file with HTTPS. The certificate\n"
-"          must be in PEM format.  If the optional password  isn't\n"
+"          (HTTPS)  Tells  curl  to  use the specified certificate\n"
+"          file when getting a file with  HTTPS.  The  certificate\n"
+"          must  be in PEM format.  If the optional password isn't\n"
+"          specified, it will be queried for on the terminal. Note\n"
 );
  puts(
-"          specified, it will be queried for on the terminal. Note\n"
-"          that this certificate is the private key and  the  pri­\n"
+"          that  this  certificate is the private key and the pri­\n"
 "          vate certificate concatenated!\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     --cacert <CA certificate>\n"
-"          (HTTPS) Tells curl to  use  the  specified  certificate\n"
-"          file to verify the peer. The certificate must be in PEM\n"
-"          format.\n"
+"          (HTTPS)  Tells  curl  to  use the specified certificate\n"
+"          file to verify the peer. The file may contain  multiple\n"
+"          CA certificates. The certificate(s) must be in PEM for­\n"
+"          mat.\n"
+"\n"
+);
+ puts(
+"          If this option is used several times, the last one will\n"
+"          be used.\n"
 "\n"
+"     --capath <CA certificate directory>\n"
+"          (HTTPS)  Tells  curl  to  use the specified certificate\n"
+"          directory to verify the peer. The certificates must  be\n"
+"          in  PEM  format,  and the directory must have been pro­\n"
+"          cessed  using  the  c_rehash  utility   supplied   with\n"
+"          openssl.  Certificate  directories  are  not  supported\n"
 );
  puts(
+"          under Windows (because c_rehash uses symbolink links to\n"
+"          create  them).  Using  --capath  can allow curl to make\n"
+"          https connections  much  more  efficiently  than  using\n"
+"          --cacert if the --cacert file contains many CA certifi­\n"
+"          cates.\n"
+"\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -f/--fail\n"
 "          (HTTP)  Fail  silently  (no  output  at  all) on server\n"
+);
+ puts(
 "          errors. This is mostly done like this to better  enable\n"
 "          scripts  etc  to  better  deal with failed attempts. In\n"
 "          normal cases when a HTTP server fails to deliver a doc­\n"
 "          ument,  it  returns  a  HTML document stating so (which\n"
 "          often also describes why and more). This flag will pre­\n"
-);
- puts(
 "          vent  curl  from  outputting  that  and  fail  silently\n"
 "          instead.\n"
+"\n"
 "          If this option is used twice,  the  second  will  again\n"
+);
+ puts(
 "          disable silent failure.\n"
 "\n"
 "     -F/--form <name=content>\n"
 "          (HTTP) This lets curl emulate a filled in form in which\n"
 "          a user has pressed the submit button. This causes  curl\n"
 "          to POST data using the content-type multipart/form-data\n"
 "          according to RFC1867. This enables uploading of  binary\n"
-);
- puts(
 "          files etc. To force the 'content' part to be be a file,\n"
 "          prefix the file name with an @ sign. To  just  get  the\n"
+);
+ puts(
 "          content part from a file, prefix the file name with the\n"
 "          letter <. The difference between @ and < is then that @\n"
 "          makes a file get attached in the post as a file upload,\n"
 "          while the < makes a text field and just  get  the  con­\n"
 "          tents for that text field from a file.\n"
 "\n"
-);
- puts(
 "          Example,  to  send  your  password  file to the server,\n"
 "          where 'password' is the name of the form-field to which\n"
 "          /etc/passwd will be the input:\n"
 "\n"
+);
+ puts(
 "          curl -F password=@/etc/passwd www.mypasswords.com\n"
 "\n"
 "          To read the file's content from stdin insted of a file,\n"
 "          use - where the file name should've been. This goes for\n"
 "          both @ and < constructs.\n"
 "\n"
 "          This option can be used multiple times.\n"
 "\n"
 "     -g/--globoff\n"
-);
- puts(
 "          This  option  switches  off  the \"URL globbing parser\".\n"
 "          When you set this option, you  can  specify  URLs  that\n"
 "          contain  the  letters  {}[]  without  having them being\n"
+);
+ puts(
 "          interpreted by curl itself. Note that these letters are\n"
 "          not  normal  legal  URL  contents  but  they  should be\n"
-"          encoded according to the URI standard. (Option added in\n"
-"          curl 7.6)\n"
+"          encoded according to the URI standard.\n"
 "\n"
 "     -G/--get\n"
-"          When  used,  this  option  will make all data specified\n"
+"          When used, this option will  make  all  data  specified\n"
+"          with  -d/--data  or  --data-binary to be used in a HTTP\n"
+"          GET request instead of the POST request that  otherwise\n"
+"          would  be  used.  The  data will be appended to the URL\n"
 );
  puts(
-"          with -d/--data or --data-binary to be used  in  a  HTTP\n"
-"          GET  request instead of the POST request that otherwise\n"
-"          would be used. The data will be  appended  to  the  URL\n"
 "          with a '?'  separator. (Option added in curl 7.9)\n"
 "\n"
+"          If used in combination with  -I,  the  POST  data  will\n"
+"          instead be appended to the URL with a HEAD request.\n"
+"\n"
+"          If used multiple times, nothing special happens.\n"
+"\n"
 "     -h/--help\n"
 "          Usage help.\n"
 "\n"
 "     -H/--header <header>\n"
 "          (HTTP) Extra header to use when getting a web page. You\n"
 "          may specify any number of extra headers. Note  that  if\n"
 );
  puts(
 "          you  should  add a custom header that has the same name\n"
-"          as one of  the  internal  ones  curl  would  use,  your\n"
-"          externally  set  header  will  be  used  instead of the\n"
-"          internal one. This allows you  to  make  even  trickier\n"
-"          stuff  than  curl  would  normally  do.  You should not\n"
-"          replace internally set  headers  without  knowing  per­\n"
-"          fectly  well  what  you're doing. Replacing an internal\n"
+"          as one of the internal ones curl would use, your exter­\n"
+"          nally  set  header will be used instead of the internal\n"
+"          one. This allows you to make even trickier  stuff  than\n"
+"          curl  would  normally do. You should not replace inter­\n"
+"          nally set headers without knowing perfectly  well  what\n"
+"          you're  doing.  Replacing  an  internal header with one\n"
 );
  puts(
-"          header with one without content on the  right  side  of\n"
-"          the colon will prevent that header from appearing.\n"
-"\n"
-"          This option can be used multiple times.\n"
+"          without content on the right side  of  the  colon  will\n"
+"          prevent that header from appearing.\n"
+"          This   option   can   be   used   multiple   times   to\n"
+"          add/replace/remove multiple headers.\n"
 "\n"
 "     -i/--include\n"
 "          (HTTP) Include the HTTP-header in the output. The HTTP-\n"
-"          header includes things like server-name,  date  of  the\n"
+"          header  includes  things  like server-name, date of the\n"
 "          document, HTTP-version and more...\n"
 "\n"
-"          If  this  option  is  used twice, the second will again\n"
+"          If this option is used twice,  the  second  will  again\n"
+);
+ puts(
 "          disable header include.\n"
 "\n"
 "     --interface <name>\n"
-);
- puts(
-"          Perform an operation using a specified  interface.  You\n"
-"          can  enter  interface name, IP address or host name. An\n"
+"          Perform  an  operation using a specified interface. You\n"
+"          can enter interface name, IP address or host  name.  An\n"
 "          example could look like:\n"
 "\n"
 "          curl --interface eth0:1 http://www.netscape.com/\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -I/--head\n"
-"          (HTTP/FTP)  Fetch  the  HTTP-header  only! HTTP-servers\n"
-"          feature the command HEAD which this uses to get nothing\n"
+"          (HTTP/FTP) Fetch  the  HTTP-header  only!  HTTP-servers\n"
 );
  puts(
-"          but  the header of a document. When used on a FTP file,\n"
+"          feature the command HEAD which this uses to get nothing\n"
+"          but the header of a document. When used on a FTP  file,\n"
 "          curl displays the file size only.\n"
 "\n"
-"          If this option is used twice,  the  second  will  again\n"
+"          If  this  option  is  used twice, the second will again\n"
 "          disable header only.\n"
 "\n"
+"     -j/--junk-session-cookies\n"
+"          (HTTP) When curl is told to read cookies from  a  given\n"
+"          file,  this  option  will  make it discard all \"session\n"
+);
+ puts(
+"          cookies\". This will basicly have the same effect as  if\n"
+"          a  new session is started. Typical browsers always dis­\n"
+"          card session cookies when they're closed  down.  (Added\n"
+"          in 7.9.7)\n"
+"\n"
+"          If  this  option is used several times, each occurrence\n"
+"          will toggle this on/off.\n"
+"\n"
 "     --krb4 <level>\n"
-"          (FTP)  Enable  kerberos4  authentication  and  use. The\n"
-"          level must be entered and should  be  one  of  'clear',\n"
-"          'safe',  'confidential'  or 'private'. Should you use a\n"
-"          level that is not one of these, 'private' will  instead\n"
+"          (FTP) Enable  kerberos4  authentication  and  use.  The\n"
+"          level  must  be  entered  and should be one of 'clear',\n"
 );
  puts(
+"          'safe', 'confidential' or 'private'. Should you  use  a\n"
+"          level  that is not one of these, 'private' will instead\n"
 "          be used.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -K/--config <config file>\n"
-"          Specify which config file to read curl arguments  from.\n"
-"          The  config  file  is a text file in which command line\n"
-"          arguments can be written which then will be used as  if\n"
-"          they  were  written on the actual command line. Options\n"
-"          and their parameters must be specified on the same con­\n"
+"          Specify  which config file to read curl arguments from.\n"
+"          The config file is a text file in  which  command  line\n"
+"          arguments  can be written which then will be used as if\n"
 );
  puts(
-"          fig  file  line.  If  the parameter is to contain white\n"
-"          spaces, the parameter must be inclosed  within  quotes.\n"
-"          If  the  first column of a config line is a '#' charac­\n"
+"          they were written on the actual command  line.  Options\n"
+"          and their parameters must be specified on the same con­\n"
+"          fig file line. If the parameter  is  to  contain  white\n"
+"          spaces,  the  parameter must be inclosed within quotes.\n"
+"          If the first column of a config line is a  '#'  charac­\n"
 "          ter, the rest of the line will be treated as a comment.\n"
 "\n"
-"          Specify  the filename as '-' to make curl read the file\n"
+"          Specify the filename as '-' to make curl read the  file\n"
 "          from stdin.\n"
 "\n"
+);
+ puts(
+"          Note  that  to  be  able to specify a URL in the config\n"
+"          file, you need to specify it using  the  --url  option,\n"
+"          and  not by simply writing the URL on its own line. So,\n"
+"          it could look similar to this:\n"
+"\n"
+"          url = \"http://curl.haxx.se/docs/\"\n"
+"\n"
 "          This option can be used multiple times.\n"
 "\n"
 "     -l/--list-only\n"
 "          (FTP) When listing an FTP directory, this switch forces\n"
+"          a  name-only  view.   Especially  useful if you want to\n"
 );
  puts(
-"          a  name-only  view.   Especially  useful if you want to\n"
 "          machine-parse the contents of an  FTP  directory  since\n"
 "          the  normal  directory view doesn't use a standard look\n"
 "          or format.\n"
 "\n"
-"          If this option is used twice,  the  second  will  again\n"
+"          This option causes an FTP  NLST  command  to  be  sent.\n"
+"          Some  FTP  servers list only files in their response to\n"
+"          NLST; they do not include subdirectories  and  symbolic\n"
+"          links.\n"
+"\n"
+"          If  this  option  is  used twice, the second will again\n"
 "          disable list only.\n"
 "\n"
 "     -L/--location\n"
-"          (HTTP/HTTPS)  If  the server reports that the requested\n"
-"          page has  a  different  location  (indicated  with  the\n"
 );
  puts(
-"          header  line Location:) this flag will let curl attempt\n"
+"          (HTTP/HTTPS) If the server reports that  the  requested\n"
+"          page  has  a  different  location  (indicated  with the\n"
+"          header line Location:) this flag will let curl  attempt\n"
 "          to reattempt the get on the new place. If used together\n"
 "          with -i or -I, headers from all requested pages will be\n"
-"          shown. If this flag is used when making  a  HTTP  POST,\n"
+"          shown.  If  this  flag is used when making a HTTP POST,\n"
 "          curl will automatically switch to GET after the initial\n"
 "          POST has been done.\n"
 "\n"
-"          If this option is used twice,  the  second  will  again\n"
+);
+ puts(
+"          If  this  option  is  used twice, the second will again\n"
 "          disable location following.\n"
 "\n"
 "     -m/--max-time <seconds>\n"
-);
- puts(
-"          Maximum time in seconds that you allow the whole opera­\n"
-"          tion to take.  This is useful for preventing your batch\n"
-"          jobs  from  hanging  for  hours due to slow networks or\n"
-"          links going down.  This doesn't  work  fully  in  win32\n"
+"          Maximum time  in  seconds  that  you  allow  the  whole\n"
+"          operation  to take.  This is useful for preventing your\n"
+"          batch jobs from hanging for hours due to slow  networks\n"
+"          or  links going down.  This doesn't work fully in win32\n"
 "          systems.  See also the --connect-timeout option.\n"
 "\n"
+);
+ puts(
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -M/--manual\n"
 "          Manual. Display the huge help text.\n"
 "\n"
 "     -n/--netrc\n"
-);
- puts(
-"          Makes curl scan the .netrc  file  in  the  user's  home\n"
-"          directory  for  login  name and password. This is typi­\n"
-"          cally used for ftp on unix. If  used  with  http,  curl\n"
+"          Makes  curl  scan  the  .netrc  file in the user's home\n"
+"          directory for login name and password.  This  is  typi­\n"
+"          cally  used  for  ftp  on unix. If used with http, curl\n"
 "          will enable user authentication. See netrc(4) or ftp(1)\n"
-"          for details on the file format. Curl will not  complain\n"
-"          if  that  file  hasn't the right permissions (it should\n"
-"          not be world nor group readable). The environment vari­\n"
+"          for  details on the file format. Curl will not complain\n"
 );
  puts(
+"          if that file hasn't the right  permissions  (it  should\n"
+"          not be world nor group readable). The environment vari­\n"
 "          able \"HOME\" is used to find the home directory.\n"
 "\n"
-"          A  quick  and  very  simple  example  of how to setup a\n"
-"          .netrc  to  allow  curl   to   ftp   to   the   machine\n"
-"          host.domain.com  with  user  name 'myself' and password\n"
+"          A quick and very simple  example  of  how  to  setup  a\n"
+"          .netrc   to   allow   curl   to   ftp  to  the  machine\n"
+"          host.domain.com with user name  'myself'  and  password\n"
 "          'secret' should look similar to:\n"
 "\n"
 "          machine host.domain.com login myself password secret\n"
 "\n"
-"          If this option is used twice,  the  second  will  again\n"
+);
+ puts(
+"          If  this  option  is  used twice, the second will again\n"
 "          disable netrc usage.\n"
 "\n"
 "     -N/--no-buffer\n"
-);
- puts(
-"          Disables  the buffering of the output stream. In normal\n"
+"          Disables the buffering of the output stream. In  normal\n"
 "          work situations, curl will use a standard buffered out­\n"
-"          put  stream that will have the effect that it will out­\n"
-"          put the data in chunks, not  necessarily  exactly  when\n"
-"          the  data arrives.  Using this option will disable that\n"
+"          put stream that will have the effect that it will  out­\n"
+"          put  the  data  in chunks, not necessarily exactly when\n"
+"          the data arrives.  Using this option will disable  that\n"
 "          buffering.\n"
 "\n"
-"          If this option is used twice,  the  second  will  again\n"
+);
+ puts(
+"          If  this  option  is  used twice, the second will again\n"
 "          switch on buffering.\n"
 "\n"
 "     -o/--output <file>\n"
-);
- puts(
-"          Write  output  to  <file> instead of stdout. If you are\n"
+"          Write output to <file> instead of stdout.  If  you  are\n"
 "          using {} or [] to fetch multiple documents, you can use\n"
-"          '#'  followed by a number in the <file> specifier. That\n"
-"          variable will be replaced with the current  string  for\n"
+"          '#' followed by a number in the <file> specifier.  That\n"
+"          variable  will  be replaced with the current string for\n"
 "          the URL being fetched. Like in:\n"
 "\n"
 "            curl http://{one,two}.site.com -o \"file_#1.txt\"\n"
 "\n"
+);
+ puts(
 "          or use several variables like:\n"
-"\n"
 "            curl http://{site,host}.host[1-5].com -o \"#1_#2\"\n"
 "\n"
-);
- puts(
-"          You  may use this option as many times as you have num­\n"
+"          You may use this option as many times as you have  num­\n"
 "          ber of URLs.\n"
 "\n"
 "     -O/--remote-name\n"
 "          Write output to a local file named like the remote file\n"
 "          we get. (Only the file part of the remote file is used,\n"
 "          the path is cut off.)\n"
 "\n"
-"          You may use this option as many times as you have  num­\n"
+"          You  may use this option as many times as you have num­\n"
 "          ber of URLs.\n"
 "\n"
 "     -p/--proxytunnel\n"
-"          When an HTTP proxy is used, this option will cause non-\n"
 );
  puts(
-"          HTTP protocols to attempt to tunnel through  the  proxy\n"
-"          instead  of merely using it to do HTTP-like operations.\n"
+"          When an HTTP proxy is used, this option will cause non-\n"
+"          HTTP  protocols  to attempt to tunnel through the proxy\n"
+"          instead of merely using it to do HTTP-like  operations.\n"
 "          The tunnel approach is made with the HTTP proxy CONNECT\n"
-"          request  and requires that the proxy allows direct con­\n"
-"          nect to the remote port number  curl  wants  to  tunnel\n"
+"          request and requires that the proxy allows direct  con­\n"
+"          nect  to  the  remote  port number curl wants to tunnel\n"
 "          through to.\n"
 "\n"
-"          If  this  option  is  used twice, the second will again\n"
+"          If this option is used twice,  the  second  will  again\n"
+);
+ puts(
 "          disable proxy tunnel.\n"
 "\n"
 "     -P/--ftpport <address>\n"
-);
- puts(
-"          (FTP) Reverses the initiator/listener roles  when  con­\n"
-"          necting  with  ftp. This switch makes Curl use the PORT\n"
-"          command instead of PASV. In practice,  PORT  tells  the\n"
+"          (FTP)  Reverses  the initiator/listener roles when con­\n"
+"          necting with ftp. This switch makes Curl use  the  PORT\n"
+"          command  instead  of  PASV. In practice, PORT tells the\n"
 "          server to connect to the client's specified address and\n"
-"          port, while PASV asks the server for an ip address  and\n"
+"          port,  while PASV asks the server for an ip address and\n"
 "          port to connect to. <address> should be one of:\n"
 "\n"
-"          interface   i.e  \"eth0\" to specify which interface's IP\n"
 );
  puts(
+"          interface   i.e \"eth0\" to specify which interface's  IP\n"
 "                      address you want to use  (Unix only)\n"
 "\n"
 "          IP address  i.e \"192.168.10.1\" to specify exact IP num­\n"
 "                      ber\n"
 "\n"
 "          host name   i.e \"my.host.domain\" to specify machine\n"
 "\n"
-"          -           (any  single-letter string) to make it pick\n"
+"          -           (any single-letter string) to make it  pick\n"
 "                      the machine's default\n"
 "\n"
-"     If this option is used several times, the last one  will  be\n"
+"     If  this  option is used several times, the last one will be\n"
 "     used.\n"
 "\n"
-"     -q   If used as the first parameter on the command line, the\n"
 );
  puts(
-"          $HOME/.curlrc file will not be read and used as a  con­\n"
+"     -q   If used as the first parameter on the command line, the\n"
+"          $HOME/.curlrc  file will not be read and used as a con­\n"
 "          fig file.\n"
 "\n"
 "     -Q/--quote <comand>\n"
-"          (FTP)  Send  an  arbitrary  command  to  the remote FTP\n"
-"          server, by using the QUOTE command of the  server.  Not\n"
-"          all  servers support this command, and the set of QUOTE\n"
-"          commands are server specific! Quote commands  are  sent\n"
-"          BEFORE  the  transfer is taking place. To make commands\n"
+"          (FTP) Send an  arbitrary  command  to  the  remote  FTP\n"
+"          server,  by  using the QUOTE command of the server. Not\n"
+"          all servers support this command, and the set of  QUOTE\n"
+"          commands  are  server specific! Quote commands are sent\n"
 );
  puts(
-"          take place after a  successful  transfer,  prefix  them\n"
+"          BEFORE the transfer is taking place. To  make  commands\n"
+"          take  place  after  a  successful transfer, prefix them\n"
 "          with a dash '-'. You may specify any amount of commands\n"
-"          to be run before and after the transfer. If the  server\n"
-"          returns  failure  for  one  of the commands, the entire\n"
+"          to  be run before and after the transfer. If the server\n"
+"          returns failure for one of  the  commands,  the  entire\n"
 "          operation will be aborted.\n"
 "\n"
 "          This option can be used multiple times.\n"
 "\n"
 "     --random-file <file>\n"
-"          (HTTPS) Specify the path name to file  containing  what\n"
 );
  puts(
-"          will  be considered as random data. The data is used to\n"
-"          seed the random engine for SSL connections.   See  also\n"
+"          (HTTPS)  Specify  the path name to file containing what\n"
+"          will be considered as random data. The data is used  to\n"
+"          seed  the  random engine for SSL connections.  See also\n"
 "          the --edg-file option.\n"
 "\n"
 "     -r/--range <range>\n"
-"          (HTTP/FTP)  Retrieve  a byte range (i.e a partial docu­\n"
-"          ment) from a HTTP/1.1 or  FTP  server.  Ranges  can  be\n"
+"          (HTTP/FTP) Retrieve a byte range (i.e a  partial  docu­\n"
+"          ment)  from  a  HTTP/1.1  or  FTP server. Ranges can be\n"
 "          specified in a number of ways.\n"
 "\n"
 "          0-499     specifies the first 500 bytes\n"
 "\n"
-"          500-999   specifies the second 500 bytes\n"
-"\n"
 );
  puts(
+"          500-999   specifies the second 500 bytes\n"
+"\n"
 "          -500      specifies the last 500 bytes\n"
 "\n"
 "          9500      specifies the bytes from offset 9500 and for­\n"
 "                    ward\n"
 "\n"
 "          0-0,-1    specifies the first and last byte only(*)(H)\n"
@@ -647,503 +724,561 @@
 "          500-700,600-799\n"
 "                    specifies 300 bytes from offset 500(H)\n"
 "\n"
 "          100-199,500-599\n"
 "                    specifies two separate 100 bytes ranges(*)(H)\n"
 "\n"
-"     (*)  =  NOTE that this will cause the server to reply with a\n"
-"     multipart response!\n"
-"\n"
 );
  puts(
-"     You should also be aware that many HTTP/1.1 servers  do  not\n"
+"     (*) = NOTE that this will cause the server to reply  with  a\n"
+"     multipart response!\n"
+"\n"
+"     You  should  also be aware that many HTTP/1.1 servers do not\n"
 "     have this feature enabled, so that when you attempt to get a\n"
 "     range, you'll instead get the whole document.\n"
 "\n"
-"     FTP range downloads only support the simple  syntax  'start-\n"
-"     stop'  (optionally  with  one  of  the  numbers omitted). It\n"
+"     FTP  range  downloads only support the simple syntax 'start-\n"
+"     stop' (optionally with  one  of  the  numbers  omitted).  It\n"
 "     depends on the non-RFC command SIZE.\n"
-"\n"
-"     If this option is used several times, the last one  will  be\n"
+);
+ puts(
+"     If  this  option is used several times, the last one will be\n"
 "     used.\n"
 "\n"
 "     -R/--remote-time\n"
-);
- puts(
 "          When used, this will make libcurl attempt to figure out\n"
 "          the timestamp of the remote file, and if that is avail­\n"
 "          able make the local file get that same timestamp.\n"
 "\n"
-"          If  this option is used twice, the second time disables\n"
+"          If this option is used twice, the second time  disables\n"
 "          this again.\n"
 "\n"
 "     -s/--silent\n"
-"          Silent mode. Don't show progress meter  or  error  mes­\n"
+"          Silent  mode.  Don't  show progress meter or error mes­\n"
 "          sages.  Makes Curl mute.\n"
-"          If  this  option  is  used twice, the second will again\n"
-"          disable mute.\n"
-"\n"
 );
  puts(
+"\n"
+"          If this option is used twice,  the  second  will  again\n"
+"          disable mute.\n"
+"\n"
 "     -S/--show-error\n"
-"          When used with -s it makes curl show error  message  if\n"
+"          When  used  with -s it makes curl show error message if\n"
 "          it fails.\n"
 "\n"
-"          If  this  option  is  used twice, the second will again\n"
+"          If this option is used twice,  the  second  will  again\n"
 "          disable show error.\n"
 "\n"
+"     --stderr <file>\n"
+"          Redirect  all  writes  to  stderr to the specified file\n"
+"          instead. If the file name is a plain '-', it is instead\n"
+);
+ puts(
+"          written to stdout. This option has no point when you're\n"
+"          using a shell with decent redirecting capabilities.\n"
+"\n"
+"          If this option is used several times, the last one will\n"
+"          be used.\n"
+"\n"
 "     -t/--telnet-option <OPT=val>\n"
-"          Pass options to the telnet protocol. Supported  options\n"
+"          Pass  options to the telnet protocol. Supported options\n"
 "          are:\n"
 "\n"
 "          TTYPE=<term> Sets the terminal type.\n"
 "\n"
 "          XDISPLOC=<X display> Sets the X display location.\n"
 "\n"
 "          NEW_ENV=<var,val> Sets an environment variable.\n"
 "\n"
 );
  puts(
 "     -T/--upload-file <file>\n"
-"          Like  -t,  but this transfers the specified local file.\n"
-"          If there is no file part in  the  specified  URL,  Curl\n"
-"          will append the local file name. NOTE that you must use\n"
-"          a trailing / on the last directory to really  prove  to\n"
-"          Curl that there is no file name or curl will think that\n"
-"          your last directory name is the  remote  file  name  to\n"
-"          use.  That  will most likely cause the upload operation\n"
+"          This transfers the specified local file to  the  remote\n"
+"          URL.  If  there  is  no file part in the specified URL,\n"
+"          Curl will append the local file  name.  NOTE  that  you\n"
+"          must  use  a trailing / on the last directory to really\n"
+"          prove to Curl that there is no file name or  curl  will\n"
+"          think  that your last directory name is the remote file\n"
+"          name to use. That will most  likely  cause  the  upload\n"
 );
  puts(
-"          to fail. If this is used on a http(s) server,  the  PUT\n"
-"          command will be used.\n"
+"          operation to fail. If this is used on a http(s) server,\n"
+"          the PUT command will be used.\n"
+"\n"
+"          Use the file name \"-\" (a  single  dash)  to  use  stdin\n"
+"          instead of a given file.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
-"     -u/--user <user:password>\n"
-"          Specify user and password to  use  when  fetching.  See\n"
-"          README.curl  for  detailed examples of how to use this.\n"
-"          If no password is  specified,  curl  will  ask  for  it\n"
-"          interactively.\n"
+"     --trace <file>\n"
+"          Enables a full trace dump of all incoming and  outgoing\n"
+"          data,  including  descriptive information, to the given\n"
+);
+ puts(
+"          output file. Use \"-\" as filename  to  have  the  output\n"
+"          sent to stdout.\n"
+"\n"
+"          If this option is used several times, the last one will\n"
+"          be used. (Added in curl 7.9.7)\n"
+"\n"
+"     --trace-ascii <file>\n"
+"          Enables a full trace dump of all incoming and  outgoing\n"
+"          data,  including  descriptive information, to the given\n"
+"          output file. Use \"-\" as filename  to  have  the  output\n"
+"          sent to stdout.\n"
 "\n"
 );
  puts(
+"          This is very similar to --trace, but leaves out the hex\n"
+"          part and only shows the ASCII  part  of  the  dump.  It\n"
+"          makes  smaller  output that might be easier to read for\n"
+"          untrained humans.\n"
+"\n"
+"          If this option is used several times, the last one will\n"
+"          be used. (Added in curl 7.9.7)\n"
+"\n"
+"     -u/--user <user:password>\n"
+"          Specify  user  and  password  to use when fetching. See\n"
+"          README.curl for detailed examples of how to  use  this.\n"
+);
+ puts(
+"          If  no  password  is  specified,  curl  will ask for it\n"
+"          interactively.\n"
+"\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -U/--proxy-user <user:password>\n"
-"          Specify user and password to use for Proxy  authentica­\n"
+"          Specify  user and password to use for Proxy authentica­\n"
 "          tion. If no password is specified, curl will ask for it\n"
 "          interactively.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     --url <URL>\n"
-"          Specify  a  URL  to  fetch. This option is mostly handy\n"
 );
  puts(
-"          when you wanna specify URL(s) in a config file.\n"
-"\n"
+"          Specify a URL to fetch. This  option  is  mostly  handy\n"
+"          when you want to specify URL(s) in a config file.\n"
 "          This option may be used any number of times. To control\n"
-"          where  this  URL  is  written,  use  the  -o  or the -O\n"
+"          where this URL  is  written,  use  the  -o  or  the  -O\n"
 "          options.\n"
 "\n"
 "     -v/--verbose\n"
-"          Makes  the  fetching  more  verbose/talkative.   Mostly\n"
-"          usable  for  debugging.  Lines  starting with '>' means\n"
+"          Makes   the  fetching  more  verbose/talkative.  Mostly\n"
+"          usable for debugging. Lines  starting  with  '>'  means\n"
 "          data sent by curl, '<' means data received by curl that\n"
-"          is  hidden  in normal cases and lines starting with '*'\n"
 );
  puts(
+"          is hidden in normal cases and lines starting  with  '*'\n"
 "          means additional info provided by curl.\n"
 "\n"
-"          If this option is used twice,  the  second  will  again\n"
+"          If  this  option  is  used twice, the second will again\n"
 "          disable verbose.\n"
 "\n"
 "     -V/--version\n"
-"          Displays  the  full  version of curl, libcurl and other\n"
+"          Displays the full version of curl,  libcurl  and  other\n"
 "          3rd party libraries linked with the executable.\n"
 "\n"
 "     -w/--write-out <format>\n"
-"          Defines what to display after a completed and  success­\n"
-"          ful  operation. The format is a string that may contain\n"
+"          Defines  what to display after a completed and success­\n"
 );
  puts(
-"          plain text mixed with  any  number  of  variables.  The\n"
+"          ful operation. The format is a string that may  contain\n"
+"          plain  text  mixed  with  any  number of variables. The\n"
 "          string can be specified as \"string\", to get read from a\n"
-"          particular file you specify it \"@filename\" and to  tell\n"
+"          particular  file you specify it \"@filename\" and to tell\n"
 "          curl to read the format from stdin you write \"@-\".\n"
 "\n"
 "          The variables present in the output format will be sub­\n"
-"          stituted by the value or text that curl thinks fit,  as\n"
-"          described  below.  All  variables  are  specified  like\n"
+"          stituted  by the value or text that curl thinks fit, as\n"
 );
  puts(
-"          %{variable_name} and to output  a  normal  %  you  just\n"
-"          write  them  like %%. You can output a newline by using\n"
-"          \\n, a carrige return with \\r and a tab space with \\t.\n"
+"          described  below.  All  variables  are  specified  like\n"
+"          %{variable_name}  and  to  output  a  normal % you just\n"
+"          write them like %%. You can output a newline  by  using\n"
+"          \\n,  a carriage return with \\r and a tab space with \\t.\n"
 "\n"
 "          NOTE:  The  %-letter  is  a  special  letter   in   the\n"
 "          win32-environment,  where  all occurrences of % must be\n"
 "          doubled when using this option.\n"
 "\n"
 "          Available variables are at this point:\n"
 "\n"
-"          url_effective  The URL that was fetched last.  This  is\n"
 );
  puts(
+"          url_effective  The URL that was fetched last.  This  is\n"
 "                         mostly meaningful if you've told curl to\n"
 "                         follow location: headers.\n"
 "\n"
 "          http_code      The numerical code that was found in the\n"
 "                         last retrieved HTTP(S) page.\n"
 "\n"
 "          time_total     The  total  time,  in  seconds, that the\n"
 "                         full operation lasted. The time will  be\n"
-"                         displayed with millisecond resolution.\n"
-"          time_namelookup\n"
 );
  puts(
+"                         displayed with millisecond resolution.\n"
+"\n"
+"          time_namelookup\n"
 "                         The  time,  in seconds, it took from the\n"
 "                         start until the name resolving was  com­\n"
 "                         pleted.\n"
 "\n"
 "          time_connect   The  time,  in seconds, it took from the\n"
 "                         start until the connect  to  the  remote\n"
 "                         host (or proxy) was completed.\n"
 "\n"
 "          time_pretransfer\n"
-"                         The  time,  in seconds, it took from the\n"
 );
  puts(
+"                         The  time,  in seconds, it took from the\n"
 "                         start until the file  transfer  is  just\n"
 "                         about  to  begin. This includes all pre-\n"
 "                         transfer commands and negotiations  that\n"
 "                         are  specific  to  the particular proto­\n"
 "                         col(s) involved.\n"
 "\n"
+"          time_starttransfer\n"
+"                         The time, in seconds, it took  from  the\n"
+);
+ puts(
+"                         start until the first byte is just about\n"
+"                         to   be   transfered.   This    includes\n"
+"                         time_pretransfer  and  also the time the\n"
+"                         server needs to calculate the result.\n"
+"\n"
 "          size_download  The total  amount  of  bytes  that  were\n"
 "                         downloaded.\n"
 "\n"
 "          size_upload    The  total  amount  of  bytes  that were\n"
-);
- puts(
 "                         uploaded.\n"
 "\n"
+);
+ puts(
 "          size_header    The total amount of bytes of  the  down­\n"
 "                         loaded headers.\n"
 "\n"
 "          size_request   The total amount of bytes that were sent\n"
 "                         in the HTTP request.\n"
 "\n"
 "          speed_download The average  download  speed  that  curl\n"
 "                         measured for the complete download.\n"
 "\n"
 "          speed_upload   The  average upload speed that curl mea­\n"
+"                         sured for the complete upload.\n"
+"\n"
 );
  puts(
-"                         sured for the complete upload.\n"
+"          content_type   The Content-Type of the requested  docu­\n"
+"                         ment, if there was any. (Added in 7.9.5)\n"
 "\n"
 "     If this option is used several times, the last one  will  be\n"
 "     used.\n"
 "\n"
 "     -x/--proxy <proxyhost[:port]>\n"
-"          Use  specified  proxy. If the port number is not speci­\n"
-"          fied, it is assumed at port 1080.\n"
+"          Use  specified  HTTP  proxy.  If the port number is not\n"
+"          specified, it is assumed at port 1080.\n"
+"\n"
+"          Note that all operations that are performed over a HTTP\n"
+"          proxy will transparantly be converted to HTTP. It means\n"
+);
+ puts(
+"          that certain protocol specific operations might not  be\n"
+"          available.  This  is  not  the  case  if you can tunnel\n"
+"          through the proxy, as done  with  the  -p/--proxytunnel\n"
+"          option.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -X/--request <command>\n"
-"          (HTTP)  Specifies a custom request to use when communi­\n"
+"          (HTTP) Specifies a custom request to use when  communi­\n"
+"          cating  with  the  HTTP  server.  The specified request\n"
 );
  puts(
-"          cating with the HTTP  server.   The  specified  request\n"
 "          will be used instead of the standard GET. Read the HTTP\n"
 "          1.1 specification for details and explanations.\n"
 "\n"
-"          (FTP) Specifies a custom FTP command to use instead  of\n"
+"          (FTP)  Specifies a custom FTP command to use instead of\n"
 "          LIST when doing file lists with ftp.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -y/--speed-time <time>\n"
 "          If a download is slower than speed-limit bytes per sec­\n"
+"          ond during  a  speed-time  period,  the  download  gets\n"
 );
  puts(
-"          ond  during  a  speed-time  period,  the  download gets\n"
 "          aborted. If speed-time is used, the default speed-limit\n"
 "          will be 1 unless set with -y.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
 "     -Y/--speed-limit <speed>\n"
 "          If a download is slower than this given speed, in bytes\n"
-"          per  second,  for  speed-time  seconds it gets aborted.\n"
+"          per second, for speed-time  seconds  it  gets  aborted.\n"
 "          speed-time is set with -Y and is 30 if not set.\n"
 "\n"
-);
- puts(
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
+);
+ puts(
 "     -z/--time-cond <date expression>\n"
-"          (HTTP)  Request  to  get  a file that has been modified\n"
-"          later than the given time and date,  or  one  that  has\n"
+"          (HTTP) Request to get a file  that  has  been  modified\n"
+"          later  than  the  given  time and date, or one that has\n"
 "          been modified before that time. The date expression can\n"
 "          be all sorts of date strings or if it doesn't match any\n"
-"          internal  ones,  it  tries to get the time from a given\n"
-);
- puts(
-"          file name instead! See the  GNU  date(1)  or  curl_get­\n"
+"          internal ones, it tries to get the time  from  a  given\n"
+"          file  name  instead!  See  the GNU date(1) or curl_get­\n"
 "          date(3) man pages for date expression details.\n"
 "\n"
-"          Start  the  date  expression with a dash (-) to make it\n"
-"          request for a document that is  older  than  the  given\n"
+);
+ puts(
+"          Start the date expression with a dash (-)  to  make  it\n"
+"          request  for  a  document  that is older than the given\n"
 "          date/time, default is a document that is newer than the\n"
 "          specified date/time.\n"
 "\n"
 "          If this option is used several times, the last one will\n"
 "          be used.\n"
 "\n"
-"     -3/--sslv3\n"
+"     -Z/--max-redirs <num>\n"
+"          Set maximum number of  redirection-followings  allowed.\n"
+"          If  -L/--location  is  used, this option can be used to\n"
 );
  puts(
+"          prevent curl from following redirections \"in absurdum\".\n"
+"\n"
+"          If this option is used several times, the last one will\n"
+"          be used.\n"
+"\n"
+"     -3/--sslv3\n"
 "          (HTTPS) Forces curl to use SSL version 3 when negotiat­\n"
 "          ing with a remote SSL server.\n"
 "\n"
 "     -2/--sslv2\n"
 "          (HTTPS) Forces curl to use SSL version 2 when negotiat­\n"
 "          ing with a remote SSL server.\n"
 "\n"
+"     -0/--http1.0\n"
+"          (HTTP) Forces curl to issue its requests using HTTP 1.0\n"
+);
+ puts(
+"          instead of using its internally preferred: HTTP 1.1.\n"
+"\n"
 "     -#/--progress-bar\n"
 "          Make  curl  display  progress information as a progress\n"
 "          bar instead of the default statistics.\n"
 "\n"
 "          If this option is used twice,  the  second  will  again\n"
 "          disable the progress bar.\n"
 "\n"
-"     --crlf\n"
-);
- puts(
-"          (FTP)  Convert  LF  to  CRLF  in upload. Useful for MVS\n"
-"          (OS/390).\n"
-"\n"
-"          If this option is used twice,  the  second  will  again\n"
-"          disable crlf converting.\n"
-"\n"
-"     --stderr <file>\n"
-"          Redirect  all  writes  to  stderr to the specified file\n"
-"          instead. If the file name is a plain '-', it is instead\n"
-"          written to stdout. This option has no point when you're\n"
-"          using a shell with decent redirecting capabilities.\n"
-"\n"
-);
- puts(
-"          If this option is used several times, the last one will\n"
-"          be used.\n"
-"\n"
 "FILES\n"
 "     ~/.curlrc\n"
 "          Default config file.\n"
 "\n"
 "ENVIRONMENT\n"
-"     HTTP_PROXY [protocol://]<host>[:port]\n"
+"     http_proxy [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for HTTP.\n"
 "\n"
+);
+ puts(
 "     HTTPS_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for HTTPS.\n"
 "\n"
 "     FTP_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for FTP.\n"
 "\n"
 "     GOPHER_PROXY [protocol://]<host>[:port]\n"
-);
- puts(
 "          Sets proxy server to use for GOPHER.\n"
 "\n"
 "     ALL_PROXY [protocol://]<host>[:port]\n"
 "          Sets  proxy server to use if no protocol-specific proxy\n"
 "          is set.\n"
 "\n"
 "     NO_PROXY <comma-separated list of hosts>\n"
-"          list of host names that shouldn't go through any proxy.\n"
-"          If set to a asterisk '*' only, it matches all hosts.\n"
-"\n"
-"     COLUMNS <integer>\n"
-"          The  width of the terminal.  This variable only affects\n"
-"          curl when the --progress-bar option is used.\n"
-"\n"
 );
  puts(
+"          list of host names that shouldn't go through any proxy.\n"
+"          If set to a asterisk\n"
+"\n"
 "EXIT CODES\n"
 "     There exists a bunch of different error codes and their cor­\n"
-"     responding  error messages that may appear during bad condi­\n"
+"     responding error messages that may appear during bad  condi­\n"
 "     tions. At the time of this writing, the exit codes are:\n"
+"\n"
 "     1    Unsupported protocol. This build of curl has no support\n"
 "          for this protocol.\n"
 "\n"
 "     2    Failed to initialize.\n"
 "\n"
 "     3    URL malformat. The syntax was not correct.\n"
 "\n"
-"     4    URL  user malformatted. The user-part of the URL syntax\n"
-"          was not correct.\n"
-"\n"
 );
  puts(
-"     5    Couldn't resolve proxy. The given proxy host could  not\n"
+"     4    URL user malformatted. The user-part of the URL  syntax\n"
+"          was not correct.\n"
+"\n"
+"     5    Couldn't  resolve proxy. The given proxy host could not\n"
 "          be resolved.\n"
 "\n"
-"     6    Couldn't  resolve  host.  The given remote host was not\n"
+"     6    Couldn't resolve host. The given remote  host  was  not\n"
 "          resolved.\n"
 "\n"
 "     7    Failed to connect to host.\n"
 "\n"
-"     8    FTP weird server  reply.  The  server  sent  data  curl\n"
+"     8    FTP  weird  server  reply.  The  server  sent data curl\n"
 "          couldn't parse.\n"
 "\n"
 "     9    FTP access denied. The server denied login.\n"
 "\n"
-"     10   FTP  user/password  incorrect.  Either one or both were\n"
-"          not accepted by the server.\n"
-"\n"
 );
  puts(
-"     11   FTP weird PASS reply. Curl  couldn't  parse  the  reply\n"
+"     10   FTP user/password incorrect. Either one  or  both  were\n"
+"          not accepted by the server.\n"
+"\n"
+"     11   FTP  weird  PASS  reply.  Curl couldn't parse the reply\n"
 "          sent to the PASS request.\n"
 "\n"
-"     12   FTP  weird  USER  reply.  Curl couldn't parse the reply\n"
+"     12   FTP weird USER reply. Curl  couldn't  parse  the  reply\n"
 "          sent to the USER request.\n"
 "\n"
-"     13   FTP weird PASV reply, Curl  couldn't  parse  the  reply\n"
+"     13   FTP  weird  PASV  reply,  Curl couldn't parse the reply\n"
 "          sent to the PASV request.\n"
 "\n"
-"     14   FTP  weird 227 format. Curl couldn't parse the 227-line\n"
+"     14   FTP weird 227 format. Curl couldn't parse the  227-line\n"
+);
+ puts(
 "          the server sent.\n"
 "\n"
 "     15   FTP can't get host. Couldn't resolve the host IP we got\n"
 "          in the 227-line.\n"
 "\n"
-);
- puts(
-"     16   FTP  can't  reconnect.  Couldn't connect to the host we\n"
+"     16   FTP can't reconnect. Couldn't connect to  the  host  we\n"
 "          got in the 227-line.\n"
-"\n"
 "     17   FTP  couldn't  set  binary.  Couldn't  change  transfer\n"
 "          method to binary.\n"
 "\n"
 "     18   Partial file. Only a part of the file was transfered.\n"
 "\n"
 "     19   FTP couldn't RETR file. The RETR command failed.\n"
 "\n"
-"     20   FTP  write  error. The transfer was reported bad by the\n"
+);
+ puts(
+"     20   FTP write error. The transfer was reported bad  by  the\n"
 "          server.\n"
 "\n"
-"     21   FTP quote error. A quote command  returned  error  from\n"
+"     21   FTP  quote  error.  A quote command returned error from\n"
 "          the server.\n"
 "\n"
-);
- puts(
-"     22   HTTP  not found. The requested page was not found. This\n"
+"     22   HTTP not found. The requested page was not found.  This\n"
 "          return code only appears if --fail is used.\n"
 "\n"
-"     23   Write error.  Curl  couldn't  write  data  to  a  local\n"
+"     23   Write  error.  Curl  couldn't  write  data  to  a local\n"
 "          filesystem or similar.\n"
 "\n"
 "     24   Malformat user. User name badly specified.\n"
 "\n"
-"     25   FTP  couldn't  STOR  file.  The  server denied the STOR\n"
+);
+ puts(
+"     25   FTP couldn't STOR file.  The  server  denied  the  STOR\n"
 "          operation.\n"
 "\n"
 "     26   Read error. Various reading problems.\n"
 "\n"
 "     27   Out of memory. A memory allocation request failed.\n"
 "\n"
-);
- puts(
-"     28   Operation timeout. The specified  time-out  period  was\n"
+"     28   Operation  timeout.  The  specified time-out period was\n"
 "          reached according to the conditions.\n"
 "\n"
-"     29   FTP  couldn't set ASCII. The server returned an unknown\n"
+"     29   FTP couldn't set ASCII. The server returned an  unknown\n"
 "          reply.\n"
 "\n"
 "     30   FTP PORT failed. The PORT command failed.\n"
 "\n"
+);
+ puts(
 "     31   FTP couldn't use REST. The REST command failed.\n"
 "\n"
-"     32   FTP couldn't use SIZE. The  SIZE  command  failed.  The\n"
-"          command  is  an  extension to the original FTP spec RFC\n"
+"     32   FTP  couldn't  use  SIZE.  The SIZE command failed. The\n"
+"          command is an extension to the original  FTP  spec  RFC\n"
 "          959.\n"
 "\n"
-);
- puts(
 "     33   HTTP range error. The range \"command\" didn't work.\n"
 "\n"
-"     34   HTTP  post  error.  Internal  post-request   generation\n"
+"     34   HTTP   post  error.  Internal  post-request  generation\n"
 "          error.\n"
 "\n"
 "     35   SSL connect error. The SSL handshaking failed.\n"
 "\n"
-"     36   FTP  bad  download resume. Couldn't continue an earlier\n"
+"     36   FTP bad download resume. Couldn't continue  an  earlier\n"
+);
+ puts(
 "          aborted download.\n"
-"\n"
-"     37   FILE couldn't read file. Failed to open the file.  Per­\n"
+"     37   FILE  couldn't read file. Failed to open the file. Per­\n"
 "          missions?\n"
 "\n"
 "     38   LDAP cannot bind. LDAP bind operation failed.\n"
 "\n"
 "     39   LDAP search failed.\n"
 "\n"
-);
- puts(
 "     40   Library not found. The LDAP library was not found.\n"
-"     41   Function  not  found.  A required LDAP function was not\n"
+"\n"
+"     41   Function not found. A required LDAP  function  was  not\n"
 "          found.\n"
 "\n"
-"     42   Aborted by callback. An application told curl to  abort\n"
+"     42   Aborted  by callback. An application told curl to abort\n"
 "          the operation.\n"
 "\n"
+);
+ puts(
 "     43   Internal error. A function was called with a bad param­\n"
 "          eter.\n"
 "\n"
 "     44   Internal error. A function was called in a bad order.\n"
 "\n"
-"     45   Interface error. A specified outgoing  interface  could\n"
+"     45   Interface  error.  A specified outgoing interface could\n"
 "          not be used.\n"
 "\n"
-);
- puts(
-"     46   Bad  password  entered. An error was signalled when the\n"
+"     46   Bad password entered. An error was  signaled  when  the\n"
 "          password was entered.\n"
 "\n"
-"     47   Too many redirects. When following redirects, curl  hit\n"
+"     47   Too  many redirects. When following redirects, curl hit\n"
 "          the maximum amount.\n"
 "\n"
 "     48   Unknown TELNET option specified.\n"
 "\n"
+);
+ puts(
 "     49   Malformed telnet option.\n"
 "\n"
+"     51   The remote peer's SSL certificate wasn't ok\n"
+"\n"
+"     52   The server didn't reply anything, which here is consid­\n"
+"          ered an error.\n"
+"\n"
 "     XX   There  will  appear  more  error  codes  here in future\n"
 "          releases. The existing ones are meant to never  change.\n"
 "\n"
 "BUGS\n"
 "     If you do find bugs, mail them to curl-bug@haxx.se.\n"
 "\n"
 "AUTHORS / CONTRIBUTORS\n"
+"     Daniel  Stenberg  is  the main author, but the whole list of\n"
 );
  puts(
-"     Daniel  Stenberg  is  the main author, but the whole list of\n"
 "     contributors is found in the separate THANKS file.\n"
 "\n"
 "WWW\n"
 "     http://curl.haxx.se\n"
-"\n"
 "FTP\n"
 "     ftp://ftp.sunet.se/pub/www/utilities/curl/\n"
 "\n"
 "SEE ALSO\n"
 "     ftp(1), wget(1), snarf(1)\n"
 "\n"
@@ -1155,18 +1290,18 @@
 "        http://curl.haxx.se\n"
 "\n"
 "SIMPLE USAGE\n"
 "\n"
 "  Get the main page from netscape's web-server:\n"
 "\n"
-);
- puts(
 "        curl http://www.netscape.com/\n"
 "\n"
 "  Get the root README file from funet's ftp-server:\n"
 "\n"
+);
+ puts(
 "        curl ftp://ftp.funet.fi/README\n"
 "\n"
 "  Get a web page from a server using port 8000:\n"
 "\n"
 "        curl http://www.weirdserver.com:8000/\n"
 "\n"
@@ -1179,18 +1314,18 @@
 "        curl gopher://gopher.funet.fi\n"
 "\n"
 "  Get the definition of curl from a dictionary:\n"
 "\n"
 "        curl dict://dict.org/m:curl\n"
 "\n"
-);
- puts(
 "  Fetch two documents at once:\n"
 "\n"
 "        curl ftp://cool.haxx.se/ http://www.weirdserver.com:8000/\n"
 "\n"
+);
+ puts(
 "DOWNLOAD TO A FILE\n"
 "\n"
 "  Get a web page and store in a local file:\n"
 "\n"
 "        curl -o thatpage.html http://www.netscape.com/\n"
 "\n"
@@ -1199,73 +1334,73 @@
 "  will fail):\n"
 "\n"
 "        curl -O http://www.netscape.com/index.html\n"
 "\n"
 "  Fetch two files and store them with their remote names:\n"
 "\n"
-);
- puts(
 "        curl -O www.haxx.se/index.html -O curl.haxx.se/download.html\n"
 "\n"
 "USING PASSWORDS\n"
 "\n"
 " FTP\n"
 "\n"
+);
+ puts(
 "   To ftp files using name+passwd, include them in the URL like:\n"
 "\n"
 "        curl ftp://name:passwd@machine.domain:port/full/path/to/file\n"
 "\n"
 "   or specify them with the -u flag like\n"
 "\n"
 "        curl -u name:passwd ftp://machine.domain:port/full/path/to/file\n"
 "\n"
 " HTTP\n"
 "\n"
 "   The HTTP URL doesn't support user and password in the URL string. Curl\n"
-);
- puts(
 "   does support that anyway to provide a ftp-style interface and thus you can\n"
 "   pick a file like:\n"
 "\n"
 "        curl http://name:passwd@machine.domain/full/path/to/file\n"
 "\n"
+);
+ puts(
 "   or specify user and password separately like in\n"
 "\n"
 "        curl -u name:passwd http://machine.domain/full/path/to/file\n"
 "\n"
 "   NOTE! Since HTTP URLs don't support user and password, you can't use that\n"
 "   style when using Curl via a proxy. You _must_ use the -u style fetch\n"
 "   during such circumstances.\n"
 "\n"
 " HTTPS\n"
 "\n"
-);
- puts(
 "   Probably most commonly used with private certificates, as explained below.\n"
 "\n"
 " GOPHER\n"
 "\n"
 "   Curl features no password support for gopher.\n"
 "\n"
 "PROXY\n"
 "\n"
+);
+ puts(
 " Get an ftp file using a proxy named my-proxy that uses port 888:\n"
 "\n"
 "        curl -x my-proxy:888 ftp://ftp.leachsite.com/README\n"
 "\n"
 " Get a file from a HTTP server that requires user and password, using the\n"
 " same proxy as above:\n"
 "\n"
 "        curl -u user:passwd -x my-proxy:888 http://www.get.this/\n"
 "\n"
-);
- puts(
 " Some proxies require special authentication. Specify by using -U as above:\n"
 "\n"
 "        curl -U user:passwd -x my-proxy:888 http://www.get.this/\n"
 "\n"
+);
+ puts(
 " See also the environment variables Curl support that offer further proxy\n"
 " control.\n"
 "\n"
 "RANGES\n"
 "\n"
 "  With HTTP 1.1 byte-ranges were introduced. Using this, a client can request\n"
@@ -1273,18 +1408,18 @@
 "  this with the -r flag.\n"
 "\n"
 "  Get the first 100 bytes of a document:\n"
 "\n"
 "        curl -r 0-99 http://www.get.this/\n"
 "\n"
-);
- puts(
 "  Get the last 500 bytes of a document:\n"
 "\n"
 "        curl -r -500 http://www.get.this/\n"
 "\n"
+);
+ puts(
 "  Curl also supports simple ranges for FTP files as well. Then you can only\n"
 "  specify start and stop position.\n"
 "\n"
 "  Get the first 100 bytes of a document using FTP:\n"
 "\n"
 "        curl -r 0-99 ftp://www.get.this/README  \n"
@@ -1292,76 +1427,76 @@
 "UPLOADING\n"
 "\n"
 " FTP\n"
 "\n"
 "  Upload all data on stdin to a specified ftp site:\n"
 "\n"
-"        curl -t ftp://ftp.upload.com/myfile\n"
+"        curl -T - ftp://ftp.upload.com/myfile\n"
 "\n"
 "  Upload data from a specified file, login with user and password:\n"
 "\n"
-);
- puts(
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/myfile\n"
 "\n"
+);
+ puts(
 "  Upload a local file to the remote site, and use the local file name remote\n"
 "  too:\n"
 " \n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/\n"
 "\n"
 "  Upload a local file to get appended to the remote file using ftp:\n"
 "\n"
 "        curl -T localfile -a ftp://ftp.upload.com/remotefile\n"
 "\n"
 "  Curl also supports ftp upload through a proxy, but only if the proxy is\n"
-);
- puts(
 "  configured to allow that kind of tunneling. If it does, you can run curl in\n"
 "  a fashion similar to:\n"
 "\n"
+);
+ puts(
 "        curl --proxytunnel -x proxy:port -T localfile ftp.upload.com\n"
 "\n"
 " HTTP\n"
 "\n"
 "  Upload all data on stdin to a specified http site:\n"
 "\n"
-"        curl -t http://www.upload.com/myfile\n"
+"        curl -T - http://www.upload.com/myfile\n"
 "\n"
 "  Note that the http server must've been configured to accept PUT before this\n"
 "  can be done successfully.\n"
 "\n"
 "  For other ways to do http data upload, see the POST section below.\n"
 "\n"
 "VERBOSE / DEBUG\n"
 "\n"
+"  If curl fails where it isn't supposed to, if the servers don't let you\n"
 );
  puts(
-"  If curl fails where it isn't supposed to, if the servers don't let you\n"
 "  in, if you can't understand the responses: use the -v flag to get VERBOSE\n"
 "  fetching. Curl will output lots of info and all data it sends and\n"
 "  receives in order to let the user see all client-server interaction.\n"
 "\n"
 "        curl -v ftp://ftp.upload.com/\n"
 "\n"
 "DETAILED INFORMATION\n"
 "\n"
 "  Different protocols provide different ways of getting detailed information\n"
+"  about specific files/documents. To get curl to show detailed information\n"
 );
  puts(
-"  about specific files/documents. To get curl to show detailed information\n"
 "  about a single file, you should use -I/--head option. It displays all\n"
 "  available info on a single file for HTTP and FTP. The HTTP information is a\n"
 "  lot more extensive.\n"
 "\n"
 "  For HTTP, you can get the header information (the same as -I would show)\n"
 "  shown before the data by using -i/--include. Curl understands the\n"
 "  -D/--dump-header option when getting files from both FTP and HTTP, and it\n"
-);
- puts(
 "  will then store the headers in the specified file.\n"
 "\n"
+);
+ puts(
 "  Store the HTTP headers in a separate file (headers.txt in the example):\n"
 "\n"
 "        curl --dump-header headers.txt curl.haxx.se\n"
 "\n"
 "  Note that headers stored in a separate file can be very useful at a later\n"
 "  time if you want curl to use cookies sent by the server. More about that in\n"
@@ -1369,45 +1504,45 @@
 "\n"
 "POST (HTTP)\n"
 "\n"
 "  It's easy to post data using curl. This is done using the -d <data>\n"
 "  option.  The post data must be urlencoded.\n"
 "\n"
-);
- puts(
 "  Post a simple \"name\" and \"phone\" guestbook.\n"
 "\n"
+);
+ puts(
 "        curl -d \"name=Rafael%20Sagula&phone=3320780\" \\\n"
 "                http://www.where.com/guest.cgi\n"
 "\n"
 "  How to post a form with curl, lesson #1:\n"
 "\n"
 "  Dig out all the <input> tags in the form that you want to fill in. (There's\n"
 "  a perl program called formfind.pl on the curl site that helps with this).\n"
 "\n"
 "  If there's a \"normal\" post, you use -d to post. -d takes a full \"post\n"
 "  string\", which is in the format\n"
 "\n"
-);
- puts(
 "        <variable1>=<data1>&<variable2>=<data2>&...\n"
 "\n"
+);
+ puts(
 "  The 'variable' names are the names set with \"name=\" in the <input> tags, and\n"
 "  the data is the contents you want to fill in for the inputs. The data *must*\n"
 "  be properly URL encoded. That means you replace space with + and that you\n"
 "  write weird letters with %XX where XX is the hexadecimal representation of\n"
 "  the letter's ASCII code.\n"
 "\n"
 "  Example:\n"
 "\n"
 "  (page located at http://www.formpost.com/getthis/\n"
 "\n"
-);
- puts(
 "        <form action=\"post.cgi\" method=\"post\">\n"
 "        <input name=user size=10>\n"
+);
+ puts(
 "        <input name=pass type=password size=10>\n"
 "        <input name=id type=hidden value=\"blablabla\">\n"
 "        <input name=ding value=\"submit\">\n"
 "        </form>\n"
 "\n"
 "  We want to enter user 'foobar' with password '12345'.\n"
@@ -1415,244 +1550,244 @@
 "  To post to this, you enter a curl command line like:\n"
 "\n"
 "        curl -d \"user=foobar&pass=12345&id=blablabla&dig=submit\"  (continues)\n"
 "          http://www.formpost.com/getthis/post.cgi\n"
 "\n"
 "\n"
+"  While -d uses the application/x-www-form-urlencoded mime-type, generally\n"
 );
  puts(
-"  While -d uses the application/x-www-form-urlencoded mime-type, generally\n"
 "  understood by CGI's and similar, curl also supports the more capable\n"
 "  multipart/form-data type. This latter type supports things like file upload.\n"
 "\n"
 "  -F accepts parameters like -F \"name=contents\". If you want the contents to\n"
 "  be read from a file, use <@filename> as contents. When specifying a file,\n"
 "  you can also specify the file content type by appending ';type=<mime type>'\n"
+"  to the file name. You can also post the contents of several files in one\n"
 );
  puts(
-"  to the file name. You can also post the contents of several files in one field.\n"
-"  For example, the field name 'coolfiles' is used to send three  files, with\n"
-"  different content types using the following syntax:\n"
+"  field.  For example, the field name 'coolfiles' is used to send three files,\n"
+"  with different content types using the following syntax:\n"
 "\n"
 "        curl -F \"coolfiles=@fil1.gif;type=image/gif,fil2.txt,fil3.html\" \\\n"
 "        http://www.post.com/postit.cgi\n"
 "\n"
 "  If the content-type is not specified, curl will try to guess from the file\n"
-"  extension  (it only knows a few), or use the previously specified type\n"
+"  extension (it only knows a few), or use the previously specified type (from\n"
+"  an earlier file if several files are specified in a list) or else it will\n"
 );
  puts(
-"  (from an earlier file if several files are specified in a list) or else it\n"
-"  will  using the default type 'text/plain'.\n"
+"  using the default type 'text/plain'.\n"
 "\n"
 "  Emulate a fill-in form with -F. Let's say you fill in three fields in a\n"
 "  form. One field is a file name which to post, one field is your name and one\n"
 "  field is a file description. We want to post the file we have written named\n"
 "  \"cooltext.txt\". To let curl do the posting of this data instead of your\n"
+"  favourite browser, you have to read the HTML source of the form page and\n"
+"  find the names of the input fields. In our example, the input field names\n"
 );
  puts(
-"  favourite browser, you have to read the HTML source of the form page and find\n"
-"  the names of the input fields. In our example, the input field names are\n"
-"  'file', 'yourname' and 'filedescription'.\n"
+"  are 'file', 'yourname' and 'filedescription'.\n"
 "\n"
 "        curl -F \"file=@cooltext.txt\" -F \"yourname=Daniel\" \\\n"
 "             -F \"filedescription=Cool text file with cool text inside\" \\\n"
 "             http://www.post.com/postit.cgi\n"
 "\n"
 "  To send two files in one post you can do it in two ways:\n"
 "\n"
-);
- puts(
 "  1. Send multiple files in a single \"field\" with a single field name:\n"
 " \n"
 "        curl -F \"pictures=@dog.gif,cat.gif\" \n"
 " \n"
 "  2. Send two fields with two field names: \n"
 "\n"
+);
+ puts(
 "        curl -F \"docpicture=@dog.gif\" -F \"catpicture=@cat.gif\" \n"
 "\n"
 "REFERRER\n"
 "\n"
 "  A HTTP request has the option to include information about which address\n"
 "  that referred to actual page.  Curl allows you to specify the\n"
 "  referrer to be used on the command line. It is especially useful to\n"
-);
- puts(
 "  fool or trick stupid servers or CGI scripts that rely on that information\n"
 "  being available or contain certain data.\n"
 "\n"
 "        curl -e www.coolsite.com http://www.showme.com/\n"
 "\n"
+);
+ puts(
 "  NOTE: The referer field is defined in the HTTP spec to be a full URL.\n"
 "\n"
 "USER AGENT\n"
 "\n"
 "  A HTTP request has the option to include information about the browser\n"
 "  that generated the request. Curl allows it to be specified on the command\n"
 "  line. It is especially useful to fool or trick stupid servers or CGI\n"
-);
- puts(
 "  scripts that only accept certain browsers.\n"
 "\n"
 "  Example:\n"
 "\n"
 "  curl -A 'Mozilla/3.0 (Win95; I)' http://www.nationsbank.com/\n"
 "\n"
 "  Other common strings:\n"
+);
+ puts(
 "    'Mozilla/3.0 (Win95; I)'     Netscape Version 3 for Windows 95\n"
 "    'Mozilla/3.04 (Win95; U)'    Netscape Version 3 for Windows 95\n"
 "    'Mozilla/2.02 (OS/2; U)'     Netscape Version 2 for OS/2\n"
 "    'Mozilla/4.04 [en] (X11; U; AIX 4.2; Nav)'           NS for AIX\n"
 "    'Mozilla/4.05 [en] (X11; U; Linux 2.0.32 i586)'      NS for Linux\n"
 "\n"
-);
- puts(
 "  Note that Internet Explorer tries hard to be compatible in every way:\n"
 "    'Mozilla/4.0 (compatible; MSIE 4.01; Windows 95)'    MSIE for W95\n"
 "\n"
+);
+ puts(
 "  Mozilla is not the only possible User-Agent name:\n"
 "    'Konqueror/1.0'             KDE File Manager desktop client\n"
 "    'Lynx/2.7.1 libwww-FM/2.14' Lynx command line browser\n"
 "\n"
 "COOKIES\n"
 "\n"
 "  Cookies are generally used by web servers to keep state information at the\n"
 "  client's side. The server sets cookies by sending a response line in the\n"
-);
- puts(
 "  headers that looks like 'Set-Cookie: <data>' where the data part then\n"
 "  typically contains a set of NAME=VALUE pairs (separated by semicolons ';'\n"
+);
+ puts(
 "  like \"NAME1=VALUE1; NAME2=VALUE2;\"). The server can also specify for what\n"
 "  path the \"cookie\" should be used for (by specifying \"path=value\"), when the\n"
 "  cookie should expire (\"expire=DATE\"), for what domain to use it\n"
 "  (\"domain=NAME\") and if it should be used on secure connections only\n"
 "  (\"secure\").\n"
 "\n"
-);
- puts(
 "  If you've received a page from a server that contains a header like:\n"
 "        Set-Cookie: sessionid=boo123; path=\"/foo\";\n"
 "\n"
+);
+ puts(
 "  it means the server wants that first pair passed on when we get anything in\n"
 "  a path beginning with \"/foo\".\n"
 "\n"
 "  Example, get a page that wants my name passed in a cookie:\n"
 "\n"
 "        curl -b \"name=Daniel\" www.sillypage.com\n"
 "\n"
 "  Curl also has the ability to use previously received cookies in following\n"
 "  sessions. If you get cookies from a server and store them in a file in a\n"
-);
- puts(
 "  manner similar to:\n"
 "\n"
 "        curl --dump-header headers www.example.com\n"
 "\n"
+);
+ puts(
 "  ... you can then in a second connect to that (or another) site, use the\n"
 "  cookies from the 'headers' file like:\n"
 "\n"
 "        curl -b headers www.example.com\n"
 "\n"
 "  Note that by specifying -b you enable the \"cookie awareness\" and with -L\n"
 "  you can make curl follow a location: (which often is used in combination\n"
 "  with cookies). So that if a site sends cookies and a location, you can\n"
-);
- puts(
 "  use a non-existing file to trigger the cookie awareness like:\n"
 "\n"
 "        curl -L -b empty.txt www.example.com\n"
 "\n"
+);
+ puts(
 "  The file to read cookies from must be formatted using plain HTTP headers OR\n"
 "  as netscape's cookie file. Curl will determine what kind it is based on the\n"
 "  file contents.  In the above command, curl will parse the header and store\n"
 "  the cookies received from www.example.com.  curl will send to the server the\n"
 "  stored cookies which match the request as it follows the location.  The\n"
-);
- puts(
 "  file \"empty.txt\" may be a non-existant file.\n"
 "  \n"
 "\n"
 "PROGRESS METER\n"
 "\n"
+);
+ puts(
 "  The progress meter exists to show a user that something actually is\n"
 "  happening. The different fields in the output have the following meaning:\n"
 "\n"
 "  % Total    % Received % Xferd  Average Speed          Time             Curr.\n"
 "                                 Dload  Upload Total    Current  Left    Speed\n"
 "  0  151M    0 38608    0     0   9406      0  4:41:43  0:00:04  4:41:39  9287\n"
 "\n"
 "  From left-to-right:\n"
+"   %             - percentage completed of the whole transfer\n"
 );
  puts(
-"   %             - percentage completed of the whole transfer\n"
 "   Total         - total size of the whole expected transfer\n"
 "   %             - percentage completed of the download\n"
 "   Received      - currently downloaded amount of bytes\n"
 "   %             - percentage completed of the upload\n"
 "   Xferd         - currently uploaded amount of bytes\n"
 "   Average Speed\n"
 "   Dload         - the average transfer speed of the download\n"
 "   Average Speed\n"
 "   Upload        - the average transfer speed of the upload\n"
+"   Time Total    - expected time to complete the operation\n"
 );
  puts(
-"   Time Total    - expected time to complete the operation\n"
 "   Time Current  - time passed since the invoke\n"
 "   Time Left     - expected time left to completetion\n"
 "   Curr.Speed    - the average transfer speed the last 5 seconds (the first\n"
 "                   5 seconds of a transfer is based on less time of course.)\n"
 "\n"
 "  The -# option will display a totally different progress bar that doesn't\n"
 "  need much explanation!\n"
 "\n"
 "SPEED LIMIT\n"
 "\n"
+"  Curl allows the user to set the transfer speed conditions that must be met\n"
 );
  puts(
-"  Curl allows the user to set the transfer speed conditions that must be met\n"
 "  to let the transfer keep going. By using the switch -y and -Y you\n"
 "  can make curl abort transfers if the transfer speed is below the specified\n"
 "  lowest limit for a specified time.\n"
 "\n"
 "  To have curl abort the download if the speed is slower than 3000 bytes per\n"
 "  second for 1 minute, run:\n"
 "\n"
 "        curl -y 3000 -Y 60 www.far-away-site.com\n"
 "\n"
 "  This can very well be used in combination with the overall time limit, so\n"
-);
- puts(
 "  that the above operatioin must be completed in whole within 30 minutes:\n"
 "\n"
+);
+ puts(
 "        curl -m 1800 -y 3000 -Y 60 www.far-away-site.com\n"
 "\n"
 "CONFIG FILE\n"
 "\n"
 "  Curl automatically tries to read the .curlrc file (or _curlrc file on win32\n"
 "  systems) from the user's home dir on startup.\n"
 "\n"
 "  The config file could be made up with normal command line switches, but you\n"
 "  can also specify the long options without the dashes to make it more\n"
 "  readable. You can separate the options and the parameter with spaces, or\n"
+"  with = or :. Comments can be used within the file. If the first letter on a\n"
 );
  puts(
-"  with = or :. Comments can be used within the file. If the first letter on a\n"
 "  line is a '#'-letter the rest of the line is treated as a comment.\n"
 "\n"
 "  If you want the parameter to contain spaces, you must inclose the entire\n"
 "  parameter within double quotes (\"). Within those quotes, you specify a\n"
 "  quote as \\\".\n"
 "\n"
 "  NOTE: You must specify options and their arguments on the same line.\n"
 "\n"
 "  Example, set default time out and proxy in a config file:\n"
 "\n"
 "        # We want a 30 minute timeout:\n"
 "        -m 1800\n"
+"        # ... and we use a proxy for all accesses:\n"
 );
  puts(
-"        # ... and we use a proxy for all accesses:\n"
 "        proxy = proxy.our.domain.com:8080\n"
 "\n"
 "  White spaces ARE significant at the end of lines, but all white spaces\n"
 "  leading up to the first characters of each line are ignored.\n"
 "\n"
 "  Prevent curl from reading the default file by using -q as the first command\n"
@@ -1660,15 +1795,15 @@
 "\n"
 "        curl -q www.thatsite.com\n"
 "\n"
 "  Force curl to get and display a local help page in case it is invoked\n"
 "  without URL by making a config file similar to:\n"
 "\n"
+"        # default url to get\n"
 );
  puts(
-"        # default url to get\n"
 "        url = \"http://help.with.curl.com/curlhelp.html\"\n"
 "\n"
 "  You can specify another config file to be read by using the -K/--config\n"
 "  flag. If you set config file name to \"-\" it'll read the config from stdin,\n"
 "  which can be handy if you want to hide options from being visible in process\n"
 "  tables etc:\n"
@@ -1841,21 +1976,21 @@
 );
  puts(
 " resume on http(s) downloads as well as ftp uploads and downloads.\n"
 "\n"
 " Continue downloading a document:\n"
 "\n"
-"        curl -c -o file ftp://ftp.server.com/path/file\n"
+"        curl -C - -o file ftp://ftp.server.com/path/file\n"
 "\n"
 " Continue uploading a document(*1):\n"
 "\n"
-"        curl -c -T file ftp://ftp.server.com/path/file\n"
+"        curl -C - -T file ftp://ftp.server.com/path/file\n"
 "\n"
 " Continue downloading a document from a web server(*2):\n"
 "\n"
-"        curl -c -o file http://www.server.com/\n"
+"        curl -C - -o file http://www.server.com/\n"
 "\n"
 " (*1) = This requires that the ftp server supports the non-standard command\n"
 "        SIZE. If it doesn't, curl will say so.\n"
 "\n"
 );
  puts(
@@ -1918,159 +2053,202 @@
 "  If you have installed the OpenLDAP library, curl can take advantage of it\n"
 "  and offer ldap:// support.\n"
 "\n"
 "  LDAP is a complex thing and writing an LDAP query is not an easy task. I do\n"
 );
  puts(
-"  advice you to dig up the syntax description for that elsewhere, RFC 1959 if\n"
-"  no other place is better.\n"
+"  advice you to dig up the syntax description for that elsewhere. Two places\n"
+"  that might suit you are:\n"
+"\n"
+"  Netscape's \"Netscape Directory SDK 3.0 for C Programmer's Guide Chapter 10:\n"
+"  Working with LDAP URLs\":\n"
+"  http://developer.netscape.com/docs/manuals/dirsdk/csdk30/url.htm\n"
+"\n"
+"  RFC 2255, \"The LDAP URL Format\" http://www.rfc-editor.org/rfc/rfc2255.txt\n"
 "\n"
 "  To show you an example, this is now I can get all people from my local LDAP\n"
 "  server that has a certain sub-domain in their email address:\n"
 "\n"
+);
+ puts(
 "        curl -B \"ldap://ldap.frontec.se/o=frontec??sub?mail=*sth.frontec.se\"\n"
 "\n"
 "  If I want the same info in HTML format, I can get it by not using the -B\n"
 "  (enforce ASCII) flag.\n"
 "\n"
 "ENVIRONMENT VARIABLES\n"
 "\n"
-);
- puts(
 "  Curl reads and understands the following environment variables:\n"
 "\n"
-"        HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, GOPHER_PROXY\n"
+"        http_proxy, HTTPS_PROXY, FTP_PROXY, GOPHER_PROXY\n"
 "\n"
 "  They should be set for protocol-specific proxies. General proxy should be\n"
 "  set with\n"
 "        \n"
 "        ALL_PROXY\n"
 "\n"
+);
+ puts(
 "  A comma-separated list of host names that shouldn't go through any proxy is\n"
 "  set in (only an asterisk, '*' matches all hosts)\n"
 "\n"
 "        NO_PROXY\n"
 "\n"
 "  If a tail substring of the domain-path for a host matches one of these\n"
-);
- puts(
 "  strings, transactions with that node will not be proxied.\n"
 "\n"
 "\n"
 "  The usage of the -x/--proxy flag overrides the environment variables.\n"
 "\n"
 "NETRC\n"
 "\n"
 "  Unix introduced the .netrc concept a long time ago. It is a way for a user\n"
+);
+ puts(
 "  to specify name and password for commonly visited ftp sites in a file so\n"
 "  that you don't have to type them in each time you visit those sites. You\n"
 "  realize this is a big security risk if someone else gets hold of your\n"
-);
- puts(
 "  passwords, so therefor most unix programs won't read this file unless it is\n"
 "  only readable by yourself (curl doesn't care though).\n"
 "\n"
-"  Curl supports .netrc files if told so (using the -n/--netrc option). This is\n"
-"  not restricted to only ftp, but curl can use it for all protocols where\n"
-"  authentication is used.\n"
+"  Curl supports .netrc files if told so (using the -n/--netrc and\n"
+"  --netrc-optional options). This is not restricted to only ftp,\n"
+);
+ puts(
+"  but curl can use it for all protocols where authentication is used.\n"
 "\n"
 "  A very simple .netrc file could look something like:\n"
 "\n"
 "        machine curl.haxx.se login iamdaniel password mysecret\n"
 "\n"
 "CUSTOM OUTPUT\n"
 "\n"
-);
- puts(
 "  To better allow script programmers to get to know about the progress of\n"
 "  curl, the -w/--write-out option was introduced. Using this, you can specify\n"
 "  what information from the previous transfer you want to extract.\n"
 "\n"
+);
+ puts(
 "  To display the amount of bytes downloaded together with some text and an\n"
 "  ending newline:\n"
 "\n"
 "        curl -w 'We downloaded %{size_download} bytes\\n' www.download.com\n"
 "\n"
 "KERBEROS4 FTP TRANSFER\n"
 "\n"
 "  Curl supports kerberos4 for FTP transfers. You need the kerberos package\n"
-);
- puts(
 "  installed and used at curl build time for it to be used.\n"
 "\n"
 "  First, get the krb-ticket the normal way, like with the kauth tool. Then use\n"
 "  curl in way similar to:\n"
 "\n"
+);
+ puts(
 "        curl --krb4 private ftp://krb4site.com -u username:fakepwd\n"
 "\n"
 "  There's no use for a password on the -u switch, but a blank one will make\n"
 "  curl ask for one and you already entered the real password to kauth.\n"
 "\n"
 "TELNET\n"
 "\n"
 "  The curl telnet support is basic and very easy to use. Curl passes all data\n"
-);
- puts(
 "  passed to it on stdin to the remote server. Connect to a remote telnet\n"
 "  server using a command line similar to:\n"
 "\n"
 "        curl telnet://remote.server.com\n"
 "\n"
+);
+ puts(
 "  And enter the data to pass to the server on stdin. The result will be sent\n"
 "  to stdout or to the file you specify with -o.\n"
 "\n"
 "  You might want the -N/--no-buffer option to switch off the buffered output\n"
 "  for slow connections or similar.\n"
 "\n"
-"  NOTE: the telnet protocol does not specify any way to login with a specified\n"
+"  Pass options to the telnet protocol negotiation, by using the -t option. To\n"
+"  tell the server we use a vt100 terminal, try something like:\n"
+"\n"
+"        curl -tTTYPE=vt100 telnet://remote.server.com\n"
+"\n"
+"  Other interesting options for it -t include:\n"
+"\n"
 );
  puts(
+"   - XDISPLOC=<X display> Sets the X display location.\n"
+"\n"
+"   - NEW_ENV=<var,val> Sets an environment variable.\n"
+"\n"
+"  NOTE: the telnet protocol does not specify any way to login with a specified\n"
 "  user and password so curl can't do that automatically. To do that, you need\n"
 "  to track when the login prompt is received and send the username and\n"
 "  password accordingly.\n"
 "\n"
 "PERSISTANT CONNECTIONS\n"
 "\n"
 "  Specifying multiple files on a single command line will make curl transfer\n"
+);
+ puts(
 "  all of them, one after the other in the specified order.\n"
 "\n"
 "  libcurl will attempt to use persistant connections for the transfers so that\n"
 "  the second transfer to the same host can use the same connection that was\n"
-);
- puts(
 "  already initiated and was left open in the previous transfer. This greatly\n"
 "  decreases connection time for all but the first transfer and it makes a far\n"
 "  better use of the network.\n"
 "\n"
 "  Note that curl cannot use persistant connections for transfers that are used\n"
+);
+ puts(
 "  in subsequence curl invokes. Try to stuff as many URLs as possible on the\n"
 "  same command line if they are using the same host, as that'll make the\n"
 "  transfers faster. If you use a http proxy for file transfers, practicly\n"
-);
- puts(
 "  all transfers will be persistant.\n"
 "\n"
 "  Persistant connections were introduced in curl 7.7.\n"
 "\n"
 "MAILING LISTS\n"
 "\n"
 "  For your convenience, we have several open mailing lists to discuss curl,\n"
-"  its development and things relevant to this.\n"
+"  its development and things relevant to this. Get all info at\n"
+);
+ puts(
+"  http://curl.haxx.se/mail/. The lists available are:\n"
+"\n"
+"  curl-users\n"
+"\n"
+"    Users of the command line tool. How to use it, what doesn't work, new\n"
+"    features, related tools, questions, news, installations, compilations,\n"
+"    running, porting etc.\n"
+"\n"
+"  curl-library\n"
 "\n"
-"  To subscribe to the main curl list, mail curl-request@contactor.se with\n"
-"  \"subscribe <fill in your email address>\" in the body.\n"
+"    Developers using or developing libcurl. Bugs, extensions, improvements.\n"
 "\n"
-"  To subscribe to the curl-library users/deverlopers list, follow the\n"
-"  instructions at http://curl.haxx.se/mail/\n"
+"  curl-announce\n"
+"\n"
+"    Low-traffic. Only announcements of new public versions.\n"
+"\n"
+"  curl-and-PHP\n"
 "\n"
 );
  puts(
-"  To subscribe to the curl-announce list, to only get information about new\n"
-"  releases, follow the instructions at http://curl.haxx.se/mail/\n"
+"    Using the curl functions in PHP. Everything curl with a PHP angle. Or PHP\n"
+"    with a curl angle.\n"
+"\n"
+"  curl-commits\n"
+"\n"
+"    Receives notifications on all CVS commits done to the curl source module.\n"
+"    This can become quite a large amount of mails during intense development,\n"
+"    be aware. This is for us who liks email...\n"
 "\n"
-"  To subscribe to the curl-and-PHP list in which curl using with PHP is\n"
-"  discussed, follow the instructions at http://curl.haxx.se/mail/\n"
+"  curl-www-commits\n"
+"\n"
+"    Receives notifications on all CVS commits done to the curl www module\n"
+"    (basicly the web site).  This can become quite a large amount of mails\n"
+);
+ puts(
+"    during intense changing, be aware. This is for us who liks email...\n"
 "\n"
 "  Please direct curl questions, feature requests and trouble reports to one of\n"
 "  these mailing lists instead of mailing any individual.\n"
  ) ;
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: macos
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/main.c	2001-09-17 21:48:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/main.c	2002-06-11 23:10:39.000000000 +0800
@@ -2,26 +2,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2001, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: main.c,v 1.95 2001/09/11 22:36:03 bagder Exp $
+ * $Id: main.c,v 1.134 2002/06/11 15:09:02 bagder Exp $
  *****************************************************************************/
 
 /* This is now designed to have its own local setup.h */
 #include "setup.h"
 
 #include <stdio.h>
@@ -36,12 +36,15 @@
 
 #define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "urlglob.h"
 #include "writeout.h"
+#ifdef USE_ENVIRONMENT
+#include "writeenv.h"
+#endif
 
 #define CURLseparator	"--_curl_--"
 
 #if defined(WIN32)&&!defined(__CYGWIN32__)
 #include <winsock.h>
 #endif
@@ -58,29 +61,31 @@
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
 #endif
 
 #ifdef HAVE_UTIME_H
- #include <utime.h>
+#include <utime.h>
 #else
- #ifdef HAVE_SYS_UTIME_H
- #include <sys/utime.h>
- #endif
+#ifdef HAVE_SYS_UTIME_H
+#include <sys/utime.h>
+#endif
 #endif
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 /* this is low-level hard-hacking memory leak tracking shit */
 #include "../lib/memdebug.h"
 #endif
 
 #define DEFAULT_MAXREDIRS  50L
 
 #ifndef __cplusplus        /* (rabe) */
+#ifndef typedef_bool
 typedef char bool;
+#endif
 #endif                     /* (rabe) */
 
 #define CURL_PROGRESS_STATS 0 /* default progress display */
 #define CURL_PROGRESS_BAR   1
 
 typedef enum {
@@ -109,12 +114,15 @@
 #define CONF_FOLLOWLOCATION (1<<23) /* use Location: Luke! */
 #define CONF_GETTEXT  (1<<24) /* use ASCII/text for transfer */
 #define CONF_HTTPPOST (1<<25) /* multipart/form-data HTTP POST */
 
 #define CONF_MUTE     (1<<28) /* force NOPROGRESS */
 
+#define CONF_NETRC_OPT (1<<29)  /* read user+password from either
+                                 * .netrc or URL*/
+
 #ifndef HAVE_STRDUP
 /* Ultrix doesn't have strdup(), so make a quick clone: */
 char *strdup(char *str)
 {
   int len;
   char *newstr;
@@ -186,12 +194,17 @@
 globalvalue int  CURL_LDAPNOFUNC;
 globalvalue int  CURL_ABORTCB;
 globalvalue int  CURL_BADPARAM;
 globalvalue int  CURL_BADORDER;
 globalvalue int  CURL_BADPWD;
 globalvalue int  CURL_MNYREDIR;
+globalvalue int  CURL_UNKTELNET;
+globalvalue int  CURL_UNKMSG;
+globalvalue int  CURL_BADSSLCERT;
+globalvalue int  CURL_SRVNOERR;
+globalvalue int  CURL_MAXMSG;
 long	vms_cond[] = {
 	VMS_STS(1,FAC_SYSTEM,MSG_NORMAL,SEV_SUCCESS),
 	CURL_UNSUPPROTO,		/* these are from curlmsg.msg file..... */
 	CURL_FAILINIT,
 	CURL_BADURLSYN,
 	CURL_BADURLUSER,
@@ -233,13 +246,18 @@
 	CURL_LDAPNOLIB,
 	CURL_LDAPNOFUNC,
 	CURL_ABORTCB,
 	CURL_BADPARAM,
 	CURL_BADORDER,
 	CURL_BADPWD,
-	CURL_MNYREDIR
+	CURL_MNYREDIR,
+	CURL_UNKTELNET,
+	CURL_UNKMSG,
+	CURL_BADSSLCERT,
+	CURL_SRVNOERR,
+	CURL_MAXMSG
 };
 #endif
 
 extern void hugehelp(void);
 
 /*
@@ -310,62 +328,80 @@
          curl_version());
   puts(" -c/--cookie-jar <file> Write all cookies to this file after operation (H)\n"
        " -C/--continue-at <offset> Specify absolute resume offset\n"
        " -d/--data <data>   HTTP POST data (H)\n"
        "    --data-ascii <data>   HTTP POST ASCII data (H)\n"
        "    --data-binary <data>  HTTP POST binary data (H)\n"
+       "    --disable-epsv  Prevents curl from using EPSV (F)\n"
        " -D/--dump-header <file> Write the headers to this file\n"
        "    --egd-file <file> EGD socket path for random data (SSL)\n"
+#ifdef USE_ENVIRONMENT
+       "    --environment   Write result codes to environment variables (RISC OS)\n"
+#endif
        " -e/--referer       Referer page (H)");
   puts(" -E/--cert <cert[:passwd]> Specifies your certificate file and password (HTTPS)\n"
+       "    --cert-type <type> Specifies certificate file type (DER/PEM/ENG) (HTTPS)\n"
+       "    --key <key>     Specifies private key file (HTTPS)\n"
+       "    --key-type <type> Specifies private key  file type (DER/PEM/ENG) (HTTPS)\n"
+       "    --pass  <pass>  Specifies passphrase for the private key (HTTPS)");
+  puts("    --engine <eng>  Specifies the crypto engine to use (HTTPS)\n"
        "    --cacert <file> CA certifciate to verify peer against (SSL)\n"
-       "    --ciphers <list> What SSL ciphers to use (SSL)\n"
-       "    --connect-timeout <seconds> Maximum time allowed for connection\n"
+       "    --capath <directory> CA directory (made using c_rehash) to verify\n"
+       "                    peer against (SSL, NOT Windows)\n"
+       "    --ciphers <list> What SSL ciphers to use (SSL)");
+  puts("    --connect-timeout <seconds> Maximum time allowed for connection\n"
        " -f/--fail          Fail silently (no output at all) on errors (H)\n"
        " -F/--form <name=content> Specify HTTP POST data (H)\n"
        " -g/--globoff       Disable URL sequences and ranges using {} and []\n"
        " -G/--get           Send the -d data with a HTTP GET (H)");
   puts(" -h/--help          This help text\n"
        " -H/--header <line> Custom header to pass to server. (H)\n"
        " -i/--include       Include the HTTP-header in the output (H)\n"
-       " -I/--head          Fetch document info only (HTTP HEAD/FTP SIZE)\n"
+       " -I/--head          Fetch document info only (HTTP HEAD/FTP SIZE)");
+  puts(" -j/--junk-session-cookies Ignore session cookies read from file (H)\n"
        "    --interface <interface> Specify the interface to be used\n"
        "    --krb4 <level>  Enable krb4 with specified security level (F)\n"
        " -K/--config        Specify which config file to read\n"
        " -l/--list-only     List only names of an FTP directory (F)");
   puts(" -L/--location      Follow Location: hints (H)\n"
        " -m/--max-time <seconds> Maximum time allowed for the transfer\n"
        " -M/--manual        Display huge help text\n"
-       " -n/--netrc         Read .netrc for user name and password\n"
+       " -n/--netrc         Must read .netrc for user name and password\n"
+       "    --netrc-optional  Use either .netrc or URL; overrides -n\n"
        " -N/--no-buffer     Disables the buffering of the output stream");
   puts(" -o/--output <file> Write output to <file> instead of stdout\n"
        " -O/--remote-name   Write output to a file named as the remote file\n"
        " -p/--proxytunnel   Perform non-HTTP services through a HTTP proxy\n"
        " -P/--ftpport <address> Use PORT with address instead of PASV when ftping (F)\n"
        " -q                 When used as the first parameter disables .curlrc\n"
        " -Q/--quote <cmd>   Send QUOTE command to FTP before file transfer (F)");
   puts(" -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server\n"
        " -R/--remote-time   Set the remote file's time on the local output\n"
        " -s/--silent        Silent mode. Don't output anything\n"
-       " -S/--show-error    Show error. With -s, make curl show errors when they occur\n"
-       "    --stderr <file> Where to redirect stderr. - means stdout.\n"
+       " -S/--show-error    Show error. With -s, make curl show errors when they occur");
+  puts("    --stderr <file> Where to redirect stderr. - means stdout.\n"
        " -t/--telnet-option <OPT=val> Set telnet option\n"
+       "    --trace <file>  Dump a network/debug trace to the given file\n"
+       "    --trace-ascii <file>  Like --trace but without the hex output\n"
        " -T/--upload-file <file> Transfer/upload <file> to remote site\n"
        "    --url <URL>     Another way to specify URL to work with");
   puts(" -u/--user <user[:password]> Specify user and password to use\n"
+       "                    Overrides -n and --netrc-optional\n"
        " -U/--proxy-user <user[:password]> Specify Proxy authentication\n"
        " -v/--verbose       Makes the operation more talkative\n"
-       " -V/--version       Outputs version number then quits\n"
-       " -w/--write-out [format] What to output after completion\n"
+       " -V/--version       Outputs version number then quits");
+  puts(" -w/--write-out [format] What to output after completion\n"
        " -x/--proxy <host[:port]>  Use proxy. (Default port is 1080)\n"
        "    --random-file <file> File to use for reading random data from (SSL)\n"
        " -X/--request <command> Specific request command to use");
   puts(" -y/--speed-time    Time needed to trig speed-limit abort. Defaults to 30\n"
        " -Y/--speed-limit   Stop transfer if below speed-limit for 'speed-time' secs\n"
        " -z/--time-cond <time> Includes a time condition to the server (H)\n"
        " -Z/--max-redirs <num> Set maximum number of redirections allowed (H)\n"
+       " -0/--http1.0       Force usage of HTTP 1.0 (H)\n"
+       " -1/--tlsv1         Force usage of TLSv1 (H)\n"
        " -2/--sslv2         Force usage of SSLv2 (H)\n"
        " -3/--sslv3         Force usage of SSLv3 (H)");
   puts(" -#/--progress-bar  Display transfer progress as a progress bar\n"
        "    --crlf          Convert LF to CRLF in upload. Useful for MVS (OS/390)");
 }
 
@@ -380,14 +416,16 @@
   char *random_file;
   char *egd_file;
   char *useragent;
   char *cookie;     /* single line with specified cookies */
   char *cookiejar;  /* write to this file */
   char *cookiefile; /* read from this file */
+  bool cookiesession; /* new session? */
   bool use_resume;
   bool resume_from_current;
+  bool disable_epsv;
   int resume_from;
   char *postfields;
   long postfieldsize;
   char *referer;
   long timeout;
   long connecttimeout;
@@ -413,44 +451,58 @@
 
   struct getout *url_get;  /* point to the node to fill in URL */
   struct getout *url_out;  /* point to the node to fill in outfile */
 
   char *cipher_list;
   char *cert;
+  char *cert_type;
   char *cacert;
-  char *cert_passwd;
+  char *capath;
+  char *key;
+  char *key_type;
+  char *key_passwd;
+  char *engine;
   bool crlf;
   char *customrequest;
   char *krb4level;
+  char *trace_dump; /* file to dump the network trace to, or NULL */
+  FILE *trace_stream;
+  bool trace_fopened;
+  bool trace_ascii;
+
+  long httpversion;
   bool progressmode;
   bool nobuffer;
   bool globoff;
   bool use_httpget;
 
   char *writeout; /* %-styled format string to output */
+  bool writeenv; /* write results to environment, if available */
 
   FILE *errors; /* if stderr redirect is requested */
+  bool errors_fopened;
 
   struct curl_slist *quote;
   struct curl_slist *postquote;
+  struct curl_slist *prequote;
 
   long ssl_version;
-  TimeCond timecond;
+  curl_TimeCond timecond;
   time_t condtime;
 
   struct curl_slist *headers;
 
-  struct HttpPost *httppost;
-  struct HttpPost *last_post;
+  struct curl_httppost *httppost;
+  struct curl_httppost *last_post;
 
   struct curl_slist *telnet_options;
         
   HttpReq httpreq;
 };
 
-static int parseconfig(char *filename,
+static int parseconfig(const char *filename,
 		       struct Configurable *config);
 static char *my_get_line(FILE *fp);
 
 static void GetStr(char **string,
 		   char *value)
 {
@@ -557,13 +609,325 @@
     /* move the last pointer */
     config->url_last = node;
   }
   return node;
 }
 
+/* Structure for storing the information needed to build a multiple files
+ * section
+*/
+struct multi_files {
+  struct curl_forms   form;
+  struct multi_files *next;
+};
+
+/* Add a new list entry possibly with a type_name
+ */
+static struct multi_files *
+AddMultiFiles (const char *file_name,
+               const char *type_name,
+               const char *show_filename,
+               struct multi_files **multi_start,
+               struct multi_files **multi_current)
+{
+  struct multi_files *multi;
+  struct multi_files *multi_type = NULL;
+  struct multi_files *multi_name = NULL;
+  multi = (struct multi_files *)malloc(sizeof(struct multi_files));
+  if (multi) {
+    memset(multi, 0, sizeof(struct multi_files));
+    multi->form.option = CURLFORM_FILE;
+    multi->form.value = file_name;
+  }
+  else
+    return NULL;
+
+  if (!*multi_start)
+    *multi_start = multi;
+
+  if (type_name) {
+    multi_type = (struct multi_files *)malloc(sizeof(struct multi_files));
+    if (multi_type) {
+      memset(multi_type, 0, sizeof(struct multi_files));
+      multi_type->form.option = CURLFORM_CONTENTTYPE;
+      multi_type->form.value = type_name;
+      multi->next = multi_type;
+
+      multi = multi_type;
+    }
+    else {
+      free (multi);
+      return NULL;
+    }
+  }
+  if (show_filename) {
+    multi_name = (struct multi_files *)malloc(sizeof(struct multi_files));
+    if (multi_name) {
+      memset(multi_name, 0, sizeof(struct multi_files));
+      multi_name->form.option = CURLFORM_FILENAME;
+      multi_name->form.value = show_filename;
+      multi->next = multi_name;
+
+      multi = multi_name;
+    }
+    else {
+      free (multi);
+      return NULL;
+    }
+  }
+
+  if (*multi_current)
+    (*multi_current)->next = multi;
+
+  *multi_current = multi;
+
+  return *multi_current;
+}
+
+/* Free the items of the list.
+ */
+static void FreeMultiInfo (struct multi_files *multi_start)
+{
+  struct multi_files *multi;
+  while (multi_start) {
+    multi = multi_start;
+    multi_start = multi_start->next;
+    free (multi);
+  }
+}
+
+/***************************************************************************
+ *
+ * formparse()
+ *	
+ * Reads a 'name=value' paramter and builds the appropriate linked list.
+ *
+ * Specify files to upload with 'name=@filename'. Supports specified
+ * given Content-Type of the files. Such as ';type=<content-type>'.
+ *
+ * You may specify more than one file for a single name (field). Specify
+ * multiple files by writing it like:
+ *
+ * 'name=@filename,filename2,filename3'
+ *
+ * If you want content-types specified for each too, write them like:
+ *
+ * 'name=@filename;type=image/gif,filename2,filename3'
+ *
+ * If you want custom headers added for a single part, write them in a separate
+ * file and do like this:
+ *
+ * 'name=foo;headers=@headerfile' or why not
+ * 'name=@filemame;headers=@headerfile'
+ *
+ * To upload a file, but to fake the file name that will be included in the
+ * formpost, do like this:
+ *
+ * 'name=@filename;filename=/dev/null'
+ *
+ * This function uses curl_formadd to fulfill it's job. Is heavily based on
+ * the old curl_formparse code.
+ *
+ ***************************************************************************/
+
+#define FORM_FILE_SEPARATOR ','
+#define FORM_TYPE_SEPARATOR ';'
+
+static int formparse(char *input,
+                     struct curl_httppost **httppost,
+                     struct curl_httppost **last_post)
+{
+  /* nextarg MUST be a string in the format 'name=contents' and we'll
+     build a linked list with the info */
+  char name[256];
+  char *contents;
+  char major[128];
+  char minor[128];
+  char *contp;
+  const char *type = NULL;
+  char *sep;
+  char *sep2;
+
+  /* Preallocate contents to the length of input to make sure we don't
+     overwrite anything. */
+  contents = malloc(strlen(input));
+  contents[0] = '\000';
+ 
+  if(1 <= sscanf(input, "%255[^=]=%[^\n]", name, contents)) {
+    /* the input was using the correct format */
+    contp = contents;
+
+    if('@' == contp[0]) {
+      struct multi_files *multi_start = NULL, *multi_current = NULL;
+      /* we use the @-letter to indicate file name(s) */
+      contp++;
+
+      multi_start = multi_current=NULL;
+
+      do {
+	/* since this was a file, it may have a content-type specifier
+	   at the end too, or a filename. Or both. */
+        char *ptr;
+        char *filename=NULL;
 
+	sep=strchr(contp, FORM_TYPE_SEPARATOR);
+	sep2=strchr(contp, FORM_FILE_SEPARATOR);
+
+	/* pick the closest */
+	if(sep2 && (sep2 < sep)) {
+	  sep = sep2;
+
+	  /* no type was specified! */
+	}
+
+        type = NULL;
+
+	if(sep) {
+
+	  /* if we got here on a comma, don't do much */
+	  if(FORM_FILE_SEPARATOR == *sep)
+	    ptr = NULL;
+	  else
+            ptr = sep+1;
+
+	  *sep=0; /* terminate file name at separator */
+
+	  while(ptr && (FORM_FILE_SEPARATOR!= *ptr)) {
+
+            /* pass all white spaces */
+            while(isspace((int)*ptr))
+              ptr++;
+
+            if(curl_strnequal("type=", ptr, 5)) {
+
+              /* set type pointer */
+              type = &ptr[5];
+	    
+              /* verify that this is a fine type specifier */
+              if(2 != sscanf(type, "%127[^/]/%127[^;,\n]",
+                             major, minor)) {
+                fprintf(stderr, "Illegally formatted content-type field!\n");
+                free(contents);
+                FreeMultiInfo (multi_start);
+                return 2; /* illegal content-type syntax! */
+              }
+              /* now point beyond the content-type specifier */
+              sep = (char *)type + strlen(major)+strlen(minor)+1;
+
+              *sep=0; /* zero terminate type string */
+
+              ptr=sep+1;
+            }
+            else if(curl_strnequal("filename=", ptr, 9)) {
+              filename = &ptr[9];
+              ptr=strchr(filename, FORM_TYPE_SEPARATOR);
+              if(!ptr) {
+                ptr=strchr(filename, FORM_FILE_SEPARATOR);
+              }
+              if(ptr) {
+                *ptr=0; /* zero terminate */
+                ptr++;
+              }
+            }
+            else
+              /* confusion, bail out of loop */
+              break;
+	  }
+          /* find the following comma */
+          if(ptr)
+            sep=strchr(ptr, FORM_FILE_SEPARATOR);
+          else
+            sep=NULL;
+	}
+	else {
+	  sep=strchr(contp, FORM_FILE_SEPARATOR);
+	}
+	if(sep) {
+	  /* the next file name starts here */
+	  *sep =0;
+	  sep++;
+	}
+        /* if type == NULL curl_formadd takes care of the problem */
+
+        if (!AddMultiFiles (contp, type, filename, &multi_start,
+                            &multi_current)) {
+          fprintf(stderr, "Error building form post!\n");
+          free(contents);
+          FreeMultiInfo (multi_start);
+          return 3;
+        }
+	contp = sep; /* move the contents pointer to after the separator */
+
+      } while(sep && *sep); /* loop if there's another file name */
+
+      /* now we add the multiple files section */
+      if (multi_start) {
+        struct curl_forms *forms = NULL;
+        struct multi_files *ptr = multi_start;
+        unsigned int i, count = 0;
+        while (ptr) {
+          ptr = ptr->next;
+          ++count;
+        }
+        forms =
+          (struct curl_forms *)malloc((count+1)*sizeof(struct curl_forms));
+        if (!forms)
+        {
+          fprintf(stderr, "Error building form post!\n");
+          free(contents);
+          FreeMultiInfo (multi_start);
+          return 4;
+        }
+        for (i = 0, ptr = multi_start; i < count; ++i, ptr = ptr->next)
+        {
+          forms[i].option = ptr->form.option;
+          forms[i].value = ptr->form.value;
+        }
+        forms[count].option = CURLFORM_END;
+        FreeMultiInfo (multi_start);
+        if (curl_formadd (httppost, last_post,
+                          CURLFORM_COPYNAME, name,
+                          CURLFORM_ARRAY, forms, CURLFORM_END) != 0) {
+          fprintf(stderr, "curl_formadd failed!\n");
+          free(forms);
+          free(contents);
+          return 5;
+        }
+        free(forms);
+      }
+    }
+    else {
+      if( contp[0]=='<' ) {
+        if (curl_formadd (httppost, last_post,
+                          CURLFORM_COPYNAME, name,
+                          CURLFORM_FILECONTENT, contp+1, CURLFORM_END) != 0) {
+          fprintf(stderr, "curl_formadd failed!\n");
+          free(contents);
+          return 6;
+        }
+      }
+      else {
+        if (curl_formadd (httppost, last_post,
+                          CURLFORM_COPYNAME, name,
+                          CURLFORM_COPYCONTENTS, contp, CURLFORM_END) != 0) {
+          fprintf(stderr, "curl_formadd failed!\n");
+          free(contents);
+          return 7;
+        }
+      }
+    }
+
+  }
+  else {
+    fprintf(stderr, "Illegally formatted input field!\n");
+    free(contents);
+    return 1;
+  }
+  free(contents);
+  return 0;
+}
 
 
 typedef enum {
   PARAM_OK,
   PARAM_OPTION_AMBIGUOUS,
   PARAM_OPTION_UNKNOWN,
@@ -599,18 +963,27 @@
      */
   struct LongShort aliases[]= {
     {"9", "crlf",        FALSE},
     {"8", "stderr",      TRUE},
     {"7", "interface",   TRUE},
     {"6", "krb4",        TRUE},
+    /* all these ones, starting with 5 as a short-option have *no* short
+       option to mention. */
     {"5", "url",         TRUE},
     {"5a", "random-file", TRUE},
     {"5b", "egd-file",   TRUE},
     {"5c", "connect-timeout", TRUE},
     {"5d", "ciphers",    TRUE},
-
+    {"5e", "disable-epsv", FALSE},
+#ifdef USE_ENVIRONMENT
+    {"5f", "environment", FALSE},
+#endif
+    {"5g", "trace",      TRUE},
+    {"5h", "trace-ascii", TRUE},
+    {"0", "http1.0",     FALSE},
+    {"1", "tlsv1",       FALSE},
     {"2", "sslv2",       FALSE},
     {"3", "sslv3",       FALSE},
     {"a", "append",      FALSE},
     {"A", "user-agent",  TRUE},
     {"b", "cookie",      TRUE},
     {"B", "ftp-ascii",   FALSE}, /* this long format is OBSOLETE now! */
@@ -621,26 +994,34 @@
     {"da", "data-ascii", TRUE},
     {"db", "data-binary", TRUE},
     {"D", "dump-header", TRUE},
     {"e", "referer",     TRUE},
     {"E", "cert",        TRUE},
     {"Ea", "cacert",     TRUE},
+    {"Eb","cert-type",   TRUE},
+    {"Ec","key",         TRUE},
+    {"Ed","key-type",    TRUE},
+    {"Ee","pass",        TRUE},
+    {"Ef","engine",      TRUE},
+    {"Eg","capath ",     TRUE},
     {"f", "fail",        FALSE},
     {"F", "form",        TRUE},
     {"g", "globoff",     FALSE},
     {"G", "get",         FALSE},
     {"h", "help",        FALSE},
     {"H", "header",      TRUE},
     {"i", "include",     FALSE},
     {"I", "head",        FALSE},
+    {"j", "junk-session-cookies", FALSE},
     {"K", "config",      TRUE},
     {"l", "list-only",   FALSE},
     {"L", "location",    FALSE},
     {"m", "max-time",    TRUE},
     {"M", "manual",      FALSE},
     {"n", "netrc",       FALSE},
+    {"no", "netrc-optional", FALSE},
     {"N", "no-buffer",   FALSE},
     {"o", "output",      TRUE},
     {"O", "remote-name", FALSE},
     {"p", "proxytunnel", FALSE},
     {"P", "ftpport",     TRUE},
     {"q", "disable",     FALSE},
@@ -741,14 +1122,16 @@
     switch(letter) {
     case '9': /* there is no short letter for this */
       /* LF -> CRLF conversinon? */
       config->crlf = TRUE;
       break;
     case '8': /* there is no short letter for this */
-      if(strcmp(nextarg, "-"))
+      if(strcmp(nextarg, "-")) {
         config->errors = fopen(nextarg, "wt");
+        config->errors_fopened = TRUE;
+      }
       else
         config->errors = stdout;
       break;
     case '7': /* there is no short letter for this */
       /* interface */
       GetStr(&config->iface, nextarg);
@@ -768,12 +1151,27 @@
       case 'c': /* connect-timeout */
         config->connecttimeout=atoi(nextarg);
         break;
       case 'd': /* ciphers */
         GetStr(&config->cipher_list, nextarg);
         break;
+      case 'e': /* --disable-epsv */
+        config->disable_epsv ^= TRUE;
+        break;
+#ifdef USE_ENVIRONMENT
+      case 'f':
+        config->writeenv ^= TRUE;
+        break;
+#endif
+      case 'g': /* --trace */
+        GetStr(&config->trace_dump, nextarg);
+        break;
+      case 'h': /* --trace-ascii */
+        GetStr(&config->trace_dump, nextarg);
+        config->trace_ascii = TRUE;
+        break;
       default: /* the URL! */
         {
           struct getout *url;
           if(config->url_get || (config->url_get=config->url_list)) {
             /* there's a node here, if it already is filled-in continue to find
                an "empty" node */
@@ -798,19 +1196,27 @@
         }
       }
       break;
     case '#': /* added 19990617 larsa */
       config->progressmode ^= CURL_PROGRESS_BAR;
       break;
+    case '0': 
+      /* HTTP version 1.0 */
+      config->httpversion = CURL_HTTP_VERSION_1_0;
+      break;
+    case '1':
+      /* TLS version 1 */
+      config->ssl_version = CURL_SSLVERSION_TLSv1;
+      break;
     case '2': 
       /* SSL version 2 */
-      config->ssl_version = 2;
+      config->ssl_version = CURL_SSLVERSION_SSLv2;
       break;
     case '3': 
-      /* SSL version 2 */
-      config->ssl_version = 3;
+      /* SSL version 3 */
+      config->ssl_version = CURL_SSLVERSION_SSLv3;
       break;
     case 'a':
       /* This makes the FTP sessions use APPE instead of STOR */
       config->conf ^= CONF_FTPAPPEND;
       break;
     case 'A':
@@ -861,13 +1267,13 @@
 
           nextarg++; /* pass the @ */
 
           if(strequal("-", nextarg))
             file = stdin;
           else 
-            file = fopen(nextarg, "r");
+            file = fopen(nextarg, "rb");
 
           if(subletter == 'b') /* forced binary */
             postdata = file2memory(file, &config->postfieldsize);
           else
             postdata = file2string(file);
           if(file && (file != stdin))
@@ -885,15 +1291,19 @@
           free(oldpost);
           free(postdata);
         }
         else
           config->postfields=postdata;
       }
-
-/*      if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq))
-        return PARAM_BAD_USE;*/
+      /*
+        We can't set the request type here, as this data might be used in
+        a simple GET if -G is used. Already or soon.
+
+        if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq))
+          return PARAM_BAD_USE;
+      */
       break;
     case 'D':
       /* dump-header to given file name */
       GetStr(&config->headerfile, nextarg);
       break;
     case 'e':
@@ -906,53 +1316,75 @@
           *ptr = 0; /* zero terminate here */
         }
         GetStr(&config->referer, nextarg);
       }
       break;
     case 'E':
-      if(subletter == 'a') {
+      switch(subletter) {
+      case 'a': /* CA info PEM file */
         /* CA info PEM file */
         GetStr(&config->cacert, nextarg);
-      }
-      else {
-	char *ptr = strchr(nextarg, ':');
-        /* Since we live in a world of weirdness and confusion, the win32
-           dudes can use : when using drive letters and thus
-           c:\file:password needs to work. In order not to break
-           compatibility, we still use : as separator, but we try to detect
-           when it is used for a file name! On windows. */
+        break;
+      case 'b': /* cert file type */
+        GetStr(&config->cert_type, nextarg);
+        break;
+      case 'c': /* private key file */
+        GetStr(&config->key, nextarg);
+        break;
+      case 'd': /* private key file type */
+        GetStr(&config->key_type, nextarg);
+        break;
+      case 'e': /* private key passphrase */
+        GetStr(&config->key_passwd, nextarg);
+        break;
+      case 'f': /* crypto engine */
+        GetStr(&config->engine, nextarg);
+        break;
+      case 'g': /* CA info PEM file */
+        /* CA cert directory */
+        GetStr(&config->capath, nextarg);
+        break;
+      default: /* certificate file */
+        {
+          char *ptr = strchr(nextarg, ':');
+          /* Since we live in a world of weirdness and confusion, the win32
+             dudes can use : when using drive letters and thus
+             c:\file:password needs to work. In order not to break
+             compatibility, we still use : as separator, but we try to detect
+             when it is used for a file name! On windows. */
 #ifdef WIN32
-        if(ptr &&
-           (ptr == &nextarg[1]) &&
-           (nextarg[2] == '\\') &&
-           (isalpha((int)nextarg[0])) )
-          /* colon in the second column, followed by a backslash, and the
-             first character is an alphabetic letter:
+          if(ptr &&
+             (ptr == &nextarg[1]) &&
+             (nextarg[2] == '\\') &&
+             (isalpha((int)nextarg[0])) )
+             /* colon in the second column, followed by a backslash, and the
+                first character is an alphabetic letter:
 
-             this is a drive letter colon */
-          ptr = strchr(&nextarg[3], ':'); /* find the next one instead */
+                this is a drive letter colon */
+            ptr = strchr(&nextarg[3], ':'); /* find the next one instead */
 #endif
-        if(ptr) {
-	  /* we have a password too */
-	  *ptr=0;
-	  ptr++;
-	  GetStr(&config->cert_passwd, ptr);
+          if(ptr) {
+            /* we have a password too */
+            *ptr=0;
+            ptr++;
+            GetStr(&config->key_passwd, ptr);
+          }
+          GetStr(&config->cert, nextarg);
 	}
-	GetStr(&config->cert, nextarg);
       }
       break;
     case 'f':
       /* fail hard on errors  */
       config->conf ^= CONF_FAILONERROR;
       break;
     case 'F':
       /* "form data" simulation, this is a little advanced so lets do our best
 	 to sort this out slowly and carefully */
-      if(curl_formparse(nextarg,
-                        &config->httppost,
-                        &config->last_post))
+      if(formparse(nextarg,
+                   &config->httppost,
+                   &config->last_post))
 	return PARAM_BAD_USE;
       if(SetHTTPrequest(HTTPREQ_POST, &config->httpreq))
         return PARAM_BAD_USE;
       break;
 
     case 'g': /* g disables URLglobbing */
@@ -970,17 +1402,33 @@
       /* A custom header to append to a list */
       config->headers = curl_slist_append(config->headers, nextarg);
       break;
     case 'i':
       config->conf ^= CONF_HEADER; /* include the HTTP header as well */
       break;
+    case 'j':
+      config->cookiesession ^= TRUE;
+      break;
     case 'I':
-      config->conf ^= CONF_HEADER; /* include the HTTP header in the output */
-      config->conf ^= CONF_NOBODY; /* don't fetch the body at all */
-      if(SetHTTPrequest(HTTPREQ_HEAD, &config->httpreq))
-        return PARAM_BAD_USE;
+      /*
+       * This is a bit tricky. We either SET both bits, or we clear both
+       * bits. Let's not make any other outcomes from this.
+       */
+      if((CONF_HEADER|CONF_NOBODY) !=
+         (config->conf&(CONF_HEADER|CONF_NOBODY)) ) {
+        /* one of them weren't set, set both */
+        config->conf |= (CONF_HEADER|CONF_NOBODY);
+        if(SetHTTPrequest(HTTPREQ_HEAD, &config->httpreq))
+          return PARAM_BAD_USE;
+      }
+      else {
+        /* both were set, clear both */
+        config->conf &= ~(CONF_HEADER|CONF_NOBODY);
+        if(SetHTTPrequest(HTTPREQ_GET, &config->httpreq))
+          return PARAM_BAD_USE;
+      }
       break;
     case 'K':
       res = parseconfig(nextarg, config);
       config->configread = TRUE;
       if(res)
 	return res;
@@ -996,15 +1444,23 @@
       config->timeout = atoi(nextarg);
       break;
     case 'M': /* M for manual, huge help */
       hugehelp();
       return PARAM_HELP_REQUESTED;
     case 'n':
-      /* pick info from .netrc, if this is used for http, curl will
-	 automatically enfore user+password with the request */
-      config->conf ^= CONF_NETRC;
+      switch(subletter) {
+      case 'o': /* CA info PEM file */
+        /* use .netrc or URL */
+        config->conf ^= CONF_NETRC_OPT;
+        break;
+      default:
+        /* pick info from .netrc, if this is used for http, curl will
+           automatically enfore user+password with the request */
+        config->conf ^= CONF_NETRC;
+        break;
+      }
       break;
     case 'N':
       /* disable the output I/O buffering */
       config->nobuffer ^= 1;
       break;
     case 'o':
@@ -1055,18 +1511,24 @@
 
     case 'q': /* if used first, already taken care of, we do it like
 		 this so we don't cause an error! */
       break;
     case 'Q':
       /* QUOTE command to send to FTP server */
-      if(nextarg[0] == '-') {
+      switch(nextarg[0]) {
+      case '-':
         /* prefixed with a dash makes it a POST TRANSFER one */
         nextarg++;
         config->postquote = curl_slist_append(config->postquote, nextarg);
-      }
-      else {
+        break;
+      case '+':
+        /* prefixed with a plus makes it a just-before-transfer one */
+        nextarg++;
+        config->prequote = curl_slist_append(config->prequote, nextarg);
+        break;
+      default:
         config->quote = curl_slist_append(config->quote, nextarg);
       }
       break;
     case 'r':
       /* byte range requested */
       GetStr(&config->range, nextarg);
@@ -1083,13 +1545,14 @@
     case 'S':
       /* show errors */
       config->showerror ^= TRUE; /* toggle on if used with -s */
       break;
     case 't':
       /* Telnet options */
-      config->telnet_options = curl_slist_append(config->telnet_options, nextarg);
+      config->telnet_options =
+        curl_slist_append(config->telnet_options, nextarg);
       break;
     case 'T':
       /* we are uploading */
       config->conf |= CONF_UPLOAD;
       if(!strequal("-", nextarg))
         /* make - equal stdin */
@@ -1129,16 +1592,14 @@
       break;
     case 'x':
       /* proxy */
       GetStr(&config->proxy, nextarg);
       break;
     case 'X':
-      /* HTTP request */
+      /* set custom request */
       GetStr(&config->customrequest, nextarg);
-      if(SetHTTPrequest(HTTPREQ_CUSTOM, &config->httpreq))
-        return PARAM_BAD_USE;
       break;
     case 'y':
       /* low speed time */
       config->low_speed_time = atoi(nextarg);
       if(!config->low_speed_limit)
 	config->low_speed_limit = 1;
@@ -1152,33 +1613,33 @@
     case 'z': /* time condition coming up */
       switch(*nextarg) {
       case '+':
         nextarg++;
       default:
         /* If-Modified-Since: (section 14.28 in RFC2068) */
-        config->timecond = TIMECOND_IFMODSINCE;
+        config->timecond = CURL_TIMECOND_IFMODSINCE;
         break;
       case '-':
         /* If-Unmodified-Since:  (section 14.24 in RFC2068) */
-        config->timecond = TIMECOND_IFUNMODSINCE;
+        config->timecond = CURL_TIMECOND_IFUNMODSINCE;
         nextarg++;
         break;
       case '=':
         /* Last-Modified:  (section 14.29 in RFC2068) */
-        config->timecond = TIMECOND_LASTMOD;
+        config->timecond = CURL_TIMECOND_LASTMOD;
         nextarg++;
         break;
       }
       now=time(NULL);
       config->condtime=curl_getdate(nextarg, &now);
       if(-1 == (int)config->condtime) {
         /* now let's see if it is a file name to get the time from instead! */
         struct stat statbuf;
         if(-1 == stat(nextarg, &statbuf)) {
           /* failed, remove time condition */
-          config->timecond = TIMECOND_NONE;
+          config->timecond = CURL_TIMECOND_NONE;
         }
         else {
           /* pull the time out from the file */
           config->condtime = statbuf.st_mtime;
         }
       }
@@ -1190,43 +1651,44 @@
 
     default: /* unknown flag */
       return PARAM_OPTION_UNKNOWN;
     }
     hit = -1;
 
-  } while(!singleopt && *++parse && !*usedarg);
+  } while(!longopt && !singleopt && *++parse && !*usedarg);
 
   return PARAM_OK;
 }
 
 
-static int parseconfig(char *filename,
+static int parseconfig(const char *filename,
 		       struct Configurable *config)
 {
   int res;
   FILE *file;
-  char filebuffer[256];
+  char filebuffer[512];
   bool usedarg;
-  char *home=NULL;
+  char *home;
   
   if(!filename || !*filename) {
     /* NULL or no file name attempts to load .curlrc from the homedir! */
 
 #define CURLRC DOT_CHAR "curlrc"
 
+    filename = CURLRC;          /* sensible default */
     home = curl_getenv("HOME"); /* portable environment reader */
-    if(!home)
-      return 0;
-    if(strlen(home)>(sizeof(filebuffer)-strlen(CURLRC))) {
-      free(home);
-      return 0;
-    }
+    if(home) {
+      if(strlen(home)<(sizeof(filebuffer)-strlen(CURLRC))) {
 
-    sprintf(filebuffer, "%s%s%s", home, DIR_CHAR, CURLRC);
+        snprintf(filebuffer, sizeof(filebuffer),
+                 "%s%s%s", home, DIR_CHAR, CURLRC);
 
-    filename = filebuffer;
+        filename = filebuffer;
+      }
+      free(home); /* we've used it, now free it */
+    }
   }
 
   if(strcmp(filename,"-"))
     file = fopen(filename, "r");
   else
     file = stdin;
@@ -1367,14 +1829,12 @@
 
       free(aline);
     }
     if(file != stdin)
       fclose(file);
   }
-  if(home)
-    free(home);
   return 0;
 }
 
 struct OutStruct {
   char *filename;
   FILE *stream;
@@ -1397,24 +1857,25 @@
     }
   }
   return fwrite(buffer, size, nmemb, out->stream);
 }
 
 struct ProgressData {
-  size_t total;
-  size_t prev;
-  size_t point;
+  int calls;
+  double total;
+  double prev;
+  double point;
   int width;
   FILE *out; /* where to write everything to */
 };
 
 int myprogress (void *clientp,
-                size_t dltotal,
-                size_t dlnow,
-                size_t ultotal,
-                size_t ulnow)
+                double dltotal,
+                double dlnow,
+                double ultotal,
+                double ulnow)
 {
   /* The original progress-bar source code was written for curl by Lars Aas,
      and this new edition inherites some of his concepts. */
   
   char line[256];
   char outline[256];
@@ -1427,12 +1888,14 @@
 
   struct ProgressData *bar = (struct ProgressData *)clientp;
   size_t total = dltotal + ultotal;
 
   bar->point = dlnow + ulnow; /* we've come this far */
 
+  bar->calls++; /* simply count invokes */
+
   if(0 == total) {
     int prevblock = bar->prev / 1024;
     int thisblock = bar->point / 1024;
     while ( thisblock > prevblock ) {
       fprintf( bar->out, "#" );
       prevblock++;
@@ -1493,12 +1956,107 @@
   bar->width = scr_size[0] - 1;
 #endif
 
   bar->out = config->errors;
 }
 
+static
+void dump(const char *text,
+          FILE *stream, unsigned char *ptr, size_t size,
+          bool nohex)
+{
+  size_t i;
+  size_t c;
+
+  unsigned int width=0x10;
+
+  if(nohex)
+    /* without the hex output, we can fit more on screen */
+    width = 0x40;
+
+  fprintf(stream, "%s, %d bytes (0x%x)\n", text, size, size);
+
+  for(i=0; i<size; i+= width) {
+
+    fprintf(stream, "%04x: ", i);
+
+    if(!nohex) {
+      /* hex not disabled, show it */
+      for(c = 0; c < width; c++)
+        if(i+c < size)
+          fprintf(stream, "%02x ", ptr[i+c]);
+        else
+          fputs("   ", stream);
+    }
+
+    for(c = 0; (c < width) && (i+c < size); c++) {
+      /* check for 0D0A; if found, skip past and start a new line of output */
+      if (nohex && (i+c+1 < size) && ptr[i+c]==0x0D && ptr[i+c+1]==0x0A) {
+        i+=(c+2-width);
+        break;
+      }
+      fprintf(stream, "%c",
+              (ptr[i+c]>=0x20) && (ptr[i+c]<0x80)?ptr[i+c]:'.');
+      /* check again for 0D0A, to avoid an extra \n if it's at width */
+      if (nohex && (i+c+2 < size) && ptr[i+c+1]==0x0D && ptr[i+c+2]==0x0A) {
+        i+=(c+3-width);
+        break;
+      }
+    }
+    fputc('\n', stream); /* newline */
+  }
+}
+
+static
+int my_trace(CURL *handle, curl_infotype type,
+             unsigned char *data, size_t size,
+             void *userp)
+{
+  struct Configurable *config = (struct Configurable *)userp;
+  FILE *output=config->errors;
+  const char *text;
+
+  (void)handle; /* prevent compiler warning */
+
+  if(!config->trace_stream) {
+    /* open for append */
+    if(strequal("-", config->trace_dump))
+      config->trace_stream = stdout;
+    else {
+      config->trace_stream = fopen(config->trace_dump, "w");
+      config->trace_fopened = TRUE;
+    }
+  }
+
+  if(config->trace_stream)
+    output = config->trace_stream;
+
+  switch (type) {
+  case CURLINFO_TEXT:
+    fprintf(output, "== Info: %s", data);
+  default: /* in case a new one is introduced to shock us */
+    return 0;
+
+  case CURLINFO_HEADER_OUT:
+    text = "=> Send header";
+    break;
+  case CURLINFO_DATA_OUT:
+    text = "=> Send data ";
+    break;
+  case CURLINFO_HEADER_IN:
+    text = "<= Recv header";
+    break;
+  case CURLINFO_DATA_IN:
+    text = "<= Recv data";
+    break;
+  }
+
+  dump(text, output, data, size, config->trace_ascii);
+  return 0;
+}
+
 void free_config_fields(struct Configurable *config)
 {
   if(config->random_file)
     free(config->random_file);
   if(config->egd_file)
     free(config->egd_file);
@@ -1529,12 +2087,16 @@
   if(config->writeout)
     free(config->writeout);
   if(config->httppost)
     curl_formfree(config->httppost);
   if(config->cacert)
     free(config->cacert);
+  if(config->capath)
+    free(config->capath);
+  if(config->cookiejar)
+    free(config->cookiejar);
 
   curl_slist_free_all(config->quote); /* checks for config->quote == NULL */
   curl_slist_free_all(config->postquote); /*  */
   curl_slist_free_all(config->headers); /*  */
 }
 
@@ -1566,20 +2128,27 @@
 
   bool allocuseragent=FALSE;
 
   char *httpgetfields=NULL;
 
   CURL *curl;
-  int res;
+  int res = 0;
   int i;
 
 #ifdef MALLOCDEBUG
   /* this sends all memory debug messages to a logfile named memdump */
-  curl_memdebug("memdump");
+  char *env;
+  env = curl_getenv("CURL_MEMDEBUG");
+  if(env) {
+    free(env);
+    curl_memdebug("memdump");
+  }
 #endif
 
+  errorbuffer[0]=0; /* prevent junk from being output */
+
   main_init(); /* inits */
 
   config->showerror=TRUE;
   config->conf=CONF_DEFAULT;
   config->use_httpget=FALSE;
 
@@ -1695,12 +2264,24 @@
   curl = curl_easy_init();
   if(!curl)
     return CURLE_FAILED_INIT;
 
   urlnode = config->url_list;
 
+  if(config->headerfile) {
+    /* open file for output: */
+    if(strcmp(config->headerfile,"-")) {
+      heads.filename = config->headerfile;
+      headerfilep=NULL;
+    }
+    else
+      headerfilep=stdout;
+    heads.stream = headerfilep;
+    heads.config = config;
+  }
+
   /* loop through the list of given URLs */
   while(urlnode) {
 
     /* get the full URL (it might be NULL) */
     url=urlnode->url;
 
@@ -1813,23 +2394,35 @@
         ptr = strrchr(ptr, '/');
         if(!ptr || !strlen(++ptr)) {
           /* The URL has no file name part, add the local file name. In order
              to be able to do so, we have to create a new URL in another
              buffer.*/
 
-          urlbuffer=(char *)malloc(strlen(url) + strlen(config->infile) + 3);
+          /* We only want the part of the local path that is on the right
+             side of the rightmost slash and backslash. */
+          char *filep = strrchr(config->infile, '/');
+          char *file2 = strrchr(filep?filep:config->infile, '\\');
+
+          if(file2)
+            filep = file2+1;
+          else if(filep)
+            filep++;
+          else
+            filep = config->infile;
+
+          urlbuffer=(char *)malloc(strlen(url) + strlen(filep) + 3);
           if(!urlbuffer) {
             helpf("out of memory\n");
             return CURLE_OUT_OF_MEMORY;
           }
           if(ptr)
             /* there is a trailing slash on the URL */
-            sprintf(urlbuffer, "%s%s", url, config->infile);
+            sprintf(urlbuffer, "%s%s", url, filep);
           else
             /* thers is no trailing slash on the URL */
-            sprintf(urlbuffer, "%s/%s", url, config->infile);
+            sprintf(urlbuffer, "%s/%s", url, filep);
           
           url = urlbuffer; /* use our new URL instead! */
         }
 /*VMS??-- Reading binary from files can be a problem... */
 /*VMS??   Only FIXED, VAR etc WITHOUT implied CC will work */
 /*VMS??   Others need a \n appended to a line */
@@ -1849,24 +2442,12 @@
       
       }
       if((config->conf&CONF_UPLOAD) &&
          config->resume_from_current) {
         config->resume_from = -1; /* -1 will then force get-it-yourself */
       }
-      if(config->headerfile) {
-        /* open file for output: */
-        if(strcmp(config->headerfile,"-")) {
-          heads.filename = config->headerfile;
-          headerfilep=NULL;
-        }
-        else
-          headerfilep=stdout;
-        heads.stream = headerfilep;
-        heads.config = config;
-      }
-    
       if(outs.stream && isatty(fileno(outs.stream)) &&
          !(config->conf&(CONF_UPLOAD|CONF_HTTPPOST)))
         /* we send the output to a tty and it isn't an upload operation,
            therefore we switch off the progress meter */
         config->conf |= CONF_NOPROGRESS;
     
@@ -1924,32 +2505,40 @@
         /* We get the output to stdout and we have not got the ASCII/text flag,
            then set stdout to be binary */
         setmode( 1, O_BINARY );
       }
 #endif
 
+      curl_easy_setopt(curl, CURLOPT_SSLENGINE, config->engine);
+      curl_easy_setopt(curl, CURLOPT_SSLENGINE_DEFAULT, 1);
 
       curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs); /* where to store */
       /* what call to write: */
       curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
       curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
       /* size of uploaded file: */
       curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
       curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
       curl_easy_setopt(curl, CURLOPT_PROXY, config->proxy); /* proxy to use */
-      curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
       curl_easy_setopt(curl, CURLOPT_HEADER, config->conf&CONF_HEADER);
       curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config->conf&CONF_NOPROGRESS);
       curl_easy_setopt(curl, CURLOPT_NOBODY, config->conf&CONF_NOBODY);
       curl_easy_setopt(curl, CURLOPT_FAILONERROR,
                        config->conf&CONF_FAILONERROR);
       curl_easy_setopt(curl, CURLOPT_UPLOAD, config->conf&CONF_UPLOAD);
       curl_easy_setopt(curl, CURLOPT_FTPLISTONLY,
                        config->conf&CONF_FTPLISTONLY);
       curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config->conf&CONF_FTPAPPEND);
-      curl_easy_setopt(curl, CURLOPT_NETRC, config->conf&CONF_NETRC);
+
+      if (config->conf&CONF_NETRC_OPT)
+        curl_easy_setopt(curl, CURLOPT_NETRC, CURL_NETRC_OPTIONAL);
+      else if (config->conf&CONF_NETRC)
+        curl_easy_setopt(curl, CURLOPT_NETRC, CURL_NETRC_REQUIRED);
+      else
+        curl_easy_setopt(curl, CURLOPT_NETRC, CURL_NETRC_IGNORED);
+
       curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
                        config->conf&CONF_FOLLOWLOCATION);
       curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config->conf&CONF_GETTEXT);
       curl_easy_setopt(curl, CURLOPT_MUTE, config->conf&CONF_MUTE);
       curl_easy_setopt(curl, CURLOPT_USERPWD, config->userpwd);
       curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);
@@ -1971,16 +2560,20 @@
       curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
                        config->use_resume?config->resume_from:0);
       curl_easy_setopt(curl, CURLOPT_COOKIE, config->cookie);
       curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config->headers);
       curl_easy_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
       curl_easy_setopt(curl, CURLOPT_SSLCERT, config->cert);
-      curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config->cert_passwd);
-
-      if(config->cacert) {
-        curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
+      curl_easy_setopt(curl, CURLOPT_SSLCERTTYPE, config->cert_type);
+      curl_easy_setopt(curl, CURLOPT_SSLKEY, config->key);
+      curl_easy_setopt(curl, CURLOPT_SSLKEYTYPE, config->key_type);
+      curl_easy_setopt(curl, CURLOPT_SSLKEYPASSWD, config->key_passwd);
+
+      if(config->cacert || config->capath) {
+        if (config->cacert) curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
+        if (config->capath) curl_easy_setopt(curl, CURLOPT_CAPATH, config->capath);
         curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE);
         curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 2);
       }
       else
         curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 1);
       
@@ -2000,12 +2593,15 @@
       curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config->postquote);
       curl_easy_setopt(curl, CURLOPT_WRITEHEADER,
                        config->headerfile?&heads:NULL);
       curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config->cookiefile);
       /* cookie jar was added in 7.9 */
       curl_easy_setopt(curl, CURLOPT_COOKIEJAR, config->cookiejar);
+      /* cookie session added in 7.9.7 */
+      curl_easy_setopt(curl, CURLOPT_COOKIESESSION, config->cookiesession);
+
       curl_easy_setopt(curl, CURLOPT_SSLVERSION, config->ssl_version);
       curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config->timecond);
       curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config->condtime);
       curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);
       curl_easy_setopt(curl, CURLOPT_STDERR, config->errors);
       
@@ -2028,36 +2624,57 @@
 
       /* new in libcurl 7.7: */
       curl_easy_setopt(curl, CURLOPT_RANDOM_FILE, config->random_file);
       curl_easy_setopt(curl, CURLOPT_EGDSOCKET, config->egd_file);
       curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, config->connecttimeout);
 
-      /* debug */
       if(config->cipher_list)
         curl_easy_setopt(curl, CURLOPT_SSL_CIPHER_LIST, config->cipher_list);
+
+      if(config->httpversion)
+        curl_easy_setopt(curl, CURLOPT_HTTP_VERSION, config->httpversion);
+
+      /* new in libcurl 7.9.2: */
+      if(config->disable_epsv)
+        /* disable it */
+        curl_easy_setopt(curl, CURLOPT_FTP_USE_EPSV, FALSE);
+
+      /* new in curl 7.9.7 */
+      if(config->trace_dump) {
+        curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, my_trace);
+        curl_easy_setopt(curl, CURLOPT_DEBUGDATA, config);
+        config->conf |= CONF_VERBOSE; /* force verbose */
+      }
+      curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
       
       res = curl_easy_perform(curl);
         
+      if((config->progressmode == CURL_PROGRESS_BAR) &&
+         progressbar.calls) {
+        /* if the custom progress bar has been displayed, we output a
+           newline here */
+        fputs("\n", progressbar.out);
+      }
+
       if(config->writeout) {
         ourWriteOut(curl, config->writeout);
       }
+#ifdef USE_ENVIRONMENT
+      if (config->writeenv)
+        ourWriteEnv(curl);
+#endif
 
 #ifdef	VMS
       if (!config->showerror)  {
         vms_show = VMSSTS_HIDE;
       }
 #else
       if((res!=CURLE_OK) && config->showerror)
         fprintf(config->errors, "curl: (%d) %s\n", res, errorbuffer);
 #endif
 
-      if(config->headerfile && !headerfilep && heads.stream)
-        fclose(heads.stream);
-
-      if(urlbuffer)
-        free(urlbuffer);
       if (outfile && !strequal(outfile, "-") && outs.stream)
         fclose(outs.stream);
 
 #ifdef HAVE_UTIME
       /* Important that we set the time _after_ the file has been 
          closed, as is done above here */
@@ -2105,21 +2722,25 @@
     nextnode=urlnode->next;
     free(urlnode); /* free the node */
     urlnode = nextnode;
 
   } /* while-loop through all URLs */
 
+  if(config->headerfile && !headerfilep && heads.stream)
+    fclose(heads.stream);
+
+  if(config->trace_fopened)
+    fclose(config->trace_stream);
+
   if(allocuseragent)
     free(config->useragent);
 
   /* cleanup the curl handle! */
   curl_easy_cleanup(curl);
 
-  if((config->errors != stderr) &&
-     (config->errors != stdout))
-    /* it wasn't directed to stdout or stderr so close the file! */
+  if(config->errors_fopened)
     fclose(config->errors);
 
   main_free(); /* cleanup */
 
   return res;
 }
@@ -2132,12 +2753,13 @@
   memset(&config, 0, sizeof(struct Configurable));
   
   res = operate(&config, argc, argv);
   free_config_fields(&config);
 
 #ifdef	VMS
+  if (res > 52) res = 53;		/* MAXMSG, porting helper */
   return (vms_cond[res]|vms_show);
 #else
   return res;
 #endif
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.am	2001-08-06 21:18:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.am	2002-04-09 06:40:38.000000000 +0800
@@ -1,38 +1,38 @@
 #
-# $Id: Makefile.am,v 1.13 2001/08/06 13:18:34 bagder Exp $
+# $Id: Makefile.am,v 1.22 2002/04/08 22:40:38 bagder Exp $
 #
 
-# Some flags needed when trying to cause warnings ;-)
-# CFLAGS = -g -DMALLOCDEBUG # -Wall -pedantic
-#CPPFLAGS = -DGLOBURL -DCURL_SEPARATORS
+AUTOMAKE_OPTIONS = foreign nostdinc
 
-INCLUDES = -I$(top_srcdir)/include
+# we use srcdir/include for the static global include files
+# we use builddir/src for the generated src/config.h file to get found
+# we use srcdir/lib for the client-private header files
+INCLUDES = -I$(top_srcdir)/include -I$(top_builddir)/src -I$(top_srcdir)/src
 
 bin_PROGRAMS = curl #memtest
 
-noinst_HEADERS = setup.h \
-	config-win32.h \
-	urlglob.h \
-	version.h \
-	writeout.h
-
 #memtest_SOURCES = memtest.c
 #memtest_LDADD = $(top_srcdir)/lib/libcurl.la
 
-curl_SOURCES = main.c hugehelp.c urlglob.c writeout.c
+curl_SOURCES = main.c hugehelp.c urlglob.c writeout.c setup.h \
+	config-win32.h config-mac.h config-vms.h config-riscos.h \
+	urlglob.h version.h writeout.h writeenv.c writeenv.h
+
 curl_LDADD = ../lib/libcurl.la
 curl_DEPENDENCIES = ../lib/libcurl.la
 BUILT_SOURCES = hugehelp.c
 CLEANFILES = hugehelp.c
 NROFF=@NROFF@
 
-EXTRA_DIST = mkhelp.pl config-win32.h curlmsg.msg\
-	Makefile.vc6 Makefile.b32 Makefile.m32 config.h.in
-
-AUTOMAKE_OPTIONS = foreign no-dependencies
+EXTRA_DIST = mkhelp.pl curlmsg.msg \
+	Makefile.vc6 Makefile.b32 Makefile.m32 Makefile.riscos config.h.in \
+	macos/curl.mcp.xml.sit.hqx \
+	macos/MACINSTALL.TXT \
+	macos/src/curl_GUSIConfig.cpp \
+	macos/src/macos_main.cpp
 
 MANPAGE=$(top_srcdir)/docs/curl.1
 README=$(top_srcdir)/docs/MANUAL
 MKHELP=$(top_srcdir)/src/mkhelp.pl
 
 # This generates the hugehelp.c file
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.in	2001-09-12 19:56:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.in	2002-06-11 23:21:37.000000000 +0800
@@ -11,19 +11,15 @@
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
 
 #
-# $Id: Makefile.am,v 1.13 2001/08/06 13:18:34 bagder Exp $
+# $Id: Makefile.am,v 1.22 2002/04/08 22:40:38 bagder Exp $
 #
 
-# Some flags needed when trying to cause warnings ;-)
-# CFLAGS = -g -DMALLOCDEBUG # -Wall -pedantic
-#CPPFLAGS = -DGLOBURL -DCURL_SEPARATORS
-
 SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 prefix = @prefix@
@@ -66,12 +62,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -94,72 +97,77 @@
 YACC = @YACC@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 NROFF = @NROFF@
 
-INCLUDES = -I$(top_srcdir)/include
-
-bin_PROGRAMS = curl #memtest
+AUTOMAKE_OPTIONS = foreign nostdinc
 
-noinst_HEADERS = setup.h \
-	config-win32.h \
-	urlglob.h \
-	version.h \
-	writeout.h
+# we use srcdir/include for the static global include files
+# we use builddir/src for the generated src/config.h file to get found
+# we use srcdir/lib for the client-private header files
+INCLUDES = -I$(top_srcdir)/include -I$(top_builddir)/src -I$(top_srcdir)/src
 
+bin_PROGRAMS = curl #memtest
 
 
 #memtest_SOURCES = memtest.c
 #memtest_LDADD = $(top_srcdir)/lib/libcurl.la
-curl_SOURCES = main.c hugehelp.c urlglob.c writeout.c
+curl_SOURCES = main.c hugehelp.c urlglob.c writeout.c setup.h \
+	config-win32.h config-mac.h config-vms.h config-riscos.h \
+	urlglob.h version.h writeout.h writeenv.c writeenv.h
+
+
 curl_LDADD = ../lib/libcurl.la
 curl_DEPENDENCIES = ../lib/libcurl.la
 BUILT_SOURCES = hugehelp.c
 CLEANFILES = hugehelp.c
 
-EXTRA_DIST = mkhelp.pl config-win32.h curlmsg.msg\
-	Makefile.vc6 Makefile.b32 Makefile.m32 config.h.in
+EXTRA_DIST = mkhelp.pl curlmsg.msg \
+	Makefile.vc6 Makefile.b32 Makefile.m32 Makefile.riscos config.h.in \
+	macos/curl.mcp.xml.sit.hqx \
+	macos/MACINSTALL.TXT \
+	macos/src/curl_GUSIConfig.cpp \
+	macos/src/macos_main.cpp
 
 
-AUTOMAKE_OPTIONS = foreign no-dependencies
-
 MANPAGE = $(top_srcdir)/docs/curl.1
 README = $(top_srcdir)/docs/MANUAL
 MKHELP = $(top_srcdir)/src/mkhelp.pl
 subdir = src
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 bin_PROGRAMS = curl$(EXEEXT)
 PROGRAMS = $(bin_PROGRAMS)
 
 am_curl_OBJECTS = main.$(OBJEXT) hugehelp.$(OBJEXT) urlglob.$(OBJEXT) \
-	writeout.$(OBJEXT)
+	writeout.$(OBJEXT) writeenv.$(OBJEXT)
 curl_OBJECTS = $(am_curl_OBJECTS)
 curl_LDFLAGS =
 
 DEFS = @DEFS@
-DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir) -I.
+DEFAULT_INCLUDES = 
 CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
-depcomp =
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+@AMDEP_TRUE@DEP_FILES = $(DEPDIR)/hugehelp.Po $(DEPDIR)/main.Po \
+@AMDEP_TRUE@	$(DEPDIR)/urlglob.Po $(DEPDIR)/writeenv.Po \
+@AMDEP_TRUE@	$(DEPDIR)/writeout.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) \
 	$(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
 	$(AM_LDFLAGS) $(LDFLAGS) -o $@
 CFLAGS = @CFLAGS@
 DIST_SOURCES = $(curl_SOURCES)
-HEADERS = $(noinst_HEADERS)
-
-DIST_COMMON = $(noinst_HEADERS) ./stamp-h2.in Makefile.am Makefile.in \
-	config.h.in
+DIST_COMMON = ./stamp-h2.in Makefile.am Makefile.in config.h.in
 SOURCES = $(curl_SOURCES)
 
 all: $(BUILT_SOURCES) config.h
 	$(MAKE) $(AM_MAKEFLAGS) all-am
 
 .SUFFIXES:
@@ -236,20 +244,39 @@
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT) core *.core
 
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/hugehelp.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/main.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/urlglob.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/writeenv.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@$(DEPDIR)/writeout.Po@am__quote@
+
+distclean-depend:
+	-rm -rf $(DEPDIR)
+
 .c.o:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 	$(COMPILE) -c `test -f $< || echo '$(srcdir)/'`$<
 
 .c.obj:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 	$(COMPILE) -c `cygpath -w $<`
 
 .c.lo:
+@AMDEP_TRUE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@	depfile='$(DEPDIR)/$*.Plo' tmpdepfile='$(DEPDIR)/$*.TPlo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
 	$(LTCOMPILE) -c -o $@ `test -f $< || echo '$(srcdir)/'`$<
+CCDEPMODE = @CCDEPMODE@
 uninstall-info-am:
 
 tags: TAGS
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(TAGS_FILES)'; \
@@ -284,12 +311,13 @@
 DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
 
 top_distdir = ..
 distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
 
 distdir: $(DISTFILES)
+	$(mkinstalldirs) $(distdir)/macos $(distdir)/macos/src
 	@for file in $(DISTFILES); do \
 	  if test -f $$file; then d=.; else d=$(srcdir); fi; \
 	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
 	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
 	    $(mkinstalldirs) "$(distdir)/$$dir"; \
 	  fi; \
@@ -301,13 +329,13 @@
 	    || cp -p $$d/$$file $(distdir)/$$file \
 	    || exit 1; \
 	  fi; \
 	done
 check-am: all-am
 check: check-am
-all-am: Makefile $(PROGRAMS) $(HEADERS) config.h
+all-am: Makefile $(PROGRAMS) config.h
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
 
 install: install-am
 install-exec: install-exec-am
@@ -337,14 +365,15 @@
 clean: clean-am
 
 clean-am: clean-binPROGRAMS clean-generic clean-libtool mostlyclean-am
 
 distclean: distclean-am
 
-distclean-am: clean-am distclean-compile distclean-generic distclean-hdr \
-	distclean-libtool distclean-tags
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-hdr distclean-libtool \
+	distclean-tags
 
 dvi: dvi-am
 
 dvi-am:
 
 info: info-am
@@ -371,21 +400,21 @@
 	mostlyclean-libtool
 
 uninstall-am: uninstall-binPROGRAMS uninstall-info-am
 
 .PHONY: GTAGS all all-am check check-am clean clean-binPROGRAMS \
 	clean-generic clean-libtool distclean distclean-compile \
-	distclean-generic distclean-hdr distclean-libtool \
-	distclean-tags distdir dvi dvi-am info info-am install \
-	install-am install-binPROGRAMS install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool tags uninstall uninstall-am \
-	uninstall-binPROGRAMS uninstall-info-am
+	distclean-depend distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags distdir dvi dvi-am info \
+	info-am install install-am install-binPROGRAMS install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool tags uninstall \
+	uninstall-am uninstall-binPROGRAMS uninstall-info-am
 
 
 # This generates the hugehelp.c file
 hugehelp.c: $(README) $(MANPAGE)  mkhelp.pl
 	rm -f hugehelp.c
 	$(NROFF) -man $(MANPAGE) | $(PERL) $(MKHELP)  $(README) > hugehelp.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.m32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.m32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.m32	2001-08-09 17:10:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.m32	2002-06-12 17:18:37.000000000 +0800
@@ -1,20 +1,20 @@
 #############################################################
-# $Id: Makefile.m32,v 1.5 2001/08/09 09:10:36 bagder Exp $
+# $Id: Makefile.m32,v 1.7 2002/06/12 09:18:37 bagder Exp $
 #
 ## Makefile for building curl.exe with MingW32 (GCC-2.95) and
 ## optionally OpenSSL (0.9.6)
 ##
 ## Use: make -f Makefile.m32 [SSL=1] [DYN=1]
 ##
 ## Comments to: Troy Engel <tengel@sonic.net> or
 ##              Joern Hartroth <hartroth@acm.org>
 
 CC = gcc
 STRIP = strip -s
-OPENSSL_PATH = ../../openssl-0.9.6
+OPENSSL_PATH = ../../openssl-0.9.6d
 
 # We may need these someday
 # PERL = perl
 # NROFF = nroff
 
 ########################################################
@@ -33,13 +33,13 @@
   curl_DEPENDENCIES = ../lib/libcurldll.a ../lib/libcurl.dll
   curl_LDADD = -L../lib -lcurldll
 else
   curl_DEPENDENCIES = ../lib/libcurl.a
   curl_LDADD = -L../lib -lcurl
 endif
-curl_LDADD += -lwsock32
+curl_LDADD += -lwsock32 -lws2_32 -lwinmm
 ifdef SSL
   curl_LDADD += -L$(OPENSSL_PATH)/out -leay32 -lssl32 -lRSAglue
 endif
 
 PROGRAMS = $(curl_PROGRAMS)
 SOURCES = $(curl_SOURCES)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: Makefile.riscos
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/Makefile.vc6	2001-09-17 22:38:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/Makefile.vc6	2002-03-23 23:39:18.000000000 +0800
@@ -1,13 +1,16 @@
 ########################################################
 ## Makefile for building curl.exe with MSVC6
-## Use: nmake -f makefile.vc6 [release | debug]
+## Use: nmake -f makefile.vc6 [release | debug] [CFG=release-ssl]
 ##      (default is release)
+## "nmake -f makefile.vc6 CFG=release-ssl" statically links OpenSSL
+## into curl.exe producing a standalone SSL-enabled executable.
 ##
 ## Comments to: Troy Engel <tengel@sonic.net>
 ## Updated by: Craig Davison <cd@securityfocus.com>
+## release-ssl added by Miklos Nemeth <mnemeth@kfkisystems.com>
 
 PROGRAM_NAME = curl.exe
 
 ########################################################
 ## Nothing more to do below this line!
 
@@ -39,12 +42,26 @@
 LINK_OBJS= \
 	hugehelp.obj \
 	writeout.obj \
 	urlglob.obj \
 	main.obj
 
+ 
+######################
+# release-ssl
+ 
+!IF "$(CFG)" == "release-ssl"
+!IFNDEF OPENSSL_PATH
+OPENSSL_PATH   = ../../openssl-0.9.6
+!ENDIF
+LFLAGSSSL = /LIBPATH:"$(OPENSSL_PATH)/out32"
+SSLLIBS   = libeay32.lib ssleay32.lib RSAglue.lib gdi32.lib 
+LINKLIBS  = $(LINKLIBS) $(SSLLIBS)
+LFLAGS = $(LFLAGS) $(LFLAGSSSL)
+!ENDIF
+ 
 all : release
 
 release: $(RELEASE_OBJS)
 	$(LINKR) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
 
 debug: $(DEBUG_OBJS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/setup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/setup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/setup.h	2001-09-17 22:10:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/setup.h	2002-04-09 06:44:33.000000000 +0800
@@ -1,46 +1,57 @@
-#ifndef __SETUP_H
-#define __SETUP_H
+#ifndef __CLIENT_SETUP_H
+#define __CLIENT_SETUP_H
 /*****************************************************************************
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: setup.h,v 1.7 2001/09/17 14:10:38 bagder Exp $
+ * $Id: setup.h,v 1.13 2002/04/08 22:44:33 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 
 #if !defined(WIN32) && defined(_WIN32)
 /* This _might_ be a good Borland fix. Please report whether this works or
    not! */
 #define WIN32
 #endif
 
 #ifdef HAVE_CONFIG_H
+#ifdef VMS
+#include "config-vms.h"
+#else
 #include "config.h" /* the configure script results */
+#endif
 #else
 #ifdef WIN32
 /* include the hand-modified win32 adjusted config.h! */
 #include "config-win32.h"
 #endif
+#ifdef macintosh
+/* this is not the same as Mac OS X */
+#include "config-mac.h"
+#endif
+#ifdef __riscos__
+#include "config-riscos.h"
+#endif
 #endif
 
 #ifndef OS
 #define OS "unknown"
 #endif
 
@@ -66,7 +77,11 @@
 #define DIR_CHAR      "/"
 #define DOT_CHAR      "."
 
 #endif
 #endif
 
+#ifdef __riscos__
+#define USE_ENVIRONMENT
+#endif
+
 #endif /* __SETUP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/stamp-h2.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/stamp-h2.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/stamp-h2.in	2001-09-12 19:56:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/stamp-h2.in	2002-06-13 05:13:48.000000000 +0800
@@ -1 +1,2 @@
 timestamp
+timestamp
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/urlglob.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/urlglob.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/urlglob.c	2001-08-14 17:17:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/urlglob.c	2002-03-19 15:54:55.000000000 +0800
@@ -2,28 +2,31 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urlglob.c,v 1.14 2001/08/14 09:17:21 bagder Exp $
+ * $Id: urlglob.c,v 1.17 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
+/* client-local setup.h */
+#include "setup.h"
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
 #include <curl/curl.h>
 #include "urlglob.h"
@@ -216,21 +219,25 @@
   char* buf = glob->glob_buffer;
   int litindex;
 
   *amount = 1; /* default is one single string */
 
   while (*pattern != '\0' && *pattern != '{' && *pattern != '[') {
-    if (*pattern == '}' || *pattern == ']') {
+    if (*pattern == '}' || *pattern == ']')
       return GLOB_ERROR;
-    }
-    if (*pattern == '\\') {		/* escape character, skip '\' */
+
+    /* only allow \ to escape known "special letters" */
+    if (*pattern == '\\' &&
+        (*(pattern+1) == '{' || *(pattern+1) == '[' ||
+         *(pattern+1) == '}' || *(pattern+1) == ']') ) {
+
+      /* escape character, skip '\' */
       ++pattern;
       ++pos;
-      if (*pattern == '\0') {		/* but no escaping of '\0'! */
+      if (*pattern == '\0')		/* but no escaping of '\0'! */
 	return GLOB_ERROR;
-      }
     }
     *buf++ = *pattern++;		/* copy character to literal */
     ++pos;
   }
   *buf = '\0';
   litindex = glob->size / 2;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/urlglob.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/urlglob.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/urlglob.h	2001-01-08 15:37:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/urlglob.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,26 +4,26 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urlglob.h,v 1.8 2001/01/08 07:37:44 bagder Exp $
+ * $Id: urlglob.h,v 1.9 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 typedef enum {UPTSet=1,UPTCharRange,UPTNumRange} URLPatternType;
 
 typedef struct {
   URLPatternType type;
   union {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/version.h	2001-09-25 14:15:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/version.h	2002-06-13 22:30:04.000000000 +0800
@@ -1,3 +1,3 @@
 #define CURL_NAME "curl"
-#define CURL_VERSION "7.9"
+#define CURL_VERSION "7.9.8"
 #define CURL_ID CURL_NAME " " CURL_VERSION " (" OS ") "
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: writeenv.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src: writeenv.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/writeout.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/writeout.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/writeout.c	2001-08-14 17:17:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/writeout.c	2002-05-17 15:57:13.000000000 +0800
@@ -2,31 +2,40 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: writeout.c,v 1.7 2001/08/14 09:17:21 bagder Exp $
+ * $Id: writeout.c,v 1.12 2002/05/17 07:57:13 bagder Exp $
  *****************************************************************************/
 
+#include "setup.h"
+
 #include <stdio.h>
 #include <string.h>
 
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_SYS_SELECT_H
+#include <sys/select.h>
+#endif
+
 #include <curl/curl.h>
 
 #define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "writeout.h"
@@ -34,20 +43,22 @@
 typedef enum {
   VAR_NONE,       /* must be the first */
   VAR_TOTAL_TIME,
   VAR_NAMELOOKUP_TIME,
   VAR_CONNECT_TIME,
   VAR_PRETRANSFER_TIME,
+  VAR_STARTTRANSFER_TIME,
   VAR_SIZE_DOWNLOAD,
   VAR_SIZE_UPLOAD,
   VAR_SPEED_DOWNLOAD,
   VAR_SPEED_UPLOAD,
   VAR_HTTP_CODE,
   VAR_HEADER_SIZE,
   VAR_REQUEST_SIZE,
   VAR_EFFECTIVE_URL,
+  VAR_CONTENT_TYPE,
   VAR_NUM_OF_VARS /* must be the last */
 } replaceid;
 
 struct variable {
   const char *name;
   replaceid id;
@@ -58,18 +69,20 @@
   {"url_effective", VAR_EFFECTIVE_URL},
   {"http_code", VAR_HTTP_CODE},
   {"time_total", VAR_TOTAL_TIME},
   {"time_namelookup", VAR_NAMELOOKUP_TIME},
   {"time_connect", VAR_CONNECT_TIME},
   {"time_pretransfer", VAR_PRETRANSFER_TIME},
+  {"time_starttransfer", VAR_STARTTRANSFER_TIME},
   {"size_header", VAR_HEADER_SIZE},
   {"size_request", VAR_REQUEST_SIZE},
   {"size_download", VAR_SIZE_DOWNLOAD},
   {"size_upload", VAR_SIZE_UPLOAD},
   {"speed_download", VAR_SPEED_DOWNLOAD},
   {"speed_upload", VAR_SPEED_UPLOAD},
+  {"content_type", VAR_CONTENT_TYPE},
   {NULL, 0}
 };
 
 void ourWriteOut(CURL *curl, char *writeinfo)
 {
   FILE *stream = stdout;
@@ -135,12 +148,17 @@
                 break;
               case VAR_PRETRANSFER_TIME:
                 if(CURLE_OK ==
                    curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &doubleinfo))
                   fprintf(stream, "%.3f", doubleinfo);
                 break;
+              case VAR_STARTTRANSFER_TIME:
+                if(CURLE_OK ==
+                   curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &doubleinfo))
+                  fprintf(stream, "%.3f", doubleinfo);
+                break;
               case VAR_SIZE_UPLOAD:
                 if(CURLE_OK ==
                    curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &doubleinfo))
                   fprintf(stream, "%.0f", doubleinfo);
                 break;
               case VAR_SIZE_DOWNLOAD:
@@ -155,12 +173,17 @@
                 break;
               case VAR_SPEED_UPLOAD:
                 if(CURLE_OK ==
                    curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))
                   fprintf(stream, "%.3f", doubleinfo);
                 break;
+              case VAR_CONTENT_TYPE:
+                if(CURLE_OK ==
+                   curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &stringp))
+                   fputs(stringp, stream);
+               break;
               default:
                 break;
               }
               break;
             }
           }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/writeout.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/writeout.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/src/writeout.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/src/writeout.h	2002-03-19 15:54:55.000000000 +0800
@@ -4,25 +4,25 @@
  *                                  _   _ ____  _     
  *  Project                     ___| | | |  _ \| |    
  *                             / __| | | | |_) | |    
  *                            | (__| |_| |  _ <| |___ 
  *                             \___|\___/|_| \_\_____|
  *
- * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ * Copyright (C) 1998 - 2002, Daniel Stenberg, <daniel@haxx.se>, et al.
  *
  * In order to be useful for every potential user, curl and libcurl are
  * dual-licensed under the MPL and the MIT/X-derivate licenses.
  *
  * You may opt to use, copy, modify, merge, publish, distribute and/or sell
  * copies of the Software, and permit persons to whom the Software is
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: writeout.h,v 1.2 2001/01/03 09:29:34 bagder Exp $
+ * $Id: writeout.h,v 1.3 2002/03/19 07:54:55 bagder Exp $
  *****************************************************************************/
 
 void ourWriteOut(CURL *curl, char *out);
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9: stamp-h1.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/Makefile.am	2001-09-18 23:26:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/Makefile.am	2002-06-11 20:25:25.000000000 +0800
@@ -2,14 +2,19 @@
 install:
 
 test:
 	[ -f test1 ] || ln -s $(srcdir)/test* .
 
 EXTRA_DIST = \
-test1    test106  test113  test120  test15   test201  test3    test44 \
-test10   test107  test114  test121  test16   test202  test300  test5 \
-test100  test108  test115  test122  test17   test21   test301  test6 \
-test101  test109  test116  test123  test18   test22   test302  test7 \
-test102  test11   test117  test124  test19   test23   test33   test8 \
-test103  test110  test118  test125  test2    test24   test4    test9 \
-test104  test111  test119  test13   test20   test25   test400  \
-test105  test112  test12   test14   test200  test26   test43   
\ No newline at end of file
+test1    test108  test117  test127  test20   test27   test34   test46 \
+test10   test109  test118  test13   test200  test28   test36   test47 \
+test100  test11   test119  test14   test201  test29   test37   test5 \
+test101  test110  test12   test15   test202  test3    test4    test6 \
+test102  test111  test120  test16   test21   test30   test400  test7 \
+test103  test112  test121  test17   test22   test300  test401  test8 \
+test104  test113  test122  test18   test23   test301  test402  test9 \
+test105  test114  test123  test19   test24   test302  test43   test31 \
+test106  test115  test124  test190  test25   test303  test44   test38 \
+test107  test116  test125  test2    test26   test33   test45   test126 \
+test304  test39   test32   test128  test48 \
+test130  test131  test132  test133  test134 test135
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/Makefile.in	2001-09-18 23:31:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/Makefile.in	2002-06-11 23:22:21.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -87,24 +94,30 @@
 YACC = @YACC@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
 EXTRA_DIST = \
-test1    test106  test113  test120  test15   test201  test3    test44 \
-test10   test107  test114  test121  test16   test202  test300  test5 \
-test100  test108  test115  test122  test17   test21   test301  test6 \
-test101  test109  test116  test123  test18   test22   test302  test7 \
-test102  test11   test117  test124  test19   test23   test33   test8 \
-test103  test110  test118  test125  test2    test24   test4    test9 \
-test104  test111  test119  test13   test20   test25   test400  \
-test105  test112  test12   test14   test200  test26   test43   
+test1    test108  test117  test127  test20   test27   test34   test46 \
+test10   test109  test118  test13   test200  test28   test36   test47 \
+test100  test11   test119  test14   test201  test29   test37   test5 \
+test101  test110  test12   test15   test202  test3    test4    test6 \
+test102  test111  test120  test16   test21   test30   test400  test7 \
+test103  test112  test121  test17   test22   test300  test401  test8 \
+test104  test113  test122  test18   test23   test301  test402  test9 \
+test105  test114  test123  test19   test24   test302  test43   test31 \
+test106  test115  test124  test190  test25   test303  test44   test38 \
+test107  test116  test125  test2    test26   test33   test45   test126 \
+test304  test39   test32   test128  test48 \
+test130  test131  test132  test133  test134 test135
 
 subdir = tests/data
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 DIST_COMMON = Makefile.am Makefile.in
 all: all-am
 
 .SUFFIXES:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test1	2001-05-23 22:11:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test1	2002-01-29 03:52:36.000000000 +0800
@@ -23,13 +23,13 @@
  <name>
 simple HTTP GET
  </name>
  <command>
 http://%HOSTIP:%HOSTPORT/1
 </command>
-</test>
+</client>
 
 #
 # Verify data after the test has been "shot"
 <verify>
 <strip>
 ^User-Agent:.*
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test100 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test100
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test100	2001-05-23 22:19:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test100	2001-11-28 21:25:22.000000000 +0800
@@ -34,11 +34,11 @@
 filter off really nothing
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
-PASV
+EPSV
 TYPE A
 LIST
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test102 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test102
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test102	2001-06-12 14:24:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test102	2001-11-28 21:25:23.000000000 +0800
@@ -16,18 +16,24 @@
 FTP RETR PASV
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/102
 </command>
 </test>
+<file name="log/ftpserver.cmd">
+REPLY EPSV 500 no such command
+</file>
+
 
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
+SIZE 102
 RETR 102
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test103 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test103
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test103	2001-06-28 06:05:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test103	2001-11-28 21:26:28.000000000 +0800
@@ -31,9 +31,10 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
 CWD a/path
 PORT 127,0,0,1,246,33
 TYPE I
+SIZE 103
 RETR 103
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test105 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test105
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test105	2001-06-12 16:53:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test105	2001-11-28 21:27:54.000000000 +0800
@@ -15,19 +15,25 @@
  <name>
 FTP user+password in URL and ASCII transfer
  </name>
  <command>
 ftp://userdude:passfellow@%HOSTIP:%FTPPORT/103 --use-ascii
 </command>
+<file name="log/ftpserver.cmd">
+REPLY EPSV 500 no such command
+REPLY SIZE 500 no such command
+</file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
 USER userdude
 PASS passfellow
 PWD
+EPSV
 PASV
 TYPE A
+SIZE 103
 RETR 103
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test106 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test106
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test106	2001-06-12 16:54:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test106	2001-11-28 21:28:26.000000000 +0800
@@ -24,11 +24,12 @@
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
 CWD /path with  spaces/and things2
-PASV
+EPSV
 TYPE A
+SIZE 106
 RETR 106
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test107 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test107
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test107	2001-06-12 17:00:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test107	2001-11-28 21:31:59.000000000 +0800
@@ -28,11 +28,11 @@
   so does it?
 </upload>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
-PASV
+EPSV
 TYPE I
 STOR 107
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test109 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test109
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test109	2001-09-13 19:40:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test109	2001-11-28 21:32:48.000000000 +0800
@@ -23,13 +23,13 @@
 <strip>
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
-PASV
+EPSV
 TYPE I
 APPE 109
 </protocol>
 <upload>
 Moooooooooooo
  upload this
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test110 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test110
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test110	2001-09-13 20:35:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test110	2001-11-28 21:33:45.000000000 +0800
@@ -14,22 +14,26 @@
  <name>
 FTP download resume with set limit
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/110 -C 20
 </command>
+<file name="log/ftpserver.cmd">
+REPLY EPSV 500 no such command
+</file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <strip>
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
 SIZE 110
 REST 20
 RETR 110
 </protocol>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test111 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test111
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test111	2001-09-13 20:47:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test111	2001-11-28 21:34:04.000000000 +0800
@@ -23,11 +23,11 @@
 <strip>
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
-PASV
+EPSV
 TYPE I
 SIZE 111
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test112 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test112
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test112	2001-09-14 17:39:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test112	2001-11-28 21:34:37.000000000 +0800
@@ -22,13 +22,13 @@
 <strip>
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
-PASV
+EPSV
 TYPE I
 APPE 112
 </protocol>
 <upload>
  gonna upload
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test115 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test115
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test115	2001-09-14 17:46:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test115	2001-11-28 21:35:08.000000000 +0800
@@ -9,21 +9,23 @@
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/115
 </command>
 <file name="log/ftpserver.cmd">
 REPLY PASV 314 bluah you f00l!
+REPLY EPSV 314 bluah you f00l!
 </file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <errorcode>
 13
 </errorcode>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test117 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test117
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test117	2001-09-14 17:50:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test117	2001-11-28 21:35:43.000000000 +0800
@@ -8,12 +8,13 @@
 FTP download, failed TYPE
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/117
 </command>
 <file name="log/ftpserver.cmd">
+REPLY EPSV 314 bluah you f00l!
 REPLY TYPE 314 bluah you f00l!
 </file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
@@ -21,10 +22,11 @@
 17
 </errorcode>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test118 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test118
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test118	2001-09-14 17:51:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test118	2001-11-28 21:36:33.000000000 +0800
@@ -9,23 +9,26 @@
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/118
 </command>
 <file name="log/ftpserver.cmd">
 REPLY RETR 314 bluah you f00l!
+REPLY EPSV 314 bluah you f00l!
 </file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <errorcode>
 19
 </errorcode>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
+SIZE 118
 RETR 118
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test119 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test119
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test119	2001-09-24 14:16:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test119	2001-11-28 21:37:06.000000000 +0800
@@ -27,9 +27,10 @@
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
 TYPE I
+SIZE 119
 RETR 119
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test120 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test120
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test120	2001-09-14 17:54:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test120	2001-11-28 21:37:50.000000000 +0800
@@ -15,20 +15,25 @@
  <name>
 ftp download with post-quote delete operation
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/120 -Q "-DELE file"
 </command>
+<file name="log/ftpserver.cmd">
+REPLY EPSV 314 bluah you f00l!
+</file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
+SIZE 120
 RETR 120
 DELE file
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test121 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test121
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test121	2001-09-14 17:55:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test121	2001-11-28 21:38:18.000000000 +0800
@@ -24,12 +24,13 @@
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
 DELE before_transfer
-PASV
+EPSV
 TYPE I
+SIZE 121
 RETR 121
 DELE after_transfer
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test122 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test122
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test122	2001-09-14 17:57:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test122	2001-11-28 21:39:10.000000000 +0800
@@ -10,19 +10,23 @@
  <name>
 FTP download resume with whole file already downloaded
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/122 -C 5
 </command>
+<file name="log/ftpserver.cmd">
+REPLY EPSV 500 no such command
+</file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
 SIZE 122
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test123 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test123
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test123	2001-09-14 19:54:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test123	2001-11-28 21:39:34.000000000 +0800
@@ -18,10 +18,10 @@
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
-PASV
+EPSV
 TYPE I
 </protocol>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test124 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test124
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test124	2001-09-14 20:00:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test124	2001-11-28 21:40:24.000000000 +0800
@@ -12,20 +12,23 @@
  </name>
  <command>
 ftp://%HOSTIP:%FTPPORT/124
 </command>
 <file name="log/ftpserver.cmd">
 REPLY PWD 314 bluah you f00l!
+REPLY EPSV 314 bluah you f00l!
 </file>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE I
+SIZE 124
 RETR 124
 </protocol>
 </verify>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test126
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test127
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test128
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test130
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test131
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test132
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test133
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test134
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test135
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test190
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test21 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test21
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test21	2001-08-07 20:11:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test21	2002-04-05 16:46:57.000000000 +0800
@@ -7,13 +7,13 @@
 # Client-side
 <client>
  <name>
 use curl with multiple request methods
  </name>
  <command>
--I -X FOOO localhost
+-I -d FOOO -F moo=moo localhost
 </command>
 </test>
 
 # Verify data after the test has been "shot"
 <verify>
 <errorcode>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test27
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test28
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test29
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test3	2001-05-23 22:23:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test3	2002-02-23 23:45:53.000000000 +0800
@@ -25,18 +25,18 @@
 #
 # Verify data after the test has been "shot"
 <verify>
 <strip>
 ^User-Agent:.*
 </strip>
-<protocol>
+<protocol nonewline=yes>
 POST /3 HTTP/1.1
 Authorization: Basic ZmFrZTotdXNlcg==
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Content-Length: 37
 Content-Type: application/x-www-form-urlencoded
 
-fooo=mooo&pooo=clue&doo=%20%20%20++++
+fooo=mooo&pooo=clue&doo=%20%20%20++++
 </protocol>
 </verify>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test30
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test302 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test302
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test302	2001-09-18 23:12:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test302	2002-04-10 22:04:26.000000000 +0800
@@ -15,13 +15,13 @@
 </test>
 
 #
 # Verify data after the test has been "shot"
 <verify>
 <errorcode>
-26
+56
 </errorcode>
 <strip>
 ^User-Agent:.*
 </strip>
 <protocol>
 </protocol>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test303
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test304
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test31
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test32
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test34
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test36
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test37
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test38
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test39
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test400 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test400
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/data/test400	2001-05-23 22:46:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data/test400	2001-11-28 21:44:48.000000000 +0800
@@ -22,23 +22,27 @@
  <name>
 FTPS dir list PASV
  </name>
  <command>
 ftps://%HOSTIP:%FTPSPORT/
 </command>
+<file name="log/ftpserver.cmd">
+REPLY EPSV 500 no such command
+</file>
 </test>
 
 #
 # Verify data after the test has been "shot"
 <verify>
 <strip>
 filter off really nothing
 </strip>
 <protocol>
 USER anonymous
 PASS curl_by_daniel@haxx.se
 PWD
+EPSV
 PASV
 TYPE A
 LIST
 </protocol>
 </verify>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test401
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test402
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test45
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test46
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test47
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/data: test48
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/FILEFORMAT /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/FILEFORMAT
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/FILEFORMAT	2001-09-14 17:49:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/FILEFORMAT	2002-06-11 20:03:11.000000000 +0800
@@ -11,30 +11,46 @@
 
  Each main section has a number of available subsections that can be
 specified, that will be checked/used if specified. This document includes all
 the subsections currently supported.
 
 <reply>
-<data>
-data to sent to the client on its request
+<data [nocheck=1]>
+data to sent to the client on its request and later verified that it arrived
+safely. Set the nocheck=1 to prevent the test script to verify the arrival
+of this data.
 </data>
-<datacheck>
-if the data is sent but this is what should be checked afterwards
+<datacheck [nonewline=yes]>
+if the data is sent but this is what should be checked afterwards. If
+'nonewline' is set, we will cut off the trailing newline of this given data
+before comparing with the one actually received by the client
 </datacheck>
 <size>
 number to return on a ftp SIZE command
 </size>
+<cmd>
+special purpose server-command to control its behavior *before* the
+reply is sent
+</cmd>
+<postcmd>
+special purpose server-command to control its behavior *after* the
+reply is sent
+</postcmd>
 </reply>
 
 <client>
 <name>
 test case description
 </name>
-<command>
+<command [option=no-output]>
 command line to run, there's a bunch of %variables that get replaced
 accordingly. more about them elsewhere
+
+Set 'option=no-output' to prevent the test script to slap on the --output
+argument that directs the output to a file. The --output is also not added if
+the client/stdout section is used.
 </command>
 <file name="log/filename">
 this creates the named file with this content before the test case is run
 which is useful if the test case needs a file to act on.
 </file>
 </client>
@@ -45,13 +61,21 @@
 </errorcode>
 <strip>
 One regex per line that is removed from the protocol dumps before the
 comparison is made. This is very useful to remove dependencies on dynamicly
 changing protocol data such as port numbers or user-agent strings.
 </strip>
-<protocol>
-the protocol dump curl should transmit
+<protocol [nonewline=yes]>
+the protocol dump curl should transmit, if 'nonewline' is set, we will cut
+off the trailing newline of this given data before comparing with the one
+actually sent by the client
 </protocol>
+<stdout>
+This verfies that this data was passed to stdout.
+</stdout>
+<file name="log/filename">
+the file's contents must be identical to this
+</file>
 <upload>
 the contents of the upload data curl should have sent
 </upload>
 </verify>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/ftpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/ftpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/ftpserver.pl	2001-09-14 20:01:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/ftpserver.pl	2002-04-04 20:23:54.000000000 +0800
@@ -1,9 +1,9 @@
 #!/usr/bin/perl
 #
-# $Id: ftpserver.pl,v 1.22 2001/09/14 12:01:21 bagder Exp $
+# $Id: ftpserver.pl,v 1.26 2002/04/04 12:23:54 bagder Exp $
 # This is the FTP server designed for the curl test suite.
 #
 # It is meant to exercise curl, it is not meant to be a fully working
 # or even very standard compliant server.
 #
 # You may optionally specify port on the command line, otherwise it'll
@@ -23,12 +23,13 @@
 
 sub logmsg { print FTPLOG "$$: "; print FTPLOG @_; }
 
 sub ftpmsg { print INPUT @_; }
 
 my $verbose=0; # set to 1 for debugging
+my $retrweirdo=0;
 
 my $port = 8921; # just a default
 do {
     if($ARGV[0] eq "-v") {
         $verbose=1;
     }
@@ -62,12 +63,13 @@
 
 # USER is ok in fresh state
 my %commandok = (
                  'USER' => 'fresh',
                  'PASS' => 'passwd',
                  'PASV' => 'loggedin|twosock',
+                 'EPSV' => 'loggedin|twosock',
                  'PORT' => 'loggedin|twosock',
                  'TYPE' => 'loggedin|twosock',
                  'LIST' => 'twosock',
                  'NLST' => 'twosock',
                  'RETR' => 'twosock',
                  'STOR' => 'twosock',
@@ -83,12 +85,13 @@
 
 # initially, we're in 'fresh' state
 my %statechange = ( 'USER' => 'passwd',    # USER goes to passwd state
                     'PASS' => 'loggedin',  # PASS goes to loggedin state
                     'PORT' => 'twosock',   # PORT goes to twosock
                     'PASV' => 'twosock',   # PASV goes to twosock
+                    'EPSV' => 'twosock',   # EPSV goes to twosock
                     );
 
 # this text is shown before the function specified below is run
 my %displaytext = ('USER' => '331 We are happy you popped in!',
                    'PASS' => '230 Welcome you silly person',
                    'PORT' => '200 You said PORT - I say FINE',
@@ -105,12 +108,13 @@
 
 # callback functions for certain commands
 my %commandfunc = ( 'PORT' => \&PORT_command,
                     'LIST' => \&LIST_command,
                     'NLST' => \&NLST_command,
                     'PASV' => \&PASV_command,
+                    'EPSV' => \&PASV_command,
                     'RETR' => \&RETR_command,   
                     'SIZE' => \&SIZE_command,
                     'REST' => \&REST_command,
                     'STOR' => \&STOR_command,
                     'APPE' => \&STOR_command, # append looks like upload
                     );
@@ -171,14 +175,25 @@
 
     if($size) {
         print "213 $size\r\n";
         logmsg "SIZE $testno returned $size\n";
     }
     else {
-        print "550 $testno: No such file or directory.\r\n";
-        logmsg "SIZE $testno: no such file\n";
+        $size=0;
+        @data = getpart("reply", "data");
+        for(@data) {
+            $size += length($_);
+        }
+        if($size) {
+            print "213 $size\r\n";
+            logmsg "SIZE $testno returned $size\n";
+        }
+        else {
+            print "550 $testno: No such file or directory.\r\n";
+            logmsg "SIZE $testno: no such file\n";
+        }
     }
     return 0;
 }
 
 sub RETR_command {
     my $testno = $_[0];
@@ -209,37 +224,51 @@
         if($rest) {
             # move read pointer forward
             $size -= $rest;
             logmsg "REST $rest was removed from size, makes $size left\n";
             $rest = 0; # reset REST offset again
         }
-        print "150 Binary data connection for $testno () ($size bytes).\r\n";
-        logmsg "150 Binary data connection for $testno ($size bytes).\n";
-
-        for(@data) {
-            my $send = $_;
-            print SOCK $send;
+        if($retrweirdo) {
+            print "150 Binary data connection for $testno () ($size bytes).\r\n",
+            "226 File transfer complete\r\n";
+            logmsg "150+226 in one shot!\n";
+
+            for(@data) {
+                my $send = $_;
+                print SOCK $send;
+            }
+            close(SOCK);
+            $retrweirdo=0; # switch off the weirdo again!
         }
-        close(SOCK);
+        else {
+            print "150 Binary data connection for $testno () ($size bytes).\r\n";
+            logmsg "150 Binary data connection for $testno ($size bytes).\n";
 
-        print "226 File transfer complete\r\n";
+            for(@data) {
+                my $send = $_;
+                print SOCK $send;
+            }
+            close(SOCK);
+
+            print "226 File transfer complete\r\n";
+        }
     }
     else {
         print "550 $testno: No such file or directory.\r\n";
         logmsg "550 $testno: no such file\n";
     }
     return 0;
 }
 
 sub STOR_command {
     my $testno=$_[0];
 
-    logmsg "STOR test number $testno\n";
-
     my $filename = "log/upload.$testno";
 
+    logmsg "STOR test number $testno in $filename\n";
+
     print "125 Gimme gimme gimme!\r\n";
 
     open(FILE, ">$filename") ||
         return 0; # failed to open output
 
     my $line;
@@ -256,12 +285,14 @@
     print "226 File transfer complete\r\n";
     return 0;
 }
 
 my $pasvport=9000;
 sub PASV_command {
+    my ($arg, $cmd)=@_;
+
     socket(Server2, PF_INET, SOCK_STREAM, $proto) || die "socket: $!";
     setsockopt(Server2, SOL_SOCKET, SO_REUSEADDR,
                pack("l", 1)) || die "setsockopt: $!";
 
     my $ok=0;
 
@@ -280,14 +311,23 @@
         print "500 no free ports!\r\n";
         logmsg "couldn't find free port\n";
         return 0;
     }
     listen(Server2,SOMAXCONN) || die "listen: $!";
 
-    printf("227 Entering Passive Mode (127,0,0,1,%d,%d)\n",
-           ($pasvport/256), ($pasvport%256));
+    if($cmd ne "EPSV") {
+        # PASV reply
+        logmsg "replying to a $cmd command\n";
+        printf("227 Entering Passive Mode (127,0,0,1,%d,%d)\n",
+               ($pasvport/256), ($pasvport%256));
+    }
+    else {
+        # EPSV reply
+        logmsg "replying to a $cmd command\n";
+        printf("229 Entering Passive Mode (|||%d|)\n", $pasvport);
+    }
 
     my $paddr = accept(SOCK, Server2);
     my($iport,$iaddr) = sockaddr_in($paddr);
     my $name = gethostbyaddr($iaddr,AF_INET);
 
     close(Server2); # close the listener when its served its purpose!
@@ -323,23 +364,31 @@
     return \&SOCK;
 }
 
 $SIG{CHLD} = \&REAPER;
 
 my %customreply;
+my %delayreply;
 sub customize {
     undef %customreply;
     open(CUSTOM, "<log/ftpserver.cmd") ||
         return 1;
 
     logmsg "FTPD: Getting commands from log/ftpserver.cmd\n";
 
     while(<CUSTOM>) {
         if($_ =~ /REPLY ([A-Z]+) (.*)/) {
             $customreply{$1}=$2;
         }
+        elsif($_ =~ /DELAY ([A-Z]+) (\d*)/) {
+            $delayreply{$1}=$2;
+        }
+        elsif($_ =~ /RETRWEIRDO/) {
+            print "instructed to use RETRWEIRDO\n";
+            $retrweirdo=1;
+        }
     }
     close(CUSTOM);
 }
 
 my @welcome=(
             '220-        _   _ ____  _     '."\r\n",
@@ -413,29 +462,38 @@
             # remain in the same state
         }
         else {
             $state = $newstate;
         }
 
+        my $delay = $delayreply{$FTPCMD};
+        if($delay) {
+            # just go sleep this many seconds!
+            sleep($delay);
+        }
+
         my $text;
         $text = $customreply{$FTPCMD};
         my $fake = $text;
         if($text eq "") {
             $text = $displaytext{$FTPCMD};
         }
+        else {
+            logmsg "$FTPCMD made to send '$text'\n";
+        }
         if($text) {
             print "$text\r\n";
         }
 
         if($fake eq "") {
             # only perform this if we're not faking a reply
             # see if the new state is a function caller.
             my $func = $commandfunc{$FTPCMD};
             if($func) {
                 # it is!
-                \&$func($FTPARG);
+                \&$func($FTPARG, $FTPCMD);
             }
         }
 
         logmsg "set to state $state\n";
             
     } # while(1)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/getpart.pm /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/getpart.pm
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/getpart.pm	2001-05-28 20:11:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/getpart.pm	2002-05-22 06:23:20.000000000 +0800
@@ -1,25 +1,33 @@
 
-use strict;
+#use strict;
 
 my @xml;
 
+my $warning=0;
+my $trace=0;
+
 sub getpartattr {
+    # if $part is undefined (ie only one argument) then
+    # return the attributes of the section
+
     my ($section, $part)=@_;
 
     my %hash;
     my $inside=0;
 
  #   print "Section: $section, part: $part\n";
 
     for(@xml) {
  #       print "$inside: $_";
         if(!$inside && ($_ =~ /^ *\<$section/)) {
             $inside++;
         }
-        elsif((1 ==$inside) && ($_ =~ /^ *\<$part([^>]*)/)) {
+        if((1 ==$inside) && ( ($_ =~ /^ *\<$part([^>]*)/) ||
+                              !(defined($part)) )
+             ) {
             $inside++;
             my $attr=$1;
             my @p=split("[ \t]", $attr);
             my $assign;
 
             foreach $assign (@p) {
@@ -60,18 +68,27 @@
             $inside++;
         }
         elsif((2 ==$inside) && ($_ =~ /^ *\<\/$part/)) {
             $inside--;
         }
         elsif((1==$inside) && ($_ =~ /^ *\<\/$section/)) {
+            if($trace) {
+                print STDERR "*** getpart.pm: $section/$part returned data!\n";
+            }
+            if(!@this && $warning) {
+                print STDERR "*** getpart.pm: $section/$part returned empty!\n";
+            }
             return @this;
         }
         elsif(2==$inside) {
             push @this, $_;
         }
     }
+    if($warning) {
+        print STDERR "*** getpart.pm: $section/$part returned empty!\n";
+    }
     return @this; #empty!
 }
 
 sub loadtest {
     my ($file)=@_;
 
@@ -116,25 +133,30 @@
      return -1;
  }
 
  for(1 .. $sizefirst) {
      my $index = $_ - 1;
      if($firstref->[$index] ne $secondref->[$index]) {
-         return 1+$index;
+         (my $aa = $firstref->[$index]) =~ s/\r+\n$/\n/;
+         (my $bb = $secondref->[$index]) =~ s/\r+\n$/\n/;
+         if($aa ne $bb) {
+             return 1+$index;
+         }
      }
  }
  return 0;
 }
 
 #
 # Write a given array to the specified file
 #
 sub writearray {
     my ($filename, $arrayref)=@_;
 
     open(TEMP, ">$filename");
+    binmode(TEMP,":raw"); # cygwin fix by Kevin Roth
     for(@$arrayref) {
         print TEMP $_;
     }
     close(TEMP);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/httpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/httpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/httpserver.pl	2001-09-18 22:34:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/httpserver.pl	2002-02-19 09:05:14.000000000 +0800
@@ -1,201 +1,17 @@
-#!/usr/bin/perl
-use Socket;
-use Carp;
-use FileHandle;
+#!/usr/bin/env perl
 
 use strict;
 
-require "getpart.pm";
-
-sub spawn;  # forward declaration
-sub logmsg { #print "$0 $$: @_ at ", scalar localtime, "\n"
- }
-
 my $verbose=0; # set to 1 for debugging
 
 my $port = 8999; # just a default
 do {
     if($ARGV[0] eq "-v") {
         $verbose=1;
     }
     elsif($ARGV[0] =~ /^(\d+)$/) {
         $port = $1;
     }
 } while(shift @ARGV);
 
-my $proto = getprotobyname('tcp') || 6;
-
-socket(Server, PF_INET, SOCK_STREAM, $proto)|| die "socket: $!";
-setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
-           pack("l", 1)) || die "setsockopt: $!";
-bind(Server, sockaddr_in($port, INADDR_ANY))|| die "bind: $!";
-listen(Server,SOMAXCONN) || die "listen: $!";
-
-if($verbose) {
-    print "HTTP server started on port $port\n";
-}
-
-open(PID, ">.http.pid");
-print PID $$;
-close(PID);
-
-my $waitedpid = 0;
-my $paddr;
-
-sub REAPER {
-    $waitedpid = wait;
-    $SIG{CHLD} = \&REAPER;  # loathe sysV
-    logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
-}
-
-$SIG{CHLD} = \&REAPER;
-
-for ( $waitedpid = 0;
-      ($paddr = accept(Client,Server)) || $waitedpid;
-        $waitedpid = 0, close Client)
-{
-    next if $waitedpid and not $paddr;
-    my($port,$iaddr) = sockaddr_in($paddr);
-    my $name = gethostbyaddr($iaddr,AF_INET);
-
-    logmsg "connection from $name [", inet_ntoa($iaddr), "] at port $port";
-
-    # this code is forked and run
-    spawn sub {
-        my ($request, $path, $ver, $left, $cl);
-
-        my @headers;
-
-        while(<STDIN>) {
-            if($_ =~ /([A-Z]*) (.*) HTTP\/1.(\d)/) {
-                $request=$1;
-                $path=$2;
-                $ver=$3;
-            }
-            elsif($_ =~ /^Content-Length: (\d*)/) {
-                $cl=$1;
-            }
-
-            if($verbose) {
-                print STDERR "IN: $_";
-            }
-            
-            push @headers, $_;
-
-            if($left > 0) {
-                $left -= length($_);
-                if($left == 0) {
-                    $left = -1; # just to force a loop break here
-                }
-            }
-            # print STDERR "RCV ($left): $_";
-
-            if(!$left &&
-               ($_ eq "\r\n") or ($_ eq "")) {
-                if($request =~ /^(POST|PUT)$/) {
-                    $left=$cl;
-                }
-                elsif($request =~ /^CONNECT$/) {
-                    if($verbose) {
-                        print STDERR "We're emulating a SSL proxy!\n";
-                    }
-                    $left = -1;
-                }
-                else {
-                    $left = -1; # force abort
-                }
-            }
-            if($left < 0) {
-                last;
-            }
-        }
-
-        if($request =~ /^CONNECT$/) {
-            # ssl proxy mode
-            print "HTTP/1.1 400 WE CANNOT ROOL NOW\r\n",
-            "Server: bahoooba\r\n\r\n";
-            exit;
-        }
-        elsif($path =~ /verifiedserver/) {
-            # this is a hard-coded query-string for the test script
-            # to verify that this is the server actually running!
-            print "HTTP/1.1 999 WE ROOLZ\r\n";
-            exit;
-        }
-        else {
-
-            #
-            # we always start the path with a number, this is the
-            # test number that this server will use to know what
-            # contents to pass back to the client
-            #
-            my $testnum;
-            if($path =~ /.*\/(\d*)/) {
-                $testnum=$1;
-            }
-            else {
-                $testnum=0;
-            }
-            open(INPUT, ">>log/server.input");
-            for(@headers) {
-                print INPUT $_;
-            }
-            close(INPUT);
-            
-            if(0 == $testnum ) {
-                print "HTTP/1.1 200 OK\r\n",
-                "header: yes\r\n",
-                "\r\n",
-                "You must enter a test number to get good data back\r\n";
-            }
-            else {
-                my $part="";
-                if($testnum > 10000) {
-                    $part = $testnum % 10000;
-                    $testnum = sprintf("%d", $testnum/10000);
-                }
-                if($verbose) {
-                    print STDERR "OUT: sending reply $testnum (part $part)\n";
-                }
-
-                loadtest("data/test$testnum");
-                # send a custom reply to the client
-                my @data = getpart("reply", "data$part");
-                for(@data) {
-                    print $_;
-                    if($verbose) {
-                        print STDERR "OUT: $_";
-                    }
-                }
-            }
-        }
-     #   print "Hello there, $name, it's now ", scalar localtime, "\r\n";
-    };
-}
-
-
-sub spawn {
-    my $coderef = shift;
-
-
-    unless (@_ == 0 && $coderef && ref($coderef) eq 'CODE') {
-        confess "usage: spawn CODEREF";
-    }
-
-
-    my $pid;
-    if (!defined($pid = fork)) {
-        logmsg "cannot fork: $!";
-        return;
-    } elsif ($pid) {
-        logmsg "begat $pid";
-        return; # I'm the parent
-    }
-    # else I'm the child -- go spawn
-
-
-    open(STDIN,  "<&Client")   || die "can't dup client to stdin";
-    open(STDOUT, ">&Client")   || die "can't dup client to stdout";
-    ## open(STDERR, ">&STDOUT") || die "can't dup stdout to stderr";
-    exit &$coderef();
-}
+exec("server/sws $port");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/Makefile.am	2001-09-17 16:41:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/Makefile.am	2002-03-01 17:19:09.000000000 +0800
@@ -1,26 +1,28 @@
 EXTRA_DIST = ftpserver.pl httpserver.pl httpsserver.pl runtests.pl \
 	     ftpsserver.pl stunnel.pm getpart.pm FILEFORMAT README \
-	     stunnel.pem
+	     stunnel.pem memanalyze.pl
 
-SUBDIRS = data
+SUBDIRS = data server
 
 PERLFLAGS = -I$(srcdir)
 
 all:
 install:
 
 curl:
 	@(cd ..; make)
 
-test:
+test: server/sws
 	@cd data && exec $(MAKE) test
 	srcdir=$(srcdir) $(PERL) $(PERLFLAGS) $(srcdir)/runtests.pl
 
-quiet-test:
+quiet-test: server/sws
 	@cd data && exec $(MAKE) test
 	srcdir=$(srcdir) $(PERL) $(PERLFLAGS) $(srcdir)/runtests.pl -s -a
 
 clean:
 	rm -rf log
 	find . -name "*~" | xargs rm -f
 
+server/sws:
+	cd server; make sws
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/Makefile.in	2001-09-17 16:41:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/Makefile.in	2002-06-11 23:22:18.000000000 +0800
@@ -58,12 +58,19 @@
 host_alias = @host_alias@
 host_triplet = @host@
 AMTAR = @AMTAR@
 AS = @AS@
 AWK = @AWK@
 CC = @CC@
+CURL_DISABLE_DICT = @CURL_DISABLE_DICT@
+CURL_DISABLE_FILE = @CURL_DISABLE_FILE@
+CURL_DISABLE_FTP = @CURL_DISABLE_FTP@
+CURL_DISABLE_GOPHER = @CURL_DISABLE_GOPHER@
+CURL_DISABLE_HTTP = @CURL_DISABLE_HTTP@
+CURL_DISABLE_LDAP = @CURL_DISABLE_LDAP@
+CURL_DISABLE_TELNET = @CURL_DISABLE_TELNET@
 DEPDIR = @DEPDIR@
 DLLTOOL = @DLLTOOL@
 ECHO = @ECHO@
 EXEEXT = @EXEEXT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
 IPV6_ENABLED = @IPV6_ENABLED@
@@ -88,21 +95,23 @@
 am__include = @am__include@
 am__quote = @am__quote@
 install_sh = @install_sh@
 
 EXTRA_DIST = ftpserver.pl httpserver.pl httpsserver.pl runtests.pl \
 	     ftpsserver.pl stunnel.pm getpart.pm FILEFORMAT README \
-	     stunnel.pem
+	     stunnel.pem memanalyze.pl
 
 
-SUBDIRS = data
+SUBDIRS = data server
 
 PERLFLAGS = -I$(srcdir)
 subdir = tests
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
-CONFIG_HEADER = $(top_builddir)/config.h $(top_builddir)/src/config.h
+CONFIG_HEADER = $(top_builddir)/lib/config.h \
+	$(top_builddir)/src/config.h \
+	$(top_builddir)/tests/server/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
 
 RECURSIVE_TARGETS = info-recursive dvi-recursive install-info-recursive \
 	uninstall-info-recursive all-recursive install-data-recursive \
 	install-exec-recursive installdirs-recursive install-recursive \
@@ -341,20 +350,23 @@
 all:
 install:
 
 curl:
 	@(cd ..; make)
 
-test:
+test: server/sws
 	@cd data && exec $(MAKE) test
 	srcdir=$(srcdir) $(PERL) $(PERLFLAGS) $(srcdir)/runtests.pl
 
-quiet-test:
+quiet-test: server/sws
 	@cd data && exec $(MAKE) test
 	srcdir=$(srcdir) $(PERL) $(PERLFLAGS) $(srcdir)/runtests.pl -s -a
 
 clean:
 	rm -rf log
 	find . -name "*~" | xargs rm -f
+
+server/sws:
+	cd server; make sws
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests: memanalyze.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/runtests.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/runtests.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9/tests/runtests.pl	2001-08-21 21:18:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests/runtests.pl	2002-06-11 23:11:41.000000000 +0800
@@ -1,15 +1,16 @@
-#!/usr/bin/perl
-# $Id: runtests.pl,v 1.39 2001/08/21 13:18:08 bagder Exp $
+#!/usr/bin/env perl
+# $Id: runtests.pl,v 1.61 2002/06/11 15:11:41 bagder Exp $
 #
 # Main curl test script, in perl to run on more platforms
 #
 #######################################################################
 # These should be the only variables that might be needed to get edited:
 
 use strict;
+#use warnings;
 
 @INC=(@INC, $ENV{'srcdir'}, ".");
 
 require "stunnel.pm"; # stunnel functions
 require "getpart.pm"; # array functions
 
@@ -17,12 +18,13 @@
 my $HOSTIP="127.0.0.1";
 my $HOSTPORT=8999; # bad name, but this is the HTTP server port
 my $HTTPSPORT=8433; # this is the HTTPS server port
 my $FTPPORT=8921;  # this is the FTP server port
 my $FTPSPORT=8821;  # this is the FTPS server port
 my $CURL="../src/curl"; # what curl executable to run on the tests
+my $DBGCURL=$CURL; #"../src/.libs/curl";  # alternative for debugging
 my $LOGDIR="log";
 my $TESTDIR="data";
 my $SERVERIN="$LOGDIR/server.input"; # what curl sent the server
 my $CURLLOG="$LOGDIR/curl.log"; # all command lines run
 my $FTPDCMD="$LOGDIR/ftpserver.cmd"; # copy ftp server instructions here
 
@@ -45,36 +47,49 @@
 # invoke perl like this:
 my $perl="perl -I$srcdir";
 
 # this gets set if curl is compiled with memory debugging:
 my $memory_debug=0;
 
+# this gets set if curl is compiled with netrc debugging:
+# It has to be in the global symbol table because of the way 'requires' works
+$main::netrc_debug=0;
+my $netrc_debug = \$main::netrc_debug;
+
 # name of the file that the memory debugging creates:
 my $memdump="memdump";
 
 # the path to the script that analyzes the memory debug output file:
-my $memanalyze="../memanalyze.pl";
+my $memanalyze="./memanalyze.pl";
 
 my $checkstunnel = &checkstunnel;
 
 my $ssl_version; # set if libcurl is built with SSL support
 
+my $skipped=0; # number of tests skipped; reported in main loop
+
 #######################################################################
 # variables the command line options may set
 #
 
 my $short;
 my $verbose;
 my $debugprotocol;
 my $anyway;
 my $gdbthis;      # run test case with gdb debugger
 my $keepoutfiles; # keep stdout and stderr files after tests
+my $listonly;     # only list the tests
+
 my $pwd;          # current working directory
 
 chomp($pwd = `pwd`);
 
+# enable memory debugging if curl is compiled with it
+$ENV{'CURL_MEMDEBUG'} = 1;
+$ENV{'HOME'}=$pwd;
+
 #######################################################################
 # Return the pid of the server as found in the given pid file
 #
 sub serverpid {
     my $PIDFILE = $_[0];
     open(PFILE, "<$PIDFILE");
@@ -111,13 +126,13 @@
     my ($pidfile)=@_;
     my $RUNNING=0;
     my $PID=0;
 
     # check for pidfile
     if ( -f $pidfile ) {
-        my $PID=serverpid($pidfile);
+        $PID=serverpid($pidfile);
         if ($PID ne "" && kill(0, $PID)) {
             $RUNNING=1;
         }
         else {
             $RUNNING=0;
             $PID = -$PID; # negative means dead process
@@ -133,41 +148,62 @@
 # start the http server, or if it already runs, verify that it is our
 # test server on the test-port!
 #
 sub runhttpserver {
     my $verbose = $_[0];
     my $RUNNING;
+    my $pid;
 
-    my $pid = checkserver($HTTPPIDFILE );
+    $pid = checkserver ($HTTPPIDFILE);
+
+    # verify if our/any server is running on this port
+    my $data=`$CURL --silent -i $HOSTIP:$HOSTPORT/verifiedserver`;
+
+    if ( $data =~ /WE ROOLZ(: |)(\d*)/ ) {
+        if($2) {
+            $pid = 0+$2;
+        }
+
+        if(!$pid) {
+            print "Test server already running with unknown pid! Use it...\n";
+            return;
+        }
 
-    if ($pid <= 0) {
-        my $flag=$debugprotocol?"-v ":"";
-        my $cmd="$perl $srcdir/httpserver.pl $flag $HOSTPORT &";
-        system($cmd);
         if($verbose) {
-            print "CMD: $cmd\n";
+            print "Test server already running with pid $pid, killing it...\n";
         }
     }
+    elsif($data ne "") {
+        print "GOT: $data\n";
+        print "An alien HTTP server is running on port $HOSTPORT\n",
+        "Edit runtests.pl to use another port and rerun the test script\n";
+        exit;
+    }
     else {
-        if($pid > 0) {
-            print "httpd ($pid) runs\n";
+        if($verbose) {
+            print "No server running, start it\n";
         }
+    }
 
-        # verify that our server is one one running on this port:
-        my $data=`$CURL --silent -i $HOSTIP:$HOSTPORT/verifiedserver`;
-
-        if ( $data !~ /WE ROOLZ/ ) {
-            print "Another HTTP server is running on port $HOSTPORT\n",
-            "Edit runtests.pl to use another port and rerun the test script\n";
+    if($pid > 0) {
+        my $res = kill (9, $pid); # die!
+        if(!$res) {
+            print "Failed to kill our HTTP test server, do it manually and",
+            " restart the tests.\n";
             exit;
         }
+        sleep(2);
+    }
 
-        if($verbose) {
-            print "The running HTTP server has been verified to be our server\n";
-        }
+    my $flag=$debugprotocol?"-v ":"";
+    my $cmd="$perl $srcdir/httpserver.pl $flag $HOSTPORT &";
+    system($cmd);
+    if($verbose) {
+        print "CMD: $cmd\n";
     }
+
 }
 
 #######################################################################
 # start the https server (or rather, tunnel) if needed
 #
 sub runhttpsserver {
@@ -360,21 +396,42 @@
 
     if( -r $memdump) {
         # if this exists, curl was compiled with memory debugging
         # enabled and we shall verify that no memory leaks exist
         # after each and every test!
         $memory_debug=1;
+
+        # there's only one debug control in the configure script
+        # so hope netrc debugging is enabled and set it up
+        $$netrc_debug = 1;
+        $ENV{'CURL_DEBUG_NETRC'} = 'log/netrc';
     }
     printf("* Memory debugging: %s\n", $memory_debug?"ON":"OFF");
+    printf("* Netrc debugging:  %s\n", $$netrc_debug?"ON":"OFF");
     printf("* HTTPS server:     %s\n", $checkstunnel?"ON":"OFF");
     printf("* FTPS server:      %s\n", $checkstunnel?"ON":"OFF");
     printf("* libcurl SSL:      %s\n", $ssl_version?"ON":"OFF");
     print "***************************************** \n";
 }
 
 #######################################################################
+# substitute the variable stuff into either a joined up file or 
+# a command, in either case passed by reference
+#
+sub subVariables {
+  my ($thing) = @_;
+  $$thing =~ s/%HOSTIP/$HOSTIP/g;
+  $$thing =~ s/%HOSTPORT/$HOSTPORT/g;
+  $$thing =~ s/%HTTPSPORT/$HTTPSPORT/g;
+  $$thing =~ s/%FTPPORT/$FTPPORT/g;
+  $$thing =~ s/%FTPSPORT/$FTPSPORT/g;
+  $$thing =~ s/%SRCDIR/$srcdir/g;
+  $$thing =~ s/%PWD/$pwd/g;
+}
+
+#######################################################################
 # Run a single specified test case
 #
 
 sub singletest {
     my $testnum=$_[0];
 
@@ -384,18 +441,47 @@
             # this is not a test
             print "$testnum doesn't look like a test case!\n";
         }
         return -1;
     }
 
+    {
+        my %hash = getpartattr("client");
+        my $requires = $hash{'requires'};
+
+        if (defined($requires)) {
+            no strict "refs";
+            my $value=${$requires};
+#            print "This test requires '$requires' with value '$value' \n";
+
+            if (${$requires}) {
+                # this test is OK
+                ;
+            }else {
+                print "$testnum requires $requires, which is not set; skipping\n";
+                $skipped++;
+                return 0;  # look successful
+            }
+        }
+    }
+
+
     # extract the reply data
     my @reply = getpart("reply", "data");
     my @replycheck = getpart("reply", "datacheck");
 
     if (@replycheck) {
         # we use this file instead to check the final output against
+
+        my %hash = getpartattr("reply", "datacheck");
+        if($hash{'nonewline'}) {
+            # Yes, we must cut off the final newline from the final line
+            # of the datacheck
+            chomp($replycheck[$#replycheck]);
+        }
+    
         @reply=@replycheck;
     }
 
     # curl command to run
     my @curlcmd= getpart("client", "command");
 
@@ -414,42 +500,49 @@
 
     # if this section exists, it is FTP server instructions:
     my @ftpservercmd = getpart("server", "instruction");
 
     my $CURLOUT="$LOGDIR/curl$testnum.out"; # curl output if not stdout
 
-    # remove previous server output logfile
-    unlink($SERVERIN);
-
-    if(@ftpservercmd) {
-        # write the instructions to file
-        writearray($FTPDCMD, \@ftpservercmd);
-    }
-
     # name of the test
     my @testname= getpart("client", "name");
 
     print "test $testnum...";
     if(!$short) {
         my $name = $testname[0];
         $name =~ s/\n//g;
         print "[$name]\n";
     }
 
+    if($listonly) {
+        return 0; # look successful
+    }
+
+    # remove previous server output logfile
+    unlink($SERVERIN);
+
+    if(@ftpservercmd) {
+        # write the instructions to file
+        writearray($FTPDCMD, \@ftpservercmd);
+    }
+
     # get the command line options to use
     my ($cmd, @blaha)= getpart("client", "command");
 
     # make some nice replace operations
     $cmd =~ s/\n//g; # no newlines please
-    $cmd =~ s/%HOSTIP/$HOSTIP/g;
-    $cmd =~ s/%HOSTPORT/$HOSTPORT/g;
-    $cmd =~ s/%HTTPSPORT/$HTTPSPORT/g;
-    $cmd =~ s/%FTPPORT/$FTPPORT/g;
-    $cmd =~ s/%FTPSPORT/$FTPSPORT/g;
-    $cmd =~ s/%SRCDIR/$srcdir/g;
-    $cmd =~ s/%PWD/$pwd/g;
+
+    subVariables \$cmd;
+
+#    $cmd =~ s/%HOSTIP/$HOSTIP/g;
+#    $cmd =~ s/%HOSTPORT/$HOSTPORT/g;
+#    $cmd =~ s/%HTTPSPORT/$HTTPSPORT/g;
+#    $cmd =~ s/%FTPPORT/$FTPPORT/g;
+#    $cmd =~ s/%FTPSPORT/$FTPSPORT/g;
+#    $cmd =~ s/%SRCDIR/$srcdir/g;
+#    $cmd =~ s/%PWD/$pwd/g;
 
     #$cmd =~ s/%HOSTNAME/$HOSTNAME/g;
 
     if($memory_debug) {
         unlink($memdump);
     }
@@ -457,22 +550,36 @@
     my @inputfile=getpart("client", "file");
     if(@inputfile) {
         # we need to generate a file before this test is invoked
         my %hash = getpartattr("client", "file");
 
         my $filename=$hash{'name'};
+
         if(!$filename) {
             print "ERROR: section client=>file has no name attribute!\n";
             exit;
         }
-        writearray($filename, \@inputfile);
+        my $fileContent = join('', @inputfile);
+        subVariables \$fileContent;
+#        print "DEBUG: writing file " . $filename . "\n";
+        open OUTFILE, ">$filename";
+        print OUTFILE   $fileContent;
+        close OUTFILE;
     }
 
+    my %cmdhash = getpartattr("client", "command");
+
     my $out="";
-    if (!@validstdout) {
-        $out="--output $CURLOUT ";
+
+    if($cmdhash{'option'} eq "no-output") {
+        #print "*** We don't slap on --output\n";
+    }
+    else {
+        if (!@validstdout) {
+            $out="--output $CURLOUT ";
+        }
     }
 
     # run curl, add -v for debug information output
     my $cmdargs="$out--include -v $cmd";
 
     my @stdintest = getpart("client", "stdin");
@@ -495,20 +602,23 @@
     # run the command line we built
     if($gdbthis) {
         open(GDBCMD, ">log/gdbcmd");
         print GDBCMD "set args $cmdargs\n";
         print GDBCMD "show args\n";
         close(GDBCMD);
-        system("gdb $CURL -x log/gdbcmd");
+        system("gdb $DBGCURL -x log/gdbcmd");
         $res =0; # makes it always continue after a debugged run
     }
     else {
         $res = system("$CMDLINE");
         $res /= 256;
     }
 
+    # remove the special FTP command file after each test!
+    unlink($FTPDCMD);
+
     my @err = getpart("verify", "errorcode");
     my $errorcode = $err[0];
 
     if($errorcode || $res) {
         if($errorcode == $res) {
             if(!$short) {
@@ -572,12 +682,21 @@
 
         # what to cut off from the live protocol sent by curl
         my @strip = getpart("verify", "strip");
 
         my @protstrip=@protocol;
 
+        # check if there's any attributes on the verify/protocol section
+        my %hash = getpartattr("verify", "protocol");
+
+        if($hash{'nonewline'}) {
+            # Yes, we must cut off the final newline from the final line
+            # of the protocol data
+            chomp($protstrip[$#protstrip]);
+        }
+
         for(@strip) {
             # strip all patterns from both arrays
             @out = striparray( $_, \@out);
             @protstrip= striparray( $_, \@protstrip);
         }
 
@@ -759,12 +878,16 @@
         $short=1;
     }
     elsif($ARGV[0] eq "-a") {
         # continue anyway, even if a test fail
         $anyway=1;
     }
+    elsif($ARGV[0] eq "-l") {
+        # lists the test case names only
+        $listonly=1;
+    }
     elsif($ARGV[0] eq "-k") {
         # keep stdout and stderr files after tests
         $keepoutfiles=1;
     }
     elsif($ARGV[0] eq "-h") {
         # show help text
@@ -772,12 +895,13 @@
 Usage: runtests.pl [options]
   -a       continue even if a test fails
   -d       display server debug info
   -g       run the test case with gdb
   -h       this help text
   -k       keep stdout and stderr files present after tests
+  -l       list all test case names/descriptions
   -s       short output
   -v       verbose output
   [num]    like "5 6 9" or " 5 to 22 " to run those tests only
 EOHELP
     ;
         exit;
@@ -800,18 +924,19 @@
 } while(shift @ARGV);
 
 if($testthis[0] ne "") {
     $TESTCASES=join(" ", @testthis);
 }
 
-
 #######################################################################
 # Output curl version and host info being tested
 #
 
-displaydata();
+if(!$listonly) {
+    displaydata();
+}
 
 #######################################################################
 # clear and create logging directory:
 #
 cleardir($LOGDIR);
 mkdir($LOGDIR, 0777);
@@ -849,13 +974,12 @@
 #
 
 my $failed;
 my $testnum;
 my $ok=0;
 my $total=0;
-my $skipped=0;
 
 foreach $testnum (split(" ", $TESTCASES)) {
 
     my $serverproblem = serverfortest($testnum);
 
     if($serverproblem) {
@@ -896,13 +1020,14 @@
 
 for(keys %run) {
     stopserver($run{$_}); # the pid file is in the hash table
 }
 
 if($total) {
-    print "$ok tests out of $total reported OK\n";
+    printf("$ok tests out of $total reported OK: %d%%\n",
+           $ok/$total*100);
 
     if($ok != $total) {
         print "These test cases failed: $failed\n";
     }
 }
 else {
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.9.8/tests: server
