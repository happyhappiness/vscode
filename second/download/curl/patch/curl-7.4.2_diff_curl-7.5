diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/CHANGES	2000-11-15 16:21:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/CHANGES	2000-12-04 16:37:43.000000000 +0800
@@ -3,12 +3,128 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
                                History of Changes
 
+Version 7.5
+
+Daniel (1 December 2000)
+- Craig Davison gave us his updates on the VC++ makefiles, so now curl should
+  build fine with the Microsoft compiler on windows too.
+
+- Fixed the libcurl versioning so that we don't ruin old programs when
+  releasing new shared library interfaces.
+
+Daniel (30 November 2000)
+- Renamed docs/README.curl to docs/MANUAL to better reflect what the document
+  actually contains.
+
+Daniel (29 November 2000)
+- I removed a bunch of '#if 0' sections from the code. They only make things
+  harder to follow. After all, we do have all older versions in the CVS.
+
+Version 7.5-pre5
+
+Daniel (28 November 2000)
+- I filled in more error codes in the man page error code list that had been
+  lagging.
+
+- James Griffiths mailed me a fine patch that introduces the CURLOPT_MAXREDIRS
+  libcurl option. When used, it'll prevent location following more than the
+  set number of times. It is useful to break out of endless redirect-loops.
+
+Daniel (27 November 2000)
+- Added two test cases for file://.
+
+Daniel (22 November 2000)
+- Added the libcurl CURLOPT_FILETIME setopt, when set it tries to get the
+  modified time of the remote document. This is a special option since it
+  involves an extra set of commands on FTP servers. (Using the MDTM command
+  which is not in the RFC959)
+
+  curl_easy_getinfo() got a corresponding CURLINFO_FILETIME to get the time
+  after a transfer. It'll return a zero if CURLOPT_FILETIME wasn't used or if
+  the time wasn't possible to get.
+
+  --head/-I used on a FTP server will now present a 'Last-Modified:' header
+  if curl could get the time of the specified file.
+
+- Added the option '--cacert [file]' to curl, which allows a specified PEM
+  file to be used to verify the peer's certificate when doing HTTPS
+  connections. This has been requested, rather recently by Hulka Bohuslav but
+  others have asked for it before as well.
+
+Daniel (21 November 2000)
+- Numerous fixes the test suite has brought into the daylight:
+
+   * curl_unescape() could return a too long string
+   * on ftp transfer failures, there could be memory leaks
+   * ftp CWD could use bad directory names
+   * memdebug now uses the mprintf() routines for better portability
+   * free(NULL) removed when doing resumed transfers
+
+- Added a bunch of test cases for FTP.
+
+- General cleanups to make less warnings with gcc -Wall -pedantic.
+
+- I made the tests/ftpserver.pl work with the most commonly used ftp
+  operations. PORT, PASV, RETR, STOR, LIST, SIZE, USER, PASS all work now. Now
+  all I have to do is integrate the ftp server doings in the runtests.pl
+  script so that ftp tests can be run the same way http tests already run.
+
+Daniel (20 November 2000)
+- Made libcurl capable of dealing with any-length URLs. The former limit of
+  4096 bytes was a bit annoying when people wanted to use curl to really make
+  life tough on a web server. Now, the command line limit is the most annoying
+  but that can be circumvented by using a config file.
+
+  NOTE: there is still a 4096-byte limit on URLs extracted from Location:
+  headers.
+
+- Corrected the spelling of 'resolve' in two error messages.
+
+- Alexander Kourakos posted a bug report and a patch that corrected it! It
+  turned out that lynx and wget support lowercase environment variable names
+  where curl only looked for the uppercase versions. Now curl will use the
+  lowercase versions if they exist, but if they don't, it'll use the uppercase
+  versions.
+
+Daniel (17 November 2000)
+- curl_formfree() was added. How come no one missed that one before? I ran the
+  test suite with the malloc debug enabled and got lots of "nice" warnings on
+  memory leaks. The most serious one was this. There were also leaks in the
+  cookie handling, and a few errors when curl failed to connect and similar
+  things. More tests cases were added to cover up and to verify that these
+  problems have been removed.
+
+- Mucho updated config file parser (I'm dead tired of all the bug reports and
+  weird behaviour I get on the former one). It works slightly differently now,
+  although I doubt many people will notice the differences. The main
+  difference being that if you use options that require parameters, they must
+  both be specified on the same line. With this new parser, you can also
+  specify long options without '--' and you may separate options and
+  parameters with : or =. It makes a config file line could look like:
+
+        user-agent = "foobar and something"
+
+  Parameters within quotes may contain spaces. Without quotes, they're
+  expected to be a single non-space word.
+
+  Had to patch the command line argument parser a little to make this work.
+
+- Added --url as an option to allow the URL to be specified this way. It makes
+  way nicer config files. The previous way of specifying URLs in the config
+  file doesn't work anymore.
+
+Daniel (15 November 2000)
+- Using certain characters in usernames or passwords for HTTP authentication
+  failed. This was due to the mprintf() that had a silly check for letters,
+  and if they weren't isprint() they weren't outputed "as-is". This caused
+  passwords and usernames using '§' (for example) to fail.
+
 Version 7.4.2
 
 Daniel (15 November 2000)
 - 'tests/runtests.pl' now sorts the test cases properly when 'all' is used.
 
 Daniel (14 November 2000)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/CONTRIBUTE /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/CONTRIBUTE
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/CONTRIBUTE	2000-07-29 23:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/CONTRIBUTE	2000-11-29 15:10:05.000000000 +0800
@@ -17,13 +17,16 @@
  When contributing with code, you agree to put your changes and new code under
  the same license curl and libcurl is already using. Curl uses the MozPL, the
  Mozilla Public License, which is *NOT* compatible with the well known GPL,
  GNU Public License. We can never re-use sources from a GPL program in curl.
  If you add a larger piece of code, you can opt to make that file or set of
  files to use a different license as long as they don't enfore any changes to
- the rest of the package. Such "separate parts" can not be GPL either.
+ the rest of the package and they make sense. Such "separate parts" can not be
+ GPL either (although they should use "GPL compatible" licenses).
+
+ Curl and libcurl will soon become dual licensed, MozPL/MITX!
 
 Naming
 
  Try using a non-confusing naming scheme for your new functions and variable
  names. It doesn't necessarily have to mean that you should use the same as in
  other places of the code, just that the names should be logical,
@@ -79,6 +82,15 @@
 Write Access to CVS Repository
 
  If you are a frequent contributor, or have another good reason, you can of
  course get write access to the CVS repository and then you'll be able to
  check-in all your changes straight into the CVS tree instead of sending all
  changes by mail as patches. Just ask if this is what you'd want.
+
+Test Cases
+
+ Since the introduction of the test suite, we will get the possibility to
+ quickly verify that the main features are working as supposed to. To maintain
+ this situation and improve it, all new features and functions that are added
+ need tro be tested. Every feature that is added should get at least one valid
+ test case that verifies that it works as documented. If every submitter also
+ post a few test cases, it won't end up as a heavy burden on a single person!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/curl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/curl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/curl.1	2000-10-30 20:47:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/curl.1	2000-11-28 16:58:18.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man curl.1
 .\" Written by Daniel Stenberg
 .\"
-.TH curl 1 "26 October 2000" "Curl 7.4.2" "Curl Manual"
+.TH curl 1 "22 November 2000" "Curl 7.5" "Curl Manual"
 .SH NAME
 curl \- get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE, HTTP or
 HTTPS syntax.
 .SH SYNOPSIS
 .B curl [options]
 .I url
@@ -133,12 +133,15 @@
 (HTTPS)
 Tells curl to use the specified certificate file when getting a file
 with HTTPS. The certificate must be in PEM format.
 If the optional password isn't specified, it will be queried for on
 the terminal. Note that this certificate is the private key and the private
 certificate concatenated!
+.IP "--cacert <CA certificate>"
+(HTTPS) Tells curl to use the specified certificate file to verify the
+peer. The certificate must be in PEM format.
 .IP "-f/--fail"
 (HTTP)
 Fail silently (no output at all) on server errors. This is mostly done
 like this to better enable scripts etc to better deal with failed
 attempts. In normal cases when a HTTP server fails to deliver a
 document, it returns a HTML document stating so (which often also
@@ -354,12 +357,15 @@
 Specify user and password to use when fetching. See README.curl for detailed
 examples of how to use this. If no password is specified, curl will
 ask for it interactively.
 .IP "-U/--proxy-user <user:password>"
 Specify user and password to use for Proxy authentication. If no
 password is specified, curl will ask for it interactively.
+.IP "--url <URL>"
+Set the URL to fetch. This option is mostly handy when you wanna specify URL
+in a config file.
 .IP "-v/--verbose"
 Makes the fetching more verbose/talkative. Mostly usable for
 debugging. Lines starting with '>' means data sent by curl, '<'
 means data received by curl that is hidden in normal cases and lines
 starting with '*' means additional info provided by curl.
 .IP "-V/--version"
@@ -527,13 +533,13 @@
 FTP weird PASS reply. Curl couldn't parse the reply sent to the PASS request.
 .IP 12
 FTP weird USER reply. Curl couldn't parse the reply sent to the USER request.
 .IP 13
 FTP weird PASV reply, Curl couldn't parse the reply sent to the PASV request.
 .IP 14
-FTP weird 227 formay. Curl couldn't parse the 227-line the server sent.
+FTP weird 227 format. Curl couldn't parse the 227-line the server sent.
 .IP 15
 FTP can't get host. Couldn't resolve the host IP we got in the 227-line.
 .IP 16
 FTP can't reconnect. Couldn't connect to the host we got in the 227-line.
 .IP 17
 FTP couldn't set binary. Couldn't change transfer method to binary.
@@ -585,12 +591,24 @@
 .IP 39
 LDAP search failed.
 .IP 40
 Library not found. The LDAP library was not found.
 .IP 41
 Function not found. A required LDAP function was not found.
+.IP 42
+Aborted by callback. An application told curl to abort the operation.
+.IP 43
+Internal error. A function was called with a bad parameter.
+.IP 44
+Internal error. A function was called in a bad order.
+.IP 45
+Interface error. A specified outgoing interface could not be used.
+.IP 46
+Bad password entered. An error was signalled when the password was entered.
+.IP 47
+Too many redirects. When following redirects, curl hit the maximum amount.
 .IP XX
 There will appear more error codes here in future releases. The existing ones
 are meant to never change.
 .SH BUGS
 If you do find bugs, mail them to curl-bug@haxx.se.
 .SH AUTHORS / CONTRIBUTORS
@@ -645,12 +663,14 @@
  - Albert Chin-A-Young <china@thewrittenword.com>
  - Stephen Kick <skick@epicrealm.com>
  - Martin Hedenfalk <mhe@stacken.kth.se>
  - Richard Prescott
  - Jason S. Priebe <priebe@wral-tv.com>
  - T. Bharath <TBharath@responsenetworks.com>
+ - Alexander Kourakos <awk@users.sourceforge.net>
+ - James Griffiths <griffiths_james@yahoo.com>
 
 .SH WWW
 http://curl.haxx.se
 .SH FTP
 ftp://ftp.sunet.se/pub/www/utilities/curl/
 .SH "SEE ALSO"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/curl_easy_getinfo.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/curl_easy_getinfo.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/curl_easy_getinfo.3	2000-10-30 21:00:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/curl_easy_getinfo.3	2000-11-22 22:57:15.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_init 3 "30 October 2000" "Curl 7.4.2" "libcurl Manual"
+.TH curl_easy_init 3 "22 November 2000" "Curl 7.5" "libcurl Manual"
 .SH NAME
 curl_easy_getinfo - Extract information from a curl session (added in 7.4)
 .SH SYNOPSIS
 .B #include <curl/easy.h>
 .sp
 .BI "CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );"
@@ -25,12 +25,18 @@
 .B CURLINFO_EFFECTIVE_URL
 Pass a pointer to a 'char *' to receive the last used effective URL.
 .TP
 .B CURLINFO_HTTP_CODE
 Pass a pointer to a long to receive the last received HTTP code.
 .TP
+.B CURLINFO_FILETIME
+Pass a pointer to a long to receive the remote time of the retrieved
+document. If you get 0, it can be because of many reasons (unknown, the server
+hides it or the server doesn't support the command that tells document time
+etc) and the time of the document is unknown. (Added in 7.5)
+.TP
 .B CURLINFO_TOTAL_TIME
 Pass a pointer to a double to receive the total transaction time in seconds
 for the previous transfer.
 .TP
 .B CURLINFO_NAMELOOKUP_TIME
 Pass a pointer to a double to receive the time, in seconds, it took from the
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/curl_easy_setopt.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/curl_easy_setopt.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/curl_easy_setopt.3	2000-11-07 07:10:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/curl_easy_setopt.3	2000-11-28 16:53:47.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_setopt 3 "30 October 2000" "Curl 7.4.2" "libcurl Manual"
+.TH curl_easy_setopt 3 "28 November 2000" "Curl 7.5" "libcurl Manual"
 .SH NAME
 curl_easy_setopt - Set curl easy-session options
 .SH SYNOPSIS
 .B #include <curl/easy.h>
 .sp
 .BI "CURLcode curl_easy_setopt(CURL *" handle ", CURLoption "option ", ...);
@@ -382,12 +382,25 @@
 (Added in 7.4.2)
 .TP
 .B CURLOPT_PASSWDDATA
 Pass a void * to whatever data you want. The passed pointer will be the first
 argument sent to the specifed CURLOPT_PASSWDFUNCTION function. (Added in
 7.4.2)
+.TP
+.B CURLOPT_FILETIME
+Pass a long. If it is a non-zero value, libcurl will attempt to get the
+modification date of the remote document in this operation. This requires that
+the remote server sends the time or replies to a time querying command. The
+curl_easy_getinfo() function with the CURLINFO_FILETIME argument can be used
+after a transfer to extract the received time (if any). (Added in 7.5)
+.TP
+.B CURLOPT_MAXREDIRS
+Pass a long. The set number will be the redirection limit. If that many
+redirections have been followed, the next redirect will cause an error. This
+option only makes sense if the CURLOPT_FOLLOWLOCATION is used at the same
+time. (Added in 7.5)
 .PP
 .SH RETURN VALUE
 0 means the option was set properly, non-zero means an error as
 .I <curl/curl.h>
 defines
 .SH "SEE ALSO"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs: curl_formfree.3
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/FAQ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/FAQ
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/FAQ	2000-10-27 20:21:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/FAQ	2000-11-22 15:26:56.000000000 +0800
@@ -1,7 +1,7 @@
-Updated: October 27, 2000 (http://curl.haxx.se/docs/faq.shtml)
+Updated: November 22, 2000 (http://curl.haxx.se/docs/faq.shtml)
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -45,12 +45,13 @@
   4.6 Can you tell me what error code 142 means?
   4.7 How do I keep usernames and passwords secret in Curl command lines?
   4.8 I found a bug!
 
  5. libcurl Issues
   5.1 Is libcurl thread safe?
+  5.2 How can I receive all data into a large memory chunk?
 
  6. License Issues
   6.1 I have a GPL program, can I use the libcurl library?
   6.2 I have a closed-source program, can I use the libcurl library?
   6.3 I have a BSD licensed program, can I use the libcurl library?
   6.4 I have a program that uses LGPL libraries, can I use libcurl?
@@ -399,12 +400,46 @@
   functions instead of non-safe ones.
 
   I am very interested in once and for all getting some kind of report or
   README file from those who have used libcurl in a threaded environment,
   since I haven't and I get this question more and more frequently!
 
+  5.2 How can I receive all data into a large memory chunk?
+
+  You are in full control of the callback function that gets called every time
+  there is data received from the remote server. You can make that callback do
+  whatever you want. You do not have to write the receivied data to a file.
+
+  One solution to this problem could be to have a pointer to a struct that you
+  pass to the callback function. You set the pointer using the
+  curl_easy_setopt(CURLOPT_FILE) function. Then that pointer will be passed to
+  the callback instead of a FILE * to a file:
+
+        /* imaginary struct */
+        struct MemoryStruct {
+          char *memory;
+          size_t size;
+        };
+
+        /* imaginary callback function */
+        size_t
+        WriteMemoryCallback(void *ptr, size_t size, size_t nmemb, void *data)
+        {
+          register int realsize = size * nmemb;
+          struct MemoryStruct *mem = (struct MemoryStruct *)data;
+        
+          mem->memory = (char *)realloc(mem->memory, mem->size + realsize + 1);
+          if (mem->memory) {
+            memcpy(&(mem->memory[mem->size]), ptr, realsize);
+            mem->size += realsize;
+            mem->memory[mem->size] = 0;
+          }
+          return realsize;
+        }
+
+
 6. License Issues
 
   Curl and libcurl are released under the MPL, the Mozilla Public License. To
   get a really good answer to your license conflict questions, you should
   study the MPL license and the license you are about to use and check for
   clashes yourself. This section is just a brief summary for the cases we get
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/INSTALL	2000-09-26 15:31:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/INSTALL	2000-11-27 21:38:33.000000000 +0800
@@ -8,55 +8,24 @@
 
 Curl has been compiled and built on numerous different operating systems. The
 way to proceed is mainly divided in two different ways: the unix way or the
 windows way.
 
 If you're using Windows (95, 98, NT) or OS/2, you should continue reading from
-the Win32 header below. All other systems should be capable of being installed
-as described in the the UNIX header.
-
-PORTS
-=====
-   Just to show off, this is a probably incomplete list of known hardware and
-   operating systems that curl has been compiled for:
-
-        - Ultrix
-        - SINIX-Z v5
-        - Alpha DEC OSF 4
-        - Alpha Digital UNIX v3.2
-        - Alpha FreeBSD 4.1
-        - Alpha Linux 2.2.16
-        - Alpha Tru64 v5.0 5.1
-        - HP-PA HP-UX 9.X 10.X 11.X
-        - MIPS IRIX 6.2, 6.5
-        - Power AIX 4.2, 4.3.1, 4.3.2
-        - PowerPC Darwin 1.0
-        - PowerPC Linux
-        - PowerPC Mac OS X
-        - Sparc Linux
-        - Sparc Solaris 2.4, 2.5, 2.5.1, 2.6, 7, 8
-        - Sparc SunOS 4.1.*
-        - i386 BeOS
-        - i386 FreeBSD
-        - i386 Linux 1.3, 2.0, 2.2, 2.3, 2.4
-        - i386 NetBSD
-        - i386 OS/2
-        - i386 OpenBSD
-        - i386 Solaris 2.7
-        - i386 Windows 95, 98, NT, 2000
-        - ia64 Linux 2.3.99
-        - m68k AmigaOS 3
-        - m68k OpenBSD
+the Win32 or OS/2 headers further down. All other systems should be capable of
+being installed as described below.
 
 UNIX
 ====
 
    The configure script *always* tries to find a working SSL library unless
    explicitly told not to.  If you have OpenSSL installed in the default
    search path for your compiler/linker, you don't need to do anything
-   special.
+   special:
+
+        ./configure
 
    If you have OpenSSL installed in /usr/local/ssl, you can run configure
    like:
 
 	./configure --with-ssl
 
@@ -98,15 +67,23 @@
    Then run:
 
      make
 
    Use the executable `curl` in src/ directory.
 
-   'make install' copies the curl file to /usr/local/bin/ (or $prefix/bin if
-   you used the --prefix option to configure) and copies the man pages, the
-   lib and the include files to a suitable place too.
+   To install curl on your system, run
+
+     make install
+
+   This will copy curl to /usr/local/bin/ (or $prefix/bin if you used the
+   --prefix option to configure) and it copies the man pages, the lib and the
+   include files to suitable places.
+
+   To make sure everything runs as supposed, run the test suite:
+
+     make test
 
    KNOWN PROBLEMS
 
      If you happen to have autoconf installed, but a version older than
      2.12 you will get into trouble. Then you can still build curl by
      issuing these commands: (from Ralph Beckmann <rabe@uni-paderborn.de>)
@@ -256,12 +233,45 @@
    If everything seems to work fine but there's no curl.exe, you need to add
    -Zexe to your linker flags.
 
    If you're getting huge binaries, probably your makefiles have the -g in
    CFLAGS.
 
+PORTS
+=====
+   Just to show off, this is a probably incomplete list of known hardware and
+   operating systems that curl has been compiled for:
+
+        - Ultrix
+        - SINIX-Z v5
+        - Alpha DEC OSF 4
+        - Alpha Digital UNIX v3.2
+        - Alpha FreeBSD 4.1
+        - Alpha Linux 2.2.16
+        - Alpha Tru64 v5.0 5.1
+        - HP-PA HP-UX 9.X 10.X 11.X
+        - MIPS IRIX 6.2, 6.5
+        - Power AIX 4.2, 4.3.1, 4.3.2
+        - PowerPC Darwin 1.0
+        - PowerPC Linux
+        - PowerPC Mac OS X
+        - Sparc Linux
+        - Sparc Solaris 2.4, 2.5, 2.5.1, 2.6, 7, 8
+        - Sparc SunOS 4.1.*
+        - i386 BeOS
+        - i386 FreeBSD
+        - i386 Linux 1.3, 2.0, 2.2, 2.3, 2.4
+        - i386 NetBSD
+        - i386 OS/2
+        - i386 OpenBSD
+        - i386 Solaris 2.7
+        - i386 Windows 95, 98, NT, 2000
+        - ia64 Linux 2.3.99
+        - m68k AmigaOS 3
+        - m68k OpenBSD
+
 OpenSSL
 =======
 
    You'll find OpenSSL information at:
 
       http://www.openssl.org
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/INTERNALS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/INTERNALS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/INTERNALS	2000-10-09 20:49:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/INTERNALS	2000-11-29 15:04:28.000000000 +0800
@@ -9,12 +9,23 @@
  The project is kind of split in two. The library and the client. The client
  part uses the library, but the library is meant to be designed to allow other
  applications to use it.
 
  Thus, the largest amount of code and complexity is in the library part.
 
+CVS
+===
+
+ All changes to the sources are committed to the CVS repository as soon as
+ they're somewhat verified to work. Changes shall be commited as independently
+ as possible so that individual changes can be easier spotted and tracked
+ afterwards.
+
+ Tagging shall be used extensively, and by the time we release new archives we
+ should tag the sources with a name similar to the released version number.
+
 Windows vs Unix
 ===============
 
  There are a few differences in how to program curl the unix way compared to
  the Windows way. The four most notable details are:
 
@@ -44,27 +55,30 @@
  Windows machine!
 
 Library
 =======
 
  As described elsewhere, libcurl is meant to get two different "layers" of
- interface. At the present point only the high-level, the "easy", interface
- has been fully implemented and thus documented. We assume the easy-interface
- in this description, the low-level interface will be documented when fully
+ interfaces. At the present point only the high-level, the "easy", interface
+ has been fully implemented and documented. We assume the easy-interface in
+ this description, the low-level interface will be documented when fully
  implemented.
 
  There are plenty of entry points to the library, namely each publicly defined
  function that libcurl offers to applications. All of those functions are
  rather small and easy-to-follow. All the ones prefixed with 'curl_easy' are
  put in the lib/easy.c file.
 
+ curl_easy_init() allocates an internal struct and makes some initializations.
+ The returned handle does not revail internals.
+
  curl_easy_setopt() takes a three arguments, where the option stuff must be
  passed in pairs, the parameter-ID and the parameter-value. The list of
  options is documented in the man page.
 
- curl_easy_perform() does a whole lot of things.
+ curl_easy_perform() does a whole lot of things:
 
  The function analyzes the URL, get the different components and connects to
  the remote host. This may involve using a proxy and/or using SSL. The
  GetHost() function in lib/hostip.c is used for looking up host names.
 
  When connected, the proper function is called. The functions are named after
@@ -128,34 +142,47 @@
  While transfering data in Transfer() a few functions might get
  used. curl_getdate() in lib/getdate.c is for HTTP date comparisons (and
  more).
 
  lib/getenv.c offers curl_getenv() which is for reading environment variables
  in a neat platform independent way. That's used in the client, but also in
- lib/url.c when checking the PROXY variables.
+ lib/url.c when checking the proxy environment variables.
 
- lib/netrc.c keeps the .netrc parser
+ lib/netrc.c holds the .netrc parser
 
  lib/timeval.c features replacement functions for systems that don't have
+ gettimeofday().
  
  A function named curl_version() that returns the full curl version string is
  found in lib/version.c.
 
 Client
 ======
 
- main() resides in src/main.c together with most of the client
- code. src/hugehelp.c is automatically generated by the mkhelp.pl perl script
- to display the complete "manual" and the src/urlglob.c file holds the
- functions used for the multiple-URL support.
+ main() resides in src/main.c together with most of the client code.
+ src/hugehelp.c is automatically generated by the mkhelp.pl perl script to
+ display the complete "manual" and the src/urlglob.c file holds the functions
+ used for the multiple-URL support.
 
  The client mostly mess around to setup its config struct properly, then it
  calls the curl_easy_*() functions of the library and when it gets back
  control after the curl_easy_perform() it cleans up the library, checks status
  and exits.
 
  When the operation is done, the ourWriteOut() function in src/writeout.c may
  be called to report about the operation. That function is using the
  curl_easy_getinfo() function to extract useful information from the curl
  session.
 
+Test Suite
+==========
+
+ During November 2000, a test suite has evolved. It is placed in its own
+ subdirectory directly off the root in the curl archive tree, and it contains
+ a bunch of scripts and a lot of test case data.
+
+ The main test script is runtests.pl that will invoke the two servers
+ httpserver.pl and ftpserver.pl before all the test cases are performed. The
+ test suite currently only runs on unix-like platforms.
 
+ You'll find a complete description of the test case data files in the README
+ file in the test directory.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs: MANUAL
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs: README.curl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/docs/TODO	2000-11-09 17:23:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/docs/TODO	2000-11-22 18:09:35.000000000 +0800
@@ -21,12 +21,16 @@
    the following is a plain list with URLs to download. Thus @filename.txt
    reads a list of URLs from a local file. A fancy option would then be to
    support @http://whatever.com that would first load a list and then get the
    URLs mentioned in the list. I figure -O or something would have to be
    implied by such an action.
 
+ * Make curl with multiple URLs, even outside of {}-letters. I could also
+   imagine an optional fork()ed system that downloads each URL in its own
+   thread. It should of course have a maximum amount of simultaneous fork()s.
+
  * Improve the regular progress meter with --continue is used. It should be
    noticable when there's a resume going on.
 
  * Add a command line option that allows the output file to get the same time
    stamp as the remote file. This requires some fiddling on FTP but comes
    almost free for HTTP.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/FILES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/FILES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/FILES	2000-11-14 00:09:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/FILES	2000-11-30 15:55:44.000000000 +0800
@@ -6,13 +6,13 @@
 docs/BUGS
 docs/CONTRIBUTE
 docs/FAQ
 docs/FEATURES
 docs/INSTALL
 docs/INTERNALS
-docs/README.curl
+docs/MANUAL
 docs/README.win32
 docs/README.libcurl
 docs/RESOURCES
 docs/TODO
 docs/curl.1
 docs/Makefile.in
@@ -71,13 +71,12 @@
 packages/Linux/RPM/curl.spec
 packages/Linux/RPM/make_curl_rpm
 packages/Linux/RPM/README
 packages/Win32/README
 packages/README
 tests/Makefile.am
-tests/data/*
-tests/runtests.pl
 tests/Makefile.in
+tests/runtests.pl
 tests/README
 tests/httpserver.pl
-
-
+tests/ftpserver.pl
+tests/data/*.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/include/curl/curl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/include/curl/curl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/include/curl/curl.h	2000-11-15 16:22:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/include/curl/curl.h	2000-12-04 16:38:10.000000000 +0800
@@ -28,14 +28,14 @@
  * Main author:
  * - Daniel Stenberg <Daniel.Stenberg@haxx.nu>
  *
  * 	http://curl.haxx.nu
  *
  * $Source: /cvsroot/curl/include/curl/curl.h,v $
- * $Revision: 1.30 $
- * $Date: 2000/11/06 22:53:50 $
+ * $Revision: 1.35 $
+ * $Date: 2000/11/28 09:10:04 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -169,22 +169,23 @@
   CURLE_BAD_FUNCTION_ARGUMENT,
   CURLE_BAD_CALLING_ORDER,
 
   CURLE_HTTP_PORT_FAILED, /* HTTP Interface operation failed */
 
   CURLE_BAD_PASSWORD_ENTERED, /* when the my_getpass() returns fail */
+  CURLE_TOO_MANY_REDIRECTS , /* catch endless re-direct loops */
 
   CURL_LAST
 } CURLcode;
 
 /* This is just to make older programs not break: */
 #define CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE
 
 #define CURL_ERROR_SIZE 256
 
-/* maximum URL length we deal with */
+/* maximum URL length we deal with in headers */
 #define URL_MAX_LENGTH 4096 
 #define URL_MAX_LENGTH_TXT "4095"
 
 /* name is uppercase CURLOPT_<name>,
    type is one of the defined CURLOPTTYPE_<type>
    number is unique identifier */
@@ -414,19 +415,23 @@
   /* Function pointer to replace the internal password prompt */
   CINIT(PASSWDFUNCTION, FUNCTIONPOINT, 66),
 
   /* Custom pointer that gets passed as first argument to the password
      function */
   CINIT(PASSWDDATA, OBJECTPOINT, 67),
+  
+  /* Maximum number of http redirects to follow */
+  CINIT(MAXREDIRS, LONG, 68),
+
+  /* Pass a pointer to a time_t to get a possible date of the requested
+     document! Pass a NULL to shut it off. */
+  CINIT(FILETIME, OBJECTPOINT, 69),
 
   CURLOPT_LASTENTRY /* the last unusued */
 } CURLoption;
 
-#define CURL_PROGRESS_STATS 0 /* default progress display */
-#define CURL_PROGRESS_BAR   1
-
 typedef enum {
   TIMECOND_NONE,
 
   TIMECOND_IFMODSINCE,
   TIMECOND_IFUNMODSINCE,
   TIMECOND_LASTMOD,
@@ -451,22 +456,25 @@
 
 /* external form function */
 int curl_formparse(char *string,
                    struct HttpPost **httppost,
                    struct HttpPost **last_post);
 
+/* cleanup a form: */
+void curl_formfree(struct HttpPost *form);
+
 /* Unix and Win32 getenv function call, this returns a malloc()'ed string that
    MUST be free()ed after usage is complete. */
 char *curl_getenv(char *variable);
 
 /* Returns a static ascii string of the libcurl version. */
 char *curl_version(void);
 
 /* This is the version number */
-#define LIBCURL_VERSION "7.4.2"
-#define LIBCURL_VERSION_NUM 0x070402
+#define LIBCURL_VERSION "7.5"
+#define LIBCURL_VERSION_NUM 0x070500
 
 /* linked-list structure for the CURLOPT_QUOTE option (and other) */
 struct curl_slist {
 	char			*data;
 	struct curl_slist	*next;
 };
@@ -681,14 +689,15 @@
   CURLINFO_SIZE_DOWNLOAD    = CURLINFO_DOUBLE + 8,
   CURLINFO_SPEED_DOWNLOAD   = CURLINFO_DOUBLE + 9,
   CURLINFO_SPEED_UPLOAD     = CURLINFO_DOUBLE + 10,
   CURLINFO_HEADER_SIZE      = CURLINFO_LONG   + 11,
   CURLINFO_REQUEST_SIZE     = CURLINFO_LONG   + 12,
   CURLINFO_SSL_VERIFYRESULT = CURLINFO_LONG   + 13,
+  CURLINFO_FILETIME         = CURLINFO_LONG   + 14,
 
-  CURLINFO_LASTONE          = 14
+  CURLINFO_LASTONE          = 15
 } CURLINFO;
 
 /*
  * NAME curl_getinfo()
  *
  * DESCRIPTION
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/dict.c	2000-08-24 22:26:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/dict.c	2000-11-20 16:53:21.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/dict.c,v $
- * $Revision: 1.7 $
- * $Date: 2000/08/24 14:26:33 $
+ * $Revision: 1.8 $
+ * $Date: 2000/11/20 08:53:21 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -230,13 +230,13 @@
       
     ppath = strchr(path, '/');
     if (ppath) {
       int i;
 	
       ppath++;
-      for (i = 0; (i < URL_MAX_LENGTH) && (ppath[i]); i++) {
+      for (i = 0; ppath[i]; i++) {
         if (ppath[i] == ':')
           ppath[i] = ' ';
       }
       sendf(data->firstsocket, data,
             "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
             "%s\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/escape.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/escape.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/escape.c	2000-10-09 19:12:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/escape.c	2000-11-22 03:38:12.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/escape.c,v $
- * $Revision: 1.7 $
- * $Date: 2000/10/09 11:12:34 $
+ * $Revision: 1.8 $
+ * $Date: 2000/11/21 19:01:53 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -97,25 +97,26 @@
    int index=0;
    int hex;
    char querypart=FALSE; /* everything to the right of a '?' letter is
                             the "query part" where '+' should become ' '.
                             RFC 2316, section 3.10 */
   
-   while(--alloc) {
+   while(--alloc > 0) {
       in = *string;
       if(querypart && ('+' == in))
          in = ' ';
       else if(!querypart && ('?' == in)) {
         /* we have "walked in" to the query part */
         querypart=TRUE;
       }
       else if('%' == in) {
         /* encoded part */
         if(sscanf(string+1, "%02X", &hex)) {
           in = hex;
           string+=2;
+          alloc-=2;
         }
       }
 
       ns[index++] = in;
       string++;
    }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/file.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/file.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/file.c	2000-11-13 15:51:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/file.c	2000-11-29 16:17:12.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/file.c,v $
- * $Revision: 1.9 $
- * $Date: 2000/11/13 07:51:23 $
+ * $Revision: 1.12 $
+ * $Date: 2000/11/29 08:17:12 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -100,12 +100,16 @@
 #include "sendf.h"
 #include "escape.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
 
 CURLcode file(struct connectdata *conn)
 {
   /* This implementation ignores the host name in conformance with 
      RFC 1738. Only local files (reachable via the standard file system)
      are supported. This means that files on remotely mounted directories
@@ -148,15 +152,12 @@
   }
 
   /* The following is a shortcut implementation of file reading
      this is both more efficient than the former call to download() and
      it avoids problems with select() and recv() on file descriptors
      in Winsock */
-#if 0
-  ProgressInit (data, expected_size);
-#endif
   if(expected_size != -1)
     pgrsSetDownloadSize(data, expected_size);
 
   while (res == CURLE_OK) {
     nread = read(fd, buf, BUFSIZE-1);
 
@@ -167,16 +168,17 @@
       break;
     bytecount += nread;
     /* NOTE: The following call to fwrite does CR/LF translation on
        Windows systems if the target is stdout. Use -O or -o parameters
        to prevent CR/LF translation (this then goes to a binary mode
        file descriptor). */
-    if(nread != data->fwrite (buf, 1, nread, data->out)) {
-      failf (data, "Failed writing output");
-      return CURLE_WRITE_ERROR;
-    }
+
+    res = client_write(data, CLIENTWRITE_BODY, buf, nread);
+    if(res)
+      return res;
+
     now = tvnow();
     if(pgrsUpdate(data))
       res = CURLE_ABORTED_BY_CALLBACK;
   }
   now = tvnow();
   if(pgrsUpdate(data))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/formdata.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/formdata.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/formdata.c	2000-10-10 06:29:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/formdata.c	2000-11-17 22:06:24.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/formdata.c,v $
- * $Revision: 1.10 $
- * $Date: 2000/10/09 22:29:35 $
+ * $Revision: 1.11 $
+ * $Date: 2000/11/17 14:06:24 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -379,21 +379,43 @@
     retstring[i] = table64[rand()%64];
   }
   retstring[BOUNDARY_LENGTH-1]=0; /* zero terminate */
 
   return retstring;
 }
- 
 
+/* Used from http.c */ 
 void FormFree(struct FormData *form)
 {
   struct FormData *next;
   do {
     next=form->next;  /* the following form line */
     free(form->line); /* free the line */
     free(form);       /* free the struct */
+  
+  } while((form=next)); /* continue */
+}
+
+/* external function to free up a whole form post chain */
+void curl_formfree(struct HttpPost *form)
+{
+  struct HttpPost *next;
+  do {
+    next=form->next;  /* the following form line */
+
+    /* recurse to sub-contents */
+    if(form->more)
+      curl_formfree(form->more);
+
+    if(form->name)
+      free(form->name); /* free the name */
+    if(form->contents)
+      free(form->contents); /* free the contents */
+    if(form->contenttype)
+      free(form->contenttype); /* free the content type */
+    free(form);       /* free the struct */
 
   } while((form=next)); /* continue */
 }
 
 struct FormData *getFormData(struct HttpPost *post,
 			     int *sizep)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/ftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/ftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/ftp.c	2000-11-10 21:42:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/ftp.c	2000-12-01 06:43:30.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/ftp.c,v $
- * $Revision: 1.29 $
- * $Date: 2000/11/10 13:42:45 $
+ * $Revision: 1.36 $
+ * $Date: 2000/11/30 21:59:51 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -82,12 +82,13 @@
 
 #include "if2ip.h"
 #include "hostip.h"
 #include "progress.h"
 #include "download.h"
 #include "escape.h"
+#include "http.h" /* for HTTP proxy tunnel stuff */
 
 #ifdef KRB4
 #include "security.h"
 #endif
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
@@ -125,13 +126,13 @@
 	if (new_item) {
 		new_item->next = NULL;
 		new_item->data = strdup(data);
 	}
 	else {
 		fprintf(stderr, "Cannot allocate memory for QUOTE list.\n");
-		exit(-1);
+		return NULL;
 	}
 
 	if (list) {
 		last = slist_get_last(list);
 		last->next = new_item;
 		return list;
@@ -214,13 +215,14 @@
 /* --- parse FTP server responses --- */
 
 #define lastline(line) (isdigit((int)line[0]) && isdigit((int)line[1]) && \
 			isdigit((int)line[2]) && (' ' == line[3]))
 
 int GetLastResponse(int sockfd, char *buf,
-                    struct connectdata *conn)
+                    struct connectdata *conn,
+                    int *ftpcode)
 {
   int nread;
   int keepon=TRUE;
   char *ptr;
   int timeout = 3600; /* in seconds */
   struct timeval interval;
@@ -230,12 +232,14 @@
 
 #define SELECT_OK      0
 #define SELECT_ERROR   1
 #define SELECT_TIMEOUT 2
   int error = SELECT_OK;
 
+  *ftpcode=0; /* 0 for errors */
+
   if(data->timeout) {
     /* if timeout is requested, find out how much remaining time we have */
     timeout = data->timeout - /* timeout time */
       (tvlong(tvnow()) - tvlong(conn->now)); /* spent time */
     if(timeout <=0 ) {
       failf(data, "Transfer aborted due to timeout");
@@ -314,12 +318,14 @@
   } while(!error &&
 	  (nread<4 || !lastline(buf)) );
   
   if(error)
     return -error;
 
+  *ftpcode=atoi(buf); /* return the initial number like this */
+
   return nread;
 }
 
 /* -- who are we? -- */
 char *getmyhost(char *buf, int buf_size)
 {
@@ -334,69 +340,23 @@
   strncpy(buf, "localhost", buf_size);
   buf[buf_size - 1] = '\0';
 #endif
   return buf;
 }
 
-#if 0
-/*
- * URLfix()
- *
- * This function returns a string converted FROM the input URL format to a
- * format that is more likely usable for the remote server. That is, all
- * special characters (found as %XX-codes) will be eascaped with \<letter>.
- */
-
-static char *URLfix(char *string)
-{
-  /* The length of the new string can't be longer than twice the original
-     string, if all letters are '+'... */
-  int alloc = strlen(string)*2;
-  char *ns = malloc(alloc);
-  unsigned char in;
-  int index=0;
-  int hex;
-   
-  while(*string) {
-    in = *string;
-    switch(in) {
-    case '+':
-      ns[index++] = '\\';
-      ns[index++] = ' ';
-      string++;
-      continue;
-
-    case '%':
-      /* encoded part */
-      if(sscanf(string+1, "%02X", &hex)) {
-        ns[index++] = '\\';
-        ns[index++] = hex;
-        string+=3;
-        continue;
-      }
-      /* FALLTHROUGH */
-    default:
-      ns[index++] = in;
-      string++;
-    }
-  }
-  ns[index]=0; /* terminate it */
-  return ns;
-}
-#endif
-
 /* ftp_connect() should do everything that is to be considered a part
    of the connection phase. */
 CURLcode ftp_connect(struct connectdata *conn)
 {
   /* this is FTP and no proxy */
   int nread;
   struct UrlData *data=conn->data;
   char *buf = data->buffer; /* this is our buffer */
   struct FTP *ftp;
   CURLcode result;
+  int ftpcode;
 
   myalarm(0); /* switch off the alarm stuff */
 
   ftp = (struct FTP *)malloc(sizeof(struct FTP));
   if(!ftp)
     return CURLE_OUT_OF_MEMORY;
@@ -415,16 +375,17 @@
                                 data->hostname, data->remote_port);
     if(CURLE_OK != result)
       return result;
   }
 
   /* The first thing we do is wait for the "220*" line: */
-  nread = GetLastResponse(data->firstsocket, buf, conn);
+  nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
-  if(strncmp(buf, "220", 3)) {
+
+  if(ftpcode != 220) {
     failf(data, "This doesn't seem like a nice ftp-server response");
     return CURLE_FTP_WEIRD_SERVER_REPLY;
   }
 
 #ifdef KRB4
   /* if not anonymous login, try a secure login */
@@ -447,48 +408,48 @@
 #endif
   
   /* send USER */
   ftpsendf(data->firstsocket, conn, "USER %s", ftp->user);
 
   /* wait for feedback */
-  nread = GetLastResponse(data->firstsocket, buf, conn);
+  nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
-  if(!strncmp(buf, "530", 3)) {
+  if(ftpcode == 530) {
     /* 530 User ... access denied
        (the server denies to log the specified user) */
     failf(data, "Access denied: %s", &buf[4]);
     return CURLE_FTP_ACCESS_DENIED;
   }
-  else if(!strncmp(buf, "331", 3)) {
+  else if(ftpcode == 331) {
     /* 331 Password required for ...
        (the server requires to send the user's password too) */
     ftpsendf(data->firstsocket, conn, "PASS %s", ftp->passwd);
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(!strncmp(buf, "530", 3)) {
+    if(ftpcode == 530) {
       /* 530 Login incorrect.
          (the username and/or the password are incorrect) */
       failf(data, "the username and/or the password are incorrect");
       return CURLE_FTP_USER_PASSWORD_INCORRECT;
     }
-    else if(!strncmp(buf, "230", 3)) {
+    else if(ftpcode == 230) {
       /* 230 User ... logged in.
          (user successfully logged in) */
         
       infof(data, "We have successfully logged in\n");
     }
     else {
       failf(data, "Odd return code after PASS");
       return CURLE_FTP_WEIRD_PASS_REPLY;
     }
   }
-  else if(/*! strncmp(buf, "230", 3)***/ buf[0] == '2') {
+  else if(buf[0] == '2') {
     /* 230 User ... logged in.
        (the user logged in without password) */
     infof(data, "We have successfully logged in\n");
 #ifdef KRB4
 	/* we are logged in (with Kerberos)
 	 * now set the requested protection level
@@ -517,12 +478,13 @@
 {
   struct UrlData *data = conn->data;
   struct FTP *ftp = data->proto.ftp;
   size_t nread;
   char *buf = data->buffer; /* this is our buffer */
   struct curl_slist *qitem; /* QUOTE item */
+  int ftpcode;
 
   if(data->bits.upload) {
     if((-1 != data->infilesize) && (data->infilesize != *ftp->bytecountp)) {
       failf(data, "Wrote only partial file (%d out of %d bytes)",
             *ftp->bytecountp, data->infilesize);
       return CURLE_PARTIAL_FILE;
@@ -546,18 +508,18 @@
   sclose(data->secondarysocket);
   data->secondarysocket = -1;
 
   if(!data->bits.no_body) {  
     /* now let's see what the server says about the transfer we
        just performed: */
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     /* 226 Transfer complete, 250 Requested file action okay, completed. */
-    if(!strncmp(buf, "226", 3) && !strncmp(buf, "250", 3)) {
+    if((ftpcode != 226) && (ftpcode != 250)) {
       failf(data, "%s", buf+4);
       return CURLE_FTP_WRITE_ERROR;
     }
   }
 
   /* Send any post-transfer QUOTE strings? */
@@ -566,13 +528,13 @@
     /* Send all QUOTE strings in same order as on command-line */
     while (qitem) {
       /* Send string */
       if (qitem->data) {
         ftpsendf(data->firstsocket, conn, "%s", qitem->data);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn);
+        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if (buf[0] != '2') {
           failf(data, "QUOT string not accepted: %s",
                 qitem->data);
@@ -580,17 +542,12 @@
         }
       }
       qitem = qitem->next;
     }
   }
 
-  if(ftp->file)
-    free(ftp->file);
-  if(ftp->dir)
-    free(ftp->dir);
-
   free(ftp);
   data->proto.ftp=NULL; /* it is gone */
 
   return CURLE_OK;
 }
 
@@ -614,23 +571,24 @@
 
   struct curl_slist *qitem; /* QUOTE item */
   /* the ftp struct is already inited in ftp_connect() */
   struct FTP *ftp = data->proto.ftp;
 
   long *bytecountp = ftp->bytecountp;
+  int ftpcode; /* for ftp status */
 
   /* Send any QUOTE strings? */
   if(data->quote) {
     qitem = data->quote;
     /* Send all QUOTE strings in same order as on command-line */
     while (qitem) {
       /* Send string */
       if (qitem->data) {
         ftpsendf(data->firstsocket, conn, "%s", qitem->data);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn);
+        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if (buf[0] != '2') {
           failf(data, "QUOT string not accepted: %s",
                 qitem->data);
@@ -641,22 +599,51 @@
     }
   }
 
   /* change directory first! */
   if(ftp->dir && ftp->dir[0]) {
     ftpsendf(data->firstsocket, conn, "CWD %s", ftp->dir);
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(strncmp(buf, "250", 3)) {
+    if(ftpcode != 250) {
       failf(data, "Couldn't change to directory %s", ftp->dir);
       return CURLE_FTP_ACCESS_DENIED;
     }
   }
 
+  if(data->bits.get_filetime && ftp->file) {
+    /* we have requested to get the modified-time of the file, this is yet
+       again a grey area as the MDTM is not kosher RFC959 */
+    ftpsendf(data->firstsocket, conn, "MDTM %s", ftp->file);
+
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    if(nread < 0)
+      return CURLE_OPERATION_TIMEOUTED;
+
+    if(ftpcode == 213) {
+      /* we got a time. Format should be: "YYYYMMDDHHMMSS[.sss]" where the
+         last .sss part is optional and means fractions of a second */
+      int year, month, day, hour, minute, second;
+      if(6 == sscanf(buf+4, "%04d%02d%02d%02d%02d%02d",
+                     &year, &month, &day, &hour, &minute, &second)) {
+        /* we have a time, reformat it */
+        time_t secs=time(NULL);
+        sprintf(buf, "%04d%02d%02d %02d:%02d:%02d",
+                year, month, day, hour, minute, second);
+        /* now, convert this into a time() value: */
+        data->progress.filetime = curl_getdate(buf, &secs);
+      }
+      else {
+        infof(data, "unsupported MDTM reply format\n");
+      }
+    }
+
+  }
+
   /* If we have selected NOBODY, it means that we only want file information.
      Which in FTP can't be much more than the file size! */
   if(data->bits.no_body) {
     /* The SIZE command is _not_ RFC 959 specified, and therefor many servers
        may not support it! It is however the only way we have to get a file's
        size! */
@@ -664,50 +651,59 @@
 
     /* Some servers return different sizes for different modes, and thus we
        must set the proper type before we check the size */
     ftpsendf(data->firstsocket, conn, "TYPE %s",
              (data->bits.ftp_ascii)?"A":"I");
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(strncmp(buf, "200", 3)) {
+    if(ftpcode != 200) {
       failf(data, "Couldn't set %s mode",
             (data->bits.ftp_ascii)?"ASCII":"binary");
       return (data->bits.ftp_ascii)? CURLE_FTP_COULDNT_SET_ASCII:
         CURLE_FTP_COULDNT_SET_BINARY;
     }
 
     ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(strncmp(buf, "213", 3)) {
+    if(ftpcode != 213) {
       failf(data, "Couldn't get file size: %s", buf+4);
       return CURLE_FTP_COULDNT_GET_SIZE;
     }
     /* get the size from the ascii string: */
     filesize = atoi(buf+4);
 
-    sprintf(buf, "Content-Length: %d\n", filesize);
+    sprintf(buf, "Content-Length: %d\r\n", filesize);
+    result = client_write(data, CLIENTWRITE_BOTH, buf, 0);
+    if(result)
+      return result;
 
-    if(strlen(buf) != data->fwrite(buf, 1, strlen(buf), data->out)) {
-      failf (data, "Failed writing output");
-      return CURLE_WRITE_ERROR;
-    }
-    if(data->writeheader) {
-      /* the header is requested to be written to this file */
-      if(strlen(buf) != data->fwrite (buf, 1, strlen(buf),
-                                      data->writeheader)) {
-        failf (data, "Failed writing output");
-        return CURLE_WRITE_ERROR;
-      }
+#ifdef HAVE_STRFTIME
+    if(data->bits.get_filetime && data->progress.filetime) {
+      struct tm *tm;
+#ifdef HAVE_LOCALTIME_R
+      struct tm buffer;
+      tm = (struct tm *)localtime_r(&data->progress.filetime, &buffer);
+#else
+      tm = localtime(&data->progress.filetime);
+#endif
+      /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
+      strftime(buf, BUFSIZE-1, "Last-Modified: %a, %d %b %Y %H:%M:%S %Z\r\n",
+               tm);
+      result = client_write(data, CLIENTWRITE_BOTH, buf, 0);
+      if(result)
+        return result;
     }
+#endif
+
     return CURLE_OK;
   }
 
   /* We have chosen to use the PORT command */
   if(data->bits.ftp_use_port) {
     struct sockaddr_in sa;
@@ -770,12 +766,15 @@
       }
       else {
         failf(data, "socket(2) failed (%s)");
         free(hostdataptr);
         return CURLE_FTP_PORT_FAILED;
       }
+      if(hostdataptr)
+        /* free the memory used for name lookup */
+        free(hostdataptr);
     }
     else {
       failf(data, "could't find my own IP address (%s)", myhost);
       return CURLE_FTP_PORT_FAILED;
     }
     {
@@ -795,30 +794,30 @@
       ftpsendf(data->firstsocket, conn, "PORT %d,%d,%d,%d,%d,%d",
             ip[0], ip[1], ip[2], ip[3],
             porttouse >> 8,
             porttouse & 255);
     }
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(strncmp(buf, "200", 3)) {
+    if(ftpcode != 200) {
       failf(data, "Server does not grok PORT, try without it!");
       return CURLE_FTP_PORT_FAILED;
     }     
   }
   else { /* we use the PASV command */
 
     ftpsendf(data->firstsocket, conn, "PASV");
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(strncmp(buf, "227", 3)) {
+    if(ftpcode != 227) {
       failf(data, "Odd return code after PASV");
       return CURLE_FTP_WEIRD_PASV_REPLY;
     }
     else {
       int ip[4];
       int port[2];
@@ -858,13 +857,14 @@
         /*
          * This is a tunnel through a http proxy and we need to connect to the
          * proxy again here. We already have the name info for it since the
          * previous lookup.
          */
         he = conn->hp;
-        connectport = data->port; /* we connect to the proxy's port */
+        connectport =
+          (unsigned short)data->port; /* we connect to the proxy's port */
       }
       else {
         /* normal, direct, ftp connection */
         he = GetHost(data, newhost, &hostdataptr);
         if(!he) {
           failf(data, "Can't resolve new host %s", newhost);
@@ -983,17 +983,17 @@
   if(data->bits.upload) {
 
     /* Set type to binary (unless specified ASCII) */
     ftpsendf(data->firstsocket, conn, "TYPE %s",
           (data->bits.ftp_ascii)?"A":"I");
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(strncmp(buf, "200", 3)) {
+    if(ftpcode != 200) {
       failf(data, "Couldn't set %s mode",
             (data->bits.ftp_ascii)?"ASCII":"binary");
       return (data->bits.ftp_ascii)? CURLE_FTP_COULDNT_SET_ASCII:
         CURLE_FTP_COULDNT_SET_BINARY;
     }
 
@@ -1014,47 +1014,31 @@
       if(data->resume_from < 0 ) {
         /* we could've got a specified offset from the command line,
            but now we know we didn't */
 
         ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn);
+        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
-        if(strncmp(buf, "213", 3)) {
+        if(ftpcode != 213) {
           failf(data, "Couldn't get file size: %s", buf+4);
           return CURLE_FTP_COULDNT_GET_SIZE;
         }
 
         /* get the size from the ascii string: */
         data->resume_from = atoi(buf+4);
       }
 
       if(data->resume_from) {
         /* do we still game? */
         int passed=0;
-#if 0
-        /* Set resume file transfer offset */
-        infof(data, "Instructs server to resume from offset %d\n",
-              data->resume_from);
-
-        ftpsendf(data->firstsocket, conn, "REST %d", data->resume_from);
-
-        nread = GetLastResponse(data->firstsocket, buf, conn);
-        if(nread < 0)
-          return CURLE_OPERATION_TIMEOUTED;
-
-        if(strncmp(buf, "350", 3)) {
-          failf(data, "Couldn't use REST: %s", buf+4);
-          return CURLE_FTP_COULDNT_USE_REST;
-        }
-#else
         /* enable append instead */
         data->bits.ftp_append = 1;
-#endif
+
         /* Now, let's read off the proper amount of bytes from the
            input. If we knew it was a proper file we could've just
            fseek()ed but we only have a stream here */
         do {
           int readthisamountnow = (data->resume_from - passed);
           int actuallyread;
@@ -1091,17 +1075,17 @@
     if(data->bits.ftp_append)
       /* we append onto the file instead of rewriting it */
       ftpsendf(data->firstsocket, conn, "APPE %s", ftp->file);
     else
       ftpsendf(data->firstsocket, conn, "STOR %s", ftp->file);
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(atoi(buf)>=400) {
+    if(ftpcode>=400) {
       failf(data, "Failed FTP upload:%s", buf+3);
       /* oops, we never close the sockets! */
       return CURLE_FTP_COULDNT_STOR_FILE;
     }
 
     if(data->bits.ftp_use_port) {
@@ -1113,15 +1097,13 @@
     *bytecountp=0;
 
     /* When we know we're uploading a specified file, we can get the file
        size prior to the actual upload. */
 
     pgrsSetUploadSize(data, data->infilesize);
-#if 0
-    ProgressInit(data, data->infilesize);
-#endif
+
     result = Transfer(conn, -1, -1, FALSE, NULL, /* no download */
                       data->secondarysocket, bytecountp);
     if(result)
       return result;
       
   }
@@ -1163,31 +1145,27 @@
         data->resume_from = from;
         infof(data, "FTP RANGE from %d getting %d bytes\n", from, data->maxdownload);
       }
       infof(data, "range-download from %d to %d, totally %d bytes\n",
             from, to, totalsize);
     }
-#if 0
-    if(!ppath[0])
-      /* make sure this becomes a valid name */
-      ppath="./";
-#endif
+
     if((data->bits.ftp_list_only) || !ftp->file) {
       /* The specified path ends with a slash, and therefore we think this
          is a directory that is requested, use LIST. But before that we
          need to set ASCII transfer mode. */
       dirlist = TRUE;
 
       /* Set type to ASCII */
       ftpsendf(data->firstsocket, conn, "TYPE A");
 	
-      nread = GetLastResponse(data->firstsocket, buf, conn);
+      nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 	
-      if(strncmp(buf, "200", 3)) {
+      if(ftpcode != 200) {
         failf(data, "Couldn't set ascii mode");
         return CURLE_FTP_COULDNT_SET_ASCII;
       }
 
       /* if this output is to be machine-parsed, the NLST command will be
          better used since the LIST command output is not specified or
@@ -1199,17 +1177,17 @@
     }
     else {
       /* Set type to binary (unless specified ASCII) */
       ftpsendf(data->firstsocket, conn, "TYPE %s",
                (data->bits.ftp_ascii)?"A":"I");
 
-      nread = GetLastResponse(data->firstsocket, buf, conn);
+      nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 
-      if(strncmp(buf, "200", 3)) {
+      if(ftpcode != 200) {
         failf(data, "Couldn't set %s mode",
               (data->bits.ftp_ascii)?"ASCII":"binary");
         return (data->bits.ftp_ascii)? CURLE_FTP_COULDNT_SET_ASCII:
           CURLE_FTP_COULDNT_SET_BINARY;
       }
 
@@ -1220,17 +1198,17 @@
          * We start with trying to use the SIZE command to figure out the size
          * of the file we're gonna get. If we can get the size, this is by far
          * the best way to know if we're trying to resume beyond the EOF.  */
 
         ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn);
+        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
-        if(strncmp(buf, "213", 3)) {
+        if(ftpcode != 213) {
           infof(data, "server doesn't support SIZE: %s", buf+4);
           /* We couldn't get the size and therefore we can't know if there
              really is a part of the file left to get, although the server
              will just close the connection when we start the connection so it
              won't cause us any harm, just not make us exit as nicely. */
         }
@@ -1264,30 +1242,30 @@
         /* Set resume file transfer offset */
         infof(data, "Instructs server to resume from offset %d\n",
               data->resume_from);
 
         ftpsendf(data->firstsocket, conn, "REST %d", data->resume_from);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn);
+        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
-        if(strncmp(buf, "350", 3)) {
+        if(ftpcode != 350) {
           failf(data, "Couldn't use REST: %s", buf+4);
           return CURLE_FTP_COULDNT_USE_REST;
         }
       }
 
       ftpsendf(data->firstsocket, conn, "RETR %s", ftp->file);
     }
 
-    nread = GetLastResponse(data->firstsocket, buf, conn);
+    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
-    if(!strncmp(buf, "150", 3) || !strncmp(buf, "125", 3)) {
+    if((ftpcode == 150) || (ftpcode == 125)) {
 
       /*
         A;
         150 Opening BINARY mode data connection for /etc/passwd (2241
         bytes).  (ok, the file is being transfered)
 	
@@ -1336,31 +1314,16 @@
           if(bytes++) {
             /* get the number! */
             size = atoi(bytes);
           }
             
         }
-#if 0
-        if(2 != sscanf(buf, "%*[^(](%d bytes%c", &size, &paren))
-          size=-1;
-#endif
       }
       else if(downloadsize > -1)
         size = downloadsize;
 
-#if 0
-      if((size > -1) && (data->resume_from>0)) {
-        size -= data->resume_from;
-        if(size <= 0) {
-          failf(data, "Offset (%d) was beyond file size (%d)",
-                data->resume_from, data->resume_from+size);
-          return CURLE_PARTIAL_FILE;
-        }
-      }
-#endif
-
       if(data->bits.ftp_use_port) {
         result = AllowServerConnect(data, portsock);
         if( result )
           return result;
       }
 
@@ -1399,19 +1362,21 @@
   ftp = data->proto.ftp;
 
   /* We split the path into dir and file parts *before* we URLdecode
      it */
   ftp->file = strrchr(conn->ppath, '/');
   if(ftp->file) {
+    if(ftp->file != conn->ppath)
+      dirlength=ftp->file-conn->ppath; /* don't count the traling slash */
+
     ftp->file++; /* point to the first letter in the file name part or
                     remain NULL */
   }
   else {
     ftp->file = conn->ppath; /* there's only a file part */
   }
-  dirlength=ftp->file-conn->ppath;
 
   if(*ftp->file) {
     ftp->file = curl_unescape(ftp->file, 0);
     if(NULL == ftp->file) {
       failf(data, "no memory");
       return CURLE_OUT_OF_MEMORY;
@@ -1433,9 +1398,17 @@
   }
   else
     ftp->dir = NULL;
 
   retcode = _ftp(conn);
 
+  /* clean up here, success or error doesn't matter */
+  if(ftp->file)
+    free(ftp->file);
+  if(ftp->dir)
+    free(ftp->dir);
+
+  ftp->file = ftp->dir = NULL; /* zero */
+
   return retcode;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/getinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/getinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/getinfo.c	2000-11-06 23:31:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/getinfo.c	2000-11-22 21:50:17.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/getinfo.c,v $
- * $Revision: 1.4 $
- * $Date: 2000/11/06 15:31:10 $
+ * $Revision: 1.5 $
+ * $Date: 2000/11/22 13:50:17 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -81,12 +81,15 @@
   case CURLINFO_EFFECTIVE_URL:
     *param_charp = data->url?data->url:"";
     break;
   case CURLINFO_HTTP_CODE:
     *param_longp = data->progress.httpcode;
     break;
+  case CURLINFO_FILETIME:
+    *param_longp = data->progress.filetime;
+    break;
   case CURLINFO_HEADER_SIZE:
     *param_longp = data->header_size;
     break;
   case CURLINFO_REQUEST_SIZE:
     *param_longp = data->request_size;
     break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/highlevel.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/highlevel.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/highlevel.c	2000-11-14 02:23:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/highlevel.c	2000-11-28 17:41:01.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/highlevel.c,v $
- * $Revision: 1.20 $
- * $Date: 2000/11/13 18:23:21 $
+ * $Revision: 1.25 $
+ * $Date: 2000/11/28 09:41:01 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -146,12 +146,13 @@
   /* for the low speed checks: */
   CURLcode urg;
   time_t timeofdoc=0;
   long bodywrites=0;
 
   char newurl[URL_MAX_LENGTH];		/* buffer for Location: URL */
+  int writetype;
 
   /* the highest fd we use + 1 */
   struct UrlData *data;
   struct connectdata *conn = (struct connectdata *)c_conn;
   char *buf;
   int maxfd;
@@ -333,30 +334,21 @@
                 pgrsSetDownloadSize(data, conn->size);
 
                 header = FALSE;	/* no more header to parse! */
 
                 /* now, only output this if the header AND body are requested:
                  */
-                if (data->bits.http_include_header) {
-                  if((p - data->headerbuff) !=
-                     data->fwrite (data->headerbuff, 1,
-                                   p - data->headerbuff, data->out)) {
-                    failf (data, "Failed writing output");
-                    return CURLE_WRITE_ERROR;
-                  }
-                }
-                if(data->writeheader) {
-                  /* obviously, the header is requested to be written to
-                     this file: */
-                  if((p - data->headerbuff) !=
-                     data->fwrite (data->headerbuff, 1, p - data->headerbuff,
-                                   data->writeheader)) {
-                    failf (data, "Failed writing output");
-                    return CURLE_WRITE_ERROR;
-                  }
-                }
+                writetype = CLIENTWRITE_HEADER;
+                if (data->bits.http_include_header)
+                  writetype |= CLIENTWRITE_BODY;
+
+                urg = client_write(data, writetype, data->headerbuff,
+                                   p - data->headerbuff);
+                if(urg)
+                  return urg;
+
                 data->header_size += p - data->headerbuff;
                 break;		/* exit header line loop */
               }
               
               if (!headerline++) {
                 /* This is the first header, it MUST be the error code line
@@ -400,40 +392,36 @@
               else if(data->cookies &&
                       strnequal("Set-Cookie: ", p, 11)) {
                 cookie_add(data->cookies, TRUE, &p[12]);
               }
               else if(strnequal("Last-Modified:", p,
                                 strlen("Last-Modified:")) &&
-                      data->timecondition) {
+                      (data->timecondition || data->bits.get_filetime) ) {
                 time_t secs=time(NULL);
                 timeofdoc = curl_getdate(p+strlen("Last-Modified:"), &secs);
+                if(data->bits.get_filetime)
+                  data->progress.filetime = timeofdoc;
               }
               else if ((code >= 300 && code < 400) &&
                        (data->bits.http_follow_location) &&
                        strnequal("Location", p, 8) &&
                        sscanf (p+8, ": %" URL_MAX_LENGTH_TXT "s",
                                newurl)) {
                 /* this is the URL that the server advices us to get
                    instead */
                 data->newurl = strdup (newurl);
               }
-              
-              if (data->bits.http_include_header) {
-                if(hbuflen != data->fwrite (p, 1, hbuflen, data->out)) {
-                  failf (data, "Failed writing output");
-                  return CURLE_WRITE_ERROR;
-                }
-              }
-              if(data->writeheader) {
-                /* the header is requested to be written to this file */
-                if(hbuflen != data->fwrite (p, 1, hbuflen,
-                                            data->writeheader)) {
-                  failf (data, "Failed writing output");
-                  return CURLE_WRITE_ERROR;
-                }
-              }
+
+              writetype = CLIENTWRITE_HEADER;
+              if (data->bits.http_include_header)
+                writetype |= CLIENTWRITE_BODY;
+
+              urg = client_write(data, writetype, p, hbuflen);
+              if(urg)
+                return urg;
+
               data->header_size += hbuflen;
               
               /* reset hbufp pointer && hbuflen */
               hbufp = data->headerbuff;
               hbuflen = 0;
             }
@@ -512,16 +500,15 @@
             }
 
             bytecount += nread;
 
             pgrsSetDownloadCounter(data, (double)bytecount);
             
-            if (nread != data->fwrite (str, 1, nread, data->out)) {
-              failf (data, "Failed writing output");
-              return CURLE_WRITE_ERROR;
-            }
+            urg = client_write(data, CLIENTWRITE_BODY, str, nread);
+            if(urg)
+              return urg;
 
           } /* if (! header and data to read ) */
         } /* if( read from socket ) */
 
         if((keepon & KEEP_WRITE) && FD_ISSET(conn->writesockfd, &writefd)) {
           /* write */
@@ -617,13 +604,13 @@
 typedef int (*func_T)(void);
 
 CURLcode curl_transfer(CURL *curl)
 {
   CURLcode res;
   struct UrlData *data = curl;
-  struct connectdata *c_connect;
+  struct connectdata *c_connect=NULL;
 
   pgrsStartNow(data);
 
   do {
     pgrsTime(data, TIMER_STARTSINGLE);
     res = curl_connect(curl, (CURLconnect **)&c_connect);
@@ -634,17 +621,23 @@
         if(res == CURLE_OK)
           res = curl_done(c_connect);
       }
 
       if((res == CURLE_OK) && data->newurl) {
         /* Location: redirect
-
+ 
            This is assumed to happen for HTTP(S) only!
-         */
+        */
         char prot[16];
         char path[URL_MAX_LENGTH];
+	if (data->maxredirs && (data->followlocation >= data->maxredirs)) {
+	  failf(data,"Maximum (%d) redirects followed", data->maxredirs);
+          curl_disconnect(c_connect);
+          res=CURLE_TOO_MANY_REDIRECTS;
+	  break;
+	}
 
         /* mark the next request as a followed location: */
         data->bits.this_is_a_follow = TRUE;
 
         data->followlocation++; /* count location-followers */
 
@@ -722,12 +715,15 @@
         }
         else {
           /* This was an absolute URL, clear the port number! */
           /* TBD: set the port with curl_setopt() */
           data->port = 0;
         }
+
+        if(data->bits.urlstringalloc)
+          free(data->url);
       
         /* TBD: set the URL with curl_setopt() */
         data->url = data->newurl;
         data->newurl = NULL; /* don't show! */
         data->bits.urlstringalloc = TRUE; /* the URL is allocated */
 
@@ -748,15 +744,9 @@
 
   } while(1); /* loop if Location: */
 
   if(data->newurl)
     free(data->newurl);
 
-#if 0
-  if((CURLE_OK == res) && data->writeinfo) {
-    /* Time to output some info to stdout */
-    WriteOut(data);
-  }
-#endif
   return res;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/hostip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/hostip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/hostip.c	2000-10-09 19:12:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/hostip.c	2000-11-21 23:35:45.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/hostip.c,v $
- * $Revision: 1.16 $
- * $Date: 2000/10/09 11:12:34 $
+ * $Revision: 1.18 $
+ * $Date: 2000/11/21 15:35:45 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -108,13 +108,13 @@
 struct hostent *GetHost(struct UrlData *data,
                         char *hostname,
                         char **bufp)
 {
   struct hostent *h = NULL;
   unsigned long in;
-  int ret;
+  int ret; /* this variable is unused on several platforms but used on some */
 
 #define CURL_NAMELOOKUP_SIZE 9000
 
   /* Allocate enough memory to hold the full name information structs and
    * everything. OSF1 is known to require at least 8872 bytes. The buffer
    * required for storing all possible aliases and IP numbers is according to
@@ -184,17 +184,19 @@
     if(ret)
 #endif
       {
       infof(data, "gethostbyname_r(2) failed for %s\n", hostname);
       h = NULL; /* set return code to NULL */
       free(buf);
+      *bufp=NULL;
     }
 #else
   else {
     if ((h = gethostbyname(hostname)) == NULL ) {
       infof(data, "gethostbyname(2) failed for %s\n", hostname);
       free(buf);
+      *bufp=NULL;
     }
 #endif
   }
   return (h);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/http.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/http.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/http.c	2000-11-13 19:29:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/http.c	2000-11-21 17:31:03.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/http.c,v $
- * $Revision: 1.34 $
- * $Date: 2000/11/13 11:29:32 $
+ * $Revision: 1.37 $
+ * $Date: 2000/11/21 09:31:03 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -324,13 +324,13 @@
                         host,
                         ppath,
                         conn->protocol&PROT_HTTPS?TRUE:FALSE);
   }
   if ((data->bits.httpproxy) && !(conn->protocol&PROT_HTTPS))  {
     /* The path sent to the proxy is in fact the entire URL */
-    strncpy(ppath, data->url, URL_MAX_LENGTH-1);
+    ppath = data->url;
   }
   if(data->bits.http_formpost) {
     /* we must build the whole darned post sequence first, so that we have
        a size of the whole shebang before we start to send it */
     http->sendit = getFormData(data->httppost, &http->postsize);
   }
@@ -387,12 +387,13 @@
                 http->p_accept?http->p_accept:"",
                 (data->bits.http_set_referer && data->ptr_ref)?data->ptr_ref:"" /* Referer: <data> <CRLF> */
                 );
 
     if(co) {
       int count=0;
+      struct Cookie *store=co;
       /* now loop through all cookies that matched */
       while(co) {
         if(co->value && strlen(co->value)) {
           if(0 == count) {
             add_bufferf(req_buffer, "Cookie: ");
           }
@@ -402,13 +403,13 @@
         }
         co = co->next; /* next cookie please */
       }
       if(count) {
         add_buffer(req_buffer, "\r\n", 2);
       }
-      cookie_freelist(co); /* free the cookie list */
+      cookie_freelist(store); /* free the cookie list */
       co=NULL;
     }
 
     if(data->timecondition) {
       struct tm *thistime;
 
@@ -451,13 +452,13 @@
     while(headers) {
       char *ptr = strchr(headers->data, ':');
       if(ptr) {
         /* we require a colon for this to be a true header */
 
         ptr++; /* pass the colon */
-        while(*ptr && isspace(*ptr))
+        while(*ptr && isspace((int)*ptr))
           ptr++;
 
         if(*ptr) {
           /* only send this if the contents was non-blank */
 
           add_bufferf(req_buffer, "%s\r\n", headers->data);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/ldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/ldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/ldap.c	2000-08-24 22:26:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/ldap.c	2000-11-22 20:55:24.000000000 +0800
@@ -26,14 +26,14 @@
  * Contributor(s):
  *  Bjørn Reese <breese@mail1.stofanet.dk>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/ldap.c,v $
- * $Revision: 1.8 $
- * $Date: 2000/08/24 14:26:33 $
+ * $Revision: 1.9 $
+ * $Date: 2000/11/22 12:55:24 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -131,14 +131,13 @@
   return func;
 }
 
 static int WriteProc(void *param, char *text, int len)
 {
   struct UrlData *data = (struct UrlData *)param;
-
-  data->fwrite(text, 1, strlen(text), data->out);
+  client_write(data, CLIENTWRITE_BODY, text, 0);
   return 0;
 }
 
 CURLcode ldap_done(struct connectdata *conn)
 {
   return CURLE_OK;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/Makefile.am	2000-10-16 20:43:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/Makefile.am	2000-12-01 06:43:29.000000000 +0800
@@ -1,19 +1,49 @@
 #
-# $Id: Makefile.am,v 1.12 2000/10/09 11:24:18 bagder Exp $
+# $Id: Makefile.am,v 1.13 2000/11/30 22:22:08 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign
 
 lib_LTLIBRARIES = libcurl.la
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
 
 INCLUDES = -I$(top_srcdir)/include
 
+
+libcurl_la_LDFLAGS = -version-info 1:0:0
+# This flag accepts an argument of the form current[:revision[:age]]. So,
+# passing -version-info 3:12:1 sets current to 3, revision to 12, and age to
+# 1.
+#
+# If either revision or age are omitted, they default to 0. Also note that age
+# must be less than or equal to the current interface number.
+#
+# Here are a set of rules to help you update your library version information: 
+#
+# 1.Start with version information of 0:0:0 for each libtool library.
+#
+# 2.Update the version information only immediately before a public release of
+# your software. More frequent updates are unnecessary, and only guarantee
+# that the current interface number gets larger faster.
+#
+# 3.If the library source code has changed at all since the last update, then
+# increment revision (c:r:a becomes c:r+1:a).
+#
+# 4.If any interfaces have been added, removed, or changed since the last
+# update, increment current, and set revision to 0.
+#
+# 5.If any interfaces have been added since the last public release, then
+# increment age.
+#
+# 6.If any interfaces have been removed since the last public release, then
+# set age to 0.
+#
+
 libcurl_la_SOURCES = \
 arpa_telnet.h  file.c         getpass.h      netrc.h        timeval.c \
 base64.c       file.h         hostip.c       progress.c     timeval.h \
 base64.h       formdata.c     hostip.h       progress.h     \
 cookie.c       formdata.h     http.c         sendf.c        \
 cookie.h       ftp.c          http.h         sendf.h        url.c \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/Makefile.in	2000-11-15 16:22:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/Makefile.in	2000-12-04 16:39:15.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.12 2000/10/09 11:24:18 bagder Exp $
+# $Id: Makefile.am,v 1.13 2000/11/30 22:22:08 bagder Exp $
 #
 
 
 SHELL = /bin/sh
 
 srcdir = @srcdir@
@@ -83,25 +83,53 @@
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
 
 INCLUDES = -I$(top_srcdir)/include
 
+libcurl_la_LDFLAGS = -version-info 1:0:0
+# This flag accepts an argument of the form current[:revision[:age]]. So,
+# passing -version-info 3:12:1 sets current to 3, revision to 12, and age to
+# 1.
+#
+# If either revision or age are omitted, they default to 0. Also note that age
+# must be less than or equal to the current interface number.
+#
+# Here are a set of rules to help you update your library version information: 
+#
+# 1.Start with version information of 0:0:0 for each libtool library.
+#
+# 2.Update the version information only immediately before a public release of
+# your software. More frequent updates are unnecessary, and only guarantee
+# that the current interface number gets larger faster.
+#
+# 3.If the library source code has changed at all since the last update, then
+# increment revision (c:r:a becomes c:r+1:a).
+#
+# 4.If any interfaces have been added, removed, or changed since the last
+# update, increment current, and set revision to 0.
+#
+# 5.If any interfaces have been added since the last public release, then
+# increment age.
+#
+# 6.If any interfaces have been removed since the last public release, then
+# set age to 0.
+#
+
 libcurl_la_SOURCES =  arpa_telnet.h  file.c         getpass.h      netrc.h        timeval.c base64.c       file.h         hostip.c       progress.c     timeval.h base64.h       formdata.c     hostip.h       progress.h     cookie.c       formdata.h     http.c         sendf.c        cookie.h       ftp.c          http.h         sendf.h        url.c dict.c         ftp.h          if2ip.c        speedcheck.c   url.h dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h download.c     getdate.h      ldap.c         ssluse.c       version.c download.h     getenv.c       ldap.h         ssluse.h       escape.c       getenv.h       mprintf.c      telnet.c       escape.h       getpass.c      netrc.c        telnet.h       getinfo.c highlevel.c strequal.c strequal.h easy.c security.h security.c krb4.c memdebug.c memdebug.h
 
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h ../src/config.h
 CONFIG_CLEAN_FILES = 
 LTLIBRARIES =  $(lib_LTLIBRARIES)
 
 
 DEFS = @DEFS@ -I. -I$(srcdir) -I.. -I../src
 CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
-libcurl_la_LDFLAGS = 
 libcurl_la_LIBADD = 
 libcurl_la_OBJECTS =  file.lo timeval.lo base64.lo hostip.lo progress.lo \
 formdata.lo cookie.lo http.lo sendf.lo ftp.lo url.lo dict.lo if2ip.lo \
 speedcheck.lo getdate.lo download.lo ldap.lo ssluse.lo version.lo \
 getenv.lo escape.lo mprintf.lo telnet.lo getpass.lo netrc.lo getinfo.lo \
 highlevel.lo strequal.lo easy.lo security.lo krb4.lo memdebug.lo
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/Makefile.vc6	2000-08-24 14:23:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/Makefile.vc6	2000-12-01 04:06:16.000000000 +0800
@@ -1,34 +1,36 @@
 #############################################################
 ## Makefile for building libcurl.lib with MSVC6
 ## Use: nmake -f makefile.vc6 [release | release-ssl | debug]
 ##      (default is release)
 ##
 ## Comments to: Troy Engel <tengel@sonic.net>
+## Updated by: Craig Davison <cd@securityfocus.com>
 
-PROGRAM_NAME = libcurl.lib
-OPENSSL_PATH = ../../openssl-0.9.3a
+PROGRAM_NAME = libcurl.lib
+PROGRAM_NAME_DEBUG = libcurld.lib
+OPENSSL_PATH = ../../openssl-0.9.6
 
 ########################################################
 ## Nothing more to do below this line!
 
 ## Release
-CCR = cl.exe /ML /O2 /D "NDEBUG"
-LINKR = link.exe -lib
+CCR = cl.exe /MD /O2 /D "NDEBUG"
+LINKR = link.exe -lib /out:$(PROGRAM_NAME)
 
 ## Debug
-CCD = cl.exe /MLd /Gm /ZI /Od /D "_DEBUG" /GZ
-LINKD = link.exe -lib
+CCD = cl.exe /MDd /Gm /ZI /Od /D "_DEBUG" /GZ
+LINKD = link.exe -lib /out:$(PROGRAM_NAME_DEBUG)
 
 ## SSL Release
-CCRS = cl.exe /ML /O2 /D "NDEBUG" /D "USE_SSLEAY" /I "$(OPENSSL_PATH)/inc32" /I "$(OPENSSL_PATH)/inc32/openssl"
-LINKRS = link.exe -lib /LIBPATH:$(OPENSSL_PATH)/out32dll
+CCRS = cl.exe /MD /O2 /D "NDEBUG" /D "USE_SSLEAY" /I "$(OPENSSL_PATH)/include" /I "$(OPENSSL_PATH)/include/openssl"
+LINKRS = link.exe -lib /out:$(PROGRAM_NAME) /LIBPATH:$(OPENSSL_PATH)/out32dll
 
 CFLAGS = /I "../include" /nologo /W3 /GX /D "WIN32" /D "VC6" /D "_MBCS" /D "_LIB" /YX /FD /c /D "MSDOS"
-LFLAGS = /nologo /out:$(PROGRAM_NAME)
-LINKLIBS = kernel32.lib wsock32.lib
+LFLAGS = /nologo
+LINKLIBS = wsock32.lib
 LINKSLIBS = libeay32.lib ssleay32.lib RSAglue.lib
 
 RELEASE_OBJS= \
 	base64r.obj \
 	cookier.obj \
 	downloadr.obj \
@@ -50,27 +52,27 @@
 	sendfr.obj \
 	speedcheckr.obj \
 	ssluser.obj \
 	timevalr.obj \
 	urlr.obj \
 	filer.obj \
-    writeoutr.obj \
+	getinfor.obj \
 	versionr.obj \
-    easyr.obj \
-    highlevelr.obj \
-    strequalr.obj
+	easyr.obj \
+	highlevelr.obj \
+	strequalr.obj
 
 DEBUG_OBJS= \
 	base64d.obj \
 	cookied.obj \
 	downloadd.obj \
 	escaped.obj \
 	formdatad.obj \
 	ftpd.obj \
 	httpd.obj \
-    ldapd.obj \
+	ldapd.obj \
 	dictd.obj \
 	telnetd.obj \
 	getdated.obj \
 	getenvd.obj \
 	getpassd.obj \
 	hostipd.obj \
@@ -81,27 +83,27 @@
 	sendfd.obj \
 	speedcheckd.obj \
 	sslused.obj \
 	timevald.obj \
 	urld.obj \
 	filed.obj \
-    writeoutd.obj \
-    versiond.obj  \
-    easyd.obj \
-    highleveld.obj \
-    strequald.obj
+	getinfod.obj \
+	versiond.obj  \
+	easyd.obj \
+	highleveld.obj \
+	strequald.obj
 
 RELEASE_SSL_OBJS= \
 	base64rs.obj \
 	cookiers.obj \
 	downloadrs.obj \
 	escapers.obj \
 	formdatars.obj \
 	ftprs.obj \
 	httprs.obj \
-    ldaprs.obj \
+	ldaprs.obj \
 	dictrs.obj \
 	telnetrs.obj \
 	getdaters.obj \
 	getenvrs.obj \
 	getpassrs.obj \
 	hostiprs.obj \
@@ -112,27 +114,27 @@
 	sendfrs.obj \
 	speedcheckrs.obj \
 	sslusers.obj \
 	timevalrs.obj \
 	urlrs.obj \
 	filers.obj \
-    writeouts.obj \
+	getinfors.obj \
 	versionrs.obj \
-    easyrs.obj \
-    highlevelrs.obj \
-    strequalrs.obj
-
+	easyrs.obj \
+	highlevelrs.obj \
+	strequalrs.obj
+
 LINK_OBJS= \
 	base64.obj \
 	cookie.obj \
 	download.obj \
 	escape.obj \
 	formdata.obj \
 	ftp.obj \
 	http.obj \
-    ldap.obj \
+	ldap.obj \
 	dict.obj \
 	telnet.obj \
 	getdate.obj \
 	getenv.obj \
 	getpass.obj \
 	hostip.obj \
@@ -143,17 +145,17 @@
 	sendf.obj \
 	speedcheck.obj \
 	ssluse.obj \
 	timeval.obj \
 	url.obj \
 	file.obj \
-    writeout.obj \
+	getinfo.obj \
 	version.obj \
-    easy.obj \
-    highlevel.obj \
-    strequal.obj
+	easy.obj \
+	highlevel.obj \
+	strequal.obj
 
 all : release
 
 release: $(RELEASE_OBJS)
 	$(LINKR) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
 
@@ -210,14 +211,14 @@
 timevalr.obj: timeval.c
 	$(CCR) $(CFLAGS) timeval.c
 urlr.obj: url.c
 	$(CCR) $(CFLAGS) url.c
 filer.obj: file.c
 	$(CCR) $(CFLAGS) file.c
-writeoutr.obj: writeout.c
-        $(CCR) $(CFLAGS) writeout.c
+getinfor.obj: getinfo.c
+	$(CCR) $(CFLAGS) getinfo.c
 versionr.obj: version.c
 	$(CCR) $(CFLAGS) version.c
 easyr.obj: easy.c
 	$(CCR) $(CFLAGS) easy.c
 highlevelr.obj: highlevel.c
 	$(CCR) $(CFLAGS) highlevel.c
@@ -237,13 +238,13 @@
 	$(CCD) $(CFLAGS) formdata.c
 ftpd.obj: ftp.c
 	$(CCD) $(CFLAGS) ftp.c
 httpd.obj: http.c
 	$(CCD) $(CFLAGS) http.c
 ldapd.obj: ldap.c
-	$(CCR) $(CFLAGS) ldap.c
+	$(CCD) $(CFLAGS) ldap.c
 dictd.obj: dict.c
 	$(CCD) $(CFLAGS) dict.c
 telnetd.obj: telnet.c
 	$(CCD) $(CFLAGS) telnet.c
 getdated.obj: getdate.c
 	$(CCD) $(CFLAGS) getdate.c
@@ -270,22 +271,22 @@
 timevald.obj: timeval.c
 	$(CCD) $(CFLAGS) timeval.c
 urld.obj: url.c
 	$(CCD) $(CFLAGS) url.c
 filed.obj: file.c
 	$(CCD) $(CFLAGS) file.c
-writeoutd.obj: writeout.c
-        $(CCR) $(CFLAGS) writeout.c
+getinfod.obj: getinfo.c
+	$(CCD) $(CFLAGS) getinfo.c
 versiond.obj: version.c
 	$(CCD) $(CFLAGS) version.c
 easyd.obj: easy.c
-	$(CCR) $(CFLAGS) easy.c
+	$(CCD) $(CFLAGS) easy.c
 highleveld.obj: highlevel.c
-	$(CCR) $(CFLAGS) highlevel.c
+	$(CCD) $(CFLAGS) highlevel.c
 strequald.obj: strequal.c
-	$(CCR) $(CFLAGS) strequal.c
+	$(CCD) $(CFLAGS) strequal.c
 
 
 ## Release SSL
 base64rs.obj: base64.c
 	$(CCRS) $(CFLAGS) base64.c
 cookiers.obj: cookie.c
@@ -298,13 +299,13 @@
 	$(CCRS) $(CFLAGS) formdata.c
 ftprs.obj: ftp.c
 	$(CCRS) $(CFLAGS) ftp.c
 httprs.obj: http.c
 	$(CCRS) $(CFLAGS) http.c
 ldaprs.obj: ldap.c
-	$(CCR) $(CFLAGS) ldap.c
+	$(CCRS) $(CFLAGS) ldap.c
 dictrs.obj: dict.c
 	$(CCRS) $(CFLAGS) dict.c
 telnetrs.obj: telnet.c
 	$(CCRS) $(CFLAGS) telnet.c
 getdaters.obj: getdate.c
 	$(CCRS) $(CFLAGS) getdate.c
@@ -331,23 +332,24 @@
 timevalrs.obj: timeval.c
 	$(CCRS) $(CFLAGS) timeval.c
 urlrs.obj: url.c
 	$(CCRS) $(CFLAGS) url.c
 filers.obj: file.c
 	$(CCRS) $(CFLAGS) file.c
-writeoutrs.obj: writeout.c
-        $(CCR) $(CFLAGS) writeout.c
+getinfors.obj: getinfo.c
+	$(CCRS) $(CFLAGS) getinfo.c
 versionrs.obj: version.c
 	$(CCRS) $(CFLAGS) version.c
 easyrs.obj: easy.c
-	$(CCR) $(CFLAGS) easy.c
+	$(CCRS) $(CFLAGS) easy.c
 highlevelrs.obj: highlevel.c
-	$(CCR) $(CFLAGS) highlevel.c
+	$(CCRS) $(CFLAGS) highlevel.c
 strequalrs.obj: strequal.c
-	$(CCR) $(CFLAGS) strequal.c
-
+	$(CCRS) $(CFLAGS) strequal.c
+
+
 clean:
 	-@erase *.obj
 	-@erase vc60.idb
 	-@erase vc60.pch
 
 distrib: clean
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/memdebug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/memdebug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/memdebug.c	2000-10-25 15:41:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/memdebug.c	2000-11-22 03:38:12.000000000 +0800
@@ -27,27 +27,31 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/memdebug.c,v $
- * $Revision: 1.2 $
- * $Date: 2000/10/25 07:41:11 $
+ * $Revision: 1.5 $
+ * $Date: 2000/11/21 19:05:26 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
+
+#define _MPRINTF_REPLACE
+#include <curl/mprintf.h>
 #include "urldata.h"
 #include <stdio.h>
 #include <string.h>
+#include <stdlib.h>
 
 /*
  * Note that these debug functions are very simple and they are meant to
  * remain so. For advanced analysis, record a log file and write perl scripts
  * to analyze them!
  *
@@ -70,14 +74,23 @@
           source, line, size, mem);
   return mem;
 }
 
 char *curl_dostrdup(char *str, int line, char *source)
 {
-  char *mem=(strdup)(str);
-  size_t len=strlen(str)+1;
+  char *mem;
+  size_t len;
+  
+  if(NULL ==str) {
+    fprintf(stderr, "ILLEGAL strdup() on NULL at %s:%d\n",
+            source, line);
+    exit(2);
+  }
+
+  mem=(strdup)(str);
+  len=strlen(str)+1;
   fprintf(logfile?logfile:stderr, "MEM %s:%d strdup(%p) (%d) = %p\n",
           source, line, str, len, mem);
   return mem;
 }
 
 void *curl_dorealloc(void *ptr, size_t size, int line, char *source)
@@ -87,12 +100,19 @@
           source, line, ptr, size, mem);
   return mem;
 }
 
 void curl_dofree(void *ptr, int line, char *source)
 {
+  if(NULL == ptr) {
+    fprintf(stderr, "ILLEGAL free() on NULL at %s:%d\n",
+            source, line);
+    exit(2);
+  }
+
   (free)(ptr);
+
   fprintf(logfile?logfile:stderr, "MEM %s:%d free(%p)\n",
           source, line, ptr);
 }
 
 #endif /* MALLOCDEBUG */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/mprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/mprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/mprintf.c	2000-10-09 19:12:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/mprintf.c	2000-11-21 21:18:30.000000000 +0800
@@ -1,9 +1,9 @@
 /****************************************************************************
  *
- * $Id: mprintf.c,v 1.3 2000/10/09 11:12:34 bagder Exp $
+ * $Id: mprintf.c,v 1.5 2000/11/21 13:18:30 bagder Exp $
  *
  *************************************************************************
  *
  * Purpose:
  *  A merge of Bjorn Reese's format() function and Daniel's dsprintf()
  *  1.0. A full blooded printf() clone with full support for <num>$
@@ -80,13 +80,13 @@
  * - Fixed space padding (i.e %d was extra padded previously)
  * - long long output is supported
  * - alternate output is done correct like in %#08x
  *
  ****************************************************************************/
 
-static const char rcsid[] = "@(#)$Id: mprintf.c,v 1.3 2000/10/09 11:12:34 bagder Exp $";
+static const char rcsid[] = "@(#)$Id: mprintf.c,v 1.5 2000/11/21 13:18:30 bagder Exp $";
 
 /*
  * To test:
  *
  * Use WIDTH, PRECISION and NUMBERED ARGUMENT combined.
  */
@@ -998,56 +998,22 @@
     f = *end++; /* goto end of %-code */
 
   }
   return done;
 }
 
-static int StoreNonPrintable(int output, struct nsprintf *infop)
-{
-  /* If the character isn't printable then we convert it */
-  char work[64], *w;
-  int num = output;
-
-  w = &work[sizeof(work)];
-  *(--w) = (char)0;
-  for(; num > 0; num /= 10) {
-    *(--w) = lower_digits[num % 10];
-  }
-  if (infop->length + strlen(w) + 1 < infop->max)
-    {
-      infop->buffer[0] = '\\';
-      infop->buffer++;
-      infop->length++;
-      for (; *w; w++)
-	{
-	  infop->buffer[0] = *w;
-	  infop->buffer++;
-	  infop->length++;
-	}
-      return output;
-    }
-  return -1;
-}
-
 /* fputc() look-alike */
 static int addbyter(int output, FILE *data)
 {
   struct nsprintf *infop=(struct nsprintf *)data;
  
   if(infop->length < infop->max) {
     /* only do this if we haven't reached max length yet */
-    if (isprint(output) || isspace(output))
-      {
-	infop->buffer[0] = (char)output; /* store */
-	infop->buffer++; /* increase pointer */
-	infop->length++; /* we are now one byte larger */
-      }
-    else
-      {
-	return StoreNonPrintable(output, infop);
-      }
+    infop->buffer[0] = (char)output; /* store */
+    infop->buffer++; /* increase pointer */
+    infop->length++; /* we are now one byte larger */
     return output; /* fputc() returns like this on success */
   }
   return -1;
 }
 
 int msnprintf(char *buffer, size_t maxlength, const char *format, ...)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/progress.c	2000-11-06 23:32:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/progress.c	2000-11-16 15:20:12.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/progress.c,v $
- * $Revision: 1.17 $
- * $Date: 2000/11/06 15:32:16 $
+ * $Revision: 1.18 $
+ * $Date: 2000/11/16 07:20:12 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -110,13 +110,13 @@
 
 void pgrsDone(struct UrlData *data)
 {
   if(!(data->progress.flags & PGRS_HIDE)) {
     data->progress.lastshow=0;
     pgrsUpdate(data); /* the final (forced) update */
-    fprintf(stderr, "\n");
+    fprintf(data->err, "\n");
   }
 }
 
 void pgrsTime(struct UrlData *data, timerid timer)
 {
   switch(timer) {
@@ -319,13 +319,13 @@
   total_transfer = data->progress.downloaded + data->progress.uploaded;
 
   /* Get the percentage of data transfered so far */
   if(total_expected_transfer)
     total_percen=(double)(total_transfer/total_expected_transfer)*100;
 
-  fprintf(stderr,
+  fprintf(data->err,
           "\r%3d %s  %3d %s  %3d %s  %s  %s %s %s %s %s",
           (int)total_percen,                            /* total % */
           max5data(total_expected_transfer, max5[2]),   /* total size */
           (int)dlpercen,                                /* rcvd % */
           max5data(data->progress.downloaded, max5[0]), /* rcvd size */
           (int)ulpercen,                                /* xfer % */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/sendf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/sendf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/sendf.c	2000-10-30 19:53:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/sendf.c	2000-11-22 20:53:56.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/sendf.c,v $
- * $Revision: 1.12 $
- * $Date: 2000/10/30 11:53:40 $
+ * $Revision: 1.13 $
+ * $Date: 2000/11/22 12:53:56 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -177,12 +177,46 @@
   }
 #endif
 
   return bytes_written;
 }
 
+/* client_write() sends data to the write callback(s)
+
+   The bit pattern defines to what "streams" to write to. Body and/or header.
+   The defines are in sendf.h of course.
+ */
+CURLcode client_write(struct UrlData *data,
+                      int type,
+                      char *ptr,
+                      size_t len)
+{
+  size_t wrote;
+
+  if(0 == len)
+    len = strlen(ptr);
+
+  if(type & CLIENTWRITE_BODY) {
+    wrote = data->fwrite(ptr, 1, len, data->out);
+    if(wrote != len) {
+      failf (data, "Failed writing body");
+      return CURLE_WRITE_ERROR;
+    }
+  }
+  if((type & CLIENTWRITE_HEADER) && data->writeheader) {
+    wrote = data->fwrite(ptr, 1, len, data->writeheader);
+    if(wrote != len) {
+      failf (data, "Failed writing header");
+      return CURLE_WRITE_ERROR;
+    }
+  }
+  
+  return CURLE_OK;
+}
+
+
 /*
  * add_buffer_init() returns a fine buffer struct
  */
 send_buffer *add_buffer_init(void)
 {
   send_buffer *blonk;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/sendf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/sendf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/sendf.h	2000-10-03 19:01:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/sendf.h	2000-11-22 20:55:55.000000000 +0800
@@ -28,14 +28,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/sendf.h,v $
- * $Revision: 1.6 $
- * $Date: 2000/10/03 11:01:32 $
+ * $Revision: 1.7 $
+ * $Date: 2000/11/22 12:55:55 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -50,13 +50,18 @@
   char *buffer;
   long size_max;
   long size_used;
 };
 typedef struct send_buffer send_buffer;
 
+#define CLIENTWRITE_BODY   1
+#define CLIENTWRITE_HEADER 2
+#define CLIENTWRITE_BOTH   (CLIENTWRITE_BODY|CLIENTWRITE_HEADER)
 
+CURLcode client_write(struct UrlData *data, int type, char *ptr,
+                      size_t len);
 send_buffer *add_buffer_init(void);
 CURLcode add_buffer(send_buffer *in, void *inptr, size_t size);
 CURLcode add_bufferf(send_buffer *in, char *fmt, ...);
 size_t add_buffer_send(int sockfd, struct connectdata *conn, send_buffer *in);
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/telnet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/telnet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/telnet.c	2000-10-30 19:53:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/telnet.c	2000-11-22 20:56:27.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/telnet.c,v $
- * $Revision: 1.6 $
- * $Date: 2000/10/30 11:53:40 $
+ * $Revision: 1.7 $
+ * $Date: 2000/11/22 12:56:27 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  *
@@ -710,14 +710,14 @@
       case TS_CR:
 	 telrcv_state = TS_DATA;
 	 if (c == '\0')
 	 {
 	    break;   /* Ignore \0 after CR */
 	 }
-	 
-	 data->fwrite((char *)&c, 1, 1, data->out);
+
+	 client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
 	 continue;
 
       case TS_DATA:
 	 if (c == IAC)
 	 {
 	    telrcv_state = TS_IAC;
@@ -725,13 +725,13 @@
 	 }
 	 else if(c == '\r')
 	 {
 	    telrcv_state = TS_CR;
 	 }
 
-	 data->fwrite((char *)&c, 1, 1, data->out);
+	 client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
 	 continue;
 
       case TS_IAC:
 	process_iac:
 	switch (c)
 	{
@@ -749,14 +749,14 @@
 	   continue;
 	case SB:
 	   SB_CLEAR();
 	   telrcv_state = TS_SB;
 	   continue;
 	case IAC:
-	   data->fwrite((char *)&c, 1, 1, data->out);
-	   break;
+          client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
+          break;
 	case DM:
 	case NOP:
 	case GA:
 	default:
 	   printoption(data, "RCVD", IAC, c);
 	   break;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/url.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/url.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/url.c	2000-11-10 17:19:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/url.c	2000-11-29 16:16:27.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/url.c,v $
- * $Revision: 1.56 $
- * $Date: 2000/11/10 09:19:09 $
+ * $Revision: 1.67 $
+ * $Date: 2000/11/29 08:16:27 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -188,12 +188,13 @@
     data->bits.httpproxy=FALSE;
   }
   
   if(data->bits.rangestringalloc) {
     free(data->range);
     data->range=NULL;
+    data->bits.rangestringalloc=0; /* free now */
   }
 
   if(data->ptr_proxyuserpwd) {
     free(data->ptr_proxyuserpwd);
     data->ptr_proxyuserpwd=NULL;
   }
@@ -294,19 +295,12 @@
       free(data); /* free the memory again */
       return CURLE_OUT_OF_MEMORY;
     }
 
     data-> headersize=HEADERSIZE;
 
-#if 0
-    /* Let's set some default values: */
-    curl_setopt(data, CURLOPT_FILE, stdout); /* default output to stdout */
-    curl_setopt(data, CURLOPT_INFILE, stdin);  /* default input from stdin */
-    curl_setopt(data, CURLOPT_STDERR, stderr);  /* default stderr to stderr! */
-#endif
-
     data->out = stdout; /* default output to stdout */
     data->in  = stdin;  /* default input from stdin */
     data->err  = stderr;  /* default stderr to stderr */
 
     data->firstsocket = -1; /* no file descriptor */
     data->secondarysocket = -1; /* no file descriptor */
@@ -361,12 +355,15 @@
   case CURLOPT_UPLOAD:
     data->bits.upload = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_POST:
     data->bits.http_post = va_arg(param, long)?TRUE:FALSE;
     break;
+  case CURLOPT_FILETIME:
+    data->bits.get_filetime = va_arg(param, long)?TRUE:FALSE;
+    break;
   case CURLOPT_FTPLISTONLY:
     data->bits.ftp_list_only = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FTPAPPEND:
     data->bits.ftp_append = va_arg(param, long)?TRUE:FALSE;
     break;
@@ -443,15 +440,13 @@
     data->low_speed_time=va_arg(param, long);
     break;
   case CURLOPT_URL:
     data->url = va_arg(param, char *);
     break;
   case CURLOPT_PORT:
-    /* this typecast is used to fool the compiler to NOT warn for a
-       "cast from pointer to integer of different size" */
-    data->port = (unsigned short)(va_arg(param, long));
+    data->port = va_arg(param, long);
     break;
   case CURLOPT_POSTFIELDS:
     data->postfields = va_arg(param, char *);
     break;
   case CURLOPT_POSTFIELDSIZE:
     data->postfieldsize = va_arg(param, long);
@@ -473,12 +468,15 @@
   case CURLOPT_PROXYPORT:
     data->proxyport = va_arg(param, long);
     break;
   case CURLOPT_TIMEOUT:
     data->timeout = va_arg(param, long);
     break;
+  case CURLOPT_MAXREDIRS:
+    data->maxredirs = va_arg(param, long);
+    break;
   case CURLOPT_USERAGENT:
     data->useragent = va_arg(param, char *);
     break;
   case CURLOPT_USERPWD:
     data->userpwd = va_arg(param, char *);
     data->bits.user_passwd = data->userpwd?1:0;
@@ -513,17 +511,12 @@
   case CURLOPT_STDERR:
     data->err = va_arg(param, FILE *);
     break;
   case CURLOPT_WRITEFUNCTION:
     data->fwrite = va_arg(param, curl_write_callback);
     break;
-#if 0
-  case CURLOPT_WRITEINFO:
-    data->writeinfo = va_arg(param, char *);
-    break;
-#endif
   case CURLOPT_READFUNCTION:
     data->fread = va_arg(param, curl_read_callback);
     break;
   case CURLOPT_SSLCERT:
     data->cert = va_arg(param, char *);
     break;
@@ -676,50 +669,35 @@
 
   struct UrlData *data = conn->data;
 
   if(conn->hostent_buf) /* host name info */
     free(conn->hostent_buf);
 
+  if(conn->path) /* the URL path part */
+    free(conn->path);
+
   free(conn); /* free the connection oriented data */
 
   /* clean up the sockets and SSL stuff from the previous "round" */
   urlfree(data, FALSE);
 
   return CURLE_OK;
 }
 
-
-/*
- * NAME curl_connect()
- *
- * DESCRIPTION
- *
- * Connects to the peer server and performs the initial setup. This function
- * writes a connect handle to its second argument that is a unique handle for
- * this connect. This allows multiple connects from the same handle returned
- * by curl_open().
- *
- * EXAMPLE
- *
- * CURLCode result;
- * CURL curl;
- * CURLconnect connect;
- * result = curl_connect(curl, &connect);
- */
-
-CURLcode curl_connect(CURL *curl, CURLconnect **in_connect)
+static CURLcode _connect(CURL *curl, CURLconnect **in_connect)
 {
   char *tmp;
   char *buf;
   CURLcode result;
-  char resumerange[12]="";
+  char resumerange[40]="";
   struct UrlData *data = curl;
   struct connectdata *conn;
 #ifdef HAVE_SIGACTION
   struct sigaction sigact;
 #endif
+  int urllen;
 
   if(!data || (data->handle != STRUCT_OPEN))
     return CURLE_BAD_FUNCTION_ARGUMENT; /* TBD: make error codes */
 
   if(!data->url)
     return CURLE_URL_MALFORMAT;
@@ -752,19 +730,31 @@
 #ifdef HAVE_SIGNAL
   signal(SIGALRM, alarmfunc);
 #endif
 
 #endif
 
+  /* We need to allocate memory to store the path in. We get the size of the
+     full URL to be sure, and we need to make it at least 256 bytes since
+     other parts of the code will rely on this fact */
+#define LEAST_PATH_ALLOC 256
+  urllen=strlen(data->url);
+  if(urllen < LEAST_PATH_ALLOC)
+    urllen=LEAST_PATH_ALLOC;
+  
+  conn->path=(char *)malloc(urllen);
+  if(NULL == conn->path)
+    return CURLE_OUT_OF_MEMORY; /* really bad error */
+
   /* Parse <url> */
   /* We need to parse the url, even when using the proxy, because
    * we will need the hostname and port in case we are trying
    * to SSL connect through the proxy -- and we don't know if we
    * will need to use SSL until we parse the url ...
    */
-  if((2 == sscanf(data->url, "%64[^:]://%" URL_MAX_LENGTH_TXT "[^\n]",
+  if((2 == sscanf(data->url, "%64[^:]://%[^\n]",
                   conn->proto,
                   conn->path)) && strequal(conn->proto, "file")) {
     /* we deal with file://<host>/<path> differently since it
        supports no hostname other than "localhost" and "127.0.0.1",
        which is unique among the protocols specified in RFC 1738 */
     if (strnequal(conn->path, "localhost/", 10) ||
@@ -778,17 +768,17 @@
   else {
     /* Set default host and default path */
     strcpy(conn->gname, "curl.haxx.se");
     strcpy(conn->path, "/");
 
     if (2 > sscanf(data->url,
-                   "%64[^\n:]://%256[^\n/]%" URL_MAX_LENGTH_TXT "[^\n]",
+                   "%64[^\n:]://%256[^\n/]%[^\n]",
                    conn->proto, conn->gname, conn->path)) {
       
       /* badly formatted, let's try the browser-style _without_ 'http://' */
-      if((1 > sscanf(data->url, "%256[^\n/]%" URL_MAX_LENGTH_TXT "[^\n]",
+      if((1 > sscanf(data->url, "%256[^\n/]%[^\n]",
                      conn->gname, conn->path)) ) {
         failf(data, "<url> malformed");
         return CURLE_URL_MALFORMAT;
       }
       if(strnequal(conn->gname, "FTP", 3)) {
         strcpy(conn->proto, "ftp");
@@ -867,26 +857,35 @@
 
 
   if(!data->bits.httpproxy) {
     /* If proxy was not specified, we check for default proxy environment
        variables, to enable i.e Lynx compliance:
 
-       HTTP_PROXY http://some.server.dom:port/
-       HTTPS_PROXY http://some.server.dom:port/
-       FTP_PROXY http://some.server.dom:port/
-       GOPHER_PROXY http://some.server.dom:port/
-       NO_PROXY host.domain.dom  (a comma-separated list of hosts which should
-       not be proxied, or an asterisk to override all proxy variables)
-       ALL_PROXY seems to exist for the CERN www lib. Probably the first to
-       check for.
- 
+       http_proxy=http://some.server.dom:port/
+       https_proxy=http://some.server.dom:port/
+       ftp_proxy=http://some.server.dom:port/
+       gopher_proxy=http://some.server.dom:port/
+       no_proxy=domain1.dom,host.domain2.dom
+                                 (a comma-separated list of hosts which should
+                                  not be proxied, or an asterisk to override
+                                  all proxy variables)
+       all_proxy=http://some.server.dom:port/
+                                 (seems to exist for the CERN www lib. Probably
+                                  the first to check for.)
+
+       For compatibility, the all-uppercase versions of these variables are
+       checked if the lowercase versions don't exist.
        */
-    char *no_proxy=GetEnv("NO_PROXY");
+    char *no_proxy=NULL;
     char *proxy=NULL;
     char proxy_env[128];
 
+    no_proxy=GetEnv("no_proxy");
+    if(!no_proxy)
+      no_proxy=GetEnv("NO_PROXY");
+
     if(!no_proxy || !strequal("*", no_proxy)) {
       /* NO_PROXY wasn't specified or it wasn't just an asterisk */
       char *nope;
 
       nope=no_proxy?strtok(no_proxy, ", "):NULL;
       while(nope) {
@@ -903,37 +902,45 @@
       if(!nope) {
 	/* It was not listed as without proxy */
 	char *protop = conn->proto;
 	char *envp = proxy_env;
 	char *prox;
 
-	/* Now, build <PROTOCOL>_PROXY and check for such a one to use */
-	while(*protop) {
-	  *envp++ = toupper(*protop++);
-	}
-	/* append _PROXY */
-	strcpy(envp, "_PROXY");
-#if 0
-	infof(data, "DEBUG: checks the environment variable %s\n", proxy_env);
-#endif
+	/* Now, build <protocol>_proxy and check for such a one to use */
+	while(*protop)
+	  *envp++ = tolower(*protop++);
+
+	/* append _proxy */
+	strcpy(envp, "_proxy");
+
 	/* read the protocol proxy: */
 	prox=GetEnv(proxy_env);
 
+	if(!prox) {
+          /* There was no lowercase variable, try the uppercase version: */
+	  for(envp = proxy_env; *envp; envp++)
+	    *envp = toupper(*envp);
+	  prox=GetEnv(proxy_env);
+	}
+
 	if(prox && *prox) { /* don't count "" strings */
 	  proxy = prox; /* use this */
         }
-        else
-          proxy = GetEnv("ALL_PROXY"); /* default proxy to use */
+	else {
+	  proxy = GetEnv("all_proxy"); /* default proxy to use */
+	  if(!proxy)
+            proxy=GetEnv("ALL_PROXY");
+	}
 
         if(proxy && *proxy) {
           /* we have a proxy here to set */
           data->proxy = proxy;
           data->bits.proxystringalloc=1; /* this needs to be freed later */
           data->bits.httpproxy=1;
         }
-      } /* if (!nope) - it wasn't specfied non-proxy */
+      } /* if (!nope) - it wasn't specified non-proxy */
     } /* NO_PROXY wasn't specified or '*' */
     if(no_proxy)
       free(no_proxy);
   } /* if not using proxy */
 
   if((conn->protocol&PROT_MISSING) && data->bits.httpproxy ) {
@@ -1139,19 +1146,13 @@
 	  (conn->protocol & (PROT_FTP|PROT_HTTP)) ) {
     /* This is a FTP or HTTP URL, and we haven't got the user+password in
        the extra parameter, we will now try to extract the possible
        user+password pair in a string like:
        ftp://user:password@ftp.my.site:8021/README */
     char *ptr=NULL; /* assign to remove possible warnings */
-#if 0
-    if(':' == *conn->name) {
-      failf(data, "URL malformat: user can't be zero length");
-      return CURLE_URL_MALFORMAT_USER;
-    }
-#endif
-    if(ptr=strchr(conn->name, '@')) {
+    if((ptr=strchr(conn->name, '@'))) {
       /* there's a user+password given here, to the left of the @ */
 
       data->user[0] =0;
       data->passwd[0]=0;
 
       if(*conn->name != ':') {
@@ -1208,13 +1209,13 @@
     }
     data->remote_port = data->port; /* it is the same port */
 
     /* Connect to target host right on */
     conn->hp = GetHost(data, conn->name, &conn->hostent_buf);
     if(!conn->hp) {
-      failf(data, "Couldn't resolv host '%s'", conn->name);
+      failf(data, "Couldn't resolve host '%s'", conn->name);
       return CURLE_COULDNT_RESOLVE_HOST;
     }
   }
   else {
     char *prox_portno;
     char *endofprot;
@@ -1264,13 +1265,13 @@
       data->port = data->proxyport;
     }
 
     /* connect to proxy */
     conn->hp = GetHost(data, proxyptr, &conn->hostent_buf);
     if(!conn->hp) {
-      failf(data, "Couldn't resolv proxy '%s'", proxyptr);
+      failf(data, "Couldn't resolve proxy '%s'", proxyptr);
       return CURLE_COULDNT_RESOLVE_PROXY;
     }
 
     free(proxydup); /* free the duplicate pointer and not the modified */
   }
   pgrsTime(data, TIMER_NAMELOOKUP);
@@ -1295,18 +1296,16 @@
 
 #ifndef INADDR_NONE
 #define INADDR_NONE (unsigned long) ~0
 #endif
 
   if (data->device && (strlen(data->device)<255)) {
-    struct ifreq ifr;
     struct sockaddr_in sa;
     struct hostent *h=NULL;
-    char *hostdataptr;
+    char *hostdataptr=NULL;
     size_t size;
-    unsigned short porttouse;
     char myhost[256] = "";
     unsigned long in;
 
     if(if2ip(data->device, myhost, sizeof(myhost))) {
       h = GetHost(data, myhost, &hostdataptr);
     }
@@ -1376,29 +1375,12 @@
           case ENAMETOOLONG:
             failf(data, "Address too long: %d", errno);
             break;
           case ENOMEM:
             failf(data, "Insufficient kernel memory was available: %d", errno);
             break;
-#if 0
-          case EROFS:
-            failf(data,
-                  "Socket inode would reside on a read-only file system: %d",
-                  errno);
-            break;
-          case ENOENT:
-            failf(data, "File does not exist: %d", errno);
-            break;
-          case ENOTDIR:
-            failf(data, "Component of path prefix is not a directory: %d",
-                  errno);
-            break;
-          case ELOOP:
-            failf(data,"Too many symbolic links encountered: %d",errno);
-            break;
-#endif
           default:
             failf(data,"errno %d\n");
           } /* end of switch */
 	
           return CURLE_HTTP_PORT_FAILED;
         } /* end of else */
@@ -1412,13 +1394,14 @@
 
     else {
       failf(data, "could't find my own IP address (%s)", myhost);
       return CURLE_HTTP_PORT_FAILED;
     }
 
-    free(hostdataptr); /* allocated by GetHost() */
+    if(hostdataptr)
+      free(hostdataptr); /* allocated by GetHost() */
 
   } /* end of device selection support */
 #endif  /* end of HAVE_INET_NTOA */
 #endif /* end of not WIN32 */
 
   if (connect(data->firstsocket,
@@ -1460,23 +1443,12 @@
       failf(data, "Attempt to connect to broadcast address without socket broadcast flag or local firewall rule violated: %d",errno);
       break;
 #endif
     case EINTR:
       failf(data, "Connection timeouted");
       break;
-#if 0
-    case EAFNOSUPPORT:
-      failf(data, "Incorrect address family: %d",errno);
-      break;
-    case ENOTSOCK:
-      failf(data, "File descriptor is not a socket: %d",errno);
-      break;
-    case EBADF:
-      failf(data, "File descriptor is not a valid index in descriptor table: %d",errno);
-      break;
-#endif
     default:
       failf(data, "Can't connect to server: %d", errno);
       break;
     }
     return CURLE_COULDNT_CONNECT;
   }
@@ -1517,16 +1489,12 @@
   {
     struct in_addr in;
     (void) memcpy(&in.s_addr, *conn->hp->h_addr_list, sizeof (in.s_addr));
     infof(data, "Connected to %s (%s)\n", conn->hp->h_name, inet_ntoa(in));
   }
 
-#if 0 /* Kerberos experiements! Beware! Take cover! */
-  kerberos_connect(data, name);
-#endif
-
 #ifdef __EMX__
   /* 20000330 mgs
    * the check is quite a hack...
    * we're calling _fsetmode to fix the problem with fwrite converting newline
    * characters (you get mangled text files, and corrupted binary files when
    * you download to stdout and redirect it to a file). */
@@ -1536,12 +1504,58 @@
   }
 #endif
 
   return CURLE_OK;
 }
 
+CURLcode curl_connect(CURL *curl, CURLconnect **in_connect)
+{
+  CURLcode code;
+  struct connectdata *conn;
+
+  /* call the stuff that needs to be called */
+  code = _connect(curl, in_connect);
+
+  if(CURLE_OK != code) {
+    /* We're not allowed to return failure with memory left allocated
+       in the connectdata struct, free those here */
+    conn = (struct connectdata *)*in_connect;
+    if(conn) {
+      if(conn->path)
+        free(conn->path);
+      if(conn->hostent_buf)
+        free(conn->hostent_buf);
+      free(conn);
+      *in_connect=NULL;
+    }
+  }
+  return code;
+}
+
+
+/*
+ * NAME curl_connect()
+ *
+ * DESCRIPTION
+ *
+ * Connects to the peer server and performs the initial setup. This function
+ * writes a connect handle to its second argument that is a unique handle for
+ * this connect. This allows multiple connects from the same handle returned
+ * by curl_open().
+ *
+ * EXAMPLE
+ *
+ * CURLCode result;
+ * CURL curl;
+ * CURLconnect connect;
+ * result = curl_connect(curl, &connect);
+ */
+
+
+
+
 CURLcode curl_done(CURLconnect *c_connect)
 {
   struct connectdata *conn = c_connect;
   struct UrlData *data;
   CURLcode result;
 
@@ -1587,16 +1601,9 @@
       return result;
     }
   }
 
   conn->state = CONN_DO; /* we have entered this state */
 
-#if 0
-  if(conn->bytecount) {
-    double ittook = tvdiff (tvnow(), conn->now);
-    infof(data, "%i bytes transfered in %.3lf seconds (%.0lf bytes/sec).\n",
-          conn->bytecount, ittook, (double)conn->bytecount/(ittook!=0.0?ittook:1));
-  }
-#endif
   return CURLE_OK;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/urldata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/urldata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/lib/urldata.h	2000-11-14 02:23:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/lib/urldata.h	2000-11-28 17:05:47.000000000 +0800
@@ -28,14 +28,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/lib/urldata.h,v $
- * $Revision: 1.31 $
- * $Date: 2000/11/13 18:23:21 $
+ * $Revision: 1.35 $
+ * $Date: 2000/11/28 09:05:47 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -172,13 +172,13 @@
   char *hostent_buf; /* pointer to allocated memory for name info */
   struct hostent *hp;
   struct sockaddr_in serv_addr;
   char proto[64];
   char gname[256];
   char *name;
-  char path[URL_MAX_LENGTH];
+  char *path; /* formerly staticly this size: URL_MAX_LENGTH */
   char *ppath;
   long bytecount;
   struct timeval now;
 
   long upload_bufsize; /* adjust as you see fit, never bigger than BUFSIZE
                           never smaller than UPLOAD_BUFSIZE */
@@ -247,12 +247,14 @@
   struct timeval t_startsingle;
   /* various data stored for possible later report */
   double t_nslookup;
   double t_connect;
   double t_pretransfer;
   int httpcode;
+  time_t filetime; /* If requested, this is might get set. It may be 0 if
+                      the time was unretrievable */
 
 #define CURR_TIME 5
 
   double speeder[ CURR_TIME ];
   int speeder_c;
 };
@@ -284,12 +286,13 @@
   char *urlpath; /* the originally given path part of the URL */
   char *dir;     /* decoded directory */
   char *file;    /* decoded file */
 };
 
 struct Configbits {
+  bool get_filetime;
   bool tunnel_thru_httpproxy;
   bool ftp_append;
   bool ftp_ascii;
   bool ftp_list_only;
   bool ftp_use_port;
   bool hide_progress;
@@ -328,13 +331,13 @@
 } CurlInterface;
 
 struct ssldata {
   bool use;              /* use ssl encrypted communications TRUE/FALSE */
   long version;          /* what version the client wants to use */
   long certverifyresult; /* result from the certificate verification */
-  bool verifypeer;       /* set TRUE if this is desired */
+  long verifypeer;       /* set TRUE if this is desired */
   char *CApath;          /* DOES NOT WORK ON WINDOWS */
   char *CAfile;          /* cerficate to verify peer against */
 #ifdef USE_SSLEAY
   /* these ones requires specific SSL-types */
   SSL_CTX* ctx;
   SSL*     handle;
@@ -398,25 +401,26 @@
   FILE *out;    /* the fetched file goes here */
   FILE *in;     /* the uploaded file is read from here */
   FILE *writeheader; /* write the header to this is non-NULL */
   char *url;   /* what to get */
   char *freethis; /* if non-NULL, an allocated string for the URL */
   char *hostname; /* hostname to connect, as parsed from url */
-  unsigned short port; /* which port to use (if non-protocol bind) set
-                          CONF_PORT to use this */
+  long port; /* which port to use (if non-protocol bind) set
+                CONF_PORT to use this */
   unsigned short remote_port; /* what remote port to connect to, not the proxy
 				 port! */
   struct Configbits bits; /* new-style (v7) flag data */
 
   char *userpwd;  /* <user:password>, if used */
   char *range; /* range, if used. See README for detailed specification on
                   this syntax. */
 
   /* stuff related to HTTP */
 
   long followlocation;
+  long maxredirs; /* maximum no. of http(s) redirects to follow */
   char *referer;
   bool free_referer; /* set TRUE if 'referer' points to a string we
                         allocated */
   char *useragent;   /* User-Agent string */
   char *postfields; /* if POST, set the fields' values here */
   long postfieldsize; /* if POST, this might have a size to use instead of
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/Makefile	2000-06-20 23:34:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/Makefile	2000-12-01 15:01:14.000000000 +0800
@@ -26,26 +26,26 @@
 # Main author:
 # - Daniel Stenberg <daniel@haxx.se>
 #
 # 	http://curl.haxx.se
 #
 # $Source: /cvsroot/curl/Makefile.dist,v $
-# $Revision: 1.3 $
-# $Date: 2000/06/20 15:33:16 $
+# $Revision: 1.4 $
+# $Date: 2000/12/01 07:01:14 $
 # $Author: bagder $
 # $State: Exp $
 # $Locker:  $
 #
 # ------------------------------------------------------------
 #
 # In a normal unix-setup, this file will become overwritten.
 #
 ############################################################################
 
 all:
-	./configure
+	./configure
 	make
 
 ssl:
 	./configure --with-ssl
 	make
 
@@ -55,15 +55,23 @@
 
 mingw32-ssl:
 	cd lib; make -f Makefile.m32 SSL=1
 	cd src; make -f Makefile.m32 SSL=1
 
 vc:
-	cd lib; nmake -f Makefile.vc6
-	cd src; nmake -f Makefile.vc6
-
+	cd lib
+	nmake -f Makefile.vc6
+	cd ..\src
+	nmake -f Makefile.vc6
+
+vc-ssl:
+	cd lib
+	nmake -f Makefile.vc6 release-ssl
+	cd ..\src
+	nmake -f Makefile.vc6
+
 cygwin:
 	./configure
 	make
 
 cygwin-ssl:
 	./configure --with-ssl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/Makefile.am	2000-11-10 22:42:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/Makefile.am	2000-11-17 23:30:01.000000000 +0800
@@ -1,12 +1,12 @@
 #
-# $Id: Makefile.am,v 1.6 2000/11/10 14:42:06 bagder Exp $
+# $Id: Makefile.am,v 1.7 2000/11/17 15:30:01 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 EXTRA_DIST = curl.spec curl-ssl.spec
 
 SUBDIRS = docs lib src include tests
 
 test:
-	@(cd tests; make test)
+	@(cd tests; make quiet-test)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/Makefile.in	2000-11-15 16:22:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/Makefile.in	2000-12-04 16:39:15.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.6 2000/11/10 14:42:06 bagder Exp $
+# $Id: Makefile.am,v 1.7 2000/11/17 15:30:01 bagder Exp $
 #
 
 
 SHELL = /bin/sh
 
 srcdir = @srcdir@
@@ -360,11 +360,11 @@
 install uninstall-am uninstall all-redirect all-am all installdirs-am \
 installdirs mostlyclean-generic distclean-generic clean-generic \
 maintainer-clean-generic clean mostlyclean distclean maintainer-clean
 
 
 test:
-	@(cd tests; make test)
+	@(cd tests; make quiet-test)
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/README	2000-11-03 16:16:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/README	2000-11-30 15:56:59.000000000 +0800
@@ -5,13 +5,13 @@
                              \___|\___/|_| \_\_____|
 
 README
 
   Curl is a command line tool for transfering data specified with URL
   syntax. Find out how to use Curl by reading the curl.1 man page or the
-  README.curl document. Find out how to install Curl by reading the INSTALL
+  MANUAL document. Find out how to install Curl by reading the INSTALL
   document.
 
   libcurl is a library that Curl is using to do its job. It is readily
   available to be used by your software. Read the README.libcurl document to
   find out how!
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/hugehelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/hugehelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/hugehelp.c	2000-11-13 20:51:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/hugehelp.c	2000-11-30 16:13:13.000000000 +0800
@@ -164,12 +164,17 @@
 "          file when getting a file with HTTPS. The certificate\n"
 "          must be in PEM format.  If the optional password isn't\n"
 "          specified, it will be queried for on the terminal. Note\n"
 "          that this certificate is the private key and the pri­\n"
 "          vate certificate concatenated!\n"
 "\n"
+"     --cacert <CA certificate>\n"
+"          (HTTPS) Tells curl to use the specified certificate\n"
+"          file to verify the peer. The certificate must be in PEM\n"
+"          format.\n"
+"\n"
 "     -f/--fail\n"
 "          (HTTP) Fail silently (no output at all) on server\n"
 "          errors. This is mostly done like this to better enable\n"
 "          scripts etc to better deal with failed attempts. In\n"
 "          normal cases when a HTTP server fails to deliver a doc­\n"
 "          ument, it returns a HTML document stating so (which\n"
@@ -206,34 +211,35 @@
 "          (HTTP) Extra header to use when getting a web page. You\n"
 "          may specify any number of extra headers. Note that if\n"
 "          you should add a custom header that has the same name\n"
 "          as one of the internal ones curl would use, your exter­\n"
 "          nally set header will be used instead of the internal\n"
 "          one. This allows you to make even trickier stuff than\n"
-"          curl would normally do. You should not replace inter­\n"
-"          nally set headers without knowing perfectly well what\n"
-"          you're doing. Replacing an internal header with one\n"
-"          without content on the right side of the colon will\n"
+"          curl would normally do. You should not replace\n"
+"          internally set headers without knowing perfectly well\n"
+"          what you're doing. Replacing an internal header with\n"
+"          one without content on the right side of the colon will\n"
 "          prevent that header from appearing.\n"
+"\n"
 "     -i/--include\n"
 "          (HTTP) Include the HTTP-header in the output. The HTTP-\n"
 "          header includes things like server-name, date of the\n"
 "          document, HTTP-version and more...\n"
 "\n"
 "     --interface <name>\n"
 "          Perform an operation using a specified interface. You\n"
 "          can enter interface name, IP address or host name. An\n"
 "          example could look like:\n"
 "\n"
 "          curl --interface eth0:1 http://www.netscape.com/\n"
+);
+ puts(
 "\n"
 "     -I/--head\n"
 "          (HTTP/FTP) Fetch the HTTP-header only! HTTP-servers\n"
 "          feature the command HEAD which this uses to get nothing\n"
-);
- puts(
 "          but the header of a document. When used on a FTP file,\n"
 "          curl displays the file size only.\n"
 "\n"
 "     --krb4 <level>\n"
 "          (FTP) Enable kerberos4 authentication and use. The\n"
 "          level must be entered and should be one of 'clear',\n"
@@ -265,12 +271,13 @@
 "          header line Location:) this flag will let curl attempt\n"
 "          to reattempt the get on the new place. If used together\n"
 "          with -i or -I, headers from all requested pages will be\n"
 "          shown. If this flag is used when making a HTTP POST,\n"
 "          curl will automatically switch to GET after the initial\n"
 "          POST has been done.\n"
+"\n"
 "     -m/--max-time <seconds>\n"
 "          Maximum time in seconds that you allow the whole opera­\n"
 "          tion to take.  This is useful for preventing your batch\n"
 "          jobs from hanging for hours due to slow networks or\n"
 "          links going down.  This doesn't work fully in win32\n"
 "          systems.\n"
@@ -311,17 +318,17 @@
 "\n"
 "            curl http://{one,two}.site.com -o \"file_#1.txt\"\n"
 "\n"
 "          or use several variables like:\n"
 "\n"
 "            curl http://{site,host}.host[1-5].com -o \"#1_#2\"\n"
-"\n"
 "     -O/--remote-name\n"
 "          Write output to a local file named like the remote file\n"
 "          we get. (Only the file part of the remote file is used,\n"
 "          the path is cut off.)\n"
+"\n"
 "     -p/--proxytunnel\n"
 "          When an HTTP proxy is used, this option will cause non-\n"
 "          HTTP protocols to attempt to tunnel through the proxy\n"
 "          instead of merely using it to do HTTP-like operations.\n"
 "          The tunnel approach is made with the HTTP proxy CONNECT\n"
 "          request and requires that the proxy allows direct con­\n"
@@ -368,12 +375,13 @@
 "          ment) from a HTTP/1.1 or FTP server. Ranges can be\n"
 "          specified in a number of ways.\n"
 "\n"
 "          0-499     specifies the first 500 bytes\n"
 "\n"
 "          500-999   specifies the second 500 bytes\n"
+"\n"
 "          -500      specifies the last 500 bytes\n"
 "\n"
 "          9500      specifies the bytes from offset 9500 and for­\n"
 "                    ward\n"
 "\n"
 "          0-0,-1    specifies the first and last byte only(*)(H)\n"
@@ -429,12 +437,16 @@
 "\n"
 "     -U/--proxy-user <user:password>\n"
 "          Specify user and password to use for Proxy authentica­\n"
 "          tion. If no password is specified, curl will ask for it\n"
 "          interactively.\n"
 "\n"
+"     --url <URL>\n"
+"          Set the URL to fetch. This option is mostly handy when\n"
+"          you wanna specify URL in a config file.\n"
+"\n"
 "     -v/--verbose\n"
 "          Makes the fetching more verbose/talkative. Mostly\n"
 "          usable for debugging. Lines starting with '>' means\n"
 "          data sent by curl, '<' means data received by curl that\n"
 "          is hidden in normal cases and lines starting with '*'\n"
 "          means additional info provided by curl.\n"
@@ -460,25 +472,26 @@
 "\n"
 "          NOTE: The %-letter is a special letter in the\n"
 "          win32-environment, where all occurrences of % must be\n"
 "          doubled when using this option.\n"
 "\n"
 "          Available variables are at this point:\n"
+);
+ puts(
 "\n"
 "          url_effective  The URL that was fetched last. This is\n"
 "                         mostly meaningful if you've told curl to\n"
 "                         follow location: headers.\n"
 "\n"
 "          http_code      The numerical code that was found in the\n"
 "                         last retrieved HTTP(S) page.\n"
-);
- puts(
 "\n"
 "          time_total     The total time, in seconds, that the\n"
 "                         full operation lasted. The time will be\n"
 "                         displayed with millisecond resolution.\n"
+"\n"
 "          time_namelookup\n"
 "                         The time, in seconds, it took from the\n"
 "                         start until the name resolving was com­\n"
 "                         pleted.\n"
 "\n"
 "          time_connect   The time, in seconds, it took from the\n"
@@ -567,20 +580,20 @@
 "\n"
 "     --stderr <file>\n"
 "          Redirect all writes to stderr to the specified file\n"
 "          instead. If the file name is a plain '-', it is instead\n"
 "          written to stdout. This option has no point when you're\n"
 "          using a shell with decent redirecting capabilities.\n"
-"\n"
 "FILES\n"
 "     ~/.curlrc\n"
 "          Default config file.\n"
 "\n"
 "ENVIRONMENT\n"
 "     HTTP_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for HTTP.\n"
+"\n"
 "     HTTPS_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for HTTPS.\n"
 "\n"
 "     FTP_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for FTP.\n"
 "\n"
@@ -618,30 +631,30 @@
 "          be resolved.\n"
 "\n"
 "     6    Couldn't resolve host. The given remote host was not\n"
 "          resolved.\n"
 "\n"
 "     7    Failed to connect to host.\n"
-"\n"
 "     8    FTP weird server reply. The server sent data curl\n"
 "          couldn't parse.\n"
 "\n"
 "     9    FTP access denied. The server denied login.\n"
 "\n"
 "     10   FTP user/password incorrect. Either one or both were\n"
 "          not accepted by the server.\n"
+"\n"
 "     11   FTP weird PASS reply. Curl couldn't parse the reply\n"
 "          sent to the PASS request.\n"
 "\n"
 "     12   FTP weird USER reply. Curl couldn't parse the reply\n"
 "          sent to the USER request.\n"
 "\n"
 "     13   FTP weird PASV reply, Curl couldn't parse the reply\n"
 "          sent to the PASV request.\n"
 "\n"
-"     14   FTP weird 227 formay. Curl couldn't parse the 227-line\n"
+"     14   FTP weird 227 format. Curl couldn't parse the 227-line\n"
 "          the server sent.\n"
 "\n"
 "     15   FTP can't get host. Couldn't resolve the host IP we got\n"
 "          in the 227-line.\n"
 "\n"
 "     16   FTP can't reconnect. Couldn't connect to the host we\n"
@@ -669,20 +682,20 @@
 "     24   Malformat user. User name badly specified.\n"
 "\n"
 "     25   FTP couldn't STOR file. The server denied the STOR\n"
 "          operation.\n"
 "\n"
 "     26   Read error. Various reading problems.\n"
-"\n"
 "     27   Out of memory. A memory allocation request failed.\n"
 "\n"
 "     28   Operation timeout. The specified time-out period was\n"
 "          reached according to the conditions.\n"
 "\n"
 "     29   FTP couldn't set ASCII. The server returned an unknown\n"
 "          reply.\n"
+"\n"
 "     30   FTP PORT failed. The PORT command failed.\n"
 "\n"
 "     31   FTP couldn't use REST. The REST command failed.\n"
 "\n"
 "     32   FTP couldn't use SIZE. The SIZE command failed. The\n"
 "          command is an extension to the original FTP spec RFC\n"
@@ -707,12 +720,28 @@
 "\n"
 "     40   Library not found. The LDAP library was not found.\n"
 "\n"
 "     41   Function not found. A required LDAP function was not\n"
 "          found.\n"
 "\n"
+"     42   Aborted by callback. An application told curl to abort\n"
+"          the operation.\n"
+"\n"
+"     43   Internal error. A function was called with a bad param­\n"
+"          eter.\n"
+"\n"
+"     44   Internal error. A function was called in a bad order.\n"
+"\n"
+"     45   Interface error. A specified outgoing interface could\n"
+"          not be used.\n"
+"\n"
+"     46   Bad password entered. An error was signalled when the\n"
+"          password was entered.\n"
+"     47   Too many redirects. When following redirects, curl hit\n"
+"          the maximum amount.\n"
+"\n"
 "     XX   There will appear more error codes here in future\n"
 "          releases. The existing ones are meant to never change.\n"
 "\n"
 "BUGS\n"
 "     If you do find bugs, mail them to curl-bug@haxx.se.\n"
 "\n"
@@ -734,12 +763,14 @@
 "      - Steven G. Johnson <stevenj@alum.mit.edu>\n"
 "      - Gilbert Ramirez Jr. <gram@verdict.uthscsa.edu>\n"
 "      - Andrés García <ornalux@redestb.es>\n"
 "      - Douglas E. Wegscheid <wegscd@whirlpool.com>\n"
 "      - Mark Butler <butlerm@xmission.com>\n"
 "      - Eric Thelin <eric@generation-i.com>\n"
+);
+ puts(
 "      - Marc Boucher <marc@mbsi.ca>\n"
 "      - Greg Onufer <Greg.Onufer@Eng.Sun.COM>\n"
 "      - Doug Kaufman <dkaufman@rahul.net>\n"
 "      - David Eriksson <david@2good.com>\n"
 "      - Ralph Beckmann <rabe@uni-paderborn.de>\n"
 "      - T. Yamada <tai@imasy.or.jp>\n"
@@ -754,14 +785,12 @@
 "      - Ron Zapp <rzapper@yahoo.com>\n"
 "      - Paul Marquis <pmarquis@iname.com>\n"
 "      - Ellis Pritchard <ellis@citria.com>\n"
 "      - Damien Adant <dams@usa.net>\n"
 "      - Chris <cbayliss@csc.come>\n"
 "      - Marco G. Salvagno <mgs@whiz.cjb.net>\n"
-);
- puts(
 "      - Paul Marquis <pmarquis@iname.com>\n"
 "      - David LeBlanc <dleblanc@qnx.com>\n"
 "      - Rich Gray at Plus Technologies\n"
 "      - Luong Dinh Dung <u8luong@lhsystems.hu>\n"
 "      - Torsten Foertsch <torsten.foertsch@gmx.net>\n"
 "      - Kristian Köhntopp <kris@koehntopp.de>\n"
@@ -770,12 +799,14 @@
 "      - Albert Chin-A-Young <china@thewrittenword.com>\n"
 "      - Stephen Kick <skick@epicrealm.com>\n"
 "      - Martin Hedenfalk <mhe@stacken.kth.se>\n"
 "      - Richard Prescott\n"
 "      - Jason S. Priebe <priebe@wral-tv.com>\n"
 "      - T. Bharath <TBharath@responsenetworks.com>\n"
+"      - Alexander Kourakos <awk@users.sourceforge.net>\n"
+"      - James Griffiths <griffiths_james@yahoo.com>\n"
 "\n"
 "WWW\n"
 "     http://curl.haxx.se\n"
 "\n"
 "FTP\n"
 "     ftp://ftp.sunet.se/pub/www/utilities/curl/\n"
@@ -1042,12 +1073,14 @@
 "  favourite browser, you have to check out the HTML of the form page to get to\n"
 "  know the names of the input fields. In our example, the input field names are\n"
 "  'file', 'yourname' and 'filedescription'.\n"
 "\n"
 "        curl -F \"file=@cooltext.txt\" -F \"yourname=Daniel\" \\\n"
 "             -F \"filedescription=Cool text file with cool text inside\" \\\n"
+);
+ puts(
 "             http://www.post.com/postit.cgi\n"
 "\n"
 "  So, to send two files in one post you can do it in two ways:\n"
 "\n"
 "  1. Send multiple files in a single \"field\" with a single field name:\n"
 " \n"
@@ -1064,19 +1097,19 @@
 "  referrer to get specified on the command line. It is especially useful to\n"
 "  fool or trick stupid servers or CGI scripts that rely on that information\n"
 "  being available or contain certain data.\n"
 "\n"
 "        curl -e www.coolsite.com http://www.showme.com/\n"
 "\n"
+"  NOTE: The referer field is defined in the HTTP spec to be a full URL.\n"
+"\n"
 "USER AGENT\n"
 "\n"
 "  A HTTP request has the option to include information about the browser\n"
 "  that generated the request. Curl allows it to be specified on the command\n"
 "  line. It is especially useful to fool or trick stupid servers or CGI\n"
-);
- puts(
 "  scripts that only accept certain browsers.\n"
 "\n"
 "  Example:\n"
 "\n"
 "  curl -A 'Mozilla/3.0 (Win95; I)' http://www.nationsbank.com/\n"
 "\n"
@@ -1184,23 +1217,32 @@
 "\n"
 "        curl -m 1800 -y 3000 -Y 60 www.far-away-site.com\n"
 "\n"
 "CONFIG FILE\n"
 "\n"
 "  Curl automatically tries to read the .curlrc file (or _curlrc file on win32\n"
-"  systems) from the user's home dir on startup. The config file should be\n"
-"  made up with normal command line switches. Comments can be used within the\n"
-"  file. If the first letter on a line is a '#'-letter the rest of the line\n"
-"  is treated as a comment.\n"
+"  systems) from the user's home dir on startup.\n"
+"\n"
+"  The config file could be made up with normal command line switches, but you\n"
+"  can also specify the long options without the dashes to make it more\n"
+"  readable. You can separate the options and the parameter with spaces, or\n"
+"  with = or :. Comments can be used within the file. If the first letter on a\n"
+"  line is a '#'-letter the rest of the line is treated as a comment.\n"
+"\n"
+"  If you want the parameter to contain spaces, you must inclose the entire\n"
+"  parameter within double quotes (\"). Within those quotes, you specify a\n"
+"  quote as \\\".\n"
+"\n"
+"  NOTE: You must specify options and their arguments on the same line.\n"
 "\n"
 "  Example, set default time out and proxy in a config file:\n"
 "\n"
 "        # We want a 30 minute timeout:\n"
 "        -m 1800\n"
 "        # ... and we use a proxy for all accesses:\n"
-"        -x proxy.our.domain.com:8080\n"
+"        proxy = proxy.our.domain.com:8080\n"
 "\n"
 "  White spaces ARE significant at the end of lines, but all white spaces\n"
 "  leading up to the first characters of each line are ignored.\n"
 "\n"
 "  Prevent curl from reading the default file by using -q as the first command\n"
 "  line parameter, like:\n"
@@ -1208,20 +1250,20 @@
 "        curl -q www.thatsite.com\n"
 "\n"
 "  Force curl to get and display a local help page in case it is invoked\n"
 "  without URL by making a config file similar to:\n"
 "\n"
 "        # default url to get\n"
-"        http://help.with.curl.com/curlhelp.html\n"
+"        url = \"http://help.with.curl.com/curlhelp.html\"\n"
 "\n"
 "  You can specify another config file to be read by using the -K/--config\n"
 "  flag. If you set config file name to \"-\" it'll read the config from stdin,\n"
 "  which can be handy if you want to hide options from being visible in process\n"
 "  tables etc:\n"
 "\n"
-"        echo \"-u user:passwd\" | curl -K - http://that.secret.site.com\n"
+"        echo \"user = user:passwd\" | curl -K - http://that.secret.site.com\n"
 "\n"
 "EXTRA HEADERS\n"
 "\n"
 "  When using curl in your own very special programs, you may end up needing\n"
 "  to pass on your own custom headers when getting a web page. You can do\n"
 "  this by using the -H flag.\n"
@@ -1302,12 +1344,14 @@
 "\n"
 "  Example:\n"
 "\n"
 "        curl https://www.secure-site.com\n"
 "\n"
 "  Curl is also capable of using your personal certificates to get/post files\n"
+);
+ puts(
 "  from sites that require valid certificates. The only drawback is that the\n"
 "  certificate needs to be in PEM-format. PEM is a standard and open format to\n"
 "  store certificates with, but it is not used by the most commonly used\n"
 "  browsers (Netscape and MSEI both use the so called PKCS#12 format). If you\n"
 "  want curl to use the certificates you use with your (favourite) browser, you\n"
 "  may need to download/compile a converter that can convert your browser's\n"
@@ -1330,14 +1374,12 @@
 "  SSL-version curl should use. Use -3 or -2 to specify that exact SSL version\n"
 "  to use:\n"
 "\n"
 "        curl -2 https://secure.site.com/\n"
 "\n"
 "  Otherwise, curl will first attempt to use v3 and then v2.\n"
-);
- puts(
 "\n"
 "  To use OpenSSL to convert your favourite browser's certificate into a PEM\n"
 "  formatted one that curl can use, do something like this (assuming netscape,\n"
 "  but IE is likely to work similarly):\n"
 "\n"
 "    You start with hitting the 'security' menu button in netscape. \n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/main.c	2000-11-13 22:07:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/main.c	2000-11-28 17:10:43.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/src/main.c,v $
- * $Revision: 1.41 $
- * $Date: 2000/11/13 11:59:19 $
+ * $Revision: 1.52 $
+ * $Date: 2000/11/28 09:10:43 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -50,12 +50,14 @@
 #include <curl/easy.h> /* new for v7 */
 
 #define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "urlglob.h"
+#include "writeout.h"
+
 #define CURLseparator	"--_curl_--"
 #define MIMEseparator	"_curl_"
 
 /* This define make use of the "Curlseparator" as opposed to the
    MIMEseparator. We might add support for the latter one in the
    future, and that's why this is left in the source. */
@@ -85,16 +87,21 @@
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 /* this is low-level hard-hacking memory leak tracking shit */
 #include "../lib/memdebug.h"
 #endif
 
+#define DEFAULT_MAXREDIRS  50L
+
 #ifndef __cplusplus        /* (rabe) */
 typedef char bool;
 #endif                     /* (rabe) */
 
+#define CURL_PROGRESS_STATS 0 /* default progress display */
+#define CURL_PROGRESS_BAR   1
+
 typedef enum {
   HTTPREQ_UNSPEC,
   HTTPREQ_GET,
   HTTPREQ_HEAD,
   HTTPREQ_POST,
   HTTPREQ_SIMPLEPOST,
@@ -102,12 +109,13 @@
   HTTPREQ_LAST
 } HttpReq;
 
 /* Just a set of bits */
 #define CONF_DEFAULT  0
 
+#define CONF_USEREMOTETIME (1<<0) /* set the remote time on the local file */
 #define CONF_AUTO_REFERER (1<<4) /* the automatic referer-system please! */
 #define CONF_VERBOSE  (1<<5) /* talk a lot */
 #define CONF_HEADER   (1<<8) /* throw the header out too */
 #define CONF_NOPROGRESS (1<<10) /* shut off the progress meter */
 #define CONF_NOBODY   (1<<11) /* use HEAD to get http document */
 #define CONF_FAILONERROR (1<<12) /* no output on http error codes >= 300 */
@@ -210,16 +218,16 @@
 
 int SetHTTPrequest(HttpReq req, HttpReq *store)
 {
   if((*store == HTTPREQ_UNSPEC) ||
      (*store == req)) {
     *store = req;
-    return CURLE_OK;
+    return 0;
   }
   fprintf(stderr, "You can only select one HTTP request!\n");
-  return CURLE_FAILED_INIT;
+  return 1;
 }
 
 static void helpf(char *fmt, ...)
 {
   va_list ap;
   if(fmt) {
@@ -244,13 +252,14 @@
        " -C/--continue-at <offset> Specify absolute resume offset\n"
        " -d/--data <data>   HTTP POST data (H)\n"
        "    --data-ascii <data>   HTTP POST ASCII data (H)\n"
        "    --data-binary <data>  HTTP POST binary data (H)\n"
        " -D/--dump-header <file> Write the headers to this file\n"
        " -e/--referer       Referer page (H)\n"
-       " -E/--cert <cert:passwd> Specifies your certificate file and password (HTTPS)\n"
+       " -E/--cert <cert[:passwd]> Specifies your certificate file and password (HTTPS)\n"
+       "    --cacert <file> CA certifciate to verify peer against (HTTPS)\n"
        " -f/--fail          Fail silently (no output at all) on errors (H)\n"
        " -F/--form <name=content> Specify HTTP POST data (H)\n"
 
        " -h/--help          This help text\n"
        " -H/--header <line> Custom header to pass to server. (H)\n"
        " -i/--include       Include the HTTP-header in the output (H)\n"
@@ -272,22 +281,23 @@
        " -Q/--quote <cmd>   Send QUOTE command to FTP before file transfer (F)\n"
        " -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server\n"
        " -s/--silent        Silent mode. Don't output anything\n"
        " -S/--show-error    Show error. With -s, make curl show errors when they occur\n"
        " -t/--upload        Transfer/upload stdin to remote site\n"
        " -T/--upload-file <file> Transfer/upload <file> to remote site\n"
-       " -u/--user <user:password> Specify user and password to use\n"
-       " -U/--proxy-user <user:password> Specify Proxy authentication\n"
+       " -u/--user <user[:password]> Specify user and password to use\n"
+       " -U/--proxy-user <user[:password]> Specify Proxy authentication\n"
        " -v/--verbose       Makes the operation more talkative\n"
        " -V/--version       Outputs version number then quits\n"
        " -w/--write-out [format] What to output after completion\n"
        " -x/--proxy <host[:port]>  Use proxy. (Default port is 1080)\n"
        " -X/--request <command> Specific request command to use\n"
        " -y/--speed-time    Time needed to trig speed-limit abort. Defaults to 30\n"
        " -Y/--speed-limit   Stop transfer if below speed-limit for 'speed-time' secs\n"
        " -z/--time-cond <time> Includes a time condition to the server (H)\n"
+       " -Z/--max-redirs <num> Set maximum number of redirections allowed (H)\n"
        " -2/--sslv2         Force usage of SSLv2 (H)\n"
        " -3/--sslv3         Force usage of SSLv3 (H)\n"
        " -#/--progress-bar  Display transfer progress as a progress bar\n"
        "    --crlf          Convert LF to CRLF in upload. Useful for MVS (OS/390)\n"
        "    --stderr <file> Where to redirect stderr. - means stdout.\n",
          curl_version()
@@ -306,12 +316,13 @@
   bool use_resume;
   int resume_from;
   char *postfields;
   long postfieldsize;
   char *referer;
   long timeout;
+  long maxredirs;
   char *outfile;
   char *headerfile;
   char remotefile;
   char *ftpport;
   char *iface;
   unsigned short porttouse;
@@ -325,12 +336,13 @@
   char *proxy;
   bool configread;
   bool proxytunnel;
   long conf;
   char *url;
   char *cert;
+  char *cacert;
   char *cert_passwd;
   bool crlf;
   char *cookiefile;
   char *customrequest;
   char *krb4level;
   bool progressmode;
@@ -355,13 +367,12 @@
   HttpReq httpreq;
 };
 
 static int parseconfig(char *filename,
 		       struct Configurable *config);
 static char *my_get_line(FILE *fp);
-static char *my_get_token(const char *line);
 
 static void GetStr(char **string,
 		   char *value)
 {
   if(*string)
     free(*string);
@@ -403,20 +414,19 @@
     return NULL; /* no string */
 }
 
 static char *file2memory(FILE *file, long *size)
 {
   char buffer[1024];
-  char *ptr;
   char *string=NULL;
   char *newstring=NULL;
   long len=0;
   long stringlen=0;
 
   if(file) {
-    while(len = fread(buffer, 1, sizeof(buffer), file)) {
+    while((len = fread(buffer, 1, sizeof(buffer), file))) {
       if(string) {
         newstring = realloc(string, len+stringlen);
         if(newstring)
           string = newstring;
         else
           break; /* no more strings attached! :-) */
@@ -430,17 +440,29 @@
     return string;
   }
   else
     return NULL; /* no string */
 }
 
-static int getparameter(char *flag, /* f or -long-flag */
-			char *nextarg, /* NULL if unset */
-			bool *usedarg, /* set to TRUE if the arg has been
-					  used */
-			struct Configurable *config)
+typedef enum {
+  PARAM_OK,
+  PARAM_OPTION_AMBIGUOUS,
+  PARAM_OPTION_UNKNOWN,
+  PARAM_REQUIRES_PARAMETER,  
+  PARAM_BAD_USE,
+  PARAM_HELP_REQUESTED,
+  PARAM_GOT_EXTRA_PARAMETER,
+
+  PARAM_LAST
+} ParameterError;
+
+static ParameterError getparameter(char *flag, /* f or -long-flag */
+                                   char *nextarg, /* NULL if unset */
+                                   bool *usedarg, /* set to TRUE if the arg
+                                                     has been used */
+                                   struct Configurable *config)
 {
   char letter;
   char subletter=0; /* subletters can only occur on long options */
 
   char *parse=NULL;
   int res;
@@ -455,12 +477,13 @@
      */
   struct LongShort aliases[]= {
     {"9", "crlf",        FALSE},
     {"8", "stderr",      TRUE},
     {"7", "interface",   TRUE},
     {"6", "krb4",        TRUE},
+    {"5", "url",         TRUE},
 
     {"2", "sslv2",       FALSE},
     {"3", "sslv3",       FALSE},
     {"a", "append",      FALSE},
     {"A", "user-agent",  TRUE},
     {"b", "cookie",      TRUE},
@@ -471,12 +494,13 @@
     {"d", "data",        TRUE},
     {"da", "data-ascii", TRUE},
     {"db", "data-binary", TRUE},
     {"D", "dump-header", TRUE},
     {"e", "referer",     TRUE},
     {"E", "cert",        TRUE},
+    {"Ea", "cacert",     TRUE},
     {"f", "fail",        FALSE},
     {"F", "form",        TRUE},
 
     {"h", "help",        FALSE},
     {"H", "header",      TRUE},
     {"i", "include",     FALSE},
@@ -507,44 +531,46 @@
     {"x", "proxy",       TRUE},
     {"X", "request",     TRUE},
     {"X", "http-request", TRUE}, /* OBSOLETE VERSION */
     {"Y", "speed-limit",  TRUE},
     {"y", "speed-time", TRUE},
     {"z", "time-cond",   TRUE},
+    {"Z", "max-redirs",   TRUE},
     {"#", "progress-bar",FALSE},
   };
 
-  if('-' == flag[0]) {
-    /* try a long name */
-    int fnam=strlen(&flag[1]);
+  if(('-' != flag[0]) ||
+     (('-' == flag[0]) && ('-' == flag[1]))) {
+    /* this should be a long name */
+    char *word=('-' == flag[0])?flag+2:flag;
+    int fnam=strlen(word);
     int numhits=0;
     for(j=0; j< sizeof(aliases)/sizeof(aliases[0]); j++) {
-      if(strnequal(aliases[j].lname, &flag[1], fnam)) {
+      if(strnequal(aliases[j].lname, word, fnam)) {
         longopt = TRUE;
         numhits++;
-        if(strequal(aliases[j].lname, &flag[1])) {
+        if(strequal(aliases[j].lname, word)) {
           parse = aliases[j].letter;
           hit = j;
           numhits = 1; /* a single unique hit */
           break;
         }
 	parse = aliases[j].letter;
 	hit = j;
       }
     }
     if(numhits>1) {
       /* this is at least the second match! */
-      helpf("option --%s is ambiguous\n", &flag[1]);
-      return CURLE_FAILED_INIT;
+      return PARAM_OPTION_AMBIGUOUS;
     }
     if(hit < 0) {
-      helpf("unknown option -%s.\n", flag);
-      return CURLE_FAILED_INIT;
+      return PARAM_OPTION_UNKNOWN;
     }    
   }
   else {
+    flag++; /* prefixed with one dash, pass it */
     hit=-1;
     parse = flag;
   }
 
   do {
     /* we can loop here if we have multiple single-letters */
@@ -565,64 +591,25 @@
 	if(letter == aliases[j].letter[0]) {
 	  hit = j;
 	  break;
 	}
       }
       if(hit < 0) {
-	helpf("unknown option -%c.\n", letter);
-	return CURLE_FAILED_INIT;      
+	return PARAM_OPTION_UNKNOWN;
       }
     }
     if(hit < 0) {
-      helpf("unknown option -%c.\n", letter);
-      return CURLE_FAILED_INIT;
+      return PARAM_OPTION_UNKNOWN;
     }    
-    if(!nextarg && aliases[hit].extraparam) {
-      helpf("option -%s/--%s requires an extra argument!\n",
-	    aliases[hit].letter,
-	    aliases[hit].lname);
-      return CURLE_FAILED_INIT;
+    if((!nextarg || !*nextarg) && aliases[hit].extraparam) {
+      return PARAM_REQUIRES_PARAMETER;
     }
     else if(nextarg && aliases[hit].extraparam)
       *usedarg = TRUE; /* mark it as used */
 
     switch(letter) {
-    case 'z': /* time condition coming up */
-      switch(*nextarg) {
-      case '+':
-        nextarg++;
-      default:
-        /* If-Modified-Since: (section 14.28 in RFC2068) */
-        config->timecond = TIMECOND_IFMODSINCE;
-        break;
-      case '-':
-        /* If-Unmodified-Since:  (section 14.24 in RFC2068) */
-        config->timecond = TIMECOND_IFUNMODSINCE;
-        nextarg++;
-        break;
-      case '=':
-        /* Last-Modified:  (section 14.29 in RFC2068) */
-        config->timecond = TIMECOND_LASTMOD;
-        nextarg++;
-        break;
-      }
-      now=time(NULL);
-      config->condtime=curl_getdate(nextarg, &now);
-      if(-1 == config->condtime) {
-        /* now let's see if it is a file name to get the time from instead! */
-        struct stat statbuf;
-        if(-1 == stat(nextarg, &statbuf)) {
-          /* failed, remove time condition */
-          config->timecond = TIMECOND_NONE;
-        }
-        else {
-          /* pull the time out from the file */
-          config->condtime = statbuf.st_mtime;
-        }
-      }
-      break;
     case '9': /* there is no short letter for this */
       /* LF -> CRLF conversinon? */
       config->crlf = TRUE;
       break;
     case '8': /* there is no short letter for this */
       if(strcmp(nextarg, "-"))
@@ -635,12 +622,16 @@
       GetStr(&config->iface, nextarg);
       break;
     case '6': /* there is no short letter for this */
       /* krb4 level string */
       GetStr(&config->krb4level, nextarg);
       break;
+    case '5':
+      /* the URL! */
+      GetStr(&config->url, nextarg);
+      break;
     case '#': /* added 19990617 larsa */
       config->progressmode ^= CURL_PROGRESS_BAR;
       break;
     case '2': 
       /* SSL version 2 */
       config->ssl_version = 2;
@@ -690,13 +681,12 @@
         char *postdata=NULL;
 
         if('@' == *nextarg) {
           /* the data begins with a '@' letter, it means that a file name
              or - (stdin) follows */
           FILE *file;
-          char *ptr;
 
           nextarg++; /* pass the @ */
 
           if(strequal("-", nextarg))
             file = stdin;
           else 
@@ -724,13 +714,13 @@
         else
           config->postfields=postdata;
       }
       if(config->postfields)
         config->conf |= CONF_POST;
       if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq))
-        return CURLE_FAILED_INIT;
+        return PARAM_BAD_USE;
       break;
     case 'D':
       /* dump-header to given file name */
       GetStr(&config->headerfile, nextarg);
       break;
     case 'e':
@@ -743,13 +733,17 @@
           *ptr = 0; /* zero terminate here */
         }
         GetStr(&config->referer, nextarg);
       }
       break;
     case 'E':
-      {
+      if(subletter == 'a') {
+        /* CA info PEM file */
+        GetStr(&config->cacert, nextarg);
+      }
+      else {
 	char *ptr = strchr(nextarg, ':');
 	if(ptr) {
 	  /* we have a password too */
 	  *ptr=0;
 	  ptr++;
 	  GetStr(&config->cert_passwd, ptr);
@@ -764,32 +758,32 @@
     case 'F':
       /* "form data" simulation, this is a little advanced so lets do our best
 	 to sort this out slowly and carefully */
       if(curl_formparse(nextarg,
                         &config->httppost,
                         &config->last_post))
-	return CURLE_FAILED_INIT;    
+	return PARAM_BAD_USE;
       if(SetHTTPrequest(HTTPREQ_POST, &config->httpreq))
-        return CURLE_FAILED_INIT;
+        return PARAM_BAD_USE;
       break;
 
     case 'h': /* h for help */
       help();
-      return CURLE_FAILED_INIT;
+      return PARAM_HELP_REQUESTED;
     case 'H':
       /* A custom header to append to a list */
       config->headers = curl_slist_append(config->headers, nextarg);
       break;
     case 'i':
       config->conf ^= CONF_HEADER; /* include the HTTP header as well */
       break;
     case 'I':
       config->conf ^= CONF_HEADER; /* include the HTTP header in the output */
       config->conf ^= CONF_NOBODY; /* don't fetch the body at all */
       if(SetHTTPrequest(HTTPREQ_HEAD, &config->httpreq))
-        return CURLE_FAILED_INIT;
+        return PARAM_BAD_USE;
       break;
     case 'K':
       res = parseconfig(nextarg, config);
       config->configread = TRUE;
       if(res)
 	return res;
@@ -803,13 +797,13 @@
     case 'm':
       /* specified max time */
       config->timeout = atoi(nextarg);
       break;
     case 'M': /* M for manual, huge help */
       hugehelp();
-      return CURLE_FAILED_INIT;
+      return PARAM_HELP_REQUESTED;
     case 'n':
       /* pick info from .netrc, if this is used for http, curl will
 	 automatically enfore user+password with the request */
       config->conf ^= CONF_NETRC;
       break;
     case 'N':
@@ -886,13 +880,13 @@
       break;
     case 'v':
       config->conf ^= CONF_VERBOSE; /* talk a lot */
       break;
     case 'V':
       printf(CURL_ID "%s\n", curl_version());
-      return CURLE_FAILED_INIT;
+      return PARAM_HELP_REQUESTED;
     case 'w':
       /* get the output string */
       if('@' == *nextarg) {
         /* the data begins with a '@' letter, it means that a file name
            or - (stdin) follows */
         FILE *file;
@@ -913,13 +907,13 @@
       GetStr(&config->proxy, nextarg);
       break;
     case 'X':
       /* HTTP request */
       GetStr(&config->customrequest, nextarg);
       if(SetHTTPrequest(HTTPREQ_CUSTOM, &config->httpreq))
-        return CURLE_FAILED_INIT;
+        return PARAM_BAD_USE;
       break;
     case 'y':
       /* low speed time */
       config->low_speed_time = atoi(nextarg);
       if(!config->low_speed_limit)
 	config->low_speed_limit = 1;
@@ -927,50 +921,83 @@
     case 'Y':
       /* low speed limit */
       config->low_speed_limit = atoi(nextarg);
       if(!config->low_speed_time)
 	config->low_speed_time=30;
       break;
+    case 'z': /* time condition coming up */
+      switch(*nextarg) {
+      case '+':
+        nextarg++;
+      default:
+        /* If-Modified-Since: (section 14.28 in RFC2068) */
+        config->timecond = TIMECOND_IFMODSINCE;
+        break;
+      case '-':
+        /* If-Unmodified-Since:  (section 14.24 in RFC2068) */
+        config->timecond = TIMECOND_IFUNMODSINCE;
+        nextarg++;
+        break;
+      case '=':
+        /* Last-Modified:  (section 14.29 in RFC2068) */
+        config->timecond = TIMECOND_LASTMOD;
+        nextarg++;
+        break;
+      }
+      now=time(NULL);
+      config->condtime=curl_getdate(nextarg, &now);
+      if(-1 == config->condtime) {
+        /* now let's see if it is a file name to get the time from instead! */
+        struct stat statbuf;
+        if(-1 == stat(nextarg, &statbuf)) {
+          /* failed, remove time condition */
+          config->timecond = TIMECOND_NONE;
+        }
+        else {
+          /* pull the time out from the file */
+          config->condtime = statbuf.st_mtime;
+        }
+      }
+      break;
+    case 'Z':
+      /* specified max no of redirects (http(s)) */
+      config->maxredirs = atoi(nextarg);
+      break;
 
     default: /* unknown flag */
-      if(letter)	
-	helpf("Unknown option '%c'\n", letter);
-      else
-	helpf("Unknown option\n"); /* short help blurb */
-      return CURLE_FAILED_INIT;
+      return PARAM_OPTION_UNKNOWN;
     }
     hit = -1;
 
   } while(*++parse && !*usedarg);
 
-  return CURLE_OK;
+  return PARAM_OK;
 }
 
 
 static int parseconfig(char *filename,
 		       struct Configurable *config)
 {
   int res;
   FILE *file;
-  char configbuffer[4096];
   char filebuffer[256];
   bool usedarg;
   char *home=NULL;
   
   if(!filename || !*filename) {
     /* NULL or no file name attempts to load .curlrc from the homedir! */
 
 #define CURLRC DOT_CHAR "curlrc"
 
     home = curl_getenv("HOME"); /* portable environment reader */
 
     if(!home)
-      return CURLE_OK;
+      return 0;
     if(strlen(home)>(sizeof(filebuffer)-strlen(CURLRC))) {
       free(home);
-      return CURLE_OK;
+      return 0;
     }
 
     sprintf(filebuffer, "%s%s%s", home, DIR_CHAR, CURLRC);
 
     filename = filebuffer;
   }
@@ -979,91 +1006,169 @@
     file = fopen(filename, "r");
   else
     file = stdin;
   
   if(file) {
     char *line;
-    char *tok1;
-    char *tok2;
-    
-    while (NULL != (line = my_get_line(file))) {
+    char *aline;
+    char *option;
+    char *param;
+    int lineno=0;
+    bool alloced_param;
+
+#define isseparator(x) (((x)=='=') || ((x) == ':'))
+
+    while (NULL != (aline = my_get_line(file))) {
+      lineno++;
+      line = aline;
+      alloced_param=FALSE;
+
       /* lines with # in the fist column is a comment! */
-      if ('#' == line[0]) {
-        free(line);
-        continue;
-      }
+      while(isspace((int)*line))
+        line++;
 
-      if (NULL == (tok1 = my_get_token(line))) {
+      switch(*line) {
+      case '#':
+      case '/':
+      case '\r':
+      case '\n':
+      case '*':
+      case '\0':
         free(line);
         continue;
       }
-      if ('-' != tok1[0]) {
-        if (config->url)
-          free(config->url);
-        config->url = tok1;
-      }
 
-      while ((NULL != tok1) && ('-' == tok1[0])) {
-        tok2 = my_get_token(NULL);
-        while (NULL == tok2) {
-          free(line);
-          if (NULL == (line = my_get_line(file)))
-            break;
-          if ('#' == line[0])
-            continue;
-          tok2 = my_get_token(line);
-        }
+      /* the option keywords starts here */
+      option = line;
+      while(*line && !isspace((int)*line) && !isseparator(*line))
+        line++;
+      /* ... and has ended here */
 
-        res = getparameter(tok1 + 1, tok2, &usedarg, config);
-        free(tok1);
-        if (!usedarg) {
-          if ('-' != tok2[0]) {
-            /* this is not an option, this is a URL */
-            if (config->url)
-              free(config->url);
-            config->url = tok2;
-            break;
+      *line++=0; /* zero terminate, we have a local copy of the data */
+
+#ifdef DEBUG_CONFIG
+      fprintf(stderr, "GOT: %s\n", option);
+#endif
+
+      /* pass spaces and separator(s) */
+      while(isspace((int)*line) || isseparator(*line))
+        line++;
+      
+      /* the parameter starts here (unless quoted) */
+      if(*line == '\"') {
+        char *ptr;
+        /* quoted parameter, do the qoute dance */
+        line++;
+        param=strdup(line); /* parameter */
+        alloced_param=TRUE;
+
+        ptr=param;
+        while(*line && (*line != '\"')) {
+          if(*line == '\\') {
+            char out;
+            line++;
+
+            /* default is to output the letter after the backslah */
+            switch(out = *line) {
+            case '\0':
+              continue; /* this'll break out of the loop */
+            case 't':
+              out='\t';
+              break;
+            case 'n':
+              out='\n';
+              break;
+            case 'r':
+              out='\r';
+              break;
+            case 'v':
+              out='\v';
+              break;
+            }
+            *ptr++=out;
+            line++;
           }
           else
-            tok1 = tok2;
+            *ptr++=*line++;
         }
-        else {
-          free(tok2);
-          break;
+        *ptr=0; /* always zero terminate */
+
+      }
+      else {
+        param=line; /* parameter starts here */
+        while(*line && !isspace((int)*line))
+          line++;
+        *line=0; /* zero terminate */
+      }
+#ifdef DEBUG_CONFIG
+      fprintf(stderr, "PARAM: \"%s\"\n", param);
+#endif
+      res = getparameter(option, param, &usedarg, config);
+
+      if(*param && !usedarg)
+        /* we passed in a parameter that wasn't used! */
+        res = PARAM_GOT_EXTRA_PARAMETER;
+
+      if(res != PARAM_OK) {
+        /* the help request isn't really an error */
+        if(!strcmp(filename, "-")) {
+          filename="<stdin>";
+        }
+        if(PARAM_HELP_REQUESTED != res) {
+          char *reason;
+          switch(res) {
+          default:
+          case PARAM_GOT_EXTRA_PARAMETER:
+            reason = "had unsupported trailing garbage";
+            break;
+          case PARAM_OPTION_UNKNOWN:
+            reason = "is unknown";
+            break;
+          case PARAM_OPTION_AMBIGUOUS:
+            reason = "is ambiguous";
+            break;
+          case PARAM_REQUIRES_PARAMETER:
+            reason = "requires parameter";
+            break;
+          case PARAM_BAD_USE:
+            reason = "is badly used here";
+            break;
+          }
+          fprintf(stderr, "%s:%d: warning: '%s' %s\n",
+                  filename, lineno, option, reason);
         }
-        if(res)
-          break; /* error detected */
       }
 
-      free(line);
+      if(alloced_param)
+        free(param);
+
+      free(aline);
     }
     if(file != stdin)
       fclose(file);
   }
   if(home)
     free(home);
-  return CURLE_OK;
+  return 0;
 }
 
 struct OutStruct {
   char *filename;
   FILE *stream;
+  struct Configurable *config;
 };
 
-/* having this global is a bit dirty, but hey, who said we weren't? ;-) */
-struct Configurable config;
-
 int my_fwrite(void *buffer, size_t size, size_t nmemb, FILE *stream)
 {
   struct OutStruct *out=(struct OutStruct *)stream;
   if(out && !out->stream) {
     /* open file for writing */
     out->stream=fopen(out->filename, "wb");
     if(!out->stream)
       return -1; /* failure */
-    if(config.nobuffer) {
+    if(out->config->nobuffer) {
       /* disable output buffering */
 #ifdef HAVE_SETVBUF
       setvbuf(out->stream, NULL, _IONBF, 0);
 #endif
     }
   }
@@ -1091,14 +1196,12 @@
   char format[40];
   float frac;
   float percent;
   int barwidth;
   int num;
   int i;
-  int prevblock;
-  int thisblock;
 
   struct ProgressData *bar = (struct ProgressData *)clientp;
   size_t total = dltotal + ultotal;
 
   bar->point = dlnow + ulnow; /* we've come this far */
 
@@ -1162,13 +1265,57 @@
   _scrsize(scr_size);
   bar->width = scr_size[0] - 1;
 #endif
 
 }
 
-int main(int argc, char *argv[])
+void free_config_fields(struct Configurable *config)
+{
+  if(config->url)
+    free(config->url);
+  if(config->userpwd)
+    free(config->userpwd);
+  if(config->postfields)
+    free(config->postfields);
+  if(config->proxy)
+    free(config->proxy);
+  if(config->proxyuserpwd)
+    free(config->proxyuserpwd);
+  if(config->cookie)
+    free(config->cookie);
+  if(config->cookiefile)
+    free(config->cookiefile);
+  if(config->krb4level)
+    free(config->krb4level);
+  if(config->headerfile)
+    free(config->headerfile);
+  if(config->outfile)
+    free(config->outfile);
+  if(config->ftpport)
+    free(config->ftpport);
+  if(config->infile)
+    free(config->infile);
+  if(config->range)
+    free(config->range);
+  if(config->customrequest)
+    free(config->customrequest);
+  if(config->writeout)
+    free(config->writeout);
+  if(config->httppost)
+    curl_formfree(config->httppost);
+  if(config->cacert)
+    free(config->cacert);
+
+  curl_slist_free_all(config->quote); /* checks for config->quote == NULL */
+  curl_slist_free_all(config->postquote); /*  */
+  curl_slist_free_all(config->headers); /*  */
+}
+
+
+static int 
+operate(struct Configurable *config, int argc, char *argv[])
 {
   char errorbuffer[CURL_ERROR_SIZE];
   char useragent[128]; /* buah, we don't want a larger default user agent */
   struct ProgressData progressbar;
 
   struct OutStruct outs;
@@ -1184,30 +1331,31 @@
   FILE *infd = stdin;
   FILE *headerfilep = NULL;
   char *urlbuffer=NULL;
   int infilesize=-1; /* -1 means unknown */
   bool stillflags=TRUE;
 
+  bool allocuseragent=FALSE;
+
   CURL *curl;
   int res;
   int i;
 
   outs.stream = stdout;
+  outs.config = config;
 
 #ifdef MALLOCDEBUG
   /* this sends all memory debug messages to a logfile named memdump */
   curl_memdebug("memdump");
 #endif
 
-  memset(&config, 0, sizeof(struct Configurable));
-  
-  config.showerror=TRUE;
-  config.conf=CONF_DEFAULT;
+  config->showerror=TRUE;
+  config->conf=CONF_DEFAULT;
 #if 0
-  config.crlf=FALSE;
-  config.quote=NULL;
+  config->crlf=FALSE;
+  config->quote=NULL;
 #endif
 
   if(argc>1 &&
      (!strnequal("--", argv[1], 2) && (argv[1][0] == '-')) &&
      strchr(argv[1], 'q')) {
     /*
@@ -1217,44 +1365,60 @@
 #if 0
     fprintf(stderr, "I TURNED OFF THE CRAP\n");
 #endif
     ;
   }
   else {
-    res = parseconfig(NULL, &config);
+    res = parseconfig(NULL, config);
     if(res)
       return res;
   }
 
-  if ((argc < 2)  && !config.url) {
+  if ((argc < 2)  && !config->url) {
     helpf(NULL);
     return CURLE_FAILED_INIT;
   }
 
   /* Parse options */
   for (i = 1; i < argc; i++) {
     if(stillflags &&
        ('-' == argv[i][0])) {
       char *nextarg;
       bool passarg;
+      char *origopt=argv[i];
       
-      char *flag = &argv[i][1];
+      char *flag = argv[i];
 
       if(strequal("--", argv[i]))
 	/* this indicates the end of the flags and thus enables the
 	   following (URL) argument to start with -. */
 	stillflags=FALSE;
       else {
 	nextarg= (i < argc - 1)? argv[i+1]: NULL;
 
-	res = getparameter ( flag,
-			     nextarg,
-			     &passarg,
-			   &config );
-	if(res)
-	  return res;
+	res = getparameter(flag, nextarg, &passarg, config);
+	if(res) {
+          switch(res) {
+          case PARAM_OPTION_AMBIGUOUS:
+            helpf("option %s is ambiguous\n", origopt);
+            break;
+          case PARAM_OPTION_UNKNOWN:
+            helpf("option %s is unknown\n", origopt);
+            break;
+          case PARAM_REQUIRES_PARAMETER:
+            helpf("option %s requires an extra argument!\n", origopt);
+            break;
+          case PARAM_BAD_USE:
+            helpf("option %s was wrongly used!\n", origopt);
+            break;
+          case PARAM_HELP_REQUESTED:
+            /* no text */
+            break;
+          }
+	  return CURLE_FAILED_INIT;
+        }
 
 	if(passarg) /* we're supposed to skip this */
 	  i++;
       }
     }
     else {
@@ -1265,368 +1429,362 @@
       url = argv[i];
     }
   }
 
   /* if no URL was specified and there was one in the config file, get that
      one */
-  if(!url && config.url)
-    url = config.url;
+  if(!url && config->url)
+    url = config->url;
   
   if(!url) {
     helpf("no URL specified!\n");
     return CURLE_FAILED_INIT;
   }
-  if(NULL == config.useragent) {
+  if(NULL == config->useragent) {
     /* set non-zero default values: */
     snprintf(useragent, sizeof(useragent),
              CURL_NAME "/" CURL_VERSION " (" OS ") " "%s", curl_version());
-    config.useragent= useragent;
+    config->useragent= useragent;
   }
+  else
+    allocuseragent = TRUE;
 #if 0
-  fprintf(stderr, "URL: %s PROXY: %s\n", url, config.proxy?config.proxy:"none");
+  fprintf(stderr, "URL: %s PROXY: %s\n", url, config->proxy?config->proxy:"none");
 #endif
 
   /* expand '{...}' and '[...]' expressions and return total number of URLs
      in pattern set */
   res = glob_url(&urls, url, &urlnum);
   if(res != CURLE_OK)
     return res;
 
-  outfiles = config.outfile;		/* save outfile pattern befor expansion */
-  if (!outfiles && !config.remotefile && urlnum > 1) {
+  /* save outfile pattern befor expansion */
+  outfiles = config->outfile?strdup(config->outfile):NULL;
+
+  if (!outfiles && !config->remotefile && urlnum > 1) {
 #ifdef CURL_SEPARATORS
     /* multiple files extracted to stdout, insert separators! */
     separator = 1;
 #endif
 #ifdef MIME_SEPARATORS
     /* multiple files extracted to stdout, insert MIME separators! */
     separator = 1;
     printf("MIME-Version: 1.0\n");
     printf("Content-Type: multipart/mixed; boundary=%s\n\n", MIMEseparator);
 #endif
   }
   for (i = 0; (url = next_url(urls)); ++i) {
-    if (outfiles)
-      config.outfile = strdup(outfiles);
-
-#if 0
-  if(config.outfile && config.infile) {
-    helpf("you can't both upload and download!\n");
-    return CURLE_FAILED_INIT;
-  }
-#endif
+    if (outfiles) {
+      free(config->outfile);
+      config->outfile = outfiles;
+    }
  
-  if (config.outfile || config.remotefile) {
-    /* 
-     * We have specified a file name to store the result in, or we have
-     * decided we want to use the remote file name.
-     */
-
-    if(config.remotefile) {
-      /* Find and get the remote file name */
-      config.outfile=strstr(url, "://");
-      if(config.outfile)
-        config.outfile+=3;
-      else
-        config.outfile=url;
-      config.outfile = strrchr(config.outfile, '/');
-      if(!config.outfile || !strlen(++config.outfile)) {
-        helpf("Remote file name has no length!\n");
-        return CURLE_WRITE_ERROR;
+    if (config->outfile || config->remotefile) {
+      /* 
+       * We have specified a file name to store the result in, or we have
+       * decided we want to use the remote file name.
+       */
+      
+      if(!config->outfile && config->remotefile) {
+        /* Find and get the remote file name */
+        config->outfile=strstr(url, "://");
+        if(config->outfile)
+          config->outfile+=3;
+        else
+          config->outfile=url;
+        config->outfile = strdup(strrchr(config->outfile, '/'));
+        if(!config->outfile || !strlen(++config->outfile)) {
+          helpf("Remote file name has no length!\n");
+          return CURLE_WRITE_ERROR;
+        }
+      }
+      else {
+	/* fill '#1' ... '#9' terms from URL pattern */
+        char *outfile = config->outfile;
+        config->outfile = match_url(config->outfile, *urls);
+        free(outfile);
+      }
+      
+      if((0 == config->resume_from) && config->use_resume) {
+        /* we're told to continue where we are now, then we get the size of the
+           file as it is now and open it for append instead */
+        struct stat fileinfo;
+
+        if(0 == stat(config->outfile, &fileinfo)) {
+          /* set offset to current file size: */
+          config->resume_from = fileinfo.st_size;
+        }
+        /* else let offset remain 0 */
+      }
+      
+      if(config->resume_from) {
+        /* open file for output: */
+        outs.stream=(FILE *) fopen(config->outfile, config->resume_from?"ab":"wb");
+        if (!outs.stream) {
+          helpf("Can't open '%s'!\n", config->outfile);
+          return CURLE_WRITE_ERROR;
+        }
+      }
+      else {
+        outs.filename = config->outfile;
+        outs.stream = NULL; /* open when needed */
       }
     }
-    else	/* fill '#1' ... '#9' terms from URL pattern */
-      config.outfile = match_url(config.outfile, *urls);
-
-    if((0 == config.resume_from) && config.use_resume) {
-      /* we're told to continue where we are now, then we get the size of the
-	 file as it is now and open it for append instead */
+    if (config->infile) {
+      /*
+       * We have specified a file to upload
+       */
       struct stat fileinfo;
 
-      if(0 == stat(config.outfile, &fileinfo)) {
-	/* set offset to current file size: */
-	config.resume_from = fileinfo.st_size;
+      /* If no file name part is given in the URL, we add this file name */
+      char *ptr=strstr(url, "://");
+      if(ptr)
+        ptr+=3;
+      else
+        ptr=url;
+      ptr = strrchr(ptr, '/');
+      if(!ptr || !strlen(++ptr)) {
+        /* The URL has no file name part, add the local file name. In order to
+           be able to do so, we have to create a new URL in another buffer.*/
+
+        urlbuffer=(char *)malloc(strlen(url) + strlen(config->infile) + 3);
+        if(!urlbuffer) {
+          helpf("out of memory\n");
+          return CURLE_OUT_OF_MEMORY;
+        }
+        if(ptr)
+          /* there is a trailing slash on the URL */
+          sprintf(urlbuffer, "%s%s", url, config->infile);
+        else
+          /* thers is no trailing slash on the URL */
+          sprintf(urlbuffer, "%s/%s", url, config->infile);
+        
+        url = urlbuffer; /* use our new URL instead! */
       }
-      /* else let offset remain 0 */
-    }
 
-    if(config.resume_from) {
-      /* open file for output: */
-      outs.stream=(FILE *) fopen(config.outfile, config.resume_from?"ab":"wb");
-      if (!outs.stream) {
-        helpf("Can't open '%s'!\n", config.outfile);
-        return CURLE_WRITE_ERROR;
+      infd=(FILE *) fopen(config->infile, "rb");
+      if (!infd || stat(config->infile, &fileinfo)) {
+        helpf("Can't open '%s'!\n", config->infile);
+        return CURLE_READ_ERROR;
       }
+      infilesize=fileinfo.st_size;
+      
     }
-    else {
-      outs.filename = config.outfile;
-      outs.stream = NULL; /* open when needed */
+    if((config->conf&CONF_UPLOAD) &&
+       config->use_resume &&
+       (0==config->resume_from)) {
+      config->resume_from = -1; /* -1 will then force get-it-yourself */
     }
-  }
-  if (config.infile) {
-    /*
-     * We have specified a file to upload
-     */
-    struct stat fileinfo;
-
-    /* If no file name part is given in the URL, we add this file name */
-    char *ptr=strstr(url, "://");
-    if(ptr)
-      ptr+=3;
-    else
-      ptr=url;
-    ptr = strrchr(ptr, '/');
-    if(!ptr || !strlen(++ptr)) {
-      /* The URL has no file name part, add the local file name. In order
-         to be able to do so, we have to create a new URL in another buffer.*/
-      urlbuffer=(char *)malloc(strlen(url) + strlen(config.infile) + 3);
-      if(!urlbuffer) {
-        helpf("out of memory\n");
-        return CURLE_OUT_OF_MEMORY;
+    if(config->headerfile) {
+      /* open file for output: */
+      if(strcmp(config->headerfile,"-")) {
+        heads.filename = config->headerfile;
+        headerfilep=NULL;
       }
-      if(ptr)
-        /* there is a trailing slash on the URL */
-        sprintf(urlbuffer, "%s%s", url, config.infile);
       else
-        /* thers is no trailing slash on the URL */
-        sprintf(urlbuffer, "%s/%s", url, config.infile);
-
-      url = urlbuffer; /* use our new URL instead! */
-    }
-
-    infd=(FILE *) fopen(config.infile, "rb");
-    if (!infd || stat(config.infile, &fileinfo)) {
-      helpf("Can't open '%s'!\n", config.infile);
-      return CURLE_READ_ERROR;
+        headerfilep=stdout;
+      heads.stream = headerfilep;
+      heads.config = config;
     }
-    infilesize=fileinfo.st_size;
-
-  }
-  if((config.conf&CONF_UPLOAD) &&
-     config.use_resume &&
-     (0==config.resume_from)) {
-    config.resume_from = -1; /* -1 will then force get-it-yourself */
-  }
-  if(config.headerfile) {
-    /* open file for output: */
-    if(strcmp(config.headerfile,"-"))
-    {
-      heads.filename = config.headerfile;
-      headerfilep=NULL;
-    }
-    else
-      headerfilep=stdout;
-    heads.stream = headerfilep;
-  }
-
-  if(outs.stream && isatty(fileno(outs.stream)) &&
-     !(config.conf&(CONF_UPLOAD|CONF_HTTPPOST)))
-    /* we send the output to a tty and it isn't an upload operation, therefore
-       we switch off the progress meter */
-    config.conf |= CONF_NOPROGRESS;
-
+    
+    if(outs.stream && isatty(fileno(outs.stream)) &&
+       !(config->conf&(CONF_UPLOAD|CONF_HTTPPOST)))
+      /* we send the output to a tty and it isn't an upload operation,
+         therefore we switch off the progress meter */
+      config->conf |= CONF_NOPROGRESS;
+    
 
-  if (urlnum > 1) {
-    fprintf(stderr, "\n[%d/%d]: %s --> %s\n", i+1, urlnum, url, config.outfile ? config.outfile : "<stdout>");
-    if (separator) {
+    if (urlnum > 1) {
+      fprintf(stderr, "\n[%d/%d]: %s --> %s\n",
+              i+1, urlnum, url, config->outfile ? config->outfile : "<stdout>");
+      if (separator) {
 #ifdef CURL_SEPARATORS
-      printf("%s%s\n", CURLseparator, url);
+        printf("%s%s\n", CURLseparator, url);
 #endif
 #ifdef MIME_SEPARATORS
-      printf("--%s\n", MIMEseparator);
-      printf("Content-ID: %s\n\n", url); 
+        printf("--%s\n", MIMEseparator);
+        printf("Content-ID: %s\n\n", url); 
 #endif
+      }
     }
-  }
 
-  if(!config.errors)
-    config.errors = stderr;
+    if(!config->errors)
+      config->errors = stderr;
 
 #ifdef WIN32
-  if(!config.outfile && !(config.conf & CONF_GETTEXT)) {
-    /* We get the output to stdout and we have not got the ASCII/text flag,
-       then set stdout to be binary */
-    setmode( 1, O_BINARY );
-  }
+    if(!config->outfile && !(config->conf & CONF_GETTEXT)) {
+      /* We get the output to stdout and we have not got the ASCII/text flag,
+         then set stdout to be binary */
+      setmode( 1, O_BINARY );
+    }
 #endif
 
 
-  main_init();
+    main_init();
+
+    /* The new, v7-style easy-interface! */
+    curl = curl_easy_init();
+    if(curl) {
+      curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs); /* where to store */
+      /* what call to write: */
+      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
+      curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
+      /* size of uploaded file: */
+      curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
+      curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
+      curl_easy_setopt(curl, CURLOPT_PROXY, config->proxy); /* proxy to use */
+      curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
+      curl_easy_setopt(curl, CURLOPT_HEADER, config->conf&CONF_HEADER);
+      curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config->conf&CONF_NOPROGRESS);
+      curl_easy_setopt(curl, CURLOPT_NOBODY, config->conf&CONF_NOBODY);
+      curl_easy_setopt(curl, CURLOPT_FAILONERROR,
+                       config->conf&CONF_FAILONERROR);
+      curl_easy_setopt(curl, CURLOPT_UPLOAD, config->conf&CONF_UPLOAD);
+      curl_easy_setopt(curl, CURLOPT_POST, config->conf&CONF_POST);
+      curl_easy_setopt(curl, CURLOPT_FTPLISTONLY,
+                       config->conf&CONF_FTPLISTONLY);
+      curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config->conf&CONF_FTPAPPEND);
+      curl_easy_setopt(curl, CURLOPT_NETRC, config->conf&CONF_NETRC);
+      curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
+                       config->conf&CONF_FOLLOWLOCATION);
+      curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config->conf&CONF_GETTEXT);
+      curl_easy_setopt(curl, CURLOPT_PUT, config->conf&CONF_PUT);
+      curl_easy_setopt(curl, CURLOPT_MUTE, config->conf&CONF_MUTE);
+      curl_easy_setopt(curl, CURLOPT_USERPWD, config->userpwd);
+      curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);
+      curl_easy_setopt(curl, CURLOPT_RANGE, config->range);
+      curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
+      curl_easy_setopt(curl, CURLOPT_TIMEOUT, config->timeout);
+      curl_easy_setopt(curl, CURLOPT_POSTFIELDS, config->postfields);
+      
+      /* new in libcurl 7.2: */
+      curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, config->postfieldsize);
 
-#if 0
-  /* This is code left from the pre-v7 time, left here mainly as a reminder
-     and possibly as a warning! ;-) */
+      curl_easy_setopt(curl, CURLOPT_REFERER, config->referer);
+      curl_easy_setopt(curl, CURLOPT_AUTOREFERER,
+                       config->conf&CONF_AUTO_REFERER);
+      curl_easy_setopt(curl, CURLOPT_USERAGENT, config->useragent);
+      curl_easy_setopt(curl, CURLOPT_FTPPORT, config->ftpport);
+      curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, config->low_speed_limit);
+      curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, config->low_speed_time);
+      curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
+                       config->use_resume?config->resume_from:0);
+      curl_easy_setopt(curl, CURLOPT_COOKIE, config->cookie);
+      curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config->headers);
+      curl_easy_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
+      curl_easy_setopt(curl, CURLOPT_SSLCERT, config->cert);
+      curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config->cert_passwd);
+
+      if(config->cacert) {
+        /* available from libcurl 7.5: */
+        curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
+        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE);
+      }
+
+      if(config->conf&(CONF_NOBODY|CONF_USEREMOTETIME)) {
+        /* no body or use remote time */
+        /* new in 7.5 */
+        curl_easy_setopt(curl, CURLOPT_FILETIME, TRUE);
+      }
+      
+      /* 7.5 news: */
+      if (config->maxredirs) 
+        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, config->maxredirs); 
+      else 
+        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, DEFAULT_MAXREDIRS); 
+ 
+
+      curl_easy_setopt(curl, CURLOPT_CRLF, config->crlf);
+      curl_easy_setopt(curl, CURLOPT_QUOTE, config->quote);
+      curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config->postquote);
+      curl_easy_setopt(curl, CURLOPT_WRITEHEADER,
+                       config->headerfile?&heads:NULL);
+      curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config->cookiefile);
+      curl_easy_setopt(curl, CURLOPT_SSLVERSION, config->ssl_version);
+      curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config->timecond);
+      curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config->condtime);
+      curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);
+      curl_easy_setopt(curl, CURLOPT_STDERR, config->errors);
+      
+      /* three new ones in libcurl 7.3: */
+      curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config->proxytunnel);
+      curl_easy_setopt(curl, CURLOPT_INTERFACE, config->iface);
+      curl_easy_setopt(curl, CURLOPT_KRB4LEVEL, config->krb4level);
 
-  res = curl_urlget(CURLOPT_FILE, (FILE *)&outs,  /* where to store */
-                    CURLOPT_WRITEFUNCTION, my_fwrite, /* what call to write */
-                    CURLOPT_INFILE, infd, /* for uploads */
-                    CURLOPT_INFILESIZE, infilesize, /* size of uploaded file */
-                    CURLOPT_URL, url,     /* what to fetch */
-                    CURLOPT_PROXY, config.proxy, /* proxy to use */
-                    CURLOPT_FLAGS, config.conf, /* flags */
-                    CURLOPT_USERPWD, config.userpwd, /* user + passwd */
-                    CURLOPT_PROXYUSERPWD, config.proxyuserpwd, /* Proxy user + passwd */
-                    CURLOPT_RANGE, config.range, /* range of document */
-                    CURLOPT_ERRORBUFFER, errorbuffer,
-                    CURLOPT_TIMEOUT, config.timeout,
-                    CURLOPT_POSTFIELDS, config.postfields,
-                    CURLOPT_REFERER, config.referer,
-                    CURLOPT_USERAGENT, config.useragent,
-                    CURLOPT_FTPPORT, config.ftpport,
-                    CURLOPT_LOW_SPEED_LIMIT, config.low_speed_limit,
-                    CURLOPT_LOW_SPEED_TIME, config.low_speed_time,
-                    CURLOPT_RESUME_FROM, config.use_resume?config.resume_from:0,
-                    CURLOPT_COOKIE, config.cookie,
-                    CURLOPT_HTTPHEADER, config.headers,
-                    CURLOPT_HTTPPOST, config.httppost,
-                    CURLOPT_SSLCERT, config.cert,
-                    CURLOPT_SSLCERTPASSWD, config.cert_passwd,
-                    CURLOPT_CRLF, config.crlf,
-                    CURLOPT_QUOTE, config.quote,
-                    CURLOPT_POSTQUOTE, config.postquote,
-                    CURLOPT_WRITEHEADER, config.headerfile?&heads:NULL,
-                    CURLOPT_COOKIEFILE, config.cookiefile,
-                    CURLOPT_SSLVERSION, config.ssl_version,
-                    CURLOPT_TIMECONDITION, config.timecond,
-                    CURLOPT_TIMEVALUE, config.condtime,
-                    CURLOPT_CUSTOMREQUEST, config.customrequest,
-                    CURLOPT_STDERR, config.errors,
-                    CURLOPT_PROGRESSMODE, config.progressmode,
-                    CURLOPT_WRITEINFO, config.writeout,
-                    CURLOPT_DONE); /* always terminate the list of tags */
-
-#endif
-  /* The new, v7-style easy-interface! */
-  curl = curl_easy_init();
-  if(curl) {
-    curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs);  /* where to store */
-    /* what call to write: */
-    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
-    curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
-    /* size of uploaded file: */
-    curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
-    curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
-    curl_easy_setopt(curl, CURLOPT_PROXY, config.proxy); /* proxy to use */
-    curl_easy_setopt(curl, CURLOPT_VERBOSE, config.conf&CONF_VERBOSE);
-    curl_easy_setopt(curl, CURLOPT_HEADER, config.conf&CONF_HEADER);
-    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config.conf&CONF_NOPROGRESS);
-    curl_easy_setopt(curl, CURLOPT_NOBODY, config.conf&CONF_NOBODY);
-    curl_easy_setopt(curl, CURLOPT_FAILONERROR, config.conf&CONF_FAILONERROR);
-    curl_easy_setopt(curl, CURLOPT_UPLOAD, config.conf&CONF_UPLOAD);
-    curl_easy_setopt(curl, CURLOPT_POST, config.conf&CONF_POST);
-    curl_easy_setopt(curl, CURLOPT_FTPLISTONLY, config.conf&CONF_FTPLISTONLY);
-    curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config.conf&CONF_FTPAPPEND);
-    curl_easy_setopt(curl, CURLOPT_NETRC, config.conf&CONF_NETRC);
-    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
-                     config.conf&CONF_FOLLOWLOCATION);
-    curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config.conf&CONF_GETTEXT);
-    curl_easy_setopt(curl, CURLOPT_PUT, config.conf&CONF_PUT);
-    curl_easy_setopt(curl, CURLOPT_MUTE, config.conf&CONF_MUTE);
-    curl_easy_setopt(curl, CURLOPT_USERPWD, config.userpwd);
-    curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config.proxyuserpwd);
-    curl_easy_setopt(curl, CURLOPT_RANGE, config.range);
-    curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
-    curl_easy_setopt(curl, CURLOPT_TIMEOUT, config.timeout);
-    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, config.postfields);
-
-    /* new in libcurl 7.2: */
-    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, config.postfieldsize);
-
-    curl_easy_setopt(curl, CURLOPT_REFERER, config.referer);
-    curl_easy_setopt(curl, CURLOPT_AUTOREFERER, config.conf&CONF_AUTO_REFERER);
-    curl_easy_setopt(curl, CURLOPT_USERAGENT, config.useragent);
-    curl_easy_setopt(curl, CURLOPT_FTPPORT, config.ftpport);
-    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, config.low_speed_limit);
-    curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, config.low_speed_time);
-    curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
-                     config.use_resume?config.resume_from:0);
-    curl_easy_setopt(curl, CURLOPT_COOKIE, config.cookie);
-    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config.headers);
-    curl_easy_setopt(curl, CURLOPT_HTTPPOST, config.httppost);
-    curl_easy_setopt(curl, CURLOPT_SSLCERT, config.cert);
-    curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config.cert_passwd);
-    curl_easy_setopt(curl, CURLOPT_CRLF, config.crlf);
-    curl_easy_setopt(curl, CURLOPT_QUOTE, config.quote);
-    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config.postquote);
-    curl_easy_setopt(curl, CURLOPT_WRITEHEADER, config.headerfile?&heads:NULL);
-    curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config.cookiefile);
-    curl_easy_setopt(curl, CURLOPT_SSLVERSION, config.ssl_version);
-    curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config.timecond);
-    curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config.condtime);
-    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config.customrequest);
-    curl_easy_setopt(curl, CURLOPT_STDERR, config.errors);
-
-    /* three new ones in libcurl 7.3: */
-    curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config.proxytunnel);
-    curl_easy_setopt(curl, CURLOPT_INTERFACE, config.iface);
-    curl_easy_setopt(curl, CURLOPT_KRB4LEVEL, config.krb4level);
-
-    if((config.progressmode == CURL_PROGRESS_BAR) &&
-       !(config.conf&(CONF_NOPROGRESS|CONF_MUTE))) {
-      /* we want the alternative style, then we have to implement it
-         ourselves! */
-      progressbarinit(&progressbar);
-      curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, myprogress);
-      curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &progressbar);
-    }
-
-    res = curl_easy_perform(curl);
-
-    if(config.writeout) {
-      ourWriteOut(curl, config.writeout);
+      if((config->progressmode == CURL_PROGRESS_BAR) &&
+         !(config->conf&(CONF_NOPROGRESS|CONF_MUTE))) {
+        /* we want the alternative style, then we have to implement it
+           ourselves! */
+        progressbarinit(&progressbar);
+        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, myprogress);
+        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &progressbar);
+      }
+
+      res = curl_easy_perform(curl);
+
+      if(config->writeout) {
+        ourWriteOut(curl, config->writeout);
+      }
+
+      /* always cleanup */
+      curl_easy_cleanup(curl);
+
+      if((res!=CURLE_OK) && config->showerror)
+        fprintf(config->errors, "curl: (%d) %s\n", res, errorbuffer);
     }
+    else
+      fprintf(config->errors, "curl: failed to init libcurl!\n");
 
-    /* always cleanup */
-    curl_easy_cleanup(curl);
+    main_free();
 
-    if((res!=CURLE_OK) && config.showerror)
-      fprintf(config.errors, "curl: (%d) %s\n", res, errorbuffer);
-  }
-  else
-    fprintf(config.errors, "curl: failed to init libcurl!\n");
+    if((config->errors != stderr) &&
+       (config->errors != stdout))
+      /* it wasn't directed to stdout or stderr so close the file! */
+      fclose(config->errors);
+    
+    if(config->headerfile && !headerfilep && heads.stream)
+      fclose(heads.stream);
 
-  main_free();
+    if(urlbuffer)
+      free(urlbuffer);
+    if (config->outfile && outs.stream)
+      fclose(outs.stream);
+    if (config->infile)
+      fclose(infd);
+    if(headerfilep)
+      fclose(headerfilep);
+    
+    if(url)
+      free(url);
 
-  if((config.errors != stderr) &&
-     (config.errors != stdout))
-    /* it wasn't directed to stdout or stderr so close the file! */
-    fclose(config.errors);
-
-  if(config.headerfile && !headerfilep && heads.stream)
-    fclose(heads.stream);
-
-  if(urlbuffer)
-    free(urlbuffer);
-  if (config.outfile && outs.stream)
-    fclose(outs.stream);
-  if (config.infile)
-    fclose(infd);
-  if(headerfilep)
-    fclose(headerfilep);
-
-  if(config.url)
-    free(config.url);
-
-  if(url)
-    free(url);
-  if(config.outfile && !config.remotefile)
-    free(config.outfile);
   }
 #ifdef MIME_SEPARATORS
   if (separator)
     printf("--%s--\n", MIMEseparator);
 #endif
 
+  if(allocuseragent)
+    free(config->useragent);
+
   /* cleanup memory used for URL globbing patterns */
   glob_cleanup(urls);
 
-  curl_slist_free_all(config.quote); /* the checks for config.quote == NULL */
-  curl_slist_free_all(config.postquote); /*  */
-  curl_slist_free_all(config.headers); /*  */
+  return res;
+}
+
 
-  return(res);
+int main(int argc, char *argv[])
+{
+  int res;
+  struct Configurable config;
+  memset(&config, 0, sizeof(struct Configurable));
+  
+  res = operate(&config, argc, argv);
+  free_config_fields(&config);
+
+  return res;
 }
 
 static char *my_get_line(FILE *fp)
 {
    char buf[4096];
    char *nl = NULL;
@@ -1650,39 +1808,6 @@
 
    if (NULL != nl)
      *nl = '\0';
 
    return retval;
 }
-
-static char *my_get_token(const char *line)
-{
-  static const char *save = NULL;
-  const char *first = NULL;
-  const char *last = NULL;
-  char *retval = NULL;
-  size_t size;
-
-  if (NULL == line)
-    line = save;
-  if (NULL == line)
-    return NULL;
-
-  while (('\0' != *line) && (isspace(*line)))
-    line++;
-  first = line;
-  while (('\0' != *line) && (!isspace(*line)))
-    line++;
-  save = line;
-  while ('\0' != *line)
-    line++;
-  last = line;
-
-  size = last - first;
-  if (0 == size)
-    return NULL;
-  if (NULL == (retval = malloc(size + 1)))
-    return NULL;
-  memcpy(retval, first, size);
-  retval[size] = '\0';
-  return retval;
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/Makefile.am	2000-10-16 20:43:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/Makefile.am	2000-11-30 16:08:49.000000000 +0800
@@ -1,8 +1,8 @@
 #
-# $Id: Makefile.am,v 1.9 2000/10/09 11:24:49 bagder Exp $
+# $Id: Makefile.am,v 1.10 2000/11/30 08:08:49 bagder Exp $
 #
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -g -DMALLOCDEBUG # -Wall -pedantic
 #CPPFLAGS = -DGLOBURL -DCURL_SEPARATORS
 
@@ -22,13 +22,13 @@
 
 EXTRA_DIST = mkhelp.pl Makefile.vc6
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 MANPAGE=$(top_srcdir)/docs/curl.1
-README=$(top_srcdir)/docs/README.curl
+README=$(top_srcdir)/docs/MANUAL
 MKHELP=$(top_srcdir)/src/mkhelp.pl
 
 # This generates the hugehelp.c file
 hugehelp.c: $(README) $(MANPAGE)  mkhelp.pl
 	rm -f hugehelp.c
 	$(NROFF) -man $(MANPAGE) | $(PERL) $(MKHELP)  $(README) > hugehelp.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/Makefile.in	2000-11-15 16:22:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/Makefile.in	2000-12-04 16:39:16.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.9 2000/10/09 11:24:49 bagder Exp $
+# $Id: Makefile.am,v 1.10 2000/11/30 08:08:49 bagder Exp $
 #
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -g -DMALLOCDEBUG # -Wall -pedantic
 #CPPFLAGS = -DGLOBURL -DCURL_SEPARATORS
 
@@ -96,13 +96,13 @@
 
 EXTRA_DIST = mkhelp.pl Makefile.vc6
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 MANPAGE = $(top_srcdir)/docs/curl.1
-README = $(top_srcdir)/docs/README.curl
+README = $(top_srcdir)/docs/MANUAL
 MKHELP = $(top_srcdir)/src/mkhelp.pl
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h config.h
 CONFIG_CLEAN_FILES = 
 PROGRAMS =  $(bin_PROGRAMS)
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/Makefile.vc6	2000-05-22 22:12:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/Makefile.vc6	2000-12-01 14:59:39.000000000 +0800
@@ -1,59 +1,75 @@
 ########################################################
 ## Makefile for building curl.exe with MSVC6
 ## Use: nmake -f makefile.vc6 [release | debug]
 ##      (default is release)
 ##
 ## Comments to: Troy Engel <tengel@sonic.net>
+## Updated by: Craig Davison <cd@securityfocus.com>
 
 PROGRAM_NAME = curl.exe
 
 ########################################################
 ## Nothing more to do below this line!
 
 ## Release
-CCR = cl.exe /ML /O2 /D "NDEBUG"
+CCR = cl.exe /MD /O2 /D "NDEBUG"
 LINKR = link.exe /incremental:no /libpath:"../lib"
 
 ## Debug
-CCD = cl.exe /MLd /Gm /ZI /Od /D "_DEBUG" /GZ
+CCD = cl.exe /MDd /Gm /ZI /Od /D "_DEBUG" /GZ
 LINKD = link.exe /incremental:yes /debug
 
-CFLAGS = /nologo /W3 /GX /D "WIN32" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+CFLAGS = /I "../include" /nologo /W3 /GX /D "WIN32" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
 LFLAGS = /nologo /out:$(PROGRAM_NAME) /subsystem:console /machine:I386
-LINKLIBS = kernel32.lib wsock32.lib libcurl.lib
+LINKLIBS = wsock32.lib libcurl.lib
+LINKLIBS_DEBUG = wsock32.lib libcurld.lib
 
 RELEASE_OBJS= \
 	hugehelpr.obj \
+	writeoutr.obj \
+	urlglobr.obj \
 	mainr.obj
 
 DEBUG_OBJS= \
 	hugehelpd.obj \
+	writeoutd.obj \
+	urlglobd.obj \
 	maind.obj
 	
 LINK_OBJS= \
 	hugehelp.obj \
+	writeout.obj \
+	urlglob.obj \
 	main.obj
 
 all : release
 
 release: $(RELEASE_OBJS)
 	$(LINKR) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
 
 debug: $(DEBUG_OBJS)
-	$(LINKD) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
+	$(LINKD) $(LFLAGS) $(LINKLIBS_DEBUG) $(LINK_OBJS)
 
 ## Release
 hugehelpr.obj: hugehelp.c
 	$(CCR) $(CFLAGS) /Zm200 hugehelp.c
+writeoutr.obj: writeout.c
+	$(CCR) $(CFLAGS) writeout.c
+urlglobr.obj: urlglob.c
+	$(CCR) $(CFLAGS) urlglob.c
 mainr.obj: main.c
 	$(CCR) $(CFLAGS) main.c
 
 ## Debug
 hugehelpd.obj: hugehelp.c
 	$(CCD) $(CFLAGS) /Zm200 hugehelp.c
+writeoutd.obj: writeout.c
+	$(CCD) $(CFLAGS) writeout.c
+urlglobd.obj: urlglob.c
+	$(CCD) $(CFLAGS) urlglob.c
 maind.obj: main.c
 	$(CCD) $(CFLAGS) main.c
 
 clean:
 	-@erase hugehelp.obj
 	-@erase main.obj
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/urlglob.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/urlglob.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/urlglob.c	2000-11-09 20:51:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/urlglob.c	2000-11-20 16:54:32.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/src/urlglob.c,v $
- * $Revision: 1.8 $
- * $Date: 2000/11/09 12:51:43 $
+ * $Revision: 1.9 $
+ * $Date: 2000/11/20 08:54:32 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -46,13 +46,13 @@
 #include "urlglob.h"
 
 #ifdef MALLOCDEBUG
 #include "../lib/memdebug.h"
 #endif
 
-char glob_buffer[URL_MAX_LENGTH];
+char *glob_buffer;
 URLGlob *glob_expand;
 
 int glob_word(char*, int);
 
 int glob_set(char *pattern, int pos) {
   /* processes a set expression with the point behind the opening '{'
@@ -207,16 +207,19 @@
   printf("internal error\n");
   exit (CURLE_FAILED_INIT);
 }
 
 int glob_url(URLGlob** glob, char* url, int *urlnum)
 {
-  if (strlen(url)>URL_MAX_LENGTH) {
-    printf("Illegally sized URL\n");
-    return CURLE_URL_MALFORMAT;
-  }
+  /*
+   * We can deal with any-size, just make a buffer with the same length
+   * as the specified URL!
+   */
+  glob_buffer=(char *)malloc(strlen(url)+1);
+  if(NULL == glob_buffer)
+    return CURLE_OUT_OF_MEMORY;
 
   glob_expand = (URLGlob*)malloc(sizeof(URLGlob));
   glob_expand->size = 0;
   *urlnum = glob_word(url, 1);
   *glob = glob_expand;
   return CURLE_OK;
@@ -235,12 +238,13 @@
 	}
 	free(glob->pattern[i/2].content.Set.elements);
       }
     }
   }
   free(glob);
+  free(glob_buffer);
 }
 
 char *next_url(URLGlob *glob)
 {
   static int beenhere = 0;
   char *buf = glob_buffer;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/urlglob.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/urlglob.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/urlglob.h	2000-11-09 20:51:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/urlglob.h	2000-11-21 17:38:41.000000000 +0800
@@ -28,14 +28,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/src/urlglob.h,v $
- * $Revision: 1.4 $
- * $Date: 2000/11/09 12:51:43 $
+ * $Revision: 1.5 $
+ * $Date: 2000/11/21 09:38:41 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -67,8 +67,9 @@
   int size;
 } URLGlob;
 
 int glob_url(URLGlob**, char*, int *);
 char* next_url(URLGlob*);
 char* match_url(char*, URLGlob); 
+void glob_cleanup(URLGlob* glob);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/version.h	2000-11-15 16:22:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/version.h	2000-12-04 16:38:11.000000000 +0800
@@ -1,3 +1,3 @@
 #define CURL_NAME "curl"
-#define CURL_VERSION "7.4.2"
+#define CURL_VERSION "7.5"
 #define CURL_ID CURL_NAME " " CURL_VERSION " (" OS ") "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/writeout.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/writeout.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/src/writeout.c	2000-10-04 21:08:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/src/writeout.c	2000-11-21 17:38:41.000000000 +0800
@@ -26,14 +26,14 @@
  * Main author:
  * - Daniel Stenberg <daniel@haxx.se>
  *
  * 	http://curl.haxx.se
  *
  * $Source: /cvsroot/curl/src/writeout.c,v $
- * $Revision: 1.2 $
- * $Date: 2000/10/04 13:08:17 $
+ * $Revision: 1.3 $
+ * $Date: 2000/11/21 09:38:41 $
  * $Author: bagder $
  * $State: Exp $
  * $Locker:  $
  *
  * ------------------------------------------------------------
  ****************************************************************************/
@@ -41,12 +41,14 @@
 #include <stdio.h>
 #include <string.h>
 
 #include <curl/curl.h>
 #include <curl/types.h>
 #include <curl/easy.h>
+
+#define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "writeout.h"
 
 typedef enum {
   VAR_NONE,       /* must be the first */
@@ -172,12 +174,14 @@
                 break;
               case VAR_SPEED_UPLOAD:
                 if(CURLE_OK ==
                    curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &doubleinfo))
                   fprintf(stream, "%.3f", doubleinfo);
                 break;
+              default:
+                break;
               }
               break;
             }
           }
           ptr=end+1; /* pass the end */
           *end = keepit;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command100.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command101.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command102.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command103.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command104.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command105.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command106.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command107.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command108.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command109.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command110.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command111.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command112.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command113.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command114.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command115.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command116.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command117.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command118.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command119.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command16.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command17.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command18.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command19.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command200.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command201.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command20.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command21.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command22.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command23.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command24.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: command25.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: CVS
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error111.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error113.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error114.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error115.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error116.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error117.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error118.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error119.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error19.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error201.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error20.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error21.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error23.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error24.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: error25.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: ftpd113.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: ftpd114.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: ftpd115.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: ftpd116.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: ftpd117.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: ftpd118.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http10.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http11.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http12.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http13.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http14.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http15.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http1.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http2.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http3.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http4.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http5.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http6.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http7.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http8.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data: http9.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name100.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name101.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name102.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name103.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name104.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name105.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name106.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name107.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name108.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name109.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name110.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name111.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name112.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name113.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name114.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name115.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name116.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name117.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name118.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name119.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name16.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name17.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name18.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name19.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name200.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name201.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name20.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name21.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name22.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name23.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name24.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: name25.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot100.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot101.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot102.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot103.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot104.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot105.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot106.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot107.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot108.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot109.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot10.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot110.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot112.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot11.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot12.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot13.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot14.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot15.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot16.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot17.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot18.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot1.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot22.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot2.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot3.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot4.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot5.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot6.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot7.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot8.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: prot9.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply100.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply101.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply102.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply103.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply104.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply105.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply106.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply110.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply16.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply17.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply200.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply22.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply24.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: reply25.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdin17.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdout107.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdout108.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdout109.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdout110.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdout112.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data/stdout15.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data/stdout15.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/data/stdout15.txt	2000-11-13 22:14:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data/stdout15.txt	2000-11-17 22:58:22.000000000 +0800
@@ -1 +1,7 @@
+HTTP/1.4 200 OK
+Fake: yes
+Fake: yes
+Fake: yes
+
+Repeated nonsense-headers
 http://127.0.0.1:8999/want/15 200 26.000
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: stdout18.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: upload107.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: upload108.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: upload109.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/data: upload112.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests: ftpserver.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/httpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/httpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/httpserver.pl	2000-11-14 06:42:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/httpserver.pl	2000-11-17 23:12:37.000000000 +0800
@@ -1,33 +1,40 @@
 #!/usr/bin/perl
 use Socket;
 use Carp;
 use FileHandle;
 
+use strict;
+
 sub spawn;  # forward declaration
 sub logmsg { #print "$0 $$: @_ at ", scalar localtime, "\n"
  }
 
-my $port = $ARGV[0];
-my $proto = getprotobyname('tcp');
-$port = $1 if $port =~ /(\d+)/; # untaint port number
+my $verbose=0; # set to 1 for debugging
 
-if($ARGV[1] =~ /^ftp$/i) {
-    $protocol="FTP";
-}
-else {
-    $protocol="HTTP";
-}
+my $port = 8999; # just a default
+do {
+    if($ARGV[0] eq "-v") {
+        $verbose=1;
+    }
+    elsif($ARGV[0] =~ /^(\d+)$/) {
+        $port = $1;
+    }
+} while(shift @ARGV);
+
+my $proto = getprotobyname('tcp') || 6;
 
 socket(Server, PF_INET, SOCK_STREAM, $proto)|| die "socket: $!";
 setsockopt(Server, SOL_SOCKET, SO_REUSEADDR,
            pack("l", 1)) || die "setsockopt: $!";
 bind(Server, sockaddr_in($port, INADDR_ANY))|| die "bind: $!";
 listen(Server,SOMAXCONN) || die "listen: $!";
 
-print "$protocol server started on port $port\n";
+if($verbose) {
+    print "HTTP server started on port $port\n";
+}
 
 open(PID, ">.server.pid");
 print PID $$;
 close(PID);
 
 my $waitedpid = 0;
@@ -36,26 +43,12 @@
 sub REAPER {
     $waitedpid = wait;
     $SIG{CHLD} = \&REAPER;  # loathe sysV
     logmsg "reaped $waitedpid" . ($? ? " with exit $?" : '');
 }
 
-# USER is ok in fresh state
-%commandok = ( "USER" => "fresh",
-               "PASS" => "passwd",
-               "PASV" => "loggedin",
-               );
-
-%statechange = ( 'USER' => 'passwd',   # USER goes to passwd state
-                 'PASS' => 'loggedin', # PASS goes to loggedin state
-                 );
-
-%displaytext = ('USER' => '331 We are happy you popped in!', # output FTP line
-                'PASS' => '230 Welcome you silly person',
-                );
-
 $SIG{CHLD} = \&REAPER;
 
 for ( $waitedpid = 0;
       ($paddr = accept(Client,Server)) || $waitedpid;
         $waitedpid = 0, close Client)
 {
@@ -66,87 +59,27 @@
     logmsg "connection from $name [", inet_ntoa($iaddr), "] at port $port";
 
     # this code is forked and run
     spawn sub {
         my ($request, $path, $ver, $left, $cl);
 
-        if($protocol eq "FTP") {
-
-            # < 220 pm1 FTP server (SunOS 5.7) ready.
-            # > USER anonymous
-            # < 331 Guest login ok, send ident as password.
-            # > PASS curl_by_daniel@haxx.se
-            # < 230 Guest login ok, access restrictions apply.
-            # * We have successfully logged in
-            # * Connected to pm1 (193.15.23.1)
-            # > PASV
-            # < 227 Entering Passive Mode (193,15,23,1,231,59)
-            # * Connecting to pm1 (193.15.23.1) port 59195
-            # > TYPE A
-            # < 200 Type set to A.
-            # > LIST
-            # < 150 ASCII data connection for /bin/ls (193.15.23.1,59196) (0 bytes).
-            # * Getting file with size: -1
-
-            # flush data:
-            $| = 1;
-
-            print "220-running the curl suite test server\r\n",
-            "220-running the curl suite test server\r\n",
-            "220 running the curl suite test server\r\n";
-
-            $state="fresh";
-
-            while(1) {
-
-                last unless defined ($_ = <STDIN>);
-
-                # Remove trailing CRLF.
-                s/[\n\r]+$//;
-
-                unless (m/^([A-Z]{3,4})\s?(.*)/i)
-                {
-                    print STDERR
-                        "badly formed command received: ".$_;
-                    exit 0;
-                }
-                $FTPCMD=$1;
-                $full=$_;
-                 
-                print STDERR "GOT: ($1) $_\n";
-
-                $ok = $commandok{$FTPCMD};
-                if($ok !~ /$state/) {
-                    print "314 $FTPCMD not OK ($ok) in state: $state!\r\n";
-                    exit;
-                }
-
-                $state=$statechange{$FTPCMD};
-                if($state eq "") {
-                    print "314 Wwwwweeeeird internal error state: $state\r\n";
-                    exit;
-                }
-                print STDERR "gone to state $state\n";
-
-                $text = $displaytext{$FTPCMD};
-                print "$text\r\n";
-            }
-            exit;
-        }
-        # otherwise, we're doing HTTP
-
+        my @headers;
         while(<STDIN>) {
             if($_ =~ /([A-Z]*) (.*) HTTP\/1.(\d)/) {
                 $request=$1;
                 $path=$2;
                 $ver=$3;
             }
             elsif($_ =~ /^Content-Length: (\d*)/) {
                 $cl=$1;
             }
 
+            if($verbose) {
+                print STDERR "IN: $_";
+            }
+            
             push @headers, $_;
 
             if($left > 0) {
                 $left -= length($_);
                 if($left == 0) {
                     $left = -1; # just to force a loop break here
@@ -178,31 +111,43 @@
 
             #
             # we always start the path with a number, this is the
             # test number that this server will use to know what
             # contents to pass back to the client
             #
+            my $testnum;
             if($path =~ /.*\/(\d*)/) {
                 $testnum=$1;
+
+                if($verbose) {
+                    print STDERR "sending reply $testnum\n";
+                }
             }
             else {
-                print STDERR "UKNOWN TEST CASE\n";
-                exit;
+                $testnum=0;
             }
             open(INPUT, ">log/server.input");
             for(@headers) {
                 print INPUT $_;
             }
             close(INPUT);
             
-            # send a reply to the client
-            open(DATA, "<data/reply$testnum.txt");
-            while(<DATA>) {
-                print $_;
+            if(0 == $testnum ) {
+                print "HTTP/1.1 200 OK\r\n",
+                "header: yes\r\n",
+                "\r\n",
+                "You must select a test number to get good data back\r\n";
+            }
+            else {
+                # send a custom reply to the client
+                open(DATA, "<data/reply$testnum.txt");
+                while(<DATA>) {
+                    print $_;
+                }
+                close(DATA);
             }
-            close(DATA);
         }
      #   print "Hello there, $name, it's now ", scalar localtime, "\r\n";
     };
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/Makefile.am	2000-11-14 00:06:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/Makefile.am	2000-11-22 19:53:55.000000000 +0800
@@ -1,10 +1,17 @@
 
 all:
 install:
 
+curl:
+	@(cd ..; make)
+
 test:
-	./runtests.pl
+	perl runtests.pl
+
+quiet-test:
+	perl runtests.pl -s -a
 
 clean:
 	rm -rf log
 	find . -name "*~" | xargs rm -f
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/Makefile.in	2000-11-15 16:22:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/Makefile.in	2000-12-04 16:38:18.000000000 +0800
@@ -172,14 +172,20 @@
 mostlyclean distclean maintainer-clean
 
 
 all:
 install:
 
+curl:
+	@(cd ..; make)
+
 test:
-	./runtests.pl
+	perl runtests.pl
+
+quiet-test:
+	perl runtests.pl -s -a
 
 clean:
 	rm -rf log
 	find . -name "*~" | xargs rm -f
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/README	2000-11-14 18:23:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/README	2000-11-27 20:26:34.000000000 +0800
@@ -10,40 +10,60 @@
   perl
 
 Run:
   'make test'. This invokes the 'runtests.pl' perl script. Edit the top
   variables of that script in case you have some specific needs.
 
-  The script breaks on the first test that doesn't do OK. Run the script
-  with -v for more verbose output.
+  The script breaks on the first test that doesn't do OK. Use -a to prevent
+  the script to abort on the first error. Run the script with -v for more
+  verbose output.
 
   Use -s fort shorter output, or pass a string with test numbers to run
   specific tests only (like ./runtests.pl "3 4" to test 3 and 4 only)
 
+Memory:
+  The test script will check that all allocated memory is freed properly IF
+  curl has been built with the MALLOCDEBUG define set. The script will
+  automatically detect if that is the case, and it will use the ../memanalyze
+  script to analyze the memory debugging output.
+
 Logs:
   All logs are generated in the logs/ subdirctory (it is emtpied first
   in the runtests.sh script)
 
 Data:
   All test-data are put in the data/ subdirctory.
 
-  For each tests there exist four files. Replace N with the test number:
+  For each tests there exist a few files, all with their own separate and
+  special purpose. Replace N with the test number:
 
     nameN.txt: test description as displayed when run
 
     commandN.txt: command line options for this test
 
-    httpN.txt: the full dump of the HTTP protocol communication that curl is
+    protN.txt: the full dump of the protocol communication that curl is
                expected to use when performing this test
 
     replyN.txt: the full dump the server should reply to curl for this test.
                If the final result that curl should've got is not in this
                file, you can instead name the file replyN0001.txt. This enables
                you to fiddle more. ;-)
 
     stdoutN.txt: if this file is present, curl's stdout is compared against
-               this file to see that they're identical
+               this file to see that they're identical. If this is present,
+               curl will not be run with -o but instead all output is compared
+               against this file!
+
+    errorN.txt: if this file is present, it should contain the error number
+               curl is supposed to return when this test is run.
+
+    uploadN.txt: if this file is present, it should contain the same data as
+               the log/upload.N does, after a curl upload has been performed.
+
+    ftpdN.txt: this file may contain instructions how to modify the behaviour
+               of the ftp server. It uses a simple syntax that is left to
+               describe here!
 
 FIX:
 
   * Make httpserver.pl work when we PUT without Content-Length:
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/runtests.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/runtests.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.4.2/tests/runtests.pl	2000-11-15 16:21:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5/tests/runtests.pl	2000-11-28 20:49:39.000000000 +0800
@@ -1,23 +1,26 @@
 #!/usr/bin/perl
-# $Id: runtests.pl,v 1.7 2000/11/15 08:21:14 bagder Exp $
+# $Id: runtests.pl,v 1.17 2000/11/28 12:49:39 bagder Exp $
 #
 # Main curl test script, in perl to run on more platforms
 #
 #######################################################################
 # These should be the only variables that might be needed to get edited:
 
 use strict;
 
 my $HOSTIP="127.0.0.1";
-my $HOSTPORT=8999;
-my $CURL="../src/curl";
+my $HOSTPORT=8999; # bad name, but this is the HTTP server port
+my $FTPPORT=8921;  # this is the FTP server port
+my $CURL="../src/curl"; # what curl executable to run on the tests
 my $LOGDIR="log";
 my $TESTDIR="data";
-my $SERVERIN="$LOGDIR/server.input";
-my $CURLOUT="$LOGDIR/curl.out";
+my $SERVERIN="$LOGDIR/server.input"; # what curl sent the server
+my $CURLOUT="$LOGDIR/curl.out"; # curl output if not stdout
+my $CURLLOG="$LOGDIR/curl.log"; # all command lines run
+my $FTPDCMD="$LOGDIR/ftpserver.cmd"; # copy ftp server instructions here
 
 # Normally, all test cases should be run, but at times it is handy to
 # simply run a particular one:
 my $TESTCASES="all";
 
 # To run specific test cases, set them like:
@@ -25,57 +28,74 @@
 
 #######################################################################
 # No variables below this point should need to be modified
 #
 
 my $PIDFILE=".server.pid";
+my $FTPPIDFILE=".ftpserver.pid";
+
+# this gets set if curl is compiled with memory debugging:
+my $memory_debug=0;
+
+# name of the file that the memory debugging creates:
+my $memdump="memdump";
+
+# the path to the script that analyzes the memory debug output file:
+my $memanalyze="../memanalyze.pl";
 
 #######################################################################
 # variables the command line options may set
 #
 
 my $short;
 my $verbose;
+my $anyway;
 
 #######################################################################
-# Return the pid of the http server as found in the pid file
+# Return the pid of the server as found in the given pid file
 #
 sub serverpid {
+    my $PIDFILE = $_[0];
     open(PFILE, "<$PIDFILE");
     my $PID=<PFILE>;
     close(PFILE);
-    chomp $PID;
     return $PID;
 }
 
 #######################################################################
-# stop the test http server
+# stop the given test server
 #
 sub stopserver {
+    my $PIDFILE = $_[0];
     # check for pidfile
     if ( -f $PIDFILE ) {
-        my $PID = serverpid();
+        my $PID = serverpid($PIDFILE);
+
         my $res = kill (9, $PID); # die!
         unlink $PIDFILE; # server is killed
 
-        if($res) {
-            print "TCP server signalled to die\n";
+        if($res && $verbose) {
+            print "Test server pid $PID signalled to die\n";
+        }
+        elsif($verbose) {
+            print "Test server pid $PID didn't exist\n";
         }
     }
 }
 
 #######################################################################
 # start the http server, or if it already runs, verify that it is our
 # test server on the test-port!
 #
-sub runserver {
+sub runhttpserver {
+    my $verbose = $_[0];
     my $STATUS;
     my $RUNNING;
     # check for pidfile
     if ( -f $PIDFILE ) {
-        my $PID=serverpid();
+        my $PID=serverpid($PIDFILE);
         if ($PID ne "" && kill(0, $PID)) {
             $STATUS="httpd (pid $PID) running";
             $RUNNING=1;
         }
         else {
             $STATUS="httpd (pid $PID?) not running";
@@ -104,12 +124,55 @@
         }
 
         print "The running HTTP server has been verified to be our server\n";
     }
 }
 
+sub runftpserver {
+    my $verbose = $_[0];
+    my $STATUS;
+    my $RUNNING;
+    # check for pidfile
+    if ( -f $FTPPIDFILE ) {
+        my $PID=serverpid($FTPPIDFILE);
+        if ($PID ne "" && kill(0, $PID)) {
+            $STATUS="ftpd (pid $PID) running";
+            $RUNNING=1;
+        }
+        else {
+            $STATUS="ftpd (pid $PID?) not running";
+            $RUNNING=0;
+        }
+    }
+    else {
+        $STATUS="ftpd (no pid file) not running";
+        $RUNNING=0;
+    }
+
+    if ($RUNNING != 1) {
+        system("perl ./ftpserver.pl $FTPPORT &");
+        sleep 1; # give it a little time to start
+    }
+    else {
+        print "$STATUS\n";
+
+        # verify that our server is one one running on this port:
+        my $data=`$CURL --silent -i ftp://$HOSTIP:$FTPPORT/verifiedserver`;
+
+        if ( $data !~ /WE ROOLZ/ ) {
+            print "Another FTP server is running on port $FTPPORT\n",
+            "Edit runtests.pl to use another FTP port and rerun the ",
+            "test script\n";
+            exit;
+        }
+
+        print "The running FTP server has been verified to be our server\n";
+    }
+}
+
+
 #######################################################################
 # This function compares two binary files and return non-zero if they
 # differ
 #
 sub comparefiles {
     my $source=$_[0];
@@ -121,23 +184,23 @@
     open(D, "<$dest") ||
         return 1;
 
     # silly win-crap
     binmode S;
     binmode D;
-    
+
     my $m = 20;
     my ($snum, $dnum, $s, $d);
     do {
         $snum = read(S, $s, $m);
         $dnum = read(D, $d, $m);
         if(($snum != $dnum) ||
            ($s ne $d)) {
             print "$source and $dest differ\n";
             $res=1;
-            last;
+            $snum=0;
         }
     } while($snum);
     close(S);
     close(D);
     return $res;
 }
@@ -208,34 +271,48 @@
         filteroff($sec, $strip, "$LOGDIR/stored.tmp");
                 
         $first="$LOGDIR/generated.tmp";
         $sec="$LOGDIR/stored.tmp";
     }
 
-    comparefiles($first, $sec);
+    $res = comparefiles($first, $sec);
     if ($res != 0) {
         print " $text FAILED";
         return 1;
     }
 
-    print " $text OK";
+    if(!$short) {
+        print " $text OK";
+    }
     return 0;
 }
 
 #######################################################################
 # display information about curl and the host the test suite runs on
 #
 sub displaydata {
+
+    unlink($memdump); # remove this if there was one left
+
     my $version=`$CURL -V`;
     my $hostname=`hostname`;
     my $hosttype=`uname -a`;
 
     print "Running tests on:\n",
     "* $version",
-    "* host $hostname",
-    "* system $hosttype";
+    "* Host: $hostname",
+    "* System: $hosttype";
+
+    if( -r $memdump) {
+        # if this exists, curl was compiled with memory debugging
+        # enabled and we shall verify that no memory leaks exist
+        # after each and every test!
+        $memory_debug=1;
+    }
+    printf("* Memory debugging: %s\n", $memory_debug?"ON":"OFF");
+
 }
 
 #######################################################################
 # Run a single specified test case
 #
 
@@ -248,28 +325,49 @@
         $REPLY="$TESTDIR/reply${NUMBER}0001.txt";
     }
 
     # curl command to run
     my $CURLCMD="$TESTDIR/command$NUMBER.txt";
 
-    # this is the valid HTTP we should generate
-    my $HTTP="$TESTDIR/http$NUMBER.txt";
-
-    # name of the test
-    open(N, "<$TESTDIR/name$NUMBER.txt");
-    my $DESC=<N>;
-    close(N);
-    $DESC =~ s/[\r\n]//g;
+    # this is the valid protocol file we should generate
+    my $PROT="$TESTDIR/prot$NUMBER.txt";
 
     # redirected stdout/stderr here
     $STDOUT="$LOGDIR/stdout$NUMBER";
     $STDERR="$LOGDIR/stderr$NUMBER";
 
-    # if this file exist, we verify that the stdout contained this:
+    # if this file exists, we verify that the stdout contained this:
     my $VALIDOUT="$TESTDIR/stdout$NUMBER.txt";
 
+    # if this file exists, we verify upload
+    my $UPLOAD="$TESTDIR/upload$NUMBER.txt";
+
+    # if this file exists, it is FTP server instructions:
+    my $ftpservercmd="$TESTDIR/ftpd$NUMBER.txt";
+
+    if(! -r $CURLCMD) {
+        # this is not a test
+        print "$NUMBER doesn't look like a test case!\n";
+        next;
+    }
+
+    # remove previous server output logfile
+    unlink($SERVERIN);
+
+    if(-r $ftpservercmd) {
+        # copy the instruction file
+        system("cp $ftpservercmd $FTPDCMD");
+    }
+
+    # name of the test
+    open(N, "<$TESTDIR/name$NUMBER.txt") ||
+        print "** Couldn't read name on test $NUMBER\n";
+    my $DESC=<N>;
+    close(N);
+    $DESC =~ s/[\r\n]//g;
+
     print "test $NUMBER...";
     if(!$short) {
         print "[$DESC]\n";
     }
 
     # get the command line options to use
@@ -279,100 +377,213 @@
     chomp $cmd;
     close(COMMAND);
 
     # make some nice replace operations
     $cmd =~ s/%HOSTIP/$HOSTIP/g;
     $cmd =~ s/%HOSTPORT/$HOSTPORT/g;
+    $cmd =~ s/%FTPPORT/$FTPPORT/g;
     #$cmd =~ s/%HOSTNAME/$HOSTNAME/g;
 
+    if($memory_debug) {
+        unlink($memdump);
+    }
+
+    my $out="";
+    if ( ! -r "$VALIDOUT" ) {
+        $out="--output $CURLOUT ";
+    }
+
     # run curl, add -v for debug information output
-    my $CMDLINE="$CURL --output $CURLOUT --include --silent $cmd >$STDOUT 2>$STDERR";
+    my $CMDLINE="$CURL $out--include -v --silent $cmd >$STDOUT 2>$STDERR";
+
+    my $STDINFILE="$TESTDIR/stdin$NUMBER.txt";
+    if(-f $STDINFILE) {
+        $CMDLINE .= " < $STDINFILE";
+    }
 
     if($verbose) {
         print "$CMDLINE\n";
     }
 
+    print CMDLOG "$CMDLINE\n";
+
     # run the command line we built
     my $res = system("$CMDLINE");
     $res /= 256;
 
+    my $ERRORCODE = "$TESTDIR/error$NUMBER.txt";
+
     if ($res != 0) {
-        print "*** Failed to invoke curl for test $NUMBER ***\n",
-        "*** [$DESC] ***\n",
-        "*** The command line was: ***\n $CMDLINE\n";
-        exit;
+        # the invoked command return an error code
+
+        my $expectederror=0;
+
+        if(-f $ERRORCODE) {
+            open(ERRO, "<$ERRORCODE");
+            $expectederror = <ERRO>;
+            close(ERRO);
+            # strip non-digits
+            $expectederror =~ s/[^0-9]//g;
+        }
+
+        if($expectederror != $res) {
+
+            print "*** Failed to invoke curl for test $NUMBER ***\n",
+            "*** [$DESC] ***\n",
+            "*** The command returned $res for: ***\n $CMDLINE\n";
+            return 1;
+        }
+        elsif(!$short) {
+            print " error OK";
+        }
     }
     else {
-        # verify the received data
-        $res = compare($CURLOUT, $REPLY, "data");
-        if ($res) {
-            exit;
+        if(-f $ERRORCODE) {
+            # this command was meant to fail, it didn't and thats WRONG
+            if(!$short) {
+                print " error FAILED";
+            }
+            return 1;
         }
 
-        # verify the sent request
-        $res = compare($SERVERIN, $HTTP, "http",
-                       "^(User-Agent:|--curl|Content-Type: multipart/form-data; boundary=).*\r\n");
-
-        # The strip pattern above is for stripping off User-Agent: since
-        # that'll be different in all versions, and the lines in a
-        # RFC1876-post that are randomly generated and therefore are doomed to
-        # always differ!
+        if ( -r "$VALIDOUT" ) {
+            # verify redirected stdout
+            $res = compare($STDOUT, $VALIDOUT, "data");
+            if($res) {
+                return 1;
+            }
+        }
+        else {
+            if (! -r $REPLY && -r $CURLOUT) {
+                print "** Missing reply data file for test $NUMBER",
+                ", should be similar to $CURLOUT\n";
+                return 1;            
+            }
 
-        if($res) {
-            exit;
+            if( -r $CURLOUT ) {
+                # verify the received data
+                $res = compare($CURLOUT, $REPLY, "data");
+                if ($res) {
+                    return 1;
+                }
+            }
         }
 
-        if ( -r "$VALIDOUT" ) {
+        if(-r $UPLOAD) {
+             # verify uploaded data
+            $res = compare("$LOGDIR/upload.$NUMBER", $UPLOAD, "upload");
+            if ($res) {
+                return 1;
+            }
+        }
+
+
+        if(-r $SERVERIN) {
+            if(! -r $PROT) {
+                print "** Missing protocol file for test $NUMBER",
+                ", should be similar to $SERVERIN\n";
+                return 1;
+            }
 
-            $res = compare($STDOUT, $VALIDOUT, "stdout");
+            # The strip pattern below is for stripping off User-Agent: since
+            # that'll be different in all versions, and the lines in a
+            # RFC1876-post that are randomly generated and therefore are
+            # doomed to always differ!
+            
+            # verify the sent request
+            $res = compare($SERVERIN, $PROT, "protocol",
+                           "^(User-Agent:|--curl|Content-Type: multipart/form-data; boundary=|PORT ).*\r\n");
             if($res) {
-                exit;
+                return 1;
             }
         }
 
-        # remove the stdout and stderr files
-        unlink($STDOUT);
-        unlink($STDERR);
+    }
 
+    # remove the stdout and stderr files
+    unlink($STDOUT);
+    unlink($STDERR);
+
+    unlink($FTPDCMD); # remove the instructions for this test
+
+    if($memory_debug) {
+        if(! -f $memdump) {
+            print "\n** ALERT! memory debuggin without any output file?\n";
+        }
+        else {
+            my @memdata=`$memanalyze < $memdump`;
+            my $leak=0;
+            for(@memdata) {
+                if($_ ne "") {
+                    # well it could be other memory problems as well, but
+                    # we call it leak for short here
+                    $leak=1;
+                }
+            }
+            if($leak) {
+                print "\n** MEMORY FAILURE\n";
+                print @memdata;
+                return 1;
+            }
+            else {
+                if(!$short) {
+                    print " memory OK";
+                }
+            }
+        }
+    }
+    if($short) {
+        print "OK";
     }
     print "\n";
 
     return 0;
 }
 
 
 #######################################################################
 # Check options to this test program
 #
 
+my @testthis;
 do {
     if ($ARGV[0] eq "-v") {
         # verbose output
         $verbose=1;
     }
     elsif($ARGV[0] eq "-s") {
         # short output
         $short=1;
     }
+    elsif($ARGV[0] eq "-a") {
+        # continue anyway, even if a test fail
+        $anyway=1;
+    }
     elsif($ARGV[0] eq "-h") {
         # show help text
         print <<EOHELP
 Usage: runtests.pl [-h][-s][-v][numbers]
+  -a       continue even if a test fails
   -h       this help text
   -s       short output
   -v       verbose output
   [num]    as string like "5 6 9" to run those tests only
 EOHELP
     ;
         exit;
     }
     elsif($ARGV[0] =~ /^(\d+)/) {
-        $TESTCASES=$ARGV[0]; # run these tests
+        push @testthis, $1;
     }
 } while(shift @ARGV);
 
+if($testthis[0] ne "") {
+    $TESTCASES=join(" ", @testthis);
+}
+
+
 #######################################################################
 # Output curl version and host info being tested
 #
 
 displaydata();
 
@@ -380,25 +591,26 @@
 # clear and create logging directory:
 #
 cleardir($LOGDIR);
 mkdir($LOGDIR, 0777);
 
 #######################################################################
-# First, start the TCP server
+# First, start our test servers
 #
 
-runserver();
+runhttpserver($verbose);
+runftpserver($verbose);
 
 #######################################################################
 # If 'all' tests are requested, find out all test numbers
 #
 
 if ( $TESTCASES eq "all") {
     # Get all commands and find out their test numbers
     opendir(DIR, $TESTDIR) || die "can't opendir $TESTDIR: $!";
-    my @cmds = grep { /^command/ && -f "$TESTDIR/$_" } readdir(DIR);
+    my @cmds = grep { /^command([0-9]+).txt/ && -f "$TESTDIR/$_" } readdir(DIR);
     closedir DIR;
 
     $TESTCASES=""; # start with no test cases
 
     # cut off everything but the digits 
     for(@cmds) {
@@ -408,22 +620,47 @@
     for(sort { $a <=> $b } @cmds) {
         $TESTCASES .= " $_";
     }
 }
 
 #######################################################################
+# Start the command line log
+#
+open(CMDLOG, ">$CURLLOG") ||
+    print "can't log command lines to $CURLLOG\n";
+
+#######################################################################
 # The main test-loop
 #
 
 my $testnum;
+my $ok=0;
+my $total=0;
 foreach $testnum (split(" ", $TESTCASES)) {
 
-    singletest($testnum);
+    $total++;
+    my $error = singletest($testnum);
+    if($error && !$anyway) {
+        # a test failed, abort
+        print "\n - abort tests\n";
+        last;
+    }
+    elsif(!$error) {
+        $ok++;
+    }
 
     # loop for next test
 }
 
 #######################################################################
-# Tests done, stop the server
+# Close command log
 #
+close(CMDLOG);
+
+#######################################################################
+# Tests done, stop the servers
+#
+
+stopserver($FTPPIDFILE);
+stopserver($PIDFILE);
 
-stopserver();
+print "$ok tests out of $total reported OK\n";
