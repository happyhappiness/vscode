diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/acconfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/acconfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/acconfig.h	2000-09-19 06:06:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/acconfig.h	2001-01-23 07:55:20.000000000 +0800
@@ -33,6 +33,9 @@
 
 /* Define if you need the _REENTRANT define for some functions */
 #undef NEED_REENTRANT
 
 /* Define if you have the Kerberos4 libraries (including -ldes) */
 #undef KRB4
+
+/* Define if you want to enable IPv6 support */
+#undef ENABLE_IPV6
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/CHANGES	2001-01-04 20:53:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/CHANGES	2001-01-27 23:39:39.000000000 +0800
@@ -3,12 +3,138 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
                                History of Changes
 
+
+Version 7.6
+
+Daniel (26 January 2001)
+- Lots of mails back and forth with Bob Schader finally made me add a small
+  piece of code in the HTTP engine so that HTTP upload resume works. You can
+  now do an operation like 'curl -T file -C <offset> <URL>' and curl will PUT
+  the ending part of the file starting at given offet to the specified URL.
+
+Version 7.6-pre4
+
+Daniel (25 January 2001)
+- I took hold of Rick Jones' question why we don't use recv() and send() for
+  reading/writing to the sockets and I've now modified the sread() and
+  swrite() macros to use them instead. If nothing else, they could be tested
+  in the next beta-round coming right up.
+
+- Jeff Morrow found a problem with libcurl's usage of SSL_read() and supplied
+  his research results in how to fix this. It turns out we have to invoke the
+  function several times in some cases. The same goes for the SSL_write().
+
+  I made some rather drastic changes all over libcurl to make all writes and
+  reads get done on one single place so that this repeated-attempts thing
+  would only have to be implemented at one point.
+
+- Rick Jones spotted that the 'total time' counter really didn't measure the
+  total time very accurate on subsecond levels.
+
+- Johan Nilsson pointed out the need to more clearly specify that the timeout
+  value you set for a download is for the *entire* download. There's currently
+  no option available that sets a timeout for the connection phase only.
+
+Daniel (24 January 2001)
+- Ingo Ralf Blum submitted a series of patches required to get curl to compile
+  properly with cygwin.
+
+- Robert Weaver posted a fix for the win32 section of the curl_getenv() code
+  that corrected a potential memory leak.
+
+- Added comments in a few files in a sudden attempt to make the sources more
+  easy to read and understand!
+
+Daniel (23 January 2001)
+- Added simple IPv6 detection in the configure script and made the version
+  string add 'ipv6' to the enable section in that case. ENABLE_IPV6 will be
+  set if curl is compiled with IPv6 support enabled.
+
+- Added a parser for IPv6-style specified IP-addresses in a URL. Thus, when
+  IPv6 gets enabled soon, we can use URLs like '[0::1]:80'...
+
+- Made the URL globbing in the client possible to fail silently if there's an
+  error in the globbing. It makes it almost intuitive, so when you don't
+  follow the syntax rules, globbing is simply switched off and the raw string
+  is used instead.
+
+  I still think we'll get problems with IPv6-style IP-addresses when we *want*
+  globbing on parts of the URL as the initial part of the URL will for sure
+  seriously confuse the globber.
+
+Daniel (22 January 2001)
+- Björn Stenberg supplied a progress meter patch that makes it look better even
+  during slow starts. Previously it made some silly assumptions...
+
+- Added two FTP tests for -Q and -Q - stuff since it was being discussed on
+  the mailing list. Had to correct the ftpserver.pl too as it bugged slightly.
+
+Daniel (19 January 2001)
+- Made the Location: parsers deal with any-length URLs. Thus I removed the last
+  code that restricts the length of URLs that curl supports.
+
+- Added a --globoff test case (#28) and it quickly identified a memory problem
+  in src/main.c that I took care of.
+
+Version 7.6-pre3
+
+Daniel (17 January 2001)
+- Made the two former files lib/download.c and lib/highlevel.c become the new
+  lib/transfer.c which makes more sense. I also did the rename from Transfer()
+  to Curl_Transfer() in the other source files that use the transfer function
+  in the spirit of using Curl_ prefix for library-scoped global symbols.
+
+Daniel (11 January 2001)
+- Added -g/--globoff that switches OFF the URL globbing and thus enables {}[]
+  letters to be part of the URL. Do note that RFC2396 section 2.4.3 explicitly
+  mention these letters to be escaped. This was posted as a feature request by
+  Jorge Gutierrez and as a bug by Terry.
+
+- Short options to curl that requires parameters can now be specified without
+  having the option and its parameter space separated. -ofile works as good as
+  -o file. -m20 is equal to -m 20. Do note that this goes for single-letter
+  options only, verbose --long-style options still must be separated with
+  space from their parameters.
+
+Daniel (8 January 2001)
+- Francis Dagenais reported that the SCO compiler still fails when compiling
+  curl due to that getpass_r() prototype. I've now put it around #ifndef
+  HAVE_GETPASS_R in an attempt to please the SCO systems.
+
+- Made some minor corrections to get the client to cleanup properly and I made
+  the separator work again when getting multiple globbed URLs to stdout.
+
+- Worked with Loic Dachary to get the make dist and make distcheck work
+  correctly. The 'maketgz' script is now using the automake generated 'make
+  dist' when creating release archives. Loic successfully made 'make rpms'
+  automatically build RPMs!
+
+Loic Dachary (6 January 2001)
+- Automated generation of rpm packages, no need to be root.
+
+- make distcheck generates a proper distribution (EXTRA_DIST
+  in all Makefile.am modified to match FILES).
+
+Daniel (5 January 2001)
+- Huge client-side hack: now multiple URLs are supported. Any number of URLs
+  can be specified on the command line, and they'll all be downloaded. There
+  must be a corresponding -o or -O for each URL or the data will be written to
+  stdout. This needs more testing, time to release a 7.6-pre package.
+
+- The krb4 support was broken in the release. Fixed now.
+
+- Huge internal symbol rename operation. All non-static but still lib-internal
+  symbols should now be prefixed with 'Curl_' to prevent collisions with other
+  libs. All public symbols should be prefixed with 'curl_' and the rest should
+  be static and thus invisible to the outside world. I updated the INTERNALS
+  document to say this as well.
+
 Version 7.5.2
 
 Daniel (4 January 2001)
 - As Kevin P Roth suggested, I've added text to the man page for every command
   line option and what happens when you specify that option more than
   once. That hasn't been exactly crystal clear before.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/config.h.in	2000-11-10 17:14:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/config.h.in	2001-01-23 22:38:19.000000000 +0800
@@ -49,12 +49,15 @@
 /* Define if you need the _REENTRANT define for some functions */
 #undef NEED_REENTRANT
 
 /* Define if you have the Kerberos4 libraries (including -ldes) */
 #undef KRB4
 
+/* Define if you want to enable IPv6 support */
+#undef ENABLE_IPV6
+
 /* The number of bytes in a long double.  */
 #undef SIZEOF_LONG_DOUBLE
 
 /* The number of bytes in a long long.  */
 #undef SIZEOF_LONG_LONG
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/configure	2001-01-04 18:29:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/configure	2001-01-25 20:28:51.000000000 +0800
@@ -21,12 +21,15 @@
   --with-gnu-ld           assume the C compiler uses GNU ld [default=no]"
 ac_help="$ac_help
   --disable-libtool-lock  avoid locking (might break parallel builds)"
 ac_help="$ac_help
   --disable-largefile     omit support for large files"
 ac_help="$ac_help
+  --enable-ipv6		Enable ipv6 (with ipv4) support
+  --disable-ipv6		Disable ipv6 support"
+ac_help="$ac_help
   --with-krb4-includes[=DIR]   Specify location of kerberos4 headers"
 ac_help="$ac_help
   --with-krb4-libs[=DIR]   Specify location of kerberos4 libs"
 ac_help="$ac_help
   --with-krb4[=DIR]       where to look for Kerberos4"
 ac_help="$ac_help
@@ -577,13 +580,13 @@
 # AIX /bin/install
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:584: checking for a BSD compatible install" >&5
+echo "configure:587: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
   for ac_dir in $PATH; do
@@ -630,13 +633,13 @@
 
 test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
 echo $ac_n "checking whether build environment is sane""... $ac_c" 1>&6
-echo "configure:637: checking whether build environment is sane" >&5
+echo "configure:640: checking whether build environment is sane" >&5
 # Just in case
 sleep 1
 echo timestamp > conftestfile
 # Do `set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
@@ -687,13 +690,13 @@
   program_transform_name="s,\$\$,${program_suffix},; $program_transform_name"
 
 # sed with no file args requires a program.
 test "$program_transform_name" = "" && program_transform_name="s,x,x,"
 
 echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
-echo "configure:694: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "configure:697: checking whether ${MAKE-make} sets \${MAKE}" >&5
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftestmake <<\EOF
 all:
@@ -733,65 +736,65 @@
 EOF
 
 
 
 missing_dir=`cd $ac_aux_dir && pwd`
 echo $ac_n "checking for working aclocal""... $ac_c" 1>&6
-echo "configure:740: checking for working aclocal" >&5
+echo "configure:743: checking for working aclocal" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (aclocal --version) < /dev/null > /dev/null 2>&1; then
    ACLOCAL=aclocal
    echo "$ac_t""found" 1>&6
 else
    ACLOCAL="$missing_dir/missing aclocal"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working autoconf""... $ac_c" 1>&6
-echo "configure:753: checking for working autoconf" >&5
+echo "configure:756: checking for working autoconf" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (autoconf --version) < /dev/null > /dev/null 2>&1; then
    AUTOCONF=autoconf
    echo "$ac_t""found" 1>&6
 else
    AUTOCONF="$missing_dir/missing autoconf"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working automake""... $ac_c" 1>&6
-echo "configure:766: checking for working automake" >&5
+echo "configure:769: checking for working automake" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (automake --version) < /dev/null > /dev/null 2>&1; then
    AUTOMAKE=automake
    echo "$ac_t""found" 1>&6
 else
    AUTOMAKE="$missing_dir/missing automake"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working autoheader""... $ac_c" 1>&6
-echo "configure:779: checking for working autoheader" >&5
+echo "configure:782: checking for working autoheader" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (autoheader --version) < /dev/null > /dev/null 2>&1; then
    AUTOHEADER=autoheader
    echo "$ac_t""found" 1>&6
 else
    AUTOHEADER="$missing_dir/missing autoheader"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working makeinfo""... $ac_c" 1>&6
-echo "configure:792: checking for working makeinfo" >&5
+echo "configure:795: checking for working makeinfo" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (makeinfo --version) < /dev/null > /dev/null 2>&1; then
    MAKEINFO=makeinfo
    echo "$ac_t""found" 1>&6
@@ -874,13 +877,13 @@
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:881: checking host system type" >&5
+echo "configure:884: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -895,13 +898,13 @@
 host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:902: checking build system type" >&5
+echo "configure:905: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
 NONE)
   case $nonopt in
   NONE) build_alias=$host_alias ;;
@@ -915,13 +918,13 @@
 build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$build" 1>&6
 
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:922: checking for $ac_word" >&5
+echo "configure:925: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$RANLIB"; then
   ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
 else
@@ -945,13 +948,13 @@
   echo "$ac_t""no" 1>&6
 fi
 
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:952: checking for $ac_word" >&5
+echo "configure:955: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -975,13 +978,13 @@
 fi
 
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:982: checking for $ac_word" >&5
+echo "configure:985: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1026,13 +1029,13 @@
   if test -z "$CC"; then
     case "`uname -s`" in
     *win32* | *WIN32*)
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1033: checking for $ac_word" >&5
+echo "configure:1036: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1058,29 +1061,29 @@
     esac
   fi
   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1065: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1068: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1076 "configure"
+#line 1079 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1081: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1084: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
     ac_cv_prog_cc_cross=no
   else
     ac_cv_prog_cc_cross=yes
@@ -1100,27 +1103,27 @@
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
 if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1107: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1110: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1112: checking whether we are using GNU C" >&5
+echo "configure:1115: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.c <<EOF
 #ifdef __GNUC__
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1121: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1124: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
 fi
 fi
 
@@ -1133,13 +1136,13 @@
 fi
 
 ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1140: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1143: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo 'void f(){}' > conftest.c
 if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
   ac_cv_prog_cc_g=yes
@@ -1176,13 +1179,13 @@
 fi
 
 ac_prog=ld
 if test "$ac_cv_prog_gcc" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   echo $ac_n "checking for ld used by GCC""... $ac_c" 1>&6
-echo "configure:1183: checking for ld used by GCC" >&5
+echo "configure:1186: checking for ld used by GCC" >&5
   ac_prog=`($CC -print-prog-name=ld) 2>&5`
   case "$ac_prog" in
     # Accept absolute paths.
     [\\/]* | [A-Za-z]:[\\/]*)
       re_direlt='/[^/][^/]*/\.\./'
       # Canonicalize the path of ld
@@ -1200,16 +1203,16 @@
     # If it is relative, then search for the first ld in PATH.
     with_gnu_ld=unknown
     ;;
   esac
 elif test "$with_gnu_ld" = yes; then
   echo $ac_n "checking for GNU ld""... $ac_c" 1>&6
-echo "configure:1207: checking for GNU ld" >&5
+echo "configure:1210: checking for GNU ld" >&5
 else
   echo $ac_n "checking for non-GNU ld""... $ac_c" 1>&6
-echo "configure:1210: checking for non-GNU ld" >&5
+echo "configure:1213: checking for non-GNU ld" >&5
 fi
 if eval "test \"`echo '$''{'ac_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -z "$LD"; then
   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
@@ -1238,13 +1241,13 @@
   echo "$ac_t""$LD" 1>&6
 else
   echo "$ac_t""no" 1>&6
 fi
 test -z "$LD" && { echo "configure: error: no acceptable ld found in \$PATH" 1>&2; exit 1; }
 echo $ac_n "checking if the linker ($LD) is GNU ld""... $ac_c" 1>&6
-echo "configure:1245: checking if the linker ($LD) is GNU ld" >&5
+echo "configure:1248: checking if the linker ($LD) is GNU ld" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   # I'd rather use --version here, but apparently some GNU ld's only accept -v.
 if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
   ac_cv_prog_gnu_ld=yes
@@ -1254,13 +1257,13 @@
 fi
 
 echo "$ac_t""$ac_cv_prog_gnu_ld" 1>&6
 
 
 echo $ac_n "checking for BSD-compatible nm""... $ac_c" 1>&6
-echo "configure:1261: checking for BSD-compatible nm" >&5
+echo "configure:1264: checking for BSD-compatible nm" >&5
 if eval "test \"`echo '$''{'ac_cv_path_NM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$NM"; then
   # Let the user override the test.
   ac_cv_path_NM="$NM"
@@ -1290,13 +1293,13 @@
 fi
 
 NM="$ac_cv_path_NM"
 echo "$ac_t""$NM" 1>&6
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:1297: checking whether ln -s works" >&5
+echo "configure:1300: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   rm -f conftestdata
 if ln -s X conftestdata 2>/dev/null
 then
@@ -1339,14 +1342,14 @@
 
 # Some flags need to be propagated to the compiler or linker for good
 # libtool support.
 case "$lt_target" in
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 1346 "configure"' > conftest.$ac_ext
-  if { (eval echo configure:1347: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  echo '#line 1349 "configure"' > conftest.$ac_ext
+  if { (eval echo configure:1350: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
     case "`/usr/bin/file conftest.o`" in
     *32-bit*)
       LD="${LD-ld} -32"
       ;;
     *N32*)
       LD="${LD-ld} -n32"
@@ -1361,25 +1364,25 @@
 
 *-*-sco3.2v5*)
   # On SCO OpenServer 5, we need -belf to get full-featured binaries.
   SAVE_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -belf"
   echo $ac_n "checking whether the C compiler needs -belf""... $ac_c" 1>&6
-echo "configure:1368: checking whether the C compiler needs -belf" >&5
+echo "configure:1371: checking whether the C compiler needs -belf" >&5
 if eval "test \"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1373 "configure"
+#line 1376 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1380: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1383: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   lt_cv_cc_needs_belf=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1482,13 +1485,13 @@
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:1489: checking host system type" >&5
+echo "configure:1492: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -1503,13 +1506,13 @@
 host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:1510: checking target system type" >&5
+echo "configure:1513: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
 NONE)
   case $nonopt in
   NONE) target_alias=$host_alias ;;
@@ -1524,13 +1527,13 @@
 echo "$ac_t""$target" 1>&6
 
 
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1531: checking for $ac_word" >&5
+echo "configure:1534: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1554,13 +1557,13 @@
 fi
 
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1561: checking for $ac_word" >&5
+echo "configure:1564: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1605,13 +1608,13 @@
   if test -z "$CC"; then
     case "`uname -s`" in
     *win32* | *WIN32*)
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1612: checking for $ac_word" >&5
+echo "configure:1615: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1637,29 +1640,29 @@
     esac
   fi
   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1644: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1647: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1655 "configure"
+#line 1658 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1660: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1663: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
     ac_cv_prog_cc_cross=no
   else
     ac_cv_prog_cc_cross=yes
@@ -1679,27 +1682,27 @@
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
 if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1686: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1689: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1691: checking whether we are using GNU C" >&5
+echo "configure:1694: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.c <<EOF
 #ifdef __GNUC__
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1700: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1703: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
 fi
 fi
 
@@ -1712,13 +1715,13 @@
 fi
 
 ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1719: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1722: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo 'void f(){}' > conftest.c
 if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
   ac_cv_prog_cc_g=yes
@@ -1745,13 +1748,13 @@
     CFLAGS=
   fi
 fi
 
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1752: checking how to run the C preprocessor" >&5
+echo "configure:1755: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
 if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
@@ -1760,53 +1763,53 @@
     # This must be in double quotes, not single quotes, because CPP may get
   # substituted into the Makefile and "${CC-cc}" will confuse make.
   CPP="${CC-cc} -E"
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1767 "configure"
+#line 1770 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1773: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1776: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1784 "configure"
+#line 1787 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1790: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1793: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 1801 "configure"
+#line 1804 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1807: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1810: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
@@ -1825,15 +1828,15 @@
 else
   ac_cv_prog_CPP="$CPP"
 fi
 echo "$ac_t""$CPP" 1>&6
 
 echo $ac_n "checking for AIX""... $ac_c" 1>&6
-echo "configure:1832: checking for AIX" >&5
+echo "configure:1835: checking for AIX" >&5
 cat > conftest.$ac_ext <<EOF
-#line 1834 "configure"
+#line 1837 "configure"
 #include "confdefs.h"
 #ifdef _AIX
   yes
 #endif
 
 EOF
@@ -1858,49 +1861,49 @@
   :
 fi
 
    if test "$enable_largefile" != no; then
 
      echo $ac_n "checking for special C compiler options needed for large files""... $ac_c" 1>&6
-echo "configure:1865: checking for special C compiler options needed for large files" >&5
+echo "configure:1868: checking for special C compiler options needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_largefile_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_largefile_CC=no
         if test "$GCC" != yes; then
 	  # IRIX 6.2 and later do not support large files by default,
 	  # so use the C compiler's -n32 option if that helps.
 	  cat > conftest.$ac_ext <<EOF
-#line 1874 "configure"
+#line 1877 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1883: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1886: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   ac_save_CC="$CC"
 	     CC="$CC -n32"
 	     cat > conftest.$ac_ext <<EOF
-#line 1892 "configure"
+#line 1895 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1901: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1904: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_largefile_CC=' -n32'
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -1914,49 +1917,49 @@
 echo "$ac_t""$ac_cv_sys_largefile_CC" 1>&6
      if test "$ac_cv_sys_largefile_CC" != no; then
        CC="$CC$ac_cv_sys_largefile_CC"
      fi
 
      echo $ac_n "checking for _FILE_OFFSET_BITS value needed for large files""... $ac_c" 1>&6
-echo "configure:1921: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+echo "configure:1924: checking for _FILE_OFFSET_BITS value needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_file_offset_bits'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_file_offset_bits=no
       cat > conftest.$ac_ext <<EOF
-#line 1927 "configure"
+#line 1930 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
         
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1938: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1941: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 1945 "configure"
+#line 1948 "configure"
 #include "confdefs.h"
 #define _FILE_OFFSET_BITS 64
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
 	   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1957: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1960: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_file_offset_bits=64
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -1970,49 +1973,49 @@
      cat >> confdefs.h <<EOF
 #define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
 EOF
 
    fi
      echo $ac_n "checking for _LARGEFILE_SOURCE value needed for large files""... $ac_c" 1>&6
-echo "configure:1977: checking for _LARGEFILE_SOURCE value needed for large files" >&5
+echo "configure:1980: checking for _LARGEFILE_SOURCE value needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_largefile_source'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_largefile_source=no
       cat > conftest.$ac_ext <<EOF
-#line 1983 "configure"
+#line 1986 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 #include <stdio.h>
         
 int main() {
 return !ftello;
 ; return 0; }
 EOF
-if { (eval echo configure:1994: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1997: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 2001 "configure"
+#line 2004 "configure"
 #include "confdefs.h"
 #define _LARGEFILE_SOURCE 1
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 #include <stdio.h>
 	   
 int main() {
 return !ftello;
 ; return 0; }
 EOF
-if { (eval echo configure:2013: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2016: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_largefile_source=1
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -2026,49 +2029,49 @@
      cat >> confdefs.h <<EOF
 #define _LARGEFILE_SOURCE $ac_cv_sys_largefile_source
 EOF
 
    fi
      echo $ac_n "checking for _LARGE_FILES value needed for large files""... $ac_c" 1>&6
-echo "configure:2033: checking for _LARGE_FILES value needed for large files" >&5
+echo "configure:2036: checking for _LARGE_FILES value needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_large_files'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_large_files=no
       cat > conftest.$ac_ext <<EOF
-#line 2039 "configure"
+#line 2042 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
         
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:2050: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2053: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 2057 "configure"
+#line 2060 "configure"
 #include "confdefs.h"
 #define _LARGE_FILES 1
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
 	   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:2069: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2072: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_large_files=1
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -2085,13 +2088,13 @@
 
    fi
    fi
   
 
 echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
-echo "configure:2092: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "configure:2095: checking whether ${MAKE-make} sets \${MAKE}" >&5
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftestmake <<\EOF
 all:
@@ -2121,20 +2124,80 @@
 
 
 
 
 
 
+echo $ac_n "checking whether to enable ipv6""... $ac_c" 1>&6
+echo "configure:2132: checking whether to enable ipv6" >&5
+# Check whether --enable-ipv6 or --disable-ipv6 was given.
+if test "${enable_ipv6+set}" = set; then
+  enableval="$enable_ipv6"
+   case "$enableval" in
+  no)
+       echo "$ac_t""no" 1>&6
+       ipv6=no
+       ;;
+  *)   echo "$ac_t""yes" 1>&6
+       cat >> confdefs.h <<\EOF
+#define ENABLE_IPV6 1
+EOF
+
+       ipv6=yes
+       ;;
+  esac 
+else
+  if test "$cross_compiling" = yes; then
+  echo "$ac_t""no" 1>&6
+  ipv6=no
+
+else
+  cat > conftest.$ac_ext <<EOF
+#line 2156 "configure"
+#include "confdefs.h"
+ /* is AF_INET6 available? */
+#include <sys/types.h>
+#include <sys/socket.h>
+main()
+{
+ if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+   exit(1);
+ else
+   exit(0);
+}
+
+EOF
+if { (eval echo configure:2170: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+then
+  echo "$ac_t""yes" 1>&6
+  cat >> confdefs.h <<\EOF
+#define ENABLE_IPV6 1
+EOF
+
+  ipv6=yes
+else
+  echo "configure: failed program was:" >&5
+  cat conftest.$ac_ext >&5
+  rm -fr conftest*
+  echo "$ac_t""no" 1>&6
+  ipv6=no
+fi
+rm -fr conftest*
+fi
+
+fi
+
+
 
 echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
-echo "configure:2130: checking for gethostbyname" >&5
+echo "configure:2193: checking for gethostbyname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2135 "configure"
+#line 2198 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2151,13 +2214,13 @@
 #else
 gethostbyname();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2158: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2221: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostbyname=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2169,32 +2232,32 @@
 if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
-echo "configure:2176: checking for gethostbyname in -lnsl" >&5
+echo "configure:2239: checking for gethostbyname in -lnsl" >&5
 ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2184 "configure"
+#line 2247 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char gethostbyname();
 
 int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:2195: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2258: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2220,18 +2283,18 @@
 
 fi
 
 
 if test "$ac_cv_lib_nsl_gethostbyname" != "yes" -a "$ac_cv_func_gethostbyname" != "yes"; then
     echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
-echo "configure:2227: checking for gethostbyname" >&5
+echo "configure:2290: checking for gethostbyname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2232 "configure"
+#line 2295 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2248,13 +2311,13 @@
 #else
 gethostbyname();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2255: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2318: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostbyname=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2266,32 +2329,32 @@
 if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for gethostbyname in -lsocket""... $ac_c" 1>&6
-echo "configure:2273: checking for gethostbyname in -lsocket" >&5
+echo "configure:2336: checking for gethostbyname in -lsocket" >&5
 ac_lib_var=`echo socket'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2281 "configure"
+#line 2344 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char gethostbyname();
 
 int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:2292: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2355: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2318,24 +2381,24 @@
 fi
 
 fi
 
 if test "$ac_cv_lib_nsl_gethostbyname" = "$ac_cv_func_gethostbyname"; then
   echo $ac_n "checking trying both nsl and socket libs""... $ac_c" 1>&6
-echo "configure:2325: checking trying both nsl and socket libs" >&5
+echo "configure:2388: checking trying both nsl and socket libs" >&5
   my_ac_save_LIBS=$LIBS
   LIBS="-lnsl -lsocket $LIBS"
   cat > conftest.$ac_ext <<EOF
-#line 2329 "configure"
+#line 2392 "configure"
 #include "confdefs.h"
 
 int main() {
 gethostbyname();
 ; return 0; }
 EOF
-if { (eval echo configure:2336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2399: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   my_ac_link_result=success
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2350,18 +2413,18 @@
   else
     echo "$ac_t""yes" 1>&6
   fi
 fi
 
 echo $ac_n "checking for strcasecmp""... $ac_c" 1>&6
-echo "configure:2357: checking for strcasecmp" >&5
+echo "configure:2420: checking for strcasecmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_strcasecmp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2362 "configure"
+#line 2425 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char strcasecmp(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2378,13 +2441,13 @@
 #else
 strcasecmp();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2448: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_strcasecmp=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2396,32 +2459,32 @@
 if eval "test \"`echo '$ac_cv_func_'strcasecmp`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for strcasecmp in -lresolve""... $ac_c" 1>&6
-echo "configure:2403: checking for strcasecmp in -lresolve" >&5
+echo "configure:2466: checking for strcasecmp in -lresolve" >&5
 ac_lib_var=`echo resolve'_'strcasecmp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolve  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2411 "configure"
+#line 2474 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char strcasecmp();
 
 int main() {
 strcasecmp()
 ; return 0; }
 EOF
-if { (eval echo configure:2422: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2485: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2447,32 +2510,32 @@
 
 fi
 
 
 if test "$ac_cv_lib_resolve_strcasecmp" = "$ac_cv_func_strcasecmp"; then
   echo $ac_n "checking for strcasecmp in -lresolve""... $ac_c" 1>&6
-echo "configure:2454: checking for strcasecmp in -lresolve" >&5
+echo "configure:2517: checking for strcasecmp in -lresolve" >&5
 ac_lib_var=`echo resolve'_'strcasecmp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolve -lnsl $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2462 "configure"
+#line 2525 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char strcasecmp();
 
 int main() {
 strcasecmp()
 ; return 0; }
 EOF
-if { (eval echo configure:2473: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2536: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2489,18 +2552,18 @@
   echo "$ac_t""no" 1>&6
 fi
 
 fi
 
 echo $ac_n "checking for connect""... $ac_c" 1>&6
-echo "configure:2496: checking for connect" >&5
+echo "configure:2559: checking for connect" >&5
 if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2501 "configure"
+#line 2564 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char connect(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2517,13 +2580,13 @@
 #else
 connect();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2524: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2587: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_connect=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2535,32 +2598,32 @@
 if eval "test \"`echo '$ac_cv_func_'connect`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:2542: checking for connect in -lsocket" >&5
+echo "configure:2605: checking for connect in -lsocket" >&5
 ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2550 "configure"
+#line 2613 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2561: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2624: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2585,18 +2648,18 @@
 fi
 
 fi
 
 
 echo $ac_n "checking for gethostname""... $ac_c" 1>&6
-echo "configure:2592: checking for gethostname" >&5
+echo "configure:2655: checking for gethostname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2597 "configure"
+#line 2660 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostname(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2613,13 +2676,13 @@
 #else
 gethostname();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2620: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2683: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostname=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2631,32 +2694,32 @@
 if eval "test \"`echo '$ac_cv_func_'gethostname`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for gethostname in -lucb""... $ac_c" 1>&6
-echo "configure:2638: checking for gethostname in -lucb" >&5
+echo "configure:2701: checking for gethostname in -lucb" >&5
 ac_lib_var=`echo ucb'_'gethostname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lucb  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2646 "configure"
+#line 2709 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char gethostname();
 
 int main() {
 gethostname()
 ; return 0; }
 EOF
-if { (eval echo configure:2657: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2720: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2681,18 +2744,18 @@
 fi
 
 fi
 
 
 echo $ac_n "checking for dlopen""... $ac_c" 1>&6
-echo "configure:2688: checking for dlopen" >&5
+echo "configure:2751: checking for dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2693 "configure"
+#line 2756 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2709,13 +2772,13 @@
 #else
 dlopen();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2716: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2779: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dlopen=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2727,32 +2790,32 @@
 if eval "test \"`echo '$ac_cv_func_'dlopen`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:2734: checking for dlopen in -ldl" >&5
+echo "configure:2797: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2742 "configure"
+#line 2805 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char dlopen();
 
 int main() {
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:2753: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2816: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2819,49 +2882,49 @@
   want_krb4="yes"
  
 fi
 
 
 echo $ac_n "checking if Kerberos4 support is requested""... $ac_c" 1>&6
-echo "configure:2826: checking if Kerberos4 support is requested" >&5
+echo "configure:2889: checking if Kerberos4 support is requested" >&5
 
 if test "$want_krb4" = yes
 then
   echo "$ac_t""yes" 1>&6
 
   
   echo $ac_n "checking where to look for Kerberos4""... $ac_c" 1>&6
-echo "configure:2834: checking where to look for Kerberos4" >&5
+echo "configure:2897: checking where to look for Kerberos4" >&5
   if test X"$OPT_KRB4" = Xyes
   then
     echo "$ac_t""defaults" 1>&6
   else
     echo "$ac_t""libs in $KRB4LIB, headers in $KRB4INC" 1>&6
   fi
 
     echo $ac_n "checking for des_pcbc_encrypt in -ldes""... $ac_c" 1>&6
-echo "configure:2843: checking for des_pcbc_encrypt in -ldes" >&5
+echo "configure:2906: checking for des_pcbc_encrypt in -ldes" >&5
 ac_lib_var=`echo des'_'des_pcbc_encrypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldes  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2851 "configure"
+#line 2914 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char des_pcbc_encrypt();
 
 int main() {
 des_pcbc_encrypt()
 ; return 0; }
 EOF
-if { (eval echo configure:2862: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2925: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2875,23 +2938,23 @@
   echo "$ac_t""yes" 1>&6
   
     for ac_hdr in des.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:2882: checking for $ac_hdr" >&5
+echo "configure:2945: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2887 "configure"
+#line 2950 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:2892: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:2955: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -2913,18 +2976,18 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 
 
         echo $ac_n "checking for res_search""... $ac_c" 1>&6
-echo "configure:2920: checking for res_search" >&5
+echo "configure:2983: checking for res_search" >&5
 if eval "test \"`echo '$''{'ac_cv_func_res_search'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2925 "configure"
+#line 2988 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char res_search(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2941,13 +3004,13 @@
 #else
 res_search();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2948: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3011: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_res_search=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2959,32 +3022,32 @@
 if eval "test \"`echo '$ac_cv_func_'res_search`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for res_search in -lresolv""... $ac_c" 1>&6
-echo "configure:2966: checking for res_search in -lresolv" >&5
+echo "configure:3029: checking for res_search in -lresolv" >&5
 ac_lib_var=`echo resolv'_'res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2974 "configure"
+#line 3037 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char res_search();
 
 int main() {
 res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:2985: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3048: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3009,32 +3072,32 @@
 fi
 
 fi
 
 
         echo $ac_n "checking for krb_net_read in -lkrb""... $ac_c" 1>&6
-echo "configure:3016: checking for krb_net_read in -lkrb" >&5
+echo "configure:3079: checking for krb_net_read in -lkrb" >&5
 ac_lib_var=`echo krb'_'krb_net_read | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lkrb  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3024 "configure"
+#line 3087 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char krb_net_read();
 
 int main() {
 krb_net_read()
 ; return 0; }
 EOF
-if { (eval echo configure:3035: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3098: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3048,23 +3111,23 @@
   echo "$ac_t""yes" 1>&6
   
             for ac_hdr in krb.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3055: checking for $ac_hdr" >&5
+echo "configure:3118: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3060 "configure"
+#line 3123 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3065: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3128: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3090,18 +3153,18 @@
 
             LIBS="-lkrb -ldes $LIBS"
 
                   for ac_func in krb_get_our_ip_for_realm
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3097: checking for $ac_func" >&5
+echo "configure:3160: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3102 "configure"
+#line 3165 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3118,13 +3181,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3125: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3188: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3151,18 +3214,18 @@
 EOF
 
 
             for ac_func in strlcpy
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3158: checking for $ac_func" >&5
+echo "configure:3221: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3163 "configure"
+#line 3226 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3179,13 +3242,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3186: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3249: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3235,44 +3298,44 @@
 then
   echo "configure: warning: SSL/https support disabled" 1>&2  
 else
 
   
   echo $ac_n "checking where to look for SSL""... $ac_c" 1>&6
-echo "configure:3242: checking where to look for SSL" >&5
+echo "configure:3305: checking where to look for SSL" >&5
   if test X"$OPT_SSL" = Xoff
   then
   	echo "$ac_t""defaults (or given in environment)" 1>&6
   else
 	test X"$OPT_SSL" = Xyes && OPT_SSL=/usr/local/ssl
                 LDFLAGS="$LDFLAGS -L$OPT_SSL/lib"
 	CPPFLAGS="$CPPFLAGS -I$OPT_SSL/include/openssl -I$OPT_SSL/include"
 	echo "$ac_t""$OPT_SSL" 1>&6
   fi
 
     echo $ac_n "checking for CRYPTO_lock in -lcrypto""... $ac_c" 1>&6
-echo "configure:3254: checking for CRYPTO_lock in -lcrypto" >&5
+echo "configure:3317: checking for CRYPTO_lock in -lcrypto" >&5
 ac_lib_var=`echo crypto'_'CRYPTO_lock | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3262 "configure"
+#line 3325 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char CRYPTO_lock();
 
 int main() {
 CRYPTO_lock()
 ; return 0; }
 EOF
-if { (eval echo configure:3273: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3336: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3296,32 +3359,32 @@
   echo "$ac_t""no" 1>&6
 fi
 
 
   if test $ac_cv_lib_crypto_CRYPTO_lock = yes; then
             echo $ac_n "checking for SSL_connect in -lssl""... $ac_c" 1>&6
-echo "configure:3303: checking for SSL_connect in -lssl" >&5
+echo "configure:3366: checking for SSL_connect in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3311 "configure"
+#line 3374 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char SSL_connect();
 
 int main() {
 SSL_connect()
 ; return 0; }
 EOF
-if { (eval echo configure:3322: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3385: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3345,36 +3408,36 @@
   echo "$ac_t""no" 1>&6
 fi
 
 
     if test "$ac_cv_lib_ssl_SSL_connect" != yes; then
                 echo $ac_n "checking for ssl with RSAglue/rsaref libs in use""... $ac_c" 1>&6
-echo "configure:3352: checking for ssl with RSAglue/rsaref libs in use" >&5;
+echo "configure:3415: checking for ssl with RSAglue/rsaref libs in use" >&5;
         OLIBS=$LIBS
         LIBS="$LIBS -lRSAglue -lrsaref"
         echo $ac_n "checking for SSL_connect in -lssl""... $ac_c" 1>&6
-echo "configure:3356: checking for SSL_connect in -lssl" >&5
+echo "configure:3419: checking for SSL_connect in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3364 "configure"
+#line 3427 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char SSL_connect();
 
 int main() {
 SSL_connect()
 ; return 0; }
 EOF
-if { (eval echo configure:3375: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3438: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3409,23 +3472,23 @@
 
 
         for ac_hdr in openssl/x509.h openssl/rsa.h openssl/crypto.h openssl/pem.h openssl/ssl.h openssl/err.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3416: checking for $ac_hdr" >&5
+echo "configure:3479: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3421 "configure"
+#line 3484 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3426: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3489: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3451,23 +3514,23 @@
 
     if test $ac_cv_header_openssl_x509_h = no; then
       for ac_hdr in x509.h rsa.h crypto.h pem.h ssl.h err.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3458: checking for $ac_hdr" >&5
+echo "configure:3521: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3463 "configure"
+#line 3526 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3468: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3531: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3496,18 +3559,18 @@
 
   
   for ac_func in RAND_status \
                   RAND_screen 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3503: checking for $ac_func" >&5
+echo "configure:3566: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3508 "configure"
+#line 3571 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3524,13 +3587,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3531: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3594: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3579,18 +3642,18 @@
 else
 
     
       for ac_func in gethostbyname_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3586: checking for $ac_func" >&5
+echo "configure:3649: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3591 "configure"
+#line 3654 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3607,13 +3670,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3614: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3677: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3627,18 +3690,18 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking if gethostbyname_r takes 3 arguments""... $ac_c" 1>&6
-echo "configure:3634: checking if gethostbyname_r takes 3 arguments" >&5
+echo "configure:3697: checking if gethostbyname_r takes 3 arguments" >&5
     if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3639 "configure"
+#line 3702 "configure"
 #include "confdefs.h"
 
 #include <string.h>
 #include <sys/types.h>
 #include <netdb.h>
 
@@ -3650,13 +3713,13 @@
 int rc;
 memset(&h, 0, sizeof(struct hostent));
 memset(&hdata, 0, sizeof(struct hostent_data));
 rc = gethostbyname_r(name, &h, &hdata);
 exit (rc != 0 ? 1 : 0); }
 EOF
-if { (eval echo configure:3657: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3720: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       echo "$ac_t""yes" 1>&6
       cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_3 1
 EOF
@@ -3666,18 +3729,18 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking if gethostbyname_r with -D_REENTRANT takes 3 arguments""... $ac_c" 1>&6
-echo "configure:3673: checking if gethostbyname_r with -D_REENTRANT takes 3 arguments" >&5
+echo "configure:3736: checking if gethostbyname_r with -D_REENTRANT takes 3 arguments" >&5
       if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3678 "configure"
+#line 3741 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 
 #include <string.h>
 #include <sys/types.h>
@@ -3691,13 +3754,13 @@
 int rc;
 memset(&h, 0, sizeof(struct hostent));
 memset(&hdata, 0, sizeof(struct hostent_data));
 rc = gethostbyname_r(name, &h, &hdata);
 exit (rc != 0 ? 1 : 0); }
 EOF
-if { (eval echo configure:3698: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3761: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
 	echo "$ac_t""yes" 1>&6
 	cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_3 1
 EOF
@@ -3711,18 +3774,18 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
   
 	echo "$ac_t""no" 1>&6
 	echo $ac_n "checking if gethostbyname_r takes 5 arguments""... $ac_c" 1>&6
-echo "configure:3718: checking if gethostbyname_r takes 5 arguments" >&5
+echo "configure:3781: checking if gethostbyname_r takes 5 arguments" >&5
 	if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3723 "configure"
+#line 3786 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 
 int
@@ -3732,13 +3795,13 @@
 char *name = "localhost";
 char buffer[8192];
 int h_errno;
 hp = gethostbyname_r(name, &h, buffer, 8192, &h_errno);
 exit (hp == NULL ? 1 : 0); }
 EOF
-if { (eval echo configure:3739: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3802: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
 	  echo "$ac_t""yes" 1>&6
 	  cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_5 1
 EOF
@@ -3748,18 +3811,18 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
   
 	  echo "$ac_t""no" 1>&6
 	  echo $ac_n "checking if gethostbyname_r takes 6 arguments""... $ac_c" 1>&6
-echo "configure:3755: checking if gethostbyname_r takes 6 arguments" >&5
+echo "configure:3818: checking if gethostbyname_r takes 6 arguments" >&5
 	  if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3760 "configure"
+#line 3823 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 
 int
@@ -3770,13 +3833,13 @@
 char buf[8192];
 int rc;
 int h_errno;
 rc = gethostbyname_r(name, &h, buf, 8192, &hp, &h_errno);
 exit (rc != 0 ? 1 : 0); }
 EOF
-if { (eval echo configure:3777: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3840: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
 	    echo "$ac_t""yes" 1>&6
 	    cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_6 1
 EOF
@@ -3814,18 +3877,18 @@
 
 
     
       for ac_func in gethostbyaddr_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3821: checking for $ac_func" >&5
+echo "configure:3884: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3826 "configure"
+#line 3889 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3842,13 +3905,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3849: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3912: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3862,15 +3925,15 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking if gethostbyaddr_r takes 5 arguments""... $ac_c" 1>&6
-echo "configure:3869: checking if gethostbyaddr_r takes 5 arguments" >&5
+echo "configure:3932: checking if gethostbyaddr_r takes 5 arguments" >&5
     cat > conftest.$ac_ext <<EOF
-#line 3871 "configure"
+#line 3934 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
 
@@ -3880,13 +3943,13 @@
 struct hostent h;
 struct hostent_data hdata;
 int rc;
 rc = gethostbyaddr_r(address, length, type, &h, &hdata);
 ; return 0; }
 EOF
-if { (eval echo configure:3887: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3950: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
       echo "$ac_t""yes" 1>&6
       cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_5 1
 EOF
@@ -3896,15 +3959,15 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments""... $ac_c" 1>&6
-echo "configure:3903: checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments" >&5
+echo "configure:3966: checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments" >&5
       cat > conftest.$ac_ext <<EOF
-#line 3905 "configure"
+#line 3968 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
@@ -3915,13 +3978,13 @@
 struct hostent h;
 struct hostent_data hdata;
 int rc;
 rc = gethostbyaddr_r(address, length, type, &h, &hdata);
 ; return 0; }
 EOF
-if { (eval echo configure:3922: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:3985: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
 	echo "$ac_t""yes" 1>&6
 	cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_5 1
 EOF
@@ -3935,15 +3998,15 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   
 	echo "$ac_t""no" 1>&6
 	echo $ac_n "checking if gethostbyaddr_r takes 7 arguments""... $ac_c" 1>&6
-echo "configure:3942: checking if gethostbyaddr_r takes 7 arguments" >&5
+echo "configure:4005: checking if gethostbyaddr_r takes 7 arguments" >&5
 	cat > conftest.$ac_ext <<EOF
-#line 3944 "configure"
+#line 4007 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
 
@@ -3956,13 +4019,13 @@
 struct hostent * hp;
 
 hp = gethostbyaddr_r(address, length, type, &h,
                      buffer, 8192, &h_errnop);
 ; return 0; }
 EOF
-if { (eval echo configure:3963: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4026: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
 	  echo "$ac_t""yes" 1>&6
 	  cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_7 1
 EOF
@@ -3972,15 +4035,15 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   
 	  echo "$ac_t""no" 1>&6
 	  echo $ac_n "checking if gethostbyaddr_r takes 8 arguments""... $ac_c" 1>&6
-echo "configure:3979: checking if gethostbyaddr_r takes 8 arguments" >&5
+echo "configure:4042: checking if gethostbyaddr_r takes 8 arguments" >&5
 	  cat > conftest.$ac_ext <<EOF
-#line 3981 "configure"
+#line 4044 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
 
@@ -3994,13 +4057,13 @@
 int rc;
 
 rc = gethostbyaddr_r(address, length, type, &h,
                      buffer, 8192, &hp, &h_errnop);
 ; return 0; }
 EOF
-if { (eval echo configure:4001: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4064: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
 	    echo "$ac_t""yes" 1>&6
 	    cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_8 1
 EOF
@@ -4031,18 +4094,18 @@
 
 
     
     for ac_func in inet_ntoa_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4038: checking for $ac_func" >&5
+echo "configure:4101: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4043 "configure"
+#line 4106 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4059,13 +4122,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4066: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4129: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4079,15 +4142,15 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking whether inet_ntoa_r is declared""... $ac_c" 1>&6
-echo "configure:4086: checking whether inet_ntoa_r is declared" >&5
+echo "configure:4149: checking whether inet_ntoa_r is declared" >&5
     cat > conftest.$ac_ext <<EOF
-#line 4088 "configure"
+#line 4151 "configure"
 #include "confdefs.h"
 
 #include <arpa/inet.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "inet_ntoa_r" >/dev/null 2>&1; then
@@ -4100,15 +4163,15 @@
       echo "$ac_t""yes" 1>&6
 else
   rm -rf conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking whether inet_ntoa_r with -D_REENTRANT is declared""... $ac_c" 1>&6
-echo "configure:4107: checking whether inet_ntoa_r with -D_REENTRANT is declared" >&5
+echo "configure:4170: checking whether inet_ntoa_r with -D_REENTRANT is declared" >&5
       cat > conftest.$ac_ext <<EOF
-#line 4109 "configure"
+#line 4172 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 #include <arpa/inet.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
@@ -4142,18 +4205,18 @@
 
 
     
     for ac_func in localtime_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4149: checking for $ac_func" >&5
+echo "configure:4212: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4154 "configure"
+#line 4217 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4170,13 +4233,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4177: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4240: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4190,15 +4253,15 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking whether localtime_r is declared""... $ac_c" 1>&6
-echo "configure:4197: checking whether localtime_r is declared" >&5
+echo "configure:4260: checking whether localtime_r is declared" >&5
     cat > conftest.$ac_ext <<EOF
-#line 4199 "configure"
+#line 4262 "configure"
 #include "confdefs.h"
 
 #include <time.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "localtime_r" >/dev/null 2>&1; then
@@ -4207,15 +4270,15 @@
       echo "$ac_t""yes" 1>&6
 else
   rm -rf conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking whether localtime_r with -D_REENTRANT is declared""... $ac_c" 1>&6
-echo "configure:4214: checking whether localtime_r with -D_REENTRANT is declared" >&5
+echo "configure:4277: checking whether localtime_r with -D_REENTRANT is declared" >&5
       cat > conftest.$ac_ext <<EOF
-#line 4216 "configure"
+#line 4279 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 #include <time.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
@@ -4244,26 +4307,26 @@
 
 
 fi
 
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:4251: checking for ANSI C header files" >&5
+echo "configure:4314: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4256 "configure"
+#line 4319 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4264: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4327: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   ac_cv_header_stdc=yes
 else
   echo "$ac_err" >&5
@@ -4274,13 +4337,13 @@
 fi
 rm -f conftest*
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4281 "configure"
+#line 4344 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "memchr" >/dev/null 2>&1; then
   :
@@ -4292,13 +4355,13 @@
 
 fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4299 "configure"
+#line 4362 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "free" >/dev/null 2>&1; then
   :
@@ -4313,24 +4376,24 @@
 if test $ac_cv_header_stdc = yes; then
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
 if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 4320 "configure"
+#line 4383 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
 #define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int main () { int i; for (i = 0; i < 256; i++)
 if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:4331: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4394: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -4377,23 +4440,23 @@
         time.h \
         io.h \
 
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:4384: checking for $ac_hdr" >&5
+echo "configure:4447: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4389 "configure"
+#line 4452 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4394: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4457: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -4416,18 +4479,18 @@
 fi
 done
 
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:4423: checking for working const" >&5
+echo "configure:4486: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4428 "configure"
+#line 4491 "configure"
 #include "confdefs.h"
 
 int main() {
 
 /* Ultrix mips cc rejects this.  */
 typedef int charset[2]; const charset x;
@@ -4470,13 +4533,13 @@
 { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
   const int foo = 10;
 }
 
 ; return 0; }
 EOF
-if { (eval echo configure:4477: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4540: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4491,18 +4554,18 @@
 #define const 
 EOF
 
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:4498: checking for size_t" >&5
+echo "configure:4561: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4503 "configure"
+#line 4566 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -4524,27 +4587,27 @@
 #define size_t unsigned
 EOF
 
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:4531: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:4594: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4536 "configure"
+#line 4599 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
 #include <time.h>
 int main() {
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:4545: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4608: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4563,32 +4626,32 @@
 
 
 # mprintf() checks:
 
 # check for 'long double'
 echo $ac_n "checking size of long double""... $ac_c" 1>&6
-echo "configure:4570: checking size of long double" >&5
+echo "configure:4633: checking size of long double" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_sizeof_long_double=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 4578 "configure"
+#line 4641 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long double));
   exit(0);
 }
 EOF
-if { (eval echo configure:4589: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4652: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_double=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -4603,32 +4666,32 @@
 #define SIZEOF_LONG_DOUBLE $ac_cv_sizeof_long_double
 EOF
 
 
 # check for 'long long'
 echo $ac_n "checking size of long long""... $ac_c" 1>&6
-echo "configure:4610: checking size of long long" >&5
+echo "configure:4673: checking size of long long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_sizeof_long_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4618 "configure"
+#line 4681 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long long));
   exit(0);
 }
 EOF
-if { (eval echo configure:4629: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4692: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -4649,13 +4712,13 @@
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:4656: checking host system type" >&5
+echo "configure:4719: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -4675,18 +4738,18 @@
 cat >> confdefs.h <<EOF
 #define OS "${host}"
 EOF
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:4682: checking return type of signal handlers" >&5
+echo "configure:4745: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4687 "configure"
+#line 4750 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
 #ifdef signal
 #undef signal
 #endif
@@ -4697,13 +4760,13 @@
 #endif
 
 int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:4704: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4767: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4741,18 +4804,18 @@
                 sigaction \
                 signal \
                 getpass_r
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4748: checking for $ac_func" >&5
+echo "configure:4811: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4753 "configure"
+#line 4816 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4769,13 +4832,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4776: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4839: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4796,19 +4859,22 @@
 fi
 done
 
 
 
 if test "$ac_cv_func_select" != "yes"; then
+  { echo "configure: error: Can't work without an existing select() function" 1>&2; exit 1; }
+fi
+if test "$ac_cv_func_socket" != "yes"; then
   { echo "configure: error: Can't work without an existing socket() function" 1>&2; exit 1; }
 fi
 
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4809: checking for $ac_word" >&5
+echo "configure:4875: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   case "$PERL" in
   /*)
   ac_cv_path_PERL="$PERL" # Let the user override the test with a path.
@@ -4841,13 +4907,13 @@
 
 for ac_prog in gnroff nroff
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4848: checking for $ac_word" >&5
+echo "configure:4914: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_NROFF'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   case "$NROFF" in
   /*)
   ac_cv_path_NROFF="$NROFF" # Let the user override the test with a path.
@@ -4883,13 +4949,13 @@
 
 for ac_prog in 'bison -y' byacc
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:4890: checking for $ac_word" >&5
+echo "configure:4956: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$YACC"; then
   ac_cv_prog_YACC="$YACC" # Let the user override the test.
 else
@@ -5018,17 +5084,25 @@
 
 ac_given_srcdir=$srcdir
 ac_given_INSTALL="$INSTALL"
 
 trap 'rm -fr `echo "Makefile \
 	   docs/Makefile \
+           docs/examples/Makefile \
 	   include/Makefile \
 	   include/curl/Makefile \
 	   src/Makefile \
            lib/Makefile \
-           tests/Makefile config.h src/config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+           tests/Makefile \
+           tests/data/Makefile \
+	   packages/Makefile \
+	   packages/Win32/Makefile \
+	   packages/Linux/Makefile \
+	   packages/Linux/RPM/Makefile \
+	   packages/Linux/RPM/curl.spec \
+	   packages/Linux/RPM/curl-ssl.spec  config.h src/config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
 
 # Protect against being on the right side of a sed subst in config.status.
 sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
  s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
@@ -5131,17 +5205,25 @@
 EOF
 
 cat >> $CONFIG_STATUS <<EOF
 
 CONFIG_FILES=\${CONFIG_FILES-"Makefile \
 	   docs/Makefile \
+           docs/examples/Makefile \
 	   include/Makefile \
 	   include/curl/Makefile \
 	   src/Makefile \
            lib/Makefile \
-           tests/Makefile"}
+           tests/Makefile \
+           tests/data/Makefile \
+	   packages/Makefile \
+	   packages/Win32/Makefile \
+	   packages/Linux/Makefile \
+	   packages/Linux/RPM/Makefile \
+	   packages/Linux/RPM/curl.spec \
+	   packages/Linux/RPM/curl-ssl.spec "}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
 for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case "$ac_file" in
   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/configure.in	2001-01-04 18:28:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/configure.in	2001-01-25 20:28:46.000000000 +0800
@@ -1,7 +1,7 @@
-dnl $Id: configure.in,v 1.43 2001/01/04 10:28:47 bagder Exp $
+dnl $Id: configure.in,v 1.49 2001/01/25 12:28:46 bagder Exp $
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT(lib/urldata.h)
 AM_CONFIG_HEADER(config.h src/config.h)
 
 VERSION=`sed -ne 's/^#define LIBCURL_VERSION "\(.*\)"/\1/p' ${srcdir}/include/curl/curl.h`
 AM_INIT_AUTOMAKE(curl,$VERSION)
@@ -234,12 +234,50 @@
 	  [ac_cv_gethostbyname_args=0])],
 	[ac_cv_gethostbyname_args=0])],
       [ac_cv_gethostbyname_args=0])])
 
 ])
 
+dnl **********************************************************************
+dnl Checks for IPv6
+dnl **********************************************************************
+
+AC_MSG_CHECKING([whether to enable ipv6])
+AC_ARG_ENABLE(ipv6,
+[  --enable-ipv6		Enable ipv6 (with ipv4) support
+  --disable-ipv6		Disable ipv6 support],
+[ case "$enableval" in
+  no)
+       AC_MSG_RESULT(no)
+       ipv6=no
+       ;;
+  *)   AC_MSG_RESULT(yes)
+       AC_DEFINE(ENABLE_IPV6)
+       ipv6=yes
+       ;;
+  esac ],
+
+  AC_TRY_RUN([ /* is AF_INET6 available? */
+#include <sys/types.h>
+#include <sys/socket.h>
+main()
+{
+ if (socket(AF_INET6, SOCK_STREAM, 0) < 0)
+   exit(1);
+ else
+   exit(0);
+}
+],
+  AC_MSG_RESULT(yes)
+  AC_DEFINE(ENABLE_IPV6)
+  ipv6=yes,
+  AC_MSG_RESULT(no)
+  ipv6=no,
+  AC_MSG_RESULT(no)
+  ipv6=no
+))
 
 dnl **********************************************************************
 dnl Checks for libraries.
 dnl **********************************************************************
 
 dnl gethostbyname in the nsl lib?
@@ -587,12 +625,15 @@
                 getpass_r
 )
 
 dnl removed 'getpass' check on October 26, 2000
 
 if test "$ac_cv_func_select" != "yes"; then
+  AC_MSG_ERROR(Can't work without an existing select() function)
+fi
+if test "$ac_cv_func_socket" != "yes"; then
   AC_MSG_ERROR(Can't work without an existing socket() function)
 fi
 
 AC_PATH_PROG( PERL, perl, , 
   $PATH:/usr/local/bin/perl:/usr/bin/:/usr/local/bin )
 AC_SUBST(PERL)
@@ -606,15 +647,20 @@
 dnl AC_PATH_PROG( RANLIB, ranlib, /usr/bin/ranlib, 
 dnl   $PATH:/usr/bin/:/usr/local/bin )
 dnl AC_SUBST(RANLIB)
 
 AC_OUTPUT( Makefile \
 	   docs/Makefile \
+           docs/examples/Makefile \
 	   include/Makefile \
 	   include/curl/Makefile \
 	   src/Makefile \
            lib/Makefile \
-           tests/Makefile)
-dnl	   perl/checklinks.pl \
-dnl	   perl/getlinks.pl \
-dnl        perl/formfind.pl \
-dnl	   perl/recursiveftpget.pl  )
+           tests/Makefile \
+           tests/data/Makefile \
+	   packages/Makefile \
+	   packages/Win32/Makefile \
+	   packages/Linux/Makefile \
+	   packages/Linux/RPM/Makefile \
+	   packages/Linux/RPM/curl.spec \
+	   packages/Linux/RPM/curl-ssl.spec )
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/CONTRIBUTE /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/CONTRIBUTE
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/CONTRIBUTE	2001-01-04 20:43:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/CONTRIBUTE	2001-01-19 17:38:11.000000000 +0800
@@ -15,13 +15,13 @@
  When contributing with code, you agree to put your changes and new code under
  the same license curl and libcurl is already using.
 
  If you add a larger piece of code, you can opt to make that file or set of
  files to use a different license as long as they don't enfore any changes to
  the rest of the package and they make sense. Such "separate parts" can not be
- GPL (as we don't want the FPL virus to attack users of libcurl) but they must
+ GPL (as we don't want the GPL virus to attack users of libcurl) but they must
  use "GPL compatible" licenses.
 
 Naming
 
  Try using a non-confusing naming scheme for your new functions and variable
  names. It doesn't necessarily have to mean that you should use the same as in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/curl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/curl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/curl.1	2001-01-04 16:24:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/curl.1	2001-01-24 22:45:06.000000000 +0800
@@ -1,22 +1,23 @@
 .\" You can view this file with:
 .\" nroff -man curl.1
 .\" Written by Daniel Stenberg
 .\"
-.TH curl 1 "4 January 2001" "Curl 7.5.2" "Curl Manual"
+.TH curl 1 "19 January 2001" "Curl 7.6" "Curl Manual"
 .SH NAME
 curl \- get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE, HTTP or
 HTTPS syntax.
 .SH SYNOPSIS
 .B curl [options]
-.I url
+.I [URL...]
 .SH DESCRIPTION
 .B curl
-is a client to get documents/files from servers, using any of the
-supported protocols. The command is designed to work without user
-interaction or any kind of interactivity.
+is a client to get documents/files from or send documents to a server, using
+any of the supported protocols (HTTP, HTTPS, FTP, GOPHER, DICT, TELNET, LDAP
+or FILE). The command is designed to work without user interaction or any kind
+of interactivity.
 
 curl offers a busload of useful tricks like proxy support, user
 authentication, ftp upload, HTTP post, SSL (https:) connections, cookies, file
 transfer resume and more.
 .SH URL
 The URL syntax is protocol dependent. You'll find a detailed description in
@@ -34,12 +35,15 @@
  ftp://ftp.letters.com/file[a-z].txt
 
 It is possible to specify up to 9 sets or series for a URL, but no nesting is
 supported at the moment:
 
  http://www.any.org/archive[1996-1999]/volume[1-4]part{a,b,c,index}.html
+
+Starting with curl 7.6, you can specify any amount of URLs on the command
+line. They will be fetched in a sequential manner in the specified order.
 .SH OPTIONS
 .IP "-a/--append"
 (FTP)
 When used in a ftp upload, this will tell curl to append to the target
 file instead of overwriting it. If the file doesn't exist, it will
 be created.
@@ -117,24 +121,29 @@
 specified.
 
 To post data purely binary, you should instead use the --data-binary option.
 
 -d/--data is the same as --data-ascii.
 
-If this option is used serveral times, the last one will be used.
+If this option is used serveral times, the ones following the first will
+append data.
 .IP "--data-ascii <data>"
 (HTTP) This is an alias for the -d/--data option.
 
-If this option is used serveral times, the last one will be used.
+If this option is used serveral times, the ones following the first will
+append data.
 .IP "--data-binary <data>"
 (HTTP) This posts data in a similar manner as --data-ascii does, although when
 using this option the entire context of the posted data is kept as-is. If you
 want to post a binary file without the strip-newlines feature of the
 --data-ascii option, this is for you.
 
 If this option is used serveral times, the last one will be used.
+
+If this option is used serveral times, the ones following the first will
+append data.
 .IP "-D/--dump-header <file>"
 (HTTP/FTP)
 Write the HTTP headers to this file. Write the FTP file info to this
 file if -I/--head is used.
 
 This option is handy to use when you want to store the cookies that a HTTP
@@ -193,12 +202,18 @@
 -F password=@/etc/passwd www.mypasswords.com
 
 To read the file's content from stdin insted of a file, use - where the file
 name should've been. This goes for both @ and < constructs.
 
 This option can be used multiple times.
+.IP "-g/--globoff"
+This option switches off the "URL globbing parser". When you set this option,
+you can specify URLs that contain the letters {}[] without having them being
+interpreted by curl itself. Note that these letters are not normal legal URL
+contents but they should be encoded according to the URI standard. (Option
+added in curl 7.6)
 .IP "-h/--help"
 Usage help.
 .IP "-H/--header <header>"
 (HTTP) Extra header to use when getting a web page. You may specify any number
 of extra headers. Note that if you should add a custom header that has the
 same name as one of the internal ones curl would use, your externally set
@@ -308,17 +323,18 @@
   curl http://{one,two}.site.com -o "file_#1.txt"
 
 or use several variables like:
 
   curl http://{site,host}.host[1-5].com -o "#1_#2"
 
-If this option is used serveral times, the last one will be used.
+You may use this option as many times as you have number of URLs.
 .IP "-O/--remote-name"
 Write output to a local file named like the remote file we get. (Only
 the file part of the remote file is used, the path is cut off.)
 
+You may use this option as many times as you have number of URLs.
 .IP "-p/--proxytunnel"
 When an HTTP proxy is used, this option will cause non-HTTP protocols to
 attempt to tunnel through the proxy instead of merely using it to do HTTP-like
 operations. The tunnel approach is made with the HTTP proxy CONNECT request
 and requires that the proxy allows direct connect to the remote port number
 curl wants to tunnel through to.
@@ -433,16 +449,20 @@
 .IP "-U/--proxy-user <user:password>"
 Specify user and password to use for Proxy authentication. If no
 password is specified, curl will ask for it interactively.
 
 If this option is used serveral times, the last one will be used.
 .IP "--url <URL>"
-Set the URL to fetch. This option is mostly handy when you wanna specify URL
-in a config file.
+Specify a URL to fetch. This option is mostly handy when you wanna specify
+URL(s) in a config file.
 
-If this option is used serveral times, the last one will be used.
+This option may be used any number of times. To control where this URL is written, use the
+.I -o
+or the
+.I -O
+options.
 .IP "-v/--verbose"
 Makes the fetching more verbose/talkative. Mostly usable for
 debugging. Lines starting with '>' means data sent by curl, '<'
 means data received by curl that is hidden in normal cases and lines
 starting with '*' means additional info provided by curl.
 
@@ -762,12 +782,15 @@
  - Martin Hedenfalk <mhe@stacken.kth.se>
  - Richard Prescott
  - Jason S. Priebe <priebe@wral-tv.com>
  - T. Bharath <TBharath@responsenetworks.com>
  - Alexander Kourakos <awk@users.sourceforge.net>
  - James Griffiths <griffiths_james@yahoo.com>
+ - Loic Dachary <loic@senga.org>
+ - Robert Weaver <robert.weaver@sabre.com>
+ - Ingo Ralf Blum <ingoralfblum@ingoralfblum.com>
 
 .SH WWW
 http://curl.haxx.se
 .SH FTP
 ftp://ftp.sunet.se/pub/www/utilities/curl/
 .SH "SEE ALSO"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/curl_easy_perform.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/curl_easy_perform.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/curl_easy_perform.3	2000-06-20 23:34:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/curl_easy_perform.3	2001-01-25 20:27:12.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_perform 3 "26 May 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_easy_perform 3 "25 Jan 2001" "Curl 7.0" "libcurl Manual"
 .SH NAME
 curl_easy_perform - Do the actual transfer in a "easy" session
 .SH SYNOPSIS
 .B #include <curl/easy.h>
 .sp
 .BI "CURLcode curl_easy_perform(CURL *" handle ");
@@ -13,12 +13,16 @@
 .SH DESCRIPTION
 This function is called after the init and all the curl_easy_setopt() calls
 are made, and will perform the transfer as described in the options.
 It must be called with the same
 .I handle
 as input as the curl_easy_init call returned.
+
+You are only allowed to call this function once using the same handle. If you
+want to do repeated calls, you must call curl_easy_cleanup and curl_easy_init
+again first.
 .SH RETURN VALUE
 0 means everything was ok, non-zero means an error occurred as
 .I <curl/curl.h>
 defines. If the CURLOPT_ERRORBUFFER was set with
 .I curl_easy_setopt
 there willo be a readable error message in the error buffer when non-zero is
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/curl_easy_setopt.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/curl_easy_setopt.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/curl_easy_setopt.3	2000-11-28 16:53:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/curl_easy_setopt.3	2001-01-11 07:20:04.000000000 +0800
@@ -234,13 +234,13 @@
 Pass a long as parameter. It contains the offset in number of bytes that you
 want the transfer to start from.
 .TP
 .B CURLOPT_COOKIE
 Pass a pointer to a zero terminated string as parameter. It will be used to
 set a cookie in the http request. The format of the string should be
-'[NAME]=[CONTENTS];' Where NAME is the cookie name.
+[NAME]=[CONTENTS]; Where NAME is the cookie name.
 .TP
 .B CURLOPT_HTTPHEADER
 Pass a pointer to a linked list of HTTP headers to pass to the server in your
 HTTP request. The linked list should be a fully valid list of 'struct
 curl_slist' structs properly filled in. Use
 .I curl_slist_append(3)
@@ -264,13 +264,13 @@
 .B CURLOPT_SSLCERTPASSWD
 Pass a pointer to a zero terminated string as parameter. It will be used as
 the password required to use the CURLOPT_SSLCERT certificate. If the password
 is not supplied, you will be prompted for it.
 .TP
 .B CURLOPT_CRLF
-TBD.
+Convert unix newlines to CRLF newlines on FTP uploads.
 .TP
 .B CURLOPT_QUOTE
 Pass a pointer to a linked list of FTP commands to pass to the server prior to
 your ftp request. The linked list should be a fully valid list of 'struct
 curl_slist' structs properly filled in. Use
 .I curl_slist_append(3)
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/examples: curlgtk.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/examples: Makefile.am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/examples: Makefile.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/examples: sepheaders.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/examples: simple.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/FAQ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/FAQ
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/FAQ	2001-01-04 20:14:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/FAQ	2001-01-22 16:37:39.000000000 +0800
@@ -1,7 +1,7 @@
-Updated: January 4, 2001 (http://curl.haxx.se/docs/faq.shtml)
+Updated: January 22, 2001 (http://curl.haxx.se/docs/faq.shtml)
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -30,13 +30,13 @@
   3.6 Does curl support javascript, ASP, XML, XHTML or HTML version Y?
   3.7 Can I use curl to delete/rename a file through FTP?
   3.8 How do I tell curl to follow HTTP redirects?
 
  4. Running Problems
   4.1 Problems connecting to SSL servers.
-  4.2 Why do I get problems when I use & in the URL?
+  4.2 Why do I get problems when I use & or % in the URL?
   4.3 How can I use {, }, [ or ] to specify multiple URLs?
   4.4 Why do I get downloaded data even though the web page doesn't exist?
   4.5 Why do I get return code XXX from a HTTP server?
    4.5.1 "400 Bad Request"
    4.5.2 "401 Unauthorized"
    4.5.3 "403 Forbidden"
@@ -45,16 +45,17 @@
   4.6 Can you tell me what error code 142 means?
   4.7 How do I keep usernames and passwords secret in Curl command lines?
   4.8 I found a bug!
   4.9 Curl can't authenticate to the server that requires NTLM?
 
  5. libcurl Issues
-  5.1 Is libcurl thread safe?
+  5.1 Is libcurl thread-safe?
   5.2 How can I receive all data into a large memory chunk?
   5.3 How do I fetch multiple files with libcurl?
   5.4 Does libcurl do Winsock initing on win32 systems?
+  5.5 Does CURLOPT_FILE work on win32 ?
 
  6. License Issues
   6.1 I have a GPL program, can I use the libcurl library?
   6.2 I have a closed-source program, can I use the libcurl library?
   6.3 I have a BSD licensed program, can I use the libcurl library?
   6.4 I have a program that uses LGPL libraries, can I use libcurl?
@@ -70,25 +71,22 @@
   cURL (or simply just 'curl') is a command line tool for getting or sending
   files using URL syntax. The name is a play on 'Client for URLs', originally
   with URL spelled in uppercase to make it obvious it deals with URLs. The
   fact it can also be pronounced 'see URL' also helped.
 
   Curl supports a range of common internet protocols, currently including
-  HTTP, HTTPS, FTP, GOPHER, LDAP, DICT and FILE.
+  HTTP, HTTPS, FTP, GOPHER, LDAP, DICT, TELNET and FILE.
 
-  Please spell it cURL or just curl.
+  We spell it cURL or just curl.
 
   1.2 What is libcurl?
 
-  libcurl is the engine inside curl that does all the work. curl is more or
-  less the command line interface that converts the given options into libcurl
-  function invokes. libcurl is a reliable, higly portable multiprotocol file
-  transfer library.
+  libcurl is a reliable, higly portable multiprotocol file transfer library.
 
   Any application is free to use libcurl, even commercial or closed-source
-  ones. Just make sure changes to the lib itself are made public.
+  ones.
 
   1.3 What is cURL not?
   
   Curl is *not*, I repeat, *not* a wget clone even though that is a very
   common misconception. Never, during curl's development, have I intended curl
   to replace wget or compete on its market. Curl is targeted at single-shot
@@ -295,32 +293,41 @@
   requests properly. To correct this problem, tell curl to select SSLv2 from
   the command line (-2/--sslv2).
 
   I have also seen examples where the remote server didn't like the SSLv2
   request and instead you had to force curl to use SSLv3 with -3/--sslv3.
 
-  4.2. Why do I get problems when I use & in the URL?
+  4.2. Why do I get problems when I use & or % in the URL?
 
   In general unix shells, the & letter is treated special and when used it
   runs the specified command in the background. To safely send the & as a part
   of a URL, you should qoute the entire URL by using single (') or double (")
   quotes around it.
 
   An example that would invoke a remote CGI that uses &-letters could be:
 
      curl 'http://www.altavista.com/cgi-bin/query?text=yes&q=curl'
 
+  In win32, the standard DOS shell treats the %-letter specially and you may
+  need to quote the string properly when % is used in it.
+
   4.3. How can I use {, }, [ or ] to specify multiple URLs?
 
   Because those letters have a special meaning to the shell, and to be used in
   a URL specified to curl you must quote them.
 
   An example that downloads two URLs (sequentially) would do:
 
     curl '{curl,www}.haxx.se'
 
+  To be able to use those letters as actual parts of the URL (without using
+  them for the curl URL "globbing" system), use the -g/--globoff option
+  (included in curl 7.6 and later):
+
+    curl -g 'www.site.com/weirdname[].html'
+
   4.4. Why do I get downloaded data even though the web page doesn't exist?
 
   Curl asks remote servers for the page you specify. If the page doesn't exist
   at the server, the HTTP protocol defines how the server should respond and
   that means that headers and a "page" will be returned. That's simply how
   HTTP works.
@@ -389,31 +396,32 @@
 
   If it is a problem with a binary you've downloaded or a package for your
   particular platform, try contacting the person who built the package/archive
   you have.
 
   If there is a bug, post a bug report in the Curl Bug Track System over at
-  http://sourceforge.net/bugs/?group_id=976 or mail a detailed bug description
-  to curl-bug@haxx.se.
+  http://sourceforge.net/bugs/?group_id=976
 
   Always include as many details you can think of, including curl version,
   operating system name and version and complete instructions how to repeat
   the bug.
 
   4.9. Curl can't authenticate to the server that requires NTLM?
 
   NTLM is a Microsoft proprietary protocol. Unfortunately, curl does not
   currently support that.
 
 5. libcurl Issues
 
-  5.1. Is libcurl thread safe?
+  5.1. Is libcurl thread-safe?
+
+  Yes.
 
-  We have attempted to write the entire code adjusted for multi-threaded
-  programs. If your system has such, curl will attempt to use threadsafe
-  functions instead of non-safe ones.
+  We have written the libcurl code specificly adjusted for multi-threaded
+  programs. libcurl will use thread-safe functions instead of non-safe ones if
+  your system has such.
 
   I am very interested in once and for all getting some kind of report or
   README file from those who have used libcurl in a threaded environment,
   since I haven't and I get this question more and more frequently!
 
   5.2 How can I receive all data into a large memory chunk?
@@ -462,12 +470,21 @@
   On win32 systems, you need to init the winsock stuff manually, libcurl will
   not do that for you. WSAStartup() and WSACleanup() should be used
   accordingly. The reason for this is of course that a single application may
   use several different libraries and parts, and there's no reason for every
   single library to do this.
 
+  5.5 Does CURLOPT_FILE work on win32 ?
+
+  Yes, but you cannot open a FILE * and pass the pointer to a DLL and have
+  that DLL use the FILE *. You must use CURLOPT_WRITEFUNCTION as well to set a
+  function that writes the file, even if that simply writes the data to the
+  specified FILE*.
+
+  (provided by Joel DeYoung)
+
 6. License Issues
 
   NOTE: This section is now updated to concern curl 7.5.2 or later!
 
   Curl and libcurl are released under a MIT/X derivate license *or* the MPL,
   the Mozilla Public License. To get a really good answer to your license
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/INSTALL	2000-11-27 21:38:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/INSTALL	2001-01-16 06:39:26.000000000 +0800
@@ -83,19 +83,34 @@
      make test
 
    KNOWN PROBLEMS
 
      If you happen to have autoconf installed, but a version older than
      2.12 you will get into trouble. Then you can still build curl by
-     issuing these commands: (from Ralph Beckmann <rabe@uni-paderborn.de>)
+     issuing these commands: (from Ralph Beckmann)
 
        ./configure [...]
        cd lib; make; cd ..
        cd src; make; cd ..
        cp src/curl elsewhere/bin/
 
+     As suggested by David West, you can make a faked version of autoconf and
+     autoheader:
+
+       ----start of autoconf----
+       #!/bin/bash
+       #fake autoconf for building curl
+       if [ "$1" = "--version" ] then
+         echo "Autoconf version 2.13"
+       fi
+       ----end of autoconf----
+
+     Then make autoheader a symbolic link to the same script and make sure
+     they're executable and set to appear in the path *BEFORE* the actual (but
+     obsolete) autoconf and autoheader scripts.
+
    OPTIONS
 
      Remember, to force configure to use the standard cc compiler if both
      cc and gcc are present, run configure like
 
        CC=cc ./configure
@@ -151,12 +166,14 @@
       Microsoft command line style
       ----------------------------
         Run the 'vcvars32.bat' file to get the proper environment variables
         set, then run 'nmake -f Makefile.vc6' in the lib/ dir and then
         'nmake -f Makefile.vc6' in the src/ dir.
 
+        The vcvars32.bat file is part of the Microsoft development environment.
+
       IDE-style
       -------------------------
         If you use VC++, Borland or similar compilers. Include all lib source
         files in a static lib "project" (all .c and .h files that is).
         (you should name it libcurl or similar)
 
@@ -196,12 +213,14 @@
       Microsoft command line style
       ----------------------------
         Run the 'vcvars32.bat' file to get the proper environment variables
         set, then run 'nmake -f Makefile.vc6 release-ssl' in the lib/ dir and
         then 'nmake -f Makefile.vc6' in the src/ dir.
 
+        The vcvars32.bat file is part of the Microsoft development environment.
+
       Microsoft / Borland style
       -------------------------
         If you have OpenSSL, and want curl to take advantage of it, edit your
         project properties to use the SSL include path, link with the SSL libs
         and define the USE_SSLEAY symbol.
 
@@ -253,24 +272,26 @@
         - Power AIX 4.2, 4.3.1, 4.3.2
         - PowerPC Darwin 1.0
         - PowerPC Linux
         - PowerPC Mac OS X
         - Sparc Linux
         - Sparc Solaris 2.4, 2.5, 2.5.1, 2.6, 7, 8
-        - Sparc SunOS 4.1.*
+        - Sparc SunOS 4.1.X
         - i386 BeOS
         - i386 FreeBSD
         - i386 Linux 1.3, 2.0, 2.2, 2.3, 2.4
         - i386 NetBSD
         - i386 OS/2
         - i386 OpenBSD
+        - i386 SCO unix
         - i386 Solaris 2.7
-        - i386 Windows 95, 98, NT, 2000
+        - i386 Windows 95, 98, ME, NT, 2000
         - ia64 Linux 2.3.99
         - m68k AmigaOS 3
         - m68k OpenBSD
+        - StrongARM NetBSD 1.4.1
 
 OpenSSL
 =======
 
    You'll find OpenSSL information at:
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/INTERNALS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/INTERNALS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/INTERNALS	2000-11-29 15:04:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/INTERNALS	2001-01-26 16:22:02.000000000 +0800
@@ -1,6 +1,7 @@
+                                     Updated for curl 7.6 on January 26, 2001
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -24,39 +24,46 @@
  should tag the sources with a name similar to the released version number.
 
 Windows vs Unix
 ===============
 
  There are a few differences in how to program curl the unix way compared to
- the Windows way. The four most notable details are:
+ the Windows way. The four perhaps most notable details are:
+
+ 1. Different function names for socket operations.
+
+   In curl, this is solved with defines and macros, so that the source looks
+   the same at all places except for the header file that defines them. The
+   macros in use are sclose(), sread() and swrite().
 
- 1. Different function names for close(), read(), write()
  2. Windows requires a couple of init calls for the socket stuff
+
+   Those must be made by the application that uses libcurl, in curl that means
+   src/main.c has some code #ifdef'ed to do just that.
+
  3. The file descriptors for network communication and file operations are
     not easily interchangable as in unix
+
+   We avoid this by not trying any funny tricks on file descriptors.
+
  4. When writing data to stdout, Windows makes end-of-lines the DOS way, thus
     destroying binary data, although you do want that conversion if it is
     text coming through... (sigh)
 
- In curl, (1) is made with defines and macros, so that the source looks the
- same at all places except for the header file that defines them.
-
- (2) must be made by the application that uses libcurl, in curl that means
- src/main.c has some code #ifdef'ed to do just that.
-
- (3) is simply avoided by not trying any funny tricks on file descriptors.
-
- (4) we set stdout to binary under windows
+   We set stdout to binary under windows
 
  Inside the source code, I do make an effort to avoid '#ifdef WIN32'. All
  conditionals that deal with features *should* instead be in the format
  '#ifdef HAVE_THAT_WEIRD_FUNCTION'. Since Windows can't run configure scripts,
  I maintain two config-win32.h files (one in / and one in src/) that are
  supposed to look exactly as a config.h file would have looked like on a
  Windows machine!
 
+ Generally speaking: always remember that this will be compiled on dozens of
+ operating systems. Don't walk on the edge.
+
 Library
 =======
 
  As described elsewhere, libcurl is meant to get two different "layers" of
  interfaces. At the present point only the high-level, the "easy", interface
  has been fully implemented and documented. We assume the easy-interface in
@@ -65,65 +72,79 @@
 
  There are plenty of entry points to the library, namely each publicly defined
  function that libcurl offers to applications. All of those functions are
  rather small and easy-to-follow. All the ones prefixed with 'curl_easy' are
  put in the lib/easy.c file.
 
+ All printf()-style functions use the supplied clones in lib/mprintf.c. This
+ makes sure we stay absolutely platform independent.
+
  curl_easy_init() allocates an internal struct and makes some initializations.
  The returned handle does not revail internals.
 
  curl_easy_setopt() takes a three arguments, where the option stuff must be
  passed in pairs, the parameter-ID and the parameter-value. The list of
  options is documented in the man page.
 
  curl_easy_perform() does a whole lot of things:
 
- The function analyzes the URL, get the different components and connects to
- the remote host. This may involve using a proxy and/or using SSL. The
- GetHost() function in lib/hostip.c is used for looking up host names.
-
- When connected, the proper function is called. The functions are named after
- the protocols they handle. ftp(), http(), dict(), etc. They all reside in
- their respective files (ftp.c, http.c and dict.c).
-
- The protocol-specific functions deal with protocol-specific negotiations and
- setup. They have access to the sendf() (from lib/sendf.c) function to send
- printf-style formatted data to the remote host and when they're ready to make
- the actual file transfer they call the Transfer() function (in
- lib/download.c) to do the transfer. All printf()-style functions use the
- supplied clones in lib/mprintf.c.
+ It starts off in the lib/easy.c file by calling curl_transfer(), but the main
+ work is lib/url.c. The function first analyzes the URL, it separates the
+ different components and connects to the remote host. This may involve using
+ a proxy and/or using SSL. The Curl_gethost() function in lib/hostip.c is used
+ for looking up host names.
+
+ When connected, the proper protocol-specific function is called. The
+ functions are named after the protocols they handle. Curl_ftp(), Curl_http(),
+ Curl_dict(), etc. They all reside in their respective files (ftp.c, http.c
+ and dict.c).
+
+ The protocol-specific functions of course deal with protocol-specific
+ negotiations and setup. They have access to the Curl_sendf() (from
+ lib/sendf.c) function to send printf-style formatted data to the remote host
+ and when they're ready to make the actual file transfer they call the
+ Curl_Transfer() function (in lib/transfer.c) to setup the transfer and
+ returns. curl_transfer() then calls _Tranfer() in lib/transfer.c that
+ performs the entire file transfer.
 
- While transfering, the progress functions in lib/progress.c are called at a
+ During transfer, the progress functions in lib/progress.c are called at a
  frequent interval (or at the user's choice, a specified callback might get
  called). The speedcheck functions in lib/speedcheck.c are also used to verify
  that the transfer is as fast as required.
 
- When completed curl_easy_cleanup() should be called to free up used
+ When completed, the curl_easy_cleanup() should be called to free up used
  resources.
 
  HTTP(S)
 
  HTTP offers a lot and is the protocol in curl that uses the most lines of
  code. There is a special file (lib/formdata.c) that offers all the multipart
  post functions.
 
- base64-functions for user+password stuff is in (lib/base64.c) and all
- functions for parsing and sending cookies are found in
- (lib/cookie.c).
+ base64-functions for user+password stuff (and more) is in (lib/base64.c) and
+ all functions for parsing and sending cookies are found in (lib/cookie.c).
 
  HTTPS uses in almost every means the same procedure as HTTP, with only two
  exceptions: the connect procedure is different and the function used to read
  or write from the socket is different, although the latter fact is hidden in
  the source by the use of curl_read() for reading and curl_write() for writing
  data to the remote server.
 
  FTP
 
- The if2ip() function can be used for getting the IP number of a specified
- network interface, and it resides in lib/if2ip.c. It is only used for the FTP
- PORT command.
+ The Curl_if2ip() function can be used for getting the IP number of a
+ specified network interface, and it resides in lib/if2ip.c.
+
+ Curl_ftpsendf() is used for sending FTP commands to the remote server. It was
+ made a separate function to prevent us programmers from forgetting that they
+ must be CRLF terminated. They must also be sent in one single write() to make
+ firewalls and similar happy.
+
+ Kerberos
+
+ The kerberos support is mainly in lib/krb4.c and lib/security.c.
 
  TELNET
 
  Telnet is implemented in lib/telnet.c.
 
  FILE
@@ -136,53 +157,118 @@
 
  GENERAL
 
  URL encoding and decoding, called escaping and unescaping in the source code,
  is found in lib/escape.c.
 
- While transfering data in Transfer() a few functions might get
+ While transfering data in _Transfer() a few functions might get
  used. curl_getdate() in lib/getdate.c is for HTTP date comparisons (and
  more).
 
  lib/getenv.c offers curl_getenv() which is for reading environment variables
  in a neat platform independent way. That's used in the client, but also in
- lib/url.c when checking the proxy environment variables.
+ lib/url.c when checking the proxy environment variables. Note that contrary
+ to the normal unix getenv(), this returns an allocated buffer that must be
+ free()ed after use.
 
  lib/netrc.c holds the .netrc parser
 
  lib/timeval.c features replacement functions for systems that don't have
- gettimeofday().
+ gettimeofday() and a few support functions for timeval convertions.
  
  A function named curl_version() that returns the full curl version string is
  found in lib/version.c.
 
+ If authentication is requested but no password is given, a getpass_r() clone
+ exists in lib/getpass.c. libcurl offers a custom callback that can be used
+ instead of this, but it doesn't change much to us.
+
+Library Symbols
+===============
+ 
+ All symbols used internally in libcurl must use a 'Curl_' prefix if they're
+ used in more than a single file. Single-file symbols must be made
+ static. Public (exported) symbols must use a 'curl_' prefix. (There are
+ exceptions, but they are destined to be changed to follow this pattern in the
+ future.)
+
+Return Codes and Informationals
+===============================
+
+ I've made things simple. Almost every function in libcurl returns a CURLcode,
+ that must be CURLE_OK if everything is OK or otherwise a suitable error code
+ as the curl/curl.h include file defines. The very spot that detects an error
+ must use the Curl_failf() function to set the human-readable error
+ description.
+
+ In aiding the user to understand what's happening and to debug curl usage, we
+ must supply a fair amount of informational messages by using the Curl_infof()
+ function. Those messages are only displayed when the user explicitly asks for
+ them. They are best used when revealing information that isn't otherwise
+ obvious.
+
 Client
 ======
 
  main() resides in src/main.c together with most of the client code.
  src/hugehelp.c is automatically generated by the mkhelp.pl perl script to
  display the complete "manual" and the src/urlglob.c file holds the functions
- used for the multiple-URL support.
+ used for the URL-"globbing" support. Globbing in the sense that the {} and []
+ expansion stuff is there.
 
- The client mostly mess around to setup its config struct properly, then it
- calls the curl_easy_*() functions of the library and when it gets back
+ The client mostly messes around to setup its 'config' struct properly, then
+ it calls the curl_easy_*() functions of the library and when it gets back
  control after the curl_easy_perform() it cleans up the library, checks status
  and exits.
 
  When the operation is done, the ourWriteOut() function in src/writeout.c may
  be called to report about the operation. That function is using the
  curl_easy_getinfo() function to extract useful information from the curl
  session.
 
+ Recent versions may loop and do all that several times if many URLs were
+ specified on the command line or config file.
+
+Memory Debugging
+================
+
+ The file named lib/memdebug.c contains debug-versions of a few
+ functions. Functions such as malloc, free, fopen, fclose, etc that somehow
+ deal with resources that might give us problems if we "leak" them. The
+ functions in the memdebug system do nothing fancy, they do their normal
+ function and then log information about what they just did. The logged data
+ is then analyzed after a complete session,
+
+ memanalyze.pl is a perl script present only in CVS (not part of the release
+ archives) that analyzes a log file generated by the memdebug system. It
+ detects if resources are allocated but never freed and other kinds of errors
+ related to resource management.
+
+ Use -DMALLOCDEBUG when compiling to enable memory debugging.
+
 Test Suite
 ==========
 
- During November 2000, a test suite has evolved. It is placed in its own
+ Since November 2000, a test suite has evolved. It is placed in its own
  subdirectory directly off the root in the curl archive tree, and it contains
  a bunch of scripts and a lot of test case data.
 
  The main test script is runtests.pl that will invoke the two servers
  httpserver.pl and ftpserver.pl before all the test cases are performed. The
  test suite currently only runs on unix-like platforms.
 
  You'll find a complete description of the test case data files in the README
  file in the test directory.
+
+ The test suite automatically detects if curl was built with the memory
+ debugging enabled, and if it was it will detect memory leaks too.
+
+Building Releases
+=================
+
+ There's no magic to this. When you consider everything stable enough to be
+ released, run the 'maketgz' script (using 'make distcheck' will give you a
+ pretty good view on the status of the current sources). maketgz prompts for
+ version number of the client and the library before it creates a release
+ archive.
+
+ You must have autoconf installed to build release archives.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/Makefile.am	2000-10-02 14:49:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/Makefile.am	2001-01-08 21:39:21.000000000 +0800
@@ -1,22 +1,26 @@
 #
-# $Id: Makefile.am,v 1.2 2000/10/02 06:49:51 bagder Exp $
+# $Id: Makefile.am,v 1.4 2001/01/08 13:39:21 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 man_MANS = \
 	curl.1 \
 	curl_easy_cleanup.3 \
 	curl_easy_getinfo.3 \
 	curl_easy_init.3 \
 	curl_easy_perform.3 \
 	curl_easy_setopt.3 \
 	curl_formparse.3 \
+	curl_formfree.3 \
 	curl_getdate.3 \
 	curl_getenv.3 \
 	curl_slist_append.3 \
 	curl_slist_free_all.3 \
 	curl_version.3
 
-EXTRA_DIST = $(man_MANS)
+EXTRA_DIST = $(man_MANS) \
+	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS \
+	LIBCURL README.win32 RESOURCES TODO TheArtOfHttpScripting
 
+SUBDIRS = examples
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/Makefile.in	2001-01-04 21:57:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/Makefile.in	2001-01-27 23:41:57.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.2 2000/10/02 06:49:51 bagder Exp $
+# $Id: Makefile.am,v 1.4 2001/01/08 13:39:21 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -76,16 +76,19 @@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-man_MANS =  	curl.1 	curl_easy_cleanup.3 	curl_easy_getinfo.3 	curl_easy_init.3 	curl_easy_perform.3 	curl_easy_setopt.3 	curl_formparse.3 	curl_getdate.3 	curl_getenv.3 	curl_slist_append.3 	curl_slist_free_all.3 	curl_version.3
+man_MANS =  	curl.1 	curl_easy_cleanup.3 	curl_easy_getinfo.3 	curl_easy_init.3 	curl_easy_perform.3 	curl_easy_setopt.3 	curl_formparse.3 	curl_formfree.3 	curl_getdate.3 	curl_getenv.3 	curl_slist_append.3 	curl_slist_free_all.3 	curl_version.3
 
 
-EXTRA_DIST = $(man_MANS)
+EXTRA_DIST = $(man_MANS) 	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS 	LIBCURL README.win32 RESOURCES TODO TheArtOfHttpScripting
+
+
+SUBDIRS = examples
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h ../src/config.h
 CONFIG_CLEAN_FILES = 
 man1dir = $(mandir)/man1
 man3dir = $(mandir)/man3
 MANS = $(man_MANS)
@@ -174,15 +177,101 @@
 install-man: $(MANS)
 	@$(NORMAL_INSTALL)
 	$(MAKE) $(AM_MAKEFLAGS) install-man1 install-man3
 uninstall-man:
 	@$(NORMAL_UNINSTALL)
 	$(MAKE) $(AM_MAKEFLAGS) uninstall-man1 uninstall-man3
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+
+@SET_MAKE@
+
+all-recursive install-data-recursive install-exec-recursive \
+installdirs-recursive install-recursive uninstall-recursive  \
+check-recursive installcheck-recursive info-recursive dvi-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
+	  rev="$$subdir $$rev"; \
+	  test "$$subdir" = "." && dot_seen=yes; \
+	done; \
+	test "$$dot_seen" = "no" && rev=". $$rev"; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+
 tags: TAGS
-TAGS:
 
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $$unique $(LISP)
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+   if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+   fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
 
 distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
 
 subdir = docs
 
 distdir: $(DISTFILES)
@@ -193,73 +282,91 @@
 	  else \
 	    test -f $(distdir)/$$file \
 	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
 	    || cp -p $$d/$$file $(distdir)/$$file || :; \
 	  fi; \
 	done
+	for subdir in $(SUBDIRS); do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    chmod 777 $(distdir)/$$subdir; \
+	    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(top_distdir) distdir=../$(distdir)/$$subdir distdir) \
+	      || exit 1; \
+	  fi; \
+	done
 info-am:
-info: info-am
+info: info-recursive
 dvi-am:
-dvi: dvi-am
+dvi: dvi-recursive
 check-am: all-am
-check: check-am
+check: check-recursive
 installcheck-am:
-installcheck: installcheck-am
+installcheck: installcheck-recursive
 install-exec-am:
-install-exec: install-exec-am
+install-exec: install-exec-recursive
 
 install-data-am: install-man
-install-data: install-data-am
+install-data: install-data-recursive
 
 install-am: all-am
 	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-install: install-am
+install: install-recursive
 uninstall-am: uninstall-man
-uninstall: uninstall-am
+uninstall: uninstall-recursive
 all-am: Makefile $(MANS)
-all-redirect: all-am
+all-redirect: all-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
-installdirs:
+installdirs: installdirs-recursive
+installdirs-am:
 	$(mkinstalldirs)  $(DESTDIR)$(mandir)/man1 $(DESTDIR)$(mandir)/man3
 
 
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
 	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
 
 maintainer-clean-generic:
-mostlyclean-am:  mostlyclean-generic
+mostlyclean-am:  mostlyclean-tags mostlyclean-generic
 
-mostlyclean: mostlyclean-am
+mostlyclean: mostlyclean-recursive
 
-clean-am:  clean-generic mostlyclean-am
+clean-am:  clean-tags clean-generic mostlyclean-am
 
-clean: clean-am
+clean: clean-recursive
 
-distclean-am:  distclean-generic clean-am
+distclean-am:  distclean-tags distclean-generic clean-am
 	-rm -f libtool
 
-distclean: distclean-am
+distclean: distclean-recursive
 
-maintainer-clean-am:  maintainer-clean-generic distclean-am
+maintainer-clean-am:  maintainer-clean-tags maintainer-clean-generic \
+		distclean-am
 	@echo "This command is intended for maintainers to use;"
 	@echo "it deletes files that may require special tools to rebuild."
 
-maintainer-clean: maintainer-clean-am
+maintainer-clean: maintainer-clean-recursive
 
 .PHONY: install-man1 uninstall-man1 install-man3 uninstall-man3 \
-install-man uninstall-man tags distdir info-am info dvi-am dvi check \
-check-am installcheck-am installcheck install-exec-am install-exec \
-install-data-am install-data install-am install uninstall-am uninstall \
-all-redirect all-am all installdirs mostlyclean-generic \
-distclean-generic clean-generic maintainer-clean-generic clean \
-mostlyclean distclean maintainer-clean
+install-man uninstall-man install-data-recursive \
+uninstall-data-recursive install-exec-recursive \
+uninstall-exec-recursive installdirs-recursive uninstalldirs-recursive \
+all-recursive check-recursive installcheck-recursive info-recursive \
+dvi-recursive mostlyclean-recursive distclean-recursive clean-recursive \
+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
+distclean-tags clean-tags maintainer-clean-tags distdir info-am info \
+dvi-am dvi check check-am installcheck-am installcheck install-exec-am \
+install-exec install-data-am install-data install-am install \
+uninstall-am uninstall all-redirect all-am all installdirs-am \
+installdirs mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
 
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/RESOURCES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/RESOURCES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/RESOURCES	2000-12-16 18:24:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/RESOURCES	2001-01-15 20:11:54.000000000 +0800
@@ -97,13 +97,19 @@
   snarf   - http://www.xach.com/snarf/
 
   lynx    - http://lynx.browser.org/ (well at least when -dump is used)
 
   swebget - http://www.uni-hildesheim.de/~smol0075/swebget/
 
-  Kermit  - http://www.columbia.edu/kermit/ftpclient/
+  Kermit  - http://www.columbia.edu/kermit/ftpclient
+
+  Pavuk   - http://www.idata.sk/~ondrej/pavuk/
+
+  httpr   - http://zwolak.dhs.org/httpr/
+
+  puf     - http://www.inf.tu-dresden.de/~ob6/sw/puf.html
 
 Related Software
 ----------------
   ftpparse - http://cr.yp.to/ftpparse.html parses FTP LIST responses
 
   autoconf - http://www.gnu.org/software/autoconf/autoconf.html
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/docs/TODO	2000-12-19 22:38:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/docs/TODO	2001-01-11 07:45:51.000000000 +0800
@@ -13,43 +13,36 @@
  product! (Yes, you may add things not mentioned here, these are just a
  few teasers...)
 
  * Make SSL session ids get used if multiple HTTPS documents from the same
    host is requested.
 
- * Improve the command line option parser to accept '-m300' as well as the '-m
-   300' convention. It should be able to work if '-m300' is considered to be
-   space separated to the next option.
-
  * Make the curl tool support URLs that start with @ that would then mean that
    the following is a plain list with URLs to download. Thus @filename.txt
    reads a list of URLs from a local file. A fancy option would then be to
    support @http://whatever.com that would first load a list and then get the
    URLs mentioned in the list. I figure -O or something would have to be
    implied by such an action.
 
- * Make curl with multiple URLs, even outside of {}-letters. I could also
-   imagine an optional fork()ed system that downloads each URL in its own
-   thread. It should of course have a maximum amount of simultaneous fork()s.
-
  * Improve the regular progress meter with --continue is used. It should be
    noticable when there's a resume going on.
 
  * Add a command line option that allows the output file to get the same time
-   stamp as the remote file. This requires some fiddling on FTP but comes
-   almost free for HTTP.
+   stamp as the remote file. We already are capable of fetching the remote
+   file's date.
 
  * Make the SSL layer option capable of using the Mozilla Security Services as
    an alternative to OpenSSL:
    http://www.mozilla.org/projects/security/pki/nss/
 
  * Make sure the low-level interface works. highlevel.c should basically be
    possible to write using that interface. Document the low-level interface
 
  * Make the easy-interface support multiple file transfers. If they're done
    to the same host, they should use persistant connections or similar.
+   Figure out a nice design for this.
 
  * Add asynchronous name resolving, as this enables full timeout support for
    fork() systems.
 
  * Move non-URL related functions that are used by both the lib and the curl
    application to a separate "portability lib".
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2: FILES
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/include/curl/curl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/include/curl/curl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/include/curl/curl.h	2001-01-04 21:57:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/include/curl/curl.h	2001-01-27 23:39:48.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curl.h,v 1.39 2001/01/03 09:29:34 bagder Exp $
+ * $Id: curl.h,v 1.46 2001/01/25 13:48:28 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 /* The include stuff here is mainly for time_t! */
 #ifdef vms
 # include <types.h>
@@ -163,16 +163,12 @@
 
 /* This is just to make older programs not break: */
 #define CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE
 
 #define CURL_ERROR_SIZE 256
 
-/* maximum URL length we deal with in headers */
-#define URL_MAX_LENGTH 4096 
-#define URL_MAX_LENGTH_TXT "4095"
-
 /* name is uppercase CURLOPT_<name>,
    type is one of the defined CURLOPTTYPE_<type>
    number is unique identifier */
 #ifdef CINIT
 #undef CINIT
 #endif
@@ -432,14 +428,16 @@
    they are used by the 'curl' client. They really should be moved to some kind
    of "portability library" since it has nothing to do with file transfers and
    might be usable to other programs...
 
    NOTE: they return TRUE if the strings match *case insensitively*.
  */
-extern int (strequal)(const char *s1, const char *s2);
-extern int (strnequal)(const char *s1, const char *s2, size_t n);
+extern int (Curl_strequal)(const char *s1, const char *s2);
+extern int (Curl_strnequal)(const char *s1, const char *s2, size_t n);
+#define strequal(a,b) Curl_strequal(a,b)
+#define strnequal(a,b,c) Curl_strnequal(a,b,c)
 
 /* external form function */
 int curl_formparse(char *string,
                    struct HttpPost **httppost,
                    struct HttpPost **last_post);
 
@@ -451,14 +449,14 @@
 char *curl_getenv(char *variable);
 
 /* Returns a static ascii string of the libcurl version. */
 char *curl_version(void);
 
 /* This is the version number */
-#define LIBCURL_VERSION "7.5.2"
-#define LIBCURL_VERSION_NUM 0x070502
+#define LIBCURL_VERSION "7.6"
+#define LIBCURL_VERSION_NUM 0x070600
 
 /* linked-list structure for the CURLOPT_QUOTE option (and other) */
 struct curl_slist {
 	char			*data;
 	struct curl_slist	*next;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/include/curl/mprintf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/include/curl/mprintf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/include/curl/mprintf.h	2001-01-04 20:27:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/include/curl/mprintf.h	2001-01-05 20:19:43.000000000 +0800
@@ -1,9 +1,9 @@
 /*************************************************************************
  *
- * $Id: mprintf.h,v 1.3 2001/01/04 12:27:05 bagder Exp $
+ * $Id: mprintf.h,v 1.5 2001/01/05 12:19:43 bagder Exp $
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
  *
  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
@@ -52,29 +52,31 @@
 
 #ifndef H_MPRINTF
 #define H_MPRINTF
 
 #include <stdarg.h>
 
-int mprintf(const char *format, ...);
-int mfprintf(FILE *fd, const char *format, ...);
-int msprintf(char *buffer, const char *format, ...);
-int msnprintf(char *buffer, size_t maxlength, const char *format, ...);
-int mvprintf(const char *format, va_list args);
-int mvfprintf(FILE *fd, const char *format, va_list args);
-int mvsprintf(char *buffer, const char *format, va_list args);
-int mvsnprintf(char *buffer, size_t maxlength, const char *format, va_list args);
-char *maprintf(const char *format, ...);
-char *mvaprintf(const char *format, va_list args);
+int curl_mprintf(const char *format, ...);
+int curl_mfprintf(FILE *fd, const char *format, ...);
+int curl_msprintf(char *buffer, const char *format, ...);
+int curl_msnprintf(char *buffer, size_t maxlength, const char *format, ...);
+int curl_mvprintf(const char *format, va_list args);
+int curl_mvfprintf(FILE *fd, const char *format, va_list args);
+int curl_mvsprintf(char *buffer, const char *format, va_list args);
+int curl_mvsnprintf(char *buffer, size_t maxlength, const char *format, va_list args);
+char *curl_maprintf(const char *format, ...);
+char *curl_mvaprintf(const char *format, va_list args);
 
 #ifdef _MPRINTF_REPLACE
-# define printf mprintf
-# define fprintf mfprintf
-# define sprintf msprintf
-# define snprintf msnprintf
-# define vprintf mvprintf
-# define vfprintf mvfprintf
-# define vsprintf mvsprintf
-# define vsnprintf mvsnprintf
+# define printf curl_mprintf
+# define fprintf curl_mfprintf
+# define sprintf curl_msprintf
+# define snprintf curl_msnprintf
+# define vprintf curl_mvprintf
+# define vfprintf curl_mvfprintf
+# define vsprintf curl_mvsprintf
+# define vsnprintf curl_mvsnprintf
+# define aprintf curl_maprintf
+# define vaprintf curl_mvaprintf
 #endif
 
 #endif /* H_MPRINTF */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/arpa_telnet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/arpa_telnet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/arpa_telnet.h	2000-05-22 22:12:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/arpa_telnet.h	2001-01-05 17:34:21.000000000 +0800
@@ -60,12 +60,13 @@
 #define	SUSP	237		/* Suspend process */
 #define	xEOF	236		/* End of file: EOF is already used... */
 
 #define SYNCH	242		/* for telfunc calls */
 
 #ifdef TELCMDS
+static
 char *telcmds[] = {
 	"EOF", "SUSP", "ABORT", "EOR",
 	"SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC",
 	"EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC", 0,
 };
 #else
@@ -121,12 +122,13 @@
 #define TELOPT_NEW_ENVIRON 39	/* New - Environment variables */
 #define	TELOPT_EXOPL	255	/* extended-options-list */
 
 
 #define	NTELOPTS	(1+TELOPT_NEW_ENVIRON)
 #ifdef TELOPTS
+static
 char *telopts[NTELOPTS+1] = {
 	"BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
 	"STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
 	"NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
 	"NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
 	"DATA ENTRY TERMINAL", "SUPDUP", "SUPDUP OUTPUT",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/base64.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/base64.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/base64.c	2000-10-09 16:47:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/base64.c	2001-01-05 15:49:05.000000000 +0800
@@ -52,13 +52,13 @@
     if(*p == c)
       return p - base64;
   return -1;
 }
 
 #if 1
-int base64_encode(const void *data, int size, char **str)
+int Curl_base64_encode(const void *data, int size, char **str)
 {
   char *s, *p;
   int i;
   int c;
   const unsigned char *q;
 
@@ -90,13 +90,13 @@
   *p=0;
   *str = s;
   return strlen(s);
 }
 #endif
 
-int base64_decode(const char *str, void *data)
+int Curl_base64_decode(const char *str, void *data)
 {
   const char *p;
   unsigned char *q;
   int c;
   int x;
   int done = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/base64.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/base64.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/base64.h	2000-09-28 15:18:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/base64.h	2001-01-05 15:59:55.000000000 +0800
@@ -31,9 +31,10 @@
  * SUCH DAMAGE.
  */
 
 #ifndef __BASE64_H
 #define __BASE64_H
 
-int base64_encode(const void *data, int size, char **str);
+int Curl_base64_encode(const void *data, int size, char **str);
+int Curl_base64_decode(const char *str, void *data);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/cookie.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/cookie.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/cookie.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/cookie.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: cookie.c,v 1.9 2001/01/03 09:29:34 bagder Exp $
+ * $Id: cookie.c,v 1.10 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 /***
 
 
 RECEIVING COOKIE INFORMATION
@@ -97,15 +97,16 @@
  * cookie_add()
  *
  * Add a single cookie line to the cookie keeping object.
  *
  ***************************************************************************/
 
-struct Cookie *cookie_add(struct CookieInfo *c,
-                          bool httpheader, /* TRUE if HTTP header-style line */
-                          char *lineptr) /* first non-space of the line */
+struct Cookie *
+Curl_cookie_add(struct CookieInfo *c,
+                bool httpheader, /* TRUE if HTTP header-style line */
+                char *lineptr) /* first non-space of the line */
 {
   struct Cookie *clist;
   char what[MAX_COOKIE_LINE];
   char name[MAX_NAME];
   char *ptr;
   char *semiptr;
@@ -344,13 +345,13 @@
  * cookie_init()
  *
  * Inits a cookie struct to read data from a local file. This is always
  * called before any cookies are set. File may be NULL.
  *
  ****************************************************************************/
-struct CookieInfo *cookie_init(char *file)
+struct CookieInfo *Curl_cookie_init(char *file)
 {
   char line[MAX_COOKIE_LINE];
   struct CookieInfo *c;
   FILE *fp;
   bool fromfile=TRUE;
   
@@ -372,21 +373,21 @@
       if(strnequal("Set-Cookie:", line, 11)) {
         /* This is a cookie line, get it! */
         char *lineptr=&line[11];
         while(*lineptr && isspace((int)*lineptr))
           lineptr++;
 
-        cookie_add(c, TRUE, lineptr);
+        Curl_cookie_add(c, TRUE, lineptr);
       }
       else {
         /* This might be a netscape cookie-file line, get it! */
         char *lineptr=line;
         while(*lineptr && isspace((int)*lineptr))
           lineptr++;
 
-        cookie_add(c, FALSE, lineptr);
+        Curl_cookie_add(c, FALSE, lineptr);
       }
     }
     if(fromfile)
       fclose(fp);
   }
 
@@ -402,14 +403,14 @@
  * the cookie if a secure connection is achieved or not.
  *
  * It shall only return cookies that haven't expired.
  *
  ****************************************************************************/
 
-struct Cookie *cookie_getlist(struct CookieInfo *c,
-			      char *host, char *path, bool secure)
+struct Cookie *Curl_cookie_getlist(struct CookieInfo *c,
+                                   char *host, char *path, bool secure)
 {
    struct Cookie *newco;
    struct Cookie *co;
    time_t now = time(NULL);
    int hostlen=strlen(host);
    int domlen;
@@ -470,13 +471,13 @@
  * cookie_freelist()
  *
  * Free a list previously returned by cookie_getlist();
  *
  ****************************************************************************/
 
-void cookie_freelist(struct Cookie *co)
+void Curl_cookie_freelist(struct Cookie *co)
 {
    struct Cookie *next;
    if(co) {
       while(co) {
 	 next = co->next;
 	 free(co); /* we only free the struct since the "members" are all
@@ -490,13 +491,13 @@
  *
  * cookie_cleanup()
  *
  * Free a "cookie object" previous created with cookie_init().
  *
  ****************************************************************************/
-void cookie_cleanup(struct CookieInfo *c)
+void Curl_cookie_cleanup(struct CookieInfo *c)
 {
    struct Cookie *co;
    struct Cookie *next;
    if(c) {
       if(c->filename)
 	 free(c->filename);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/cookie.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/cookie.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/cookie.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/cookie.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: cookie.h,v 1.3 2001/01/03 09:29:34 bagder Exp $
+ * $Id: cookie.h,v 1.4 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #ifdef WIN32
 #include <time.h>
 #else
@@ -60,13 +60,13 @@
 #define MAX_COOKIE_LINE_TXT "2047"
 
 /* This is the maximum length of a cookie name we deal with: */
 #define MAX_NAME 256
 #define MAX_NAME_TXT "255"
 
-struct Cookie *cookie_add(struct CookieInfo *, bool, char *);
-struct CookieInfo *cookie_init(char *);
-struct Cookie *cookie_getlist(struct CookieInfo *, char *, char *, bool);
-void cookie_freelist(struct Cookie *);
-void cookie_cleanup(struct CookieInfo *);
+struct Cookie *Curl_cookie_add(struct CookieInfo *, bool, char *);
+struct CookieInfo *Curl_cookie_init(char *);
+struct Cookie *Curl_cookie_getlist(struct CookieInfo *, char *, char *, bool);
+void Curl_cookie_freelist(struct Cookie *);
+void Curl_cookie_cleanup(struct CookieInfo *);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/dict.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/dict.c	2001-01-25 20:13:35.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: dict.c,v 1.9 2001/01/03 09:29:34 bagder Exp $
+ * $Id: dict.c,v 1.12 2001/01/25 12:13:35 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -68,27 +68,27 @@
 
 
 #endif
 
 #include "urldata.h"
 #include <curl/curl.h>
-#include "download.h"
+#include "transfer.h"
 #include "sendf.h"
 
 #include "progress.h"
 #include "strequal.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
-CURLcode dict_done(struct connectdata *conn)
+CURLcode Curl_dict_done(struct connectdata *conn)
 {
   return CURLE_OK;
 }
 
-CURLcode dict(struct connectdata *conn)
+CURLcode Curl_dict(struct connectdata *conn)
 {
   int nth;
   char *word;
   char *ppath;
   char *database = NULL;
   char *strategy = NULL;
@@ -138,27 +138,27 @@
       nth = 0;
     }
     else {
       nth = atoi(nthdef);
     }
       
-    sendf(data->firstsocket, data,
-          "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
-          "MATCH "
-          "%s "    /* database */
-          "%s "    /* strategy */
-          "%s\n"   /* word */
-          "QUIT\n",
+    Curl_sendf(data->firstsocket, conn,
+               "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
+               "MATCH "
+               "%s "    /* database */
+               "%s "    /* strategy */
+               "%s\n"   /* word */
+               "QUIT\n",
 	    
-          database,
-          strategy,
-          word
-          );
+               database,
+               strategy,
+               word
+               );
     
-    result = Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
-                      -1, NULL); /* no upload */
+    result = Curl_Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
+                           -1, NULL); /* no upload */
       
     if(result)
       return result;
     
   }
   else if (strnequal(path, DICT_DEFINE, sizeof(DICT_DEFINE)-1) ||
@@ -188,26 +188,26 @@
       nth = 0;
     }
     else {
       nth = atoi(nthdef);
     }
       
-    sendf(data->firstsocket, data,
-          "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
-          "DEFINE "
-          "%s "     /* database */
-          "%s\n"    /* word */
-          "QUIT\n",
-          
-          database,
-          word
-          );
+    Curl_sendf(data->firstsocket, conn,
+               "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
+               "DEFINE "
+               "%s "     /* database */
+               "%s\n"    /* word */
+               "QUIT\n",
+               
+               database,
+               word
+               );
+    
+    result = Curl_Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
+                           -1, NULL); /* no upload */
     
-    result = Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
-                      -1, NULL); /* no upload */
-      
     if(result)
       return result;
       
   }
   else {
       
@@ -217,20 +217,20 @@
 	
       ppath++;
       for (i = 0; ppath[i]; i++) {
         if (ppath[i] == ':')
           ppath[i] = ' ';
       }
-      sendf(data->firstsocket, data,
-            "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
-            "%s\n"
-            "QUIT\n",
-            ppath);
+      Curl_sendf(data->firstsocket, conn,
+                 "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
+                 "%s\n"
+                 "QUIT\n",
+                 ppath);
       
-      result = Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
-                        -1, NULL);
+      result = Curl_Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
+                             -1, NULL);
       
       if(result)
         return result;
       
     }
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/dict.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/dict.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/dict.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/dict.h	2001-01-05 18:11:42.000000000 +0800
@@ -18,12 +18,12 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: dict.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: dict.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
-CURLcode dict(struct connectdata *conn);
-CURLcode dict_done(struct connectdata *conn);
+CURLcode Curl_dict(struct connectdata *conn);
+CURLcode Curl_dict_done(struct connectdata *conn);
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib: download.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib: download.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/easy.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/easy.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/easy.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/easy.c	2001-01-17 21:23:01.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: easy.c,v 1.8 2001/01/03 09:29:34 bagder Exp $
+ * $Id: easy.c,v 1.9 2001/01/17 13:23:01 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -69,13 +69,13 @@
 #endif
 
 #endif
 
 #include "urldata.h"
 #include <curl/curl.h>
-#include "highlevel.h"
+#include "transfer.h"
 #include <curl/types.h>
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 CURL *curl_easy_init(void)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/file.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/file.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/file.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/file.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.c,v 1.13 2001/01/03 09:29:34 bagder Exp $
+ * $Id: file.c,v 1.14 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -103,13 +103,13 @@
   struct stat statbuf;
   size_t expected_size=-1;
   size_t nread;
   struct UrlData *data = conn->data;
   char *buf = data->buffer;
   int bytecount = 0;
-  struct timeval start = tvnow();
+  struct timeval start = Curl_tvnow();
   struct timeval now = start;
   int fd;
   char *actual_path = curl_unescape(path, 0);
 
 #if defined(WIN32) || defined(__EMX__)
   int i;
@@ -136,13 +136,13 @@
 
   /* The following is a shortcut implementation of file reading
      this is both more efficient than the former call to download() and
      it avoids problems with select() and recv() on file descriptors
      in Winsock */
   if(expected_size != -1)
-    pgrsSetDownloadSize(data, expected_size);
+    Curl_pgrsSetDownloadSize(data, expected_size);
 
   while (res == CURLE_OK) {
     nread = read(fd, buf, BUFSIZE-1);
 
     if (0 <= nread)
       buf[nread] = 0;
@@ -152,22 +152,22 @@
     bytecount += nread;
     /* NOTE: The following call to fwrite does CR/LF translation on
        Windows systems if the target is stdout. Use -O or -o parameters
        to prevent CR/LF translation (this then goes to a binary mode
        file descriptor). */
 
-    res = client_write(data, CLIENTWRITE_BODY, buf, nread);
+    res = Curl_client_write(data, CLIENTWRITE_BODY, buf, nread);
     if(res)
       return res;
 
-    now = tvnow();
-    if(pgrsUpdate(data))
+    now = Curl_tvnow();
+    if(Curl_pgrsUpdate(data))
       res = CURLE_ABORTED_BY_CALLBACK;
   }
-  now = tvnow();
-  if(pgrsUpdate(data))
+  now = Curl_tvnow();
+  if(Curl_pgrsUpdate(data))
     res = CURLE_ABORTED_BY_CALLBACK;
 
   close(fd);
 
   return res;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/formdata.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/formdata.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/formdata.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/formdata.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: formdata.c,v 1.12 2001/01/03 09:29:34 bagder Exp $
+ * $Id: formdata.c,v 1.13 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 /*
   Debug the form generator stand-alone by compiling this source file with:
 
   gcc -DHAVE_CONFIG_H -I../ -g -D_FORM_DEBUG -o formdata -I../include formdata.c
@@ -88,22 +88,16 @@
  * If you want content-types specified for each too, write them like:
  *
  * 'name=@filename;type=image/gif,filename2,filename3'
  *
  ***************************************************************************/
 
-int curl_formparse(char *input,
-                   struct HttpPost **httppost,
-                   struct HttpPost **last_post)
-{
-  return FormParse(input, httppost, last_post);
-}
-
 #define FORM_FILE_SEPARATOR ','
 #define FORM_TYPE_SEPARATOR ';'
 
+static
 int FormParse(char *input,
 	      struct HttpPost **httppost,
 	      struct HttpPost **last_post)
 {
   /* nextarg MUST be a string in the format 'name=contents' and we'll
      build a linked list with the info */
@@ -295,12 +289,19 @@
     fprintf(stderr, "Illegally formatted input field!\n");
     return 1;
   }
   return 0;
 }
 
+int curl_formparse(char *input,
+                   struct HttpPost **httppost,
+                   struct HttpPost **last_post)
+{
+  return FormParse(input, httppost, last_post);
+}
+
 static int AddFormData(struct FormData **formp,
 			void *line,
 			long length)
 {
   struct FormData *newform = (struct FormData *)
     malloc(sizeof(struct FormData));
@@ -336,13 +337,13 @@
   va_end(ap);
 
   return AddFormData(formp, s, 0);
 }
 
 
-char *MakeFormBoundary(void)
+char *Curl_FormBoundary(void)
 {
   char *retstring;
   static int randomizer=0; /* this is just so that two boundaries within
 			      the same form won't be identical */
   int i;
 
@@ -364,13 +365,13 @@
   retstring[BOUNDARY_LENGTH-1]=0; /* zero terminate */
 
   return retstring;
 }
 
 /* Used from http.c */ 
-void FormFree(struct FormData *form)
+void Curl_FormFree(struct FormData *form)
 {
   struct FormData *next;
   do {
     next=form->next;  /* the following form line */
     free(form->line); /* free the line */
     free(form);       /* free the struct */
@@ -397,14 +398,14 @@
       free(form->contenttype); /* free the content type */
     free(form);       /* free the struct */
 
   } while((form=next)); /* continue */
 }
 
-struct FormData *getFormData(struct HttpPost *post,
-			     int *sizep)
+struct FormData *Curl_getFormData(struct HttpPost *post,
+                                  int *sizep)
 {
   struct FormData *form = NULL;
   struct FormData *firstform;
 
   struct HttpPost *file;
 
@@ -412,13 +413,13 @@
   char *boundary;
   char *fileboundary=NULL;
 
   if(!post)
     return NULL; /* no input => no output! */
 
-  boundary = MakeFormBoundary();
+  boundary = Curl_FormBoundary();
   
   /* Make the first line of the output */
   AddFormDataf(&form,
                "Content-Type: multipart/form-data;"
                " boundary=%s\r\n",
                boundary);
@@ -436,13 +437,13 @@
 			 post->name);
 
     if(post->more) {
       /* If used, this is a link to more file names, we must then do
          the magic to include several files with the same field name */
 
-      fileboundary = MakeFormBoundary();
+      fileboundary = Curl_FormBoundary();
 
       size += AddFormDataf(&form,
 			   "\r\nContent-Type: multipart/mixed,"
 			   " boundary=%s\r\n",
 			   fileboundary);
     }
@@ -532,41 +533,28 @@
 
   free(boundary);
 
   return firstform;
 }
 
-int FormInit(struct Form *form, struct FormData *formdata )
+int Curl_FormInit(struct Form *form, struct FormData *formdata )
 {
   if(!formdata)
     return 1; /* error */
 
-#if 0  
-  struct FormData *lastnode=formdata;
-
-  /* find the last node in the list */
-  while(lastnode->next) {
-    lastnode = lastnode->next;
-  }
-
-  /* Now, make sure that we'll send a nice terminating sequence at the end
-   * of the post. We *DONT* add this string to the size of the data since this
-   * is actually AFTER the data. */
-  AddFormDataf(&lastnode, "\r\n\r\n");
-#endif
   form->data = formdata;
   form->sent = 0;
 
   return 0;
 }
 
 /* fread() emulation */
-int FormReader(char *buffer,
-	       size_t size,
-	       size_t nitems,
-	       FILE *mydata)
+int Curl_FormReader(char *buffer,
+                    size_t size,
+                    size_t nitems,
+                    FILE *mydata)
 {
   struct Form *form;
   int wantedsize;
   int gotsize;
 
   form=(struct Form *)mydata;
@@ -635,13 +623,13 @@
       fprintf(stderr, "Illegally formatted input field: '%s'!\n",
 	      argv[i]);
       return 1;
     }
   }
 
-  form=getFormData(httppost, &size);
+  form=Curl_getFormData(httppost, &size);
 
   FormInit(&formread, form);
 
   while(nread = FormReader(buffer, 1, sizeof(buffer), (FILE *)&formread)) {
     fwrite(buffer, nread, 1, stderr);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/formdata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/formdata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/formdata.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/formdata.h	2001-01-05 18:11:42.000000000 +0800
@@ -18,13 +18,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: formdata.h,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: formdata.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 /* plain and simple linked list with lines to send */
 struct FormData {
   struct FormData *next;
   char *line;
   long length;
@@ -33,26 +33,22 @@
 struct Form {
   struct FormData *data; /* current form line to send */
   int sent; /* number of bytes of the current line that has already
 	       been sent in a previous invoke */
 };
 
-int FormParse(char *string,
-	      struct HttpPost **httppost,
-	      struct HttpPost **last_post);
+int Curl_FormInit(struct Form *form, struct FormData *formdata );
 
-int FormInit(struct Form *form, struct FormData *formdata );
-
-struct FormData *getFormData(struct HttpPost *post,
-			     int *size);
+struct FormData *Curl_getFormData(struct HttpPost *post,
+                                  int *size);
 
 /* fread() emulation */
-int FormReader(char *buffer,
-	       size_t size,
-	       size_t nitems,
-	       FILE *mydata);
+int Curl_FormReader(char *buffer,
+                    size_t size,
+                    size_t nitems,
+                    FILE *mydata);
 
-char *MakeFormBoundary(void);
+char *Curl_FormBoundary(void);
 
-void FormFree(struct FormData *);
+void Curl_FormFree(struct FormData *);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ftp.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ftp.c	2001-01-25 20:17:07.000000000 +0800
@@ -15,20 +15,21 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.c,v 1.40 2001/01/03 09:29:34 bagder Exp $
+ * $Id: ftp.c,v 1.45 2001/01/25 12:17:07 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <stdarg.h>
 #include <ctype.h>
 #include <errno.h>
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -63,24 +64,33 @@
 #include "urldata.h"
 #include "sendf.h"
 
 #include "if2ip.h"
 #include "hostip.h"
 #include "progress.h"
-#include "download.h"
+#include "transfer.h"
 #include "escape.h"
 #include "http.h" /* for HTTP proxy tunnel stuff */
+#include "ftp.h"
 
 #ifdef KRB4
 #include "security.h"
+#include "krb4.h"
 #endif
+
+#define _MPRINTF_REPLACE /* use our functions only */
+#include <curl/mprintf.h>
+
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
+/* easy-to-use macro: */
+#define ftpsendf Curl_ftpsendf
+
 /* returns last node in linked list */
 static struct curl_slist *slist_get_last(struct curl_slist *list)
 {
 	struct curl_slist	*item;
 
 	/* if caller passed us a NULL, return now */
@@ -199,36 +209,41 @@
 
 /* --- parse FTP server responses --- */
 
 #define lastline(line) (isdigit((int)line[0]) && isdigit((int)line[1]) && \
 			isdigit((int)line[2]) && (' ' == line[3]))
 
-int GetLastResponse(int sockfd, char *buf,
-                    struct connectdata *conn,
-                    int *ftpcode)
+/*
+ * We allow the ftpcode pointer to be NULL if no reply integer is wanted
+ */
+
+int Curl_GetFTPResponse(int sockfd, char *buf,
+                        struct connectdata *conn,
+                        int *ftpcode)
 {
   int nread;
-  int keepon=TRUE;
+  size_t keepon=TRUE;
   char *ptr;
   int timeout = 3600; /* in seconds */
   struct timeval interval;
   fd_set rkeepfd;
   fd_set readfd;
   struct UrlData *data = conn->data;
 
 #define SELECT_OK      0
 #define SELECT_ERROR   1
 #define SELECT_TIMEOUT 2
   int error = SELECT_OK;
 
-  *ftpcode=0; /* 0 for errors */
+  if(ftpcode)
+    *ftpcode=0; /* 0 for errors */
 
   if(data->timeout) {
     /* if timeout is requested, find out how much remaining time we have */
     timeout = data->timeout - /* timeout time */
-      (tvlong(tvnow()) - tvlong(conn->now)); /* spent time */
+      (Curl_tvlong(Curl_tvnow()) - Curl_tvlong(conn->now)); /* spent time */
     if(timeout <=0 ) {
       failf(data, "Transfer aborted due to timeout");
       return -SELECT_TIMEOUT; /* already too little time */
     }
   }
 
@@ -254,28 +269,23 @@
       case -1: /* select() error, stop reading */
         error = SELECT_ERROR;
         failf(data, "Transfer aborted due to select() error");
         break;
       case 0: /* timeout */
         error = SELECT_TIMEOUT;
-        infof(data, "Transfer aborted due to timeout\n");
         failf(data, "Transfer aborted due to timeout");
         break;
       default:
-#ifdef USE_SSLEAY
-        if (data->ssl.use) {
-          keepon = SSL_read(data->ssl.handle, ptr, 1);
-        }
-        else {
-#endif
-          keepon = sread(sockfd, ptr, 1);
-#ifdef USE_SSLEAY
-        }
-#endif /* USE_SSLEAY */
-
-        if ((*ptr == '\n') || (*ptr == '\r'))
+        /*
+         * This code previously didn't use the kerberos sec_read() code
+         * to read, but when we use Curl_read() it may do so. Do confirm
+         * that this is still ok and then remove this comment!
+         */
+        if(CURLE_OK != Curl_read(conn, sockfd, ptr, 1, &keepon))
+          keepon = FALSE;
+        else if ((*ptr == '\n') || (*ptr == '\r'))
           keepon = FALSE;
       }
       if(keepon) {
         nread++;
         ptr++;
       }
@@ -303,19 +313,20 @@
   } while(!error &&
 	  (nread<4 || !lastline(buf)) );
   
   if(error)
     return -error;
 
-  *ftpcode=atoi(buf); /* return the initial number like this */
+  if(ftpcode)
+    *ftpcode=atoi(buf); /* return the initial number like this */
 
   return nread;
 }
 
 /* -- who are we? -- */
-char *getmyhost(char *buf, int buf_size)
+char *Curl_getmyhost(char *buf, int buf_size)
 {
 #if defined(HAVE_GETHOSTNAME)
   gethostname(buf, buf_size);
 #elif defined(HAVE_UNAME)
   struct utsname ugnm;
   strncpy(buf, uname(&ugnm) < 0 ? "localhost" : ugnm.nodename, buf_size - 1);
@@ -327,13 +338,13 @@
 #endif
   return buf;
 }
 
 /* ftp_connect() should do everything that is to be considered a part
    of the connection phase. */
-CURLcode ftp_connect(struct connectdata *conn)
+CURLcode Curl_ftp_connect(struct connectdata *conn)
 {
   /* this is FTP and no proxy */
   int nread;
   struct UrlData *data=conn->data;
   char *buf = data->buffer; /* this is our buffer */
   struct FTP *ftp;
@@ -353,20 +364,20 @@
   ftp->bytecountp = &conn->bytecount;
   ftp->user = data->user;
   ftp->passwd = data->passwd;
 
   if (data->bits.tunnel_thru_httpproxy) {
     /* We want "seamless" FTP operations through HTTP proxy tunnel */
-    result = GetHTTPProxyTunnel(data, data->firstsocket,
-                                data->hostname, data->remote_port);
+    result = Curl_ConnectHTTPProxyTunnel(conn, data->firstsocket,
+                                         data->hostname, data->remote_port);
     if(CURLE_OK != result)
       return result;
   }
 
   /* The first thing we do is wait for the "220*" line: */
-  nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode != 220) {
     failf(data, "This doesn't seem like a nice ftp-server response");
     return CURLE_FTP_WEIRD_SERVER_REPLY;
@@ -393,13 +404,13 @@
 #endif
   
   /* send USER */
   ftpsendf(data->firstsocket, conn, "USER %s", ftp->user);
 
   /* wait for feedback */
-  nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode == 530) {
     /* 530 User ... access denied
        (the server denies to log the specified user) */
@@ -407,13 +418,13 @@
     return CURLE_FTP_ACCESS_DENIED;
   }
   else if(ftpcode == 331) {
     /* 331 Password required for ...
        (the server requires to send the user's password too) */
     ftpsendf(data->firstsocket, conn, "PASS %s", ftp->passwd);
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode == 530) {
       /* 530 Login incorrect.
          (the username and/or the password are incorrect) */
@@ -456,13 +467,13 @@
 
   return CURLE_OK;
 }
 
 
 /* argument is already checked for validity */
-CURLcode ftp_done(struct connectdata *conn)
+CURLcode Curl_ftp_done(struct connectdata *conn)
 {
   struct UrlData *data = conn->data;
   struct FTP *ftp = data->proto.ftp;
   size_t nread;
   char *buf = data->buffer; /* this is our buffer */
   struct curl_slist *qitem; /* QUOTE item */
@@ -493,13 +504,13 @@
   sclose(data->secondarysocket);
   data->secondarysocket = -1;
 
   if(!data->bits.no_body) {  
     /* now let's see what the server says about the transfer we
        just performed: */
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     /* 226 Transfer complete, 250 Requested file action okay, completed. */
     if((ftpcode != 226) && (ftpcode != 250)) {
       failf(data, "%s", buf+4);
@@ -513,13 +524,13 @@
     /* Send all QUOTE strings in same order as on command-line */
     while (qitem) {
       /* Send string */
       if (qitem->data) {
         ftpsendf(data->firstsocket, conn, "%s", qitem->data);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if (ftpcode >= 400) {
           failf(data, "QUOT string not accepted: %s",
                 qitem->data);
@@ -567,13 +578,13 @@
     /* Send all QUOTE strings in same order as on command-line */
     while (qitem) {
       /* Send string */
       if (qitem->data) {
         ftpsendf(data->firstsocket, conn, "%s", qitem->data);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if (ftpcode >= 400) {
           failf(data, "QUOT string not accepted: %s",
                 qitem->data);
@@ -584,13 +595,13 @@
     }
   }
 
   /* change directory first! */
   if(ftp->dir && ftp->dir[0]) {
     ftpsendf(data->firstsocket, conn, "CWD %s", ftp->dir);
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 250) {
       failf(data, "Couldn't change to directory %s", ftp->dir);
       return CURLE_FTP_ACCESS_DENIED;
@@ -599,13 +610,13 @@
 
   if(data->bits.get_filetime && ftp->file) {
     /* we have requested to get the modified-time of the file, this is yet
        again a grey area as the MDTM is not kosher RFC959 */
     ftpsendf(data->firstsocket, conn, "MDTM %s", ftp->file);
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode == 213) {
       /* we got a time. Format should be: "YYYYMMDDHHMMSS[.sss]" where the
          last .sss part is optional and means fractions of a second */
@@ -636,38 +647,38 @@
 
     /* Some servers return different sizes for different modes, and thus we
        must set the proper type before we check the size */
     ftpsendf(data->firstsocket, conn, "TYPE %s",
              (data->bits.ftp_ascii)?"A":"I");
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 200) {
       failf(data, "Couldn't set %s mode",
             (data->bits.ftp_ascii)?"ASCII":"binary");
       return (data->bits.ftp_ascii)? CURLE_FTP_COULDNT_SET_ASCII:
         CURLE_FTP_COULDNT_SET_BINARY;
     }
 
     ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 213) {
       failf(data, "Couldn't get file size: %s", buf+4);
       return CURLE_FTP_COULDNT_GET_SIZE;
     }
     /* get the size from the ascii string: */
     filesize = atoi(buf+4);
 
     sprintf(buf, "Content-Length: %d\r\n", filesize);
-    result = client_write(data, CLIENTWRITE_BOTH, buf, 0);
+    result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
     if(result)
       return result;
 
 #ifdef HAVE_STRFTIME
     if(data->bits.get_filetime && data->progress.filetime) {
       struct tm *tm;
@@ -677,13 +688,13 @@
 #else
       tm = localtime(&data->progress.filetime);
 #endif
       /* format: "Tue, 15 Nov 1994 12:45:26 GMT" */
       strftime(buf, BUFSIZE-1, "Last-Modified: %a, %d %b %Y %H:%M:%S %Z\r\n",
                tm);
-      result = client_write(data, CLIENTWRITE_BOTH, buf, 0);
+      result = Curl_client_write(data, CLIENTWRITE_BOTH, buf, 0);
       if(result)
         return result;
     }
 #endif
 
     return CURLE_OK;
@@ -696,24 +707,26 @@
     char *hostdataptr=NULL;
     size_t size;
     unsigned short porttouse;
     char myhost[256] = "";
 
     if(data->ftpport) {
-      if(if2ip(data->ftpport, myhost, sizeof(myhost))) {
-        h = GetHost(data, myhost, &hostdataptr);
+      if(Curl_if2ip(data->ftpport, myhost, sizeof(myhost))) {
+        h = Curl_gethost(data, myhost, &hostdataptr);
       }
       else {
         if(strlen(data->ftpport)>1)
-          h = GetHost(data, data->ftpport, &hostdataptr);
+          h = Curl_gethost(data, data->ftpport, &hostdataptr);
         if(h)
           strcpy(myhost, data->ftpport); /* buffer overflow risk */
       }
     }
     if(! *myhost) {
-      h=GetHost(data, getmyhost(myhost, sizeof(myhost)), &hostdataptr);
+      h=Curl_gethost(data,
+                     Curl_getmyhost(myhost, sizeof(myhost)),
+                     &hostdataptr);
     }
     infof(data, "We connect from %s\n", myhost);
 
     if ( h ) {
       if( (portsock = socket(AF_INET, SOCK_STREAM, 0)) >= 0 ) {
 
@@ -785,26 +798,26 @@
       ftpsendf(data->firstsocket, conn, "PORT %d,%d,%d,%d,%d,%d",
             ip[0], ip[1], ip[2], ip[3],
             porttouse >> 8,
             porttouse & 255);
     }
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 200) {
       failf(data, "Server does not grok PORT, try without it!");
       return CURLE_FTP_PORT_FAILED;
     }     
   }
   else { /* we use the PASV command */
 
     ftpsendf(data->firstsocket, conn, "PASV");
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 227) {
       failf(data, "Odd return code after PASV");
       return CURLE_FTP_WEIRD_PASV_REPLY;
@@ -853,13 +866,13 @@
         he = conn->hp;
         connectport =
           (unsigned short)data->port; /* we connect to the proxy's port */
       }
       else {
         /* normal, direct, ftp connection */
-        he = GetHost(data, newhost, &hostdataptr);
+        he = Curl_gethost(data, newhost, &hostdataptr);
         if(!he) {
           failf(data, "Can't resolve new host %s", newhost);
           return CURLE_FTP_CANT_GET_HOST;
         }
         connectport = newport; /* we connect to the remote port */
       }
@@ -958,14 +971,14 @@
         }
         return CURLE_FTP_CANT_RECONNECT;
       }
 
       if (data->bits.tunnel_thru_httpproxy) {
         /* We want "seamless" FTP operations through HTTP proxy tunnel */
-        result = GetHTTPProxyTunnel(data, data->secondarysocket,
-                                    newhost, newport);
+        result = Curl_ConnectHTTPProxyTunnel(conn, data->secondarysocket,
+                                             newhost, newport);
         if(CURLE_OK != result)
           return result;
       }
     }
   }
   /* we have the (new) data connection ready */
@@ -974,13 +987,13 @@
   if(data->bits.upload) {
 
     /* Set type to binary (unless specified ASCII) */
     ftpsendf(data->firstsocket, conn, "TYPE %s",
           (data->bits.ftp_ascii)?"A":"I");
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 200) {
       failf(data, "Couldn't set %s mode",
             (data->bits.ftp_ascii)?"ASCII":"binary");
@@ -1005,13 +1018,13 @@
       if(data->resume_from < 0 ) {
         /* we could've got a specified offset from the command line,
            but now we know we didn't */
 
         ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 213) {
           failf(data, "Couldn't get file size: %s", buf+4);
           return CURLE_FTP_COULDNT_GET_SIZE;
@@ -1066,13 +1079,13 @@
     if(data->bits.ftp_append)
       /* we append onto the file instead of rewriting it */
       ftpsendf(data->firstsocket, conn, "APPE %s", ftp->file);
     else
       ftpsendf(data->firstsocket, conn, "STOR %s", ftp->file);
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode>=400) {
       failf(data, "Failed FTP upload:%s", buf+3);
       /* oops, we never close the sockets! */
@@ -1087,15 +1100,15 @@
 
     *bytecountp=0;
 
     /* When we know we're uploading a specified file, we can get the file
        size prior to the actual upload. */
 
-    pgrsSetUploadSize(data, data->infilesize);
+    Curl_pgrsSetUploadSize(data, data->infilesize);
 
-    result = Transfer(conn, -1, -1, FALSE, NULL, /* no download */
+    result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
                       data->secondarysocket, bytecountp);
     if(result)
       return result;
       
   }
   else {
@@ -1146,13 +1159,13 @@
          need to set ASCII transfer mode. */
       dirlist = TRUE;
 
       /* Set type to ASCII */
       ftpsendf(data->firstsocket, conn, "TYPE A");
 	
-      nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+      nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 	
       if(ftpcode != 200) {
         failf(data, "Couldn't set ascii mode");
         return CURLE_FTP_COULDNT_SET_ASCII;
@@ -1168,13 +1181,13 @@
     }
     else {
       /* Set type to binary (unless specified ASCII) */
       ftpsendf(data->firstsocket, conn, "TYPE %s",
                (data->bits.ftp_ascii)?"A":"I");
 
-      nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+      nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 
       if(ftpcode != 200) {
         failf(data, "Couldn't set %s mode",
               (data->bits.ftp_ascii)?"ASCII":"binary");
@@ -1189,13 +1202,13 @@
          * We start with trying to use the SIZE command to figure out the size
          * of the file we're gonna get. If we can get the size, this is by far
          * the best way to know if we're trying to resume beyond the EOF.  */
 
         ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 213) {
           infof(data, "server doesn't support SIZE: %s", buf+4);
           /* We couldn't get the size and therefore we can't know if there
@@ -1233,26 +1246,26 @@
         /* Set resume file transfer offset */
         infof(data, "Instructs server to resume from offset %d\n",
               data->resume_from);
 
         ftpsendf(data->firstsocket, conn, "REST %d", data->resume_from);
 
-        nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 350) {
           failf(data, "Couldn't use REST: %s", buf+4);
           return CURLE_FTP_COULDNT_USE_REST;
         }
       }
 
       ftpsendf(data->firstsocket, conn, "RETR %s", ftp->file);
     }
 
-    nread = GetLastResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if((ftpcode == 150) || (ftpcode == 125)) {
 
       /*
@@ -1318,13 +1331,13 @@
           return result;
       }
 
       infof(data, "Getting file with size: %d\n", size);
 
       /* FTP download: */
-      result=Transfer(conn, data->secondarysocket, size, FALSE,
+      result=Curl_Transfer(conn, data->secondarysocket, size, FALSE,
                       bytecountp,
                       -1, NULL); /* no upload here */
       if(result)
         return result;
     }
     else {
@@ -1338,13 +1351,13 @@
   return CURLE_OK;
 }
 
 /* -- deal with the ftp server!  -- */
 
 /* argument is already checked for validity */
-CURLcode ftp(struct connectdata *conn)
+CURLcode Curl_ftp(struct connectdata *conn)
 {
   CURLcode retcode;
 
   struct UrlData *data = conn->data;
   struct FTP *ftp;
   int dirlength=0; /* 0 forces strlen() */
@@ -1400,6 +1413,42 @@
 
   ftp->file = ftp->dir = NULL; /* zero */
 
   return retcode;
 }
 
+/*
+ * ftpsendf() sends the formated string as a ftp command to a ftp server
+ *
+ * NOTE: we build the command in a fixed-length buffer, which sets length
+ * restrictions on the command!
+ *
+ */
+size_t Curl_ftpsendf(int fd, struct connectdata *conn, char *fmt, ...)
+{
+  size_t bytes_written;
+  char s[256];
+
+  va_list ap;
+  va_start(ap, fmt);
+  vsnprintf(s, 250, fmt, ap);
+  va_end(ap);
+
+  if(conn->data->bits.verbose)
+    fprintf(conn->data->err, "> %s\n", s);
+
+  strcat(s, "\r\n"); /* append a trailing CRLF */
+
+#ifdef KRB4
+  if(conn->sec_complete && conn->data->cmdchannel) {
+    bytes_written = sec_fprintf(conn, conn->data->cmdchannel, s);
+    fflush(conn->data->cmdchannel);
+  }
+  else
+#endif /* KRB4 */
+    {
+      bytes_written = swrite(fd, s, strlen(s));
+    }
+  return(bytes_written);
+}
+
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ftp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ftp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ftp.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ftp.h	2001-01-05 18:11:42.000000000 +0800
@@ -18,16 +18,23 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: ftp.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
-CURLcode ftp(struct connectdata *conn);
-CURLcode ftp_done(struct connectdata *conn);
-CURLcode ftp_connect(struct connectdata *conn);
+CURLcode Curl_ftp(struct connectdata *conn);
+CURLcode Curl_ftp_done(struct connectdata *conn);
+CURLcode Curl_ftp_connect(struct connectdata *conn);
+
+size_t Curl_ftpsendf(int fd, struct connectdata *, char *fmt, ...);
 
 struct curl_slist *curl_slist_append(struct curl_slist *list, char *data);
 void curl_slist_free_all(struct curl_slist *list);
 
+/* The kerberos stuff needs this: */
+int Curl_GetFTPResponse(int sockfd, char *buf,
+                        struct connectdata *conn,
+                        int *ftpcode);
+
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/getenv.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/getenv.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/getenv.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/getenv.c	2001-01-24 17:01:32.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getenv.c,v 1.8 2001/01/03 09:29:34 bagder Exp $
+ * $Id: getenv.c,v 1.10 2001/01/24 09:01:32 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
@@ -30,25 +30,27 @@
 #endif
 
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
+static
 char *GetEnv(char *variable)
 {
 #ifdef WIN32
   /* This shit requires windows.h (HUGE) to be included */
   char env[MAX_PATH]; /* MAX_PATH is from windef.h */
   char *temp = getenv(variable);
   env[0] = '\0';
-  ExpandEnvironmentStrings(temp, env, sizeof(env));
+  if (temp != NULL)
+    ExpandEnvironmentStrings(temp, env, sizeof(env));
 #else
   /* no length control */
   char *env = getenv(variable);
 #endif
-  return env?strdup(env):NULL;
+  return (env && env[0])?strdup(env):NULL;
 }
 
 char *curl_getenv(char *v)
 {
   return GetEnv(v);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/getenv.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/getenv.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/getenv.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/getenv.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,13 +17,12 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getenv.h,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: getenv.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
-/* Unix and Win32 getenv function call */
-char *GetEnv(char *variable);
+#include <curl/curl.h>
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/getpass.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/getpass.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/getpass.h	2000-12-05 16:03:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/getpass.h	2001-01-09 06:30:30.000000000 +0800
@@ -1,8 +1,35 @@
 #ifndef __GETPASS_H
 #define __GETPASS_H
+/*****************************************************************************
+ *                                  _   _ ____  _     
+ *  Project                     ___| | | |  _ \| |    
+ *                             / __| | | | |_) | |    
+ *                            | (__| |_| |  _ <| |___ 
+ *                             \___|\___/|_| \_\_____|
+ *
+ * Copyright (C) 2000, Daniel Stenberg, <daniel@haxx.se>, et al.
+ *
+ * In order to be useful for every potential user, curl and libcurl are
+ * dual-licensed under the MPL and the MIT/X-derivate licenses.
+ *
+ * You may opt to use, copy, modify, merge, publish, distribute and/or sell
+ * copies of the Software, and permit persons to whom the Software is
+ * furnished to do so, under the terms of the MPL or the MIT/X-derivate
+ * licenses. You may pick one of these licenses.
+ *
+ * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
+ * KIND, either express or implied.
+ *
+ * $Id: getpass.h,v 1.7 2001/01/08 22:30:30 bagder Exp $
+ *****************************************************************************/
+#ifndef HAVE_GETPASS_R
+/* If there's a system-provided function named like this, we trust it is
+   also found in one of the standard headers. */
+
 /*
  * Returning NULL will abort the continued operation!
  */
 char* getpass_r(char *prompt, char* buffer, size_t buflen );
+#endif
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib: highlevel.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib: highlevel.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/hostip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/hostip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/hostip.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/hostip.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip.c,v 1.19 2001/01/03 09:29:34 bagder Exp $
+ * $Id: hostip.c,v 1.20 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <errno.h>
@@ -59,13 +59,13 @@
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 /* --- resolve name or IP-number --- */
 
-char *MakeIP(unsigned long num,char *addr, int addr_len)
+static char *MakeIP(unsigned long num,char *addr, int addr_len)
 {
 #if defined(HAVE_INET_NTOA) || defined(HAVE_INET_NTOA_R)
   struct in_addr in;
   in.s_addr = htonl(num);
 
 #if defined(HAVE_INET_NTOA_R)
@@ -80,20 +80,23 @@
   paddr = (unsigned char *)&num;
   sprintf(addr, "%u.%u.%u.%u", paddr[0], paddr[1], paddr[2], paddr[3]);
 #endif
   return (addr);
 }
 
-/* The original code to this function was stolen from the Dancer source code,
-   written by Bjorn Reese, it has since been patched and modified. */
+/* The original code to this function was once stolen from the Dancer source
+   code, written by Bjorn Reese, it has since been patched and modified
+   considerably. */
+
 #ifndef INADDR_NONE
 #define INADDR_NONE (unsigned long) ~0
 #endif
-struct hostent *GetHost(struct UrlData *data,
-                        char *hostname,
-                        char **bufp)
+
+struct hostent *Curl_gethost(struct UrlData *data,
+                             char *hostname,
+                             char **bufp)
 {
   struct hostent *h = NULL;
   unsigned long in;
   int ret; /* this variable is unused on several platforms but used on some */
 
 #define CURL_NAMELOOKUP_SIZE 9000
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/hostip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/hostip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/hostip.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/hostip.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,12 +17,14 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: hostip.h,v 1.6 2001/01/03 09:29:34 bagder Exp $
+ * $Id: hostip.h,v 1.7 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
-struct hostent *GetHost(struct UrlData *data, char *hostname, char **bufp );
+struct hostent *Curl_gethost(struct UrlData *data,
+                             char *hostname,
+                             char **bufp);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/http.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/http.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/http.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/http.c	2001-01-26 23:49:39.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.c,v 1.38 2001/01/03 09:29:34 bagder Exp $
+ * $Id: http.c,v 1.43 2001/01/26 15:49:39 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -84,31 +84,167 @@
 
 
 #endif
 
 #include "urldata.h"
 #include <curl/curl.h>
-#include "download.h"
+#include "transfer.h"
 #include "sendf.h"
 #include "formdata.h"
 #include "progress.h"
 #include "base64.h"
 #include "cookie.h"
 #include "strequal.h"
-#include "url.h"
 #include "ssluse.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 /*
+ * The add_buffer series of functions are used to build one large memory chunk
+ * from repeated function invokes. Used so that the entire HTTP request can
+ * be sent in one go.
+ */
+static CURLcode
+ add_buffer(send_buffer *in, void *inptr, size_t size);
+
+/*
+ * add_buffer_init() returns a fine buffer struct
+ */
+static
+send_buffer *add_buffer_init(void)
+{
+  send_buffer *blonk;
+  blonk=(send_buffer *)malloc(sizeof(send_buffer));
+  if(blonk) {
+    memset(blonk, 0, sizeof(send_buffer));
+    return blonk;
+  }
+  return NULL; /* failed, go home */
+}
+
+/*
+ * add_buffer_send() sends a buffer and frees all associated memory.
+ */
+static
+size_t add_buffer_send(int sockfd, struct connectdata *conn, send_buffer *in)
+{
+  size_t amount;
+  if(conn->data->bits.verbose) {
+    fputs("> ", conn->data->err);
+    /* this data _may_ contain binary stuff */
+    fwrite(in->buffer, in->size_used, 1, conn->data->err);
+  }
+
+  Curl_write(conn, sockfd, in->buffer, in->size_used, &amount);
+
+  if(in->buffer)
+    free(in->buffer);
+  free(in);
+
+  return amount;
+}
+
+
+/* 
+ * add_bufferf() builds a buffer from the formatted input
+ */
+static
+CURLcode add_bufferf(send_buffer *in, char *fmt, ...)
+{
+  CURLcode result = CURLE_OUT_OF_MEMORY;
+  char *s;
+  va_list ap;
+  va_start(ap, fmt);
+  s = vaprintf(fmt, ap); /* this allocs a new string to append */
+  va_end(ap);
+
+  if(s) {
+    result = add_buffer(in, s, strlen(s));
+    free(s);
+  }
+  return result;
+}
+
+/*
+ * add_buffer() appends a memory chunk to the existing one
+ */
+static
+CURLcode add_buffer(send_buffer *in, void *inptr, size_t size)
+{
+  char *new_rb;
+  int new_size;
+
+  if(size > 0) {
+    if(!in->buffer ||
+       ((in->size_used + size) > (in->size_max - 1))) {
+      new_size = (in->size_used+size)*2;
+      if(in->buffer)
+        /* we have a buffer, enlarge the existing one */
+        new_rb = (char *)realloc(in->buffer, new_size);
+      else
+        /* create a new buffer */
+        new_rb = (char *)malloc(new_size);
+
+      if(!new_rb)
+        return CURLE_OUT_OF_MEMORY;
+
+      in->buffer = new_rb;
+      in->size_max = new_size;
+    }
+    memcpy(&in->buffer[in->size_used], inptr, size);
+      
+    in->size_used += size;
+  }
+
+  return CURLE_OK;
+}
+
+/* end of the add_buffer functions */
+/*****************************************************************************/
+
+/*
+ * Read everything until a newline.
+ */
+
+static
+int GetLine(int sockfd, char *buf, struct connectdata *conn)
+{
+  size_t nread;
+  int read_rc=1;
+  char *ptr;
+  struct UrlData *data=conn->data;
+
+  ptr=buf;
+
+  /* get us a full line, terminated with a newline */
+  for(nread=0;
+      (nread<BUFSIZE) && read_rc;
+      nread++, ptr++) {
+    if((CURLE_OK != Curl_read(conn, sockfd, ptr, 1, &nread)) ||
+       (*ptr == '\n'))
+      break;
+  }
+  *ptr=0; /* zero terminate */
+
+  if(data->bits.verbose) {
+    fputs("< ", data->err);
+    fwrite(buf, 1, nread, data->err);
+    fputs("\n", data->err);
+  }
+  return nread;
+}
+
+
+
+/*
  * This function checks the linked list of custom HTTP headers for a particular
  * header (prefix).
  */
 bool static checkheaders(struct UrlData *data, char *thisheader)
 {
   struct curl_slist *head;
@@ -120,38 +256,40 @@
     }
   }
   return FALSE;
 }
 
 /*
- * GetHTTPProxyTunnel() requires that we're connected to a HTTP proxy. This
+ * ConnectHTTPProxyTunnel() requires that we're connected to a HTTP proxy. This
  * function will issue the necessary commands to get a seamless tunnel through
  * this proxy. After that, the socket can be used just as a normal socket.
  */
 
-CURLcode GetHTTPProxyTunnel(struct UrlData *data, int tunnelsocket,
-                            char *hostname, int remote_port)
+CURLcode Curl_ConnectHTTPProxyTunnel(struct connectdata *conn,
+                                     int tunnelsocket,
+                                     char *hostname, int remote_port)
 {
   int httperror=0;
   int subversion=0;
+  struct UrlData *data=conn->data;
 
   infof(data, "Establish HTTP proxy tunnel to %s:%d\n", hostname, remote_port);
 
-  /* OK, now send the connect statment */
-  sendf(tunnelsocket, data,
-        "CONNECT %s:%d HTTP/1.0\015\012"
-        "%s"
-        "%s"
-        "\r\n",
-        hostname, remote_port,
-        (data->bits.proxy_user_passwd)?data->ptr_proxyuserpwd:"",
-        (data->useragent?data->ptr_uagent:"")
-        );
+  /* OK, now send the connect request to the proxy */
+  Curl_sendf(tunnelsocket, conn,
+             "CONNECT %s:%d HTTP/1.0\015\012"
+             "%s"
+             "%s"
+             "\r\n",
+             hostname, remote_port,
+             (data->bits.proxy_user_passwd)?data->ptr_proxyuserpwd:"",
+             (data->useragent?data->ptr_uagent:"")
+             );
 
   /* wait for the proxy to send us a HTTP/1.0 200 OK header */
-  while(GetLine(tunnelsocket, data->buffer, data)) {
+  while(GetLine(tunnelsocket, data->buffer, conn)) {
     if('\r' == data->buffer[0])
       break; /* end of headers */
     if(2 == sscanf(data->buffer, "HTTP/1.%d %d",
                    &subversion,
                    &httperror)) {
       ;
@@ -167,13 +305,13 @@
   }
 
   infof (data, "Proxy replied to CONNECT request\n");
   return CURLE_OK;
 }
 
-CURLcode http_connect(struct connectdata *conn)
+CURLcode Curl_http_connect(struct connectdata *conn)
 {
   struct UrlData *data;
   CURLcode result;
 
   data=conn->data;
 
@@ -183,22 +321,21 @@
    * us to the host we want to talk to.  Only after the connect
    * has occured, can we start talking SSL
    */
   if (conn->protocol & PROT_HTTPS) {
     if (data->bits.httpproxy) {
       /* HTTPS through a proxy can only be done with a tunnel */
-      result = GetHTTPProxyTunnel(data, data->firstsocket,
-                                  data->hostname, data->remote_port);
+      result = Curl_ConnectHTTPProxyTunnel(conn, data->firstsocket,
+                                           data->hostname, data->remote_port);
       if(CURLE_OK != result)
         return result;
     }
 
     /* now, perform the SSL initialization for this socket */
-    if(UrgSSLConnect (data)) {
+    if(Curl_SSLConnect(data))
       return CURLE_SSL_CONNECT_ERROR;
-    }
   }
 
   if(data->bits.user_passwd && !data->bits.this_is_a_follow) {
     /* Authorization: is requested, this is not a followed location, get the
        original host name */
     data->auth_host = strdup(data->hostname);
@@ -206,32 +343,32 @@
 
   return CURLE_OK;
 }
 
 /* called from curl_close() when this struct is about to get wasted, free
    protocol-specific resources */
-CURLcode http_close(struct connectdata *conn)
+CURLcode Curl_http_close(struct connectdata *conn)
 {
   if(conn->data->auth_host)
     free(conn->data->auth_host);
   return CURLE_OK;
 }
 
-CURLcode http_done(struct connectdata *conn)
+CURLcode Curl_http_done(struct connectdata *conn)
 {
   struct UrlData *data;
   long *bytecount = &conn->bytecount;
   struct HTTP *http;
 
   data=conn->data;
   http=data->proto.http;
 
   if(data->bits.http_formpost) {
     *bytecount = http->readbytecount + http->writebytecount;
       
-    FormFree(http->sendit); /* Now free that whole lot */
+    Curl_FormFree(http->sendit); /* Now free that whole lot */
 
     data->fread = http->storefread; /* restore */
     data->in = http->in; /* restore */
   }
   else if(data->bits.http_put) {
     *bytecount = http->readbytecount + http->writebytecount;
@@ -241,13 +378,13 @@
   data->proto.http=NULL; /* it is gone */
 
   return CURLE_OK;
 }
 
 
-CURLcode http(struct connectdata *conn)
+CURLcode Curl_http(struct connectdata *conn)
 {
   struct UrlData *data=conn->data;
   char *buf = data->buffer; /* this is a short cut to the buffer */
   CURLcode result=CURLE_OK;
   struct HTTP *http;
   struct Cookie *co=NULL; /* no cookies from start */
@@ -281,62 +418,120 @@
     /* To prevent the user+password to get sent to other than the original
        host due to a location-follow, we do some weirdo checks here */
     if(!data->bits.this_is_a_follow ||
        !data->auth_host ||
        strequal(data->auth_host, data->hostname)) {
       sprintf(data->buffer, "%s:%s", data->user, data->passwd);
-      if(base64_encode(data->buffer, strlen(data->buffer),
-                      &authorization) >= 0) {
-        data->ptr_userpwd = maprintf( "Authorization: Basic %s\015\012",
-                                      authorization);
+      if(Curl_base64_encode(data->buffer, strlen(data->buffer),
+                            &authorization) >= 0) {
+        data->ptr_userpwd = aprintf( "Authorization: Basic %s\015\012",
+                                     authorization);
         free(authorization);
       }
     }
   }
   if((data->bits.set_range) && !checkheaders(data, "Range:")) {
-    data->ptr_rangeline = maprintf("Range: bytes=%s\015\012", data->range);
+    data->ptr_rangeline = aprintf("Range: bytes=%s\015\012", data->range);
   }
   if((data->bits.http_set_referer) && !checkheaders(data, "Referer:")) {
-    data->ptr_ref = maprintf("Referer: %s\015\012", data->referer);
+    data->ptr_ref = aprintf("Referer: %s\015\012", data->referer);
   }
   if(data->cookie && !checkheaders(data, "Cookie:")) {
-    data->ptr_cookie = maprintf("Cookie: %s\015\012", data->cookie);
+    data->ptr_cookie = aprintf("Cookie: %s\015\012", data->cookie);
   }
 
   if(data->cookies) {
-    co = cookie_getlist(data->cookies,
-                        host,
-                        ppath,
-                        conn->protocol&PROT_HTTPS?TRUE:FALSE);
+    co = Curl_cookie_getlist(data->cookies,
+                             host,
+                             ppath,
+                             conn->protocol&PROT_HTTPS?TRUE:FALSE);
   }
   if ((data->bits.httpproxy) && !(conn->protocol&PROT_HTTPS))  {
     /* The path sent to the proxy is in fact the entire URL */
     ppath = data->url;
   }
   if(data->bits.http_formpost) {
     /* we must build the whole darned post sequence first, so that we have
        a size of the whole shebang before we start to send it */
-    http->sendit = getFormData(data->httppost, &http->postsize);
+    http->sendit = Curl_getFormData(data->httppost, &http->postsize);
   }
 
   if(!checkheaders(data, "Host:")) {
     if(((conn->protocol&PROT_HTTPS) && (data->remote_port == PORT_HTTPS)) ||
        (!(conn->protocol&PROT_HTTPS) && (data->remote_port == PORT_HTTP)) )
       /* If (HTTPS on port 443) OR (non-HTTPS on port 80) then don't include
          the port number in the host string */
-      data->ptr_host = maprintf("Host: %s\r\n", host);
+      data->ptr_host = aprintf("Host: %s\r\n", host);
     else
-      data->ptr_host = maprintf("Host: %s:%d\r\n", host, data->remote_port);
+      data->ptr_host = aprintf("Host: %s:%d\r\n", host, data->remote_port);
   }
 
   if(!checkheaders(data, "Pragma:"))
     http->p_pragma = "Pragma: no-cache\r\n";
 
   if(!checkheaders(data, "Accept:"))
     http->p_accept = "Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\r\n";
 
+  if((data->bits.http_post ||
+      data->bits.http_formpost ||
+      data->bits.http_put) &&
+     data->resume_from) {
+    /**********************************************************************
+     * Resuming upload in HTTP means that we PUT or POST and that we have
+     * got a resume_from value set. The resume value has already created
+     * a Range: header that will be passed along. We need to "fast forward"
+     * the file the given number of bytes and decrease the assume upload
+     * file size before we continue this venture in the dark lands of HTTP.
+     *********************************************************************/
+   
+    if(data->resume_from < 0 ) {
+      /*
+       * This is meant to get the size of the present remote-file by itself.
+       * We don't support this now. Bail out!
+       */
+       data->resume_from = 0;
+    }
+
+    if(data->resume_from) {
+      /* do we still game? */
+      int passed=0;
+
+      /* Now, let's read off the proper amount of bytes from the
+         input. If we knew it was a proper file we could've just
+         fseek()ed but we only have a stream here */
+      do {
+        int readthisamountnow = (data->resume_from - passed);
+        int actuallyread;
+
+        if(readthisamountnow > BUFSIZE)
+          readthisamountnow = BUFSIZE;
+
+        actuallyread =
+          data->fread(data->buffer, 1, readthisamountnow, data->in);
+
+        passed += actuallyread;
+        if(actuallyread != readthisamountnow) {
+          failf(data, "Could only read %d bytes from the input\n",
+                passed);
+          return CURLE_READ_ERROR;
+        }
+      } while(passed != data->resume_from); /* loop until done */
+
+      /* now, decrease the size of the read */
+      if(data->infilesize>0) {
+        data->infilesize -= data->resume_from;
+
+        if(data->infilesize <= 0) {
+          failf(data, "File already completely uploaded\n");
+          return CURLE_PARTIAL_FILE;
+        }
+      }
+      /* we've passed, proceed as normal */
+    }
+  }
+
   do {
     send_buffer *req_buffer;
     struct curl_slist *headers=data->headers;
 
     /* initialize a dynamic send-buffer */
     req_buffer = add_buffer_init();
@@ -386,13 +581,13 @@
         }
         co = co->next; /* next cookie please */
       }
       if(count) {
         add_buffer(req_buffer, "\r\n", 2);
       }
-      cookie_freelist(store); /* free the cookie list */
+      Curl_cookie_freelist(store); /* free the cookie list */
       co=NULL;
     }
 
     if(data->timecondition) {
       struct tm *thistime;
 
@@ -448,40 +643,40 @@
         }
       }
       headers = headers->next;
     }
 
     if(data->bits.http_formpost) {
-      if(FormInit(&http->form, http->sendit)) {
+      if(Curl_FormInit(&http->form, http->sendit)) {
         failf(data, "Internal HTTP POST error!\n");
         return CURLE_HTTP_POST_ERROR;
       }
 
       http->storefread = data->fread; /* backup */
       http->in = data->in; /* backup */
           
       data->fread =
         (size_t (*)(char *, size_t, size_t, FILE *))
-        FormReader; /* set the read function to read from the
-                       generated form data */
+        Curl_FormReader; /* set the read function to read from the
+                            generated form data */
       data->in = (FILE *)&http->form;
 
       add_bufferf(req_buffer,
                   "Content-Length: %d\r\n", http->postsize-2);
 
       /* set upload size to the progress meter */
-      pgrsSetUploadSize(data, http->postsize);
+      Curl_pgrsSetUploadSize(data, http->postsize);
 
       data->request_size = 
         add_buffer_send(data->firstsocket, conn, req_buffer);
-      result = Transfer(conn, data->firstsocket, -1, TRUE,
+      result = Curl_Transfer(conn, data->firstsocket, -1, TRUE,
                         &http->readbytecount,
                           data->firstsocket,
                         &http->writebytecount);
       if(result) {
-        FormFree(http->sendit); /* free that whole lot */
+        Curl_FormFree(http->sendit); /* free that whole lot */
         return result;
       }
     }
     else if(data->bits.http_put) {
       /* Let's PUT the data to the server! */
 
@@ -491,20 +686,20 @@
                     data->infilesize );
       }
       else
         add_bufferf(req_buffer, "\015\012");
 
       /* set the upload size to the progress meter */
-      pgrsSetUploadSize(data, data->infilesize);
+      Curl_pgrsSetUploadSize(data, data->infilesize);
 
       /* this sends the buffer and frees all the buffer resources */
       data->request_size = 
         add_buffer_send(data->firstsocket, conn, req_buffer);
 
       /* prepare for transfer */
-      result = Transfer(conn, data->firstsocket, -1, TRUE,
+      result = Curl_Transfer(conn, data->firstsocket, -1, TRUE,
                         &http->readbytecount,
                         data->firstsocket,
                         &http->writebytecount);
       if(result)
         return result;
       
@@ -544,13 +739,13 @@
 
       /* issue the request */
       data->request_size = 
         add_buffer_send(data->firstsocket, conn, req_buffer);
 
       /* HTTP GET/HEAD download: */
-      result = Transfer(conn, data->firstsocket, -1, TRUE, bytecount,
+      result = Curl_Transfer(conn, data->firstsocket, -1, TRUE, bytecount,
                         -1, NULL); /* nothing to upload */
     }
     if(result)
       return result;
   } while (0); /* this is just a left-over from the multiple document download
                   attempts */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/http.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/http.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/http.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/http.h	2001-01-25 20:24:34.000000000 +0800
@@ -18,20 +18,21 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.h,v 1.8 2001/01/03 09:29:34 bagder Exp $
+ * $Id: http.h,v 1.10 2001/01/25 12:24:34 bagder Exp $
  *****************************************************************************/
 
 /* ftp can use this as well */
-CURLcode GetHTTPProxyTunnel(struct UrlData *data, int tunnelsocket,
-                            char *hostname, int remote_port);
+CURLcode Curl_ConnectHTTPProxyTunnel(struct connectdata *conn,
+                                     int tunnelsocket,
+                                     char *hostname, int remote_port);
 
 /* protocol-specific functions set up to be called by the main engine */
-CURLcode http(struct connectdata *conn);
-CURLcode http_done(struct connectdata *conn);
-CURLcode http_connect(struct connectdata *conn);
-CURLcode http_close(struct connectdata *conn);
+CURLcode Curl_http(struct connectdata *conn);
+CURLcode Curl_http_done(struct connectdata *conn);
+CURLcode Curl_http_connect(struct connectdata *conn);
+CURLcode Curl_http_close(struct connectdata *conn);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/if2ip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/if2ip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/if2ip.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/if2ip.c	2001-01-24 22:44:05.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: if2ip.c,v 1.11 2001/01/03 09:29:34 bagder Exp $
+ * $Id: if2ip.c,v 1.13 2001/01/24 14:44:05 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -29,13 +29,13 @@
 
 
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 
-#if ! defined(WIN32) && ! defined(__BEOS__)
+#if ! defined(WIN32) && ! defined(__BEOS__) && !defined(__CYGWIN32__)
 
 #ifdef NEED_REENTRANT
 #define _REENTRANT
 #endif
 
 #ifdef HAVE_SYS_SOCKET_H
@@ -69,13 +69,13 @@
 #if defined(HAVE_INET_NTOA_R) && !defined(HAVE_INET_NTOA_R_DECL) 
 #include "inet_ntoa_r.h"
 #endif
 
 #define SYS_ERROR -1
 
-char *if2ip(char *interface, char *buf, int buf_size)
+char *Curl_if2ip(char *interface, char *buf, int buf_size)
 {
   int dummy;
   char *ip=NULL;
   
   if(!interface)
     return NULL;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/if2ip.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/if2ip.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/if2ip.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/if2ip.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,17 +17,17 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: if2ip.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: if2ip.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 #include "setup.h"
 
 #if ! defined(WIN32) && ! defined(__BEOS__)
-extern char *if2ip(char *interface, char *buf, int buf_size);
+extern char *Curl_if2ip(char *interface, char *buf, int buf_size);
 #else
-#define if2ip(a,b,c) NULL
+#define Curl_if2ip(a,b,c) NULL
 #endif
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/krb4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/krb4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/krb4.c	2000-10-09 16:49:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/krb4.c	2001-01-25 20:00:48.000000000 +0800
@@ -44,12 +44,15 @@
 #include <stdlib.h>
 #include <netdb.h>
 #include <syslog.h>
 #include <string.h>
 #include <krb.h>
 
+#include "ftp.h"
+#include "sendf.h"
+
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 #ifdef FTP_SERVER
@@ -92,13 +95,14 @@
     *p = '\0';
     if (*src == '\0')
 	return n;
     else
 	return n + strlen (src);
 }
-
+#else
+size_t strlcpy (char *dst, const char *src, size_t dst_sz);
 #endif
 
 static int
 krb4_check_prot(void *app_data, int level)
 {
     if(level == prot_confidential)
@@ -276,18 +280,21 @@
     KTEXT_ST adat;
     MSG_DAT msg_data;
     int checksum;
     u_int32_t cs;
     struct krb4_data *d = app_data;
     struct sockaddr_in *localaddr  = (struct sockaddr_in *)LOCAL_ADDR;
+#if 0
     struct sockaddr_in *remoteaddr = (struct sockaddr_in *)REMOTE_ADDR;
+#endif
     char *host = conn->hp->h_name;
     size_t nread;
     int l = sizeof(local_addr);
 
-    if(getsockname(conn->data->firstsocket, LOCAL_ADDR, &l) < 0)
+    if(getsockname(conn->data->firstsocket,
+                   (struct sockaddr *)LOCAL_ADDR, &l) < 0)
 	perror("getsockname()");
 
     checksum = getpid();
     ret = mk_auth(d, &adat, "ftp", host, checksum);
     if(ret == KDC_PR_UNKNOWN)
 	ret = mk_auth(d, &adat, "rcmd", host, checksum);
@@ -305,13 +312,13 @@
 	  && krb_get_our_ip_for_realm(NULL, &natAddr) != KSUCCESS)
 	printf("Can't get address for realm %s\n",
 	       krb_realmofhost(host));
       else {
 	if (natAddr.s_addr != localaddr->sin_addr.s_addr) {
 	  printf("Using NAT IP address (%s) for kerberos 4\n",
-		 inet_ntoa(natAddr));
+		 (char *)inet_ntoa(natAddr));
 	  localaddr->sin_addr = natAddr;
 	  
 	  /*
 	   * This not the best place to do this, but it
 	   * is here we know that (probably) NAT is in
 	   * use!
@@ -324,21 +331,21 @@
     }
 #endif
 
     /*printf("Local address is %s\n", inet_ntoa(localaddr->sin_addr));***/
     /*printf("Remote address is %s\n", inet_ntoa(remoteaddr->sin_addr));***/
 
-    if(base64_encode(adat.dat, adat.length, &p) < 0) {
+    if(Curl_base64_encode(adat.dat, adat.length, &p) < 0) {
 	printf("Out of memory base64-encoding.\n");
 	return AUTH_CONTINUE;
     }
     /*ret = command("ADAT %s", p)*/
-    ftpsendf(conn->data->firstsocket, conn, "ADAT %s", p);
+    Curl_ftpsendf(conn->data->firstsocket, conn, "ADAT %s", p);
     /* wait for feedback */
-    nread = GetLastResponse(conn->data->firstsocket,
-			    conn->data->buffer, conn);
+    nread = Curl_GetFTPResponse(conn->data->firstsocket,
+                                conn->data->buffer, conn, NULL);
     if(nread < 0)
 	return /*CURLE_OPERATION_TIMEOUTED*/-1;
     free(p);
 
     if(/*ret != COMPLETE*/conn->data->buffer[0] != '2'){
 	printf("Server didn't accept auth data.\n");
@@ -348,13 +355,13 @@
     p = strstr(/*reply_string*/conn->data->buffer, "ADAT=");
     if(!p){
 	printf("Remote host didn't send adat reply.\n");
 	return AUTH_ERROR;
     }
     p += 5;
-    len = base64_decode(p, adat.dat);
+    len = Curl_base64_decode(p, adat.dat);
     if(len < 0){
 	printf("Failed to decode base64 from server.\n");
 	return AUTH_ERROR;
     }
     adat.length = len;
     ret = krb_rd_safe(adat.dat, adat.length, &d->key, 
@@ -386,64 +393,59 @@
 };
 
 #endif /* FTP_SERVER */
 
 void krb_kauth(struct connectdata *conn)
 {
-    int ret;
-    char buf[1024];
     des_cblock key;
     des_key_schedule schedule;
     KTEXT_ST tkt, tktcopy;
     char *name;
     char *p;
-    int overbose;
     char passwd[100];
     int tmp;
     size_t nread;
 	
     int save;
 
     save = set_command_prot(conn, prot_private);
     /*ret = command("SITE KAUTH %s", name);***/
-    ftpsendf(conn->data->firstsocket, conn,
+    Curl_ftpsendf(conn->data->firstsocket, conn,
              "SITE KAUTH %s", conn->data->user);
     /* wait for feedback */
-    nread = GetLastResponse(conn->data->firstsocket, conn->data->buffer, conn);
+    nread = Curl_GetFTPResponse(conn->data->firstsocket, conn->data->buffer,
+                                conn, NULL);
     if(nread < 0)
 	return /*CURLE_OPERATION_TIMEOUTED*/;
 
     if(/*ret != CONTINUE*/conn->data->buffer[0] != '3'){
-	/*verbose = overbose;***/
 	set_command_prot(conn, save);
 	/*code = -1;***/
 	return;
     }
-    /*verbose = overbose;***/
     p = strstr(/*reply_string***/conn->data->buffer, "T=");
     if(!p){
 	printf("Bad reply from server.\n");
 	set_command_prot(conn, save);
 	/*code = -1;***/
 	return;
     }
     p += 2;
-    tmp = base64_decode(p, &tkt.dat);
+    tmp = Curl_base64_decode(p, &tkt.dat);
     if(tmp < 0){
 	printf("Failed to decode base64 in reply.\n");
 	set_command_prot(conn, save);
 	/*code = -1;***/
 	return;
     }
     tkt.length = tmp;
     tktcopy.length = tkt.length;
     
     p = strstr(/*reply_string***/conn->data->buffer, "P=");
     if(!p){
 	printf("Bad reply from server.\n");
-	/*verbose = overbose;***/
 	set_command_prot(conn, save);
 	/*code = -1;***/
 	return;
     }
     name = p + 2;
     for(; *p && *p != ' ' && *p != '\r' && *p != '\n'; p++);
@@ -473,24 +475,25 @@
 			 tkt.length,
 			 schedule, &key, DES_DECRYPT);
     }
     memset(key, 0, sizeof(key));
     memset(schedule, 0, sizeof(schedule));
     memset(passwd, 0, sizeof(passwd));
-    if(base64_encode(tktcopy.dat, tktcopy.length, &p) < 0) {
+    if(Curl_base64_encode(tktcopy.dat, tktcopy.length, &p) < 0) {
       failf(conn->data, "Out of memory base64-encoding.\n");
       set_command_prot(conn, save);
       /*code = -1;***/
       return;
     }
     memset (tktcopy.dat, 0, tktcopy.length);
     /*ret = command("SITE KAUTH %s %s", name, p);***/
-    ftpsendf(conn->data->firstsocket, conn,
+    Curl_ftpsendf(conn->data->firstsocket, conn,
              "SITE KAUTH %s %s", name, p);
     /* wait for feedback */
-    nread = GetLastResponse(conn->data->firstsocket, conn->data->buffer, conn);
+    nread = Curl_GetFTPResponse(conn->data->firstsocket, conn->data->buffer,
+                                conn, NULL);
     if(nread < 0)
 	return /*CURLE_OPERATION_TIMEOUTED*/;
     free(p);
     set_command_prot(conn, save);
 }
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib: krb4.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ldap.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ldap.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ldap.c,v 1.10 2001/01/03 09:29:34 bagder Exp $
+ * $Id: ldap.c,v 1.11 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -114,24 +114,24 @@
   return func;
 }
 
 static int WriteProc(void *param, char *text, int len)
 {
   struct UrlData *data = (struct UrlData *)param;
-  client_write(data, CLIENTWRITE_BODY, text, 0);
+  Curl_client_write(data, CLIENTWRITE_BODY, text, 0);
   return 0;
 }
 
-CURLcode ldap_done(struct connectdata *conn)
+CURLcode Curl_ldap_done(struct connectdata *conn)
 {
   return CURLE_OK;
 }
 
 /***********************************************************************
  */
-CURLcode ldap(struct connectdata *conn)
+CURLcode Curl_ldap(struct connectdata *conn)
 {
   CURLcode status = CURLE_OK;
   int rc;
   void *(*ldap_open)(char *, int);
   int (*ldap_simple_bind_s)(void *, char *, char *);
   int (*ldap_unbind_s)(void *);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ldap.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ldap.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ldap.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ldap.h	2001-01-05 18:11:42.000000000 +0800
@@ -18,12 +18,12 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ldap.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: ldap.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
-CURLcode ldap(struct connectdata *conn);
-CURLcode ldap_done(struct connectdata *conn);
+CURLcode Curl_ldap(struct connectdata *conn);
+CURLcode Curl_ldap_done(struct connectdata *conn);
 
 #endif /* __LDAP_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.am	2000-12-01 06:43:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.am	2001-01-17 21:22:27.000000000 +0800
@@ -1,12 +1,16 @@
 #
-# $Id: Makefile.am,v 1.13 2000/11/30 22:22:08 bagder Exp $
+# $Id: Makefile.am,v 1.16 2001/01/17 13:22:27 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign
 
+EXTRA_DIST = getdate.y \
+       Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6 \
+       libcurl.def dllinit.c
+
 lib_LTLIBRARIES = libcurl.la
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
 
 INCLUDES = -I$(top_srcdir)/include
@@ -46,18 +50,20 @@
 base64.c       file.h         hostip.c       progress.c     timeval.h \
 base64.h       formdata.c     hostip.h       progress.h     \
 cookie.c       formdata.h     http.c         sendf.c        \
 cookie.h       ftp.c          http.h         sendf.h        url.c \
 dict.c         ftp.h          if2ip.c        speedcheck.c   url.h \
 dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h \
-download.c     getdate.h      ldap.c         ssluse.c       version.c \
-download.h     getenv.c       ldap.h         ssluse.h       \
+getdate.h      ldap.c         ssluse.c       version.c \
+getenv.c       ldap.h         ssluse.h       \
 escape.c       getenv.h       mprintf.c      telnet.c       \
 escape.h       getpass.c      netrc.c        telnet.h       \
-getinfo.c highlevel.c strequal.c strequal.h easy.c \
-security.h security.c krb4.c memdebug.c memdebug.h
+getinfo.c transfer.c strequal.c strequal.h easy.c \
+security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h
+
+noinst_HEADERS = setup.h transfer.h
 
 # Say $(srcdir), so GNU make does not report an ambiguity with the .y.c rule.
 $(srcdir)/getdate.c: getdate.y
 	cd $(srcdir) && \
 	  $(YACC) $(YFLAGS) getdate.y; \
 	  mv -f y.tab.c getdate.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.b32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.b32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.b32	2000-12-05 21:42:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.b32	2001-01-17 21:20:02.000000000 +0800
@@ -26,13 +26,13 @@
 
 .SUFFIXES: .c
 
 SOURCES	   = \
 	base64.c \
 	cookie.c \
-	download.c \
+	transfer.c \
 	escape.c \
 	formdata.c \
 	ftp.c \
 	http.c \
 	ldap.c \
 	dict.c \
@@ -51,13 +51,12 @@
 	timeval.c \
 	url.c \
 	file.c \
 	getinfo.c \
 	version.c \
 	easy.c \
-	highlevel.c \
 	strequal.c
 
 OBJECTS = $(SOURCES:.c=.obj)
 
 .c.obj:
 	$(CXX) -c $(INCDIRS) $(CXXFLAGS) $(DEFINES) $<
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.b32.resp /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.b32.resp
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.b32.resp	2000-12-05 21:42:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.b32.resp	2001-01-17 21:20:31.000000000 +0800
@@ -1,9 +1,9 @@
 +base64.obj &
 +cookie.obj &
-+download.obj &
++transfer.obj &
 +escape.obj &
 +formdata.obj &
 +ftp.obj &
 +http.obj &
 +ldap.obj &
 +dict.obj &
@@ -22,8 +22,7 @@
 +timeval.obj &
 +url.obj &
 +file.obj &
 +getinfo.obj &
 +version.obj &
 +easy.obj &
-+highlevel.obj &
 +strequal.obj
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.in	2001-01-04 21:57:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.in	2001-01-27 23:41:59.000000000 +0800
@@ -8,17 +8,17 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.13 2000/11/30 22:22:08 bagder Exp $
+# $Id: Makefile.am,v 1.16 2001/01/17 13:22:27 bagder Exp $
 #
 
 
-SHELL = /bin/sh
+SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 prefix = @prefix@
 exec_prefix = @exec_prefix@
@@ -76,12 +76,15 @@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign
 
+EXTRA_DIST = getdate.y        Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6        libcurl.def dllinit.c
+
+
 lib_LTLIBRARIES = libcurl.la
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
 
 INCLUDES = -I$(top_srcdir)/include
@@ -112,14 +115,16 @@
 # increment age.
 #
 # 6.If any interfaces have been removed since the last public release, then
 # set age to 0.
 #
 
-libcurl_la_SOURCES =  arpa_telnet.h  file.c         getpass.h      netrc.h        timeval.c base64.c       file.h         hostip.c       progress.c     timeval.h base64.h       formdata.c     hostip.h       progress.h     cookie.c       formdata.h     http.c         sendf.c        cookie.h       ftp.c          http.h         sendf.h        url.c dict.c         ftp.h          if2ip.c        speedcheck.c   url.h dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h download.c     getdate.h      ldap.c         ssluse.c       version.c download.h     getenv.c       ldap.h         ssluse.h       escape.c       getenv.h       mprintf.c      telnet.c       escape.h       getpass.c      netrc.c        telnet.h       getinfo.c highlevel.c strequal.c strequal.h easy.c security.h security.c krb4.c memdebug.c memdebug.h
+libcurl_la_SOURCES =  arpa_telnet.h  file.c         getpass.h      netrc.h        timeval.c base64.c       file.h         hostip.c       progress.c     timeval.h base64.h       formdata.c     hostip.h       progress.h     cookie.c       formdata.h     http.c         sendf.c        cookie.h       ftp.c          http.h         sendf.h        url.c dict.c         ftp.h          if2ip.c        speedcheck.c   url.h dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h getdate.h      ldap.c         ssluse.c       version.c getenv.c       ldap.h         ssluse.h       escape.c       getenv.h       mprintf.c      telnet.c       escape.h       getpass.c      netrc.c        telnet.h       getinfo.c transfer.c strequal.c strequal.h easy.c security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h
 
+
+noinst_HEADERS = setup.h transfer.h
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h ../src/config.h
 CONFIG_CLEAN_FILES = 
 LTLIBRARIES =  $(lib_LTLIBRARIES)
 
 
@@ -127,20 +132,22 @@
 CPPFLAGS = @CPPFLAGS@
 LDFLAGS = @LDFLAGS@
 LIBS = @LIBS@
 libcurl_la_LIBADD = 
 libcurl_la_OBJECTS =  file.lo timeval.lo base64.lo hostip.lo progress.lo \
 formdata.lo cookie.lo http.lo sendf.lo ftp.lo url.lo dict.lo if2ip.lo \
-speedcheck.lo getdate.lo download.lo ldap.lo ssluse.lo version.lo \
-getenv.lo escape.lo mprintf.lo telnet.lo getpass.lo netrc.lo getinfo.lo \
-highlevel.lo strequal.lo easy.lo security.lo krb4.lo memdebug.lo
+speedcheck.lo getdate.lo ldap.lo ssluse.lo version.lo getenv.lo \
+escape.lo mprintf.lo telnet.lo getpass.lo netrc.lo getinfo.lo \
+transfer.lo strequal.lo easy.lo security.lo krb4.lo memdebug.lo
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
+HEADERS =  $(noinst_HEADERS)
+
 DIST_COMMON =  Makefile.am Makefile.in
 
 
 DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
 
 TAR = gtar
@@ -285,13 +292,13 @@
 
 install-am: all-am
 	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
 install: install-am
 uninstall-am: uninstall-libLTLIBRARIES
 uninstall: uninstall-am
-all-am: Makefile $(LTLIBRARIES)
+all-am: Makefile $(LTLIBRARIES) $(HEADERS)
 all-redirect: all-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
 installdirs:
 	$(mkinstalldirs)  $(DESTDIR)$(libdir)
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.m32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.m32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.m32	2000-10-06 18:48:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.m32	2001-01-17 21:20:47.000000000 +0800
@@ -27,22 +27,22 @@
 libcurl_a_LIBRARIES = libcurl.a
 
 libcurl_a_SOURCES = arpa_telnet.h file.c getpass.h netrc.h timeval.c base64.c \
 	file.h hostip.c progress.c timeval.h base64.h formdata.c hostip.h progress.h	\
 	cookie.c formdata.h http.c sendf.c cookie.h ftp.c http.h sendf.h url.c dict.c	\
 	ftp.h if2ip.c speedcheck.c url.h dict.h getdate.c if2ip.h speedcheck.h		\
-	urldata.h download.c getdate.h ldap.c ssluse.c version.c download.h getenv.c	\
+	urldata.h transfer.c getdate.h ldap.c ssluse.c version.c transfer.h getenv.c	\
 	ldap.h ssluse.h escape.c getenv.h mprintf.c telnet.c escape.h getpass.c netrc.c	\
-	telnet.h getinfo.c highlevel.c strequal.c strequal.h easy.c security.h		\
+	telnet.h getinfo.c strequal.c strequal.h easy.c security.h		\
 	security.c krb4.c
 
 libcurl_a_OBJECTS =  file.o timeval.o base64.o hostip.o progress.o \
 	formdata.o cookie.o http.o sendf.o ftp.o url.o dict.o if2ip.o \
-	speedcheck.o getdate.o download.o ldap.o ssluse.o version.o \
+	speedcheck.o getdate.o transfer.o ldap.o ssluse.o version.o \
 	getenv.o escape.o mprintf.o telnet.o getpass.o netrc.o getinfo.o \
-	highlevel.o strequal.o easy.o security.o krb4.o
+	strequal.o easy.o security.o krb4.o
 
 LIBRARIES =  $(libcurl_a_LIBRARIES)
 SOURCES = $(libcurl_a_SOURCES)
 OBJECTS = $(libcurl_a_OBJECTS)
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.vc6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.vc6
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/Makefile.vc6	2000-12-11 16:12:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/Makefile.vc6	2001-01-17 21:21:35.000000000 +0800
@@ -30,13 +30,13 @@
 LINKLIBS = wsock32.lib
 LINKSLIBS = libeay32.lib ssleay32.lib RSAglue.lib
 
 RELEASE_OBJS= \
 	base64r.obj \
 	cookier.obj \
-	downloadr.obj \
+	transferr.obj \
 	escaper.obj \
 	formdatar.obj \
 	ftpr.obj \
 	httpr.obj \
 	ldapr.obj \
 	dictr.obj \
@@ -55,19 +55,18 @@
 	timevalr.obj \
 	urlr.obj \
 	filer.obj \
 	getinfor.obj \
 	versionr.obj \
 	easyr.obj \
-	highlevelr.obj \
 	strequalr.obj
 
 DEBUG_OBJS= \
 	base64d.obj \
 	cookied.obj \
-	downloadd.obj \
+	transferd.obj \
 	escaped.obj \
 	formdatad.obj \
 	ftpd.obj \
 	httpd.obj \
 	ldapd.obj \
 	dictd.obj \
@@ -86,19 +85,18 @@
 	timevald.obj \
 	urld.obj \
 	filed.obj \
 	getinfod.obj \
 	versiond.obj  \
 	easyd.obj \
-	highleveld.obj \
 	strequald.obj
 
 RELEASE_SSL_OBJS= \
 	base64rs.obj \
 	cookiers.obj \
-	downloadrs.obj \
+	transferrs.obj \
 	escapers.obj \
 	formdatars.obj \
 	ftprs.obj \
 	httprs.obj \
 	ldaprs.obj \
 	dictrs.obj \
@@ -117,19 +115,18 @@
 	timevalrs.obj \
 	urlrs.obj \
 	filers.obj \
 	getinfors.obj \
 	versionrs.obj \
 	easyrs.obj \
-	highlevelrs.obj \
 	strequalrs.obj
 
 LINK_OBJS= \
 	base64.obj \
 	cookie.obj \
-	download.obj \
+	transfer.obj \
 	escape.obj \
 	formdata.obj \
 	ftp.obj \
 	http.obj \
 	ldap.obj \
 	dict.obj \
@@ -148,13 +145,12 @@
 	timeval.obj \
 	url.obj \
 	file.obj \
 	getinfo.obj \
 	version.obj \
 	easy.obj \
-	highlevel.obj \
 	strequal.obj
 
 all : release
 
 release: $(RELEASE_OBJS)
 	$(LINKR) $(LFLAGS) $(LINKLIBS) $(LINK_OBJS)
@@ -167,14 +163,14 @@
 
 ## Release
 base64r.obj: base64.c
 	$(CCR) $(CFLAGS) base64.c
 cookier.obj: cookie.c
 	$(CCR) $(CFLAGS) cookie.c
-downloadr.obj: download.c
-	$(CCR) $(CFLAGS) download.c
+transferr.obj: transfer.c
+	$(CCR) $(CFLAGS) transfer.c
 escaper.obj: escape.c
 	$(CCR) $(CFLAGS) escape.c
 formdatar.obj: formdata.c
 	$(CCR) $(CFLAGS) formdata.c
 ftpr.obj: ftp.c
 	$(CCR) $(CFLAGS) ftp.c
@@ -217,24 +213,22 @@
 getinfor.obj: getinfo.c
 	$(CCR) $(CFLAGS) getinfo.c
 versionr.obj: version.c
 	$(CCR) $(CFLAGS) version.c
 easyr.obj: easy.c
 	$(CCR) $(CFLAGS) easy.c
-highlevelr.obj: highlevel.c
-	$(CCR) $(CFLAGS) highlevel.c
 strequalr.obj: strequal.c
 	$(CCR) $(CFLAGS) strequal.c
 
 ## Debug
 base64d.obj: base64.c
 	$(CCD) $(CFLAGS) base64.c
 cookied.obj: cookie.c
 	$(CCD) $(CFLAGS) cookie.c
-downloadd.obj: download.c
-	$(CCD) $(CFLAGS) download.c
+transferd.obj: transfer.c
+	$(CCD) $(CFLAGS) transfer.c
 escaped.obj: escape.c
 	$(CCD) $(CFLAGS) escape.c
 formdatad.obj: formdata.c
 	$(CCD) $(CFLAGS) formdata.c
 ftpd.obj: ftp.c
 	$(CCD) $(CFLAGS) ftp.c
@@ -277,25 +271,23 @@
 getinfod.obj: getinfo.c
 	$(CCD) $(CFLAGS) getinfo.c
 versiond.obj: version.c
 	$(CCD) $(CFLAGS) version.c
 easyd.obj: easy.c
 	$(CCD) $(CFLAGS) easy.c
-highleveld.obj: highlevel.c
-	$(CCD) $(CFLAGS) highlevel.c
 strequald.obj: strequal.c
 	$(CCD) $(CFLAGS) strequal.c
 
 
 ## Release SSL
 base64rs.obj: base64.c
 	$(CCRS) $(CFLAGS) base64.c
 cookiers.obj: cookie.c
 	$(CCRS) $(CFLAGS) cookie.c
-downloadrs.obj: download.c
-	$(CCRS) $(CFLAGS) download.c
+transferrs.obj: transfer.c
+	$(CCRS) $(CFLAGS) transfer.c
 escapers.obj: escape.c
 	$(CCRS) $(CFLAGS) escape.c
 formdatars.obj: formdata.c
 	$(CCRS) $(CFLAGS) formdata.c
 ftprs.obj: ftp.c
 	$(CCRS) $(CFLAGS) ftp.c
@@ -338,14 +330,12 @@
 getinfors.obj: getinfo.c
 	$(CCRS) $(CFLAGS) getinfo.c
 versionrs.obj: version.c
 	$(CCRS) $(CFLAGS) version.c
 easyrs.obj: easy.c
 	$(CCRS) $(CFLAGS) easy.c
-highlevelrs.obj: highlevel.c
-	$(CCRS) $(CFLAGS) highlevel.c
 strequalrs.obj: strequal.c
 	$(CCRS) $(CFLAGS) strequal.c
 
 
 clean:
 	-@erase *.obj
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/memdebug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/memdebug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/memdebug.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/memdebug.c	2001-01-05 18:11:42.000000000 +0800
@@ -16,13 +16,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: memdebug.c,v 1.10 2001/01/03 09:29:34 bagder Exp $
+ * $Id: memdebug.c,v 1.11 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
@@ -132,13 +132,13 @@
 /* this is our own defined way to close sockets on *ALL* platforms */
 int curl_sclose(int sockfd, int line, char *source)
 {
   int res=sclose(sockfd);
   fprintf(logfile?logfile:stderr, "FD %s:%d sclose(%d)\n",
           source, line, sockfd);
-  return sockfd;
+  return res;
 }
 
 FILE *curl_fopen(char *file, char *mode, int line, char *source)
 {
   FILE *res=(fopen)(file, mode);
   fprintf(logfile?logfile:stderr, "FILE %s:%d fopen(\"%s\") = %p\n",
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/mprintf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/mprintf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/mprintf.c	2001-01-04 20:27:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/mprintf.c	2001-01-05 20:19:42.000000000 +0800
@@ -1,9 +1,9 @@
 /****************************************************************************
  *
- * $Id: mprintf.c,v 1.6 2001/01/04 12:27:04 bagder Exp $
+ * $Id: mprintf.c,v 1.8 2001/01/05 12:19:42 bagder Exp $
  *
  *************************************************************************
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
  * copyright notice and this permission notice appear in all copies.
@@ -89,13 +89,13 @@
  * - Fixed space padding (i.e %d was extra padded previously)
  * - long long output is supported
  * - alternate output is done correct like in %#08x
  *
  ****************************************************************************/
 
-static const char rcsid[] = "@(#)$Id: mprintf.c,v 1.6 2001/01/04 12:27:04 bagder Exp $";
+static const char rcsid[] = "@(#)$Id: mprintf.c,v 1.8 2001/01/05 12:19:42 bagder Exp $";
 
 /*
  * To test:
  *
  * Use WIDTH, PRECISION and NUMBERED ARGUMENT combined.
  */
@@ -204,13 +204,13 @@
 struct asprintf {
   char *buffer; /* allocated buffer */
   size_t len;   /* length of string */
   size_t alloc; /* length of alloc */
 };
 
-int msprintf(char *buffer, const char *format, ...);
+int curl_msprintf(char *buffer, const char *format, ...);
 
 static int dprintf_DollarString(char *input, char **end)
 {
   int number=0;
   while(isdigit((int)*input)) {
     number *= 10;
@@ -952,17 +952,17 @@
 	  strcat(formatbuf, "#");
 
 	fptr=&formatbuf[strlen(formatbuf)];
 
 	if(width >= 0) {
 	  /* RECURSIVE USAGE */
-	  fptr += msprintf(fptr, "%d", width);
+	  fptr += curl_msprintf(fptr, "%d", width);
 	}
 	if(prec >= 0) {
 	  /* RECURSIVE USAGE */
-	  fptr += msprintf(fptr, ".%d", prec);
+	  fptr += curl_msprintf(fptr, ".%d", prec);
 	}
 	if (p->flags & FLAGS_LONG)
 	  strcat(fptr, "l");
 
 	if (p->flags & FLAGS_FLOATE)
 	  strcat(fptr, p->flags&FLAGS_UPPER?"E":"e");
@@ -1022,13 +1022,13 @@
     infop->length++; /* we are now one byte larger */
     return output; /* fputc() returns like this on success */
   }
   return -1;
 }
 
-int msnprintf(char *buffer, size_t maxlength, const char *format, ...)
+int curl_msnprintf(char *buffer, size_t maxlength, const char *format, ...)
 {
   va_list ap_save; /* argument pointer */
   int retcode;
   struct nsprintf info;
 
   info.buffer = buffer;
@@ -1042,13 +1042,13 @@
 
   /* we could even return things like */
   
   return retcode;
 }
 
-int mvsnprintf(char *buffer, size_t maxlength, const char *format, va_list ap_save)
+int curl_mvsnprintf(char *buffer, size_t maxlength, const char *format, va_list ap_save)
 {
   int retcode;
   struct nsprintf info;
 
   info.buffer = buffer;
   info.length = 0;
@@ -1089,13 +1089,13 @@
   infop->len++;
 
   return output; /* fputc() returns like this on success */
 
 }
 
-char *maprintf(const char *format, ...)
+char *curl_maprintf(const char *format, ...)
 {
   va_list ap_save; /* argument pointer */
   int retcode;
   struct asprintf info;
 
   info.buffer = NULL;
@@ -1110,13 +1110,13 @@
     return info.buffer;
   }
   else
     return NULL;
 }
 
-char *mvaprintf(const char *format, va_list ap_save)
+char *curl_mvaprintf(const char *format, va_list ap_save)
 {
   int retcode;
   struct asprintf info;
 
   info.buffer = NULL;
   info.len = 0;
@@ -1137,59 +1137,59 @@
   char **buffer = (char **)data;
   **buffer = (char)output;
   (*buffer)++;
   return output; /* act like fputc() ! */
 }
 
-int msprintf(char *buffer, const char *format, ...)
+int curl_msprintf(char *buffer, const char *format, ...)
 {
   va_list ap_save; /* argument pointer */
   int retcode;
   va_start(ap_save, format);
   retcode = dprintf_formatf(&buffer, storebuffer, format, ap_save);
   va_end(ap_save);
   *buffer=0; /* we terminate this with a zero byte */
   return retcode;
 }
 
 extern int fputc(int, FILE *);
 
-int mprintf(const char *format, ...)
+int curl_mprintf(const char *format, ...)
 {
   int retcode;
   va_list ap_save; /* argument pointer */
   va_start(ap_save, format);
   retcode = dprintf_formatf(stdout, fputc, format, ap_save);
   va_end(ap_save);
   return retcode;
 }
 
-int mfprintf(FILE *whereto, const char *format, ...)
+int curl_mfprintf(FILE *whereto, const char *format, ...)
 {
   int retcode;
   va_list ap_save; /* argument pointer */
   va_start(ap_save, format);
   retcode = dprintf_formatf(whereto, fputc, format, ap_save);
   va_end(ap_save);
   return retcode;
 }
 
-int mvsprintf(char *buffer, const char *format, va_list ap_save)
+int curl_mvsprintf(char *buffer, const char *format, va_list ap_save)
 {
   int retcode;
   retcode = dprintf_formatf(&buffer, storebuffer, format, ap_save);
   *buffer=0; /* we terminate this with a zero byte */
   return retcode;
 }
 
-int mvprintf(const char *format, va_list ap_save)
+int curl_mvprintf(const char *format, va_list ap_save)
 {
   return dprintf_formatf(stdout, fputc, format, ap_save);
 }
 
-int mvfprintf(FILE *whereto, const char *format, va_list ap_save)
+int curl_mvfprintf(FILE *whereto, const char *format, va_list ap_save)
 {
   return dprintf_formatf(whereto, fputc, format, ap_save);
 }
 
 #ifdef DPRINTF_DEBUG
 int main()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/netrc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/netrc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/netrc.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/netrc.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: netrc.c,v 1.7 2001/01/03 09:29:34 bagder Exp $
+ * $Id: netrc.c,v 1.8 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -48,21 +48,21 @@
 };
 
 /* make sure we have room for at least this size: */
 #define LOGINSIZE 64
 #define PASSWORDSIZE 64
 
-int ParseNetrc(char *host,
-	       char *login,
-	       char *password)
+int Curl_parsenetrc(char *host,
+                    char *login,
+                    char *password)
 {
   FILE *file;
   char netrcbuffer[256];
   int retcode=1;
   
-  char *home = GetEnv("HOME"); /* portable environment reader */
+  char *home = curl_getenv("HOME"); /* portable environment reader */
   int state=NOTHING;
 
   char state_login=0;
   char state_password=0;
 
 #define NETRC DOT_CHAR "netrc"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/netrc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/netrc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/netrc.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/netrc.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,12 +17,12 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: netrc.h,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: netrc.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
-int ParseNetrc(char *host,
-	       char *login,
-	       char *password);
+int Curl_parsenetrc(char *host,
+                    char *login,
+                    char *password);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/progress.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/progress.c	2001-01-25 20:32:40.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: progress.c,v 1.19 2001/01/03 09:29:34 bagder Exp $
+ * $Id: progress.c,v 1.22 2001/01/25 12:32:40 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
@@ -42,23 +42,23 @@
 #include <curl/curl.h>
 #include "urldata.h"
 #include "sendf.h"
 
 #include "progress.h"
 
-void time2str(char *r, int t)
+static void time2str(char *r, int t)
 {
   int h = (t/3600);
   int m = (t-(h*3600))/60;
   int s = (t-(h*3600)-(m*60));
   sprintf(r,"%2d:%02d:%02d",h,m,s);
 }
 
 /* The point of this function would be to return a string of the input data,
    but never longer than 5 columns. Add suffix k, M, G when suitable... */
-char *max5data(double bytes, char *max5)
+static char *max5data(double bytes, char *max5)
 {
 #define ONE_KILOBYTE 1024
 #define ONE_MEGABYTE (1024*1024)
 
   if(bytes < 100000) {
     sprintf(max5, "%5d", (int)bytes);
@@ -88,77 +88,77 @@
    pgrsSetUploadCounter() - amount of data currently uploaded
    pgrsUpdate() - show progress
    pgrsDone() - transfer complete
 
 */
 
-void pgrsDone(struct UrlData *data)
+void Curl_pgrsDone(struct UrlData *data)
 {
   if(!(data->progress.flags & PGRS_HIDE)) {
     data->progress.lastshow=0;
-    pgrsUpdate(data); /* the final (forced) update */
+    Curl_pgrsUpdate(data); /* the final (forced) update */
     fprintf(data->err, "\n");
   }
 }
 
-void pgrsTime(struct UrlData *data, timerid timer)
+void Curl_pgrsTime(struct UrlData *data, timerid timer)
 {
   switch(timer) {
   default:
   case TIMER_NONE:
     /* mistake filter */
     break;
   case TIMER_STARTSINGLE:
     /* This is set at the start of a single fetch, there may be several
        fetches within an operation, why we add all other times relative
        to this one */
-    data->progress.t_startsingle = tvnow();
+    data->progress.t_startsingle = Curl_tvnow();
     break;
 
   case TIMER_NAMELOOKUP:
-    data->progress.t_nslookup += tvdiff(tvnow(),
+    data->progress.t_nslookup += Curl_tvdiff(Curl_tvnow(),
                                         data->progress.t_startsingle);
     break;
   case TIMER_CONNECT:
-    data->progress.t_connect += tvdiff(tvnow(),
+    data->progress.t_connect += Curl_tvdiff(Curl_tvnow(),
                                        data->progress.t_startsingle);
     break;
   case TIMER_PRETRANSFER:
-    data->progress.t_pretransfer += tvdiff(tvnow(),
+    data->progress.t_pretransfer += Curl_tvdiff(Curl_tvnow(),
                                            data->progress.t_startsingle);
     break;
   case TIMER_POSTRANSFER:
     /* this is the normal end-of-transfer thing */
     break;
   }
 }
 
-void pgrsStartNow(struct UrlData *data)
+void Curl_pgrsStartNow(struct UrlData *data)
 {
-  data->progress.start = tvnow();
+  data->progress.start = Curl_tvnow();
 }
 
-void pgrsSetDownloadCounter(struct UrlData *data, double size)
+void Curl_pgrsSetDownloadCounter(struct UrlData *data, double size)
 {
   data->progress.downloaded = size;
 }
 
-void pgrsSetUploadCounter(struct UrlData *data, double size)
+void Curl_pgrsSetUploadCounter(struct UrlData *data, double size)
 {
   data->progress.uploaded = size;
 }
 
-void pgrsSetDownloadSize(struct UrlData *data, double size)
+void Curl_pgrsSetDownloadSize(struct UrlData *data, double size)
 {
   if(size > 0) {
     data->progress.size_dl = size;
     data->progress.flags |= PGRS_DL_SIZE_KNOWN;
   }
 }
 
-void pgrsSetUploadSize(struct UrlData *data, double size)
+void Curl_pgrsSetUploadSize(struct UrlData *data, double size)
 {
   if(size > 0) {
     data->progress.size_ul = size;
     data->progress.flags |= PGRS_UL_SIZE_KNOWN;
   }
 }
@@ -168,13 +168,13 @@
   % Total    % Received % Xferd  Average Speed          Time             Curr.
                                  Dload  Upload Total    Current  Left    Speed
 100 12345  100 12345  100 12345  12345  12345 12:12:12 12:12:12 12:12:12 12345
 
  */
 
-int pgrsUpdate(struct UrlData *data)
+int Curl_pgrsUpdate(struct UrlData *data)
 {
   struct timeval now;
   int result;
 
   char max5[6][10];
   double dlpercen=0;
@@ -207,22 +207,22 @@
               "  %% Total    %% Received %% Xferd  Average Speed          Time             Curr.\n"
               "                                 Dload  Upload Total    Current  Left    Speed\n");
     }
     data->progress.flags |= PGRS_HEADERS_OUT; /* headers are shown */
   }
 
-  now = tvnow(); /* what time is it */
+  now = Curl_tvnow(); /* what time is it */
 
-  if(data->progress.lastshow == tvlong(now))
+  /* The exact time spent so far */
+  data->progress.timespent = Curl_tvdiff (now, data->progress.start);
+
+  if(data->progress.lastshow == Curl_tvlong(now))
     return 0; /* never update this more than once a second if the end isn't 
                  reached */
   data->progress.lastshow = now.tv_sec;
 
-  /* The exact time spent so far */
-  data->progress.timespent = tvdiff (now, data->progress.start);
-
   /* The average download speed this far */
   data->progress.dlspeed = data->progress.downloaded/(data->progress.timespent!=0.0?data->progress.timespent:1.0);
 
   /* The average upload speed this far */
   data->progress.ulspeed = data->progress.uploaded/(data->progress.timespent!=0.0?data->progress.timespent:1.0);
 
@@ -254,23 +254,19 @@
     if(result)
       failf(data, "Callback aborted");
     return result;
   }
 
       /* Figure out the estimated time of arrival for the upload */
-  if(data->progress.flags & PGRS_UL_SIZE_KNOWN) {
-    if(!data->progress.ulspeed)
-      data->progress.ulspeed=1;
+  if((data->progress.flags & PGRS_UL_SIZE_KNOWN) && data->progress.ulspeed){
     ulestimate = data->progress.size_ul / data->progress.ulspeed;
     ulpercen = (data->progress.uploaded / data->progress.size_ul)*100;
   }
 
   /* ... and the download */
-  if(data->progress.flags & PGRS_DL_SIZE_KNOWN) {
-    if(!data->progress.dlspeed)
-      data->progress.dlspeed=1;
+  if((data->progress.flags & PGRS_DL_SIZE_KNOWN) && data->progress.dlspeed) {
     dlestimate = data->progress.size_dl / data->progress.dlspeed;
     dlpercen = (data->progress.downloaded / data->progress.size_dl)*100;
   }
     
   /* Now figure out which of them that is slower and use for the for
          total estimate! */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/progress.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/progress.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/progress.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/progress.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: progress.h,v 1.10 2001/01/03 09:29:34 bagder Exp $
+ * $Id: progress.h,v 1.11 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "timeval.h"
 
 
 typedef enum {
@@ -33,20 +33,20 @@
   TIMER_PRETRANSFER,
   TIMER_POSTRANSFER,
   TIMER_STARTSINGLE,
   TIMER_LAST /* must be last */
 } timerid;
   
-void pgrsDone(struct UrlData *data);
-void pgrsStartNow(struct UrlData *data);
-void pgrsSetDownloadSize(struct UrlData *data, double size);
-void pgrsSetUploadSize(struct UrlData *data, double size);
-void pgrsSetDownloadCounter(struct UrlData *data, double size);
-void pgrsSetUploadCounter(struct UrlData *data, double size);
-int pgrsUpdate(struct UrlData *data);
-void pgrsTime(struct UrlData *data, timerid timer);
+void Curl_pgrsDone(struct UrlData *data);
+void Curl_pgrsStartNow(struct UrlData *data);
+void Curl_pgrsSetDownloadSize(struct UrlData *data, double size);
+void Curl_pgrsSetUploadSize(struct UrlData *data, double size);
+void Curl_pgrsSetDownloadCounter(struct UrlData *data, double size);
+void Curl_pgrsSetUploadCounter(struct UrlData *data, double size);
+int Curl_pgrsUpdate(struct UrlData *data);
+void Curl_pgrsTime(struct UrlData *data, timerid timer);
 
 
 /* Don't show progress for sizes smaller than: */
 #define LEAST_SIZE_PROGRESS BUFSIZE
 
 #define PROGRESS_DOWNLOAD (1<<0)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/security.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/security.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/security.c	2000-10-09 16:49:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/security.c	2001-01-05 17:55:09.000000000 +0800
@@ -37,19 +37,28 @@
  */
 
 #include "setup.h"
 
 #ifdef KRB4
 
+#define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "security.h"
 #include <stdlib.h>
 #include <string.h>
 #include <netdb.h>
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
 #include "base64.h"
+#include "sendf.h"
+#include "ftp.h"
+
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 #define min(a, b)   ((a) < (b) ? (a) : (b))
@@ -61,21 +70,23 @@
     { prot_clear, "clear" },
     { prot_safe, "safe" },
     { prot_confidential, "confidential" },
     { prot_private, "private" }
 };
 
+#if 0
 static const char *
 level_to_name(enum protection_level level)
 {
     int i;
     for(i = 0; i < sizeof(level_names) / sizeof(level_names[0]); i++)
 	if(level_names[i].level == level)
 	    return level_names[i].name;
     return "unknown";
 }
+#endif
 
 #ifndef FTP_SERVER /* not used in server */
 static enum protection_level 
 name_to_level(const char *name)
 {
     int i;
@@ -316,13 +327,13 @@
 {
   char *buf;
   int ret;
   if(conn->data_prot == prot_clear)
     return vfprintf(f, fmt, ap);
   else {
-    buf = maprintf(fmt, ap);
+    buf = aprintf(fmt, ap);
     ret = buffer_write(&conn->out_buffer, buf, strlen(buf));
     free(buf);
     return ret;
   }
 }
 
@@ -357,13 +368,13 @@
 {
     int len;
     char *buf;
     int code;
     
     buf = malloc(strlen(s));
-    len = base64_decode(s + 4, buf); /* XXX */
+    len = Curl_base64_decode(s + 4, buf); /* XXX */
     
     len = (*mech->decode)(conn->app_data, buf, len, level, conn);
     if(len < 0)
 	return -1;
     
     buf[len] = '\0';
@@ -387,22 +398,22 @@
     char *buf;
     void *enc;
     int len;
     if(!conn->sec_complete)
 	return vfprintf(f, fmt, ap);
     
-    buf = maprintf(fmt, ap);
+    buf = aprintf(fmt, ap);
     len = (*mech->encode)(conn->app_data, buf, strlen(buf),
                           conn->command_prot, &enc,
 			  conn);
     free(buf);
     if(len < 0) {
 	failf(conn->data, "Failed to encode command.\n");
 	return -1;
     }
-    if(base64_encode(enc, len, &buf) < 0){
+    if(Curl_base64_encode(enc, len, &buf) < 0){
       failf(conn->data, "Out of memory base64-encoding.\n");
       return -1;
     }
 #ifdef FTP_SERVER
     if(command_prot == prot_safe)
 	fprintf(f, "631 %s\r\n", buf);
@@ -458,28 +469,27 @@
 }
 #endif
 
 static int
 sec_prot_internal(struct connectdata *conn, int level)
 {
-    int ret;
     char *p;
     unsigned int s = 1048576;
     size_t nread;
 
     if(!conn->sec_complete){
       infof(conn->data, "No security data exchange has taken place.\n");
       return -1;
     }
 
     if(level){
-      ftpsendf(conn->data->firstsocket, conn,
-               "PBSZ %u", s);
+      Curl_ftpsendf(conn->data->firstsocket, conn,
+                    "PBSZ %u", s);
       /* wait for feedback */
-      nread = GetLastResponse(conn->data->firstsocket,
-                              conn->data->buffer, conn);
+      nread = Curl_GetFTPResponse(conn->data->firstsocket,
+                                  conn->data->buffer, conn, NULL);
       if(nread < 0)
         return /*CURLE_OPERATION_TIMEOUTED*/-1;
       if(/*ret != COMPLETE*/conn->data->buffer[0] != '2'){
         failf(conn->data, "Failed to set protection buffer size.\n");
         return -1;
       }
@@ -488,17 +498,17 @@
       if(p)
         sscanf(p, "PBSZ=%u", &s);
       if(s < conn->buffer_size)
         conn->buffer_size = s;
     }
 
-    ftpsendf(conn->data->firstsocket, conn,
-             "PROT %c", level["CSEP"]);
+    Curl_ftpsendf(conn->data->firstsocket, conn,
+                  "PROT %c", level["CSEP"]);
     /* wait for feedback */
-    nread = GetLastResponse(conn->data->firstsocket,
-			    conn->data->buffer, conn);
+    nread = Curl_GetFTPResponse(conn->data->firstsocket,
+                                conn->data->buffer, conn, NULL);
     if(nread < 0)
       return /*CURLE_OPERATION_TIMEOUTED*/-1;
     if(/*ret != COMPLETE*/conn->data->buffer[0] != '2'){
       failf(conn->data, "Failed to set protection level.\n");
       return -1;
     }
@@ -597,17 +607,17 @@
 	if((*m)->init && (*(*m)->init)(conn->app_data) != 0) {
 	    infof(data, "Skipping %s...\n", (*m)->name);
 	    continue;
 	}
 	infof(data, "Trying %s...\n", (*m)->name);
 	/*ret = command("AUTH %s", (*m)->name);***/
-	ftpsendf(conn->data->firstsocket, conn,
+	Curl_ftpsendf(conn->data->firstsocket, conn,
                  "AUTH %s", (*m)->name);
 	/* wait for feedback */
-	nread = GetLastResponse(conn->data->firstsocket,
-				conn->data->buffer, conn);
+	nread = Curl_GetFTPResponse(conn->data->firstsocket,
+                                    conn->data->buffer, conn, NULL);
 	if(nread < 0)
 	    return /*CURLE_OPERATION_TIMEOUTED*/-1;
 	if(/*ret != CONTINUE*/conn->data->buffer[0] != '3'){
 	    if(/*code == 504*/strncmp(conn->data->buffer,"504",3) == 0) {
 		infof(data,
                       "%s is not supported by the server.\n", (*m)->name);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/sendf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/sendf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/sendf.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/sendf.c	2001-01-25 20:20:30.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.c,v 1.15 2001/01/03 09:29:34 bagder Exp $
+ * $Id: sendf.c,v 1.17 2001/01/25 12:20:30 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -49,13 +49,13 @@
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 /* infof() is for info message along the way */
 
-void infof(struct UrlData *data, char *fmt, ...)
+void Curl_infof(struct UrlData *data, char *fmt, ...)
 {
   va_list ap;
   if(data->bits.verbose) {
     va_start(ap, fmt);
     fputs("* ", data->err);
     vfprintf(data->err, fmt, ap);
@@ -63,120 +63,113 @@
   }
 }
 
 /* failf() is for messages stating why we failed, the LAST one will be
    returned for the user (if requested) */
 
-void failf(struct UrlData *data, char *fmt, ...)
+void Curl_failf(struct UrlData *data, char *fmt, ...)
 {
   va_list ap;
   va_start(ap, fmt);
   if(data->errorbuffer)
     vsnprintf(data->errorbuffer, CURL_ERROR_SIZE, fmt, ap);
   else /* no errorbuffer receives this, write to data->err instead */
     vfprintf(data->err, fmt, ap);
   va_end(ap);
 }
 
-/* sendf() sends the formated data to the server */
-size_t sendf(int fd, struct UrlData *data, char *fmt, ...)
+/* Curl_sendf() sends formated data to the server */
+size_t Curl_sendf(int sockfd, struct connectdata *conn,
+                  char *fmt, ...)
 {
+  struct UrlData *data = conn->data;
   size_t bytes_written;
   char *s;
   va_list ap;
   va_start(ap, fmt);
-  s = mvaprintf(fmt, ap);
+  s = vaprintf(fmt, ap); /* returns an allocated string */
   va_end(ap);
   if(!s)
     return 0; /* failure */
   if(data->bits.verbose)
     fprintf(data->err, "> %s", s);
 
-#ifndef USE_SSLEAY
-  bytes_written = swrite(fd, s, strlen(s));
-#else /* USE_SSLEAY */
-  if (data->ssl.use) {
-    bytes_written = SSL_write(data->ssl.handle, s, strlen(s));
-  } else {
-    bytes_written = swrite(fd, s, strlen(s));
-  }
-#endif /* USE_SSLEAY */
+  /* Write the buffer to the socket */
+  Curl_write(conn, sockfd, s, strlen(s), &bytes_written);
+
   free(s); /* free the output string */
-  return(bytes_written);
+
+  return bytes_written;
 }
 
 /*
- * ftpsendf() sends the formated string as a ftp command to a ftp server
- *
- * NOTE: we build the command in a fixed-length buffer, which sets length
- * restrictions on the command!
+ * Curl_write() is an internal write function that sends plain (binary) data
+ * to the server. Works with plain sockets, SSL or kerberos.
  *
  */
-size_t ftpsendf(int fd, struct connectdata *conn, char *fmt, ...)
-{
-  size_t bytes_written;
-  char s[256];
-
-  va_list ap;
-  va_start(ap, fmt);
-  vsnprintf(s, 250, fmt, ap);
-  va_end(ap);
-
-  if(conn->data->bits.verbose)
-    fprintf(conn->data->err, "> %s\n", s);
-
-  strcat(s, "\r\n"); /* append a trailing CRLF */
-
-#ifdef KRB4
-  if(conn->sec_complete && conn->data->cmdchannel) {
-    bytes_written = sec_fprintf(conn, conn->data->cmdchannel, s);
-    fflush(conn->data->cmdchannel);
-  }
-  else
-#endif /* KRB4 */
-    {
-      bytes_written = swrite(fd, s, strlen(s));
-    }
-  return(bytes_written);
-}
-
-/* ssend() sends plain (binary) data to the server */
-size_t ssend(int fd, struct connectdata *conn, void *mem, size_t len)
+CURLcode Curl_write(struct connectdata *conn, int sockfd,
+                    void *mem, size_t len,
+                    size_t *written)
 {
   size_t bytes_written;
   struct UrlData *data=conn->data; /* conn knows data, not vice versa */
 
 #ifdef USE_SSLEAY
   if (data->ssl.use) {
-    bytes_written = SSL_write(data->ssl.handle, mem, len);
+    int loop=100; /* just a precaution to never loop endlessly */
+    while(loop--) {
+      bytes_written = SSL_write(data->ssl.handle, mem, len);
+      if((-1 != bytes_written) ||
+         (SSL_ERROR_WANT_WRITE != SSL_get_error(data->ssl.handle,
+                                                bytes_written) ))
+        break;
+    }
   }
   else {
 #endif
 #ifdef KRB4
     if(conn->sec_complete) {
-      bytes_written = sec_write(conn, fd, mem, len);
+      bytes_written = sec_write(conn, sockfd, mem, len);
     }
     else
 #endif /* KRB4 */
-      bytes_written = swrite(fd, mem, len);
+      bytes_written = swrite(sockfd, mem, len);
 #ifdef USE_SSLEAY
   }
 #endif
 
-  return bytes_written;
+  *written = bytes_written;
+  return CURLE_OK;
 }
 
+/*
+ * External write-function, writes to the data-socket.
+ * Takes care of plain sockets, SSL or kerberos transparently.
+ */
+CURLcode curl_write(CURLconnect *c_conn, char *buf, size_t amount,
+                   size_t *n)
+{
+  struct connectdata *conn = (struct connectdata *)c_conn;
+
+  if(!n || !conn || (conn->handle != STRUCT_CONNECT))
+    return CURLE_FAILED_INIT;
+
+  return Curl_write(conn, conn->sockfd, buf, amount, n);
+}
+
+
+
 /* client_write() sends data to the write callback(s)
 
    The bit pattern defines to what "streams" to write to. Body and/or header.
    The defines are in sendf.h of course.
  */
-CURLcode client_write(struct UrlData *data,
-                      int type,
-                      char *ptr,
-                      size_t len)
+CURLcode Curl_client_write(struct UrlData *data,
+                           int type,
+                           char *ptr,
+                           size_t len)
 {
   size_t wrote;
 
   if(0 == len)
     len = strlen(ptr);
 
@@ -197,93 +190,57 @@
   
   return CURLE_OK;
 }
 
 
 /*
- * add_buffer_init() returns a fine buffer struct
+ * Internal read-from-socket function. This is meant to deal with plain
+ * sockets, SSL sockets and kerberos sockets.
  */
-send_buffer *add_buffer_init(void)
+CURLcode Curl_read(struct connectdata *conn, int sockfd,
+                   char *buf, size_t buffersize,
+                   size_t *n)
 {
-  send_buffer *blonk;
-  blonk=(send_buffer *)malloc(sizeof(send_buffer));
-  if(blonk) {
-    memset(blonk, 0, sizeof(send_buffer));
-    return blonk;
-  }
-  return NULL; /* failed, go home */
-}
+  struct UrlData *data = conn->data;
+  size_t nread;
 
-/*
- * add_buffer_send() sends a buffer and frees all associated memory.
- */
-size_t add_buffer_send(int sockfd, struct connectdata *conn, send_buffer *in)
-{
-  size_t amount;
-  if(conn->data->bits.verbose) {
-    fputs("> ", conn->data->err);
-    /* this data _may_ contain binary stuff */
-    fwrite(in->buffer, in->size_used, 1, conn->data->err);
+#ifdef USE_SSLEAY
+  if (data->ssl.use) {
+    int loop=100; /* just a precaution to never loop endlessly */
+    while(loop--) {
+      nread = SSL_read(data->ssl.handle, buf, buffersize);
+      if((-1 != nread) ||
+         (SSL_ERROR_WANT_READ != SSL_get_error(data->ssl.handle, nread) ))
+        break;
+    }
   }
-
-  amount = ssend(sockfd, conn, in->buffer, in->size_used);
-
-  if(in->buffer)
-    free(in->buffer);
-  free(in);
-
-  return amount;
-}
-
-
-/* 
- * add_bufferf() builds a buffer from the formatted input
- */
-CURLcode add_bufferf(send_buffer *in, char *fmt, ...)
-{
-  CURLcode result = CURLE_OUT_OF_MEMORY;
-  char *s;
-  va_list ap;
-  va_start(ap, fmt);
-  s = mvaprintf(fmt, ap); /* this allocs a new string to append */
-  va_end(ap);
-
-  if(s) {
-    result = add_buffer(in, s, strlen(s));
-    free(s);
+  else {
+#endif
+#ifdef KRB4
+    if(conn->sec_complete)
+      nread = sec_read(conn, sockfd, buf, buffersize);
+    else
+#endif
+      nread = sread (sockfd, buf, buffersize);
+#ifdef USE_SSLEAY
   }
-  return result;
+#endif /* USE_SSLEAY */
+  *n = nread;
+  return CURLE_OK;
 }
 
 /*
- * add_buffer() appends a memory chunk to the existing one
+ * The public read function reads from the 'sockfd' file descriptor only.
+ * Use the Curl_read() internally when you want to specify fd.
  */
-CURLcode add_buffer(send_buffer *in, void *inptr, size_t size)
-{
-  char *new_rb;
-  int new_size;
-
-  if(size > 0) {
-    if(!in->buffer ||
-       ((in->size_used + size) > (in->size_max - 1))) {
-      new_size = (in->size_used+size)*2;
-      if(in->buffer)
-        /* we have a buffer, enlarge the existing one */
-        new_rb = (char *)realloc(in->buffer, new_size);
-      else
-        /* create a new buffer */
-        new_rb = (char *)malloc(new_size);
 
-      if(!new_rb)
-        return CURLE_OUT_OF_MEMORY;
+CURLcode curl_read(CURLconnect *c_conn, char *buf, size_t buffersize,
+                   size_t *n)
+{
+  struct connectdata *conn = (struct connectdata *)c_conn;
 
-      in->buffer = new_rb;
-      in->size_max = new_size;
-    }
-    memcpy(&in->buffer[in->size_used], inptr, size);
-      
-    in->size_used += size;
-  }
+  if(!n || !conn || (conn->handle != STRUCT_CONNECT))
+    return CURLE_FAILED_INIT;
 
-  return CURLE_OK;
+  return Curl_read(conn, conn->sockfd, buf, buffersize, n);
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/sendf.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/sendf.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/sendf.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/sendf.h	2001-01-25 20:20:30.000000000 +0800
@@ -17,35 +17,40 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.h,v 1.8 2001/01/03 09:29:34 bagder Exp $
+ * $Id: sendf.h,v 1.10 2001/01/25 12:20:30 bagder Exp $
  *****************************************************************************/
 
-size_t ftpsendf(int fd, struct connectdata *, char *fmt, ...);
-size_t sendf(int fd, struct UrlData *, char *fmt, ...);
-size_t ssend(int fd, struct connectdata *, void *fmt, size_t len);
-void infof(struct UrlData *, char *fmt, ...);
-void failf(struct UrlData *, char *fmt, ...);
+size_t Curl_sendf(int fd, struct connectdata *, char *fmt, ...);
+void Curl_infof(struct UrlData *, char *fmt, ...);
+void Curl_failf(struct UrlData *, char *fmt, ...);
+
+#define infof Curl_infof
+#define failf Curl_failf
 
 struct send_buffer {
   char *buffer;
   long size_max;
   long size_used;
 };
 typedef struct send_buffer send_buffer;
 
 #define CLIENTWRITE_BODY   1
 #define CLIENTWRITE_HEADER 2
 #define CLIENTWRITE_BOTH   (CLIENTWRITE_BODY|CLIENTWRITE_HEADER)
 
-CURLcode client_write(struct UrlData *data, int type, char *ptr,
-                      size_t len);
-send_buffer *add_buffer_init(void);
-CURLcode add_buffer(send_buffer *in, void *inptr, size_t size);
-CURLcode add_bufferf(send_buffer *in, char *fmt, ...);
-size_t add_buffer_send(int sockfd, struct connectdata *conn, send_buffer *in);
+CURLcode Curl_client_write(struct UrlData *data, int type, char *ptr,
+                           size_t len);
 
+/* internal read-function, does plain socket, SSL and krb4 */
+CURLcode Curl_read(struct connectdata *conn, int sockfd,
+                   char *buf, size_t buffersize,
+                   size_t *n);
+/* internal write-function, does plain socket, SSL and krb4 */
+CURLcode Curl_write(struct connectdata *conn, int sockfd,
+                    void *mem, size_t len,
+                    size_t *written);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/setup.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/setup.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/setup.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/setup.h	2001-01-25 20:21:10.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: setup.h,v 1.9 2001/01/03 09:29:34 bagder Exp $
+ * $Id: setup.h,v 1.10 2001/01/25 12:21:10 bagder Exp $
  *****************************************************************************/
 
 
 
 #if !defined(WIN32) && defined(_WIN32)
 /* This _might_ be a good Borland fix. Please report whether this works or
@@ -97,13 +97,12 @@
 #endif
 
 /* Below we define four functions. They should
    1. close a socket
    2. read from a socket
    3. write to a socket
-   (Hopefully, only win32-crap do this weird name changing)
 
    4. set the SIGALRM signal timeout
    5. set dir/file naming defines
    */
 
 #ifdef WIN32
@@ -112,14 +111,14 @@
 #define sread(x,y,z) recv(x,y,z,0)
 #define swrite(x,y,z) (size_t)send(x,y,z,0)
 #define myalarm(x) /* win32 is a silly system */
 #else
      /* gcc-for-win is still good :) */
 #define sclose(x) close(x)
-#define sread(x,y,z) read(x,y,z)
-#define swrite(x,y,z) write(x,y,z)
+#define sread(x,y,z) recv(x,y,z,0)
+#define swrite(x,y,z) send(x,y,z,0)
 #define myalarm(x) alarm(x)
 #endif
 
 #define PATH_CHAR     ";"
 #define DIR_CHAR      "\\"
 #define DOT_CHAR      "_"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/speedcheck.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/speedcheck.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/speedcheck.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/speedcheck.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: speedcheck.c,v 1.7 2001/01/03 09:29:34 bagder Exp $
+ * $Id: speedcheck.c,v 1.8 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #if defined(__MINGW32__)
@@ -30,30 +30,30 @@
 
 #include <curl/curl.h>
 #include "urldata.h"
 #include "sendf.h"
 #include "speedcheck.h"
 
-void speedinit(struct UrlData *data)
+void Curl_speedinit(struct UrlData *data)
 {
   memset(&data->keeps_speed, 0, sizeof(struct timeval));
 }
 
-CURLcode speedcheck(struct UrlData *data,
-                    struct timeval now)
+CURLcode Curl_speedcheck(struct UrlData *data,
+                         struct timeval now)
 {
   if((data->progress.current_speed >= 0) &&
      data->low_speed_time &&
-     (tvlong(data->keeps_speed) != 0) &&
+     (Curl_tvlong(data->keeps_speed) != 0) &&
      (data->progress.current_speed < data->low_speed_limit)) {
 
     /* We are now below the "low speed limit". If we are below it
        for "low speed time" seconds we consider that enough reason
        to abort the download. */
     
-    if( tvdiff(now, data->keeps_speed) > data->low_speed_time) {
+    if( Curl_tvdiff(now, data->keeps_speed) > data->low_speed_time) {
       /* we have been this slow for long enough, now die */
       failf(data,
 	    "Operation too slow. "
 	    "Less than %d bytes/sec transfered the last %d seconds",
 	    data->low_speed_limit,
 	    data->low_speed_time);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/speedcheck.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/speedcheck.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/speedcheck.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/speedcheck.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,18 +17,18 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: speedcheck.h,v 1.6 2001/01/03 09:29:34 bagder Exp $
+ * $Id: speedcheck.h,v 1.7 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include "timeval.h"
 
-void speedinit(struct UrlData *data);
-CURLcode speedcheck(struct UrlData *data,
-                    struct timeval now);
+void Curl_speedinit(struct UrlData *data);
+CURLcode Curl_speedcheck(struct UrlData *data,
+                         struct timeval now);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ssluse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ssluse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ssluse.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ssluse.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.c,v 1.11 2001/01/03 09:29:34 bagder Exp $
+ * $Id: ssluse.c,v 1.12 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 /*
  * The original SSL code was written by
  * Linas Vepstas <linas@linas.org> and Sampo Kellomaki <sampo@iki.fi>
  */
@@ -59,15 +59,16 @@
 }
 
 /* This function is *highly* inspired by (and parts are directly stolen
  * from) source from the SSLeay package written by Eric Young
  * (eay@cryptsoft.com).  */
 
-int SSL_cert_stuff(struct UrlData *data, 
-		   char *cert_file,
-		   char *key_file)
+static
+int cert_stuff(struct UrlData *data, 
+               char *cert_file,
+               char *key_file)
 {
   if (cert_file != NULL) {
     SSL *ssl;
     X509 *x509;
 
     if(data->cert_passwd) {
@@ -121,12 +122,13 @@
   return(1);
 }
 
 #endif
 
 #ifdef USE_SSLEAY
+static
 int cert_verify_callback(int ok, X509_STORE_CTX *ctx)
 {
   X509 *err_cert;
   char buf[256];
 
   err_cert=X509_STORE_CTX_get_current_cert(ctx);
@@ -136,13 +138,13 @@
 }
 
 #endif
 
 /* ====================================================== */
 int
-UrgSSLConnect (struct UrlData *data)
+Curl_SSLConnect (struct UrlData *data)
 {
 #ifdef USE_SSLEAY
     int err;
     char * str;
     SSL_METHOD *req_method;
 
@@ -160,13 +162,13 @@
       /* We need to seed the PRNG properly! */
 #ifdef HAVE_RAND_SCREEN
       /* This one gets a random value by reading the currently shown screen */
       RAND_screen();
 #else
       int len;
-      char *area = MakeFormBoundary();
+      char *area = Curl_FormBoundary();
       if(!area)
 	return 3; /* out of memory */
 	
       len = strlen(area);
 
       RAND_seed(area, len);
@@ -195,13 +197,13 @@
     if(!data->ssl.ctx) {
       failf(data, "SSL: couldn't create a context!");
       return 1;
     }
     
     if(data->cert) {
-      if (!SSL_cert_stuff(data, data->cert, data->cert)) {
+      if (!cert_stuff(data, data->cert, data->cert)) {
 	failf(data, "couldn't use certificate!\n");
 	return 2;
       }
     }
 
     if(data->ssl.verifypeer){
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ssluse.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ssluse.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/ssluse.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/ssluse.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,13 +17,10 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.h,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: ssluse.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
-int SSL_cert_stuff(struct UrlData *data, 
-		   char *cert_file,
-		   char *key_file);
-int UrgSSLConnect (struct UrlData *data);
+int Curl_SSLConnect (struct UrlData *data);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/strequal.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/strequal.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/strequal.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/strequal.c	2001-01-05 18:11:42.000000000 +0800
@@ -15,20 +15,20 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.c,v 1.7 2001/01/03 09:29:34 bagder Exp $
+ * $Id: strequal.c,v 1.8 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
-int strequal(const char *first, const char *second)
+int Curl_strequal(const char *first, const char *second)
 {
 #if defined(HAVE_STRCASECMP)
   return !strcasecmp(first, second);
 #elif defined(HAVE_STRCMPI)
   return !strcmpi(first, second);
 #elif defined(HAVE_STRICMP)
@@ -42,13 +42,13 @@
     second++;
   }
   return toupper(*first) == toupper(*second);
 #endif
 }
 
-int strnequal(const char *first, const char *second, size_t max)
+int Curl_strnequal(const char *first, const char *second, size_t max)
 {
 #if defined(HAVE_STRCASECMP)
   return !strncasecmp(first, second, max);
 #elif defined(HAVE_STRCMPI)
   return !strncmpi(first, second, max);
 #elif defined(HAVE_STRICMP)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/strequal.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/strequal.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/strequal.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/strequal.h	2001-01-05 18:11:42.000000000 +0800
@@ -17,12 +17,15 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.h,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: strequal.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
  *****************************************************************************/
-int strequal(const char *first, const char *second);
-int strnequal(const char *first, const char *second, size_t max);
+int Curl_strequal(const char *first, const char *second);
+int Curl_strnequal(const char *first, const char *second, size_t max);
+
+#define strequal(a,b) Curl_strequal(a,b)
+#define strnequal(a,b,c) Curl_strnequal(a,b,c)
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/telnet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/telnet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/telnet.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/telnet.c	2001-01-25 20:22:17.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: telnet.c,v 1.8 2001/01/03 09:29:34 bagder Exp $
+ * $Id: telnet.c,v 1.11 2001/01/25 12:22:17 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -68,23 +68,20 @@
 
 
 #endif
 
 #include "urldata.h"
 #include <curl/curl.h>
-#include "download.h"
+#include "transfer.h"
 #include "sendf.h"
-#include "formdata.h"
-#include "progress.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 #define  TELOPTS
 #define  TELCMDS
-#define  SLC_NAMES
 
 #include "arpa_telnet.h"
 
 #define SUBBUFSIZE 512
 
 #define  SB_CLEAR()  subpointer = subbuffer;
@@ -95,16 +92,13 @@
 
 #define  SB_GET() ((*subpointer++)&0xff)
 #define  SB_PEEK()   ((*subpointer)&0xff)
 #define  SB_EOF() (subpointer >= subend)
 #define  SB_LEN() (subend - subpointer)
 
-void telwrite(struct UrlData *data,
-	      unsigned char *buffer,	/* Data to write */
-	      int count);		/* Number of bytes to write */
-
+static
 void telrcv(struct UrlData *data,
 	    unsigned char *inbuf,	/* Data received from socket */
 	    int count);			/* Number of bytes received */
 
 static void printoption(struct UrlData *data,
 			const char *direction,
@@ -152,12 +146,13 @@
 static int usq[256]; 
 static int us_preferred[256]; 
 static int him[256]; 
 static int himq[256]; 
 static int him_preferred[256]; 
 
+static
 void init_telnet(struct UrlData *data)
 {
    telrcv_state = TS_DATA;
 
    /* Init suboptions */
    SB_CLEAR();
@@ -243,12 +238,13 @@
    
    swrite(data->firstsocket, buf, 3);
    
    printoption(data, "SENT", cmd, option);
 }
 
+static
 void set_remote_option(struct UrlData *data, int option, int newstate)
 {
    if(newstate == YES)
    {
       switch(him[option])
       {
@@ -323,12 +319,13 @@
 	 }
 	 break;
       }
    }
 }
 
+static
 void rec_will(struct UrlData *data, int option)
 {
    switch(him[option])
    {
    case NO:
       if(him_preferred[option] == YES)
@@ -374,12 +371,13 @@
 	 break;
       }
       break;
    }
 }
    
+static
 void rec_wont(struct UrlData *data, int option)
 {
    switch(him[option])
    {
    case NO:
       /* Already disabled */
@@ -497,12 +495,13 @@
 	 }
 	 break;
       }
    }
 }
 
+static
 void rec_do(struct UrlData *data, int option)
 {
    switch(us[option])
    {
    case NO:
       if(us_preferred[option] == YES)
@@ -547,13 +546,14 @@
 	 send_negotiation(data, WONT, option);
 	 break;
       }
       break;
    }
 }
-   
+
+static   
 void rec_dont(struct UrlData *data, int option)
 {
    switch(us[option])
    {
    case NO:
       /* Already disabled */
@@ -666,12 +666,13 @@
 static void suboption(struct UrlData *data)
 {
    printsub(data, '<', (unsigned char *)subbuffer, SB_LEN()+2);
    return;
 }
 
+static
 void telrcv(struct UrlData *data,
 	    unsigned char *inbuf,	/* Data received from socket */
 	    int count)			/* Number of bytes received */
 {
    unsigned char c;
    int index = 0;
@@ -686,13 +687,13 @@
 	 telrcv_state = TS_DATA;
 	 if (c == '\0')
 	 {
 	    break;   /* Ignore \0 after CR */
 	 }
 
-	 client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
+	 Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
 	 continue;
 
       case TS_DATA:
 	 if (c == IAC)
 	 {
 	    telrcv_state = TS_IAC;
@@ -700,13 +701,13 @@
 	 }
 	 else if(c == '\r')
 	 {
 	    telrcv_state = TS_CR;
 	 }
 
-	 client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
+	 Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
 	 continue;
 
       case TS_IAC:
 	process_iac:
 	switch (c)
 	{
@@ -724,13 +725,13 @@
 	   continue;
 	case SB:
 	   SB_CLEAR();
 	   telrcv_state = TS_SB;
 	   continue;
 	case IAC:
-          client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
+          Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
           break;
 	case DM:
 	case NOP:
 	case GA:
 	default:
 	   printoption(data, "RCVD", IAC, c);
@@ -815,105 +816,76 @@
 	 }
 	 break;
       }
    }
 }
 
-void telwrite(struct UrlData *data,
-	      unsigned char *buffer,	/* Data to write */
-	      int count)		/* Number of bytes to write */
-{
-   unsigned char outbuf[2];
-   int out_count = 0;
-   int bytes_written;
-
-   while(count--)
-   {
-      outbuf[0] = *buffer++;
-      out_count = 1;
-      if(outbuf[0] == IAC)
-	 outbuf[out_count++] = IAC;
-      
-#ifndef USE_SSLEAY
-      bytes_written = swrite(data->firstsocket, outbuf, out_count);
-#else
-      if (data->ssl.use) {
-        bytes_written = SSL_write(data->ssl.handle, (char *)outbuf,
-                                  out_count);
-      }
-      else {
-        bytes_written = swrite(data->firstsocket, outbuf, out_count);
-      }
-#endif /* USE_SSLEAY */
-   }
-}
-
-CURLcode telnet_done(struct connectdata *conn)
+CURLcode Curl_telnet_done(struct connectdata *conn)
 {
   return CURLE_OK;
 }
 
-CURLcode telnet(struct connectdata *conn)
+CURLcode Curl_telnet(struct connectdata *conn)
 {
   struct UrlData *data = conn->data;
   int sockfd = data->firstsocket;
   fd_set readfd;
   fd_set keepfd;
 
   bool keepon = TRUE;
   char *buf = data->buffer;
-  int nread;
+  size_t nread;
 
   init_telnet(data);
    
   FD_ZERO (&readfd);		/* clear it */
   FD_SET (sockfd, &readfd);
   FD_SET (1, &readfd);
 
   keepfd = readfd;
 
-   while (keepon)
-   {
-      readfd = keepfd;		/* set this every lap in the loop */
+  while (keepon) {
+    readfd = keepfd;		/* set this every lap in the loop */
 
-      switch (select (sockfd + 1, &readfd, NULL, NULL, NULL))
-      {
-      case -1:			/* error, stop reading */
-	 keepon = FALSE;
-	 continue;
-      case 0:			/* timeout */
-	 break;
-      default:			/* read! */
-	 if(FD_ISSET(1, &readfd))
-	 {
-	    nread = read(1, buf, 255);
-	    telwrite(data, (unsigned char *)buf, nread);
-	 }
-
-	 if(FD_ISSET(sockfd, &readfd))
-	 {
-#ifndef USE_SSLEAY
-	    nread = sread (sockfd, buf, BUFSIZE - 1);
-#else
-	    if (data->ssl.use) {
-	       nread = SSL_read (data->ssl.handle, buf, BUFSIZE - 1);
-	    }
-	    else {
-	       nread = sread (sockfd, buf, BUFSIZE - 1);
-	    }
-#endif /* USE_SSLEAY */
-	 }
-
-	 /* if we receive 0 or less here, the server closed the connection and
-	   we bail out from this! */
-	if (nread <= 0) {
-	  keepon = FALSE;
-	  break;
+    switch (select (sockfd + 1, &readfd, NULL, NULL, NULL)) {
+    case -1:			/* error, stop reading */
+      keepon = FALSE;
+      continue;
+    case 0:			/* timeout */
+      break;
+    default:			/* read! */
+      if(FD_ISSET(1, &readfd)) { /* read from stdin */
+        unsigned char outbuf[2];
+        int out_count = 0;
+        size_t bytes_written;
+        char *buffer = buf;
+        
+        nread = read(1, buf, 255);
+
+        while(nread--) {
+          outbuf[0] = *buffer++;
+          out_count = 1;
+          if(outbuf[0] == IAC)
+            outbuf[out_count++] = IAC;
+      
+          Curl_write(conn, data->firstsocket, outbuf,
+                     out_count, &bytes_written);
 	}
+      }
 
-	 telrcv(data, (unsigned char *)buf, nread);
+      if(FD_ISSET(sockfd, &readfd))
+        Curl_read(conn, sockfd, buf, BUFSIZE - 1, &nread);
+
+      /* if we receive 0 or less here, the server closed the connection and
+         we bail out from this! */
+      if (nread <= 0) {
+        keepon = FALSE;
+        break;
       }
-   }
-   return CURLE_OK;
+
+      telrcv(data, (unsigned char *)buf, nread);
+    }
+  }
+  return CURLE_OK;
 }
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/telnet.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/telnet.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/telnet.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/telnet.h	2001-01-05 18:11:43.000000000 +0800
@@ -18,12 +18,12 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: telnet.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: telnet.h,v 1.6 2001/01/05 10:11:43 bagder Exp $
  *****************************************************************************/
-CURLcode telnet(struct connectdata *conn);
-CURLcode telnet_done(struct connectdata *conn);
+CURLcode Curl_telnet(struct connectdata *conn);
+CURLcode Curl_telnet_done(struct connectdata *conn);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/timeval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/timeval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/timeval.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/timeval.c	2001-01-05 18:11:43.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: timeval.c,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: timeval.c,v 1.5 2001/01/05 10:11:43 bagder Exp $
  *****************************************************************************/
 
 #ifdef WIN32
 #include <windows.h>
 #endif
 #include "timeval.h"
@@ -50,27 +50,27 @@
  return 1;
 }
 #define HAVE_GETTIMEOFDAY
 #endif
 #endif
 
-struct timeval tvnow ()
+struct timeval Curl_tvnow ()
 {
  struct timeval now;
 #ifdef HAVE_GETTIMEOFDAY
  gettimeofday (&now, NULL);
 #else
  now.tv_sec = (long) time(NULL);
  now.tv_usec = 0;
 #endif
  return now;
 }
 
-double tvdiff (struct timeval t1, struct timeval t2)
+double Curl_tvdiff (struct timeval t1, struct timeval t2)
 {
  return (double)(t1.tv_sec - t2.tv_sec) + ((t1.tv_usec-t2.tv_usec)/1000000.0);
 }
 
-long tvlong (struct timeval t1)
+long Curl_tvlong (struct timeval t1)
 {
  return t1.tv_sec;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/timeval.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/timeval.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/timeval.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/timeval.h	2001-01-05 18:11:43.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: timeval.h,v 1.6 2001/01/03 09:29:34 bagder Exp $
+ * $Id: timeval.h,v 1.7 2001/01/05 10:11:43 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #if defined(WIN32) && !defined(__GNUC__) || defined(__MINGW32__)
 #include <time.h>
@@ -39,11 +39,11 @@
  long tv_sec;
  long tv_usec;
 };
 #endif
 #endif
 
-struct timeval tvnow ();
-double tvdiff (struct timeval t1, struct timeval t2);
-long tvlong (struct timeval t1);
+struct timeval Curl_tvnow ();
+double Curl_tvdiff (struct timeval t1, struct timeval t2);
+long Curl_tvlong (struct timeval t1);
 
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib: transfer.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib: transfer.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/url.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/url.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/url.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/url.c	2001-01-26 23:52:01.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.c,v 1.69 2001/01/03 09:29:34 bagder Exp $
+ * $Id: url.c,v 1.76 2001/01/26 15:52:01 bagder Exp $
  *****************************************************************************/
 
 /* -- WIN32 approved -- */
 
 #include "setup.h"
 
@@ -82,15 +82,14 @@
 #include "formdata.h"
 #include "getenv.h"
 #include "base64.h"
 #include "ssluse.h"
 #include "hostip.h"
 #include "if2ip.h"
-#include "download.h"
+#include "transfer.h"
 #include "sendf.h"
-#include "speedcheck.h"
 #include "getpass.h"
 #include "progress.h"
 #include "cookie.h"
 #include "strequal.h"
 #include "escape.h"
 
@@ -221,13 +220,13 @@
       free(data->referer);
 
     if(data->bits.urlstringalloc)
       /* the URL is allocated, free it! */
       free(data->url);
 
-    cookie_cleanup(data->cookies);
+    Curl_cookie_cleanup(data->cookies);
 
     free(data);
 
     /* global cleanup */
     curl_free();
   }
@@ -245,12 +244,13 @@
   if(protocol)
     free(protocol);
 
   return CURLE_OK;
 }
 
+static
 int my_getpass(void *clientp, char *prompt, char* buffer, int buflen )
 {
   char *retbuf;
   retbuf = getpass_r(prompt, buffer, buflen);
   if(NULL == retbuf)
     return 1;
@@ -298,12 +298,14 @@
     data->fpasswd = my_getpass;
 
     data->infilesize = -1; /* we don't know any size */
 
     data->current_speed = -1; /* init to negative == impossible */
 
+    data->httpreq = HTTPREQ_GET; /* Default HTTP request */
+
     *curl = data;
     return CURLE_OK;
   }
 
   /* this is a very serious error */
   return CURLE_OUT_OF_MEMORY;
@@ -337,12 +339,13 @@
     break;
   case CURLOPT_UPLOAD:
     data->bits.upload = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_POST:
     data->bits.http_post = va_arg(param, long)?TRUE:FALSE;
+    data->httpreq = HTTPREQ_POST;
     break;
   case CURLOPT_FILETIME:
     data->bits.get_filetime = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FTPLISTONLY:
     data->bits.ftp_list_only = va_arg(param, long)?TRUE:FALSE;
@@ -358,25 +361,23 @@
     break;
   case CURLOPT_FTPASCII:
     data->bits.ftp_ascii = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_PUT:
     data->bits.http_put = va_arg(param, long)?TRUE:FALSE;
+    data->httpreq = HTTPREQ_PUT;
     break;
   case CURLOPT_MUTE:
     data->bits.mute = va_arg(param, long)?TRUE:FALSE;
     break;
-
   case CURLOPT_TIMECONDITION:
     data->timecondition = va_arg(param, long);
     break;
-
   case CURLOPT_TIMEVALUE:
     data->timevalue = va_arg(param, long);
     break;
-
   case CURLOPT_SSLVERSION:
     data->ssl.version = va_arg(param, long);
     break;
 
   case CURLOPT_COOKIEFILE:
     cookiefile = (char *)va_arg(param, void *);
@@ -378,13 +379,13 @@
     data->ssl.version = va_arg(param, long);
     break;
 
   case CURLOPT_COOKIEFILE:
     cookiefile = (char *)va_arg(param, void *);
     if(cookiefile) {
-      data->cookies = cookie_init(cookiefile);
+      data->cookies = Curl_cookie_init(cookiefile);
     }
     break;
   case CURLOPT_WRITEHEADER:
     data->writeheader = (FILE *)va_arg(param, FILE *);
     break;
   case CURLOPT_COOKIE:
@@ -402,16 +403,18 @@
     break;
   case CURLOPT_HTTPHEADER:
     data->headers = va_arg(param, struct curl_slist *);
     break;
   case CURLOPT_CUSTOMREQUEST:
     data->customrequest = va_arg(param, char *);
+    data->httpreq = HTTPREQ_CUSTOM;
     break;
   case CURLOPT_HTTPPOST:
     data->httppost = va_arg(param, struct HttpPost *);
     data->bits.http_formpost = data->httppost?1:0;
+    data->httpreq = HTTPREQ_POST_FORM;
     break;
   case CURLOPT_INFILE:
     data->in = va_arg(param, FILE *);
     break;
   case CURLOPT_INFILESIZE:
     data->infilesize = va_arg(param, long);
@@ -530,125 +533,25 @@
     /* unknown tag and its companion, just ignore: */
     return CURLE_READ_ERROR; /* correct this */
   }
   return CURLE_OK;
 }
 
-
-/*
- * Read everything until a newline.
- */
-
-int GetLine(int sockfd, char *buf, struct UrlData *data)
-{
-  int nread;
-  int read_rc=1;
-  char *ptr;
-  ptr=buf;
-
-  /* get us a full line, terminated with a newline */
-  for(nread=0;
-      (nread<BUFSIZE) && read_rc;
-      nread++, ptr++) {
-#ifdef USE_SSLEAY
-    if (data->ssl.use) {
-      read_rc = SSL_read(data->ssl.handle, ptr, 1);
-    }
-    else {
-#endif
-      read_rc = sread(sockfd, ptr, 1);
-#ifdef USE_SSLEAY
-    }
-#endif /* USE_SSLEAY */
-    if (*ptr == '\n')
-      break;
-  }
-  *ptr=0; /* zero terminate */
-
-  if(data->bits.verbose) {
-    fputs("< ", data->err);
-    fwrite(buf, 1, nread, data->err);
-    fputs("\n", data->err);
-  }
-  return nread;
-}
-
-
-#ifndef WIN32
+#if !defined(WIN32)||defined(__CYGWIN32__)
 #ifndef RETSIGTYPE
 #define RETSIGTYPE void
 #endif
+static
 RETSIGTYPE alarmfunc(int signal)
 {
   /* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
   (void)signal;
   return;
 }
 #endif
 
-CURLcode curl_write(CURLconnect *c_conn, char *buf, size_t amount,
-                   size_t *n)
-{
-  struct connectdata *conn = (struct connectdata *)c_conn;
-  struct UrlData *data;
-  size_t bytes_written;
-
-  if(!n || !conn || (conn->handle != STRUCT_CONNECT))
-    return CURLE_FAILED_INIT;
-  data = conn->data;
-
-#ifdef USE_SSLEAY
-  if (data->ssl.use) {
-    bytes_written = SSL_write(data->ssl.handle, buf, amount);
-  }
-  else {
-#endif
-#ifdef KRB4
-    if(conn->sec_complete)
-      bytes_written = sec_write(conn, conn->writesockfd, buf, amount);
-    else
-#endif
-      bytes_written = swrite(conn->writesockfd, buf, amount);
-#ifdef USE_SSLEAY
-  }
-#endif /* USE_SSLEAY */
-
-  *n = bytes_written;
-  return CURLE_OK;
-}
-
-CURLcode curl_read(CURLconnect *c_conn, char *buf, size_t buffersize,
-                   size_t *n)
-{
-  struct connectdata *conn = (struct connectdata *)c_conn;
-  struct UrlData *data;
-  size_t nread;
-
-  if(!n || !conn || (conn->handle != STRUCT_CONNECT))
-    return CURLE_FAILED_INIT;
-  data = conn->data;
-
-#ifdef USE_SSLEAY
-  if (data->ssl.use) {
-    nread = SSL_read (data->ssl.handle, buf, buffersize);
-  }
-  else {
-#endif
-#ifdef KRB4
-    if(conn->sec_complete)
-      nread = sec_read(conn, conn->sockfd, buf, buffersize);
-    else
-#endif
-      nread = sread (conn->sockfd, buf, buffersize);
-#ifdef USE_SSLEAY
-  }
-#endif /* USE_SSLEAY */
-  *n = nread;
-  return CURLE_OK;
-}
-
 CURLcode curl_disconnect(CURLconnect *c_connect)
 {
   struct connectdata *conn = c_connect;
 
   struct UrlData *data = conn->data;
 
@@ -671,23 +574,31 @@
   char *tmp;
   char *buf;
   CURLcode result;
   char resumerange[40]="";
   struct UrlData *data = curl;
   struct connectdata *conn;
+  char endbracket;
 #ifdef HAVE_SIGACTION
   struct sigaction sigact;
 #endif
   int urllen;
 
+  /*************************************************************
+   * Check input data
+   *************************************************************/
+
   if(!data || (data->handle != STRUCT_OPEN))
     return CURLE_BAD_FUNCTION_ARGUMENT; /* TBD: make error codes */
 
   if(!data->url)
     return CURLE_URL_MALFORMAT;
 
+  /*************************************************************
+   * Allocate and initiate a connection struct
+   *************************************************************/
   conn = (struct connectdata *)malloc(sizeof(struct connectdata));
   if(!conn) {
     *in_connect = NULL; /* clear the pointer */
     return CURLE_OUT_OF_MEMORY;
   }
   *in_connect = conn;
@@ -700,12 +611,15 @@
 
   conn->upload_bufsize = UPLOAD_BUFSIZE; /* the smallest upload buffer size
                                             we use */
 
   buf = data->buffer; /* this is our buffer */
 
+  /*************************************************************
+   * Set signal handler
+   *************************************************************/
 #ifdef HAVE_SIGACTION
   sigaction(SIGALRM, NULL, &sigact);
   sigact.sa_handler = alarmfunc;
 #ifdef SA_RESTART
   /* HPUX doesn't have SA_RESTART but defaults to that behaviour! */
   sigact.sa_flags &= ~SA_RESTART;
@@ -716,59 +630,78 @@
 #ifdef HAVE_SIGNAL
   signal(SIGALRM, alarmfunc);
 #endif
 
 #endif
 
-  /* We need to allocate memory to store the path in. We get the size of the
-     full URL to be sure, and we need to make it at least 256 bytes since
-     other parts of the code will rely on this fact */
+  /***********************************************************
+   * We need to allocate memory to store the path in. We get the size of the
+   * full URL to be sure, and we need to make it at least 256 bytes since
+   * other parts of the code will rely on this fact
+   ***********************************************************/
 #define LEAST_PATH_ALLOC 256
   urllen=strlen(data->url);
   if(urllen < LEAST_PATH_ALLOC)
     urllen=LEAST_PATH_ALLOC;
   
   conn->path=(char *)malloc(urllen);
   if(NULL == conn->path)
     return CURLE_OUT_OF_MEMORY; /* really bad error */
 
-  /* Parse <url> */
-  /* We need to parse the url, even when using the proxy, because
-   * we will need the hostname and port in case we are trying
-   * to SSL connect through the proxy -- and we don't know if we
-   * will need to use SSL until we parse the url ...
-   */
+  /*************************************************************
+   * Parse the URL.
+   *
+   * We need to parse the url even when using the proxy, because we will need
+   * the hostname and port in case we are trying to SSL connect through the
+   * proxy -- and we don't know if we will need to use SSL until we parse the
+   * url ...
+   ************************************************************/
   if((2 == sscanf(data->url, "%64[^:]://%[^\n]",
                   conn->proto,
                   conn->path)) && strequal(conn->proto, "file")) {
-    /* we deal with file://<host>/<path> differently since it
-       supports no hostname other than "localhost" and "127.0.0.1",
-       which is unique among the protocols specified in RFC 1738 */
+    /*
+     * we deal with file://<host>/<path> differently since it supports no
+     * hostname other than "localhost" and "127.0.0.1", which is unique among
+     * the URL protocols specified in RFC 1738
+     */
+
     if (strnequal(conn->path, "localhost/", 10) ||
         strnequal(conn->path, "127.0.0.1/", 10))
-      /* ... since coincidentally both host strings are of equal length
-         otherwise, <host>/ is quietly ommitted */
+      /* If there's another host name than the one we support, <host>/ is
+       * quietly ommitted */
       strcpy(conn->path, &conn->path[10]);
 
-    strcpy(conn->proto, "file");
+    strcpy(conn->proto, "file"); /* store protocol string lowercase */
   }
   else {
     /* Set default host and default path */
     strcpy(conn->gname, "curl.haxx.se");
     strcpy(conn->path, "/");
 
     if (2 > sscanf(data->url,
                    "%64[^\n:]://%256[^\n/]%[^\n]",
                    conn->proto, conn->gname, conn->path)) {
       
-      /* badly formatted, let's try the browser-style _without_ 'http://' */
+      /*
+       * The URL was badly formatted, let's try the browser-style _without_
+       * protocol specified like 'http://'.
+       */
       if((1 > sscanf(data->url, "%256[^\n/]%[^\n]",
                      conn->gname, conn->path)) ) {
+        /*
+         * We couldn't even get this format.
+         */
         failf(data, "<url> malformed");
         return CURLE_URL_MALFORMAT;
       }
+
+      /*
+       * Since there was no protocol part specified, we guess what protocol it
+       * is based on the first letters of the server name.
+       */
+
       if(strnequal(conn->gname, "FTP", 3)) {
         strcpy(conn->proto, "ftp");
       }
       else if(strnequal(conn->gname, "GOPHER", 6))
         strcpy(conn->proto, "gopher");
 #ifdef USE_SSLEAY
@@ -786,12 +719,15 @@
       }
 
       conn->protocol |= PROT_MISSING; /* not given in URL */
     }
   }
 
+  /*************************************************************
+   * Take care of user and password authentication stuff
+   *************************************************************/
 
   if(data->bits.user_passwd && !data->bits.use_netrc) {
     data->user[0] =0;
     data->passwd[0]=0;
 
     if(*data->userpwd != ':') {
@@ -809,12 +745,15 @@
          data->fpasswd(data->passwd_client,
                        "password:", data->passwd, sizeof(data->passwd)))
         return CURLE_BAD_PASSWORD_ENTERED;
     }
   }
 
+  /*************************************************************
+   * Take care of proxy authentication stuff
+   *************************************************************/
   if(data->bits.proxy_user_passwd) {
     data->proxyuser[0] =0;
     data->proxypasswd[0]=0;
 
     if(*data->proxyuserpwd != ':') {
       /* the name is given, get user+password */
@@ -834,43 +773,49 @@
                         sizeof(data->proxypasswd)))
         return CURLE_BAD_PASSWORD_ENTERED;
     }
 
   }
 
+  /*************************************************************
+   * Set a few convenience pointers 
+   *************************************************************/
   conn->name = conn->gname;
   conn->ppath = conn->path;
   data->hostname = conn->name;
 
 
+  /*************************************************************
+   * Detect what (if any) proxy to use
+   *************************************************************/
   if(!data->bits.httpproxy) {
     /* If proxy was not specified, we check for default proxy environment
-       variables, to enable i.e Lynx compliance:
-
-       http_proxy=http://some.server.dom:port/
-       https_proxy=http://some.server.dom:port/
-       ftp_proxy=http://some.server.dom:port/
-       gopher_proxy=http://some.server.dom:port/
-       no_proxy=domain1.dom,host.domain2.dom
-                                 (a comma-separated list of hosts which should
-                                  not be proxied, or an asterisk to override
-                                  all proxy variables)
-       all_proxy=http://some.server.dom:port/
-                                 (seems to exist for the CERN www lib. Probably
-                                  the first to check for.)
-
-       For compatibility, the all-uppercase versions of these variables are
-       checked if the lowercase versions don't exist.
-       */
+     * variables, to enable i.e Lynx compliance:
+     *
+     * http_proxy=http://some.server.dom:port/
+     * https_proxy=http://some.server.dom:port/
+     * ftp_proxy=http://some.server.dom:port/
+     * gopher_proxy=http://some.server.dom:port/
+     * no_proxy=domain1.dom,host.domain2.dom
+     *   (a comma-separated list of hosts which should
+     *   not be proxied, or an asterisk to override
+     *   all proxy variables)
+     * all_proxy=http://some.server.dom:port/
+     *   (seems to exist for the CERN www lib. Probably
+     *   the first to check for.)
+     *
+     * For compatibility, the all-uppercase versions of these variables are
+     * checked if the lowercase versions don't exist.
+     */
     char *no_proxy=NULL;
     char *proxy=NULL;
     char proxy_env[128];
 
-    no_proxy=GetEnv("no_proxy");
+    no_proxy=curl_getenv("no_proxy");
     if(!no_proxy)
-      no_proxy=GetEnv("NO_PROXY");
+      no_proxy=curl_getenv("NO_PROXY");
 
     if(!no_proxy || !strequal("*", no_proxy)) {
       /* NO_PROXY wasn't specified or it wasn't just an asterisk */
       char *nope;
 
       nope=no_proxy?strtok(no_proxy, ", "):NULL;
@@ -896,28 +841,28 @@
 	  *envp++ = tolower(*protop++);
 
 	/* append _proxy */
 	strcpy(envp, "_proxy");
 
 	/* read the protocol proxy: */
-	prox=GetEnv(proxy_env);
+	prox=curl_getenv(proxy_env);
 
 	if(!prox) {
           /* There was no lowercase variable, try the uppercase version: */
 	  for(envp = proxy_env; *envp; envp++)
 	    *envp = toupper(*envp);
-	  prox=GetEnv(proxy_env);
+	  prox=curl_getenv(proxy_env);
 	}
 
 	if(prox && *prox) { /* don't count "" strings */
 	  proxy = prox; /* use this */
 	}
 	else {
-	  proxy = GetEnv("all_proxy"); /* default proxy to use */
+	  proxy = curl_getenv("all_proxy"); /* default proxy to use */
 	  if(!proxy)
-            proxy=GetEnv("ALL_PROXY");
+            proxy=curl_getenv("ALL_PROXY");
 	}
 
         if(proxy && *proxy) {
           /* we have a proxy here to set */
           data->proxy = proxy;
           data->bits.proxystringalloc=1; /* this needs to be freed later */
@@ -926,83 +871,88 @@
       } /* if (!nope) - it wasn't specified non-proxy */
     } /* NO_PROXY wasn't specified or '*' */
     if(no_proxy)
       free(no_proxy);
   } /* if not using proxy */
 
+  /*************************************************************
+   * No protocol but proxy usage needs attention
+   *************************************************************/
   if((conn->protocol&PROT_MISSING) && data->bits.httpproxy ) {
     /* We're guessing prefixes here and since we're told to use a proxy, we
        need to add the protocol prefix to the URL string before we continue!
        */
     char *reurl;
 
-    reurl = maprintf("%s://%s", conn->proto, data->url);
+    reurl = aprintf("%s://%s", conn->proto, data->url);
 
     if(!reurl)
       return CURLE_OUT_OF_MEMORY;
 
     data->url = reurl;
     if(data->freethis)
       free(data->freethis);
     data->freethis = reurl;
 
     conn->protocol &= ~PROT_MISSING; /* switch that one off again */
   }
 
-  /* RESUME on a HTTP page is a tricky business. First, let's just check that
-     'range' isn't used, then set the range parameter and leave the resume as
-     it is to inform about this situation for later use. We will then
-     "attempt" to resume, and if we're talking to a HTTP/1.1 (or later)
-     server, we will get the document resumed. If we talk to a HTTP/1.0
-     server, we just fail since we can't rewind the file writing from within
-     this function. */
+  /************************************************************
+   * RESUME on a HTTP page is a tricky business. First, let's just check that
+   * 'range' isn't used, then set the range parameter and leave the resume as
+   * it is to inform about this situation for later use. We will then
+   * "attempt" to resume, and if we're talking to a HTTP/1.1 (or later)
+   * server, we will get the document resumed. If we talk to a HTTP/1.0
+   * server, we just fail since we can't rewind the file writing from within
+   * this function.
+   ***********************************************************/
   if(data->resume_from) {
     if(!data->bits.set_range) {
       /* if it already was in use, we just skip this */
       snprintf(resumerange, sizeof(resumerange), "%d-", data->resume_from);
       data->range=strdup(resumerange); /* tell ourselves to fetch this range */
       data->bits.rangestringalloc = TRUE; /* mark as allocated */
       data->bits.set_range = 1; /* switch on range usage */
     }
   }
 
-
+  /*************************************************************
+   * Set timeout if that is being used
+   *************************************************************/
   if(data->timeout) {
     /* We set the timeout on the connection/resolving phase first, separately
-       from the download/upload part to allow a maximum time on everything */
+     * from the download/upload part to allow a maximum time on everything */
     myalarm(data->timeout); /* this sends a signal when the timeout fires
 			       off, and that will abort system calls */
   }
 
-  /*
-   * Hmm, if we are using a proxy, then we can skip the GOPHER and the
-   * FTP steps, although we cannot skip the HTTPS step (since the proxy
-   * works differently, depending on whether its SSL or not).
-   */
+  /*************************************************************
+   * Setup internals depending on protocol
+   *************************************************************/
 
   if (strequal(conn->proto, "HTTP")) {
     if(!data->port)
       data->port = PORT_HTTP;
     data->remote_port = PORT_HTTP;
     conn->protocol |= PROT_HTTP;
-    conn->curl_do = http;
-    conn->curl_done = http_done;
-    conn->curl_close = http_close;
+    conn->curl_do = Curl_http;
+    conn->curl_done = Curl_http_done;
+    conn->curl_close = Curl_http_close;
   }
   else if (strequal(conn->proto, "HTTPS")) {
 #ifdef USE_SSLEAY
     if(!data->port)
       data->port = PORT_HTTPS;
     data->remote_port = PORT_HTTPS;
     conn->protocol |= PROT_HTTP;
     conn->protocol |= PROT_HTTPS;
 
-    conn->curl_do = http;
-    conn->curl_done = http_done;
-    conn->curl_connect = http_connect;
-    conn->curl_close = http_close;
+    conn->curl_do = Curl_http;
+    conn->curl_done = Curl_http_done;
+    conn->curl_connect = Curl_http_connect;
+    conn->curl_close = Curl_http_close;
 
 #else /* USE_SSLEAY */
     failf(data, "libcurl was built with SSL disabled, https: not supported!");
     return CURLE_UNSUPPORTED_PROTOCOL;
 #endif /* !USE_SSLEAY */
   }
@@ -1014,41 +964,41 @@
     if (isdigit((int)conn->path[1])) {
       conn->ppath = strchr(&conn->path[1], '/');
       if (conn->ppath == NULL)
 	conn->ppath = conn->path;
       }
     conn->protocol |= PROT_GOPHER;
-    conn->curl_do = http;
-    conn->curl_done = http_done;
-    conn->curl_close = http_close;
+    conn->curl_do = Curl_http;
+    conn->curl_done = Curl_http_done;
+    conn->curl_close = Curl_http_close;
   }
   else if(strequal(conn->proto, "FTP")) {
     char *type;
     if(!data->port)
       data->port = PORT_FTP;
     data->remote_port = PORT_FTP;
     conn->protocol |= PROT_FTP;
 
     if(data->bits.httpproxy &&
        !data->bits.tunnel_thru_httpproxy) {
       /* Unless we have asked to tunnel ftp operations through the proxy, we
          switch and use HTTP operations only */
-      conn->curl_do = http;
-      conn->curl_done = http_done;
-      conn->curl_close = http_close;
+      conn->curl_do = Curl_http;
+      conn->curl_done = Curl_http_done;
+      conn->curl_close = Curl_http_close;
     }
     else {
-      conn->curl_do = ftp;
-      conn->curl_done = ftp_done;
-      conn->curl_connect = ftp_connect;
+      conn->curl_do = Curl_ftp;
+      conn->curl_done = Curl_ftp_done;
+      conn->curl_connect = Curl_ftp_connect;
     }
 
     conn->ppath++; /* don't include the initial slash */
 
     /* FTP URLs support an extension like ";type=<typecode>" that
-       we'll try to get now! */
+     * we'll try to get now! */
     type=strstr(conn->ppath, ";type=");
     if(!type) {
       type=strstr(conn->gname, ";type=");
     }
     if(type) {
       char command;
@@ -1073,51 +1023,55 @@
     /* telnet testing factory */
     conn->protocol |= PROT_TELNET;
     if(!data->port)
       data->port = PORT_TELNET;
     data->remote_port = PORT_TELNET;
 
-    conn->curl_do = telnet;
-    conn->curl_done = telnet_done;
+    conn->curl_do = Curl_telnet;
+    conn->curl_done = Curl_telnet_done;
 
   }
   else if (strequal(conn->proto, "DICT")) {
     conn->protocol |= PROT_DICT;
     if(!data->port)
       data->port = PORT_DICT;
     data->remote_port = PORT_DICT;
-    conn->curl_do = dict;
-    conn->curl_done = dict_done;
+    conn->curl_do = Curl_dict;
+    conn->curl_done = Curl_dict_done;
   }
   else if (strequal(conn->proto, "LDAP")) {
     conn->protocol |= PROT_LDAP;
     if(!data->port)
       data->port = PORT_LDAP;
     data->remote_port = PORT_LDAP;
-    conn->curl_do = ldap;
-    conn->curl_done = ldap_done;
+    conn->curl_do = Curl_ldap;
+    conn->curl_done = Curl_ldap_done;
   }
   else if (strequal(conn->proto, "FILE")) {
     conn->protocol |= PROT_FILE;
 
     conn->curl_do = file;
     /* no done() function */
 
-    result = Transfer(conn, -1, -1, FALSE, NULL, /* no download */
+    result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
                       -1, NULL); /* no upload */
 
     return CURLE_OK;
   }
-
   else {
+    /* We fell through all checks and thus we don't support the specified
+       protocol */
     failf(data, "Unsupported protocol: %s", conn->proto);
     return CURLE_UNSUPPORTED_PROTOCOL;
   }
 
+  /*************************************************************
+   * .netrc scanning coming up
+   *************************************************************/
   if(data->bits.use_netrc) {
-    if(ParseNetrc(data->hostname, data->user, data->passwd)) {
+    if(Curl_parsenetrc(data->hostname, data->user, data->passwd)) {
       infof(data, "Couldn't find host %s in the .netrc file, using defaults",
             data->hostname);
     }
     /* weather we failed or not, we don't know which fields that were filled
        in anyway */
     if(!data->user[0])
@@ -1128,15 +1082,15 @@
       data->bits.user_passwd = 1; /* enable user+password */
     }
   }
   else if(!(data->bits.user_passwd) &&
 	  (conn->protocol & (PROT_FTP|PROT_HTTP)) ) {
     /* This is a FTP or HTTP URL, and we haven't got the user+password in
-       the extra parameter, we will now try to extract the possible
-       user+password pair in a string like:
-       ftp://user:password@ftp.my.site:8021/README */
+     * the extra parameter, we will now try to extract the possible
+     * user+password pair in a string like:
+     * ftp://user:password@ftp.my.site:8021/README */
     char *ptr=NULL; /* assign to remove possible warnings */
     if((ptr=strchr(conn->name, '@'))) {
       /* there's a user+password given here, to the left of the @ */
 
       data->user[0] =0;
       data->passwd[0]=0;
@@ -1182,24 +1136,56 @@
     else {
       strcpy(data->user, CURL_DEFAULT_USER);
       strcpy(data->passwd, CURL_DEFAULT_PASSWORD);
     }
   }
 
+  /*************************************************************
+   * Figure out the remote port number
+   *
+   * No matter if we use a proxy or not, we have to figure out the remote
+   * port number of various reasons.
+   *
+   * To be able to detect port number flawlessly, we must not confuse them
+   * IPv6-specified addresses in the [0::1] style.
+   *************************************************************/
+
+  if((1 == sscanf(conn->name, "[%*39[0-9a-fA-F:]%c", &endbracket)) &&
+     (']' == endbracket)) {
+    /* this is a IPv6-style specified IP-address */
+#ifndef ENABLE_IPV6
+    failf(data, "You haven't enabled IPv6 support");
+    return CURLE_URL_MALFORMAT;
+#else
+    tmp = strchr(conn->name, ']');
+
+    tmp++; /* pass the ending bracket */
+    if(':' != *tmp)
+      tmp = NULL; /* no port number available */
+#endif
+  }
+  else {
+    /* traditional IPv4-style port-extracting */
+    tmp = strchr(conn->name, ':');
+  }
+
+  if (tmp) {
+    *tmp++ = '\0'; /* cut off the name there */
+    data->remote_port = atoi(tmp);
+  }
+
+  /*************************************************************
+   * Resolve the name of the server or proxy
+   *************************************************************/
   if(!data->bits.httpproxy) {
     /* If not connecting via a proxy, extract the port from the URL, if it is
      * there, thus overriding any defaults that might have been set above. */
-    tmp = strchr(conn->name, ':');
-    if (tmp) {
-      *tmp++ = '\0';
-      data->port = atoi(tmp);
-    }
-    data->remote_port = data->port; /* it is the same port */
+    data->port =  data->remote_port; /* it is the same port */
 
     /* Connect to target host right on */
-    conn->hp = GetHost(data, conn->name, &conn->hostent_buf);
+    conn->hp = Curl_gethost(data, conn->name, &conn->hostent_buf);
     if(!conn->hp) {
       failf(data, "Couldn't resolve host '%s'", conn->name);
       return CURLE_COULDNT_RESOLVE_HOST;
     }
   }
   else {
@@ -1215,20 +1201,12 @@
 
     if(NULL == proxydup) {
       failf(data, "memory shortage");
       return CURLE_OUT_OF_MEMORY;
     }
 
-    /* we use proxy all right, but we wanna know the remote port for SSL
-       reasons */
-    tmp = strchr(conn->name, ':');
-    if (tmp) {
-      *tmp++ = '\0'; /* cut off the name there */
-      data->remote_port = atoi(tmp);
-    }
-
     /* Daniel Dec 10, 1998:
        We do the proxy host string parsing here. We want the host name and the
        port name. Accept a protocol:// prefix, even though it should just be
        ignored. */
 
     /* 1. skip the protocol part if present */
@@ -1249,68 +1227,68 @@
       /* None given in the proxy string, then get the default one if it is
          given */
       data->port = data->proxyport;
     }
 
     /* connect to proxy */
-    conn->hp = GetHost(data, proxyptr, &conn->hostent_buf);
+    conn->hp = Curl_gethost(data, proxyptr, &conn->hostent_buf);
     if(!conn->hp) {
       failf(data, "Couldn't resolve proxy '%s'", proxyptr);
       return CURLE_COULDNT_RESOLVE_PROXY;
     }
 
     free(proxydup); /* free the duplicate pointer and not the modified */
   }
-  pgrsTime(data, TIMER_NAMELOOKUP);
+  Curl_pgrsTime(data, TIMER_NAMELOOKUP);
 
   data->firstsocket = socket(AF_INET, SOCK_STREAM, 0);
 
   memset((char *) &conn->serv_addr, '\0', sizeof(conn->serv_addr));
   memcpy((char *)&(conn->serv_addr.sin_addr),
          conn->hp->h_addr, conn->hp->h_length);
   conn->serv_addr.sin_family = conn->hp->h_addrtype;
   conn->serv_addr.sin_port = htons(data->port);
 
-#ifndef WIN32 
+#if !defined(WIN32)||defined(__CYGWIN32__)
   /* We don't generally like checking for OS-versions, we should make this
      HAVE_XXXX based, although at the moment I don't have a decent test for
      this! */
 
-  /* sck 8/31/2000 add support for specifing device to bind socket to */
-  /* I am using this, but it may not work everywhere, only tested on
-     RedHat 6.2 */
 #ifdef HAVE_INET_NTOA
 
 #ifndef INADDR_NONE
 #define INADDR_NONE (unsigned long) ~0
 #endif
 
+  /*************************************************************
+   * Select device to bind socket to
+   *************************************************************/
   if (data->device && (strlen(data->device)<255)) {
     struct sockaddr_in sa;
     struct hostent *h=NULL;
     char *hostdataptr=NULL;
     size_t size;
     char myhost[256] = "";
     unsigned long in;
 
-    if(if2ip(data->device, myhost, sizeof(myhost))) {
-      h = GetHost(data, myhost, &hostdataptr);
+    if(Curl_if2ip(data->device, myhost, sizeof(myhost))) {
+      h = Curl_gethost(data, myhost, &hostdataptr);
     }
     else {
       if(strlen(data->device)>1) {
-        h = GetHost(data, data->device, &hostdataptr);
+        h = Curl_gethost(data, data->device, &hostdataptr);
       }
       if(h) {
         /* we know data->device is shorter than the myhost array */
         strcpy(myhost, data->device);
       }
     }
 
     if(! *myhost) {
       /* need to fix this
-         h=GetHost(data,
+         h=Curl_gethost(data,
          getmyhost(*myhost,sizeof(myhost)),
          hostent_buf,
          sizeof(hostent_buf));
       */
       printf("in here\n");
     }
@@ -1381,18 +1359,21 @@
     else {
       failf(data, "could't find my own IP address (%s)", myhost);
       return CURLE_HTTP_PORT_FAILED;
     }
 
     if(hostdataptr)
-      free(hostdataptr); /* allocated by GetHost() */
+      free(hostdataptr); /* allocated by Curl_gethost() */
 
   } /* end of device selection support */
 #endif  /* end of HAVE_INET_NTOA */
 #endif /* end of not WIN32 */
 
+  /*************************************************************
+   * Connect to server/proxy
+   *************************************************************/
   if (connect(data->firstsocket,
               (struct sockaddr *) &(conn->serv_addr),
               sizeof(conn->serv_addr)
               ) < 0) {
     switch(errno) {
 #ifdef ECONNREFUSED
@@ -1436,45 +1417,58 @@
       failf(data, "Can't connect to server: %d", errno);
       break;
     }
     return CURLE_COULDNT_CONNECT;
   }
 
+  /*************************************************************
+   * Proxy authentication
+   *************************************************************/
   if(data->bits.proxy_user_passwd) {
     char *authorization;
     snprintf(data->buffer, BUFSIZE, "%s:%s",
              data->proxyuser, data->proxypasswd);
-    if(base64_encode(data->buffer, strlen(data->buffer),
-                    &authorization) >= 0) {
+    if(Curl_base64_encode(data->buffer, strlen(data->buffer),
+                          &authorization) >= 0) {
       data->ptr_proxyuserpwd =
-        maprintf("Proxy-authorization: Basic %s\015\012", authorization);
+        aprintf("Proxy-authorization: Basic %s\015\012", authorization);
       free(authorization);
     }
   }
+
+  /*************************************************************
+   * Send user-agent to HTTP proxies even if the target protocol
+   * isn't HTTP.
+   *************************************************************/
   if((conn->protocol&PROT_HTTP) || data->bits.httpproxy) {
     if(data->useragent) {
-      data->ptr_uagent = maprintf("User-Agent: %s\015\012", data->useragent);
+      data->ptr_uagent =
+        aprintf("User-Agent: %s\015\012", data->useragent);
     }
   }
 
   if(conn->curl_connect) {
     /* is there a connect() procedure? */
-    conn->now = tvnow(); /* set this here for timeout purposes in the
-                            connect procedure, it is later set again for the
-                            progress meter purpose */
+
+    /* set start time here for timeout purposes in the
+     * connect procedure, it is later set again for the
+     * progress meter purpose */
+    conn->now = Curl_tvnow();
+
+    /* Call the protocol-specific connect function */
     result = conn->curl_connect(conn);
     if(result != CURLE_OK)
       return result; /* pass back errors */
   }
 
-  pgrsTime(data, TIMER_CONNECT); /* we're connected */
+  Curl_pgrsTime(data, TIMER_CONNECT); /* we're connected */
 
-  conn->now = tvnow(); /* time this *after* the connect is done */
+  conn->now = Curl_tvnow(); /* time this *after* the connect is done */
   conn->bytecount = 0;
   
-  /* Figure out the ip-number and the first host name it shows: */
+  /* Figure out the ip-number and display the first host name it shows: */
   {
     struct in_addr in;
     (void) memcpy(&in.s_addr, *conn->hp->h_addr_list, sizeof (in.s_addr));
     infof(data, "Connected to %s (%s)\n", conn->hp->h_name, inet_ntoa(in));
   }
 
@@ -1557,13 +1551,13 @@
   /* this calls the protocol-specific function pointer previously set */
   if(conn->curl_done)
     result = conn->curl_done(conn);
   else
     result = CURLE_OK;
 
-  pgrsDone(data); /* done with the operation */
+  Curl_pgrsDone(data); /* done with the operation */
 
   conn->state = CONN_DONE;
 
   return result;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/urldata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/urldata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/urldata.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/urldata.h	2001-01-26 23:52:01.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urldata.h,v 1.36 2001/01/03 09:29:34 bagder Exp $
+ * $Id: urldata.h,v 1.39 2001/01/26 15:52:01 bagder Exp $
  *****************************************************************************/
 
 /* This file is for lib internal stuff */
 
 #include "setup.h"
 
@@ -79,42 +79,49 @@
 
 #include <curl/curl.h>
 
 /* Download buffer size, keep it fairly big for speed reasons */
 #define BUFSIZE (1024*50)
 
-/* Upload buffer size, keep it smallish to get faster progress meter
-   updates. This should probably become dynamic and adjust to the upload
+/* Defaul upload buffer size, keep it smallish to get faster progress meter
+   updates. This is just default, it is dynamic and adjusts to the upload
    speed. */
 #define UPLOAD_BUFSIZE (1024*2)
 
 /* Initial size of the buffer to store headers in, it'll be enlarged in case
    of need. */
 #define HEADERSIZE 256
 
+/* Just a convenience macro to get the larger value out of two given */
 #ifndef MAX
 #define MAX(x,y) ((x)>(y)?(x):(y))
 #endif
 
+/* Type of handle. All publicly returned 'handles' in the curl interface
+   have a handle first in the struct that describes what kind of handle it
+   is. Used to detect bad handle usage. */
 typedef enum {
   STRUCT_NONE,
   STRUCT_OPEN,
   STRUCT_CONNECT,
   STRUCT_LAST
 } Handle;
 
+/* Connecting to a remote server using the curl interface is moving through
+   a state machine, this type is used to store the current state */
 typedef enum {
   CONN_NONE,  /* illegal state */
   CONN_INIT,  /* curl_connect() has been called */
   CONN_DO,    /* curl_do() has been called successfully */
   CONN_DONE,  /* curl_done() has been called successfully */
   CONN_ERROR, /* and error has occurred */
   CONN_LAST   /* illegal state */
 } ConnState;
 
 #ifdef KRB4
+/* Types needed for krb4-ftp connections */
 struct krb4buffer {
   void *data;
   size_t size;
   size_t index;
   int eof_flag;
 };
@@ -152,19 +159,19 @@
 #define PROT_LDAP    (1<<7)
 #define PROT_FILE    (1<<8)
 
   char *hostent_buf; /* pointer to allocated memory for name info */
   struct hostent *hp;
   struct sockaddr_in serv_addr;
-  char proto[64];
-  char gname[256];
-  char *name;
-  char *path; /* formerly staticly this size: URL_MAX_LENGTH */
+  char proto[64];  /* store the protocol string in this buffer */
+  char gname[257]; /* store the hostname in this buffer */
+  char *name;      /* host name pointer to fool around with */
+  char *path;      /* allocated buffer to store the URL's path part in */
   char *ppath;
   long bytecount;
-  struct timeval now;
+  struct timeval now; /* current time */
 
   long upload_bufsize; /* adjust as you see fit, never bigger than BUFSIZE
                           never smaller than UPLOAD_BUFSIZE */
 
   /* These two functions MUST be set by the curl_connect() function to be
      be protocol dependent */
@@ -245,15 +252,15 @@
 /****************************************************************************
  * HTTP unique setup
  ***************************************************************************/
 struct HTTP {
   struct FormData *sendit;
   int postsize;
-  char *p_pragma;
-  char *p_accept;
-  long readbytecount;
+  char *p_pragma;      /* Pragma: string */
+  char *p_accept;      /* Accept: string */
+  long readbytecount; 
   long writebytecount;
 
   /* For FORM posting */
   struct Form form;
   size_t (*storefread)(char *, size_t , size_t , FILE *);
   FILE *in;
@@ -261,33 +268,48 @@
 
 /****************************************************************************
  * FTP unique setup
  ***************************************************************************/
 struct FTP {
   long *bytecountp;
-  char *user;
-  char *passwd;
+  char *user;    /* user name string */
+  char *passwd;  /* password string */
   char *urlpath; /* the originally given path part of the URL */
   char *dir;     /* decoded directory */
   char *file;    /* decoded file */
 };
 
+typedef enum {
+  HTTPREQ_NONE, /* first in list */
+  HTTPREQ_GET,
+  HTTPREQ_POST,
+  HTTPREQ_POST_FORM, /* we make a difference internally */
+  HTTPREQ_PUT,
+  HTTPREQ_CUSTOM,
+  HTTPREQ_LAST /* last in list */
+} Curl_HttpReq;
+
+/* This struct is for boolean settings that define how to behave during
+   this session. */
 struct Configbits {
+  /* these four request types mirror the httpreq field */
+  bool http_formpost;
+  bool http_post;
+  bool http_put;
+  bool http_get;
+
   bool get_filetime;
   bool tunnel_thru_httpproxy;
   bool ftp_append;
   bool ftp_ascii;
   bool ftp_list_only;
   bool ftp_use_port;
   bool hide_progress;
   bool http_fail_on_error;
   bool http_follow_location;
-  bool http_formpost;
   bool http_include_header;
-  bool http_post;
-  bool http_put;
   bool http_set_referer;
   bool http_auto_referer; /* set "correct" referer when following location: */
   bool httpproxy;
   bool mute;
   bool no_body;
   bool proxy_user_passwd;
@@ -310,12 +331,13 @@
   CURLI_NONE,
   CURLI_EASY,
   CURLI_NORMAL,
   CURLI_LAST
 } CurlInterface;
 
+/* struct for data related to SSL and SSL connections */
 struct ssldata {
   bool use;              /* use ssl encrypted communications TRUE/FALSE */
   long version;          /* what version the client wants to use */
   long certverifyresult; /* result from the certificate verification */
   long verifypeer;       /* set TRUE if this is desired */
   char *CApath;          /* DOES NOT WORK ON WINDOWS */
@@ -465,36 +487,39 @@
   struct ssldata ssl; /* this is for ssl-stuff */
 
   long crlf;
   struct curl_slist *quote;     /* before the transfer */
   struct curl_slist *postquote; /* after the transfer */
 
-  TimeCond timecondition;
-  time_t timevalue;
+  TimeCond timecondition; /* kind of comparison */
+  time_t timevalue;       /* what time to compare with */
+
+  Curl_HttpReq httpreq; /* what kind of HTTP request (if any) is this */
 
   char *customrequest; /* http/ftp request to use */
 
   char *headerbuff; /* allocated buffer to store headers in */
   int headersize;   /* size of the allocation */
 
 #if 0
   /* this was removed in libcurl 7.4 */
   char *writeinfo;  /* if non-NULL describes what to output on a successful
                        completion */
 #endif
 
-  struct Progress progress;
+  struct Progress progress; /* for all the progress meter data */
 
 #define MAX_CURL_USER_LENGTH 128
 #define MAX_CURL_PASSWORD_LENGTH 128
 
   char *auth_host; /* if set, this is the allocated string to the host name
                     * to which to send the authorization data to, and no other
                     * host (which location-following otherwise could lead to)
                     */
 
+  /* buffers to store authentication data in */
   char user[MAX_CURL_USER_LENGTH];
   char passwd[MAX_CURL_PASSWORD_LENGTH];
   char proxyuser[MAX_CURL_USER_LENGTH];
   char proxypasswd[MAX_CURL_PASSWORD_LENGTH];
 
   /**** Dynamicly allocated strings, may need to be freed on return ****/
@@ -503,13 +528,13 @@
   char *ptr_userpwd; /* free later if not NULL! */
   char *ptr_rangeline; /* free later if not NULL! */
   char *ptr_ref; /* free later if not NULL! */
   char *ptr_cookie; /* free later if not NULL! */
   char *ptr_host; /* free later if not NULL */
 
-  char *krb4_level;
+  char *krb4_level; /* what security level */
 #ifdef KRB4
   FILE *cmdchannel;
 #endif
 
   struct timeval keeps_speed; /* this should be request-specific */
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/url.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/url.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/url.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/url.h	2001-01-25 20:25:00.000000000 +0800
@@ -17,11 +17,12 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.h,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: url.h,v 1.5 2001/01/05 10:11:43 bagder Exp $
  *****************************************************************************/
-int GetLine(int sockfd, char *buf, struct UrlData *data);
+
+/* empty */
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/version.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/version.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/lib/version.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/lib/version.c	2001-01-23 16:16:59.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: version.c,v 1.7 2001/01/03 09:29:34 bagder Exp $
+ * $Id: version.c,v 1.9 2001/01/23 08:16:59 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <stdio.h>
@@ -30,43 +30,52 @@
 #include "urldata.h"
 
 char *curl_version(void)
 {
   static char version[200];
   char *ptr;
-#if defined(USE_SSLEAY)
-  static char sub[2];
-#endif
   strcpy(version, LIBCURL_NAME " " LIBCURL_VERSION );
   ptr=strchr(version, '\0');
 
 #ifdef USE_SSLEAY
 
 #if (SSLEAY_VERSION_NUMBER >= 0x900000)
   sprintf(ptr, " (SSL %lx.%lx.%lx)",
           (SSLEAY_VERSION_NUMBER>>28)&0xff,
           (SSLEAY_VERSION_NUMBER>>20)&0xff,
           (SSLEAY_VERSION_NUMBER>>12)&0xf);
 #else
-  if(SSLEAY_VERSION_NUMBER&0x0f) {
-    sub[0]=(SSLEAY_VERSION_NUMBER&0x0f) + 'a' -1;
+  {
+    char sub[2];
+    if(SSLEAY_VERSION_NUMBER&0x0f) {
+      sub[0]=(SSLEAY_VERSION_NUMBER&0x0f) + 'a' -1;
+    }
+    else
+      sub[0]=0;
+
+    sprintf(ptr, " (SSL %x.%x.%x%s)",
+            (SSLEAY_VERSION_NUMBER>>12)&0xff,
+            (SSLEAY_VERSION_NUMBER>>8)&0xf,
+            (SSLEAY_VERSION_NUMBER>>4)&0xf, sub);
   }
-  else
-    sub[0]=0;
-
-  sprintf(ptr, " (SSL %x.%x.%x%s)",
-          (SSLEAY_VERSION_NUMBER>>12)&0xff,
-          (SSLEAY_VERSION_NUMBER>>8)&0xf,
-          (SSLEAY_VERSION_NUMBER>>4)&0xf, sub);
-
 #endif
   ptr=strchr(ptr, '\0');
 #endif
 
+#if defined(KRB4) || defined(ENABLE_IPV6)
+  strcat(ptr, " (");
+  ptr+=2;
 #ifdef KRB4
-  sprintf(ptr, " (krb4 enabled)");
+  sprintf(ptr, "krb4 ");
+  ptr += strlen(ptr);
+#endif
+#ifdef ENABLE_IPV6
+  sprintf(ptr, "ipv6 ");
+  ptr += strlen(ptr);
+#endif
+  sprintf(ptr, "enabled)");
   ptr += strlen(ptr);
 #endif
 
 #ifdef USE_ZLIB
   sprintf(ptr, " (zlib %s)", zlibVersion());
   ptr += strlen(ptr);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/Makefile.am	2000-11-17 23:30:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/Makefile.am	2001-01-09 18:09:13.000000000 +0800
@@ -1,12 +1,47 @@
 #
-# $Id: Makefile.am,v 1.7 2000/11/17 15:30:01 bagder Exp $
+# $Id: Makefile.am,v 1.13 2001/01/09 10:09:13 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-EXTRA_DIST = curl.spec curl-ssl.spec
+EXTRA_DIST = \
+	CHANGES LEGAL maketgz MITX.txt MPL-1.1.txt \
+	config-win32.h reconf packages/README Makefile.dist
 
-SUBDIRS = docs lib src include tests
+SUBDIRS = docs lib src include tests packages
+
+# create a root makefile in the distribution:
+dist-hook:
+	cp $(srcdir)/Makefile.dist $(distdir)/Makefile
+
+check: test
 
 test:
 	@(cd tests; make quiet-test)
+
+#
+# Build source and binary rpms. For rpm-3.0 and above, the ~/.rpmmacros
+# must contain the following line:
+# %_topdir /home/loic/local/rpm
+# and that /home/loic/local/rpm contains the directory SOURCES, BUILD etc.
+#
+# cd /home/loic/local/rpm ; mkdir -p SOURCES BUILD RPMS/i386 SPECS SRPMS
+#
+# If additional configure flags are needed to build the package, add the
+# following in ~/.rpmmacros
+# %configure CFLAGS="%{optflags}" ./configure %{_target_platform} --prefix=%{_prefix} ${AM_CONFIGFLAGS}
+# and run make rpm in the following way:
+# AM_CONFIGFLAGS='--with-uri=/home/users/loic/local/RedHat-6.2' make rpm
+#
+
+rpms:
+	$(MAKE) RPMDIST=curl rpm
+	$(MAKE) RPMDIST=curl-ssl rpm
+
+rpm:
+	RPM_TOPDIR=`rpm --showrc | $(PERL) -n -e 'print if(s/.*_topdir\s+(.*)/$$1/)'` ; \
+	cp $(srcdir)/packages/Linux/RPM/$(RPMDIST).spec $$RPM_TOPDIR/SPECS ; \
+	cp $(PACKAGE)-$(VERSION).tar.gz $$RPM_TOPDIR/SOURCES ; \
+	rpm -ba --clean --rmsource $$RPM_TOPDIR/SPECS/$(RPMDIST).spec ; \
+	mv $$RPM_TOPDIR/RPMS/i386/$(RPMDIST)-*.rpm . ; \
+	mv $$RPM_TOPDIR/SRPMS/$(RPMDIST)-*.src.rpm .
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6: Makefile.dist
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/Makefile.in	2001-01-04 21:57:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/Makefile.in	2001-01-27 23:41:57.000000000 +0800
@@ -8,17 +8,17 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.7 2000/11/17 15:30:01 bagder Exp $
+# $Id: Makefile.am,v 1.13 2001/01/09 10:09:13 bagder Exp $
 #
 
 
-SHELL = /bin/sh
+SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 prefix = @prefix@
 exec_prefix = @exec_prefix@
@@ -76,15 +76,16 @@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-EXTRA_DIST = curl.spec curl-ssl.spec
+EXTRA_DIST =  	CHANGES LEGAL maketgz MITX.txt MPL-1.1.txt 	config-win32.h reconf packages/README Makefile.dist
 
-SUBDIRS = docs lib src include tests
+
+SUBDIRS = docs lib src include tests packages
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = config.h ./src/config.h
 CONFIG_CLEAN_FILES = 
 DIST_COMMON =  README ./stamp-h1.in Makefile.am Makefile.in acconfig.h \
 acinclude.m4 aclocal.m4 config.guess config.h.in config.sub configure \
@@ -264,12 +265,13 @@
 	GZIP=$(GZIP_ENV) $(TAR) chozf $(distdir).tar.gz $(distdir)
 	-rm -rf $(distdir)
 distdir: $(DISTFILES)
 	-rm -rf $(distdir)
 	mkdir $(distdir)
 	-chmod 777 $(distdir)
+	$(mkinstalldirs) $(distdir)/packages
 	@for file in $(DISTFILES); do \
 	  d=$(srcdir); \
 	  if test -d $$d/$$file; then \
 	    cp -pr $$/$$file $(distdir)/$$file; \
 	  else \
 	    test -f $(distdir)/$$file \
@@ -284,12 +286,13 @@
 	    || exit 1; \
 	    chmod 777 $(distdir)/$$subdir; \
 	    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(distdir) distdir=../$(distdir)/$$subdir distdir) \
 	      || exit 1; \
 	  fi; \
 	done
+	$(MAKE) $(AM_MAKEFLAGS) top_distdir="$(top_distdir)" distdir="$(distdir)" dist-hook
 info-am:
 info: info-recursive
 dvi-am:
 dvi: dvi-recursive
 check-am: all-am
 check: check-recursive
@@ -359,12 +362,45 @@
 install-exec-am install-exec install-data-am install-data install-am \
 install uninstall-am uninstall all-redirect all-am all installdirs-am \
 installdirs mostlyclean-generic distclean-generic clean-generic \
 maintainer-clean-generic clean mostlyclean distclean maintainer-clean
 
 
+# create a root makefile in the distribution:
+dist-hook:
+	cp $(srcdir)/Makefile.dist $(distdir)/Makefile
+
+check: test
+
 test:
 	@(cd tests; make quiet-test)
 
+#
+# Build source and binary rpms. For rpm-3.0 and above, the ~/.rpmmacros
+# must contain the following line:
+# %_topdir /home/loic/local/rpm
+# and that /home/loic/local/rpm contains the directory SOURCES, BUILD etc.
+#
+# cd /home/loic/local/rpm ; mkdir -p SOURCES BUILD RPMS/i386 SPECS SRPMS
+#
+# If additional configure flags are needed to build the package, add the
+# following in ~/.rpmmacros
+# %configure CFLAGS="%{optflags}" ./configure %{_target_platform} --prefix=%{_prefix} ${AM_CONFIGFLAGS}
+# and run make rpm in the following way:
+# AM_CONFIGFLAGS='--with-uri=/home/users/loic/local/RedHat-6.2' make rpm
+#
+
+rpms:
+	$(MAKE) RPMDIST=curl rpm
+	$(MAKE) RPMDIST=curl-ssl rpm
+
+rpm:
+	RPM_TOPDIR=`rpm --showrc | $(PERL) -n -e 'print if(s/.*_topdir\s+(.*)/$$1/)'` ; \
+	cp $(srcdir)/packages/Linux/RPM/$(RPMDIST).spec $$RPM_TOPDIR/SPECS ; \
+	cp $(PACKAGE)-$(VERSION).tar.gz $$RPM_TOPDIR/SOURCES ; \
+	rpm -ba --clean --rmsource $$RPM_TOPDIR/SPECS/$(RPMDIST).spec ; \
+	mv $$RPM_TOPDIR/RPMS/i386/$(RPMDIST)-*.rpm . ; \
+	mv $$RPM_TOPDIR/SRPMS/$(RPMDIST)-*.src.rpm .
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/maketgz /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/maketgz
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/maketgz	2000-10-23 21:55:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/maketgz	2001-01-08 20:51:36.000000000 +0800
@@ -55,35 +55,16 @@
   # no such executable
   return 0
 }
 
 ############################################################################
 #
-# If we have autoconf we can just as well update configure.in to contain our
-# brand new version number:
+# Enforce a rerun of configure (updates the VERSION)
 #
- 
-#if { findprog autoconf >/dev/null 2>/dev/null; } then
-#  echo "- No autoconf found, we leave configure as it is"
-#else
-#  # Replace version number in configure.in file:
-#
-#  CONF="configure.in"
-#
-#  sed 's/^AM_INIT_AUTOMAKE.*/AM_INIT_AUTOMAKE(curl,"'$version'")/g' $CONF >$CONF.new
-#
-#  # Save old  file
-#  cp -p $CONF $CONF.old
-#
-#  # Make new configure.in
-#  mv $CONF.new $CONF
-# 
-#  # Update the configure script
-#  echo "Runs autoconf"
-#  autoconf
-#fi
+
+./config.status --recheck
 
 ############################################################################
 #
 # automake is needed to run to make a non-GNU Makefile.in if Makefile.am has
 # been modified.
 #
@@ -94,68 +75,10 @@
   echo "Runs automake --include-deps"
   automake --include-deps
 fi
 
 ############################################################################
 #
-# Now run make first to make the file dates decent and make sure that it
-# compiles just before release!
-#
-
-make
-
-# get current dir
-dir=`pwd`
-
-# Get basename
-orig=`basename $dir`
-
-# Get the left part of the dash (-)
-new=`echo $orig | cut -d- -f1`
-
-# Build new directory name
-n=$new-$version;
-
-# Tell the world what we're doing
-echo "Copying files into distribution archive";
-
-if [ -r $n ]; then
-  echo "Directory already exists!"
-  exit
-fi
-
-# Create the new dir
-mkdir $n
-
-# Copy all relevant files, with path and permissions!
-tar -cf - `cat FILES` | (cd $n; tar -xBpf -)
-
-# Create the distribution root Makefile from Makefile.dist
-cp -p Makefile.dist $n/Makefile
-
-############################################################################
-#
-# Replace @SHELL@ with /bin/sh in the Makefile.in files!
+# Now run make dist
 #
-echo "Replace @SHELL@ with /bin/sh in the Makefile.in files"
-temp=/tmp/curl$$
-for file in Makefile.in lib/Makefile.in src/Makefile.in; do
-  in="$n/$file"
-  sed "s:@SHELL@:/bin/sh:g" $in >$temp
-  cp $temp $in
-done
-rm -rf $temp
-
-# Tell the world what we're doing
-echo "creates $n.tar.gz";
-
-# Make a tar archive of it all
-tar -cvf $n.tar $n
-
-# gzip the archive
-gzip $n.tar
-
-# Make it world readable
-chmod a+r $n.tar.gz ;
 
-# Delete the temp dir
-rm -rf $n
+make dist
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Linux: Makefile.am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Linux: Makefile.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/packages/Linux/RPM: curl.spec
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Linux/RPM: curl.spec.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/packages/Linux/RPM: curl-ssl.spec
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Linux/RPM: curl-ssl.spec.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Linux/RPM: Makefile.am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Linux/RPM: Makefile.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages: Makefile.am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages: Makefile.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Win32: Makefile.am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/packages/Win32: Makefile.in
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/hugehelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/hugehelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/hugehelp.c	2001-01-04 18:23:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/hugehelp.c	2001-01-25 19:11:31.000000000 +0800
@@ -10,133 +10,139 @@
 "                             \\___|\\___/|_| \\_\\_____|\n"
 "NAME\n"
 "     curl - get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE,\n"
 "     HTTP or HTTPS syntax.\n"
 "\n"
 "SYNOPSIS\n"
-"     curl [options] url\n"
+"     curl [options] [URL...]\n"
 "\n"
 "DESCRIPTION\n"
-"     curl is a client to get documents/files from servers,  using\n"
-"     any  of  the supported protocols. The command is designed to\n"
-"     work without user interaction or any kind of  interactivity.\n"
+"     curl is a client to get documents/files from or  send  docu­\n"
+"     ments  to  a  server,  using  any of the supported protocols\n"
+"     (HTTP, HTTPS, FTP, GOPHER, DICT, TELNET, LDAP or FILE).  The\n"
+"     command  is designed to work without user interaction or any\n"
+"     kind of interactivity.\n"
 "\n"
-"     curl  offers  a busload of useful tricks like proxy support,\n"
-"     user authentication, ftp upload,  HTTP  post,  SSL  (https:)\n"
+"     curl offers a busload of useful tricks like  proxy  support,\n"
+"     user  authentication,  ftp  upload,  HTTP post, SSL (https:)\n"
 "     connections, cookies, file transfer resume and more.\n"
 "\n"
 "URL\n"
 "     The URL syntax is protocol dependent. You'll find a detailed\n"
 "     description in RFC 2396.\n"
 "\n"
-"     You can specify multiple URLs or parts of  URLs  by  writing\n"
+"     You  can  specify  multiple URLs or parts of URLs by writing\n"
 "     part sets within braces as in:\n"
 "\n"
 "      http://site.{one,two,three}.com\n"
 "\n"
-"     or  you can get sequences of alphanumeric series by using []\n"
+"     or you can get sequences of alphanumeric series by using  []\n"
 "     as in:\n"
 "\n"
 "      ftp://ftp.numericals.com/file[1-100].txt\n"
 "      ftp://ftp.numericals.com/file[001-100].txt    (with leading\n"
 "     zeros)\n"
 "      ftp://ftp.letters.com/file[a-z].txt\n"
 "\n"
-"     It  is possible to specify up to 9 sets or series for a URL,\n"
+"     It is possible to specify up to 9 sets or series for a  URL,\n"
 "     but no nesting is supported at the moment:\n"
 "\n"
 "      http://www.any.org/archive[1996-1999]/vol­\n"
 "     ume[1-4]part{a,b,c,index}.html\n"
 "\n"
+"     Starting with curl 7.6, you can specify any amount  of  URLs\n"
+"     on  the  command  line. They will be fetched in a sequential\n"
+"     manner in the specified order.\n"
+"\n"
 "OPTIONS\n"
 "     -a/--append\n"
 "          (FTP) When used in a ftp upload, this will tell curl to\n"
 "          append to the target file instead of overwriting it. If\n"
 "          the file doesn't exist, it will be created.\n"
 "\n"
-"          If  this option is used twice, the second one will dis­\n"
-"          able append mode again.\n"
+"          If this option is  used  twice,  the  second  one  will\n"
+"          disable append mode again.\n"
 "\n"
 "     -A/--user-agent <agent string>\n"
-"          (HTTP) Specify the User-Agent string  to  send  to  the\n"
-"          HTTP  server.  Some badly done CGIs fail if its not set\n"
-"          to \"Mozilla/4.0\".  To  encode  blanks  in  the  string,\n"
-"          surround  the string with single quote marks.  This can\n"
+"          (HTTP)  Specify  the  User-Agent  string to send to the\n"
+"          HTTP server. Some badly done CGIs fail if its  not  set\n"
+"          to \"Mozilla/4.0\".  To encode blanks in the string, sur­\n"
+"          round the string with single  quote  marks.   This  can\n"
 "          also be set with the -H/--header flag of course.\n"
 "\n"
-"          If this option is used more than  once,  the  last  one\n"
+"          If  this  option  is  used more than once, the last one\n"
 "          will be the one to be used.\n"
 "\n"
 "     -b/--cookie <name=data>\n"
 "          (HTTP) Pass the data to the HTTP server as a cookie. It\n"
-"          is supposedly the data  previously  received  from  the\n"
-"          server  in a \"Set-Cookie:\" line.  The data should be in\n"
+"          is  supposedly  the  data  previously received from the\n"
+"          server in a \"Set-Cookie:\" line.  The data should be  in\n"
 "          the format \"NAME1=VALUE1; NAME2=VALUE2\".\n"
 "\n"
-"          If no '=' letter is used in the line, it is treated  as\n"
-"          a  filename  to  use  to  read previously stored cookie\n"
-"          lines from, which should be used  in  this  session  if\n"
+"          If  no '=' letter is used in the line, it is treated as\n"
+"          a filename to use  to  read  previously  stored  cookie\n"
+"          lines  from,  which  should  be used in this session if\n"
 "          they  match.  Using  this  method  also  activates  the\n"
-"          \"cookie parser\" which will make  curl  record  incoming\n"
+"          \"cookie  parser\"  which  will make curl record incoming\n"
 "          cookies too, which may be handy if you're using this in\n"
-"          combination with the  -L/--location  option.  The  file\n"
+"          combination  with  the  -L/--location  option. The file\n"
 "          format of the file to read cookies from should be plain\n"
 "          HTTP headers or the netscape cookie file format.\n"
 "\n"
-"          NOTE that the file specified with -b/--cookie  is  only\n"
-"          used  as  input. No cookies will be stored in the file.\n"
+"          NOTE  that  the file specified with -b/--cookie is only\n"
+"          used as input. No cookies will be stored in  the  file.\n"
 "          To store cookies, save the HTTP headers to a file using\n"
 "          -D/--dump-header!\n"
 "\n"
-"          If  this  option  is  used more than once, the last one\n"
+"          If this option is used more than  once,  the  last  one\n"
 "          will be the one to be used.\n"
 "\n"
 "     -B/--use-ascii\n"
-"          Use ASCII transfer when getting an  FTP  file  or  LDAP\n"
-"          info.  For  FTP,  this can also be enforced by using an\n"
-"          URL that ends with \";type=A\". This option  causes  data\n"
+"          Use  ASCII  transfer  when  getting an FTP file or LDAP\n"
+"          info. For FTP, this can also be enforced  by  using  an\n"
+"          URL  that  ends with \";type=A\". This option causes data\n"
 "          sent to stdout to be in text mode for win32 systems.\n"
 "\n"
-"          If  this option is used twice, the second one will dis­\n"
+"          If this option is used twice, the second one will  dis­\n"
 "          able ASCII usage.\n"
 "\n"
 "     -c/--continue\n"
 "          Deprecated. Use '-C -' instead.  Continue/Resume a pre­\n"
-"          vious  file  transfer.  This instructs curl to continue\n"
-"          appending data on the  file  where  it  was  previously\n"
-"          left,  possibly  because  of a broken connection to the\n"
-"          server. There must be a named physical file  to  append\n"
-"          to  for  this to work.  Note: Upload resume is depening\n"
-"          on a command named SIZE not always present in  all  ftp\n"
+"          vious file transfer. This instructs  curl  to  continue\n"
+"          appending  data  on  the  file  where it was previously\n"
+"          left, possibly because of a broken  connection  to  the\n"
+"          server.  There  must be a named physical file to append\n"
+"          to for this to work.  Note: Upload resume  is  depening\n"
+"          on  a  command named SIZE not always present in all ftp\n"
 "          servers! Upload resume is for FTP only.  HTTP resume is\n"
 "          only possible with HTTP/1.1 or later servers.\n"
 "\n"
 "     -C/--continue-at <offset>\n"
-"          Continue/Resume a previous file transfer at  the  given\n"
-"          offset.  The  given offset is the exact number of bytes\n"
-"          that will be skipped counted from the beginning of  the\n"
+"          Continue/Resume  a  previous file transfer at the given\n"
+"          offset. The given offset is the exact number  of  bytes\n"
+"          that  will be skipped counted from the beginning of the\n"
 "          source file before it is transfered to the destination.\n"
-"          If used with uploads, the ftp server command SIZE  will\n"
-"          not  be  used  by  curl. Upload resume is for FTP only.\n"
-"          HTTP resume is only possible  with  HTTP/1.1  or  later\n"
+"          If  used with uploads, the ftp server command SIZE will\n"
+"          not be used by curl. Upload resume  is  for  FTP  only.\n"
+"          HTTP  resume  is  only  possible with HTTP/1.1 or later\n"
 "          servers.\n"
 "\n"
-"          If  this  option  is  used serveral times, the last one\n"
+"          If this option is used serveral  times,  the  last  one\n"
 "          will be used.\n"
 "\n"
 "     -d/--data <data>\n"
-"          (HTTP) Sends the specified data in a  POST  request  to\n"
-"          the  HTTP server. Note that the data is sent exactly as\n"
-"          specified with no extra processing (with  all  newlines\n"
-"          cut  off).   The  data is expected to be \"url-encoded\".\n"
-"          This will cause curl to pass the  data  to  the  server\n"
+"          (HTTP)  Sends  the  specified data in a POST request to\n"
+"          the HTTP server. Note that the data is sent exactly  as\n"
+"          specified  with  no extra processing (with all newlines\n"
+"          cut off).  The data is expected  to  be  \"url-encoded\".\n"
+"          This  will  cause  curl  to pass the data to the server\n"
 "          using  the  content-type  application/x-www-form-urlen­\n"
 "          coded. Compare to -F. If more than one -d/--data option\n"
 "          is used on the same command line, the data pieces spec­\n"
-"          ified will be merged together with a separating  &-let­\n"
-"          ter.  Thus, using '-d name=daniel -d skill=lousy' would\n"
+"          ified  will be merged together with a separating &-let­\n"
+"          ter. Thus, using '-d name=daniel -d skill=lousy'  would\n"
 "          generate a post chunk that looks like\n"
 "\n"
 "          If you start the data with the letter @, the rest\n"
 "          should be a file name to read the data from, or - if\n"
 "          you want curl to read the data from stdin.  The con­\n"
 "          tents of the file must already be url-encoded. Multiple\n"
@@ -144,31 +150,34 @@
 "\n"
 "          To post data purely binary, you should instead use the\n"
 "          --data-binary option.\n"
 "\n"
 "          -d/--data is the same as --data-ascii.\n"
 "\n"
-"          If this option is used serveral times, the last one\n"
-"          will be used.\n"
+"          If this option is used serveral times, the ones follow­\n"
+"          ing the first will append data.\n"
 "\n"
 "     --data-ascii <data>\n"
 "          (HTTP) This is an alias for the -d/--data option.\n"
 "\n"
-"          If this option is used serveral times, the last one\n"
-"          will be used.\n"
+"          If this option is used serveral times, the ones follow­\n"
+"          ing the first will append data.\n"
 "\n"
 "     --data-binary <data>\n"
 "          (HTTP) This posts data in a similar manner as --data-\n"
 "          ascii does, although when using this option the entire\n"
 "          context of the posted data is kept as-is. If you want\n"
 "          to post a binary file without the strip-newlines fea­\n"
 "          ture of the --data-ascii option, this is for you.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
+"          If this option is used serveral times, the ones follow­\n"
+"          ing the first will append data.\n"
+"\n"
 "     -D/--dump-header <file>\n"
 "          (HTTP/FTP) Write the HTTP headers to this file. Write\n"
 "          the FTP file info to this file if -I/--head is used.\n"
 "\n"
 "          This option is handy to use when you want to store the\n"
 "          cookies that a HTTP site sends to you. The cookies\n"
@@ -212,14 +221,14 @@
 "     -f/--fail\n"
 "          (HTTP) Fail silently (no output at all) on server\n"
 "          errors. This is mostly done like this to better enable\n"
 "          scripts etc to better deal with failed attempts. In\n"
 "          normal cases when a HTTP server fails to deliver a doc­\n"
 "          ument, it returns a HTML document stating so (which\n"
-"          often also describes why and more). This flag will\n"
-"          prevent curl from outputting that and fail silently\n"
+"          often also describes why and more). This flag will pre­\n"
+"          vent curl from outputting that and fail silently\n"
 "          instead.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable silent failure.\n"
 "\n"
 "     -F/--form <name=content>\n"
@@ -229,28 +238,37 @@
 "          according to RFC1867. This enables uploading of binary\n"
 "          files etc. To force the 'content' part to be be a file,\n"
 "          prefix the file name with an @ sign. To just get the\n"
 "          content part from a file, prefix the file name with the\n"
 "          letter <. The difference between @ and < is then that @\n"
 "          makes a file get attached in the post as a file upload,\n"
+);
+ puts(
 "          while the < makes a text field and just get the con­\n"
 "          tents for that text field from a file.\n"
 "\n"
 "          Example, to send your password file to the server,\n"
 "          where input:\n"
 "\n"
 "          curl -F password=@/etc/passwd www.mypasswords.com\n"
 "\n"
 "          To read the file's content from stdin insted of a file,\n"
 "          use - where the file name should've been. This goes for\n"
-);
- puts(
 "          both @ and < constructs.\n"
 "\n"
 "          This option can be used multiple times.\n"
 "\n"
+"     -g/--globoff\n"
+"          This option switches off the \"URL globbing parser\".\n"
+"          When you set this option, you can specify URLs that\n"
+"          contain the letters {}[] without having them being\n"
+"          interpreted by curl itself. Note that these letters are\n"
+"          not normal legal URL contents but they should be\n"
+"          encoded according to the URI standard. (Option added in\n"
+"          curl 7.6)\n"
+"\n"
 "     -h/--help\n"
 "          Usage help.\n"
 "\n"
 "     -H/--header <header>\n"
 "          (HTTP) Extra header to use when getting a web page. You\n"
 "          may specify any number of extra headers. Note that if\n"
@@ -267,12 +285,13 @@
 "          This option can be used multiple times.\n"
 "\n"
 "     -i/--include\n"
 "          (HTTP) Include the HTTP-header in the output. The HTTP-\n"
 "          header includes things like server-name, date of the\n"
 "          document, HTTP-version and more...\n"
+"\n"
 "          If this option is used twice, the second will again\n"
 "          disable header include.\n"
 "\n"
 "     --interface <name>\n"
 "          Perform an operation using a specified interface. You\n"
 "          can enter interface name, IP address or host name. An\n"
@@ -394,20 +413,22 @@
 "            curl http://{one,two}.site.com -o \"file_#1.txt\"\n"
 "\n"
 "          or use several variables like:\n"
 "\n"
 "            curl http://{site,host}.host[1-5].com -o \"#1_#2\"\n"
 "\n"
-"          If this option is used serveral times, the last one\n"
-"          will be used.\n"
+"          You may use this option as many times as you have num­\n"
+"          ber of URLs.\n"
 "\n"
 "     -O/--remote-name\n"
 "          Write output to a local file named like the remote file\n"
 "          we get. (Only the file part of the remote file is used,\n"
 "          the path is cut off.)\n"
 "\n"
+"          You may use this option as many times as you have num­\n"
+"          ber of URLs.\n"
 "     -p/--proxytunnel\n"
 "          When an HTTP proxy is used, this option will cause non-\n"
 "          HTTP protocols to attempt to tunnel through the proxy\n"
 "          instead of merely using it to do HTTP-like operations.\n"
 "          The tunnel approach is made with the HTTP proxy CONNECT\n"
 "          request and requires that the proxy allows direct con­\n"
@@ -421,12 +442,13 @@
 "          (FTP) Reverses the initiator/listener roles when con­\n"
 "          necting with ftp. This switch makes Curl use the PORT\n"
 "          command instead of PASV. In practice, PORT tells the\n"
 "          server to connect to the client's specified address and\n"
 "          port, while PASV asks the server for an ip address and\n"
 "          port to connect to. <address> should be one of:\n"
+"\n"
 "          interface   i.e \"eth0\" to specify which interface's IP\n"
 "                      address you want to use  (Unix only)\n"
 "\n"
 "          IP address  i.e \"192.168.10.1\" to specify exact IP num­\n"
 "                      ber\n"
 "\n"
@@ -452,13 +474,12 @@
 "          with a dash '-'. You may specify any amount of commands\n"
 "          to be run before and after the transfer. If the server\n"
 "          returns failure for one of the commands, the entire\n"
 "          operation will be aborted.\n"
 "\n"
 "          This option can be used multiple times.\n"
-"\n"
 "     -r/--range <range>\n"
 "          (HTTP/FTP) Retrieve a byte range (i.e a partial docu­\n"
 "          ment) from a HTTP/1.1 or FTP server. Ranges can be\n"
 "          specified in a number of ways.\n"
 "\n"
 "          0-499     specifies the first 500 bytes\n"
@@ -474,12 +495,14 @@
 "\n"
 "          500-700,600-799\n"
 "                    specifies 300 bytes from offset 500(H)\n"
 "\n"
 "          100-199,500-599\n"
 "                    specifies two separate 100 bytes ranges(*)(H)\n"
+);
+ puts(
 "\n"
 "     (*) = NOTE that this will cause the server to reply with a\n"
 "     multipart response!\n"
 "\n"
 "     You should also be aware that many HTTP/1.1 servers do not\n"
 "     have this feature enabled, so that when you attempt to get a\n"
@@ -501,14 +524,12 @@
 "\n"
 "     -S/--show-error\n"
 "          When used with -s it makes curl show error message if\n"
 "          it fails.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
-);
- puts(
 "          disable show error.\n"
 "\n"
 "     -t/--upload\n"
 "          Deprecated. Use '-T -' instead.  Transfer the stdin\n"
 "          data to the specified file. Curl will read everything\n"
 "          from stdin until EOF and store with the supplied name.\n"
@@ -544,17 +565,18 @@
 "          interactively.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     --url <URL>\n"
-"          Set the URL to fetch. This option is mostly handy when\n"
-"          you wanna specify URL in a config file.\n"
+"          Specify a URL to fetch. This option is mostly handy\n"
+"          when you wanna specify URL(s) in a config file.\n"
 "\n"
-"          If this option is used serveral times, the last one\n"
-"          will be used.\n"
+"          This option may be used any number of times. To control\n"
+"          where this URL is written, use the -o or the -O\n"
+"          options.\n"
 "\n"
 "     -v/--verbose\n"
 "          Makes the fetching more verbose/talkative. Mostly\n"
 "          usable for debugging. Lines starting with '>' means\n"
 "          data sent by curl, '<' means data received by curl that\n"
 "          is hidden in normal cases and lines starting with '*'\n"
@@ -578,12 +600,13 @@
 "          The variables present in the output format will be sub­\n"
 "          stituted by the value or text that curl thinks fit, as\n"
 "          described below. All variables are specified like\n"
 "          %{variable_name} and to output a normal % you just\n"
 "          write them like %%. You can output a newline by using\n"
 "          \\n, a carrige return with \\r and a tab space with \\t.\n"
+"\n"
 "          NOTE: The %-letter is a special letter in the\n"
 "          win32-environment, where all occurrences of % must be\n"
 "          doubled when using this option.\n"
 "\n"
 "          Available variables are at this point:\n"
 "\n"
@@ -629,12 +652,13 @@
 "\n"
 "          speed_download The average download speed that curl\n"
 "                         measured for the complete download.\n"
 "\n"
 "          speed_upload   The average upload speed that curl mea­\n"
 "                         sured for the complete upload.\n"
+"\n"
 "     If this option is used serveral times, the last one will be\n"
 "     used.\n"
 "\n"
 "     -x/--proxy <proxyhost[:port]>\n"
 "          Use specified proxy. If the port number is not speci­\n"
 "          fied, it is assumed at port 1080.\n"
@@ -659,13 +683,12 @@
 "          ond during a speed-time period, the download gets\n"
 "          aborted. If speed-time is used, the default speed-limit\n"
 "          will be 1 unless set with -y.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
-"\n"
 "     -Y/--speed-limit <speed>\n"
 "          If a download is slower than this given speed, in bytes\n"
 "          per second, for speed-time seconds it gets aborted.\n"
 "          speed-time is set with -Y and is 30 if not set.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
@@ -681,12 +704,13 @@
 "          date(3) man pages for date expression details.\n"
 "\n"
 "          Start the date expression with a dash (-) to make it\n"
 "          request for a document that is older than the given\n"
 "          date/time, default is a document that is newer than the\n"
 "          specified date/time.\n"
+"\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -3/--sslv3\n"
 "          (HTTPS) Forces curl to use SSL version 3 when negotiat­\n"
 "          ing with a remote SSL server.\n"
@@ -711,13 +735,12 @@
 "\n"
 "     --stderr <file>\n"
 "          Redirect all writes to stderr to the specified file\n"
 "          instead. If the file name is a plain '-', it is instead\n"
 "          written to stdout. This option has no point when you're\n"
 "          using a shell with decent redirecting capabilities.\n"
-"\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "FILES\n"
 "     ~/.curlrc\n"
 "          Default config file.\n"
@@ -731,22 +754,25 @@
 "\n"
 "     FTP_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for FTP.\n"
 "\n"
 "     GOPHER_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for GOPHER.\n"
+"\n"
 "     ALL_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use if no protocol-specific proxy\n"
 "          is set.\n"
 "\n"
 "     NO_PROXY <comma-separated list of hosts>\n"
 "          list of host names that shouldn't go through any proxy.\n"
 "          If set to a asterisk '*' only, it matches all hosts.\n"
 "\n"
 "     COLUMNS <integer>\n"
 "          The width of the terminal.  This variable only affects\n"
+);
+ puts(
 "          curl when the --progress-bar option is used.\n"
 "\n"
 "EXIT CODES\n"
 "     There exists a bunch of different error codes and their cor­\n"
 "     responding error messages that may appear during bad condi­\n"
 "     tions. At the time of this writing, the exit codes are:\n"
@@ -772,24 +798,23 @@
 "     8    FTP weird server reply. The server sent data curl\n"
 "          couldn't parse.\n"
 "\n"
 "     9    FTP access denied. The server denied login.\n"
 "\n"
 "     10   FTP user/password incorrect. Either one or both were\n"
-);
- puts(
 "          not accepted by the server.\n"
 "\n"
 "     11   FTP weird PASS reply. Curl couldn't parse the reply\n"
 "          sent to the PASS request.\n"
 "\n"
 "     12   FTP weird USER reply. Curl couldn't parse the reply\n"
 "          sent to the USER request.\n"
 "\n"
 "     13   FTP weird PASV reply, Curl couldn't parse the reply\n"
 "          sent to the PASV request.\n"
+"\n"
 "     14   FTP weird 227 format. Curl couldn't parse the 227-line\n"
 "          the server sent.\n"
 "\n"
 "     15   FTP can't get host. Couldn't resolve the host IP we got\n"
 "          in the 227-line.\n"
 "\n"
@@ -836,12 +861,13 @@
 "\n"
 "     32   FTP couldn't use SIZE. The SIZE command failed. The\n"
 "          command is an extension to the original FTP spec RFC\n"
 "          959.\n"
 "\n"
 "     33   HTTP range error. The range \"command\" didn't work.\n"
+"\n"
 "     34   HTTP post error. Internal post-request generation\n"
 "          error.\n"
 "\n"
 "     35   SSL connect error. The SSL handshaking failed.\n"
 "\n"
 "     36   FTP bad download resume. Couldn't continue an earlier\n"
@@ -866,13 +892,12 @@
 "          eter.\n"
 "\n"
 "     44   Internal error. A function was called in a bad order.\n"
 "\n"
 "     45   Interface error. A specified outgoing interface could\n"
 "          not be used.\n"
-"\n"
 "     46   Bad password entered. An error was signalled when the\n"
 "          password was entered.\n"
 "\n"
 "     47   Too many redirects. When following redirects, curl hit\n"
 "          the maximum amount.\n"
 "\n"
@@ -936,15 +961,19 @@
 "      - Martin Hedenfalk <mhe@stacken.kth.se>\n"
 "      - Richard Prescott\n"
 "      - Jason S. Priebe <priebe@wral-tv.com>\n"
 "      - T. Bharath <TBharath@responsenetworks.com>\n"
 "      - Alexander Kourakos <awk@users.sourceforge.net>\n"
 "      - James Griffiths <griffiths_james@yahoo.com>\n"
+"      - Loic Dachary <loic@senga.org>\n"
+"      - Robert Weaver <robert.weaver@sabre.com>\n"
+"      - Ingo Ralf Blum <ingoralfblum@ingoralfblum.com>\n"
 "\n"
 "WWW\n"
 "     http://curl.haxx.se\n"
+"\n"
 "FTP\n"
 "     ftp://ftp.sunet.se/pub/www/utilities/curl/\n"
 "\n"
 "SEE ALSO\n"
 "     ftp(1), wget(1), snarf(1)\n"
 "\n"
@@ -1078,12 +1107,14 @@
 "\n"
 "  Upload data from a specified file, login with user and password:\n"
 "\n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/myfile\n"
 "\n"
 "  Upload a local file to the remote site, and use the local file name remote\n"
+);
+ puts(
 "  too:\n"
 " \n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/\n"
 "\n"
 "  Upload a local file to get appended to the remote file using ftp:\n"
 "\n"
@@ -1111,14 +1142,12 @@
 "  If curl fails where it isn't supposed to, if the servers don't let you\n"
 "  in, if you can't understand the responses: use the -v flag to get VERBOSE\n"
 "  fetching. Curl will output lots of info and all data it sends and\n"
 "  receives in order to let the user see all client-server interaction.\n"
 "\n"
 "        curl -v ftp://ftp.upload.com/\n"
-);
- puts(
 "\n"
 "DETAILED INFORMATION\n"
 "\n"
 "  Different protocols provide different ways of getting detailed information\n"
 "  about specific files/documents. To get curl to show detailed information\n"
 "  about a single file, you should use -I/--head option. It displays all\n"
@@ -1334,12 +1363,14 @@
 "  The -# option will display a totally different progress bar that doesn't\n"
 "  need much explanation!\n"
 "\n"
 "SPEED LIMIT\n"
 "\n"
 "  Curl offers the user to set conditions regarding transfer speed that must\n"
+);
+ puts(
 "  be met to let the transfer keep going. By using the switch -y and -Y you\n"
 "  can make curl abort transfers if the transfer speed doesn't exceed your\n"
 "  given lowest limit for a specified time.\n"
 "\n"
 "  To let curl abandon downloading this page if its slower than 3000 bytes per\n"
 "  second for 1 minute, run:\n"
@@ -1358,14 +1389,12 @@
 "\n"
 "  The config file could be made up with normal command line switches, but you\n"
 "  can also specify the long options without the dashes to make it more\n"
 "  readable. You can separate the options and the parameter with spaces, or\n"
 "  with = or :. Comments can be used within the file. If the first letter on a\n"
 "  line is a '#'-letter the rest of the line is treated as a comment.\n"
-);
- puts(
 "\n"
 "  If you want the parameter to contain spaces, you must inclose the entire\n"
 "  parameter within double quotes (\"). Within those quotes, you specify a\n"
 "  quote as \\\".\n"
 "\n"
 "  NOTE: You must specify options and their arguments on the same line.\n"
@@ -1621,12 +1650,14 @@
 "\n"
 "  Curl reads and understands the following environment variables:\n"
 "\n"
 "        HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, GOPHER_PROXY\n"
 "\n"
 "  They should be set for protocol-specific proxies. General proxy should be\n"
+);
+ puts(
 "  set with\n"
 "        \n"
 "        ALL_PROXY\n"
 "\n"
 "  A comma-separated list of host names that shouldn't go through any proxy is\n"
 "  set in (only an asterisk, '*' matches all hosts)\n"
@@ -1650,14 +1681,12 @@
 "\n"
 "  Curl supports .netrc files if told so (using the -n/--netrc option). This is\n"
 "  not restricted to only ftp, but curl can use it for all protocols where\n"
 "  authentication is used.\n"
 "\n"
 "  A very simple .netrc file could look something like:\n"
-);
- puts(
 "\n"
 "        machine curl.haxx.se login iamdaniel password mysecret\n"
 "\n"
 "CUSTOM OUTPUT\n"
 "\n"
 "  To better allow script programmers to get to know about the progress of\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/main.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/main.c	2001-01-24 22:44:05.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: main.c,v 1.57 2001/01/03 09:29:34 bagder Exp $
+ * $Id: main.c,v 1.67 2001/01/24 14:44:05 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
@@ -36,23 +36,22 @@
 #include <curl/mprintf.h>
 
 #include "urlglob.h"
 #include "writeout.h"
 
 #define CURLseparator	"--_curl_--"
-#define MIMEseparator	"_curl_"
 
 /* This define make use of the "Curlseparator" as opposed to the
    MIMEseparator. We might add support for the latter one in the
    future, and that's why this is left in the source. */
 #define CURL_SEPARATORS
 
 /* This is now designed to have its own local setup.h */
 #include "setup.h"
 
-#ifdef WIN32
+#if defined(WIN32)&&!defined(__CYGWIN32__)
 #include <winsock.h>
 #endif
 
 #include "version.h"
 
 #ifdef HAVE_IO_H /* typical win32 habit */
@@ -219,33 +218,46 @@
     vfprintf(stderr, fmt, ap);
     va_end(ap);
   }
   fprintf(stderr, "curl: try 'curl --help' for more information\n");
 }
 
+/*
+ * A chain of these nodes contain URL to get and where to put the URL's
+ * contents.
+ */
+struct getout {
+  struct getout *next;
+  char *url;
+  char *outfile;
+  int flags;
+};
+#define GETOUT_OUTFILE (1<<0) /* set when outfile is deemed done */
+#define GETOUT_URL     (1<<1) /* set when URL is deemed done */
+#define GETOUT_USEREMOTE (1<<2) /* use remote file name locally */
+
 static void help(void)
 {
   printf(CURL_ID "%s\n"
        "Usage: curl [options...] <url>\n"
        "Options: (H) means HTTP/HTTPS only, (F) means FTP only\n"
        " -a/--append        Append to target file when uploading (F)\n"
        " -A/--user-agent <string> User-Agent to send to server (H)\n"
        " -b/--cookie <name=string/file> Cookie string or file to read cookies from (H)\n"
        " -B/--use-ascii     Use ASCII/text transfer\n"
-       " -c/--continue      Resume a previous transfer where we left it\n"
        " -C/--continue-at <offset> Specify absolute resume offset\n"
        " -d/--data <data>   HTTP POST data (H)\n"
        "    --data-ascii <data>   HTTP POST ASCII data (H)\n"
        "    --data-binary <data>  HTTP POST binary data (H)\n"
        " -D/--dump-header <file> Write the headers to this file\n"
        " -e/--referer       Referer page (H)\n"
        " -E/--cert <cert[:passwd]> Specifies your certificate file and password (HTTPS)\n"
        "    --cacert <file> CA certifciate to verify peer against (HTTPS)\n"
        " -f/--fail          Fail silently (no output at all) on errors (H)\n"
        " -F/--form <name=content> Specify HTTP POST data (H)\n"
-
+       " -g/--globoff       Disable URL sequences and ranges using {} and []\n"
        " -h/--help          This help text\n"
        " -H/--header <line> Custom header to pass to server. (H)\n"
        " -i/--include       Include the HTTP-header in the output (H)\n"
        " -I/--head          Fetch document info only (HTTP HEAD/FTP SIZE)\n"
        "    --interface <interface> Specify the interface to be used\n"
        "    --krb4 <level>  Enable krb4 with specified security level (F)\n"
@@ -262,14 +274,14 @@
        " -P/--ftpport <address> Use PORT with address instead of PASV when ftping (F)\n"
        " -q                 When used as the first parameter disables .curlrc\n"
        " -Q/--quote <cmd>   Send QUOTE command to FTP before file transfer (F)\n"
        " -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server\n"
        " -s/--silent        Silent mode. Don't output anything\n"
        " -S/--show-error    Show error. With -s, make curl show errors when they occur\n"
-       " -t/--upload        Transfer/upload stdin to remote site\n"
        " -T/--upload-file <file> Transfer/upload <file> to remote site\n"
+       "    --url <URL>     Another way to specify URL to work with\n"
        " -u/--user <user[:password]> Specify user and password to use\n"
        " -U/--proxy-user <user[:password]> Specify Proxy authentication\n"
        " -v/--verbose       Makes the operation more talkative\n"
        " -V/--version       Outputs version number then quits\n"
        " -w/--write-out [format] What to output after completion\n"
        " -x/--proxy <host[:port]>  Use proxy. (Default port is 1080)\n"
@@ -300,15 +312,13 @@
   int resume_from;
   char *postfields;
   long postfieldsize;
   char *referer;
   long timeout;
   long maxredirs;
-  char *outfile;
   char *headerfile;
-  char remotefile;
   char *ftpport;
   char *iface;
   unsigned short porttouse;
   char *range;
   int low_speed_limit;
   int low_speed_time;
@@ -317,22 +327,29 @@
   char *userpwd;
   char *proxyuserpwd;
   char *proxy;
   bool configread;
   bool proxytunnel;
   long conf;
-  char *url;
+
+  struct getout *url_list; /* point to the first node */
+  struct getout *url_last; /* point to the last/current node */
+
+  struct getout *url_get;  /* point to the node to fill in URL */
+  struct getout *url_out;  /* point to the node to fill in outfile */
+
   char *cert;
   char *cacert;
   char *cert_passwd;
   bool crlf;
   char *cookiefile;
   char *customrequest;
   char *krb4level;
   bool progressmode;
   bool nobuffer;
+  bool globoff;
 
   char *writeout; /* %-styled format string to output */
 
   FILE *errors; /* if stderr redirect is requested */
 
   struct curl_slist *quote;
@@ -423,12 +440,52 @@
     return string;
   }
   else
     return NULL; /* no string */
 }
 
+void clean_getout(struct Configurable *config)
+{
+  struct getout *node=config->url_list;
+  struct getout *next;
+
+  while(node) {
+    next = node->next;
+    if(node->url)
+      free(node->url);
+    if(node->outfile)
+      free(node->outfile);
+    free(node);
+
+    node = next; /* GOTO next */
+  }
+}
+
+struct getout *new_getout(struct Configurable *config)
+{
+  struct getout *node =malloc(sizeof(struct getout));
+  struct getout *last= config->url_last;
+  if(node) {
+    /* clear the struct */
+    memset(node, 0, sizeof(struct getout));
+        
+    /* append this new node last in the list */
+    if(last)
+      last->next = node;
+    else
+      config->url_list = node; /* first node */
+            
+    /* move the last pointer */
+    config->url_last = node;
+  }
+  return node;
+}
+
+
+
+
 typedef enum {
   PARAM_OK,
   PARAM_OPTION_AMBIGUOUS,
   PARAM_OPTION_UNKNOWN,
   PARAM_REQUIRES_PARAMETER,  
   PARAM_BAD_USE,
@@ -450,12 +507,14 @@
   char *parse=NULL;
   int res;
   int j;
   time_t now;
   int hit=-1;
   bool longopt=FALSE;
+  bool singleopt=FALSE; /* when true means '-o foo' used '-ofoo' */
+
 
   /* single-letter,
      long-name,
      boolean whether it takes an additional argument
      */
   struct LongShort aliases[]= {
@@ -480,13 +539,13 @@
     {"D", "dump-header", TRUE},
     {"e", "referer",     TRUE},
     {"E", "cert",        TRUE},
     {"Ea", "cacert",     TRUE},
     {"f", "fail",        FALSE},
     {"F", "form",        TRUE},
-
+    {"g", "globoff",     FALSE},
     {"h", "help",        FALSE},
     {"H", "header",      TRUE},
     {"i", "include",     FALSE},
     {"I", "head",        FALSE},
     {"K", "config",      TRUE},
     {"l", "list-only",   FALSE},
@@ -580,13 +639,17 @@
 	return PARAM_OPTION_UNKNOWN;
       }
     }
     if(hit < 0) {
       return PARAM_OPTION_UNKNOWN;
     }    
-    if((!nextarg || !*nextarg) && aliases[hit].extraparam) {
+    if(!longopt && aliases[hit].extraparam && parse[1]) {
+      nextarg=&parse[1]; /* this is the actual extra parameter */
+      singleopt=TRUE;   /* don't loop anymore after this */
+    }
+    else if((!nextarg || !*nextarg) && aliases[hit].extraparam) {
       return PARAM_REQUIRES_PARAMETER;
     }
     else if(nextarg && aliases[hit].extraparam)
       *usedarg = TRUE; /* mark it as used */
 
     switch(letter) {
@@ -607,13 +670,36 @@
     case '6': /* there is no short letter for this */
       /* krb4 level string */
       GetStr(&config->krb4level, nextarg);
       break;
     case '5':
       /* the URL! */
-      GetStr(&config->url, nextarg);
+      {
+        struct getout *url;
+        if(config->url_get || (config->url_get=config->url_list)) {
+          /* there's a node here, if it already is filled-in continue to find
+             an "empty" node */
+          while(config->url_get && (config->url_get->flags&GETOUT_URL))
+            config->url_get = config->url_get->next;
+        }
+
+        /* now there might or might not be an available node to fill in! */
+
+        if(config->url_get)
+          /* existing node */
+          url = config->url_get;
+        else
+          /* there was no free node, create one! */
+          url=new_getout(config);
+
+        if(url) {
+          /* fill in the URL */
+          GetStr(&url->url, nextarg);
+          url->flags |= GETOUT_URL;
+        }
+      }
       break;
     case '#': /* added 19990617 larsa */
       config->progressmode ^= CURL_PROGRESS_BAR;
       break;
     case '2': 
       /* SSL version 2 */
@@ -687,13 +773,13 @@
         }
 
         if(config->postfields && *config->postfields) {
           /* we already have a string, we append this one
              with a separating &-letter */
           char *oldpost=config->postfields;
-          config->postfields=maprintf("%s&%s", oldpost, postdata);
+          config->postfields=aprintf("%s&%s", oldpost, postdata);
           free(oldpost);
           free(postdata);
         }
         else
           config->postfields=postdata;
       }
@@ -746,12 +832,16 @@
                         &config->last_post))
 	return PARAM_BAD_USE;
       if(SetHTTPrequest(HTTPREQ_POST, &config->httpreq))
         return PARAM_BAD_USE;
       break;
 
+    case 'g': /* g disables URLglobbing */
+      config->globoff ^= TRUE;
+      break;
+
     case 'h': /* h for help */
       help();
       return PARAM_HELP_REQUESTED;
     case 'H':
       /* A custom header to append to a list */
       config->headers = curl_slist_append(config->headers, nextarg);
@@ -791,18 +881,43 @@
       break;
     case 'N':
       /* disable the output I/O buffering */
       config->nobuffer ^= 1;
       break;
     case 'o':
-      /* output file */
-      GetStr(&config->outfile, nextarg); /* write to this file */
-      break;
     case 'O':
       /* output file */
-      config->remotefile ^= TRUE;
+      {
+        struct getout *url;
+        if(config->url_out || (config->url_out=config->url_list)) {
+          /* there's a node here, if it already is filled-in continue to find
+             an "empty" node */
+          while(config->url_out && (config->url_out->flags&GETOUT_OUTFILE))
+            config->url_out = config->url_out->next;
+        }
+
+        /* now there might or might not be an available node to fill in! */
+
+        if(config->url_out)
+          /* existing node */
+          url = config->url_out;
+        else
+          /* there was no free node, create one! */
+          url=new_getout(config);
+
+        if(url) {
+          /* fill in the outfile */
+          if('o' == letter)
+            GetStr(&url->outfile, nextarg);
+          else {
+            url->outfile=NULL; /* leave it */
+            url->flags |= GETOUT_USEREMOTE;
+          }
+          url->flags |= GETOUT_OUTFILE;
+        }
+      }
       break;
     case 'P':
       /* This makes the FTP sessions use PORT instead of PASV */
       /* use <eth0> or <192.168.10.10> style addresses. Anything except
 	 this will make us try to get the "default" address.
 	 NOTE: this is a changed behaviour since the released 4.1!
@@ -948,13 +1063,13 @@
 
     default: /* unknown flag */
       return PARAM_OPTION_UNKNOWN;
     }
     hit = -1;
 
-  } while(*++parse && !*usedarg);
+  } while(!singleopt && *++parse && !*usedarg);
 
   return PARAM_OK;
 }
 
 
 static int parseconfig(char *filename,
@@ -1250,14 +1365,12 @@
 #endif
 
 }
 
 void free_config_fields(struct Configurable *config)
 {
-  if(config->url)
-    free(config->url);
   if(config->userpwd)
     free(config->userpwd);
   if(config->postfields)
     free(config->postfields);
   if(config->proxy)
     free(config->proxy);
@@ -1268,14 +1381,12 @@
   if(config->cookiefile)
     free(config->cookiefile);
   if(config->krb4level)
     free(config->krb4level);
   if(config->headerfile)
     free(config->headerfile);
-  if(config->outfile)
-    free(config->outfile);
   if(config->ftpport)
     free(config->ftpport);
   if(config->infile)
     free(config->infile);
   if(config->range)
     free(config->range);
@@ -1297,19 +1408,21 @@
 static int 
 operate(struct Configurable *config, int argc, char *argv[])
 {
   char errorbuffer[CURL_ERROR_SIZE];
   char useragent[128]; /* buah, we don't want a larger default user agent */
   struct ProgressData progressbar;
+  struct getout *urlnode;
+  struct getout *nextnode;
 
   struct OutStruct outs;
   struct OutStruct heads;
 
   char *url = NULL;
 
-  URLGlob *urls;
+  URLGlob *urls=NULL;
   int urlnum;
   char *outfiles;
   int separator = 0;
   
   FILE *infd = stdin;
   FILE *headerfilep = NULL;
@@ -1320,15 +1433,12 @@
   bool allocuseragent=FALSE;
 
   CURL *curl;
   int res;
   int i;
 
-  outs.stream = stdout;
-  outs.config = config;
-
 #ifdef MALLOCDEBUG
   /* this sends all memory debug messages to a logfile named memdump */
   curl_memdebug("memdump");
 #endif
 
   config->showerror=TRUE;
@@ -1353,13 +1463,13 @@
   else {
     res = parseconfig(NULL, config);
     if(res)
       return res;
   }
 
-  if ((argc < 2)  && !config->url) {
+  if ((argc < 2)  && !config->url_list) {
     helpf(NULL);
     return CURLE_FAILED_INIT;
   }
 
   /* Parse options */
   for (i = 1; i < argc; i++) {
@@ -1394,370 +1504,388 @@
             helpf("option %s was wrongly used!\n", origopt);
             break;
           case PARAM_HELP_REQUESTED:
             /* no text */
             break;
           }
+          clean_getout(config);
 	  return CURLE_FAILED_INIT;
         }
 
 	if(passarg) /* we're supposed to skip this */
 	  i++;
       }
     }
     else {
-      if(url) {
-	helpf("only one URL is supported!\n");
-	return CURLE_FAILED_INIT;
-      }
-      url = argv[i];
+      bool used;
+      /* just add the URL please */
+      res = getparameter("--url", argv[i], &used, config);
+      if(res)
+        return res;
     }
   }
 
-  /* if no URL was specified and there was one in the config file, get that
-     one */
-  if(!url && config->url)
-    url = config->url;
-  
-  if(!url) {
+  if(!config->url_list) {
     helpf("no URL specified!\n");
     return CURLE_FAILED_INIT;
   }
   if(NULL == config->useragent) {
     /* set non-zero default values: */
     snprintf(useragent, sizeof(useragent),
              CURL_NAME "/" CURL_VERSION " (" OS ") " "%s", curl_version());
     config->useragent= useragent;
   }
   else
     allocuseragent = TRUE;
-#if 0
-  fprintf(stderr, "URL: %s PROXY: %s\n", url, config->proxy?config->proxy:"none");
-#endif
 
-  /* expand '{...}' and '[...]' expressions and return total number of URLs
-     in pattern set */
-  res = glob_url(&urls, url, &urlnum);
-  if(res != CURLE_OK)
-    return res;
-
-  /* save outfile pattern befor expansion */
-  outfiles = config->outfile?strdup(config->outfile):NULL;
-
-  if (!outfiles && !config->remotefile && urlnum > 1) {
-#ifdef CURL_SEPARATORS
-    /* multiple files extracted to stdout, insert separators! */
-    separator = 1;
-#endif
-#ifdef MIME_SEPARATORS
-    /* multiple files extracted to stdout, insert MIME separators! */
-    separator = 1;
-    printf("MIME-Version: 1.0\n");
-    printf("Content-Type: multipart/mixed; boundary=%s\n\n", MIMEseparator);
-#endif
-  }
-  for (i = 0; (url = next_url(urls)); ++i) {
-    if (config->outfile) {
-      free(config->outfile);
-      config->outfile = outfiles?strdup(outfiles):NULL;
+  urlnode = config->url_list;
+
+  /* loop through the list of given URLs */
+  while(urlnode) {
+
+    /* get the full URL (it might be NULL) */
+    url=urlnode->url;
+
+    if(NULL == url) {
+      /* This node had no URL, skip it and continue to the next */
+      if(urlnode->outfile)
+        free(urlnode->outfile);
+    
+      /* move on to the next URL */
+      nextnode=urlnode->next;
+      free(urlnode); /* free the node */
+      urlnode = nextnode;
+      continue; /* next please */
+    }
+
+    /* default output stream is stdout */
+    outs.stream = stdout;
+    outs.config = config;
+
+    if(!config->globoff) {
+      /* Unless explicitly shut off, we expand '{...}' and '[...]' expressions
+         and return total number of URLs in pattern set */
+      res = glob_url(&urls, url, &urlnum);
+      if(res != CURLE_OK)
+        return res;
     }
+
+
+    /* save outfile pattern before expansion */
+    outfiles = urlnode->outfile?strdup(urlnode->outfile):NULL;
+
+    if ((!outfiles || strequal(outfiles, "-")) && urlnum > 1) {
+      /* multiple files extracted to stdout, insert separators! */
+      separator = 1;
+    }
+    for(i = 0;
+        (url = urls?next_url(urls):(i?NULL:strdup(url)));
+        i++) {
+      char *outfile;
+      outfile = outfiles?strdup(outfiles):NULL;
  
-    if (config->outfile || config->remotefile) {
-      /* 
-       * We have specified a file name to store the result in, or we have
-       * decided we want to use the remote file name.
-       */
+      if((urlnode->flags&GETOUT_USEREMOTE) ||
+         (outfile && !strequal("-", outfile)) ) {
+
+        /* 
+         * We have specified a file name to store the result in, or we have
+         * decided we want to use the remote file name.
+         */
       
-      if(!config->outfile && config->remotefile) {
-        /* Find and get the remote file name */
-        char * pc =strstr(url, "://");
-        if(pc)
-          pc+=3;
-        else
-          pc=url;
-        pc = strrchr(pc, '/');
-        config->outfile = (char *) NULL == pc ? NULL : strdup(pc+1) ;
-        if(!config->outfile || !strlen(config->outfile)) {
-          helpf("Remote file name has no length!\n");
-          return CURLE_WRITE_ERROR;
+        if(!outfile) {
+          /* Find and get the remote file name */
+          char * pc =strstr(url, "://");
+          if(pc)
+            pc+=3;
+          else
+            pc=url;
+          pc = strrchr(pc, '/');
+          outfile = (char *) NULL == pc ? NULL : strdup(pc+1) ;
+          if(!outfile) {
+            helpf("Remote file name has no length!\n");
+            return CURLE_WRITE_ERROR;
+          }
+        }
+        else if(urls) {
+          /* fill '#1' ... '#9' terms from URL pattern */
+          char *storefile = outfile;
+          outfile = match_url(storefile, urls);
+          free(storefile);
         }
-      }
-      else {
-	/* fill '#1' ... '#9' terms from URL pattern */
-        char *outfile = config->outfile;
-        config->outfile = match_url(config->outfile, urls);
-        free(outfile);
-      }
       
-      if((0 == config->resume_from) && config->use_resume) {
-        /* we're told to continue where we are now, then we get the size of the
-           file as it is now and open it for append instead */
-        struct stat fileinfo;
-
-        if(0 == stat(config->outfile, &fileinfo)) {
-          /* set offset to current file size: */
-          config->resume_from = fileinfo.st_size;
+        if((0 == config->resume_from) && config->use_resume) {
+          /* we're told to continue where we are now, then we get the size of
+             the file as it is now and open it for append instead */
+
+          struct stat fileinfo;
+
+          if(0 == stat(outfile, &fileinfo)) {
+            /* set offset to current file size: */
+            config->resume_from = fileinfo.st_size;
+          }
+          /* else let offset remain 0 */
         }
-        /* else let offset remain 0 */
-      }
       
-      if(config->resume_from) {
-        /* open file for output: */
-        outs.stream=(FILE *) fopen(config->outfile, config->resume_from?"ab":"wb");
-        if (!outs.stream) {
-          helpf("Can't open '%s'!\n", config->outfile);
-          return CURLE_WRITE_ERROR;
+        if(config->resume_from) {
+          /* open file for output: */
+          outs.stream=(FILE *) fopen(outfile, config->resume_from?"ab":"wb");
+          if (!outs.stream) {
+            helpf("Can't open '%s'!\n", outfile);
+            return CURLE_WRITE_ERROR;
+          }
+        }
+        else {
+          outs.filename = outfile;
+          outs.stream = NULL; /* open when needed */
         }
       }
-      else {
-        outs.filename = config->outfile;
-        outs.stream = NULL; /* open when needed */
-      }
-    }
-    if (config->infile) {
-      /*
-       * We have specified a file to upload
-       */
-      struct stat fileinfo;
+      if(config->infile) {
+        /*
+         * We have specified a file to upload
+         */
+        struct stat fileinfo;
 
-      /* If no file name part is given in the URL, we add this file name */
-      char *ptr=strstr(url, "://");
-      if(ptr)
-        ptr+=3;
-      else
-        ptr=url;
-      ptr = strrchr(ptr, '/');
-      if(!ptr || !strlen(++ptr)) {
-        /* The URL has no file name part, add the local file name. In order to
-           be able to do so, we have to create a new URL in another buffer.*/
-
-        urlbuffer=(char *)malloc(strlen(url) + strlen(config->infile) + 3);
-        if(!urlbuffer) {
-          helpf("out of memory\n");
-          return CURLE_OUT_OF_MEMORY;
-        }
+        /* If no file name part is given in the URL, we add this file name */
+        char *ptr=strstr(url, "://");
         if(ptr)
-          /* there is a trailing slash on the URL */
-          sprintf(urlbuffer, "%s%s", url, config->infile);
+          ptr+=3;
         else
-          /* thers is no trailing slash on the URL */
-          sprintf(urlbuffer, "%s/%s", url, config->infile);
-        
-        url = urlbuffer; /* use our new URL instead! */
-      }
+          ptr=url;
+        ptr = strrchr(ptr, '/');
+        if(!ptr || !strlen(++ptr)) {
+          /* The URL has no file name part, add the local file name. In order
+             to be able to do so, we have to create a new URL in another
+             buffer.*/
+
+          urlbuffer=(char *)malloc(strlen(url) + strlen(config->infile) + 3);
+          if(!urlbuffer) {
+            helpf("out of memory\n");
+            return CURLE_OUT_OF_MEMORY;
+          }
+          if(ptr)
+            /* there is a trailing slash on the URL */
+            sprintf(urlbuffer, "%s%s", url, config->infile);
+          else
+            /* thers is no trailing slash on the URL */
+            sprintf(urlbuffer, "%s/%s", url, config->infile);
+          
+          url = urlbuffer; /* use our new URL instead! */
+        }
 
-      infd=(FILE *) fopen(config->infile, "rb");
-      if (!infd || stat(config->infile, &fileinfo)) {
-        helpf("Can't open '%s'!\n", config->infile);
-        return CURLE_READ_ERROR;
-      }
-      infilesize=fileinfo.st_size;
+        infd=(FILE *) fopen(config->infile, "rb");
+        if (!infd || stat(config->infile, &fileinfo)) {
+          helpf("Can't open '%s'!\n", config->infile);
+          return CURLE_READ_ERROR;
+        }
+        infilesize=fileinfo.st_size;
       
-    }
-    if((config->conf&CONF_UPLOAD) &&
-       config->use_resume &&
-       (0==config->resume_from)) {
-      config->resume_from = -1; /* -1 will then force get-it-yourself */
-    }
-    if(config->headerfile) {
-      /* open file for output: */
-      if(strcmp(config->headerfile,"-")) {
-        heads.filename = config->headerfile;
-        headerfilep=NULL;
       }
-      else
-        headerfilep=stdout;
-      heads.stream = headerfilep;
-      heads.config = config;
-    }
+      if((config->conf&CONF_UPLOAD) &&
+         config->use_resume &&
+         (0==config->resume_from)) {
+        config->resume_from = -1; /* -1 will then force get-it-yourself */
+      }
+      if(config->headerfile) {
+        /* open file for output: */
+        if(strcmp(config->headerfile,"-")) {
+          heads.filename = config->headerfile;
+          headerfilep=NULL;
+        }
+        else
+          headerfilep=stdout;
+        heads.stream = headerfilep;
+        heads.config = config;
+      }
     
-    if(outs.stream && isatty(fileno(outs.stream)) &&
-       !(config->conf&(CONF_UPLOAD|CONF_HTTPPOST)))
-      /* we send the output to a tty and it isn't an upload operation,
-         therefore we switch off the progress meter */
-      config->conf |= CONF_NOPROGRESS;
+      if(outs.stream && isatty(fileno(outs.stream)) &&
+         !(config->conf&(CONF_UPLOAD|CONF_HTTPPOST)))
+        /* we send the output to a tty and it isn't an upload operation,
+           therefore we switch off the progress meter */
+        config->conf |= CONF_NOPROGRESS;
     
 
-    if (urlnum > 1) {
-      fprintf(stderr, "\n[%d/%d]: %s --> %s\n",
-              i+1, urlnum, url, config->outfile ? config->outfile : "<stdout>");
-      if (separator) {
-#ifdef CURL_SEPARATORS
-        printf("%s%s\n", CURLseparator, url);
-#endif
-#ifdef MIME_SEPARATORS
-        printf("--%s\n", MIMEseparator);
-        printf("Content-ID: %s\n\n", url); 
-#endif
+      if (urlnum > 1) {
+        fprintf(stderr, "\n[%d/%d]: %s --> %s\n",
+                i+1, urlnum, url, outfile ? outfile : "<stdout>");
+        if (separator)
+          printf("%s%s\n", CURLseparator, url);
+      }
+
+      if(!config->errors)
+        config->errors = stderr;
+
+#if defined(WIN32) && !defined(__CYGWIN32__)
+      if(!outfile && !(config->conf & CONF_GETTEXT)) {
+        /* We get the output to stdout and we have not got the ASCII/text flag,
+           then set stdout to be binary */
+        setmode( 1, O_BINARY );
       }
-    }
-
-    if(!config->errors)
-      config->errors = stderr;
-
-#ifdef WIN32
-    if(!config->outfile && !(config->conf & CONF_GETTEXT)) {
-      /* We get the output to stdout and we have not got the ASCII/text flag,
-         then set stdout to be binary */
-      setmode( 1, O_BINARY );
-    }
 #endif
 
 
-    main_init();
-
-    /* The new, v7-style easy-interface! */
-    curl = curl_easy_init();
-    if(curl) {
-      curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs); /* where to store */
-      /* what call to write: */
-      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
-      curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
-      /* size of uploaded file: */
-      curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
-      curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
-      curl_easy_setopt(curl, CURLOPT_PROXY, config->proxy); /* proxy to use */
-      curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
-      curl_easy_setopt(curl, CURLOPT_HEADER, config->conf&CONF_HEADER);
-      curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config->conf&CONF_NOPROGRESS);
-      curl_easy_setopt(curl, CURLOPT_NOBODY, config->conf&CONF_NOBODY);
-      curl_easy_setopt(curl, CURLOPT_FAILONERROR,
-                       config->conf&CONF_FAILONERROR);
-      curl_easy_setopt(curl, CURLOPT_UPLOAD, config->conf&CONF_UPLOAD);
-      curl_easy_setopt(curl, CURLOPT_POST, config->conf&CONF_POST);
-      curl_easy_setopt(curl, CURLOPT_FTPLISTONLY,
-                       config->conf&CONF_FTPLISTONLY);
-      curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config->conf&CONF_FTPAPPEND);
-      curl_easy_setopt(curl, CURLOPT_NETRC, config->conf&CONF_NETRC);
-      curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
-                       config->conf&CONF_FOLLOWLOCATION);
-      curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config->conf&CONF_GETTEXT);
-      curl_easy_setopt(curl, CURLOPT_PUT, config->conf&CONF_PUT);
-      curl_easy_setopt(curl, CURLOPT_MUTE, config->conf&CONF_MUTE);
-      curl_easy_setopt(curl, CURLOPT_USERPWD, config->userpwd);
-      curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);
-      curl_easy_setopt(curl, CURLOPT_RANGE, config->range);
-      curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
-      curl_easy_setopt(curl, CURLOPT_TIMEOUT, config->timeout);
-      curl_easy_setopt(curl, CURLOPT_POSTFIELDS, config->postfields);
-      
-      /* new in libcurl 7.2: */
-      curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, config->postfieldsize);
+      main_init();
+
+      curl = curl_easy_init();
+      if(curl) {
+        curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs); /* where to store */
+        /* what call to write: */
+        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
+        curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
+        /* size of uploaded file: */
+        curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
+        curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
+        curl_easy_setopt(curl, CURLOPT_PROXY, config->proxy); /* proxy to use */
+        curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
+        curl_easy_setopt(curl, CURLOPT_HEADER, config->conf&CONF_HEADER);
+        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config->conf&CONF_NOPROGRESS);
+        curl_easy_setopt(curl, CURLOPT_NOBODY, config->conf&CONF_NOBODY);
+        curl_easy_setopt(curl, CURLOPT_FAILONERROR,
+                         config->conf&CONF_FAILONERROR);
+        curl_easy_setopt(curl, CURLOPT_UPLOAD, config->conf&CONF_UPLOAD);
+        curl_easy_setopt(curl, CURLOPT_POST, config->conf&CONF_POST);
+        curl_easy_setopt(curl, CURLOPT_FTPLISTONLY,
+                         config->conf&CONF_FTPLISTONLY);
+        curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config->conf&CONF_FTPAPPEND);
+        curl_easy_setopt(curl, CURLOPT_NETRC, config->conf&CONF_NETRC);
+        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
+                         config->conf&CONF_FOLLOWLOCATION);
+        curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config->conf&CONF_GETTEXT);
+        curl_easy_setopt(curl, CURLOPT_PUT, config->conf&CONF_PUT);
+        curl_easy_setopt(curl, CURLOPT_MUTE, config->conf&CONF_MUTE);
+        curl_easy_setopt(curl, CURLOPT_USERPWD, config->userpwd);
+        curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);
+        curl_easy_setopt(curl, CURLOPT_RANGE, config->range);
+        curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
+        curl_easy_setopt(curl, CURLOPT_TIMEOUT, config->timeout);
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, config->postfields);
+        
+        /* new in libcurl 7.2: */
+        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, config->postfieldsize);
+        
+        curl_easy_setopt(curl, CURLOPT_REFERER, config->referer);
+        curl_easy_setopt(curl, CURLOPT_AUTOREFERER,
+                         config->conf&CONF_AUTO_REFERER);
+        curl_easy_setopt(curl, CURLOPT_USERAGENT, config->useragent);
+        curl_easy_setopt(curl, CURLOPT_FTPPORT, config->ftpport);
+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, config->low_speed_limit);
+        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, config->low_speed_time);
+        curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
+                         config->use_resume?config->resume_from:0);
+        curl_easy_setopt(curl, CURLOPT_COOKIE, config->cookie);
+        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config->headers);
+        curl_easy_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
+        curl_easy_setopt(curl, CURLOPT_SSLCERT, config->cert);
+        curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config->cert_passwd);
+
+        if(config->cacert) {
+          /* available from libcurl 7.5: */
+          curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
+          curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE);
+        }
 
-      curl_easy_setopt(curl, CURLOPT_REFERER, config->referer);
-      curl_easy_setopt(curl, CURLOPT_AUTOREFERER,
-                       config->conf&CONF_AUTO_REFERER);
-      curl_easy_setopt(curl, CURLOPT_USERAGENT, config->useragent);
-      curl_easy_setopt(curl, CURLOPT_FTPPORT, config->ftpport);
-      curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, config->low_speed_limit);
-      curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, config->low_speed_time);
-      curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
-                       config->use_resume?config->resume_from:0);
-      curl_easy_setopt(curl, CURLOPT_COOKIE, config->cookie);
-      curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config->headers);
-      curl_easy_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
-      curl_easy_setopt(curl, CURLOPT_SSLCERT, config->cert);
-      curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config->cert_passwd);
-
-      if(config->cacert) {
-        /* available from libcurl 7.5: */
-        curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
-        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE);
-      }
-
-      if(config->conf&(CONF_NOBODY|CONF_USEREMOTETIME)) {
-        /* no body or use remote time */
-        /* new in 7.5 */
-        curl_easy_setopt(curl, CURLOPT_FILETIME, TRUE);
-      }
+        if(config->conf&(CONF_NOBODY|CONF_USEREMOTETIME)) {
+          /* no body or use remote time */
+          /* new in 7.5 */
+          curl_easy_setopt(curl, CURLOPT_FILETIME, TRUE);
+        }
       
-      /* 7.5 news: */
-      if (config->maxredirs) 
-        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, config->maxredirs); 
-      else 
-        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, DEFAULT_MAXREDIRS); 
+        /* 7.5 news: */
+        if (config->maxredirs) 
+          curl_easy_setopt(curl, CURLOPT_MAXREDIRS, config->maxredirs); 
+        else 
+          curl_easy_setopt(curl, CURLOPT_MAXREDIRS, DEFAULT_MAXREDIRS); 
  
-
-      curl_easy_setopt(curl, CURLOPT_CRLF, config->crlf);
-      curl_easy_setopt(curl, CURLOPT_QUOTE, config->quote);
-      curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config->postquote);
-      curl_easy_setopt(curl, CURLOPT_WRITEHEADER,
-                       config->headerfile?&heads:NULL);
-      curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config->cookiefile);
-      curl_easy_setopt(curl, CURLOPT_SSLVERSION, config->ssl_version);
-      curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config->timecond);
-      curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config->condtime);
-      curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);
-      curl_easy_setopt(curl, CURLOPT_STDERR, config->errors);
+        curl_easy_setopt(curl, CURLOPT_CRLF, config->crlf);
+        curl_easy_setopt(curl, CURLOPT_QUOTE, config->quote);
+        curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config->postquote);
+        curl_easy_setopt(curl, CURLOPT_WRITEHEADER,
+                         config->headerfile?&heads:NULL);
+        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config->cookiefile);
+        curl_easy_setopt(curl, CURLOPT_SSLVERSION, config->ssl_version);
+        curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config->timecond);
+        curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config->condtime);
+        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);
+        curl_easy_setopt(curl, CURLOPT_STDERR, config->errors);
       
-      /* three new ones in libcurl 7.3: */
-      curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config->proxytunnel);
-      curl_easy_setopt(curl, CURLOPT_INTERFACE, config->iface);
-      curl_easy_setopt(curl, CURLOPT_KRB4LEVEL, config->krb4level);
-
-      if((config->progressmode == CURL_PROGRESS_BAR) &&
-         !(config->conf&(CONF_NOPROGRESS|CONF_MUTE))) {
-        /* we want the alternative style, then we have to implement it
-           ourselves! */
-        progressbarinit(&progressbar);
-        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, myprogress);
-        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &progressbar);
+        /* three new ones in libcurl 7.3: */
+        curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config->proxytunnel);
+        curl_easy_setopt(curl, CURLOPT_INTERFACE, config->iface);
+        curl_easy_setopt(curl, CURLOPT_KRB4LEVEL, config->krb4level);
+
+        if((config->progressmode == CURL_PROGRESS_BAR) &&
+           !(config->conf&(CONF_NOPROGRESS|CONF_MUTE))) {
+          /* we want the alternative style, then we have to implement it
+             ourselves! */
+          progressbarinit(&progressbar);
+          curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, myprogress);
+          curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &progressbar);
+        }
+        
+        res = curl_easy_perform(curl);
+        
+        if(config->writeout) {
+          ourWriteOut(curl, config->writeout);
+        }
+        
+        /* always cleanup */
+        curl_easy_cleanup(curl);
+        
+        if((res!=CURLE_OK) && config->showerror)
+          fprintf(config->errors, "curl: (%d) %s\n", res, errorbuffer);
       }
+      else
+        fprintf(config->errors, "curl: failed to init libcurl!\n");
 
-      res = curl_easy_perform(curl);
+      main_free();
 
-      if(config->writeout) {
-        ourWriteOut(curl, config->writeout);
-      }
+      if((config->errors != stderr) &&
+         (config->errors != stdout))
+        /* it wasn't directed to stdout or stderr so close the file! */
+        fclose(config->errors);
+    
+      if(config->headerfile && !headerfilep && heads.stream)
+        fclose(heads.stream);
 
-      /* always cleanup */
-      curl_easy_cleanup(curl);
+      if(urlbuffer)
+        free(urlbuffer);
+      if (outfile && !strequal(outfile, "-") && outs.stream)
+        fclose(outs.stream);
+      if (config->infile)
+        fclose(infd);
+      if(headerfilep)
+        fclose(headerfilep);
+      
+      if(url)
+        free(url);
 
-      if((res!=CURLE_OK) && config->showerror)
-        fprintf(config->errors, "curl: (%d) %s\n", res, errorbuffer);
+      if(outfile)
+        free(outfile);
     }
-    else
-      fprintf(config->errors, "curl: failed to init libcurl!\n");
-
-    main_free();
+    if(outfiles)
+      free(outfiles);
 
-    if((config->errors != stderr) &&
-       (config->errors != stdout))
-      /* it wasn't directed to stdout or stderr so close the file! */
-      fclose(config->errors);
+    if(urls)
+      /* cleanup memory used for URL globbing patterns */
+      glob_cleanup(urls);
+
+    /* empty this urlnode struct */
+    if(urlnode->url)
+      free(urlnode->url);
+    if(urlnode->outfile)
+      free(urlnode->outfile);
     
-    if(config->headerfile && !headerfilep && heads.stream)
-      fclose(heads.stream);
+    /* move on to the next URL */
+    nextnode=urlnode->next;
+    free(urlnode); /* free the node */
+    urlnode = nextnode;
 
-    if(urlbuffer)
-      free(urlbuffer);
-    if (config->outfile && outs.stream)
-      fclose(outs.stream);
-    if (config->infile)
-      fclose(infd);
-    if(headerfilep)
-      fclose(headerfilep);
-    
-    if(url)
-      free(url);
-
-  }
-  if(outfiles)
-    free(outfiles);
-
-#ifdef MIME_SEPARATORS
-  if (separator)
-    printf("--%s--\n", MIMEseparator);
-#endif
+  } /* while-loop through all URLs */
 
   if(allocuseragent)
     free(config->useragent);
 
-  /* cleanup memory used for URL globbing patterns */
-  glob_cleanup(urls);
-
   return res;
 }
 
 
 int main(int argc, char *argv[])
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/Makefile.am	2001-01-04 18:26:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/Makefile.am	2001-01-08 23:16:37.000000000 +0800
@@ -1,29 +1,36 @@
 #
-# $Id: Makefile.am,v 1.10 2000/11/30 08:08:49 bagder Exp $
+# $Id: Makefile.am,v 1.11 2001/01/08 10:00:15 bagder Exp $
 #
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -g -DMALLOCDEBUG # -Wall -pedantic
 #CPPFLAGS = -DGLOBURL -DCURL_SEPARATORS
 
 INCLUDES = -I$(top_srcdir)/include
 
 bin_PROGRAMS = curl #memtest
 
+noinst_HEADERS = setup.h \
+	config-win32.h \
+	urlglob.h \
+	version.h \
+	writeout.h
+
 #memtest_SOURCES = memtest.c
 #memtest_LDADD = $(top_srcdir)/lib/libcurl.la
 
 curl_SOURCES = main.c hugehelp.c urlglob.c writeout.c
-curl_LDADD = $(top_srcdir)/lib/libcurl.la
-curl_DEPENDENCIES = $(top_srcdir)/lib/libcurl.la
+curl_LDADD = ../lib/libcurl.la
+curl_DEPENDENCIES = ../lib/libcurl.la
 BUILT_SOURCES = hugehelp.c
 CLEANFILES = hugehelp.c
 NROFF=@NROFF@
 
-EXTRA_DIST = mkhelp.pl Makefile.vc6
+EXTRA_DIST = mkhelp.pl config-win32.h \
+	Makefile.vc6 Makefile.b32 Makefile.m32
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 MANPAGE=$(top_srcdir)/docs/curl.1
 README=$(top_srcdir)/docs/MANUAL
 MKHELP=$(top_srcdir)/src/mkhelp.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/Makefile.in	2001-01-04 21:57:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/Makefile.in	2001-01-27 23:41:58.000000000 +0800
@@ -8,21 +8,21 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.10 2000/11/30 08:08:49 bagder Exp $
+# $Id: Makefile.am,v 1.11 2001/01/08 10:00:15 bagder Exp $
 #
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -g -DMALLOCDEBUG # -Wall -pedantic
 #CPPFLAGS = -DGLOBURL -DCURL_SEPARATORS
 
 
-SHELL = /bin/sh
+SHELL = @SHELL@
 
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 prefix = @prefix@
 exec_prefix = @exec_prefix@
@@ -81,23 +81,27 @@
 YACC = @YACC@
 
 INCLUDES = -I$(top_srcdir)/include
 
 bin_PROGRAMS = curl #memtest
 
+noinst_HEADERS = setup.h 	config-win32.h 	urlglob.h 	version.h 	writeout.h
+
+
 #memtest_SOURCES = memtest.c
 #memtest_LDADD = $(top_srcdir)/lib/libcurl.la
 
 curl_SOURCES = main.c hugehelp.c urlglob.c writeout.c
-curl_LDADD = $(top_srcdir)/lib/libcurl.la
-curl_DEPENDENCIES = $(top_srcdir)/lib/libcurl.la
+curl_LDADD = ../lib/libcurl.la
+curl_DEPENDENCIES = ../lib/libcurl.la
 BUILT_SOURCES = hugehelp.c
 CLEANFILES = hugehelp.c
 NROFF = @NROFF@
 
-EXTRA_DIST = mkhelp.pl Makefile.vc6
+EXTRA_DIST = mkhelp.pl config-win32.h 	Makefile.vc6 Makefile.b32 Makefile.m32
+
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 MANPAGE = $(top_srcdir)/docs/curl.1
 README = $(top_srcdir)/docs/MANUAL
 MKHELP = $(top_srcdir)/src/mkhelp.pl
@@ -115,12 +119,14 @@
 curl_LDFLAGS = 
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
+HEADERS =  $(noinst_HEADERS)
+
 DIST_COMMON =  ./stamp-h2.in Makefile.am Makefile.in config.h.in
 
 
 DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)
 
 TAR = gtar
@@ -297,13 +303,13 @@
 
 install-am: all-am
 	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
 install: install-am
 uninstall-am: uninstall-binPROGRAMS
 uninstall: uninstall-am
-all-am: Makefile $(PROGRAMS) config.h
+all-am: Makefile $(PROGRAMS) $(HEADERS) config.h
 all-redirect: all-am
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
 installdirs:
 	$(mkinstalldirs)  $(DESTDIR)$(bindir)
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/urlglob.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/urlglob.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/urlglob.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/urlglob.c	2001-01-23 18:14:43.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urlglob.c,v 1.11 2001/01/03 09:29:34 bagder Exp $
+ * $Id: urlglob.c,v 1.13 2001/01/23 10:14:43 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
@@ -29,15 +29,29 @@
 #include "urlglob.h"
 
 #ifdef MALLOCDEBUG
 #include "../lib/memdebug.h"
 #endif
 
-int glob_word(URLGlob *, char*, int);
+typedef enum {
+  GLOB_OK,
+  GLOB_ERROR
+} GlobCode;
 
-int glob_set(URLGlob *glob, char *pattern, int pos)
+/*
+ * glob_word()
+ *
+ * Input a full globbed string, set the forth argument to the amount of
+ * strings we get out of this. Return GlobCode.
+ */
+GlobCode glob_word(URLGlob *, /* object anchor */
+                   char *,    /* globbed string */
+                   int,       /* position */
+                   int *);    /* returned number of strings */
+
+GlobCode glob_set(URLGlob *glob, char *pattern, int pos, int *amount)
 {
   /* processes a set expression with the point behind the opening '{'
      ','-separated elements are collected until the next closing '}'
   */
   char* buf = glob->glob_buffer;
   URLPattern *pat;
@@ -49,162 +63,210 @@
   pat->content.Set.ptr_s = 0;
   pat->content.Set.elements = (char**)malloc(0);
   ++glob->size;
 
   while (1) {
     switch (*pattern) {
-    case '\0':				/* URL ended while set was still open */
-      printf("error: unmatched brace at pos %d\n", pos);
-      exit (CURLE_URL_MALFORMAT);
+    case '\0':			/* URL ended while set was still open */
+      /*printf("error: unmatched brace at pos %d\n", pos);*/
+      return GLOB_ERROR;
+
     case '{':
-    case '[':				/* no nested expressions at this time */
-      printf("error: nested braces not supported %d\n", pos);
-      exit (CURLE_URL_MALFORMAT);
+    case '[':			/* no nested expressions at this time */
+      /*printf("error: nested braces not supported %d\n", pos);*/
+      return GLOB_ERROR;
+
     case ',':
     case '}':				/* set element completed */
       *buf = '\0';
       pat->content.Set.elements =
         realloc(pat->content.Set.elements,
                 (pat->content.Set.size + 1) * sizeof(char*));
       if (!pat->content.Set.elements) {
-	printf("out of memory in set pattern\n");
-	exit(CURLE_OUT_OF_MEMORY);
+	/*printf("out of memory in set pattern\n");*/
+        return GLOB_ERROR;
       }
       pat->content.Set.elements[pat->content.Set.size] =
         strdup(glob->glob_buffer);
       ++pat->content.Set.size;
 
-      if (*pattern == '}')		/* entire set pattern completed */
+      if (*pattern == '}') {
+        /* entire set pattern completed */
+        int wordamount;
+
 	/* always check for a literal (may be "") between patterns */
-	return pat->content.Set.size * glob_word(glob, ++pattern, ++pos);
+        if(GLOB_ERROR == glob_word(glob, ++pattern, ++pos, &wordamount))
+          wordamount=1;
+	*amount = pat->content.Set.size * wordamount;
+
+        return GLOB_OK;
+      }
 
       buf = glob->glob_buffer;
       ++pattern;
       ++pos;
       break;
+
     case ']':				/* illegal closing bracket */
-      printf("error: illegal pattern at pos %d\n", pos);
-      exit (CURLE_URL_MALFORMAT);
+      /*printf("error: illegal pattern at pos %d\n", pos);*/
+      return GLOB_ERROR;
+
     case '\\':				/* escaped character, skip '\' */
       if (*(buf+1) == '\0') {		/* but no escaping of '\0'! */
-	printf("error: illegal pattern at pos %d\n", pos);
-	exit (CURLE_URL_MALFORMAT);
+	/*printf("error: illegal pattern at pos %d\n", pos); */
+	return GLOB_ERROR;
       }
       ++pattern;
       ++pos;				/* intentional fallthrough */
+
     default:
       *buf++ = *pattern++;		/* copy character to set element */
       ++pos;
     }
   }
-  exit (CURLE_FAILED_INIT);
+  return GLOB_ERROR;
 }
 
-int glob_range(URLGlob *glob, char *pattern, int pos)
+GlobCode glob_range(URLGlob *glob, char *pattern, int pos, int *amount)
 {
   /* processes a range expression with the point behind the opening '['
      - char range: e.g. "a-z]", "B-Q]"
      - num range: e.g. "0-9]", "17-2000]"
      - num range with leading zeros: e.g. "001-999]"
      expression is checked for well-formedness and collected until the next ']'
   */
   URLPattern *pat;
   char *c;
+  int wordamount=1;
   
   pat = (URLPattern*)&glob->pattern[glob->size / 2];
   /* patterns 0,1,2,... correspond to size=1,3,5,... */
   ++glob->size;
 
   if (isalpha((int)*pattern)) {		/* character range detected */
     pat->type = UPTCharRange;
-    if (sscanf(pattern, "%c-%c]", &pat->content.CharRange.min_c, &pat->content.CharRange.max_c) != 2 ||
+    if (sscanf(pattern, "%c-%c]", &pat->content.CharRange.min_c,
+               &pat->content.CharRange.max_c) != 2 ||
 	pat->content.CharRange.min_c >= pat->content.CharRange.max_c ||
 	pat->content.CharRange.max_c - pat->content.CharRange.min_c > 'z' - 'a') {
       /* the pattern is not well-formed */ 
-      printf("error: illegal pattern or range specification after pos %d\n", pos);
-      exit (CURLE_URL_MALFORMAT);
+#if 0
+      printf("error: illegal pattern or range specification after pos %d\n",
+             pos);
+#endif
+      return GLOB_ERROR;
     }
     pat->content.CharRange.ptr_c = pat->content.CharRange.min_c;
     /* always check for a literal (may be "") between patterns */
-    return (pat->content.CharRange.max_c - pat->content.CharRange.min_c + 1) *
-      glob_word(glob, pattern + 4, pos + 4);
+
+    if(GLOB_ERROR == glob_word(glob, pattern + 4, pos + 4, &wordamount))
+      wordamount=1;
+
+    *amount = (pat->content.CharRange.max_c -
+               pat->content.CharRange.min_c + 1) *
+      wordamount;
+
+    return GLOB_OK;
   }
-  if (isdigit((int)*pattern)) {		/* numeric range detected */
+
+  if (isdigit((int)*pattern)) { /* numeric range detected */
+
     pat->type = UPTNumRange;
     pat->content.NumRange.padlength = 0;
-    if (sscanf(pattern, "%d-%d]", &pat->content.NumRange.min_n, &pat->content.NumRange.max_n) != 2 ||
+    if (sscanf(pattern, "%d-%d]",
+               &pat->content.NumRange.min_n,
+               &pat->content.NumRange.max_n) != 2 ||
 	pat->content.NumRange.min_n >= pat->content.NumRange.max_n) {
       /* the pattern is not well-formed */ 
-      printf("error: illegal pattern or range specification after pos %d\n", pos);
-      exit (CURLE_URL_MALFORMAT);
+#if 0
+      printf("error: illegal pattern or range specification after pos %d\n",
+             pos);
+#endif
+      return GLOB_ERROR;
     }
     if (*pattern == '0') {		/* leading zero specified */
       c = pattern;  
       while (isdigit((int)*c++))
-	++pat->content.NumRange.padlength;	/* padding length is set for all instances
-						   of this pattern */
+	++pat->content.NumRange.padlength; /* padding length is set for all
+                                              instances of this pattern */
     }
     pat->content.NumRange.ptr_n = pat->content.NumRange.min_n;
     c = (char*)(strchr(pattern, ']') + 1);	/* continue after next ']' */
+
     /* always check for a literal (may be "") between patterns */
-    return (pat->content.NumRange.max_n - pat->content.NumRange.min_n + 1) *
-      glob_word(glob, c, pos + (c - pattern));
+
+    if(GLOB_ERROR == glob_word(glob, c, pos + (c - pattern), &wordamount))
+      wordamount = 1;
+    
+    *amount = (pat->content.NumRange.max_n - 
+               pat->content.NumRange.min_n + 1) *
+      wordamount;
+
+    return GLOB_OK;
   }
-  printf("error: illegal character in range specification at pos %d\n", pos);
-  exit (CURLE_URL_MALFORMAT);
+  /*printf("error: illegal character in range specification at pos %d\n",
+    pos);*/
+  return GLOB_ERROR;
 }
 
-int glob_word(URLGlob *glob, char *pattern, int pos)
+GlobCode glob_word(URLGlob *glob, char *pattern, int pos, int *amount)
 {
   /* processes a literal string component of a URL
      special characters '{' and '[' branch to set/range processing functions
    */ 
   char* buf = glob->glob_buffer;
   int litindex;
 
+  *amount = 1; /* default is one single string */
+
   while (*pattern != '\0' && *pattern != '{' && *pattern != '[') {
     if (*pattern == '}' || *pattern == ']') {
-      printf("illegal character at position %d\n", pos);
-      exit (CURLE_URL_MALFORMAT);
+      return GLOB_ERROR;
     }
     if (*pattern == '\\') {		/* escape character, skip '\' */
       ++pattern;
       ++pos;
       if (*pattern == '\0') {		/* but no escaping of '\0'! */
-	printf("illegal character at position %d\n", pos);
-	exit (CURLE_URL_MALFORMAT);
+	return GLOB_ERROR;
       }
     }
     *buf++ = *pattern++;		/* copy character to literal */
     ++pos;
   }
   *buf = '\0';
   litindex = glob->size / 2;
   /* literals 0,1,2,... correspond to size=0,2,4,... */
   glob->literal[litindex] = strdup(glob->glob_buffer);
   ++glob->size;
-  if (*pattern == '\0')
-    return 1;				/* singular URL processed  */
-  if (*pattern == '{') {
-    return glob_set(glob, ++pattern, ++pos);	/* process set pattern */
-  }
-  if (*pattern == '[') {
-    return glob_range(glob, ++pattern, ++pos);/* process range pattern */
+
+  switch (*pattern) {
+  case '\0':
+    return GLOB_OK;			/* singular URL processed  */
+
+  case '{':
+    /* process set pattern */
+    return glob_set(glob, ++pattern, ++pos, amount);
+
+  case '[':
+    /* process range pattern */
+    return glob_range(glob, ++pattern, ++pos, amount);
   }
-  printf("internal error\n");
-  exit (CURLE_FAILED_INIT);
+
+  return GLOB_ERROR; /* something got wrong */
 }
 
 int glob_url(URLGlob** glob, char* url, int *urlnum)
 {
   /*
    * We can deal with any-size, just make a buffer with the same length
    * as the specified URL!
    */
   URLGlob *glob_expand;
+  int amount;
   char *glob_buffer=(char *)malloc(strlen(url)+1);
+
   if(NULL == glob_buffer)
     return CURLE_OUT_OF_MEMORY;
 
   glob_expand = (URLGlob*)malloc(sizeof(URLGlob));
   if(NULL == glob_expand) {
     free(glob_buffer);
@@ -210,13 +272,23 @@
     free(glob_buffer);
     return CURLE_OUT_OF_MEMORY;
   }
   glob_expand->size = 0;
   glob_expand->urllen = strlen(url);
   glob_expand->glob_buffer = glob_buffer;
-  *urlnum = glob_word(glob_expand, url, 1);
+  glob_expand->beenhere=0;
+  if(GLOB_OK == glob_word(glob_expand, url, 1, &amount))
+    *urlnum = amount;
+  else {
+    /* it failed, we cleanup */
+    free(glob_buffer);
+    free(glob_expand);
+    glob_expand = NULL;
+    *urlnum = 1;
+  }
+
   *glob = glob_expand;
   return CURLE_OK;
 }
 
 void glob_cleanup(URLGlob* glob)
 {
@@ -237,21 +309,20 @@
   free(glob->glob_buffer);
   free(glob);
 }
 
 char *next_url(URLGlob *glob)
 {
-  static int beenhere = 0;
   char *buf = glob->glob_buffer;
   URLPattern *pat;
   char *lit;
   signed int i;
   int carry;
 
-  if (!beenhere)
-    beenhere = 1;
+  if (!glob->beenhere)
+    glob->beenhere = 1;
   else {
     carry = 1;
 
     /* implement a counter over the index ranges of all patterns,
        starting with the rightmost pattern */
     for (i = glob->size / 2 - 1; carry && i >= 0; --i) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/urlglob.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/urlglob.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/urlglob.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/urlglob.h	2001-01-08 15:37:44.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urlglob.h,v 1.7 2001/01/03 09:29:34 bagder Exp $
+ * $Id: urlglob.h,v 1.8 2001/01/08 07:37:44 bagder Exp $
  *****************************************************************************/
 typedef enum {UPTSet=1,UPTCharRange,UPTNumRange} URLPatternType;
 
 typedef struct {
   URLPatternType type;
   union {
@@ -47,12 +47,13 @@
 typedef struct {
   char* literal[10];
   URLPattern pattern[9];
   int size;
   int urllen;
   char *glob_buffer;
+  char beenhere;
 } URLGlob;
 
 int glob_url(URLGlob**, char*, int *);
 char* next_url(URLGlob*);
 char* match_url(char*, URLGlob *); 
 void glob_cleanup(URLGlob* glob);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/src/version.h	2001-01-04 21:57:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/src/version.h	2001-01-27 23:39:48.000000000 +0800
@@ -1,3 +1,3 @@
 #define CURL_NAME "curl"
-#define CURL_VERSION "7.5.2"
+#define CURL_VERSION "7.6"
 #define CURL_ID CURL_NAME " " CURL_VERSION " (" OS ") "
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6: stamp-h1.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2: stamp-h.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: command120.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: command121.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: command26.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: command27.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: command28.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: Makefile.am
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: Makefile.in
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: name120.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: name121.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: name26.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: name27.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: name28.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: prot120.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: prot121.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: prot26.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: prot27.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: prot28.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: reply120.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: reply121.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: reply26.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: reply28.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/data: stdout27.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/ftpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/ftpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/ftpserver.pl	2000-11-27 20:53:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/ftpserver.pl	2001-01-23 00:16:18.000000000 +0800
@@ -1,9 +1,9 @@
 #!/usr/bin/perl
 #
-# $Id: ftpserver.pl,v 1.13 2000/11/27 12:53:32 bagder Exp $
+# $Id: ftpserver.pl,v 1.14 2001/01/22 16:16:18 bagder Exp $
 # This is the FTP server designed for the curl test suite.
 #
 # It is meant to excersive curl, it is not meant to become a fully working
 # or even very standard compliant server.
 #
 # You may optionally specify port on the command line, otherwise it'll
@@ -73,12 +73,13 @@
                  'REST' => 'twosock',
                  'CWD'  => 'loggedin|twosock',
                  'SYST' => 'loggedin',
                  'SIZE' => 'loggedin|twosock',
                  'PWD'  => 'loggedin|twosock',
                  'QUIT'  => 'loggedin|twosock',
+                 'DELE' => 'loggedin|twosock'
                  );
 
 # initially, we're in 'fresh' state
 my %statechange = ( 'USER' => 'passwd',    # USER goes to passwd state
                     'PASS' => 'loggedin',  # PASS goes to loggedin state
                     'PORT' => 'twosock',   # PORT goes to twosock
@@ -94,12 +95,13 @@
                    'NLST' => '150 here comes a directory',
                    'CWD'  => '250 CWD command successful.',
                    'SYST' => '215 UNIX Type: L8', # just fake something
                    'QUIT' => '221 bye bye baby', # just reply something
                    'PWD'  => '257 "/nowhere/anywhere" is current directory',
                    'REST' => '350 Yeah yeah we set it there for you',
+                   'DELE' => '200 OK OK OK whatever you say'
                    );
 
 # callback functions for certain commands
 my %commandfunc = ( 'PORT' => \&PORT_command,
                     'LIST' => \&LIST_command,
                     'NLST' => \&NLST_command,
@@ -297,20 +299,20 @@
 }
 
 $SIG{CHLD} = \&REAPER;
 
 my %customreply;
 sub customize {
+    undef %customreply;
     open(CUSTOM, "<log/ftpserver.cmd") ||
         return 1;
 
     if($verbose) {
         print STDERR "FTPD: Getting commands from log/ftpserver.cmd\n";
     }
 
-    undef %customreply;
     while(<CUSTOM>) {
         if($_ =~ /REPLY ([A-Z]+) (.*)/) {
             $customreply{$1}=$2;
         }
     }
     close(CUSTOM);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/Makefile.am	2000-12-05 17:09:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/Makefile.am	2001-01-09 06:11:08.000000000 +0800
@@ -1,17 +1,22 @@
+EXTRA_DIST = ftpserver.pl httpserver.pl runtests.pl
+
+SUBDIRS = data
 
 all:
 install:
 
 curl:
 	@(cd ..; make)
 
 test:
-	$(PERL) runtests.pl
+	$(MAKE) -C data test
+	srcdir=$(srcdir) $(PERL) $(srcdir)/runtests.pl
 
 quiet-test:
-	$(PERL) runtests.pl -s -a
+	$(MAKE) -C data test
+	srcdir=$(srcdir) $(PERL) $(srcdir)/runtests.pl -s -a
 
 clean:
 	rm -rf log
 	find . -name "*~" | xargs rm -f
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/Makefile.in	2001-01-04 21:57:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/Makefile.in	2001-01-27 23:41:59.000000000 +0800
@@ -69,12 +69,16 @@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
+
+EXTRA_DIST = ftpserver.pl httpserver.pl runtests.pl
+
+SUBDIRS = data
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h ../src/config.h
 CONFIG_CLEAN_FILES = 
 DIST_COMMON =  README Makefile.am Makefile.in
 
 
@@ -88,15 +92,101 @@
 	cd $(top_srcdir) && $(AUTOMAKE) --gnu --include-deps tests/Makefile
 
 Makefile: $(srcdir)/Makefile.in  $(top_builddir)/config.status
 	cd $(top_builddir) \
 	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
 
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+
+@SET_MAKE@
+
+all-recursive install-data-recursive install-exec-recursive \
+installdirs-recursive install-recursive uninstall-recursive  \
+check-recursive installcheck-recursive info-recursive dvi-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+mostlyclean-recursive clean-recursive distclean-recursive \
+maintainer-clean-recursive:
+	@set fnord $(MAKEFLAGS); amf=$$2; \
+	dot_seen=no; \
+	rev=''; list='$(SUBDIRS)'; for subdir in $$list; do \
+	  rev="$$subdir $$rev"; \
+	  test "$$subdir" = "." && dot_seen=yes; \
+	done; \
+	test "$$dot_seen" = "no" && rev=". $$rev"; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	   || case "$$amf" in *=*) exit 1;; *k*) fail=yes;; *) exit 1;; esac; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+
 tags: TAGS
-TAGS:
 
+ID: $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	here=`pwd` && cd $(srcdir) \
+	  && mkid -f$$here/ID $$unique $(LISP)
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+   if test "$$subdir" = .; then :; else \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
+   fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)'; \
+	unique=`for i in $$list; do echo $$i; done | \
+	  awk '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$unique$(LISP)$$tags" \
+	  || (cd $(srcdir) && etags $(ETAGS_ARGS) $$tags  $$unique $(LISP) -o $$here/TAGS)
+
+mostlyclean-tags:
+
+clean-tags:
+
+distclean-tags:
+	-rm -f TAGS ID
+
+maintainer-clean-tags:
 
 distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
 
 subdir = tests
 
 distdir: $(DISTFILES)
@@ -107,85 +197,105 @@
 	  else \
 	    test -f $(distdir)/$$file \
 	    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \
 	    || cp -p $$d/$$file $(distdir)/$$file || :; \
 	  fi; \
 	done
+	for subdir in $(SUBDIRS); do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d $(distdir)/$$subdir \
+	    || mkdir $(distdir)/$$subdir \
+	    || exit 1; \
+	    chmod 777 $(distdir)/$$subdir; \
+	    (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=../$(top_distdir) distdir=../$(distdir)/$$subdir distdir) \
+	      || exit 1; \
+	  fi; \
+	done
 info-am:
-info: info-am
+info: info-recursive
 dvi-am:
-dvi: dvi-am
+dvi: dvi-recursive
 check-am: all-am
-check: check-am
+check: check-recursive
 installcheck-am:
-installcheck: installcheck-am
+installcheck: installcheck-recursive
 install-exec-am:
-install-exec: install-exec-am
+install-exec: install-exec-recursive
 
 install-data-am:
-install-data: install-data-am
+install-data: install-data-recursive
 
 install-am: all-am
 	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
-install: install-am
+install: install-recursive
 uninstall-am:
-uninstall: uninstall-am
+uninstall: uninstall-recursive
 all-am: Makefile
-all-redirect: all-am
+all-redirect: all-recursive
 install-strip:
 	$(MAKE) $(AM_MAKEFLAGS) AM_INSTALL_PROGRAM_FLAGS=-s install
-installdirs:
+installdirs: installdirs-recursive
+installdirs-am:
 
 
 mostlyclean-generic:
 
 clean-generic:
 
 distclean-generic:
 	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 	-rm -f config.cache config.log stamp-h stamp-h[0-9]*
 
 maintainer-clean-generic:
-mostlyclean-am:  mostlyclean-generic
+mostlyclean-am:  mostlyclean-tags mostlyclean-generic
 
-mostlyclean: mostlyclean-am
+mostlyclean: mostlyclean-recursive
 
-clean-am:  clean-generic mostlyclean-am
+clean-am:  clean-tags clean-generic mostlyclean-am
 
-clean: clean-am
+clean: clean-recursive
 
-distclean-am:  distclean-generic clean-am
+distclean-am:  distclean-tags distclean-generic clean-am
 	-rm -f libtool
 
-distclean: distclean-am
+distclean: distclean-recursive
 
-maintainer-clean-am:  maintainer-clean-generic distclean-am
+maintainer-clean-am:  maintainer-clean-tags maintainer-clean-generic \
+		distclean-am
 	@echo "This command is intended for maintainers to use;"
 	@echo "it deletes files that may require special tools to rebuild."
 
-maintainer-clean: maintainer-clean-am
+maintainer-clean: maintainer-clean-recursive
 
-.PHONY: tags distdir info-am info dvi-am dvi check check-am \
-installcheck-am installcheck install-exec-am install-exec \
-install-data-am install-data install-am install uninstall-am uninstall \
-all-redirect all-am all installdirs mostlyclean-generic \
-distclean-generic clean-generic maintainer-clean-generic clean \
-mostlyclean distclean maintainer-clean
+.PHONY: install-data-recursive uninstall-data-recursive \
+install-exec-recursive uninstall-exec-recursive installdirs-recursive \
+uninstalldirs-recursive all-recursive check-recursive \
+installcheck-recursive info-recursive dvi-recursive \
+mostlyclean-recursive distclean-recursive clean-recursive \
+maintainer-clean-recursive tags tags-recursive mostlyclean-tags \
+distclean-tags clean-tags maintainer-clean-tags distdir info-am info \
+dvi-am dvi check check-am installcheck-am installcheck install-exec-am \
+install-exec install-data-am install-data install-am install \
+uninstall-am uninstall all-redirect all-am all installdirs-am \
+installdirs mostlyclean-generic distclean-generic clean-generic \
+maintainer-clean-generic clean mostlyclean distclean maintainer-clean
 
 
 all:
 install:
 
 curl:
 	@(cd ..; make)
 
 test:
-	$(PERL) runtests.pl
+	$(MAKE) -C data test
+	srcdir=$(srcdir) $(PERL) $(srcdir)/runtests.pl
 
 quiet-test:
-	$(PERL) runtests.pl -s -a
+	$(MAKE) -C data test
+	srcdir=$(srcdir) $(PERL) $(srcdir)/runtests.pl -s -a
 
 clean:
 	rm -rf log
 	find . -name "*~" | xargs rm -f
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/runtests.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/runtests.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.5.2/tests/runtests.pl	2000-11-28 20:49:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6/tests/runtests.pl	2001-01-25 19:07:36.000000000 +0800
@@ -1,16 +1,17 @@
 #!/usr/bin/perl
-# $Id: runtests.pl,v 1.17 2000/11/28 12:49:39 bagder Exp $
+# $Id: runtests.pl,v 1.18 2001/01/08 22:18:30 bagder Exp $
 #
 # Main curl test script, in perl to run on more platforms
 #
 #######################################################################
 # These should be the only variables that might be needed to get edited:
 
 use strict;
 
+my $srcdir = $ENV{'srcdir'} || '.';
 my $HOSTIP="127.0.0.1";
 my $HOSTPORT=8999; # bad name, but this is the HTTP server port
 my $FTPPORT=8921;  # this is the FTP server port
 my $CURL="../src/curl"; # what curl executable to run on the tests
 my $LOGDIR="log";
 my $TESTDIR="data";
@@ -105,13 +106,13 @@
     else {
         $STATUS="httpd (no pid file) not running";
         $RUNNING=0;
     }
 
     if ($RUNNING != 1) {
-        system("perl ./httpserver.pl $HOSTPORT &");
+        system("perl $srcdir/httpserver.pl $HOSTPORT &");
         sleep 1; # give it a little time to start
     }
     else {
         print "$STATUS\n";
 
         # verify that our server is one one running on this port:
@@ -146,13 +147,13 @@
     else {
         $STATUS="ftpd (no pid file) not running";
         $RUNNING=0;
     }
 
     if ($RUNNING != 1) {
-        system("perl ./ftpserver.pl $FTPPORT &");
+        system("perl $srcdir/ftpserver.pl $FTPPORT &");
         sleep 1; # give it a little time to start
     }
     else {
         print "$STATUS\n";
 
         # verify that our server is one one running on this port:
