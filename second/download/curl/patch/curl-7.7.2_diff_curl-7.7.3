diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/CHANGES	2001-04-23 15:23:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/CHANGES	2001-05-04 21:31:54.000000000 +0800
@@ -3,12 +3,67 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
                                History of Changes
 
+Version 7.7.3-pre1
+
+Daniel (4 May 2001)
+- All callback functions now take 'void *' instead of 'FILE *'. This is made
+  this way to make it more obvious to people that anything can be passed to
+  them (by using the apropriate option). After discussions with Sterling
+  Hughes.
+
+Daniel (3 May 2001)
+- Cris Bailiff fixed a chunked transfer encoding problem with persistent
+  connection that made libcurl fail if the persistent connection used mixed
+  chunked and non-chunked transfers.
+
+- Cris Bailiff fixed a bad treatment of 304-replies, as they would not be
+  treated as content-length 0 replies but would cause a "hang" until the
+  server timed-out and closed the connection.
+
+- Brad Burdick found a minor problem in the docs/examples/Makefile.am
+
+Daniel (27 April 2001)
+- Updated the INTERALS document again. It was lagging a bit. I think I made it
+  more easy to follow now as well.
+
+- Brad Burdick found a problem with persistent connections when curl received
+  a "Content-Length: 0" header.
+
+- Giuseppe D'Ambrosio was first out to report that TELNET doesn't work in curl
+  compiled/built on win32. It seems to work for unixes though!
+
+- Dave Hamilton reported weird problems with CURL/PHP that I really can't
+  explain at the moment. I'm hoping on some help from the PHP crew.
+
+Daniel (26 April 2001)
+- I rewrote the FTP command response function. I had to do it to make ftps
+  work, as the OpenSSL read()-function didn't work the same way the normal
+  unix read() does, but it was also a huge performance boost. Previously the
+  function read one byte at a time, now it reads very large chunks, and it
+  makes a notable speed difference.
+
+Daniel (25 April 2001)
+- Connection re-use when not using a proxy didn't work properly for
+  non-default port numbers.
+
+Daniel (24 April 2001)
+- I've noticed that FTPS doesn't work. We attempt to use ssl even for the
+  data transfer, which causes the transfer to 'hang'... We need to fix this.
+
+- Improved the test suite to use 'stunnel' to do HTTPS and FTPS testing on
+  the alredy written perl servers easily.
+
+Daniel (23 April 2001)
+- The OpenSSL version string recently modified didn't zero terminate one
+  of the generated strings properly, which could lead to a crash or simply
+  weird version string output!
+
 Version 7.7.2
 
 Daniel (22 April 2001)
 - Rosimildo da Silva updated the Makefiles for Borland/Windows.
 
 - Eric Rautman pointed out a problem with persistent connections that would
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/curl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/curl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/curl.1	2001-04-20 14:05:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/curl.1	2001-05-04 16:45:36.000000000 +0800
@@ -822,12 +822,14 @@
  - Robert Weaver <robert.weaver@sabre.com>
  - Ingo Ralf Blum <ingoralfblum@ingoralfblum.com>
  - Jun-ichiro itojun Hagino <itojun@iijlab.net>
  - Frederic Lepied <flepied@mandrakesoft.com>
  - Georg Horn <horn@koblenz-net.de>
  - Cris Bailiff <c.bailiff@awayweb.com>
+ - Sterling Hughes <sterling@designmultimedia.com>
+ - S. Moonesamy
 
 .SH WWW
 http://curl.haxx.se
 .SH FTP
 ftp://ftp.sunet.se/pub/www/utilities/curl/
 .SH "SEE ALSO"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/curl_easy_setopt.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/curl_easy_setopt.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/curl_easy_setopt.3	2001-04-10 15:37:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/curl_easy_setopt.3	2001-05-04 15:45:34.000000000 +0800
@@ -39,60 +39,49 @@
 .I "curl_easy_init"
 call.
 .SH OPTIONS
 These options are in a bit of random order, but you'll figure it out!
 .TP 0.8i
 .B CURLOPT_FILE
-Data pointer to pass instead of FILE * to the file write function. Note that
-if you specify the
+Data pointer to pass to file write function. Note that if you specify the
 .I CURLOPT_WRITEFUNCTION
-, this is the pointer you'll get as input.
+, this is the pointer you'll get as input. If you don't use a callback, you
+must pass a 'FILE *' as libcurl passes it to fwrite() when writing data.
 
-NOTE: If you're using libcurl as a win32 .DLL, you MUST use a
-.I CURLOPT_WRITEFUNCTION
-if you set the
-.I CURLOPT_FILE
-option.
+NOTE: If you're using libcurl as a win32 DLL, you MUST use the
+\fICURLOPT_WRITEFUNCTION\fP if you set this option.
 .TP
 .B CURLOPT_WRITEFUNCTION
 Function pointer that should match the following prototype:
-.BI "size_t function( void *ptr, size_t size, size_t nmemb, FILE *stream);"
+.BI "size_t function( void *ptr, size_t size, size_t nmemb, void *stream);"
 This function gets called by libcurl as soon as there is received data that
-needs to be written down. The size of the data pointed to by
-.I ptr 
-is
-.I size
-multiplied with
-.I nmemb.
-Return the number of bytes actually written or return -1 to signal error to the library (it will cause it to abort the transfer).
+needs to be written down. The size of the data pointed to by \fIptr\fP is
+\fIsize\fP multiplied with \fInmemb\fP.  Return the number of bytes actually
+written or return -1 to signal error to the library (it will cause it to abort
+the transfer with CURLE_WRITE_ERROR).
+
+Set the \fIstream\fP argument with the \fBCURLOPT_FILE\fP option.
 .TP
 .B CURLOPT_INFILE
-Data pointer to pass instead of FILE * to the file read function. Note that if
-you specify the
-.I CURLOPT_READFUNCTION
-, this is the pointer you'll get as input.
+Data pointer to pass to the file read function. Note that if you specify the
+\fICURLOPT_READFUNCTION\fP, this is the pointer you'll get as input. If you
+don't specify a read callback, this must be a valid FILE *.
 
-NOTE: If you're using libcurl as a win32 .DLL, you MUST use a
-.I CURLOPT_READFUNCTION
-if you set the
-.I CURLOPT_INFILE
-option.
+NOTE: If you're using libcurl as a win32 DLL, you MUST use a
+\fICURLOPT_READFUNCTION\fP if you set this option.
 .TP
 .B CURLOPT_READFUNCTION
 Function pointer that should match the following prototype:
-.BI "size_t function( void *ptr, size_t size, size_t nmemb, FILE *stream);"
+.BI "size_t function( void *ptr, size_t size, size_t nmemb, void *stream);"
 This function gets called by libcurl as soon as it needs to read data in order
-to send it to the peer. The data area pointed at by the pointer
-.I ptr
-may be filled with at most
-.I size
-multiplied with
-.I nmemb
-number of bytes. Your function must return the actual number of bytes that you
-stored in that memory area. Returning -1 will signal an error to the library
-and cause it to abort the current transfer immediately.
+to send it to the peer. The data area pointed at by the pointer \fIptr\fP may
+be filled with at most \fIsize\fP multiplied with \fInmemb\fP number of
+bytes. Your function must return the actual number of bytes that you stored in
+that memory area. Returning -1 will signal an error to the library and cause
+it to abort the current transfer immediately (with a CURLE_READ_ERROR return
+code).
 .TP
 .B CURLOPT_INFILESIZE
 When uploading a file to a remote site, this option should be used to tell
 libcurl what the expected size of the infile is.
 .TP
 .B CURLOPT_URL
@@ -314,22 +303,21 @@
 Pass a pointer to a linked list of FTP commands to pass to the server after
 your ftp transfer request. The linked list should be a fully valid list of
 struct curl_slist structs properly filled in as described for
 .I "CURLOPT_QUOTE"
 .TP
 .B CURLOPT_WRITEHEADER
-Pass a FILE * to be used to write the header part of the received data to. The
-headers are guaranteed to be written one-by-one to this file handle and only
-complete lines are written. Parsing headers should be easy enough using
-this. See also the
-.I CURLOPT_HEADERFUNCTION
-option.
+Pass a pointer to be used to write the header part of the received data to. If
+you don't use a callback to take care of the writing, this must be a FILE
+*. The headers are guaranteed to be written one-by-one and only complete lines
+are written. Parsing headers should be easy enough using this. See also the
+\fICURLOPT_HEADERFUNCTION\fP option.
 .TP
 .B CURLOPT_HEADERFUNCTION
 Function pointer that should match the following prototype:
-.BI "size_t function( void *ptr, size_t size, size_t nmemb, FILE *stream);"
+.BI "size_t function( void *ptr, size_t size, size_t nmemb, void *stream);"
 This function gets called by libcurl as soon as there is received header data
 that needs to be written down. The function will be called once for each
 header with a complete header line in each invoke. The size of the data
 pointed to by
 .I ptr 
 is
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/curl_formparse.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/curl_formparse.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/curl_formparse.3	2001-03-05 23:35:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/curl_formparse.3	2001-05-03 22:24:05.000000000 +0800
@@ -1,30 +1,35 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_formparse 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
+.TH curl_formparse 3 "3 May 2001" "libcurl 7.7.2" "libcurl Manual"
 .SH NAME
 curl_formparse - add a section to a multipart/formdata HTTP POST
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
-.BI "CURLcode curl_formparse(char *" string, "struct HttpPost **" firstitem,
-.BI "struct HttpPost ** "lastitem ");"
+.BI "CURLcode curl_formparse(char * " string, " struct HttpPost ** " firstitem,
+.BI "struct HttpPost ** " lastitem ");"
 .ad
 .SH DESCRIPTION
 curl_formparse() is used to append sections when building a multipart/formdata
-HTTP POST. Append one section at a time until you've added all the sections
-you want included and then you pass the
-.I firstitem
-pointer as parameter to CURLOPT_HTTPPOST.
-.I lastitem
-is set after each call and on repeated invokes it should be left as set to
-allow repeated invokes to find the end of the list in a faster way.
-.I string
-must be a zero terminated string following the following syntax.
+HTTP POST (sometimes refered to as rfc1867-style posts). Append one section at
+a time until you've added all the sections you want included and then you pass
+the \fI firstitem\fP pointer as parameter to \fBCURLOPT_HTTPPOST\fP.
+\fIlastitem\fP is set after each call and on repeated invokes it should be
+left as set to allow repeated invokes to find the end of the list in a faster
+way.  \fIstring\fP must be a zero terminated string abiding to the syntax
+described in a section below
+
+The pointers \fIfirstitem\fP and \fIlastitem\fP point to, should both be
+pointers to NULL in the first call to this function. All list-data will be
+allocated by the function itself. You must call \fIcurl_formfree\fP after the
+form post has been done to free the resources again.
+
+See example below.
 .SH "FORM PARSE STRINGS"
 The
 .I string 
 parameter must be using one of the following patterns. Note that the []
 letters should not be included in the real-life string.
 .TP 0.8i
@@ -52,11 +57,23 @@
 .B [name]=@[filename1,filename2,...];[type=<content-type>]
 When you specify several files to read the contents from, you can set the
 content-type for all of them in the same way as with a single file.
 .PP
 .SH RETURN VALUE
 Returns non-zero if an error occurs.
+.SH EXAMPLE
+
+ HttpPost* post = NULL;
+ HttpPost* last = NULL;
+
+ /* Add an image section */
+ curl_formparse("picture=@my-face.jpg", &post, &last);
+ /* Add a normal text section */
+ curl_formparse("name=FooBar", &post, &last);
+ /* Set the form info */
+ curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);
+
 .SH "SEE ALSO"
 .BR curl_easy_setopt "(3) "
 .SH BUGS
 Surely there are some, you tell me!
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs: curl_mprintf.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs: curl_printf.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: curlgtk.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: ftpget.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/examples/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/examples/Makefile.am	2001-03-27 17:09:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples/Makefile.am	2001-05-04 17:35:55.000000000 +0800
@@ -1,12 +1,12 @@
 #
-# $Id: Makefile.am,v 1.7 2001/03/27 09:09:09 bagder Exp $
+# $Id: Makefile.am,v 1.9 2001/05/04 09:35:55 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-EXTRA_DIST = 
-	README curlgtk.c sepheaders.c simple.c postit.c \
-	win32sockets.c persistant.c ftpget.c Makefile.example
+EXTRA_DIST = README curlgtk.c sepheaders.c simple.c postit.c \
+	     win32sockets.c persistant.c ftpget.c Makefile.example \
+	     multithread.c
 
 all:
 	@echo "done"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: Makefile.example
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/examples/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/examples/Makefile.in	2001-04-23 15:29:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples/Makefile.in	2001-05-07 18:52:10.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.7 2001/03/27 09:09:09 bagder Exp $
+# $Id: Makefile.am,v 1.9 2001/05/04 09:35:55 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -80,13 +80,14 @@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-EXTRA_DIST = 
+EXTRA_DIST = README curlgtk.c sepheaders.c simple.c postit.c 	     win32sockets.c persistant.c ftpget.c Makefile.example 	     multithread.c
+
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../../config.h ../../src/config.h
 CONFIG_CLEAN_FILES = 
 DIST_COMMON =  README Makefile.am Makefile.in
 
 
@@ -180,14 +181,12 @@
 installcheck-am installcheck install-exec-am install-exec \
 install-data-am install-data install-am install uninstall-am uninstall \
 all-redirect all-am all installdirs mostlyclean-generic \
 distclean-generic clean-generic maintainer-clean-generic clean \
 mostlyclean distclean maintainer-clean
 
-	README curlgtk.c sepheaders.c simple.c postit.c \
-	win32sockets.c persistant.c ftpget.c Makefile.example
 
 all:
 	@echo "done"
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: multithread.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: persistant.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: postit.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: sepheaders.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: simple.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/examples: win32sockets.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/INSTALL	2001-04-17 14:06:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/INSTALL	2001-05-04 14:16:38.000000000 +0800
@@ -234,13 +234,13 @@
       - GNU sed
       - autoconf 2.13
 
    If you want to build with OpenSSL or OpenLDAP support, you'll need to
    download those libraries, too. Dirk Ohme has done some work to port SSL
    libraries under OS/2, but it looks like he doesn't care about emx.  You'll
-   find his patches on: http://come.to/Dirk.Ohme
+   find his patches on: http://come.to/Dirk_Ohme
 
    If during the linking you get an error about _errno being an undefined
    symbol referenced from the text segment, you need to add -D__ST_MT_ERRNO__
    in your definitions.
 
    If everything seems to work fine but there's no curl.exe, you need to add
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/INTERNALS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/INTERNALS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/INTERNALS	2001-04-23 15:08:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/INTERNALS	2001-04-27 22:45:47.000000000 +0800
@@ -1,7 +1,7 @@
-                                       Updated for curl 7.7 on March 13, 2001
+                                       Updated for curl 7.7.2 on April 26, 2001
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -70,47 +70,82 @@
  put in the lib/easy.c file.
 
  All printf()-style functions use the supplied clones in lib/mprintf.c. This
  makes sure we stay absolutely platform independent.
 
  curl_easy_init() allocates an internal struct and makes some initializations.
- The returned handle does not revail internals.
+ The returned handle does not reveal internals.
 
  curl_easy_setopt() takes a three arguments, where the option stuff must be
  passed in pairs, the parameter-ID and the parameter-value. The list of
  options is documented in the man page.
 
  curl_easy_perform() does a whole lot of things:
 
- It starts off in the lib/easy.c file by calling curl_transfer(), but the main
- work is lib/url.c. The function first analyzes the URL, it separates the
- different components and connects to the remote host. This may involve using
- a proxy and/or using SSL. The Curl_gethost() function in lib/hostip.c is used
- for looking up host names.
-
- When connected, the proper protocol-specific function is called. The
- functions are named after the protocols they handle. Curl_ftp(), Curl_http(),
- Curl_dict(), etc. They all reside in their respective files (ftp.c, http.c
- and dict.c).
-
- The protocol-specific functions of course deal with protocol-specific
- negotiations and setup. They have access to the Curl_sendf() (from
- lib/sendf.c) function to send printf-style formatted data to the remote host
- and when they're ready to make the actual file transfer they call the
- Curl_Transfer() function (in lib/transfer.c) to setup the transfer and
- returns. Curl_perform() then calls Transfer() in lib/transfer.c that performs
- the entire file transfer. Curl_perform() is what does the main "connect - do
- - transfer - done" loop. It loops if there's a Location: to follow.
-
- During transfer, the progress functions in lib/progress.c are called at a
- frequent interval (or at the user's choice, a specified callback might get
- called). The speedcheck functions in lib/speedcheck.c are also used to verify
- that the transfer is as fast as required.
+ It starts off in the lib/easy.c file by calling Curl_perform() and the main
+ work then continues lib/url.c. The flow continues with a call to
+ Curl_connect() to connect to the remote site.
+
+ o Curl_connect()
+
+   ... analyzes the URL, it separates the different components and connects to
+   the remote host. This may involve using a proxy and/or using SSL. The
+   Curl_gethost() function in lib/hostip.c is used for looking up host names.
+
+   When Curl_connect is done, we are connected to the remote site. Then it is
+   time to tell the server to get a document/file. Curl_do() arranges this.
+
+ o Curl_do()
+
+   Curl_do() makes sure the proper protocol-specific function is called. The
+   functions are named after the protocols they handle. Curl_ftp(),
+   Curl_http(), Curl_dict(), etc. They all reside in their respective files
+   (ftp.c, http.c and dict.c).
+
+   The protocol-specific functions of course deal with protocol-specific
+   negotiations and setup. They have access to the Curl_sendf() (from
+   lib/sendf.c) function to send printf-style formatted data to the remote
+   host and when they're ready to make the actual file transfer they call the
+   Curl_Transfer() function (in lib/transfer.c) to setup the transfer and
+   returns.
+
+ o Transfer()
+
+   Curl_perform() then calls Transfer() in lib/transfer.c that performs
+   the entire file transfer.
+
+   During transfer, the progress functions in lib/progress.c are called at a
+   frequent interval (or at the user's choice, a specified callback might get
+   called). The speedcheck functions in lib/speedcheck.c are also used to
+   verify that the transfer is as fast as required.
+
+ o Curl_done()
+
+   Called after a transfer is done. This function takes care of everything
+   that has to be done after a transfer. This function attempts to leave
+   matters in a state so that Curl_do() should be possible to call again on
+   the same connection (in a persistent connection case). It may also soon be
+   closed with Curl_disconnect().
+
+ o Curl_disconnect()
+
+   During normal connection and transfers, no one ever tries to close any
+   connection so this is not normally called when curl_easy_perform() is
+   used. This function is only used when we are certain that no more transfers
+   is going to be made on the connection (it can be also closed by
+   force). This function can also be called at times to make sure that libcurl
+   doesn't keep too many connections alive at the same time.
+
+   This function cleans up all resources that are associated with a single
+   connection.
+
+ Curl_perform() is the function that does the main "connect - do - transfer -
+ done" loop. It loops if there's a Location: to follow.
 
  When completed, the curl_easy_cleanup() should be called to free up used
- resources.
+ resources. It runs Curl_disconnect() on all open connectons.
 
  A quick roundup on internal function sequences (many of these call
  protocol-specific function-pointers):
 
   curl_connect - connects to a remote site and does initial connect fluff
    This also checks for an existing connection to the requested site and uses
@@ -269,31 +305,32 @@
 
  When the operation is done, the ourWriteOut() function in src/writeout.c may
  be called to report about the operation. That function is using the
  curl_easy_getinfo() function to extract useful information from the curl
  session.
 
- Recent versions may loop and do all that several times if many URLs were
+ Recent versions may loop and do all this several times if many URLs were
  specified on the command line or config file.
 
 Memory Debugging
 ================
 
- The file named lib/memdebug.c contains debug-versions of a few
- functions. Functions such as malloc, free, fopen, fclose, etc that somehow
- deal with resources that might give us problems if we "leak" them. The
- functions in the memdebug system do nothing fancy, they do their normal
- function and then log information about what they just did. The logged data
- can then be analyzed after a complete session,
+ The file lib/memdebug.c contains debug-versions of a few functions. Functions
+ such as malloc, free, fopen, fclose, etc that somehow deal with resources
+ that might give us problems if we "leak" them. The functions in the memdebug
+ system do nothing fancy, they do their normal function and then log
+ information about what they just did. The logged data can then be analyzed
+ after a complete session,
 
- memanalyze.pl is a perl script present only present in CVS (not part of the
+ memanalyze.pl is the perl script present only present in CVS (not part of the
  release archives) that analyzes a log file generated by the memdebug
  system. It detects if resources are allocated but never freed and other kinds
  of errors related to resource management.
 
- Use -DMALLOCDEBUG when compiling to enable memory debugging.
+ Use -DMALLOCDEBUG when compiling to enable memory debugging, this is also
+ switched on by running configure with --enable-debug.
 
 Test Suite
 ==========
 
  Since November 2000, a test suite has evolved. It is placed in its own
  subdirectory directly off the root in the curl archive tree, and it contains
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/libcurl.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/libcurl.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/libcurl.5	2001-04-20 22:40:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/libcurl.5	2001-04-23 19:40:24.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
-.\" nroff -man libcurl.5
+.\" nroff -man [file]
 .\" Written by Daniel Stenberg
 .\"
-.TH libcurl 5 "20 April 2001" "libcurl 7.7.2" "libcurl overview"
+.TH libcurl 5 "23 April 2001" "libcurl 7.7.2" "libcurl overview"
 .SH NAME
 libcurl \- client-side URL transfers
 .SH DESCRIPTION
 This is an overview on how to use libcurl in your c/c++ programs. There are
 specific man pages for each function mentioned in here.
 
@@ -61,12 +61,18 @@
 .TP
 .B curl_slist_append()
 builds a linked list
 .TP
 .B curl_slist_free_all()
 frees a whole curl_slist
+.TP
+.B curl_mprintf()
+portable printf() functions
+.TP
+.B curl_streual()
+portable case insensitive string comparisons
 .RE
 
 .SH "LINKING WITH LIBCURL"
 Starting with 7.7.2 (on unix-like machines), there's a tool named curl-config
 that gets installed with the rest of the curl stuff when 'make install' is
 performed.
@@ -117,8 +123,8 @@
 held by libcurl will be closed and forgotten.
 
 Note that the options set with curl_easy_setopt() will be used in on every
 repeat curl_easy_perform() call
 .SH "COMPATIBILITY WITH OLDER LIBCURLS"
 Repeated curl_easy_perform() calls on the same handle were not supported in
-pre-7.7 versions, and caused confusion and defined behaviour.
+pre-7.7 versions, and caused confusion and undefined behaviour.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/Makefile.am	2001-04-22 23:52:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/Makefile.am	2001-04-23 16:30:22.000000000 +0800
@@ -1,8 +1,8 @@
 #
-# $Id: Makefile.am,v 1.7 2001/04/22 15:50:12 bagder Exp $
+# $Id: Makefile.am,v 1.8 2001/04/23 08:30:22 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 man_MANS = \
 	curl.1 \
@@ -20,13 +20,13 @@
 	curl_slist_free_all.3 \
 	curl_version.3 \
 	curl_escape.3 \
 	curl_unescape.3 \
 	curl_strequal.3 \
 	curl_strnequal.3 \
-	curl_printf.3 \
+	curl_mprintf.3 \
 	libcurl.5
 
 EXTRA_DIST = $(man_MANS) \
 	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS \
 	LIBCURL README.win32 RESOURCES TODO TheArtOfHttpScripting
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/Makefile.in	2001-04-23 15:29:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/Makefile.in	2001-05-07 18:52:10.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.7 2001/04/22 15:50:12 bagder Exp $
+# $Id: Makefile.am,v 1.8 2001/04/23 08:30:22 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -80,13 +80,13 @@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-man_MANS =  	curl.1 	curl-config.1 	curl_easy_cleanup.3 	curl_easy_getinfo.3 	curl_easy_init.3 	curl_easy_perform.3 	curl_easy_setopt.3 	curl_formparse.3 	curl_formfree.3 	curl_getdate.3 	curl_getenv.3 	curl_slist_append.3 	curl_slist_free_all.3 	curl_version.3 	curl_escape.3 	curl_unescape.3 	curl_strequal.3 	curl_strnequal.3 	curl_printf.3 	libcurl.5
+man_MANS =  	curl.1 	curl-config.1 	curl_easy_cleanup.3 	curl_easy_getinfo.3 	curl_easy_init.3 	curl_easy_perform.3 	curl_easy_setopt.3 	curl_formparse.3 	curl_formfree.3 	curl_getdate.3 	curl_getenv.3 	curl_slist_append.3 	curl_slist_free_all.3 	curl_version.3 	curl_escape.3 	curl_unescape.3 	curl_strequal.3 	curl_strnequal.3 	curl_mprintf.3 	libcurl.5
 
 
 EXTRA_DIST = $(man_MANS) 	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS 	LIBCURL README.win32 RESOURCES TODO TheArtOfHttpScripting
 
 
 SUBDIRS = examples
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/README.win32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/README.win32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/docs/README.win32	2000-09-29 16:12:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/docs/README.win32	2001-04-23 19:42:00.000000000 +0800
@@ -19,6 +19,11 @@
   curl web site and view them as plain HTML.
 
   The main curl.1 man page is "built-in". Use a command line similar to this
   in order to extract a separate text file:
 
         curl -M >manual.txt
+
+  Download all the libcurl man pages in HTML format using the link on the
+  bottom of this page:
+
+        http://curl.haxx.se/libcurl/c/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/include/curl/curl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/include/curl/curl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/include/curl/curl.h	2001-04-23 15:28:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/include/curl/curl.h	2001-05-07 18:51:33.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curl.h,v 1.74 2001/04/17 13:21:13 bagder Exp $
+ * $Id: curl.h,v 1.76 2001/05/04 07:47:11 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 /* The include stuff here is mainly for time_t! */
 #ifdef vms
 # include <types.h>
@@ -73,18 +73,18 @@
                                       size_t ultotal,
                                       size_t ulnow);
 
 typedef size_t (*curl_write_callback)(char *buffer,
                                       size_t size,
                                       size_t nitems,
-                                      FILE *outstream);
+                                      void *outstream);
 
 typedef size_t (*curl_read_callback)(char *buffer,
                                      size_t size,
                                      size_t nitems,
-                                     FILE *instream);
+                                     void *instream);
 
 typedef int (*curl_passwd_callback)(void *clientp,
                                     char *prompt,
                                     char *buffer,
                                     int buflen);
 
@@ -170,13 +170,13 @@
 #define CURLOPTTYPE_OBJECTPOINT   10000
 #define CURLOPTTYPE_FUNCTIONPOINT 20000
 
 typedef enum {
   CINIT(NOTHING, LONG, 0), /********* the first one is unused ************/
   
-  /* This is the FILE * the regular output should be written to. */
+  /* This is the FILE * or void * the regular output should be written to. */
   CINIT(FILE, OBJECTPOINT, 1),
 
   /* The full URL to get/put */
   CINIT(URL,  OBJECTPOINT, 2),
 
   /* Port number to connect to, if other than default. Specify the CONF_PORT
@@ -273,13 +273,14 @@
   /* send TYPE parameter? */
   CINIT(CRLF, LONG, 27),
 
   /* send linked-list of QUOTE commands */
   CINIT(QUOTE, OBJECTPOINT, 28),
 
-  /* send FILE * to store headers to */
+  /* send FILE * or void * to store headers to, if you use a callback it
+     is simply passed to the callback unmodified */
   CINIT(WRITEHEADER, OBJECTPOINT, 29),
 
 #ifdef MULTIDOC
   /* send linked list of MoreDoc structs */
   CINIT(MOREDOCS, OBJECTPOINT, 30),
 #endif
@@ -483,14 +484,14 @@
 /* Escape and unescape URL encoding in strings. The functions return a new
  * allocated string or NULL if an error occurred.  */
 char *curl_escape(char *string, int length);
 char *curl_unescape(char *string, int length);
 
 /* This is the version number */
-#define LIBCURL_VERSION "7.7.2"
-#define LIBCURL_VERSION_NUM 0x070702
+#define LIBCURL_VERSION "7.7.3"
+#define LIBCURL_VERSION_NUM 0x070703
 
 /* linked-list structure for the CURLOPT_QUOTE option (and other) */
 struct curl_slist {
 	char			*data;
 	struct curl_slist	*next;
 };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/ftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/ftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/ftp.c	2001-04-18 15:25:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/ftp.c	2001-04-26 18:29:24.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.c,v 1.65 2001/04/18 07:25:11 bagder Exp $
+ * $Id: ftp.c,v 1.66 2001/04/26 10:29:24 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <string.h>
@@ -144,22 +144,182 @@
 
 /* --- parse FTP server responses --- */
 
 #define lastline(line) (isdigit((int)line[0]) && isdigit((int)line[1]) && \
 			isdigit((int)line[2]) && (' ' == line[3]))
 
+
+int Curl_GetFTPResponse(int sockfd,
+                        char *buf,
+                        struct connectdata *conn,
+                        int *ftpcode)
+{
+  /* Brand new implementation.
+   * We cannot read just one byte per read() and then go back to select()
+   * as it seems that the OpenSSL read() stuff doesn't grok that properly.
+   *
+   * Alas, read as much as possible, split up into lines, use the ending
+   * line in a response or continue reading.
+   */
+
+  int nread;   /* total size read */
+  int perline; /* count bytes per line */
+  bool keepon=TRUE;
+  ssize_t gotbytes;
+  char *ptr;
+  int timeout = 3600; /* default timeout in seconds */
+  struct timeval interval;
+  fd_set rkeepfd;
+  fd_set readfd;
+  struct UrlData *data = conn->data;
+  char *line_start;
+  int code;
+
+#define SELECT_OK      0
+#define SELECT_ERROR   1
+#define SELECT_TIMEOUT 2
+  int error = SELECT_OK;
+
+  if(ftpcode)
+    *ftpcode=0; /* 0 for errors */
+
+  if(data->timeout) {
+    /* if timeout is requested, find out how much remaining time we have */
+    timeout = data->timeout - /* timeout time */
+      (Curl_tvlong(Curl_tvnow()) - Curl_tvlong(conn->now)); /* spent time */
+    if(timeout <=0 ) {
+      failf(data, "Transfer aborted due to timeout");
+      return -SELECT_TIMEOUT; /* already too little time */
+    }
+  }
+
+  FD_ZERO (&readfd);		/* clear it */
+  FD_SET (sockfd, &readfd);     /* read socket */
+
+  /* get this in a backup variable to be able to restore it on each lap in the
+     select() loop */
+  rkeepfd = readfd;
+
+  ptr=buf;
+  line_start = buf;
+
+  nread=0;
+  perline=0;
+  keepon=TRUE;
+
+  while((nread<BUFSIZE) && (keepon && !error)) {
+    readfd = rkeepfd;		   /* set every lap */
+    interval.tv_sec = timeout;
+    interval.tv_usec = 0;
+
+    switch (select (sockfd+1, &readfd, NULL, NULL, &interval)) {
+    case -1: /* select() error, stop reading */
+      error = SELECT_ERROR;
+      failf(data, "Transfer aborted due to select() error");
+      break;
+    case 0: /* timeout */
+      error = SELECT_TIMEOUT;
+      failf(data, "Transfer aborted due to timeout");
+      break;
+    default:
+      /*
+       * This code previously didn't use the kerberos sec_read() code
+       * to read, but when we use Curl_read() it may do so. Do confirm
+       * that this is still ok and then remove this comment!
+       */
+      if(CURLE_OK != Curl_read(conn, sockfd, ptr, BUFSIZE-nread, &gotbytes))
+        keepon = FALSE;
+      else if(gotbytes <= 0) {
+        keepon = FALSE;
+        error = SELECT_ERROR;
+        failf(data, "Connection aborted");
+      }
+      else {
+        /* we got a whole chunk of data, which can be anything from one
+         * byte to a set of lines and possible just a piece of the last
+         * line */
+        int i;
+
+        nread += gotbytes;
+        for(i=0; i< gotbytes; ptr++, i++) {
+          perline++;
+          if(*ptr=='\n') {
+            /* a newline is CRLF in ftp-talk, so the CR is ignored as
+               the line isn't really terminated until the LF comes */
+
+            /* output debug output if that is requested */
+            if(data->bits.verbose) {
+              fputs("< ", data->err);
+              fwrite(line_start, 1, perline, data->err);
+              /* no need to output LF here, it is part of the data */
+            }
+
+            if(perline>3 && lastline(line_start)) {
+              /* This is the end of the last line, copy the last
+               * line to the start of the buffer and zero terminate,
+               * for old times sake (and krb4)! */
+              char *moo;
+              int i;
+              for(moo=line_start, i=0; moo<ptr; moo++, i++)
+                buf[i] = *moo;
+              moo[i]=0; /* zero terminate */
+              keepon=FALSE;
+              break;
+            }
+            perline=0; /* line starts over here */
+            line_start = ptr+1;
+          }
+        }
+      }
+      break;
+    } /* switch */
+  } /* while there's buffer left and loop is requested */
+
+  if(!error)
+    code = atoi(buf);
+
+#if KRB4
+  /* handle the security-oriented responses 6xx ***/
+  /* FIXME: some errorchecking perhaps... ***/
+  switch(code) {
+  case 631:
+    sec_read_msg(conn, buf, prot_safe);
+    break;
+  case 632:
+    sec_read_msg(conn, buf, prot_private);
+    break;
+  case 633:
+    sec_read_msg(conn, buf, prot_confidential);
+    break;
+  default:
+    /* normal ftp stuff we pass through! */
+    break;
+  }
+#endif
+
+  if(error)
+    return -error;
+
+  if(ftpcode)
+    *ftpcode=code; /* return the initial number like this */
+
+  return nread; /* total amount of bytes read */
+}
+
+#if 0
 /*
  * We allow the ftpcode pointer to be NULL if no reply integer is wanted
  */
 
 int Curl_GetFTPResponse(int sockfd, char *buf,
                         struct connectdata *conn,
                         int *ftpcode)
 {
   int nread;
   ssize_t keepon=TRUE;
+  size_t got;
   char *ptr;
   int timeout = 3600; /* in seconds */
   struct timeval interval;
   fd_set rkeepfd;
   fd_set readfd;
   struct UrlData *data = conn->data;
@@ -257,12 +417,13 @@
 
   if(ftpcode)
     *ftpcode=atoi(buf); /* return the initial number like this */
 
   return nread;
 }
+#endif
 
 /* -- who are we? -- */
 char *Curl_getmyhost(char *buf, int buf_size)
 {
 #if defined(HAVE_GETHOSTNAME)
   gethostname(buf, buf_size);
@@ -834,45 +995,46 @@
 	  char *q = strchr(portmsgbuf, '%');
 	  if (q)
 	    *q = '\0';
 	}
 	ftpsendf(conn->firstsocket, conn, "%s |%d|%s|%s|", *modep, eprtaf,
 	    portmsgbuf, tmp);
-      } else if (strcmp(*modep, "LPRT") == 0 || strcmp(*modep, "PORT") == 0) {
+      } else if (strcmp(*modep, "LPRT") == 0 ||
+                 strcmp(*modep, "PORT") == 0) {
 	int i;
 
         if (strcmp(*modep, "LPRT") == 0 && lprtaf < 0)
 	  continue;
         if (strcmp(*modep, "PORT") == 0 && sa->sa_family != AF_INET)
 	  continue;
 
 	portmsgbuf[0] = '\0';
         if (strcmp(*modep, "LPRT") == 0) {
 	  snprintf(tmp, sizeof(tmp), "%d,%d", lprtaf, alen);
 	  if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
-	    goto again;
+	    continue;
 	  }
 	}
 	for (i = 0; i < alen; i++) {
 	  if (portmsgbuf[0])
 	    snprintf(tmp, sizeof(tmp), ",%u", ap[i]);
 	  else
 	    snprintf(tmp, sizeof(tmp), "%u", ap[i]);
 	  if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
-	    goto again;
+	    continue;
 	  }
 	}
         if (strcmp(*modep, "LPRT") == 0) {
 	  snprintf(tmp, sizeof(tmp), ",%d", plen);
 	  if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf))
-	    goto again;
+	    continue;
 	}
 	for (i = 0; i < plen; i++) {
 	  snprintf(tmp, sizeof(tmp), ",%u", pp[i]);
 	  if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
-	    goto again;
+            continue;
 	  }
 	}
 	ftpsendf(conn->firstsocket, conn, "%s %s", *modep, portmsgbuf);
       }
 
       nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/ssluse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/ssluse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/ssluse.c	2001-03-14 18:15:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/ssluse.c	2001-04-25 05:41:29.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.c,v 1.18 2001/03/14 10:15:42 bagder Exp $
+ * $Id: ssluse.c,v 1.19 2001/04/24 21:41:29 bagder Exp $
  *****************************************************************************/
 
 /*
  * The original SSL code was written by
  * Linas Vepstas <linas@linas.org> and Sampo Kellomaki <sampo@iki.fi>
  */
@@ -34,12 +34,17 @@
 #include "sendf.h"
 #include "formdata.h" /* for the boundary function */
 
 #ifdef USE_SSLEAY
 #include <openssl/rand.h>
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 static char global_passwd[64];
 
 static int passwd_callback(char *buf, int num, int verify
 #if OPENSSL_VERSION_NUMBER >= 0x00904100L
                            /* This was introduced in 0.9.4, we can set this
                               using SSL_CTX_set_default_passwd_cb_userdata()
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/transfer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/transfer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/transfer.c	2001-04-18 15:25:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/transfer.c	2001-05-03 18:45:39.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.c,v 1.34 2001/04/18 07:25:11 bagder Exp $
+ * $Id: transfer.c,v 1.37 2001/05/03 10:45:39 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -358,12 +358,28 @@
                    *
                    * If we requested a "no body", this is a good time to get
                    * out and return home.
                    */
                   if(data->bits.no_body)
                     return CURLE_OK;
+
+                  if(!conn->bits.close) {
+                    /* If this is not the last request before a close, we must
+                       set the maximum download size to the size of the
+                       expected document or else, we won't know when to stop
+                       reading! */
+                    if(-1 != conn->size)
+                      conn->maxdownload = conn->size;
+
+                    /* If max download size is *zero* (nothing) we already
+                       have nothing and can safely return ok now! */
+                    if(0 == conn->maxdownload)
+                      return CURLE_OK;
+                    
+                    /* What to do if the size is *not* known? */
+                  }
                   break;		/* exit header line loop */
                 }
 
                 /* We continue reading headers, so reset the line-based
                    header parsing variables hbufp && hbuflen */
                 hbufp = data->headerbuff;
@@ -389,17 +405,27 @@
                     /* serious error, go home! */
                     failf (data, "The requested file was not found");
                     return CURLE_HTTP_NOT_FOUND;
                   }
                   data->progress.httpcode = httpcode;
                   data->progress.httpversion = httpversion;
+
                   if(httpversion == 0)
                     /* Default action for HTTP/1.0 must be to close, unless
                        we get one of those fancy headers that tell us the
                        server keeps it open for us! */
                     conn->bits.close = TRUE;
+
+                  if (httpcode == 304)
+                    /* (quote from RFC2616, section 10.3.5):
+                     *  The 304 response MUST NOT contain a
+                     * message-body, and thus is always
+                     * terminated by the first empty line
+                     * after the header fields.
+                     */
+                    conn->size=0;
                 }
                 else {
                   header = FALSE;	/* this is not a header line */
                   break;
                 }
               }
@@ -580,22 +606,12 @@
                       }
                       break;
                     } /* switch */
                   } /* two valid time strings */
                 } /* we have a time condition */
 
-                if(!conn->bits.close) {
-                  /* If this is not the last request before a close, we must
-                     set the maximum download size to the size of the expected
-                     document or else, we won't know when to stop reading! */
-                  if(-1 != conn->size)
-                    conn->maxdownload = conn->size;
-
-                  /* What to do if the size is *not* known? */
-                }
-
               } /* this is HTTP */
             } /* this is the first time we write a body part */
             bodywrites++;
 
             if(conn->bits.chunk) {
               /*
@@ -619,25 +635,25 @@
                    str buffer that weren't written to the client, but we don't
                    care about them right now. */
               }
               /* If it returned OK, we just keep going */
             }
 
-            if(conn->maxdownload &&
+            if((-1 != conn->maxdownload) &&
                (bytecount + nread >= conn->maxdownload)) {
               nread = conn->maxdownload - bytecount;
               if((signed int)nread < 0 ) /* this should be unusual */
                 nread = 0;
               keepon &= ~KEEP_READ; /* we're done reading */
             }
 
             bytecount += nread;
 
             Curl_pgrsSetDownloadCounter(data, (double)bytecount);
             
-            if(! conn->bits.chunk) {
+            if(!conn->bits.chunk && nread) {
               /* If this is chunky transfer, it was already written */
               urg = Curl_client_write(data, CLIENTWRITE_BODY, str, nread);
               if(urg)
                 return urg;
             }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/url.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/url.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/url.c	2001-04-23 14:11:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/url.c	2001-05-04 15:47:11.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.c,v 1.117 2001/04/23 06:11:08 bagder Exp $
+ * $Id: url.c,v 1.121 2001/05/04 07:47:11 bagder Exp $
  *****************************************************************************/
 
 /* -- WIN32 approved -- */
 
 #include "setup.h"
 
@@ -213,16 +213,16 @@
 
     data->out = stdout; /* default output to stdout */
     data->in  = stdin;  /* default input from stdin */
     data->err  = stderr;  /* default stderr to stderr */
 
     /* use fwrite as default function to store output */
-    data->fwrite = (size_t (*)(char *, size_t, size_t, FILE *))fwrite;
+    data->fwrite = (curl_write_callback)fwrite;
 
     /* use fread as default function to read input */
-    data->fread = (size_t (*)(char *, size_t, size_t, FILE *))fread;
+    data->fread = (curl_read_callback)fread;
 
     /* set the default passwd function */
     data->fpasswd = my_getpass;
 
     data->infilesize = -1; /* we don't know any size */
 
@@ -927,13 +927,13 @@
       continue;
     if(!needle->bits.httpproxy) {
       /* The requested connection does not use a HTTP proxy */
 
       if(strequal(needle->protostr, check->protostr) &&
          strequal(needle->name, check->name) &&
-         (needle->port == check->port) ) {
+         (needle->remote_port == check->remote_port) ) {
         bool dead;
         if(strequal(needle->protostr, "FTP")) {
           /* This is FTP, verify that we're using the same name and
              password as well */
           if(!strequal(needle->data->user, check->proto.ftp->user) ||
              !strequal(needle->data->passwd, check->proto.ftp->passwd)) {
@@ -1361,12 +1361,15 @@
   conn->bits.close = TRUE;
   
   /* inherite initial knowledge from the data struct */
   conn->bits.user_passwd = data->userpwd?1:0;
   conn->bits.proxy_user_passwd = data->proxyuserpwd?1:0;
 
+  /* maxdownload must be -1 on init, as 0 is a valid value! */
+  conn->maxdownload = -1;  /* might have been used previously! */
+
   /* Store creation time to help future close decision making */
   conn->created = Curl_tvnow();
 
 
   /***********************************************************
    * We need to allocate memory to store the path in. We get the size of the
@@ -2026,14 +2029,15 @@
     conn->hostname = old_conn->gname;
 
     conn->path = path;       /* use this one */
     conn->ppath = path;      /* set this too */
 
     /* re-use init */
-    conn->maxdownload = 0;   /* might have been used previously! */
     conn->bits.reuse = TRUE; /* yes, we're re-using here */
+    conn->bits.chunk = FALSE; /* always assume not chunked unless told otherwise */
+    conn->maxdownload = -1;  /* might have been used previously! */
 
     free(old_conn);          /* we don't need this anymore */
 
     *in_connect = conn;      /* return this instead! */
 
     infof(data, "Re-using existing connection! (#%d)\n", conn->connectindex);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/urldata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/urldata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/urldata.h	2001-04-18 15:25:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/urldata.h	2001-05-04 15:47:11.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urldata.h,v 1.60 2001/04/18 07:25:11 bagder Exp $
+ * $Id: urldata.h,v 1.61 2001/05/04 07:47:11 bagder Exp $
  *****************************************************************************/
 
 /* This file is for lib internal stuff */
 
 #include "setup.h"
 
@@ -453,15 +453,16 @@
                      this. */
 
   
   long header_size;  /* size of read header(s) in bytes */
   long request_size; /* the amount of bytes sent in the request(s) */
 
-  FILE *out;    /* the fetched file goes here */
-  FILE *in;     /* the uploaded file is read from here */
-  FILE *writeheader; /* write the header to this is non-NULL */
+  void *out;         /* the fetched file goes here */
+  void *in;          /* the uploaded file is read from here */
+  void *writeheader; /* write the header to this is non-NULL */
+
   char *url;   /* what to get */
   char *freethis; /* if non-NULL, an allocated string for the URL */
   long use_port;  /* which port to use (when not using default) */
   struct Configbits bits; /* new-style (v7) flag data */
   struct ssl_config_data ssl; /* this is for ssl-stuff */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/version.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/version.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/lib/version.c	2001-04-06 16:48:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/lib/version.c	2001-04-24 14:12:07.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: version.c,v 1.10 2001/04/06 08:48:42 bagder Exp $
+ * $Id: version.c,v 1.12 2001/04/24 06:12:07 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 #include <stdio.h>
@@ -38,17 +38,18 @@
 
 #ifdef USE_SSLEAY
 
 #if (SSLEAY_VERSION_NUMBER >= 0x906000)
   {
     char sub[2];
+    sub[1]='\0';
     if(SSLEAY_VERSION_NUMBER&0xff0) {
       sub[0]=((SSLEAY_VERSION_NUMBER>>4)&0xff) + 'a' -1;
     }
     else
-      sub[0]=0;
+      sub[0]='\0';
 
     sprintf(ptr, " (OpenSSL %lx.%lx.%lx%s)",
             (SSLEAY_VERSION_NUMBER>>28)&0xf,
             (SSLEAY_VERSION_NUMBER>>20)&0xff,
             (SSLEAY_VERSION_NUMBER>>12)&0xff,
             sub);
@@ -60,17 +61,18 @@
           (SSLEAY_VERSION_NUMBER>>28)&0xff,
           (SSLEAY_VERSION_NUMBER>>20)&0xff,
           (SSLEAY_VERSION_NUMBER>>12)&0xf);
 #else
   {
     char sub[2];
+    sub[1]='\0';
     if(SSLEAY_VERSION_NUMBER&0x0f) {
       sub[0]=(SSLEAY_VERSION_NUMBER&0x0f) + 'a' -1;
     }
     else
-      sub[0]=0;
+      sub[0]='\0';
 
     sprintf(ptr, " (SSL %x.%x.%x%s)",
             (SSLEAY_VERSION_NUMBER>>12)&0xff,
             (SSLEAY_VERSION_NUMBER>>8)&0xf,
             (SSLEAY_VERSION_NUMBER>>4)&0xf, sub);
   }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/README	2001-01-03 17:26:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/README	2001-04-23 20:37:00.000000000 +0800
@@ -9,13 +9,13 @@
   Curl is a command line tool for transfering data specified with URL
   syntax. Find out how to use Curl by reading the curl.1 man page or the
   MANUAL document. Find out how to install Curl by reading the INSTALL
   document.
 
   libcurl is a library that Curl is using to do its job. It is readily
-  available to be used by your software. Read the LIBCURL document to
+  available to be used by your software. Read the libcurl.5 man page to
   find out how!
 
   You find answers to the most frequent questions we get in the FAQ document.
 
   Study the LEGAL file for distribution terms and similar.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/src/hugehelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/src/hugehelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/src/hugehelp.c	2001-04-20 22:36:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/src/hugehelp.c	2001-05-07 18:52:31.000000000 +0800
@@ -1164,12 +1164,14 @@
 "      - Jun-ichiro itojun Hagino <itojun@iijlab.net>\n"
 );
  puts(
 "      - Frederic Lepied <flepied@mandrakesoft.com>\n"
 "      - Georg Horn <horn@koblenz-net.de>\n"
 "      - Cris Bailiff <c.bailiff@awayweb.com>\n"
+"      - Sterling Hughes <sterling@designmultimedia.com>\n"
+"      - S. Moonesamy\n"
 "\n"
 "WWW\n"
 "     http://curl.haxx.se\n"
 "\n"
 "FTP\n"
 "     ftp://ftp.sunet.se/pub/www/utilities/curl/\n"
@@ -1181,18 +1183,18 @@
 "\n"
 "  You always find news about what's going on as well as the latest versions\n"
 "  from the curl web pages, located at:\n"
 "\n"
 "        http://curl.haxx.se\n"
 "\n"
+);
+ puts(
 "SIMPLE USAGE\n"
 "\n"
 "  Get the main page from netscape's web-server:\n"
 "\n"
-);
- puts(
 "        curl http://www.netscape.com/\n"
 "\n"
 "  Get the root README file from funet's ftp-server:\n"
 "\n"
 "        curl ftp://ftp.funet.fi/README\n"
 "\n"
@@ -1205,18 +1207,18 @@
 "        curl ftp://cool.haxx.se/\n"
 "\n"
 "  Get a gopher document from funet's gopher server:\n"
 "\n"
 "        curl gopher://gopher.funet.fi\n"
 "\n"
+);
+ puts(
 "  Get the definition of curl from a dictionary:\n"
 "\n"
 "        curl dict://dict.org/m:curl\n"
 "\n"
-);
- puts(
 "  Fetch two documents at once:\n"
 "\n"
 "        curl ftp://cool.haxx.se/ http://www.weirdserver.com:8000/\n"
 "\n"
 "DOWNLOAD TO A FILE\n"
 "\n"
@@ -1225,18 +1227,18 @@
 "        curl -o thatpage.html http://www.netscape.com/\n"
 "\n"
 "  Get a web page and store in a local file, make the local file get the name\n"
 "  of the remote document (if no file name part is specified in the URL, this\n"
 "  will fail):\n"
 "\n"
+);
+ puts(
 "        curl -O http://www.netscape.com/index.html\n"
 "\n"
 "  Fetch two files and store them with their remote names:\n"
 "\n"
-);
- puts(
 "        curl -O www.haxx.se/index.html -O curl.haxx.se/download.html\n"
 "\n"
 "USING PASSWORDS\n"
 "\n"
 " FTP\n"
 "\n"
@@ -1247,32 +1249,32 @@
 "   or specify them with the -u flag like\n"
 "\n"
 "        curl -u name:passwd ftp://machine.domain:port/full/path/to/file\n"
 "\n"
 " HTTP\n"
 "\n"
-"   The HTTP URL doesn't support user and password in the URL string. Curl\n"
 );
  puts(
+"   The HTTP URL doesn't support user and password in the URL string. Curl\n"
 "   does support that anyway to provide a ftp-style interface and thus you can\n"
 "   pick a file like:\n"
 "\n"
 "        curl http://name:passwd@machine.domain/full/path/to/file\n"
 "\n"
 "   or specify user and password separately like in\n"
 "\n"
 "        curl -u name:passwd http://machine.domain/full/path/to/file\n"
 "\n"
 "   NOTE! Since HTTP URLs don't support user and password, you can't use that\n"
+);
+ puts(
 "   style when using Curl via a proxy. You _must_ use the -u style fetch\n"
 "   during such circumstances.\n"
 "\n"
 " HTTPS\n"
 "\n"
-);
- puts(
 "   Probably most commonly used with private certificates, as explained below.\n"
 "\n"
 " GOPHER\n"
 "\n"
 "   Curl features no password support for gopher.\n"
 "\n"
@@ -1282,16 +1284,16 @@
 "\n"
 "        curl -x my-proxy:888 ftp://ftp.leachsite.com/README\n"
 "\n"
 " Get a file from a HTTP server that requires user and password, using the\n"
 " same proxy as above:\n"
 "\n"
-"        curl -u user:passwd -x my-proxy:888 http://www.get.this/\n"
-"\n"
 );
  puts(
+"        curl -u user:passwd -x my-proxy:888 http://www.get.this/\n"
+"\n"
 " Some proxies require special authentication. Specify by using -U as above:\n"
 "\n"
 "        curl -U user:passwd -x my-proxy:888 http://www.get.this/\n"
 "\n"
 " See also the environment variables Curl support that offer further proxy\n"
 " control.\n"
@@ -1299,18 +1301,18 @@
 "RANGES\n"
 "\n"
 "  With HTTP 1.1 byte-ranges were introduced. Using this, a client can request\n"
 "  to get only one or more subparts of a specified document. Curl supports\n"
 "  this with the -r flag.\n"
 "\n"
+);
+ puts(
 "  Get the first 100 bytes of a document:\n"
 "\n"
 "        curl -r 0-99 http://www.get.this/\n"
 "\n"
-);
- puts(
 "  Get the last 500 bytes of a document:\n"
 "\n"
 "        curl -r -500 http://www.get.this/\n"
 "\n"
 "  Curl also supports simple ranges for FTP files as well. Then you can only\n"
 "  specify start and stop position.\n"
@@ -1324,16 +1326,16 @@
 " FTP\n"
 "\n"
 "  Upload all data on stdin to a specified ftp site:\n"
 "\n"
 "        curl -t ftp://ftp.upload.com/myfile\n"
 "\n"
-"  Upload data from a specified file, login with user and password:\n"
-"\n"
 );
  puts(
+"  Upload data from a specified file, login with user and password:\n"
+"\n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/myfile\n"
 "\n"
 "  Upload a local file to the remote site, and use the local file name remote\n"
 "  too:\n"
 " \n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/\n"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/src/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/src/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/src/main.c	2001-04-18 22:06:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/src/main.c	2001-05-04 15:47:11.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: main.c,v 1.76 2001/04/18 14:06:47 bagder Exp $
+ * $Id: main.c,v 1.77 2001/05/04 07:47:11 bagder Exp $
  *****************************************************************************/
 
 /* This is now designed to have its own local setup.h */
 #include "setup.h"
 
 #include <stdio.h>
@@ -1265,13 +1265,13 @@
 struct OutStruct {
   char *filename;
   FILE *stream;
   struct Configurable *config;
 };
 
-int my_fwrite(void *buffer, size_t size, size_t nmemb, FILE *stream)
+int my_fwrite(void *buffer, size_t size, size_t nmemb, void *stream)
 {
   struct OutStruct *out=(struct OutStruct *)stream;
   if(out && !out->stream) {
     /* open file for writing */
     out->stream=fopen(out->filename, "wb");
     if(!out->stream)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/src/version.h	2001-04-23 15:28:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/src/version.h	2001-05-07 18:51:33.000000000 +0800
@@ -1,3 +1,3 @@
 #define CURL_NAME "curl"
-#define CURL_VERSION "7.7.2"
+#define CURL_VERSION "7.7.3"
 #define CURL_ID CURL_NAME " " CURL_VERSION " (" OS ") "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/data/stdout15.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/data/stdout15.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/data/stdout15.txt	2000-11-17 22:58:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/data/stdout15.txt	2001-04-25 05:10:28.000000000 +0800
@@ -1,7 +1,7 @@
 HTTP/1.4 200 OK
 Fake: yes
 Fake: yes
 Fake: yes
 
 Repeated nonsense-headers
-http://127.0.0.1:8999/want/15 200 26.000
+http://127.0.0.1:8999/want/15 200 26
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/ftpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/ftpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/ftpserver.pl	2001-03-05 22:03:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/ftpserver.pl	2001-04-25 05:10:26.000000000 +0800
@@ -1,9 +1,9 @@
 #!/usr/bin/perl
 #
-# $Id: ftpserver.pl,v 1.15 2001/03/05 14:03:20 bagder Exp $
+# $Id: ftpserver.pl,v 1.16 2001/04/24 21:09:53 bagder Exp $
 # This is the FTP server designed for the curl test suite.
 #
 # It is meant to excersive curl, it is not meant to become a fully working
 # or even very standard compliant server.
 #
 # You may optionally specify port on the command line, otherwise it'll
@@ -286,13 +286,21 @@
     if($arg !~ /(\d+),(\d+),(\d+),(\d+),(\d+),(\d+)/) {
         logmsg "bad PORT-line: $arg\n";
         print "500 silly you, go away\r\n";
         return 0;
     }
     my $iaddr = inet_aton("$1.$2.$3.$4");
-    my $paddr = sockaddr_in(($5<<8)+$6, $iaddr);
+
+    my $port = ($5<<8)+$6;
+
+    if(!$port || $port > 65535) {
+        print STDERR "very illegal PORT number: $port\n";
+        return 1;
+    }
+
+    my $paddr = sockaddr_in($port, $iaddr);
     my $proto   = getprotobyname('tcp') || 6;
 
     socket(SOCK, PF_INET, SOCK_STREAM, $proto) || die "major failure";
     connect(SOCK, $paddr)    || return 1;
 
     return \&SOCK;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/README	2001-03-13 20:35:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/README	2001-04-25 05:10:26.000000000 +0800
@@ -5,12 +5,14 @@
                              \___|\___/|_| \_\_____|
 
 The cURL Test Suite
 
 Requires:
   perl (and a unix-style shell)
+  diff (when a test fail, a diff is shown)
+  stunnel (for HTTPS and FTPS tests)
 
 Run:
   'make test'. This invokes the 'runtests.pl' perl script. Edit the top
   variables of that script in case you have some specific needs.
 
   The script breaks on the first test that doesn't do OK. Use -a to prevent
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/runtests.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/runtests.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.2/tests/runtests.pl	2001-03-14 06:14:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7.3/tests/runtests.pl	2001-05-04 15:47:11.000000000 +0800
@@ -1,25 +1,28 @@
 #!/usr/bin/perl
-# $Id: runtests.pl,v 1.25 2001/03/13 22:14:53 bagder Exp $
+# $Id: runtests.pl,v 1.29 2001/05/04 07:47:11 bagder Exp $
 #
 # Main curl test script, in perl to run on more platforms
 #
 #######################################################################
 # These should be the only variables that might be needed to get edited:
 
 use strict;
 
+use stunnel;
+
 my $srcdir = $ENV{'srcdir'} || '.';
 my $HOSTIP="127.0.0.1";
 my $HOSTPORT=8999; # bad name, but this is the HTTP server port
+my $HTTPSPORT=8433; # this is the HTTPS server port
 my $FTPPORT=8921;  # this is the FTP server port
+my $FTPSPORT=8821;  # this is the FTPS server port
 my $CURL="../src/curl"; # what curl executable to run on the tests
 my $LOGDIR="log";
 my $TESTDIR="data";
 my $SERVERIN="$LOGDIR/server.input"; # what curl sent the server
-my $CURLOUT="$LOGDIR/curl.out"; # curl output if not stdout
 my $CURLLOG="$LOGDIR/curl.log"; # all command lines run
 my $FTPDCMD="$LOGDIR/ftpserver.cmd"; # copy ftp server instructions here
 
 # Normally, all test cases should be run, but at times it is handy to
 # simply run a particular one:
 my $TESTCASES="all";
@@ -28,33 +31,38 @@
 # $TESTCASES="1 2 3 7 8";
 
 #######################################################################
 # No variables below this point should need to be modified
 #
 
-my $PIDFILE=".server.pid";
-my $FTPPIDFILE=".ftpserver.pid";
+my $HTTPPIDFILE=".server.pid";
+my $HTTPSPIDFILE=".https.pid";
+my $FTPPIDFILE=".ftps.pid";
+my $FTPSPIDFILE=".ftpsserver.pid";
 
 # this gets set if curl is compiled with memory debugging:
 my $memory_debug=0;
 
 # name of the file that the memory debugging creates:
 my $memdump="memdump";
 
 # the path to the script that analyzes the memory debug output file:
 my $memanalyze="../memanalyze.pl";
 
+my $checkstunnel = &checkstunnel;
+
 #######################################################################
 # variables the command line options may set
 #
 
 my $short;
 my $verbose;
 my $debugprotocol;
 my $anyway;
-my $gdbthis; # run test case with gdb debugger
+my $gdbthis;      # run test case with gdb debugger
+my $keepoutfiles; # keep stdout and stderr files after tests
 
 #######################################################################
 # Return the pid of the server as found in the given pid file
 #
 sub serverpid {
     my $PIDFILE = $_[0];
@@ -83,101 +91,162 @@
             print "Test server pid $PID didn't exist\n";
         }
     }
 }
 
 #######################################################################
-# start the http server, or if it already runs, verify that it is our
-# test server on the test-port!
+# check the given test server if it is still alive
 #
-sub runhttpserver {
-    my $verbose = $_[0];
-    my $STATUS;
-    my $RUNNING;
+sub checkserver {
+    my ($pidfile)=@_;
+    my $RUNNING=0;
+    my $PID=0;
+
     # check for pidfile
-    if ( -f $PIDFILE ) {
-        my $PID=serverpid($PIDFILE);
+    if ( -f $pidfile ) {
+        my $PID=serverpid($pidfile);
         if ($PID ne "" && kill(0, $PID)) {
-            $STATUS="httpd (pid $PID) running";
             $RUNNING=1;
         }
         else {
-            $STATUS="httpd (pid $PID?) not running";
             $RUNNING=0;
+            $PID = -$PID; # negative means dead process
         }
     }
     else {
-        $STATUS="httpd (no pid file) not running";
         $RUNNING=0;
     }
+    return $PID
+}
+
+#######################################################################
+# start the http server, or if it already runs, verify that it is our
+# test server on the test-port!
+#
+sub runhttpserver {
+    my $verbose = $_[0];
+    my $RUNNING;
+
+    my $pid = checkserver($HTTPPIDFILE );
 
-    if ($RUNNING != 1) {
+    if ($pid <= 0) {
         my $flag=$debugprotocol?"-v ":"";
         system("perl $srcdir/httpserver.pl $flag $HOSTPORT &");
-        sleep 1; # give it a little time to start
+        if($verbose) {
+            print "httpd started\n";
+        }
     }
     else {
-        print "$STATUS\n";
+        if($pid > 0) {
+            print "httpd ($pid) runs\n";
+        }
 
         # verify that our server is one one running on this port:
         my $data=`$CURL --silent -i $HOSTIP:$HOSTPORT/verifiedserver`;
 
         if ( $data !~ /WE ROOLZ/ ) {
             print "Another HTTP server is running on port $HOSTPORT\n",
             "Edit runtests.pl to use another port and rerun the test script\n";
             exit;
         }
 
-        print "The running HTTP server has been verified to be our server\n";
+        if($verbose) {
+            print "The running HTTP server has been verified to be our server\n";
+        }
     }
 }
 
-sub runftpserver {
+#######################################################################
+# start the https server (or rather, tunnel) if needed
+#
+sub runhttpsserver {
     my $verbose = $_[0];
     my $STATUS;
     my $RUNNING;
-    # check for pidfile
-    if ( -f $FTPPIDFILE ) {
-        my $PID=serverpid($FTPPIDFILE);
-        if ($PID ne "" && kill(0, $PID)) {
-            $STATUS="ftpd (pid $PID) running";
-            $RUNNING=1;
-        }
-        else {
-            $STATUS="ftpd (pid $PID?) not running";
-            $RUNNING=0;
+    my $PID=checkserver($HTTPSPIDFILE );
+
+    if($PID > 0) {
+        # kill previous stunnel!
+        if($verbose) {
+            print "kills off running stunnel at $PID\n";
         }
+        stopserver($HTTPSPIDFILE);
     }
-    else {
-        $STATUS="ftpd (no pid file) not running";
-        $RUNNING=0;
+
+    my $flag=$debugprotocol?"-v ":"";
+    system("perl $srcdir/httpsserver.pl $flag -r $HOSTPORT $HTTPSPORT &");
+    if($verbose) {
+        print "httpd stunnel started\n";
     }
+}
 
-    if ($RUNNING != 1) {
+#######################################################################
+# start the ftp server if needed
+#
+sub runftpserver {
+    my $verbose = $_[0];
+    my $STATUS;
+    my $RUNNING;
+    # check for pidfile
+    my $pid = checkserver ($FTPPIDFILE );
+
+    if ($pid <= 0) {
         my $flag=$debugprotocol?"-v ":"";
         if($debugprotocol) {
             print "* Starts ftp server verbose:\n";
             print "perl $srcdir/ftpserver.pl $flag $FTPPORT &\n";
         }
         system("perl $srcdir/ftpserver.pl $flag $FTPPORT &");
-        sleep 1; # give it a little time to start
+        if($verbose) {
+            print "ftpd started\n";
+        }
     }
     else {
-        print "$STATUS\n";
+        if($verbose) {
+            print "ftpd ($pid) is already running\n";
+        }
 
         # verify that our server is one one running on this port:
         my $data=`$CURL --silent -i ftp://$HOSTIP:$FTPPORT/verifiedserver`;
 
         if ( $data !~ /WE ROOLZ/ ) {
             print "Another FTP server is running on port $FTPPORT\n",
             "Edit runtests.pl to use another FTP port and rerun the ",
             "test script\n";
             exit;
         }
 
-        print "The running FTP server has been verified to be our server\n";
+        if($verbose) {
+            print "The running FTP server has been verified to be our server\n";
+        }
+    }
+}
+
+#######################################################################
+# start the ftps server (or rather, tunnel) if needed
+#
+sub runftpsserver {
+    my $verbose = $_[0];
+    my $STATUS;
+    my $RUNNING;
+    my $PID=checkserver($FTPSPIDFILE );
+
+    if($PID > 0) {
+        # kill previous stunnel!
+        if($verbose) {
+            print "kills off running stunnel at $PID\n";
+        }
+        stopserver($FTPSPIDFILE);
+    }
+
+    my $flag=$debugprotocol?"-v ":"";
+    my $cmd="perl $srcdir/ftpsserver.pl $flag -r $FTPPORT $FTPSPORT &";
+    print "CMD: $cmd\n";
+    system($cmd);
+    if($verbose) {
+        print "ftpd stunnel started\n";
     }
 }
 
 
 #######################################################################
 # This function compares two binary files and return non-zero if they
@@ -201,15 +270,13 @@
     my ($snum, $dnum, $s, $d);
     do {
         $snum = read(S, $s, $m);
         $dnum = read(D, $d, $m);
         if(($snum != $dnum) ||
            ($s ne $d)) {
-            print "$source and $dest differ\n";
-            $res=1;
-            $snum=0;
+            return 1;
         }
     } while($snum);
     close(S);
     close(D);
     return $res;
 }
@@ -282,13 +349,15 @@
         $first="$LOGDIR/generated.tmp";
         $sec="$LOGDIR/stored.tmp";
     }
 
     $res = comparefiles($first, $sec);
     if ($res != 0) {
-        print " $text FAILED";
+        print " $text FAILED\n";
+        print "=> diff $first $sec' looks like (\">\" added by runtime):\n";
+        print `diff $sec $first`;
         return 1;
     }
 
     if(!$short) {
         print " $text OK";
     }
@@ -300,28 +369,38 @@
 #
 sub displaydata {
 
     unlink($memdump); # remove this if there was one left
 
     my $version=`$CURL -V`;
+    chomp $version;
+
+    my $curl = $version;
+
+    $curl =~ s/^(.*)(libcurl.*)/$1/g;
+    my $libcurl = $2;
+
     my $hostname=`hostname`;
     my $hosttype=`uname -a`;
 
-    print "Running tests on:\n",
-    "* $version",
+    print "********* System characteristics ******** \n",
+    "* $curl\n",
+    "* $libcurl\n",
     "* Host: $hostname",
     "* System: $hosttype";
 
     if( -r $memdump) {
         # if this exists, curl was compiled with memory debugging
         # enabled and we shall verify that no memory leaks exist
         # after each and every test!
         $memory_debug=1;
     }
     printf("* Memory debugging: %s\n", $memory_debug?"ON":"OFF");
-
+    printf("* HTTPS server:     %s\n", $checkstunnel?"ON":"OFF");
+    printf("* FTPS server:      %s\n", $checkstunnel?"ON":"OFF");
+    print "***************************************** \n";
 }
 
 #######################################################################
 # Run a single specified test case
 #
 
@@ -350,29 +429,33 @@
     # if this file exists, we verify upload
     my $UPLOAD="$TESTDIR/upload$NUMBER.txt";
 
     # if this file exists, it is FTP server instructions:
     my $ftpservercmd="$TESTDIR/ftpd$NUMBER.txt";
 
+    my $CURLOUT="$LOGDIR/curl$NUMBER.out"; # curl output if not stdout
+
     if(! -r $CURLCMD) {
-        # this is not a test
-        print "$NUMBER doesn't look like a test case!\n";
-        return -1;
+        if($verbose) {
+            # this is not a test
+            print "$NUMBER doesn't look like a test case!\n";
+            return -1;
+        }
     }
 
     # remove previous server output logfile
     unlink($SERVERIN);
 
     if(-r $ftpservercmd) {
         # copy the instruction file
         system("cp $ftpservercmd $FTPDCMD");
     }
 
     # name of the test
     open(N, "<$TESTDIR/name$NUMBER.txt") ||
-        print "** Couldn't read name on test $NUMBER\n";
+        return -1; # not a test
     my $DESC=<N>;
     close(N);
     $DESC =~ s/[\r\n]//g;
 
     print "test $NUMBER...";
     if(!$short) {
@@ -386,13 +469,15 @@
     chomp $cmd;
     close(COMMAND);
 
     # make some nice replace operations
     $cmd =~ s/%HOSTIP/$HOSTIP/g;
     $cmd =~ s/%HOSTPORT/$HOSTPORT/g;
+    $cmd =~ s/%HTTPSPORT/$HTTPSPORT/g;
     $cmd =~ s/%FTPPORT/$FTPPORT/g;
+    $cmd =~ s/%FTPSPORT/$FTPSPORT/g;
     #$cmd =~ s/%HOSTNAME/$HOSTNAME/g;
 
     if($memory_debug) {
         unlink($memdump);
     }
 
@@ -517,18 +602,21 @@
                 return 1;
             }
         }
 
     }
 
-    # remove the stdout and stderr files
-    unlink($STDOUT);
-    unlink($STDERR);
+    if(!$keepoutfiles) {
+        # remove the stdout and stderr files
+        unlink($STDOUT);
+        unlink($STDERR);
+        unlink($CURLOUT); # remove the downloaded results
+
+        unlink("$LOGDIR/upload.$NUMBER");  # remove upload leftovers
+    }
 
-    unlink("$LOGDIR/upload.$NUMBER");  # remove upload leftovers
-    unlink($CURLOUT); # remove the downloaded results
     unlink($FTPDCMD); # remove the instructions for this test
 
     if($memory_debug) {
         if(! -f $memdump) {
             print "\n** ALERT! memory debuggin without any output file?\n";
         }
@@ -559,12 +647,75 @@
     }
     print "\n";
 
     return 0;
 }
 
+my %run;
+
+sub serverfortest {
+    my ($testnum)=@_;
+
+    if($testnum< 100) {
+        # 0 - 99 is for HTTP
+        if(!$run{'http'}) {
+            runhttpserver($verbose);
+            $run{'http'}=$HTTPPIDFILE;
+        }
+    }
+    elsif($testnum< 200) {
+        # 100 - 199 is for FTP
+        if(!$run{'ftp'}) {
+            runftpserver($verbose);
+            $run{'ftp'}=$FTPPIDFILE;
+        }
+    }
+    elsif($testnum< 300) {
+        # 200 - 299 is for FILE, no server!
+        $run{'file'}="moo";
+    }
+    elsif($testnum< 400) {
+        # 300 - 399 is for HTTPS, two servers!
+
+        if(!$checkstunnel) {
+            # we can't run https tests without stunnel
+            return 1;
+        }
+
+        if(!$run{'http'}) {
+            runhttpserver($verbose);
+            $run{'http'}=$HTTPPIDFILE;
+        }
+        if(!$run{'https'}) {
+            runhttpsserver($verbose);
+            $run{'https'}=$HTTPSPIDFILE;
+        }
+    }
+    elsif($testnum< 500) {
+        # 400 - 499 is for FTPS, also two servers
+
+        if(!$checkstunnel) {
+            # we can't run https tests without stunnel
+            return 1;
+        }
+        if(!$run{'ftp'}) {
+            runftpserver($verbose);
+            $run{'ftp'}=$FTPPIDFILE;
+        }
+        if(!$run{'ftps'}) {
+            runftpsserver($verbose);
+            $run{'ftps'}=$FTPSPIDFILE;
+        }
+    }
+    else {
+        print "Bad test number, no server available\n";
+        return 100;
+    }
+    sleep 1; # give a second for the server(s) to startup
+    return 0; # ok
+}
 
 #######################################################################
 # Check options to this test program
 #
 
 my $number=0;
@@ -588,23 +739,28 @@
         $short=1;
     }
     elsif($ARGV[0] eq "-a") {
         # continue anyway, even if a test fail
         $anyway=1;
     }
+    elsif($ARGV[0] eq "-k") {
+        # keep stdout and stderr files after tests
+        $keepoutfiles=1;
+    }
     elsif($ARGV[0] eq "-h") {
         # show help text
         print <<EOHELP
-Usage: runtests.pl [-h][-s][-v][numbers]
+Usage: runtests.pl [options]
   -a       continue even if a test fails
   -d       display server debug info
   -g       run the test case with gdb
   -h       this help text
+  -k       keep stdout and stderr files present after tests
   -s       short output
   -v       verbose output
-  [num]    as string like "5 6 9" to run those tests only
+  [num]    like "5 6 9" or " 5 to 22 " to run those tests only
 EOHELP
     ;
         exit;
     }
     elsif($ARGV[0] =~ /^(\d+)/) {
         $number = $1;
@@ -641,14 +797,17 @@
 mkdir($LOGDIR, 0777);
 
 #######################################################################
 # First, start our test servers
 #
 
-runhttpserver($verbose);
-runftpserver($verbose);
+#runhttpserver($verbose);
+#runftpserver($verbose);
+#runhttpsserver($verbose);
+
+#sleep 1; # start-up time
 
 #######################################################################
 # If 'all' tests are requested, find out all test numbers
 #
 
 if ( $TESTCASES eq "all") {
@@ -680,14 +839,25 @@
 #
 
 my $failed;
 my $testnum;
 my $ok=0;
 my $total=0;
+my $skipped=0;
+
 foreach $testnum (split(" ", $TESTCASES)) {
 
+    my $serverproblem = serverfortest($testnum);
+
+    if($serverproblem) {
+        # there's a problem with the server, don't run
+        # this particular server, but count it as "skipped"
+        $skipped++;
+        next;
+    }
+
     my $error = singletest($testnum);
     if(-1 != $error) {
         # valid test case number
         $total++;
     }
     if($error>0) {
@@ -711,19 +881,26 @@
 close(CMDLOG);
 
 #######################################################################
 # Tests done, stop the servers
 #
 
-stopserver($FTPPIDFILE);
-stopserver($PIDFILE);
+for(keys %run) {
+    stopserver($run{$_}); # the pid file is in the hash table
+}
+#stopserver($FTPPIDFILE);
+#stopserver($PIDFILE);
+#stopserver($HTTPSPIDFILE);
 
 if($total) {
     print "$ok tests out of $total reported OK\n";
 
     if($ok != $total) {
         print "These test cases failed: $failed\n";
     }
 }
 else {
     print "No tests were performed!\n";
 }
+if($skipped) {
+    print "$skipped tests were skipped due to server problems\n";
+}
