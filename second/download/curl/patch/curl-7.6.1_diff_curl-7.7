diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/acconfig.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/acconfig.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/acconfig.h	2001-02-07 17:21:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/acconfig.h	2001-03-10 00:50:35.000000000 +0800
@@ -40,6 +40,14 @@
 /* Define if you want to enable IPv6 support */
 #undef ENABLE_IPV6
 
 /* Define this to 'int' if ssize_t is not an available typedefed type */
 #undef ssize_t
 
+/* Define this to 'int' if socklen_t is not an available typedefed type */
+#undef socklen_t
+
+/* Define this as a suitable file to read random data from */
+#undef RANDOM_FILE
+
+/* Define this to your Entropy Gathering Daemon socket pathname */
+#undef EGD_SOCKET
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/CHANGES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/CHANGES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/CHANGES	2001-02-13 21:34:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/CHANGES	2001-03-22 20:46:49.000000000 +0800
@@ -3,12 +3,280 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
                                History of Changes
 
+Version 7.7
+
+Daniel (22 March 2001)
+- The configure script now fails with an error message if gethostbyname_r() is
+  detected but it couldn't figure out how to invoke it (what amount of
+  arguments it is supposed to get). Reports from Andrés García made me aware
+  of this need.
+
+- Talking with Jim Drash made me finally put the curl_escape and curl_unescape
+  functions in the curl.h include file and write man pages for them. The
+  escape function was modified to use the same interface as the unescape one
+  had.
+
+- No bug reports at all on the latest betas. Release time coming up.
+
+Version 7.7-beta5
+
+Daniel (19 March 2001)
+- Georg Ottinger reported problems with using -C together with -L in the sense
+  that the -C info got lost when it was redirected. I could not repeat this
+  problem on the 7.7 branch why I leave this for the moment. Test case 39 was
+  added to do exactly this, and it seems to do right.
+
+- Christian Robottom Reis reported how his 7.7 beta didn't successfully do
+  form posts as elegantly as 7.6.1 did. Indeed, this was a flaw in the header
+  engine, as HTTP 1.1 has introduced a new 100 "transient" return code for PUT
+  and POST operations that I need to add support for. Section 8.2.3 in RFC2616
+  has all the details. Seems to work now!
+
+Daniel (16 March 2001)
+- After having experienced another machine break-down, we're back.
+
+- Georg Horn's perl interface Curl::easy is now included in the curl release
+  archive. The perl/ directory is now present. Please help me with docs,
+  examples and updates you think fit.
+
+- Made a new php/ directory in the release archive and moved the PHP examples
+  into a subdirectory in there. Not much PHP info yet, but I plan to. Please
+  help me here as well!
+
+- Made libcurl return error if a transfer is aborted in the middle of a
+  "chunk". It actually enables libcurl to discover premature transfer aborts
+  even if the Content-Length: size is unknown.
+
+Daniel (15 March 2001)
+- Added --connect-timeout to curl, which sets the new CURLOPT_CONNECTTIMEOUT
+  option in libcurl. It limits the time curl is allowed to spend in the
+  connection phase. This differs from -m/--max-time that limits the entire
+  file transfer operation. Requested by Larry Fahnoe and others.
+
+  I also updated the curl.1 and curl_easy_setopt.3 man pages and removed the
+  item from the TODO.
+
+Version 7.7-beta4
+
+Daniel (14 March 2001)
+- Made curl grok IPv6 with HTTP proxies and got everything to compile nicely
+  again when ENABLE_IPV6 is set.
+
+  I need to remake things in the test suite. I can't test the FTP parts with
+  curl built for IPv6 as it uses a different set of FTP commands then!
+
+- I fell onto a bug report on php.net (posted by Lars Torben Wilson) that was
+  a report meant for our project. Anyway, it said the .netrc parsing didn't
+  work as supposed, and as I agreed with Lars, I made the netrc parser use
+  getpwuid() to figure out the home directory of the effective user and try
+  that netrc. It still uses the environment variable HOME for those that don't
+  have that function or if the user doesn't return valid pwd info.
+
+- Edin Kadribaic posted a bug report where he got a crash when a fetch with
+  user+password in the URL followed a Location: to a second URL (absolute,
+  without name+password). This bug has been around for a long while and
+  crashes due to a read at address zero. Fixed now. Wrote test case 38, that
+  tests this.
+
+- Modified the test suite's httpserver slightly to append all client request
+  data to its log file so that the test script now better can verify a range
+  of requests and not only the last one, as it did previously.
+
+- Updated the curl man page with --random-file and --egd-file details.
+
+Version 7.7-beta3
+
+Daniel (14 March 2001)
+- Björn Stenberg provided similar fixes as Jörn did and some additional patches
+  for non-SSL compiles.
+
+- I increased the interface number for libcurl as I've removed the low level
+  functions from the interface. I also took this opportunity to rename the
+  Curl_strequal function to curl_strequal and Curl_strnequal to
+  curl_strnequal, as they're public libcurl functions (even if they're still
+  undocumented).
+
+  This will make older programs not capable of using the new libcurl with
+  just a drop-in replacement.
+
+- Jörn Hartroth updated stuff for win32 compiles:
+  o config-win32.h was fixed for socklen_t
+  o lib/ssluse.c had a bad #endif placement
+  o lib/file.c was made to compile on win32 again
+  o lib/Makefile.m32 was updated with the new files
+  o lib/libcurl.def matches the current interface state
+
+Daniel (13 March 2001)
+- It only took an hour or so before Jörn Hartroth found a problem in the
+  chunked transfer-encoding. Given his fine example-site, I could easily spot
+  the problem and when I re-read the spec (the part I have pasted in the top
+  of the http_chunks.h file), I realized I had made my state-machine slightly
+  wrong and didn't expect/handle the trailing CRLF that comes after the data
+  in each chunk (and those extra two bytes sure feel wasted).
+
+  Had to modify test case 34 to match this as well.
+
+Version 7.7-beta2
+
+Daniel (13 March 2001)
+- Added the policy stuff to the curl_easy_setopt man page for the two supported
+  policies.
+
+- Implemented some support for the CURLOPT_CLOSEPOLICY option. The policies
+  CURLCLOSEPOLICY_LEAST_RECENTLY_USED and CURLCLOSEPOLICY_OLDEST are now
+  supported, and the "least recently used" is used as default if no policy
+  is chosen.
+
+Daniel (12 March 2001)
+- Added CURLOPT_RANDOM_FILE and CURLOPT_EGDSOCKET to libcurl for seeding the
+  SSL random engine. The random seeding support was also brought to the curl
+  client with the new options --random-file <file> and --egd-file <file>. I
+  need some people to really test this to know they work as supposed. Remember
+  that libcurl now informs (if verbose is on) if the random seed is considered
+  weak (HTTPS connections).
+
+- Made the chunked transfer-encoding engine detected bad formatted data length
+  and return error if so (we can't possibly extract sensible data if this is
+  the case). Added a test case that detects this. Number 36. Now there are 60
+  test cases.
+
+- Added 5 new libcurl options to curl/curl.h that can be used to control the
+  persistant connection support in libcurl. They're also documented (fairly
+  thoroughly) in the curl_easy_setopt.3 man page. Three of them are now
+  implemented, although not really tested at this point... Anyway, the new
+  implemented options are named CURLOPT_MAXCONNECTS, CURLOPT_FRESH_CONNECT,
+  CURLOPT_FORBID_REUSE. The ones still left to write code for are:
+  CURLOPT_CLOSEPOLICY and its related option CURLOPT_CLOSEFUNCTION.
+
+- Made curl (the actual command line tool) use the new libcurl 7.7 persistant
+  connection support by re-using the same curl handle for every specified file
+  transfer and after some more test case tweaking we have 100% test case OK.
+  I made some test cases return HTTP/1.0 now to make sure that works as well.
+
+- Had to add 'Connection: close' to the headers of a bunch of test cases so
+  that curl behaves "old-style" since the test http server doesn't do multiple
+  connections... Now I get 100% test case OK.
+
+- The curl.haxx.se site, the main curl mailing list and my personal email are
+  all dead today due to power blackout in the area where the main servers are
+  located. Horrible.
+
+- I've made persistance work over a squid HTTP proxy. I find it disturbing
+  that it uses headers that aren't present in any HTTP standard though
+  (Proxy-Connection:) and that makes me feel that I'm now on the edge of what
+  the standard actually defines. I need to get this code excercised on a lot
+  of different HTTP proxies before I feel safe.
+
+  Now I'm facing the problem with my test suite servers (both FTP and HTTP)
+  not supporting persistant connections and libcurl is doing them now. I have
+  to fix the test servers to get all the test cases do OK.
+
+Daniel (8 March 2001)
+- Guenole Bescon reported that libcurl did output errors to stderr even if
+  MUTE and NOPROGRESS was set. It turned out to be a bug and happens if
+  there's an error and no ERRORBUFFER is set. This is now corrected.
+
+Version 7.7-beta1
+
+Daniel (8 March 2001)
+- "Transfer-Encoding: chunked" is no longer any trouble for libcurl. I've
+  added two source files and I've run some test downloads that look fine.
+
+- HTTP HEAD works too, even on 1.1 servers.
+
+Daniel (5 March 2001)
+- The current 57 test cases now pass OK. It would suggest that libcurl works
+  using the old-style with one connection per handle. The test suite doesn't
+  handle multiple connections yet so there are no test cases for this.
+
+- I patched the telnet.c heavily to not use any global variables anymore. It
+  should make it a lot nicer library-wise.
+
+- The file:// support was modified slightly to use the internal connect-first-
+  then-do approach.
+
+Daniel (4 March 2001)
+- More bugs erased.
+
+Version 7.7-alpha2
+
+Daniel (4 March 2001)
+- Now, there's even a basic check that a re-used connection is still alive
+  before it is assumed so. A few first tests have proven that libcurl will
+  then re-connect instead of re-use the dead connection!
+
+Daniel (2 March 2001)
+- Now they work intermixed as well. Major coolness!
+
+- More fiddling around, my 'tiny' client I have for testing purposes now has
+  proved to download both FTP and HTTP with persistant connections. They do
+  not work intermixed yet though.
+
+Daniel (1 March 2001)
+- Wilfredo Sanchez pointed out a minor spelling mistake in a man page and that
+  curl_slist_append() should take a const char * as second argument. It does
+  now.
+
+Daniel (22 February 2001)
+- The persistant connections start to look good for HTTP. On a subsequent
+  request, it seems that libcurl now can pick an already existing connection
+  if a suitable one exists, or it opens a new one.
+
+- Douglas R. Horner mailed me corrections to the curl_formparse() man page
+  that I applied.
+
+Daniel (20 February 2001)
+- Added the docs/examples/win32sockets.c file for our windows friends.
+
+- Linus Nielsen Feltzing provided brand new TELNET functionality and
+  improvements:
+
+  * Negotiation is now passive. Curl does not negotiate until the peer does.
+  * Possibility to set negotiation options on the command line, currently only
+    XDISPLOC, TTYPE and NEW_ENVIRON (called NEW_ENV).
+  * Now sends the USER environment variable if the -u switch is used.
+  * Use -t to set telnet options (Linus even updated the man page, awesome!)
+
+- Haven't done this big changes to curl for a while. Moved around a lot of
+  struct fields and stuff to make multiple connections get connection specific
+  data in separate structs so that they can co-exist in a nice way. See the
+  mailing lists for discussions around how this is gonna be implemented. Docs
+  and more will follow.
+
+  Studied the HTTP RFC to find out better how persistant connections should
+  work. Seems cool enough.
+
+Daniel (19 February 2001)
+- Bob Schader brought me two files that help set up a MS VC++ libcurl project
+  easier. He also provided me with an up-to-date libcurl.def file.
+
+- I moved a bunch of prototypes from the public <curl/curl.h> file to the
+  library private urldata.h. This is because of the upcoming changes. The
+  low level interface is no longer being planned to become reality.
+
+Daniel (15 February 2001)
+- CURLOPT_POST is not required anymore. Just setting the POST string with
+  CURLOPT_POSTFIELDS will switch on the HTTP POST. Most other things in
+  libcurl already works this way, i.e they require only the parameter to
+  switch on a feature so I think this works well with the rest. Setting a NULL
+  string switches off the POST again.
+
+- Excellent suggestions from Rich Gray, Rick Jones, Johan Nilsson and Bjorn
+  Reese helped me define a way how to incorporate persistant connections into
+  libcurl in a very smooth way. If done right, no change may have to be made
+  to older programs and they will just start using persistant connections when
+  applicable!
+
+Daniel (13 February 2001)
+- Changed the word 'timeouted' to 'timed out' in two different error messages.
+  Suggested by Larry Fahnoe.
+
 Version 7.6.1
 
 Daniel (9 February 2001)
 - Frank Reid and Cain Hopwood provided information and research around a HTTPS
   PUT/upload problem we seem to have. No solution found yet.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/config.h.in	2001-02-07 17:22:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/config.h.in	2001-03-15 00:01:53.000000000 +0800
@@ -52,27 +52,42 @@
 /* Define if you have the Kerberos4 libraries (including -ldes) */
 #undef KRB4
 
 /* Define this to 'int' if ssize_t is not an available typedefed type */
 #undef ssize_t
 
+/* Define this to 'int' if socklen_t is not an available typedefed type */
+#undef socklen_t
+
+/* Define this as a suitable file to read random data from */
+#undef RANDOM_FILE
+
+/* Define this to your Entropy Gathering Daemon socket pathname */
+#undef EGD_SOCKET
+
 /* The number of bytes in a long double.  */
 #undef SIZEOF_LONG_DOUBLE
 
 /* The number of bytes in a long long.  */
 #undef SIZEOF_LONG_LONG
 
+/* Define if you have the RAND_egd function.  */
+#undef HAVE_RAND_EGD
+
 /* Define if you have the RAND_screen function.  */
 #undef HAVE_RAND_SCREEN
 
 /* Define if you have the RAND_status function.  */
 #undef HAVE_RAND_STATUS
 
 /* Define if you have the closesocket function.  */
 #undef HAVE_CLOSESOCKET
 
+/* Define if you have the geteuid function.  */
+#undef HAVE_GETEUID
+
 /* Define if you have the gethostbyaddr function.  */
 #undef HAVE_GETHOSTBYADDR
 
 /* Define if you have the gethostbyaddr_r function.  */
 #undef HAVE_GETHOSTBYADDR_R
 
@@ -82,12 +97,15 @@
 /* Define if you have the gethostname function.  */
 #undef HAVE_GETHOSTNAME
 
 /* Define if you have the getpass_r function.  */
 #undef HAVE_GETPASS_R
 
+/* Define if you have the getpwuid function.  */
+#undef HAVE_GETPWUID
+
 /* Define if you have the getservbyname function.  */
 #undef HAVE_GETSERVBYNAME
 
 /* Define if you have the gettimeofday function.  */
 #undef HAVE_GETTIMEOFDAY
 
@@ -220,12 +238,15 @@
 /* Define if you have the <openssl/x509.h> header file.  */
 #undef HAVE_OPENSSL_X509_H
 
 /* Define if you have the <pem.h> header file.  */
 #undef HAVE_PEM_H
 
+/* Define if you have the <pwd.h> header file.  */
+#undef HAVE_PWD_H
+
 /* Define if you have the <rsa.h> header file.  */
 #undef HAVE_RSA_H
 
 /* Define if you have the <sgtty.h> header file.  */
 #undef HAVE_SGTTY_H
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/configure	2001-02-07 17:49:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/configure	2001-03-22 18:20:07.000000000 +0800
@@ -27,12 +27,16 @@
   --enable-debug		Enable pedantic debug options
   --disable-debug		Disable debug options"
 ac_help="$ac_help
   --enable-ipv6		Enable ipv6 (with ipv4) support
   --disable-ipv6		Disable ipv6 support"
 ac_help="$ac_help
+  --with-egd-socket=FILE  Entropy Gathering Daemon socket pathname"
+ac_help="$ac_help
+  --with-random=FILE      read randomness from FILE (default=/dev/urandom)"
+ac_help="$ac_help
   --with-krb4-includes[=DIR]   Specify location of kerberos4 headers"
 ac_help="$ac_help
   --with-krb4-libs[=DIR]   Specify location of kerberos4 libs"
 ac_help="$ac_help
   --with-krb4[=DIR]       where to look for Kerberos4"
 ac_help="$ac_help
@@ -583,13 +587,13 @@
 # AIX /bin/install
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:590: checking for a BSD compatible install" >&5
+echo "configure:594: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     IFS="${IFS= 	}"; ac_save_IFS="$IFS"; IFS=":"
   for ac_dir in $PATH; do
@@ -636,13 +640,13 @@
 
 test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'
 
 test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
 
 echo $ac_n "checking whether build environment is sane""... $ac_c" 1>&6
-echo "configure:643: checking whether build environment is sane" >&5
+echo "configure:647: checking whether build environment is sane" >&5
 # Just in case
 sleep 1
 echo timestamp > conftestfile
 # Do `set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
@@ -693,13 +697,13 @@
   program_transform_name="s,\$\$,${program_suffix},; $program_transform_name"
 
 # sed with no file args requires a program.
 test "$program_transform_name" = "" && program_transform_name="s,x,x,"
 
 echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
-echo "configure:700: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "configure:704: checking whether ${MAKE-make} sets \${MAKE}" >&5
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftestmake <<\EOF
 all:
@@ -739,65 +743,65 @@
 EOF
 
 
 
 missing_dir=`cd $ac_aux_dir && pwd`
 echo $ac_n "checking for working aclocal""... $ac_c" 1>&6
-echo "configure:746: checking for working aclocal" >&5
+echo "configure:750: checking for working aclocal" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (aclocal --version) < /dev/null > /dev/null 2>&1; then
    ACLOCAL=aclocal
    echo "$ac_t""found" 1>&6
 else
    ACLOCAL="$missing_dir/missing aclocal"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working autoconf""... $ac_c" 1>&6
-echo "configure:759: checking for working autoconf" >&5
+echo "configure:763: checking for working autoconf" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (autoconf --version) < /dev/null > /dev/null 2>&1; then
    AUTOCONF=autoconf
    echo "$ac_t""found" 1>&6
 else
    AUTOCONF="$missing_dir/missing autoconf"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working automake""... $ac_c" 1>&6
-echo "configure:772: checking for working automake" >&5
+echo "configure:776: checking for working automake" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (automake --version) < /dev/null > /dev/null 2>&1; then
    AUTOMAKE=automake
    echo "$ac_t""found" 1>&6
 else
    AUTOMAKE="$missing_dir/missing automake"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working autoheader""... $ac_c" 1>&6
-echo "configure:785: checking for working autoheader" >&5
+echo "configure:789: checking for working autoheader" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (autoheader --version) < /dev/null > /dev/null 2>&1; then
    AUTOHEADER=autoheader
    echo "$ac_t""found" 1>&6
 else
    AUTOHEADER="$missing_dir/missing autoheader"
    echo "$ac_t""missing" 1>&6
 fi
 
 echo $ac_n "checking for working makeinfo""... $ac_c" 1>&6
-echo "configure:798: checking for working makeinfo" >&5
+echo "configure:802: checking for working makeinfo" >&5
 # Run test in a subshell; some versions of sh will print an error if
 # an executable is not found, even if stderr is redirected.
 # Redirect stdin to placate older versions of autoconf.  Sigh.
 if (makeinfo --version) < /dev/null > /dev/null 2>&1; then
    MAKEINFO=makeinfo
    echo "$ac_t""found" 1>&6
@@ -880,13 +884,13 @@
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:887: checking host system type" >&5
+echo "configure:891: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -901,13 +905,13 @@
 host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking build system type""... $ac_c" 1>&6
-echo "configure:908: checking build system type" >&5
+echo "configure:912: checking build system type" >&5
 
 build_alias=$build
 case "$build_alias" in
 NONE)
   case $nonopt in
   NONE) build_alias=$host_alias ;;
@@ -921,13 +925,13 @@
 build_os=`echo $build | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$build" 1>&6
 
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:928: checking for $ac_word" >&5
+echo "configure:932: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$RANLIB"; then
   ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
 else
@@ -951,13 +955,13 @@
   echo "$ac_t""no" 1>&6
 fi
 
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:958: checking for $ac_word" >&5
+echo "configure:962: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -981,13 +985,13 @@
 fi
 
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:988: checking for $ac_word" >&5
+echo "configure:992: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1032,13 +1036,13 @@
   if test -z "$CC"; then
     case "`uname -s`" in
     *win32* | *WIN32*)
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1039: checking for $ac_word" >&5
+echo "configure:1043: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1064,29 +1068,29 @@
     esac
   fi
   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1071: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1075: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1082 "configure"
+#line 1086 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1087: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1091: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
     ac_cv_prog_cc_cross=no
   else
     ac_cv_prog_cc_cross=yes
@@ -1106,27 +1110,27 @@
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
 if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1113: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1117: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1118: checking whether we are using GNU C" >&5
+echo "configure:1122: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.c <<EOF
 #ifdef __GNUC__
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1127: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1131: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
 fi
 fi
 
@@ -1139,13 +1143,13 @@
 fi
 
 ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1146: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1150: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo 'void f(){}' > conftest.c
 if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
   ac_cv_prog_cc_g=yes
@@ -1182,13 +1186,13 @@
 fi
 
 ac_prog=ld
 if test "$ac_cv_prog_gcc" = yes; then
   # Check if gcc -print-prog-name=ld gives a path.
   echo $ac_n "checking for ld used by GCC""... $ac_c" 1>&6
-echo "configure:1189: checking for ld used by GCC" >&5
+echo "configure:1193: checking for ld used by GCC" >&5
   ac_prog=`($CC -print-prog-name=ld) 2>&5`
   case "$ac_prog" in
     # Accept absolute paths.
     [\\/]* | [A-Za-z]:[\\/]*)
       re_direlt='/[^/][^/]*/\.\./'
       # Canonicalize the path of ld
@@ -1206,16 +1210,16 @@
     # If it is relative, then search for the first ld in PATH.
     with_gnu_ld=unknown
     ;;
   esac
 elif test "$with_gnu_ld" = yes; then
   echo $ac_n "checking for GNU ld""... $ac_c" 1>&6
-echo "configure:1213: checking for GNU ld" >&5
+echo "configure:1217: checking for GNU ld" >&5
 else
   echo $ac_n "checking for non-GNU ld""... $ac_c" 1>&6
-echo "configure:1216: checking for non-GNU ld" >&5
+echo "configure:1220: checking for non-GNU ld" >&5
 fi
 if eval "test \"`echo '$''{'ac_cv_path_LD'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -z "$LD"; then
   IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
@@ -1244,13 +1248,13 @@
   echo "$ac_t""$LD" 1>&6
 else
   echo "$ac_t""no" 1>&6
 fi
 test -z "$LD" && { echo "configure: error: no acceptable ld found in \$PATH" 1>&2; exit 1; }
 echo $ac_n "checking if the linker ($LD) is GNU ld""... $ac_c" 1>&6
-echo "configure:1251: checking if the linker ($LD) is GNU ld" >&5
+echo "configure:1255: checking if the linker ($LD) is GNU ld" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gnu_ld'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   # I'd rather use --version here, but apparently some GNU ld's only accept -v.
 if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
   ac_cv_prog_gnu_ld=yes
@@ -1260,13 +1264,13 @@
 fi
 
 echo "$ac_t""$ac_cv_prog_gnu_ld" 1>&6
 
 
 echo $ac_n "checking for BSD-compatible nm""... $ac_c" 1>&6
-echo "configure:1267: checking for BSD-compatible nm" >&5
+echo "configure:1271: checking for BSD-compatible nm" >&5
 if eval "test \"`echo '$''{'ac_cv_path_NM'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$NM"; then
   # Let the user override the test.
   ac_cv_path_NM="$NM"
@@ -1296,13 +1300,13 @@
 fi
 
 NM="$ac_cv_path_NM"
 echo "$ac_t""$NM" 1>&6
 
 echo $ac_n "checking whether ln -s works""... $ac_c" 1>&6
-echo "configure:1303: checking whether ln -s works" >&5
+echo "configure:1307: checking whether ln -s works" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_LN_S'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   rm -f conftestdata
 if ln -s X conftestdata 2>/dev/null
 then
@@ -1345,14 +1349,14 @@
 
 # Some flags need to be propagated to the compiler or linker for good
 # libtool support.
 case "$lt_target" in
 *-*-irix6*)
   # Find out which ABI we are using.
-  echo '#line 1352 "configure"' > conftest.$ac_ext
-  if { (eval echo configure:1353: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+  echo '#line 1356 "configure"' > conftest.$ac_ext
+  if { (eval echo configure:1357: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
     case "`/usr/bin/file conftest.o`" in
     *32-bit*)
       LD="${LD-ld} -32"
       ;;
     *N32*)
       LD="${LD-ld} -n32"
@@ -1367,25 +1371,25 @@
 
 *-*-sco3.2v5*)
   # On SCO OpenServer 5, we need -belf to get full-featured binaries.
   SAVE_CFLAGS="$CFLAGS"
   CFLAGS="$CFLAGS -belf"
   echo $ac_n "checking whether the C compiler needs -belf""... $ac_c" 1>&6
-echo "configure:1374: checking whether the C compiler needs -belf" >&5
+echo "configure:1378: checking whether the C compiler needs -belf" >&5
 if eval "test \"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1379 "configure"
+#line 1383 "configure"
 #include "confdefs.h"
 
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1386: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1390: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   lt_cv_cc_needs_belf=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -1488,13 +1492,13 @@
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:1495: checking host system type" >&5
+echo "configure:1499: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -1509,13 +1513,13 @@
 host_cpu=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
 host_vendor=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
 host_os=`echo $host | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
 echo "$ac_t""$host" 1>&6
 
 echo $ac_n "checking target system type""... $ac_c" 1>&6
-echo "configure:1516: checking target system type" >&5
+echo "configure:1520: checking target system type" >&5
 
 target_alias=$target
 case "$target_alias" in
 NONE)
   case $nonopt in
   NONE) target_alias=$host_alias ;;
@@ -1530,13 +1534,13 @@
 echo "$ac_t""$target" 1>&6
 
 
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1537: checking for $ac_word" >&5
+echo "configure:1541: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1560,13 +1564,13 @@
 fi
 
 if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1567: checking for $ac_word" >&5
+echo "configure:1571: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1611,13 +1615,13 @@
   if test -z "$CC"; then
     case "`uname -s`" in
     *win32* | *WIN32*)
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1618: checking for $ac_word" >&5
+echo "configure:1622: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$CC"; then
   ac_cv_prog_CC="$CC" # Let the user override the test.
 else
@@ -1643,29 +1647,29 @@
     esac
   fi
   test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:1650: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:1654: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
 ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
 cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 1661 "configure"
+#line 1665 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:1666: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1670: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
     ac_cv_prog_cc_cross=no
   else
     ac_cv_prog_cc_cross=yes
@@ -1685,27 +1689,27 @@
 
 echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
 if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:1692: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:1696: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:1697: checking whether we are using GNU C" >&5
+echo "configure:1701: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.c <<EOF
 #ifdef __GNUC__
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1706: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1710: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
 fi
 fi
 
@@ -1718,13 +1722,13 @@
 fi
 
 ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:1725: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:1729: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo 'void f(){}' > conftest.c
 if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
   ac_cv_prog_cc_g=yes
@@ -1751,13 +1755,13 @@
     CFLAGS=
   fi
 fi
 
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:1758: checking how to run the C preprocessor" >&5
+echo "configure:1762: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
 fi
 if test -z "$CPP"; then
 if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
@@ -1766,53 +1770,53 @@
     # This must be in double quotes, not single quotes, because CPP may get
   # substituted into the Makefile and "${CC-cc}" will confuse make.
   CPP="${CC-cc} -E"
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 1773 "configure"
+#line 1777 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1779: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1783: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 1790 "configure"
+#line 1794 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1796: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1800: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 1807 "configure"
+#line 1811 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1813: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1817: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
 else
   echo "$ac_err" >&5
   echo "configure: failed program was:" >&5
@@ -1831,15 +1835,15 @@
 else
   ac_cv_prog_CPP="$CPP"
 fi
 echo "$ac_t""$CPP" 1>&6
 
 echo $ac_n "checking for AIX""... $ac_c" 1>&6
-echo "configure:1838: checking for AIX" >&5
+echo "configure:1842: checking for AIX" >&5
 cat > conftest.$ac_ext <<EOF
-#line 1840 "configure"
+#line 1844 "configure"
 #include "confdefs.h"
 #ifdef _AIX
   yes
 #endif
 
 EOF
@@ -1864,49 +1868,49 @@
   :
 fi
 
    if test "$enable_largefile" != no; then
 
      echo $ac_n "checking for special C compiler options needed for large files""... $ac_c" 1>&6
-echo "configure:1871: checking for special C compiler options needed for large files" >&5
+echo "configure:1875: checking for special C compiler options needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_largefile_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_largefile_CC=no
         if test "$GCC" != yes; then
 	  # IRIX 6.2 and later do not support large files by default,
 	  # so use the C compiler's -n32 option if that helps.
 	  cat > conftest.$ac_ext <<EOF
-#line 1880 "configure"
+#line 1884 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1889: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1893: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   ac_save_CC="$CC"
 	     CC="$CC -n32"
 	     cat > conftest.$ac_ext <<EOF
-#line 1898 "configure"
+#line 1902 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1907: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1911: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_largefile_CC=' -n32'
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -1920,49 +1924,49 @@
 echo "$ac_t""$ac_cv_sys_largefile_CC" 1>&6
      if test "$ac_cv_sys_largefile_CC" != no; then
        CC="$CC$ac_cv_sys_largefile_CC"
      fi
 
      echo $ac_n "checking for _FILE_OFFSET_BITS value needed for large files""... $ac_c" 1>&6
-echo "configure:1927: checking for _FILE_OFFSET_BITS value needed for large files" >&5
+echo "configure:1931: checking for _FILE_OFFSET_BITS value needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_file_offset_bits'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_file_offset_bits=no
       cat > conftest.$ac_ext <<EOF
-#line 1933 "configure"
+#line 1937 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
         
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1944: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1948: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 1951 "configure"
+#line 1955 "configure"
 #include "confdefs.h"
 #define _FILE_OFFSET_BITS 64
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
 	   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:1963: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1967: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_file_offset_bits=64
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -1976,49 +1980,49 @@
      cat >> confdefs.h <<EOF
 #define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
 EOF
 
    fi
      echo $ac_n "checking for _LARGEFILE_SOURCE value needed for large files""... $ac_c" 1>&6
-echo "configure:1983: checking for _LARGEFILE_SOURCE value needed for large files" >&5
+echo "configure:1987: checking for _LARGEFILE_SOURCE value needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_largefile_source'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_largefile_source=no
       cat > conftest.$ac_ext <<EOF
-#line 1989 "configure"
+#line 1993 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 #include <stdio.h>
         
 int main() {
 return !ftello;
 ; return 0; }
 EOF
-if { (eval echo configure:2000: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2004: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 2007 "configure"
+#line 2011 "configure"
 #include "confdefs.h"
 #define _LARGEFILE_SOURCE 1
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 #include <stdio.h>
 	   
 int main() {
 return !ftello;
 ; return 0; }
 EOF
-if { (eval echo configure:2019: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2023: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_largefile_source=1
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -2032,49 +2036,49 @@
      cat >> confdefs.h <<EOF
 #define _LARGEFILE_SOURCE $ac_cv_sys_largefile_source
 EOF
 
    fi
      echo $ac_n "checking for _LARGE_FILES value needed for large files""... $ac_c" 1>&6
-echo "configure:2039: checking for _LARGE_FILES value needed for large files" >&5
+echo "configure:2043: checking for _LARGE_FILES value needed for large files" >&5
 if eval "test \"`echo '$''{'ac_cv_sys_large_files'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_cv_sys_large_files=no
       cat > conftest.$ac_ext <<EOF
-#line 2045 "configure"
+#line 2049 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
         
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:2056: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2060: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 2063 "configure"
+#line 2067 "configure"
 #include "confdefs.h"
 #define _LARGE_FILES 1
 #include <sys/types.h>
     int a[(off_t) 9223372036854775807 == 9223372036854775807 ? 1 : -1];
   
 
 	   
 int main() {
 
 ; return 0; }
 EOF
-if { (eval echo configure:2075: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2079: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_sys_large_files=1
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
 fi
@@ -2091,13 +2095,13 @@
 
    fi
    fi
   
 
 echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
-echo "configure:2098: checking whether ${MAKE-make} sets \${MAKE}" >&5
+echo "configure:2102: checking whether ${MAKE-make} sets \${MAKE}" >&5
 set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftestmake <<\EOF
 all:
@@ -2119,13 +2123,13 @@
   echo "$ac_t""no" 1>&6
   SET_MAKE="MAKE=${MAKE-make}"
 fi
 
 
 echo $ac_n "checking whether to enable debug options""... $ac_c" 1>&6
-echo "configure:2126: checking whether to enable debug options" >&5
+echo "configure:2130: checking whether to enable debug options" >&5
 # Check whether --enable-debug or --disable-debug was given.
 if test "${enable_debug+set}" = set; then
   enableval="$enable_debug"
    case "$enableval" in
   no)
        echo "$ac_t""no" 1>&6
@@ -2153,13 +2157,13 @@
 
 
 
 
 
 echo $ac_n "checking whether to enable ipv6""... $ac_c" 1>&6
-echo "configure:2160: checking whether to enable ipv6" >&5
+echo "configure:2164: checking whether to enable ipv6" >&5
 # Check whether --enable-ipv6 or --disable-ipv6 was given.
 if test "${enable_ipv6+set}" = set; then
   enableval="$enable_ipv6"
    case "$enableval" in
   no)
        echo "$ac_t""no" 1>&6
@@ -2173,13 +2177,13 @@
   if test "$cross_compiling" = yes; then
   echo "$ac_t""no" 1>&6
   ipv6=no
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 2180 "configure"
+#line 2184 "configure"
 #include "confdefs.h"
  /* is AF_INET6 available? */
 #include <sys/types.h>
 #include <sys/socket.h>
 main()
 {
@@ -2187,13 +2191,13 @@
    exit(1);
  else
    exit(0);
 }
 
 EOF
-if { (eval echo configure:2194: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2198: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   echo "$ac_t""yes" 1>&6
   ipv6=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
@@ -2207,24 +2211,24 @@
 fi
 
 
 if test "$ipv6" = "yes"; then
   
   echo $ac_n "checking for working getaddrinfo""... $ac_c" 1>&6
-echo "configure:2214: checking for working getaddrinfo" >&5
+echo "configure:2218: checking for working getaddrinfo" >&5
 if eval "test \"`echo '$''{'ac_cv_working_getaddrinfo'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   if test "$cross_compiling" = yes; then
   
   ac_cv_working_getaddrinfo="yes"
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 2225 "configure"
+#line 2229 "configure"
 #include "confdefs.h"
 
 #include <netdb.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 
@@ -2242,13 +2246,13 @@
     else {
         exit(0);
     }
 }
 
 EOF
-if { (eval echo configure:2249: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2253: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
   ac_cv_working_getaddrinfo="yes"
 
 else
   echo "configure: failed program was:" >&5
@@ -2277,18 +2281,18 @@
 
 fi
 
 
 
 echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
-echo "configure:2284: checking for gethostbyname" >&5
+echo "configure:2288: checking for gethostbyname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2289 "configure"
+#line 2293 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2305,13 +2309,13 @@
 #else
 gethostbyname();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2312: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2316: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostbyname=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2323,32 +2327,32 @@
 if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
-echo "configure:2330: checking for gethostbyname in -lnsl" >&5
+echo "configure:2334: checking for gethostbyname in -lnsl" >&5
 ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lnsl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2338 "configure"
+#line 2342 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char gethostbyname();
 
 int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:2349: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2353: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2374,18 +2378,18 @@
 
 fi
 
 
 if test "$ac_cv_lib_nsl_gethostbyname" != "yes" -a "$ac_cv_func_gethostbyname" != "yes"; then
     echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
-echo "configure:2381: checking for gethostbyname" >&5
+echo "configure:2385: checking for gethostbyname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2386 "configure"
+#line 2390 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostbyname(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2402,13 +2406,13 @@
 #else
 gethostbyname();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2409: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2413: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostbyname=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2420,32 +2424,32 @@
 if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for gethostbyname in -lsocket""... $ac_c" 1>&6
-echo "configure:2427: checking for gethostbyname in -lsocket" >&5
+echo "configure:2431: checking for gethostbyname in -lsocket" >&5
 ac_lib_var=`echo socket'_'gethostbyname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2435 "configure"
+#line 2439 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char gethostbyname();
 
 int main() {
 gethostbyname()
 ; return 0; }
 EOF
-if { (eval echo configure:2446: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2450: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2472,24 +2476,24 @@
 fi
 
 fi
 
 if test "$ac_cv_lib_nsl_gethostbyname" = "$ac_cv_func_gethostbyname"; then
   echo $ac_n "checking trying both nsl and socket libs""... $ac_c" 1>&6
-echo "configure:2479: checking trying both nsl and socket libs" >&5
+echo "configure:2483: checking trying both nsl and socket libs" >&5
   my_ac_save_LIBS=$LIBS
   LIBS="-lnsl -lsocket $LIBS"
   cat > conftest.$ac_ext <<EOF
-#line 2483 "configure"
+#line 2487 "configure"
 #include "confdefs.h"
 
 int main() {
 gethostbyname();
 ; return 0; }
 EOF
-if { (eval echo configure:2490: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2494: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   my_ac_link_result=success
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2504,18 +2508,18 @@
   else
     echo "$ac_t""yes" 1>&6
   fi
 fi
 
 echo $ac_n "checking for strcasecmp""... $ac_c" 1>&6
-echo "configure:2511: checking for strcasecmp" >&5
+echo "configure:2515: checking for strcasecmp" >&5
 if eval "test \"`echo '$''{'ac_cv_func_strcasecmp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2516 "configure"
+#line 2520 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char strcasecmp(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2532,13 +2536,13 @@
 #else
 strcasecmp();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2539: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2543: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_strcasecmp=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2550,32 +2554,32 @@
 if eval "test \"`echo '$ac_cv_func_'strcasecmp`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for strcasecmp in -lresolve""... $ac_c" 1>&6
-echo "configure:2557: checking for strcasecmp in -lresolve" >&5
+echo "configure:2561: checking for strcasecmp in -lresolve" >&5
 ac_lib_var=`echo resolve'_'strcasecmp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolve  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2565 "configure"
+#line 2569 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char strcasecmp();
 
 int main() {
 strcasecmp()
 ; return 0; }
 EOF
-if { (eval echo configure:2576: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2580: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2601,32 +2605,32 @@
 
 fi
 
 
 if test "$ac_cv_lib_resolve_strcasecmp" = "$ac_cv_func_strcasecmp"; then
   echo $ac_n "checking for strcasecmp in -lresolve""... $ac_c" 1>&6
-echo "configure:2608: checking for strcasecmp in -lresolve" >&5
+echo "configure:2612: checking for strcasecmp in -lresolve" >&5
 ac_lib_var=`echo resolve'_'strcasecmp | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolve -lnsl $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2616 "configure"
+#line 2620 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char strcasecmp();
 
 int main() {
 strcasecmp()
 ; return 0; }
 EOF
-if { (eval echo configure:2627: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2631: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2643,18 +2647,18 @@
   echo "$ac_t""no" 1>&6
 fi
 
 fi
 
 echo $ac_n "checking for connect""... $ac_c" 1>&6
-echo "configure:2650: checking for connect" >&5
+echo "configure:2654: checking for connect" >&5
 if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2655 "configure"
+#line 2659 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char connect(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2671,13 +2675,13 @@
 #else
 connect();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2678: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2682: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_connect=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2689,32 +2693,32 @@
 if eval "test \"`echo '$ac_cv_func_'connect`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:2696: checking for connect in -lsocket" >&5
+echo "configure:2700: checking for connect in -lsocket" >&5
 ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lsocket  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2704 "configure"
+#line 2708 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char connect();
 
 int main() {
 connect()
 ; return 0; }
 EOF
-if { (eval echo configure:2715: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2719: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2739,18 +2743,18 @@
 fi
 
 fi
 
 
 echo $ac_n "checking for gethostname""... $ac_c" 1>&6
-echo "configure:2746: checking for gethostname" >&5
+echo "configure:2750: checking for gethostname" >&5
 if eval "test \"`echo '$''{'ac_cv_func_gethostname'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2751 "configure"
+#line 2755 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char gethostname(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2767,13 +2771,13 @@
 #else
 gethostname();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2774: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2778: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_gethostname=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2785,32 +2789,32 @@
 if eval "test \"`echo '$ac_cv_func_'gethostname`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for gethostname in -lucb""... $ac_c" 1>&6
-echo "configure:2792: checking for gethostname in -lucb" >&5
+echo "configure:2796: checking for gethostname in -lucb" >&5
 ac_lib_var=`echo ucb'_'gethostname | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lucb  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2800 "configure"
+#line 2804 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char gethostname();
 
 int main() {
 gethostname()
 ; return 0; }
 EOF
-if { (eval echo configure:2811: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2815: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2835,18 +2839,18 @@
 fi
 
 fi
 
 
 echo $ac_n "checking for dlopen""... $ac_c" 1>&6
-echo "configure:2842: checking for dlopen" >&5
+echo "configure:2846: checking for dlopen" >&5
 if eval "test \"`echo '$''{'ac_cv_func_dlopen'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2847 "configure"
+#line 2851 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char dlopen(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2863,13 +2867,13 @@
 #else
 dlopen();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:2870: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2874: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_dlopen=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2881,32 +2885,32 @@
 if eval "test \"`echo '$ac_cv_func_'dlopen`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for dlopen in -ldl""... $ac_c" 1>&6
-echo "configure:2888: checking for dlopen in -ldl" >&5
+echo "configure:2892: checking for dlopen in -ldl" >&5
 ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2896 "configure"
+#line 2900 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char dlopen();
 
 int main() {
 dlopen()
 ; return 0; }
 EOF
-if { (eval echo configure:2907: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2911: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -2931,12 +2935,73 @@
 fi
 
 fi
 
 
 
+# Check whether --with-egd-socket or --without-egd-socket was given.
+if test "${with_egd_socket+set}" = set; then
+  withval="$with_egd_socket"
+   EGD_SOCKET="$withval" 
+
+fi
+
+if test -n "$EGD_SOCKET" ; then
+	cat >> confdefs.h <<EOF
+#define EGD_SOCKET "$EGD_SOCKET"
+EOF
+
+fi
+
+# Check whether --with-random or --without-random was given.
+if test "${with_random+set}" = set; then
+  withval="$with_random"
+   RANDOM_FILE="$withval" 
+else
+  
+                
+ac_safe=`echo ""/dev/urandom"" | sed 'y%./+-%__p_%'`
+echo $ac_n "checking for "/dev/urandom"""... $ac_c" 1>&6
+echo "configure:2965: checking for "/dev/urandom"" >&5
+if eval "test \"`echo '$''{'ac_cv_file_$ac_safe'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  if test "$cross_compiling" = yes; then
+    { echo "configure: error: Cannot check for file existence when cross compiling" 1>&2; exit 1; }
+else
+  if test -r "/dev/urandom"; then
+    eval "ac_cv_file_$ac_safe=yes"
+  else
+    eval "ac_cv_file_$ac_safe=no"
+  fi
+fi
+fi
+if eval "test \"`echo '$ac_cv_file_'$ac_safe`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  
+                RANDOM_FILE="/dev/urandom";
+            
+        
+else
+  echo "$ac_t""no" 1>&6
+
+fi
+
+    
+
+fi
+
+if test -n "$RANDOM_FILE" ; then
+	
+	cat >> confdefs.h <<EOF
+#define RANDOM_FILE "$RANDOM_FILE"
+EOF
+
+fi
+
+
 # Check whether --with-krb4-includes or --without-krb4-includes was given.
 if test "${with_krb4_includes+set}" = set; then
   withval="$with_krb4_includes"
   
  CPPFLAGS="$CPPFLAGS -I$withval"
  KRB4INC="$withval"
@@ -2973,53 +3038,53 @@
   want_krb4="yes"
  
 fi
 
 
 echo $ac_n "checking if Kerberos4 support is requested""... $ac_c" 1>&6
-echo "configure:2980: checking if Kerberos4 support is requested" >&5
+echo "configure:3045: checking if Kerberos4 support is requested" >&5
 
 if test "$want_krb4" = yes
 then
   if test "$ipv6" = "yes"; then
     echo krb4 is not compatible with IPv6
     exit 1
   fi
   echo "$ac_t""yes" 1>&6
 
   
   echo $ac_n "checking where to look for Kerberos4""... $ac_c" 1>&6
-echo "configure:2992: checking where to look for Kerberos4" >&5
+echo "configure:3057: checking where to look for Kerberos4" >&5
   if test X"$OPT_KRB4" = Xyes
   then
     echo "$ac_t""defaults" 1>&6
   else
     echo "$ac_t""libs in $KRB4LIB, headers in $KRB4INC" 1>&6
   fi
 
     echo $ac_n "checking for des_pcbc_encrypt in -ldes""... $ac_c" 1>&6
-echo "configure:3001: checking for des_pcbc_encrypt in -ldes" >&5
+echo "configure:3066: checking for des_pcbc_encrypt in -ldes" >&5
 ac_lib_var=`echo des'_'des_pcbc_encrypt | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-ldes  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3009 "configure"
+#line 3074 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char des_pcbc_encrypt();
 
 int main() {
 des_pcbc_encrypt()
 ; return 0; }
 EOF
-if { (eval echo configure:3020: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3085: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3033,23 +3098,23 @@
   echo "$ac_t""yes" 1>&6
   
     for ac_hdr in des.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3040: checking for $ac_hdr" >&5
+echo "configure:3105: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3045 "configure"
+#line 3110 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3050: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3115: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3071,18 +3136,18 @@
   echo "$ac_t""no" 1>&6
 fi
 done
 
 
         echo $ac_n "checking for res_search""... $ac_c" 1>&6
-echo "configure:3078: checking for res_search" >&5
+echo "configure:3143: checking for res_search" >&5
 if eval "test \"`echo '$''{'ac_cv_func_res_search'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3083 "configure"
+#line 3148 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char res_search(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3099,13 +3164,13 @@
 #else
 res_search();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3106: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3171: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_res_search=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3117,32 +3182,32 @@
 if eval "test \"`echo '$ac_cv_func_'res_search`\" = yes"; then
   echo "$ac_t""yes" 1>&6
   :
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for res_search in -lresolv""... $ac_c" 1>&6
-echo "configure:3124: checking for res_search in -lresolv" >&5
+echo "configure:3189: checking for res_search in -lresolv" >&5
 ac_lib_var=`echo resolv'_'res_search | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lresolv  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3132 "configure"
+#line 3197 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char res_search();
 
 int main() {
 res_search()
 ; return 0; }
 EOF
-if { (eval echo configure:3143: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3208: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3167,32 +3232,32 @@
 fi
 
 fi
 
 
         echo $ac_n "checking for krb_net_read in -lkrb""... $ac_c" 1>&6
-echo "configure:3174: checking for krb_net_read in -lkrb" >&5
+echo "configure:3239: checking for krb_net_read in -lkrb" >&5
 ac_lib_var=`echo krb'_'krb_net_read | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lkrb  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3182 "configure"
+#line 3247 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char krb_net_read();
 
 int main() {
 krb_net_read()
 ; return 0; }
 EOF
-if { (eval echo configure:3193: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3258: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3206,23 +3271,23 @@
   echo "$ac_t""yes" 1>&6
   
             for ac_hdr in krb.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3213: checking for $ac_hdr" >&5
+echo "configure:3278: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3218 "configure"
+#line 3283 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3223: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3288: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3248,18 +3313,18 @@
 
             LIBS="-lkrb -ldes $LIBS"
 
                   for ac_func in krb_get_our_ip_for_realm
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3255: checking for $ac_func" >&5
+echo "configure:3320: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3260 "configure"
+#line 3325 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3276,13 +3341,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3283: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3348: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3309,18 +3374,18 @@
 EOF
 
 
             for ac_func in strlcpy
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3316: checking for $ac_func" >&5
+echo "configure:3381: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3321 "configure"
+#line 3386 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3337,13 +3402,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3344: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3409: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3393,44 +3458,44 @@
 then
   echo "configure: warning: SSL/https support disabled" 1>&2  
 else
 
   
   echo $ac_n "checking where to look for SSL""... $ac_c" 1>&6
-echo "configure:3400: checking where to look for SSL" >&5
+echo "configure:3465: checking where to look for SSL" >&5
   if test X"$OPT_SSL" = Xoff
   then
   	echo "$ac_t""defaults (or given in environment)" 1>&6
   else
 	test X"$OPT_SSL" = Xyes && OPT_SSL=/usr/local/ssl
                 LDFLAGS="$LDFLAGS -L$OPT_SSL/lib"
 	CPPFLAGS="$CPPFLAGS -I$OPT_SSL/include/openssl -I$OPT_SSL/include"
 	echo "$ac_t""$OPT_SSL" 1>&6
   fi
 
     echo $ac_n "checking for CRYPTO_lock in -lcrypto""... $ac_c" 1>&6
-echo "configure:3412: checking for CRYPTO_lock in -lcrypto" >&5
+echo "configure:3477: checking for CRYPTO_lock in -lcrypto" >&5
 ac_lib_var=`echo crypto'_'CRYPTO_lock | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lcrypto  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3420 "configure"
+#line 3485 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char CRYPTO_lock();
 
 int main() {
 CRYPTO_lock()
 ; return 0; }
 EOF
-if { (eval echo configure:3431: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3496: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3454,32 +3519,32 @@
   echo "$ac_t""no" 1>&6
 fi
 
 
   if test $ac_cv_lib_crypto_CRYPTO_lock = yes; then
             echo $ac_n "checking for SSL_connect in -lssl""... $ac_c" 1>&6
-echo "configure:3461: checking for SSL_connect in -lssl" >&5
+echo "configure:3526: checking for SSL_connect in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3469 "configure"
+#line 3534 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char SSL_connect();
 
 int main() {
 SSL_connect()
 ; return 0; }
 EOF
-if { (eval echo configure:3480: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3545: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3503,36 +3568,36 @@
   echo "$ac_t""no" 1>&6
 fi
 
 
     if test "$ac_cv_lib_ssl_SSL_connect" != yes; then
                 echo $ac_n "checking for ssl with RSAglue/rsaref libs in use""... $ac_c" 1>&6
-echo "configure:3510: checking for ssl with RSAglue/rsaref libs in use" >&5;
+echo "configure:3575: checking for ssl with RSAglue/rsaref libs in use" >&5;
         OLIBS=$LIBS
         LIBS="$LIBS -lRSAglue -lrsaref"
         echo $ac_n "checking for SSL_connect in -lssl""... $ac_c" 1>&6
-echo "configure:3514: checking for SSL_connect in -lssl" >&5
+echo "configure:3579: checking for SSL_connect in -lssl" >&5
 ac_lib_var=`echo ssl'_'SSL_connect | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   ac_save_LIBS="$LIBS"
 LIBS="-lssl  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 3522 "configure"
+#line 3587 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
     builtin and then its argument prototype would still apply.  */
 char SSL_connect();
 
 int main() {
 SSL_connect()
 ; return 0; }
 EOF
-if { (eval echo configure:3533: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3598: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3567,23 +3632,23 @@
 
 
         for ac_hdr in openssl/x509.h openssl/rsa.h openssl/crypto.h openssl/pem.h openssl/ssl.h openssl/err.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3574: checking for $ac_hdr" >&5
+echo "configure:3639: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3579 "configure"
+#line 3644 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3584: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3649: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3609,23 +3674,23 @@
 
     if test $ac_cv_header_openssl_x509_h = no; then
       for ac_hdr in x509.h rsa.h crypto.h pem.h ssl.h err.h
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:3616: checking for $ac_hdr" >&5
+echo "configure:3681: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3621 "configure"
+#line 3686 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:3626: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:3691: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -3651,21 +3716,22 @@
     fi
 
   fi
 
   
   for ac_func in RAND_status \
-                  RAND_screen 
+                  RAND_screen \
+                  RAND_egd 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3661: checking for $ac_func" >&5
+echo "configure:3727: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3666 "configure"
+#line 3732 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3682,13 +3748,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3689: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3755: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3737,18 +3803,18 @@
 else
 
     
       for ac_func in gethostbyname_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3744: checking for $ac_func" >&5
+echo "configure:3810: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3749 "configure"
+#line 3815 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -3765,13 +3831,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:3772: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:3838: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -3785,18 +3851,18 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking if gethostbyname_r takes 3 arguments""... $ac_c" 1>&6
-echo "configure:3792: checking if gethostbyname_r takes 3 arguments" >&5
+echo "configure:3858: checking if gethostbyname_r takes 3 arguments" >&5
     if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3797 "configure"
+#line 3863 "configure"
 #include "confdefs.h"
 
 #include <string.h>
 #include <sys/types.h>
 #include <netdb.h>
 
@@ -3808,13 +3874,13 @@
 int rc;
 memset(&h, 0, sizeof(struct hostent));
 memset(&hdata, 0, sizeof(struct hostent_data));
 rc = gethostbyname_r(name, &h, &hdata);
 exit (rc != 0 ? 1 : 0); }
 EOF
-if { (eval echo configure:3815: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3881: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
       echo "$ac_t""yes" 1>&6
       cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_3 1
 EOF
@@ -3824,18 +3890,18 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking if gethostbyname_r with -D_REENTRANT takes 3 arguments""... $ac_c" 1>&6
-echo "configure:3831: checking if gethostbyname_r with -D_REENTRANT takes 3 arguments" >&5
+echo "configure:3897: checking if gethostbyname_r with -D_REENTRANT takes 3 arguments" >&5
       if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3836 "configure"
+#line 3902 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 
 #include <string.h>
 #include <sys/types.h>
@@ -3849,13 +3915,13 @@
 int rc;
 memset(&h, 0, sizeof(struct hostent));
 memset(&hdata, 0, sizeof(struct hostent_data));
 rc = gethostbyname_r(name, &h, &hdata);
 exit (rc != 0 ? 1 : 0); }
 EOF
-if { (eval echo configure:3856: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3922: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
 	echo "$ac_t""yes" 1>&6
 	cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_3 1
 EOF
@@ -3869,18 +3935,18 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
   
 	echo "$ac_t""no" 1>&6
 	echo $ac_n "checking if gethostbyname_r takes 5 arguments""... $ac_c" 1>&6
-echo "configure:3876: checking if gethostbyname_r takes 5 arguments" >&5
+echo "configure:3942: checking if gethostbyname_r takes 5 arguments" >&5
 	if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3881 "configure"
+#line 3947 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 
 int
@@ -3890,13 +3956,13 @@
 char *name = "localhost";
 char buffer[8192];
 int h_errno;
 hp = gethostbyname_r(name, &h, buffer, 8192, &h_errno);
 exit (hp == NULL ? 1 : 0); }
 EOF
-if { (eval echo configure:3897: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:3963: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
 	  echo "$ac_t""yes" 1>&6
 	  cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_5 1
 EOF
@@ -3906,18 +3972,18 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
   
 	  echo "$ac_t""no" 1>&6
 	  echo $ac_n "checking if gethostbyname_r takes 6 arguments""... $ac_c" 1>&6
-echo "configure:3913: checking if gethostbyname_r takes 6 arguments" >&5
+echo "configure:3979: checking if gethostbyname_r takes 6 arguments" >&5
 	  if test "$cross_compiling" = yes; then
   ac_cv_gethostbyname_args=0
 else
   cat > conftest.$ac_ext <<EOF
-#line 3918 "configure"
+#line 3984 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 
 int
@@ -3928,13 +3994,13 @@
 char buf[8192];
 int rc;
 int h_errno;
 rc = gethostbyname_r(name, &h, buf, 8192, &hp, &h_errno);
 exit (rc != 0 ? 1 : 0); }
 EOF
-if { (eval echo configure:3935: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4001: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   
 	    echo "$ac_t""yes" 1>&6
 	    cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYNAME_R_6 1
 EOF
@@ -3966,24 +4032,30 @@
 else
   echo "$ac_t""no" 1>&6
 fi
 done
 
 
+if test "$ac_cv_func_gethostbyname_r" = "yes"; then
+  if test "$ac_cv_gethostbyname_args" = "0"; then
+            { echo "configure: error: couldn't figure out how to use gethostbyname_r()" 1>&2; exit 1; }
+  fi
+fi
+
 
 
     
       for ac_func in gethostbyaddr_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:3979: checking for $ac_func" >&5
+echo "configure:4051: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 3984 "configure"
+#line 4056 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4000,13 +4072,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4007: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4079: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4020,15 +4092,15 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking if gethostbyaddr_r takes 5 arguments""... $ac_c" 1>&6
-echo "configure:4027: checking if gethostbyaddr_r takes 5 arguments" >&5
+echo "configure:4099: checking if gethostbyaddr_r takes 5 arguments" >&5
     cat > conftest.$ac_ext <<EOF
-#line 4029 "configure"
+#line 4101 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
 
@@ -4038,13 +4110,13 @@
 struct hostent h;
 struct hostent_data hdata;
 int rc;
 rc = gethostbyaddr_r(address, length, type, &h, &hdata);
 ; return 0; }
 EOF
-if { (eval echo configure:4045: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4117: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
       echo "$ac_t""yes" 1>&6
       cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_5 1
 EOF
@@ -4054,15 +4126,15 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments""... $ac_c" 1>&6
-echo "configure:4061: checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments" >&5
+echo "configure:4133: checking if gethostbyaddr_r with -D_REENTRANT takes 5 arguments" >&5
       cat > conftest.$ac_ext <<EOF
-#line 4063 "configure"
+#line 4135 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
@@ -4073,13 +4145,13 @@
 struct hostent h;
 struct hostent_data hdata;
 int rc;
 rc = gethostbyaddr_r(address, length, type, &h, &hdata);
 ; return 0; }
 EOF
-if { (eval echo configure:4080: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4152: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
 	echo "$ac_t""yes" 1>&6
 	cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_5 1
 EOF
@@ -4093,15 +4165,15 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   
 	echo "$ac_t""no" 1>&6
 	echo $ac_n "checking if gethostbyaddr_r takes 7 arguments""... $ac_c" 1>&6
-echo "configure:4100: checking if gethostbyaddr_r takes 7 arguments" >&5
+echo "configure:4172: checking if gethostbyaddr_r takes 7 arguments" >&5
 	cat > conftest.$ac_ext <<EOF
-#line 4102 "configure"
+#line 4174 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
 
@@ -4114,13 +4186,13 @@
 struct hostent * hp;
 
 hp = gethostbyaddr_r(address, length, type, &h,
                      buffer, 8192, &h_errnop);
 ; return 0; }
 EOF
-if { (eval echo configure:4121: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4193: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
 	  echo "$ac_t""yes" 1>&6
 	  cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_7 1
 EOF
@@ -4130,15 +4202,15 @@
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   
 	  echo "$ac_t""no" 1>&6
 	  echo $ac_n "checking if gethostbyaddr_r takes 8 arguments""... $ac_c" 1>&6
-echo "configure:4137: checking if gethostbyaddr_r takes 8 arguments" >&5
+echo "configure:4209: checking if gethostbyaddr_r takes 8 arguments" >&5
 	  cat > conftest.$ac_ext <<EOF
-#line 4139 "configure"
+#line 4211 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
 #include <netdb.h>
 int main() {
 
@@ -4152,13 +4224,13 @@
 int rc;
 
 rc = gethostbyaddr_r(address, length, type, &h,
                      buffer, 8192, &hp, &h_errnop);
 ; return 0; }
 EOF
-if { (eval echo configure:4159: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4231: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   
 	    echo "$ac_t""yes" 1>&6
 	    cat >> confdefs.h <<\EOF
 #define HAVE_GETHOSTBYADDR_R_8 1
 EOF
@@ -4189,18 +4261,18 @@
 
 
     
     for ac_func in inet_ntoa_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4196: checking for $ac_func" >&5
+echo "configure:4268: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4201 "configure"
+#line 4273 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4217,13 +4289,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4224: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4296: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4237,15 +4309,15 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking whether inet_ntoa_r is declared""... $ac_c" 1>&6
-echo "configure:4244: checking whether inet_ntoa_r is declared" >&5
+echo "configure:4316: checking whether inet_ntoa_r is declared" >&5
     cat > conftest.$ac_ext <<EOF
-#line 4246 "configure"
+#line 4318 "configure"
 #include "confdefs.h"
 
 #include <arpa/inet.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "inet_ntoa_r" >/dev/null 2>&1; then
@@ -4258,15 +4330,15 @@
       echo "$ac_t""yes" 1>&6
 else
   rm -rf conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking whether inet_ntoa_r with -D_REENTRANT is declared""... $ac_c" 1>&6
-echo "configure:4265: checking whether inet_ntoa_r with -D_REENTRANT is declared" >&5
+echo "configure:4337: checking whether inet_ntoa_r with -D_REENTRANT is declared" >&5
       cat > conftest.$ac_ext <<EOF
-#line 4267 "configure"
+#line 4339 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 #include <arpa/inet.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
@@ -4300,18 +4372,18 @@
 
 
     
     for ac_func in localtime_r
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4307: checking for $ac_func" >&5
+echo "configure:4379: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4312 "configure"
+#line 4384 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4328,13 +4400,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4335: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:4407: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4348,15 +4420,15 @@
     ac_tr_func=HAVE_`echo $ac_func | tr 'abcdefghijklmnopqrstuvwxyz' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`
   cat >> confdefs.h <<EOF
 #define $ac_tr_func 1
 EOF
  
     echo $ac_n "checking whether localtime_r is declared""... $ac_c" 1>&6
-echo "configure:4355: checking whether localtime_r is declared" >&5
+echo "configure:4427: checking whether localtime_r is declared" >&5
     cat > conftest.$ac_ext <<EOF
-#line 4357 "configure"
+#line 4429 "configure"
 #include "confdefs.h"
 
 #include <time.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "localtime_r" >/dev/null 2>&1; then
@@ -4365,15 +4437,15 @@
       echo "$ac_t""yes" 1>&6
 else
   rm -rf conftest*
   
       echo "$ac_t""no" 1>&6
       echo $ac_n "checking whether localtime_r with -D_REENTRANT is declared""... $ac_c" 1>&6
-echo "configure:4372: checking whether localtime_r with -D_REENTRANT is declared" >&5
+echo "configure:4444: checking whether localtime_r with -D_REENTRANT is declared" >&5
       cat > conftest.$ac_ext <<EOF
-#line 4374 "configure"
+#line 4446 "configure"
 #include "confdefs.h"
 
 #define _REENTRANT
 #include <time.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
@@ -4402,26 +4474,26 @@
 
 
 fi
 
 
 echo $ac_n "checking for ANSI C header files""... $ac_c" 1>&6
-echo "configure:4409: checking for ANSI C header files" >&5
+echo "configure:4481: checking for ANSI C header files" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stdc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4414 "configure"
+#line 4486 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 #include <stdarg.h>
 #include <string.h>
 #include <float.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4422: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4494: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   ac_cv_header_stdc=yes
 else
   echo "$ac_err" >&5
@@ -4432,13 +4504,13 @@
 fi
 rm -f conftest*
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4439 "configure"
+#line 4511 "configure"
 #include "confdefs.h"
 #include <string.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "memchr" >/dev/null 2>&1; then
   :
@@ -4450,13 +4522,13 @@
 
 fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
 cat > conftest.$ac_ext <<EOF
-#line 4457 "configure"
+#line 4529 "configure"
 #include "confdefs.h"
 #include <stdlib.h>
 EOF
 if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
   egrep "free" >/dev/null 2>&1; then
   :
@@ -4471,24 +4543,24 @@
 if test $ac_cv_header_stdc = yes; then
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
 if test "$cross_compiling" = yes; then
   :
 else
   cat > conftest.$ac_ext <<EOF
-#line 4478 "configure"
+#line 4550 "configure"
 #include "confdefs.h"
 #include <ctype.h>
 #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
 #define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int main () { int i; for (i = 0; i < 256; i++)
 if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);
 exit (0); }
 
 EOF
-if { (eval echo configure:4489: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4561: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   :
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -4531,27 +4603,28 @@
         fcntl.h \
         dlfcn.h \
         alloca.h \
         winsock.h \
         time.h \
         io.h \
+        pwd.h
 
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:4542: checking for $ac_hdr" >&5
+echo "configure:4615: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4547 "configure"
+#line 4620 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:4552: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:4625: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
   eval "ac_cv_header_$ac_safe=yes"
 else
   echo "$ac_err" >&5
@@ -4574,18 +4647,18 @@
 fi
 done
 
 
 
 echo $ac_n "checking for working const""... $ac_c" 1>&6
-echo "configure:4581: checking for working const" >&5
+echo "configure:4654: checking for working const" >&5
 if eval "test \"`echo '$''{'ac_cv_c_const'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4586 "configure"
+#line 4659 "configure"
 #include "confdefs.h"
 
 int main() {
 
 /* Ultrix mips cc rejects this.  */
 typedef int charset[2]; const charset x;
@@ -4628,13 +4701,13 @@
 { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
   const int foo = 10;
 }
 
 ; return 0; }
 EOF
-if { (eval echo configure:4635: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4708: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_c_const=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4649,18 +4722,18 @@
 #define const 
 EOF
 
 fi
 
 echo $ac_n "checking for size_t""... $ac_c" 1>&6
-echo "configure:4656: checking for size_t" >&5
+echo "configure:4729: checking for size_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_size_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4661 "configure"
+#line 4734 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -4682,27 +4755,27 @@
 #define size_t unsigned
 EOF
 
 fi
 
 echo $ac_n "checking whether time.h and sys/time.h may both be included""... $ac_c" 1>&6
-echo "configure:4689: checking whether time.h and sys/time.h may both be included" >&5
+echo "configure:4762: checking whether time.h and sys/time.h may both be included" >&5
 if eval "test \"`echo '$''{'ac_cv_header_time'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4694 "configure"
+#line 4767 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/time.h>
 #include <time.h>
 int main() {
 struct tm *tp;
 ; return 0; }
 EOF
-if { (eval echo configure:4703: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:4776: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_header_time=yes
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4721,32 +4794,32 @@
 
 
 # mprintf() checks:
 
 # check for 'long double'
 echo $ac_n "checking size of long double""... $ac_c" 1>&6
-echo "configure:4728: checking size of long double" >&5
+echo "configure:4801: checking size of long double" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_sizeof_long_double=8
 else
   cat > conftest.$ac_ext <<EOF
-#line 4736 "configure"
+#line 4809 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long double));
   exit(0);
 }
 EOF
-if { (eval echo configure:4747: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4820: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_double=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -4761,32 +4834,32 @@
 #define SIZEOF_LONG_DOUBLE $ac_cv_sizeof_long_double
 EOF
 
 
 # check for 'long long'
 echo $ac_n "checking size of long long""... $ac_c" 1>&6
-echo "configure:4768: checking size of long long" >&5
+echo "configure:4841: checking size of long long" >&5
 if eval "test \"`echo '$''{'ac_cv_sizeof_long_long'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_sizeof_long_long=4
 else
   cat > conftest.$ac_ext <<EOF
-#line 4776 "configure"
+#line 4849 "configure"
 #include "confdefs.h"
 #include <stdio.h>
 main()
 {
   FILE *f=fopen("conftestval", "w");
   if (!f) exit(1);
   fprintf(f, "%d\n", sizeof(long long));
   exit(0);
 }
 EOF
-if { (eval echo configure:4787: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:4860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_sizeof_long_long=`cat conftestval`
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -fr conftest*
@@ -4802,18 +4875,18 @@
 EOF
 
 
 
 # check for ssize_t
 echo $ac_n "checking for ssize_t""... $ac_c" 1>&6
-echo "configure:4809: checking for ssize_t" >&5
+echo "configure:4882: checking for ssize_t" >&5
 if eval "test \"`echo '$''{'ac_cv_type_ssize_t'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4814 "configure"
+#line 4887 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #if STDC_HEADERS
 #include <stdlib.h>
 #include <stddef.h>
 #endif
@@ -4836,19 +4909,79 @@
 EOF
 
 fi
 
 
 
+if test "$ac_cv_header_sys_socket_h" = "yes"; then
+   echo $ac_n "checking for socklen_t in sys/socket.h""... $ac_c" 1>&6
+echo "configure:4918: checking for socklen_t in sys/socket.h" >&5
+   cat > conftest.$ac_ext <<EOF
+#line 4920 "configure"
+#include "confdefs.h"
+#include <sys/socket.h>
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "socklen_t" >/dev/null 2>&1; then
+  rm -rf conftest*
+  socklen_t=yes
+    echo "$ac_t""yes" 1>&6
+else
+  rm -rf conftest*
+  echo "$ac_t""no" 1>&6
+fi
+rm -f conftest*
+
+fi
+
+if test "$socklen_t" != "yes"; then
+  # check for socklen_t the standard way if it wasn't found before
+  echo $ac_n "checking for socklen_t""... $ac_c" 1>&6
+echo "configure:4940: checking for socklen_t" >&5
+if eval "test \"`echo '$''{'ac_cv_type_socklen_t'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 4945 "configure"
+#include "confdefs.h"
+#include <sys/types.h>
+#if STDC_HEADERS
+#include <stdlib.h>
+#include <stddef.h>
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "(^|[^a-zA-Z_0-9])socklen_t[^a-zA-Z_0-9]" >/dev/null 2>&1; then
+  rm -rf conftest*
+  ac_cv_type_socklen_t=yes
+else
+  rm -rf conftest*
+  ac_cv_type_socklen_t=no
+fi
+rm -f conftest*
+
+fi
+echo "$ac_t""$ac_cv_type_socklen_t" 1>&6
+if test $ac_cv_type_socklen_t = no; then
+  cat >> confdefs.h <<\EOF
+#define socklen_t int
+EOF
+
+fi
+
+fi
+
+
+
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:4849: checking host system type" >&5
+echo "configure:4982: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
 NONE)
   case $nonopt in
   NONE)
@@ -4868,18 +5001,18 @@
 cat >> confdefs.h <<EOF
 #define OS "${host}"
 EOF
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:4875: checking return type of signal handlers" >&5
+echo "configure:5008: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4880 "configure"
+#line 5013 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
 #ifdef signal
 #undef signal
 #endif
@@ -4890,13 +5023,13 @@
 #endif
 
 int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:4897: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:5030: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4931,22 +5064,24 @@
                 perror \
                 closesocket \
                 setvbuf \
                 sigaction \
                 signal \
                 getpass_r \
-                strlcat
+                strlcat \
+                getpwuid \
+                geteuid
 
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:4942: checking for $ac_func" >&5
+echo "configure:5077: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 4947 "configure"
+#line 5082 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
 #include <assert.h>
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -4963,13 +5098,13 @@
 #else
 $ac_func();
 #endif
 
 ; return 0; }
 EOF
-if { (eval echo configure:4970: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:5105: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
   echo "configure: failed program was:" >&5
   cat conftest.$ac_ext >&5
   rm -rf conftest*
@@ -4999,13 +5134,13 @@
   { echo "configure: error: Can't work without an existing socket() function" 1>&2; exit 1; }
 fi
 
 # Extract the first word of "perl", so it can be a program name with args.
 set dummy perl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5006: checking for $ac_word" >&5
+echo "configure:5141: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_PERL'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   case "$PERL" in
   /*)
   ac_cv_path_PERL="$PERL" # Let the user override the test with a path.
@@ -5038,13 +5173,13 @@
 
 for ac_prog in gnroff nroff
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5045: checking for $ac_word" >&5
+echo "configure:5180: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_path_NROFF'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   case "$NROFF" in
   /*)
   ac_cv_path_NROFF="$NROFF" # Let the user override the test with a path.
@@ -5080,13 +5215,13 @@
 
 for ac_prog in 'bison -y' byacc
 do
 # Extract the first word of "$ac_prog", so it can be a program name with args.
 set dummy $ac_prog; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:5087: checking for $ac_word" >&5
+echo "configure:5222: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_YACC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   if test -n "$YACC"; then
   ac_cv_prog_YACC="$YACC" # Let the user override the test.
 else
@@ -5227,13 +5362,18 @@
            tests/data/Makefile \
 	   packages/Makefile \
 	   packages/Win32/Makefile \
 	   packages/Linux/Makefile \
 	   packages/Linux/RPM/Makefile \
 	   packages/Linux/RPM/curl.spec \
-	   packages/Linux/RPM/curl-ssl.spec  config.h src/config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
+	   packages/Linux/RPM/curl-ssl.spec \
+           perl/Makefile \
+           perl/Curl_easy/Makefile \
+           php/Makefile \
+           php/examples/Makefile
+ config.h src/config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
 EOF
 cat >> $CONFIG_STATUS <<EOF
 
 # Protect against being on the right side of a sed subst in config.status.
 sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
  s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
@@ -5290,12 +5430,13 @@
 s%@target@%$target%g
 s%@target_alias@%$target_alias%g
 s%@target_cpu@%$target_cpu%g
 s%@target_vendor@%$target_vendor%g
 s%@target_os@%$target_os%g
 s%@CPP@%$CPP%g
+s%@RANDOM_FILE@%$RANDOM_FILE%g
 s%@PERL@%$PERL%g
 s%@NROFF@%$NROFF%g
 s%@YACC@%$YACC%g
 
 CEOF
 EOF
@@ -5348,13 +5489,18 @@
            tests/data/Makefile \
 	   packages/Makefile \
 	   packages/Win32/Makefile \
 	   packages/Linux/Makefile \
 	   packages/Linux/RPM/Makefile \
 	   packages/Linux/RPM/curl.spec \
-	   packages/Linux/RPM/curl-ssl.spec "}
+	   packages/Linux/RPM/curl-ssl.spec \
+           perl/Makefile \
+           perl/Curl_easy/Makefile \
+           php/Makefile \
+           php/examples/Makefile
+"}
 EOF
 cat >> $CONFIG_STATUS <<\EOF
 for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
   case "$ac_file" in
   *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/configure.in	2001-02-07 17:49:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/configure.in	2001-03-22 16:51:24.000000000 +0800
@@ -1,7 +1,7 @@
-dnl $Id: configure.in,v 1.53 2001/02/07 09:49:06 bagder Exp $
+dnl $Id: configure.in,v 1.60 2001/03/22 08:51:24 bagder Exp $
 dnl Process this file with autoconf to produce a configure script.
 AC_INIT(lib/urldata.h)
 AM_CONFIG_HEADER(config.h src/config.h)
 
 VERSION=`sed -ne 's/^#define LIBCURL_VERSION "\(.*\)"/\1/p' ${srcdir}/include/curl/curl.h`
 AM_INIT_AUTOMAKE(curl,$VERSION)
@@ -292,12 +292,20 @@
 	    have_missing_r_funcs="$have_missing_r_funcs gethostbyname_r"],
 	    [ac_cv_gethostbyname_args=0])],
 	  [ac_cv_gethostbyname_args=0])],
 	[ac_cv_gethostbyname_args=0])],
       [ac_cv_gethostbyname_args=0])])
 
+if test "$ac_cv_func_gethostbyname_r" = "yes"; then
+  if test "$ac_cv_gethostbyname_args" = "0"; then
+    dnl there's a gethostbyname_r() function, but we don't know how
+    dnl many arguments it wants!
+    AC_MSG_ERROR([couldn't figure out how to use gethostbyname_r()])
+  fi
+fi
+
 ])
 
 dnl **********************************************************************
 dnl Checks for IPv6
 dnl **********************************************************************
 
@@ -389,12 +397,42 @@
 AC_CHECK_FUNC(gethostname, , AC_CHECK_LIB(ucb, gethostname))
 
 dnl dl lib?
 AC_CHECK_FUNC(dlopen, , AC_CHECK_LIB(dl, dlopen))
 
 dnl **********************************************************************
+dnl Check for the random seed preferences 
+dnl **********************************************************************
+
+AC_ARG_WITH(egd-socket,
+    [  --with-egd-socket=FILE  Entropy Gathering Daemon socket pathname],
+    [ EGD_SOCKET="$withval" ]
+)
+if test -n "$EGD_SOCKET" ; then
+	AC_DEFINE_UNQUOTED(EGD_SOCKET, "$EGD_SOCKET")
+fi
+
+dnl Check for user-specified random device
+AC_ARG_WITH(random,
+    [  --with-random=FILE      read randomness from FILE (default=/dev/urandom)],
+    [ RANDOM_FILE="$withval" ],
+    [
+        dnl Check for random device
+        AC_CHECK_FILE("/dev/urandom",
+            [
+                RANDOM_FILE="/dev/urandom";
+            ]
+        )
+    ]
+)
+if test -n "$RANDOM_FILE" ; then
+	AC_SUBST(RANDOM_FILE)
+	AC_DEFINE_UNQUOTED(RANDOM_FILE, "$RANDOM_FILE")
+fi
+
+dnl **********************************************************************
 dnl Check for the presence of Kerberos4 libraries and headers
 dnl **********************************************************************
 
 AC_ARG_WITH(krb4-includes,
  [  --with-krb4-includes[=DIR]   Specify location of kerberos4 headers],[
  CPPFLAGS="$CPPFLAGS -I$withval"
@@ -542,13 +580,14 @@
 
   fi
 
   dnl these can only exist if openssl exists
 
   AC_CHECK_FUNCS( RAND_status \
-                  RAND_screen )
+                  RAND_screen \
+                  RAND_egd )
 
 fi
 
 dnl **********************************************************************
 dnl Check for the presence of ZLIB libraries and headers
 dnl **********************************************************************
@@ -639,12 +678,13 @@
         fcntl.h \
         dlfcn.h \
         alloca.h \
         winsock.h \
         time.h \
         io.h \
+        pwd.h
 )
 
 dnl Check for libz header
 dnl AC_CHECK_HEADERS(zlib.h)
 
 dnl Checks for typedefs, structures, and compiler characteristics.
@@ -659,12 +699,34 @@
 # check for 'long long'
 AC_CHECK_SIZEOF(long long, 4)
 
 # check for ssize_t
 AC_CHECK_TYPE(ssize_t, int)
 
+dnl
+dnl We can't just AC_CHECK_TYPE() for socklen_t since it doesn't appear
+dnl in the standard headers. We egrep for it in the socket headers and
+dnl if it is used there we assume we have the type defined, otherwise
+dnl we search for it with AC_CHECK_TYPE() the "normal" way
+dnl
+
+if test "$ac_cv_header_sys_socket_h" = "yes"; then
+   AC_MSG_CHECKING(for socklen_t in sys/socket.h)
+   AC_EGREP_HEADER(socklen_t,
+    sys/socket.h,
+    socklen_t=yes
+    AC_MSG_RESULT(yes),
+    AC_MSG_RESULT(no))
+fi
+
+if test "$socklen_t" != "yes"; then
+  # check for socklen_t the standard way if it wasn't found before
+  AC_CHECK_TYPE(socklen_t, int)
+fi
+
+
 dnl Get system canonical name
 AC_CANONICAL_HOST
 AC_DEFINE_UNQUOTED(OS, "${host}")
 
 dnl Checks for library functions.
 dnl AC_PROG_GCC_TRADITIONAL
@@ -690,13 +752,15 @@
                 perror \
                 closesocket \
                 setvbuf \
                 sigaction \
                 signal \
                 getpass_r \
-                strlcat
+                strlcat \
+                getpwuid \
+                geteuid
 )
 
 dnl removed 'getpass' check on October 26, 2000
 
 if test "$ac_cv_func_select" != "yes"; then
   AC_MSG_ERROR(Can't work without an existing select() function)
@@ -730,8 +794,13 @@
            tests/data/Makefile \
 	   packages/Makefile \
 	   packages/Win32/Makefile \
 	   packages/Linux/Makefile \
 	   packages/Linux/RPM/Makefile \
 	   packages/Linux/RPM/curl.spec \
-	   packages/Linux/RPM/curl-ssl.spec )
+	   packages/Linux/RPM/curl-ssl.spec \
+           perl/Makefile \
+           perl/Curl_easy/Makefile \
+           php/Makefile \
+           php/examples/Makefile
+)
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/config-win32.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/config-win32.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/config-win32.h	2001-02-07 17:21:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/config-win32.h	2001-03-14 16:10:18.000000000 +0800
@@ -23,12 +23,15 @@
 /* Define to `unsigned' if <sys/types.h> doesn't define.  */
 /* #undef size_t */
 
 /* Define this to 'int' if ssize_t is not an available typedefed type */
 #define ssize_t int
 
+/* Define this to 'int' if socklen_t is not an available typedefed type */
+#define socklen_t int
+
 /* Define if you have the ANSI C header files.  */
 #define STDC_HEADERS 1
 
 /* Define if you can safely include both <sys/time.h> and <time.h>.  */
 /* #define TIME_WITH_SYS_TIME 1 */
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/BUGS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/BUGS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/BUGS	2000-05-23 01:35:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/BUGS	2001-03-13 20:35:42.000000000 +0800
@@ -3,39 +3,40 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
 BUGS
 
-  Curl has grown substantially from that day, several years ago, when I
-  started fiddling with it. When I write this, there are 16500 lines of source
-  code, and by the time you read this it has probably grown even more.
+  Curl and libcurl have grown substantially since the beginning. At the time
+  of writing (mid March 2001), there are 23000 lines of source code, and by
+  the time you read this it has probably grown even more.
 
   Of course there are lots of bugs left. And lots of misfeatures.
 
   To help us make curl the stable and solid product we want it to be, we need
   bug reports and bug fixes. If you can't fix a bug yourself and submit a fix
   for it, try to report an as detailed report as possible to the curl mailing
   list to allow one of us to have a go at a solution. You should also post
   your bug/problem at curl's bug tracking system over at
 
         http://sourceforge.net/bugs/?group_id=976
 
   When reporting a bug, you should include information that will help us
-  understand what's wrong, what's expected and how to repeat it. You therefore
-  need to supply your operating system's name and version number (uname -a
-  under a unix is fine), what version of curl you're using (curl -v is fine),
-  what URL you were working with and anything else you think matters.
+  understand what's wrong, what you expected to happen and how to repeat the
+  bad behaviour. You therefore need to supply your operating system's name and
+  version number (uname -a under a unix is fine), what version of curl you're
+  using (curl -V is fine), what URL you were working with and anything else
+  you think matters.
 
   If curl crashed, causing a core dump (in unix), there is hardly any use to
   send that huge file to anyone of us. Unless we have an exact same system
   setup as you, we can't do much with it. What we instead ask of you is to get
   a stack trace and send that (much smaller) output to us instead!
 
   The address and how to subscribe to the mailing list is detailed in the
-  README.curl file.
+  MANUAL file.
 
   HOW TO GET A STACK TRACE with a common unix debugger
   ====================================================
 
   First, you must make sure that you compile all sources with -g and that you
   don't 'strip' the final executable.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/CONTRIBUTE /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/CONTRIBUTE
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/CONTRIBUTE	2001-01-19 17:38:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/CONTRIBUTE	2001-03-13 20:35:42.000000000 +0800
@@ -10,38 +10,38 @@
  in mind when you decide to write a contribution to the project. This concerns
  new features as well as corrections to existing flaws or bugs.
 
 The License Issue
 
  When contributing with code, you agree to put your changes and new code under
- the same license curl and libcurl is already using.
+ the same license curl and libcurl is already using unless stated otherwise.
 
  If you add a larger piece of code, you can opt to make that file or set of
  files to use a different license as long as they don't enfore any changes to
  the rest of the package and they make sense. Such "separate parts" can not be
  GPL (as we don't want the GPL virus to attack users of libcurl) but they must
  use "GPL compatible" licenses.
 
 Naming
 
  Try using a non-confusing naming scheme for your new functions and variable
  names. It doesn't necessarily have to mean that you should use the same as in
  other places of the code, just that the names should be logical,
- understandable and be named according to what they're used for.
+ understandable and be named according to what they're used for. File-local
+ functions should be made static.
 
 Indenting
 
  Please try using the same indenting levels and bracing method as all the
  other code already does. It makes the source code a lot easier to follow if
- all of it is written using the same style. I don't ask you to like it, I just
- ask you to follow the tradition! ;-)
+ all of it is written using the same style. We don't ask you to like it, we
+ just ask you to follow the tradition! ;-)
 
 Commenting
 
- Comment your source code extensively. I don't see myself as a very good
- source commenter, but I try to become one. Commented code is quality code and
+ Comment your source code extensively. Commented code is quality code and
  enables future modifications much more. Uncommented code much more risk being
  completely replaced when someone wants to extend things, since other persons'
  source code can get quite hard to read.
 
 General Style
 
@@ -68,15 +68,15 @@
  description exactly what they correct so that all patches can be selectively
  applied by the maintainer or other interested parties.
 
 Patch Against Recent Sources
 
  Please try to get the latest available sources to make your patches
- against. It makes my life so much easier. The very best is if you get the
- most up-to-date sources from the CVS repository, but the latest release
- archive is quite OK as well!
+ against. It makes the life of the developers so much easier. The very best is
+ if you get the most up-to-date sources from the CVS repository, but the
+ latest release archive is quite OK as well!
 
 Document
 
  Writing docs is dead boring and one of the big problems with many open source
  projects. Someone's gotta do it. It makes it a lot easier if you submit a
  small description of your fix or your new features with every contribution so
@@ -88,12 +88,12 @@
  course get write access to the CVS repository and then you'll be able to
  check-in all your changes straight into the CVS tree instead of sending all
  changes by mail as patches. Just ask if this is what you'd want.
 
 Test Cases
 
- Since the introduction of the test suite, we will get the possibility to
- quickly verify that the main features are working as supposed to. To maintain
- this situation and improve it, all new features and functions that are added
- need tro be tested. Every feature that is added should get at least one valid
+ Since the introduction of the test suite, we can quickly verify that the main
+ features are working as they're supposed to. To maintain this situation and
+ improve it, all new features and functions that are added need to be tested
+ in the test suite. Every feature that is added should get at least one valid
  test case that verifies that it works as documented. If every submitter also
  post a few test cases, it won't end up as a heavy burden on a single person!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl.1	2001-02-06 06:50:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl.1	2001-03-16 18:53:05.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man curl.1
 .\" Written by Daniel Stenberg
 .\"
-.TH curl 1 "19 January 2001" "Curl 7.6" "Curl Manual"
+.TH curl 1 "15 March 2001" "Curl 7.7" "Curl Manual"
 .SH NAME
 curl \- get a URL with FTP, TELNET, LDAP, GOPHER, DICT, FILE, HTTP or
 HTTPS syntax.
 .SH SYNOPSIS
 .B curl [options]
 .I [URL...]
@@ -38,12 +38,18 @@
 supported at the moment:
 
  http://www.any.org/archive[1996-1999]/volume[1-4]part{a,b,c,index}.html
 
 Starting with curl 7.6, you can specify any amount of URLs on the command
 line. They will be fetched in a sequential manner in the specified order.
+
+Starting with curl 7.7, curl will attempt to re-use connections for multiple
+file transfers, so that getting many files from the same server will not do
+multiple connects/handshakes. This improves speed. Of course this is only done
+on files specified on a single command line and cannot be used between
+separate curl invokes.
 .SH OPTIONS
 .IP "-a/--append"
 (FTP)
 When used in a ftp upload, this will tell curl to append to the target
 file instead of overwriting it. If the file doesn't exist, it will
 be created.
@@ -82,12 +88,20 @@
 .IP "-B/--use-ascii"
 Use ASCII transfer when getting an FTP file or LDAP info. For FTP, this can
 also be enforced by using an URL that ends with ";type=A". This option causes
 data sent to stdout to be in text mode for win32 systems.
 
 If this option is used twice, the second one will disable ASCII usage.
+.IP "--connect-timeout <seconds>"
+Maximum time in seconds that you allow the connection to the server to take.
+This only limits the connection phase, once curl has connected this option is
+of no more use. This option doesn't work in win32 systems.  See also the
+.I "--max-time"
+option.
+
+If this option is used serveral times, the last one will be used.
 .IP "-c/--continue"
 .B Deprecated. Use '-C -' instead.
 Continue/Resume a previous file transfer. This instructs curl to
 continue appending data on the file where it was previously left,
 possibly because of a broken connection to the server. There must be
 a named physical file to append to for this to work.
@@ -102,20 +116,21 @@
 If used with uploads, the ftp server command SIZE will not be used by
 curl. Upload resume is for FTP only.
 HTTP resume is only possible with HTTP/1.1 or later servers.
 
 If this option is used serveral times, the last one will be used.
 .IP "-d/--data <data>"
-(HTTP) Sends the specified data in a POST request to the HTTP server. Note
-that the data is sent exactly as specified with no extra processing (with all
-newlines cut off).  The data is expected to be "url-encoded". This will cause
-curl to pass the data to the server using the content-type
-application/x-www-form-urlencoded. Compare to -F. If more than one -d/--data
-option is used on the same command line, the data pieces specified will be
-merged together with a separating &-letter. Thus, using '-d name=daniel -d
-skill=lousy' would generate a post chunk that looks like
+(HTTP) Sends the specified data in a POST request to the HTTP server, in a way
+that can emulate as if a user has filled in a HTML form and pressed the submit
+button. Note that the data is sent exactly as specified with no extra
+processing (with all newlines cut off).  The data is expected to be
+"url-encoded". This will cause curl to pass the data to the server using the
+content-type application/x-www-form-urlencoded. Compare to -F. If more than
+one -d/--data option is used on the same command line, the data pieces
+specified will be merged together with a separating &-letter. Thus, using '-d
+name=daniel -d skill=lousy' would generate a post chunk that looks like
 'name=daniel&skill=lousy'.
 
 If you start the data with the letter @, the rest should be a file name to
 read the data from, or - if you want curl to read the data from stdin.  The
 contents of the file must already be url-encoded. Multiple files can also be
 specified.
@@ -157,12 +172,17 @@
 .I -L/--location 
 you can append ";auto" to the referer URL to make curl automatically set the
 previous URL when it follows a Location: header. The ";auto" string can be
 used alone, even if you don't set an initial referer.
 
 If this option is used serveral times, the last one will be used.
+.IP "--egd-file <file>"
+(HTTPS) Specify the path name to the Entropy Gathering Daemon socket. The
+socket is used to seed the random engine for SSL connections. See also the
+.I "--random-file"
+option.
 .IP "-E/--cert <certificate[:password]>"
 (HTTPS)
 Tells curl to use the specified certificate file when getting a file
 with HTTPS. The certificate must be in PEM format.
 If the optional password isn't specified, it will be queried for on
 the terminal. Note that this certificate is the private key and the private
@@ -280,12 +300,15 @@
 
 If this option is used twice, the second will again disable location following.
 .IP "-m/--max-time <seconds>"
 Maximum time in seconds that you allow the whole operation to take.  This is
 useful for preventing your batch jobs from hanging for hours due to slow
 networks or links going down.  This doesn't work fully in win32 systems.
+See also the
+.I "--connect-timeout"
+option.
 
 If this option is used serveral times, the last one will be used.
 .IP "-M/--manual"
 Manual. Display the huge help text.
 .IP "-n/--netrc"
 Makes curl scan the
@@ -374,12 +397,18 @@
 transfer is taking place. To make commands take place after a successful
 transfer, prefix them with a dash '-'. You may specify any amount of commands
 to be run before and after the transfer. If the server returns failure for one
 of the commands, the entire operation will be aborted.
 
 This option can be used multiple times.
+.IP "--random-file <file>"
+(HTTPS) Specify the path name to file containing what will be considered as
+random data. The data is used to seed the random engine for SSL connections.
+See also the
+.I "--edg-file"
+option.
 .IP "-r/--range <range>"
 (HTTP/FTP)
 Retrieve a byte range (i.e a partial document) from a HTTP/1.1 or FTP
 server. Ranges can be specified in a number of ways.
 .RS
 .TP 10
@@ -422,17 +451,20 @@
 
 If this option is used twice, the second will again disable mute.
 .IP "-S/--show-error"
 When used with -s it makes curl show error message if it fails.
 
 If this option is used twice, the second will again disable show error.
-.IP "-t/--upload"
-.B Deprecated. Use '-T -' instead.
-Transfer the stdin data to the specified file. Curl will read
-everything from stdin until EOF and store with the supplied name. If
-this is used on a http(s) server, the PUT command will be used.
+.IP "-t/--telnet-option <OPT=val>"
+Pass options to the telnet protocol. Supported options are:
+
+TTYPE=<term> Sets the terminal type.
+
+XDISPLOC=<X display> Sets the X display location.
+
+NEW_ENV=<var,val> Sets an environment variable.
 .IP "-T/--upload-file <file>"
 Like -t, but this transfers the specified local file. If there is no
 file part in the specified URL, Curl will append the local file
 name. NOTE that you must use a trailing / on the last directory to
 really prove to Curl that there is no file name or curl will
 think that your last directory name is the remote file name to
@@ -755,13 +787,13 @@
  - David Eriksson <david@2good.com>
  - Ralph Beckmann <rabe@uni-paderborn.de>
  - T. Yamada <tai@imasy.or.jp>
  - Lars J. Aas <larsa@sim.no>
  - Jörn Hartroth <Joern.Hartroth@computer.org>
  - Matthew Clarke <clamat@van.maves.ca>
- - Linus Nielsen <Linus.Nielsen@haxx.se>
+ - Linus Nielsen Feltzing <linus@haxx.se>
  - Felix von Leitner <felix@convergence.de>
  - Dan Zitter <dzitter@zitter.net>
  - Jongki Suwandi <Jongki.Suwandi@eng.sun.com>
  - Chris Maltby <chris@aurema.com>
  - Ron Zapp <rzapper@yahoo.com>
  - Paul Marquis <pmarquis@iname.com>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_cleanup.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_cleanup.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_cleanup.3	2000-06-20 23:34:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_cleanup.3	2001-03-05 23:42:44.000000000 +0800
@@ -1,25 +1,29 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_cleanup 3 "22 May 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_easy_cleanup 3 "5 March 2001" "libcurl 7.7" "libcurl Manual"
 .SH NAME
-curl_easy_cleanup - End a libcurl "easy" session
+curl_easy_cleanup - End a libcurl session
 .SH SYNOPSIS
-.B #include <curl/easy.h>
+.B #include <curl/curl.h>
 .sp
-.BI "curl_easy_cleanup(CURL *" handle ");
+.BI "curl_easy_cleanup(CURL *" handle ");"
 .ad
 .SH DESCRIPTION
 This function must be the last function to call for a curl session. It is the
 opposite of the
 .I curl_easy_init
 function and must be called with the same
 .I handle
 as input as the curl_easy_init call returned.
+
+This will effectively close all connections libcurl has been used and possibly
+has kept open until now. Don't call this function if you intend to transfer
+more files (libcurl 7.7 or later).
 .SH RETURN VALUE
 None
 .SH "SEE ALSO"
 .BR curl_easy_init "(3), "
 .SH BUGS
 Surely there are some, you tell me!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_getinfo.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_getinfo.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_getinfo.3	2001-02-05 04:07:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_getinfo.3	2001-03-05 23:35:58.000000000 +0800
@@ -1,15 +1,15 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_init 3 "4 February 2001" "Curl 7.6.1" "libcurl Manual"
+.TH curl_easy_init 3 "5 March 2001" "libcurl 7.6.1" "libcurl Manual"
 .SH NAME
 curl_easy_getinfo - Extract information from a curl session (added in 7.4)
 .SH SYNOPSIS
-.B #include <curl/easy.h>
+.B #include <curl/curl.h>
 .sp
 .BI "CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );"
 .ad
 .SH DESCRIPTION
 Request internal information from the curl session with this function.  The
 third argument
@@ -80,14 +80,14 @@
 .B CURLINFO_SSL_VERIFYRESULT
 Pass a pointer to a long to receive the result of the certification
 verification that was requested (using the CURLOPT_SSL_VERIFYPEER option to
 curl_easy_setopt). (Added in 7.4.2)
 .TP
 .B CURLINFO_CONTENT_LENGTH_DOWNLOAD
-Pass a pointer to a double to receive the content-length of the download.
-(Added in 7.6.1)
+Pass a pointer to a double to receive the content-length of the download. This
+is the value read from the Content-Length: field.  (Added in 7.6.1)
 .TP
 .B CURLINFO_CONTENT_LENGTH_UPLOAD
 Pass a pointer to a double to receive the specified size of the upload.
 (Added in 7.6.1)
 .PP
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_init.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_init.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_init.3	2000-09-26 15:22:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_init.3	2001-03-05 23:36:04.000000000 +0800
@@ -1,27 +1,31 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_init 3 "26 September 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_easy_init 3 "5 March 2001" "libcurl 7.7" "libcurl Manual"
 .SH NAME
-curl_easy_init - Start a libcurl "easy" session
+curl_easy_init - Start a libcurl session
 .SH SYNOPSIS
-.B #include <curl/easy.h>
+.B #include <curl/curl.h>
 .sp
 .BI "CURL *curl_easy_init( );"
 .ad
 .SH DESCRIPTION
 This function must be the first function to call, and it returns a CURL handle
 that you shall use as input to the other easy-functions. The init calls
 intializes curl and this call MUST have a corresponding call to
 .I curl_easy_cleanup
 when the operation is complete.
 
 On win32 systems, you need to init the winsock stuff manually, libcurl will
 not do that for you. WSAStartup() and WSACleanup() should be used accordingly.
+
+Using libcurl 7.7 and later, you should perform all your sequential file
+transfers using the same curl handle. This enables libcurl to use persistant
+connections where possible.
 .SH RETURN VALUE
 If this function returns NULL, something went wrong and you cannot use the
 other curl functions.
 .SH "SEE ALSO"
 .BR curl_easy_cleanup "(3), "
 .SH BUGS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_perform.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_perform.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_perform.3	2001-01-25 20:27:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_perform.3	2001-03-05 23:36:14.000000000 +0800
@@ -1,33 +1,46 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_perform 3 "25 Jan 2001" "Curl 7.0" "libcurl Manual"
+.TH curl_easy_perform 3 "5 Mar 2001" "libcurl 7.7" "libcurl Manual"
 .SH NAME
-curl_easy_perform - Do the actual transfer in a "easy" session
+curl_easy_perform - Perform a file transfer
 .SH SYNOPSIS
-.B #include <curl/easy.h>
+.B #include <curl/curl.h>
 .sp
 .BI "CURLcode curl_easy_perform(CURL *" handle ");
 .ad
 .SH DESCRIPTION
 This function is called after the init and all the curl_easy_setopt() calls
 are made, and will perform the transfer as described in the options.
 It must be called with the same
 .I handle
 as input as the curl_easy_init call returned.
 
-You are only allowed to call this function once using the same handle. If you
-want to do repeated calls, you must call curl_easy_cleanup and curl_easy_init
-again first.
+libcurl version 7.7 or later (for older versions see below): You can do any
+amount of calls to curl_easy_perform() while using the same handle. If you
+intend to transfer more than one file, you are even encouraged to do
+so. libcurl will then attempt to re-use the same connection for the following
+transfers, thus making the operations faster, less CPU intense and using less
+network resources. Just note that you will have to use
+.I curl_easy_setopt
+between the invokes to set options for the following curl_easy_perform.
+
+You must never call this function simultaneously from two places using the
+same handle. Let the function return first before invoking it another time. If
+you want parallel transfers, you must use several curl handles.
+
+Before libcurl version 7.7: You are only allowed to call this function once
+using the same handle. If you want to do repeated calls, you must call
+curl_easy_cleanup and curl_easy_init again first.
 .SH RETURN VALUE
 0 means everything was ok, non-zero means an error occurred as
 .I <curl/curl.h>
 defines. If the CURLOPT_ERRORBUFFER was set with
 .I curl_easy_setopt
-there willo be a readable error message in the error buffer when non-zero is
+there will be a readable error message in the error buffer when non-zero is
 returned.
 .SH "SEE ALSO"
 .BR curl_easy_init "(3), " curl_easy_setopt "(3), "
 .SH BUGS
 Surely there are some, you tell me!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_setopt.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_setopt.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_easy_setopt.3	2001-02-02 15:22:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_easy_setopt.3	2001-03-16 18:53:05.000000000 +0800
@@ -1,15 +1,15 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_easy_setopt 3 "2 February 2001" "Curl 7.5" "libcurl Manual"
+.TH curl_easy_setopt 3 "13 March 2001" "libcurl 7.7" "libcurl Manual"
 .SH NAME
 curl_easy_setopt - Set curl easy-session options
 .SH SYNOPSIS
-.B #include <curl/easy.h>
+.B #include <curl/curl.h>
 .sp
 .BI "CURLcode curl_easy_setopt(CURL *" handle ", CURLoption "option ", ...);
 .ad
 .SH DESCRIPTION
 curl_easy_setopt() is called to tell libcurl how to behave in a number of
 ways. Most operations in libcurl have default actions, and by using the
@@ -17,13 +17,24 @@
 options are set with the
 .I option
 followed by a parameter. That parameter can be a long, a function pointer or
 an object pointer, all depending on what the option in question expects. Read
 this manual carefully as bad input values may cause libcurl to behave badly!
 You can only set one option in each function call. A typical application uses
-many calls in the setup phase.
+many curl_easy_setopt() calls in the setup phase.
+
+NOTE: strings passed to libcurl as 'char *' arguments, will not be copied by
+the library. Instead you should keep them available until libcurl no longer
+needs them. Failing to do so will cause very odd behaviour or even crashes.
+
+More note: the options set with this function call are valid for the
+forthcoming data transfers that are performed when you invoke
+.I curl_easy_perform .
+The options are not in any way reset between transfers, so if you want
+subsequent transfers with different options, you must change them between the
+transfers.
 
 The
 .I "handle"
 is the return code from the
 .I "curl_easy_init"
 call.
@@ -83,20 +94,22 @@
 .B CURLOPT_INFILESIZE
 When uploading a file to a remote site, this option should be used to tell
 libcurl what the expected size of the infile is.
 .TP
 .B CURLOPT_URL
 The actual URL to deal with. The parameter should be a char * to a zero
-terminated string. NOTE: this option is currently required!
+terminated string. The string must remain present until curl no longer needs
+it, as it doesn't copy the string. NOTE: this option is required to be set
+before curl_easy_perform() is called.
 .TP
 .B CURLOPT_PROXY
 If you need libcurl to use a http proxy to access the outside world, set the
 proxy string with this option. The parameter should be a char * to a zero
-terminated string. To specify port number in this string, append":[port]" to
+terminated string. To specify port number in this string, append :[port] to
 the end of the host name. The proxy string may be prefixed with
-"[protocol]://" since any such prefix will be ignored.
+[protocol]:// since any such prefix will be ignored.
 .TP
 .B CURLOPT_PROXYPORT
 Set this long with this option to set the proxy port to use unless it is
 specified in the proxy string CURLOPT_PROXY.
 .TP
 .B CURLOPT_HTTPPROXYTUNNEL
@@ -186,26 +199,29 @@
 Pass a char * as parameter, which should be [username]:[password] to use for
 the connection to the HTTP proxy. If the password is left out, you will be
 prompted for it.
 .TP
 .B CURLOPT_RANGE
 Pass a char * as parameter, which should contain the specified range you
-want. It should be in the format "X-Y", where X or Y may be left out. The HTTP
+want. It should be in the format "X-Y", where X or Y may be left out. HTTP
 transfers also support several intervals, separated with commas as in
-.I "X-Y,N-M".
+.I "X-Y,N-M"
+. Using this kind of multiple intervals will cause the HTTP server to send the
+response document in pieces.
 .TP
 .B CURLOPT_ERRORBUFFER
 Pass a char * to a buffer that the libcurl may store human readable error
 messages in. This may be more helpful than just the return code from the
 library. The buffer must be at least CURL_ERROR_SIZE big.
 .TP
 .B CURLOPT_TIMEOUT
 Pass a long as parameter containing the maximum time in seconds that you allow
 the libcurl transfer operation to take. Do note that normally, name lookups
 maky take a considerable time and that limiting the operation to less than a
-few minutes risk aborting perfectly normal operations.
+few minutes risk aborting perfectly normal operations. This option will cause
+curl to use the SIGALRM to enable timeouting system calls.
 .TP
 .B CURLOPT_POSTFIELDS
 Pass a char * as parameter, which should be the full data to post in a HTTP
 post operation. See also the CURLOPT_POST.
 .TP
 .B CURLOPT_POSTFIELDSIZE
@@ -407,12 +423,65 @@
 .TP
 .B CURLOPT_MAXREDIRS
 Pass a long. The set number will be the redirection limit. If that many
 redirections have been followed, the next redirect will cause an error. This
 option only makes sense if the CURLOPT_FOLLOWLOCATION is used at the same
 time. (Added in 7.5)
+.TP
+.B CURLOPT_MAXCONNECTS
+Pass a long. The set number will be the persistant connection cache size. The
+set amount will be the maximum amount of simultaneous connections that libcurl
+may cache between file transfers. Default is 5, and there isn't much point in
+changing this value unless you are perfectly aware of how this work and
+changes libcurl's behaviour. Note: if you have already performed transfers
+with this curl handle, setting a smaller MAXCONNECTS than before may cause
+open connections to unnecessarily get closed. (Added in 7.7)
+.TP
+.B CURLOPT_CLOSEPOLICY
+Pass a long. This option sets what policy libcurl should use when the
+connection cache is filled and one of the open connections has to be closed to
+make room for a new connection. This must be one of the CURLCLOSEPOLICY_*
+defines. Use CURLCLOSEPOLICY_LEAST_RECENTLY_USED to make libcurl close the
+connection that was least recently used, that connection is also least likely
+to be capable of re-use. Use CURLCLOSEPOLICY_OLDEST to make libcurl close the
+oldest connection, the one that was created first among the ones in the
+connection cache. The other close policies are not support yet. (Added in 7.7)
+.TP
+.B CURLOPT_FRESH_CONNECT
+Pass a long. Set to non-zero to make the next transfer use a new connection by
+force. If the connection cache is full before this connection, one of the
+existinf connections will be closed as according to the set policy. This
+option should be used with caution and only if you understand what it
+does. Set to 0 to have libcurl attempt re-use of an existing connection.
+(Added in 7.7)
+.TP
+.B CURLOPT_FORBID_REUSE
+Pass a long. Set to non-zero to make the next transfer explicitly close the
+connection when done. Normally, libcurl keep all connections alive when done
+with one transfer in case there comes a succeeding one that can re-use them.
+This option should be used with caution and only if you understand what it
+does. Set to 0 to have libcurl keep the connection open for possibly later
+re-use. (Added in 7.7)
+.TP
+.B CURLOPT_RANDOM_FILE
+Pass a char * to a zero terminated file name. The file will be used to read
+from to seed the random engine for SSL. The more random the specified file is,
+the more secure will the SSL connection become.
+.TP
+.B CURLOPT_FORBID_REUSE
+Pass a char * to the zero terminated path name to the Entropy Gathering Daemon
+socket. It will be used to seed the random engine for SSL.
+.TP
+.B CURLOPT_CONNECTTIMEOUT
+Pass a long. It should contain the maximum time in seconds that you allow the
+connection to the server to take.  This only limits the connection phase, once
+it has connected, this option is of no more use. Set to zero to disable
+connection timeout (it will then only timeout on the system's internal
+timeouts). This option doesn't work in win32 systems.  See also the
+.I CURLOPT_TIMEOUT
+option.
 .PP
 .SH RETURN VALUE
 0 means the option was set properly, non-zero means an error as
 .I <curl/curl.h>
 defines
 .SH "SEE ALSO"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs: curl_escape.3
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_formfree.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_formfree.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_formfree.3	2000-11-17 22:10:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_formfree.3	2001-03-05 23:35:42.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_formfree 3 "17 November 2000" "Curl 7.5" "libcurl Manual"
+.TH curl_formfree 3 "5 March 2001" "libcurl 7.5" "libcurl Manual"
 .SH NAME
 curl_formfree - free a previously build multipart/formdata HTTP POST chain
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
 .BI "void curl_formfree(struct HttpPost *" form);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_formparse.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_formparse.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_formparse.3	2001-02-08 16:14:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_formparse.3	2001-03-05 23:35:30.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_formparse 3 "8 February 2001" "Curl 7.0" "libcurl Manual"
+.TH curl_formparse 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
 .SH NAME
 curl_formparse - add a section to a multipart/formdata HTTP POST
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
 .BI "CURLcode curl_formparse(char *" string, "struct HttpPost **" firstitem,
@@ -39,20 +39,20 @@
 .TP
 .B [name]=@[filename1,filename2,...]
 Add a form field named 'name' with the contents as read from the local files
 named 'filename1' and 'filename2'. This is identical to the upper, except that
 you get the contents of several files in one section.
 .TP
-.B [name]=@[filename];[content-type]
+.B [name]=@[filename];[type=<content-type>]
 Whenever you specify a file to read from, you can optionally specify the
 content-type as well. The content-type is passed to the server together with
 the contents of the file. curl_formparse() will guess content-type for a
 number of well-known extensions and otherwise it will set it to binary. You
 can override the internal decision by using this option.
 .TP
-.B [name]=@[filename1,filename2,...];[content-type]
+.B [name]=@[filename1,filename2,...];[type=<content-type>]
 When you specify several files to read the contents from, you can set the
 content-type for all of them in the same way as with a single file.
 .PP
 .SH RETURN VALUE
 Returns non-zero if an error occurs.
 .SH "SEE ALSO"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_getdate.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_getdate.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_getdate.3	2000-06-20 23:34:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_getdate.3	2001-03-05 23:35:07.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_getdate 3 "2 June 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_getdate 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
 .SH NAME
 curl_getdate - Convert an date in a ASCII string to number of seconds since
 January 1, 1970
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_getenv.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_getenv.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_getenv.3	2000-06-20 23:34:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_getenv.3	2001-03-05 23:35:19.000000000 +0800
@@ -1,11 +1,11 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_getenv 3 "2 June 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_getenv 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
 .SH NAME
 curl_getenv - return value for environment name
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
 .BI "char *curl_getenv(char *" name ");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_slist_append.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_slist_append.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_slist_append.3	2000-06-20 23:34:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_slist_append.3	2001-03-05 23:37:18.000000000 +0800
@@ -1,18 +1,18 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_slist_append 3 "2 June 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_slist_append 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
 .SH NAME
 curl_slist_append - add a string to an slist
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
 .BI "struct curl_slist *curl_slist_append(struct curl_slit *" list,
-.BI "char * "string ");"
+.BI "const char * "string ");"
 .ad
 .SH DESCRIPTION
 curl_slist_append() appends a specified string to a linked list of
 strings. The existing
 .I list
 should be passed as the first argument while the new list is returned from
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_slist_free_all.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_slist_free_all.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_slist_free_all.3	2000-06-20 23:34:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_slist_free_all.3	2001-03-05 23:42:08.000000000 +0800
@@ -1,17 +1,17 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_slist_free_all 3 "2 June 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_slist_free_all 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
 .SH NAME
 curl_slist_free_all - free an entire curl_slist list
 .SH SYNOPSIS
 .B #include <curl/curl.h>
 .sp
-.BI "void curl_slist_free_all(struct curl_slit *" list);
+.BI "void curl_slist_free_all(struct curl_slist *" list);
 .ad
 .SH DESCRIPTION
 curl_slist_free_all() removes all traces of a previously built curl_slist
 linked list.
 .SH RETURN VALUE
 Nothing.
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs: curl_unescape.3
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_version.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_version.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/curl_version.3	2000-06-20 23:34:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/curl_version.3	2001-03-05 23:37:02.000000000 +0800
@@ -1,25 +1,25 @@
 .\" You can view this file with:
 .\" nroff -man [file]
 .\" Written by daniel@haxx.se
 .\"
-.TH curl_version 3 "2 June 2000" "Curl 7.0" "libcurl Manual"
+.TH curl_version 3 "5 March 2001" "libcurl 7.0" "libcurl Manual"
 .SH NAME
 curl_version - returns the libcurl version string
 .SH SYNOPSIS
-.B #include <curl/easy.h>
+.B #include <curl/curl.h>
 .sp
 .BI "char *curl_version( );"
 .ad
 .SH DESCRIPTION
 Returns a human readable string with the version number of libcurl and some of
 its important components (like OpenSSL version).
 
-Do note that this returns the actual running lib's version, you might have
-installed a newer lib's include files in your system which may turn your
-LIBCURL_VERSION #define value to differ from this result.
+Note: this returns the actual running lib's version, you might have installed
+a newer lib's include files in your system which may turn your LIBCURL_VERSION
+#define value to differ from this result.
 .SH RETURN VALUE
 A pointer to a zero terminated string.
 .SH "SEE ALSO"
 The
 .I LIBCURL_VERSION
 #define in <curl/curl.h>
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/examples/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/examples/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/examples/Makefile.am	2001-02-08 16:26:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/examples/Makefile.am	2001-03-06 00:56:10.000000000 +0800
@@ -1,11 +1,13 @@
 #
-# $Id: Makefile.am,v 1.2 2001/02/08 08:26:54 bagder Exp $
+# $Id: Makefile.am,v 1.5 2001/03/05 16:56:10 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 EXTRA_DIST = 
-	README curlgtk.c sepheaders.c simple.c postit.c
+	README curlgtk.c sepheaders.c simple.c postit.c \
+	win32sockets.c persistant.c \
+	getpageinvar.php simpleget.php simplepost.php
 
 all:
 	@echo "done"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/examples/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/examples/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/examples/Makefile.in	2001-02-13 21:35:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/examples/Makefile.in	2001-03-22 23:42:55.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.2 2001/02/08 08:26:54 bagder Exp $
+# $Id: Makefile.am,v 1.5 2001/03/05 16:56:10 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -70,12 +70,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
@@ -176,13 +177,15 @@
 installcheck-am installcheck install-exec-am install-exec \
 install-data-am install-data install-am install uninstall-am uninstall \
 all-redirect all-am all installdirs mostlyclean-generic \
 distclean-generic clean-generic maintainer-clean-generic clean \
 mostlyclean distclean maintainer-clean
 
-	README curlgtk.c sepheaders.c simple.c postit.c
+	README curlgtk.c sepheaders.c simple.c postit.c \
+	win32sockets.c persistant.c \
+	getpageinvar.php simpleget.php simplepost.php
 
 all:
 	@echo "done"
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/examples/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/examples/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/examples/README	2000-09-20 19:14:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/examples/README	2001-03-16 21:43:28.000000000 +0800
@@ -3,6 +3,8 @@
 This directory is for tiny libcurl programming examples. They are meant to
 show some simple steps on how you can build your own application to take full
 advantage of libcurl.
 
 If you end up with other small but still useful example sources, please mail
 them for submission in future packages and on the web site.
+
+Try the php/examples/ directory for PHP programming snippets!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/FAQ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/FAQ
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/FAQ	2001-02-12 16:54:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/FAQ	2001-03-22 19:22:58.000000000 +0800
@@ -1,7 +1,7 @@
-Updated: February 12, 2001 (http://curl.haxx.se/docs/faq.shtml)
+Updated: March 22, 2001 (http://curl.haxx.se/docs/faq.shtml)
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
@@ -28,13 +28,13 @@
   3.4 How do I tell curl to run custom FTP commands?
   3.5 How can I disable the Pragma: nocache header?
   3.6 Does curl support javascript, ASP, XML, XHTML or HTML version Y?
   3.7 Can I use curl to delete/rename a file through FTP?
   3.8 How do I tell curl to follow HTTP redirects?
   3.9 How do I use curl in PHP?
-  3.10 What about SOAP, WEBDAV, XML-RPC or similar protocols over HTTP?
+  3.10 What about SOAP, WebDAV, XML-RPC or similar protocols over HTTP?
 
  4. Running Problems
   4.1 Problems connecting to SSL servers.
   4.2 Why do I get problems when I use & or % in the URL?
   4.3 How can I use {, }, [ or ] to specify multiple URLs?
   4.4 Why do I get downloaded data even though the web page doesn't exist?
@@ -76,13 +76,14 @@
   with URL spelled in uppercase to make it obvious it deals with URLs. The
   fact it can also be pronounced 'see URL' also helped.
 
   Curl supports a range of common internet protocols, currently including
   HTTP, HTTPS, FTP, GOPHER, LDAP, DICT, TELNET and FILE.
 
-  We spell it cURL or just curl.
+  We spell it cURL or just curl. We pronounce it with an initial k sound:
+  [kurl].
 
   1.2 What is libcurl?
 
   libcurl is a reliable, higly portable multiprotocol file transfer library.
 
   Any application is free to use libcurl, even commercial or closed-source
@@ -109,35 +110,36 @@
   Curl is not a single-OS program. Curl exists, compiles, builds and runs
   under a wide range of operating systems, including all modern Unixes (and a
   bunch of older ones too), Windows, Amiga, BeOS, OS/2, OS X, QNX etc.
 
   1.4 When will you make curl do XXXX ?
 
-  I love suggestions of what to change in order to make curl and libcurl
-  better. I do however believe in a few rules when it comes to the future of
+  We love suggestions of what to change in order to make curl and libcurl
+  better. We do however believe in a few rules when it comes to the future of
   curl:
 
-  * It is to remain a command line tool. If you want GUIs or fancy scripting
+  * Curl is to remain a command line tool. If you want GUIs or fancy scripting
     capabilities, you're free to write another tool that uses libcurl and that
-    offers this. There's no point in having one single tool that does every
+    offers this. There's no point in having a single tool that does every
     imaginable thing. That's also one of the great advantages of having the
-    core of curl as a library: libcurl.
+    core of curl as a library.
 
-  * I do not add things to curl that other small and available tools already
+  * We do not add things to curl that other small and available tools already
     do very fine at the side. Curl's output is fine to pipe into another
     program or redirect to another file for the next program to interpret.
 
-  * I focus on protocol related issues and improvements. If you wanna do more
+  * We focus on protocol related issues and improvements. If you wanna do more
     magic with the supported protocols than curl currently does, chances are
     big I will agree. If you wanna add more protocols, I may very well
     agree.
 
-  * If you want me to make all the work while you wait for me to implement it
-    for you, that is not a very friendly attitude. I spend a considerable time
-    already on maintaining and developing curl. In order to get more out of
-    me, I trust you will offer some of your time and efforts in return.
+  * If you want someone else to make all the work while you wait for us to
+    implement it for you, that is not a very friendly attitude. We spend a
+    considerable time already on maintaining and developing curl. In order to
+    get more out of us, you should consider trading in some of your time and
+    efforts in return.
 
   * If you write the code, chances are bigger that it will get into curl
     faster.
 
 2. Install Related Problems
 
@@ -179,32 +181,30 @@
     See the INSTALL file section that explains how to add those libs to
     configure. Make sure that you remove the config.cache file before you
     rerun configure with the new flags.
 
   2.2. Does curl work/build with other SSL libraries?
 
-  Curl has been written to use OpenSSL, although I doubt there would be much
-  problems using a different library. I just don't know any other free one and
-  that has limited my possibilities to develop against anything else.
-
-  If anyone does "port" curl to use a commercial SSL library, I am of course
-  very interested in getting the patch!
+  Curl has been written to use OpenSSL, although there should not be much
+  problems using a different library. If anyone does "port" curl to use a
+  different SSL library, we are of course very interested in getting the
+  patch!
 
   2.3. Where can I find a copy of LIBEAY32.DLL?
 
   That is an OpenSSL binary built for Windows.
 
   Curl uses OpenSSL to do the SSL stuff. The LIBEAY32.DLL is what curl needs
-  on a windows machine to do https://. Check out the curl web page to find
+  on a windows machine to do https://. Check out the curl web site to find
   accurate and up-to-date pointers to recent OpenSSL DDLs and other binary
   packages.
 
   2.4. Does cURL support Socks (RFC 1928) ?
 
-  No. Nobody has wanted it that badly yet. I would appriciate patches that
-  brings this functionality.
+  No. Nobody has wanted it that badly yet. We appriciate patches that bring
+  this functionality.
 
 
 3. Usage problems
 
   3.1. curl: (1) SSL is disabled, https: not supported
 
@@ -220,28 +220,28 @@
 
   Also, check out the other paragraph in this FAQ labeled "configure doesn't
   find OpenSSL even when it is installed".
 
   3.2. How do I tell curl to resume a transfer?
 
-  Curl supports resume both ways on FTP, download ways on HTTP.
+  Curl supports resumed transfers both ways on both FTP and HTTP.
 
   Try the -C option.
 
   3.3. Why doesn't my posting using -F work?
 
   You can't simply use -F or -d at your choice. The web server that will
   receive your post assumes one of the formats. If the form you're trying to
   "fake" sets the type to 'multipart/form-data', then and only then you must
   use the -F type. In all the most common cases, you should use -d which then
   causes a posting with the type 'application/x-www-form-urlencoded'.
 
-  I have described this in some detail in the README.curl file, and if you
-  don't understand it the first time, read it again before you post questions
-  about this to the mailing list. I would also suggest that you read through
-  the mailing list archives for old postings and questions regarding this.
+  This is described in some detail in the README.curl file, and if you don't
+  understand it the first time, read it again before you post questions about
+  this to the mailing list. Also, try reading through the mailing list
+  archives for old postings and questions regarding this.
 
   3.4. How do I tell curl to run custom FTP commands?
 
   You can tell curl to perform optional commands both before and/or after a
   file transfer. Study the -Q/--quote option.
 
@@ -292,13 +292,13 @@
         http://www.php.net/manual/ref.curl.php
 
   PHP also offers the option to run a command line, and then you can of course
   invoke the curl tool using a command line. This is the way to use curl if
   you're using PHP3 or PHP4 built without curl module support.
 
-  3.10 What about SOAP, WEBDAV, XML-RPC or similar protocols over HTTP?
+  3.10 What about SOAP, WebDAV, XML-RPC or similar protocols over HTTP?
 
   Curl adheres to the HTTP spec, which basically means you can play with *any*
   protocol that is built ontop of HTTP. Protocols such as SOAP, WEBDAV and
   XML-RPC are all such ones. You can use -X to set custom requests and -H to
   set custom headers (or replace internally generated ones).
 
@@ -306,28 +306,28 @@
   proper library options to do the same.
 
 4. Running Problems
 
   4.1. Problems connecting to SSL servers.
 
-  It took a very long time before I could sort out why curl had problems
-  to connect to certain SSL servers when using SSLeay or OpenSSL v0.9+.
-  The error sometimes showed up similar to:
+  It took a very long time before we could sort out why curl had problems to
+  connect to certain SSL servers when using SSLeay or OpenSSL v0.9+.  The
+  error sometimes showed up similar to:
 
   16570:error:1407D071:SSL routines:SSL2_READ:bad mac decode:s2_pkt.c:233:
 
   It turned out to be because many older SSL servers don't deal with SSLv3
   requests properly. To correct this problem, tell curl to select SSLv2 from
   the command line (-2/--sslv2).
 
-  I have also seen examples where the remote server didn't like the SSLv2
+  There has also been examples where the remote server didn't like the SSLv2
   request and instead you had to force curl to use SSLv3 with -3/--sslv3.
 
   4.2. Why do I get problems when I use & or % in the URL?
 
-  In general unix shells, the & letter is treated special and when used it
+  In general unix shells, the & letter is treated special and when used, it
   runs the specified command in the background. To safely send the & as a part
   of a URL, you should qoute the entire URL by using single (') or double (")
   quotes around it.
 
   An example that would invoke a remote CGI that uses &-letters could be:
 
@@ -346,14 +346,14 @@
 
   An example that downloads two URLs (sequentially) would do:
 
     curl '{curl,www}.haxx.se'
 
   To be able to use those letters as actual parts of the URL (without using
-  them for the curl URL "globbing" system), use the -g/--globoff option
-  (included in curl 7.6 and later):
+  them for the curl URL "globbing" system), use the -g/--globoff option (curl
+  7.6 and later):
 
     curl -g 'www.site.com/weirdname[].html'
 
   4.4. Why do I get downloaded data even though the web page doesn't exist?
 
   Curl asks remote servers for the page you specify. If the page doesn't exist
@@ -363,14 +363,14 @@
 
   By using the --fail option you can tell curl explicitly to not get any data
   if the HTTP return code doesn't say success.
 
   4.5 Why do I get return code XXX from a HTTP server?
 
-  RFC2616 clearly explains the return codes. I'll make a short transcript
-  here. Go read the RFC for exact details:
+  RFC2616 clearly explains the return codes. This is a short transcript. Go
+  read the RFC for exact details:
 
     4.5.1 "400 Bad Request"
 
     The request could not be understood by the server due to malformed
     syntax. The client SHOULD NOT repeat the request without modifications.
 
@@ -400,13 +400,13 @@
   that curl has existed due to a timeout. There was no nice way for curl to
   abort from such a condition and that's why it got this undocumented
   error. This should not occur in releases after 7.4.1.
 
   4.7. How do I keep usernames and passwords secret in Curl command lines?
 
-  I see this problem as two parts:
+  This problem has two sides:
 
   The first part is to avoid having clear-text passwords in the command line
   so that they don't appear in 'ps' outputs and similar. That is easily
   avoided by using the "-K" option tho tell curl to read parameters from a
   file or stdin to which you can pass the secret info.
 
@@ -447,15 +447,14 @@
   Yes.
 
   We have written the libcurl code specificly adjusted for multi-threaded
   programs. libcurl will use thread-safe functions instead of non-safe ones if
   your system has such.
 
-  I am very interested in once and for all getting some kind of report or
-  README file from those who have used libcurl in a threaded environment,
-  since I haven't and I get this question more and more frequently!
+  We would appriciate some kind of report or README file from those who have
+  used libcurl in a threaded environment.
 
   5.2 How can I receive all data into a large memory chunk?
 
   You are in full control of the callback function that gets called every time
   there is data received from the remote server. You can make that callback do
   whatever you want. You do not have to write the receivied data to a file.
@@ -486,15 +485,22 @@
           }
           return realsize;
         }
 
   5.3 How do I fetch multiple files with libcurl?
 
-  The easy interface of libcurl does not support multiple requests using the
-  same connection. The only available way to do multiple requests is to
-  init/perform/cleanup for each request.
+  Starting with version 7.7, curl and libcurl will have excellent support for
+  transferring multiple files. You should just repeatedly set new URLs with
+  curl_easy_setopt() and then transfer it with curl_easy_perform(). The handle
+  you get from curl_easy_init() is not only reusable starting with libcurl
+  7.7, but also you're encouraged to reuse it if you can, as that will enable
+  libcurl to use persistant connections.
+
+  For libcurl prior to 7.7, there was no multiple file support. The only
+  available way to do multiple requests was to init/perform/cleanup for each
+  transfer.
 
   5.4 Does libcurl do Winsock initing on win32 systems?
 
   No.
 
   On win32 systems, you need to init the winsock stuff manually, libcurl will
@@ -512,23 +518,22 @@
   CURLOPT_INFILE you must also specify CURLOPT_READFUNCTION.
 
   (Provided by Joel DeYoung and Bob Schader)
 
   5.6 What about Keep-Alive or persistant connections?
 
-  This is closely related to issue 5.3. Since libcurl has no real support
-  for doing multiple file transfers, there's no support for Keep-Alive or
-  persistant connections either.
+  Starting with version 7.7, curl and libcurl will have excellent support for
+  persistant connections when transferring several files from the same server.
+  Curl will attempt to reuse connections for all URLs specified on the same
+  command line/config file, and libcurl will reuse connections for all
+  transfers that are made using the same libcurl handle.
 
-  This is of course subject to change as soon as libcurl gets support for
-  multiple files. Feel free to join in and make this change happen sooner!
+  Previous versions had no persistant connection support.
 
 6. License Issues
 
-  NOTE: This section concerns curl 7.5.2 or later!
-
   Curl and libcurl are released under a MIT/X derivate license *or* the MPL,
   the Mozilla Public License. To get a really good answer to your license
   conflict questions, you should study the MPL and MIT/X licenses and the
   license you are about to use and check for clashes yourself. This section is
   just a brief summary for the cases we get the most questions. (Parts of this
   section was much enhanced by Bjorn Reese.)
@@ -567,12 +572,13 @@
   left intact.
 
   6.6. Can you please change the curl/libcurl license to XXXX?
 
   No.
 
-  We carefully picked this license years ago and a large amount of people have
-  contributed with source code knowing that this is the license we use. This
-  license puts the restrictions we want on curl/libcurl and it does not spread
-  to other programs or libraries that use it. The recent dual license
-  modification should make it possible for everyone to use libcurl or curl in
-  their projects, no matter what license they already have in use.
+  We have carefully picked this license after years of development and
+  discussions and a large amount of people have contributed with source code
+  knowing that this is the license we use. This license puts the restrictions
+  we want on curl/libcurl and it does not spread to other programs or
+  libraries that use it. The recent dual license modification should make it
+  possible for everyone to use libcurl or curl in their projects, no matter
+  what license they already have in use.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/FEATURES /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/FEATURES
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/FEATURES	2000-12-11 23:34:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/FEATURES	2001-03-13 20:35:42.000000000 +0800
@@ -14,24 +14,27 @@
  - multiple URLs
  - guesses protocol from host name unless specified
  - uses .netrc
  - progress bar/time specs while downloading
  - "standard" proxy environment variables support
  - config file support
- - compiles on win32
+ - compiles on win32 (reported built on 29 operating systems)
  - redirectable stderr
  - use selected network interface for outgoing traffic
+ - IPv6 support
+ - persistant connections
 
 HTTP
+ - HTTP/1.1 compliant
  - GET
  - PUT
  - HEAD
  - POST
  - multipart POST
  - authentication
- - resume
+ - resume (both GET and PUT)
  - follow redirects
  - maximum amount of redirects to follow
  - custom HTTP request
  - cookie get/send fully parsed
  - understands the netscape cookie file format
  - custom headers (that can replace/remove internally generated headers)
@@ -68,12 +71,13 @@
  - via http-proxy
  - all operations can be tunneled through a http-proxy
  - customizable to retrieve file modification date
 
 TELNET
  - connection negotiation
+ - custom telnet options
  - stdin/stdout I/O
 
 LDAP (*2)
  - full LDAP URL support
 
 DICT
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/INSTALL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/INSTALL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/INSTALL	2001-02-05 17:36:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/INSTALL	2001-03-16 18:53:04.000000000 +0800
@@ -7,27 +7,38 @@
                                 How To Compile
 
 Curl has been compiled and built on numerous different operating systems. The
 way to proceed is mainly divided in two different ways: the unix way or the
 windows way.
 
-If you're using Windows (95, 98, NT) or OS/2, you should continue reading from
-the Win32 or OS/2 headers further down. All other systems should be capable of
-being installed as described below.
+If you're using Windows (95/98/NT/ME/2000 or whatever) or OS/2, you should
+continue reading from the Win32 or OS/2 headers further down. All other
+systems should be capable of being installed as described below.
 
 UNIX
 ====
 
-   The configure script *always* tries to find a working SSL library unless
-   explicitly told not to.  If you have OpenSSL installed in the default
-   search path for your compiler/linker, you don't need to do anything
-   special:
+   A normal unix installation is made in three or four steps (after you've
+   unpacked the source archive):
 
         ./configure
+        make
+        make test (optional)
+        make install
 
-   If you have OpenSSL installed in /usr/local/ssl, you can run configure
+   You probably need to be root when doing the last command.
+
+   If you want to install curl in a different file hierarchy than /usr/local,
+   you need to specify that already when running configure:
+
+        ./configure --prefix=/path/to/curl/tree
+
+   The configure script always tries to find a working SSL library unless
+   explicitly told not to. If you have OpenSSL installed in the default search
+   path for your compiler/linker, you don't need to do anything special. If
+   you have OpenSSL installed in e.g /usr/local/ssl, you can run configure
    like:
 
 	./configure --with-ssl
 
    If you have OpenSSL installed somewhere else (for example, /opt/OpenSSL,)
    you can run configure like this:
@@ -51,39 +62,17 @@
 
      (with csh, tcsh and their clones):
      
        env CPPFLAGS="-I/path/to/ssl/include" LDFLAGS="-L/path/to/ssl/lib" \
        ./configure
 
-   If your SSL library was compiled with rsaref (usually for use in
-   the United States), you may also need to set:
+   If your SSL library was compiled with rsaref (usually for use in the United
+   States), you may also need to set:
 
      LIBS=-lRSAglue -lrsaref
-     (from Doug Kaufman <dkaufman@rahul.net>)
-
-   Without SSL support, just run:
-
-     ./configure
-
-   Then run:
-
-     make
-
-   Use the executable `curl` in src/ directory.
-
-   To install curl on your system, run
-
-     make install
-
-   This will copy curl to /usr/local/bin/ (or $prefix/bin if you used the
-   --prefix option to configure) and it copies the man pages, the lib and the
-   include files to suitable places.
-
-   To make sure everything runs as supposed, run the test suite:
-
-     make test
+     (as suggested by Doug Kaufman)
 
    KNOWN PROBLEMS
 
      If you happen to have autoconf installed, but a version older than 2.12
      you will get into trouble. Then you can still build curl by issuing these
      commands (note that this requires curl to be built staticly): (from Ralph
@@ -106,13 +95,13 @@
        ----end of autoconf----
 
      Then make autoheader a symbolic link to the same script and make sure
      they're executable and set to appear in the path *BEFORE* the actual (but
      obsolete) autoconf and autoheader scripts.
 
-   OPTIONS
+   MORE OPTIONS
 
      Remember, to force configure to use the standard cc compiler if both
      cc and gcc are present, run configure like
 
        CC=cc ./configure
          or
@@ -153,35 +142,33 @@
  
    Without SSL:
 
       MingW32 (GCC-2.95) style
       ------------------------
         Run the 'mingw32.bat' file to get the proper environment variables
-        set, then run 'make -f Makefile.m32' in the lib/ dir and then
-        'make -f Makefile.m32' in the src/ dir.
+        set, then run 'make mingw32' in the root dir.
 
-        If you have any problems linking libraries or finding header files,
-        be sure to look at the provided "Makefile.m32" files for the proper
+        If you have any problems linking libraries or finding header files, be
+        sure to verify that the provided "Makefile.m32" files use the proper
         paths, and adjust as necessary.
 
       Cygwin style
       ------------
-        Almost identical to the unix installation. Run the configure script
-        in the curl root with 'sh configure'. Make sure you have the sh
-        executable in /bin/ or you'll see the configure fail towards the
-        end.
+        Almost identical to the unix installation. Run the configure script in
+        the curl root with 'sh configure'. Make sure you have the sh
+        executable in /bin/ or you'll see the configure fail towards the end.
 
         Run 'make'
 
       Microsoft command line style
       ----------------------------
         Run the 'vcvars32.bat' file to get the proper environment variables
-        set, then run 'nmake -f Makefile.vc6' in the lib/ dir and then
-        'nmake -f Makefile.vc6' in the src/ dir.
+        set, then run 'nmake vc' in the root dir.
 
-        The vcvars32.bat file is part of the Microsoft development environment.
+        The vcvars32.bat file is part of the Microsoft development
+        environment.
 
       IDE-style
       -------------------------
         If you use VC++, Borland or similar compilers. Include all lib source
         files in a static lib "project" (all .c and .h files that is).
         (you should name it libcurl or similar)
@@ -203,22 +190,20 @@
 
    With SSL:
 
       MingW32 (GCC-2.95) style
       ------------------------
         Run the 'mingw32.bat' file to get the proper environment variables
-        set, then run 'make -f Makefile.m32 SSL=1' in the lib/ dir and then
-        'make -f Makefile.m32 SSL=1' in the src/ dir.
+        set, then run 'make mingw32-ssl' in the root dir.
 
-        If you have any problems linking libraries or finding header files,
-        be sure to look at the provided "Makefile.m32" files for the proper
+        If you have any problems linking libraries or finding header files, be
+        sure to look at the provided "Makefile.m32" files for the proper
         paths, and adjust as necessary.
 
       Cygwin style
       ------------
-
         Haven't done, nor got any reports on how to do. It should although be
         identical to the unix setup for the same purpose. See above.
 
       Microsoft command line style
       ----------------------------
         Run the 'vcvars32.bat' file to get the proper environment variables
@@ -219,16 +204,16 @@
         Haven't done, nor got any reports on how to do. It should although be
         identical to the unix setup for the same purpose. See above.
 
       Microsoft command line style
       ----------------------------
         Run the 'vcvars32.bat' file to get the proper environment variables
-        set, then run 'nmake -f Makefile.vc6 release-ssl' in the lib/ dir and
-        then 'nmake -f Makefile.vc6' in the src/ dir.
+        set, then run 'nmake vc-ssl' in the root dir.
 
-        The vcvars32.bat file is part of the Microsoft development environment.
+        The vcvars32.bat file is part of the Microsoft development
+        environment.
 
       Microsoft / Borland style
       -------------------------
         If you have OpenSSL, and want curl to take advantage of it, edit your
         project properties to use the SSL include path, link with the SSL libs
         and define the USE_SSLEAY symbol.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/INTERNALS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/INTERNALS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/INTERNALS	2001-01-26 16:22:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/INTERNALS	2001-03-13 23:42:51.000000000 +0800
@@ -1,20 +1,20 @@
-                                     Updated for curl 7.6 on January 26, 2001
+                                       Updated for curl 7.7 on March 13, 2001
                                   _   _ ____  _     
                               ___| | | |  _ \| |    
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
 INTERNALS
 
- The project is kind of split in two. The library and the client. The client
- part uses the library, but the library is meant to be designed to allow other
- applications to use it.
+ The project is split in two. The library and the client. The client part uses
+ the library, but the library is designed to allow other applications to use
+ it.
 
- Thus, the largest amount of code and complexity is in the library part.
+ The largest amount of code and complexity is in the library part.
 
 CVS
 ===
  All changes to the sources are committed to the CVS repository as soon as
  they're somewhat verified to work. Changes shall be commited as independently
  as possible so that individual changes can be easier spotted and tracked
@@ -32,47 +32,41 @@
  1. Different function names for socket operations.
 
    In curl, this is solved with defines and macros, so that the source looks
    the same at all places except for the header file that defines them. The
    macros in use are sclose(), sread() and swrite().
 
- 2. Windows requires a couple of init calls for the socket stuff
+ 2. Windows requires a couple of init calls for the socket stuff.
 
    Those must be made by the application that uses libcurl, in curl that means
    src/main.c has some code #ifdef'ed to do just that.
 
  3. The file descriptors for network communication and file operations are
-    not easily interchangable as in unix
+    not easily interchangable as in unix.
 
    We avoid this by not trying any funny tricks on file descriptors.
 
  4. When writing data to stdout, Windows makes end-of-lines the DOS way, thus
     destroying binary data, although you do want that conversion if it is
     text coming through... (sigh)
 
    We set stdout to binary under windows
 
- Inside the source code, I do make an effort to avoid '#ifdef WIN32'. All
+ Inside the source code, We make an effort to avoid '#ifdef [Your OS]'. All
  conditionals that deal with features *should* instead be in the format
  '#ifdef HAVE_THAT_WEIRD_FUNCTION'. Since Windows can't run configure scripts,
- I maintain two config-win32.h files (one in / and one in src/) that are
+ we maintain two config-win32.h files (one in / and one in src/) that are
  supposed to look exactly as a config.h file would have looked like on a
  Windows machine!
 
  Generally speaking: always remember that this will be compiled on dozens of
  operating systems. Don't walk on the edge.
 
 Library
 =======
 
- As described elsewhere, libcurl is meant to get two different "layers" of
- interfaces. At the present point only the high-level, the "easy", interface
- has been fully implemented and documented. We assume the easy-interface in
- this description, the low-level interface will be documented when fully
- implemented.
-
  There are plenty of entry points to the library, namely each publicly defined
  function that libcurl offers to applications. All of those functions are
  rather small and easy-to-follow. All the ones prefixed with 'curl_easy' are
  put in the lib/easy.c file.
 
  All printf()-style functions use the supplied clones in lib/mprintf.c. This
@@ -100,23 +94,40 @@
 
  The protocol-specific functions of course deal with protocol-specific
  negotiations and setup. They have access to the Curl_sendf() (from
  lib/sendf.c) function to send printf-style formatted data to the remote host
  and when they're ready to make the actual file transfer they call the
  Curl_Transfer() function (in lib/transfer.c) to setup the transfer and
- returns. curl_transfer() then calls _Tranfer() in lib/transfer.c that
- performs the entire file transfer.
+ returns. Curl_perform() then calls Transfer() in lib/transfer.c that performs
+ the entire file transfer. Curl_perform() is what does the main "connect - do
+ - transfer - done" loop. It loops if there's a Location: to follow.
 
  During transfer, the progress functions in lib/progress.c are called at a
  frequent interval (or at the user's choice, a specified callback might get
  called). The speedcheck functions in lib/speedcheck.c are also used to verify
  that the transfer is as fast as required.
 
  When completed, the curl_easy_cleanup() should be called to free up used
  resources.
 
+ A quick roundup on internal function sequences (many of these call
+ protocol-specific function-pointers):
+
+  curl_connect - connects to a remote site and does initial connect fluff
+   This also checks for an existing connection to the requested site and uses
+   that one if it is possible.
+
+   curl_do - starts a transfer
+    curl_transfer() - transfers data
+   curl_done - ends a transfer
+
+  curl_disconnect - disconnects from a remote site. This is called when the
+   disconnect is really requested, which doesn't necessarily have to be
+   exactly after curl_done in case we want to keep the connection open for
+   a while.
+
  HTTP(S)
 
  HTTP offers a lot and is the protocol in curl that uses the most lines of
  code. There is a special file (lib/formdata.c) that offers all the multipart
  post functions.
 
@@ -126,12 +137,20 @@
  HTTPS uses in almost every means the same procedure as HTTP, with only two
  exceptions: the connect procedure is different and the function used to read
  or write from the socket is different, although the latter fact is hidden in
  the source by the use of curl_read() for reading and curl_write() for writing
  data to the remote server.
 
+ http_chunks.c contains functions that understands HTTP 1.1 chunked transfer
+ encoding.
+
+ An interesting detail with the HTTP(S) request, is the add_buffer() series of
+ functions we use. They append data to one single buffer, and when the
+ building is done the entire request is sent off in one single write. This is
+ done this way to overcome problems with flawed firewalls and lame servers.
+
  FTP
 
  The Curl_if2ip() function can be used for getting the IP number of a
  specified network interface, and it resides in lib/if2ip.c.
 
  Curl_ftpsendf() is used for sending FTP commands to the remote server. It was
@@ -157,13 +176,13 @@
 
  GENERAL
 
  URL encoding and decoding, called escaping and unescaping in the source code,
  is found in lib/escape.c.
 
- While transfering data in _Transfer() a few functions might get
+ While transfering data in Transfer() a few functions might get
  used. curl_getdate() in lib/getdate.c is for HTTP date comparisons (and
  more).
 
  lib/getenv.c offers curl_getenv() which is for reading environment variables
  in a neat platform independent way. That's used in the client, but also in
  lib/url.c when checking the proxy environment variables. Note that contrary
@@ -179,12 +198,40 @@
  found in lib/version.c.
 
  If authentication is requested but no password is given, a getpass_r() clone
  exists in lib/getpass.c. libcurl offers a custom callback that can be used
  instead of this, but it doesn't change much to us.
 
+Persistant Connections
+======================
+
+ With curl 7.7, we added persistant connection support to libcurl which has
+ introduced a somewhat different treatmeant of things inside of libcurl.
+
+ o The 'UrlData' struct returned in the curl_easy_init() call must never
+   hold connection-oriented data. It is meant to hold the root data as well
+   as all the options etc that the library-user may choose.
+ o The 'UrlData' struct holds the cache array of pointers to 'connectdata'
+   structs. There's one connectdata struct for each connection that libcurl
+   knows about.
+ o This also enables the 'curl handle' to be reused on subsequent transfers,
+   something that was illegal in pre-7.7 versions.
+ o When we are about to perform a transfer with curl_easy_perform(), we first
+   check for an already existing connection in the cache that we can use,
+   otherwise we create a new one and add to the cache. If the cache is full
+   already when we add a new connection, we close one of the present ones. We
+   select which one to close dependent on the close policy that may have been
+   previously set.
+ o When the tranfer operation is complete, we try to leave the connection open.
+   Particular options may tell us not to, and protocols may signal closure on
+   connections and then we don't keep it open of course.
+ o When curl_easy_cleanup() is called, we close all still opened connections.
+
+ You do realize that the curl handle must be re-used in order for the
+ persistant connections to work.
+
 Library Symbols
 ===============
  
  All symbols used internally in libcurl must use a 'Curl_' prefix if they're
  used in more than a single file. Single-file symbols must be made
  static. Public (exported) symbols must use a 'curl_' prefix. (There are
@@ -233,18 +280,18 @@
 
  The file named lib/memdebug.c contains debug-versions of a few
  functions. Functions such as malloc, free, fopen, fclose, etc that somehow
  deal with resources that might give us problems if we "leak" them. The
  functions in the memdebug system do nothing fancy, they do their normal
  function and then log information about what they just did. The logged data
- is then analyzed after a complete session,
+ can then be analyzed after a complete session,
 
- memanalyze.pl is a perl script present only in CVS (not part of the release
- archives) that analyzes a log file generated by the memdebug system. It
- detects if resources are allocated but never freed and other kinds of errors
- related to resource management.
+ memanalyze.pl is a perl script present only present in CVS (not part of the
+ release archives) that analyzes a log file generated by the memdebug
+ system. It detects if resources are allocated but never freed and other kinds
+ of errors related to resource management.
 
  Use -DMALLOCDEBUG when compiling to enable memory debugging.
 
 Test Suite
 ==========
 
@@ -253,22 +300,23 @@
  a bunch of scripts and a lot of test case data.
 
  The main test script is runtests.pl that will invoke the two servers
  httpserver.pl and ftpserver.pl before all the test cases are performed. The
  test suite currently only runs on unix-like platforms.
 
- You'll find a complete description of the test case data files in the README
- file in the test directory.
+ You'll find a complete description of the test case data files in the
+ tests/README file.
 
  The test suite automatically detects if curl was built with the memory
  debugging enabled, and if it was it will detect memory leaks too.
 
 Building Releases
 =================
 
  There's no magic to this. When you consider everything stable enough to be
  released, run the 'maketgz' script (using 'make distcheck' will give you a
  pretty good view on the status of the current sources). maketgz prompts for
  version number of the client and the library before it creates a release
- archive.
+ archive. maketgz uses 'make dist' for the actual archive building, why you
+ need to fill in the Makefile.am files properly for which files that should
+ be included in the release archives.
 
- You must have autoconf installed to build release archives.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/LIBCURL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/LIBCURL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/LIBCURL	2000-06-14 22:08:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/LIBCURL	2001-03-13 20:35:43.000000000 +0800
@@ -1,61 +1,94 @@
                          _ _ _                     _ 
                         | (_) |__   ___ _   _ _ __| |
                         | | | '_ \ / __| | | | '__| |
                         | | | |_) | (__| |_| | |  | |
                         |_|_|_.__/ \___|\__,_|_|  |_|
 
+                   How To Use Libcurl In Your C/C++ Program
 
-                     How To Use Libcurl In Your Program
+ [ libcurl can be used directly from within your PHP or Perl programs as well,
+   look elsewhere for documentation on this ]
 
-Interfaces
-
- libcurl currently offers two different interfaces to the URL transfer
- engine. They can be seen as one low-level and one high-level, in the sense
- that the low-level one will allow you to deal with a lot more details but on
- the other hand not offer as many fancy features (such as Location:
- following). The high-level interface is supposed to be a built-in
- implementation of the low-level interface. You will not be able to mix
- function calls from the different layers.
-
- As we currently ONLY support the high-level interface, the so called easy
- interface, I will not attempt to describe any low-level functions at this
- point.
-
-Function descriptions
-
- The interface is meant to be very simple for very simple
- implementations. Thus, we have minimized the number of entries.
+ The interface is meant to be very simple for applictions/programmers, hence
+ the name "easy". We have therefore minimized the number of entries.
 
 The Easy Interface
 
- When using the easy interface, you init your easy-session and get a handle,
- which you use as input to the following interface functions you use.
+ When using the easy interface, you init your session and get a handle, which
+ you use as input to the following interface functions you use. Use
+ curl_easy_init() to get the handle.
 
  You continue by setting all the options you want in the upcoming transfer,
- most important among them is the URL itself. You might want to set some
- callbacks as well that will be called from the library when data is available
- etc.
-
- When all is setup, you tell libcurl to perform the transfer. It will then do
- the entire operation and won't return until it is done or failed.
-
- After the transfer has been made, you cleanup the easy-session's handle and
- libcurl is entirely off the hook!
-
-        curl_easy_init() 
-        curl_easy_setopt() 
-        curl_easy_perform() 
-        curl_easy_cleanup() 
-
- While the above four functions are the main functions to use in the easy
- interface, there is a series of helpful functions to use. They are:
-
-        curl_version()        - displays the libcurl version
-        curl_getdate()        - converts a date string to time_t
-        curl_getenv()         - portable environment variable reader
-        curl_formparse()      - helps building a HTTP form POST
-        curl_slist_append()   - builds a linked list
-        curl_slist_free_all() - frees a whole curl_slist
+ most important among them is the URL itself (you can't transfer anything
+ without a specified URL as you may have figured out yourself). You might want
+ to set some callbacks as well that will be called from the library when data
+ is available etc. curl_easy_setopt() is there for this.
+
+ When all is setup, you tell libcurl to perform the transfer using
+ curl_easy_perform(). It will then do the entire operation and won't return
+ until it is done or failed.
+
+ After the transfer has been made, you cleanup the session with
+ curl_easy_cleanup() and libcurl is entirely off the hook! If you want
+ persistant connections, you don't cleanup immediately, but instead run ahead
+ and perform other transfers. See the chapter below for Persistant
+ Connections.
+
+ While the above mentioned four functions are the main functions to use in the
+ easy interface, there is a series of other helpful functions to use. They
+ are:
+
+   curl_version()        - displays the libcurl version
+   curl_getdate()        - converts a date string to time_t
+   curl_getenv()         - portable environment variable reader
+   curl_easy_getinfo()   - get information about a performed transfer
+   curl_formparse()      - helps building a HTTP form POST
+   curl_formfree()       - free a list built with curl_formparse()
+   curl_slist_append()   - builds a linked list
+   curl_slist_free_all() - frees a whole curl_slist
+
+ For details on these, read the separate man pages.
+
+Portability
+
+ libcurl works *exactly* the same, on any of the platforms it compiles and
+ builds on.
+
+ There's only one caution, and that is the win32 platform that may(*) require
+ you to init the winsock stuff before you use the libcurl functions. Details
+ on this are noted on the curl_easy_init() man page.
+
+ (*) = it appears as if users of the cygwin environment get this done
+       automatically.
+
+Threads
+
+ Never *ever* call curl-functions simultaneously using the same handle from
+ several threads. libcurl is thread-safe and can be used in any number of
+ threads, but you must use separate curl handles if you want to use libcurl in
+ more than one thread simultaneously.
+
+Persistant Connections
+
+ With libcurl 7.7, persistant connections were added. Persistant connections
+ means that libcurl can re-use the same connection for several transfers, if
+ the conditions are right.
+
+ libcurl will *always* attempt to use persistant connections. Whenever you use
+ curl_easy_perform(), libcurl will attempt to use an existing connection to do
+ the transfer, and if none exists it'll open a new one that will be subject
+ for re-use on a possible following call to curl_easy_perform().
+
+ To allow libcurl to take full advantage of persistant connections, you should
+ do as many of your file transfers as possible using the same curl
+ handle. When you call curl_easy_cleanup(), all the possibly open connections
+ held by libcurl will be closed and forgotten.
+
+ Note that the options set with curl_easy_setopt() will be used in on every
+ repeat curl_easy_perform() call
+
+Compatibility with older libcurls
 
- Read the separate man pages for these functions for details!
+ Repeated curl_easy_perform() calls on the same handle were not supported in
+ pre-7.7 versions, and caused confusion and defined behaviour.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/Makefile.am	2001-01-08 21:39:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/Makefile.am	2001-03-22 19:22:09.000000000 +0800
@@ -1,8 +1,8 @@
 #
-# $Id: Makefile.am,v 1.4 2001/01/08 13:39:21 bagder Exp $
+# $Id: Makefile.am,v 1.5 2001/03/22 11:22:09 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 man_MANS = \
 	curl.1 \
@@ -14,13 +14,15 @@
 	curl_formparse.3 \
 	curl_formfree.3 \
 	curl_getdate.3 \
 	curl_getenv.3 \
 	curl_slist_append.3 \
 	curl_slist_free_all.3 \
-	curl_version.3
+	curl_version.3 \
+	curl_escape.3 \
+	curl_unescape.3
 
 EXTRA_DIST = $(man_MANS) \
 	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS \
 	LIBCURL README.win32 RESOURCES TODO TheArtOfHttpScripting
 
 SUBDIRS = examples
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/Makefile.in	2001-02-13 21:35:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/Makefile.in	2001-03-22 23:42:55.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.4 2001/01/08 13:39:21 bagder Exp $
+# $Id: Makefile.am,v 1.5 2001/03/22 11:22:09 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -70,19 +70,20 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
-man_MANS =  	curl.1 	curl_easy_cleanup.3 	curl_easy_getinfo.3 	curl_easy_init.3 	curl_easy_perform.3 	curl_easy_setopt.3 	curl_formparse.3 	curl_formfree.3 	curl_getdate.3 	curl_getenv.3 	curl_slist_append.3 	curl_slist_free_all.3 	curl_version.3
+man_MANS =  	curl.1 	curl_easy_cleanup.3 	curl_easy_getinfo.3 	curl_easy_init.3 	curl_easy_perform.3 	curl_easy_setopt.3 	curl_formparse.3 	curl_formfree.3 	curl_getdate.3 	curl_getenv.3 	curl_slist_append.3 	curl_slist_free_all.3 	curl_version.3 	curl_escape.3 	curl_unescape.3
 
 
 EXTRA_DIST = $(man_MANS) 	MANUAL BUGS CONTRIBUTE FAQ FEATURES INTERNALS 	LIBCURL README.win32 RESOURCES TODO TheArtOfHttpScripting
 
 
 SUBDIRS = examples
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/MANUAL /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/MANUAL
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/MANUAL	2001-02-06 17:59:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/MANUAL	2001-03-13 20:35:43.000000000 +0800
@@ -22,30 +22,38 @@
   Get a web page from a server using port 8000:
 
         curl http://www.weirdserver.com:8000/
 
   Get a list of the root directory of an FTP site:
 
-        curl ftp://ftp.fts.frontec.se/
+        curl ftp://cool.haxx.se/
 
   Get the definition of curl from a dictionary:
 
         curl dict://dict.org/m:curl
 
+  Fetch two documents at once:
+
+        curl ftp://cool.haxx.se/ http://www.weirdserver.com:8000/
+
 DOWNLOAD TO A FILE
 
   Get a web page and store in a local file:
 
         curl -o thatpage.html http://www.netscape.com/
 
   Get a web page and store in a local file, make the local file get the name
   of the remote document (if no file name part is specified in the URL, this
   will fail):
 
         curl -O http://www.netscape.com/index.html
 
+  Fetch two files and store them with their remote names:
+
+        curl -O www.haxx.se/index.html -O curl.haxx.se/download.html
+
 USING PASSWORDS
 
  FTP
 
    To ftp files using name+passwd, include them in the URL like:
 
@@ -452,15 +460,19 @@
 
   Example, send the header "X-you-and-me: yes" to the server when getting a
   page:
 
         curl -H "X-you-and-me: yes" www.love.com
 
-  This can also be useful in case you want curl to send a different text in
-  a header than it normally does. The -H header you specify then replaces the
-  header curl would normally send.
+  This can also be useful in case you want curl to send a different text in a
+  header than it normally does. The -H header you specify then replaces the
+  header curl would normally send. If you replace an internal header with an
+  empty one, you prevent that header from being sent. To prevent the Host:
+  header from being used:
+
+        curl -H "Host:" www.server.com
 
 FTP and PATH NAMES
 
   Do note that when getting files with the ftp:// URL, the given path is
   relative the directory you enter. To get the file 'README' from your home
   directory at your ftp site, do:
@@ -742,19 +754,44 @@
 
   NOTE: the telnet protocol does not specify any way to login with a specified
   user and password so curl can't do that automatically. To do that, you need
   to track when the login prompt is received and send the username and
   password accordingly.
 
-MAILING LIST
+PERSISTANT CONNECTIONS
+
+  Specifying multiple files on a single command line will make curl transfer
+  all of them, one after the other in the specified order.
+
+  libcurl will attempt to use persistant connections for the transfers so that
+  the second transfer to the same host can use the same connection that was
+  already initiated and was left open in the previous transfer. This greatly
+  decreases connection time for all but the first transfer and it makes a far
+  better use of the network.
+
+  Note that curl cannot use persistant connections for transfers that are used
+  in subsequence curl invokes. Try to stuff as many URLs as possible on the
+  same command line if they are using the same host, as that'll make the
+  transfers faster. If you use a http proxy for file transfers, practicly
+  all transfers will be persistant.
+
+  Persistant connections were introduced in curl 7.7.
+
+MAILING LISTS
+
+  For your convenience, we have several open mailing lists to discuss curl,
+  its development and things relevant to this.
 
-  We have an open mailing list to discuss curl, its development and things
-  relevant to this.
+  To subscribe to the main curl list, mail curl-request@contactor.se with
+  "subscribe <fill in your email address>" in the body.
 
-  To subscribe, mail curl-request@contactor.se with "subscribe <fill in your
-  email address>" in the body.
+  To subscribe to the curl-library users/deverlopers list, follow the
+  instructions at http://curl.haxx.se/mail/
 
-  To post to the list, mail curl@contactor.se.
+  To subscribe to the curl-announce list, to only get information about new
+  releases, follow the instructions at http://curl.haxx.se/mail/
 
-  To unsubcribe, mail curl-request@contactor.se with "unsubscribe <your
-  subscribed email address>" in the body.
+  To subscribe to the curl-and-PHP list in which curl using with PHP is
+  discussed, follow the instructions at http://curl.haxx.se/mail/
 
+  Please direct curl questions, feature requests and trouble reports to one of
+  these mailing lists instead of mailing any individual.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/docs/TODO	2001-01-11 07:45:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/docs/TODO	2001-03-22 19:21:19.000000000 +0800
@@ -3,98 +3,93 @@
                              / __| | | | |_) | |    
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
 TODO
 
-For the future
+ Things to do in project cURL. Please tell me what you think, contribute and
+ send me patches that improve things!
 
- Ok, this is what I wanna do with Curl. Please tell me what you think, and
- please don't hesitate to contribute and send me patches that improve this
- product! (Yes, you may add things not mentioned here, these are just a
- few teasers...)
+To do for the next release:
 
  * Make SSL session ids get used if multiple HTTPS documents from the same
    host is requested.
 
- * Make the curl tool support URLs that start with @ that would then mean that
-   the following is a plain list with URLs to download. Thus @filename.txt
-   reads a list of URLs from a local file. A fancy option would then be to
-   support @http://whatever.com that would first load a list and then get the
-   URLs mentioned in the list. I figure -O or something would have to be
-   implied by such an action.
-
- * Improve the regular progress meter with --continue is used. It should be
-   noticable when there's a resume going on.
+ * Document the undocumented libcurl functions: the printf clones (like
+   curl_msprintf, curl_mfprintf, curl_msnprintf, curl_maprintf and
+   curl_mvfprintf) and the string compare functions (curl_strequal
+   and curl_strnequal).
+
+To do in a future release (random order):
+
+ * Rewrite parts of the test suite. Make a (XML?) format to store all
+   test-data in a single for a single test case. The current system makes far
+   too many separate files. We also need to have the test suite support
+   different behaviors, like when libcurl is compiled for IPv6 support and
+   thus performs a different set of FTP commands.
+
+ * Add configure options that disables certain protocols in libcurl to
+   decrease footprint.  '--disable-[protocol]' where protocol is http, ftp,
+   telnet, ldap, dict or file.
+
+ * Extend the test suite to include telnet and https. The telnet could just do
+   ftp or http operations (for which we have test servers) and the https would
+   probably work against/with some of the openssl tools.
 
  * Add a command line option that allows the output file to get the same time
-   stamp as the remote file. We already are capable of fetching the remote
+   stamp as the remote file. libcurl already is capable of fetching the remote
    file's date.
 
- * Make the SSL layer option capable of using the Mozilla Security Services as
-   an alternative to OpenSSL:
-   http://www.mozilla.org/projects/security/pki/nss/
-
- * Make sure the low-level interface works. highlevel.c should basically be
-   possible to write using that interface. Document the low-level interface
-
- * Make the easy-interface support multiple file transfers. If they're done
-   to the same host, they should use persistant connections or similar.
-   Figure out a nice design for this.
+ * Make curl's SSL layer option capable of using other free SSL libraries.
+   Such as the Mozilla Security Services
+   (http://www.mozilla.org/projects/security/pki/nss/) and GNUTLS
+   (http://gnutls.hellug.gr/)
 
  * Add asynchronous name resolving, as this enables full timeout support for
    fork() systems.
 
+ * Non-blocking connect(), also to make timeouts work on windows.
+
  * Move non-URL related functions that are used by both the lib and the curl
    application to a separate "portability lib".
 
  * Add support for other languages than C.  C++ (rumours have been heard about
    something being worked on in this area) and perl (we have seen the first
    versions of this!) comes to mind. Python anyone?
 
- * "Content-Encoding: compress/gzip/zlib"
+ * "Content-Encoding: compress/gzip/zlib" HTTP 1.1 clearly defines how to get
+   and decode compressed documents. There is the zlib that is pretty good at
+   decompressing stuff. This work was started in October 1999 but halted again
+   since it proved more work than we thought. It is still a good idea to
+   implement though.
 
-   HTTP 1.1 clearly defines how to get and decode compressed documents. There
-   is the zlib that is pretty good at decompressing stuff. This work was
-   started in October 1999 but halted again since it proved more work than we
-   thought. It is still a good idea to implement though.
-
- * Authentication: NTLM. It would be cool to support that MS crap called NTLM
+ * Authentication: NTLM. Support for that MS crap called NTLM
    authentication. MS proxies and servers sometime require that. Since that
    protocol is a proprietary one, it involves reverse engineering and network
    sniffing. This should however be a library-based functionality. There are a
    few different efforts "out there" to make open source HTTP clients support
    this and it should be possible to take advantage of other people's hard
-   work. http://modntlm.sourceforge.net/ is one.
+   work. http://modntlm.sourceforge.net/ is one. There's a web page at
+   http://www.innovation.ch/java/ntlm.html that contains detailed reverse-
+   engineered info.
 
  * RFC2617 compliance, "Digest Access Authentication"
    A valid test page seem to exist at:
-    http://hopf.math.nwu.edu/testpage/digest/
+   http://hopf.math.nwu.edu/testpage/digest/
    And some friendly person's server source code is available at
-    http://hopf.math.nwu.edu/digestauth/index.html
-
+   http://hopf.math.nwu.edu/digestauth/index.html
    Then there's the Apache mod_digest source code too of course.  It seems as
    if Netscape doesn't support this, and not many servers do. Although this is
    a lot better authentication method than the more common "Basic". Basic
    sends the password in cleartext over the network, this "Digest" method uses
    a challange-response protocol which increases security quite a lot.
 
- * Multiple Proxies?
-   Is there anyone that actually uses serial-proxies? I mean, send CONNECT to
-   the first proxy to connect to the second proxy to which you send CONNECT to
-   connect to the remote host (or even more iterations). Is there anyone
-   wanting curl to support it? (Not that it would be hard, just confusing...)
-
  * Other proxies
    Ftp-kind proxy, Socks5, whatever kind of proxies are there?
 
- * IPv6 Awareness and support
-   Where ever it would fit.  configure search for v6-versions of a few
-   functions and then use them instead is of course the first thing to do...
-   RFC 2428 "FTP Extensions for IPv6 and NATs" will be interesting. PORT
-   should be replaced with EPRT for IPv6, and EPSV instead of PASV.
+ * IPv6 Awareness and support. (This is partly done.)  RFC 2428 "FTP
+   Extensions for IPv6 and NATs" is interesting. PORT should be replaced with
+   EPRT for IPv6 (done), and EPSV instead of PASV.  HTTP proxies are left to
+   add support for.
 
  * SSL for more protocols, like SSL-FTP...
    (http://search.ietf.org/internet-drafts/draft-murray-auth-ftp-ssl-05.txt)
-
- * HTTP POST resume using Range:
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/include/curl/curl.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/include/curl/curl.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/include/curl/curl.h	2001-02-13 21:35:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/include/curl/curl.h	2001-03-22 23:42:20.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: curl.h,v 1.52 2001/02/07 09:49:06 bagder Exp $
+ * $Id: curl.h,v 1.69 2001/03/22 11:40:58 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 /* The include stuff here is mainly for time_t! */
 #ifdef vms
 # include <types.h>
@@ -94,74 +94,63 @@
    Always add new return codes last. Never *EVER* remove any. The return
    codes must remain the same!
  */
 
 typedef enum {
   CURLE_OK = 0,
-  CURLE_UNSUPPORTED_PROTOCOL,
-  CURLE_FAILED_INIT,
-  CURLE_URL_MALFORMAT,
-  CURLE_URL_MALFORMAT_USER,
-  CURLE_COULDNT_RESOLVE_PROXY,
-  CURLE_COULDNT_RESOLVE_HOST,
-  CURLE_COULDNT_CONNECT,
-  CURLE_FTP_WEIRD_SERVER_REPLY,
-  CURLE_FTP_ACCESS_DENIED,
-  CURLE_FTP_USER_PASSWORD_INCORRECT,
-  CURLE_FTP_WEIRD_PASS_REPLY,
-  CURLE_FTP_WEIRD_USER_REPLY,
-  CURLE_FTP_WEIRD_PASV_REPLY,
-  CURLE_FTP_WEIRD_227_FORMAT,
-  CURLE_FTP_CANT_GET_HOST,
-  CURLE_FTP_CANT_RECONNECT,
-  CURLE_FTP_COULDNT_SET_BINARY,
-  CURLE_PARTIAL_FILE,
-  CURLE_FTP_COULDNT_RETR_FILE,
-  CURLE_FTP_WRITE_ERROR,
-  CURLE_FTP_QUOTE_ERROR,
-  CURLE_HTTP_NOT_FOUND,
-  CURLE_WRITE_ERROR,
-
-  CURLE_MALFORMAT_USER, /* the user name is illegally specified */
-  CURLE_FTP_COULDNT_STOR_FILE, /* failed FTP upload */
-  CURLE_READ_ERROR, /* could open/read from file */
-
-  CURLE_OUT_OF_MEMORY,
-  CURLE_OPERATION_TIMEOUTED, /* the timeout time was reached */
-  CURLE_FTP_COULDNT_SET_ASCII, /* TYPE A failed */
-
-  CURLE_FTP_PORT_FAILED, /* FTP PORT operation failed */
-
-  CURLE_FTP_COULDNT_USE_REST, /* the REST command failed */
-  CURLE_FTP_COULDNT_GET_SIZE, /* the SIZE command failed */
-
-  CURLE_HTTP_RANGE_ERROR, /* The RANGE "command" didn't seem to work */
-
-  CURLE_HTTP_POST_ERROR,
-
-  CURLE_SSL_CONNECT_ERROR, /* something was wrong when connecting with SSL */
-
-  CURLE_FTP_BAD_DOWNLOAD_RESUME, /* couldn't resume download */
-
-  CURLE_FILE_COULDNT_READ_FILE,
-
-  CURLE_LDAP_CANNOT_BIND,
-  CURLE_LDAP_SEARCH_FAILED,
-  CURLE_LIBRARY_NOT_FOUND,
-  CURLE_FUNCTION_NOT_FOUND,
-  
-  CURLE_ABORTED_BY_CALLBACK,
-  CURLE_BAD_FUNCTION_ARGUMENT,
-  CURLE_BAD_CALLING_ORDER,
-
-  CURLE_HTTP_PORT_FAILED, /* HTTP Interface operation failed */
-
-  CURLE_BAD_PASSWORD_ENTERED, /* when the my_getpass() returns fail */
-  CURLE_TOO_MANY_REDIRECTS , /* catch endless re-direct loops */
+  CURLE_UNSUPPORTED_PROTOCOL,    /* 1 */
+  CURLE_FAILED_INIT,             /* 2 */
+  CURLE_URL_MALFORMAT,           /* 3 */
+  CURLE_URL_MALFORMAT_USER,      /* 4 */
+  CURLE_COULDNT_RESOLVE_PROXY,   /* 5 */
+  CURLE_COULDNT_RESOLVE_HOST,    /* 6 */
+  CURLE_COULDNT_CONNECT,         /* 7 */
+  CURLE_FTP_WEIRD_SERVER_REPLY,  /* 8 */
+  CURLE_FTP_ACCESS_DENIED,       /* 9 */
+  CURLE_FTP_USER_PASSWORD_INCORRECT, /* 10 */
+  CURLE_FTP_WEIRD_PASS_REPLY,    /* 11 */
+  CURLE_FTP_WEIRD_USER_REPLY,    /* 12 */
+  CURLE_FTP_WEIRD_PASV_REPLY,    /* 13 */
+  CURLE_FTP_WEIRD_227_FORMAT,    /* 14 */
+  CURLE_FTP_CANT_GET_HOST,       /* 15 */
+  CURLE_FTP_CANT_RECONNECT,      /* 16 */
+  CURLE_FTP_COULDNT_SET_BINARY,  /* 17 */
+  CURLE_PARTIAL_FILE,            /* 18 */
+  CURLE_FTP_COULDNT_RETR_FILE,   /* 19 */
+  CURLE_FTP_WRITE_ERROR,         /* 20 */
+  CURLE_FTP_QUOTE_ERROR,         /* 21 */
+  CURLE_HTTP_NOT_FOUND,          /* 22 */
+  CURLE_WRITE_ERROR,             /* 23 */
+  CURLE_MALFORMAT_USER,          /* 24 - user name is illegally specified */
+  CURLE_FTP_COULDNT_STOR_FILE,   /* 25 - failed FTP upload */
+  CURLE_READ_ERROR,              /* 26 - could open/read from file */
+  CURLE_OUT_OF_MEMORY,           /* 27 */
+  CURLE_OPERATION_TIMEOUTED,     /* 28 - the timeout time was reached */
+  CURLE_FTP_COULDNT_SET_ASCII,   /* 29 - TYPE A failed */
+  CURLE_FTP_PORT_FAILED,         /* 30 - FTP PORT operation failed */
+  CURLE_FTP_COULDNT_USE_REST,    /* 31 - the REST command failed */
+  CURLE_FTP_COULDNT_GET_SIZE,    /* 32 - the SIZE command failed */
+  CURLE_HTTP_RANGE_ERROR,        /* 33 - RANGE "command" didn't work */
+  CURLE_HTTP_POST_ERROR,         /* 34 */
+  CURLE_SSL_CONNECT_ERROR,       /* 35 - wrong when connecting with SSL */
+  CURLE_FTP_BAD_DOWNLOAD_RESUME, /* 36 - couldn't resume download */
+  CURLE_FILE_COULDNT_READ_FILE,  /* 37 */
+  CURLE_LDAP_CANNOT_BIND,        /* 38 */
+  CURLE_LDAP_SEARCH_FAILED,      /* 39 */
+  CURLE_LIBRARY_NOT_FOUND,       /* 40 */
+  CURLE_FUNCTION_NOT_FOUND,      /* 41 */
+  CURLE_ABORTED_BY_CALLBACK,     /* 42 */
+  CURLE_BAD_FUNCTION_ARGUMENT,   /* 43 */
+  CURLE_BAD_CALLING_ORDER,       /* 44 */
+  CURLE_HTTP_PORT_FAILED,        /* 45 - HTTP Interface operation failed */
+  CURLE_BAD_PASSWORD_ENTERED,    /* 46 - my_getpass() returns fail */
+  CURLE_TOO_MANY_REDIRECTS ,     /* 47 - catch endless re-direct loops */
+  CURLE_UNKNOWN_TELNET_OPTION,   /* 48 - User specified an unknown option */
+  CURLE_TELNET_OPTION_SYNTAX ,   /* 49 - Malformed telnet option */
 
-  CURL_LAST
+  CURL_LAST /* never use! */
 } CURLcode;
 
 /* This is just to make older programs not break: */
 #define CURLE_FTP_PARTIAL_FILE CURLE_PARTIAL_FILE
 
 #define CURL_ERROR_SIZE 256
@@ -403,12 +392,47 @@
   CINIT(MAXREDIRS, LONG, 68),
 
   /* Pass a pointer to a time_t to get a possible date of the requested
      document! Pass a NULL to shut it off. */
   CINIT(FILETIME, OBJECTPOINT, 69),
 
+  /* This points to a linked list of telnet options */
+  CINIT(TELNETOPTIONS, OBJECTPOINT, 70),
+
+  /* Max amount of cached alive connections */
+  CINIT(MAXCONNECTS, LONG, 71),
+
+  /* What policy to use when closing connections when the cache is filled
+     up */
+  CINIT(CLOSEPOLICY, LONG, 72),
+
+  /* Callback to use when CURLCLOSEPOLICY_CALLBACK is set */
+  CINIT(CLOSEFUNCTION, FUNCTIONPOINT, 73),
+
+  /* Set to explicitly use a new connection for the upcoming transfer.
+     Do not use this unless you're absolutely sure of this, as it makes the
+     operation slower and is less friendly for the network. */
+  CINIT(FRESH_CONNECT, LONG, 74),
+
+  /* Set to explicitly forbid the upcoming transfer's connection to be re-used
+     when done. Do not use this unless you're absolutely sure of this, as it
+     makes the operation slower and is less friendly for the network. */
+  CINIT(FORBID_REUSE, LONG, 75),
+
+  /* Set to a file name that contains random data for libcurl to use to
+     seed the random engine when doing SSL connects. */
+  CINIT(RANDOM_FILE, OBJECTPOINT, 76),
+
+  /* Set to the Entropy Gathering Daemon socket pathname */
+  CINIT(EGDSOCKET, OBJECTPOINT, 77),
+
+  /* Time-out connect operations after this amount of seconds, if connects
+     are OK within this time, then fine... This only aborts the connect
+     phase. [Only works on unix-style/SIGALRM operating systems] */
+  CINIT(CONNECTTIMEOUT, LONG, 78),
+
   CURLOPT_LASTENTRY /* the last unusued */
 } CURLoption;
 
 typedef enum {
   TIMECOND_NONE,
 
@@ -428,16 +452,16 @@
    they are used by the 'curl' client. They really should be moved to some kind
    of "portability library" since it has nothing to do with file transfers and
    might be usable to other programs...
 
    NOTE: they return TRUE if the strings match *case insensitively*.
  */
-extern int (Curl_strequal)(const char *s1, const char *s2);
-extern int (Curl_strnequal)(const char *s1, const char *s2, size_t n);
-#define strequal(a,b) Curl_strequal(a,b)
-#define strnequal(a,b,c) Curl_strnequal(a,b,c)
+extern int (curl_strequal)(const char *s1, const char *s2);
+extern int (curl_strnequal)(const char *s1, const char *s2, size_t n);
+#define strequal(a,b) curl_strequal(a,b)
+#define strnequal(a,b,c) curl_strnequal(a,b,c)
 
 /* external form function */
 int curl_formparse(char *string,
                    struct HttpPost **httppost,
                    struct HttpPost **last_post);
 
@@ -448,200 +472,29 @@
    MUST be free()ed after usage is complete. */
 char *curl_getenv(char *variable);
 
 /* Returns a static ascii string of the libcurl version. */
 char *curl_version(void);
 
+/* Escape and unescape URL encoding in strings. The functions return a new
+ * allocated string or NULL if an error occurred.  */
+char *curl_escape(char *string, int length);
+char *curl_unescape(char *string, int length);
+
 /* This is the version number */
-#define LIBCURL_VERSION "7.6.1"
-#define LIBCURL_VERSION_NUM 0x070601
+#define LIBCURL_VERSION "7.7"
+#define LIBCURL_VERSION_NUM 0x070700
 
 /* linked-list structure for the CURLOPT_QUOTE option (and other) */
 struct curl_slist {
 	char			*data;
 	struct curl_slist	*next;
 };
 
-struct curl_slist *curl_slist_append(struct curl_slist *list, char *data);
-void curl_slist_free_all(struct curl_slist *list);
-
-/*
- * NAME	curl_init()
- *
- * DESCRIPTION
- *
- * Inits libcurl globally. This must be used before any libcurl calls can
- * be used. This may install global plug-ins or whatever. (This does not
- * do winsock inits in Windows.)
- *
- * EXAMPLE
- *
- * curl_init();
- *
- */
-CURLcode curl_init(void);
-
-/*
- * NAME	curl_init()
- *
- * DESCRIPTION
- *
- * Frees libcurl globally. This must be used after all libcurl calls have
- * been used. This may remove global plug-ins or whatever. (This does not
- * do winsock cleanups in Windows.)
- *
- * EXAMPLE
- *
- * curl_free(curl);
- *
- */
-void curl_free(void);
-
-/*
- * NAME curl_open()
- *
- * DESCRIPTION
- *
- * Opens a general curl session. It does not try to connect or do anything
- * on the network because of this call. The specified URL is only required
- * to enable curl to figure out what protocol to "activate".
- *
- * A session should be looked upon as a series of requests to a single host.  A
- * session interacts with one host only, using one single protocol.
- *
- * The URL is not required. If set to "" or NULL, it can still be set later
- * using the curl_setopt() function. If the curl_connect() function is called
- * without the URL being known, it will return error.
- *
- * EXAMPLE
- *
- * CURLcode result;
- * CURL *curl;
- * result = curl_open(&curl, "http://curl.haxx.nu/libcurl/");
- * if(result != CURL_OK) {
- *   return result;
- * }
- * */
-CURLcode curl_open(CURL **curl, char *url);
-
-/*
- * NAME curl_setopt()
- *
- * DESCRIPTION
- *
- * Sets a particular option to the specified value.
- *
- * EXAMPLE
- *
- * CURL curl;
- * curl_setopt(curl, CURL_HTTP_FOLLOW_LOCATION, TRUE);
- */
-CURLcode curl_setopt(CURL *handle, CURLoption option, ...);
-
-/*
- * NAME curl_close()
- *
- * DESCRIPTION
- *
- * Closes a session previously opened with curl_open()
- *
- * EXAMPLE
- *
- * CURL *curl;
- * CURLcode result;
- *
- * result = curl_close(curl);
- */
-CURLcode curl_close(CURL *curl); /* the opposite of curl_open() */
-
-CURLcode curl_read(CURLconnect *c_conn, char *buf, size_t buffersize,
-                   ssize_t *n);
-CURLcode curl_write(CURLconnect *c_conn, char *buf, size_t amount,
-                    size_t *n);
-
-/*
- * NAME curl_connect()
- *
- * DESCRIPTION
- *
- * Connects to the peer server and performs the initial setup. This function
- * writes a connect handle to its second argument that is a unique handle for
- * this connect. This allows multiple connects from the same handle returned
- * by curl_open().
- *
- * EXAMPLE
- *
- * CURLCode result;
- * CURL curl;
- * CURLconnect connect;
- * result = curl_connect(curl, &connect);
- */
-
-CURLcode curl_connect(CURL *curl, CURLconnect **in_connect);
-
-/*
- * NAME curl_do()
- *
- * DESCRIPTION
- *
- * (Note: May 3rd 2000: this function does not currently allow you to
- * specify a document, it will use the one set previously)
- *
- * This function asks for the particular document, file or resource that
- * resides on the server we have connected to. You may specify a full URL,
- * just an absolute path or even a relative path. That means, if you're just
- * getting one file from the remote site, you can use the same URL as input
- * for both curl_open() as well as for this function.
- *
- * In the even there is a host name, port number, user name or password parts
- * in the URL, you can use the 'flags' argument to ignore them completely, or
- * at your choice, make the function fail if you're trying to get a URL from
- * different host than you connected to with curl_connect().
- *
- * You can only get one document at a time using the same connection. When one
- * document has been received you can although request again.
- *
- * When the transfer is done, curl_done() MUST be called.
- *
- * EXAMPLE
- *
- * CURLCode result;
- * char *url;
- * CURLconnect *connect;
- * result = curl_do(connect, url, CURL_DO_NONE); */
-CURLcode curl_do(CURLconnect *in_conn);
-
-/*
- * NAME curl_done()
- *
- * DESCRIPTION
- *
- * When the transfer following a curl_do() call is done, this function should
- * get called.
- *
- * EXAMPLE
- *
- * CURLCode result;
- * char *url;
- * CURLconnect *connect;
- * result = curl_done(connect); */
-CURLcode curl_done(CURLconnect *connect);
-
-/*
- * NAME curl_disconnect()
- *
- * DESCRIPTION
- *
- * Disconnects from the peer server and performs connection cleanup.
- *
- * EXAMPLE
- *
- * CURLcode result;
- * CURLconnect *connect;
- * result = curl_disconnect(connect); */
-CURLcode curl_disconnect(CURLconnect *connect);
+struct curl_slist *curl_slist_append(struct curl_slist *, const char *);
+void curl_slist_free_all(struct curl_slist *);
 
 /*
  * NAME curl_getdate()
  *
  * DESCRIPTION
  *
@@ -679,25 +532,28 @@
   CURLINFO_CONTENT_LENGTH_DOWNLOAD   = CURLINFO_DOUBLE + 15,
   CURLINFO_CONTENT_LENGTH_UPLOAD     = CURLINFO_DOUBLE + 16,
 
   CURLINFO_LASTONE          = 17
 } CURLINFO;
 
-/*
- * NAME curl_getinfo()
- *
- * DESCRIPTION
- *
- * Request internal information from the curl session with this function.
- * The third argument MUST be a pointer to a long or a pointer to a char *.
- * The data pointed to will be filled in accordingly and can be relied upon
- * only if the function returns CURLE_OK.
- * This function is intended to get used *AFTER* a performed transfer, all
- * results are undefined before the transfer is completed.
- */
-CURLcode curl_getinfo(CURL *curl, CURLINFO info, ...);
+/* unfortunately, the easy.h include file needs the options and info stuff
+   before it can be included! */
+#include <curl/easy.h> /* nothing in curl is fun without the easy stuff */
+
+typedef enum {
+  CURLCLOSEPOLICY_NONE, /* first, never use this */
+
+  CURLCLOSEPOLICY_OLDEST,
+  CURLCLOSEPOLICY_LEAST_RECENTLY_USED,
+  CURLCLOSEPOLICY_LEAST_TRAFFIC,
+  CURLCLOSEPOLICY_SLOWEST,
+  CURLCLOSEPOLICY_CALLBACK,
+ 
+  CURLCLOSEPOLICY_LAST /* last, never use this */
+} curl_closepolicy;
+
 
 #ifdef  __cplusplus
 }
 #endif
 
 #endif /* __CURL_CURL_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/include/curl/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/include/curl/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/include/curl/Makefile.in	2001-02-13 21:35:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/include/curl/Makefile.in	2001-03-22 23:42:56.000000000 +0800
@@ -65,12 +65,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 pkginclude_HEADERS =  	curl.h 	easy.h 	mprintf.h 	stdcheaders.h 	types.h
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/include/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/include/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/include/Makefile.in	2001-02-13 21:35:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/include/Makefile.in	2001-03-22 23:42:56.000000000 +0800
@@ -66,12 +66,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 SUBDIRS = curl
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib: curllib.dsp
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib: curllib.dsw
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/dict.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/dict.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/dict.c	2001-01-25 20:13:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/dict.c	2001-03-14 22:11:11.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: dict.c,v 1.12 2001/01/25 12:13:35 bagder Exp $
+ * $Id: dict.c,v 1.14 2001/03/14 14:11:11 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -97,13 +97,13 @@
   CURLcode result=CURLE_OK;
   struct UrlData *data=conn->data;
 
   char *path = conn->path;
   long *bytecount = &conn->bytecount;
 
-  if(data->bits.user_passwd) {
+  if(conn->bits.user_passwd) {
     /* AUTH is missing */
   }
 
   if (strnequal(path, DICT_MATCH, sizeof(DICT_MATCH)-1) ||
       strnequal(path, DICT_MATCH2, sizeof(DICT_MATCH2)-1) ||
       strnequal(path, DICT_MATCH3, sizeof(DICT_MATCH3)-1)) {
@@ -138,26 +138,26 @@
       nth = 0;
     }
     else {
       nth = atoi(nthdef);
     }
       
-    Curl_sendf(data->firstsocket, conn,
+    Curl_sendf(conn->firstsocket, conn,
                "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
                "MATCH "
                "%s "    /* database */
                "%s "    /* strategy */
                "%s\n"   /* word */
                "QUIT\n",
 	    
                database,
                strategy,
                word
                );
     
-    result = Curl_Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
+    result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
                            -1, NULL); /* no upload */
       
     if(result)
       return result;
     
   }
@@ -188,24 +188,24 @@
       nth = 0;
     }
     else {
       nth = atoi(nthdef);
     }
       
-    Curl_sendf(data->firstsocket, conn,
+    Curl_sendf(conn->firstsocket, conn,
                "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
                "DEFINE "
                "%s "     /* database */
                "%s\n"    /* word */
                "QUIT\n",
                
                database,
                word
                );
     
-    result = Curl_Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
+    result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
                            -1, NULL); /* no upload */
     
     if(result)
       return result;
       
   }
@@ -217,19 +217,19 @@
 	
       ppath++;
       for (i = 0; ppath[i]; i++) {
         if (ppath[i] == ':')
           ppath[i] = ' ';
       }
-      Curl_sendf(data->firstsocket, conn,
+      Curl_sendf(conn->firstsocket, conn,
                  "CLIENT " LIBCURL_NAME " " LIBCURL_VERSION "\n"
                  "%s\n"
                  "QUIT\n",
                  ppath);
       
-      result = Curl_Transfer(conn, data->firstsocket, -1, FALSE, bytecount,
+      result = Curl_Transfer(conn, conn->firstsocket, -1, FALSE, bytecount,
                              -1, NULL);
       
       if(result)
         return result;
       
     }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/easy.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/easy.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/easy.c	2001-01-17 21:23:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/easy.c	2001-03-10 00:50:36.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: easy.c,v 1.9 2001/01/17 13:23:01 bagder Exp $
+ * $Id: easy.c,v 1.10 2001/03/09 15:10:58 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -80,21 +80,17 @@
 
 CURL *curl_easy_init(void)
 {
   CURLcode res;
   struct UrlData *data;
 
-  if(curl_init())
-    return NULL;
-
   /* We use curl_open() with undefined URL so far */
-  res = curl_open((CURL **)&data, NULL);
+  res = Curl_open((CURL **)&data, NULL);
   if(res != CURLE_OK)
     return NULL;
 
-  data->interf = CURLI_EASY; /* mark it as an easy one */
   /* SAC */
   data->device = NULL;
 
   return data;
 }
 
@@ -116,42 +112,41 @@
      the types.
   */
 
   if(tag < CURLOPTTYPE_OBJECTPOINT) {
     /* This is a LONG type */
     param_long = va_arg(arg, long);
-    curl_setopt(data, tag, param_long);
+    Curl_setopt(data, tag, param_long);
   }
   else if(tag < CURLOPTTYPE_FUNCTIONPOINT) {
     /* This is a object pointer type */
     param_obj = va_arg(arg, void *);
-    curl_setopt(data, tag, param_obj);
+    Curl_setopt(data, tag, param_obj);
   }
   else {
     param_func = va_arg(arg, func_T );
-    curl_setopt(data, tag, param_func);
+    Curl_setopt(data, tag, param_func);
   }
 
   va_end(arg);
   return CURLE_OK;
 }
 
 CURLcode curl_easy_perform(CURL *curl)
 {
-  return curl_transfer(curl);
+  return Curl_perform(curl);
 }
 
 void curl_easy_cleanup(CURL *curl)
 {
-  curl_close(curl);
-  curl_free();
+  Curl_close(curl);
 }
 
 CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ...)
 {
   va_list arg;
   void *paramp;
   va_start(arg, info);
   paramp = va_arg(arg, void *);
 
-  return curl_getinfo(curl, info, paramp);
+  return Curl_getinfo(curl, info, paramp);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/escape.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/escape.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/escape.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/escape.c	2001-03-22 19:40:58.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: escape.c,v 1.9 2001/01/03 09:29:34 bagder Exp $
+ * $Id: escape.c,v 1.11 2001/03/22 11:40:58 bagder Exp $
  *****************************************************************************/
 
 /* Escape and unescape URL encoding in strings. The functions return a new
  * allocated string or NULL if an error occurred.  */
 
 #include "setup.h"
@@ -33,77 +33,77 @@
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
-char *curl_escape(char *string)
+char *curl_escape(char *string, int length)
 {
-   int alloc=strlen(string)+1;
-   char *ns = malloc(alloc);
-   unsigned char in;
-   int newlen = alloc;
-   int index=0;
-
-   while(*string) {
-      in = *string;
-      if(' ' == in)
-	 ns[index++] = '+';
-      else if(!(in >= 'a' && in <= 'z') &&
-	      !(in >= 'A' && in <= 'Z') &&
-	      !(in >= '0' && in <= '9')) {
-	 /* encode it */
-	 newlen += 2; /* the size grows with two, since this'll become a %XX */
-	 if(newlen > alloc) {
-	    alloc *= 2;
-	    ns = realloc(ns, alloc);
-	    if(!ns)
-	       return NULL;
-	 }
-	 sprintf(&ns[index], "%%%02X", in);
-	 index+=3;
+  int alloc = (length?length:strlen(string))+1;  
+  char *ns = malloc(alloc);
+  unsigned char in;
+  int newlen = alloc;
+  int index=0;
+
+  while(length--) {
+    in = *string;
+    if(' ' == in)
+      ns[index++] = '+';
+    else if(!(in >= 'a' && in <= 'z') &&
+            !(in >= 'A' && in <= 'Z') &&
+            !(in >= '0' && in <= '9')) {
+      /* encode it */
+      newlen += 2; /* the size grows with two, since this'll become a %XX */
+      if(newlen > alloc) {
+        alloc *= 2;
+        ns = realloc(ns, alloc);
+        if(!ns)
+          return NULL;
       }
-      else {
-	 /* just copy this */
-	 ns[index++]=in;
-      }
-      string++;
-   }
-   ns[index]=0; /* terminate it */
-   return ns;
+      sprintf(&ns[index], "%%%02X", in);
+      index+=3;
+    }
+    else {
+      /* just copy this */
+      ns[index++]=in;
+    }
+    string++;
+  }
+  ns[index]=0; /* terminate it */
+  return ns;
 }
 
 char *curl_unescape(char *string, int length)
 {
-   int alloc = (length?length:strlen(string))+1;
-   char *ns = malloc(alloc);
-   unsigned char in;
-   int index=0;
-   int hex;
-   char querypart=FALSE; /* everything to the right of a '?' letter is
-                            the "query part" where '+' should become ' '.
-                            RFC 2316, section 3.10 */
+  int alloc = (length?length:strlen(string))+1;
+  char *ns = malloc(alloc);
+  unsigned char in;
+  int index=0;
+  unsigned int hex;
+  char querypart=FALSE; /* everything to the right of a '?' letter is
+                           the "query part" where '+' should become ' '.
+                           RFC 2316, section 3.10 */
   
-   while(--alloc > 0) {
-      in = *string;
-      if(querypart && ('+' == in))
-         in = ' ';
-      else if(!querypart && ('?' == in)) {
-        /* we have "walked in" to the query part */
-        querypart=TRUE;
-      }
-      else if('%' == in) {
-        /* encoded part */
-        if(sscanf(string+1, "%02X", &hex)) {
-          in = hex;
-          string+=2;
-          alloc-=2;
-        }
+  while(--alloc > 0) {
+    in = *string;
+    if(querypart && ('+' == in))
+      in = ' ';
+    else if(!querypart && ('?' == in)) {
+      /* we have "walked in" to the query part */
+      querypart=TRUE;
+    }
+    else if('%' == in) {
+      /* encoded part */
+      if(sscanf(string+1, "%02X", &hex)) {
+        in = hex;
+        string+=2;
+        alloc-=2;
       }
-
-      ns[index++] = in;
-      string++;
-   }
-   ns[index]=0; /* terminate it */
-   return ns;
+    }
+    
+    ns[index++] = in;
+    string++;
+  }
+  ns[index]=0; /* terminate it */
+  return ns;
   
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/escape.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/escape.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/escape.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/escape.h	2001-03-22 19:40:58.000000000 +0800
@@ -18,15 +18,15 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: escape.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: escape.h,v 1.6 2001/03/22 11:40:58 bagder Exp $
  *****************************************************************************/
 /* Escape and unescape URL encoding in strings. The functions return a new
  * allocated string or NULL if an error occurred.  */
 
-char *curl_escape(char *string);
+char *curl_escape(char *string, int length);
 char *curl_unescape(char *string, int length);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/file.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/file.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/file.c	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/file.c	2001-03-14 16:28:19.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.c,v 1.14 2001/01/05 10:11:42 bagder Exp $
+ * $Id: file.c,v 1.16 2001/03/14 08:28:19 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -88,50 +88,73 @@
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
-CURLcode file(struct connectdata *conn)
+/* Emulate a connect-then-transfer protocol. We connect to the file here */
+CURLcode Curl_file_connect(struct connectdata *conn)
 {
-  /* This implementation ignores the host name in conformance with 
-     RFC 1738. Only local files (reachable via the standard file system)
-     are supported. This means that files on remotely mounted directories
-     (via NFS, Samba, NT sharing) can be accessed through a file:// URL
-  */
-  CURLcode res = CURLE_OK;
-  char *path = conn->path;
-  struct stat statbuf;
-  size_t expected_size=-1;
-  size_t nread;
-  struct UrlData *data = conn->data;
-  char *buf = data->buffer;
-  int bytecount = 0;
-  struct timeval start = Curl_tvnow();
-  struct timeval now = start;
+  char *actual_path = curl_unescape(conn->path, 0);
+  struct FILE *file;
   int fd;
-  char *actual_path = curl_unescape(path, 0);
-
 #if defined(WIN32) || defined(__EMX__)
   int i;
+#endif
+
+  file = (struct FILE *)malloc(sizeof(struct FILE));
+  if(!file)
+    return CURLE_OUT_OF_MEMORY;
+
+  memset(file, 0, sizeof(struct FILE));
+  conn->proto.file = file;
 
+#if defined(WIN32) || defined(__EMX__)
   /* change path separators from '/' to '\\' for Windows and OS/2 */
   for (i=0; actual_path[i] != '\0'; ++i)
     if (actual_path[i] == '/')
       actual_path[i] = '\\';
 
   fd = open(actual_path, O_RDONLY | O_BINARY);	/* no CR/LF translation! */
 #else
   fd = open(actual_path, O_RDONLY);
 #endif
   free(actual_path);
 
   if(fd == -1) {
-    failf(data, "Couldn't open file %s", path);
+    failf(conn->data, "Couldn't open file %s", conn->path);
     return CURLE_FILE_COULDNT_READ_FILE;
   }
+  file->fd = fd;
+
+  return CURLE_OK;
+}
+
+/* This is the do-phase, separated from the connect-phase above */
+
+CURLcode Curl_file(struct connectdata *conn)
+{
+  /* This implementation ignores the host name in conformance with 
+     RFC 1738. Only local files (reachable via the standard file system)
+     are supported. This means that files on remotely mounted directories
+     (via NFS, Samba, NT sharing) can be accessed through a file:// URL
+  */
+  CURLcode res = CURLE_OK;
+  struct stat statbuf;
+  size_t expected_size=-1;
+  size_t nread;
+  struct UrlData *data = conn->data;
+  char *buf = data->buffer;
+  int bytecount = 0;
+  struct timeval start = Curl_tvnow();
+  struct timeval now = start;
+  int fd;
+
+  /* get the fd from the connection phase */
+  fd = conn->proto.file->fd;
+
   if( -1 != fstat(fd, &statbuf)) {
     /* we could stat it, then read out the size */
     expected_size = statbuf.st_size;
   }
 
   /* The following is a shortcut implementation of file reading
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/file.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/file.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/file.h	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/file.h	2001-03-05 21:39:01.000000000 +0800
@@ -18,11 +18,11 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: file.h,v 1.5 2001/01/03 09:29:34 bagder Exp $
+ * $Id: file.h,v 1.6 2001/03/05 13:39:01 bagder Exp $
  *****************************************************************************/
-CURLcode file(struct connectdata *conn);
-
+CURLcode Curl_file(struct connectdata *conn);
+CURLcode Curl_file_connect(struct connectdata *conn);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ftp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ftp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ftp.c	2001-02-13 21:34:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ftp.c	2001-03-15 02:24:25.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.c,v 1.52 2001/02/13 13:34:16 bagder Exp $
+ * $Id: ftp.c,v 1.61 2001/03/14 18:24:07 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <string.h>
@@ -74,93 +74,27 @@
 
 #ifdef KRB4
 #include "security.h"
 #include "krb4.h"
 #endif
 
+#include "strequal.h"
+
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
 /* easy-to-use macro: */
 #define ftpsendf Curl_ftpsendf
 
-/* returns last node in linked list */
-static struct curl_slist *slist_get_last(struct curl_slist *list)
-{
-	struct curl_slist	*item;
-
-	/* if caller passed us a NULL, return now */
-	if (!list)
-		return NULL;
-
-	/* loop through to find the last item */
-	item = list;
-	while (item->next) {
-		item = item->next;
-	}
-	return item;
-}
-
-/* append a struct to the linked list. It always retunrs the address of the
- * first record, so that you can sure this function as an initialization
- * function as well as an append function. If you find this bothersome,
- * then simply create a separate _init function and call it appropriately from
- * within the proram. */
-struct curl_slist *curl_slist_append(struct curl_slist *list, char *data)
-{
-	struct curl_slist	*last;
-	struct curl_slist	*new_item;
-
-	new_item = (struct curl_slist *) malloc(sizeof(struct curl_slist));
-	if (new_item) {
-		new_item->next = NULL;
-		new_item->data = strdup(data);
-	}
-	else {
-		fprintf(stderr, "Cannot allocate memory for QUOTE list.\n");
-		return NULL;
-	}
-
-	if (list) {
-		last = slist_get_last(list);
-		last->next = new_item;
-		return list;
-	}
-
-	/* if this is the first item, then new_item *is* the list */
-	return new_item;
-}
-
-/* be nice and clean up resources */
-void curl_slist_free_all(struct curl_slist *list)
-{
-	struct curl_slist	*next;
-	struct curl_slist	*item;
-
-	if (!list)
-		return;
-
-	item = list;
-	do {
-		next = item->next;
-		
-		if (item->data) {
-			free(item->data);
-		}
-		free(item);
-		item = next;
-	} while (next);
-}
-
-
 static CURLcode AllowServerConnect(struct UrlData *data,
+                                   struct connectdata *conn,
                                    int sock)
 {
   fd_set rdset;
   struct timeval dt;
   
   FD_ZERO(&rdset);
@@ -184,25 +118,25 @@
     /* we have received data here */
     {
       int s;
       size_t size = sizeof(struct sockaddr_in);
       struct sockaddr_in add;
 
-      getsockname(sock, (struct sockaddr *) &add, (int *)&size);
-      s=accept(sock, (struct sockaddr *) &add, (int *)&size);
+      getsockname(sock, (struct sockaddr *) &add, (socklen_t *)&size);
+      s=accept(sock, (struct sockaddr *) &add, (socklen_t *)&size);
 
       sclose(sock); /* close the first socket */
 
       if( -1 == s) {
 	/* DIE! */
 	failf(data, "Error accept()ing server connect");
 	return CURLE_FTP_PORT_FAILED;
       }
       infof(data, "Connection accepted from server\n");
 
-      data->secondarysocket = s;
+      conn->secondarysocket = s;
     }
     break;
   }
   return CURLE_OK;
 }
 
@@ -359,29 +293,34 @@
 
   ftp = (struct FTP *)malloc(sizeof(struct FTP));
   if(!ftp)
     return CURLE_OUT_OF_MEMORY;
 
   memset(ftp, 0, sizeof(struct FTP));
-  data->proto.ftp = ftp;
+  conn->proto.ftp = ftp;
+
+  /* We always support persistant connections on ftp */
+  conn->bits.close = FALSE;
 
   /* get some initial data into the ftp struct */
   ftp->bytecountp = &conn->bytecount;
-  ftp->user = data->user;
-  ftp->passwd = data->passwd;
+
+  /* duplicate to keep them even when the data struct changes */
+  ftp->user = strdup(data->user);
+  ftp->passwd = strdup(data->passwd);
 
   if (data->bits.tunnel_thru_httpproxy) {
     /* We want "seamless" FTP operations through HTTP proxy tunnel */
-    result = Curl_ConnectHTTPProxyTunnel(conn, data->firstsocket,
-                                         data->hostname, data->remote_port);
+    result = Curl_ConnectHTTPProxyTunnel(conn, conn->firstsocket,
+                                         conn->hostname, conn->remote_port);
     if(CURLE_OK != result)
       return result;
   }
 
   /* The first thing we do is wait for the "220*" line: */
-  nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode != 220) {
     failf(data, "This doesn't seem like a nice ftp-server response");
     return CURLE_FTP_WEIRD_SERVER_REPLY;
@@ -395,40 +334,40 @@
     sec_request_prot(conn, "private");
 
     /* We set private first as default, in case the line below fails to
        set a valid level */
     sec_request_prot(conn, data->krb4_level);
 
-    data->cmdchannel = fdopen(data->firstsocket, "w");
+    data->cmdchannel = fdopen(conn->firstsocket, "w");
 
     if(sec_login(conn) != 0)
       infof(data, "Logging in with password in cleartext!\n");
     else
       infof(data, "Authentication successful\n");
   }
 #endif
   
   /* send USER */
-  ftpsendf(data->firstsocket, conn, "USER %s", ftp->user);
+  ftpsendf(conn->firstsocket, conn, "USER %s", ftp->user);
 
   /* wait for feedback */
-  nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
   if(nread < 0)
     return CURLE_OPERATION_TIMEOUTED;
 
   if(ftpcode == 530) {
     /* 530 User ... access denied
        (the server denies to log the specified user) */
     failf(data, "Access denied: %s", &buf[4]);
     return CURLE_FTP_ACCESS_DENIED;
   }
   else if(ftpcode == 331) {
     /* 331 Password required for ...
        (the server requires to send the user's password too) */
-    ftpsendf(data->firstsocket, conn, "PASS %s", ftp->passwd);
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    ftpsendf(conn->firstsocket, conn, "PASS %s", ftp->passwd);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode == 530) {
       /* 530 Login incorrect.
          (the username and/or the password are incorrect) */
@@ -466,21 +405,73 @@
   }
   else {
     failf(data, "Odd return code after USER");
     return CURLE_FTP_WEIRD_USER_REPLY;
   }
 
+  /* send PWD to discover our entry point */
+  ftpsendf(conn->firstsocket, conn, "PWD");
+
+  /* wait for feedback */
+  nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+  if(nread < 0)
+    return CURLE_OPERATION_TIMEOUTED;
+
+  if(ftpcode == 257) {
+    char *dir = (char *)malloc(nread+1);
+    char *store=dir;
+    char *ptr=&buf[4]; /* start on the first letter */
+    
+    /* Reply format is like
+       257<space>"<directory-name>"<space><commentary> and the RFC959 says
+
+       The directory name can contain any character; embedded double-quotes
+       should be escaped by double-quotes (the "quote-doubling" convention).
+    */
+    if('\"' == *ptr) {
+      /* it started good */
+      ptr++;
+      while(ptr && *ptr) {
+        if('\"' == *ptr) {
+          if('\"' == ptr[1]) {
+            /* "quote-doubling" */
+            *store = ptr[1];
+            ptr++;
+          }
+          else {
+            /* end of path */
+            *store = '\0'; /* zero terminate */
+            break; /* get out of this loop */
+          }
+        }
+        else
+          *store = *ptr;
+        store++;
+        ptr++;
+      }
+      ftp->entrypath =dir; /* remember this */
+      infof(data, "Entry path is '%s'\n", ftp->entrypath);
+    }
+    else {
+      /* couldn't get the path */
+    }
+
+  }
+  else {
+    /* We couldn't read the PWD response! */
+  }
+
   return CURLE_OK;
 }
 
 
 /* argument is already checked for validity */
 CURLcode Curl_ftp_done(struct connectdata *conn)
 {
   struct UrlData *data = conn->data;
-  struct FTP *ftp = data->proto.ftp;
+  struct FTP *ftp = conn->proto.ftp;
   size_t nread;
   char *buf = data->buffer; /* this is our buffer */
   struct curl_slist *qitem; /* QUOTE item */
   int ftpcode;
 
   if(data->bits.upload) {
@@ -489,32 +480,32 @@
             *ftp->bytecountp, data->infilesize);
       return CURLE_PARTIAL_FILE;
     }
   }
   else {
     if((-1 != conn->size) && (conn->size != *ftp->bytecountp) &&
-       (data->maxdownload != *ftp->bytecountp)) {
+       (conn->maxdownload != *ftp->bytecountp)) {
       failf(data, "Received only partial file");
       return CURLE_PARTIAL_FILE;
     }
     else if(!data->bits.no_body && (0 == *ftp->bytecountp)) {
       failf(data, "No data was received!");
       return CURLE_FTP_COULDNT_RETR_FILE;
     }
   }
 #ifdef KRB4
-  sec_fflush_fd(conn, data->secondarysocket);
+  sec_fflush_fd(conn, conn->secondarysocket);
 #endif
   /* shut down the socket to inform the server we're done */
-  sclose(data->secondarysocket);
-  data->secondarysocket = -1;
+  sclose(conn->secondarysocket);
+  conn->secondarysocket = -1;
 
   if(!data->bits.no_body) {  
     /* now let's see what the server says about the transfer we
        just performed: */
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     /* 226 Transfer complete, 250 Requested file action okay, completed. */
     if((ftpcode != 226) && (ftpcode != 250)) {
       failf(data, "%s", buf+4);
@@ -526,15 +517,15 @@
   if(data->postquote) {
     qitem = data->postquote;
     /* Send all QUOTE strings in same order as on command-line */
     while (qitem) {
       /* Send string */
       if (qitem->data) {
-        ftpsendf(data->firstsocket, conn, "%s", qitem->data);
+        ftpsendf(conn->firstsocket, conn, "%s", qitem->data);
 
-        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if (ftpcode >= 400) {
           failf(data, "QUOT string not accepted: %s",
                 qitem->data);
@@ -557,38 +548,39 @@
   size_t nread;
   CURLcode result;
   struct UrlData *data=conn->data;
   char *buf = data->buffer; /* this is our buffer */
   /* for the ftp PORT mode */
   int portsock=-1;
-  struct sockaddr_in serv_addr;
-  char hostent_buf[8192];
 #if defined (HAVE_INET_NTOA_R)
   char ntoa_buf[64];
 #endif
 #ifdef ENABLE_IPV6
   struct addrinfo *ai;
+#else
+  struct sockaddr_in serv_addr;
+  char hostent_buf[8192];
 #endif
 
   struct curl_slist *qitem; /* QUOTE item */
   /* the ftp struct is already inited in ftp_connect() */
-  struct FTP *ftp = data->proto.ftp;
+  struct FTP *ftp = conn->proto.ftp;
 
   long *bytecountp = ftp->bytecountp;
   int ftpcode; /* for ftp status */
 
   /* Send any QUOTE strings? */
   if(data->quote) {
     qitem = data->quote;
     /* Send all QUOTE strings in same order as on command-line */
     while (qitem) {
       /* Send string */
       if (qitem->data) {
-        ftpsendf(data->firstsocket, conn, "%s", qitem->data);
+        ftpsendf(conn->firstsocket, conn, "%s", qitem->data);
 
-        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if (ftpcode >= 400) {
           failf(data, "QUOT string not accepted: %s",
                 qitem->data);
@@ -596,31 +588,48 @@
         }
       }
       qitem = qitem->next;
     }
   }
 
+  if(conn->bits.reuse) {
+    /* This is a re-used connection. Since we change directory to where the
+       transfer is taking place, we must now get back to the original dir
+       where we ended up after login: */
+    ftpsendf(conn->firstsocket, conn, "CWD %s", ftp->entrypath);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
+    if(nread < 0)
+      return CURLE_OPERATION_TIMEOUTED;
+    
+    if(ftpcode != 250) {
+      failf(data, "Couldn't change back to directory %s", ftp->entrypath);
+      return CURLE_FTP_ACCESS_DENIED;
+    }
+  }
+
+
+
   /* change directory first! */
   if(ftp->dir && ftp->dir[0]) {
-    ftpsendf(data->firstsocket, conn, "CWD %s", ftp->dir);
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    ftpsendf(conn->firstsocket, conn, "CWD %s", ftp->dir);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 250) {
       failf(data, "Couldn't change to directory %s", ftp->dir);
       return CURLE_FTP_ACCESS_DENIED;
     }
   }
 
   if(data->bits.get_filetime && ftp->file) {
     /* we have requested to get the modified-time of the file, this is yet
        again a grey area as the MDTM is not kosher RFC959 */
-    ftpsendf(data->firstsocket, conn, "MDTM %s", ftp->file);
+    ftpsendf(conn->firstsocket, conn, "MDTM %s", ftp->file);
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode == 213) {
       /* we got a time. Format should be: "YYYYMMDDHHMMSS[.sss]" where the
          last .sss part is optional and means fractions of a second */
@@ -648,29 +657,29 @@
        may not support it! It is however the only way we have to get a file's
        size! */
     int filesize;
 
     /* Some servers return different sizes for different modes, and thus we
        must set the proper type before we check the size */
-    ftpsendf(data->firstsocket, conn, "TYPE %s",
+    ftpsendf(conn->firstsocket, conn, "TYPE %s",
              (data->bits.ftp_ascii)?"A":"I");
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 200) {
       failf(data, "Couldn't set %s mode",
             (data->bits.ftp_ascii)?"ASCII":"binary");
       return (data->bits.ftp_ascii)? CURLE_FTP_COULDNT_SET_ASCII:
         CURLE_FTP_COULDNT_SET_BINARY;
     }
 
-    ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
+    ftpsendf(conn->firstsocket, conn, "SIZE %s", ftp->file);
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 213) {
       failf(data, "Couldn't get file size: %s", buf+4);
       return CURLE_FTP_COULDNT_GET_SIZE;
@@ -706,35 +715,35 @@
 
   /* We have chosen to use the PORT command */
   if(data->bits.ftp_use_port) {
 #ifdef ENABLE_IPV6
     struct addrinfo hints, *res, *ai;
     struct sockaddr_storage ss;
-    int sslen;
+    socklen_t sslen;
     char hbuf[NI_MAXHOST];
-    char *localaddr;
+
     struct sockaddr *sa=(struct sockaddr *)&ss;
 #ifdef NI_WITHSCOPEID
     const int niflags = NI_NUMERICHOST | NI_NUMERICSERV | NI_WITHSCOPEID;
 #else
     const int niflags = NI_NUMERICHOST | NI_NUMERICSERV;
 #endif
-    unsigned char *ap;
-    unsigned char *pp;
+    char *ap;
+    char *pp;
     int alen, plen;
     char portmsgbuf[4096], tmp[4096];
-    char *p;
+
     char *mode[] = { "EPRT", "LPRT", "PORT", NULL };
     char **modep;
 
     /*
      * we should use Curl_if2ip?  given pickiness of recent ftpd,
      * I believe we should use the same address as the control connection.
      */
     sslen = sizeof(ss);
-    if (getsockname(data->firstsocket, (struct sockaddr *)&ss, &sslen) < 0)
+    if (getsockname(conn->firstsocket, (struct sockaddr *)&ss, &sslen) < 0)
       return CURLE_FTP_PORT_FAILED;
 
     if (getnameinfo((struct sockaddr *)&ss, sslen, hbuf, sizeof(hbuf), NULL, 0,
 	niflags))
       return CURLE_FTP_PORT_FAILED;
 
@@ -752,19 +761,19 @@
     for (ai = res; ai; ai = ai->ai_next) {
       portsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
       if (portsock < 0)
 	continue;
 
       if (bind(portsock, ai->ai_addr, ai->ai_addrlen) < 0) {
-	close(portsock);
+	sclose(portsock);
 	portsock = -1;
 	continue;
       }
 
       if (listen(portsock, 1) < 0) {
-	close(portsock);
+	sclose(portsock);
 	portsock = -1;
 	continue;
       }
 
       break;
     }
@@ -816,13 +825,13 @@
 	/* do not transmit IPv6 scope identifier to the wire */
 	if (sa->sa_family == AF_INET6) {
 	  char *q = strchr(portmsgbuf, '%');
 	  if (q)
 	    *q = '\0';
 	}
-	ftpsendf(data->firstsocket, conn, "%s |%d|%s|%s|", *modep, eprtaf,
+	ftpsendf(conn->firstsocket, conn, "%s |%d|%s|%s|", *modep, eprtaf,
 	    portmsgbuf, tmp);
       } else if (strcmp(*modep, "LPRT") == 0 || strcmp(*modep, "PORT") == 0) {
 	int i;
 
         if (strcmp(*modep, "LPRT") == 0 && lprtaf < 0)
 	  continue;
@@ -853,29 +862,29 @@
 	for (i = 0; i < plen; i++) {
 	  snprintf(tmp, sizeof(tmp), ",%u", pp[i]);
 	  if (strlcat(portmsgbuf, tmp, sizeof(portmsgbuf)) >= sizeof(portmsgbuf)) {
 	    goto again;
 	  }
 	}
-	ftpsendf(data->firstsocket, conn, "%s %s", *modep, portmsgbuf);
+	ftpsendf(conn->firstsocket, conn, "%s %s", *modep, portmsgbuf);
       }
 
-      nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+      nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
       if (nread < 0)
 	return CURLE_OPERATION_TIMEOUTED;
 
       if (ftpcode != 200) {
 	failf(data, "Server does not grok %s", *modep);
 	continue;
       } else
 	      break;
 again:;
     }
 
     if (!*modep) {
-      close(portsock);
+      sclose(portsock);
       freeaddrinfo(res);
       return CURLE_FTP_PORT_FAILED;
     }
 
 #else
     struct sockaddr_in sa;
@@ -906,13 +915,13 @@
     if ( h ) {
       if( (portsock = socket(AF_INET, SOCK_STREAM, 0)) >= 0 ) {
 
         /* we set the secondary socket variable to this for now, it
            is only so that the cleanup function will close it in case
            we fail before the true secondary stuff is made */
-        data->secondarysocket = portsock;
+        conn->secondarysocket = portsock;
 
         memset((char *)&sa, 0, sizeof(sa));
         memcpy((char *)&sa.sin_addr,
                h->h_addr,
                h->h_length);
         sa.sin_family = AF_INET;
@@ -923,13 +932,13 @@
         if(bind(portsock, (struct sockaddr *)&sa, size) >= 0) {
           /* we succeeded to bind */
           struct sockaddr_in add;
           size = sizeof(add);
 
           if(getsockname(portsock, (struct sockaddr *) &add,
-                         (int *)&size)<0) {
+                         (socklen_t *)&size)<0) {
             failf(data, "getsockname() failed");
             return CURLE_FTP_PORT_FAILED;
           }
           porttouse = ntohs(add.sin_port);
 
           if ( listen(portsock, 1) < 0 ) {
@@ -968,19 +977,19 @@
       sscanf( ntoa_buf, "%hu.%hu.%hu.%hu",
               &ip[0], &ip[1], &ip[2], &ip[3]);
 #else
       sscanf( inet_ntoa(in), "%hu.%hu.%hu.%hu",
               &ip[0], &ip[1], &ip[2], &ip[3]);
 #endif
-      ftpsendf(data->firstsocket, conn, "PORT %d,%d,%d,%d,%d,%d",
+      ftpsendf(conn->firstsocket, conn, "PORT %d,%d,%d,%d,%d,%d",
             ip[0], ip[1], ip[2], ip[3],
             porttouse >> 8,
             porttouse & 255);
     }
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 200) {
       failf(data, "Server does not grok PORT, try without it!");
       return CURLE_FTP_PORT_FAILED;
@@ -995,14 +1004,14 @@
     char *mode[] = { "PASV", NULL };
     int results[] = { 227, 0 };
 #endif
     int modeoff;
 
     for (modeoff = 0; mode[modeoff]; modeoff++) {
-      ftpsendf(data->firstsocket, conn, mode[modeoff]);
-      nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+      ftpsendf(conn->firstsocket, conn, mode[modeoff]);
+      nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
 	return CURLE_OPERATION_TIMEOUTED;
 
       if (ftpcode == results[modeoff])
 	break;
     }
@@ -1018,15 +1027,16 @@
       unsigned short connectport; /* the local port connect() should use! */
       char newhost[32];
 #ifdef ENABLE_IPV6
       struct addrinfo *res;
 #else
       struct hostent *he;
-#endif
-      char *str=buf,*ip_addr;
       char *hostdataptr=NULL;
+      char *ip_addr;
+#endif
+      char *str=buf;
 
       /*
        * New 227-parser June 3rd 1999.
        * It now scans for a sequence of six comma-separated numbers and
        * will take them as IP+port indicators.
        *
@@ -1054,18 +1064,18 @@
         /*
          * This is a tunnel through a http proxy and we need to connect to the
          * proxy again here. We already have the name info for it since the
          * previous lookup.
          */
 #ifdef ENABLE_IPV6
-        res = conn->res;
+        res = conn->hp;
 #else
         he = conn->hp;
 #endif
         connectport =
-          (unsigned short)data->port; /* we connect to the proxy's port */
+          (unsigned short)conn->port; /* we connect to the proxy's port */
       }
       else {
         /* normal, direct, ftp connection */
 #ifdef ENABLE_IPV6
         res = Curl_getaddrinfo(data, newhost, newport);
         if(!res)
@@ -1078,21 +1088,21 @@
           return CURLE_FTP_CANT_GET_HOST;
         }
         connectport = newport; /* we connect to the remote port */
       }
 	
 #ifdef ENABLE_IPV6
-      data->secondarysocket = -1;
+      conn->secondarysocket = -1;
       for (ai = res; ai; ai = ai->ai_next) {
 	/* XXX for now, we can do IPv4 only */
 	if (ai->ai_family != AF_INET)
 	  continue;
 
-	data->secondarysocket = socket(ai->ai_family, ai->ai_socktype,
+	conn->secondarysocket = socket(ai->ai_family, ai->ai_socktype,
 	    ai->ai_protocol);
-	if (data->secondarysocket < 0)
+	if (conn->secondarysocket < 0)
 	  continue;
 
 	if(data->bits.verbose) {
 	  char hbuf[NI_MAXHOST];
 	  char nbuf[NI_MAXHOST];
 	  char sbuf[NI_MAXSERV];
@@ -1111,27 +1121,27 @@
 	    infof(data, "Connecting to %s port %s\n", nbuf, sbuf);
 	  } else {
 	    infof(data, "Connecting to %s (%s) port %s\n", hbuf, nbuf, sbuf);
 	  }
 	}
 
-	if (connect(data->secondarysocket, ai->ai_addr, ai->ai_addrlen) < 0) {
-	  close(data->secondarysocket);
-	  data->secondarysocket = -1;
+	if (connect(conn->secondarysocket, ai->ai_addr, ai->ai_addrlen) < 0) {
+	  close(conn->secondarysocket);
+	  conn->secondarysocket = -1;
 	  continue;
 	}
 
 	break;
       }
 
-      if (data->secondarysocket < 0) {
+      if (conn->secondarysocket < 0) {
 	failf(data, strerror(errno));
         return CURLE_FTP_CANT_RECONNECT;
       }
 #else
-      data->secondarysocket = socket(AF_INET, SOCK_STREAM, 0);
+      conn->secondarysocket = socket(AF_INET, SOCK_STREAM, 0);
 
       memset((char *) &serv_addr, '\0', sizeof(serv_addr));
       memcpy((char *)&(serv_addr.sin_addr), he->h_addr, he->h_length);
       serv_addr.sin_family = he->h_addrtype;
 
       serv_addr.sin_port = htons(connectport);
@@ -1199,37 +1209,37 @@
               connectport);
       }
 	
       if(hostdataptr)
         free(hostdataptr);
 
-      if (connect(data->secondarysocket, (struct sockaddr *) &serv_addr,
+      if (connect(conn->secondarysocket, (struct sockaddr *) &serv_addr,
                   sizeof(serv_addr)) < 0) {
         switch(errno) {
 #ifdef ECONNREFUSED
           /* this should be made nicer */
         case ECONNREFUSED:
           failf(data, "Connection refused by ftp server");
           break;
 #endif
 #ifdef EINTR
         case EINTR:
-          failf(data, "Connection timeouted to ftp server");
+          failf(data, "Connection timed out to ftp server");
           break;
 #endif
         default:
           failf(data, "Can't connect to ftp server");
           break;
         }
         return CURLE_FTP_CANT_RECONNECT;
       }
 #endif /*ENABLE_IPV6*/
 
       if (data->bits.tunnel_thru_httpproxy) {
         /* We want "seamless" FTP operations through HTTP proxy tunnel */
-        result = Curl_ConnectHTTPProxyTunnel(conn, data->secondarysocket,
+        result = Curl_ConnectHTTPProxyTunnel(conn, conn->secondarysocket,
                                              newhost, newport);
         if(CURLE_OK != result)
           return result;
       }
     } else {
       return CURLE_FTP_CANT_RECONNECT;
@@ -1238,16 +1248,16 @@
   /* we have the (new) data connection ready */
   infof(data, "Connected the data stream!\n");
 
   if(data->bits.upload) {
 
     /* Set type to binary (unless specified ASCII) */
-    ftpsendf(data->firstsocket, conn, "TYPE %s",
+    ftpsendf(conn->firstsocket, conn, "TYPE %s",
           (data->bits.ftp_ascii)?"A":"I");
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode != 200) {
       failf(data, "Couldn't set %s mode",
             (data->bits.ftp_ascii)?"ASCII":"binary");
@@ -1270,15 +1280,15 @@
       /* => transfer as usual */
 
       if(data->resume_from < 0 ) {
         /* we could've got a specified offset from the command line,
            but now we know we didn't */
 
-        ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
+        ftpsendf(conn->firstsocket, conn, "SIZE %s", ftp->file);
 
-        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 213) {
           failf(data, "Couldn't get file size: %s", buf+4);
           return CURLE_FTP_COULDNT_GET_SIZE;
@@ -1329,41 +1339,41 @@
       }
     }
 
     /* Send everything on data->in to the socket */
     if(data->bits.ftp_append)
       /* we append onto the file instead of rewriting it */
-      ftpsendf(data->firstsocket, conn, "APPE %s", ftp->file);
+      ftpsendf(conn->firstsocket, conn, "APPE %s", ftp->file);
     else
-      ftpsendf(data->firstsocket, conn, "STOR %s", ftp->file);
+      ftpsendf(conn->firstsocket, conn, "STOR %s", ftp->file);
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if(ftpcode>=400) {
       failf(data, "Failed FTP upload:%s", buf+3);
       /* oops, we never close the sockets! */
       return CURLE_FTP_COULDNT_STOR_FILE;
     }
 
     if(data->bits.ftp_use_port) {
-      result = AllowServerConnect(data, portsock);
+      result = AllowServerConnect(data, conn, portsock);
       if( result )
         return result;
     }
 
     *bytecountp=0;
 
     /* When we know we're uploading a specified file, we can get the file
        size prior to the actual upload. */
 
     Curl_pgrsSetUploadSize(data, data->infilesize);
 
     result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
-                      data->secondarysocket, bytecountp);
+                      conn->secondarysocket, bytecountp);
     if(result)
       return result;
       
   }
   else {
     /* Retrieve file or directory */
@@ -1389,59 +1399,59 @@
         data->resume_from = from;
         infof(data, "FTP RANGE %d to end of file\n", from);
       }
       else if(from < 0) {
         /* -Y */
         totalsize = -from;
-        data->maxdownload = -from;
+        conn->maxdownload = -from;
         data->resume_from = from;
         infof(data, "FTP RANGE the last %d bytes\n", totalsize);
       }
       else {
         /* X-Y */
         totalsize = to-from;
-        data->maxdownload = totalsize+1; /* include the last mentioned byte */
+        conn->maxdownload = totalsize+1; /* include the last mentioned byte */
         data->resume_from = from;
-        infof(data, "FTP RANGE from %d getting %d bytes\n", from, data->maxdownload);
+        infof(data, "FTP RANGE from %d getting %d bytes\n", from, conn->maxdownload);
       }
       infof(data, "range-download from %d to %d, totally %d bytes\n",
             from, to, totalsize);
     }
 
     if((data->bits.ftp_list_only) || !ftp->file) {
       /* The specified path ends with a slash, and therefore we think this
          is a directory that is requested, use LIST. But before that we
          need to set ASCII transfer mode. */
       dirlist = TRUE;
 
       /* Set type to ASCII */
-      ftpsendf(data->firstsocket, conn, "TYPE A");
+      ftpsendf(conn->firstsocket, conn, "TYPE A");
 	
-      nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+      nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 	
       if(ftpcode != 200) {
         failf(data, "Couldn't set ascii mode");
         return CURLE_FTP_COULDNT_SET_ASCII;
       }
 
       /* if this output is to be machine-parsed, the NLST command will be
          better used since the LIST command output is not specified or
          standard in any way */
 
-      ftpsendf(data->firstsocket, conn, "%s",
+      ftpsendf(conn->firstsocket, conn, "%s",
             data->customrequest?data->customrequest:
             (data->bits.ftp_list_only?"NLST":"LIST"));
     }
     else {
       /* Set type to binary (unless specified ASCII) */
-      ftpsendf(data->firstsocket, conn, "TYPE %s",
+      ftpsendf(conn->firstsocket, conn, "TYPE %s",
                (data->bits.ftp_ascii)?"A":"I");
 
-      nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+      nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
       if(nread < 0)
         return CURLE_OPERATION_TIMEOUTED;
 
       if(ftpcode != 200) {
         failf(data, "Couldn't set %s mode",
               (data->bits.ftp_ascii)?"ASCII":"binary");
@@ -1454,15 +1464,15 @@
         /* Daniel: (August 4, 1999)
          *
          * We start with trying to use the SIZE command to figure out the size
          * of the file we're gonna get. If we can get the size, this is by far
          * the best way to know if we're trying to resume beyond the EOF.  */
 
-        ftpsendf(data->firstsocket, conn, "SIZE %s", ftp->file);
+        ftpsendf(conn->firstsocket, conn, "SIZE %s", ftp->file);
 
-        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 213) {
           infof(data, "server doesn't support SIZE: %s", buf+4);
           /* We couldn't get the size and therefore we can't know if there
@@ -1498,28 +1508,28 @@
         }
 
         /* Set resume file transfer offset */
         infof(data, "Instructs server to resume from offset %d\n",
               data->resume_from);
 
-        ftpsendf(data->firstsocket, conn, "REST %d", data->resume_from);
+        ftpsendf(conn->firstsocket, conn, "REST %d", data->resume_from);
 
-        nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+        nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
         if(nread < 0)
           return CURLE_OPERATION_TIMEOUTED;
 
         if(ftpcode != 350) {
           failf(data, "Couldn't use REST: %s", buf+4);
           return CURLE_FTP_COULDNT_USE_REST;
         }
       }
 
-      ftpsendf(data->firstsocket, conn, "RETR %s", ftp->file);
+      ftpsendf(conn->firstsocket, conn, "RETR %s", ftp->file);
     }
 
-    nread = Curl_GetFTPResponse(data->firstsocket, buf, conn, &ftpcode);
+    nread = Curl_GetFTPResponse(conn->firstsocket, buf, conn, &ftpcode);
     if(nread < 0)
       return CURLE_OPERATION_TIMEOUTED;
 
     if((ftpcode == 150) || (ftpcode == 125)) {
 
       /*
@@ -1577,21 +1587,21 @@
         }
       }
       else if(downloadsize > -1)
         size = downloadsize;
 
       if(data->bits.ftp_use_port) {
-        result = AllowServerConnect(data, portsock);
+        result = AllowServerConnect(data, conn, portsock);
         if( result )
           return result;
       }
 
       infof(data, "Getting file with size: %d\n", size);
 
       /* FTP download: */
-      result=Curl_Transfer(conn, data->secondarysocket, size, FALSE,
+      result=Curl_Transfer(conn, conn->secondarysocket, size, FALSE,
                       bytecountp,
                       -1, NULL); /* no upload here */
       if(result)
         return result;
     }
     else {
@@ -1614,13 +1624,13 @@
 
   struct UrlData *data = conn->data;
   struct FTP *ftp;
   int dirlength=0; /* 0 forces strlen() */
 
   /* the ftp struct is already inited in ftp_connect() */
-  ftp = data->proto.ftp;
+  ftp = conn->proto.ftp;
 
   /* We split the path into dir and file parts *before* we URLdecode
      it */
   ftp->file = strrchr(conn->ppath, '/');
   if(ftp->file) {
     if(ftp->file != conn->ppath)
@@ -1703,6 +1713,19 @@
       bytes_written = swrite(fd, s, strlen(s));
     }
   return(bytes_written);
 }
 
 
+CURLcode Curl_ftp_disconnect(struct connectdata *conn)
+{
+  struct FTP *ftp= conn->proto.ftp;
+
+  if(ftp->user)
+    free(ftp->user);
+  if(ftp->passwd)
+    free(ftp->passwd);
+  if(ftp->entrypath)
+    free(ftp->entrypath);
+
+  return CURLE_OK;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ftp.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ftp.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ftp.h	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ftp.h	2001-03-02 15:44:22.000000000 +0800
@@ -18,23 +18,21 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ftp.h,v 1.6 2001/01/05 10:11:42 bagder Exp $
+ * $Id: ftp.h,v 1.7 2001/03/02 07:44:22 bagder Exp $
  *****************************************************************************/
 CURLcode Curl_ftp(struct connectdata *conn);
 CURLcode Curl_ftp_done(struct connectdata *conn);
 CURLcode Curl_ftp_connect(struct connectdata *conn);
+CURLcode Curl_ftp_disconnect(struct connectdata *conn);
 
 size_t Curl_ftpsendf(int fd, struct connectdata *, char *fmt, ...);
 
-struct curl_slist *curl_slist_append(struct curl_slist *list, char *data);
-void curl_slist_free_all(struct curl_slist *list);
-
 /* The kerberos stuff needs this: */
 int Curl_GetFTPResponse(int sockfd, char *buf,
                         struct connectdata *conn,
                         int *ftpcode);
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getdate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getdate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getdate.c	2000-10-30 19:50:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getdate.c	2001-03-16 23:21:43.000000000 +0800
@@ -101,12 +101,17 @@
 #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
 
 #if defined (STDC_HEADERS) || defined (USG)
 # include <string.h>
 #endif
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
 # define __attribute__(x)
 #endif
 
 #ifndef ATTRIBUTE_UNUSED
 # define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
@@ -219,13 +224,13 @@
 static int	yyRelMinutes;
 static int	yyRelMonth;
 static int	yyRelSeconds;
 static int	yyRelYear;
 
 
-#line 205 "getdate.y"
+#line 210 "getdate.y"
 typedef union {
     int			Number;
     enum _MERIDIAN	Meridian;
 } YYSTYPE;
 #include <stdio.h>
 
@@ -302,17 +307,17 @@
 };
 
 #endif
 
 #if YYDEBUG != 0
 static const short yyrline[] = { 0,
-   221,   222,   225,   228,   231,   234,   237,   240,   243,   249,
-   255,   264,   270,   282,   285,   288,   294,   298,   302,   308,
-   312,   330,   336,   342,   346,   351,   355,   362,   370,   373,
-   376,   379,   382,   385,   388,   391,   394,   397,   400,   403,
-   406,   409,   412,   415,   418,   421,   424,   429,   462,   466
+   226,   227,   230,   233,   236,   239,   242,   245,   248,   254,
+   260,   269,   275,   287,   290,   293,   299,   303,   307,   313,
+   317,   335,   341,   347,   351,   356,   360,   367,   375,   378,
+   381,   384,   387,   390,   393,   396,   399,   402,   405,   408,
+   411,   414,   417,   420,   423,   426,   429,   434,   467,   471
 };
 #endif
 
 
 #if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
 
@@ -387,13 +392,13 @@
      7,     3,     8,    20,    10,    11,    12,    13,    14,    15,
     15,    17,    16,    19,     5,    21,    10,     8,    16,    16,
     11,    15,    13,    14,    16,    19,    17,    16,    21,     0,
     56
 };
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/local/share/bison.simple"
+#line 3 "/usr/lib/bison.simple"
 /* This file comes from bison-1.28.  */
 
 /* Skeleton output parser for bison,
    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
@@ -601,13 +606,13 @@
     *t++ = *f++;
 }
 
 #endif
 #endif
 
-#line 217 "/usr/local/share/bison.simple"
+#line 217 "/usr/lib/bison.simple"
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
    It should actually point to an object.
    Grammar actions can access the variable by casting it
    to the proper pointer type.  */
@@ -930,141 +935,141 @@
 #endif
 
 
   switch (yyn) {
 
 case 3:
-#line 225 "getdate.y"
+#line 230 "getdate.y"
 {
 	    yyHaveTime++;
 	;
     break;}
 case 4:
-#line 228 "getdate.y"
+#line 233 "getdate.y"
 {
 	    yyHaveZone++;
 	;
     break;}
 case 5:
-#line 231 "getdate.y"
+#line 236 "getdate.y"
 {
 	    yyHaveDate++;
 	;
     break;}
 case 6:
-#line 234 "getdate.y"
+#line 239 "getdate.y"
 {
 	    yyHaveDay++;
 	;
     break;}
 case 7:
-#line 237 "getdate.y"
+#line 242 "getdate.y"
 {
 	    yyHaveRel++;
 	;
     break;}
 case 9:
-#line 243 "getdate.y"
+#line 248 "getdate.y"
 {
 	    yyHour = yyvsp[-1].Number;
 	    yyMinutes = 0;
 	    yySeconds = 0;
 	    yyMeridian = yyvsp[0].Meridian;
 	;
     break;}
 case 10:
-#line 249 "getdate.y"
+#line 254 "getdate.y"
 {
 	    yyHour = yyvsp[-3].Number;
 	    yyMinutes = yyvsp[-1].Number;
 	    yySeconds = 0;
 	    yyMeridian = yyvsp[0].Meridian;
 	;
     break;}
 case 11:
-#line 255 "getdate.y"
+#line 260 "getdate.y"
 {
 	    yyHour = yyvsp[-3].Number;
 	    yyMinutes = yyvsp[-1].Number;
 	    yyMeridian = MER24;
 	    yyHaveZone++;
 	    yyTimezone = (yyvsp[0].Number < 0
 			  ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
 			  : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
 	;
     break;}
 case 12:
-#line 264 "getdate.y"
+#line 269 "getdate.y"
 {
 	    yyHour = yyvsp[-5].Number;
 	    yyMinutes = yyvsp[-3].Number;
 	    yySeconds = yyvsp[-1].Number;
 	    yyMeridian = yyvsp[0].Meridian;
 	;
     break;}
 case 13:
-#line 270 "getdate.y"
+#line 275 "getdate.y"
 {
 	    yyHour = yyvsp[-5].Number;
 	    yyMinutes = yyvsp[-3].Number;
 	    yySeconds = yyvsp[-1].Number;
 	    yyMeridian = MER24;
 	    yyHaveZone++;
 	    yyTimezone = (yyvsp[0].Number < 0
 			  ? -yyvsp[0].Number % 100 + (-yyvsp[0].Number / 100) * 60
 			  : - (yyvsp[0].Number % 100 + (yyvsp[0].Number / 100) * 60));
 	;
     break;}
 case 14:
-#line 282 "getdate.y"
+#line 287 "getdate.y"
 {
 	    yyTimezone = yyvsp[0].Number;
 	;
     break;}
 case 15:
-#line 285 "getdate.y"
+#line 290 "getdate.y"
 {
 	    yyTimezone = yyvsp[0].Number - 60;
 	;
     break;}
 case 16:
-#line 289 "getdate.y"
+#line 294 "getdate.y"
 {
 	    yyTimezone = yyvsp[-1].Number - 60;
 	;
     break;}
 case 17:
-#line 294 "getdate.y"
+#line 299 "getdate.y"
 {
 	    yyDayOrdinal = 1;
 	    yyDayNumber = yyvsp[0].Number;
 	;
     break;}
 case 18:
-#line 298 "getdate.y"
+#line 303 "getdate.y"
 {
 	    yyDayOrdinal = 1;
 	    yyDayNumber = yyvsp[-1].Number;
 	;
     break;}
 case 19:
-#line 302 "getdate.y"
+#line 307 "getdate.y"
 {
 	    yyDayOrdinal = yyvsp[-1].Number;
 	    yyDayNumber = yyvsp[0].Number;
 	;
     break;}
 case 20:
-#line 308 "getdate.y"
+#line 313 "getdate.y"
 {
 	    yyMonth = yyvsp[-2].Number;
 	    yyDay = yyvsp[0].Number;
 	;
     break;}
 case 21:
-#line 312 "getdate.y"
+#line 317 "getdate.y"
 {
 	  /* Interpret as YYYY/MM/DD if $1 >= 1000, otherwise as MM/DD/YY.
 	     The goal in recognizing YYYY/MM/DD is solely to support legacy
 	     machine-generated dates like those in an RCS log listing.  If
 	     you want portability, use the ISO 8601 format.  */
 	  if (yyvsp[-4].Number >= 1000)
@@ -1079,180 +1084,180 @@
 	      yyDay = yyvsp[-2].Number;
 	      yyYear = yyvsp[0].Number;
 	    }
 	;
     break;}
 case 22:
-#line 330 "getdate.y"
+#line 335 "getdate.y"
 {
 	    /* ISO 8601 format.  yyyy-mm-dd.  */
 	    yyYear = yyvsp[-2].Number;
 	    yyMonth = -yyvsp[-1].Number;
 	    yyDay = -yyvsp[0].Number;
 	;
     break;}
 case 23:
-#line 336 "getdate.y"
+#line 341 "getdate.y"
 {
 	    /* e.g. 17-JUN-1992.  */
 	    yyDay = yyvsp[-2].Number;
 	    yyMonth = yyvsp[-1].Number;
 	    yyYear = -yyvsp[0].Number;
 	;
     break;}
 case 24:
-#line 342 "getdate.y"
+#line 347 "getdate.y"
 {
 	    yyMonth = yyvsp[-1].Number;
 	    yyDay = yyvsp[0].Number;
 	;
     break;}
 case 25:
-#line 346 "getdate.y"
+#line 351 "getdate.y"
 {
 	    yyMonth = yyvsp[-3].Number;
 	    yyDay = yyvsp[-2].Number;
 	    yyYear = yyvsp[0].Number;
 	;
     break;}
 case 26:
-#line 351 "getdate.y"
+#line 356 "getdate.y"
 {
 	    yyMonth = yyvsp[0].Number;
 	    yyDay = yyvsp[-1].Number;
 	;
     break;}
 case 27:
-#line 355 "getdate.y"
+#line 360 "getdate.y"
 {
 	    yyMonth = yyvsp[-1].Number;
 	    yyDay = yyvsp[-2].Number;
 	    yyYear = yyvsp[0].Number;
 	;
     break;}
 case 28:
-#line 362 "getdate.y"
+#line 367 "getdate.y"
 {
 	    yyRelSeconds = -yyRelSeconds;
 	    yyRelMinutes = -yyRelMinutes;
 	    yyRelHour = -yyRelHour;
 	    yyRelDay = -yyRelDay;
 	    yyRelMonth = -yyRelMonth;
 	    yyRelYear = -yyRelYear;
 	;
     break;}
 case 30:
-#line 373 "getdate.y"
+#line 378 "getdate.y"
 {
 	    yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 31:
-#line 376 "getdate.y"
+#line 381 "getdate.y"
 {
 	    yyRelYear += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 32:
-#line 379 "getdate.y"
+#line 384 "getdate.y"
 {
 	    yyRelYear += yyvsp[0].Number;
 	;
     break;}
 case 33:
-#line 382 "getdate.y"
+#line 387 "getdate.y"
 {
 	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 34:
-#line 385 "getdate.y"
+#line 390 "getdate.y"
 {
 	    yyRelMonth += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 35:
-#line 388 "getdate.y"
+#line 393 "getdate.y"
 {
 	    yyRelMonth += yyvsp[0].Number;
 	;
     break;}
 case 36:
-#line 391 "getdate.y"
+#line 396 "getdate.y"
 {
 	    yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 37:
-#line 394 "getdate.y"
+#line 399 "getdate.y"
 {
 	    yyRelDay += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 38:
-#line 397 "getdate.y"
+#line 402 "getdate.y"
 {
 	    yyRelDay += yyvsp[0].Number;
 	;
     break;}
 case 39:
-#line 400 "getdate.y"
+#line 405 "getdate.y"
 {
 	    yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 40:
-#line 403 "getdate.y"
+#line 408 "getdate.y"
 {
 	    yyRelHour += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 41:
-#line 406 "getdate.y"
+#line 411 "getdate.y"
 {
 	    yyRelHour += yyvsp[0].Number;
 	;
     break;}
 case 42:
-#line 409 "getdate.y"
+#line 414 "getdate.y"
 {
 	    yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 43:
-#line 412 "getdate.y"
+#line 417 "getdate.y"
 {
 	    yyRelMinutes += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 44:
-#line 415 "getdate.y"
+#line 420 "getdate.y"
 {
 	    yyRelMinutes += yyvsp[0].Number;
 	;
     break;}
 case 45:
-#line 418 "getdate.y"
+#line 423 "getdate.y"
 {
 	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 46:
-#line 421 "getdate.y"
+#line 426 "getdate.y"
 {
 	    yyRelSeconds += yyvsp[-1].Number * yyvsp[0].Number;
 	;
     break;}
 case 47:
-#line 424 "getdate.y"
+#line 429 "getdate.y"
 {
 	    yyRelSeconds += yyvsp[0].Number;
 	;
     break;}
 case 48:
-#line 430 "getdate.y"
+#line 435 "getdate.y"
 {
 	    if (yyHaveTime && yyHaveDate && !yyHaveRel)
 	      yyYear = yyvsp[0].Number;
 	    else
 	      {
 		if (yyvsp[0].Number>10000)
@@ -1279,26 +1284,26 @@
 		    yyMeridian = MER24;
 		  }
 	      }
 	  ;
     break;}
 case 49:
-#line 463 "getdate.y"
+#line 468 "getdate.y"
 {
 	    yyval.Meridian = MER24;
 	  ;
     break;}
 case 50:
-#line 467 "getdate.y"
+#line 472 "getdate.y"
 {
 	    yyval.Meridian = yyvsp[0].Meridian;
 	  ;
     break;}
 }
    /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/local/share/bison.simple"
+#line 543 "/usr/lib/bison.simple"
 
   yyvsp -= yylen;
   yyssp -= yylen;
 #ifdef YYLSP_NEEDED
   yylsp -= yylen;
 #endif
@@ -1512,13 +1517,13 @@
 #ifdef YYLSP_NEEDED
       free (yyls);
 #endif
     }
   return 1;
 }
-#line 472 "getdate.y"
+#line 477 "getdate.y"
 
 
 /* Include this file down here because bison inserts code above which
    may define-away `const'.  We want the prototype for get_date to have
    the same signature as the function definition does. */
 #include "getdate.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getdate.y /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getdate.y
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getdate.y	2000-10-30 19:50:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getdate.y	2001-03-16 23:21:43.000000000 +0800
@@ -77,12 +77,17 @@
 #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
 
 #if defined (STDC_HEADERS) || defined (USG)
 # include <string.h>
 #endif
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
 # define __attribute__(x)
 #endif
 
 #ifndef ATTRIBUTE_UNUSED
 # define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getinfo.c	2001-02-05 04:03:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getinfo.c	2001-03-10 00:50:36.000000000 +0800
@@ -15,26 +15,26 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: getinfo.c,v 1.7 2001/02/04 20:03:30 bagder Exp $
+ * $Id: getinfo.c,v 1.8 2001/03/09 15:13:11 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
 #include "urldata.h"
 
 #include <stdio.h>
 #include <string.h>
 #include <stdarg.h>
 
-CURLcode curl_getinfo(CURL *curl, CURLINFO info, ...)
+CURLcode Curl_getinfo(CURL *curl, CURLINFO info, ...)
 {
   va_list arg;
   long *param_longp;
   double *param_doublep;
   char **param_charp;
   struct UrlData *data = (struct UrlData *)curl;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getpass.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getpass.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/getpass.c	2000-12-05 16:04:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/getpass.c	2001-03-16 23:21:43.000000000 +0800
@@ -19,13 +19,13 @@
  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  * ============================================================================
  *
- * $Id: getpass.c,v 1.11 2000/12/05 08:04:04 bagder Exp $
+ * $Id: getpass.c,v 1.12 2001/03/16 15:19:36 bagder Exp $
  *
  * The spirit of this license is to allow use of this source code in any
  * project be it open or closed but still encourage the use of the open,
  * library based equivilents.
  *
  * Author(s):
@@ -63,12 +63,17 @@
 #  ifdef HAVE_TERMIO_H
 #  include <termio.h>
 #  else
 #  endif
 #endif
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 /* no perror? make an fprintf! */
 #ifndef HAVE_PERROR
 #  define perror(x) fprintf(stderr, "Error in: %s\n", x)
 #endif
 
 char *getpass_r(const char *prompt, char *buffer, size_t buflen)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/http.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/http.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/http.c	2001-02-13 21:34:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/http.c	2001-03-14 22:11:11.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.c,v 1.48 2001/02/13 13:34:16 bagder Exp $
+ * $Id: http.c,v 1.58 2001/03/14 14:11:11 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -101,12 +101,13 @@
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
+/* ------------------------------------------------------------------------- */
 /*
  * The add_buffer series of functions are used to build one large memory chunk
  * from repeated function invokes. Used so that the entire HTTP request can
  * be sent in one go.
  */
 static CURLcode
@@ -202,13 +203,13 @@
   }
 
   return CURLE_OK;
 }
 
 /* end of the add_buffer functions */
-/*****************************************************************************/
+/* ------------------------------------------------------------------------- */
 
 /*
  * Read everything until a newline.
  */
 
 static
@@ -279,14 +280,14 @@
   Curl_sendf(tunnelsocket, conn,
              "CONNECT %s:%d HTTP/1.0\015\012"
              "%s"
              "%s"
              "\r\n",
              hostname, remote_port,
-             (data->bits.proxy_user_passwd)?data->ptr_proxyuserpwd:"",
-             (data->useragent?data->ptr_uagent:"")
+             (conn->bits.proxy_user_passwd)?conn->allocptr.proxyuserpwd:"",
+             (data->useragent?conn->allocptr.uagent:"")
              );
 
   /* wait for the proxy to send us a HTTP/1.0 200 OK header */
   while(GetLine(tunnelsocket, data->buffer, conn)) {
     if('\r' == data->buffer[0])
       break; /* end of headers */
@@ -306,12 +307,15 @@
   }
 
   infof (data, "Proxy replied to CONNECT request\n");
   return CURLE_OK;
 }
 
+/*
+ * HTTP stuff to do at connect-time.
+ */
 CURLcode Curl_http_connect(struct connectdata *conn)
 {
   struct UrlData *data;
   CURLcode result;
 
   data=conn->data;
@@ -322,27 +326,27 @@
    * us to the host we want to talk to.  Only after the connect
    * has occured, can we start talking SSL
    */
   if (conn->protocol & PROT_HTTPS) {
     if (data->bits.httpproxy) {
       /* HTTPS through a proxy can only be done with a tunnel */
-      result = Curl_ConnectHTTPProxyTunnel(conn, data->firstsocket,
-                                           data->hostname, data->remote_port);
+      result = Curl_ConnectHTTPProxyTunnel(conn, conn->firstsocket,
+                                           conn->hostname, conn->remote_port);
       if(CURLE_OK != result)
         return result;
     }
 
     /* now, perform the SSL initialization for this socket */
-    if(Curl_SSLConnect(data))
+    if(Curl_SSLConnect(conn))
       return CURLE_SSL_CONNECT_ERROR;
   }
 
-  if(data->bits.user_passwd && !data->bits.this_is_a_follow) {
+  if(conn->bits.user_passwd && !data->bits.this_is_a_follow) {
     /* Authorization: is requested, this is not a followed location, get the
        original host name */
-    data->auth_host = strdup(data->hostname);
+    data->auth_host = strdup(conn->hostname);
   }
 
   return CURLE_OK;
 }
 
 /* called from curl_close() when this struct is about to get wasted, free
@@ -358,13 +362,13 @@
 {
   struct UrlData *data;
   long *bytecount = &conn->bytecount;
   struct HTTP *http;
 
   data=conn->data;
-  http=data->proto.http;
+  http=conn->proto.http;
 
   if(data->bits.http_formpost) {
     *bytecount = http->readbytecount + http->writebytecount;
       
     Curl_FormFree(http->sendit); /* Now free that whole lot */
 
@@ -387,54 +391,69 @@
   struct HTTP *http;
   struct Cookie *co=NULL; /* no cookies from start */
   char *ppath = conn->ppath; /* three previous function arguments */
   char *host = conn->name;
   long *bytecount = &conn->bytecount;
 
-  http = (struct HTTP *)malloc(sizeof(struct HTTP));
-  if(!http)
-    return CURLE_OUT_OF_MEMORY;
-  memset(http, 0, sizeof(struct HTTP));
-  data->proto.http = http;
+  if(!conn->proto.http) {
+    /* Only allocate this struct if we don't already have it! */
+
+    http = (struct HTTP *)malloc(sizeof(struct HTTP));
+    if(!http)
+      return CURLE_OUT_OF_MEMORY;
+    memset(http, 0, sizeof(struct HTTP));
+    conn->proto.http = http;
+  }
+  else
+    http = conn->proto.http;
+
+  /* We default to persistant connections */
+  conn->bits.close = FALSE;
 
   if ( (conn->protocol&(PROT_HTTP|PROT_FTP)) &&
        data->bits.upload) {
     data->bits.http_put=1;
   }
   
   /* The User-Agent string has been built in url.c already, because it might
      have been used in the proxy connect, but if we have got a header with
      the user-agent string specified, we erase the previously made string
      here. */
-  if(checkheaders(data, "User-Agent:") && data->ptr_uagent) {
-    free(data->ptr_uagent);
-    data->ptr_uagent=NULL;
+  if(checkheaders(data, "User-Agent:") && conn->allocptr.uagent) {
+    free(conn->allocptr.uagent);
+    conn->allocptr.uagent=NULL;
   }
 
-  if((data->bits.user_passwd) && !checkheaders(data, "Authorization:")) {
+  if((conn->bits.user_passwd) && !checkheaders(data, "Authorization:")) {
     char *authorization;
 
     /* To prevent the user+password to get sent to other than the original
        host due to a location-follow, we do some weirdo checks here */
     if(!data->bits.this_is_a_follow ||
        !data->auth_host ||
-       strequal(data->auth_host, data->hostname)) {
+       strequal(data->auth_host, conn->hostname)) {
       sprintf(data->buffer, "%s:%s", data->user, data->passwd);
       if(Curl_base64_encode(data->buffer, strlen(data->buffer),
                             &authorization) >= 0) {
-        data->ptr_userpwd = aprintf( "Authorization: Basic %s\015\012",
+        if(conn->allocptr.userpwd)
+          free(conn->allocptr.userpwd);
+        conn->allocptr.userpwd = aprintf( "Authorization: Basic %s\015\012",
                                      authorization);
         free(authorization);
       }
     }
   }
   if((data->bits.http_set_referer) && !checkheaders(data, "Referer:")) {
-    data->ptr_ref = aprintf("Referer: %s\015\012", data->referer);
+    if(conn->allocptr.ref)
+      free(conn->allocptr.ref);
+    conn->allocptr.ref = aprintf("Referer: %s\015\012", data->referer);
   }
   if(data->cookie && !checkheaders(data, "Cookie:")) {
-    data->ptr_cookie = aprintf("Cookie: %s\015\012", data->cookie);
+    if(conn->allocptr.cookie)
+      free(conn->allocptr.cookie);
+    conn->allocptr.cookie = aprintf("Cookie: %s\015\012", data->cookie);
   }
 
   if(data->cookies) {
     co = Curl_cookie_getlist(data->cookies,
                              host,
                              ppath,
@@ -448,19 +467,28 @@
     /* we must build the whole darned post sequence first, so that we have
        a size of the whole shebang before we start to send it */
     http->sendit = Curl_getFormData(data->httppost, &http->postsize);
   }
 
   if(!checkheaders(data, "Host:")) {
-    if(((conn->protocol&PROT_HTTPS) && (data->remote_port == PORT_HTTPS)) ||
-       (!(conn->protocol&PROT_HTTPS) && (data->remote_port == PORT_HTTP)) )
+    /* if ptr_host is already set, it is almost OK since we only re-use
+       connections to the very same host and port, but when we use a HTTP
+       proxy we have a persistant connect and yet we must change the Host:
+       header! */
+
+    if(conn->allocptr.host)
+      free(conn->allocptr.host);
+
+    if(((conn->protocol&PROT_HTTPS) && (conn->remote_port == PORT_HTTPS)) ||
+       (!(conn->protocol&PROT_HTTPS) && (conn->remote_port == PORT_HTTP)) )
       /* If (HTTPS on port 443) OR (non-HTTPS on port 80) then don't include
          the port number in the host string */
-      data->ptr_host = aprintf("Host: %s\r\n", host);
+      conn->allocptr.host = aprintf("Host: %s\r\n", host);
     else
-      data->ptr_host = aprintf("Host: %s:%d\r\n", host, data->remote_port);
+      conn->allocptr.host = aprintf("Host: %s:%d\r\n", host,
+                                    conn->remote_port);
   }
 
   if(!checkheaders(data, "Pragma:"))
     http->p_pragma = "Pragma: no-cache\r\n";
 
   if(!checkheaders(data, "Accept:"))
@@ -528,28 +556,28 @@
      * A range is selected. We use different headers whether we're downloading
      * or uploading and we always let customized headers override our internal
      * ones if any such are specified.
      */
     if((data->httpreq == HTTPREQ_GET) &&
        !checkheaders(data, "Range:")) {
-      data->ptr_rangeline = aprintf("Range: bytes=%s\r\n", data->range);
+      conn->allocptr.rangeline = aprintf("Range: bytes=%s\r\n", data->range);
     }
     else if((data->httpreq != HTTPREQ_GET) &&
             !checkheaders(data, "Content-Range:")) {
 
       if(data->resume_from) {
         /* This is because "resume" was selected */
         long total_expected_size= data->resume_from + data->infilesize;
-        data->ptr_rangeline = aprintf("Content-Range: bytes %s%ld/%ld\r\n",
+        conn->allocptr.rangeline = aprintf("Content-Range: bytes %s%ld/%ld\r\n",
                                       data->range, total_expected_size-1,
                                       total_expected_size);
       }
       else {
         /* Range was selected and then we just pass the incoming range and 
            append total size */
-        data->ptr_rangeline = aprintf("Content-Range: bytes %s/%d\r\n",
+        conn->allocptr.rangeline = aprintf("Content-Range: bytes %s/%d\r\n",
                                       data->range, data->infilesize);
       }
     }
   }
 
   do {
@@ -559,13 +587,13 @@
     /* initialize a dynamic send-buffer */
     req_buffer = add_buffer_init();
 
     /* add the main request stuff */
     add_bufferf(req_buffer,
                 "%s " /* GET/HEAD/POST/PUT */
-                "%s HTTP/1.0\r\n" /* path */
+                "%s HTTP/1.1\r\n" /* path */
                 "%s" /* proxyuserpwd */
                 "%s" /* userpwd */
                 "%s" /* range */
                 "%s" /* user agent */
                 "%s" /* cookie */
                 "%s" /* host */
@@ -575,21 +603,25 @@
 
                 data->customrequest?data->customrequest:
                 (data->bits.no_body?"HEAD":
                  (data->bits.http_post || data->bits.http_formpost)?"POST":
                  (data->bits.http_put)?"PUT":"GET"),
                 ppath,
-                (data->bits.proxy_user_passwd && data->ptr_proxyuserpwd)?data->ptr_proxyuserpwd:"",
-                (data->bits.user_passwd && data->ptr_userpwd)?data->ptr_userpwd:"",
-                (data->bits.set_range && data->ptr_rangeline)?data->ptr_rangeline:"",
-                (data->useragent && *data->useragent && data->ptr_uagent)?data->ptr_uagent:"",
-                (data->ptr_cookie?data->ptr_cookie:""), /* Cookie: <data> */
-                (data->ptr_host?data->ptr_host:""), /* Host: host */
+                (conn->bits.proxy_user_passwd &&
+                 conn->allocptr.proxyuserpwd)?conn->allocptr.proxyuserpwd:"",
+                (conn->bits.user_passwd && conn->allocptr.userpwd)?
+                conn->allocptr.userpwd:"",
+                (data->bits.set_range && conn->allocptr.rangeline)?
+                conn->allocptr.rangeline:"",
+                (data->useragent && *data->useragent && conn->allocptr.uagent)?
+                conn->allocptr.uagent:"",
+                (conn->allocptr.cookie?conn->allocptr.cookie:""), /* Cookie: <data> */
+                (conn->allocptr.host?conn->allocptr.host:""), /* Host: host */
                 http->p_pragma?http->p_pragma:"",
                 http->p_accept?http->p_accept:"",
-                (data->bits.http_set_referer && data->ptr_ref)?data->ptr_ref:"" /* Referer: <data> <CRLF> */
+                (data->bits.http_set_referer && conn->allocptr.ref)?conn->allocptr.ref:"" /* Referer: <data> <CRLF> */
                 );
 
     if(co) {
       int count=0;
       struct Cookie *store=co;
       /* now loop through all cookies that matched */
@@ -687,16 +719,16 @@
                   "Content-Length: %d\r\n", http->postsize-2);
 
       /* set upload size to the progress meter */
       Curl_pgrsSetUploadSize(data, http->postsize);
 
       data->request_size = 
-        add_buffer_send(data->firstsocket, conn, req_buffer);
-      result = Curl_Transfer(conn, data->firstsocket, -1, TRUE,
+        add_buffer_send(conn->firstsocket, conn, req_buffer);
+      result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE,
                         &http->readbytecount,
-                          data->firstsocket,
+                          conn->firstsocket,
                         &http->writebytecount);
       if(result) {
         Curl_FormFree(http->sendit); /* free that whole lot */
         return result;
       }
     }
@@ -713,18 +745,18 @@
 
       /* set the upload size to the progress meter */
       Curl_pgrsSetUploadSize(data, data->infilesize);
 
       /* this sends the buffer and frees all the buffer resources */
       data->request_size = 
-        add_buffer_send(data->firstsocket, conn, req_buffer);
+        add_buffer_send(conn->firstsocket, conn, req_buffer);
 
       /* prepare for transfer */
-      result = Curl_Transfer(conn, data->firstsocket, -1, TRUE,
+      result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE,
                         &http->readbytecount,
-                        data->firstsocket,
+                        conn->firstsocket,
                         &http->writebytecount);
       if(result)
         return result;
       
     }
     else {
@@ -759,16 +791,16 @@
       }
       else
         add_buffer(req_buffer, "\r\n", 2);
 
       /* issue the request */
       data->request_size = 
-        add_buffer_send(data->firstsocket, conn, req_buffer);
+        add_buffer_send(conn->firstsocket, conn, req_buffer);
 
       /* HTTP GET/HEAD download: */
-      result = Curl_Transfer(conn, data->firstsocket, -1, TRUE, bytecount,
+      result = Curl_Transfer(conn, conn->firstsocket, -1, TRUE, bytecount,
                         -1, NULL); /* nothing to upload */
     }
     if(result)
       return result;
   } while (0); /* this is just a left-over from the multiple document download
                   attempts */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib: http_chunks.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib: http_chunks.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/http.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/http.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/http.h	2001-01-25 20:24:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/http.h	2001-03-08 07:51:41.000000000 +0800
@@ -18,13 +18,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: http.h,v 1.10 2001/01/25 12:24:34 bagder Exp $
+ * $Id: http.h,v 1.11 2001/03/07 23:51:41 bagder Exp $
  *****************************************************************************/
 
 /* ftp can use this as well */
 CURLcode Curl_ConnectHTTPProxyTunnel(struct connectdata *conn,
                                      int tunnelsocket,
                                      char *hostname, int remote_port);
@@ -32,7 +32,12 @@
 /* protocol-specific functions set up to be called by the main engine */
 CURLcode Curl_http(struct connectdata *conn);
 CURLcode Curl_http_done(struct connectdata *conn);
 CURLcode Curl_http_connect(struct connectdata *conn);
 CURLcode Curl_http_close(struct connectdata *conn);
 
+/* The following functions are defined in http_chunks.c */
+void Curl_httpchunk_init(struct connectdata *conn);
+CHUNKcode Curl_httpchunk_read(struct connectdata *conn, char *datap,
+                              ssize_t length, ssize_t *wrote);
+
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/if2ip.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/if2ip.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/if2ip.c	2001-01-24 22:44:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/if2ip.c	2001-03-16 23:44:38.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: if2ip.c,v 1.13 2001/01/24 14:44:05 bagder Exp $
+ * $Id: if2ip.c,v 1.15 2001/03/16 15:44:38 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -67,12 +67,17 @@
 #endif
 
 #if defined(HAVE_INET_NTOA_R) && !defined(HAVE_INET_NTOA_R_DECL) 
 #include "inet_ntoa_r.h"
 #endif
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 #define SYS_ERROR -1
 
 char *Curl_if2ip(char *interface, char *buf, int buf_size)
 {
   int dummy;
   char *ip=NULL;
@@ -87,12 +92,13 @@
   else {
     struct ifreq req;
     memset(&req, 0, sizeof(req));
     strcpy(req.ifr_name, interface);
     req.ifr_addr.sa_family = AF_INET;
     if (SYS_ERROR == ioctl(dummy, SIOCGIFADDR, &req, sizeof(req))) {
+      sclose(dummy);
       return NULL;
     }
     else {
       struct in_addr in;
 
       struct sockaddr_in *s = (struct sockaddr_in *)&req.ifr_dstaddr;
@@ -101,13 +107,13 @@
       ip = inet_ntoa_r(in,buf,buf_size);
 #else
       ip = strncpy(buf,inet_ntoa(in),buf_size);
       ip[buf_size - 1] = 0;
 #endif
     }
-    close(dummy);
+    sclose(dummy);
   }
   return ip;
 }
 
 /* -- end of if2ip() -- */
 #else
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/krb4.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/krb4.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/krb4.c	2001-01-25 20:00:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/krb4.c	2001-02-20 08:05:29.000000000 +0800
@@ -287,13 +287,13 @@
     struct sockaddr_in *remoteaddr = (struct sockaddr_in *)REMOTE_ADDR;
 #endif
     char *host = conn->hp->h_name;
     size_t nread;
     int l = sizeof(local_addr);
 
-    if(getsockname(conn->data->firstsocket,
+    if(getsockname(conn->firstsocket,
                    (struct sockaddr *)LOCAL_ADDR, &l) < 0)
 	perror("getsockname()");
 
     checksum = getpid();
     ret = mk_auth(d, &adat, "ftp", host, checksum);
     if(ret == KDC_PR_UNKNOWN)
@@ -336,15 +336,15 @@
 
     if(Curl_base64_encode(adat.dat, adat.length, &p) < 0) {
 	printf("Out of memory base64-encoding.\n");
 	return AUTH_CONTINUE;
     }
     /*ret = command("ADAT %s", p)*/
-    Curl_ftpsendf(conn->data->firstsocket, conn, "ADAT %s", p);
+    Curl_ftpsendf(conn->firstsocket, conn, "ADAT %s", p);
     /* wait for feedback */
-    nread = Curl_GetFTPResponse(conn->data->firstsocket,
+    nread = Curl_GetFTPResponse(conn->firstsocket,
                                 conn->data->buffer, conn, NULL);
     if(nread < 0)
 	return /*CURLE_OPERATION_TIMEOUTED*/-1;
     free(p);
 
     if(/*ret != COMPLETE*/conn->data->buffer[0] != '2'){
@@ -406,16 +406,16 @@
     size_t nread;
 	
     int save;
 
     save = set_command_prot(conn, prot_private);
     /*ret = command("SITE KAUTH %s", name);***/
-    Curl_ftpsendf(conn->data->firstsocket, conn,
+    Curl_ftpsendf(conn->firstsocket, conn,
              "SITE KAUTH %s", conn->data->user);
     /* wait for feedback */
-    nread = Curl_GetFTPResponse(conn->data->firstsocket, conn->data->buffer,
+    nread = Curl_GetFTPResponse(conn->firstsocket, conn->data->buffer,
                                 conn, NULL);
     if(nread < 0)
 	return /*CURLE_OPERATION_TIMEOUTED*/;
 
     if(/*ret != CONTINUE*/conn->data->buffer[0] != '3'){
 	set_command_prot(conn, save);
@@ -483,16 +483,16 @@
       set_command_prot(conn, save);
       /*code = -1;***/
       return;
     }
     memset (tktcopy.dat, 0, tktcopy.length);
     /*ret = command("SITE KAUTH %s %s", name, p);***/
-    Curl_ftpsendf(conn->data->firstsocket, conn,
+    Curl_ftpsendf(conn->firstsocket, conn,
              "SITE KAUTH %s %s", name, p);
     /* wait for feedback */
-    nread = Curl_GetFTPResponse(conn->data->firstsocket, conn->data->buffer,
+    nread = Curl_GetFTPResponse(conn->firstsocket, conn->data->buffer,
                                 conn, NULL);
     if(nread < 0)
 	return /*CURLE_OPERATION_TIMEOUTED*/;
     free(p);
     set_command_prot(conn, save);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ldap.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ldap.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ldap.c	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ldap.c	2001-02-21 01:35:52.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ldap.c,v 1.11 2001/01/05 10:11:42 bagder Exp $
+ * $Id: ldap.c,v 1.12 2001/02/20 17:35:52 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -168,16 +168,16 @@
   DYNA_GET_FUNCTION(void *(*)(void *, void *), ldap_first_entry);
   DYNA_GET_FUNCTION(void *(*)(void *, void *), ldap_next_entry);
   DYNA_GET_FUNCTION(char *(*)(int), ldap_err2string);
   DYNA_GET_FUNCTION(int (*)(void *, char *, void *, void *, char **, char **, int (*)(void *, char *, int), void *, char *, int, unsigned long), ldap_entry2text);
   DYNA_GET_FUNCTION(int (*)(void *, char *, void *, void *, char **, char **, int (*)(void *, char *, int), void *, char *, int, unsigned long, char *, char *), ldap_entry2html);
   
-  server = ldap_open(data->hostname, data->port);
+  server = ldap_open(conn->hostname, conn->port);
   if (server == NULL) {
     failf(data, "LDAP: Cannot connect to %s:%d",
-	  data->hostname, data->port);
+	  conn->hostname, conn->port);
     status = CURLE_COULDNT_CONNECT;
   } else {
     rc = ldap_simple_bind_s(server, data->user, data->passwd);
     if (rc != 0) {
       failf(data, "LDAP: %s", ldap_err2string(rc));
       status = CURLE_LDAP_CANNOT_BIND;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/libcurl.def /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/libcurl.def
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/libcurl.def	2000-11-13 16:35:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/libcurl.def	2001-03-22 23:41:47.000000000 +0800
@@ -4,39 +4,29 @@
 
 LIBRARY		LIBCURL
 
 DESCRIPTION	'curl libcurl - http://curl.haxx.se'
 
 EXPORTS
-	curl_close @ 1 ; 
-	curl_connect @ 2 ; 
-	curl_disconnect @ 3 ; 
-	curl_do @ 4 ; 
-	curl_done @ 5 ; 
-	curl_easy_cleanup @ 6 ; 
-	curl_easy_getinfo @ 7 ; 
-	curl_easy_init @ 8 ; 
-	curl_easy_perform @ 9 ; 
-	curl_easy_setopt @ 10 ; 
-	curl_escape @ 11 ; 
-	curl_formparse @ 12 ; 
-	curl_free @ 13 ; 
-	curl_getdate @ 14 ; 
-	curl_getenv @ 15 ; 
-	curl_init @ 16 ; 
-	curl_open @ 17 ; 
-	curl_read @ 18 ; 
-	curl_setopt @ 19 ; 
-	curl_slist_append @ 20 ; 
-	curl_slist_free_all @ 21 ; 
-	curl_transfer @ 22 ; 
-	curl_unescape @ 23 ; 
-	curl_version @ 24 ; 
-	curl_write @ 25 ; 
-	maprintf @ 26 ; 
- 	mfprintf @ 27 ;
- 	mprintf @ 28 ;
- 	msprintf @ 29 ;
- 	msnprintf @ 30 ;
- 	mvfprintf @ 31 ;
-	strequal @ 32 ; 
-	strnequal @ 33 ; 
+	curl_easy_cleanup @ 1 ; 
+	curl_easy_getinfo @ 2 ; 
+	curl_easy_init @ 3 ; 
+	curl_easy_perform @ 4 ; 
+	curl_easy_setopt @ 5 ; 
+	curl_escape @ 6 ; 
+	curl_formparse @ 7 ; 
+	curl_formfree @ 8 ; 
+	curl_getdate @ 9 ; 
+	curl_getenv @ 10 ; 
+	curl_slist_append @ 11 ; 
+	curl_slist_free_all @ 12 ; 
+	curl_unescape @ 13 ; 
+	curl_version @ 14 ; 
+	curl_maprintf @ 15 ; 
+ 	curl_mfprintf @ 16 ;
+	curl_mprintf @ 17 ;
+ 	curl_msprintf @ 18 ;
+ 	curl_msnprintf @ 19 ;
+ 	curl_mvfprintf @ 20 ;
+	curl_strequal @ 21 ; 
+	curl_strnequal @ 22 ; 
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/Makefile.am	2001-02-12 16:21:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/Makefile.am	2001-03-14 16:54:18.000000000 +0800
@@ -1,25 +1,25 @@
 #
-# $Id: Makefile.am,v 1.17 2001/02/12 08:21:45 bagder Exp $
+# $Id: Makefile.am,v 1.20 2001/03/14 08:54:18 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign
 
 EXTRA_DIST = getdate.y \
        Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6 \
-       libcurl.def dllinit.c
+       libcurl.def dllinit.c curllib.dsp curllib.dsw
 
 lib_LTLIBRARIES = libcurl.la
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
 
 INCLUDES = -I$(top_srcdir)/include
 
 
-libcurl_la_LDFLAGS = -version-info 1:0:0
+libcurl_la_LDFLAGS = -version-info 2:0:0
 # This flag accepts an argument of the form current[:revision[:age]]. So,
 # passing -version-info 3:12:1 sets current to 3, revision to 12, and age to
 # 1.
 #
 # If either revision or age are omitted, they default to 0. Also note that age
 # must be less than or equal to the current interface number.
@@ -55,13 +55,14 @@
 dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h \
 getdate.h      ldap.c         ssluse.c       version.c \
 getenv.c       ldap.h         ssluse.h       \
 escape.c       mprintf.c      telnet.c       \
 escape.h       getpass.c      netrc.c        telnet.h       \
 getinfo.c transfer.c strequal.c strequal.h easy.c \
-security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h
+security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h \
+http_chunks.c http_chunks.h
 
 noinst_HEADERS = setup.h transfer.h
 
 # Say $(srcdir), so GNU make does not report an ambiguity with the .y.c rule.
 $(srcdir)/getdate.c: getdate.y
 	cd $(srcdir) && \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/Makefile.in	2001-02-13 21:35:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/Makefile.in	2001-03-22 23:42:56.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.17 2001/02/12 08:21:45 bagder Exp $
+# $Id: Makefile.am,v 1.20 2001/03/14 08:54:18 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -70,29 +70,30 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign
 
-EXTRA_DIST = getdate.y        Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6        libcurl.def dllinit.c
+EXTRA_DIST = getdate.y        Makefile.b32 Makefile.b32.resp Makefile.m32 Makefile.vc6        libcurl.def dllinit.c curllib.dsp curllib.dsw
 
 
 lib_LTLIBRARIES = libcurl.la
 
 # Some flags needed when trying to cause warnings ;-)
 # CFLAGS = -DMALLOCDEBUG -g # -Wall #-pedantic
 
 INCLUDES = -I$(top_srcdir)/include
 
-libcurl_la_LDFLAGS = -version-info 1:0:0
+libcurl_la_LDFLAGS = -version-info 2:0:0
 # This flag accepts an argument of the form current[:revision[:age]]. So,
 # passing -version-info 3:12:1 sets current to 3, revision to 12, and age to
 # 1.
 #
 # If either revision or age are omitted, they default to 0. Also note that age
 # must be less than or equal to the current interface number.
@@ -115,13 +116,13 @@
 # increment age.
 #
 # 6.If any interfaces have been removed since the last public release, then
 # set age to 0.
 #
 
-libcurl_la_SOURCES =  arpa_telnet.h  file.c         getpass.h      netrc.h        timeval.c base64.c       file.h         hostip.c       progress.c     timeval.h base64.h       formdata.c     hostip.h       progress.h     cookie.c       formdata.h     http.c         sendf.c        cookie.h       ftp.c          http.h         sendf.h        url.c dict.c         ftp.h          if2ip.c        speedcheck.c   url.h dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h getdate.h      ldap.c         ssluse.c       version.c getenv.c       ldap.h         ssluse.h       escape.c       mprintf.c      telnet.c       escape.h       getpass.c      netrc.c        telnet.h       getinfo.c transfer.c strequal.c strequal.h easy.c security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h
+libcurl_la_SOURCES =  arpa_telnet.h  file.c         getpass.h      netrc.h        timeval.c base64.c       file.h         hostip.c       progress.c     timeval.h base64.h       formdata.c     hostip.h       progress.h     cookie.c       formdata.h     http.c         sendf.c        cookie.h       ftp.c          http.h         sendf.h        url.c dict.c         ftp.h          if2ip.c        speedcheck.c   url.h dict.h         getdate.c      if2ip.h        speedcheck.h   urldata.h getdate.h      ldap.c         ssluse.c       version.c getenv.c       ldap.h         ssluse.h       escape.c       mprintf.c      telnet.c       escape.h       getpass.c      netrc.c        telnet.h       getinfo.c transfer.c strequal.c strequal.h easy.c security.h security.c krb4.c krb4.h memdebug.c memdebug.h inet_ntoa_r.h http_chunks.c http_chunks.h
 
 
 noinst_HEADERS = setup.h transfer.h
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h ../src/config.h
 CONFIG_CLEAN_FILES = 
@@ -134,13 +135,14 @@
 LIBS = @LIBS@
 libcurl_la_LIBADD = 
 libcurl_la_OBJECTS =  file.lo timeval.lo base64.lo hostip.lo progress.lo \
 formdata.lo cookie.lo http.lo sendf.lo ftp.lo url.lo dict.lo if2ip.lo \
 speedcheck.lo getdate.lo ldap.lo ssluse.lo version.lo getenv.lo \
 escape.lo mprintf.lo telnet.lo getpass.lo netrc.lo getinfo.lo \
-transfer.lo strequal.lo easy.lo security.lo krb4.lo memdebug.lo
+transfer.lo strequal.lo easy.lo security.lo krb4.lo memdebug.lo \
+http_chunks.lo
 CFLAGS = @CFLAGS@
 COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 LTCOMPILE = $(LIBTOOL) --mode=compile $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@
 HEADERS =  $(noinst_HEADERS)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/Makefile.m32 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/Makefile.m32
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/Makefile.m32	2001-01-17 21:20:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/Makefile.m32	2001-03-14 16:11:20.000000000 +0800
@@ -30,19 +30,19 @@
 	file.h hostip.c progress.c timeval.h base64.h formdata.c hostip.h progress.h	\
 	cookie.c formdata.h http.c sendf.c cookie.h ftp.c http.h sendf.h url.c dict.c	\
 	ftp.h if2ip.c speedcheck.c url.h dict.h getdate.c if2ip.h speedcheck.h		\
 	urldata.h transfer.c getdate.h ldap.c ssluse.c version.c transfer.h getenv.c	\
 	ldap.h ssluse.h escape.c getenv.h mprintf.c telnet.c escape.h getpass.c netrc.c	\
 	telnet.h getinfo.c strequal.c strequal.h easy.c security.h		\
-	security.c krb4.c
+	security.c krb4.h krb4.c memdebug.h memdebug.c inet_ntoa_r.h http_chunks.h http_chunks.c
 
 libcurl_a_OBJECTS =  file.o timeval.o base64.o hostip.o progress.o \
 	formdata.o cookie.o http.o sendf.o ftp.o url.o dict.o if2ip.o \
 	speedcheck.o getdate.o transfer.o ldap.o ssluse.o version.o \
 	getenv.o escape.o mprintf.o telnet.o getpass.o netrc.o getinfo.o \
-	strequal.o easy.o security.o krb4.o
+	strequal.o easy.o security.o krb4.o memdebug.o http_chunks.o
 
 LIBRARIES =  $(libcurl_a_LIBRARIES)
 SOURCES = $(libcurl_a_SOURCES)
 OBJECTS = $(libcurl_a_OBJECTS)
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/memdebug.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/memdebug.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/memdebug.c	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/memdebug.c	2001-03-10 00:50:37.000000000 +0800
@@ -16,13 +16,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: memdebug.c,v 1.11 2001/01/05 10:11:42 bagder Exp $
+ * $Id: memdebug.c,v 1.13 2001/03/09 15:13:34 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <curl/curl.h>
 
@@ -69,13 +69,13 @@
   void *mem=(malloc)(size);
   fprintf(logfile?logfile:stderr, "MEM %s:%d malloc(%d) = %p\n",
           source, line, size, mem);
   return mem;
 }
 
-char *curl_dostrdup(char *str, int line, char *source)
+char *curl_dostrdup(const char *str, int line, char *source)
 {
   char *mem;
   size_t len;
   
   if(NULL ==str) {
     fprintf(stderr, "ILLEGAL strdup() on NULL at %s:%d\n",
@@ -117,13 +117,13 @@
   int sockfd=(socket)(domain, type, protocol);
   fprintf(logfile?logfile:stderr, "FD %s:%d socket() = %d\n",
           source, line, sockfd);
   return sockfd;
 }
 
-int curl_accept(int s, struct sockaddr *addr, int *addrlen,
+int curl_accept(int s, struct sockaddr *addr, socklen_t *addrlen,
                 int line, char *source)
 {
   int sockfd=(accept)(s, addr, addrlen);
   fprintf(logfile?logfile:stderr, "FD %s:%d accept() = %d\n",
           source, line, sockfd);
   return sockfd;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/memdebug.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/memdebug.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/memdebug.h	2000-12-19 21:18:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/memdebug.h	2001-03-10 00:50:37.000000000 +0800
@@ -4,19 +4,19 @@
 #include <stdio.h>
 
 /* memory functions */
 void *curl_domalloc(size_t size, int line, char *source);
 void *curl_dorealloc(void *ptr, size_t size, int line, char *source);
 void curl_dofree(void *ptr, int line, char *source);
-char *curl_dostrdup(char *str, int line, char *source);
+char *curl_dostrdup(const char *str, int line, char *source);
 void curl_memdebug(char *logname);
 
 /* file descriptor manipulators */
 int curl_socket(int domain, int type, int protocol, int, char *);
 int curl_sclose(int sockfd, int, char *);
-int curl_accept(int s, struct sockaddr *addr, int *addrlen,
+int curl_accept(int s, struct sockaddr *addr, socklen_t *addrlen,
                 int line, char *source);
 
 /* FILE functions */
 FILE *curl_fopen(char *file, char *mode, int line, char *source);
 int curl_fclose(FILE *file, int line, char *source);
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/netrc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/netrc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/netrc.c	2001-02-07 16:36:23.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/netrc.c	2001-03-16 23:21:44.000000000 +0800
@@ -15,25 +15,41 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: netrc.c,v 1.9 2001/02/07 08:36:23 bagder Exp $
+ * $Id: netrc.c,v 1.12 2001/03/16 15:19:36 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 
+#ifdef HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#ifdef HAVE_PWD_H
+#include <pwd.h>
+#endif
+
+
 #include <curl/curl.h>
 
 #include "strequal.h"
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 /* Debug this single source file with:
    'make netrc' then run './netrc'!
 
    Oh, make sure you have a .netrc file too ;-)
  */
 
@@ -57,25 +73,39 @@
                     char *password)
 {
   FILE *file;
   char netrcbuffer[256];
   int retcode=1;
   
-  char *home = curl_getenv("HOME"); /* portable environment reader */
+  char *home = NULL; 
   int state=NOTHING;
 
   char state_login=0;
   char state_password=0;
 
 #define NETRC DOT_CHAR "netrc"
 
-  if(!home)
-    return -1;
+#if defined(HAVE_GETPWUID) && defined(HAVE_GETEUID)
+  struct passwd *pw;
+  pw= getpwuid(geteuid());
+  if (pw)
+    home = pw->pw_dir;
+#else
+  void *pw=NULL;
+#endif
+  
+  if(NULL == pw) {
+    home = curl_getenv("HOME"); /* portable environment reader */
+    if(!home) {
+      return -1;
+    }
+  }
 
   if(strlen(home)>(sizeof(netrcbuffer)-strlen(NETRC))) {
-    free(home);
+    if(NULL==pw)
+      free(home);
     return -1;
   }
 
   sprintf(netrcbuffer, "%s%s%s", home, DIR_CHAR, NETRC);
 
   file = fopen(netrcbuffer, "r");
@@ -137,13 +167,14 @@
       } /* while (tok) */
     } /* while fgets() */
 
     fclose(file);
   }
 
-  free(home);
+  if(NULL==pw)
+    free(home);
 
   return retcode;
 }
 
 #ifdef _NETRC_DEBUG
 int main(int argc, char **argv)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/security.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/security.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/security.c	2001-01-05 17:55:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/security.c	2001-02-20 08:04:45.000000000 +0800
@@ -479,16 +479,16 @@
     if(!conn->sec_complete){
       infof(conn->data, "No security data exchange has taken place.\n");
       return -1;
     }
 
     if(level){
-      Curl_ftpsendf(conn->data->firstsocket, conn,
+      Curl_ftpsendf(conn->firstsocket, conn,
                     "PBSZ %u", s);
       /* wait for feedback */
-      nread = Curl_GetFTPResponse(conn->data->firstsocket,
+      nread = Curl_GetFTPResponse(conn->firstsocket,
                                   conn->data->buffer, conn, NULL);
       if(nread < 0)
         return /*CURLE_OPERATION_TIMEOUTED*/-1;
       if(/*ret != COMPLETE*/conn->data->buffer[0] != '2'){
         failf(conn->data, "Failed to set protection buffer size.\n");
         return -1;
@@ -498,16 +498,16 @@
       if(p)
         sscanf(p, "PBSZ=%u", &s);
       if(s < conn->buffer_size)
         conn->buffer_size = s;
     }
 
-    Curl_ftpsendf(conn->data->firstsocket, conn,
+    Curl_ftpsendf(conn->firstsocket, conn,
                   "PROT %c", level["CSEP"]);
     /* wait for feedback */
-    nread = Curl_GetFTPResponse(conn->data->firstsocket,
+    nread = Curl_GetFTPResponse(conn->firstsocket,
                                 conn->data->buffer, conn, NULL);
     if(nread < 0)
       return /*CURLE_OPERATION_TIMEOUTED*/-1;
     if(/*ret != COMPLETE*/conn->data->buffer[0] != '2'){
       failf(conn->data, "Failed to set protection level.\n");
       return -1;
@@ -607,16 +607,16 @@
 	if((*m)->init && (*(*m)->init)(conn->app_data) != 0) {
 	    infof(data, "Skipping %s...\n", (*m)->name);
 	    continue;
 	}
 	infof(data, "Trying %s...\n", (*m)->name);
 	/*ret = command("AUTH %s", (*m)->name);***/
-	Curl_ftpsendf(conn->data->firstsocket, conn,
+	Curl_ftpsendf(conn->firstsocket, conn,
                  "AUTH %s", (*m)->name);
 	/* wait for feedback */
-	nread = Curl_GetFTPResponse(conn->data->firstsocket,
+	nread = Curl_GetFTPResponse(conn->firstsocket,
                                     conn->data->buffer, conn, NULL);
 	if(nread < 0)
 	    return /*CURLE_OPERATION_TIMEOUTED*/-1;
 	if(/*ret != CONTINUE*/conn->data->buffer[0] != '3'){
 	    if(/*code == 504*/strncmp(conn->data->buffer,"504",3) == 0) {
 		infof(data,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/sendf.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/sendf.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/sendf.c	2001-02-12 16:22:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/sendf.c	2001-03-13 21:22:58.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: sendf.c,v 1.18 2001/01/31 13:54:13 bagder Exp $
+ * $Id: sendf.c,v 1.22 2001/03/13 13:22:58 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -47,36 +47,109 @@
 #include <string.h>
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
-/* infof() is for info message along the way */
+/* returns last node in linked list */
+static struct curl_slist *slist_get_last(struct curl_slist *list)
+{
+	struct curl_slist	*item;
+
+	/* if caller passed us a NULL, return now */
+	if (!list)
+		return NULL;
+
+	/* loop through to find the last item */
+	item = list;
+	while (item->next) {
+		item = item->next;
+	}
+	return item;
+}
+
+/* append a struct to the linked list. It always retunrs the address of the
+ * first record, so that you can sure this function as an initialization
+ * function as well as an append function. If you find this bothersome,
+ * then simply create a separate _init function and call it appropriately from
+ * within the proram. */
+struct curl_slist *curl_slist_append(struct curl_slist *list,
+                                     const char *data)
+{
+	struct curl_slist	*last;
+	struct curl_slist	*new_item;
+
+	new_item = (struct curl_slist *) malloc(sizeof(struct curl_slist));
+	if (new_item) {
+		new_item->next = NULL;
+		new_item->data = strdup(data);
+	}
+	else {
+		fprintf(stderr, "Cannot allocate memory for QUOTE list.\n");
+		return NULL;
+	}
+
+	if (list) {
+		last = slist_get_last(list);
+		last->next = new_item;
+		return list;
+	}
+
+	/* if this is the first item, then new_item *is* the list */
+	return new_item;
+}
+
+/* be nice and clean up resources */
+void curl_slist_free_all(struct curl_slist *list)
+{
+	struct curl_slist	*next;
+	struct curl_slist	*item;
+
+	if (!list)
+		return;
+
+	item = list;
+	do {
+		next = item->next;
+		
+		if (item->data) {
+			free(item->data);
+		}
+		free(item);
+		item = next;
+	} while (next);
+}
+
+
+/* Curl_infof() is for info message along the way */
 
 void Curl_infof(struct UrlData *data, char *fmt, ...)
 {
   va_list ap;
   if(data->bits.verbose) {
     va_start(ap, fmt);
     fputs("* ", data->err);
     vfprintf(data->err, fmt, ap);
     va_end(ap);
   }
 }
 
-/* failf() is for messages stating why we failed, the LAST one will be
+/* Curl_failf() is for messages stating why we failed, the LAST one will be
    returned for the user (if requested) */
 
 void Curl_failf(struct UrlData *data, char *fmt, ...)
 {
   va_list ap;
   va_start(ap, fmt);
   if(data->errorbuffer)
     vsnprintf(data->errorbuffer, CURL_ERROR_SIZE, fmt, ap);
-  else /* no errorbuffer receives this, write to data->err instead */
+  else if(!data->bits.mute) {
+    /* no errorbuffer receives this, write to data->err instead */
     vfprintf(data->err, fmt, ap);
+    fprintf(data->err, "\n");
+  }
   va_end(ap);
 }
 
 /* Curl_sendf() sends formated data to the server */
 size_t Curl_sendf(int sockfd, struct connectdata *conn,
                   char *fmt, ...)
@@ -108,21 +181,20 @@
  */
 CURLcode Curl_write(struct connectdata *conn, int sockfd,
                     void *mem, size_t len,
                     size_t *written)
 {
   size_t bytes_written;
-  struct UrlData *data=conn->data; /* conn knows data, not vice versa */
 
 #ifdef USE_SSLEAY
-  if (data->ssl.use) {
+  if (conn->ssl.use) {
     int loop=100; /* just a precaution to never loop endlessly */
     while(loop--) {
-      bytes_written = SSL_write(data->ssl.handle, mem, len);
+      bytes_written = SSL_write(conn->ssl.handle, mem, len);
       if((-1 != bytes_written) ||
-         (SSL_ERROR_WANT_WRITE != SSL_get_error(data->ssl.handle,
+         (SSL_ERROR_WANT_WRITE != SSL_get_error(conn->ssl.handle,
                                                 bytes_written) ))
         break;
     }
   }
   else {
 #endif
@@ -138,29 +210,12 @@
 #endif
 
   *written = bytes_written;
   return CURLE_OK;
 }
 
-/*
- * External write-function, writes to the data-socket.
- * Takes care of plain sockets, SSL or kerberos transparently.
- */
-CURLcode curl_write(CURLconnect *c_conn, char *buf, size_t amount,
-                   size_t *n)
-{
-  struct connectdata *conn = (struct connectdata *)c_conn;
-
-  if(!n || !conn || (conn->handle != STRUCT_CONNECT))
-    return CURLE_FAILED_INIT;
-
-  return Curl_write(conn, conn->sockfd, buf, amount, n);
-}
-
-
-
 /* client_write() sends data to the write callback(s)
 
    The bit pattern defines to what "streams" to write to. Body and/or header.
    The defines are in sendf.h of course.
  */
 CURLcode Curl_client_write(struct UrlData *data,
@@ -197,22 +252,21 @@
  * sockets, SSL sockets and kerberos sockets.
  */
 CURLcode Curl_read(struct connectdata *conn, int sockfd,
                    char *buf, size_t buffersize,
                    ssize_t *n)
 {
-  struct UrlData *data = conn->data;
   ssize_t nread;
 
 #ifdef USE_SSLEAY
-  if (data->ssl.use) {
+  if (conn->ssl.use) {
     int loop=100; /* just a precaution to never loop endlessly */
     while(loop--) {
-      nread = SSL_read(data->ssl.handle, buf, buffersize);
+      nread = SSL_read(conn->ssl.handle, buf, buffersize);
       if((-1 != nread) ||
-         (SSL_ERROR_WANT_READ != SSL_get_error(data->ssl.handle, nread) ))
+         (SSL_ERROR_WANT_READ != SSL_get_error(conn->ssl.handle, nread) ))
         break;
     }
   }
   else {
 #endif
 #ifdef KRB4
@@ -225,22 +279,6 @@
   }
 #endif /* USE_SSLEAY */
   *n = nread;
   return CURLE_OK;
 }
 
-/*
- * The public read function reads from the 'sockfd' file descriptor only.
- * Use the Curl_read() internally when you want to specify fd.
- */
-
-CURLcode curl_read(CURLconnect *c_conn, char *buf, size_t buffersize,
-                   ssize_t *n)
-{
-  struct connectdata *conn = (struct connectdata *)c_conn;
-
-  if(!n || !conn || (conn->handle != STRUCT_CONNECT))
-    return CURLE_FAILED_INIT;
-
-  return Curl_read(conn, conn->sockfd, buf, buffersize, n);
-}
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/speedcheck.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/speedcheck.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/speedcheck.c	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/speedcheck.c	2001-03-10 00:50:38.000000000 +0800
@@ -15,18 +15,19 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: speedcheck.c,v 1.8 2001/01/05 10:11:42 bagder Exp $
+ * $Id: speedcheck.c,v 1.9 2001/03/09 15:14:51 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <stdio.h>
+#include <string.h>
 #if defined(__MINGW32__)
 #include <winsock.h>
 #endif
 
 #include <curl/curl.h>
 #include "urldata.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ssluse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ssluse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ssluse.c	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ssluse.c	2001-03-14 18:15:42.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.c,v 1.12 2001/01/05 10:11:42 bagder Exp $
+ * $Id: ssluse.c,v 1.18 2001/03/14 10:15:42 bagder Exp $
  *****************************************************************************/
 
 /*
  * The original SSL code was written by
  * Linas Vepstas <linas@linas.org> and Sampo Kellomaki <sampo@iki.fi>
  */
@@ -32,12 +32,13 @@
 
 #include "urldata.h"
 #include "sendf.h"
 #include "formdata.h" /* for the boundary function */
 
 #ifdef USE_SSLEAY
+#include <openssl/rand.h>
 
 static char global_passwd[64];
 
 static int passwd_callback(char *buf, int num, int verify
 #if OPENSSL_VERSION_NUMBER >= 0x00904100L
                            /* This was introduced in 0.9.4, we can set this
@@ -55,52 +56,145 @@
       return strlen(buf);
     }
   }  
   return 0;
 }
 
-/* This function is *highly* inspired by (and parts are directly stolen
- * from) source from the SSLeay package written by Eric Young
- * (eay@cryptsoft.com).  */
+static
+bool seed_enough(struct connectdata *conn, /* unused for now */
+                 int nread)
+{
+#ifdef HAVE_RAND_STATUS
+  /* only available in OpenSSL 0.9.5a and later */
+  if(RAND_status())
+    return TRUE;
+#else
+  if(nread > 500)
+    /* this is a very silly decision to make */
+    return TRUE;
+#endif
+  return FALSE; /* not enough */
+}
+
+static
+int random_the_seed(struct connectdata *conn)
+{
+  char *buf = conn->data->buffer; /* point to the big buffer */
+  int nread=0;
+  struct UrlData *data=conn->data;
+
+  /* Q: should we add support for a random file name as a libcurl option?
+     A: Yes, it is here */
+
+#ifndef RANDOM_FILE
+  /* if RANDOM_FILE isn't defined, we only perform this if an option tells
+     us to! */
+  if(data->ssl.random_file)
+#define RANDOM_FILE "" /* doesn't matter won't be used */
+#endif
+  {
+    /* let the option override the define */
+    nread += RAND_load_file((data->ssl.random_file?
+                             data->ssl.random_file:RANDOM_FILE),
+                            16384);
+    if(seed_enough(conn, nread))
+      return nread;
+  }
+
+#if defined(HAVE_RAND_EGD)
+  /* only available in OpenSSL 0.9.5 and later */
+  /* EGD_SOCKET is set at configure time or not at all */
+#ifndef EGD_SOCKET
+  /* If we don't have the define set, we only do this if the egd-option
+     is set */
+  if(data->ssl.egdsocket)
+#define EGD_SOCKET "" /* doesn't matter won't be used */
+#endif
+  {
+    /* If there's an option and a define, the option overrides the
+       define */
+    int ret = RAND_egd(data->ssl.egdsocket?data->ssl.egdsocket:EGD_SOCKET);
+    if(-1 != ret) {
+      nread += ret;
+      if(seed_enough(conn, nread))
+        return nread;
+    }
+  }
+#endif
+
+  /* If we get here, it means we need to seed the PRNG using a "silly"
+     approach! */
+#ifdef HAVE_RAND_SCREEN
+  /* This one gets a random value by reading the currently shown screen */
+  RAND_screen();
+  nread = 100; /* just a value */
+#else
+  {
+    int len;
+    char *area = Curl_FormBoundary();
+    if(!area)
+      return 3; /* out of memory */
+	
+    len = strlen(area);
+    RAND_seed(area, len);
+
+    free(area); /* now remove the random junk */
+  }
+#endif
+
+  /* generates a default path for the random seed file */
+  buf[0]=0; /* blank it first */
+  RAND_file_name(buf, BUFSIZE);
+  if ( buf[0] ) {
+    /* we got a file name to try */
+    nread += RAND_load_file(buf, 16384);
+    if(seed_enough(conn, nread))
+      return nread;
+  }
+
+  infof(conn->data, "Your connection is using a weak random seed!\n");
+  return nread;
+}
 
 static
-int cert_stuff(struct UrlData *data, 
+int cert_stuff(struct connectdata *conn,
                char *cert_file,
                char *key_file)
 {
+  struct UrlData *data = conn->data;
   if (cert_file != NULL) {
     SSL *ssl;
     X509 *x509;
 
     if(data->cert_passwd) {
       /*
        * If password has been given, we store that in the global
        * area (*shudder*) for a while:
        */
       strcpy(global_passwd, data->cert_passwd);
       /* Set passwd callback: */
-      SSL_CTX_set_default_passwd_cb(data->ssl.ctx, passwd_callback);
+      SSL_CTX_set_default_passwd_cb(conn->ssl.ctx, passwd_callback);
     }
 
-    if (SSL_CTX_use_certificate_file(data->ssl.ctx,
+    if (SSL_CTX_use_certificate_file(conn->ssl.ctx,
 				     cert_file,
 				     SSL_FILETYPE_PEM) <= 0) {
       failf(data, "unable to set certificate file (wrong password?)\n");
       return(0);
     }
     if (key_file == NULL)
       key_file=cert_file;
 
-    if (SSL_CTX_use_PrivateKey_file(data->ssl.ctx,
+    if (SSL_CTX_use_PrivateKey_file(conn->ssl.ctx,
 				    key_file,
 				    SSL_FILETYPE_PEM) <= 0) {
       failf(data, "unable to set public key file\n");
       return(0);
     }
     
-    ssl=SSL_new(data->ssl.ctx);
+    ssl=SSL_new(conn->ssl.ctx);
     x509=SSL_get_certificate(ssl);
     
     if (x509 != NULL)
       EVP_PKEY_copy_parameters(X509_get_pubkey(x509),
 			       SSL_get_privatekey(ssl));
     SSL_free(ssl);
@@ -108,26 +202,23 @@
     /* If we are using DSA, we can copy the parameters from
      * the private key */
 		
     
     /* Now we know that a key and cert have been set against
      * the SSL context */
-    if (!SSL_CTX_check_private_key(data->ssl.ctx)) {
+    if (!SSL_CTX_check_private_key(conn->ssl.ctx)) {
       failf(data, "Private key does not match the certificate public key\n");
       return(0);
     }
     
     /* erase it now */
     memset(global_passwd, 0, sizeof(global_passwd));
   }
   return(1);
 }
 
-#endif
-
-#ifdef USE_SSLEAY
 static
 int cert_verify_callback(int ok, X509_STORE_CTX *ctx)
 {
   X509 *err_cert;
   char buf[256];
 
@@ -138,155 +229,136 @@
 }
 
 #endif
 
 /* ====================================================== */
 int
-Curl_SSLConnect (struct UrlData *data)
+Curl_SSLConnect(struct connectdata *conn)
 {
 #ifdef USE_SSLEAY
-    int err;
-    char * str;
-    SSL_METHOD *req_method;
-
-    /* mark this is being ssl enabled from here on out. */
-    data->ssl.use = TRUE;
-
-    /* Lets get nice error messages */
-    SSL_load_error_strings();
+  struct UrlData *data = conn->data;
+  int err;
+  char * str;
+  SSL_METHOD *req_method;
 
-#ifdef HAVE_RAND_STATUS
-    /* RAND_status() was introduced in OpenSSL 0.9.5 */
-    if(0 == RAND_status())
-#endif
-    {
-      /* We need to seed the PRNG properly! */
-#ifdef HAVE_RAND_SCREEN
-      /* This one gets a random value by reading the currently shown screen */
-      RAND_screen();
-#else
-      int len;
-      char *area = Curl_FormBoundary();
-      if(!area)
-	return 3; /* out of memory */
-	
-      len = strlen(area);
+  /* mark this is being ssl enabled from here on out. */
+  conn->ssl.use = TRUE;
 
-      RAND_seed(area, len);
+  /* Lets get nice error messages */
+  SSL_load_error_strings();
 
-      free(area); /* now remove the random junk */
-#endif
-    }
+  /* Make funny stuff to get random input */
+  random_the_seed(conn);
     
-    /* Setup all the global SSL stuff */
-    SSLeay_add_ssl_algorithms();
+  /* Setup all the global SSL stuff */
+  SSLeay_add_ssl_algorithms();
 
-    switch(data->ssl.version) {
-    default:
-      req_method = SSLv23_client_method();
-      break;
-    case 2:
-      req_method = SSLv2_client_method();
-      break;
-    case 3:
-      req_method = SSLv3_client_method();
-      break;
-    }
+  switch(data->ssl.version) {
+  default:
+    req_method = SSLv23_client_method();
+    break;
+  case 2:
+    req_method = SSLv2_client_method();
+    break;
+  case 3:
+    req_method = SSLv3_client_method();
+    break;
+  }
     
-    data->ssl.ctx = SSL_CTX_new(req_method);
+  conn->ssl.ctx = SSL_CTX_new(req_method);
 
-    if(!data->ssl.ctx) {
-      failf(data, "SSL: couldn't create a context!");
-      return 1;
-    }
+  if(!conn->ssl.ctx) {
+    failf(data, "SSL: couldn't create a context!");
+    return 1;
+  }
     
-    if(data->cert) {
-      if (!cert_stuff(data, data->cert, data->cert)) {
-	failf(data, "couldn't use certificate!\n");
-	return 2;
-      }
+  if(data->cert) {
+    if (!cert_stuff(conn, data->cert, data->cert)) {
+      failf(data, "couldn't use certificate!\n");
+      return 2;
     }
+  }
 
-    if(data->ssl.verifypeer){
-      SSL_CTX_set_verify(data->ssl.ctx,
-                         SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
-                         SSL_VERIFY_CLIENT_ONCE,
-                         cert_verify_callback);
-      if (!SSL_CTX_load_verify_locations(data->ssl.ctx,
-                                         data->ssl.CAfile,
-                                         data->ssl.CApath)) {
-        failf(data,"error setting cerficate verify locations\n");
-        return 2;
-      }
+  if(data->ssl.verifypeer){
+    SSL_CTX_set_verify(conn->ssl.ctx,
+                       SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT|
+                       SSL_VERIFY_CLIENT_ONCE,
+                       cert_verify_callback);
+    if (!SSL_CTX_load_verify_locations(conn->ssl.ctx,
+                                       data->ssl.CAfile,
+                                       data->ssl.CApath)) {
+      failf(data,"error setting cerficate verify locations\n");
+      return 2;
     }
-    else
-      SSL_CTX_set_verify(data->ssl.ctx, SSL_VERIFY_NONE, cert_verify_callback);
+  }
+  else
+    SSL_CTX_set_verify(conn->ssl.ctx, SSL_VERIFY_NONE, cert_verify_callback);
 
 
-    /* Lets make an SSL structure */
-    data->ssl.handle = SSL_new (data->ssl.ctx);
-    SSL_set_connect_state (data->ssl.handle);
+  /* Lets make an SSL structure */
+  conn->ssl.handle = SSL_new (conn->ssl.ctx);
+  SSL_set_connect_state (conn->ssl.handle);
 
-    data->ssl.server_cert = 0x0;
+  conn->ssl.server_cert = 0x0;
 
-    /* pass the raw socket into the SSL layers */
-    SSL_set_fd (data->ssl.handle, data->firstsocket);
-    err = SSL_connect (data->ssl.handle);
+  /* pass the raw socket into the SSL layers */
+  SSL_set_fd (conn->ssl.handle, conn->firstsocket);
+  err = SSL_connect (conn->ssl.handle);
 
-    if (-1 == err) {
-      err = ERR_get_error(); 
-      failf(data, "SSL: %s", ERR_error_string(err, NULL));
-      return 10;
-    }
+  if (-1 == err) {
+    err = ERR_get_error(); 
+    failf(data, "SSL: %s", ERR_error_string(err, NULL));
+    return 10;
+  }
 
-    /* Informational message */
-    infof (data, "SSL connection using %s\n",
-           SSL_get_cipher(data->ssl.handle));
+  /* Informational message */
+  infof (data, "SSL connection using %s\n",
+         SSL_get_cipher(conn->ssl.handle));
   
-    /* Get server's certificate (note: beware of dynamic allocation) - opt */
-    /* major serious hack alert -- we should check certificates
-     * to authenticate the server; otherwise we risk man-in-the-middle
-     * attack
-     */
-
-    data->ssl.server_cert = SSL_get_peer_certificate (data->ssl.handle);
-    if(!data->ssl.server_cert) {
-      failf(data, "SSL: couldn't get peer certificate!");
-      return 3;
-    }
-    infof (data, "Server certificate:\n");
+  /* Get server's certificate (note: beware of dynamic allocation) - opt */
+  /* major serious hack alert -- we should check certificates
+   * to authenticate the server; otherwise we risk man-in-the-middle
+   * attack
+   */
+
+  conn->ssl.server_cert = SSL_get_peer_certificate (conn->ssl.handle);
+  if(!conn->ssl.server_cert) {
+    failf(data, "SSL: couldn't get peer certificate!");
+    return 3;
+  }
+  infof (data, "Server certificate:\n");
   
-    str = X509_NAME_oneline (X509_get_subject_name (data->ssl.server_cert),
-                             NULL, 0);
-    if(!str) {
-      failf(data, "SSL: couldn't get X509-subject!");
-      return 4;
-    }
-    infof(data, "\t subject: %s\n", str);
-    CRYPTO_free(str);
+  str = X509_NAME_oneline (X509_get_subject_name (conn->ssl.server_cert),
+                           NULL, 0);
+  if(!str) {
+    failf(data, "SSL: couldn't get X509-subject!");
+    return 4;
+  }
+  infof(data, "\t subject: %s\n", str);
+  CRYPTO_free(str);
 
-    str = X509_NAME_oneline (X509_get_issuer_name  (data->ssl.server_cert),
-                             NULL, 0);
-    if(!str) {
-      failf(data, "SSL: couldn't get X509-issuer name!");
-      return 5;
-    }
-    infof(data, "\t issuer: %s\n", str);
-    CRYPTO_free(str);
+  str = X509_NAME_oneline (X509_get_issuer_name  (conn->ssl.server_cert),
+                           NULL, 0);
+  if(!str) {
+    failf(data, "SSL: couldn't get X509-issuer name!");
+    return 5;
+  }
+  infof(data, "\t issuer: %s\n", str);
+  CRYPTO_free(str);
 
-    /* We could do all sorts of certificate verification stuff here before
-       deallocating the certificate. */
+  /* We could do all sorts of certificate verification stuff here before
+     deallocating the certificate. */
 
-    if(data->ssl.verifypeer) {
-      data->ssl.certverifyresult=SSL_get_verify_result(data->ssl.handle);
-      infof(data, "Verify result: %d\n", data->ssl.certverifyresult);
-    }
-    else
-      data->ssl.certverifyresult=0;
+  if(data->ssl.verifypeer) {
+    data->ssl.certverifyresult=SSL_get_verify_result(conn->ssl.handle);
+    infof(data, "Verify result: %d\n", data->ssl.certverifyresult);
+  }
+  else
+    data->ssl.certverifyresult=0;
 
-    X509_free(data->ssl.server_cert);
+  X509_free(conn->ssl.server_cert);
 #else /* USE_SSLEAY */
-    /* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
-    (void) data;
+  /* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
+  (void) conn;
 #endif
-    return 0;
+  return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ssluse.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ssluse.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/ssluse.h	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/ssluse.h	2001-02-21 01:35:52.000000000 +0800
@@ -17,10 +17,11 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: ssluse.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
+ * $Id: ssluse.h,v 1.6 2001/02/20 17:35:52 bagder Exp $
  *****************************************************************************/
-int Curl_SSLConnect (struct UrlData *data);
+#include "urldata.h"
+int Curl_SSLConnect(struct connectdata *conn);
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/strequal.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/strequal.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/strequal.c	2001-02-06 17:12:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/strequal.c	2001-03-14 16:47:56.000000000 +0800
@@ -15,20 +15,20 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.c,v 1.11 2001/02/06 09:12:39 bagder Exp $
+ * $Id: strequal.c,v 1.12 2001/03/14 08:47:56 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 #include <string.h>
 
-int Curl_strequal(const char *first, const char *second)
+int curl_strequal(const char *first, const char *second)
 {
 #if defined(HAVE_STRCASECMP)
   return !strcasecmp(first, second);
 #elif defined(HAVE_STRCMPI)
   return !strcmpi(first, second);
 #elif defined(HAVE_STRICMP)
@@ -42,13 +42,13 @@
     second++;
   }
   return toupper(*first) == toupper(*second);
 #endif
 }
 
-int Curl_strnequal(const char *first, const char *second, size_t max)
+int curl_strnequal(const char *first, const char *second, size_t max)
 {
 #if defined(HAVE_STRCASECMP)
   return !strncasecmp(first, second, max);
 #elif defined(HAVE_STRCMPI)
   return !strncmpi(first, second, max);
 #elif defined(HAVE_STRICMP)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/strequal.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/strequal.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/strequal.h	2001-01-05 18:11:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/strequal.h	2001-03-14 16:47:56.000000000 +0800
@@ -17,15 +17,19 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: strequal.h,v 1.5 2001/01/05 10:11:42 bagder Exp $
+ * $Id: strequal.h,v 1.6 2001/03/14 08:47:56 bagder Exp $
  *****************************************************************************/
-int Curl_strequal(const char *first, const char *second);
-int Curl_strnequal(const char *first, const char *second, size_t max);
 
-#define strequal(a,b) Curl_strequal(a,b)
-#define strnequal(a,b,c) Curl_strnequal(a,b,c)
+/*
+ * These two actually are public functions.
+ */
+int curl_strequal(const char *first, const char *second);
+int curl_strnequal(const char *first, const char *second, size_t max);
+
+#define strequal(a,b) curl_strequal(a,b)
+#define strnequal(a,b,c) curl_strnequal(a,b,c)
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/telnet.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/telnet.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/telnet.c	2001-01-31 23:05:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/telnet.c	2001-03-16 23:21:44.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: telnet.c,v 1.13 2001/01/31 15:05:44 bagder Exp $
+ * $Id: telnet.c,v 1.19 2001/03/16 15:19:36 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -79,522 +79,554 @@
 
 #define  TELOPTS
 #define  TELCMDS
 
 #include "arpa_telnet.h"
 
+/* The last #include file should be: */
+#ifdef MALLOCDEBUG
+#include "memdebug.h"
+#endif
+
 #define SUBBUFSIZE 512
 
-#define  SB_CLEAR()  subpointer = subbuffer;
-#define  SB_TERM()   { subend = subpointer; SB_CLEAR(); }
-#define  SB_ACCUM(c) if (subpointer < (subbuffer+sizeof subbuffer)) { \
-            *subpointer++ = (c); \
+#define  SB_CLEAR(x)  x->subpointer = x->subbuffer;
+#define  SB_TERM(x)   { x->subend = x->subpointer; SB_CLEAR(x); }
+#define  SB_ACCUM(x,c) if (x->subpointer < (x->subbuffer+sizeof x->subbuffer)) { \
+            *x->subpointer++ = (c); \
          }
 
-#define  SB_GET() ((*subpointer++)&0xff)
-#define  SB_PEEK()   ((*subpointer)&0xff)
-#define  SB_EOF() (subpointer >= subend)
-#define  SB_LEN() (subend - subpointer)
+#define  SB_GET(x) ((*x->subpointer++)&0xff)
+#define  SB_PEEK(x)   ((*x->subpointer)&0xff)
+#define  SB_EOF(x) (x->subpointer >= x->subend)
+#define  SB_LEN(x) (x->subend - x->subpointer)
 
 static
-void telrcv(struct UrlData *data,
+void telrcv(struct connectdata *,
 	    unsigned char *inbuf,	/* Data received from socket */
 	    int count);			/* Number of bytes received */
 
 static void printoption(struct UrlData *data,
 			const char *direction,
 			int cmd, int option);
 
-static void negotiate(struct UrlData *data);
-static void send_negotiation(struct UrlData *data, int cmd, int option);
-static void set_local_option(struct UrlData *data, int cmd, int option);
-static void set_remote_option(struct UrlData *data, int cmd, int option);
+static void negotiate(struct connectdata *);
+static void send_negotiation(struct connectdata *, int cmd, int option);
+static void set_local_option(struct connectdata *, int cmd, int option);
+static void set_remote_option(struct connectdata *, int cmd, int option);
 
 static void printsub(struct UrlData *data,
 		     int direction, unsigned char *pointer, int length);
-static void suboption(struct UrlData *data);
+static void suboption(struct connectdata *);
 
-/* suboptions */
-static char subbuffer[SUBBUFSIZE];
-static char *subpointer, *subend;    /* buffer for sub-options */
+/* For negotiation compliant to RFC 1143 */
+#define NO	0
+#define YES 	1
+#define WANTYES	2
+#define WANTNO	3
+
+#define EMPTY	 0
+#define OPPOSITE 1
 
 /*
  * Telnet receiver states for fsm
  */
-static enum
+typedef enum
 {
    TS_DATA = 0,
    TS_IAC,
    TS_WILL,
    TS_WONT,
    TS_DO,
    TS_DONT,
    TS_CR,
    TS_SB,   /* sub-option collection */
    TS_SE   /* looking for sub-option end */
-} telrcv_state;
+} TelnetReceive;
 
-/* For negotiation compliant to RFC 1143 */
-#define NO	0
-#define YES 	1
-#define WANTYES	2
-#define WANTNO	3
-
-#define EMPTY	 0
-#define OPPOSITE 1
-
-static int us[256]; 
-static int usq[256]; 
-static int us_preferred[256]; 
-static int him[256]; 
-static int himq[256]; 
-static int him_preferred[256]; 
+struct TELNET {
+  int please_negotiate;
+  int already_negotiated;
+  int us[256]; 
+  int usq[256]; 
+  int us_preferred[256]; 
+  int him[256]; 
+  int himq[256]; 
+  int him_preferred[256]; 
+  char *subopt_ttype;             /* Set with suboption TTYPE */
+  char *subopt_xdisploc;          /* Set with suboption XDISPLOC */
+  struct curl_slist *telnet_vars; /* Environment variables */
+
+  /* suboptions */
+  char subbuffer[SUBBUFSIZE];
+  char *subpointer, *subend;      /* buffer for sub-options */
+  
+  TelnetReceive telrcv_state;
+};
 
 static
-void init_telnet(struct UrlData *data)
+CURLcode init_telnet(struct connectdata *conn)
 {
-   telrcv_state = TS_DATA;
+  struct TELNET *tn;
 
-   /* Init suboptions */
-   SB_CLEAR();
-
-   /* Set all options to NO */
-   memset(us, NO, 256);
-   memset(usq, NO, 256);
-   memset(us_preferred, NO, 256);
-   memset(him, NO, 256);
-   memset(himq, NO, 256);
-   memset(him_preferred, NO, 256);
-
-   /* Set the options we want */
-   us_preferred[TELOPT_BINARY] = YES;
-   us_preferred[TELOPT_SGA] = YES;
-   him_preferred[TELOPT_BINARY] = YES;
-   him_preferred[TELOPT_SGA] = YES;
+  tn = (struct TELNET *)malloc(sizeof(struct TELNET));
+  if(!tn)
+    return CURLE_OUT_OF_MEMORY;
+  
+  conn->proto.telnet = (void *)tn; /* make us known */
+
+  memset(tn, 0, sizeof(struct TELNET));
+
+  tn->telrcv_state = TS_DATA;
+
+  /* Init suboptions */
+  SB_CLEAR(tn);
+
+  /* Set all options to NO */
+#if 0
+  /* NO is zero => default fill pattern */
+  memset(tn->us, NO, 256);
+  memset(tn->usq, NO, 256);
+  memset(tn->us_preferred, NO, 256);
+  memset(tn->him, NO, 256);
+  memset(tn->himq, NO, 256);
+  memset(tn->him_preferred, NO, 256);
+#endif
+  /* Set the options we want by default */
+  tn->us_preferred[TELOPT_BINARY] = YES;
+  tn->us_preferred[TELOPT_SGA] = YES;
+  tn->him_preferred[TELOPT_BINARY] = YES;
+  tn->him_preferred[TELOPT_SGA] = YES;
 
-   /* Start negotiating */
-   negotiate(data);
+  return CURLE_OK;
 }
 
-static void negotiate(struct UrlData *data)
+static void negotiate(struct connectdata *conn)
 {
-   int i;
+  int i;
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
    
-   for(i = 0;i < NTELOPTS;i++)
-   {
-      if(us_preferred[i] == YES)
-	 set_local_option(data, i, YES);
+  for(i = 0;i < NTELOPTS;i++)
+  {
+    if(tn->us_preferred[i] == YES)
+      set_local_option(conn, i, YES);
       
-      if(him_preferred[i] == YES)
-	 set_remote_option(data, i, YES);
-   }
+    if(tn->him_preferred[i] == YES)
+      set_remote_option(conn, i, YES);
+  }
 }
 
 static void printoption(struct UrlData *data,
 			const char *direction, int cmd, int option)
 {
-   char *fmt;
-   char *opt;
+  char *fmt;
+  char *opt;
    
-   if (data->bits.verbose)
-   {
-      if (cmd == IAC)
-      {
-         if (TELCMD_OK(option))
-            printf("%s IAC %s\n", direction, TELCMD(option));
-         else
-            printf("%s IAC %d\n", direction, option);
-      }
+  if (data->bits.verbose)
+  {
+    if (cmd == IAC)
+    {
+      if (TELCMD_OK(option))
+        printf("%s IAC %s\n", direction, TELCMD(option));
       else
-      {
-         fmt = (cmd == WILL) ? "WILL" : (cmd == WONT) ? "WONT" :
-            (cmd == DO) ? "DO" : (cmd == DONT) ? "DONT" : 0;
-         if (fmt)
-         {
-            if (TELOPT_OK(option))
-               opt = TELOPT(option);
-            else if (option == TELOPT_EXOPL)
-               opt = "EXOPL";
-            else
-               opt = NULL;
-
-            if(opt)
-               printf("%s %s %s\n", direction, fmt, opt);
-            else
-               printf("%s %s %d\n", direction, fmt, option);
-         }
-         else
-            printf("%s %d %d\n", direction, cmd, option);
+        printf("%s IAC %d\n", direction, option);
+    }
+    else
+    {
+      fmt = (cmd == WILL) ? "WILL" : (cmd == WONT) ? "WONT" :
+        (cmd == DO) ? "DO" : (cmd == DONT) ? "DONT" : 0;
+      if (fmt)
+      {
+        if (TELOPT_OK(option))
+          opt = TELOPT(option);
+        else if (option == TELOPT_EXOPL)
+          opt = "EXOPL";
+        else
+          opt = NULL;
+
+        if(opt)
+          printf("%s %s %s\n", direction, fmt, opt);
+        else
+          printf("%s %s %d\n", direction, fmt, option);
       }
-   }
+      else
+        printf("%s %d %d\n", direction, cmd, option);
+    }
+  }
 }
 
-static void send_negotiation(struct UrlData *data, int cmd, int option)
+static void send_negotiation(struct connectdata *conn, int cmd, int option)
 {
    unsigned char buf[3];
 
    buf[0] = IAC;
    buf[1] = cmd;
    buf[2] = option;
    
-   swrite(data->firstsocket, buf, 3);
+   swrite(conn->firstsocket, buf, 3);
    
-   printoption(data, "SENT", cmd, option);
+   printoption(conn->data, "SENT", cmd, option);
 }
 
 static
-void set_remote_option(struct UrlData *data, int option, int newstate)
+void set_remote_option(struct connectdata *conn, int option, int newstate)
 {
-   if(newstate == YES)
-   {
-      switch(him[option])
-      {
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  if(newstate == YES)
+  {
+    switch(tn->him[option])
+    {
       case NO:
-	 him[option] = WANTYES;
-	 send_negotiation(data, DO, option);
-	 break;
+        tn->him[option] = WANTYES;
+        send_negotiation(conn, DO, option);
+        break;
 	 
       case YES:
-	 /* Already enabled */
-	 break;
+        /* Already enabled */
+        break;
 	 
       case WANTNO:
-	 switch(himq[option])
-	 {
-	 case EMPTY:
+        switch(tn->himq[option])
+        {
+          case EMPTY:
 	    /* Already negotiating for YES, queue the request */
-	    himq[option] = OPPOSITE;
+            tn->himq[option] = OPPOSITE;
 	    break;
-	 case OPPOSITE:
+          case OPPOSITE:
 	    /* Error: already queued an enable request */
 	    break;
-	 }
-	 break;
+        }
+        break;
 	 
       case WANTYES:
-	 switch(himq[option])
-	 {
-	 case EMPTY:
+        switch(tn->himq[option])
+        {
+          case EMPTY:
 	    /* Error: already negotiating for enable */
 	    break;
-	 case OPPOSITE:
-	    himq[option] = EMPTY;
+          case OPPOSITE:
+            tn->himq[option] = EMPTY;
 	    break;
-	 }
-	 break;
-      }
-   }
-   else /* NO */
-   {
-      switch(him[option])
-      {
+        }
+        break;
+    }
+  }
+  else /* NO */
+  {
+    switch(tn->him[option])
+    {
       case NO:
-	 /* Already disabled */
-	 break;
+        /* Already disabled */
+        break;
 	 
       case YES:
-	 him[option] = WANTNO;
-	 send_negotiation(data, DONT, option);
-	 break;
+        tn->him[option] = WANTNO;
+        send_negotiation(conn, DONT, option);
+        break;
 	 
       case WANTNO:
-	 switch(himq[option])
-	 {
-	 case EMPTY:
+        switch(tn->himq[option])
+        {
+          case EMPTY:
 	    /* Already negotiating for NO */
 	    break;
-	 case OPPOSITE:
-	    himq[option] = EMPTY;
+          case OPPOSITE:
+            tn->himq[option] = EMPTY;
 	    break;
-	 }
-	 break;
+        }
+        break;
 	 
       case WANTYES:
-	 switch(himq[option])
-	 {
-	 case EMPTY:
-	    himq[option] = OPPOSITE;
+        switch(tn->himq[option])
+        {
+          case EMPTY:
+            tn->himq[option] = OPPOSITE;
 	    break;
-	 case OPPOSITE:
+          case OPPOSITE:
 	    break;
-	 }
-	 break;
-      }
-   }
+        }
+        break;
+    }
+  }
 }
 
 static
-void rec_will(struct UrlData *data, int option)
+void rec_will(struct connectdata *conn, int option)
 {
-   switch(him[option])
-   {
-   case NO:
-      if(him_preferred[option] == YES)
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  switch(tn->him[option])
+  {
+    case NO:
+      if(tn->him_preferred[option] == YES)
       {
-	 him[option] = YES;
-	 send_negotiation(data, DO, option);
+        tn->him[option] = YES;
+        send_negotiation(conn, DO, option);
       }
       else
       {
-	 send_negotiation(data, DONT, option);
+        send_negotiation(conn, DONT, option);
       }
       break;
 	 
-   case YES:
+    case YES:
       /* Already enabled */
       break;
 	 
-   case WANTNO:
-      switch(himq[option])
+    case WANTNO:
+      switch(tn->himq[option])
       {
-      case EMPTY:
-	 /* Error: DONT answered by WILL */
-	 him[option] = NO;
-	 break;
-      case OPPOSITE:
-	 /* Error: DONT answered by WILL */
-	 him[option] = YES;
-	 himq[option] = EMPTY;
-	 break;
+        case EMPTY:
+          /* Error: DONT answered by WILL */
+          tn->him[option] = NO;
+          break;
+        case OPPOSITE:
+          /* Error: DONT answered by WILL */
+          tn->him[option] = YES;
+          tn->himq[option] = EMPTY;
+          break;
       }
       break;
 	 
-   case WANTYES:
-      switch(himq[option])
-      {
-      case EMPTY:
-	 him[option] = YES;
-	 break;
-      case OPPOSITE:
-	 him[option] = WANTNO;
-	 himq[option] = EMPTY;
-	 send_negotiation(data, DONT, option);
-	 break;
+    case WANTYES:
+      switch(tn->himq[option])
+      {
+        case EMPTY:
+          tn->him[option] = YES;
+          break;
+        case OPPOSITE:
+          tn->him[option] = WANTNO;
+          tn->himq[option] = EMPTY;
+          send_negotiation(conn, DONT, option);
+          break;
       }
       break;
-   }
+  }
 }
    
 static
-void rec_wont(struct UrlData *data, int option)
+void rec_wont(struct connectdata *conn, int option)
 {
-   switch(him[option])
-   {
-   case NO:
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  switch(tn->him[option])
+  {
+    case NO:
       /* Already disabled */
       break;
 	 
-   case YES:
-      him[option] = NO;
-      send_negotiation(data, DONT, option);
+    case YES:
+      tn->him[option] = NO;
+      send_negotiation(conn, DONT, option);
       break;
 	 
-   case WANTNO:
-      switch(himq[option])
+    case WANTNO:
+      switch(tn->himq[option])
       {
-      case EMPTY:
-	 him[option] = NO;
-	 break;
+        case EMPTY:
+          tn->him[option] = NO;
+          break;
 	 
-      case OPPOSITE:
-	 him[option] = WANTYES;
-	 himq[option] = EMPTY;
-	 send_negotiation(data, DO, option);
-	 break;
+        case OPPOSITE:
+          tn->him[option] = WANTYES;
+          tn->himq[option] = EMPTY;
+          send_negotiation(conn, DO, option);
+          break;
       }
       break;
 	 
-   case WANTYES:
-      switch(himq[option])
+    case WANTYES:
+      switch(tn->himq[option])
       {
-      case EMPTY:
-	 him[option] = NO;
-	 break;
-      case OPPOSITE:
-	 him[option] = NO;
-	 himq[option] = EMPTY;
-	 break;
+        case EMPTY:
+          tn->him[option] = NO;
+          break;
+        case OPPOSITE:
+          tn->him[option] = NO;
+          tn->himq[option] = EMPTY;
+          break;
       }
       break;
-   }
+  }
 }
    
-void set_local_option(struct UrlData *data, int option, int newstate)
+void set_local_option(struct connectdata *conn, int option, int newstate)
 {
-   if(newstate == YES)
-   {
-      switch(us[option])
-      {
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  if(newstate == YES)
+  {
+    switch(tn->us[option])
+    {
       case NO:
-	 us[option] = WANTYES;
-	 send_negotiation(data, WILL, option);
-	 break;
+        tn->us[option] = WANTYES;
+        send_negotiation(conn, WILL, option);
+        break;
 	 
       case YES:
-	 /* Already enabled */
-	 break;
+        /* Already enabled */
+        break;
 	 
       case WANTNO:
-	 switch(usq[option])
-	 {
-	 case EMPTY:
+        switch(tn->usq[option])
+        {
+          case EMPTY:
 	    /* Already negotiating for YES, queue the request */
-	    usq[option] = OPPOSITE;
+            tn->usq[option] = OPPOSITE;
 	    break;
-	 case OPPOSITE:
+          case OPPOSITE:
 	    /* Error: already queued an enable request */
 	    break;
-	 }
-	 break;
+        }
+        break;
 	 
       case WANTYES:
-	 switch(usq[option])
-	 {
-	 case EMPTY:
+        switch(tn->usq[option])
+        {
+          case EMPTY:
 	    /* Error: already negotiating for enable */
 	    break;
-	 case OPPOSITE:
-	    usq[option] = EMPTY;
+          case OPPOSITE:
+            tn->usq[option] = EMPTY;
 	    break;
-	 }
-	 break;
-      }
-   }
-   else /* NO */
-   {
-      switch(us[option])
-      {
+        }
+        break;
+    }
+  }
+  else /* NO */
+  {
+    switch(tn->us[option])
+    {
       case NO:
-	 /* Already disabled */
-	 break;
+        /* Already disabled */
+        break;
 	 
       case YES:
-	 us[option] = WANTNO;
-	 send_negotiation(data, WONT, option);
-	 break;
+        tn->us[option] = WANTNO;
+        send_negotiation(conn, WONT, option);
+        break;
 	 
       case WANTNO:
-	 switch(usq[option])
-	 {
-	 case EMPTY:
+        switch(tn->usq[option])
+        {
+          case EMPTY:
 	    /* Already negotiating for NO */
 	    break;
-	 case OPPOSITE:
-	    usq[option] = EMPTY;
+          case OPPOSITE:
+            tn->usq[option] = EMPTY;
 	    break;
-	 }
-	 break;
+        }
+        break;
 	 
       case WANTYES:
-	 switch(usq[option])
-	 {
-	 case EMPTY:
-	    usq[option] = OPPOSITE;
+        switch(tn->usq[option])
+        {
+          case EMPTY:
+            tn->usq[option] = OPPOSITE;
 	    break;
-	 case OPPOSITE:
+          case OPPOSITE:
 	    break;
-	 }
-	 break;
-      }
-   }
+        }
+        break;
+    }
+  }
 }
 
 static
-void rec_do(struct UrlData *data, int option)
+void rec_do(struct connectdata *conn, int option)
 {
-   switch(us[option])
-   {
-   case NO:
-      if(us_preferred[option] == YES)
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  switch(tn->us[option])
+  {
+    case NO:
+      if(tn->us_preferred[option] == YES)
       {
-	 us[option] = YES;
-	 send_negotiation(data, WILL, option);
+        tn->us[option] = YES;
+        send_negotiation(conn, WILL, option);
       }
       else
       {
-	 send_negotiation(data, WONT, option);
+        send_negotiation(conn, WONT, option);
       }
       break;
 	 
-   case YES:
+    case YES:
       /* Already enabled */
       break;
 	 
-   case WANTNO:
-      switch(usq[option])
+    case WANTNO:
+      switch(tn->usq[option])
       {
-      case EMPTY:
-	 /* Error: DONT answered by WILL */
-	 us[option] = NO;
-	 break;
-      case OPPOSITE:
-	 /* Error: DONT answered by WILL */
-	 us[option] = YES;
-	 usq[option] = EMPTY;
-	 break;
+        case EMPTY:
+          /* Error: DONT answered by WILL */
+          tn->us[option] = NO;
+          break;
+        case OPPOSITE:
+          /* Error: DONT answered by WILL */
+          tn->us[option] = YES;
+          tn->usq[option] = EMPTY;
+          break;
       }
       break;
 	 
-   case WANTYES:
-      switch(usq[option])
-      {
-      case EMPTY:
-	 us[option] = YES;
-	 break;
-      case OPPOSITE:
-	 us[option] = WANTNO;
-	 himq[option] = EMPTY;
-	 send_negotiation(data, WONT, option);
-	 break;
+    case WANTYES:
+      switch(tn->usq[option])
+      {
+        case EMPTY:
+          tn->us[option] = YES;
+          break;
+        case OPPOSITE:
+          tn->us[option] = WANTNO;
+          tn->himq[option] = EMPTY;
+          send_negotiation(conn, WONT, option);
+          break;
       }
       break;
-   }
+  }
 }
 
 static   
-void rec_dont(struct UrlData *data, int option)
+void rec_dont(struct connectdata *conn, int option)
 {
-   switch(us[option])
-   {
-   case NO:
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  switch(tn->us[option])
+  {
+    case NO:
       /* Already disabled */
       break;
 	 
-   case YES:
-      us[option] = NO;
-      send_negotiation(data, WONT, option);
+    case YES:
+      tn->us[option] = NO;
+      send_negotiation(conn, WONT, option);
       break;
 	 
-   case WANTNO:
-      switch(usq[option])
+    case WANTNO:
+      switch(tn->usq[option])
       {
-      case EMPTY:
-	 us[option] = NO;
-	 break;
+        case EMPTY:
+          tn->us[option] = NO;
+          break;
 	 
-      case OPPOSITE:
-	 us[option] = WANTYES;
-	 usq[option] = EMPTY;
-	 send_negotiation(data, WILL, option);
-	 break;
+        case OPPOSITE:
+          tn->us[option] = WANTYES;
+          tn->usq[option] = EMPTY;
+          send_negotiation(conn, WILL, option);
+          break;
       }
       break;
 	 
-   case WANTYES:
-      switch(usq[option])
+    case WANTYES:
+      switch(tn->usq[option])
       {
-      case EMPTY:
-	 us[option] = NO;
-	 break;
-      case OPPOSITE:
-	 us[option] = NO;
-	 usq[option] = EMPTY;
-	 break;
+        case EMPTY:
+          tn->us[option] = NO;
+          break;
+        case OPPOSITE:
+          tn->us[option] = NO;
+          tn->usq[option] = EMPTY;
+          break;
       }
       break;
-   }
+  }
 }
 
 
 static void printsub(struct UrlData *data,
 		     int direction,		/* '<' or '>' */
 		     unsigned char *pointer,	/* where suboption data is */
@@ -596,250 +628,432 @@
 
 
 static void printsub(struct UrlData *data,
 		     int direction,		/* '<' or '>' */
 		     unsigned char *pointer,	/* where suboption data is */
 		     int length)		/* length of suboption data */
-
 {
-   int i = 0;
+  int i = 0;
 
-   if (data->bits.verbose)
-   {
-      if (direction)
-      {
-         printf("%s IAC SB ", (direction == '<')? "RCVD":"SENT");
-         if (length >= 3)
-         {
-            int j;
-
-            i = pointer[length-2];
-            j = pointer[length-1];
-
-            if (i != IAC || j != SE)
-            {
-               printf("(terminated by ");
-               if (TELOPT_OK(i))
-                  printf("%s ", TELOPT(i));
-               else if (TELCMD_OK(i))
-                  printf("%s ", TELCMD(i));
-               else
-                  printf("%d ", i);
-               if (TELOPT_OK(j))
-                  printf("%s", TELOPT(j));
-               else if (TELCMD_OK(j))
-                  printf("%s", TELCMD(j));
-               else
-                  printf("%d", j);
-               printf(", not IAC SE!) ");
-            }
-         }
-         length -= 2;
-      }
-      if (length < 1)
+  if (data->bits.verbose)
+  {
+    if (direction)
+    {
+      printf("%s IAC SB ", (direction == '<')? "RCVD":"SENT");
+      if (length >= 3)
       {
-         printf("(Empty suboption?)");
-         return;
+        int j;
+
+        i = pointer[length-2];
+        j = pointer[length-1];
+
+        if (i != IAC || j != SE)
+        {
+          printf("(terminated by ");
+          if (TELOPT_OK(i))
+            printf("%s ", TELOPT(i));
+          else if (TELCMD_OK(i))
+            printf("%s ", TELCMD(i));
+          else
+            printf("%d ", i);
+          if (TELOPT_OK(j))
+            printf("%s", TELOPT(j));
+          else if (TELCMD_OK(j))
+            printf("%s", TELCMD(j));
+          else
+            printf("%d", j);
+          printf(", not IAC SE!) ");
+        }
       }
+      length -= 2;
+    }
+    if (length < 1)
+    {
+      printf("(Empty suboption?)");
+      return;
+    }
 
-      if (TELOPT_OK(pointer[0]))
-	 printf("%s (unknown)", TELOPT(pointer[0]));
-      else
-	 printf("%d (unknown)", pointer[i]);
-      for (i = 1; i < length; i++)
-	 printf(" %d", pointer[i]);
+    if (TELOPT_OK(pointer[0])) {
+      switch(pointer[0]) {
+        case TELOPT_TTYPE:
+        case TELOPT_XDISPLOC:
+        case TELOPT_NEW_ENVIRON:
+          printf("%s", TELOPT(pointer[0]));
+          break;
+        default:
+          printf("%s (unsupported)", TELOPT(pointer[0]));
+          break;
+      }
+    }
+    else
+      printf("%d (unknown)", pointer[i]);
+
+    switch(pointer[1]) {
+      case TELQUAL_IS:
+        printf(" IS");
+        break;
+      case TELQUAL_SEND:
+        printf(" SEND");
+        break;
+      case TELQUAL_INFO:
+        printf(" INFO/REPLY");
+        break;
+      case TELQUAL_NAME:
+        printf(" NAME");
+        break;
+    }
       
-      if (direction)
-      {
-         printf("\n");
+    switch(pointer[0]) {
+      case TELOPT_TTYPE:
+      case TELOPT_XDISPLOC:
+        pointer[length] = 0;
+        printf(" \"%s\"", &pointer[2]);
+        break;
+      case TELOPT_NEW_ENVIRON:
+        if(pointer[1] == TELQUAL_IS) {
+          printf(" ");
+          for(i = 3;i < length;i++) {
+            switch(pointer[i]) {
+              case NEW_ENV_VAR:
+                printf(", ");
+                break;
+              case NEW_ENV_VALUE:
+                printf(" = ");
+                break;
+              default:
+                printf("%c", pointer[i]);
+                break;
+            }
+          }
+        }
+        break;
+      default:
+        for (i = 2; i < length; i++)
+          printf(" %.2x", pointer[i]);
+        break;
+    }
+      
+    if (direction)
+    {
+      printf("\n");
+    }
+  }
+}
+
+static int check_telnet_options(struct connectdata *conn)
+{
+  struct curl_slist *head;
+  char option_keyword[128];
+  char option_arg[256];
+  char *buf;
+  struct UrlData *data = conn->data;
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+
+  /* Add the user name as an environment variable if it
+     was given on the command line */
+  if(conn->bits.user_passwd)
+  {
+    char *buf = malloc(256);
+    sprintf(buf, "USER,%s", data->user);
+    tn->telnet_vars = curl_slist_append(tn->telnet_vars, buf);
+
+    tn->us_preferred[TELOPT_NEW_ENVIRON] = YES;
+  }
+
+  for(head = data->telnet_options; head; head=head->next) {
+    if(sscanf(head->data, "%127[^= ]%*[ =]%255s",
+              option_keyword, option_arg) == 2) {
+
+      /* Terminal type */
+      if(strequal(option_keyword, "TTYPE")) {
+        tn->subopt_ttype = option_arg;
+        tn->us_preferred[TELOPT_TTYPE] = YES;
+        continue;
+      }
+
+      /* Display variable */
+      if(strequal(option_keyword, "XDISPLOC")) {
+        tn->subopt_xdisploc = option_arg;
+        tn->us_preferred[TELOPT_XDISPLOC] = YES;
+        continue;
+      }
+
+      /* Environment variable */
+      if(strequal(option_keyword, "NEW_ENV")) {
+        buf = strdup(option_arg);
+        if(!buf)
+          return CURLE_OUT_OF_MEMORY;
+        tn->telnet_vars = curl_slist_append(tn->telnet_vars, buf);
+        tn->us_preferred[TELOPT_NEW_ENVIRON] = YES;
+        continue;
       }
-   }
+
+      failf(data, "Unknown telnet option %s", head->data);
+      return CURLE_UNKNOWN_TELNET_OPTION;
+    } else {
+      failf(data, "Syntax error in telnet option: %s", head->data);
+      return CURLE_TELNET_OPTION_SYNTAX;
+    }
+  }
+
+  return CURLE_OK;
 }
 
 /*
  * suboption()
  *
  * Look at the sub-option buffer, and try to be helpful to the other
  * side.
- * No suboptions are supported yet.
  */
 
-static void suboption(struct UrlData *data)
+static void suboption(struct connectdata *conn)
 {
-   printsub(data, '<', (unsigned char *)subbuffer, SB_LEN()+2);
-   return;
+  struct curl_slist *v;
+  unsigned char subchar;
+  unsigned char temp[2048];
+  int len;
+  int tmplen;
+  char varname[128];
+  char varval[128];
+  struct UrlData *data = conn->data;
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+
+  printsub(data, '<', (unsigned char *)tn->subbuffer, SB_LEN(tn)+2);
+  switch (subchar = SB_GET(tn)) {
+    case TELOPT_TTYPE:
+      len = strlen(tn->subopt_ttype) + 4 + 2;
+      snprintf((char *)temp, sizeof(temp),
+               "%c%c%c%c%s%c%c", IAC, SB, TELOPT_TTYPE,
+               TELQUAL_IS, tn->subopt_ttype, IAC, SE);
+      swrite(conn->firstsocket, temp, len);
+      printsub(data, '>', &temp[2], len-2);
+      break;
+    case TELOPT_XDISPLOC:
+      len = strlen(tn->subopt_xdisploc) + 4 + 2;
+      snprintf((char *)temp, sizeof(temp),
+               "%c%c%c%c%s%c%c", IAC, SB, TELOPT_XDISPLOC,
+               TELQUAL_IS, tn->subopt_xdisploc, IAC, SE);
+      swrite(conn->firstsocket, temp, len);
+      printsub(data, '>', &temp[2], len-2);
+      break;
+    case TELOPT_NEW_ENVIRON:
+      snprintf((char *)temp, sizeof(temp),
+               "%c%c%c%c", IAC, SB, TELOPT_NEW_ENVIRON, TELQUAL_IS);
+      len = 4;
+
+      for(v = tn->telnet_vars;v;v = v->next) {
+        tmplen = (strlen(v->data) + 1);
+        /* Add the variable only if it fits */
+        if(len + tmplen < sizeof(temp)-6) {
+          sscanf(v->data, "%127[^,],%s", varname, varval);
+          snprintf((char *)&temp[len], sizeof(temp) - len,
+                   "%c%s%c%s", NEW_ENV_VAR, varname,
+                   NEW_ENV_VALUE, varval);
+          len += tmplen;
+        }
+      }
+      snprintf((char *)&temp[len], sizeof(temp) - len,
+               "%c%c", IAC, SE);
+      len += 2;
+      swrite(conn->firstsocket, temp, len);
+      printsub(data, '>', &temp[2], len-2);
+      break;
+  }
+  return;
 }
 
 static
-void telrcv(struct UrlData *data,
+void telrcv(struct connectdata *conn,
 	    unsigned char *inbuf,	/* Data received from socket */
 	    int count)			/* Number of bytes received */
 {
-   unsigned char c;
-   int index = 0;
+  unsigned char c;
+  int index = 0;
+  struct UrlData *data = conn->data;
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
 
-   while(count--)
-   {
-      c = inbuf[index++];
+  while(count--)
+  {
+    c = inbuf[index++];
 
-      switch (telrcv_state)
-      {
+    switch (tn->telrcv_state)
+    {
       case TS_CR:
-	 telrcv_state = TS_DATA;
-	 if (c == '\0')
-	 {
-	    break;   /* Ignore \0 after CR */
-	 }
+        tn->telrcv_state = TS_DATA;
+        if (c == '\0')
+        {
+          break;   /* Ignore \0 after CR */
+        }
 
-	 Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
-	 continue;
+        Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
+        continue;
 
       case TS_DATA:
-	 if (c == IAC)
-	 {
-	    telrcv_state = TS_IAC;
-	    break;
-	 }
-	 else if(c == '\r')
-	 {
-	    telrcv_state = TS_CR;
-	 }
+        if (c == IAC)
+        {
+          tn->telrcv_state = TS_IAC;
+          break;
+        }
+        else if(c == '\r')
+        {
+          tn->telrcv_state = TS_CR;
+        }
 
-	 Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
-	 continue;
+        Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
+        continue;
 
       case TS_IAC:
-	process_iac:
-	switch (c)
-	{
+      process_iac:
+      switch (c)
+      {
 	case WILL:
-	   telrcv_state = TS_WILL;
-	   continue;
+          tn->telrcv_state = TS_WILL;
+          continue;
 	case WONT:
-	   telrcv_state = TS_WONT;
-	   continue;
+          tn->telrcv_state = TS_WONT;
+          continue;
 	case DO:
-	   telrcv_state = TS_DO;
-	   continue;
+          tn->telrcv_state = TS_DO;
+          continue;
 	case DONT:
-	   telrcv_state = TS_DONT;
-	   continue;
+          tn->telrcv_state = TS_DONT;
+          continue;
 	case SB:
-	   SB_CLEAR();
-	   telrcv_state = TS_SB;
-	   continue;
+          SB_CLEAR(tn);
+          tn->telrcv_state = TS_SB;
+          continue;
 	case IAC:
           Curl_client_write(data, CLIENTWRITE_BODY, (char *)&c, 1);
           break;
 	case DM:
 	case NOP:
 	case GA:
 	default:
-	   printoption(data, "RCVD", IAC, c);
-	   break;
-	}
-	telrcv_state = TS_DATA;
-	continue;
+          printoption(data, "RCVD", IAC, c);
+          break;
+      }
+      tn->telrcv_state = TS_DATA;
+      continue;
 
       case TS_WILL:
-	 printoption(data, "RCVD", WILL, c);
-	 rec_will(data, c);
-	 telrcv_state = TS_DATA;
-	 continue;
+        printoption(data, "RCVD", WILL, c);
+        tn->please_negotiate = 1;
+        rec_will(conn, c);
+        tn->telrcv_state = TS_DATA;
+        continue;
       
       case TS_WONT:
-	 printoption(data, "RCVD", WONT, c);
-	 rec_wont(data, c);
-	 telrcv_state = TS_DATA;
-	 continue;
+        printoption(data, "RCVD", WONT, c);
+        tn->please_negotiate = 1;
+        rec_wont(conn, c);
+        tn->telrcv_state = TS_DATA;
+        continue;
       
       case TS_DO:
-	 printoption(data, "RCVD", DO, c);
-	 rec_do(data, c);
-	 telrcv_state = TS_DATA;
-	 continue;
+        printoption(data, "RCVD", DO, c);
+        tn->please_negotiate = 1;
+        rec_do(conn, c);
+        tn->telrcv_state = TS_DATA;
+        continue;
       
       case TS_DONT:
-	 printoption(data, "RCVD", DONT, c);
-	 rec_dont(data, c);
-	 telrcv_state = TS_DATA;
-	 continue;
+        printoption(data, "RCVD", DONT, c);
+        tn->please_negotiate = 1;
+        rec_dont(conn, c);
+        tn->telrcv_state = TS_DATA;
+        continue;
 
       case TS_SB:
-	 if (c == IAC)
-	 {
-	    telrcv_state = TS_SE;
-	 }
-	 else
-	 {
-	    SB_ACCUM(c);
-	 }
-	 continue;
+        if (c == IAC)
+        {
+          tn->telrcv_state = TS_SE;
+        }
+        else
+        {
+          SB_ACCUM(tn,c);
+        }
+        continue;
 
       case TS_SE:
-	 if (c != SE)
-	 {
-	    if (c != IAC)
-	    {
-	       /*
-		* This is an error.  We only expect to get
-		* "IAC IAC" or "IAC SE".  Several things may
-		* have happend.  An IAC was not doubled, the
-		* IAC SE was left off, or another option got
-		* inserted into the suboption are all possibilities.
-		* If we assume that the IAC was not doubled,
-		* and really the IAC SE was left off, we could
-		* get into an infinate loop here.  So, instead,
-		* we terminate the suboption, and process the
-		* partial suboption if we can.
-		*/
-	       SB_ACCUM((unsigned char)IAC);
-	       SB_ACCUM(c);
-	       subpointer -= 2;
-	       SB_TERM();
+        if (c != SE)
+        {
+          if (c != IAC)
+          {
+            /*
+             * This is an error.  We only expect to get
+             * "IAC IAC" or "IAC SE".  Several things may
+             * have happend.  An IAC was not doubled, the
+             * IAC SE was left off, or another option got
+             * inserted into the suboption are all possibilities.
+             * If we assume that the IAC was not doubled,
+             * and really the IAC SE was left off, we could
+             * get into an infinate loop here.  So, instead,
+             * we terminate the suboption, and process the
+             * partial suboption if we can.
+             */
+            SB_ACCUM(tn, (unsigned char)IAC);
+            SB_ACCUM(tn, c);
+            tn->subpointer -= 2;
+            SB_TERM(tn);
 	    
-	       printoption(data, "In SUBOPTION processing, RCVD", IAC, c);
-	       suboption(data);   /* handle sub-option */
-	       telrcv_state = TS_IAC;
-	       goto process_iac;
-	    }
-	    SB_ACCUM(c);
-	    telrcv_state = TS_SB;
-	 }
-	 else
-	 {
-	    SB_ACCUM((unsigned char)IAC);
-	    SB_ACCUM((unsigned char)SE);
-	    subpointer -= 2;
-	    SB_TERM();
-	    suboption(data);   /* handle sub-option */
-	    telrcv_state = TS_DATA;
-	 }
-	 break;
-      }
-   }
+            printoption(data, "In SUBOPTION processing, RCVD", IAC, c);
+            suboption(conn);   /* handle sub-option */
+            tn->telrcv_state = TS_IAC;
+            goto process_iac;
+          }
+          SB_ACCUM(tn,c);
+          tn->telrcv_state = TS_SB;
+        }
+        else
+        {
+          SB_ACCUM(tn, (unsigned char)IAC);
+          SB_ACCUM(tn, (unsigned char)SE);
+          tn->subpointer -= 2;
+          SB_TERM(tn);
+          suboption(conn);   /* handle sub-option */
+          tn->telrcv_state = TS_DATA;
+        }
+        break;
+    }
+  }
 }
 
 CURLcode Curl_telnet_done(struct connectdata *conn)
 {
+  struct TELNET *tn = (struct TELNET *)conn->proto.telnet;
+  curl_slist_free_all(tn->telnet_vars);
+
+  free(conn->proto.telnet);
+  conn->proto.telnet = NULL;
+
   return CURLE_OK;
 }
 
 CURLcode Curl_telnet(struct connectdata *conn)
 {
+  CURLcode code;
   struct UrlData *data = conn->data;
-  int sockfd = data->firstsocket;
+  int sockfd = conn->firstsocket;
   fd_set readfd;
   fd_set keepfd;
 
   bool keepon = TRUE;
   char *buf = data->buffer;
   ssize_t nread;
+  struct TELNET *tn;
 
-  init_telnet(data);
-   
+  code = init_telnet(conn);
+  if(code)
+    return code;
+
+  tn = (struct TELNET *)conn->proto.telnet;
+
+  code = check_telnet_options(conn);
+  if(code)
+    return code;
+  
   FD_ZERO (&readfd);		/* clear it */
   FD_SET (sockfd, &readfd);
   FD_SET (1, &readfd);
 
   keepfd = readfd;
 
@@ -864,13 +1078,13 @@
         while(nread--) {
           outbuf[0] = *buffer++;
           out_count = 1;
           if(outbuf[0] == IAC)
             outbuf[out_count++] = IAC;
       
-          Curl_write(conn, data->firstsocket, outbuf,
+          Curl_write(conn, conn->firstsocket, outbuf,
                      out_count, &bytes_written);
         }
       }
 
       if(FD_ISSET(sockfd, &readfd)) {
         Curl_read(conn, sockfd, buf, BUFSIZE - 1, &nread);
@@ -879,13 +1093,21 @@
            we bail out from this! */
         if (nread <= 0) {
           keepon = FALSE;
           break;
         }
 
-        telrcv(data, (unsigned char *)buf, nread);
+        telrcv(conn, (unsigned char *)buf, nread);
+
+        /* Negotiate if the peer has started negotiating,
+           otherwise don't. We don't want to speak telnet with
+           non-telnet servers, like POP or SMTP. */
+        if(tn->please_negotiate && !tn->already_negotiated) {
+          negotiate(conn);
+          tn->already_negotiated = 1;
+        }
       }
     }
   }
   /* mark this as "no further transfer wanted" */
   return Curl_Transfer(conn, -1, -1, FALSE, NULL, -1, NULL);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/timeval.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/timeval.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/timeval.c	2001-01-05 18:11:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/timeval.c	2001-03-13 20:35:46.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: timeval.c,v 1.5 2001/01/05 10:11:43 bagder Exp $
+ * $Id: timeval.c,v 1.6 2001/03/13 07:53:06 bagder Exp $
  *****************************************************************************/
 
 #ifdef WIN32
 #include <windows.h>
 #endif
 #include "timeval.h"
@@ -50,13 +50,13 @@
  return 1;
 }
 #define HAVE_GETTIMEOFDAY
 #endif
 #endif
 
-struct timeval Curl_tvnow ()
+struct timeval Curl_tvnow (void)
 {
  struct timeval now;
 #ifdef HAVE_GETTIMEOFDAY
  gettimeofday (&now, NULL);
 #else
  now.tv_sec = (long) time(NULL);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/transfer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/transfer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/transfer.c	2001-02-13 21:32:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/transfer.c	2001-03-19 15:47:57.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.c,v 1.9 2001/02/07 08:36:23 bagder Exp $
+ * $Id: transfer.c,v 1.23 2001/03/19 07:47:57 bagder Exp $
  *****************************************************************************/
 
 #include "setup.h"
 
 /* -- WIN32 approved -- */
 #include <stdio.h>
@@ -86,12 +86,13 @@
 #include "transfer.h"
 #include "sendf.h"
 #include "speedcheck.h"
 #include "getpass.h"
 #include "progress.h"
 #include "getdate.h"
+#include "http.h"
 
 #define _MPRINTF_REPLACE /* use our functions only */
 #include <curl/mprintf.h>
 
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
@@ -103,13 +104,13 @@
 #endif
 
 /* Parts of this function was written by the friendly Mark Butler
    <butlerm@xmission.com>. */
 
 CURLcode static
-_Transfer(struct connectdata *c_conn)
+Transfer(struct connectdata *c_conn)
 {
   ssize_t nread;                /* number of bytes read */
   int bytecount = 0;            /* total number of bytes read */
   int writebytecount = 0;       /* number of bytes written */
   long contentlength=0;         /* size of incoming data */
   struct timeval start = Curl_tvnow();
@@ -123,13 +124,14 @@
   char *str_start;		/* within buf */
   char *end_ptr;		/* within buf */
   char *p;			/* within headerbuff */
   bool content_range = FALSE;	/* set TRUE if Content-Range: was found */
   int offset = 0;		/* possible resume offset read from the
                                    Content-Range: header */
-  int code = 0;			/* error code from the 'HTTP/1.? XXX' line */
+  int httpcode = 0;		/* error code from the 'HTTP/1.? XXX' line */
+  int httpversion = -1;         /* the last digit in the HTTP/1.1 string */
 
   /* for the low speed checks: */
   CURLcode urg;
   time_t timeofdoc=0;
   long bodywrites=0;
   int writetype;
@@ -137,15 +139,12 @@
   /* the highest fd we use + 1 */
   struct UrlData *data;
   struct connectdata *conn = (struct connectdata *)c_conn;
   char *buf;
   int maxfd;
 
-  if(!conn || (conn->handle != STRUCT_CONNECT))
-    return CURLE_BAD_FUNCTION_ARGUMENT;
-  
   data = conn->data; /* there's the root struct */
   buf = data->buffer;
   maxfd = (conn->sockfd>conn->writesockfd?conn->sockfd:conn->writesockfd)+1;
 
   hbufp = data->headerbuff;
 
@@ -179,13 +178,13 @@
     fd_set rkeepfd;
     fd_set wkeepfd;
     struct timeval interval;
     int keepon=0;
 
     /* timeout every X second
-       - makes a better progressmeter (i.e even when no data is read, the
+       - makes a better progress meter (i.e even when no data is read, the
        meter can be updated and reflect reality)
        - allows removal of the alarm() crap
        - variable timeout is easier
      */
 
     FD_ZERO (&readfd);		/* clear it */
@@ -308,24 +307,40 @@
               
               p = data->headerbuff;
               
               /* we now have a full line that p points to */
               if (('\n' == *p) || ('\r' == *p)) {
                 /* Zero-length line means end of header! */
+#if 0
                 if (-1 != conn->size)	/* if known */
-                  conn->size += bytecount; /* we append the already read size */
+                  conn->size += bytecount; /* we append the already read
+                                              size */
+#endif
 
 
                 if ('\r' == *p)
                   p++;		/* pass the \r byte */
                 if ('\n' == *p)
                   p++;		/* pass the \n byte */
-
+#if 0 /* headers are not included in the size */
                 Curl_pgrsSetDownloadSize(data, conn->size);
+#endif
 
-                header = FALSE;	/* no more header to parse! */
+                if(100 == httpcode) {
+                  /*
+                   * we have made a HTTP PUT or POST and this is 1.1-lingo
+                   * that tells us that the server is OK with this and ready
+                   * to receive our stuff.
+                   * However, we'll get more headers now so we must get
+                   * back into the header-parsing state!
+                   */
+                  header = TRUE;
+                  headerline = 0; /* we restart the header line counter */
+                }
+                else
+                  header = FALSE;	/* no more header to parse! */
 
                 /* now, only output this if the header AND body are requested:
                  */
                 writetype = CLIENTWRITE_HEADER;
                 if (data->bits.http_include_header)
                   writetype |= CLIENTWRITE_BODY;
@@ -333,46 +348,113 @@
                 urg = Curl_client_write(data, writetype, data->headerbuff,
                                         p - data->headerbuff);
                 if(urg)
                   return urg;
 
                 data->header_size += p - data->headerbuff;
-                break;		/* exit header line loop */
+
+                if(!header) {
+                  /*
+                   * end-of-headers.
+                   *
+                   * If we requested a "no body" and this isn't a "close"
+                   * connection, this is a good time to get out and return
+                   * home.
+                   */
+                  if(!conn->bits.close && data->bits.no_body)
+                    return CURLE_OK;
+                  break;		/* exit header line loop */
+                }
+
+                /* We continue reading headers, so reset the line-based
+                   header parsing variables hbufp && hbuflen */
+                hbufp = data->headerbuff;
+                hbuflen = 0;
+                continue;
               }
               
               if (!headerline++) {
                 /* This is the first header, it MUST be the error code line
                    or else we consiser this to be the body right away! */
-                if (sscanf (p, " HTTP/1.%*c %3d", &code)) {
+                if (2 == sscanf (p, " HTTP/1.%d %3d", &httpversion,
+                                 &httpcode)) {
                   /* 404 -> URL not found! */
                   if (
-                      ( ((data->bits.http_follow_location) && (code >= 400))
+                      ( ((data->bits.http_follow_location) &&
+                         (httpcode >= 400))
                         ||
-                        (!data->bits.http_follow_location && (code >= 300)))
+                        (!data->bits.http_follow_location &&
+                         (httpcode >= 300)))
                       && (data->bits.http_fail_on_error)) {
                     /* If we have been told to fail hard on HTTP-errors,
                        here is the check for that: */
                     /* serious error, go home! */
                     failf (data, "The requested file was not found");
                     return CURLE_HTTP_NOT_FOUND;
                   }
-                  data->progress.httpcode = code;
+                  data->progress.httpcode = httpcode;
+                  data->progress.httpversion = httpversion;
+                  if(httpversion == 0)
+                    /* Default action for HTTP/1.0 must be to close, unless
+                       we get one of those fancy headers that tell us the
+                       server keeps it open for us! */
+                    conn->bits.close = TRUE;
                 }
                 else {
                   header = FALSE;	/* this is not a header line */
                   break;
                 }
               }
               /* check for Content-Length: header lines to get size */
               if (strnequal("Content-Length", p, 14) &&
-                  sscanf (p+14, ": %ld", &contentlength))
+                  sscanf (p+14, ": %ld", &contentlength)) {
                 conn->size = contentlength;
+                Curl_pgrsSetDownloadSize(data, contentlength);
+              }
+              else if((httpversion == 0) &&
+                      conn->bits.httpproxy &&
+                      strnequal("Proxy-Connection: keep-alive", p,
+                                strlen("Proxy-Connection: keep-alive"))) {
+                /*
+                 * When a HTTP/1.0 reply comes when using a proxy, the
+                 * 'Proxy-Connection: keep-alive' line tells us the
+                 * connection will be kept alive for our pleasure.
+                 * Default action for 1.0 is to close.
+                 */
+                conn->bits.close = FALSE; /* don't close when done */
+                infof(data, "HTTP/1.0 proxy connection set to keep alive!\n");
+              }
+              else if (strnequal("Connection: close", p,
+                                 strlen("Connection: close"))) {
+                /*
+                 * [RFC 2616, section 8.1.2.1]
+                 * "Connection: close" is HTTP/1.1 language and means that
+                 * the connection will close when this request has been
+                 * served.
+                 */
+                conn->bits.close = TRUE; /* close when done */
+              }
+              else if (strnequal("Transfer-Encoding: chunked", p,
+                                 strlen("Transfer-Encoding: chunked"))) {
+                /*
+                 * [RFC 2616, section 3.6.1] A 'chunked' transfer encoding
+                 * means that the server will send a series of "chunks". Each
+                 * chunk starts with line with info (including size of the
+                 * coming block) (terminated with CRLF), then a block of data
+                 * with the previously mentioned size. There can be any amount
+                 * of chunks, and a chunk-data set to zero signals the
+                 * end-of-chunks. */
+                conn->bits.chunk = TRUE; /* chunks coming our way */
+
+                /* init our chunky engine */
+                Curl_httpchunk_init(conn);
+              }
               else if (strnequal("Content-Range", p, 13)) {
                 if (sscanf (p+13, ": bytes %d-", &offset) ||
                     sscanf (p+13, ": bytes: %d-", &offset)) {
-                  /* This second format was added August 1st by Igor
+                  /* This second format was added August 1st 2000 by Igor
                      Khristophorov since Sun's webserver JavaWebServer/1.1.1
                      obviously sends the header this way! :-( */
                   if (data->resume_from == offset) {
                     /* we asked for a resume and we got it */
                     content_range = TRUE;
                   }
@@ -387,13 +469,13 @@
                       (data->timecondition || data->bits.get_filetime) ) {
                 time_t secs=time(NULL);
                 timeofdoc = curl_getdate(p+strlen("Last-Modified:"), &secs);
                 if(data->bits.get_filetime)
                   data->progress.filetime = timeofdoc;
               }
-              else if ((code >= 300 && code < 400) &&
+              else if ((httpcode >= 300 && httpcode < 400) &&
                        (data->bits.http_follow_location) &&
                        strnequal("Location: ", p, 10)) {
                 /* this is the URL that the server advices us to get instead */
                 char *ptr;
                 char *start=p;
                 char backup;
@@ -402,13 +484,13 @@
                 ptr = start; /* start scanning here */
                 /* scan through the string to find the end */
                 while(*ptr && !isspace((int)*ptr))
                   ptr++;
                 backup = *ptr; /* store the ending letter */
                 *ptr = '\0';   /* zero terminate */
-                data->newurl = strdup(start); /* clone string */
+                conn->newurl = strdup(start); /* clone string */
                 *ptr = backup; /* restore ending letter */
               }
 
               writetype = CLIENTWRITE_HEADER;
               if (data->bits.http_include_header)
                 writetype |= CLIENTWRITE_BODY;
@@ -443,18 +525,18 @@
              parsing, where the beginning of the buffer is headers and the end
              is non-headers. */
           if (str && !header && ((signed int)nread > 0)) {
             
             if(0 == bodywrites) {
               /* These checks are only made the first time we are about to
-                 write a chunk of the body */
+                 write a piece of the body */
               if(conn->protocol&PROT_HTTP) {
                 /* HTTP-only checks */
-                if (data->newurl) {
+                if (conn->newurl) {
                   /* abort after the headers if "follow Location" is set */
-                  infof (data, "Follow to new URL: %s\n", data->newurl);
+                  infof (data, "Follow to new URL: %s\n", conn->newurl);
                   return CURLE_OK;
                 }
                 else if (data->resume_from &&
                          !content_range &&
                          (data->httpreq==HTTPREQ_GET)) {
                   /* we wanted to resume a download, although the server
@@ -486,31 +568,70 @@
                         return CURLE_OK;
                       }
                       break;
                     } /* switch */
                   } /* two valid time strings */
                 } /* we have a time condition */
+
+                if(!conn->bits.close) {
+                  /* If this is not the last request before a close, we must
+                     set the maximum download size to the size of the expected
+                     document or else, we won't know when to stop reading! */
+                  if(-1 != conn->size)
+                    conn->maxdownload = conn->size;
+
+                  /* What to do if the size is *not* known? */
+                }
+
               } /* this is HTTP */
             } /* this is the first time we write a body part */
             bodywrites++;
 
-            if(data->maxdownload &&
-               (bytecount + nread > data->maxdownload)) {
-              nread = data->maxdownload - bytecount;
+            if(conn->bits.chunk) {
+              /*
+               * Bless me father for I have sinned. Here comes a chunked
+               * transfer flying and we need to decode this properly.  While
+               * the name says read, this function both reads and writes away
+               * the data. The returned 'nread' holds the number of actual
+               * data it wrote to the client.  */
+              CHUNKcode res =
+                Curl_httpchunk_read(conn, str, nread, &nread);
+
+              if(CHUNKE_OK < res) {
+                failf(data, "Receeived problem in the chunky parser");
+                return CURLE_READ_ERROR;
+              }
+              else if(CHUNKE_STOP == res) {
+                /* we're done reading chunks! */
+                keepon &= ~KEEP_READ; /* read no more */
+
+                /* There are now possibly N number of bytes at the end of the
+                   str buffer that weren't written to the client, but we don't
+                   care about them right now. */
+              }
+              /* If it returned OK, we just keep going */
+            }
+
+            if(conn->maxdownload &&
+               (bytecount + nread >= conn->maxdownload)) {
+              nread = conn->maxdownload - bytecount;
               if((signed int)nread < 0 ) /* this should be unusual */
                 nread = 0;
               keepon &= ~KEEP_READ; /* we're done reading */
             }
 
             bytecount += nread;
 
             Curl_pgrsSetDownloadCounter(data, (double)bytecount);
             
-            urg = Curl_client_write(data, CLIENTWRITE_BODY, str, nread);
-            if(urg)
-              return urg;
+            if(! conn->bits.chunk) {
+              /* If this is chunky transfer, it was already written */
+              urg = Curl_client_write(data, CLIENTWRITE_BODY, str, nread);
+              if(urg)
+                return urg;
+            }
 
           } /* if (! header and data to read ) */
         } /* if( read from socket ) */
 
         if((keepon & KEEP_WRITE) && FD_ISSET(conn->writesockfd, &writefd)) {
           /* write */
@@ -590,55 +711,64 @@
   if(!(data->bits.no_body) && contentlength &&
      (bytecount != contentlength)) {
     failf(data, "transfer closed with %d bytes remaining to read",
           contentlength-bytecount);
     return CURLE_PARTIAL_FILE;
   }
+  else if(conn->bits.chunk && conn->proto.http->chunk.datasize) {
+    failf(data, "transfer closed with at least %d bytes remaining",
+          conn->proto.http->chunk.datasize);
+    return CURLE_PARTIAL_FILE;
+  }
   if(Curl_pgrsUpdate(data))
     return CURLE_ABORTED_BY_CALLBACK;
 
   if(conn->bytecountp)
     *conn->bytecountp = bytecount; /* read count */
   if(conn->writebytecountp)
     *conn->writebytecountp = writebytecount; /* write count */
 
   return CURLE_OK;
 }
 
-typedef int (*func_T)(void);
-
-CURLcode curl_transfer(CURL *curl)
+CURLcode Curl_perform(CURL *curl)
 {
   CURLcode res;
-  struct UrlData *data = curl;
-  struct connectdata *c_connect=NULL;
+  struct UrlData *data = (struct UrlData *)curl;
+  struct connectdata *conn=NULL;
+  bool port=TRUE; /* allow data->use_port to set port to use */
 
   Curl_pgrsStartNow(data);
 
   do {
     Curl_pgrsTime(data, TIMER_STARTSINGLE);
-    res = curl_connect(curl, (CURLconnect **)&c_connect);
+    res = Curl_connect(data, &conn, port);
     if(res == CURLE_OK) {
-      res = curl_do(c_connect);
+      res = Curl_do(conn);
       if(res == CURLE_OK) {
-        res = _Transfer(c_connect); /* now fetch that URL please */
+        res = Transfer(conn); /* now fetch that URL please */
         if(res == CURLE_OK)
-          res = curl_done(c_connect);
+          res = Curl_done(conn);
       }
 
-      if((res == CURLE_OK) && data->newurl) {
+      if((res == CURLE_OK) && conn->newurl) {
         /* Location: redirect
  
            This is assumed to happen for HTTP(S) only!
         */
         char prot[16]; /* URL protocol string storage */
         char letter;   /* used for a silly sscanf */
 
+        port=TRUE; /* by default we use the user set port number even after
+                      a Location: */
+
 	if (data->maxredirs && (data->followlocation >= data->maxredirs)) {
 	  failf(data,"Maximum (%d) redirects followed", data->maxredirs);
+#ifdef USE_OLD_DISCONNECT
           curl_disconnect(c_connect);
+#endif
           res=CURLE_TOO_MANY_REDIRECTS;
 	  break;
 	}
 
         /* mark the next request as a followed location: */
         data->bits.this_is_a_follow = TRUE;
@@ -657,13 +787,13 @@
 
           data->referer = strdup(data->url);
           data->free_referer = TRUE;          /* yes, free this later */
           data->bits.http_set_referer = TRUE; /* might have been false */
         }
 
-        if(2 != sscanf(data->newurl, "%15[^:]://%c", prot, &letter)) {
+        if(2 != sscanf(conn->newurl, "%15[^:]://%c", prot, &letter)) {
           /***
            *DANG* this is an RFC 2068 violation. The URL is supposed
            to be absolute and this doesn't seem to be that!
            ***
            Instead, we have to TRY to append this new path to the old URL
            to the right of the host part. Oh crap, this is doomed to cause
@@ -675,19 +805,20 @@
 
           /* protsep points to the start of the host name */
           protsep=strstr(data->url, "//");
           if(!protsep)
             protsep=data->url;
           else {
-            /* TBD: set the port with curl_setopt() */
-            data->port=0; /* we got a full URL and then we should reset the
-                             port number here to re-initiate it later */
+            port=FALSE; /* we got a full URL and thus we should not obey the
+                           port number that might have been set by the user
+                           in data->use_port */
+
             protsep+=2; /* pass the slashes */
           }
 
-          if('/' != data->newurl[0]) {
+          if('/' != conn->newurl[0]) {
             /* First we need to find out if there's a ?-letter in the URL,
                and cut it and the right-side of that off */
             pathsep = strrchr(protsep, '?');
             if(pathsep)
               *pathsep=0;
 
@@ -704,33 +835,32 @@
             if(pathsep)
               *pathsep=0;
           }
 
           newest=(char *)malloc( strlen(data->url) +
                                  1 + /* possible slash */
-                                 strlen(data->newurl) + 1/* zero byte */);
+                                 strlen(conn->newurl) + 1/* zero byte */);
 
           if(!newest)
             return CURLE_OUT_OF_MEMORY;
-          sprintf(newest, "%s%s%s", data->url, ('/' == data->newurl[0])?"":"/",
-                  data->newurl);
-          free(data->newurl);
-          data->newurl = newest;
+          sprintf(newest, "%s%s%s", data->url, ('/' == conn->newurl[0])?"":"/",
+                  conn->newurl);
+          free(conn->newurl);
+          conn->newurl = newest;
         }
         else {
-          /* This was an absolute URL, clear the port number! */
-          /* TBD: set the port with curl_setopt() */
-          data->port = 0;
+          /* This is an absolute URL, don't use the custom port number */
+          port = FALSE;
         }
 
         if(data->bits.urlstringalloc)
           free(data->url);
       
         /* TBD: set the URL with curl_setopt() */
-        data->url = data->newurl;
-        data->newurl = NULL; /* don't show! */
+        data->url = conn->newurl;
+        conn->newurl = NULL; /* don't show! */
         data->bits.urlstringalloc = TRUE; /* the URL is allocated */
 
         infof(data, "Follows Location: to new URL: '%s'\n", data->url);
 
         /*
          * We get here when the HTTP code is 300-399. We need to perform
@@ -769,24 +899,30 @@
            * proxy.  The recipient is expected to repeat this single request
            * via the proxy. 305 responses MUST only be generated by origin
            * servers."
            */
           break;
         }
+#ifdef USE_OLD_DISCONNECT
         curl_disconnect(c_connect);
+#endif
         continue;
       }
 
+#ifdef USE_OLD_DISCONNECT
       curl_disconnect(c_connect);
+#endif
     }
     break; /* it only reaches here when this shouldn't loop */
 
   } while(1); /* loop if Location: */
 
-  if(data->newurl)
-    free(data->newurl);
+  if(conn->newurl) {
+    free(conn->newurl);
+    conn->newurl = NULL;
+  }
 
   return res;
 }
 
 
 CURLcode 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/transfer.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/transfer.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/transfer.h	2001-01-17 21:19:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/transfer.h	2001-03-10 00:50:38.000000000 +0800
@@ -17,16 +17,17 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: transfer.h,v 1.1 2001/01/17 13:19:01 bagder Exp $
+ * $Id: transfer.h,v 1.2 2001/03/09 15:17:09 bagder Exp $
  *****************************************************************************/
-CURLcode curl_transfer(CURL *curl);
+CURLcode Curl_perform(CURL *curl);
 
+/* This sets up a forthcoming transfer */
 CURLcode 
 Curl_Transfer (struct connectdata *data,
                int sockfd,		/* socket to read from or -1 */
                int size,		/* -1 if unknown at this point */
                bool getheader,     	/* TRUE if header parsing is wanted */
                long *bytecountp,	/* return number of bytes read */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/url.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/url.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/url.c	2001-02-13 21:34:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/url.c	2001-03-16 18:53:06.000000000 +0800
@@ -15,13 +15,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: url.c,v 1.83 2001/02/13 13:34:16 bagder Exp $
+ * $Id: url.c,v 1.107 2001/03/15 14:38:30 bagder Exp $
  *****************************************************************************/
 
 /* -- WIN32 approved -- */
 
 #include "setup.h"
 
@@ -110,142 +110,79 @@
 #endif
 /* The last #include file should be: */
 #ifdef MALLOCDEBUG
 #include "memdebug.h"
 #endif
 
-/* -- -- */
+/* Local static prototypes */
+static int ConnectionKillOne(struct UrlData *data);
+static bool ConnectionExists(struct UrlData *data,
+                             struct connectdata *needle,
+                             struct connectdata **usethis);
+static unsigned int ConnectionStore(struct UrlData *data,
+                                    struct connectdata *conn);
 
 
-CURLcode _urlget(struct UrlData *data);
-
-/* does nothing, returns OK */
-CURLcode curl_init(void)
-{
-  return CURLE_OK;
-}
-
-/* does nothing */
-void curl_free(void)
+#if !defined(WIN32)||defined(__CYGWIN32__)
+#ifndef RETSIGTYPE
+#define RETSIGTYPE void
+#endif
+static
+RETSIGTYPE alarmfunc(int signal)
 {
+  /* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
+  (void)signal;
+  return;
 }
+#endif
 
-void static urlfree(struct UrlData *data, bool totally)
+CURLcode Curl_close(CURL *curl)
 {
-#ifdef USE_SSLEAY
-  if (data->ssl.use) {
-    if(data->ssl.handle) {
-      (void)SSL_shutdown(data->ssl.handle);
-      SSL_set_connect_state(data->ssl.handle);
-
-      SSL_free (data->ssl.handle);
-      data->ssl.handle = NULL;
-    }
-    if(data->ssl.ctx) {
-      SSL_CTX_free (data->ssl.ctx);
-      data->ssl.ctx = NULL;
-    }
-    data->ssl.use = FALSE; /* get back to ordinary socket usage */
-  }
-#endif /* USE_SSLEAY */
-
-  /* close possibly still open sockets */
-  if(-1 != data->secondarysocket) {
-    sclose(data->secondarysocket);
-    data->secondarysocket = -1;	
-  }
-  if(-1 != data->firstsocket) {
-    sclose(data->firstsocket);
-    data->firstsocket=-1;
-  }
+  struct UrlData *data=(struct UrlData *)curl;
+  
+  /* Loop through all open connections and kill them one by one */
+  while(-1 != ConnectionKillOne(data));
 
   if(data->bits.proxystringalloc) {
     data->bits.proxystringalloc=FALSE;;
     free(data->proxy);
     data->proxy=NULL;
 
     /* Since we allocated the string the previous round, it means that we
        "discovered" the proxy in the environment variables and thus we must
        switch off that knowledge again... */
     data->bits.httpproxy=FALSE;
   }
-  
+
+
   if(data->bits.rangestringalloc) {
     free(data->range);
     data->range=NULL;
     data->bits.rangestringalloc=0; /* free now */
   }
 
-  if(data->ptr_proxyuserpwd) {
-    free(data->ptr_proxyuserpwd);
-    data->ptr_proxyuserpwd=NULL;
-  }
-  if(data->ptr_uagent) {
-    free(data->ptr_uagent);
-    data->ptr_uagent=NULL;
-  }
-  if(data->ptr_userpwd) {
-    free(data->ptr_userpwd);
-    data->ptr_userpwd=NULL;
-  }
-  if(data->ptr_rangeline) {
-    free(data->ptr_rangeline);
-    data->ptr_rangeline=NULL;
-  }
-  if(data->ptr_ref) {
-    free(data->ptr_ref);
-    data->ptr_ref=NULL;
-  }
-  if(data->ptr_cookie) {
-    free(data->ptr_cookie);
-    data->ptr_cookie=NULL;
-  }
-  if(data->ptr_host) {
-    free(data->ptr_host);
-    data->ptr_host=NULL;
-  }
-
-  if(totally) {
-    /* we let the switch decide whether we're doing a part or total
-       cleanup */
-
-    /* check for allocated [URL] memory to free: */
-    if(data->freethis)
-      free(data->freethis);
-
-    if(data->headerbuff)
-      free(data->headerbuff);
-
-    if(data->free_referer)
-      free(data->referer);
+  /* check for allocated [URL] memory to free: */
+  if(data->freethis)
+    free(data->freethis);
 
-    if(data->bits.urlstringalloc)
-      /* the URL is allocated, free it! */
-      free(data->url);
+  if(data->headerbuff)
+    free(data->headerbuff);
 
-    Curl_cookie_cleanup(data->cookies);
+  if(data->free_referer)
+    free(data->referer);
 
-    free(data);
+  if(data->bits.urlstringalloc)
+    /* the URL is allocated, free it! */
+    free(data->url);
 
-    /* global cleanup */
-    curl_free();
-  }
-}
-
-CURLcode curl_close(CURL *curl)
-{
-  struct UrlData *data=(struct UrlData *)curl;
-  
-  void *protocol = data->proto.generic;
+  Curl_cookie_cleanup(data->cookies);
 
-  /* total session cleanup (frees 'data' as well!)*/
-  urlfree(data, TRUE);
-
-  if(protocol)
-    free(protocol);
+  /* free the connection cache */
+  free(data->connects);
 
+  free(data);
   return CURLE_OK;
 }
 
 static
 int my_getpass(void *clientp, char *prompt, char* buffer, int buflen )
 {
@@ -255,41 +192,39 @@
     return 1;
   else
     return 0; /* success */
 }
 
 
-CURLcode curl_open(CURL **curl, char *url)
+CURLcode Curl_open(CURL **curl, char *url)
 {
   /* We don't yet support specifying the URL at this point */
   struct UrlData *data;
+#ifdef HAVE_SIGACTION
+  struct sigaction sigact;
+#endif
 
   /* Very simple start-up: alloc the struct, init it with zeroes and return */
   data = (struct UrlData *)malloc(sizeof(struct UrlData));
   if(data) {
     memset(data, 0, sizeof(struct UrlData));
-    data->handle = STRUCT_OPEN;
-    data->interf = CURLI_NORMAL; /* normal interface by default */
 
     /* We do some initial setup here, all those fields that can't be just 0 */
 
     data-> headerbuff=(char*)malloc(HEADERSIZE);
     if(!data->headerbuff) {
       free(data); /* free the memory again */
       return CURLE_OUT_OF_MEMORY;
     }
 
-    data-> headersize=HEADERSIZE;
+    data->headersize=HEADERSIZE;
 
     data->out = stdout; /* default output to stdout */
     data->in  = stdin;  /* default input from stdin */
     data->err  = stderr;  /* default stderr to stderr */
 
-    data->firstsocket = -1; /* no file descriptor */
-    data->secondarysocket = -1; /* no file descriptor */
-
     /* use fwrite as default function to store output */
     data->fwrite = (size_t (*)(char *, size_t, size_t, FILE *))fwrite;
 
     /* use fread as default function to read input */
     data->fread = (size_t (*)(char *, size_t, size_t, FILE *))fread;
 
@@ -299,360 +234,1097 @@
     data->infilesize = -1; /* we don't know any size */
 
     data->current_speed = -1; /* init to negative == impossible */
 
     data->httpreq = HTTPREQ_GET; /* Default HTTP request */
 
+    /* create an array with connection data struct pointers */
+    data->numconnects = 5; /* hard-coded right now */
+    data->connects = (struct connectdata **)
+      malloc(sizeof(struct connectdata *) * data->numconnects);
+
+    if(!data->connects) {
+      free(data);
+      return CURLE_OUT_OF_MEMORY;
+    }
+
+    memset(data->connects, 0, sizeof(struct connectdata *)*data->numconnects);
+
     *curl = data;
+
+    /*************************************************************
+     * Set signal handler
+     *************************************************************/
+#ifdef HAVE_SIGACTION
+    sigaction(SIGALRM, NULL, &sigact);
+    sigact.sa_handler = alarmfunc;
+#ifdef SA_RESTART
+    /* HPUX doesn't have SA_RESTART but defaults to that behaviour! */
+    sigact.sa_flags &= ~SA_RESTART;
+#endif
+    sigaction(SIGALRM, &sigact, NULL);
+#else
+    /* no sigaction(), revert to the much lamer signal() */
+#ifdef HAVE_SIGNAL
+    signal(SIGALRM, alarmfunc);
+#endif
+
+#endif
+
     return CURLE_OK;
   }
 
   /* this is a very serious error */
   return CURLE_OUT_OF_MEMORY;
 }
 
-CURLcode curl_setopt(CURL *curl, CURLoption option, ...)
+CURLcode Curl_setopt(CURL *curl, CURLoption option, ...)
 {
   struct UrlData *data = curl;
   va_list param;
   char *cookiefile;
 
   va_start(param, option);
 
   switch(option) {
+  case CURLOPT_RANDOM_FILE:
+    /*
+     * This is the path name to a file that contains random data to seed
+     * the random SSL stuff with. The file is only used for reading.
+     */
+    data->ssl.random_file = va_arg(param, char *);
+    break;
+  case CURLOPT_EGDSOCKET:
+    /*
+     * The Entropy Gathering Daemon socket pathname
+     */
+    data->ssl.egdsocket = va_arg(param, char *);
+    break;
+  case CURLOPT_MAXCONNECTS:
+    /*
+     * Set the absolute number of maximum simultaneous alive connection that
+     * libcurl is allowed to have.
+     */
+    {
+      long newconnects= va_arg(param, long);
+      struct connectdata **newptr;
+
+      if(newconnects < data->numconnects) {
+        /* Since this number is *decreased* from the existing number, we must
+           close the possibly open connections that live on the indexes that
+           are being removed! */
+        int i;
+        for(i=newconnects; i< data->numconnects; i++)
+          Curl_disconnect(data->connects[i]);
+      }
+      if(newconnects) {
+        newptr= (struct connectdata **)
+          realloc(data->connects,
+                  sizeof(struct connectdata *) * newconnects);
+        if(!newptr)
+          /* we closed a few connections in vain, but so what? */
+          return CURLE_OUT_OF_MEMORY;
+        data->connects = newptr;
+        data->numconnects = newconnects;
+      }
+      else {
+        /* zero makes NO cache at all */
+        if(data->connects)
+          free(data->connects);
+        data->connects=NULL;
+        data->numconnects=0;
+      }
+    }
+    break;
+  case CURLOPT_FORBID_REUSE:
+    /*
+     * When this transfer is done, it must not be left to be reused by a
+     * subsequent transfer but shall be closed immediately.
+     */
+    data->bits.reuse_forbid = va_arg(param, long)?TRUE:FALSE;
+    break;
+  case CURLOPT_FRESH_CONNECT:
+    /*
+     * This transfer shall not use a previously cached connection but
+     * should be made with a fresh new connect!
+     */
+    data->bits.reuse_fresh = va_arg(param, long)?TRUE:FALSE;
+    break;
   case CURLOPT_VERBOSE:
+    /*
+     * Verbose means infof() calls that give a lot of information about
+     * the connection and transfer procedures as well as internal choices.
+     */
     data->bits.verbose = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_HEADER:
+    /*
+     * Set to include the header in the general data output stream.
+     */
     data->bits.http_include_header = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_NOPROGRESS:
+    /*
+     * Shut off the internal supported progress meter
+     */
     data->bits.hide_progress = va_arg(param, long)?TRUE:FALSE;
     if(data->bits.hide_progress)
       data->progress.flags |= PGRS_HIDE;
     break;
   case CURLOPT_NOBODY:
+    /*
+     * Do not include the body part in the output data stream.
+     */
     data->bits.no_body = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FAILONERROR:
+    /*
+     * Don't output the >=300 error code HTML-page, but instead only
+     * return error.
+     */
     data->bits.http_fail_on_error = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_UPLOAD:
+    /*
+     * We want to sent data to the remote host
+     */
     data->bits.upload = va_arg(param, long)?TRUE:FALSE;
     if(data->bits.upload)
       /* If this is HTTP, PUT is what's needed to "upload" */
       data->httpreq = HTTPREQ_PUT;
     break;
-  case CURLOPT_POST:
-    data->bits.http_post = va_arg(param, long)?TRUE:FALSE;
-    if(data->bits.http_post)
-      data->httpreq = HTTPREQ_POST;
-    break;
   case CURLOPT_FILETIME:
+    /*
+     * Try to get the file time of the remote document. The time will
+     * later (possibly) become available using curl_easy_getinfo().
+     */
     data->bits.get_filetime = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FTPLISTONLY:
+    /*
+     * An FTP option that changes the command to one that asks for a list
+     * only, no file info details.
+     */
     data->bits.ftp_list_only = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FTPAPPEND:
+    /*
+     * We want to upload and append to an existing (FTP) file.
+     */
     data->bits.ftp_append = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_NETRC:
+    /*
+     * Parse the $HOME/.netrc file
+     */
     data->bits.use_netrc = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FOLLOWLOCATION:
+    /*
+     * Follow Location: header hints on a HTTP-server.
+     */
     data->bits.http_follow_location = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_FTPASCII:
+    /*
+     * Transfer FTP using ASCII instead of BINARY.
+     */
     data->bits.ftp_ascii = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_PUT:
+    /*
+     * Use the HTTP PUT request to transfer data.
+     */
     data->bits.http_put = va_arg(param, long)?TRUE:FALSE;
     if(data->bits.http_put)
       data->httpreq = HTTPREQ_PUT;
     break;
   case CURLOPT_MUTE:
+    /*
+     * Stay absolutely quiet.
+     */
     data->bits.mute = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_TIMECONDITION:
+    /*
+     * Set HTTP time condition. This must be one of the defines in the
+     * curl/curl.h header file.
+     */
     data->timecondition = va_arg(param, long);
     break;
   case CURLOPT_TIMEVALUE:
+    /*
+     * This is the value to compare with the remote document with the
+     * method set with CURLOPT_TIMECONDITION
+     */
     data->timevalue = va_arg(param, long);
     break;
   case CURLOPT_SSLVERSION:
+    /*
+     * Set explicit SSL version to try to connect with, as some SSL
+     * implementations are lame.
+     */
     data->ssl.version = va_arg(param, long);
     break;
 
   case CURLOPT_COOKIEFILE:
+    /*
+     * Set cookie file to read and parse.
+     */
     cookiefile = (char *)va_arg(param, void *);
     if(cookiefile) {
       data->cookies = Curl_cookie_init(cookiefile);
     }
     break;
   case CURLOPT_WRITEHEADER:
+    /*
+     * Callback function for header data
+     */
     data->writeheader = (FILE *)va_arg(param, FILE *);
     break;
   case CURLOPT_COOKIE:
+    /*
+     * Cookie string to send to the remote server in the request.
+     */
     data->cookie = va_arg(param, char *);
     break;
   case CURLOPT_ERRORBUFFER:
+    /*
+     * Error buffer provided by the caller to get the human readable
+     * error string in.
+     */
     data->errorbuffer = va_arg(param, char *);
     break;
   case CURLOPT_FILE:
+    /*
+     * FILE pointer to write to or include in the data write callback
+     */
     data->out = va_arg(param, FILE *);
     break;
   case CURLOPT_FTPPORT:
+    /*
+     * Use FTP PORT, this also specifies which IP address to use
+     */
     data->ftpport = va_arg(param, char *);
     data->bits.ftp_use_port = data->ftpport?1:0;
     break;
   case CURLOPT_HTTPHEADER:
+    /*
+     * Set a list with HTTP headers to use (or replace internals with)
+     */
     data->headers = va_arg(param, struct curl_slist *);
     break;
   case CURLOPT_CUSTOMREQUEST:
+    /*
+     * Set a custom string to use as request
+     */
     data->customrequest = va_arg(param, char *);
     if(data->customrequest)
       data->httpreq = HTTPREQ_CUSTOM;
     break;
   case CURLOPT_HTTPPOST:
+    /*
+     * Set to make us do HTTP POST
+     */
     data->httppost = va_arg(param, struct HttpPost *);
     data->bits.http_formpost = data->httppost?1:0;
     if(data->bits.http_formpost)
       data->httpreq = HTTPREQ_POST_FORM;
     break;
   case CURLOPT_INFILE:
+    /*
+     * FILE pointer to read the file to be uploaded from. Or possibly
+     * used as argument to the read callback.
+     */
     data->in = va_arg(param, FILE *);
     break;
   case CURLOPT_INFILESIZE:
+    /*
+     * If known, this should inform curl about the file size of the
+     * to-be-uploaded file.
+     */
     data->infilesize = va_arg(param, long);
     break;
   case CURLOPT_LOW_SPEED_LIMIT:
+    /*
+     * The low speed limit that if transfers are below this for
+     * CURLOPT_LOW_SPEED_TIME, the transfer is aborted.
+     */
     data->low_speed_limit=va_arg(param, long);
     break;
   case CURLOPT_LOW_SPEED_TIME:
+    /*
+     * The low speed time that if transfers are below the set
+     * CURLOPT_LOW_SPEED_LIMIT during this time, the transfer is aborted.
+     */
     data->low_speed_time=va_arg(param, long);
     break;
   case CURLOPT_URL:
+    /*
+     * The URL to fetch.
+     */
     data->url = va_arg(param, char *);
     break;
   case CURLOPT_PORT:
-    data->port = va_arg(param, long);
+    /*
+     * The port number to use when getting the URL
+     */
+    data->use_port = va_arg(param, long);
+    break;
+  case CURLOPT_POST:
+    /* Does this option serve a purpose anymore? */
+    data->bits.http_post = va_arg(param, long)?TRUE:FALSE;
+    if(data->bits.http_post)
+      data->httpreq = HTTPREQ_POST;
     break;
   case CURLOPT_POSTFIELDS:
+    /*
+     * A string with POST data. Makes curl HTTP POST.
+     */
     data->postfields = va_arg(param, char *);
+    data->bits.http_post = data->postfields?TRUE:FALSE;
+    if(data->bits.http_post)
+      data->httpreq = HTTPREQ_POST;
     break;
   case CURLOPT_POSTFIELDSIZE:
+    /*
+     * The size of the POSTFIELD data, if curl should now do a strlen
+     * to find out. Enables binary posts.
+     */
     data->postfieldsize = va_arg(param, long);
     break;
   case CURLOPT_REFERER:
+    /*
+     * String to set in the HTTP Referer: field.
+     */
     data->referer = va_arg(param, char *);
     data->bits.http_set_referer = (data->referer && *data->referer)?1:0;
     break;
   case CURLOPT_AUTOREFERER:
+    /*
+     * Switch on automatic referer that gets set if curl follows locations.
+     */
     data->bits.http_auto_referer = va_arg(param, long)?1:0;
     break;
   case CURLOPT_PROXY:
+    /*
+     * Set proxy server:port to use as HTTP proxy
+     */
     data->proxy = va_arg(param, char *);
     data->bits.httpproxy = data->proxy?1:0;
     break;
   case CURLOPT_HTTPPROXYTUNNEL:
+    /*
+     * Tunnel operations through the proxy instead of normal proxy use
+     */
     data->bits.tunnel_thru_httpproxy = va_arg(param, long)?TRUE:FALSE;
     break;
   case CURLOPT_PROXYPORT:
+    /*
+     * Explicitly set HTTP proxy port number.
+     */
     data->proxyport = va_arg(param, long);
     break;
   case CURLOPT_TIMEOUT:
+    /*
+     * The maximum time you allow curl to use for a single transfer
+     * operation.
+     */
     data->timeout = va_arg(param, long);
     break;
+  case CURLOPT_CONNECTTIMEOUT:
+    /*
+     * The maximum time you allow curl to use to connect.
+     */
+    data->connecttimeout = va_arg(param, long);
+    break;
   case CURLOPT_MAXREDIRS:
+    /*
+     * The maximum amount of hops you allow curl to follow Location:
+     * headers. This should mostly be used to detect never-ending loops.
+     */
     data->maxredirs = va_arg(param, long);
     break;
   case CURLOPT_USERAGENT:
+    /*
+     * String to use in the HTTP User-Agent field
+     */
     data->useragent = va_arg(param, char *);
     break;
   case CURLOPT_USERPWD:
+    /*
+     * user:password to use in the operation
+     */
     data->userpwd = va_arg(param, char *);
-    data->bits.user_passwd = data->userpwd?1:0;
     break;
   case CURLOPT_POSTQUOTE:
+    /*
+     * List of RAW FTP commands to use after a transfer 
+     */
     data->postquote = va_arg(param, struct curl_slist *);
     break;
+  case CURLOPT_QUOTE:
+    /*
+     * List of RAW FTP commands to use before a transfer 
+     */
+    data->quote = va_arg(param, struct curl_slist *);
+    break;
   case CURLOPT_PROGRESSFUNCTION:
+    /*
+     * Progress callback function
+     */
     data->fprogress = va_arg(param, curl_progress_callback);
     data->progress.callback = TRUE; /* no longer internal */
     break;
   case CURLOPT_PROGRESSDATA:
+    /*
+     * Custom client data to pass to the progress callback
+     */
     data->progress_client = va_arg(param, void *);
     break;
   case CURLOPT_PASSWDFUNCTION:
+    /*
+     * Password prompt callback
+     */
     data->fpasswd = va_arg(param, curl_passwd_callback);
     break;
   case CURLOPT_PASSWDDATA:
+    /*
+     * Custom client data to pass to the password callback
+     */
     data->passwd_client = va_arg(param, void *);
     break;
   case CURLOPT_PROXYUSERPWD:
+    /*
+     * user:password needed to use the proxy
+     */
     data->proxyuserpwd = va_arg(param, char *);
-    data->bits.proxy_user_passwd = data->proxyuserpwd?1:0;
     break;
   case CURLOPT_RANGE:
+    /*
+     * What range of the file you want to transfer
+     */
     data->range = va_arg(param, char *);
     data->bits.set_range = data->range?1:0;
     break;
   case CURLOPT_RESUME_FROM:
+    /*
+     * Resume transfer at the give file position
+     */
     data->resume_from = va_arg(param, long);
     break;
   case CURLOPT_STDERR:
+    /*
+     * Set to a FILE * that should receive all error writes. This
+     * defaults to stderr for normal operations.
+     */
     data->err = va_arg(param, FILE *);
     break;
   case CURLOPT_WRITEFUNCTION:
+    /*
+     * Set data write callback
+     */
     data->fwrite = va_arg(param, curl_write_callback);
     break;
   case CURLOPT_READFUNCTION:
+    /*
+     * Read data callback
+     */
     data->fread = va_arg(param, curl_read_callback);
     break;
   case CURLOPT_SSLCERT:
+    /*
+     * String that holds file name of the SSL certificate to use
+     */
     data->cert = va_arg(param, char *);
     break;
   case CURLOPT_SSLCERTPASSWD:
+    /*
+     * String that holds the SSL certificate password.
+     */
     data->cert_passwd = va_arg(param, char *);
     break;
   case CURLOPT_CRLF:
+    /*
+     * Kludgy option to enable CRLF convertions. Subject for
+     * removal.
+     */
     data->crlf = va_arg(param, long);
     break;
-  case CURLOPT_QUOTE:
-    data->quote = va_arg(param, struct curl_slist *);
-    break;
   case CURLOPT_INTERFACE:
+    /*
+     * Set what interface to bind to when performing an operation and thus
+     * what from-IP your connection will use.
+     */
     data->device = va_arg(param, char *);
     break;
   case CURLOPT_KRB4LEVEL:
+    /*
+     * A string that defines the krb4 security level.
+     */
     data->krb4_level = va_arg(param, char *);
     data->bits.krb4=data->krb4_level?TRUE:FALSE;
     break;
   case CURLOPT_SSL_VERIFYPEER:
+    /*
+     * Enable peer SSL verifying.
+     */
     data->ssl.verifypeer = va_arg(param, long);
     break;
   case CURLOPT_CAINFO:
+    /*
+     * Set CA info for SSL connection. Specify file name of the CA certificate
+     */
     data->ssl.CAfile = va_arg(param, char *);
     data->ssl.CApath = NULL; /*This does not work on windows.*/
     break;
+  case CURLOPT_TELNETOPTIONS:
+    /*
+     * Set a linked list of telnet options
+     */
+    data->telnet_options = va_arg(param, struct curl_slist *);
+    break;
   default:
     /* unknown tag and its companion, just ignore: */
     return CURLE_READ_ERROR; /* correct this */
   }
   return CURLE_OK;
 }
 
-#if !defined(WIN32)||defined(__CYGWIN32__)
-#ifndef RETSIGTYPE
-#define RETSIGTYPE void
-#endif
-static
-RETSIGTYPE alarmfunc(int signal)
+CURLcode Curl_disconnect(struct connectdata *conn)
 {
-  /* this is for "-ansi -Wall -pedantic" to stop complaining!   (rabe) */
-  (void)signal;
-  return;
-}
-#endif
+  if(!conn)
+    return CURLE_OK; /* this is closed and fine already */
 
-CURLcode curl_disconnect(CURLconnect *c_connect)
-{
-  struct connectdata *conn = c_connect;
+  if(-1 != conn->connectindex) {
+    /* unlink ourselves! */
+    infof(conn->data, "Closing live connection (#%d)\n", conn->connectindex);
+    conn->data->connects[conn->connectindex] = NULL;
+  }
 
-  struct UrlData *data = conn->data;
+  if(conn->curl_disconnect)
+    /* This is set if protocol-specific cleanups should be made */
+    conn->curl_disconnect(conn);
 
-  if(data->proto.generic)
-    free(data->proto.generic);
-  data->proto.generic=NULL; /* it is gone */
+  if(conn->proto.generic)
+    free(conn->proto.generic);
 
 #ifdef ENABLE_IPV6
-  if(conn->res) /* host name info */
-    freeaddrinfo(conn->res);
+  if(conn->hp) /* host name info */
+    freeaddrinfo(conn->hp);
 #else
   if(conn->hostent_buf) /* host name info */
     free(conn->hostent_buf);
 #endif
 
   if(conn->path) /* the URL path part */
     free(conn->path);
 
-  free(conn); /* free the connection oriented data */
+#ifdef USE_SSLEAY
+  if (conn->ssl.use) {
+    if(conn->ssl.handle) {
+      (void)SSL_shutdown(conn->ssl.handle);
+      SSL_set_connect_state(conn->ssl.handle);
+
+      SSL_free (conn->ssl.handle);
+      conn->ssl.handle = NULL;
+    }
+    if(conn->ssl.ctx) {
+      SSL_CTX_free (conn->ssl.ctx);
+      conn->ssl.ctx = NULL;
+    }
+    conn->ssl.use = FALSE; /* get back to ordinary socket usage */
+  }
+#endif /* USE_SSLEAY */
+
+  /* close possibly still open sockets */
+  if(-1 != conn->secondarysocket)
+    sclose(conn->secondarysocket);
+  if(-1 != conn->firstsocket)
+    sclose(conn->firstsocket);
+
+  if(conn->allocptr.proxyuserpwd)
+    free(conn->allocptr.proxyuserpwd);
+  if(conn->allocptr.uagent)
+    free(conn->allocptr.uagent);
+  if(conn->allocptr.userpwd)
+    free(conn->allocptr.userpwd);
+  if(conn->allocptr.rangeline)
+    free(conn->allocptr.rangeline);
+  if(conn->allocptr.ref)
+    free(conn->allocptr.ref);
+  if(conn->allocptr.cookie)
+    free(conn->allocptr.cookie);
+  if(conn->allocptr.host)
+    free(conn->allocptr.host);
+
+  if(conn->proxyhost)
+    free(conn->proxyhost);
 
-  /* clean up the sockets and SSL stuff from the previous "round" */
-  urlfree(data, FALSE);
+  free(conn); /* free all the connection oriented data */
 
   return CURLE_OK;
 }
 
-static CURLcode _connect(CURL *curl, CURLconnect **in_connect)
+/*
+ * This function should return TRUE if the socket is to be assumed to
+ * be dead. Most commonly this happens when the server has closed the
+ * connection due to inactivity.
+ */
+static bool SocketIsDead(int sock) 
+{ 
+  int sval; 
+  bool ret_val = TRUE; 
+  fd_set check_set; 
+  struct timeval to; 
+
+  FD_ZERO(&check_set); 
+  FD_SET(sock,&check_set); 
+
+  to.tv_sec = 0; 
+  to.tv_usec = 1; 
+
+  sval = select(sock + 1, &check_set, 0, 0, &to);
+  if(sval == 0) 
+    /* timeout */
+    ret_val = FALSE; 
+  
+  return ret_val;
+}
+
+/*
+ * Given one filled in connection struct, this function should detect if there
+ * already is one that have all the significant details exactly the same and
+ * thus should be used instead.
+ */
+static bool
+ConnectionExists(struct UrlData *data,
+                 struct connectdata *needle,
+                 struct connectdata **usethis)
+{
+  size_t i;
+  struct connectdata *check;
+
+  for(i=0; i< data->numconnects; i++) {
+    /*
+     * Note that if we use a HTTP proxy, we check connections to that
+     * proxy and not to the actual remote server.
+     */
+    check = data->connects[i];
+    if(!check)
+      /* NULL pointer means not filled-in entry */
+      continue;
+    if(!needle->bits.httpproxy) {
+      /* The requested connection does not use a HTTP proxy */
+
+      if(strequal(needle->protostr, check->protostr) &&
+         strequal(needle->name, check->name) &&
+         (needle->port == check->port) ) {
+        bool dead;
+        if(strequal(needle->protostr, "FTP")) {
+          /* This is FTP, verify that we're using the same name and
+             password as well */
+          if(!strequal(needle->data->user, check->proto.ftp->user) ||
+             !strequal(needle->data->passwd, check->proto.ftp->passwd)) {
+            /* one of them was different */
+            continue;
+          }
+        }
+        dead = SocketIsDead(check->firstsocket);
+        if(dead) {
+          infof(data, "Connection %d seems to be dead!\n", i);
+          Curl_disconnect(check); /* disconnect resources */
+          data->connects[i]=NULL; /* nothing here */
+          continue; /* try another one now */
+        }
+      }
+      *usethis = check;
+      return TRUE; /* yes, we found one to use! */
+    }
+    else { /* The requested needle connection is using a proxy,
+              is the checked one using the same? */
+      if(check->bits.httpproxy &&
+         strequal(needle->proxyhost, check->proxyhost) &&
+         needle->port == check->port) {
+        /* This is the same proxy connection, use it! */
+        *usethis = check;
+        return TRUE;
+      }
+    }
+  }
+  return FALSE; /* no matching connecting exists */
+}
+
+/*
+ * This function frees/closes a connection in the connection cache. This
+ * should take the previously set policy into account when deciding which
+ * of the connections to kill.
+ */
+static int
+ConnectionKillOne(struct UrlData *data)
+{
+  size_t i;
+  struct connectdata *conn;
+  int highscore=-1;
+  int connindex=-1;
+  int score;
+  CURLcode result;
+  struct timeval now;
+
+  now = Curl_tvnow();
+
+  for(i=0; i< data->numconnects; i++) {
+    conn = data->connects[i];
+    
+    if(!conn)
+      continue;
+
+    /*
+     * By using the set policy, we score each connection.
+     */
+    switch(data->closepolicy) {
+    case CURLCLOSEPOLICY_LEAST_RECENTLY_USED:
+    default:
+      /*
+       * Set higher score for the age passed since the connection
+       * was used.
+       */
+      score = Curl_tvlong(now) - Curl_tvlong(conn->now);
+      break;
+    case CURLCLOSEPOLICY_OLDEST:
+      /*
+       * Set higher score for the age passed since the connection
+       * was created.
+       */
+      score = Curl_tvlong(now) - Curl_tvlong(conn->created);
+      break;
+    }
+
+    if(score > highscore) {
+      highscore = score;
+      connindex = i;
+    }
+  }
+  if(connindex >= 0) {
+
+    /* the winner gets the honour of being disconnected */
+    result = Curl_disconnect(data->connects[connindex]);
+
+    /* clean the array entry */
+    data->connects[connindex] = NULL;
+  }
+
+  return connindex; /* return the available index or -1 */
+}
+
+/*
+ * The given input connection struct pointer is to be stored. If the "cache"
+ * is already full, we must clean out the most suitable using the previously
+ * set policy.
+ *
+ * The given connection should be unique. That must've been checked prior to
+ * this call.
+ */
+static unsigned int
+ConnectionStore(struct UrlData *data,
+                struct connectdata *conn)
+{
+  size_t i;
+  for(i=0; i< data->numconnects; i++) {
+    if(!data->connects[i])
+      break;
+  }
+  if(i == data->numconnects) {
+    /* there was no room available, kill one */
+    i = ConnectionKillOne(data);
+    infof(data, "Connection (#%d) was killed to make room\n", i);
+  }
+
+  data->connects[i] = conn; /* fill in this */
+  conn->connectindex = i; /* make the child know where the pointer to this
+                             particular data is stored */
+
+  return i;
+}
+
+static CURLcode ConnectPlease(struct UrlData *data,
+                              struct connectdata *conn)
+{
+
+#ifndef ENABLE_IPV6
+  conn->firstsocket = socket(AF_INET, SOCK_STREAM, 0);
+
+  memset((char *) &conn->serv_addr, '\0', sizeof(conn->serv_addr));
+  memcpy((char *)&(conn->serv_addr.sin_addr),
+         conn->hp->h_addr, conn->hp->h_length);
+  conn->serv_addr.sin_family = conn->hp->h_addrtype;
+  conn->serv_addr.sin_port = htons(conn->port);
+#else
+  /* IPv6-style */
+  struct addrinfo *ai;
+#endif
+
+#if !defined(WIN32)||defined(__CYGWIN32__)
+  /* We don't generally like checking for OS-versions, we should make this
+     HAVE_XXXX based, although at the moment I don't have a decent test for
+     this! */
+
+#ifdef HAVE_INET_NTOA
+
+#ifndef INADDR_NONE
+#define INADDR_NONE (unsigned long) ~0
+#endif
+
+#ifndef ENABLE_IPV6
+  /*************************************************************
+   * Select device to bind socket to
+   *************************************************************/
+  if (data->device && (strlen(data->device)<255)) {
+    struct sockaddr_in sa;
+    struct hostent *h=NULL;
+    char *hostdataptr=NULL;
+    size_t size;
+    char myhost[256] = "";
+    unsigned long in;
+
+    if(Curl_if2ip(data->device, myhost, sizeof(myhost))) {
+      h = Curl_gethost(data, myhost, &hostdataptr);
+    }
+    else {
+      if(strlen(data->device)>1) {
+        h = Curl_gethost(data, data->device, &hostdataptr);
+      }
+      if(h) {
+        /* we know data->device is shorter than the myhost array */
+        strcpy(myhost, data->device);
+      }
+    }
+
+    if(! *myhost) {
+      /* need to fix this
+         h=Curl_gethost(data,
+         getmyhost(*myhost,sizeof(myhost)),
+         hostent_buf,
+         sizeof(hostent_buf));
+      */
+      printf("in here\n");
+    }
+
+    infof(data, "We connect from %s\n", myhost);
+
+    if ( (in=inet_addr(myhost)) != INADDR_NONE ) {
+
+      if ( h ) {
+        memset((char *)&sa, 0, sizeof(sa));
+        memcpy((char *)&sa.sin_addr,
+               h->h_addr,
+               h->h_length);
+        sa.sin_family = AF_INET;
+        sa.sin_addr.s_addr = in;
+        sa.sin_port = 0; /* get any port */
+	
+        if( bind(conn->firstsocket, (struct sockaddr *)&sa, sizeof(sa)) >= 0) {
+          /* we succeeded to bind */
+          struct sockaddr_in add;
+	
+          size = sizeof(add);
+          if(getsockname(conn->firstsocket, (struct sockaddr *) &add,
+                         (socklen_t *)&size)<0) {
+            failf(data, "getsockname() failed");
+            return CURLE_HTTP_PORT_FAILED;
+          }
+        }
+        else {
+          switch(errno) {
+          case EBADF:
+            failf(data, "Invalid descriptor: %d", errno);
+            break;
+          case EINVAL:
+            failf(data, "Invalid request: %d", errno);
+            break;
+          case EACCES:
+            failf(data, "Address is protected, user not superuser: %d", errno);
+            break;
+          case ENOTSOCK:
+            failf(data,
+                  "Argument is a descriptor for a file, not a socket: %d",
+                  errno);
+            break;
+          case EFAULT:
+            failf(data, "Inaccessable memory error: %d", errno);
+            break;
+          case ENAMETOOLONG:
+            failf(data, "Address too long: %d", errno);
+            break;
+          case ENOMEM:
+            failf(data, "Insufficient kernel memory was available: %d", errno);
+            break;
+          default:
+            failf(data,"errno %d\n");
+          } /* end of switch */
+	
+          return CURLE_HTTP_PORT_FAILED;
+        } /* end of else */
+	
+      } /* end of if  h */
+      else {
+	failf(data,"could't find my own IP address (%s)", myhost);
+	return CURLE_HTTP_PORT_FAILED;
+      }
+    } /* end of inet_addr */
+
+    else {
+      failf(data, "could't find my own IP address (%s)", myhost);
+      return CURLE_HTTP_PORT_FAILED;
+    }
+
+    if(hostdataptr)
+      free(hostdataptr); /* allocated by Curl_gethost() */
+
+  } /* end of device selection support */
+#endif  /* end of HAVE_INET_NTOA */
+#endif /* end of not WIN32 */
+#endif /*ENABLE_IPV6*/
+
+  /*************************************************************
+   * Connect to server/proxy
+   *************************************************************/
+#ifdef ENABLE_IPV6
+  conn->firstsocket = -1;
+  for (ai = conn->hp; ai; ai = ai->ai_next) {
+    conn->firstsocket = socket(ai->ai_family,
+                               ai->ai_socktype,
+                               ai->ai_protocol);
+    if (conn->firstsocket < 0)
+      continue;
+
+    if (connect(conn->firstsocket, ai->ai_addr, ai->ai_addrlen) < 0) {
+      sclose(conn->firstsocket);
+      conn->firstsocket = -1;
+      continue;
+    }
+
+    break;
+  }
+  conn->ai = ai;
+  if (conn->firstsocket < 0) {
+    failf(data, strerror(errno));
+    return CURLE_COULDNT_CONNECT;
+  }
+#else
+  if (connect(conn->firstsocket,
+              (struct sockaddr *) &(conn->serv_addr),
+              sizeof(conn->serv_addr)
+              ) < 0) {
+    switch(errno) {
+#ifdef ECONNREFUSED
+      /* this should be made nicer */
+    case ECONNREFUSED:
+      failf(data, "Connection refused");
+      break;
+    case EFAULT:
+      failf(data, "Invalid socket address: %d",errno);
+      break;
+    case EISCONN:
+      failf(data, "Socket already connected: %d",errno);
+      break;
+    case ETIMEDOUT:
+      failf(data, "Timeout while accepting connection, server busy: %d",errno);
+      break;
+    case ENETUNREACH:
+      failf(data, "Network is unreachable: %d",errno);
+      break;
+    case EADDRINUSE:
+      failf(data, "Local address already in use: %d",errno);
+      break;
+    case EINPROGRESS:
+      failf(data, "Socket is nonblocking and connection can not be completed immediately: %d",errno);
+      break;
+    case EALREADY:
+      failf(data, "Socket is nonblocking and a previous connection attempt not completed: %d",errno);
+      break;
+    case EAGAIN:
+      failf(data, "No more free local ports: %d",errno);
+      break;
+    case EACCES:
+    case EPERM:
+      failf(data, "Attempt to connect to broadcast address without socket broadcast flag or local firewall rule violated: %d",errno);
+      break;
+#endif
+    case EINTR:
+      failf(data, "Connection timed out");
+      break;
+    default:
+      failf(data, "Can't connect to server: %d", errno);
+      break;
+    }
+    return CURLE_COULDNT_CONNECT;
+  }
+#endif
+
+  return CURLE_OK;
+}
+
+static CURLcode Connect(struct UrlData *data,
+                        struct connectdata **in_connect,
+                        bool allow_port) /* allow data->use_port ? */
 {
   char *tmp;
   char *buf;
   CURLcode result;
   char resumerange[40]="";
-  struct UrlData *data = curl;
   struct connectdata *conn;
+  struct connectdata *conn_temp;
   char endbracket;
-#ifdef HAVE_SIGACTION
-  struct sigaction sigact;
-#endif
   int urllen;
-#ifdef ENABLE_IPV6
-  struct addrinfo *ai;
-#endif
 
   /*************************************************************
    * Check input data
    *************************************************************/
 
-  if(!data || (data->handle != STRUCT_OPEN))
-    return CURLE_BAD_FUNCTION_ARGUMENT; /* TBD: make error codes */
-
   if(!data->url)
     return CURLE_URL_MALFORMAT;
 
-  /*************************************************************
-   * Allocate and initiate a connection struct
-   *************************************************************/
+  /* First, split up the current URL in parts so that we can use the
+     parts for checking against the already present connections. In order
+     to not have to modify everything at once, we allocate a temporary
+     connection data struct and fill in for comparison purposes. */
+
   conn = (struct connectdata *)malloc(sizeof(struct connectdata));
   if(!conn) {
     *in_connect = NULL; /* clear the pointer */
     return CURLE_OUT_OF_MEMORY;
   }
+  /* We must set the return variable as soon as possible, so that our
+     parent can cleanup any possible allocs we may have done before
+     any failure */
   *in_connect = conn;
 
+  /* we have to init the struct */
   memset(conn, 0, sizeof(struct connectdata));
-  conn->handle = STRUCT_CONNECT;
-
-  conn->data = data; /* remember our daddy */
-  conn->state = CONN_INIT;
-
-  conn->upload_bufsize = UPLOAD_BUFSIZE; /* the smallest upload buffer size
-                                            we use */
 
-  buf = data->buffer; /* this is our buffer */
+  /* and we setup a few fields in case we end up actually using this struct */
+  conn->data = data;           /* remember our daddy */
+  conn->upload_bufsize = UPLOAD_BUFSIZE; /* default upload buffer size */
+  conn->firstsocket = -1;     /* no file descriptor */
+  conn->secondarysocket = -1; /* no file descriptor */
+  conn->connectindex = -1;    /* no index */
+  conn->bits.httpproxy = data->bits.httpproxy; /* proxy-or-not status */
+
+  /* Default protocol-independent behavior doesn't support persistant
+     connections, so we set this to force-close. Protocols that support
+     this need to set this to FALSE in their "curl_do" functions. */
+  conn->bits.close = TRUE;
+  
+  /* inherite initial knowledge from the data struct */
+  conn->bits.user_passwd = data->userpwd?1:0;
+  conn->bits.proxy_user_passwd = data->proxyuserpwd?1:0;
 
-  /*************************************************************
-   * Set signal handler
-   *************************************************************/
-#ifdef HAVE_SIGACTION
-  sigaction(SIGALRM, NULL, &sigact);
-  sigact.sa_handler = alarmfunc;
-#ifdef SA_RESTART
-  /* HPUX doesn't have SA_RESTART but defaults to that behaviour! */
-  sigact.sa_flags &= ~SA_RESTART;
-#endif
-  sigaction(SIGALRM, &sigact, NULL);
-#else
-  /* no sigaction(), revert to the much lamer signal() */
-#ifdef HAVE_SIGNAL
-  signal(SIGALRM, alarmfunc);
-#endif
+  /* Store creation time to help future close decision making */
+  conn->created = Curl_tvnow();
 
-#endif
 
   /***********************************************************
    * We need to allocate memory to store the path in. We get the size of the
    * full URL to be sure, and we need to make it at least 256 bytes since
    * other parts of the code will rely on this fact
    ***********************************************************/
@@ -671,36 +1343,36 @@
    * We need to parse the url even when using the proxy, because we will need
    * the hostname and port in case we are trying to SSL connect through the
    * proxy -- and we don't know if we will need to use SSL until we parse the
    * url ...
    ************************************************************/
   if((2 == sscanf(data->url, "%64[^:]://%[^\n]",
-                  conn->proto,
-                  conn->path)) && strequal(conn->proto, "file")) {
+                  conn->protostr,
+                  conn->path)) && strequal(conn->protostr, "file")) {
     /*
      * we deal with file://<host>/<path> differently since it supports no
      * hostname other than "localhost" and "127.0.0.1", which is unique among
      * the URL protocols specified in RFC 1738
      */
 
     if (strnequal(conn->path, "localhost/", 10) ||
         strnequal(conn->path, "127.0.0.1/", 10))
       /* If there's another host name than the one we support, <host>/ is
        * quietly ommitted */
       strcpy(conn->path, &conn->path[10]);
 
-    strcpy(conn->proto, "file"); /* store protocol string lowercase */
+    strcpy(conn->protostr, "file"); /* store protocol string lowercase */
   }
   else {
     /* Set default host and default path */
     strcpy(conn->gname, "curl.haxx.se");
     strcpy(conn->path, "/");
 
     if (2 > sscanf(data->url,
                    "%64[^\n:]://%256[^\n/]%[^\n]",
-                   conn->proto, conn->gname, conn->path)) {
+                   conn->protostr, conn->gname, conn->path)) {
       
       /*
        * The URL was badly formatted, let's try the browser-style _without_
        * protocol specified like 'http://'.
        */
       if((1 > sscanf(data->url, "%256[^\n/]%[^\n]",
@@ -715,39 +1387,41 @@
       /*
        * Since there was no protocol part specified, we guess what protocol it
        * is based on the first letters of the server name.
        */
 
       if(strnequal(conn->gname, "FTP", 3)) {
-        strcpy(conn->proto, "ftp");
+        strcpy(conn->protostr, "ftp");
       }
       else if(strnequal(conn->gname, "GOPHER", 6))
-        strcpy(conn->proto, "gopher");
+        strcpy(conn->protostr, "gopher");
 #ifdef USE_SSLEAY
       else if(strnequal(conn->gname, "HTTPS", 5))
-        strcpy(conn->proto, "https");
+        strcpy(conn->protostr, "https");
 #endif /* USE_SSLEAY */
       else if(strnequal(conn->gname, "TELNET", 6))
-        strcpy(conn->proto, "telnet");
+        strcpy(conn->protostr, "telnet");
       else if (strnequal(conn->gname, "DICT", sizeof("DICT")-1))
-        strcpy(conn->proto, "DICT");
+        strcpy(conn->protostr, "DICT");
       else if (strnequal(conn->gname, "LDAP", sizeof("LDAP")-1))
-        strcpy(conn->proto, "LDAP");
+        strcpy(conn->protostr, "LDAP");
       else {
-        strcpy(conn->proto, "http");
+        strcpy(conn->protostr, "http");
       }
 
       conn->protocol |= PROT_MISSING; /* not given in URL */
     }
   }
 
+  buf = data->buffer; /* this is our buffer */
+
   /*************************************************************
    * Take care of user and password authentication stuff
    *************************************************************/
 
-  if(data->bits.user_passwd && !data->bits.use_netrc) {
+  if(conn->bits.user_passwd && !data->bits.use_netrc) {
     data->user[0] =0;
     data->passwd[0]=0;
 
     if(*data->userpwd != ':') {
       /* the name is given, get user+password */
       sscanf(data->userpwd, "%127[^:]:%127[^\n]",
@@ -766,13 +1440,13 @@
     }
   }
 
   /*************************************************************
    * Take care of proxy authentication stuff
    *************************************************************/
-  if(data->bits.proxy_user_passwd) {
+  if(conn->bits.proxy_user_passwd) {
     data->proxyuser[0] =0;
     data->proxypasswd[0]=0;
 
     if(*data->proxyuserpwd != ':') {
       /* the name is given, get user+password */
       sscanf(data->proxyuserpwd, "%127[^:]:%127[^\n]",
@@ -796,13 +1470,13 @@
 
   /*************************************************************
    * Set a few convenience pointers 
    *************************************************************/
   conn->name = conn->gname;
   conn->ppath = conn->path;
-  data->hostname = conn->name;
+  conn->hostname = conn->name;
 
 
   /*************************************************************
    * Detect what (if any) proxy to use
    *************************************************************/
   if(!data->bits.httpproxy) {
@@ -847,13 +1521,13 @@
           }
         }
 	nope=strtok(NULL, ", ");
       }
       if(!nope) {
 	/* It was not listed as without proxy */
-	char *protop = conn->proto;
+	char *protop = conn->protostr;
 	char *envp = proxy_env;
 	char *prox;
 
 	/* Now, build <protocol>_proxy and check for such a one to use */
 	while(*protop)
 	  *envp++ = tolower(*protop++);
@@ -898,13 +1572,13 @@
   if((conn->protocol&PROT_MISSING) && data->bits.httpproxy ) {
     /* We're guessing prefixes here and since we're told to use a proxy, we
        need to add the protocol prefix to the URL string before we continue!
        */
     char *reurl;
 
-    reurl = aprintf("%s://%s", conn->proto, data->url);
+    reurl = aprintf("%s://%s", conn->protostr, data->url);
 
     if(!reurl)
       return CURLE_OUT_OF_MEMORY;
 
     data->url = reurl;
     if(data->freethis)
@@ -933,37 +1607,41 @@
     }
   }
 
   /*************************************************************
    * Set timeout if that is being used
    *************************************************************/
-  if(data->timeout) {
+  if(data->timeout || data->connecttimeout) {
     /* We set the timeout on the connection/resolving phase first, separately
      * from the download/upload part to allow a maximum time on everything */
-    myalarm(data->timeout); /* this sends a signal when the timeout fires
-			       off, and that will abort system calls */
+
+    /* myalarm() makes a signal get sent when the timeout fires off, and that
+       will abort system calls */
+    if(data->connecttimeout)
+      myalarm(data->connecttimeout);
+    else
+      myalarm(data->timeout);
   }
 
   /*************************************************************
    * Setup internals depending on protocol
    *************************************************************/
 
-  if (strequal(conn->proto, "HTTP")) {
-    if(!data->port)
-      data->port = PORT_HTTP;
-    data->remote_port = PORT_HTTP;
+  if (strequal(conn->protostr, "HTTP")) {
+    conn->port = (data->use_port && allow_port)?data->use_port:PORT_HTTP;
+    conn->remote_port = PORT_HTTP;
     conn->protocol |= PROT_HTTP;
     conn->curl_do = Curl_http;
     conn->curl_done = Curl_http_done;
     conn->curl_close = Curl_http_close;
   }
-  else if (strequal(conn->proto, "HTTPS")) {
+  else if (strequal(conn->protostr, "HTTPS")) {
 #ifdef USE_SSLEAY
-    if(!data->port)
-      data->port = PORT_HTTPS;
-    data->remote_port = PORT_HTTPS;
+
+    conn->port = (data->use_port && allow_port)?data->use_port:PORT_HTTPS;
+    conn->remote_port = PORT_HTTPS;
     conn->protocol |= PROT_HTTP;
     conn->protocol |= PROT_HTTPS;
 
     conn->curl_do = Curl_http;
     conn->curl_done = Curl_http_done;
     conn->curl_connect = Curl_http_connect;
@@ -971,32 +1649,30 @@
 
 #else /* USE_SSLEAY */
     failf(data, "libcurl was built with SSL disabled, https: not supported!");
     return CURLE_UNSUPPORTED_PROTOCOL;
 #endif /* !USE_SSLEAY */
   }
-  else if (strequal(conn->proto, "GOPHER")) {
-    if(!data->port)
-      data->port = PORT_GOPHER;
-    data->remote_port = PORT_GOPHER;
+  else if (strequal(conn->protostr, "GOPHER")) {
+    conn->port = (data->use_port && allow_port)?data->use_port:PORT_GOPHER;
+    conn->remote_port = PORT_GOPHER;
     /* Skip /<item-type>/ in path if present */
     if (isdigit((int)conn->path[1])) {
       conn->ppath = strchr(&conn->path[1], '/');
       if (conn->ppath == NULL)
 	conn->ppath = conn->path;
       }
     conn->protocol |= PROT_GOPHER;
     conn->curl_do = Curl_http;
     conn->curl_done = Curl_http_done;
     conn->curl_close = Curl_http_close;
   }
-  else if(strequal(conn->proto, "FTP")) {
+  else if(strequal(conn->protostr, "FTP")) {
     char *type;
-    if(!data->port)
-      data->port = PORT_FTP;
-    data->remote_port = PORT_FTP;
+    conn->port = (data->use_port && allow_port)?data->use_port:PORT_FTP;
+    conn->remote_port = PORT_FTP;
     conn->protocol |= PROT_FTP;
 
     if(data->bits.httpproxy &&
        !data->bits.tunnel_thru_httpproxy) {
       /* Unless we have asked to tunnel ftp operations through the proxy, we
          switch and use HTTP operations only */
@@ -1005,12 +1681,13 @@
       conn->curl_close = Curl_http_close;
     }
     else {
       conn->curl_do = Curl_ftp;
       conn->curl_done = Curl_ftp_done;
       conn->curl_connect = Curl_ftp_connect;
+      conn->curl_disconnect = Curl_ftp_disconnect;
     }
 
     conn->ppath++; /* don't include the initial slash */
 
     /* FTP URLs support an extension like ";type=<typecode>" that
      * we'll try to get now! */
@@ -1034,76 +1711,79 @@
 	/* switch off ASCII */
 	data->bits.ftp_ascii = 0;
 	break;
       }
     }
   }
-  else if(strequal(conn->proto, "TELNET")) {
+  else if(strequal(conn->protostr, "TELNET")) {
     /* telnet testing factory */
     conn->protocol |= PROT_TELNET;
-    if(!data->port)
-      data->port = PORT_TELNET;
-    data->remote_port = PORT_TELNET;
 
+    conn->port = (data->use_port && allow_port)?data->use_port: PORT_TELNET;
+    conn->remote_port = PORT_TELNET;
     conn->curl_do = Curl_telnet;
     conn->curl_done = Curl_telnet_done;
-
   }
-  else if (strequal(conn->proto, "DICT")) {
+  else if (strequal(conn->protostr, "DICT")) {
     conn->protocol |= PROT_DICT;
-    if(!data->port)
-      data->port = PORT_DICT;
-    data->remote_port = PORT_DICT;
+    conn->port = (data->use_port && allow_port)?data->use_port:PORT_DICT;
+    conn->remote_port = PORT_DICT;
     conn->curl_do = Curl_dict;
     conn->curl_done = Curl_dict_done;
   }
-  else if (strequal(conn->proto, "LDAP")) {
+  else if (strequal(conn->protostr, "LDAP")) {
     conn->protocol |= PROT_LDAP;
-    if(!data->port)
-      data->port = PORT_LDAP;
-    data->remote_port = PORT_LDAP;
+    conn->port = (data->use_port && allow_port)?data->use_port:PORT_LDAP;
+    conn->remote_port = PORT_LDAP;
     conn->curl_do = Curl_ldap;
     conn->curl_done = Curl_ldap_done;
   }
-  else if (strequal(conn->proto, "FILE")) {
+  else if (strequal(conn->protostr, "FILE")) {
     conn->protocol |= PROT_FILE;
 
-    conn->curl_do = file;
+    conn->curl_do = Curl_file;
     /* no done() function */
 
-    result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
-                      -1, NULL); /* no upload */
+    /* anyway, this is supposed to be the connect function so we better
+       at least check that the file is present here! */
+    result = Curl_file_connect(conn);
+
+    /* Setup a "faked" transfer that'll do nothing */
+    if(CURLE_OK == result) {
+      result = Curl_Transfer(conn, -1, -1, FALSE, NULL, /* no download */
+                             -1, NULL); /* no upload */
+    }
 
-    return CURLE_OK;
+    return result;
   }
   else {
     /* We fell through all checks and thus we don't support the specified
        protocol */
-    failf(data, "Unsupported protocol: %s", conn->proto);
+    failf(data, "Unsupported protocol: %s", conn->protostr);
     return CURLE_UNSUPPORTED_PROTOCOL;
   }
 
   /*************************************************************
    * .netrc scanning coming up
    *************************************************************/
   if(data->bits.use_netrc) {
-    if(Curl_parsenetrc(data->hostname, data->user, data->passwd)) {
+    if(Curl_parsenetrc(conn->hostname, data->user, data->passwd)) {
       infof(data, "Couldn't find host %s in the .netrc file, using defaults",
-            data->hostname);
+            conn->hostname);
     }
     else
-      data->bits.user_passwd = 1; /* enable user+password */
+      conn->bits.user_passwd = 1; /* enable user+password */
 
     /* weather we failed or not, we don't know which fields that were filled
        in anyway */
     if(!data->user[0])
       strcpy(data->user, CURL_DEFAULT_USER);
     if(!data->passwd[0])
       strcpy(data->passwd, CURL_DEFAULT_PASSWORD);
   }
-  else if(!(data->bits.user_passwd) &&
+  else if(!(conn->bits.user_passwd) &&
 	  (conn->protocol & (PROT_FTP|PROT_HTTP)) ) {
     /* This is a FTP or HTTP URL, and we haven't got the user+password in
      * the extra parameter, we will now try to extract the possible
      * user+password pair in a string like:
      * ftp://user:password@ftp.my.site:8021/README */
     char *ptr=NULL; /* assign to remove possible warnings */
@@ -1146,13 +1826,13 @@
           strcpy(data->passwd, newpasswd);
         }
         free(newpasswd);
       }
 
       conn->name = ++ptr;
-      data->bits.user_passwd=1; /* enable user+password */
+      conn->bits.user_passwd=TRUE; /* enable user+password */
     }
     else {
       strcpy(data->user, CURL_DEFAULT_USER);
       strcpy(data->passwd, CURL_DEFAULT_PASSWORD);
     }
   }
@@ -1185,41 +1865,20 @@
     /* traditional IPv4-style port-extracting */
     tmp = strchr(conn->name, ':');
   }
 
   if (tmp) {
     *tmp++ = '\0'; /* cut off the name there */
-    data->remote_port = atoi(tmp);
+    conn->remote_port = atoi(tmp);
   }
 
-  /*************************************************************
-   * Resolve the name of the server or proxy
-   *************************************************************/
-  if(!data->bits.httpproxy) {
-    /* If not connecting via a proxy, extract the port from the URL, if it is
-     * there, thus overriding any defaults that might have been set above. */
-    data->port =  data->remote_port; /* it is the same port */
+  if(data->bits.httpproxy) {
+    /* If this is supposed to use a proxy, we need to figure out the proxy
+       host name name, so that we can re-use an existing connection
+       that may exist registered to the same proxy host. */
 
-    /* Connect to target host right on */
-#ifdef ENABLE_IPV6
-    conn->res = Curl_getaddrinfo(data, conn->name, data->port);
-    if(!conn->res)
-#else
-    conn->hp = Curl_gethost(data, conn->name, &conn->hostent_buf);
-    if(!conn->hp)
-#endif
-    {
-      failf(data, "Couldn't resolve host '%s'", conn->name);
-      return CURLE_COULDNT_RESOLVE_HOST;
-    }
-  }
-  else {
-#ifdef ENABLE_IPV6
-    failf(data, "proxy yet to be supported");
-    return CURLE_OUT_OF_MEMORY;
-#else
     char *prox_portno;
     char *endofprot;
 
     /* We need to make a duplicate of the proxy so that we can modify the
        string safely. */
     char *proxydup=strdup(data->proxy);
@@ -1246,275 +1905,165 @@
     /* allow user to specify proxy.server.com:1080 if desired */
     prox_portno = strchr (proxyptr, ':');
     if (prox_portno) {
       *prox_portno = 0x0; /* cut off number from host name */
       prox_portno ++;
       /* now set the local port number */
-      data->port = atoi(prox_portno);
+      conn->port = atoi(prox_portno);
     }
     else if(data->proxyport) {
       /* None given in the proxy string, then get the default one if it is
          given */
-      data->port = data->proxyport;
+      conn->port = data->proxyport;
     }
 
-    /* connect to proxy */
-    conn->hp = Curl_gethost(data, proxyptr, &conn->hostent_buf);
-    if(!conn->hp) {
-      failf(data, "Couldn't resolve proxy '%s'", proxyptr);
-      return CURLE_COULDNT_RESOLVE_PROXY;
-    }
+    /* now, clone the cleaned proxy host name */
+    conn->proxyhost = strdup(proxyptr);
 
     free(proxydup); /* free the duplicate pointer and not the modified */
-#endif
   }
-  Curl_pgrsTime(data, TIMER_NAMELOOKUP);
-
-#ifndef ENABLE_IPV6
-  data->firstsocket = socket(AF_INET, SOCK_STREAM, 0);
-
-  memset((char *) &conn->serv_addr, '\0', sizeof(conn->serv_addr));
-  memcpy((char *)&(conn->serv_addr.sin_addr),
-         conn->hp->h_addr, conn->hp->h_length);
-  conn->serv_addr.sin_family = conn->hp->h_addrtype;
-  conn->serv_addr.sin_port = htons(data->port);
-#endif
-
-#if !defined(WIN32)||defined(__CYGWIN32__)
-  /* We don't generally like checking for OS-versions, we should make this
-     HAVE_XXXX based, although at the moment I don't have a decent test for
-     this! */
-
-#ifdef HAVE_INET_NTOA
-
-#ifndef INADDR_NONE
-#define INADDR_NONE (unsigned long) ~0
-#endif
 
-#ifndef ENABLE_IPV6
   /*************************************************************
-   * Select device to bind socket to
+   * Check the current list of connections to see if we can
+   * re-use an already existing one or if we have to create a
+   * new one.
    *************************************************************/
-  if (data->device && (strlen(data->device)<255)) {
-    struct sockaddr_in sa;
-    struct hostent *h=NULL;
-    char *hostdataptr=NULL;
-    size_t size;
-    char myhost[256] = "";
-    unsigned long in;
-
-    if(Curl_if2ip(data->device, myhost, sizeof(myhost))) {
-      h = Curl_gethost(data, myhost, &hostdataptr);
-    }
-    else {
-      if(strlen(data->device)>1) {
-        h = Curl_gethost(data, data->device, &hostdataptr);
-      }
-      if(h) {
-        /* we know data->device is shorter than the myhost array */
-        strcpy(myhost, data->device);
-      }
-    }
 
-    if(! *myhost) {
-      /* need to fix this
-         h=Curl_gethost(data,
-         getmyhost(*myhost,sizeof(myhost)),
-         hostent_buf,
-         sizeof(hostent_buf));
-      */
-      printf("in here\n");
-    }
+  /* reuse_fresh is set TRUE if we are told to use a fresh connection
+     by force */
+  if(!data->bits.reuse_fresh &&
+     ConnectionExists(data, conn, &conn_temp)) {
+    /*
+     * We already have a connection for this, we got the former connection
+     * in the conn_temp variable and thus we need to cleanup the one we
+     * just allocated before we can move along and use the previously
+     * existing one.
+     */
+    struct connectdata *old_conn = conn;
+    char *path = old_conn->path; /* setup the current path pointer properly */
+    if(old_conn->proxyhost)
+      free(old_conn->proxyhost);
+    conn = conn_temp;        /* use this connection from now on */
+    free(conn->path);        /* free the previous path pointer */
 
-    infof(data, "We connect from %s\n", myhost);
+    /* we need these pointers if we speak over a proxy */
+    conn->name = old_conn->name;
+    conn->hostname = old_conn->hostname;
 
-    if ( (in=inet_addr(myhost)) != INADDR_NONE ) {
+    conn->path = path;       /* use this one */
+    conn->ppath = path;      /* set this too */
 
-      if ( h ) {
-        memset((char *)&sa, 0, sizeof(sa));
-        memcpy((char *)&sa.sin_addr,
-               h->h_addr,
-               h->h_length);
-        sa.sin_family = AF_INET;
-        sa.sin_addr.s_addr = in;
-        sa.sin_port = 0; /* get any port */
-	
-        if( bind(data->firstsocket, (struct sockaddr *)&sa, sizeof(sa)) >= 0) {
-          /* we succeeded to bind */
-          struct sockaddr_in add;
-	
-          size = sizeof(add);
-          if(getsockname(data->firstsocket, (struct sockaddr *) &add,
-                         (int *)&size)<0) {
-            failf(data, "getsockname() failed");
-            return CURLE_HTTP_PORT_FAILED;
-          }
-        }
-        else {
-          switch(errno) {
-          case EBADF:
-            failf(data, "Invalid descriptor: %d", errno);
-            break;
-          case EINVAL:
-            failf(data, "Invalid request: %d", errno);
-            break;
-          case EACCES:
-            failf(data, "Address is protected, user not superuser: %d", errno);
-            break;
-          case ENOTSOCK:
-            failf(data,
-                  "Argument is a descriptor for a file, not a socket: %d",
-                  errno);
-            break;
-          case EFAULT:
-            failf(data, "Inaccessable memory error: %d", errno);
-            break;
-          case ENAMETOOLONG:
-            failf(data, "Address too long: %d", errno);
-            break;
-          case ENOMEM:
-            failf(data, "Insufficient kernel memory was available: %d", errno);
-            break;
-          default:
-            failf(data,"errno %d\n");
-          } /* end of switch */
-	
-          return CURLE_HTTP_PORT_FAILED;
-        } /* end of else */
-	
-      } /* end of if  h */
-      else {
-	failf(data,"could't find my own IP address (%s)", myhost);
-	return CURLE_HTTP_PORT_FAILED;
-      }
-    } /* end of inet_addr */
+    /* re-use init */
+    conn->maxdownload = 0;   /* might have been used previously! */
+    conn->bits.reuse = TRUE; /* yes, we're re-using here */
 
-    else {
-      failf(data, "could't find my own IP address (%s)", myhost);
-      return CURLE_HTTP_PORT_FAILED;
-    }
+    free(old_conn);          /* we don't need this anymore */
 
-    if(hostdataptr)
-      free(hostdataptr); /* allocated by Curl_gethost() */
+    *in_connect = conn;      /* return this instead! */
 
-  } /* end of device selection support */
-#endif  /* end of HAVE_INET_NTOA */
-#endif /* end of not WIN32 */
-#endif /*ENABLE_IPV6*/
+    infof(data, "Re-using existing connection! (#%d)\n", conn->connectindex);
+  }
+  else {
+    /*
+     * This is a brand new connection, so let's store it in the connection
+     * cache of ours!
+     */
+    ConnectionStore(data, conn);
+  }
 
   /*************************************************************
-   * Connect to server/proxy
+   * Resolve the name of the server or proxy
    *************************************************************/
-#ifdef ENABLE_IPV6
-  data->firstsocket = -1;
-  for (ai = conn->res; ai; ai = ai->ai_next) {
-    data->firstsocket = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
-    if (data->firstsocket < 0)
-      continue;
+  if(!data->bits.httpproxy) {
+    /* If not connecting via a proxy, extract the port from the URL, if it is
+     * there, thus overriding any defaults that might have been set above. */
+    conn->port =  conn->remote_port; /* it is the same port */
 
-    if (connect(data->firstsocket, ai->ai_addr, ai->ai_addrlen) < 0) {
-      close(data->firstsocket);
-      data->firstsocket = -1;
-      continue;
+    /* Resolve target host right on */
+    if(!conn->hp) {
+#ifdef ENABLE_IPV6
+      /* it might already be set if reusing a connection */
+      conn->hp = Curl_getaddrinfo(data, conn->name, conn->port);
+#else
+      /* it might already be set if reusing a connection */
+      conn->hp = Curl_gethost(data, conn->name, &conn->hostent_buf);
+#endif
+    }
+    if(!conn->hp)
+    {
+      failf(data, "Couldn't resolve host '%s'", conn->name);
+      return CURLE_COULDNT_RESOLVE_HOST;
     }
-
-    break;
-  }
-  if (data->firstsocket < 0) {
-    failf(data, strerror(errno));
-    return CURLE_COULDNT_CONNECT;
   }
+  else if(!conn->hp) {
+    /* This is a proxy that hasn't been resolved yet. It may be resolved
+       if we're reusing an existing connection. */
+
+    /* resolve proxy */
+#ifdef ENABLE_IPV6
+      /* it might already be set if reusing a connection */
+    conn->hp = Curl_getaddrinfo(data, conn->proxyhost, conn->port);
 #else
-  if (connect(data->firstsocket,
-              (struct sockaddr *) &(conn->serv_addr),
-              sizeof(conn->serv_addr)
-              ) < 0) {
-    switch(errno) {
-#ifdef ECONNREFUSED
-      /* this should be made nicer */
-    case ECONNREFUSED:
-      failf(data, "Connection refused");
-      break;
-    case EFAULT:
-      failf(data, "Invalid socket address: %d",errno);
-      break;
-    case EISCONN:
-      failf(data, "Socket already connected: %d",errno);
-      break;
-    case ETIMEDOUT:
-      failf(data, "Timeout while accepting connection, server busy: %d",errno);
-      break;
-    case ENETUNREACH:
-      failf(data, "Network is unreachable: %d",errno);
-      break;
-    case EADDRINUSE:
-      failf(data, "Local address already in use: %d",errno);
-      break;
-    case EINPROGRESS:
-      failf(data, "Socket is nonblocking and connection can not be completed immediately: %d",errno);
-      break;
-    case EALREADY:
-      failf(data, "Socket is nonblocking and a previous connection attempt not completed: %d",errno);
-      break;
-    case EAGAIN:
-      failf(data, "No more free local ports: %d",errno);
-      break;
-    case EACCES:
-    case EPERM:
-      failf(data, "Attempt to connect to broadcast address without socket broadcast flag or local firewall rule violated: %d",errno);
-      break;
+    conn->hp = Curl_gethost(data, conn->proxyhost, &conn->hostent_buf);
 #endif
-    case EINTR:
-      failf(data, "Connection timeouted");
-      break;
-    default:
-      failf(data, "Can't connect to server: %d", errno);
-      break;
+    if(!conn->hp) {
+      failf(data, "Couldn't resolve proxy '%s'", conn->proxyhost);
+      return CURLE_COULDNT_RESOLVE_PROXY;
     }
-    return CURLE_COULDNT_CONNECT;
   }
-#endif
+  Curl_pgrsTime(data, TIMER_NAMELOOKUP);
 
   /*************************************************************
    * Proxy authentication
    *************************************************************/
-  if(data->bits.proxy_user_passwd) {
+  if(conn->bits.proxy_user_passwd) {
     char *authorization;
     snprintf(data->buffer, BUFSIZE, "%s:%s",
              data->proxyuser, data->proxypasswd);
     if(Curl_base64_encode(data->buffer, strlen(data->buffer),
                           &authorization) >= 0) {
-      data->ptr_proxyuserpwd =
+      if(conn->allocptr.proxyuserpwd)
+        free(conn->allocptr.proxyuserpwd);
+      conn->allocptr.proxyuserpwd =
         aprintf("Proxy-authorization: Basic %s\015\012", authorization);
       free(authorization);
     }
   }
 
   /*************************************************************
    * Send user-agent to HTTP proxies even if the target protocol
    * isn't HTTP.
    *************************************************************/
   if((conn->protocol&PROT_HTTP) || data->bits.httpproxy) {
     if(data->useragent) {
-      data->ptr_uagent =
+      if(conn->allocptr.uagent)
+        free(conn->allocptr.uagent);
+      conn->allocptr.uagent =
         aprintf("User-Agent: %s\015\012", data->useragent);
     }
   }
 
-  if(conn->curl_connect) {
-    /* is there a connect() procedure? */
+  if(-1 == conn->firstsocket) {
+    /* Connect only if not already connected! */
+    result = ConnectPlease(data, conn);
+    if(CURLE_OK != result)
+      return result;
+
+    if(conn->curl_connect) {
+      /* is there a connect() procedure? */
 
-    /* set start time here for timeout purposes in the
-     * connect procedure, it is later set again for the
-     * progress meter purpose */
-    conn->now = Curl_tvnow();
-
-    /* Call the protocol-specific connect function */
-    result = conn->curl_connect(conn);
-    if(result != CURLE_OK)
-      return result; /* pass back errors */
+      /* set start time here for timeout purposes in the
+       * connect procedure, it is later set again for the
+       * progress meter purpose */
+      conn->now = Curl_tvnow();
+
+      /* Call the protocol-specific connect function */
+      result = conn->curl_connect(conn);
+      if(result != CURLE_OK)
+        return result; /* pass back errors */
+    }
   }
 
   Curl_pgrsTime(data, TIMER_CONNECT); /* we're connected */
 
   conn->now = Curl_tvnow(); /* time this *after* the connect is done */
   conn->bytecount = 0;
@@ -1525,12 +2074,14 @@
     char hbuf[NI_MAXHOST];
 #ifdef NI_WITHSCOPEID
     const int niflags = NI_NUMERICHOST | NI_WITHSCOPEID;
 #else
     const int niflags = NI_NUMERICHOST;
 #endif
+    struct addrinfo *ai = conn->ai;
+
     if (getnameinfo(ai->ai_addr, ai->ai_addrlen, hbuf, sizeof(hbuf), NULL, 0,
 	niflags)) {
       snprintf(hbuf, sizeof(hbuf), "?");
     }
     if (ai->ai_canonname) {
       infof(data, "Connected to %s (%s)\n", ai->ai_canonname, hbuf);
@@ -1558,117 +2109,66 @@
   }
 #endif
 
   return CURLE_OK;
 }
 
-CURLcode curl_connect(CURL *curl, CURLconnect **in_connect)
+CURLcode Curl_connect(struct UrlData *data,
+                      struct connectdata **in_connect,
+                      bool allow_port)
 {
   CURLcode code;
   struct connectdata *conn;
 
   /* call the stuff that needs to be called */
-  code = _connect(curl, in_connect);
+  code = Connect(data, in_connect, allow_port);
 
   if(CURLE_OK != code) {
     /* We're not allowed to return failure with memory left allocated
        in the connectdata struct, free those here */
     conn = (struct connectdata *)*in_connect;
-    if(conn) {
-      if(conn->path)
-        free(conn->path);
-#ifdef ENABLE_IPV6
-      if(conn->res)
-        freeaddrinfo(conn->res);
-#else
-      if(conn->hostent_buf)
-        free(conn->hostent_buf);
-#endif
-      free(conn);
-      *in_connect=NULL;
-    }
+    if(conn)
+      Curl_disconnect(conn);      /* close the connection */
   }
   return code;
 }
 
 
-/*
- * NAME curl_connect()
- *
- * DESCRIPTION
- *
- * Connects to the peer server and performs the initial setup. This function
- * writes a connect handle to its second argument that is a unique handle for
- * this connect. This allows multiple connects from the same handle returned
- * by curl_open().
- *
- * EXAMPLE
- *
- * CURLCode result;
- * CURL curl;
- * CURLconnect connect;
- * result = curl_connect(curl, &connect);
- */
-
-
-
-
-CURLcode curl_done(CURLconnect *c_connect)
+CURLcode Curl_done(struct connectdata *conn)
 {
-  struct connectdata *conn = c_connect;
-  struct UrlData *data;
+  struct UrlData *data=conn->data;
   CURLcode result;
 
-  if(!conn || (conn->handle!= STRUCT_CONNECT)) {
-    return CURLE_BAD_FUNCTION_ARGUMENT;
-  }
-  if(conn->state != CONN_DO) {
-    /* This can only be called after a curl_do() */
-    return CURLE_BAD_CALLING_ORDER;
-  }
-  data = conn->data;
-
   /* this calls the protocol-specific function pointer previously set */
   if(conn->curl_done)
     result = conn->curl_done(conn);
   else
     result = CURLE_OK;
 
   Curl_pgrsDone(data); /* done with the operation */
 
-  conn->state = CONN_DONE;
+  /* if data->bits.reuse_forbid is TRUE, it means the libcurl client has
+     forced us to close this no matter what we think.
+    
+     if conn->bits.close is TRUE, it means that the connection should be
+     closed in spite of all our efforts to be nice, due to protocol
+     restrictions in our or the server's end */
+  if(data->bits.reuse_forbid ||
+     ((CURLE_OK == result) && conn->bits.close))
+    result = Curl_disconnect(conn); /* close the connection */
+  else
+    infof(data, "Connection (#%d) left alive\n", conn->connectindex);
 
   return result;
 }
 
-CURLcode curl_do(CURLconnect *in_conn)
+CURLcode Curl_do(struct connectdata *conn)
 {
-  struct connectdata *conn = in_conn;
-  CURLcode result;
-
-  if(!conn || (conn->handle!= STRUCT_CONNECT)) {
-    return CURLE_BAD_FUNCTION_ARGUMENT;
-  }
-  switch(conn->state) {
-  case CONN_INIT:
-  case CONN_DONE:
-    /* these two states are OK */
-    break;
-  default:
-    /* anything else is bad */
-    return CURLE_BAD_CALLING_ORDER;
-  }
+  CURLcode result=CURLE_OK;
 
-  if(conn->curl_do) {
+  if(conn->curl_do)
     /* generic protocol-specific function pointer set in curl_connect() */
     result = conn->curl_do(conn);
-    if(result) {
-      conn->state = CONN_ERROR;
-      return result;
-    }
-  }
-
-  conn->state = CONN_DO; /* we have entered this state */
 
-  return CURLE_OK;
+  return result;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/urldata.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/urldata.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/lib/urldata.h	2001-02-06 07:04:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/lib/urldata.h	2001-03-16 18:53:07.000000000 +0800
@@ -17,13 +17,13 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: urldata.h,v 1.40 2001/02/05 23:04:44 bagder Exp $
+ * $Id: urldata.h,v 1.57 2001/03/15 14:38:30 bagder Exp $
  *****************************************************************************/
 
 /* This file is for lib internal stuff */
 
 #include "setup.h"
 
@@ -76,12 +76,14 @@
 #endif
 
 #include "timeval.h"
 
 #include <curl/curl.h>
 
+#include "http_chunks.h" /* for the structs and enum stuff */
+
 /* Download buffer size, keep it fairly big for speed reasons */
 #define BUFSIZE (1024*50)
 
 /* Defaul upload buffer size, keep it smallish to get faster progress meter
    updates. This is just default, it is dynamic and adjusts to the upload
    speed. */
@@ -93,33 +95,12 @@
 
 /* Just a convenience macro to get the larger value out of two given */
 #ifndef MAX
 #define MAX(x,y) ((x)>(y)?(x):(y))
 #endif
 
-/* Type of handle. All publicly returned 'handles' in the curl interface
-   have a handle first in the struct that describes what kind of handle it
-   is. Used to detect bad handle usage. */
-typedef enum {
-  STRUCT_NONE,
-  STRUCT_OPEN,
-  STRUCT_CONNECT,
-  STRUCT_LAST
-} Handle;
-
-/* Connecting to a remote server using the curl interface is moving through
-   a state machine, this type is used to store the current state */
-typedef enum {
-  CONN_NONE,  /* illegal state */
-  CONN_INIT,  /* curl_connect() has been called */
-  CONN_DO,    /* curl_do() has been called successfully */
-  CONN_DONE,  /* curl_done() has been called successfully */
-  CONN_ERROR, /* and error has occurred */
-  CONN_LAST   /* illegal state */
-} ConnState;
-
 #ifdef KRB4
 /* Types needed for krb4-ftp connections */
 struct krb4buffer {
   void *data;
   size_t size;
   size_t index;
@@ -130,26 +111,94 @@
     prot_safe, 
     prot_confidential, 
     prot_private 
 };
 #endif
 
+/* struct for data related to SSL and SSL connections */
+struct ssl_connect_data {
+  bool use;              /* use ssl encrypted communications TRUE/FALSE */
+#ifdef USE_SSLEAY
+  /* these ones requires specific SSL-types */
+  SSL_CTX* ctx;
+  SSL*     handle;
+  X509*    server_cert;
+#endif /* USE_SSLEAY */
+};
+
+struct ssl_config_data {
+  long version;          /* what version the client wants to use */
+  long certverifyresult; /* result from the certificate verification */
+  long verifypeer;       /* set TRUE if this is desired */
+  char *CApath;          /* DOES NOT WORK ON WINDOWS */
+  char *CAfile;          /* cerficate to verify peer against */
+  char *random_file;     /* path to file containing "random" data */
+  char *egdsocket;       /* path to file containing the EGD daemon socket */
+};
+
+/****************************************************************************
+ * HTTP unique setup
+ ***************************************************************************/
+struct HTTP {
+  struct FormData *sendit;
+  int postsize;
+  char *p_pragma;      /* Pragma: string */
+  char *p_accept;      /* Accept: string */
+  long readbytecount; 
+  long writebytecount;
+
+  /* For FORM posting */
+  struct Form form;
+  size_t (*storefread)(char *, size_t , size_t , FILE *);
+  FILE *in;
+
+  struct Curl_chunker chunk;
+};
+
+/****************************************************************************
+ * FTP unique setup
+ ***************************************************************************/
+struct FTP {
+  long *bytecountp;
+  char *user;    /* user name string */
+  char *passwd;  /* password string */
+  char *urlpath; /* the originally given path part of the URL */
+  char *dir;     /* decoded directory */
+  char *file;    /* decoded file */
+
+  char *entrypath; /* the PWD reply when we logged on */
+};
+
+/****************************************************************************
+ * FILE unique setup
+ ***************************************************************************/
+struct FILE {
+  int fd; /* open file descriptor to read from! */
+};
+
+/*
+ * Boolean values that concerns this connection.
+ */
+struct ConnectBits {
+  bool close; /* if set, we close the connection after this request */
+  bool reuse; /* if set, this is a re-used connection */
+  bool chunk; /* if set, this is a chunked transfer-encoding */
+  bool httpproxy; /* if set, this transfer is done through a http proxy */
+  bool user_passwd;       /* do we use user+password for this connection? */
+  bool proxy_user_passwd; /* user+password for the proxy? */
+};
+
 /*
  * The connectdata struct contains all fields and variables that should be
  * unique for an entire connection.
  */
 struct connectdata {
   /**** Fields set when inited and not modified again */
-
-  /* To better see what kind of struct that is passed as input, *ALL* publicly
-     returned handles MUST have this initial 'Handle'. */
-  Handle handle; /* struct identifier */
   struct UrlData *data; /* link to the root CURL struct */
-
-  /**** curl_connect() phase fields */
-  ConnState state; /* for state dependent actions */
+  int connectindex; /* what index in the connects index this particular
+                       struct has */
 
   long protocol; /* PROT_* flags concerning the protocol set */
 #define PROT_MISSING (1<<0)
 #define PROT_GOPHER  (1<<1)
 #define PROT_HTTP    (1<<2)
 #define PROT_HTTPS   (1<<3)
@@ -157,40 +206,63 @@
 #define PROT_TELNET  (1<<5)
 #define PROT_DICT    (1<<6)
 #define PROT_LDAP    (1<<7)
 #define PROT_FILE    (1<<8)
 
 #ifdef ENABLE_IPV6
-  struct addrinfo *res;
+  struct addrinfo *hp; /* host info pointer list */
+  struct addrinfo *ai; /* the particular host we use */
 #else
   char *hostent_buf; /* pointer to allocated memory for name info */
   struct hostent *hp;
   struct sockaddr_in serv_addr;
 #endif
-  char proto[64];  /* store the protocol string in this buffer */
+  char protostr[64];  /* store the protocol string in this buffer */
   char gname[257]; /* store the hostname in this buffer */
   char *name;      /* host name pointer to fool around with */
   char *path;      /* allocated buffer to store the URL's path part in */
+  char *hostname;  /* hostname to connect, as parsed from url */
+  long port;       /* which port to use locally */
+  unsigned short remote_port; /* what remote port to connect to,
+                                 not the proxy port! */
   char *ppath;
   long bytecount;
-  struct timeval now; /* current time */
+
+  char *proxyhost; /* name of the http proxy host */
+
+  struct timeval now;     /* "current" time */
+  struct timeval created; /* creation time */
+  int firstsocket;     /* the main socket to use */
+  int secondarysocket; /* for i.e ftp transfers */
 
   long upload_bufsize; /* adjust as you see fit, never bigger than BUFSIZE
                           never smaller than UPLOAD_BUFSIZE */
 
+  long maxdownload; /* in bytes, the maximum amount of data to fetch, 0
+                       means unlimited */
+  
+  struct ssl_connect_data ssl; /* this is for ssl-stuff */
+
+  struct ConnectBits bits;    /* various state-flags for this connection */
+
   /* These two functions MUST be set by the curl_connect() function to be
      be protocol dependent */
   CURLcode (*curl_do)(struct connectdata *connect);
   CURLcode (*curl_done)(struct connectdata *connect);
 
   /* This function *MAY* be set to a protocol-dependent function that is run
    * after the connect() and everything is done, as a step in the connection.
    */ 
   CURLcode (*curl_connect)(struct connectdata *connect);
 
   /* This function *MAY* be set to a protocol-dependent function that is run
+   * by the curl_disconnect(), as a step in the disconnection.
+   */ 
+  CURLcode (*curl_disconnect)(struct connectdata *connect);
+
+  /* This function *MAY* be set to a protocol-dependent function that is run
    * in the curl_close() function if protocol-specific cleanups are required.
    */ 
   CURLcode (*curl_close)(struct connectdata *connect);
 
   /**** curl_get() phase fields */
 
@@ -202,12 +274,27 @@
           
   /* WRITE stuff */
   int writesockfd;       /* socket to write to, it may very well be
                             the same we read from. -1 disables */
   long *writebytecountp; /* return number of bytes written or NULL */
 
+  /** Dynamicly allocated strings, may need to be freed before this **/
+  /** struct is killed.                                             **/
+  struct dynamically_allocated_data {
+    char *proxyuserpwd; /* free later if not NULL! */
+    char *uagent; /* free later if not NULL! */
+    char *userpwd; /* free later if not NULL! */
+    char *rangeline; /* free later if not NULL! */
+    char *ref; /* free later if not NULL! */
+    char *cookie; /* free later if not NULL! */
+    char *host; /* free later if not NULL */
+  } allocptr;
+
+  char *newurl; /* This can only be set if a Location: was in the
+		   document headers */
+
 #ifdef KRB4
 
   enum protection_level command_prot;
   enum protection_level data_prot;
   enum protection_level request_data_prot;
 
@@ -215,12 +302,30 @@
 
   struct krb4buffer in_buffer, out_buffer;
   int sec_complete;
   void *app_data;
 
 #endif
+
+  /*************** Request - specific items ************/
+  /* previously this was in the urldata struct */
+  union {
+    struct HTTP *http;
+    struct HTTP *gopher; /* alias, just for the sake of being more readable */
+    struct HTTP *https;  /* alias, just for the sake of being more readable */
+    struct FTP *ftp;
+    struct FILE *file;
+    void *telnet;        /* private for telnet.c-eyes only */
+#if 0 /* no need for special ones for these: */
+    struct LDAP *ldap;
+    struct DICT *dict;
+#endif
+    void *generic;
+  } proto;
+
+
 };
 
 struct Progress {
   long lastshow; /* time() of the last displayed progress meter or NULL to
                     force redraw at next call */
   double size_dl;
@@ -241,50 +346,22 @@
   struct timeval t_startsingle;
   /* various data stored for possible later report */
   double t_nslookup;
   double t_connect;
   double t_pretransfer;
   int httpcode;
+  int httpversion;
   time_t filetime; /* If requested, this is might get set. It may be 0 if
                       the time was unretrievable */
 
 #define CURR_TIME 5
 
   double speeder[ CURR_TIME ];
   int speeder_c;
 };
 
-/****************************************************************************
- * HTTP unique setup
- ***************************************************************************/
-struct HTTP {
-  struct FormData *sendit;
-  int postsize;
-  char *p_pragma;      /* Pragma: string */
-  char *p_accept;      /* Accept: string */
-  long readbytecount; 
-  long writebytecount;
-
-  /* For FORM posting */
-  struct Form form;
-  size_t (*storefread)(char *, size_t , size_t , FILE *);
-  FILE *in;
-};
-
-/****************************************************************************
- * FTP unique setup
- ***************************************************************************/
-struct FTP {
-  long *bytecountp;
-  char *user;    /* user name string */
-  char *passwd;  /* password string */
-  char *urlpath; /* the originally given path part of the URL */
-  char *dir;     /* decoded directory */
-  char *file;    /* decoded file */
-};
-
 typedef enum {
   HTTPREQ_NONE, /* first in list */
   HTTPREQ_GET,
   HTTPREQ_POST,
   HTTPREQ_POST_FORM, /* we make a difference internally */
   HTTPREQ_PUT,
@@ -313,48 +390,26 @@
   bool http_include_header;
   bool http_set_referer;
   bool http_auto_referer; /* set "correct" referer when following location: */
   bool httpproxy;
   bool mute;
   bool no_body;
-  bool proxy_user_passwd;
   bool set_port;
   bool set_range;
   bool upload;
   bool use_netrc;
-  bool user_passwd;
   bool verbose;
   bool this_is_a_follow; /* this is a followed Location: request */
   bool krb4; /* kerberos4 connection requested */
   bool proxystringalloc; /* the http proxy string is malloc()'ed */
   bool rangestringalloc; /* the range string is malloc()'ed */
   bool urlstringalloc;   /* the URL string is malloc()'ed */
-};
-
-/* What type of interface that intiated this struct */
-typedef enum {
-  CURLI_NONE,
-  CURLI_EASY,
-  CURLI_NORMAL,
-  CURLI_LAST
-} CurlInterface;
-
-/* struct for data related to SSL and SSL connections */
-struct ssldata {
-  bool use;              /* use ssl encrypted communications TRUE/FALSE */
-  long version;          /* what version the client wants to use */
-  long certverifyresult; /* result from the certificate verification */
-  long verifypeer;       /* set TRUE if this is desired */
-  char *CApath;          /* DOES NOT WORK ON WINDOWS */
-  char *CAfile;          /* cerficate to verify peer against */
-#ifdef USE_SSLEAY
-  /* these ones requires specific SSL-types */
-  SSL_CTX* ctx;
-  SSL*     handle;
-  X509*    server_cert;
-#endif /* USE_SSLEAY */
+  bool reuse_forbid;     /* if this is forbidden to be reused, close 
+                            after use */
+  bool reuse_fresh;      /* do not re-use an existing connection for this
+                            transfer */
 };
 
 /*
  * As of April 11, 2000 we're now trying to split up the urldata struct in
  * three different parts:
  *
@@ -365,62 +420,47 @@
  * (Session)
  * 2 - Host and protocol-specific. No matter if we do several transfers to and
  *     from this host, these variables stay the same.
  *
  * (Request)
  * 3 - Request-specific. Variables that are of interest for this particular
- *     transfer being made right now.
+ *     transfer being made right now. THIS IS WRONG STRUCT FOR THOSE.
  *
+ * In Febrary 2001, this is being done stricter. The 'connectdata' struct
+ * MUST have all the connection oriented stuff as we may now have several
+ * simultaneous connections and connection structs in memory.
+ *
+ * From now on, the 'UrlData' must only contain data that is set once to go
+ * for many (perhaps) independent connections. Values that are generated or
+ * calculated internally MUST NOT be a part of this struct.
  */
 
 struct UrlData {
-  Handle handle; /* struct identifier */
-  CurlInterface interf; /* created by WHAT interface? */
-
   /*************** Global - specific items  ************/
   FILE *err;    /* the stderr writes goes here */
   char *errorbuffer; /* store failure messages in here */
 
   /*************** Session - specific items ************/
-  char *proxy; /* if proxy, set it here, set CONF_PROXY to use this */
+  char *proxy; /* if proxy, set it here */
   char *proxyuserpwd;  /* Proxy <user:password>, if used */
   long proxyport; /* If non-zero, use this port number by default. If the
                      proxy string features a ":[port]" that one will override
                      this. */
 
   
   long header_size;  /* size of read header(s) in bytes */
   long request_size; /* the amount of bytes sent in the request(s) */
 
-  /*************** Request - specific items ************/
-
-  union {
-    struct HTTP *http;
-    struct HTTP *gopher; /* alias, just for the sake of being more readable */
-    struct HTTP *https;  /* alias, just for the sake of being more readable */
-    struct FTP *ftp;
-#if 0 /* no need for special ones for these: */
-    struct TELNET *telnet;
-    struct FILE *file;
-    struct LDAP *ldap;
-    struct DICT *dict;
-#endif
-    void *generic;
-  } proto;
-
   FILE *out;    /* the fetched file goes here */
   FILE *in;     /* the uploaded file is read from here */
   FILE *writeheader; /* write the header to this is non-NULL */
   char *url;   /* what to get */
   char *freethis; /* if non-NULL, an allocated string for the URL */
-  char *hostname; /* hostname to connect, as parsed from url */
-  long port; /* which port to use (if non-protocol bind) set
-                CONF_PORT to use this */
-  unsigned short remote_port; /* what remote port to connect to, not the proxy
-				 port! */
+  long use_port;  /* which port to use (when not using default) */
   struct Configbits bits; /* new-style (v7) flag data */
+  struct ssl_config_data ssl; /* this is for ssl-stuff */
 
   char *userpwd;  /* <user:password>, if used */
   char *range; /* range, if used. See README for detailed specification on
                   this syntax. */
 
   /* stuff related to HTTP */
@@ -453,66 +493,52 @@
   void *progress_client; /* pointer to pass to the progress callback */
 
   /* function to call instead of the internal for password */
   curl_passwd_callback fpasswd;
   void *passwd_client; /* pointer to pass to the passwd callback */
 
-  long timeout; /* in seconds, 0 means no timeout */
-  long infilesize; /* size of file to upload, -1 means unknown */
-
-  long maxdownload; /* in bytes, the maximum amount of data to fetch, 0
-                       means unlimited */
-  
-  /* fields only set and used within _urlget() */
-  int firstsocket;     /* the main socket to use */
-  int secondarysocket; /* for i.e ftp transfers */
+  long timeout;        /* in seconds, 0 means no timeout */
+  long connecttimeout; /* in seconds, 0 means no timeout */
+  long infilesize;     /* size of file to upload, -1 means unknown */
 
   char buffer[BUFSIZE+1]; /* buffer with size BUFSIZE */
 
   double current_speed;  /* the ProgressShow() funcion sets this */
 
   long low_speed_limit; /* bytes/second */
   long low_speed_time;  /* number of seconds */
 
   int resume_from;    /* continue [ftp] transfer from here */
 
   char *cookie;       /* HTTP cookie string to send */
 
-  char *newurl; /* This can only be set if a Location: was in the
-		   document headers */
-
   struct curl_slist *headers; /* linked list of extra headers */
   struct HttpPost *httppost;  /* linked list of POST data */
 
   char *cert; /* PEM-formatted certificate */
   char *cert_passwd; /* plain text certificate password */
 
   struct CookieInfo *cookies;
 
-  struct ssldata ssl; /* this is for ssl-stuff */
-
   long crlf;
   struct curl_slist *quote;     /* before the transfer */
   struct curl_slist *postquote; /* after the transfer */
 
+  /* Telnet negotiation options */
+  struct curl_slist *telnet_options; /* linked list of telnet options */
+
   TimeCond timecondition; /* kind of comparison */
   time_t timevalue;       /* what time to compare with */
 
   Curl_HttpReq httpreq; /* what kind of HTTP request (if any) is this */
 
   char *customrequest; /* http/ftp request to use */
 
   char *headerbuff; /* allocated buffer to store headers in */
   int headersize;   /* size of the allocation */
 
-#if 0
-  /* this was removed in libcurl 7.4 */
-  char *writeinfo;  /* if non-NULL describes what to output on a successful
-                       completion */
-#endif
-
   struct Progress progress; /* for all the progress meter data */
 
 #define MAX_CURL_USER_LENGTH 128
 #define MAX_CURL_PASSWORD_LENGTH 128
 
   char *auth_host; /* if set, this is the allocated string to the host name
@@ -523,28 +549,47 @@
   /* buffers to store authentication data in */
   char user[MAX_CURL_USER_LENGTH];
   char passwd[MAX_CURL_PASSWORD_LENGTH];
   char proxyuser[MAX_CURL_USER_LENGTH];
   char proxypasswd[MAX_CURL_PASSWORD_LENGTH];
 
-  /**** Dynamicly allocated strings, may need to be freed on return ****/
-  char *ptr_proxyuserpwd; /* free later if not NULL! */
-  char *ptr_uagent; /* free later if not NULL! */
-  char *ptr_userpwd; /* free later if not NULL! */
-  char *ptr_rangeline; /* free later if not NULL! */
-  char *ptr_ref; /* free later if not NULL! */
-  char *ptr_cookie; /* free later if not NULL! */
-  char *ptr_host; /* free later if not NULL */
-
   char *krb4_level; /* what security level */
 #ifdef KRB4
   FILE *cmdchannel;
 #endif
 
   struct timeval keeps_speed; /* this should be request-specific */
+
+  /* 'connects' will be an allocated array with pointers. If the pointer is
+     set, it holds an allocated connection. */
+  struct connectdata **connects;
+  size_t numconnects; /* size of the 'connects' array */
+  curl_closepolicy closepolicy;
+
 };
 
 #define LIBCURL_NAME "libcurl"
 #define LIBCURL_ID LIBCURL_NAME " " LIBCURL_VERSION " " SSL_ID
 
+CURLcode Curl_getinfo(CURL *curl, CURLINFO info, ...);
+
+/*
+ * Here follows function prototypes from what we used to plan to call
+ * the "low level" interface. It is no longer prioritized and it is not likely
+ * to ever be supported to external users.
+ *
+ * I removed all the comments to them as well, as they were no longer accurate
+ * and they're not meant for "public use" anymore.
+ */
+
+CURLcode Curl_open(CURL **curl, char *url);
+CURLcode Curl_setopt(CURL *handle, CURLoption option, ...);
+CURLcode Curl_close(CURL *curl); /* the opposite of curl_open() */
+CURLcode Curl_connect(struct UrlData *,
+                      struct connectdata **,
+                      bool allow_port);
+CURLcode Curl_do(struct connectdata *);
+CURLcode Curl_done(struct connectdata *);
+CURLcode Curl_disconnect(struct connectdata *);
+
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile	2001-02-13 21:36:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile	2001-03-22 23:43:58.000000000 +0800
@@ -15,34 +15,34 @@
 # furnished to do so, under the terms of the MPL or the MIT/X-derivate
 # licenses. You may pick one of these licenses.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.dist,v 1.7 2001/01/04 10:37:07 bagder Exp $
+# $Id: Makefile.dist,v 1.8 2001/03/15 12:34:40 bagder Exp $
 #############################################################################
 
 all:
 	./configure
 	make
 
 ssl:
 	./configure --with-ssl
 	make
 
 borland:
-	cd lib; make -f Makefile.b32
-	cd src; make -f Makefile.b32
+	cd lib & make -f Makefile.b32
+	cd src & make -f Makefile.b32
 
 mingw32:
-	cd lib; make -f Makefile.m32
-	cd src; make -f Makefile.m32
+	cd lib & make -f Makefile.m32
+	cd src & make -f Makefile.m32
 
 mingw32-ssl:
-	cd lib; make -f Makefile.m32 SSL=1
-	cd src; make -f Makefile.m32 SSL=1
+	cd lib & make -f Makefile.m32 SSL=1
+	cd src & make -f Makefile.m32 SSL=1
 
 vc:
 	cd lib
 	nmake -f Makefile.vc6
 	cd ..\src
 	nmake -f Makefile.vc6
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile.am	2001-01-09 18:09:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile.am	2001-03-16 23:22:51.000000000 +0800
@@ -1,17 +1,17 @@
 #
-# $Id: Makefile.am,v 1.13 2001/01/09 10:09:13 bagder Exp $
+# $Id: Makefile.am,v 1.14 2001/03/16 15:22:51 bagder Exp $
 #
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 EXTRA_DIST = \
 	CHANGES LEGAL maketgz MITX.txt MPL-1.1.txt \
 	config-win32.h reconf packages/README Makefile.dist
 
-SUBDIRS = docs lib src include tests packages
+SUBDIRS = docs lib src include tests packages perl php
 
 # create a root makefile in the distribution:
 dist-hook:
 	cp $(srcdir)/Makefile.dist $(distdir)/Makefile
 
 check: test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile.dist /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile.dist
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile.dist	2001-01-04 18:37:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile.dist	2001-03-15 20:34:40.000000000 +0800
@@ -15,34 +15,34 @@
 # furnished to do so, under the terms of the MPL or the MIT/X-derivate
 # licenses. You may pick one of these licenses.
 #
 # This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
 # KIND, either express or implied.
 #
-# $Id: Makefile.dist,v 1.7 2001/01/04 10:37:07 bagder Exp $
+# $Id: Makefile.dist,v 1.8 2001/03/15 12:34:40 bagder Exp $
 #############################################################################
 
 all:
 	./configure
 	make
 
 ssl:
 	./configure --with-ssl
 	make
 
 borland:
-	cd lib; make -f Makefile.b32
-	cd src; make -f Makefile.b32
+	cd lib & make -f Makefile.b32
+	cd src & make -f Makefile.b32
 
 mingw32:
-	cd lib; make -f Makefile.m32
-	cd src; make -f Makefile.m32
+	cd lib & make -f Makefile.m32
+	cd src & make -f Makefile.m32
 
 mingw32-ssl:
-	cd lib; make -f Makefile.m32 SSL=1
-	cd src; make -f Makefile.m32 SSL=1
+	cd lib & make -f Makefile.m32 SSL=1
+	cd src & make -f Makefile.m32 SSL=1
 
 vc:
 	cd lib
 	nmake -f Makefile.vc6
 	cd ..\src
 	nmake -f Makefile.vc6
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/Makefile.in	2001-02-13 21:35:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/Makefile.in	2001-03-22 23:42:55.000000000 +0800
@@ -8,13 +8,13 @@
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY, to the extent permitted by law; without
 # even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 # PARTICULAR PURPOSE.
 
 #
-# $Id: Makefile.am,v 1.13 2001/01/09 10:09:13 bagder Exp $
+# $Id: Makefile.am,v 1.14 2001/03/16 15:22:51 bagder Exp $
 #
 
 
 SHELL = @SHELL@
 
 srcdir = @srcdir@
@@ -70,22 +70,23 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
 EXTRA_DIST =  	CHANGES LEGAL maketgz MITX.txt MPL-1.1.txt 	config-win32.h reconf packages/README Makefile.dist
 
 
-SUBDIRS = docs lib src include tests packages
+SUBDIRS = docs lib src include tests packages perl php
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = config.h ./src/config.h
 CONFIG_CLEAN_FILES = 
 DIST_COMMON =  README ./stamp-h1.in Makefile.am Makefile.in acconfig.h \
 acinclude.m4 aclocal.m4 config.guess config.h.in config.sub configure \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/maketgz /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/maketgz
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/maketgz	2001-01-08 20:51:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/maketgz	2001-03-05 23:46:27.000000000 +0800
@@ -8,13 +8,13 @@
 libversion="$version"
 
 #
 # Now we have a section to get the major, minor and patch number from the
 # full version string. We create a single hexadecimal number from it '0xMMmmpp'
 #
-perl='$a=<STDIN>;@p=split("\\.",$a);for(0..2){printf STDOUT ("%02x",$p[0+$_]);}';
+perl='$a=<STDIN>;@p=split("[\\.-]",$a);for(0..2){printf STDOUT ("%02x",$p[0+$_]);}';
 
 numeric=`echo $libversion | perl -e "$perl"`
 
 echo "CURL version number?"
 read curlversion
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Linux/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Linux/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Linux/Makefile.in	2001-02-13 21:35:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Linux/Makefile.in	2001-03-22 23:42:57.000000000 +0800
@@ -66,12 +66,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 SUBDIRS = RPM
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Linux/RPM/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Linux/RPM/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Linux/RPM/Makefile.in	2001-02-13 21:35:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Linux/RPM/Makefile.in	2001-03-22 23:42:57.000000000 +0800
@@ -66,12 +66,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 EXTRA_DIST = README curl-ssl.spec.in curl.spec.in make_curl_rpm
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Makefile.am	2001-01-09 00:10:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Makefile.am	2001-03-16 21:07:34.000000000 +0800
@@ -1 +1,3 @@
 SUBDIRS = Win32 Linux
+
+EXTRA_DIST = README
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Makefile.in	2001-02-13 21:35:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Makefile.in	2001-03-22 23:42:57.000000000 +0800
@@ -66,17 +66,20 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 SUBDIRS = Win32 Linux
+
+EXTRA_DIST = README
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../config.h ../src/config.h
 CONFIG_CLEAN_FILES = 
 DIST_COMMON =  README Makefile.am Makefile.in
 
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Win32/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Win32/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/packages/Win32/Makefile.in	2001-02-13 21:35:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/packages/Win32/Makefile.in	2001-03-22 23:42:57.000000000 +0800
@@ -66,12 +66,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 EXTRA_DIST = README
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7: perl
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7: php
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/hugehelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/hugehelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/hugehelp.c	2001-02-07 17:53:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/hugehelp.c	2001-03-16 21:11:59.000000000 +0800
@@ -14,23 +14,27 @@
 "\n"
 "SYNOPSIS\n"
 "     curl [options] [URL...]\n"
 "\n"
 "DESCRIPTION\n"
 "     curl is a client to get documents/files from or  send  docu­\n"
+);
+ puts(
 "     ments  to  a  server,  using  any of the supported protocols\n"
 "     (HTTP, HTTPS, FTP, GOPHER, DICT, TELNET, LDAP or FILE).  The\n"
 "     command  is designed to work without user interaction or any\n"
 "     kind of interactivity.\n"
 "\n"
 "     curl offers a busload of useful tricks like  proxy  support,\n"
 "     user  authentication,  ftp  upload,  HTTP post, SSL (https:)\n"
 "     connections, cookies, file transfer resume and more.\n"
 "\n"
 "URL\n"
 "     The URL syntax is protocol dependent. You'll find a detailed\n"
+);
+ puts(
 "     description in RFC 2396.\n"
 "\n"
 "     You  can  specify  multiple URLs or parts of URLs by writing\n"
 "     part sets within braces as in:\n"
 "\n"
 "      http://site.{one,two,three}.com\n"
@@ -41,135 +45,182 @@
 "      ftp://ftp.numericals.com/file[1-100].txt\n"
 "      ftp://ftp.numericals.com/file[001-100].txt    (with leading\n"
 "     zeros)\n"
 "      ftp://ftp.letters.com/file[a-z].txt\n"
 "\n"
 "     It is possible to specify up to 9 sets or series for a  URL,\n"
+);
+ puts(
 "     but no nesting is supported at the moment:\n"
 "\n"
 "      http://www.any.org/archive[1996-1999]/vol­\n"
 "     ume[1-4]part{a,b,c,index}.html\n"
 "\n"
 "     Starting with curl 7.6, you can specify any amount  of  URLs\n"
 "     on  the  command  line. They will be fetched in a sequential\n"
 "     manner in the specified order.\n"
 "\n"
+"     Starting with curl 7.7, curl will attempt to re-use  connec­\n"
+"     tions  for  multiple  file  transfers,  so that getting many\n"
+);
+ puts(
+"     files from  the  same  server  will  not  do  multiple  con­\n"
+"     nects/handshakes.  This  improves  speed.  Of course this is\n"
+"     only done on files specified on a single  command  line  and\n"
+"     cannot be used between separate curl invokes.\n"
 "OPTIONS\n"
 "     -a/--append\n"
 "          (FTP) When used in a ftp upload, this will tell curl to\n"
 "          append to the target file instead of overwriting it. If\n"
 "          the file doesn't exist, it will be created.\n"
 "\n"
-"          If this option is  used  twice,  the  second  one  will\n"
-"          disable append mode again.\n"
+);
+ puts(
+"          If  this option is used twice, the second one will dis­\n"
+"          able append mode again.\n"
 "\n"
 "     -A/--user-agent <agent string>\n"
-"          (HTTP)  Specify  the  User-Agent  string to send to the\n"
-"          HTTP server. Some badly done CGIs fail if its  not  set\n"
+"          (HTTP) Specify the User-Agent string  to  send  to  the\n"
+"          HTTP  server.  Some badly done CGIs fail if its not set\n"
 "          to \"Mozilla/4.0\".  To encode blanks in the string, sur­\n"
-"          round the string with single  quote  marks.   This  can\n"
+"          round  the  string  with  single quote marks.  This can\n"
 "          also be set with the -H/--header flag of course.\n"
 "\n"
-"          If  this  option  is  used more than once, the last one\n"
+);
+ puts(
+"          If this option is used more than  once,  the  last  one\n"
 "          will be the one to be used.\n"
 "\n"
 "     -b/--cookie <name=data>\n"
 "          (HTTP) Pass the data to the HTTP server as a cookie. It\n"
-"          is  supposedly  the  data  previously received from the\n"
-"          server in a \"Set-Cookie:\" line.  The data should be  in\n"
+"          is supposedly the data  previously  received  from  the\n"
+"          server  in a \"Set-Cookie:\" line.  The data should be in\n"
 "          the format \"NAME1=VALUE1; NAME2=VALUE2\".\n"
 "\n"
-"          If  no '=' letter is used in the line, it is treated as\n"
-"          a filename to use  to  read  previously  stored  cookie\n"
-"          lines  from,  which  should  be used in this session if\n"
+"          If no '=' letter is used in the line, it is treated  as\n"
+);
+ puts(
+"          a  filename  to  use  to  read previously stored cookie\n"
+"          lines from, which should be used  in  this  session  if\n"
 "          they  match.  Using  this  method  also  activates  the\n"
-"          \"cookie  parser\"  which  will make curl record incoming\n"
+"          \"cookie parser\" which will make  curl  record  incoming\n"
 "          cookies too, which may be handy if you're using this in\n"
-"          combination  with  the  -L/--location  option. The file\n"
+"          combination with the  -L/--location  option.  The  file\n"
 "          format of the file to read cookies from should be plain\n"
+);
+ puts(
 "          HTTP headers or the netscape cookie file format.\n"
 "\n"
-"          NOTE  that  the file specified with -b/--cookie is only\n"
-"          used as input. No cookies will be stored in  the  file.\n"
+"          NOTE that the file specified with -b/--cookie  is  only\n"
+"          used  as  input. No cookies will be stored in the file.\n"
 "          To store cookies, save the HTTP headers to a file using\n"
 "          -D/--dump-header!\n"
 "\n"
-"          If this option is used more than  once,  the  last  one\n"
+"          If  this  option  is  used more than once, the last one\n"
 "          will be the one to be used.\n"
 "\n"
 "     -B/--use-ascii\n"
-"          Use  ASCII  transfer  when  getting an FTP file or LDAP\n"
-"          info. For FTP, this can also be enforced  by  using  an\n"
-"          URL  that  ends with \";type=A\". This option causes data\n"
+"          Use ASCII transfer when getting an  FTP  file  or  LDAP\n"
+);
+ puts(
+"          info.  For  FTP,  this can also be enforced by using an\n"
+"          URL that ends with \";type=A\". This option  causes  data\n"
 "          sent to stdout to be in text mode for win32 systems.\n"
 "\n"
-"          If this option is used twice, the second one will  dis­\n"
+"          If  this option is used twice, the second one will dis­\n"
 "          able ASCII usage.\n"
+"     --connect-timeout <seconds>\n"
+"          Maximum time in seconds that you allow  the  connection\n"
+"          to the server to take.  This only limits the connection\n"
+);
+ puts(
+"          phase, once curl has connected this  option  is  of  no\n"
+"          more  use.  This  option doesn't work in win32 systems.\n"
+"          See also the --max-time option.\n"
+"\n"
+"          If this option is used serveral  times,  the  last  one\n"
+"          will be used.\n"
 "\n"
 "     -c/--continue\n"
 "          Deprecated. Use '-C -' instead.  Continue/Resume a pre­\n"
 "          vious file transfer. This instructs  curl  to  continue\n"
 "          appending  data  on  the  file  where it was previously\n"
+);
+ puts(
 "          left, possibly because of a broken  connection  to  the\n"
 "          server.  There  must be a named physical file to append\n"
 "          to for this to work.  Note: Upload resume  is  depening\n"
 "          on  a  command named SIZE not always present in all ftp\n"
 "          servers! Upload resume is for FTP only.  HTTP resume is\n"
 "          only possible with HTTP/1.1 or later servers.\n"
 "\n"
 "     -C/--continue-at <offset>\n"
 "          Continue/Resume  a  previous file transfer at the given\n"
+);
+ puts(
 "          offset. The given offset is the exact number  of  bytes\n"
 "          that  will be skipped counted from the beginning of the\n"
 "          source file before it is transfered to the destination.\n"
 "          If  used with uploads, the ftp server command SIZE will\n"
 "          not be used by curl. Upload resume  is  for  FTP  only.\n"
 "          HTTP  resume  is  only  possible with HTTP/1.1 or later\n"
 "          servers.\n"
 "\n"
 "          If this option is used serveral  times,  the  last  one\n"
+);
+ puts(
 "          will be used.\n"
 "\n"
 "     -d/--data <data>\n"
 "          (HTTP)  Sends  the  specified data in a POST request to\n"
-"          the HTTP server. Note that the data is sent exactly  as\n"
-"          specified  with  no extra processing (with all newlines\n"
-"          cut off).  The data is expected  to  be  \"url-encoded\".\n"
-"          This  will  cause  curl  to pass the data to the server\n"
-"          using  the  content-type  application/x-www-form-urlen­\n"
-"          coded. Compare to -F. If more than one -d/--data option\n"
-"          is used on the same command line, the data pieces spec­\n"
-"          ified  will be merged together with a separating &-let­\n"
-"          ter. Thus, using '-d name=daniel -d skill=lousy'  would\n"
-"          generate a post chunk that looks like\n"
+"          the HTTP server, in a way that can emulate as if a user\n"
+"          has  filled  in a HTML form and pressed the submit but­\n"
+"          ton. Note that the data is sent  exactly  as  specified\n"
+"          with  no  extra processing (with all newlines cut off).\n"
+"          The data is expected to  be  \"url-encoded\".  This  will\n"
+);
+ puts(
+"          cause  curl  to  pass  the data to the server using the\n"
+"          content-type application/x-www-form-urlencoded. Compare\n"
+"          to -F. If more than one -d/--data option is used on the\n"
+"          same command line, the data pieces  specified  will  be\n"
+"          merged together with a separating &-letter. Thus, using\n"
+"          '-d name=daniel -d skill=lousy' would generate  a  post\n"
+"          chunk that looks like\n"
 "\n"
 "          If you start the data with the letter @, the rest\n"
+);
+ puts(
 "          should be a file name to read the data from, or - if\n"
-"          you want curl to read the data from stdin.  The con­\n"
-"          tents of the file must already be url-encoded. Multiple\n"
-"          files can also be specified.\n"
+"          you want curl to read the data from stdin.  The\n"
+"          contents of the file must already be url-encoded. Mul­\n"
+"          tiple files can also be specified.\n"
 "\n"
 "          To post data purely binary, you should instead use the\n"
 "          --data-binary option.\n"
 "\n"
 "          -d/--data is the same as --data-ascii.\n"
 "\n"
 "          If this option is used serveral times, the ones follow­\n"
 "          ing the first will append data.\n"
 "\n"
+);
+ puts(
 "     --data-ascii <data>\n"
 "          (HTTP) This is an alias for the -d/--data option.\n"
 "\n"
 "          If this option is used serveral times, the ones follow­\n"
 "          ing the first will append data.\n"
 "\n"
 "     --data-binary <data>\n"
 "          (HTTP) This posts data in a similar manner as --data-\n"
 "          ascii does, although when using this option the entire\n"
 "          context of the posted data is kept as-is. If you want\n"
 "          to post a binary file without the strip-newlines fea­\n"
+);
+ puts(
 "          ture of the --data-ascii option, this is for you.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "          If this option is used serveral times, the ones follow­\n"
@@ -177,39 +228,53 @@
 "\n"
 "     -D/--dump-header <file>\n"
 "          (HTTP/FTP) Write the HTTP headers to this file. Write\n"
 "          the FTP file info to this file if -I/--head is used.\n"
 "\n"
 "          This option is handy to use when you want to store the\n"
+);
+ puts(
 "          cookies that a HTTP site sends to you. The cookies\n"
 "          could then be read in a second curl invoke by using the\n"
 "          -b/--cookie option!\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -e/--referer <URL>\n"
 "          (HTTP) Sends the \"Referer Page\" information to the HTTP\n"
 "          server. This can also be set with the -H/--header flag\n"
 "          of course.  When used with -L/--location you can append\n"
+);
+ puts(
 "          \";auto\" to the referer URL to make curl automatically\n"
 "          set the previous URL when it follows a Location:\n"
 "          header. The \";auto\" string can be used alone, even if\n"
 "          you don't set an initial referer.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
+"     --egd-file <file>\n"
+"          (HTTPS) Specify the path name to the Entropy Gathering\n"
+"          Daemon socket. The socket is used to seed the random\n"
+);
+ puts(
+"          engine for SSL connections. See also the --random-file\n"
+"          option.\n"
+"\n"
 "     -E/--cert <certificate[:password]>\n"
 "          (HTTPS) Tells curl to use the specified certificate\n"
 "          file when getting a file with HTTPS. The certificate\n"
 "          must be in PEM format.  If the optional password isn't\n"
 "          specified, it will be queried for on the terminal. Note\n"
 "          that this certificate is the private key and the pri­\n"
 "          vate certificate concatenated!\n"
 "\n"
+);
+ puts(
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     --cacert <CA certificate>\n"
 "          (HTTPS) Tells curl to use the specified certificate\n"
 "          file to verify the peer. The certificate must be in PEM\n"
@@ -218,90 +283,102 @@
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -f/--fail\n"
 "          (HTTP) Fail silently (no output at all) on server\n"
 "          errors. This is mostly done like this to better enable\n"
+);
+ puts(
 "          scripts etc to better deal with failed attempts. In\n"
 "          normal cases when a HTTP server fails to deliver a doc­\n"
 "          ument, it returns a HTML document stating so (which\n"
 "          often also describes why and more). This flag will pre­\n"
 "          vent curl from outputting that and fail silently\n"
 "          instead.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable silent failure.\n"
 "\n"
 "     -F/--form <name=content>\n"
+);
+ puts(
 "          (HTTP) This lets curl emulate a filled in form in which\n"
 "          a user has pressed the submit button. This causes curl\n"
 "          to POST data using the content-type multipart/form-data\n"
 "          according to RFC1867. This enables uploading of binary\n"
 "          files etc. To force the 'content' part to be be a file,\n"
 "          prefix the file name with an @ sign. To just get the\n"
 "          content part from a file, prefix the file name with the\n"
-"          letter <. The difference between @ and < is then that @\n"
-"          makes a file get attached in the post as a file upload,\n"
 );
  puts(
+"          letter <. The difference between @ and < is then that @\n"
+"          makes a file get attached in the post as a file upload,\n"
 "          while the < makes a text field and just get the con­\n"
 "          tents for that text field from a file.\n"
-"\n"
 "          Example, to send your password file to the server,\n"
 "          where input:\n"
 "\n"
 "          curl -F password=@/etc/passwd www.mypasswords.com\n"
 "\n"
 "          To read the file's content from stdin insted of a file,\n"
+);
+ puts(
 "          use - where the file name should've been. This goes for\n"
 "          both @ and < constructs.\n"
 "\n"
 "          This option can be used multiple times.\n"
 "\n"
 "     -g/--globoff\n"
 "          This option switches off the \"URL globbing parser\".\n"
 "          When you set this option, you can specify URLs that\n"
 "          contain the letters {}[] without having them being\n"
 "          interpreted by curl itself. Note that these letters are\n"
 "          not normal legal URL contents but they should be\n"
+);
+ puts(
 "          encoded according to the URI standard. (Option added in\n"
 "          curl 7.6)\n"
 "\n"
 "     -h/--help\n"
 "          Usage help.\n"
 "\n"
 "     -H/--header <header>\n"
 "          (HTTP) Extra header to use when getting a web page. You\n"
 "          may specify any number of extra headers. Note that if\n"
 "          you should add a custom header that has the same name\n"
 "          as one of the internal ones curl would use, your exter­\n"
 "          nally set header will be used instead of the internal\n"
+);
+ puts(
 "          one. This allows you to make even trickier stuff than\n"
 "          curl would normally do. You should not replace inter­\n"
 "          nally set headers without knowing perfectly well what\n"
 "          you're doing. Replacing an internal header with one\n"
 "          without content on the right side of the colon will\n"
 "          prevent that header from appearing.\n"
 "\n"
 "          This option can be used multiple times.\n"
 "\n"
 "     -i/--include\n"
 "          (HTTP) Include the HTTP-header in the output. The HTTP-\n"
+);
+ puts(
 "          header includes things like server-name, date of the\n"
 "          document, HTTP-version and more...\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable header include.\n"
 "\n"
 "     --interface <name>\n"
 "          Perform an operation using a specified interface. You\n"
 "          can enter interface name, IP address or host name. An\n"
 "          example could look like:\n"
 "\n"
 "          curl --interface eth0:1 http://www.netscape.com/\n"
-"\n"
+);
+ puts(
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -I/--head\n"
 "          (HTTP/FTP) Fetch the HTTP-header only! HTTP-servers\n"
 "          feature the command HEAD which this uses to get nothing\n"
@@ -309,108 +386,127 @@
 "          curl displays the file size only.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable header only.\n"
 "\n"
 "     --krb4 <level>\n"
+);
+ puts(
 "          (FTP) Enable kerberos4 authentication and use. The\n"
 "          level must be entered and should be one of 'clear',\n"
 "          'safe', 'confidential' or 'private'. Should you use a\n"
 "          level that is not one of these, 'private' will instead\n"
 "          be used.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -K/--config <config file>\n"
 "          Specify which config file to read curl arguments from.\n"
+);
+ puts(
 "          The config file is a text file in which command line\n"
 "          arguments can be written which then will be used as if\n"
 "          they were written on the actual command line. Options\n"
 "          and their parameters must be specified on the same con­\n"
 "          fig file line. If the parameter is to contain white\n"
 "          spaces, the parameter must be inclosed within quotes.\n"
 "          If the first column of a config line is a '#' charac­\n"
+);
+ puts(
 "          ter, the rest of the line will be treated as a comment.\n"
 "\n"
 "          Specify the filename as '-' to make curl read the file\n"
 "          from stdin.\n"
 "\n"
 "          This option can be used multiple times.\n"
 "\n"
 "     -l/--list-only\n"
 "          (FTP) When listing an FTP directory, this switch forces\n"
 "          a name-only view.  Especially useful if you want to\n"
 "          machine-parse the contents of an FTP directory since\n"
 "          the normal directory view doesn't use a standard look\n"
+);
+ puts(
 "          or format.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable list only.\n"
 "\n"
 "     -L/--location\n"
 "          (HTTP/HTTPS) If the server reports that the requested\n"
 "          page has a different location (indicated with the\n"
 "          header line Location:) this flag will let curl attempt\n"
 "          to reattempt the get on the new place. If used together\n"
 "          with -i or -I, headers from all requested pages will be\n"
+);
+ puts(
 "          shown. If this flag is used when making a HTTP POST,\n"
 "          curl will automatically switch to GET after the initial\n"
 "          POST has been done.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable location following.\n"
 "\n"
 "     -m/--max-time <seconds>\n"
 "          Maximum time in seconds that you allow the whole opera­\n"
 "          tion to take.  This is useful for preventing your batch\n"
 "          jobs from hanging for hours due to slow networks or\n"
+);
+ puts(
 "          links going down.  This doesn't work fully in win32\n"
-"          systems.\n"
+"          systems.  See also the --connect-timeout option.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -M/--manual\n"
 "          Manual. Display the huge help text.\n"
 "\n"
 "     -n/--netrc\n"
 "          Makes curl scan the .netrc file in the user's home\n"
 "          directory for login name and password. This is typi­\n"
 "          cally used for ftp on unix. If used with http, curl\n"
+);
+ puts(
 "          will enable user authentication. See netrc(4) for\n"
 "          details on the file format. Curl will not complain if\n"
 "          that file hasn't the right permissions (it should not\n"
 "          be world nor group readable). The environment variable\n"
 "          \"HOME\" is used to find the home directory.\n"
 "\n"
 "          A quick and very simple example of how to setup a\n"
 "          .netrc to allow curl to ftp to the machine\n"
 "          host.domain.com with user name\n"
 "\n"
+);
+ puts(
 "          machine host.domain.com login myself password secret\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable netrc usage.\n"
 "\n"
 "     -N/--no-buffer\n"
 "          Disables the buffering of the output stream. In normal\n"
 "          work situations, curl will use a standard buffered out­\n"
 "          put stream that will have the effect that it will out­\n"
 "          put the data in chunks, not necessarily exactly when\n"
+);
+ puts(
 "          the data arrives.  Using this option will disable that\n"
 "          buffering.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          switch on buffering.\n"
-"\n"
 "     -o/--output <file>\n"
 "          Write output to <file> instead of stdout. If you are\n"
 "          using {} or [] to fetch multiple documents, you can use\n"
 "          '#' followed by a number in the <file> specifier. That\n"
 "          variable will be replaced with the current string for\n"
+);
+ puts(
 "          the URL being fetched. Like in:\n"
 "\n"
 "            curl http://{one,two}.site.com -o \"file_#1.txt\"\n"
 "\n"
 "          or use several variables like:\n"
 "\n"
@@ -421,72 +517,93 @@
 "\n"
 "     -O/--remote-name\n"
 "          Write output to a local file named like the remote file\n"
 "          we get. (Only the file part of the remote file is used,\n"
 "          the path is cut off.)\n"
 "\n"
+);
+ puts(
 "          You may use this option as many times as you have num­\n"
 "          ber of URLs.\n"
+"\n"
 "     -p/--proxytunnel\n"
 "          When an HTTP proxy is used, this option will cause non-\n"
 "          HTTP protocols to attempt to tunnel through the proxy\n"
 "          instead of merely using it to do HTTP-like operations.\n"
 "          The tunnel approach is made with the HTTP proxy CONNECT\n"
 "          request and requires that the proxy allows direct con­\n"
 "          nect to the remote port number curl wants to tunnel\n"
+);
+ puts(
 "          through to.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable proxy tunnel.\n"
 "\n"
 "     -P/--ftpport <address>\n"
 "          (FTP) Reverses the initiator/listener roles when con­\n"
 "          necting with ftp. This switch makes Curl use the PORT\n"
 "          command instead of PASV. In practice, PORT tells the\n"
 "          server to connect to the client's specified address and\n"
 "          port, while PASV asks the server for an ip address and\n"
+);
+ puts(
 "          port to connect to. <address> should be one of:\n"
 "\n"
 "          interface   i.e \"eth0\" to specify which interface's IP\n"
 "                      address you want to use  (Unix only)\n"
 "\n"
 "          IP address  i.e \"192.168.10.1\" to specify exact IP num­\n"
 "                      ber\n"
 "\n"
 "          host name   i.e \"my.host.domain\" to specify machine\n"
-"\n"
 "          -           (any single-letter string) to make it pick\n"
 "                      the machine's default\n"
 "\n"
+);
+ puts(
 "     If this option is used serveral times, the last one will be\n"
 "     used.\n"
 "\n"
 "     -q   If used as the first parameter on the command line, the\n"
 "          $HOME/.curlrc file will not be read and used as a con­\n"
 "          fig file.\n"
 "\n"
 "     -Q/--quote <comand>\n"
 "          (FTP) Send an arbitrary command to the remote FTP\n"
 "          server, by using the QUOTE command of the server. Not\n"
 "          all servers support this command, and the set of QUOTE\n"
+);
+ puts(
 "          commands are server specific! Quote commands are sent\n"
 "          BEFORE the transfer is taking place. To make commands\n"
 "          take place after a successful transfer, prefix them\n"
 "          with a dash '-'. You may specify any amount of commands\n"
 "          to be run before and after the transfer. If the server\n"
 "          returns failure for one of the commands, the entire\n"
 "          operation will be aborted.\n"
 "\n"
 "          This option can be used multiple times.\n"
+"\n"
+"     --random-file <file>\n"
+);
+ puts(
+"          (HTTPS) Specify the path name to file containing what\n"
+"          will be considered as random data. The data is used to\n"
+"          seed the random engine for SSL connections.  See also\n"
+"          the --edg-file option.\n"
+"\n"
 "     -r/--range <range>\n"
 "          (HTTP/FTP) Retrieve a byte range (i.e a partial docu­\n"
 "          ment) from a HTTP/1.1 or FTP server. Ranges can be\n"
 "          specified in a number of ways.\n"
 "\n"
 "          0-499     specifies the first 500 bytes\n"
 "\n"
+);
+ puts(
 "          500-999   specifies the second 500 bytes\n"
 "\n"
 "          -500      specifies the last 500 bytes\n"
 "\n"
 "          9500      specifies the bytes from offset 9500 and for­\n"
 "                    ward\n"
@@ -497,24 +614,25 @@
 "                    specifies 300 bytes from offset 500(H)\n"
 "\n"
 "          100-199,500-599\n"
 "                    specifies two separate 100 bytes ranges(*)(H)\n"
 );
  puts(
-"\n"
 "     (*) = NOTE that this will cause the server to reply with a\n"
 "     multipart response!\n"
 "\n"
 "     You should also be aware that many HTTP/1.1 servers do not\n"
 "     have this feature enabled, so that when you attempt to get a\n"
 "     range, you'll instead get the whole document.\n"
 "\n"
 "     FTP range downloads only support the simple syntax 'start-\n"
 "     stop' (optionally with one of the numbers omitted). It\n"
 "     depends on the non-RFC command SIZE.\n"
 "\n"
+);
+ puts(
 "     If this option is used serveral times, the last one will be\n"
 "     used.\n"
 "\n"
 "     -s/--silent\n"
 "          Silent mode. Don't show progress meter or error mes­\n"
 "          sages.  Makes Curl mute.\n"
@@ -526,44 +644,54 @@
 "          When used with -s it makes curl show error message if\n"
 "          it fails.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable show error.\n"
 "\n"
-"     -t/--upload\n"
-"          Deprecated. Use '-T -' instead.  Transfer the stdin\n"
-"          data to the specified file. Curl will read everything\n"
-"          from stdin until EOF and store with the supplied name.\n"
-"          If this is used on a http(s) server, the PUT command\n"
-"          will be used.\n"
+);
+ puts(
+"     -t/--telnet-option <OPT=val>\n"
+"          Pass options to the telnet protocol. Supported options\n"
+"          are:\n"
+"\n"
+"          TTYPE=<term> Sets the terminal type.\n"
+"\n"
+"          XDISPLOC=<X display> Sets the X display location.\n"
+"\n"
+"          NEW_ENV=<var,val> Sets an environment variable.\n"
 "\n"
 "     -T/--upload-file <file>\n"
 "          Like -t, but this transfers the specified local file.\n"
 "          If there is no file part in the specified URL, Curl\n"
+);
+ puts(
 "          will append the local file name. NOTE that you must use\n"
 "          a trailing / on the last directory to really prove to\n"
 "          Curl that there is no file name or curl will think that\n"
 "          your last directory name is the remote file name to\n"
 "          use. That will most likely cause the upload operation\n"
 "          to fail. If this is used on a http(s) server, the PUT\n"
 "          command will be used.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
+);
+ puts(
 "          will be used.\n"
-"\n"
 "     -u/--user <user:password>\n"
 "          Specify user and password to use when fetching. See\n"
 "          README.curl for detailed examples of how to use this.\n"
 "          If no password is specified, curl will ask for it\n"
 "          interactively.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -U/--proxy-user <user:password>\n"
 "          Specify user and password to use for Proxy authentica­\n"
+);
+ puts(
 "          tion. If no password is specified, curl will ask for it\n"
 "          interactively.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
@@ -573,72 +701,86 @@
 "\n"
 "          This option may be used any number of times. To control\n"
 "          where this URL is written, use the -o or the -O\n"
 "          options.\n"
 "\n"
 "     -v/--verbose\n"
+);
+ puts(
 "          Makes the fetching more verbose/talkative. Mostly\n"
 "          usable for debugging. Lines starting with '>' means\n"
 "          data sent by curl, '<' means data received by curl that\n"
 "          is hidden in normal cases and lines starting with '*'\n"
 "          means additional info provided by curl.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable verbose.\n"
 "\n"
 "     -V/--version\n"
 "          Displays the full version of curl, libcurl and other\n"
+);
+ puts(
 "          3rd party libraries linked with the executable.\n"
 "\n"
 "     -w/--write-out <format>\n"
 "          Defines what to display after a completed and success­\n"
 "          ful operation. The format is a string that may contain\n"
 "          plain text mixed with any number of variables. The\n"
 "          string can be specified as \"string\", to get read from a\n"
 "          particular file you specify it \"@filename\" and to tell\n"
 "          curl to read the format from stdin you write \"@-\".\n"
 "\n"
+);
+ puts(
 "          The variables present in the output format will be sub­\n"
 "          stituted by the value or text that curl thinks fit, as\n"
 "          described below. All variables are specified like\n"
 "          %{variable_name} and to output a normal % you just\n"
 "          write them like %%. You can output a newline by using\n"
 "          \\n, a carrige return with \\r and a tab space with \\t.\n"
 "\n"
 "          NOTE: The %-letter is a special letter in the\n"
+);
+ puts(
 "          win32-environment, where all occurrences of % must be\n"
 "          doubled when using this option.\n"
 "\n"
 "          Available variables are at this point:\n"
 "\n"
 "          url_effective  The URL that was fetched last. This is\n"
 "                         mostly meaningful if you've told curl to\n"
 "                         follow location: headers.\n"
 "\n"
 "          http_code      The numerical code that was found in the\n"
 "                         last retrieved HTTP(S) page.\n"
 "\n"
+);
+ puts(
 "          time_total     The total time, in seconds, that the\n"
 "                         full operation lasted. The time will be\n"
 "                         displayed with millisecond resolution.\n"
 "\n"
 "          time_namelookup\n"
 "                         The time, in seconds, it took from the\n"
 "                         start until the name resolving was com­\n"
 "                         pleted.\n"
 "\n"
 "          time_connect   The time, in seconds, it took from the\n"
+);
+ puts(
 "                         start until the connect to the remote\n"
 "                         host (or proxy) was completed.\n"
 "\n"
 "          time_pretransfer\n"
 "                         The time, in seconds, it took from the\n"
 "                         start until the file transfer is just\n"
 "                         about to begin. This includes all pre-\n"
 "                         transfer commands and negotiations that\n"
 "                         are specific to the particular proto­\n"
+);
+ puts(
 "                         col(s) involved.\n"
 "\n"
 "          size_download  The total amount of bytes that were\n"
 "                         downloaded.\n"
 "\n"
 "          size_upload    The total amount of bytes that were\n"
@@ -647,67 +789,80 @@
 "          size_header    The total amount of bytes of the down­\n"
 "                         loaded headers.\n"
 "\n"
 "          size_request   The total amount of bytes that were sent\n"
 "                         in the HTTP request.\n"
 "\n"
+);
+ puts(
 "          speed_download The average download speed that curl\n"
 "                         measured for the complete download.\n"
 "\n"
-"          speed_upload   The average upload speed that curl mea­\n"
-"                         sured for the complete upload.\n"
+"          speed_upload   The average upload speed that curl\n"
+"                         measured for the complete upload.\n"
 "\n"
 "     If this option is used serveral times, the last one will be\n"
 "     used.\n"
 "\n"
 "     -x/--proxy <proxyhost[:port]>\n"
 "          Use specified proxy. If the port number is not speci­\n"
 "          fied, it is assumed at port 1080.\n"
 "\n"
+);
+ puts(
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -X/--request <command>\n"
 "          (HTTP) Specifies a custom request to use when communi­\n"
 "          cating with the HTTP server.  The specified request\n"
 "          will be used instead of the standard GET. Read the HTTP\n"
 "          1.1 specification for details and explanations.\n"
 "\n"
 "          (FTP) Specifies a custom FTP command to use instead of\n"
 "          LIST when doing file lists with ftp.\n"
 "\n"
+);
+ puts(
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -y/--speed-time <time>\n"
 "          If a download is slower than speed-limit bytes per sec­\n"
 "          ond during a speed-time period, the download gets\n"
 "          aborted. If speed-time is used, the default speed-limit\n"
 "          will be 1 unless set with -y.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
+"\n"
 "     -Y/--speed-limit <speed>\n"
+);
+ puts(
 "          If a download is slower than this given speed, in bytes\n"
 "          per second, for speed-time seconds it gets aborted.\n"
 "          speed-time is set with -Y and is 30 if not set.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "     -z/--time-cond <date expression>\n"
 "          (HTTP) Request to get a file that has been modified\n"
 "          later than the given time and date, or one that has\n"
+);
+ puts(
 "          been modified before that time. The date expression can\n"
 "          be all sorts of date strings or if it doesn't match any\n"
 "          internal ones, it tries to get the time from a given\n"
 "          file name instead! See the GNU date(1) or curl_get­\n"
 "          date(3) man pages for date expression details.\n"
 "\n"
 "          Start the date expression with a dash (-) to make it\n"
 "          request for a document that is older than the given\n"
+);
+ puts(
 "          date/time, default is a document that is newer than the\n"
 "          specified date/time.\n"
 "\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
@@ -717,12 +872,14 @@
 "\n"
 "     -2/--sslv2\n"
 "          (HTTPS) Forces curl to use SSL version 2 when negotiat­\n"
 "          ing with a remote SSL server.\n"
 "\n"
 "     -#/--progress-bar\n"
+);
+ puts(
 "          Make curl display progress information as a progress\n"
 "          bar instead of the default statistics.\n"
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable the progress bar.\n"
 "\n"
@@ -732,55 +889,61 @@
 "\n"
 "          If this option is used twice, the second will again\n"
 "          disable crlf converting.\n"
 "\n"
 "     --stderr <file>\n"
 "          Redirect all writes to stderr to the specified file\n"
+);
+ puts(
 "          instead. If the file name is a plain '-', it is instead\n"
 "          written to stdout. This option has no point when you're\n"
 "          using a shell with decent redirecting capabilities.\n"
+"\n"
 "          If this option is used serveral times, the last one\n"
 "          will be used.\n"
 "\n"
 "FILES\n"
 "     ~/.curlrc\n"
 "          Default config file.\n"
 "\n"
 "ENVIRONMENT\n"
 "     HTTP_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for HTTP.\n"
 "\n"
 "     HTTPS_PROXY [protocol://]<host>[:port]\n"
+);
+ puts(
 "          Sets proxy server to use for HTTPS.\n"
 "\n"
 "     FTP_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for FTP.\n"
-"\n"
 "     GOPHER_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use for GOPHER.\n"
 "\n"
 "     ALL_PROXY [protocol://]<host>[:port]\n"
 "          Sets proxy server to use if no protocol-specific proxy\n"
 "          is set.\n"
 "\n"
 "     NO_PROXY <comma-separated list of hosts>\n"
 "          list of host names that shouldn't go through any proxy.\n"
+);
+ puts(
 "          If set to a asterisk '*' only, it matches all hosts.\n"
 "\n"
 "     COLUMNS <integer>\n"
 "          The width of the terminal.  This variable only affects\n"
-);
- puts(
 "          curl when the --progress-bar option is used.\n"
 "\n"
 "EXIT CODES\n"
 "     There exists a bunch of different error codes and their cor­\n"
 "     responding error messages that may appear during bad condi­\n"
 "     tions. At the time of this writing, the exit codes are:\n"
 "\n"
 "     1    Unsupported protocol. This build of curl has no support\n"
+);
+ puts(
 "          for this protocol.\n"
 "\n"
 "     2    Failed to initialize.\n"
 "\n"
 "     3    URL malformat. The syntax was not correct.\n"
 "\n"
@@ -793,28 +956,31 @@
 "     6    Couldn't resolve host. The given remote host was not\n"
 "          resolved.\n"
 "\n"
 "     7    Failed to connect to host.\n"
 "\n"
 "     8    FTP weird server reply. The server sent data curl\n"
+);
+ puts(
 "          couldn't parse.\n"
 "\n"
 "     9    FTP access denied. The server denied login.\n"
 "\n"
 "     10   FTP user/password incorrect. Either one or both were\n"
 "          not accepted by the server.\n"
 "\n"
 "     11   FTP weird PASS reply. Curl couldn't parse the reply\n"
 "          sent to the PASS request.\n"
 "\n"
 "     12   FTP weird USER reply. Curl couldn't parse the reply\n"
 "          sent to the USER request.\n"
-"\n"
 "     13   FTP weird PASV reply, Curl couldn't parse the reply\n"
 "          sent to the PASV request.\n"
 "\n"
+);
+ puts(
 "     14   FTP weird 227 format. Curl couldn't parse the 227-line\n"
 "          the server sent.\n"
 "\n"
 "     15   FTP can't get host. Couldn't resolve the host IP we got\n"
 "          in the 227-line.\n"
 "\n"
@@ -825,12 +991,14 @@
 "          method to binary.\n"
 "\n"
 "     18   Partial file. Only a part of the file was transfered.\n"
 "\n"
 "     19   FTP couldn't RETR file. The RETR command failed.\n"
 "\n"
+);
+ puts(
 "     20   FTP write error. The transfer was reported bad by the\n"
 "          server.\n"
 "\n"
 "     21   FTP quote error. A quote command returned error from\n"
 "          the server.\n"
 "\n"
@@ -840,12 +1008,14 @@
 "     23   Write error. Curl couldn't write data to a local\n"
 "          filesystem or similar.\n"
 "\n"
 "     24   Malformat user. User name badly specified.\n"
 "\n"
 "     25   FTP couldn't STOR file. The server denied the STOR\n"
+);
+ puts(
 "          operation.\n"
 "\n"
 "     26   Read error. Various reading problems.\n"
 "\n"
 "     27   Out of memory. A memory allocation request failed.\n"
 "\n"
@@ -856,12 +1026,14 @@
 "          reply.\n"
 "\n"
 "     30   FTP PORT failed. The PORT command failed.\n"
 "\n"
 "     31   FTP couldn't use REST. The REST command failed.\n"
 "\n"
+);
+ puts(
 "     32   FTP couldn't use SIZE. The SIZE command failed. The\n"
 "          command is an extension to the original FTP spec RFC\n"
 "          959.\n"
 "\n"
 "     33   HTTP range error. The range \"command\" didn't work.\n"
 "\n"
@@ -871,12 +1043,14 @@
 "     35   SSL connect error. The SSL handshaking failed.\n"
 "\n"
 "     36   FTP bad download resume. Couldn't continue an earlier\n"
 "          aborted download.\n"
 "\n"
 "     37   FILE couldn't read file. Failed to open the file. Per­\n"
+);
+ puts(
 "          missions?\n"
 "\n"
 "     38   LDAP cannot bind. LDAP bind operation failed.\n"
 "\n"
 "     39   LDAP search failed.\n"
 "\n"
@@ -890,14 +1064,17 @@
 "\n"
 "     43   Internal error. A function was called with a bad param­\n"
 "          eter.\n"
 "\n"
 "     44   Internal error. A function was called in a bad order.\n"
 "\n"
+);
+ puts(
 "     45   Interface error. A specified outgoing interface could\n"
 "          not be used.\n"
+"\n"
 "     46   Bad password entered. An error was signalled when the\n"
 "          password was entered.\n"
 "\n"
 "     47   Too many redirects. When following redirects, curl hit\n"
 "          the maximum amount.\n"
 "\n"
@@ -905,67 +1082,79 @@
 "          releases. The existing ones are meant to never change.\n"
 "\n"
 "BUGS\n"
 "     If you do find bugs, mail them to curl-bug@haxx.se.\n"
 "\n"
 "AUTHORS / CONTRIBUTORS\n"
+);
+ puts(
 "      - Daniel Stenberg <Daniel.Stenberg@haxx.se>\n"
 "      - Rafael Sagula <sagula@inf.ufrgs.br>\n"
 "      - Sampo Kellomaki <sampo@iki.fi>\n"
 "      - Linas Vepstas <linas@linas.org>\n"
 "      - Bjorn Reese <breese@mail1.stofanet.dk>\n"
 "      - Johan Anderson <johan@homemail.com>\n"
 "      - Kjell Ericson <Kjell.Ericson@haxx.se>\n"
 "      - Troy Engel <tengel@sonic.net>\n"
 "      - Ryan Nelson <ryan@inch.com>\n"
 "      - Björn Stenberg <Bjorn.Stenberg@haxx.se>\n"
 "      - Angus Mackay <amackay@gus.ml.org>\n"
+);
+ puts(
 "      - Eric Young <eay@cryptsoft.com>\n"
 "      - Simon Dick <simond@totally.irrelevant.org>\n"
 "      - Oren Tirosh <oren@monty.hishome.net>\n"
 "      - Steven G. Johnson <stevenj@alum.mit.edu>\n"
 "      - Gilbert Ramirez Jr. <gram@verdict.uthscsa.edu>\n"
 "      - Andrés García <ornalux@redestb.es>\n"
 "      - Douglas E. Wegscheid <wegscd@whirlpool.com>\n"
 "      - Mark Butler <butlerm@xmission.com>\n"
 "      - Eric Thelin <eric@generation-i.com>\n"
 "      - Marc Boucher <marc@mbsi.ca>\n"
+);
+ puts(
 "      - Greg Onufer <Greg.Onufer@Eng.Sun.COM>\n"
 "      - Doug Kaufman <dkaufman@rahul.net>\n"
 "      - David Eriksson <david@2good.com>\n"
 "      - Ralph Beckmann <rabe@uni-paderborn.de>\n"
 "      - T. Yamada <tai@imasy.or.jp>\n"
 "      - Lars J. Aas <larsa@sim.no>\n"
 "      - Jörn Hartroth <Joern.Hartroth@computer.org>\n"
 "      - Matthew Clarke <clamat@van.maves.ca>\n"
-"      - Linus Nielsen <Linus.Nielsen@haxx.se>\n"
+"      - Linus Nielsen Feltzing <linus@haxx.se>\n"
 "      - Felix von Leitner <felix@convergence.de>\n"
 "      - Dan Zitter <dzitter@zitter.net>\n"
+);
+ puts(
 "      - Jongki Suwandi <Jongki.Suwandi@eng.sun.com>\n"
 "      - Chris Maltby <chris@aurema.com>\n"
 "      - Ron Zapp <rzapper@yahoo.com>\n"
 "      - Paul Marquis <pmarquis@iname.com>\n"
 "      - Ellis Pritchard <ellis@citria.com>\n"
 "      - Damien Adant <dams@usa.net>\n"
 "      - Chris <cbayliss@csc.come>\n"
 "      - Marco G. Salvagno <mgs@whiz.cjb.net>\n"
 "      - Paul Marquis <pmarquis@iname.com>\n"
 "      - David LeBlanc <dleblanc@qnx.com>\n"
 "      - Rich Gray at Plus Technologies\n"
 "      - Luong Dinh Dung <u8luong@lhsystems.hu>\n"
+);
+ puts(
 "      - Torsten Foertsch <torsten.foertsch@gmx.net>\n"
 "      - Kristian Köhntopp <kris@koehntopp.de>\n"
 "      - Fred Noz <FNoz@siac.com>\n"
 "      - Caolan McNamara <caolan@csn.ul.ie>\n"
 "      - Albert Chin-A-Young <china@thewrittenword.com>\n"
 "      - Stephen Kick <skick@epicrealm.com>\n"
 "      - Martin Hedenfalk <mhe@stacken.kth.se>\n"
 "      - Richard Prescott\n"
 "      - Jason S. Priebe <priebe@wral-tv.com>\n"
 "      - T. Bharath <TBharath@responsenetworks.com>\n"
 "      - Alexander Kourakos <awk@users.sourceforge.net>\n"
+);
+ puts(
 "      - James Griffiths <griffiths_james@yahoo.com>\n"
 "      - Loic Dachary <loic@senga.org>\n"
 "      - Robert Weaver <robert.weaver@sabre.com>\n"
 "      - Ingo Ralf Blum <ingoralfblum@ingoralfblum.com>\n"
 "      - Jun-ichiro itojun Hagino <itojun@iijlab.net>\n"
 "\n"
@@ -978,12 +1167,14 @@
 "SEE ALSO\n"
 "     ftp(1), wget(1), snarf(1)\n"
 "\n"
 "LATEST VERSION\n"
 "\n"
 "  You always find news about what's going on as well as the latest versions\n"
+);
+ puts(
 "  from the curl web pages, located at:\n"
 "\n"
 "        http://curl.haxx.se\n"
 "\n"
 "SIMPLE USAGE\n"
 "\n"
@@ -1000,42 +1191,56 @@
 "        curl gopher://gopher.funet.fi\n"
 "\n"
 "  Get a web page from a server using port 8000:\n"
 "\n"
 "        curl http://www.weirdserver.com:8000/\n"
 "\n"
+);
+ puts(
 "  Get a list of the root directory of an FTP site:\n"
 "\n"
-"        curl ftp://ftp.fts.frontec.se/\n"
+"        curl ftp://cool.haxx.se/\n"
 "\n"
 "  Get the definition of curl from a dictionary:\n"
 "\n"
 "        curl dict://dict.org/m:curl\n"
 "\n"
+"  Fetch two documents at once:\n"
+"\n"
+"        curl ftp://cool.haxx.se/ http://www.weirdserver.com:8000/\n"
+"\n"
 "DOWNLOAD TO A FILE\n"
 "\n"
 "  Get a web page and store in a local file:\n"
 "\n"
 "        curl -o thatpage.html http://www.netscape.com/\n"
 "\n"
 "  Get a web page and store in a local file, make the local file get the name\n"
+);
+ puts(
 "  of the remote document (if no file name part is specified in the URL, this\n"
 "  will fail):\n"
 "\n"
 "        curl -O http://www.netscape.com/index.html\n"
 "\n"
+"  Fetch two files and store them with their remote names:\n"
+"\n"
+"        curl -O www.haxx.se/index.html -O curl.haxx.se/download.html\n"
+"\n"
 "USING PASSWORDS\n"
 "\n"
 " FTP\n"
 "\n"
 "   To ftp files using name+passwd, include them in the URL like:\n"
 "\n"
 "        curl ftp://name:passwd@machine.domain:port/full/path/to/file\n"
 "\n"
 "   or specify them with the -u flag like\n"
 "\n"
+);
+ puts(
 "        curl -u name:passwd ftp://machine.domain:port/full/path/to/file\n"
 "\n"
 " HTTP\n"
 "\n"
 "   The HTTP URL doesn't support user and password in the URL string. Curl\n"
 "   does support that anyway to provide a ftp-style interface and thus you can\n"
@@ -1044,12 +1249,14 @@
 "        curl http://name:passwd@machine.domain/full/path/to/file\n"
 "\n"
 "   or specify user and password separately like in\n"
 "\n"
 "        curl -u name:passwd http://machine.domain/full/path/to/file\n"
 "\n"
+);
+ puts(
 "   NOTE! Since HTTP URLs don't support user and password, you can't use that\n"
 "   style when using Curl via a proxy. You _must_ use the -u style fetch\n"
 "   during such circumstances.\n"
 "\n"
 " HTTPS\n"
 "\n"
@@ -1062,12 +1269,14 @@
 "PROXY\n"
 "\n"
 " Get an ftp file using a proxy named my-proxy that uses port 888:\n"
 "\n"
 "        curl -x my-proxy:888 ftp://ftp.leachsite.com/README\n"
 "\n"
+);
+ puts(
 " Get a file from a HTTP server that requires user and password, using the\n"
 " same proxy as above:\n"
 "\n"
 "        curl -u user:passwd -x my-proxy:888 http://www.get.this/\n"
 "\n"
 " Some proxies require special authentication. Specify by using -U as above:\n"
@@ -1077,12 +1286,14 @@
 " See also the environment variables Curl support that offer further proxy\n"
 " control.\n"
 "\n"
 "RANGES\n"
 "\n"
 "  With HTTP 1.1 byte-ranges were introduced. Using this, a client can request\n"
+);
+ puts(
 "  to get only one or more subparts of a specified document. Curl supports\n"
 "  this with the -r flag.\n"
 "\n"
 "  Get the first 100 bytes of a document:\n"
 "\n"
 "        curl -r 0-99 http://www.get.this/\n"
@@ -1099,29 +1310,31 @@
 "        curl -r 0-99 ftp://www.get.this/README  \n"
 "\n"
 "UPLOADING\n"
 "\n"
 " FTP\n"
 "\n"
+);
+ puts(
 "  Upload all data on stdin to a specified ftp site:\n"
 "\n"
 "        curl -t ftp://ftp.upload.com/myfile\n"
 "\n"
 "  Upload data from a specified file, login with user and password:\n"
 "\n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/myfile\n"
-);
- puts(
 "\n"
 "  Upload a local file to the remote site, and use the local file name remote\n"
 "  too:\n"
 " \n"
 "        curl -T uploadfile -u user:passwd ftp://ftp.upload.com/\n"
 "\n"
 "  Upload a local file to get appended to the remote file using ftp:\n"
 "\n"
+);
+ puts(
 "        curl -T localfile -a ftp://ftp.upload.com/remotefile\n"
 "\n"
 "  Curl also supports ftp upload through a proxy, but only if the proxy is\n"
 "  configured to allow that kind of tunneling. If it does, you can run curl in\n"
 "  a fashion similar to:\n"
 "\n"
@@ -1131,12 +1344,14 @@
 "\n"
 "  Upload all data on stdin to a specified http site:\n"
 "\n"
 "        curl -t http://www.upload.com/myfile\n"
 "\n"
 "  Note that the http server must've been configured to accept PUT before this\n"
+);
+ puts(
 "  can be done successfully.\n"
 "\n"
 "  For other ways to do http data upload, see the POST section below.\n"
 "\n"
 "VERBOSE / DEBUG\n"
 "\n"
@@ -1146,20 +1361,24 @@
 "  receives in order to let the user see all client-server interaction.\n"
 "\n"
 "        curl -v ftp://ftp.upload.com/\n"
 "\n"
 "DETAILED INFORMATION\n"
 "\n"
+);
+ puts(
 "  Different protocols provide different ways of getting detailed information\n"
 "  about specific files/documents. To get curl to show detailed information\n"
 "  about a single file, you should use -I/--head option. It displays all\n"
 "  available info on a single file for HTTP and FTP. The HTTP information is a\n"
 "  lot more extensive.\n"
 "\n"
 "  For HTTP, you can get the header information (the same as -I would show)\n"
 "  shown before the data by using -i/--include. Curl understands the\n"
+);
+ puts(
 "  -D/--dump-header option when getting files from both FTP and HTTP, and it\n"
 "  will then store the headers in the specified file.\n"
 "\n"
 "  Store the HTTP headers in a separate file:\n"
 "\n"
 "        curl --dump-header headers.txt curl.haxx.se\n"
@@ -1168,12 +1387,14 @@
 "  time if you want curl to use cookies sent by the server. More about that in\n"
 "  the cookies section.\n"
 "\n"
 "POST (HTTP)\n"
 "\n"
 "  It's easy to post data using curl. This is done using the -d <data>\n"
+);
+ puts(
 "  option.  The post data must be urlencoded.\n"
 "\n"
 "  Post a simple \"name\" and \"phone\" guestbook.\n"
 "\n"
 "        curl -d \"name=Rafael%20Sagula&phone=3320780\" \\\n"
 "                http://www.where.com/guest.cgi\n"
@@ -1181,12 +1402,14 @@
 "  How to post a form with curl, lesson #1:\n"
 "\n"
 "  Dig out all the <input> tags in the form that you want to fill in. (There's\n"
 "  a perl program called formfind.pl on the curl site that helps with this).\n"
 "\n"
 "  If there's a \"normal\" post, you use -d to post. -d takes a full \"post\n"
+);
+ puts(
 "  string\", which is in the format\n"
 "\n"
 "        <variable1>=<data1>&<variable2>=<data2>&...\n"
 "\n"
 "  The 'variable' names are the names set with \"name=\" in the <input> tags, and\n"
 "  the data is the contents you want to fill in for the inputs. The data *must*\n"
@@ -1195,12 +1418,14 @@
 "  the letter's ASCII code.\n"
 "\n"
 "  Example:\n"
 "\n"
 "  (page located at http://www.formpost.com/getthis/\n"
 "\n"
+);
+ puts(
 "        <form action=\"post.cgi\" method=\"post\">\n"
 "        <input name=user size=10>\n"
 "        <input name=pass type=password size=10>\n"
 "        <input name=id type=hidden value=\"blablabla\">\n"
 "        <input name=ding value=\"submit\">\n"
 "        </form>\n"
@@ -1210,36 +1435,44 @@
 "  To post to this, you enter a curl command line like:\n"
 "\n"
 "        curl -d \"user=foobar&pass=12345&id=blablabla&dig=submit\"  (continues)\n"
 "          http://www.formpost.com/getthis/post.cgi\n"
 "\n"
 "\n"
+);
+ puts(
 "  While -d uses the application/x-www-form-urlencoded mime-type, generally\n"
 "  understood by CGI's and similar, curl also supports the more capable\n"
 "  multipart/form-data type. This latter type supports things like file upload.\n"
 "\n"
 "  -F accepts parameters like -F \"name=contents\". If you want the contents to\n"
 "  be read from a file, use <@filename> as contents. When specifying a file,\n"
 "  you can also specify which content type the file is, by appending\n"
+);
+ puts(
 "  ';type=<mime type>' to the file name. You can also post contents of several\n"
 "  files in one field. So that the field name 'coolfiles' can be sent three\n"
 "  files with different content types in a manner similar to:\n"
 "\n"
 "        curl -F \"coolfiles=@fil1.gif;type=image/gif,fil2.txt,fil3.html\" \\\n"
 "        http://www.post.com/postit.cgi\n"
 "\n"
 "  If content-type is not specified, curl will try to guess from the extension\n"
 "  (it only knows a few), or use the previously specified type (from an earlier\n"
+);
+ puts(
 "  file if several files are specified in a list) or finally using the default\n"
 "  type 'text/plain'.\n"
 "\n"
 "  Emulate a fill-in form with -F. Let's say you fill in three fields in a\n"
 "  form. One field is a file name which to post, one field is your name and one\n"
 "  field is a file description. We want to post the file we have written named\n"
 "  \"cooltext.txt\". To let curl do the posting of this data instead of your\n"
 "  favourite browser, you have to check out the HTML of the form page to get to\n"
+);
+ puts(
 "  know the names of the input fields. In our example, the input field names are\n"
 "  'file', 'yourname' and 'filedescription'.\n"
 "\n"
 "        curl -F \"file=@cooltext.txt\" -F \"yourname=Daniel\" \\\n"
 "             -F \"filedescription=Cool text file with cool text inside\" \\\n"
 "             http://www.post.com/postit.cgi\n"
@@ -1247,24 +1480,28 @@
 "  So, to send two files in one post you can do it in two ways:\n"
 "\n"
 "  1. Send multiple files in a single \"field\" with a single field name:\n"
 " \n"
 "        curl -F \"pictures=@dog.gif,cat.gif\" \n"
 " \n"
+);
+ puts(
 "  2. Send two fields with two field names: \n"
 "\n"
 "        curl -F \"docpicture=@dog.gif\" -F \"catpicture=@cat.gif\" \n"
 "\n"
 "REFERER\n"
 "\n"
 "  A HTTP request has the option to include information about which address\n"
 "  that referred to actual page, and curl allows the user to specify that\n"
 "  referrer to get specified on the command line. It is especially useful to\n"
 "  fool or trick stupid servers or CGI scripts that rely on that information\n"
 "  being available or contain certain data.\n"
 "\n"
+);
+ puts(
 "        curl -e www.coolsite.com http://www.showme.com/\n"
 "\n"
 "  NOTE: The referer field is defined in the HTTP spec to be a full URL.\n"
 "\n"
 "USER AGENT\n"
 "\n"
@@ -1274,41 +1511,49 @@
 "  scripts that only accept certain browsers.\n"
 "\n"
 "  Example:\n"
 "\n"
 "  curl -A 'Mozilla/3.0 (Win95; I)' http://www.nationsbank.com/\n"
 "\n"
+);
+ puts(
 "  Other common strings:\n"
 "    'Mozilla/3.0 (Win95; I)'     Netscape Version 3 for Windows 95\n"
 "    'Mozilla/3.04 (Win95; U)'    Netscape Version 3 for Windows 95\n"
 "    'Mozilla/2.02 (OS/2; U)'     Netscape Version 2 for OS/2\n"
 "    'Mozilla/4.04 [en] (X11; U; AIX 4.2; Nav)'           NS for AIX\n"
 "    'Mozilla/4.05 [en] (X11; U; Linux 2.0.32 i586)'      NS for Linux\n"
 "\n"
 "  Note that Internet Explorer tries hard to be compatible in every way:\n"
 "    'Mozilla/4.0 (compatible; MSIE 4.01; Windows 95)'    MSIE for W95\n"
+);
+ puts(
 "\n"
 "  Mozilla is not the only possible User-Agent name:\n"
 "    'Konqueror/1.0'             KDE File Manager desktop client\n"
 "    'Lynx/2.7.1 libwww-FM/2.14' Lynx command line browser\n"
 "\n"
 "COOKIES\n"
 "\n"
 "  Cookies are generally used by web servers to keep state information at the\n"
 "  client's side. The server sets cookies by sending a response line in the\n"
 "  headers that looks like 'Set-Cookie: <data>' where the data part then\n"
 "  typically contains a set of NAME=VALUE pairs (separated by semicolons ';'\n"
+);
+ puts(
 "  like \"NAME1=VALUE1; NAME2=VALUE2;\"). The server can also specify for what\n"
 "  path the \"cookie\" should be used for (by specifying \"path=value\"), when the\n"
 "  cookie should expire (\"expire=DATE\"), for what domain to use it\n"
 "  (\"domain=NAME\") and if it should be used on secure connections only\n"
 "  (\"secure\").\n"
 "\n"
 "  If you've received a page from a server that contains a header like:\n"
 "        Set-Cookie: sessionid=boo123; path=\"/foo\";\n"
 "\n"
+);
+ puts(
 "  it means the server wants that first pair passed on when we get anything in\n"
 "  a path beginning with \"/foo\".\n"
 "\n"
 "  Example, get a page that wants my name passed in a cookie:\n"
 "\n"
 "        curl -b \"name=Daniel\" www.sillypage.com\n"
@@ -1316,69 +1561,79 @@
 "  Curl also has the ability to use previously received cookies in following\n"
 "  sessions. If you get cookies from a server and store them in a file in a\n"
 "  manner similar to:\n"
 "\n"
 "        curl --dump-header headers www.example.com\n"
 "\n"
+);
+ puts(
 "  ... you can then in a second connect to that (or another) site, use the\n"
 "  cookies from the 'headers' file like:\n"
 "\n"
 "        curl -b headers www.example.com\n"
 "\n"
 "  Note that by specifying -b you enable the \"cookie awareness\" and with -L\n"
 "  you can make curl follow a location: (which often is used in combination\n"
 "  with cookies). So that if a site sends cookies and a location, you can\n"
 "  use a non-existing file to trig the cookie awareness like:\n"
 "\n"
 "        curl -L -b empty-file www.example.com\n"
 "\n"
+);
+ puts(
 "  The file to read cookies from must be formatted using plain HTTP headers OR\n"
 "  as netscape's cookie file. Curl will determine what kind it is based on the\n"
 "  file contents.\n"
 "\n"
 "PROGRESS METER\n"
 "\n"
 "  The progress meter exists to show a user that something actually is\n"
 "  happening. The different fields in the output have the following meaning:\n"
 "\n"
 "  % Total    % Received % Xferd  Average Speed          Time             Curr.\n"
 "                                 Dload  Upload Total    Current  Left    Speed\n"
+);
+ puts(
 "  0  151M    0 38608    0     0   9406      0  4:41:43  0:00:04  4:41:39  9287\n"
 "\n"
 "  From left-to-right:\n"
 "   %             - percentage completed of the whole transfer\n"
 "   Total         - total size of the whole expected transfer\n"
 "   %             - percentage completed of the download\n"
 "   Received      - currently downloaded amount of bytes\n"
 "   %             - percentage completed of the upload\n"
 "   Xferd         - currently uploaded amount of bytes\n"
 "   Average Speed\n"
+);
+ puts(
 "   Dload         - the average transfer speed of the download\n"
 "   Average Speed\n"
 "   Upload        - the average transfer speed of the upload\n"
 "   Time Total    - expected time to complete the operation\n"
 "   Time Current  - time passed since the invoke\n"
 "   Time Left     - expected time left to completetion\n"
 "   Curr.Speed    - the average transfer speed the last 5 seconds (the first\n"
 "                   5 seconds of a transfer is based on less time of course.)\n"
 "\n"
-"  The -# option will display a totally different progress bar that doesn't\n"
 );
  puts(
+"  The -# option will display a totally different progress bar that doesn't\n"
 "  need much explanation!\n"
 "\n"
 "SPEED LIMIT\n"
 "\n"
 "  Curl offers the user to set conditions regarding transfer speed that must\n"
 "  be met to let the transfer keep going. By using the switch -y and -Y you\n"
 "  can make curl abort transfers if the transfer speed doesn't exceed your\n"
 "  given lowest limit for a specified time.\n"
 "\n"
 "  To let curl abandon downloading this page if its slower than 3000 bytes per\n"
 "  second for 1 minute, run:\n"
 "\n"
+);
+ puts(
 "        curl -y 3000 -Y 60 www.far-away-site.com\n"
 "\n"
 "  This can very well be used in combination with the overall time limit, so\n"
 "  that the above operatioin must be completed in whole within 30 minutes:\n"
 "\n"
 "        curl -m 1800 -y 3000 -Y 60 www.far-away-site.com\n"
@@ -1386,21 +1641,25 @@
 "CONFIG FILE\n"
 "\n"
 "  Curl automatically tries to read the .curlrc file (or _curlrc file on win32\n"
 "  systems) from the user's home dir on startup.\n"
 "\n"
 "  The config file could be made up with normal command line switches, but you\n"
+);
+ puts(
 "  can also specify the long options without the dashes to make it more\n"
 "  readable. You can separate the options and the parameter with spaces, or\n"
 "  with = or :. Comments can be used within the file. If the first letter on a\n"
 "  line is a '#'-letter the rest of the line is treated as a comment.\n"
 "\n"
 "  If you want the parameter to contain spaces, you must inclose the entire\n"
 "  parameter within double quotes (\"). Within those quotes, you specify a\n"
 "  quote as \\\".\n"
 "\n"
+);
+ puts(
 "  NOTE: You must specify options and their arguments on the same line.\n"
 "\n"
 "  Example, set default time out and proxy in a config file:\n"
 "\n"
 "        # We want a 30 minute timeout:\n"
 "        -m 1800\n"
@@ -1408,12 +1667,14 @@
 "        proxy = proxy.our.domain.com:8080\n"
 "\n"
 "  White spaces ARE significant at the end of lines, but all white spaces\n"
 "  leading up to the first characters of each line are ignored.\n"
 "\n"
 "  Prevent curl from reading the default file by using -q as the first command\n"
+);
+ puts(
 "  line parameter, like:\n"
 "\n"
 "        curl -q www.thatsite.com\n"
 "\n"
 "  Force curl to get and display a local help page in case it is invoked\n"
 "  without URL by making a config file similar to:\n"
@@ -1421,12 +1682,14 @@
 "        # default url to get\n"
 "        url = \"http://help.with.curl.com/curlhelp.html\"\n"
 "\n"
 "  You can specify another config file to be read by using the -K/--config\n"
 "  flag. If you set config file name to \"-\" it'll read the config from stdin,\n"
 "  which can be handy if you want to hide options from being visible in process\n"
+);
+ puts(
 "  tables etc:\n"
 "\n"
 "        echo \"user = user:passwd\" | curl -K - http://that.secret.site.com\n"
 "\n"
 "EXTRA HEADERS\n"
 "\n"
@@ -1436,22 +1699,30 @@
 "\n"
 "  Example, send the header \"X-you-and-me: yes\" to the server when getting a\n"
 "  page:\n"
 "\n"
 "        curl -H \"X-you-and-me: yes\" www.love.com\n"
 "\n"
-"  This can also be useful in case you want curl to send a different text in\n"
-"  a header than it normally does. The -H header you specify then replaces the\n"
-"  header curl would normally send.\n"
+"  This can also be useful in case you want curl to send a different text in a\n"
+);
+ puts(
+"  header than it normally does. The -H header you specify then replaces the\n"
+"  header curl would normally send. If you replace an internal header with an\n"
+"  empty one, you prevent that header from being sent. To prevent the Host:\n"
+"  header from being used:\n"
+"\n"
+"        curl -H \"Host:\" www.server.com\n"
 "\n"
 "FTP and PATH NAMES\n"
 "\n"
 "  Do note that when getting files with the ftp:// URL, the given path is\n"
 "  relative the directory you enter. To get the file 'README' from your home\n"
 "  directory at your ftp site, do:\n"
 "\n"
+);
+ puts(
 "        curl ftp://user:passwd@my.site.com/README\n"
 "\n"
 "  But if you want the README file from the root directory of that very same\n"
 "  site, you need to specify the absolute file name:\n"
 "\n"
 "        curl ftp://user:passwd@my.site.com//README\n"
@@ -1461,31 +1732,37 @@
 "FTP and firewalls\n"
 "\n"
 "  The FTP protocol requires one of the involved parties to open a second\n"
 "  connction as soon as data is about to get transfered. There are two ways to\n"
 "  do this.\n"
 "\n"
+);
+ puts(
 "  The default way for curl is to issue the PASV command which causes the\n"
 "  server to open another port and await another connection performed by the\n"
 "  client. This is good if the client is behind a firewall that don't allow\n"
 "  incoming connections.\n"
 "\n"
 "        curl ftp.download.com\n"
 "\n"
 "  If the server for example, is behind a firewall that don't allow connections\n"
 "  on other ports than 21 (or if it just doesn't support the PASV command), the\n"
+);
+ puts(
 "  other way to do it is to use the PORT command and instruct the server to\n"
 "  connect to the client on the given (as parameters to the PORT command) IP\n"
 "  number and port.\n"
 "\n"
 "  The -P flag to curl supports a few different options. Your machine may have\n"
 "  several IP-addresses and/or network interfaces and curl allows you to select\n"
 "  which of them to use. Default address can also be used:\n"
 "\n"
 "        curl -P - ftp.download.com\n"
 "\n"
+);
+ puts(
 "  Download with PORT but use the IP address of our 'le0' interface (this does\n"
 "  not work on windows):\n"
 "\n"
 "        curl -P le0 ftp.download.com\n"
 "\n"
 "  Download with PORT but use 192.168.0.10 as our IP address to use:\n"
@@ -1501,51 +1778,61 @@
 "  or\n"
 "\n"
 "	curl --interface 192.168.1.10 http://www.netscape.com/\n"
 "\n"
 "HTTPS\n"
 "\n"
+);
+ puts(
 "  Secure HTTP requires SSL libraries to be installed and used when curl is\n"
 "  built. If that is done, curl is capable of retrieving and posting documents\n"
 "  using the HTTPS procotol.\n"
 "\n"
 "  Example:\n"
 "\n"
 "        curl https://www.secure-site.com\n"
 "\n"
 "  Curl is also capable of using your personal certificates to get/post files\n"
 "  from sites that require valid certificates. The only drawback is that the\n"
 "  certificate needs to be in PEM-format. PEM is a standard and open format to\n"
+);
+ puts(
 "  store certificates with, but it is not used by the most commonly used\n"
 "  browsers (Netscape and MSEI both use the so called PKCS#12 format). If you\n"
 "  want curl to use the certificates you use with your (favourite) browser, you\n"
 "  may need to download/compile a converter that can convert your browser's\n"
 "  formatted certificates to PEM formatted ones. This kind of converter is\n"
 "  included in recent versions of OpenSSL, and for older versions Dr Stephen\n"
+);
+ puts(
 "  N. Henson has written a patch for SSLeay that adds this functionality. You\n"
 "  can get his patch (that requires an SSLeay installation) from his site at:\n"
 "  http://www.drh-consultancy.demon.co.uk/\n"
 "\n"
 "  Example on how to automatically retrieve a document using a certificate with\n"
 "  a personal password:\n"
 "\n"
 "        curl -E /path/to/cert.pem:password https://secure.site.com/\n"
 "\n"
 "  If you neglect to specify the password on the command line, you will be\n"
+);
+ puts(
 "  prompted for the correct password before any data can be received.\n"
 "\n"
 "  Many older SSL-servers have problems with SSLv3 or TLS, that newer versions\n"
 "  of OpenSSL etc is using, therefore it is sometimes useful to specify what\n"
 "  SSL-version curl should use. Use -3 or -2 to specify that exact SSL version\n"
 "  to use:\n"
 "\n"
 "        curl -2 https://secure.site.com/\n"
 "\n"
 "  Otherwise, curl will first attempt to use v3 and then v2.\n"
 "\n"
 "  To use OpenSSL to convert your favourite browser's certificate into a PEM\n"
+);
+ puts(
 "  formatted one that curl can use, do something like this (assuming netscape,\n"
 "  but IE is likely to work similarly):\n"
 "\n"
 "    You start with hitting the 'security' menu button in netscape. \n"
 "\n"
 "    Select 'certificates->yours' and then pick a certificate in the list \n"
@@ -1556,12 +1843,14 @@
 "\n"
 "    select a proper place to save it \n"
 "\n"
 "    Run the 'openssl' application to convert the certificate. If you cd to the\n"
 "    openssl installation, you can do it like:\n"
 "\n"
+);
+ puts(
 "     # ./apps/openssl pkcs12 -certfile [file you saved] -out [PEMfile]\n"
 "\n"
 "\n"
 "RESUMING FILE TRANSFERS\n"
 "\n"
 " To continue a file transfer where it was previously aborted, curl supports\n"
@@ -1574,12 +1863,14 @@
 " Continue uploading a document(*1):\n"
 "\n"
 "        curl -c -T file ftp://ftp.server.com/path/file\n"
 "\n"
 " Continue downloading a document from a web server(*2):\n"
 "\n"
+);
+ puts(
 "        curl -c -o file http://www.server.com/\n"
 "\n"
 " (*1) = This requires that the ftp server supports the non-standard command\n"
 "        SIZE. If it doesn't, curl will say so.\n"
 "\n"
 " (*2) = This requires that the wb server supports at least HTTP/1.1. If it\n"
@@ -1588,23 +1879,27 @@
 "TIME CONDITIONS\n"
 "\n"
 " HTTP allows a client to specify a time condition for the document it\n"
 " requests. It is If-Modified-Since or If-Unmodified-Since. Curl allow you to\n"
 " specify them with the -z/--time-cond flag.\n"
 "\n"
+);
+ puts(
 " For example, you can easily make a download that only gets performed if the\n"
 " remote file is newer than a local copy. It would be made like:\n"
 "\n"
 "        curl -z local.html http://remote.server.com/remote.html\n"
 "\n"
 " Or you can download a file only if the local file is newer than the remote\n"
 " one. Do this by prepending the date string with a '-', as in:\n"
 "\n"
 "        curl -z -local.html http://remote.server.com/remote.html\n"
 "\n"
 " You can specify a \"free text\" date as condition. Tell curl to only download\n"
+);
+ puts(
 " the file if it was updated since yesterday:\n"
 "\n"
 "        curl -z yesterday http://remote.server.com/remote.html\n"
 "\n"
 " Curl will then accept a wide range of date formats. You always make the date\n"
 " check the other way around by prepending it with a dash '-'.\n"
@@ -1615,12 +1910,14 @@
 "\n"
 "        curl dict://dict.org/m:curl\n"
 "        curl dict://dict.org/d:heisenbug:jargon\n"
 "        curl dict://dict.org/d:daniel:web1913\n"
 "\n"
 "  Aliases for 'm' are 'match' and 'find', and aliases for 'd' are 'define'\n"
+);
+ puts(
 "  and 'lookup'. For example,\n"
 "\n"
 "        curl dict://dict.org/find:curl\n"
 "\n"
 "  Commands that break the URL description of the RFC (but not the DICT\n"
 "  protocol) are\n"
@@ -1633,12 +1930,14 @@
 "LDAP\n"
 "\n"
 "  If you have installed the OpenLDAP library, curl can take advantage of it\n"
 "  and offer ldap:// support.\n"
 "\n"
 "  LDAP is a complex thing and writing an LDAP query is not an easy task. I do\n"
+);
+ puts(
 "  advice you to dig up the syntax description for that elsewhere, RFC 1959 if\n"
 "  no other place is better.\n"
 "\n"
 "  To show you an example, this is now I can get all people from my local LDAP\n"
 "  server that has a certain sub-domain in their email address:\n"
 "\n"
@@ -1646,40 +1945,44 @@
 "\n"
 "  If I want the same info in HTML format, I can get it by not using the -B\n"
 "  (enforce ASCII) flag.\n"
 "\n"
 "ENVIRONMENT VARIABLES\n"
 "\n"
+);
+ puts(
 "  Curl reads and understands the following environment variables:\n"
 "\n"
 "        HTTP_PROXY, HTTPS_PROXY, FTP_PROXY, GOPHER_PROXY\n"
-);
- puts(
 "\n"
 "  They should be set for protocol-specific proxies. General proxy should be\n"
 "  set with\n"
 "        \n"
 "        ALL_PROXY\n"
 "\n"
 "  A comma-separated list of host names that shouldn't go through any proxy is\n"
 "  set in (only an asterisk, '*' matches all hosts)\n"
 "\n"
 "        NO_PROXY\n"
 "\n"
 "  If a tail substring of the domain-path for a host matches one of these\n"
+);
+ puts(
 "  strings, transactions with that node will not be proxied.\n"
 "\n"
 "\n"
 "  The usage of the -x/--proxy flag overrides the environment variables.\n"
 "\n"
 "NETRC\n"
 "\n"
 "  Unix introduced the .netrc concept a long time ago. It is a way for a user\n"
 "  to specify name and password for commonly visited ftp sites in a file so\n"
 "  that you don't have to type them in each time you visit those sites. You\n"
 "  realize this is a big security risk if someone else gets hold of your\n"
+);
+ puts(
 "  passwords, so therefor most unix programs won't read this file unless it is\n"
 "  only readable by yourself (curl doesn't care though).\n"
 "\n"
 "  Curl supports .netrc files if told so (using the -n/--netrc option). This is\n"
 "  not restricted to only ftp, but curl can use it for all protocols where\n"
 "  authentication is used.\n"
@@ -1687,24 +1990,28 @@
 "  A very simple .netrc file could look something like:\n"
 "\n"
 "        machine curl.haxx.se login iamdaniel password mysecret\n"
 "\n"
 "CUSTOM OUTPUT\n"
 "\n"
+);
+ puts(
 "  To better allow script programmers to get to know about the progress of\n"
 "  curl, the -w/--write-out option was introduced. Using this, you can specify\n"
 "  what information from the previous transfer you want to extract.\n"
 "\n"
 "  To display the amount of bytes downloaded together with some text and an\n"
 "  ending newline:\n"
 "\n"
 "        curl -w 'We downloaded %{size_download} bytes\\n' www.download.com\n"
 "\n"
 "KERBEROS4 FTP TRANSFER\n"
 "\n"
 "  Curl supports kerberos4 for FTP transfers. You need the kerberos package\n"
+);
+ puts(
 "  installed and used at curl build time for it to be used.\n"
 "\n"
 "  First, get the krb-ticket the normal way, like with the kauth tool. Then use\n"
 "  curl in way similar to:\n"
 "\n"
 "        curl --krb4 private ftp://krb4site.com -u username:fakepwd\n"
@@ -1712,37 +2019,72 @@
 "  There's no use for a password on the -u switch, but a blank one will make\n"
 "  curl ask for one and you already entered the real password to kauth.\n"
 "\n"
 "TELNET\n"
 "\n"
 "  The curl telnet support is basic and very easy to use. Curl passes all data\n"
+);
+ puts(
 "  passed to it on stdin to the remote server. Connect to a remote telnet\n"
 "  server using a command line similar to:\n"
 "\n"
 "        curl telnet://remote.server.com\n"
 "\n"
 "  And enter the data to pass to the server on stdin. The result will be sent\n"
 "  to stdout or to the file you specify with -o.\n"
 "\n"
 "  You might want the -N/--no-buffer option to switch off the buffered output\n"
 "  for slow connections or similar.\n"
 "\n"
 "  NOTE: the telnet protocol does not specify any way to login with a specified\n"
+);
+ puts(
 "  user and password so curl can't do that automatically. To do that, you need\n"
 "  to track when the login prompt is received and send the username and\n"
 "  password accordingly.\n"
 "\n"
-"MAILING LIST\n"
+"PERSISTANT CONNECTIONS\n"
+"\n"
+"  Specifying multiple files on a single command line will make curl transfer\n"
+"  all of them, one after the other in the specified order.\n"
 "\n"
-"  We have an open mailing list to discuss curl, its development and things\n"
-"  relevant to this.\n"
+"  libcurl will attempt to use persistant connections for the transfers so that\n"
+"  the second transfer to the same host can use the same connection that was\n"
+);
+ puts(
+"  already initiated and was left open in the previous transfer. This greatly\n"
+"  decreases connection time for all but the first transfer and it makes a far\n"
+"  better use of the network.\n"
+"\n"
+"  Note that curl cannot use persistant connections for transfers that are used\n"
+"  in subsequence curl invokes. Try to stuff as many URLs as possible on the\n"
+"  same command line if they are using the same host, as that'll make the\n"
+"  transfers faster. If you use a http proxy for file transfers, practicly\n"
+);
+ puts(
+"  all transfers will be persistant.\n"
+"\n"
+"  Persistant connections were introduced in curl 7.7.\n"
 "\n"
-"  To subscribe, mail curl-request@contactor.se with \"subscribe <fill in your\n"
-"  email address>\" in the body.\n"
+"MAILING LISTS\n"
 "\n"
-"  To post to the list, mail curl@contactor.se.\n"
+"  For your convenience, we have several open mailing lists to discuss curl,\n"
+"  its development and things relevant to this.\n"
+"\n"
+"  To subscribe to the main curl list, mail curl-request@contactor.se with\n"
+"  \"subscribe <fill in your email address>\" in the body.\n"
+"\n"
+"  To subscribe to the curl-library users/deverlopers list, follow the\n"
+"  instructions at http://curl.haxx.se/mail/\n"
+"\n"
+);
+ puts(
+"  To subscribe to the curl-announce list, to only get information about new\n"
+"  releases, follow the instructions at http://curl.haxx.se/mail/\n"
 "\n"
-"  To unsubcribe, mail curl-request@contactor.se with \"unsubscribe <your\n"
-"  subscribed email address>\" in the body.\n"
+"  To subscribe to the curl-and-PHP list in which curl using with PHP is\n"
+"  discussed, follow the instructions at http://curl.haxx.se/mail/\n"
 "\n"
+"  Please direct curl questions, feature requests and trouble reports to one of\n"
+"  these mailing lists instead of mailing any individual.\n"
  ) ;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/main.c	2001-01-29 15:26:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/main.c	2001-03-16 23:21:44.000000000 +0800
@@ -15,39 +15,32 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: main.c,v 1.68 2001/01/29 07:26:50 bagder Exp $
+ * $Id: main.c,v 1.75 2001/03/16 15:21:26 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdarg.h>
 #include <sys/stat.h>
 #include <ctype.h>
 
 #include <curl/curl.h>
-#include <curl/types.h> /* new for v7 */
-#include <curl/easy.h> /* new for v7 */
 
 #define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "urlglob.h"
 #include "writeout.h"
 
 #define CURLseparator	"--_curl_--"
 
-/* This define make use of the "Curlseparator" as opposed to the
-   MIMEseparator. We might add support for the latter one in the
-   future, and that's why this is left in the source. */
-#define CURL_SEPARATORS
-
 /* This is now designed to have its own local setup.h */
 #include "setup.h"
 
 #if defined(WIN32)&&!defined(__CYGWIN32__)
 #include <winsock.h>
 #endif
@@ -99,22 +92,19 @@
 #define CONF_VERBOSE  (1<<5) /* talk a lot */
 #define CONF_HEADER   (1<<8) /* throw the header out too */
 #define CONF_NOPROGRESS (1<<10) /* shut off the progress meter */
 #define CONF_NOBODY   (1<<11) /* use HEAD to get http document */
 #define CONF_FAILONERROR (1<<12) /* no output on http error codes >= 300 */
 #define CONF_UPLOAD   (1<<14) /* this is an upload */
-#define CONF_POST     (1<<15) /* HTTP POST method */
 #define CONF_FTPLISTONLY (1<<16) /* Use NLST when listing ftp dir */
 #define CONF_FTPAPPEND (1<<20) /* Append instead of overwrite on upload! */
 #define CONF_NETRC    (1<<22)  /* read user+password from .netrc */
 #define CONF_FOLLOWLOCATION (1<<23) /* use Location: Luke! */
 #define CONF_GETTEXT  (1<<24) /* use ASCII/text for transfer */
 #define CONF_HTTPPOST (1<<25) /* multipart/form-data HTTP POST */
-#if 0
-#define CONF_PUT      (1<<27) /* PUT the input file */
-#endif
+
 #define CONF_MUTE     (1<<28) /* force NOPROGRESS */
 
 #ifndef HAVE_STRDUP
 /* Ultrix doesn't have strdup(), so make a quick clone: */
 char *strdup(char *str)
 {
@@ -242,83 +232,89 @@
   printf(CURL_ID "%s\n"
        "Usage: curl [options...] <url>\n"
        "Options: (H) means HTTP/HTTPS only, (F) means FTP only\n"
        " -a/--append        Append to target file when uploading (F)\n"
        " -A/--user-agent <string> User-Agent to send to server (H)\n"
        " -b/--cookie <name=string/file> Cookie string or file to read cookies from (H)\n"
-       " -B/--use-ascii     Use ASCII/text transfer\n"
-       " -C/--continue-at <offset> Specify absolute resume offset\n"
+       " -B/--use-ascii     Use ASCII/text transfer\n",
+         curl_version());
+  puts(" -C/--continue-at <offset> Specify absolute resume offset\n"
        " -d/--data <data>   HTTP POST data (H)\n"
        "    --data-ascii <data>   HTTP POST ASCII data (H)\n"
        "    --data-binary <data>  HTTP POST binary data (H)\n"
        " -D/--dump-header <file> Write the headers to this file\n"
-       " -e/--referer       Referer page (H)\n"
-       " -E/--cert <cert[:passwd]> Specifies your certificate file and password (HTTPS)\n"
+       "    --egd-file <file> EGD socket path for random data (SSL)\n"
+       " -e/--referer       Referer page (H)");
+  puts(" -E/--cert <cert[:passwd]> Specifies your certificate file and password (HTTPS)\n"
        "    --cacert <file> CA certifciate to verify peer against (HTTPS)\n"
+       "    --connect-timeout <seconds> Maximum time allowed for connection\n"
        " -f/--fail          Fail silently (no output at all) on errors (H)\n"
        " -F/--form <name=content> Specify HTTP POST data (H)\n"
        " -g/--globoff       Disable URL sequences and ranges using {} and []\n"
        " -h/--help          This help text\n"
-       " -H/--header <line> Custom header to pass to server. (H)\n"
-       " -i/--include       Include the HTTP-header in the output (H)\n"
+       " -H/--header <line> Custom header to pass to server. (H)");
+  puts(" -i/--include       Include the HTTP-header in the output (H)\n"
        " -I/--head          Fetch document info only (HTTP HEAD/FTP SIZE)\n"
        "    --interface <interface> Specify the interface to be used\n"
        "    --krb4 <level>  Enable krb4 with specified security level (F)\n"
        " -K/--config        Specify which config file to read\n"
-       " -l/--list-only     List only names of an FTP directory (F)\n"
-       " -L/--location      Follow Location: hints (H)\n"
+       " -l/--list-only     List only names of an FTP directory (F)");
+  puts(" -L/--location      Follow Location: hints (H)\n"
        " -m/--max-time <seconds> Maximum time allowed for the transfer\n"
        " -M/--manual        Display huge help text\n"
        " -n/--netrc         Read .netrc for user name and password\n"
-       " -N/--no-buffer     Disables the buffering of the output stream\n"
-       " -o/--output <file> Write output to <file> instead of stdout\n"
+       " -N/--no-buffer     Disables the buffering of the output stream");
+  puts(" -o/--output <file> Write output to <file> instead of stdout\n"
        " -O/--remote-name   Write output to a file named as the remote file\n"
        " -p/--proxytunnel   Perform non-HTTP services through a HTTP proxy\n"
        " -P/--ftpport <address> Use PORT with address instead of PASV when ftping (F)\n"
        " -q                 When used as the first parameter disables .curlrc\n"
-       " -Q/--quote <cmd>   Send QUOTE command to FTP before file transfer (F)\n"
-       " -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server\n"
+       " -Q/--quote <cmd>   Send QUOTE command to FTP before file transfer (F)");
+  puts(" -r/--range <range> Retrieve a byte range from a HTTP/1.1 or FTP server\n"
        " -s/--silent        Silent mode. Don't output anything\n"
        " -S/--show-error    Show error. With -s, make curl show errors when they occur\n"
+       "    --stderr <file> Where to redirect stderr. - means stdout.\n"
+       " -t/--telnet-option <OPT=val> Set telnet option\n"
        " -T/--upload-file <file> Transfer/upload <file> to remote site\n"
-       "    --url <URL>     Another way to specify URL to work with\n"
-       " -u/--user <user[:password]> Specify user and password to use\n"
+       "    --url <URL>     Another way to specify URL to work with");
+  puts(" -u/--user <user[:password]> Specify user and password to use\n"
        " -U/--proxy-user <user[:password]> Specify Proxy authentication\n"
        " -v/--verbose       Makes the operation more talkative\n"
        " -V/--version       Outputs version number then quits\n"
        " -w/--write-out [format] What to output after completion\n"
        " -x/--proxy <host[:port]>  Use proxy. (Default port is 1080)\n"
-       " -X/--request <command> Specific request command to use\n"
-       " -y/--speed-time    Time needed to trig speed-limit abort. Defaults to 30\n"
+       "    --random-file <file> File to use for reading random data from (SSL)\n"
+       " -X/--request <command> Specific request command to use");
+  puts(" -y/--speed-time    Time needed to trig speed-limit abort. Defaults to 30\n"
        " -Y/--speed-limit   Stop transfer if below speed-limit for 'speed-time' secs\n"
        " -z/--time-cond <time> Includes a time condition to the server (H)\n"
        " -Z/--max-redirs <num> Set maximum number of redirections allowed (H)\n"
        " -2/--sslv2         Force usage of SSLv2 (H)\n"
-       " -3/--sslv3         Force usage of SSLv3 (H)\n"
-       " -#/--progress-bar  Display transfer progress as a progress bar\n"
-       "    --crlf          Convert LF to CRLF in upload. Useful for MVS (OS/390)\n"
-       "    --stderr <file> Where to redirect stderr. - means stdout.\n",
-         curl_version()
-         );
+       " -3/--sslv3         Force usage of SSLv3 (H)");
+  puts(" -#/--progress-bar  Display transfer progress as a progress bar\n"
+       "    --crlf          Convert LF to CRLF in upload. Useful for MVS (OS/390)");
 }
 
 struct LongShort {
   char *letter;
   char *lname;
   bool extraparam;
 };
 
 struct Configurable {
+  char *random_file;
+  char *egd_file;
   char *useragent;
   char *cookie;
   bool use_resume;
   int resume_from;
   char *postfields;
   long postfieldsize;
   char *referer;
   long timeout;
+  long connecttimeout;
   long maxredirs;
   char *headerfile;
   char *ftpport;
   char *iface;
   unsigned short porttouse;
   char *range;
@@ -363,12 +359,14 @@
 
   struct curl_slist *headers;
 
   struct HttpPost *httppost;
   struct HttpPost *last_post;
 
+  struct curl_slist *telnet_options;
+        
   HttpReq httpreq;
 };
 
 static int parseconfig(char *filename,
 		       struct Configurable *config);
 static char *my_get_line(FILE *fp);
@@ -522,12 +520,15 @@
   struct LongShort aliases[]= {
     {"9", "crlf",        FALSE},
     {"8", "stderr",      TRUE},
     {"7", "interface",   TRUE},
     {"6", "krb4",        TRUE},
     {"5", "url",         TRUE},
+    {"5a", "random-file", TRUE},
+    {"5b", "egd-file",   TRUE},
+    {"5c", "connect-timeout", TRUE},
 
     {"2", "sslv2",       FALSE},
     {"3", "sslv3",       FALSE},
     {"a", "append",      FALSE},
     {"A", "user-agent",  TRUE},
     {"b", "cookie",      TRUE},
@@ -562,13 +563,13 @@
     {"P", "ftpport",     TRUE},
     {"q", "disable",     FALSE},
     {"Q", "quote",       TRUE},
     {"r", "range",       TRUE},
     {"s", "silent",      FALSE},
     {"S", "show-error",  FALSE},
-    {"t", "upload",      FALSE},
+    {"t", "telnet-options", TRUE},
     {"T", "upload-file", TRUE},
     {"u", "user",        TRUE},
     {"U", "proxy-user",  TRUE},
     {"v", "verbose",     FALSE},
     {"V", "version",     FALSE},
     {"w", "write-out",   TRUE},
@@ -671,35 +672,46 @@
       break;
     case '6': /* there is no short letter for this */
       /* krb4 level string */
       GetStr(&config->krb4level, nextarg);
       break;
     case '5':
-      /* the URL! */
-      {
-        struct getout *url;
-        if(config->url_get || (config->url_get=config->url_list)) {
-          /* there's a node here, if it already is filled-in continue to find
-             an "empty" node */
-          while(config->url_get && (config->url_get->flags&GETOUT_URL))
-            config->url_get = config->url_get->next;
-        }
-
-        /* now there might or might not be an available node to fill in! */
+      switch(subletter) {
+      case 'a': /* random-file */
+        GetStr(&config->random_file, nextarg);
+        break;
+      case 'b': /* egd-file */
+        GetStr(&config->egd_file, nextarg);
+        break;
+      case 'c': /* connect-timeout */
+        config->connecttimeout=atoi(nextarg);
+        break;
+      default: /* the URL! */
+        {
+          struct getout *url;
+          if(config->url_get || (config->url_get=config->url_list)) {
+            /* there's a node here, if it already is filled-in continue to find
+               an "empty" node */
+            while(config->url_get && (config->url_get->flags&GETOUT_URL))
+              config->url_get = config->url_get->next;
+          }
 
-        if(config->url_get)
-          /* existing node */
-          url = config->url_get;
-        else
-          /* there was no free node, create one! */
-          url=new_getout(config);
+          /* now there might or might not be an available node to fill in! */
 
-        if(url) {
-          /* fill in the URL */
-          GetStr(&url->url, nextarg);
-          url->flags |= GETOUT_URL;
+          if(config->url_get)
+            /* existing node */
+            url = config->url_get;
+          else
+            /* there was no free node, create one! */
+            url=new_getout(config);
+          
+          if(url) {
+            /* fill in the URL */
+            GetStr(&url->url, nextarg);
+            url->flags |= GETOUT_URL;
+          }
         }
       }
       break;
     case '#': /* added 19990617 larsa */
       config->progressmode ^= CURL_PROGRESS_BAR;
       break;
@@ -782,14 +794,13 @@
           free(oldpost);
           free(postdata);
         }
         else
           config->postfields=postdata;
       }
-      if(config->postfields)
-        config->conf |= CONF_POST;
+
       if(SetHTTPrequest(HTTPREQ_SIMPLEPOST, &config->httpreq))
         return PARAM_BAD_USE;
       break;
     case 'D':
       /* dump-header to given file name */
       GetStr(&config->headerfile, nextarg);
@@ -956,15 +967,14 @@
       break;
     case 'S':
       /* show errors */
       config->showerror ^= TRUE; /* toggle on if used with -s */
       break;
     case 't':
-      /* we are uploading */
-      config->conf ^= CONF_UPLOAD;
-      fprintf(stderr, "-t is a deprecated switch, use '-T -' instead!\n");
+      /* Telnet options */
+      config->telnet_options = curl_slist_append(config->telnet_options, nextarg);
       break;
     case 'T':
       /* we are uploading */
       config->conf |= CONF_UPLOAD;
       if(!strequal("-", nextarg))
         /* make - equal stdin */
@@ -1367,12 +1377,16 @@
 #endif
 
 }
 
 void free_config_fields(struct Configurable *config)
 {
+  if(config->random_file)
+    free(config->random_file);
+  if(config->egd_file)
+    free(config->egd_file);
   if(config->userpwd)
     free(config->userpwd);
   if(config->postfields)
     free(config->postfields);
   if(config->proxy)
     free(config->proxy);
@@ -1440,29 +1454,24 @@
 
 #ifdef MALLOCDEBUG
   /* this sends all memory debug messages to a logfile named memdump */
   curl_memdebug("memdump");
 #endif
 
+  main_init(); /* inits winsock crap for windows */
+
   config->showerror=TRUE;
   config->conf=CONF_DEFAULT;
-#if 0
-  config->crlf=FALSE;
-  config->quote=NULL;
-#endif
 
   if(argc>1 &&
      (!strnequal("--", argv[1], 2) && (argv[1][0] == '-')) &&
      strchr(argv[1], 'q')) {
     /*
      * The first flag, that is not a verbose name, but a shortname
      * and it includes the 'q' flag!
      */
-#if 0
-    fprintf(stderr, "I TURNED OFF THE CRAP\n");
-#endif
     ;
   }
   else {
     res = parseconfig(NULL, config);
     if(res)
       return res;
@@ -1536,12 +1545,21 @@
              CURL_NAME "/" CURL_VERSION " (" OS ") " "%s", curl_version());
     config->useragent= useragent;
   }
   else
     allocuseragent = TRUE;
 
+  /*
+   * Get a curl handle to use for all forthcoming curl transfers.  Cleanup
+   * when all transfers are done. This is supported with libcurl 7.7 and
+   * should not be attempted on previous versions.
+   */
+  curl = curl_easy_init();
+  if(!curl)
+    return CURLE_FAILED_INIT;
+
   urlnode = config->url_list;
 
   /* loop through the list of given URLs */
   while(urlnode) {
 
     /* get the full URL (it might be NULL) */
@@ -1721,128 +1739,120 @@
            then set stdout to be binary */
         setmode( 1, O_BINARY );
       }
 #endif
 
 
-      main_init();
-
-      curl = curl_easy_init();
-      if(curl) {
-        curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs); /* where to store */
-        /* what call to write: */
-        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
-        curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
-        /* size of uploaded file: */
-        curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
-        curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
-        curl_easy_setopt(curl, CURLOPT_PROXY, config->proxy); /* proxy to use */
-        curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
-        curl_easy_setopt(curl, CURLOPT_HEADER, config->conf&CONF_HEADER);
-        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config->conf&CONF_NOPROGRESS);
-        curl_easy_setopt(curl, CURLOPT_NOBODY, config->conf&CONF_NOBODY);
-        curl_easy_setopt(curl, CURLOPT_FAILONERROR,
-                         config->conf&CONF_FAILONERROR);
-        curl_easy_setopt(curl, CURLOPT_UPLOAD, config->conf&CONF_UPLOAD);
-        curl_easy_setopt(curl, CURLOPT_POST, config->conf&CONF_POST);
-        curl_easy_setopt(curl, CURLOPT_FTPLISTONLY,
-                         config->conf&CONF_FTPLISTONLY);
-        curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config->conf&CONF_FTPAPPEND);
-        curl_easy_setopt(curl, CURLOPT_NETRC, config->conf&CONF_NETRC);
-        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
-                         config->conf&CONF_FOLLOWLOCATION);
-        curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config->conf&CONF_GETTEXT);
-#if 0
-        curl_easy_setopt(curl, CURLOPT_PUT, config->conf&CONF_PUT);
-#endif
-        curl_easy_setopt(curl, CURLOPT_MUTE, config->conf&CONF_MUTE);
-        curl_easy_setopt(curl, CURLOPT_USERPWD, config->userpwd);
-        curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);
-        curl_easy_setopt(curl, CURLOPT_RANGE, config->range);
-        curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
-        curl_easy_setopt(curl, CURLOPT_TIMEOUT, config->timeout);
-        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, config->postfields);
+      curl_easy_setopt(curl, CURLOPT_FILE, (FILE *)&outs); /* where to store */
+      /* what call to write: */
+      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, my_fwrite);
+      curl_easy_setopt(curl, CURLOPT_INFILE, infd); /* for uploads */
+      /* size of uploaded file: */
+      curl_easy_setopt(curl, CURLOPT_INFILESIZE, infilesize);
+      curl_easy_setopt(curl, CURLOPT_URL, url);     /* what to fetch */
+      curl_easy_setopt(curl, CURLOPT_PROXY, config->proxy); /* proxy to use */
+      curl_easy_setopt(curl, CURLOPT_VERBOSE, config->conf&CONF_VERBOSE);
+      curl_easy_setopt(curl, CURLOPT_HEADER, config->conf&CONF_HEADER);
+      curl_easy_setopt(curl, CURLOPT_NOPROGRESS, config->conf&CONF_NOPROGRESS);
+      curl_easy_setopt(curl, CURLOPT_NOBODY, config->conf&CONF_NOBODY);
+      curl_easy_setopt(curl, CURLOPT_FAILONERROR,
+                       config->conf&CONF_FAILONERROR);
+      curl_easy_setopt(curl, CURLOPT_UPLOAD, config->conf&CONF_UPLOAD);
+      curl_easy_setopt(curl, CURLOPT_FTPLISTONLY,
+                       config->conf&CONF_FTPLISTONLY);
+      curl_easy_setopt(curl, CURLOPT_FTPAPPEND, config->conf&CONF_FTPAPPEND);
+      curl_easy_setopt(curl, CURLOPT_NETRC, config->conf&CONF_NETRC);
+      curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION,
+                       config->conf&CONF_FOLLOWLOCATION);
+      curl_easy_setopt(curl, CURLOPT_TRANSFERTEXT, config->conf&CONF_GETTEXT);
+      curl_easy_setopt(curl, CURLOPT_MUTE, config->conf&CONF_MUTE);
+      curl_easy_setopt(curl, CURLOPT_USERPWD, config->userpwd);
+      curl_easy_setopt(curl, CURLOPT_PROXYUSERPWD, config->proxyuserpwd);
+      curl_easy_setopt(curl, CURLOPT_RANGE, config->range);
+      curl_easy_setopt(curl, CURLOPT_ERRORBUFFER, errorbuffer);
+      curl_easy_setopt(curl, CURLOPT_TIMEOUT, config->timeout);
+      curl_easy_setopt(curl, CURLOPT_POSTFIELDS, config->postfields);
         
-        /* new in libcurl 7.2: */
-        curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, config->postfieldsize);
+      /* new in libcurl 7.2: */
+      curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, config->postfieldsize);
         
-        curl_easy_setopt(curl, CURLOPT_REFERER, config->referer);
-        curl_easy_setopt(curl, CURLOPT_AUTOREFERER,
-                         config->conf&CONF_AUTO_REFERER);
-        curl_easy_setopt(curl, CURLOPT_USERAGENT, config->useragent);
-        curl_easy_setopt(curl, CURLOPT_FTPPORT, config->ftpport);
-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, config->low_speed_limit);
-        curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, config->low_speed_time);
-        curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
-                         config->use_resume?config->resume_from:0);
-        curl_easy_setopt(curl, CURLOPT_COOKIE, config->cookie);
-        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config->headers);
-        curl_easy_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
-        curl_easy_setopt(curl, CURLOPT_SSLCERT, config->cert);
-        curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config->cert_passwd);
-
-        if(config->cacert) {
-          /* available from libcurl 7.5: */
-          curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
-          curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE);
-        }
-
-        if(config->conf&(CONF_NOBODY|CONF_USEREMOTETIME)) {
-          /* no body or use remote time */
-          /* new in 7.5 */
-          curl_easy_setopt(curl, CURLOPT_FILETIME, TRUE);
-        }
+      curl_easy_setopt(curl, CURLOPT_REFERER, config->referer);
+      curl_easy_setopt(curl, CURLOPT_AUTOREFERER,
+                       config->conf&CONF_AUTO_REFERER);
+      curl_easy_setopt(curl, CURLOPT_USERAGENT, config->useragent);
+      curl_easy_setopt(curl, CURLOPT_FTPPORT, config->ftpport);
+      curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, config->low_speed_limit);
+      curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, config->low_speed_time);
+      curl_easy_setopt(curl, CURLOPT_RESUME_FROM,
+                       config->use_resume?config->resume_from:0);
+      curl_easy_setopt(curl, CURLOPT_COOKIE, config->cookie);
+      curl_easy_setopt(curl, CURLOPT_HTTPHEADER, config->headers);
+      curl_easy_setopt(curl, CURLOPT_HTTPPOST, config->httppost);
+      curl_easy_setopt(curl, CURLOPT_SSLCERT, config->cert);
+      curl_easy_setopt(curl, CURLOPT_SSLCERTPASSWD, config->cert_passwd);
+
+      if(config->cacert) {
+        /* available from libcurl 7.5: */
+        curl_easy_setopt(curl, CURLOPT_CAINFO, config->cacert);
+        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, TRUE);
+      }
       
-        /* 7.5 news: */
-        if (config->maxredirs) 
-          curl_easy_setopt(curl, CURLOPT_MAXREDIRS, config->maxredirs); 
-        else 
-          curl_easy_setopt(curl, CURLOPT_MAXREDIRS, DEFAULT_MAXREDIRS); 
+      if(config->conf&(CONF_NOBODY|CONF_USEREMOTETIME)) {
+        /* no body or use remote time */
+        /* new in 7.5 */
+        curl_easy_setopt(curl, CURLOPT_FILETIME, TRUE);
+      }
+      
+      /* 7.5 news: */
+      if (config->maxredirs) 
+        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, config->maxredirs); 
+      else 
+        curl_easy_setopt(curl, CURLOPT_MAXREDIRS, DEFAULT_MAXREDIRS); 
  
-        curl_easy_setopt(curl, CURLOPT_CRLF, config->crlf);
-        curl_easy_setopt(curl, CURLOPT_QUOTE, config->quote);
-        curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config->postquote);
-        curl_easy_setopt(curl, CURLOPT_WRITEHEADER,
-                         config->headerfile?&heads:NULL);
-        curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config->cookiefile);
-        curl_easy_setopt(curl, CURLOPT_SSLVERSION, config->ssl_version);
-        curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config->timecond);
-        curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config->condtime);
-        curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);
-        curl_easy_setopt(curl, CURLOPT_STDERR, config->errors);
+      curl_easy_setopt(curl, CURLOPT_CRLF, config->crlf);
+      curl_easy_setopt(curl, CURLOPT_QUOTE, config->quote);
+      curl_easy_setopt(curl, CURLOPT_POSTQUOTE, config->postquote);
+      curl_easy_setopt(curl, CURLOPT_WRITEHEADER,
+                       config->headerfile?&heads:NULL);
+      curl_easy_setopt(curl, CURLOPT_COOKIEFILE, config->cookiefile);
+      curl_easy_setopt(curl, CURLOPT_SSLVERSION, config->ssl_version);
+      curl_easy_setopt(curl, CURLOPT_TIMECONDITION, config->timecond);
+      curl_easy_setopt(curl, CURLOPT_TIMEVALUE, config->condtime);
+      curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, config->customrequest);
+      curl_easy_setopt(curl, CURLOPT_STDERR, config->errors);
       
-        /* three new ones in libcurl 7.3: */
-        curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config->proxytunnel);
-        curl_easy_setopt(curl, CURLOPT_INTERFACE, config->iface);
-        curl_easy_setopt(curl, CURLOPT_KRB4LEVEL, config->krb4level);
-
-        if((config->progressmode == CURL_PROGRESS_BAR) &&
-           !(config->conf&(CONF_NOPROGRESS|CONF_MUTE))) {
-          /* we want the alternative style, then we have to implement it
-             ourselves! */
-          progressbarinit(&progressbar);
-          curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, myprogress);
-          curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &progressbar);
-        }
-        
-        res = curl_easy_perform(curl);
-        
-        if(config->writeout) {
-          ourWriteOut(curl, config->writeout);
-        }
+      /* three new ones in libcurl 7.3: */
+      curl_easy_setopt(curl, CURLOPT_HTTPPROXYTUNNEL, config->proxytunnel);
+      curl_easy_setopt(curl, CURLOPT_INTERFACE, config->iface);
+      curl_easy_setopt(curl, CURLOPT_KRB4LEVEL, config->krb4level);
+      
+      if((config->progressmode == CURL_PROGRESS_BAR) &&
+         !(config->conf&(CONF_NOPROGRESS|CONF_MUTE))) {
+        /* we want the alternative style, then we have to implement it
+           ourselves! */
+        progressbarinit(&progressbar);
+        curl_easy_setopt(curl, CURLOPT_PROGRESSFUNCTION, myprogress);
+        curl_easy_setopt(curl, CURLOPT_PROGRESSDATA, &progressbar);
+      }
         
-        /* always cleanup */
-        curl_easy_cleanup(curl);
+      /* new in libcurl 7.6.2: */
+      curl_easy_setopt(curl, CURLOPT_TELNETOPTIONS, config->telnet_options);
+
+      /* new in libcurl 7.7: */
+      curl_easy_setopt(curl, CURLOPT_RANDOM_FILE, config->random_file);
+      curl_easy_setopt(curl, CURLOPT_EGDSOCKET, config->egd_file);
+      curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, config->connecttimeout);
+      
+      res = curl_easy_perform(curl);
         
-        if((res!=CURLE_OK) && config->showerror)
-          fprintf(config->errors, "curl: (%d) %s\n", res, errorbuffer);
+      if(config->writeout) {
+        ourWriteOut(curl, config->writeout);
       }
-      else
-        fprintf(config->errors, "curl: failed to init libcurl!\n");
-
-      main_free();
+        
+      if((res!=CURLE_OK) && config->showerror)
+        fprintf(config->errors, "curl: (%d) %s\n", res, errorbuffer);
 
       if((config->errors != stderr) &&
          (config->errors != stdout))
         /* it wasn't directed to stdout or stderr so close the file! */
         fclose(config->errors);
     
@@ -1884,12 +1894,17 @@
 
   } /* while-loop through all URLs */
 
   if(allocuseragent)
     free(config->useragent);
 
+  /* cleanup the curl handle! */
+  curl_easy_cleanup(curl);
+
+  main_free(); /* cleanup the winsock stuff for windows */
+
   return res;
 }
 
 
 int main(int argc, char *argv[])
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/Makefile.in	2001-02-13 21:35:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/Makefile.in	2001-03-22 23:42:56.000000000 +0800
@@ -73,12 +73,13 @@
 LIBTOOL = @LIBTOOL@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 INCLUDES = -I$(top_srcdir)/include
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/mkhelp.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/mkhelp.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/mkhelp.pl	2000-05-23 18:29:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/mkhelp.pl	2001-03-10 00:50:39.000000000 +0800
@@ -72,23 +72,23 @@
 $outsize=0;
 for(@out) {
     chop;
 
     $new = $_;
 
-    $outsize += length($new);
+    $outsize += length($new)+1; # one for the newline
 
     $new =~ s/\\/\\\\/g;
     $new =~ s/\"/\\\"/g;
 
-    printf("\"%s\\n\"\n", $new);
-
-    if($outsize > 10000) {
+    # gcc 2.96 claims ISO C89 only is required to support 509 letter strings
+    if($outsize > 500) {
         # terminate and make another puts() call here
         print ");\n puts(\n";
-        $outsize=0;
+        $outsize=length($new)+1;
     }
+    printf("\"%s\\n\"\n", $new);
 
 }
 
 print " ) ;\n}\n"
     
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/version.h	2001-02-13 21:35:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/version.h	2001-03-22 23:42:20.000000000 +0800
@@ -1,3 +1,3 @@
 #define CURL_NAME "curl"
-#define CURL_VERSION "7.6.1"
+#define CURL_VERSION "7.7"
 #define CURL_ID CURL_NAME " " CURL_VERSION " (" OS ") "
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/writeout.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/writeout.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/src/writeout.c	2001-01-03 17:29:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/src/writeout.c	2001-03-14 18:27:13.000000000 +0800
@@ -15,21 +15,19 @@
  * furnished to do so, under the terms of the MPL or the MIT/X-derivate
  * licenses. You may pick one of these licenses.
  *
  * This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
  * KIND, either express or implied.
  *
- * $Id: writeout.c,v 1.4 2001/01/03 09:29:34 bagder Exp $
+ * $Id: writeout.c,v 1.5 2001/03/14 10:27:13 bagder Exp $
  *****************************************************************************/
 
 #include <stdio.h>
 #include <string.h>
 
 #include <curl/curl.h>
-#include <curl/types.h>
-#include <curl/easy.h>
 
 #define _MPRINTF_REPLACE /* we want curl-functions instead of native ones */
 #include <curl/mprintf.h>
 
 #include "writeout.h"
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/command26.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/command26.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/command26.txt	2001-01-09 20:00:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/command26.txt	2001-03-13 20:35:50.000000000 +0800
@@ -1,4 +1,4 @@
-http://%HOSTIP:%HOSTPORT/want/25 -o - -o -
+http://%HOSTIP:%HOSTPORT/want/26 -o - -o -
 
 
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: command34.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: command35.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: command36.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: command37.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: command38.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: command39.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: error36.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/Makefile.am /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/Makefile.am
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/Makefile.am	2001-01-29 22:36:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/Makefile.am	2001-03-19 16:35:38.000000000 +0800
@@ -1,65 +1,71 @@
 all:
 install:
 
 test:
 	[ -f command1.txt ] || ln -s $(srcdir)/*.txt .
 
-EXTRA_DIST = command1.txt      error113.txt      name17.txt        prot8.txt \
-command10.txt     error114.txt      name18.txt        prot9.txt \
-command100.txt    error115.txt      name19.txt        reply1.txt \
-command101.txt    error116.txt      name2.txt         reply10.txt \
-command102.txt    error117.txt      name20.txt        reply100.txt \
-command103.txt    error118.txt      name200.txt       reply101.txt \
-command104.txt    error119.txt      name201.txt       reply102.txt \
-command105.txt    error19.txt       name21.txt        reply103.txt \
-command106.txt    error20.txt       name22.txt        reply104.txt \
-command107.txt    error201.txt      name23.txt        reply105.txt \
-command108.txt    error21.txt       name24.txt        reply106.txt \
-command109.txt    error23.txt       name25.txt        reply11.txt \
-command11.txt     error24.txt       name3.txt         reply110.txt \
-command110.txt    error25.txt       name4.txt         reply110001.txt \
-command111.txt    ftpd113.txt       name5.txt         reply110002.txt \
-command112.txt    ftpd114.txt       name6.txt         reply12.txt \
-command113.txt    ftpd115.txt       name7.txt         reply13.txt \
-command114.txt    ftpd116.txt       name8.txt         reply14.txt \
-command115.txt    ftpd117.txt       name9.txt         reply15.txt \
-command116.txt    ftpd118.txt       prot1.txt         reply16.txt \
-command117.txt    name1.txt         prot10.txt        reply17.txt \
-command118.txt    name10.txt        prot100.txt       reply2.txt \
-command119.txt    name100.txt       prot101.txt       reply200.txt \
-command12.txt     name101.txt       prot102.txt       reply22.txt \
-command13.txt     name102.txt       prot103.txt       reply24.txt \
-command14.txt     name103.txt       prot104.txt       reply25.txt \
-command15.txt     name104.txt       prot105.txt       reply3.txt \
-command16.txt     name105.txt       prot106.txt       reply4.txt \
-command17.txt     name106.txt       prot107.txt       reply5.txt \
-command18.txt     name107.txt       prot108.txt       reply6.txt \
-command19.txt     name108.txt       prot109.txt       reply7.txt \
-command2.txt      name109.txt       prot11.txt        reply8.txt \
-command20.txt     name11.txt        prot110.txt       reply9.txt \
-command200.txt    name110.txt       prot112.txt       stdin17.txt \
-command201.txt    name111.txt       prot12.txt        stdout107.txt \
-command21.txt     name112.txt       prot13.txt        stdout108.txt \
-command22.txt     name113.txt       prot14.txt        stdout109.txt \
-command23.txt     name114.txt       prot15.txt        stdout110.txt \
-command24.txt     name115.txt       prot16.txt        stdout112.txt \
-command25.txt     name116.txt       prot17.txt        stdout15.txt \
-command3.txt      name117.txt       prot18.txt        stdout18.txt \
-command4.txt      name118.txt       prot2.txt         upload107.txt \
-command5.txt      name119.txt       prot22.txt        upload108.txt \
-command6.txt      name12.txt        prot3.txt         upload109.txt \
-command7.txt      name13.txt        prot4.txt         upload112.txt \
-command8.txt      name14.txt        prot5.txt \
-command9.txt      name15.txt        prot6.txt \
-error111.txt      name16.txt        prot7.txt \
+EXTRA_DIST = command1.txt error113.txt name17.txt prot8.txt \
+command10.txt  error114.txt name18.txt  prot9.txt \
+command100.txt error115.txt name19.txt  reply1.txt \
+command101.txt error116.txt name2.txt   reply10.txt \
+command102.txt error117.txt name20.txt  reply100.txt \
+command103.txt error118.txt name200.txt reply101.txt \
+command104.txt error119.txt name201.txt reply102.txt \
+command105.txt error19.txt  name21.txt  reply103.txt \
+command106.txt error20.txt  name22.txt  reply104.txt \
+command107.txt error201.txt name23.txt  reply105.txt \
+command108.txt error21.txt  name24.txt  reply106.txt \
+command109.txt error23.txt  name25.txt  reply11.txt \
+command11.txt  error24.txt  name3.txt   reply110.txt \
+command110.txt error25.txt  name4.txt   reply110001.txt \
+command111.txt ftpd113.txt  name5.txt   reply110002.txt \
+command112.txt ftpd114.txt  name6.txt   reply12.txt \
+command113.txt ftpd115.txt  name7.txt   reply13.txt \
+command114.txt ftpd116.txt  name8.txt   reply14.txt \
+command115.txt ftpd117.txt  name9.txt   reply15.txt \
+command116.txt ftpd118.txt  prot1.txt   reply16.txt \
+command117.txt name1.txt    prot10.txt  reply17.txt \
+command118.txt name10.txt   prot100.txt reply2.txt \
+command119.txt name100.txt  prot101.txt reply200.txt \
+command12.txt  name101.txt  prot102.txt reply22.txt \
+command13.txt  name102.txt  prot103.txt reply24.txt \
+command14.txt  name103.txt  prot104.txt reply25.txt \
+command15.txt  name104.txt  prot105.txt reply3.txt \
+command16.txt  name105.txt  prot106.txt reply4.txt \
+command17.txt  name106.txt  prot107.txt reply5.txt \
+command18.txt  name107.txt  prot108.txt reply6.txt \
+command19.txt  name108.txt  prot109.txt reply7.txt \
+command2.txt   name109.txt  prot11.txt  reply8.txt \
+command20.txt  name11.txt   prot110.txt reply9.txt \
+command200.txt name110.txt  prot112.txt stdin17.txt \
+command201.txt name111.txt  prot12.txt  stdout107.txt \
+command21.txt  name112.txt  prot13.txt  stdout108.txt \
+command22.txt  name113.txt  prot14.txt  stdout109.txt \
+command23.txt  name114.txt  prot15.txt  stdout110.txt \
+command24.txt  name115.txt  prot16.txt  stdout112.txt \
+command25.txt  name116.txt  prot17.txt  stdout15.txt \
+command3.txt   name117.txt  prot18.txt  stdout18.txt \
+command4.txt   name118.txt  prot2.txt   upload107.txt \
+command5.txt   name119.txt  prot22.txt  upload108.txt \
+command6.txt   name12.txt   prot3.txt   upload109.txt \
+command7.txt   name13.txt   prot4.txt   upload112.txt \
+command8.txt   name14.txt   prot5.txt \
+command9.txt   name15.txt   prot6.txt \
+error111.txt   name16.txt   prot7.txt \
 command26.txt  prot26.txt     command27.txt  prot27.txt \
 name26.txt     reply26.txt    name27.txt     stdout27.txt \
 command28.txt  name28.txt     prot28.txt     reply28.txt \
 command120.txt  name120.txt     prot120.txt     reply120.txt \
 command121.txt  name121.txt     prot121.txt     reply121.txt \
 command29.txt  error30.txt  name30.txt  prot30.txt   reply30.txt \
 command30.txt  name29.txt   prot29.txt  reply29.txt \
 command31.txt  name32.txt  reply31.txt      reply32.txt \
 command32.txt  prot31.txt  reply310001.txt  reply320001.txt \
 name31.txt     prot32.txt  reply310002.txt  reply320002.txt \
-command33.txt  extra33.txt    name33.txt     prot33.txt     reply33.txt
+command33.txt  extra33.txt    name33.txt     prot33.txt     reply33.txt \
+command34.txt prot34.txt reply340001.txt name34.txt reply34.txt \
+command35.txt  name35.txt     prot35.txt     reply35.txt \
+command36.txt  error36.txt  name36.txt  reply36.txt \
+command37.txt  name37.txt  prot37.txt  reply37.txt \
+command38.txt prot38.txt reply380001.txt name38.txt reply38.txt \
+command39.txt prot39.txt reply390001.txt name39.txt reply39.txt reply390002.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/Makefile.in	2001-02-13 21:35:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/Makefile.in	2001-03-22 23:42:57.000000000 +0800
@@ -66,17 +66,18 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
-EXTRA_DIST = command1.txt      error113.txt      name17.txt        prot8.txt command10.txt     error114.txt      name18.txt        prot9.txt command100.txt    error115.txt      name19.txt        reply1.txt command101.txt    error116.txt      name2.txt         reply10.txt command102.txt    error117.txt      name20.txt        reply100.txt command103.txt    error118.txt      name200.txt       reply101.txt command104.txt    error119.txt      name201.txt       reply102.txt command105.txt    error19.txt       name21.txt        reply103.txt command106.txt    error20.txt       name22.txt        reply104.txt command107.txt    error201.txt      name23.txt        reply105.txt command108.txt    error21.txt       name24.txt        reply106.txt command109.txt    error23.txt       name25.txt        reply11.txt command11.txt     error24.txt       name3.txt         reply110.txt command110.txt    error25.txt       name4.txt         reply110001.txt command111.txt    ftpd113.txt       name5.txt         reply110002.txt command112.txt    ftpd114.txt       name6.txt         reply12.txt command113.txt    ftpd115.txt       name7.txt         reply13.txt command114.txt    ftpd116.txt       name8.txt         reply14.txt command115.txt    ftpd117.txt       name9.txt         reply15.txt command116.txt    ftpd118.txt       prot1.txt         reply16.txt command117.txt    name1.txt         prot10.txt        reply17.txt command118.txt    name10.txt        prot100.txt       reply2.txt command119.txt    name100.txt       prot101.txt       reply200.txt command12.txt     name101.txt       prot102.txt       reply22.txt command13.txt     name102.txt       prot103.txt       reply24.txt command14.txt     name103.txt       prot104.txt       reply25.txt command15.txt     name104.txt       prot105.txt       reply3.txt command16.txt     name105.txt       prot106.txt       reply4.txt command17.txt     name106.txt       prot107.txt       reply5.txt command18.txt     name107.txt       prot108.txt       reply6.txt command19.txt     name108.txt       prot109.txt       reply7.txt command2.txt      name109.txt       prot11.txt        reply8.txt command20.txt     name11.txt        prot110.txt       reply9.txt command200.txt    name110.txt       prot112.txt       stdin17.txt command201.txt    name111.txt       prot12.txt        stdout107.txt command21.txt     name112.txt       prot13.txt        stdout108.txt command22.txt     name113.txt       prot14.txt        stdout109.txt command23.txt     name114.txt       prot15.txt        stdout110.txt command24.txt     name115.txt       prot16.txt        stdout112.txt command25.txt     name116.txt       prot17.txt        stdout15.txt command3.txt      name117.txt       prot18.txt        stdout18.txt command4.txt      name118.txt       prot2.txt         upload107.txt command5.txt      name119.txt       prot22.txt        upload108.txt command6.txt      name12.txt        prot3.txt         upload109.txt command7.txt      name13.txt        prot4.txt         upload112.txt command8.txt      name14.txt        prot5.txt command9.txt      name15.txt        prot6.txt error111.txt      name16.txt        prot7.txt command26.txt  prot26.txt     command27.txt  prot27.txt name26.txt     reply26.txt    name27.txt     stdout27.txt command28.txt  name28.txt     prot28.txt     reply28.txt command120.txt  name120.txt     prot120.txt     reply120.txt command121.txt  name121.txt     prot121.txt     reply121.txt command29.txt  error30.txt  name30.txt  prot30.txt   reply30.txt command30.txt  name29.txt   prot29.txt  reply29.txt command31.txt  name32.txt  reply31.txt      reply32.txt command32.txt  prot31.txt  reply310001.txt  reply320001.txt name31.txt     prot32.txt  reply310002.txt  reply320002.txt command33.txt  extra33.txt    name33.txt     prot33.txt     reply33.txt
+EXTRA_DIST = command1.txt error113.txt name17.txt prot8.txt command10.txt  error114.txt name18.txt  prot9.txt command100.txt error115.txt name19.txt  reply1.txt command101.txt error116.txt name2.txt   reply10.txt command102.txt error117.txt name20.txt  reply100.txt command103.txt error118.txt name200.txt reply101.txt command104.txt error119.txt name201.txt reply102.txt command105.txt error19.txt  name21.txt  reply103.txt command106.txt error20.txt  name22.txt  reply104.txt command107.txt error201.txt name23.txt  reply105.txt command108.txt error21.txt  name24.txt  reply106.txt command109.txt error23.txt  name25.txt  reply11.txt command11.txt  error24.txt  name3.txt   reply110.txt command110.txt error25.txt  name4.txt   reply110001.txt command111.txt ftpd113.txt  name5.txt   reply110002.txt command112.txt ftpd114.txt  name6.txt   reply12.txt command113.txt ftpd115.txt  name7.txt   reply13.txt command114.txt ftpd116.txt  name8.txt   reply14.txt command115.txt ftpd117.txt  name9.txt   reply15.txt command116.txt ftpd118.txt  prot1.txt   reply16.txt command117.txt name1.txt    prot10.txt  reply17.txt command118.txt name10.txt   prot100.txt reply2.txt command119.txt name100.txt  prot101.txt reply200.txt command12.txt  name101.txt  prot102.txt reply22.txt command13.txt  name102.txt  prot103.txt reply24.txt command14.txt  name103.txt  prot104.txt reply25.txt command15.txt  name104.txt  prot105.txt reply3.txt command16.txt  name105.txt  prot106.txt reply4.txt command17.txt  name106.txt  prot107.txt reply5.txt command18.txt  name107.txt  prot108.txt reply6.txt command19.txt  name108.txt  prot109.txt reply7.txt command2.txt   name109.txt  prot11.txt  reply8.txt command20.txt  name11.txt   prot110.txt reply9.txt command200.txt name110.txt  prot112.txt stdin17.txt command201.txt name111.txt  prot12.txt  stdout107.txt command21.txt  name112.txt  prot13.txt  stdout108.txt command22.txt  name113.txt  prot14.txt  stdout109.txt command23.txt  name114.txt  prot15.txt  stdout110.txt command24.txt  name115.txt  prot16.txt  stdout112.txt command25.txt  name116.txt  prot17.txt  stdout15.txt command3.txt   name117.txt  prot18.txt  stdout18.txt command4.txt   name118.txt  prot2.txt   upload107.txt command5.txt   name119.txt  prot22.txt  upload108.txt command6.txt   name12.txt   prot3.txt   upload109.txt command7.txt   name13.txt   prot4.txt   upload112.txt command8.txt   name14.txt   prot5.txt command9.txt   name15.txt   prot6.txt error111.txt   name16.txt   prot7.txt command26.txt  prot26.txt     command27.txt  prot27.txt name26.txt     reply26.txt    name27.txt     stdout27.txt command28.txt  name28.txt     prot28.txt     reply28.txt command120.txt  name120.txt     prot120.txt     reply120.txt command121.txt  name121.txt     prot121.txt     reply121.txt command29.txt  error30.txt  name30.txt  prot30.txt   reply30.txt command30.txt  name29.txt   prot29.txt  reply29.txt command31.txt  name32.txt  reply31.txt      reply32.txt command32.txt  prot31.txt  reply310001.txt  reply320001.txt name31.txt     prot32.txt  reply310002.txt  reply320002.txt command33.txt  extra33.txt    name33.txt     prot33.txt     reply33.txt command34.txt prot34.txt reply340001.txt name34.txt reply34.txt command35.txt  name35.txt     prot35.txt     reply35.txt command36.txt  error36.txt  name36.txt  reply36.txt command37.txt  name37.txt  prot37.txt  reply37.txt command38.txt prot38.txt reply380001.txt name38.txt reply38.txt command39.txt prot39.txt reply390001.txt name39.txt reply39.txt reply390002.txt
 
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = ../../config.h ../../src/config.h
 CONFIG_CLEAN_FILES = 
 DIST_COMMON =  Makefile.am Makefile.in
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/name14.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/name14.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/name14.txt	2000-11-13 21:50:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/name14.txt	2001-03-08 18:26:11.000000000 +0800
@@ -1 +1 @@
-HTTP HEAD
+HTTP HEAD with Connection: close
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/name25.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/name25.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/name25.txt	2000-11-28 17:17:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/name25.txt	2001-03-13 20:35:51.000000000 +0800
@@ -1 +1 @@
-looping HTTP Location: following with --max-redirs
+looping HTTP Location: following with --max-redirs, no persistance
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: name34.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: name35.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: name36.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: name37.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: name38.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: name39.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot100.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot100.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot100.txt	2000-11-21 22:39:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot100.txt	2001-03-05 01:53:55.000000000 +0800
@@ -1,5 +1,6 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE A
 LIST
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot101.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot101.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot101.txt	2000-11-21 22:43:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot101.txt	2001-03-05 01:54:15.000000000 +0800
@@ -1,5 +1,6 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PORT 127,0,0,1,243,212
 TYPE A
 LIST
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot102.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot102.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot102.txt	2000-11-21 23:54:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot102.txt	2001-03-05 01:54:22.000000000 +0800
@@ -1,5 +1,6 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE I
 RETR 102
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot103.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot103.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot103.txt	2000-11-22 03:38:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot103.txt	2001-03-05 01:54:27.000000000 +0800
@@ -1,6 +1,7 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 CWD a/path
 PORT 127,0,0,1,246,33
 TYPE I
 RETR 103
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot104.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot104.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot104.txt	2000-11-22 21:44:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot104.txt	2001-03-05 01:54:31.000000000 +0800
@@ -1,6 +1,7 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 CWD a/path
 MDTM 103
 TYPE I
 SIZE 103
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot105.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot105.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot105.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot105.txt	2001-03-05 01:54:36.000000000 +0800
@@ -1,5 +1,6 @@
 USER userdude
 PASS passfellow
+PWD
 PASV
 TYPE A
 RETR 103
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot106.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot106.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot106.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot106.txt	2001-03-05 01:54:40.000000000 +0800
@@ -1,6 +1,7 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 CWD /path with  spaces/and things2
 PASV
 TYPE A
 RETR 106
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot107.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot107.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot107.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot107.txt	2001-03-05 01:52:57.000000000 +0800
@@ -1,5 +1,6 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE I
 STOR 107
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot108.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot108.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot108.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot108.txt	2001-03-05 01:53:25.000000000 +0800
@@ -1,6 +1,7 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 CWD CWD/STOR/RETR
 PORT 127,0,0,1,5,109
 TYPE I
 STOR 108
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot109.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot109.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot109.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot109.txt	2001-03-05 01:53:48.000000000 +0800
@@ -1,5 +1,6 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE I
 APPE 109
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot10.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot10.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot10.txt	2000-11-13 19:56:46.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot10.txt	2001-03-05 01:58:16.000000000 +0800
@@ -1,7 +1,7 @@
-PUT /we/want/10 HTTP/1.0
+PUT /we/want/10 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Content-Length: 60
 
 http://%HOSTIP:%HOSTPORT/we/want/10 -T data/command10.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot110.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot110.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot110.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot110.txt	2001-03-05 01:54:51.000000000 +0800
@@ -1,7 +1,8 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE I
 SIZE 110
 REST 20
 RETR 110
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot112.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot112.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot112.txt	2000-11-22 03:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot112.txt	2001-03-05 01:55:00.000000000 +0800
@@ -1,5 +1,6 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE I
 APPE 112
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot11.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot11.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot11.txt	2000-11-13 21:12:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot11.txt	2001-03-14 22:20:21.000000000 +0800
@@ -1,5 +1,10 @@
-GET /want/data/110002.txt?coolsite=yes HTTP/1.0
+GET /want/11 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+
+GET /want/data/110002.txt?coolsite=yes HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot120.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot120.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot120.txt	2001-01-22 23:59:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot120.txt	2001-03-05 02:04:34.000000000 +0800
@@ -1,6 +1,7 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 PASV
 TYPE I
 RETR 106
 DELE file
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot121.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot121.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot121.txt	2001-01-23 00:04:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot121.txt	2001-03-05 02:04:47.000000000 +0800
@@ -1,7 +1,8 @@
 USER anonymous
 PASS curl_by_daniel@haxx.se
+PWD
 DELE before_transfer
 PASV
 TYPE I
 RETR 106
 DELE after_transfer
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot12.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot12.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot12.txt	2000-11-13 21:42:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot12.txt	2001-03-05 01:58:17.000000000 +0800
@@ -1,6 +1,6 @@
-GET /want/12 HTTP/1.0
+GET /want/12 HTTP/1.1
 Range: bytes=100-200
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot13.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot13.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot13.txt	2000-11-13 21:44:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot13.txt	2001-03-05 01:58:17.000000000 +0800
@@ -1,5 +1,5 @@
-DELETE /want/13 HTTP/1.0
+DELETE /want/13 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot14.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot14.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot14.txt	2000-11-13 21:51:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot14.txt	2001-03-05 01:58:18.000000000 +0800
@@ -1,6 +1,6 @@
-HEAD /want/14 HTTP/1.0
+HEAD /want/14 HTTP/1.1
 User-Agent: curl/7.4.2-pre4 (sparc-sun-solaris2.7) libcurl 7.4.2-pre4
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot15.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot15.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot15.txt	2000-11-13 22:05:00.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot15.txt	2001-03-05 01:58:18.000000000 +0800
@@ -1,5 +1,5 @@
-GET /want/15 HTTP/1.0
+GET /want/15 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot16.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot16.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot16.txt	2000-11-15 23:46:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot16.txt	2001-03-05 01:58:18.000000000 +0800
@@ -1,6 +1,6 @@
-GET http://we.want.that.site.com/2 HTTP/1.0
+GET http://we.want.that.site.com/2 HTTP/1.1
 Proxy-authorization: Basic ZmFrZUB1c2VyOqenp2xvb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb29vb28=
 Host: we.want.that.site.com
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot17.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot17.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot17.txt	2000-11-17 17:46:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot17.txt	2001-03-05 01:58:18.000000000 +0800
@@ -1,6 +1,6 @@
-MOOO /that.site.com/17 HTTP/1.0
+MOOO /that.site.com/17 HTTP/1.1
 User-Agent: agent007 license to drill
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot18.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot18.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot18.txt	2000-11-17 23:05:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot18.txt	2001-03-14 22:20:58.000000000 +0800
@@ -1,6 +1,15 @@
-GET /11 HTTP/1.0
-User-Agent: curl/7.4.2 (sparc-sun-solaris2.7) libcurl 7.4.2
+GET /3 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+
+GET /10 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+
+GET /11 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot1.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot1.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot1.txt	2000-11-10 21:07:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot1.txt	2001-03-05 01:58:16.000000000 +0800
@@ -1,6 +1,6 @@
-GET /1 HTTP/1.0
+GET /1 HTTP/1.1
 User-Agent: curl/7.4.2-pre3 (sparc-sun-solaris2.7) libcurl 7.4.2-pre3 (SSL 0.9.6)
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot22.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot22.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot22.txt	2000-11-20 17:03:06.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot22.txt	2001-03-05 02:01:51.000000000 +0800
@@ -1,6 +1,6 @@
-GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/17 HTTP/1.0
+GET /aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/17 HTTP/1.1
 User-Agent: curl/7.4.2 (sparc-sun-solaris2.7) libcurl 7.4.2 (SSL 0.9.6)
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot26.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot26.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot26.txt	2001-01-09 20:07:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot26.txt	2001-03-13 20:35:51.000000000 +0800
@@ -1,6 +1,6 @@
-GET /want/25 HTTP/1.0
+GET /want/26 HTTP/1.1
 User-Agent: curl/7.6-pre1 (sparc-sun-solaris2.7) libcurl 7.5.2 (SSL 0.9.6) (krb4 enabled)
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot27.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot27.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot27.txt	2001-01-09 20:22:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot27.txt	2001-03-14 22:22:02.000000000 +0800
@@ -1,6 +1,15 @@
-GET /want/22 HTTP/1.0
-User-Agent: curl/7.6-pre1 (sparc-sun-solaris2.7) libcurl 7.6-pre1 (SSL 0.9.6) (krb4 enabled)
+GET /want/25 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+
+GET /want/24 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+
+GET /want/22 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot28.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot28.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot28.txt	2001-01-19 20:11:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot28.txt	2001-03-05 01:58:20.000000000 +0800
@@ -1,5 +1,5 @@
-GET /wantit/{}[]/28 HTTP/1.0
+GET /wantit/{}[]/28 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot29.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot29.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot29.txt	2001-01-28 02:49:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot29.txt	2001-03-05 01:58:20.000000000 +0800
@@ -1,7 +1,7 @@
-GET /29 HTTP/1.0
+GET /29 HTTP/1.1
 Range: bytes=200-
 User-Agent: curl/7.6 (i686-pc-linux-gnu) libcurl 7.6 (SSL 0.9.5) (ipv6 enabled)
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot2.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot2.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot2.txt	2000-11-10 21:07:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot2.txt	2001-03-05 01:58:19.000000000 +0800
@@ -1,6 +1,6 @@
-GET /2 HTTP/1.0
+GET /2 HTTP/1.1
 Authorization: Basic ZmFrZTp1c2Vy
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot30.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot30.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot30.txt	2001-01-28 02:49:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot30.txt	2001-03-05 01:58:21.000000000 +0800
@@ -1,6 +1,6 @@
-GET /30 HTTP/1.0
+GET /30 HTTP/1.1
 User-Agent: curl/7.6 (i686-pc-linux-gnu) libcurl 7.6 (SSL 0.9.5) (ipv6 enabled)
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot31.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot31.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot31.txt	2001-01-28 04:02:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot31.txt	2001-03-14 22:22:22.000000000 +0800
@@ -1,8 +1,15 @@
-POST /moo/moo/moo/310002 HTTP/1.0
-User-Agent: curl/7.6 (i686-pc-linux-gnu) libcurl 7.6 (SSL 0.9.5) (ipv6 enabled)
+POST /31 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+Content-Length: 9
+Content-Type: application/x-www-form-urlencoded
+
+mooo=fooo
+POST /moo/moo/moo/310002 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Content-Length: 9
 Content-Type: application/x-www-form-urlencoded
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot32.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot32.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot32.txt	2001-01-28 04:02:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot32.txt	2001-03-14 22:22:35.000000000 +0800
@@ -1,6 +1,13 @@
-GET /moo/moo/moo/320002 HTTP/1.0
-User-Agent: curl/7.6 (i686-pc-linux-gnu) libcurl 7.6 (SSL 0.9.5) (ipv6 enabled)
+POST /32 HTTP/1.1
+Host: 127.0.0.1:8999
+Pragma: no-cache
+Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
+Content-Length: 9
+Content-Type: application/x-www-form-urlencoded
+
+mooo=fooo
+GET /moo/moo/moo/320002 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot33.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot33.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot33.txt	2001-01-29 22:35:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot33.txt	2001-03-05 01:58:22.000000000 +0800
@@ -1,7 +1,7 @@
-PUT /33 HTTP/1.0
+PUT /33 HTTP/1.1
 Content-Range: bytes 50-149/150
 User-Agent: curl/7.6 (sparc-sun-solaris2.7) libcurl 7.6-pre4 (SSL 0.9.6) (krb4 enabled)
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Content-Length: 100
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: prot34.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: prot35.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: prot37.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: prot38.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: prot39.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot3.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot3.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot3.txt	2000-11-10 23:23:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot3.txt	2001-03-05 01:58:21.000000000 +0800
@@ -1,7 +1,7 @@
-POST /3 HTTP/1.0
+POST /3 HTTP/1.1
 Authorization: Basic ZmFrZTotdXNlcg==
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Content-Length: 37
 Content-Type: application/x-www-form-urlencoded
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot4.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot4.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot4.txt	2000-11-10 23:21:39.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot4.txt	2001-03-05 01:58:22.000000000 +0800
@@ -1,6 +1,6 @@
-GET /4 HTTP/1.0
+GET /4 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 extra-header: here
 Accept: replaced
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot5.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot5.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot5.txt	2000-11-13 16:10:35.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot5.txt	2001-03-05 01:58:22.000000000 +0800
@@ -1,5 +1,5 @@
-GET http://127.0.0.1:8999/we/want/that/page/5 HTTP/1.0
+GET http://127.0.0.1:8999/we/want/that/page/5 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot6.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot6.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot6.txt	2000-11-13 16:18:03.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot6.txt	2001-03-05 01:58:23.000000000 +0800
@@ -1,6 +1,6 @@
-GET /we/want/that/page/6 HTTP/1.0
+GET /we/want/that/page/6 HTTP/1.1
 Cookie: name=contents;name2=content2
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot7.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot7.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot7.txt	2000-11-13 16:23:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot7.txt	2001-03-05 01:58:23.000000000 +0800
@@ -1,5 +1,5 @@
-GET /we/want/7 HTTP/1.0
+GET /we/want/7 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot8.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot8.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot8.txt	2000-11-13 16:47:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot8.txt	2001-03-05 01:58:23.000000000 +0800
@@ -1,6 +1,6 @@
-GET /we/want/8 HTTP/1.0
+GET /we/want/8 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Cookie: foobar=name; partmatch=present
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot9.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot9.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/prot9.txt	2000-11-13 17:04:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/prot9.txt	2001-03-05 01:58:23.000000000 +0800
@@ -1,7 +1,7 @@
-POST /we/want/9 HTTP/1.0
+POST /we/want/9 HTTP/1.1
 Host: 127.0.0.1:8999
 Pragma: no-cache
 Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*
 Content-Length: 446
 Content-Type: multipart/form-data; boundary=curluczemxkcWWsxptLlAImrFQHwQ3W
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply10.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply10.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply10.txt	2000-11-13 19:47:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply10.txt	2001-03-13 20:35:52.000000000 +0800
@@ -1,5 +1,5 @@
-HTTP/1.1 200 OK
+HTTP/1.0 200 OK
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 
 blablabla
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply110001.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply110001.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply110001.txt	2000-11-13 21:10:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply110001.txt	2001-02-21 01:37:06.000000000 +0800
@@ -1,10 +1,11 @@
 HTTP/1.1 301 This is a weirdo text message
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 Location: data/110002.txt?coolsite=yes
+Connection: close
 
 HTTP/1.1 200 Followed here fine
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 
 If this is received, the location following worked
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply11.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply11.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply11.txt	2000-11-13 21:10:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply11.txt	2001-02-21 00:44:19.000000000 +0800
@@ -1,6 +1,7 @@
 HTTP/1.1 301 This is a weirdo text message
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 Location: data/110002.txt?coolsite=yes
+Connection: close
 
 This server reply is for testing a simple Location: following
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply14.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply14.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply14.txt	2000-11-13 21:52:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply14.txt	2001-03-08 18:23:59.000000000 +0800
@@ -1,4 +1,5 @@
 HTTP/1.1 200 OK
 Server: thebest/1.0
+Connection: close
 
 no?
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply24.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply24.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply24.txt	2000-11-22 16:54:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply24.txt	2001-03-13 20:35:52.000000000 +0800
@@ -1,5 +1,5 @@
-HTTP/1.1 404 BAD BOY
+HTTP/1.0 404 BAD BOY
 Content-Type: text/html
 
 This silly page doesn't reaaaaaly exist so you should not get it.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply25.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply25.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply25.txt	2000-11-28 17:19:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply25.txt	2001-03-13 20:35:52.000000000 +0800
@@ -1,5 +1,7 @@
 HTTP/1.1 301 This is a weirdo text message
 Server: test-server/fake
 Location: data/reply/25
+Content-Length: 32
+Connection: close
 
 Redirect to the same URL again!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply26.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply26.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply26.txt	2001-01-09 20:07:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply26.txt	2001-03-13 20:35:53.000000000 +0800
@@ -1,5 +1,6 @@
 HTTP/1.1 301 This is a weirdo text message
 Server: test-server/fake
 Location: data/reply/25
+Connection: close
 
 Redirect to the same URL again!
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply310001.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply310001.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply310001.txt	2001-01-28 04:02:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply310001.txt	2001-03-13 20:35:54.000000000 +0800
@@ -1,9 +1,10 @@
 HTTP/1.1 301 Moved Permanently
 Server: fake
 Location: /moo/moo/moo/310002
+Connection: close
 
 HTTP/1.1 200 Followed here fine
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 
 If this is received, the location following worked
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply31.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply31.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply31.txt	2001-01-28 04:02:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply31.txt	2001-03-13 20:35:53.000000000 +0800
@@ -1,6 +1,7 @@
 HTTP/1.1 301 Moved Permanently
 Server: fake
 Location: /moo/moo/moo/310002
+Connection: close
 
 No contents
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply320001.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply320001.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply320001.txt	2001-01-28 04:02:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply320001.txt	2001-03-13 20:35:54.000000000 +0800
@@ -1,9 +1,10 @@
 HTTP/1.1 303 See Other
 Server: fake
 Location: /moo/moo/moo/320002
+Connection: close
 
 HTTP/1.1 200 Followed here fine
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 
 If this is received, the location following worked
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply32.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply32.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply32.txt	2001-01-28 04:02:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply32.txt	2001-03-13 20:35:54.000000000 +0800
@@ -1,7 +1,8 @@
 HTTP/1.1 303 See Other
 Server: fake
 Location: /moo/moo/moo/320002
+Connection: close
 
 This Location should be fetched with a GET!
 
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply340001.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply34.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply35.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply36.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply37.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply380001.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply38.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply390001.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply390002.txt
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data: reply39.txt
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply3.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply3.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/reply3.txt	2000-11-10 19:37:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/reply3.txt	2001-03-13 20:35:53.000000000 +0800
@@ -1,7 +1,7 @@
-HTTP/1.1 200 OK
+HTTP/1.0 200 OK
 Server: test-server/fake
 Content-Type: text/html
 Content-Length: 0
 
 this is data even though Content-Length is set to zero
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/stdout18.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/stdout18.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/stdout18.txt	2000-11-17 23:04:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/stdout18.txt	2001-03-13 20:35:55.000000000 +0800
@@ -1,22 +1,23 @@
 --_curl_--127.0.0.1:8999/3
-HTTP/1.1 200 OK
+HTTP/1.0 200 OK
 Server: test-server/fake
 Content-Type: text/html
 Content-Length: 0
 
 this is data even though Content-Length is set to zero
 
 
 --_curl_--127.0.0.1:8999/10
-HTTP/1.1 200 OK
+HTTP/1.0 200 OK
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 
 blablabla
 --_curl_--127.0.0.1:8999/11
 HTTP/1.1 301 This is a weirdo text message
 Date: Thu, 09 Nov 2010 14:49:00 GMT
 Server: test-server/fake
 Location: data/110002.txt?coolsite=yes
+Connection: close
 
 This server reply is for testing a simple Location: following
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/stdout27.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/stdout27.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/data/stdout27.txt	2001-01-09 20:21:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/data/stdout27.txt	2001-03-13 20:35:55.000000000 +0800
@@ -1,12 +1,14 @@
 HTTP/1.1 301 This is a weirdo text message
 Server: test-server/fake
 Location: data/reply/25
+Content-Length: 32
+Connection: close
 
 Redirect to the same URL again!
-HTTP/1.1 404 BAD BOY
+HTTP/1.0 404 BAD BOY
 Content-Type: text/html
 
 This silly page doesn't reaaaaaly exist so you should not get it.
 
 HTTP/1.1 200 OK
 Funny-head: yesyes
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/ftpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/ftpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/ftpserver.pl	2001-01-23 00:16:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/ftpserver.pl	2001-03-05 22:03:20.000000000 +0800
@@ -1,9 +1,9 @@
 #!/usr/bin/perl
 #
-# $Id: ftpserver.pl,v 1.14 2001/01/22 16:16:18 bagder Exp $
+# $Id: ftpserver.pl,v 1.15 2001/03/05 14:03:20 bagder Exp $
 # This is the FTP server designed for the curl test suite.
 #
 # It is meant to excersive curl, it is not meant to become a fully working
 # or even very standard compliant server.
 #
 # You may optionally specify port on the command line, otherwise it'll
@@ -347,12 +347,16 @@
     FTPLOG->autoflush(1);
     INPUT->autoflush(1);
 
     &customize(); # read test control instructions
 
     print @welcome;
+    if($verbose) {
+        print STDERR "OUT:\n";
+        print STDERR @welcome;
+    }
     my $state="fresh";
 
     while(1) {
 
         last unless defined ($_ = <STDIN>);
         
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/httpserver.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/httpserver.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/httpserver.pl	2001-01-28 04:22:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/httpserver.pl	2001-03-14 22:18:20.000000000 +0800
@@ -60,12 +60,14 @@
 
     # this code is forked and run
     spawn sub {
         my ($request, $path, $ver, $left, $cl);
 
         my @headers;
+
+      stdin:
         while(<STDIN>) {
             if($_ =~ /([A-Z]*) (.*) HTTP\/1.(\d)/) {
                 $request=$1;
                 $path=$2;
                 $ver=$3;
             }
@@ -122,29 +124,32 @@
                     print STDERR "OUT: sending reply $testnum\n";
                 }
             }
             else {
                 $testnum=0;
             }
-            open(INPUT, ">log/server.input");
+            open(INPUT, ">>log/server.input");
             for(@headers) {
                 print INPUT $_;
             }
             close(INPUT);
             
             if(0 == $testnum ) {
                 print "HTTP/1.1 200 OK\r\n",
                 "header: yes\r\n",
                 "\r\n",
-                "You must select a test number to get good data back\r\n";
+                "You must enter a test number to get good data back\r\n";
             }
             else {
                 # send a custom reply to the client
                 open(DATA, "<data/reply$testnum.txt");
                 while(<DATA>) {
                     print $_;
+                    if($verbose) {
+                        print STDERR "OUT: $_";
+                    }
                 }
                 close(DATA);
             }
         }
      #   print "Hello there, $name, it's now ", scalar localtime, "\r\n";
     };
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/Makefile.in	2001-02-13 21:35:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/Makefile.in	2001-03-22 23:42:57.000000000 +0800
@@ -66,12 +66,13 @@
 LN_S = @LN_S@
 MAKEINFO = @MAKEINFO@
 NROFF = @NROFF@
 OBJDUMP = @OBJDUMP@
 PACKAGE = @PACKAGE@
 PERL = @PERL@
+RANDOM_FILE = @RANDOM_FILE@
 RANLIB = @RANLIB@
 VERSION = @VERSION@
 YACC = @YACC@
 
 EXTRA_DIST = ftpserver.pl httpserver.pl runtests.pl
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/README	2000-11-27 20:26:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/README	2001-03-13 20:35:48.000000000 +0800
@@ -4,34 +4,52 @@
                             | (__| |_| |  _ <| |___ 
                              \___|\___/|_| \_\_____|
 
 The cURL Test Suite
 
 Requires:
-  perl
+  perl (and a unix-style shell)
 
 Run:
   'make test'. This invokes the 'runtests.pl' perl script. Edit the top
   variables of that script in case you have some specific needs.
 
   The script breaks on the first test that doesn't do OK. Use -a to prevent
   the script to abort on the first error. Run the script with -v for more
-  verbose output.
+  verbose output. Use -d to run the test servers with debug output enabled as
+  well.
 
-  Use -s fort shorter output, or pass a string with test numbers to run
-  specific tests only (like ./runtests.pl "3 4" to test 3 and 4 only)
+  Use -s for shorter output, or pass test numbers to run specific tests only
+  (like "./runtests.pl 3 4" to test 3 and 4 only). It also supports test case
+  ranges with 'to'. As in "./runtests 3 to 9" which runs the seven tests from
+  3 to 9.
 
 Memory:
   The test script will check that all allocated memory is freed properly IF
   curl has been built with the MALLOCDEBUG define set. The script will
   automatically detect if that is the case, and it will use the ../memanalyze
   script to analyze the memory debugging output.
 
+Debug:
+  If a test case fails, you can conveniently get the script to invoke the
+  debugger (gdb) for you with the server running and the exact same command
+  line parameters that failed. Just invoke 'runtests.pl <test number> -g' and
+  then just type 'run' in the debugger to perform the command through the
+  debugger.
+
+  If a test case causes a core dump, analyze it by running gdb like:
+
+          # gdb ../curl/src core
+
+  ... and get a stack trace with the gdb command:
+
+          (gdb) where
+
 Logs:
   All logs are generated in the logs/ subdirctory (it is emtpied first
-  in the runtests.sh script)
+  in the runtests.pl script)
 
 Data:
   All test-data are put in the data/ subdirctory.
 
   For each tests there exist a few files, all with their own separate and
   special purpose. Replace N with the test number:
@@ -42,14 +60,16 @@
 
     protN.txt: the full dump of the protocol communication that curl is
                expected to use when performing this test
 
     replyN.txt: the full dump the server should reply to curl for this test.
                If the final result that curl should've got is not in this
-               file, you can instead name the file replyN0001.txt. This enables
-               you to fiddle more. ;-)
+               file, you can instead name the file replyN0001.txt. This
+               enables you to fiddle more. ;-) Alas, the server sends the
+               replyN.txt file but checks the result after the test against
+               the *0001.txt file.
 
     stdoutN.txt: if this file is present, curl's stdout is compared against
                this file to see that they're identical. If this is present,
                curl will not be run with -o but instead all output is compared
                against this file!
 
@@ -60,10 +80,10 @@
                the log/upload.N does, after a curl upload has been performed.
 
     ftpdN.txt: this file may contain instructions how to modify the behaviour
                of the ftp server. It uses a simple syntax that is left to
                describe here!
 
-FIX:
+TODO:
 
   * Make httpserver.pl work when we PUT without Content-Length:
-
+  * Add persistant connection support and test cases
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/runtests.pl /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/runtests.pl
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.6.1/tests/runtests.pl	2001-01-29 23:07:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/curl/repos/curl-7.7/tests/runtests.pl	2001-03-14 06:14:53.000000000 +0800
@@ -1,8 +1,8 @@
 #!/usr/bin/perl
-# $Id: runtests.pl,v 1.20 2001/01/29 15:07:28 bagder Exp $
+# $Id: runtests.pl,v 1.25 2001/03/13 22:14:53 bagder Exp $
 #
 # Main curl test script, in perl to run on more platforms
 #
 #######################################################################
 # These should be the only variables that might be needed to get edited:
 
@@ -48,12 +48,13 @@
 #
 
 my $short;
 my $verbose;
 my $debugprotocol;
 my $anyway;
+my $gdbthis; # run test case with gdb debugger
 
 #######################################################################
 # Return the pid of the server as found in the given pid file
 #
 sub serverpid {
     my $PIDFILE = $_[0];
@@ -150,12 +151,16 @@
         $STATUS="ftpd (no pid file) not running";
         $RUNNING=0;
     }
 
     if ($RUNNING != 1) {
         my $flag=$debugprotocol?"-v ":"";
+        if($debugprotocol) {
+            print "* Starts ftp server verbose:\n";
+            print "perl $srcdir/ftpserver.pl $flag $FTPPORT &\n";
+        }
         system("perl $srcdir/ftpserver.pl $flag $FTPPORT &");
         sleep 1; # give it a little time to start
     }
     else {
         print "$STATUS\n";
 
@@ -348,13 +353,13 @@
     # if this file exists, it is FTP server instructions:
     my $ftpservercmd="$TESTDIR/ftpd$NUMBER.txt";
 
     if(! -r $CURLCMD) {
         # this is not a test
         print "$NUMBER doesn't look like a test case!\n";
-        next;
+        return -1;
     }
 
     # remove previous server output logfile
     unlink($SERVERIN);
 
     if(-r $ftpservercmd) {
@@ -394,28 +399,40 @@
     my $out="";
     if ( ! -r "$VALIDOUT" ) {
         $out="--output $CURLOUT ";
     }
 
     # run curl, add -v for debug information output
-    my $CMDLINE="$CURL $out--include -v --silent $cmd >$STDOUT 2>$STDERR";
+    my $cmdargs="$out--include -v --silent $cmd";
 
     my $STDINFILE="$TESTDIR/stdin$NUMBER.txt";
     if(-f $STDINFILE) {
-        $CMDLINE .= " < $STDINFILE";
+        $cmdargs .= " < $STDINFILE";
     }
+    my $CMDLINE="$CURL $cmdargs >$STDOUT 2>$STDERR";
 
     if($verbose) {
         print "$CMDLINE\n";
     }
 
     print CMDLOG "$CMDLINE\n";
 
+    my $res;
     # run the command line we built
-    my $res = system("$CMDLINE");
-    $res /= 256;
+    if($gdbthis) {
+        open(GDBCMD, ">log/gdbcmd");
+        print GDBCMD "set args $cmdargs\n";
+        print GDBCMD "show args\n";
+        close(GDBCMD);
+        system("gdb $CURL -x log/gdbcmd");
+        $res =0; # makes it always continue after a debugged run
+    }
+    else {
+        $res = system("$CMDLINE");
+        $res /= 256;
+    }
 
     my $ERRORCODE = "$TESTDIR/error$NUMBER.txt";
 
     if ($res != 0) {
         # the invoked command return an error code
 
@@ -547,22 +564,28 @@
 
 
 #######################################################################
 # Check options to this test program
 #
 
+my $number=0;
+my $fromnum=-1;
 my @testthis;
 do {
     if ($ARGV[0] eq "-v") {
         # verbose output
         $verbose=1;
     }
     elsif ($ARGV[0] eq "-d") {
         # have the servers display protocol output 
         $debugprotocol=1;
     }
+    elsif ($ARGV[0] eq "-g") {
+        # run this test with gdb
+        $gdbthis=1;
+    }
     elsif($ARGV[0] eq "-s") {
         # short output
         $short=1;
     }
     elsif($ARGV[0] eq "-a") {
         # continue anyway, even if a test fail
@@ -571,22 +594,35 @@
     elsif($ARGV[0] eq "-h") {
         # show help text
         print <<EOHELP
 Usage: runtests.pl [-h][-s][-v][numbers]
   -a       continue even if a test fails
   -d       display server debug info
+  -g       run the test case with gdb
   -h       this help text
   -s       short output
   -v       verbose output
   [num]    as string like "5 6 9" to run those tests only
 EOHELP
     ;
         exit;
     }
     elsif($ARGV[0] =~ /^(\d+)/) {
-        push @testthis, $1;
+        $number = $1;
+        if($fromnum >= 0) {
+            for($fromnum .. $number) {
+                push @testthis, $_;
+            }
+            $fromnum = -1;
+        }
+        else {
+            push @testthis, $1;
+        }
+    }
+    elsif($ARGV[0] =~ /^to$/i) {
+        $fromnum = $number+1;
     }
 } while(shift @ARGV);
 
 if($testthis[0] ne "") {
     $TESTCASES=join(" ", @testthis);
 }
@@ -640,23 +676,30 @@
     print "can't log command lines to $CURLLOG\n";
 
 #######################################################################
 # The main test-loop
 #
 
+my $failed;
 my $testnum;
 my $ok=0;
 my $total=0;
 foreach $testnum (split(" ", $TESTCASES)) {
 
-    $total++;
     my $error = singletest($testnum);
-    if($error && !$anyway) {
-        # a test failed, abort
-        print "\n - abort tests\n";
-        last;
+    if(-1 != $error) {
+        # valid test case number
+        $total++;
+    }
+    if($error>0) {
+        if(!$anyway) {
+            # a test failed, abort
+            print "\n - abort tests\n";
+            last;
+        }
+        $failed.= "$testnum ";
     }
     elsif(!$error) {
         $ok++;
     }
 
     # loop for next test
@@ -671,7 +714,16 @@
 # Tests done, stop the servers
 #
 
 stopserver($FTPPIDFILE);
 stopserver($PIDFILE);
 
-print "$ok tests out of $total reported OK\n";
+if($total) {
+    print "$ok tests out of $total reported OK\n";
+
+    if($ok != $total) {
+        print "These test cases failed: $failed\n";
+    }
+}
+else {
+    print "No tests were performed!\n";
+}
