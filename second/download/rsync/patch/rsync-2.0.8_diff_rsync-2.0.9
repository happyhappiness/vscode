diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/clientserver.c	1998-05-17 22:57:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/clientserver.c	1998-05-18 18:30:43.000000000 +0800
@@ -30,23 +30,27 @@
 	int fd, i;
 	char *sargs[MAX_ARGS];
 	int sargc=0;
 	char line[MAXPATHLEN];
 	char *p, *user=NULL;
 	extern int remote_version;
+	extern int am_client;
+	extern int am_sender;
 
 	p = strchr(host, '@');
 	if (p) {
 		user = host;
 		host = p+1;
 		*p = 0;
 	}
 
 	if (!user) user = getenv("USER");
 	if (!user) user = getenv("LOGNAME");
 
+	am_client = 1;
+
 	fd = open_socket_out(host, rsync_port);
 	if (fd == -1) {
 		exit_cleanup(1);
 	}
 	
 	server_options(sargs,&sargc);
@@ -89,12 +93,15 @@
 
 	for (i=0;i<sargc;i++) {
 		io_printf(fd,"%s\n", sargs[i]);
 	}
 	io_printf(fd,"\n");
 
+	if (remote_version > 17 && !am_sender)
+		io_start_multiplex_in(fd);
+
 	return client_run(fd, fd, -1, argc, argv);
 }
 
 
 
 static int rsync_module(int fd, int i)
@@ -110,12 +117,13 @@
 	char *host = client_name(fd);
 	char *name = lp_name(i);
 	char *user;
 	int start_glob=0;
 	char *request=NULL;
 	extern int am_sender;
+	extern int remote_version;
 
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
 		rprintf(FERROR,"rsync denied on module %s from %s (%s)\n",
 			name, client_name(fd), client_addr(fd));
 		io_printf(fd,"@ERROR: access denied to %s from %s (%s)\n",
 			  name, client_name(fd), client_addr(fd));
@@ -252,12 +260,15 @@
 	if (verbose > 1) verbose = 1;
 
 	argc -= optind;
 	argp = argv + optind;
 	optind = 0;
 
+	if (remote_version > 17 && am_sender)
+		io_start_multiplex_out(fd);
+
 	start_server(fd, fd, argc, argp);
 
 	return 0;
 }
 
 /* send a list of available modules to the client. Don't list those
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/cvs.log /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/cvs.log
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/cvs.log	1998-05-17 23:19:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/cvs.log	1998-05-18 18:31:05.000000000 +0800
@@ -4381,6 +4381,82 @@
 if f_in == f_out then don't close one of them
 
 
 
 
 
+
+****************************************
+Date:	Monday May 18, 1998 @ 18:20
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv1465
+
+Modified Files:
+	clientserver.c io.c log.c main.c options.c proto.h rsync.c 
+	rsync.h socket.c util.c 
+Log Message:
+this is a large commit which adds io multiplexing, thus giving error
+messages from the server when using the socket code.
+
+I've doen a fair bit of testing and I don't seem to have broken
+anything, but it is a very complex change. More testing needed!
+
+
+
+****************************************
+Date:	Monday May 18, 1998 @ 19:34
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv11552
+
+Modified Files:
+	main.c 
+Log Message:
+handle rsh clients that don't like half-open connections
+
+
+
+
+****************************************
+Date:	Monday May 18, 1998 @ 20:23
+Author:	tridge
+
+Update of /data/cvs/rsync
+In directory samba:/tmp/cvs-serv14309
+
+Modified Files:
+	io.c 
+Log Message:
+fixed a multiplexing bug
+
+
+
+
+
+****************************************
+Date:	Monday May 18, 1998 @ 20:30
+Author:	rsync-bu
+
+Update of /data/cvs/rsync
+In directory samba:/data/people/rsync-bugs/rsync
+
+Modified Files:
+	version.h 
+Log Message:
+preparing for release of 2.0.9
+
+
+****************************************
+Date:	Monday May 18, 1998 @ 20:30
+Author:	rsync-bu
+
+Update of /data/cvs/rsync/packaging/redhat/5.0
+In directory samba:/data/people/rsync-bugs/rsync/packaging/redhat/5.0
+
+Modified Files:
+	rsync.spec 
+Log Message:
+preparing for release of 2.0.9
+
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/io.c	1998-05-17 22:57:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/io.c	1998-05-18 18:30:43.000000000 +0800
@@ -24,41 +24,155 @@
   */
 #include "rsync.h"
 
 static int64 total_written;
 static int64 total_read;
 
+static int io_multiplexing_out;
+static int io_multiplexing_in;
+static int multiplex_in_fd;
+static int multiplex_out_fd;
+static time_t last_io;
+
 extern int verbose;
 extern int sparse_files;
 extern int io_timeout;
 
 int64 write_total(void)
 {
-  return total_written;
+	return total_written;
 }
 
 int64 read_total(void)
 {
-  return total_read;
+	return total_read;
 }
 
 static int buffer_f_in = -1;
 
 void setup_nonblocking(int f_in,int f_out)
 {
 	set_blocking(f_out,0);
 	buffer_f_in = f_in;
 }
 
+static void check_timeout(void)
+{
+	time_t t;
+	
+	if (!io_timeout) return;
+
+	if (!last_io) {
+		last_io = time(NULL);
+		return;
+	}
+
+	t = time(NULL);
+
+	if (last_io && io_timeout && (t-last_io)>io_timeout) {
+		rprintf(FERROR,"read timeout after %d second - exiting\n", 
+			(int)(t-last_io));
+		exit_cleanup(1);
+	}
+}
+
 
 static char *read_buffer;
 static char *read_buffer_p;
 static int read_buffer_len;
 static int read_buffer_size;
 
 
+/* continue trying to read len bytes - don't return until len
+   has been read */
+static void read_loop(int fd, char *buf, int len)
+{
+	while (len) {
+		int n = read(fd, buf, len);
+		if (n > 0) {
+			buf += n;
+			len -= n;
+		}
+		if (n == 0) {
+			rprintf(FERROR,"EOF in read_loop\n");
+			exit_cleanup(1);
+		}
+		if (n == -1) {
+			fd_set fds;
+			struct timeval tv;
+
+			if (errno != EAGAIN && errno != EWOULDBLOCK) {
+				rprintf(FERROR,"io error: %s\n", 
+					strerror(errno));
+				exit_cleanup(1);
+			}
+
+			FD_ZERO(&fds);
+			FD_SET(fd, &fds);
+			tv.tv_sec = io_timeout;
+			tv.tv_usec = 0;
+
+			if (select(fd+1, &fds, NULL, NULL, 
+				   io_timeout?&tv:NULL) != 1) {
+				check_timeout();
+			}
+		}
+	}
+}
+
+static int read_unbuffered(int fd, char *buf, int len)
+{
+	static int remaining;
+	char ibuf[4];
+	int tag, ret=0;
+	char line[1024];
+
+	if (!io_multiplexing_in || fd != multiplex_in_fd) 
+		return read(fd, buf, len);
+
+	while (ret == 0) {
+		if (remaining) {
+			len = MIN(len, remaining);
+			read_loop(fd, buf, len);
+			remaining -= len;
+			ret = len;
+			continue;
+		}
+
+		read_loop(fd, ibuf, 4);
+		tag = IVAL(ibuf, 0);
+
+		remaining = tag & 0xFFFFFF;
+		tag = tag >> 24;
+
+		if (tag == MPLEX_BASE) continue;
+
+		tag -= MPLEX_BASE;
+
+		if (tag != FERROR && tag != FINFO) {
+			rprintf(FERROR,"unexpected tag %d\n", tag);
+			exit_cleanup(1);
+		}
+
+		if (remaining > sizeof(line)-1) {
+			rprintf(FERROR,"multiplexing overflow %d\n\n", 
+				remaining);
+			exit_cleanup(1);
+		}
+
+		read_loop(fd, line, remaining);
+		line[remaining] = 0;
+
+		rprintf(tag,"%s", line);
+		remaining = 0;
+	}
+
+	return ret;
+}
+
+
 /* This function was added to overcome a deadlock problem when using
  * ssh.  It looks like we can't allow our receive queue to get full or
  * ssh will clag up. Uggh.  */
 static void read_check(int f)
 {
 	int n;
@@ -90,41 +204,18 @@
 		else
 			read_buffer = (char *)realloc(read_buffer,read_buffer_size);
 		if (!read_buffer) out_of_memory("read check");      
 		read_buffer_p = read_buffer;      
 	}
 
-	n = read(f,read_buffer+read_buffer_len,n);
+	n = read_unbuffered(f,read_buffer+read_buffer_len,n);
 	if (n > 0) {
 		read_buffer_len += n;
 	}
 }
 
-static time_t last_io;
-
-
-static void check_timeout(void)
-{
-	time_t t;
-	
-	if (!io_timeout) return;
-
-	if (!last_io) {
-		last_io = time(NULL);
-		return;
-	}
-
-	t = time(NULL);
-
-	if (last_io && io_timeout && (t-last_io)>io_timeout) {
-		rprintf(FERROR,"read timeout after %d second - exiting\n", 
-			(int)(t-last_io));
-		exit_cleanup(1);
-	}
-}
-
 static int readfd(int fd,char *buffer,int N)
 {
 	int  ret;
 	int total=0;  
 	struct timeval tv;
 	
@@ -138,13 +229,15 @@
 			read_buffer_p += ret;
 			read_buffer_len -= ret;
 			total += ret;
 			continue;
 		} 
 
-		while ((ret = read(fd,buffer + total,N-total)) == -1) {
+		io_flush();
+
+		while ((ret = read_unbuffered(fd,buffer + total,N-total)) == -1) {
 			fd_set fds;
 
 			if (errno != EAGAIN && errno != EWOULDBLOCK)
 				return -1;
 			FD_ZERO(&fds);
 			FD_SET(fd, &fds);
@@ -171,13 +264,13 @@
 int32 read_int(int f)
 {
   int ret;
   char b[4];
   if ((ret=readfd(f,b,4)) != 4) {
     if (verbose > 1) 
-      rprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+      rprintf(FERROR,"(%d) read_int: Error reading %d bytes : %s\n",
 	      getpid(),4,ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_read += 4;
   return IVAL(b,0);
 }
@@ -195,13 +288,13 @@
 	rprintf(FERROR,"Integer overflow - attempted 64 bit offset\n");
 	exit_cleanup(1);
 #else
 	if (remote_version >= 16) {
 		if ((ret=readfd(f,b,8)) != 8) {
 			if (verbose > 1) 
-				rprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+				rprintf(FERROR,"(%d) read_longint: Error reading %d bytes : %s\n",
 					getpid(),8,ret==-1?strerror(errno):"EOF");
 			exit_cleanup(1);
 		}
 		total_read += 8;
 		ret = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 	}
@@ -212,13 +305,13 @@
 
 void read_buf(int f,char *buf,int len)
 {
   int ret;
   if ((ret=readfd(f,buf,len)) != len) {
     if (verbose > 1) 
-      rprintf(FERROR,"(%d) Error reading %d bytes : %s\n",
+      rprintf(FERROR,"(%d) read_buf: Error reading %d bytes : %s\n",
 	      getpid(),len,ret==-1?strerror(errno):"EOF");
     exit_cleanup(1);
   }
   total_read += len;
 }
 
@@ -303,109 +396,126 @@
 	return ret;
 }
 
 
 static int writefd_unbuffered(int fd,char *buf,int len)
 {
-  int total = 0;
-  fd_set w_fds, r_fds;
-  int fd_count, count, got_select=0;
-  struct timeval tv;
-
-  if (buffer_f_in == -1) 
-    return write(fd,buf,len);
-
-  while (total < len) {
-    int ret = write(fd,buf+total,len-total);
-
-    if (ret == 0) return total;
-
-    if (ret == -1 && !(errno == EWOULDBLOCK || errno == EAGAIN)) 
-      return -1;
-
-    if (ret == -1 && got_select) {
-	    /* hmmm, we got a write select on the fd and then failed to write.
-	       Why doesn't that mean that the fd is dead? It doesn't on some
-	       systems it seems (eg. IRIX) */
-	    u_sleep(1000);
-#if 0
-	    rprintf(FERROR,"write exception\n");
-	    exit_cleanup(1);
-#endif
-    }
+	int total = 0;
+	fd_set w_fds, r_fds;
+	int fd_count, count, got_select=0;
+	struct timeval tv;
 
-    got_select = 0;
+	while (total < len) {
+		int ret = write(fd,buf+total,len-total);
 
+		if (ret == 0) return total;
 
-    if (ret == -1) {
-	    if (read_buffer_len < MAX_READ_BUFFER)
-		    read_check(buffer_f_in);
-
-	    fd_count = fd+1;
-	    FD_ZERO(&w_fds);
-	    FD_ZERO(&r_fds);
-	    FD_SET(fd,&w_fds);
-	    if (buffer_f_in != -1) {
-		    FD_SET(buffer_f_in,&r_fds);
-		    if (buffer_f_in > fd) 
-			    fd_count = buffer_f_in+1;
-	    }
-
-	    tv.tv_sec = BLOCKING_TIMEOUT;
-	    tv.tv_usec = 0;
-	    count = select(fd_count,buffer_f_in == -1? NULL: &r_fds,
-			   &w_fds,NULL,&tv);
-
-	    if (count == -1 && errno != EINTR) {
-		    if (verbose > 1) 
-			    rprintf(FERROR,"select error: %s\n", strerror(errno));
-		    exit_cleanup(1);
-	    }
-
-	    if (count == 0) {
-		    check_timeout();
-		    continue;
-	    }
-      
-	    if (FD_ISSET(fd, &w_fds)) {
-		    got_select = 1;
-	    }
-    } else {
-	    total += ret;
-    }
-  }
+		if (ret == -1 && !(errno == EWOULDBLOCK || errno == EAGAIN)) 
+			return -1;
+
+		if (ret == -1 && got_select) {
+			/* hmmm, we got a write select on the fd and
+			   then failed to write.  Why doesn't that
+			   mean that the fd is dead? It doesn't on
+			   some systems it seems (eg. IRIX) */
+			u_sleep(1000);
+		}
+
+		got_select = 0;
+
+
+		if (ret != -1) {
+			total += ret;
+			continue;
+		}
+
+		if (read_buffer_len < MAX_READ_BUFFER && buffer_f_in != -1)
+			read_check(buffer_f_in);
+
+		fd_count = fd+1;
+		FD_ZERO(&w_fds);
+		FD_ZERO(&r_fds);
+		FD_SET(fd,&w_fds);
+		if (buffer_f_in != -1) {
+			FD_SET(buffer_f_in,&r_fds);
+			if (buffer_f_in > fd) 
+				fd_count = buffer_f_in+1;
+		}
 
-  if (io_timeout)
-	  last_io = time(NULL);
+		tv.tv_sec = BLOCKING_TIMEOUT;
+		tv.tv_usec = 0;
+		count = select(fd_count,buffer_f_in == -1? NULL: &r_fds,
+			       &w_fds,NULL,&tv);
+		
+		if (count == -1 && errno != EINTR) {
+			if (verbose > 1) 
+				rprintf(FERROR,"select error: %s\n", strerror(errno));
+			exit_cleanup(1);
+		}
+		
+		if (count == 0) {
+			check_timeout();
+			continue;
+		}
+		
+		if (FD_ISSET(fd, &w_fds)) {
+			got_select = 1;
+		}
+	}
 
-  return total;
+	if (io_timeout)
+		last_io = time(NULL);
+	
+	return total;
 }
 
+
 static char *io_buffer;
 static int io_buffer_count;
 
 void io_start_buffering(int fd)
 {
-	io_buffer = (char *)malloc(IO_BUFFER_SIZE);
+	if (io_buffer) return;
+	multiplex_out_fd = fd;
+	io_buffer = (char *)malloc(IO_BUFFER_SIZE+4);
 	if (!io_buffer) out_of_memory("writefd");
 	io_buffer_count = 0;
+
+	/* leave room for the multiplex header in case it's needed */
+	io_buffer += 4;
 }
 
-void io_end_buffering(int fd)
+void io_flush(void)
 {
-	if (io_buffer_count) {
-		if (writefd_unbuffered(fd, io_buffer, 
-				       io_buffer_count) != 
+	int fd = multiplex_out_fd;
+	if (!io_buffer_count) return;
+
+	if (io_multiplexing_out) {
+		SIVAL(io_buffer-4, 0, (MPLEX_BASE<<24) + io_buffer_count);
+		if (writefd_unbuffered(fd, io_buffer-4, io_buffer_count+4) !=
+		    io_buffer_count+4) {
+			rprintf(FERROR,"write failed\n");
+			exit_cleanup(1);
+		}
+	} else {
+		if (writefd_unbuffered(fd, io_buffer, io_buffer_count) != 
 		    io_buffer_count) {
 			rprintf(FERROR,"write failed\n");
 			exit_cleanup(1);
 		}
-		io_buffer_count = 0;
 	}
-	free(io_buffer);
-	io_buffer = NULL;
+	io_buffer_count = 0;
+}
+
+void io_end_buffering(int fd)
+{
+	io_flush();
+	if (!io_multiplexing_out) {
+		free(io_buffer-4);
+		io_buffer = NULL;
+	}
 }
 
 static int writefd(int fd,char *buf,int len1)
 {
 	int len = len1;
 
@@ -417,37 +527,30 @@
 			memcpy(io_buffer+io_buffer_count, buf, n);
 			buf += n;
 			len -= n;
 			io_buffer_count += n;
 		}
 		
-		if (io_buffer_count == IO_BUFFER_SIZE) {
-			if (writefd_unbuffered(fd, io_buffer, 
-					       io_buffer_count) != 
-			    io_buffer_count) {
-				return -1;
-			}
-			io_buffer_count = 0;
-		}
+		if (io_buffer_count == IO_BUFFER_SIZE) io_flush();
 	}
 
 	return len1;
 }
 
 
 void write_int(int f,int32 x)
 {
-  int ret;
-  char b[4];
-  SIVAL(b,0,x);
-  if ((ret=writefd(f,b,4)) != 4) {
-    rprintf(FERROR,"write_int failed : %s\n",
-	    ret==-1?strerror(errno):"EOF");
-    exit_cleanup(1);
-  }
-  total_written += 4;
+	int ret;
+	char b[4];
+	SIVAL(b,0,x);
+	if ((ret=writefd(f,b,4)) != 4) {
+		rprintf(FERROR,"write_int failed : %s\n",
+			ret==-1?strerror(errno):"EOF");
+		exit_cleanup(1);
+	}
+	total_written += 4;
 }
 
 void write_longint(int f, int64 x)
 {
 	extern int remote_version;
 	char b[8];
@@ -469,19 +572,19 @@
 	}
 	total_written += 8;
 }
 
 void write_buf(int f,char *buf,int len)
 {
-  int ret;
-  if ((ret=writefd(f,buf,len)) != len) {
-    rprintf(FERROR,"write_buf failed : %s\n",
-	    ret==-1?strerror(errno):"EOF");
-    exit_cleanup(1);
-  }
-  total_written += len;
+	int ret;
+	if ((ret=writefd(f,buf,len)) != len) {
+		rprintf(FERROR,"write_buf failed : %s\n",
+			ret==-1?strerror(errno):"EOF");
+		exit_cleanup(1);
+	}
+	total_written += len;
 }
 
 /* write a string to the connection */
 void write_sbuf(int f,char *buf)
 {
 	write_buf(f, buf, strlen(buf));
@@ -530,6 +633,48 @@
 	va_end(ap);
 
 	if (len < 0) exit_cleanup(1);
 
 	write_sbuf(fd, buf);
 }
+
+
+/* setup for multiplexing an error stream with the data stream */
+void io_start_multiplex_out(int fd)
+{
+	multiplex_out_fd = fd;
+	io_flush();
+	io_start_buffering(fd);
+	io_multiplexing_out = 1;
+}
+
+/* setup for multiplexing an error stream with the data stream */
+void io_start_multiplex_in(int fd)
+{
+	multiplex_in_fd = fd;
+	io_flush();
+	if (read_buffer_len) {
+		fprintf(stderr,"ERROR: data in read buffer at mplx start\n");
+		exit_cleanup(1);
+	}
+
+	io_multiplexing_in = 1;
+}
+
+/* write an message to the error stream */
+int io_multiplex_write(int f, char *buf, int len)
+{
+	if (!io_multiplexing_out) return 0;
+
+	io_flush();
+
+	SIVAL(io_buffer-4, 0, ((MPLEX_BASE + f)<<24) + len);
+	memcpy(io_buffer, buf, len);
+
+	writefd_unbuffered(multiplex_out_fd, io_buffer-4, len+4);
+	return 1;
+}
+
+void io_close_input(int fd)
+{
+	buffer_f_in = -1;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/log.c	1998-05-15 18:57:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/log.c	1998-05-18 18:30:43.000000000 +0800
@@ -53,12 +53,18 @@
 {
 	va_list ap;  
 	char buf[1024];
 	int len;
 	FILE *f=NULL;
 	extern int am_daemon;
+	/* recursion can happen with certain fatal conditions */
+	static int depth;
+
+	if (depth) return;
+
+	depth++;
 
 	va_start(ap, format);
 	len = vslprintf(buf, sizeof(buf)-1, format, ap);
 	va_end(ap);
 
 	if (len < 0) exit_cleanup(1);
@@ -69,13 +75,17 @@
 
 	if (am_daemon) {
 		int priority = LOG_INFO;
 		if (fd == FERROR) priority = LOG_WARNING;
 
 		log_open();
-		syslog(priority, "%s", buf);
+		if (!io_multiplex_write(fd, buf, strlen(buf))) {
+			syslog(priority, "%s", buf);
+		}
+
+		depth--;
 		return;
 	}
 
 	if (fd == FERROR) {
 		f = stderr;
 	} 
@@ -88,12 +98,14 @@
 			f = stdout;
 	} 
 
 	if (!f) exit_cleanup(1);
 
 	if (fwrite(buf, len, 1, f) != 1) exit_cleanup(1);
+
+	depth--;
 }
 
 void rflush(int fd)
 {
 	FILE *f = NULL;
 	extern int am_daemon;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/main.c	1998-05-17 23:18:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/main.c	1998-05-18 18:30:43.000000000 +0800
@@ -32,15 +32,15 @@
 	time_t t = time(NULL);
 	extern int am_server;
 	extern int am_sender;
 	extern int am_daemon;
 
 	if (am_daemon) {
-		rprintf(FINFO, "wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
-			(double)write_total(),(double)read_total(),
-			(double)total_size);
+		syslog(LOG_INFO,"wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
+		       (double)write_total(),(double)read_total(),
+		       (double)total_size);
 		if (f == -1 || !am_sender) return;
 	}
 
 	if (!verbose) return;
 
 	if (am_server && am_sender) {
@@ -215,49 +215,63 @@
 		argc=1;
 		argv--;
 		argv[0] = ".";
 	}
 	
 	flist = send_file_list(f_out,argc,argv);
+	if (!flist || flist->count == 0) {
+		exit_cleanup(0);
+	}
+
 	send_files(flist,f_out,f_in);
 	report(f_out);
+	io_flush();
 	exit_cleanup(0);
 }
 
 
 static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
 {
 	int pid;
 	int status=0;
 	int recv_pipe[2];
 	extern int preserve_hard_links;
-	extern int am_daemon;
+	extern int am_server;
 
 	if (preserve_hard_links)
 		init_hard_links(flist);
 
 	if (pipe(recv_pipe) < 0) {
 		rprintf(FERROR,"pipe failed in do_recv\n");
-		exit(1);
+		exit_cleanup(1);
 	}
   
+	io_flush();
 
 	if ((pid=do_fork()) == 0) {
 		close(recv_pipe[0]);
 		if (f_in != f_out) close(f_out);
+
 		recv_files(f_in,flist,local_name,recv_pipe[1]);
-		if (am_daemon) report(-1);
-		exit_cleanup(0);
+		if (!am_server)
+			report(f_in);
+
+		if (verbose > 3)
+			rprintf(FINFO,"do_recv waiting on %d\n",pid);
+
+		io_flush();
+		_exit(0);
 	}
 
 	close(recv_pipe[1]);
+	io_close_input(f_in);
 	if (f_in != f_out) close(f_in);
 	generate_files(f_out,flist,local_name,recv_pipe[0]);
 
+	io_flush();
 	waitpid(pid, &status, 0);
-
 	return status;
 }
 
 
 static void do_server_recv(int f_in, int f_out, int argc,char *argv[])
 {
@@ -284,13 +298,13 @@
 
 	if (delete_mode)
 		recv_exclude_list(f_in);
 
 	flist = recv_file_list(f_in);
 	if (!flist || flist->count == 0) {
-		rprintf(FERROR,"nothing to do\n");
+		rprintf(FERROR,"server_recv: nothing to do\n");
 		exit_cleanup(1);
 	}
 	
 	if (argc > 0) {    
 		if (strcmp(dir,".")) {
 			argv[0] += strlen(dir);
@@ -341,34 +355,36 @@
 		flist = send_file_list(f_out,argc,argv);
 		if (verbose > 3) 
 			rprintf(FINFO,"file list sent\n");
 		send_files(flist,f_out,f_in);
 		if (pid != -1) {
 			if (verbose > 3)
-				rprintf(FINFO,"waiting on %d\n",pid);
+				rprintf(FINFO,"client_run waiting on %d\n",pid);
+			io_flush();
 			waitpid(pid, &status, 0);
 		}
 		report(-1);
 		exit_cleanup(status);
 	}
 	
 	send_exclude_list(f_out);
 	
 	flist = recv_file_list(f_in);
 	if (!flist || flist->count == 0) {
-		rprintf(FINFO,"nothing to do\n");
+		rprintf(FINFO,"client: nothing to do\n");
 		exit_cleanup(0);
 	}
 	
 	local_name = get_local_name(flist,argv[0]);
 	
 	status2 = do_recv(f_in,f_out,flist,local_name);
 	
-	report(f_in);
-	
 	if (pid != -1) {
+		if (verbose > 3)
+			rprintf(FINFO,"client_run2 waiting on %d\n",pid);
+		io_flush();
 		waitpid(pid, &status, 0);
 	}
 	
 	return status | status2;
 }
 
@@ -480,13 +496,13 @@
 
 	starttime = time(NULL);
 	am_root = (getuid() == 0);
 
 	if (argc < 2) {
 		usage(FERROR);
-		exit(1);
+		exit_cleanup(1);
 	}
 
 	/* we set a 0 umask so that correct file permissions can be
 	   carried across */
 	orig_umask = (int)umask(0);
 
@@ -504,13 +520,13 @@
 	if (am_daemon) {
 		return daemon_main();
 	}
 
 	if (argc < 1) {
 		usage(FERROR);
-		exit(1);
+		exit_cleanup(1);
 	}
 
 	if (dry_run)
 		verbose = MAX(verbose,1);
 
 #ifndef SUPPORT_LINKS
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/options.c	1998-05-10 15:25:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/options.c	1998-05-18 18:30:43.000000000 +0800
@@ -51,12 +51,13 @@
 int read_only = 0;
 int module_id = -1;
 int am_server = 0;
 int am_sender=0;
 int recurse = 0;
 int am_daemon=0;
+int am_client=0;
 
 int block_size=BLOCK_SIZE;
 
 char *backup_suffix = BACKUP_SUFFIX;
 char *tmpdir = NULL;
 char *config_file = RSYNCD_CONF;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/packaging/redhat/5.0/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/packaging/redhat/5.0/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/packaging/redhat/5.0/rsync.spec	1998-05-17 23:18:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/packaging/redhat/5.0/rsync.spec	1998-05-18 18:30:47.000000000 +0800
@@ -1,13 +1,13 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.0.8
+Version: 2.0.9
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
-Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.0.8.tar.gz
+Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-2.0.9.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
 BuildRoot: /tmp/rsync
 
 %description
 rsync is a replacement for rcp that has many more features.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/proto.h	1998-05-17 22:57:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/proto.h	1998-05-18 18:30:43.000000000 +0800
@@ -47,21 +47,26 @@
 void read_buf(int f,char *buf,int len);
 void read_sbuf(int f,char *buf,int len);
 unsigned char read_byte(int f);
 int sparse_end(int f);
 int write_file(int f,char *buf,int len);
 void io_start_buffering(int fd);
+void io_flush(void);
 void io_end_buffering(int fd);
 void write_int(int f,int32 x);
 void write_longint(int f, int64 x);
 void write_buf(int f,char *buf,int len);
 void write_sbuf(int f,char *buf);
 void write_byte(int f,unsigned char c);
 void write_flush(int f);
 int read_line(int f, char *buf, int maxlen);
 void io_printf(int fd, const char *format, ...);
+void io_start_multiplex_out(int fd);
+void io_start_multiplex_in(int fd);
+int io_multiplex_write(int f, char *buf, int len);
+void io_close_input(int fd);
 char *lp_motd_file(void);
 char *lp_lock_file(void);
 char *lp_socket_options(void);
 int lp_max_connections(void);
 int lp_syslog_facility(void);
 char *lp_name(int );
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/rsync.c	1998-05-15 18:57:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/rsync.c	1998-05-18 18:30:44.000000000 +0800
@@ -720,12 +720,13 @@
 }
 
 static char *cleanup_fname;
 
 void exit_cleanup(int code)
 {
+	io_flush();
 	if (cleanup_fname)
 		do_unlink(cleanup_fname);
 	signal(SIGUSR1, SIG_IGN);
 	if (code) {
 		kill_all(SIGUSR1);
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/rsync.h	1998-05-17 22:57:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/rsync.h	1998-05-18 18:30:44.000000000 +0800
@@ -38,13 +38,13 @@
 #define SAME_DIR (1<<5)
 #define SAME_NAME SAME_DIR
 #define LONG_NAME (1<<6)
 #define SAME_TIME (1<<7)
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 17
+#define PROTOCOL_VERSION 18
 #define MIN_PROTOCOL_VERSION 11
 #define MAX_PROTOCOL_VERSION 30
 
 #define RSYNC_PORT 873
 
 #define SPARSE_WRITE_SIZE (1024)
@@ -55,12 +55,13 @@
 #define MAX_READ_BUFFER (1024*1024)
 
 #define MAX_ARGS 1000
 
 #define BLOCKING_TIMEOUT 10
 
+#define MPLEX_BASE 7
 #define FERROR 1
 #define FINFO 2
 
 #include "config.h"
 
 #if HAVE_REMSH
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/socket.c	1998-05-15 22:10:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/socket.c	1998-05-18 18:30:44.000000000 +0800
@@ -122,18 +122,18 @@
 
 	signal(SIGCHLD, SIG_IGN);
 
 	/* open an incoming socket */
 	s = open_socket_in(SOCK_STREAM, port);
 	if (s == -1)
-		exit(1);
+		exit_cleanup(1);
 
 	/* ready to listen */
 	if (listen(s, 5) == -1) {
 		close(s);
-		exit(1);
+		exit_cleanup(1);
 	}
 
 
 	/* now accept incoming connections - forking a new process
 	   for each incoming connection */
 	while (1) {
@@ -305,13 +305,13 @@
 	struct sockaddr sa;
 	struct sockaddr_in *sockin = (struct sockaddr_in *) (&sa);
 	int     length = sizeof(sa);
 	static char addr_buf[100];
 
 	if (getpeername(fd, &sa, &length)) {
-		exit(1);
+		exit_cleanup(1);
 	}
 
 	strlcpy(addr_buf,(char *)inet_ntoa(sockin->sin_addr), sizeof(addr_buf)-1);
 
 	return addr_buf;
 }
@@ -328,13 +328,13 @@
 	static char name_buf[100];
 	struct hostent *hp;
 
 	strcpy(name_buf,"UNKNOWN");
 
 	if (getpeername(fd, &sa, &length)) {
-		exit(1);
+		exit_cleanup(1);
 	}
 
 	/* Look up the remote host name. */
 	if ((hp = gethostbyaddr((char *) &sockin->sin_addr,
 				sizeof(sockin->sin_addr),
 				AF_INET))) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/util.c	1998-05-16 08:54:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/util.c	1998-05-18 18:30:44.000000000 +0800
@@ -630,21 +630,21 @@
 	   that is secure and portable. This is it.  */
 
 	if (!buf) {
 		buf = malloc(len);
 		if (!buf) {
 			/* can't call debug or we would recurse */
-			exit(1);
+			exit_cleanup(1);
 		}
 	}
 
 	vsprintf(buf, format, ap);
 	ret = strlen(buf);
 	if (ret > n) {
 		/* yikes! */
-		exit(1);
+		exit_cleanup(1);
 	}
 	buf[ret] = 0;
 	
 	memcpy(str, buf, ret+1);
 
 	return ret;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/version.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/version.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.8/version.h	1998-05-17 23:18:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.0.9/version.h	1998-05-18 18:30:46.000000000 +0800
@@ -1 +1 @@
-#define VERSION "2.0.8"
+#define VERSION "2.0.9"
