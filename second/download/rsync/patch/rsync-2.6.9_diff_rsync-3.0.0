diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/access.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/access.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/access.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/access.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,25 +1,24 @@
 /*
  * Routines to authenticate access to a daemon (hosts allow/deny).
  *
  * Copyright (C) 1998 Andrew Tridgell
- * Copyright (C) 2004, 2005 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 static int match_hostname(char *host, char *tok)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/aclocal.m4 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/aclocal.m4
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/aclocal.m4	2001-11-28 11:12:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/aclocal.m4	2007-11-03 04:52:33.000000000 +0800
@@ -65,7 +65,28 @@
       AC_DEFINE_UNQUOTED(socklen_t, $rsync_cv_socklen_t_equiv,
 			[type to use in place of socklen_t if not defined])],
       [#include <sys/types.h>
 #include <sys/socket.h>])
 ])
 
-
+dnl AC_HAVE_TYPE(TYPE,INCLUDES)
+AC_DEFUN([AC_HAVE_TYPE], [
+AC_REQUIRE([AC_HEADER_STDC])
+cv=`echo "$1" | sed 'y%./+- %__p__%'`
+AC_MSG_CHECKING(for $1)
+AC_CACHE_VAL([ac_cv_type_$cv],
+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+AC_INCLUDES_DEFAULT
+$2]],
+[[$1 foo;]])],
+[eval "ac_cv_type_$cv=yes"],
+[eval "ac_cv_type_$cv=no"]))dnl
+ac_foo=`eval echo \\$ac_cv_type_$cv`
+AC_MSG_RESULT($ac_foo)
+if test "$ac_foo" = yes; then
+  ac_tr_hdr=HAVE_`echo $1 | sed 'y%abcdefghijklmnopqrstuvwxyz./- %ABCDEFGHIJKLMNOPQRSTUVWXYZ____%'`
+if false; then
+	AC_CHECK_TYPES($1)
+fi
+  AC_DEFINE_UNQUOTED($ac_tr_hdr, 1, [Define if you have type `$1'])
+fi
+])
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: acls.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/authenticate.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/authenticate.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,40 +1,39 @@
 /*
  * Support rsync daemon authentication.
  *
  * Copyright (C) 1998-2000 Andrew Tridgell
- * Copyright (C) 2002, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2002-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern char *password_file;
 
 /***************************************************************************
 encode a buffer using base64 - simple and slow algorithm. null terminates
 the result.
   ***************************************************************************/
-void base64_encode(char *buf, int len, char *out, int pad)
+void base64_encode(const char *buf, int len, char *out, int pad)
 {
 	char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 	int bit_offset, byte_offset, idx, i;
-	unsigned char *d = (unsigned char *)buf;
+	const uchar *d = (const uchar *)buf;
 	int bytes = (len*8 + 5)/6;
 
 	for (i = 0; i < bytes; i++) {
 		byte_offset = (i*6)/8;
 		bit_offset = (i*6)%8;
 		if (bit_offset < 3) {
@@ -52,42 +51,44 @@
 		out[i++] = '=';
 
 	out[i] = '\0';
 }
 
 /* Generate a challenge buffer and return it base64-encoded. */
-static void gen_challenge(char *addr, char *challenge)
+static void gen_challenge(const char *addr, char *challenge)
 {
 	char input[32];
-	char md4_out[MD4_SUM_LENGTH];
+	char digest[MAX_DIGEST_LEN];
 	struct timeval tv;
+	int len;
 
 	memset(input, 0, sizeof input);
 
-	strlcpy((char *)input, addr, 17);
+	strlcpy(input, addr, 17);
 	sys_gettimeofday(&tv);
 	SIVAL(input, 16, tv.tv_sec);
 	SIVAL(input, 20, tv.tv_usec);
 	SIVAL(input, 24, getpid());
 
 	sum_init(0);
 	sum_update(input, sizeof input);
-	sum_end(md4_out);
+	len = sum_end(digest);
 
-	base64_encode(md4_out, MD4_SUM_LENGTH, challenge, 0);
+	base64_encode(digest, len, challenge, 0);
 }
 
 
 /* Return the secret for a user from the secret file, null terminated.
  * Maximum length is len (not counting the null). */
-static int get_secret(int module, char *user, char *secret, int len)
+static int get_secret(int module, const char *user, char *secret, int len)
 {
-	char *fname = lp_secrets_file(module);
+	const char *fname = lp_secrets_file(module);
 	STRUCT_STAT st;
 	int fd, ok = 1;
-	char ch, *p;
+	const char *p;
+	char ch, *s;
 
 	if (!fname || !*fname)
 		return 0;
 
 	if ((fd = open(fname, O_RDONLY)) < 0)
 		return 0;
@@ -133,66 +134,63 @@
 			else
 				p = NULL;
 		}
 	}
 
 	/* Slurp the secret into the "secret" buffer. */
-	p = secret;
+	s = secret;
 	while (len > 0) {
-		if (read(fd, p, 1) != 1 || *p == '\n')
+		if (read(fd, s, 1) != 1 || *s == '\n')
 			break;
-		if (*p == '\r')
+		if (*s == '\r')
 			continue;
-		p++;
+		s++;
 		len--;
 	}
-	*p = '\0';
+	*s = '\0';
 	close(fd);
 
 	return 1;
 }
 
-static char *getpassf(char *filename)
+static const char *getpassf(const char *filename)
 {
 	STRUCT_STAT st;
 	char buffer[512], *p;
 	int fd, n, ok = 1;
-	char *envpw = getenv("RSYNC_PASSWORD");
+	const char *envpw = getenv("RSYNC_PASSWORD");
 
 	if (!filename)
 		return NULL;
 
 	if ((fd = open(filename,O_RDONLY)) < 0) {
-		rsyserr(FERROR, errno, "could not open password file \"%s\"",
+		rsyserr(FWARNING, errno, "could not open password file \"%s\"",
 			filename);
 		if (envpw)
-			rprintf(FERROR, "falling back to RSYNC_PASSWORD environment variable.\n");
+			rprintf(FINFO, "falling back to RSYNC_PASSWORD environment variable.\n");
 		return NULL;
 	}
 
 	if (do_stat(filename, &st) == -1) {
-		rsyserr(FERROR, errno, "stat(%s)", filename);
+		rsyserr(FWARNING, errno, "stat(%s)", filename);
 		ok = 0;
 	} else if ((st.st_mode & 06) != 0) {
-		rprintf(FERROR,"password file must not be other-accessible\n");
+		rprintf(FWARNING, "password file must not be other-accessible\n");
 		ok = 0;
 	} else if (MY_UID() == 0 && st.st_uid != 0) {
-		rprintf(FERROR,"password file must be owned by root when running as root\n");
+		rprintf(FWARNING, "password file must be owned by root when running as root\n");
 		ok = 0;
 	}
 	if (!ok) {
-		rprintf(FERROR,"continuing without password file\n");
-		if (envpw)
-			rprintf(FERROR, "using RSYNC_PASSWORD environment variable.\n");
 		close(fd);
+		rprintf(FWARNING, "continuing without password file\n");
+		if (envpw)
+			rprintf(FINFO, "falling back to RSYNC_PASSWORD environment variable.\n");
 		return NULL;
 	}
 
-	if (envpw)
-		rprintf(FERROR, "RSYNC_PASSWORD environment variable ignored\n");
-
 	n = read(fd, buffer, sizeof buffer - 1);
 	close(fd);
 	if (n > 0) {
 		buffer[n] = '\0';
 		if ((p = strtok(buffer, "\n\r")) != NULL)
 			return strdup(p);
@@ -200,49 +198,50 @@
 
 	return NULL;
 }
 
 /* Generate an MD4 hash created from the combination of the password
  * and the challenge string and return it base64-encoded. */
-static void generate_hash(char *in, char *challenge, char *out)
+static void generate_hash(const char *in, const char *challenge, char *out)
 {
-	char buf[MD4_SUM_LENGTH];
+	char buf[MAX_DIGEST_LEN];
+	int len;
 
 	sum_init(0);
 	sum_update(in, strlen(in));
 	sum_update(challenge, strlen(challenge));
-	sum_end(buf);
+	len = sum_end(buf);
 
-	base64_encode(buf, MD4_SUM_LENGTH, out, 0);
+	base64_encode(buf, len, out, 0);
 }
 
 /* Possibly negotiate authentication with the client.  Use "leader" to
  * start off the auth if necessary.
  *
  * Return NULL if authentication failed.  Return "" if anonymous access.
  * Otherwise return username.
  */
-char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
-		  char *leader)
+char *auth_server(int f_in, int f_out, int module, const char *host,
+		  const char *addr, const char *leader)
 {
 	char *users = lp_auth_users(module);
-	char challenge[MD4_SUM_LENGTH*2];
+	char challenge[MAX_DIGEST_LEN*2];
 	char line[BIGPATHBUFLEN];
 	char secret[512];
-	char pass2[MD4_SUM_LENGTH*2];
+	char pass2[MAX_DIGEST_LEN*2];
 	char *tok, *pass;
 
 	/* if no auth list then allow anyone in! */
 	if (!users || !*users)
 		return "";
 
 	gen_challenge(addr, challenge);
 
 	io_printf(f_out, "%s%s\n", leader, challenge);
 
-	if (!read_line(f_in, line, sizeof line - 1)
+	if (!read_line_old(f_in, line, sizeof line)
 	 || (pass = strchr(line, ' ')) == NULL) {
 		rprintf(FLOG, "auth failed on module %s from %s (%s): "
 			"invalid challenge response\n",
 			lp_name(module), host, addr);
 		return NULL;
 	}
@@ -283,17 +282,16 @@
 		return NULL;
 	}
 
 	return strdup(line);
 }
 
-
-void auth_client(int fd, char *user, char *challenge)
+void auth_client(int fd, const char *user, const char *challenge)
 {
-	char *pass;
-	char pass2[MD4_SUM_LENGTH*2];
+	const char *pass;
+	char pass2[MAX_DIGEST_LEN*2];
 
 	if (!user || !*user)
 		user = "nobody";
 
 	if (!(pass = getpassf(password_file))
 	 && !(pass = getenv("RSYNC_PASSWORD"))) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/backup.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/backup.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,44 +1,44 @@
 /*
  * Backup handling code.
  *
  * Copyright (C) 1999 Andrew Tridgell
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
-extern int backup_dir_len;
-extern unsigned int backup_dir_remainder;
-extern char backup_dir_buf[MAXPATHLEN];
-extern char *backup_suffix;
-extern char *backup_dir;
-
 extern int am_root;
+extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_devices;
 extern int preserve_specials;
 extern int preserve_links;
 extern int safe_symlinks;
+extern int backup_dir_len;
+extern unsigned int backup_dir_remainder;
+extern char backup_dir_buf[MAXPATHLEN];
+extern char *backup_suffix;
+extern char *backup_dir;
 
 /* make a complete pathname for backup file */
-char *get_backup_name(char *fname)
+char *get_backup_name(const char *fname)
 {
 	if (backup_dir) {
 		if (stringjoin(backup_dir_buf + backup_dir_len, backup_dir_remainder,
 			       fname, backup_suffix, NULL) < backup_dir_remainder)
 			return backup_dir_buf;
 	} else {
@@ -49,16 +49,16 @@
 
 	rprintf(FERROR, "backup filename too long\n");
 	return NULL;
 }
 
 /* simple backup creates a backup with a suffix in the same directory */
-static int make_simple_backup(char *fname)
+static int make_simple_backup(const char *fname)
 {
 	int rename_errno;
-	char *fnamebak = get_backup_name(fname);
+	const char *fnamebak = get_backup_name(fname);
 
 	if (!fnamebak)
 		return 0;
 
 	while (1) {
 		if (do_rename(fname, fnamebak) == 0) {
@@ -89,113 +89,160 @@
 
 
 /****************************************************************************
 Create a directory given an absolute path, perms based upon another directory
 path
 ****************************************************************************/
-static int make_bak_dir(char *fullpath)
+int make_bak_dir(const char *fullpath)
 {
-	STRUCT_STAT st;
-	char *rel = fullpath + backup_dir_len;
-	char *end = rel + strlen(rel);
-	char *p = end;
+	char fbuf[MAXPATHLEN], *rel, *end, *p;
+	struct file_struct *file;
+	int len = backup_dir_len;
+	stat_x sx;
 
-	while (strncmp(fullpath, "./", 2) == 0)
+	while (*fullpath == '.' && fullpath[1] == '/') {
 		fullpath += 2;
+		len -= 2;
+	}
+
+	if (strlcpy(fbuf, fullpath, sizeof fbuf) >= sizeof fbuf)
+		return -1;
+
+	rel = fbuf + len;
+	end = p = rel + strlen(rel);
 
 	/* Try to find an existing dir, starting from the deepest dir. */
 	while (1) {
-		if (--p == fullpath) {
-			p += strlen(p);
-			goto failure;
-		}
+		if (--p == fbuf)
+			return -1;
 		if (*p == '/') {
 			*p = '\0';
-			if (mkdir_defmode(fullpath) == 0)
+			if (mkdir_defmode(fbuf) == 0)
 				break;
 			if (errno != ENOENT) {
 				rsyserr(FERROR, errno,
 					"make_bak_dir mkdir %s failed",
-					full_fname(fullpath));
-				goto failure;
+					full_fname(fbuf));
+				return -1;
 			}
 		}
 	}
 
 	/* Make all the dirs that we didn't find on the way here. */
 	while (1) {
 		if (p >= rel) {
 			/* Try to transfer the directory settings of the
 			 * actual dir that the files are coming from. */
-			if (do_stat(rel, &st) < 0) {
+			if (x_stat(rel, &sx.st, NULL) < 0) {
 				rsyserr(FERROR, errno,
 					"make_bak_dir stat %s failed",
 					full_fname(rel));
 			} else {
-				do_lchown(fullpath, st.st_uid, st.st_gid);
-				do_chmod(fullpath, st.st_mode);
+#ifdef SUPPORT_ACLS
+				sx.acc_acl = sx.def_acl = NULL;
+#endif
+#ifdef SUPPORT_XATTRS
+				sx.xattr = NULL;
+#endif
+				if (!(file = make_file(rel, NULL, NULL, 0, NO_FILTERS)))
+					continue;
+#ifdef SUPPORT_ACLS
+				if (preserve_acls && !S_ISLNK(file->mode)) {
+					get_acl(rel, &sx);
+					cache_acl(file, &sx);
+					free_acl(&sx);
+				}
+#endif
+#ifdef SUPPORT_XATTRS
+				if (preserve_xattrs) {
+					get_xattr(rel, &sx);
+					cache_xattr(file, &sx);
+					free_xattr(&sx);
+				}
+#endif
+				set_file_attrs(fbuf, file, NULL, NULL, 0);
+				unmake_file(file);
 			}
 		}
 		*p = '/';
 		p += strlen(p);
 		if (p == end)
 			break;
-		if (mkdir_defmode(fullpath) < 0) {
+		if (mkdir_defmode(fbuf) < 0) {
 			rsyserr(FERROR, errno, "make_bak_dir mkdir %s failed",
-				full_fname(fullpath));
-			goto failure;
+				full_fname(fbuf));
+			return -1;
 		}
 	}
-	return 0;
 
-  failure:
-	while (p != end) {
-		*p = '/';
-		p += strlen(p);
-	}
-	return -1;
+	return 0;
 }
 
 /* robustly move a file, creating new directory structures if necessary */
-static int robust_move(char *src, char *dst)
+static int robust_move(const char *src, char *dst)
 {
 	if (robust_rename(src, dst, NULL, 0755) < 0
 	 && (errno != ENOENT || make_bak_dir(dst) < 0
 	  || robust_rename(src, dst, NULL, 0755) < 0))
 		return -1;
 	return 0;
 }
 
 
 /* If we have a --backup-dir, then we get here from make_backup().
  * We will move the file to be deleted into a parallel directory tree. */
-static int keep_backup(char *fname)
+static int keep_backup(const char *fname)
 {
-	STRUCT_STAT st;
+	stat_x sx;
 	struct file_struct *file;
 	char *buf;
 	int kept = 0;
 	int ret_code;
 
 	/* return if no file to keep */
-	if (do_lstat(fname, &st) < 0)
+	if (x_lstat(fname, &sx.st, NULL) < 0)
 		return 1;
+#ifdef SUPPORT_ACLS
+	sx.acc_acl = sx.def_acl = NULL;
+#endif
+#ifdef SUPPORT_XATTRS
+	sx.xattr = NULL;
+#endif
 
 	if (!(file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
 		return 1; /* the file could have disappeared */
 
-	if (!(buf = get_backup_name(fname)))
+	if (!(buf = get_backup_name(fname))) {
+		unmake_file(file);
 		return 0;
+	}
+
+#ifdef SUPPORT_ACLS
+	if (preserve_acls && !S_ISLNK(file->mode)) {
+		get_acl(fname, &sx);
+		cache_acl(file, &sx);
+		free_acl(&sx);
+	}
+#endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs) {
+		get_xattr(fname, &sx);
+		cache_xattr(file, &sx);
+		free_xattr(&sx);
+	}
+#endif
 
 	/* Check to see if this is a device file, or link */
 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
 	 || (preserve_specials && IS_SPECIAL(file->mode))) {
+		uint32 *devp = F_RDEV_P(file);
+		dev_t rdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
 		do_unlink(buf);
-		if (do_mknod(buf, file->mode, file->u.rdev) < 0
+		if (do_mknod(buf, file->mode, rdev) < 0
 		    && (errno != ENOENT || make_bak_dir(buf) < 0
-		     || do_mknod(buf, file->mode, file->u.rdev) < 0)) {
+		     || do_mknod(buf, file->mode, rdev) < 0)) {
 			rsyserr(FERROR, errno, "mknod %s failed",
 				full_fname(buf));
 		} else if (verbose > 2) {
 			rprintf(FINFO, "make_backup: DEVICE %s successful.\n",
 				fname);
 		}
@@ -219,62 +266,63 @@
 		}
 		kept = 1;
 	}
 
 #ifdef SUPPORT_LINKS
 	if (!kept && preserve_links && S_ISLNK(file->mode)) {
-		if (safe_symlinks && unsafe_symlink(file->u.link, buf)) {
+		const char *sl = F_SYMLINK(file);
+		if (safe_symlinks && unsafe_symlink(sl, buf)) {
 			if (verbose) {
 				rprintf(FINFO, "ignoring unsafe symlink %s -> %s\n",
-					full_fname(buf), file->u.link);
+					full_fname(buf), sl);
 			}
 			kept = 1;
 		} else {
 			do_unlink(buf);
-			if (do_symlink(file->u.link, buf) < 0
+			if (do_symlink(sl, buf) < 0
 			    && (errno != ENOENT || make_bak_dir(buf) < 0
-			     || do_symlink(file->u.link, buf) < 0)) {
+			     || do_symlink(sl, buf) < 0)) {
 				rsyserr(FERROR, errno, "link %s -> \"%s\"",
-					full_fname(buf),
-					file->u.link);
+					full_fname(buf), sl);
 			}
 			do_unlink(fname);
 			kept = 1;
 		}
 	}
 #endif
 
 	if (!kept && !S_ISREG(file->mode)) {
 		rprintf(FINFO, "make_bak: skipping non-regular file %s\n",
 			fname);
+		unmake_file(file);
 		return 1;
 	}
 
 	/* move to keep tree if a file */
 	if (!kept) {
 		if (robust_move(fname, buf) != 0) {
 			rsyserr(FERROR, errno, "keep_backup failed: %s -> \"%s\"",
 				full_fname(fname), buf);
-		} else if (st.st_nlink > 1) {
+		} else if (sx.st.st_nlink > 1) {
 			/* If someone has hard-linked the file into the backup
 			 * dir, rename() might return success but do nothing! */
 			robust_unlink(fname); /* Just in case... */
 		}
 	}
-	set_file_attrs(buf, file, NULL, 0);
-	free(file);
+	set_file_attrs(buf, file, NULL, fname, 0);
+	unmake_file(file);
 
 	if (verbose > 1) {
 		rprintf(FINFO, "backed up %s to %s\n",
 			fname, buf);
 	}
 	return 1;
 }
 
 
 /* main backup switch routine */
-int make_backup(char *fname)
+int make_backup(const char *fname)
 {
 	if (backup_dir)
 		return keep_backup(fname);
 	return make_simple_backup(fname);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/batch.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/batch.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,26 +1,25 @@
 /*
  * Support for the batch-file options.
  *
  * Copyright (C) 1999 Weiss
  * Copyright (C) 2004 Chris Shoemaker
- * Copyright (C) 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 #include "zlib/zlib.h"
 #include <time.h>
 
@@ -29,32 +28,48 @@
 extern int xfer_dirs;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
+extern int preserve_acls;
+extern int preserve_xattrs;
 extern int always_checksum;
 extern int do_compression;
-extern int def_compress_level;
+extern int inplace;
+extern int append_mode;
 extern int protocol_version;
 extern char *batch_name;
+#ifdef ICONV_OPTION
+extern char *iconv_opt;
+#endif
 
 extern struct filter_list_struct filter_list;
 
-static int tweaked_compress_level;
+int batch_stream_flags;
+
+static int tweaked_append;
+static int tweaked_append_verify;
+static int tweaked_iconv;
 
 static int *flag_ptr[] = {
 	&recurse,		/* 0 */
 	&preserve_uid,		/* 1 */
 	&preserve_gid,		/* 2 */
 	&preserve_links,	/* 3 */
 	&preserve_devices,	/* 4 */
 	&preserve_hard_links,	/* 5 */
 	&always_checksum,	/* 6 */
 	&xfer_dirs,		/* 7 (protocol 29) */
-	&tweaked_compress_level,/* 8 (protocol 29) */
+	&do_compression,	/* 8 (protocol 29) */
+	&tweaked_iconv,		/* 9  (protocol 30) */
+	&preserve_acls,		/* 10 (protocol 30) */
+	&preserve_xattrs,	/* 11 (protocol 30) */
+	&inplace,		/* 12 (protocol 30) */
+	&tweaked_append,	/* 13 (protocol 30) */
+	&tweaked_append_verify,	/* 14 (protocol 30) */
 	NULL
 };
 
 static char *flag_name[] = {
 	"--recurse (-r)",
 	"--owner (-o)",
@@ -62,45 +77,67 @@
 	"--links (-l)",
 	"--devices (-D)",
 	"--hard-links (-H)",
 	"--checksum (-c)",
 	"--dirs (-d)",
 	"--compress (-z)",
+	"--iconv",
+	"--acls (-A)",
+	"--xattrs (-X)",
+	"--inplace",
+	"--append",
+	"--append-verify",
 	NULL
 };
 
 void write_stream_flags(int fd)
 {
 	int i, flags;
 
-#if Z_DEFAULT_COMPRESSION == -1
-	tweaked_compress_level = do_compression ? def_compress_level + 2 : 0;
-#else
-#error internal logic error!  Fix def_compress_level logic above and below too!
+	tweaked_append = append_mode == 1;
+	tweaked_append_verify = append_mode == 2;
+#ifdef ICONV_OPTION
+	tweaked_iconv = iconv_opt != NULL;
 #endif
 
 	/* Start the batch file with a bitmap of data-stream-affecting
 	 * flags. */
-	if (protocol_version < 29)
-		flag_ptr[7] = NULL;
 	for (i = 0, flags = 0; flag_ptr[i]; i++) {
 		if (*flag_ptr[i])
 			flags |= 1 << i;
 	}
 	write_int(fd, flags);
 }
 
 void read_stream_flags(int fd)
 {
-	int i, flags;
+	batch_stream_flags = read_int(fd);
+}
+
+void check_batch_flags(void)
+{
+	int i;
 
 	if (protocol_version < 29)
 		flag_ptr[7] = NULL;
-	for (i = 0, flags = read_int(fd); flag_ptr[i]; i++) {
-		int set = flags & (1 << i) ? 1 : 0;
+	else if (protocol_version < 30)
+		flag_ptr[9] = NULL;
+	tweaked_append = append_mode == 1;
+	tweaked_append_verify = append_mode == 2;
+#ifdef ICONV_OPTION
+	tweaked_iconv = iconv_opt != NULL;
+#endif
+	for (i = 0; flag_ptr[i]; i++) {
+		int set = batch_stream_flags & (1 << i) ? 1 : 0;
 		if (*flag_ptr[i] != set) {
+			if (i == 9) {
+				rprintf(FERROR,
+					"%s specify the --iconv option to use this batch file.\n",
+					set ? "Please" : "Do not");
+				exit_cleanup(RERR_SYNTAX);
+			}
 			if (verbose) {
 				rprintf(FINFO,
 					"%sing the %s option to match the batchfile.\n",
 					set ? "Sett" : "Clear", flag_name[i]);
 			}
 			*flag_ptr[i] = set;
@@ -110,18 +147,16 @@
 		if (recurse)
 			xfer_dirs |= 1;
 		else if (xfer_dirs < 2)
 			xfer_dirs = 0;
 	}
 
-	if (tweaked_compress_level == 0 || tweaked_compress_level == 2)
-		do_compression = 0;
-	else {
-		do_compression = 1;
-		def_compress_level = tweaked_compress_level - 2;
-	}
+	if (tweaked_append)
+		append_mode = 1;
+	else if (tweaked_append_verify)
+		append_mode = 2;
 }
 
 static void write_arg(int fd, char *arg)
 {
 	char *x, *s;
 
@@ -177,13 +212,13 @@
 		   batch_name, ".sh", NULL);
 	fd = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
 		     S_IRUSR | S_IWUSR | S_IEXEC);
 	if (fd < 0) {
 		rsyserr(FERROR, errno, "Batch file %s open error",
 			filename);
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILESELECT);
 	}
 
 	/* Write argvs info to BATCH.sh file */
 	write_arg(fd, argv[0]);
 	if (filter_list.head) {
 		if (protocol_version >= 29)
@@ -223,9 +258,9 @@
 	write_byte(fd, '}');
 	if (filter_list.head)
 		write_filter_rules(fd);
 	if (write(fd, "\n", 1) != 1 || close(fd) < 0) {
 		rsyserr(FERROR, errno, "Batch file %s write error",
 			filename);
-		exit_cleanup(1);
+		exit_cleanup(RERR_FILEIO);
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/byteorder.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/byteorder.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/byteorder.h	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/byteorder.h	2008-03-02 04:01:41.000000000 +0800
@@ -1,46 +1,45 @@
 /*
  * Simple byteorder handling.
  *
  * Copyright (C) 1992-1995 Andrew Tridgell
+ * Copyright (C) 2007-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #undef CAREFUL_ALIGNMENT
 
-/* we know that the x86 can handle misalignment and has the "right"
-   byteorder */
+/* We know that the x86 can handle misalignment and has the same
+ * byte order (LSB-first) as the 32-bit numbers we transmit. */
 #ifdef __i386__
 #define CAREFUL_ALIGNMENT 0
 #endif
 
 #ifndef CAREFUL_ALIGNMENT
 #define CAREFUL_ALIGNMENT 1
 #endif
 
 #define CVAL(buf,pos) (((unsigned char *)(buf))[pos])
-#define PVAL(buf,pos) ((unsigned)CVAL(buf,pos))
+#define UVAL(buf,pos) ((uint32)CVAL(buf,pos))
 #define SCVAL(buf,pos,val) (CVAL(buf,pos) = (val))
 
-
 #if CAREFUL_ALIGNMENT
-#define SVAL(buf,pos) (PVAL(buf,pos)|PVAL(buf,(pos)+1)<<8)
-#define IVAL(buf,pos) (SVAL(buf,pos)|SVAL(buf,(pos)+2)<<16)
+#define PVAL(buf,pos) (UVAL(buf,pos)|UVAL(buf,(pos)+1)<<8)
+#define IVAL(buf,pos) (PVAL(buf,pos)|PVAL(buf,(pos)+2)<<16)
 #define SSVALX(buf,pos,val) (CVAL(buf,pos)=(val)&0xFF,CVAL(buf,pos+1)=(val)>>8)
 #define SIVALX(buf,pos,val) (SSVALX(buf,pos,val&0xFFFF),SSVALX(buf,pos+2,val>>16))
 #define SIVAL(buf,pos,val) SIVALX((buf),(pos),((uint32)(val)))
 #else
 /* this handles things for architectures like the 386 that can handle
    alignment errors */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/case_N.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/case_N.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/case_N.h	2006-10-15 23:57:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/case_N.h	2008-03-02 04:01:41.000000000 +0800
@@ -1,24 +1,23 @@
 /*
  * End-of-run cleanup helper code used by cleanup.c.
  *
- * Copyright (C) 2006 Wayne Davison
+ * Copyright (C) 2006-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* This is included by cleanup.c multiple times, once for every segement in
  * the _exit_cleanup() code.  This produces the next "case N:" statement in
  * sequence and increments the cleanup_step variable by 1.  This ensures that
  * our case statements never get out of whack due to added/removed steps. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/checksum.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/checksum.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,37 +1,34 @@
 /*
  * Routines to support checksumming of bytes.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2004, 2005 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
-int csum_length=2; /* initial value */
-
-#define CSUM_CHUNK 64
-
 extern int checksum_seed;
 extern int protocol_version;
 
+int csum_length = SHORT_SUM_LENGTH; /* initial value */
+
 /*
   a simple 32 bit checksum that can be upadted from either end
   (inspired by Mark Adler's Adler-32 checksum)
   */
 uint32 get_checksum1(char *buf1, int32 len)
 {
@@ -51,137 +48,178 @@
     return (s1 & 0xffff) + (s2 << 16);
 }
 
 
 void get_checksum2(char *buf, int32 len, char *sum)
 {
-	int32 i;
-	static char *buf1;
-	static int32 len1;
-	struct mdfour m;
+	md_context m;
 
-	if (len > len1) {
-		if (buf1)
-			free(buf1);
-		buf1 = new_array(char, len+4);
-		len1 = len;
-		if (!buf1)
-			out_of_memory("get_checksum2");
-	}
-
-	mdfour_begin(&m);
+	if (protocol_version >= 30) {
+		uchar seedbuf[4];
+		md5_begin(&m);
+		md5_update(&m, (uchar *)buf, len);
+		if (checksum_seed) {
+			SIVAL(seedbuf, 0, checksum_seed);
+			md5_update(&m, seedbuf, 4);
+		}
+		md5_result(&m, (uchar *)sum);
+	} else {
+		int32 i;
+		static char *buf1;
+		static int32 len1;
+
+		mdfour_begin(&m);
+
+		if (len > len1) {
+			if (buf1)
+				free(buf1);
+			buf1 = new_array(char, len+4);
+			len1 = len;
+			if (!buf1)
+				out_of_memory("get_checksum2");
+		}
+
+		memcpy(buf1, buf, len);
+		if (checksum_seed) {
+			SIVAL(buf1,len,checksum_seed);
+			len += 4;
+		}
+
+		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK)
+			mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);
+
+		/*
+		 * Prior to version 27 an incorrect MD4 checksum was computed
+		 * by failing to call mdfour_tail() for block sizes that
+		 * are multiples of 64.  This is fixed by calling mdfour_update()
+		 * even when there are no more bytes.
+		 */
+		if (len - i > 0 || protocol_version >= 27)
+			mdfour_update(&m, (uchar *)(buf1+i), len-i);
 
-	memcpy(buf1,buf,len);
-	if (checksum_seed) {
-		SIVAL(buf1,len,checksum_seed);
-		len += 4;
+		mdfour_result(&m, (uchar *)sum);
 	}
-
-	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
-		mdfour_update(&m, (uchar *)(buf1+i), CSUM_CHUNK);
-	}
-	/*
-	 * Prior to version 27 an incorrect MD4 checksum was computed
-	 * by failing to call mdfour_tail() for block sizes that
-	 * are multiples of 64.  This is fixed by calling mdfour_update()
-	 * even when there are no more bytes.
-	 */
-	if (len - i > 0 || protocol_version >= 27) {
-		mdfour_update(&m, (uchar *)(buf1+i), (len-i));
-	}
-
-	mdfour_result(&m, (uchar *)sum);
 }
 
-
-void file_checksum(char *fname,char *sum,OFF_T size)
+void file_checksum(char *fname, char *sum, OFF_T size)
 {
-	OFF_T i;
 	struct map_struct *buf;
+	OFF_T i, len = size;
+	md_context m;
+	int32 remainder;
 	int fd;
-	OFF_T len = size;
-	struct mdfour m;
 
-	memset(sum,0,MD4_SUM_LENGTH);
+	memset(sum, 0, MAX_DIGEST_LEN);
 
 	fd = do_open(fname, O_RDONLY, 0);
 	if (fd == -1)
 		return;
 
 	buf = map_file(fd, size, MAX_MAP_SIZE, CSUM_CHUNK);
 
-	mdfour_begin(&m);
-
-	for(i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
-		mdfour_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
-			      CSUM_CHUNK);
-	}
+	if (protocol_version >= 30) {
+		md5_begin(&m);
 
-	/* Prior to version 27 an incorrect MD4 checksum was computed
-	 * by failing to call mdfour_tail() for block sizes that
-	 * are multiples of 64.  This is fixed by calling mdfour_update()
-	 * even when there are no more bytes. */
-	if (len - i > 0 || protocol_version >= 27)
-		mdfour_update(&m, (uchar *)map_ptr(buf, i, len-i), len-i);
+		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+			md5_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
+				   CSUM_CHUNK);
+		}
+
+		remainder = (int32)(len - i);
+		if (remainder > 0)
+			md5_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
+
+		md5_result(&m, (uchar *)sum);
+	} else {
+		mdfour_begin(&m);
+
+		for (i = 0; i + CSUM_CHUNK <= len; i += CSUM_CHUNK) {
+			mdfour_update(&m, (uchar *)map_ptr(buf, i, CSUM_CHUNK),
+				      CSUM_CHUNK);
+		}
+
+		/* Prior to version 27 an incorrect MD4 checksum was computed
+		 * by failing to call mdfour_tail() for block sizes that
+		 * are multiples of 64.  This is fixed by calling mdfour_update()
+		 * even when there are no more bytes. */
+		remainder = (int32)(len - i);
+		if (remainder > 0 || protocol_version >= 27)
+			mdfour_update(&m, (uchar *)map_ptr(buf, i, remainder), remainder);
 
-	mdfour_result(&m, (uchar *)sum);
+		mdfour_result(&m, (uchar *)sum);
+	}
 
 	close(fd);
 	unmap_file(buf);
 }
 
-
 static int32 sumresidue;
-static char sumrbuf[CSUM_CHUNK];
-static struct mdfour md;
+static md_context md;
 
 void sum_init(int seed)
 {
 	char s[4];
-	mdfour_begin(&md);
-	sumresidue = 0;
-	SIVAL(s, 0, seed);
-	sum_update(s, 4);
+
+	if (protocol_version >= 30)
+		md5_begin(&md);
+	else {
+		mdfour_begin(&md);
+		sumresidue = 0;
+		SIVAL(s, 0, seed);
+		sum_update(s, 4);
+	}
 }
 
 /**
  * Feed data into an MD4 accumulator, md.  The results may be
  * retrieved using sum_end().  md is used for different purposes at
  * different points during execution.
  *
  * @todo Perhaps get rid of md and just pass in the address each time.
  * Very slightly clearer and slower.
  **/
-void sum_update(char *p, int32 len)
+void sum_update(const char *p, int32 len)
 {
+	if (protocol_version >= 30) {
+		md5_update(&md, (uchar *)p, len);
+		return;
+	}
+
 	if (len + sumresidue < CSUM_CHUNK) {
-		memcpy(sumrbuf + sumresidue, p, len);
+		memcpy(md.buffer + sumresidue, p, len);
 		sumresidue += len;
 		return;
 	}
 
 	if (sumresidue) {
 		int32 i = CSUM_CHUNK - sumresidue;
-		memcpy(sumrbuf + sumresidue, p, i);
-		mdfour_update(&md, (uchar *)sumrbuf, CSUM_CHUNK);
+		memcpy(md.buffer + sumresidue, p, i);
+		mdfour_update(&md, (uchar *)md.buffer, CSUM_CHUNK);
 		len -= i;
 		p += i;
 	}
 
 	while (len >= CSUM_CHUNK) {
 		mdfour_update(&md, (uchar *)p, CSUM_CHUNK);
 		len -= CSUM_CHUNK;
 		p += CSUM_CHUNK;
 	}
 
 	sumresidue = len;
 	if (sumresidue)
-		memcpy(sumrbuf, p, sumresidue);
+		memcpy(md.buffer, p, sumresidue);
 }
 
-void sum_end(char *sum)
+int sum_end(char *sum)
 {
+	if (protocol_version >= 30) {
+		md5_result(&md, (uchar *)sum);
+		return MD5_DIGEST_LEN;
+	}
+
 	if (sumresidue || protocol_version >= 27)
-		mdfour_update(&md, (uchar *)sumrbuf, sumresidue);
+		mdfour_update(&md, (uchar *)md.buffer, sumresidue);
 
 	mdfour_result(&md, (uchar *)sum);
+
+	return MD4_DIGEST_LEN;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/chmod.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/chmod.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/chmod.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/chmod.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,25 +1,24 @@
 /*
  * Implement the core of the --chmod option.
  *
  * Copyright (C) 2002 Scott Howard
- * Copyright (C) 2005, 2006 Wayne Davison
+ * Copyright (C) 2005-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern mode_t orig_umask;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/cleanup.c	2006-10-15 23:43:26.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/cleanup.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,36 +1,35 @@
 /*
  * End-of-run cleanup routines.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int am_server;
 extern int am_daemon;
 extern int io_error;
 extern int keep_partial;
-extern int log_got_error;
+extern int got_xfer_error;
 extern char *partial_dir;
 extern char *logfile_name;
 
 #ifdef HAVE_SIGACTION
 static struct sigaction sigact;
 #endif
@@ -76,14 +75,14 @@
  * Handling the cleanup when a transfer is interrupted is tricky when
  * --partial is selected.  We need to ensure that the partial file is
  * kept if any real data has been transferred.
  **/
 int cleanup_got_literal = 0;
 
-static char *cleanup_fname;
-static char *cleanup_new_fname;
+static const char *cleanup_fname;
+static const char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
 static int cleanup_fd_r, cleanup_fd_w;
 static pid_t cleanup_pid = 0;
 
 pid_t cleanup_child_pid = -1;
 
@@ -101,12 +100,17 @@
 	SIGACTION(SIGUSR1, SIG_IGN);
 	SIGACTION(SIGUSR2, SIG_IGN);
 
 	if (exit_code) /* Preserve first error code when recursing. */
 		code = exit_code;
 
+	/* If this is the exit at the end of the run, the server side
+	 * should not attempt to output a message (see log.c). */
+	if (am_server && code == 0)
+		am_server = 2;
+
 	/* Some of our actions might cause a recursive call back here, so we
 	 * keep track of where we are in the cleanup and never repeat a step. */
 	switch (cleanup_step) {
 #include "case_N.h" /* case 0: cleanup_step++; */
 
 		exit_code = unmodified_code = code;
@@ -132,21 +136,21 @@
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 
 		if (cleanup_got_literal && cleanup_fname && cleanup_new_fname
 		 && keep_partial && handle_partial_dir(cleanup_new_fname, PDIR_CREATE)) {
-			char *fname = cleanup_fname;
+			const char *fname = cleanup_fname;
 			cleanup_fname = NULL;
 			if (cleanup_fd_r != -1)
 				close(cleanup_fd_r);
 			if (cleanup_fd_w != -1) {
 				flush_write_file(cleanup_fd_w);
 				close(cleanup_fd_w);
 			}
-			finish_transfer(cleanup_new_fname, fname, NULL,
+			finish_transfer(cleanup_new_fname, fname, NULL, NULL,
 					cleanup_file, 0, !partial_dir);
 		}
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 
@@ -167,13 +171,13 @@
 
 		if (code == 0) {
 			if (io_error & IOERR_DEL_LIMIT)
 				code = exit_code = RERR_DEL_LIMIT;
 			if (io_error & IOERR_VANISHED)
 				code = exit_code = RERR_VANISHED;
-			if (io_error & IOERR_GENERAL || log_got_error)
+			if (io_error & IOERR_GENERAL || got_xfer_error)
 				code = exit_code = RERR_PARTIAL;
 		}
 
 		if (code || am_daemon || (logfile_name && (am_server || !verbose)))
 			log_exit(code, file, line);
 
@@ -187,12 +191,14 @@
 				unmodified_code, file, line, code);
 		}
 
 		/* FALLTHROUGH */
 #include "case_N.h"
 
+		if (am_server && code)
+			msleep(100);
 		close_all();
 
 		/* FALLTHROUGH */
 	default:
 		break;
 	}
@@ -204,13 +210,13 @@
 {
 	cleanup_fname = cleanup_new_fname = NULL;
 	cleanup_got_literal = 0;
 }
 
 
-void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
+void cleanup_set(const char *fnametmp, const char *fname, struct file_struct *file,
 		 int fd_r, int fd_w)
 {
 	cleanup_fname = fnametmp;
 	cleanup_new_fname = fname; /* can be NULL on a partial-dir failure */
 	cleanup_file = file;
 	cleanup_fd_r = fd_r;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/clientname.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/clientname.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/clientname.c	2006-10-14 07:17:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/clientname.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,26 +1,25 @@
 /*
  * Functions for looking up the remote name or addr of a socket.
  *
  * Copyright (C) 1992-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002, 2003, 2004 Wayne Davison
+ * Copyright (C) 2002-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /*
  * This file is now converted to use the new-style getaddrinfo()
  * interface, which supports IPv6 but is also supported on recent
  * IPv4-only machines.  On systems that don't have that interface, we
@@ -264,13 +263,13 @@
 
 		sin1 = (const struct sockaddr_in6 *) ss;
 		sin2 = (const struct sockaddr_in6 *) ai->ai_addr;
 
 		if (ai->ai_addrlen < sizeof (struct sockaddr_in6)) {
 			rprintf(FLOG, "%s: too short sockaddr_in6; length=%d\n",
-				fn, ai->ai_addrlen);
+				fn, (int)ai->ai_addrlen);
 			return 1;
 		}
 
 		if (memcmp(&sin1->sin6_addr, &sin2->sin6_addr,
 			   sizeof sin1->sin6_addr))
 			return 1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/clientserver.c	2006-10-24 08:36:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/clientserver.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,68 +1,82 @@
 /*
  * The socket based protocol for setting up a connection with rsyncd.
  *
  * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001-2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002, 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2002-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
 
 extern int verbose;
-extern int quiet;
+extern int dry_run;
 extern int output_motd;
 extern int list_only;
 extern int am_sender;
 extern int am_server;
 extern int am_daemon;
 extern int am_root;
 extern int rsync_port;
+extern int ignore_errors;
 extern int kluge_around_eof;
 extern int daemon_over_rsh;
 extern int sanitize_paths;
+extern int numeric_ids;
 extern int filesfrom_fd;
 extern int remote_protocol;
 extern int protocol_version;
 extern int io_timeout;
 extern int no_detach;
+extern int write_batch;
 extern int default_af_hint;
 extern int logfile_format_has_i;
 extern int logfile_format_has_o_or_i;
 extern mode_t orig_umask;
 extern char *bind_address;
 extern char *sockopts;
 extern char *config_file;
 extern char *logfile_format;
 extern char *files_from;
 extern char *tmpdir;
 extern struct chmod_mode_struct *chmod_modes;
 extern struct filter_list_struct server_filter_list;
+extern char curr_dir[];
+#ifdef ICONV_OPTION
+extern char *iconv_opt;
+extern iconv_t ic_send, ic_recv;
+#endif
 
 char *auth_user;
 int read_only = 0;
 int module_id = -1;
+int munge_symlinks = 0;
 struct chmod_mode_struct *daemon_chmod_modes;
 
-/* Length of lp_path() string when in daemon mode & not chrooted, else 0. */
+/* module_dirlen is the length of the module_dir string when in daemon
+ * mode and module_dir is not "/"; otherwise 0.  (Note that a chroot-
+ * enabled module can have a non-"/" module_dir these days.) */
+char *module_dir = NULL;
 unsigned int module_dirlen = 0;
 
+static int rl_nulls = 0;
+
 #ifdef HAVE_SIGACTION
 static struct sigaction sigact;
 #endif
 
 /**
  * Run a client connected to an rsyncd.  The alternative to this
@@ -75,21 +89,22 @@
  * Instead of doing a transfer, the client may at this stage instead
  * get a listing of remote modules and exit.
  *
  * @return -1 for error in startup, or the result of client_run().
  * Either way, it eventually gets passed to exit_cleanup().
  **/
-int start_socket_client(char *host, char *path, int argc, char *argv[])
+int start_socket_client(char *host, int remote_argc, char *remote_argv[],
+			int argc, char *argv[])
 {
 	int fd, ret;
 	char *p, *user = NULL;
 
 	/* This is redundant with code in start_inband_exchange(), but this
 	 * short-circuits a problem in the client before we open a socket,
 	 * and the extra check won't hurt. */
-	if (*path == '/') {
+	if (**remote_argv == '/') {
 		rprintf(FERROR,
 			"ERROR: The remote path must start with a module name not a /\n");
 		return -1;
 	}
 
 	if ((p = strrchr(host, '@')) != NULL) {
@@ -102,86 +117,169 @@
 				     default_af_hint);
 	if (fd == -1)
 		exit_cleanup(RERR_SOCKETIO);
 
 	set_socket_options(fd, sockopts);
 
-	ret = start_inband_exchange(user, path, fd, fd, argc);
+#ifdef ICONV_CONST
+	setup_iconv();
+#endif
+
+	ret = start_inband_exchange(fd, fd, user, remote_argc, remote_argv);
 
 	return ret ? ret : client_run(fd, fd, -1, argc, argv);
 }
 
-int start_inband_exchange(char *user, char *path, int f_in, int f_out,
-			  int argc)
+static int exchange_protocols(int f_in, int f_out, char *buf, size_t bufsiz, int am_client)
 {
-	int i;
+	int remote_sub = -1;
+#if SUBPROTOCOL_VERSION != 0
+	int our_sub = protocol_version < PROTOCOL_VERSION ? 0 : SUBPROTOCOL_VERSION;
+#else
+	int our_sub = 0;
+#endif
+	char *motd;
+
+	io_printf(f_out, "@RSYNCD: %d.%d\n", protocol_version, our_sub);
+
+	if (!am_client) {
+		motd = lp_motd_file();
+		if (motd && *motd) {
+			FILE *f = fopen(motd,"r");
+			while (f && !feof(f)) {
+				int len = fread(buf, 1, bufsiz - 1, f);
+				if (len > 0)
+					write_buf(f_out, buf, len);
+			}
+			if (f)
+				fclose(f);
+			write_sbuf(f_out, "\n");
+		}
+	}
+
+	/* This strips the \n. */
+	if (!read_line_old(f_in, buf, bufsiz)) {
+		if (am_client)
+			rprintf(FERROR, "rsync: did not see server greeting\n");
+		return -1;
+	}
+
+	if (sscanf(buf, "@RSYNCD: %d.%d", &remote_protocol, &remote_sub) < 1) {
+		if (am_client)
+			rprintf(FERROR, "rsync: server sent \"%s\" rather than greeting\n", buf);
+		else
+			io_printf(f_out, "@ERROR: protocol startup error\n");
+		return -1;
+	}
+
+	if (remote_sub < 0) {
+		if (remote_protocol == 30) {
+			if (am_client)
+				rprintf(FERROR, "rsync: server is speaking an incompatible beta of protocol 30\n");
+			else
+				io_printf(f_out, "@ERROR: your client is speaking an incompatible beta of protocol 30\n");
+			return -1;
+		}
+		remote_sub = 0;
+	}
+
+	if (protocol_version > remote_protocol) {
+		protocol_version = remote_protocol;
+		if (remote_sub)
+			protocol_version--;
+	} else if (protocol_version == remote_protocol) {
+		if (remote_sub != our_sub)
+			protocol_version--;
+	}
+#if SUBPROTOCOL_VERSION != 0
+	else if (protocol_version < remote_protocol) {
+		if (our_sub)
+			protocol_version--;
+	}
+#endif
+
+	if (protocol_version >= 30)
+		rl_nulls = 1;
+
+	return 0;
+}
+
+int start_inband_exchange(int f_in, int f_out, const char *user, int argc, char *argv[])
+{
+	int i, modlen;
+	char line[BIGPATHBUFLEN];
 	char *sargs[MAX_ARGS];
 	int sargc = 0;
-	char line[BIGPATHBUFLEN];
-	char *p;
+	char *p, *modname;
 
-	if (argc == 0 && !am_sender)
-		list_only |= 1;
+	assert(argc > 0);
 
-	if (*path == '/') {
+	if (**argv == '/') {
 		rprintf(FERROR,
 			"ERROR: The remote path must start with a module name\n");
 		return -1;
 	}
 
+	if (!(p = strchr(*argv, '/')))
+		modlen = strlen(*argv);
+	else
+		modlen = p - *argv;
+
+	if (!(modname = new_array(char, modlen+1+1))) /* room for '/' & '\0' */
+		out_of_memory("start_inband_exchange");
+	strlcpy(modname, *argv, modlen + 1);
+	modname[modlen] = '/';
+	modname[modlen+1] = '\0';
+
 	if (!user)
 		user = getenv("USER");
 	if (!user)
 		user = getenv("LOGNAME");
 
-	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
-
-	if (!read_line(f_in, line, sizeof line - 1)) {
-		rprintf(FERROR, "rsync: did not see server greeting\n");
+	if (exchange_protocols(f_in, f_out, line, sizeof line, 1) < 0)
 		return -1;
-	}
-
-	if (sscanf(line,"@RSYNCD: %d", &remote_protocol) != 1) {
-		/* note that read_line strips of \n or \r */
-		rprintf(FERROR, "rsync: server sent \"%s\" rather than greeting\n",
-			line);
-		return -1;
-	}
-	if (protocol_version > remote_protocol)
-		protocol_version = remote_protocol;
-
-	if (list_only && protocol_version >= 29)
-		list_only |= 2;
 
 	/* set daemon_over_rsh to false since we need to build the
 	 * true set of args passed through the rsh/ssh connection;
 	 * this is a no-op for direct-socket-connection mode */
 	daemon_over_rsh = 0;
 	server_options(sargs, &sargc);
 
+	if (sargc >= MAX_ARGS - 2)
+		goto arg_overflow;
+
 	sargs[sargc++] = ".";
 
-	if (path && *path)
-		sargs[sargc++] = path;
+	while (argc > 0) {
+		if (sargc >= MAX_ARGS - 1) {
+		  arg_overflow:
+			rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if (strncmp(*argv, modname, modlen) == 0
+		 && argv[0][modlen] == '\0')
+			sargs[sargc++] = modname; /* we send "modname/" */
+		else
+			sargs[sargc++] = *argv;
+		argv++;
+		argc--;
+	}
 
 	sargs[sargc] = NULL;
 
 	if (verbose > 1)
-		print_child_argv(sargs);
+		print_child_argv("sending daemon args:", sargs);
 
-	p = strchr(path,'/');
-	if (p) *p = 0;
-	io_printf(f_out, "%s\n", path);
-	if (p) *p = '/';
+	io_printf(f_out, "%.*s\n", modlen, modname);
 
 	/* Old servers may just drop the connection here,
 	 rather than sending a proper EXIT command.  Yuck. */
 	kluge_around_eof = list_only && protocol_version < 25 ? 1 : 0;
 
 	while (1) {
-		if (!read_line(f_in, line, sizeof line - 1)) {
+		if (!read_line_old(f_in, line, sizeof line)) {
 			rprintf(FERROR, "rsync: didn't get server startup line\n");
 			return -1;
 		}
 
 		if (strncmp(line,"@RSYNCD: AUTHREQD ",18) == 0) {
 			auth_client(f_out, user, line+18);
@@ -210,83 +308,103 @@
 		 * no way to differentiate it.  The manpage mentions this. */
 		if (output_motd)
 			rprintf(FINFO, "%s\n", line);
 	}
 	kluge_around_eof = 0;
 
-	for (i = 0; i < sargc; i++) {
-		io_printf(f_out, "%s\n", sargs[i]);
+	if (rl_nulls) {
+		for (i = 0; i < sargc; i++) {
+			write_sbuf(f_out, sargs[i]);
+			write_byte(f_out, 0);
+		}
+		write_byte(f_out, 0);
+	} else {
+		for (i = 0; i < sargc; i++)
+			io_printf(f_out, "%s\n", sargs[i]);
+		write_sbuf(f_out, "\n");
 	}
-	io_printf(f_out, "\n");
 
 	if (protocol_version < 23) {
 		if (protocol_version == 22 || !am_sender)
 			io_start_multiplex_in();
 	}
 
+	free(modname);
+
 	return 0;
 }
 
 static char *finish_pre_exec(pid_t pid, int fd, char *request,
 			     int argc, char *argv[])
 {
 	int j, status = -1;
 
-	if (request) {
-		write_buf(fd, request, strlen(request)+1);
-		for (j = 0; j < argc; j++)
-			write_buf(fd, argv[j], strlen(argv[j])+1);
-	}
+	if (!request)
+		request = "(NONE)";
 
+	write_buf(fd, request, strlen(request)+1);
+	for (j = 0; j < argc; j++)
+		write_buf(fd, argv[j], strlen(argv[j])+1);
 	write_byte(fd, 0);
 
 	close(fd);
 
 	if (wait_process(pid, &status, 0) < 0
 	 || !WIFEXITED(status) || WEXITSTATUS(status) != 0) {
 		char *e;
-		if (asprintf(&e, "pre-xfer exec returned failure (%d)\n", status) < 0)
+		if (asprintf(&e, "pre-xfer exec returned failure (%d)%s%s\n",
+			     status, status < 0 ? ": " : "",
+			     status < 0 ? strerror(errno) : "") < 0)
 			out_of_memory("finish_pre_exec");
 		return e;
 	}
 	return NULL;
 }
 
 static int read_arg_from_pipe(int fd, char *buf, int limit)
 {
 	char *bp = buf, *eob = buf + limit - 1;
 
 	while (1) {
-	    if (read(fd, bp, 1) != 1)
+	    int got = read(fd, bp, 1);
+	    if (got != 1) {
+		if (got < 0 && errno == EINTR)
+			continue;
 		return -1;
+	    }
 	    if (*bp == '\0')
 		break;
 	    if (bp < eob)
 		bp++;
 	}
 	*bp = '\0';
 
 	return bp - buf;
 }
 
 static int rsync_module(int f_in, int f_out, int i, char *addr, char *host)
 {
-	int argc = 0;
-	int maxargs;
-	char **argv;
+	int argc, opt_cnt;
+	char **argv, *chroot_path = NULL;
 	char line[BIGPATHBUFLEN];
 	uid_t uid = (uid_t)-2;  /* canonically "nobody" */
 	gid_t gid = (gid_t)-2;
 	char *p, *err_msg = NULL;
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
-	int start_glob = 0;
 	int ret, pre_exec_fd = -1;
 	pid_t pre_exec_pid = 0;
 	char *request = NULL;
 
+#ifdef ICONV_OPTION
+	iconv_opt = lp_charset(i);
+	if (*iconv_opt)
+		setup_iconv();
+	iconv_opt = NULL;
+#endif
+
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
 		rprintf(FLOG, "rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
 		if (!lp_list(i))
 			io_printf(f_out, "@ERROR: Unknown module '%s'\n", name);
 		else {
@@ -337,23 +455,23 @@
 
 	am_root = (MY_UID() == 0);
 
 	if (am_root) {
 		p = lp_uid(i);
 		if (!name_to_uid(p, &uid)) {
-			if (!isdigit(*(unsigned char *)p)) {
+			if (!isDigit(p)) {
 				rprintf(FLOG, "Invalid uid %s\n", p);
 				io_printf(f_out, "@ERROR: invalid uid %s\n", p);
 				return -1;
 			}
 			uid = atoi(p);
 		}
 
 		p = lp_gid(i);
 		if (!name_to_gid(p, &gid)) {
-			if (!isdigit(*(unsigned char *)p)) {
+			if (!isDigit(p)) {
 				rprintf(FLOG, "Invalid gid %s\n", p);
 				io_printf(f_out, "@ERROR: invalid gid %s\n", p);
 				return -1;
 			}
 			gid = atoi(p);
 		}
@@ -363,17 +481,42 @@
 	 * that we change to some uid other than the current one, then
 	 * log a warning. */
 
 	/* TODO: Perhaps take a list of gids, and make them into the
 	 * supplementary groups. */
 
-	if (use_chroot || (module_dirlen = strlen(lp_path(i))) == 1) {
+	module_dir = lp_path(i);
+	if (use_chroot) {
+		if ((p = strstr(module_dir, "/./")) != NULL) {
+			*p = '\0';
+			p += 2;
+		} else if ((p = strdup("/")) == NULL)
+			out_of_memory("rsync_module");
+	}
+
+	/* We do a push_dir() that doesn't actually call chdir()
+	 * just to make a relative path absolute. */
+	strlcpy(line, curr_dir, sizeof line);
+	if (!push_dir(module_dir, 1))
+		goto chdir_failed;
+	if (strcmp(curr_dir, module_dir) != 0
+	 && (module_dir = strdup(curr_dir)) == NULL)
+		out_of_memory("rsync_module");
+	push_dir(line, 1); /* Restore curr_dir. */
+
+	if (use_chroot) {
+		chroot_path = module_dir;
+		module_dir = p; /* p is "/" or our inside-chroot path */
+	}
+	module_dirlen = clean_fname(module_dir, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);
+
+	if (module_dirlen == 1) {
 		module_dirlen = 0;
 		set_filter_dir("/", 1);
 	} else
-		set_filter_dir(lp_path(i), module_dirlen);
+		set_filter_dir(module_dir, module_dirlen);
 
 	p = lp_filter(i);
 	parse_rule(&server_filter_list, p, MATCHFLG_WORD_SPLIT,
 		   XFLG_ABS_IF_SLASH);
 
 	p = lp_include_from(i);
@@ -396,14 +539,23 @@
 	log_init(1);
 
 #ifdef HAVE_PUTENV
 	if (*lp_prexfer_exec(i) || *lp_postxfer_exec(i)) {
 		char *modname, *modpath, *hostaddr, *hostname, *username;
 		int status;
+
+		if (!use_chroot)
+			p = module_dir;
+		else if (module_dirlen) {
+			pathjoin(line, sizeof line, chroot_path, module_dir+1);
+			p = line;
+		} else
+			p = chroot_path;
+
 		if (asprintf(&modname, "RSYNC_MODULE_NAME=%s", name) < 0
-		 || asprintf(&modpath, "RSYNC_MODULE_PATH=%s", lp_path(i)) < 0
+		 || asprintf(&modpath, "RSYNC_MODULE_PATH=%s", p) < 0
 		 || asprintf(&hostaddr, "RSYNC_HOST_ADDR=%s", addr) < 0
 		 || asprintf(&hostname, "RSYNC_HOST_NAME=%s", host) < 0
 		 || asprintf(&username, "RSYNC_USER_NAME=%s", auth_user) < 0)
 			out_of_memory("rsync_module");
 		putenv(modname);
 		putenv(modpath);
@@ -497,36 +649,43 @@
 		 * might be better to always use chroot.
 		 *
 		 * So, perhaps if we can't chroot we should just issue
 		 * a warning, unless a "require chroot" flag is set,
 		 * in which case we fail.
 		 */
-		if (chroot(lp_path(i))) {
-			rsyserr(FLOG, errno, "chroot %s failed",
-				lp_path(i));
+		if (chroot(chroot_path)) {
+			rsyserr(FLOG, errno, "chroot %s failed", chroot_path);
 			io_printf(f_out, "@ERROR: chroot failed\n");
 			return -1;
 		}
-
-		if (!push_dir("/", 0)) {
-			rsyserr(FLOG, errno, "chdir %s failed\n",
-				lp_path(i));
-			io_printf(f_out, "@ERROR: chdir failed\n");
-			return -1;
-		}
-
+		if (!push_dir(module_dir, 0))
+			goto chdir_failed;
+		if (module_dirlen)
+			sanitize_paths = 1;
 	} else {
-		if (!push_dir(lp_path(i), 0)) {
-			rsyserr(FLOG, errno, "chdir %s failed\n",
-				lp_path(i));
+		if (!push_dir(module_dir, 0)) {
+		  chdir_failed:
+			rsyserr(FLOG, errno, "chdir %s failed\n", module_dir);
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
 
+	if ((munge_symlinks = lp_munge_symlinks(i)) < 0)
+		munge_symlinks = !use_chroot || module_dirlen;
+	if (munge_symlinks) {
+		STRUCT_STAT st;
+		if (stat(SYMLINK_PREFIX, &st) == 0 && S_ISDIR(st.st_mode)) {
+			rprintf(FLOG, "Symlink munging is unsupported when a %s directory exists.\n",
+				SYMLINK_PREFIX);
+			io_printf(f_out, "@ERROR: daemon security issue -- contact admin\n", name);
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+	}
+
 	if (am_root) {
 		/* XXXX: You could argue that if the daemon is started
 		 * by a non-root user and they explicitly specify a
 		 * gid, then we should try to change to that gid --
 		 * this could be possible if it's already in their
 		 * supplementary groups. */
@@ -568,65 +727,31 @@
 			tmpdir = NULL;
 		}
 	}
 
 	io_printf(f_out, "@RSYNCD: OK\n");
 
-	maxargs = MAX_ARGS;
-	if (!(argv = new_array(char *, maxargs)))
-		out_of_memory("rsync_module");
-	argv[argc++] = "rsyncd";
-
-	while (1) {
-		if (!read_line(f_in, line, sizeof line - 1))
-			return -1;
-
-		if (!*line)
-			break;
-
-		p = line;
-
-		if (argc == maxargs) {
-			maxargs += MAX_ARGS;
-			if (!(argv = realloc_array(argv, char *, maxargs)))
-				out_of_memory("rsync_module");
-		}
-		if (!(argv[argc] = strdup(p)))
-			out_of_memory("rsync_module");
-
-		switch (start_glob) {
-		case 0:
-			argc++;
-			if (strcmp(line, ".") == 0)
-				start_glob = 1;
-			break;
-		case 1:
-			if (pre_exec_pid) {
-				err_msg = finish_pre_exec(pre_exec_pid,
-							  pre_exec_fd, p,
-							  argc, argv);
-				pre_exec_pid = 0;
-			}
-			request = strdup(p);
-			start_glob = 2;
-			/* FALL THROUGH */
-		default:
-			if (!err_msg)
-				glob_expand(name, &argv, &argc, &maxargs);
-			break;
-		}
-	}
+	opt_cnt = read_args(f_in, name, line, sizeof line, rl_nulls, &argv, &argc, &request);
 
 	if (pre_exec_pid) {
 		err_msg = finish_pre_exec(pre_exec_pid, pre_exec_fd, request,
-					  argc, argv);
+					  opt_cnt, argv);
 	}
 
 	verbose = 0; /* future verbosity is controlled by client options */
 	ret = parse_arguments(&argc, (const char ***) &argv, 0);
-	quiet = 0; /* Don't let someone try to be tricky. */
+	am_server = 1; /* Don't let someone try to be tricky. */
+	if (lp_ignore_errors(module_id))
+		ignore_errors = 1;
+	if (write_batch < 0)
+		dry_run = 1;
+
+	if (lp_fake_super(i))
+		am_root = -1;
+	else if (am_root < 0) /* Treat --fake-super from client as --super. */
+		am_root = 2;
 
 	if (filesfrom_fd == 0)
 		filesfrom_fd = f_in;
 
 	if (request) {
 		if (*auth_user) {
@@ -675,19 +800,36 @@
 		}
 		io_start_multiplex_out();
 	}
 
 	if (!ret || err_msg) {
 		if (err_msg)
-			rprintf(FERROR, err_msg);
+			rwrite(FERROR, err_msg, strlen(err_msg), 0);
 		else
 			option_error();
 		msleep(400);
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
+#ifdef ICONV_OPTION
+	if (!iconv_opt) {
+		if (ic_send != (iconv_t)-1) {
+			iconv_close(ic_send);
+			ic_send = (iconv_t)-1;
+		}
+		if (ic_recv != (iconv_t)-1) {
+			iconv_close(ic_recv);
+			ic_recv = (iconv_t)-1;
+		}
+	}
+#endif
+
+	if (!numeric_ids
+	 && (use_chroot ? lp_numeric_ids(i) != False : lp_numeric_ids(i) == True))
+		numeric_ids = -1; /* Set --numeric-ids w/o breaking protocol. */
+
 	if (lp_timeout(i) && lp_timeout(i) > io_timeout)
 		set_io_timeout(lp_timeout(i));
 
 	/* If we have some incoming/outgoing chmod changes, append them to
 	 * any user-specified changes (making our changes have priority).
 	 * We also get a pointer to just our changes so that a receiver
@@ -725,13 +867,13 @@
 /* this is called when a connection is established to a client
    and we want to start talking. The setup of the system is done from
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[1024];
-	char *motd, *addr, *host;
+	char *addr, *host;
 	int i;
 
 	io_set_sock_fds(f_in, f_out);
 
 	/* We must load the config file before calling any function that
 	 * might cause log-file output to occur.  This ensures that the
@@ -750,41 +892,17 @@
 			set_socket_options(f_in, sockopts);
 		else
 			set_socket_options(f_in, lp_socket_options());
 		set_nonblocking(f_in);
 	}
 
-	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
-
-	motd = lp_motd_file();
-	if (motd && *motd) {
-		FILE *f = fopen(motd,"r");
-		while (f && !feof(f)) {
-			int len = fread(line, 1, sizeof line - 1, f);
-			if (len > 0) {
-				line[len] = 0;
-				io_printf(f_out, "%s", line);
-			}
-		}
-		if (f)
-			fclose(f);
-		io_printf(f_out, "\n");
-	}
-
-	if (!read_line(f_in, line, sizeof line - 1))
+	if (exchange_protocols(f_in, f_out, line, sizeof line, 0) < 0)
 		return -1;
 
-	if (sscanf(line,"@RSYNCD: %d", &remote_protocol) != 1) {
-		io_printf(f_out, "@ERROR: protocol startup error\n");
-		return -1;
-	}
-	if (protocol_version > remote_protocol)
-		protocol_version = remote_protocol;
-
 	line[0] = 0;
-	if (!read_line(f_in, line, sizeof line - 1))
+	if (!read_line_old(f_in, line, sizeof line))
 		return -1;
 
 	if (!*line || strcmp(line, "#list") == 0) {
 		rprintf(FLOG, "module-list request from %s (%s)\n",
 			host, addr);
 		send_listing(f_out);
@@ -809,15 +927,76 @@
 #endif
 	SIGACTION(SIGCHLD, remember_children);
 
 	return rsync_module(f_in, f_out, i, addr, host);
 }
 
+static void create_pid_file(void)
+{
+	char *pid_file = lp_pid_file();
+	char pidbuf[16];
+	pid_t pid = getpid();
+	int fd;
+
+	if (!pid_file || !*pid_file)
+		return;
+
+	cleanup_set_pid(pid);
+	if ((fd = do_open(pid_file, O_WRONLY|O_CREAT|O_EXCL, 0666 & ~orig_umask)) == -1) {
+		cleanup_set_pid(0);
+		fprintf(stderr, "failed to create pid file %s: %s\n", pid_file, strerror(errno));
+		rsyserr(FLOG, errno, "failed to create pid file %s", pid_file);
+		exit_cleanup(RERR_FILEIO);
+	}
+	snprintf(pidbuf, sizeof pidbuf, "%ld\n", (long)pid);
+	write(fd, pidbuf, strlen(pidbuf));
+	close(fd);
+}
+
+/* Become a daemon, discarding the controlling terminal. */
+static void become_daemon(void)
+{
+	int i;
+	pid_t pid = fork();
+
+	if (pid) {
+		if (pid < 0) {
+			fprintf(stderr, "failed to fork: %s\n", strerror(errno));
+			exit_cleanup(RERR_FILEIO);
+		}
+		_exit(0);
+	}
+
+	create_pid_file();
+
+	/* detach from the terminal */
+#ifdef HAVE_SETSID
+	setsid();
+#elif defined TIOCNOTTY
+	i = open("/dev/tty", O_RDWR);
+	if (i >= 0) {
+		ioctl(i, (int)TIOCNOTTY, (char *)0);
+		close(i);
+	}
+#endif
+	/* make sure that stdin, stdout an stderr don't stuff things
+	 * up (library functions, for example) */
+	for (i = 0; i < 3; i++) {
+		close(i);
+		open("/dev/null", O_RDWR);
+	}
+}
+
 int daemon_main(void)
 {
-	char *pid_file;
+	if (!config_file) {
+		if (am_server && am_root <= 0)
+			config_file = RSYNCD_USERCONF;
+		else
+			config_file = RSYNCD_SYSCONF;
+	}
 
 	if (is_a_socket(STDIN_FILENO)) {
 		int i;
 
 		/* we are running via inetd - close off stdout and
 		 * stderr so that library functions (and getopt) don't
@@ -827,17 +1006,21 @@
 			open("/dev/null", O_RDWR);
 		}
 
 		return start_daemon(STDIN_FILENO, STDIN_FILENO);
 	}
 
-	if (!no_detach)
-		become_daemon();
-
-	if (!lp_load(config_file, 1))
+	if (!lp_load(config_file, 1)) {
+		fprintf(stderr, "Failed to parse config file: %s\n", config_file);
 		exit_cleanup(RERR_SYNTAX);
+	}
+
+	if (no_detach)
+		create_pid_file();
+	else
+		become_daemon();
 
 	if (rsync_port == 0 && (rsync_port = lp_rsync_port()) == 0)
 		rsync_port = RSYNC_PORT;
 	if (bind_address == NULL && *lp_bind_address())
 		bind_address = lp_bind_address();
 
@@ -846,26 +1029,9 @@
 	rprintf(FLOG, "rsyncd version %s starting, listening on port %d\n",
 		RSYNC_VERSION, rsync_port);
 	/* TODO: If listening on a particular address, then show that
 	 * address too.  In fact, why not just do inet_ntop on the
 	 * local address??? */
 
-	if (((pid_file = lp_pid_file()) != NULL) && (*pid_file != '\0')) {
-		char pidbuf[16];
-		int fd;
-		pid_t pid = getpid();
-		cleanup_set_pid(pid);
-		if ((fd = do_open(lp_pid_file(), O_WRONLY|O_CREAT|O_TRUNC,
-					0666 & ~orig_umask)) == -1) {
-			cleanup_set_pid(0);
-			rsyserr(FLOG, errno, "failed to create pid file %s",
-				pid_file);
-			exit_cleanup(RERR_FILEIO);
-		}
-		snprintf(pidbuf, sizeof pidbuf, "%ld\n", (long)pid);
-		write(fd, pidbuf, strlen(pidbuf));
-		close(fd);
-	}
-
 	start_accept_loop(rsync_port, start_daemon);
 	return -1;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/compat.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/compat.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,46 +1,153 @@
 /*
  * Compatibility routines for older rsync protocol versions.
  *
  * Copyright (C) Andrew Tridgell 1996
  * Copyright (C) Paul Mackerras 1996
- * Copyright (C) 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 int remote_protocol = 0;
+int file_extra_cnt = 0; /* count of file-list extras that everyone gets */
+int inc_recurse = 0;
 
 extern int verbose;
 extern int am_server;
+extern int am_sender;
+extern int local_server;
 extern int inplace;
+extern int recurse;
+extern int use_qsort;
+extern int allow_inc_recurse;
+extern int append_mode;
 extern int fuzzy_basis;
 extern int read_batch;
+extern int delay_updates;
 extern int checksum_seed;
 extern int basis_dir_cnt;
 extern int prune_empty_dirs;
 extern int protocol_version;
+extern int protect_args;
+extern int preserve_uid;
+extern int preserve_gid;
+extern int preserve_acls;
+extern int preserve_xattrs;
+extern int need_messages_from_generator;
+extern int delete_mode, delete_before, delete_during, delete_after;
+extern char *shell_cmd;
+extern char *partial_dir;
 extern char *dest_option;
+extern char *files_from;
+extern char *filesfrom_host;
+extern struct filter_list_struct filter_list;
+extern int need_unsorted_flist;
+#ifdef ICONV_OPTION
+extern iconv_t ic_send, ic_recv;
+#endif
+
+/* These index values are for the file-list's extra-attribute array. */
+int uid_ndx, gid_ndx, acls_ndx, xattrs_ndx, unsort_ndx;
+
+int receiver_symlink_times = 0; /* receiver can set the time on a symlink */
+
+#ifdef ICONV_OPTION
+int filesfrom_convert = 0;
+#endif
+
+#define CF_INC_RECURSE	 (1<<0)
+#define CF_SYMLINK_TIMES (1<<1)
+
+static const char *client_info;
+
+/* The server makes sure that if either side only supports a pre-release
+ * version of a protocol, that both sides must speak a compatible version
+ * of that protocol for it to be advertised as available. */
+static void check_sub_protocol(void)
+{
+	char *dot;
+	int their_protocol, their_sub;
+#if SUBPROTOCOL_VERSION != 0
+	int our_sub = protocol_version < PROTOCOL_VERSION ? 0 : SUBPROTOCOL_VERSION;
+#else
+	int our_sub = 0;
+#endif
+
+	/* client_info starts with VER.SUB string if client is a pre-release. */
+	if (!(their_protocol = atoi(client_info))
+	 || !(dot = strchr(client_info, '.'))
+	 || !(their_sub = atoi(dot+1))) {
+#if SUBPROTOCOL_VERSION != 0
+		if (our_sub)
+			protocol_version--;
+#endif
+		return;
+	}
+
+	if (their_protocol < protocol_version) {
+		if (their_sub)
+			protocol_version = their_protocol - 1;
+		return;
+	}
+
+	if (their_protocol > protocol_version)
+		their_sub = 0; /* 0 == final version of older protocol */
+	if (their_sub != our_sub)
+		protocol_version--;
+}
+
+void set_allow_inc_recurse(void)
+{
+	client_info = shell_cmd ? shell_cmd : "";
+
+	if (!recurse || use_qsort)
+		allow_inc_recurse = 0;
+	else if (!am_sender
+	 && (delete_before || delete_after
+	  || delay_updates || prune_empty_dirs))
+		allow_inc_recurse = 0;
+	else if (am_server && !local_server
+	 && (strchr(client_info, 'i') == NULL))
+		allow_inc_recurse = 0;
+}
 
 void setup_protocol(int f_out,int f_in)
 {
+	if (am_sender)
+		file_extra_cnt += PTR_EXTRA_CNT;
+	else
+		file_extra_cnt++;
+	if (preserve_uid)
+		uid_ndx = ++file_extra_cnt;
+	if (preserve_gid)
+		gid_ndx = ++file_extra_cnt;
+	if (preserve_acls && !am_sender)
+		acls_ndx = ++file_extra_cnt;
+	if (preserve_xattrs)
+		xattrs_ndx = ++file_extra_cnt;
+
+	if (am_server)
+		set_allow_inc_recurse();
+
 	if (remote_protocol == 0) {
+		if (am_server && !local_server)
+			check_sub_protocol();
 		if (!read_batch)
 			write_int(f_out, protocol_version);
 		remote_protocol = read_int(f_in);
 		if (protocol_version > remote_protocol)
 			protocol_version = remote_protocol;
 	}
@@ -71,12 +178,40 @@
 	}
 	if (protocol_version > PROTOCOL_VERSION) {
 		rprintf(FERROR, "--protocol must be no more than %d on the %s.\n",
 			PROTOCOL_VERSION, am_server? "Server" : "Client");
 		exit_cleanup(RERR_PROTOCOL);
 	}
+	if (read_batch)
+		check_batch_flags();
+
+	if (protocol_version < 30) {
+		if (append_mode == 1)
+			append_mode = 2;
+		if (preserve_acls && !local_server) {
+			rprintf(FERROR,
+			    "--acls requires protocol 30 or higher"
+			    " (negotiated %d).\n",
+			    protocol_version);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+		if (preserve_xattrs && !local_server) {
+			rprintf(FERROR,
+			    "--xattrs requires protocol 30 or higher"
+			    " (negotiated %d).\n",
+			    protocol_version);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+	}
+
+	if (delete_mode && !(delete_before+delete_during+delete_after)) {
+		if (protocol_version < 30)
+			delete_before = 1;
+		else
+			delete_during = 1;
+	}
 
 	if (protocol_version < 29) {
 		if (fuzzy_basis) {
 			rprintf(FERROR,
 			    "--fuzzy requires protocol 29 or higher"
 			    " (negotiated %d).\n",
@@ -104,13 +239,62 @@
 			rprintf(FERROR,
 			    "--prune-empty-dirs requires protocol 29 or higher"
 			    " (negotiated %d).\n",
 			    protocol_version);
 			exit_cleanup(RERR_PROTOCOL);
 		}
+	} else if (protocol_version >= 30) {
+		int compat_flags;
+		if (am_server) {
+			compat_flags = allow_inc_recurse ? CF_INC_RECURSE : 0;
+#if defined HAVE_LUTIMES && defined HAVE_UTIMES
+			compat_flags |= CF_SYMLINK_TIMES;
+#endif
+			write_byte(f_out, compat_flags);
+		} else
+			compat_flags = read_byte(f_in);
+		/* The inc_recurse var MUST be set to 0 or 1. */
+		inc_recurse = compat_flags & CF_INC_RECURSE ? 1 : 0;
+		if (am_sender) {
+			receiver_symlink_times = am_server
+			    ? strchr(client_info, 'L') != NULL
+			    : !!(compat_flags & CF_SYMLINK_TIMES);
+		}
+#if defined HAVE_LUTIMES && defined HAVE_UTIMES
+		else
+			receiver_symlink_times = 1;
+#endif
+		if (inc_recurse && !allow_inc_recurse) {
+			/* This should only be able to happen in a batch. */
+			fprintf(stderr,
+			    "Incompatible options specified for inc-recursive %s.\n",
+			    read_batch ? "batch file" : "connection");
+			exit_cleanup(RERR_SYNTAX);
+		}
+		need_messages_from_generator = 1;
+	}
+
+	if (need_unsorted_flist && (!am_sender || inc_recurse))
+		unsort_ndx = ++file_extra_cnt;
+
+	if (partial_dir && *partial_dir != '/' && (!am_server || local_server)) {
+		int flags = MATCHFLG_NO_PREFIXES | MATCHFLG_DIRECTORY;
+		if (!am_sender || protocol_version >= 30)
+			flags |= MATCHFLG_PERISHABLE;
+		parse_rule(&filter_list, partial_dir, flags, 0);
+	}
+
+
+#ifdef ICONV_OPTION
+	if (protect_args && files_from) {
+		if (am_sender)
+			filesfrom_convert = filesfrom_host && ic_send != (iconv_t)-1;
+		else
+			filesfrom_convert = !filesfrom_host && ic_recv != (iconv_t)-1;
 	}
+#endif
 
 	if (am_server) {
 		if (!checksum_seed)
 			checksum_seed = time(NULL);
 		write_int(f_out, checksum_seed);
 	} else {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/config.h.in	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/config.h.in	2008-03-02 04:12:14.000000000 +0800
@@ -24,12 +24,24 @@
    this is either `int' or `gid_t'. */
 #undef GETGROUPS_T
 
 /* Define to 1 if the `getpgrp' function requires zero arguments. */
 #undef GETPGRP_VOID
 
+/* Define to 1 if you have the `aclsort' function. */
+#undef HAVE_ACLSORT
+
+/* true if you have acl_get_perm_np */
+#undef HAVE_ACL_GET_PERM_NP
+
+/* Define to 1 if you have the <acl/libacl.h> header file. */
+#undef HAVE_ACL_LIBACL_H
+
+/* true if you have AIX ACLs */
+#undef HAVE_AIX_ACLS
+
 /* Define to 1 if you have `alloca', as a function or macro. */
 #undef HAVE_ALLOCA
 
 /* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
    */
 #undef HAVE_ALLOCA_H
@@ -40,12 +52,15 @@
 /* Define to 1 if you have the <arpa/nameser.h> header file. */
 #undef HAVE_ARPA_NAMESER_H
 
 /* Define to 1 if you have the `asprintf' function. */
 #undef HAVE_ASPRINTF
 
+/* Define to 1 if you have the <attr/xattr.h> header file. */
+#undef HAVE_ATTR_XATTR_H
+
 /* Define to 1 if readdir() is broken */
 #undef HAVE_BROKEN_READDIR
 
 /* Define to 1 if vsprintf has a C99-compatible return value */
 #undef HAVE_C99_VSNPRINTF
 
@@ -68,28 +83,34 @@
    */
 #undef HAVE_DIRENT_H
 
 /* Define to 1 if errno is declared in errno.h */
 #undef HAVE_ERRNO_DECL
 
+/* Define to 1 if you have the `extattr_get_link' function. */
+#undef HAVE_EXTATTR_GET_LINK
+
 /* Define to 1 if you have the `fchmod' function. */
 #undef HAVE_FCHMOD
 
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
 /* Define to 1 if you have the <float.h> header file. */
 #undef HAVE_FLOAT_H
 
+/* True if you have FreeBSD xattrs */
+#undef HAVE_FREEBSD_XATTRS
+
 /* Define to 1 if you have the `fstat' function. */
 #undef HAVE_FSTAT
 
 /* Define to 1 if you have the `ftruncate' function. */
 #undef HAVE_FTRUNCATE
 
-/* Define to 1 if you have the "getaddrinfo" function. */
+/* Define to 1 if you have the "getaddrinfo" function and required types. */
 #undef HAVE_GETADDRINFO
 
 /* Define to 1 if you have the `getcwd' function. */
 #undef HAVE_GETCWD
 
 /* Define to 1 if you have the `getegid' function. */
@@ -98,54 +119,66 @@
 /* Define to 1 if you have the `geteuid' function. */
 #undef HAVE_GETEUID
 
 /* Define to 1 if you have the `getgroups' function. */
 #undef HAVE_GETGROUPS
 
-/* Define to 1 if you have the `getnameinfo' function. */
-#undef HAVE_GETNAMEINFO
-
 /* Define to 1 if you have the `getpgrp' function. */
 #undef HAVE_GETPGRP
 
 /* Define to 1 if gettimeofday() takes a time-zone arg */
 #undef HAVE_GETTIMEOFDAY_TZ
 
+/* Define to 1 if you have the `getxattr' function. */
+#undef HAVE_GETXATTR
+
 /* Define to 1 if you have the `glob' function. */
 #undef HAVE_GLOB
 
 /* Define to 1 if you have the <glob.h> header file. */
 #undef HAVE_GLOB_H
 
 /* Define to 1 if you have the <grp.h> header file. */
 #undef HAVE_GRP_H
 
+/* true if you have HPUX ACLs */
+#undef HAVE_HPUX_ACLS
+
 /* Define to 1 if you have the <iconv.h> header file. */
 #undef HAVE_ICONV_H
 
 /* Define to 1 if you have the `iconv_open' function. */
 #undef HAVE_ICONV_OPEN
 
+/* Define to 1 if the system has the type `id_t'. */
+#undef HAVE_ID_T
+
 /* Define to 1 if you have the `inet_ntop' function. */
 #undef HAVE_INET_NTOP
 
 /* Define to 1 if you have the `inet_pton' function. */
 #undef HAVE_INET_PTON
 
 /* Define to 1 if you have the <inttypes.h> header file. */
 #undef HAVE_INTTYPES_H
 
+/* true if you have IRIX ACLs */
+#undef HAVE_IRIX_ACLS
+
 /* Define to 1 if you have the <langinfo.h> header file. */
 #undef HAVE_LANGINFO_H
 
 /* Define to 1 if you have the `lchmod' function. */
 #undef HAVE_LCHMOD
 
 /* Define to 1 if you have the `lchown' function. */
 #undef HAVE_LCHOWN
 
+/* Define to 1 if you have the `acl' library (-lacl). */
+#undef HAVE_LIBACL
+
 /* Define to 1 if you have the <libcharset.h> header file. */
 #undef HAVE_LIBCHARSET_H
 
 /* Define to 1 if you have the `inet' library (-linet). */
 #undef HAVE_LIBINET
 
@@ -158,21 +191,27 @@
 /* Define to 1 if you have the `popt' library (-lpopt). */
 #undef HAVE_LIBPOPT
 
 /* Define to 1 if you have the `resolv' library (-lresolv). */
 #undef HAVE_LIBRESOLV
 
+/* Define to 1 if you have the `sec' library (-lsec). */
+#undef HAVE_LIBSEC
+
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
 /* Define to 1 if you have the <limits.h> header file. */
 #undef HAVE_LIMITS_H
 
 /* Define to 1 if you have the `link' function. */
 #undef HAVE_LINK
 
+/* True if you have Linux xattrs */
+#undef HAVE_LINUX_XATTRS
+
 /* Define to 1 if you have the `locale_charset' function. */
 #undef HAVE_LOCALE_CHARSET
 
 /* Define to 1 if you have the <locale.h> header file. */
 #undef HAVE_LOCALE_H
 
@@ -211,39 +250,60 @@
 /* Define to 1 if you have the `mknod' function. */
 #undef HAVE_MKNOD
 
 /* Define to 1 if you have the `mkstemp64' function. */
 #undef HAVE_MKSTEMP64
 
+/* Define to 1 if the system has the type `mode_t'. */
+#undef HAVE_MODE_T
+
 /* Define to 1 if you have the `mtrace' function. */
 #undef HAVE_MTRACE
 
 /* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
 #undef HAVE_NDIR_H
 
 /* Define to 1 if you have the <netdb.h> header file. */
 #undef HAVE_NETDB_H
 
 /* Define to 1 if you have the `nl_langinfo' function. */
 #undef HAVE_NL_LANGINFO
 
+/* Define to 1 if the system has the type `off_t'. */
+#undef HAVE_OFF_T
+
 /* Define to 1 if you have the `open64' function. */
 #undef HAVE_OPEN64
 
+/* true if you have Mac OS X ACLs */
+#undef HAVE_OSX_ACLS
+
+/* True if you have Mac OS X xattrs */
+#undef HAVE_OSX_XATTRS
+
+/* Define to 1 if the system has the type `pid_t'. */
+#undef HAVE_PID_T
+
+/* true if you have posix ACLs */
+#undef HAVE_POSIX_ACLS
+
 /* Define to 1 if you have the `putenv' function. */
 #undef HAVE_PUTENV
 
 /* Define to 1 if you have the `readlink' function. */
 #undef HAVE_READLINK
 
 /* Define to 1 if remote shell is remsh, not rsh */
 #undef HAVE_REMSH
 
 /* Define to 1 if mkstemp() is available and works right */
 #undef HAVE_SECURE_MKSTEMP
 
+/* Define to 1 if you have the `setattrlist' function. */
+#undef HAVE_SETATTRLIST
+
 /* Define to 1 if you have the `setgroups' function. */
 #undef HAVE_SETGROUPS
 
 /* Define to 1 if you have the `setlocale' function. */
 #undef HAVE_SETLOCALE
 
@@ -256,33 +316,36 @@
 /* Define to 1 if you have the `sigaction' function. */
 #undef HAVE_SIGACTION
 
 /* Define to 1 if you have the `sigprocmask' function. */
 #undef HAVE_SIGPROCMASK
 
+/* Define to 1 if the system has the type `size_t'. */
+#undef HAVE_SIZE_T
+
 /* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
 /* Do we have sockaddr_in6.sin6_scope_id? */
 #undef HAVE_SOCKADDR_IN6_SCOPE_ID
 
 /* Do we have sockaddr_in.sin_len? */
 #undef HAVE_SOCKADDR_IN_LEN
 
 /* Do we have sockaddr.sa_len? */
 #undef HAVE_SOCKADDR_LEN
 
-/* Define to 1 if you have struct sockaddr_storage. */
-#undef HAVE_SOCKADDR_STORAGE
-
 /* Do we have sockaddr_un.sun_len? */
 #undef HAVE_SOCKADDR_UN_LEN
 
 /* Define to 1 if you have the "socketpair" function */
 #undef HAVE_SOCKETPAIR
 
+/* true if you have solaris ACLs */
+#undef HAVE_SOLARIS_ACLS
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
@@ -316,22 +379,40 @@
 /* Define to 1 if you have the `strpbrk' function. */
 #undef HAVE_STRPBRK
 
 /* Define to 1 if you have the `strtol' function. */
 #undef HAVE_STRTOL
 
-/* Define to 1 if you have struct stat64. */
+/* Define to 1 if the system has the type `struct addrinfo'. */
+#undef HAVE_STRUCT_ADDRINFO
+
+/* Define to 1 if the system has the type `struct sockaddr_storage'. */
+#undef HAVE_STRUCT_SOCKADDR_STORAGE
+
+/* Define to 1 if the system has the type `struct stat64'. */
 #undef HAVE_STRUCT_STAT64
 
 /* Define to 1 if `st_rdev' is member of `struct stat'. */
 #undef HAVE_STRUCT_STAT_ST_RDEV
 
+/* Define to 1 if you have the "struct utimbuf" type */
+#undef HAVE_STRUCT_UTIMBUF
+
+/* Define to 1 if you have the <sys/acl.h> header file. */
+#undef HAVE_SYS_ACL_H
+
+/* Define to 1 if you have the <sys/attr.h> header file. */
+#undef HAVE_SYS_ATTR_H
+
 /* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
    */
 #undef HAVE_SYS_DIR_H
 
+/* Define to 1 if you have the <sys/extattr.h> header file. */
+#undef HAVE_SYS_EXTATTR_H
+
 /* Define to 1 if you have the <sys/fcntl.h> header file. */
 #undef HAVE_SYS_FCNTL_H
 
 /* Define to 1 if you have the <sys/filio.h> header file. */
 #undef HAVE_SYS_FILIO_H
 
@@ -369,20 +450,26 @@
 /* Define to 1 if you have the <sys/un.h> header file. */
 #undef HAVE_SYS_UN_H
 
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #undef HAVE_SYS_WAIT_H
 
+/* Define to 1 if you have the <sys/xattr.h> header file. */
+#undef HAVE_SYS_XATTR_H
+
 /* Define to 1 if you have the `tcgetpgrp' function. */
 #undef HAVE_TCGETPGRP
 
+/* true if you have Tru64 ACLs */
+#undef HAVE_TRU64_ACLS
+
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
-/* Define to 1 if you have the "struct utimbuf" type */
-#undef HAVE_UTIMBUF
+/* true if you have UnixWare ACLs */
+#undef HAVE_UNIXWARE_ACLS
 
 /* Define to 1 if you have the `utime' function. */
 #undef HAVE_UTIME
 
 /* Define to 1 if you have the `utimes' function. */
 #undef HAVE_UTIMES
@@ -405,15 +492,34 @@
 /* Define to 1 if you have the `wait4' function. */
 #undef HAVE_WAIT4
 
 /* Define to 1 if you have the `waitpid' function. */
 #undef HAVE_WAITPID
 
+/* Define to 1 if you have the `_acl' function. */
+#undef HAVE__ACL
+
+/* Define to 1 if you have the `_facl' function. */
+#undef HAVE__FACL
+
+/* Define to 1 if you have the `__acl' function. */
+#undef HAVE___ACL
+
+/* Define to 1 if you have the `__facl' function. */
+#undef HAVE___FACL
+
 /* Define to 1 if you have the `__va_copy' function. */
 #undef HAVE___VA_COPY
 
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* Define if you want the --iconv option. Specifing a value will set the
+   default iconv setting (a NULL means no --iconv processing by default). */
+#undef ICONV_OPTION
+
 /* true if you have IPv6 */
 #undef INET6
 
 /* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
    */
 #undef MAJOR_IN_MKDEV
@@ -473,12 +579,21 @@
 /* Define to 1 if "signed char" is a valid type */
 #undef SIGNED_CHAR_OK
 
 /* The size of `int', as computed by sizeof. */
 #undef SIZEOF_INT
 
+/* The size of `int16_t', as computed by sizeof. */
+#undef SIZEOF_INT16_T
+
+/* The size of `int32_t', as computed by sizeof. */
+#undef SIZEOF_INT32_T
+
+/* The size of `int64_t', as computed by sizeof. */
+#undef SIZEOF_INT64_T
+
 /* The size of `long', as computed by sizeof. */
 #undef SIZEOF_LONG
 
 /* The size of `long long', as computed by sizeof. */
 #undef SIZEOF_LONG_LONG
 
@@ -488,26 +603,44 @@
 /* The size of `off_t', as computed by sizeof. */
 #undef SIZEOF_OFF_T
 
 /* The size of `short', as computed by sizeof. */
 #undef SIZEOF_SHORT
 
+/* The size of `time_t', as computed by sizeof. */
+#undef SIZEOF_TIME_T
+
+/* The size of `uint16_t', as computed by sizeof. */
+#undef SIZEOF_UINT16_T
+
+/* The size of `uint32_t', as computed by sizeof. */
+#undef SIZEOF_UINT32_T
+
 /* If using the C implementation of alloca, define if you know the
    direction of stack growth for your system; otherwise it will be
    automatically deduced at runtime.
 	STACK_DIRECTION > 0 => grows toward higher addresses
 	STACK_DIRECTION < 0 => grows toward lower addresses
 	STACK_DIRECTION = 0 => direction of growth unknown */
 #undef STACK_DIRECTION
 
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* Define to 1 to add support for ACLs */
+#undef SUPPORT_ACLS
+
+/* Define to 1 to add support for extended attributes */
+#undef SUPPORT_XATTRS
+
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #undef TIME_WITH_SYS_TIME
 
+/* String to pass to iconv() for the UTF-8 charset. */
+#undef UTF8_CHARSET
+
 /* Define to 1 if your processor stores words with the most significant byte
    first (like Motorola and SPARC, unlike Intel and VAX). */
 #undef WORDS_BIGENDIAN
 
 /* Number of bits in a file offset, on hosts where this is settable. */
 #undef _FILE_OFFSET_BITS
@@ -524,23 +657,11 @@
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
 #ifndef __cplusplus
 #undef inline
 #endif
 
-/* Define to `int' if <sys/types.h> does not define. */
-#undef mode_t
-
-/* Define to `long int' if <sys/types.h> does not define. */
-#undef off_t
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef pid_t
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
-
 /* type to use in place of socklen_t if not defined */
 #undef socklen_t
 
 /* Define to `int' if <sys/types.h> doesn't define. */
 #undef uid_t
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/configure	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure	2007-12-18 15:32:47.000000000 +0800
@@ -1,15928 +1,25 @@
-#! /bin/sh
-# Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.60a.
-#
-# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
-
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
-fi
-BIN_SH=xpg4; export BIN_SH # for Tru64
-DUALCASE=1; export DUALCASE # for MKS sh
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
-fi
-
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-as_nl='
-'
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
-fi
-
-# Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
-    eval $as_var=C; export $as_var
-  else
-    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-  fi
-done
-
-# Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-
-# Name of the executable.
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# CDPATH.
-$as_unset CDPATH
-
-
-if test "x$CONFIG_SHELL" = x; then
-  if (eval ":") 2>/dev/null; then
-  as_have_required=yes
-else
-  as_have_required=no
-fi
-
-  if test $as_have_required = yes && 	 (eval ":
-(as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test \$exitcode = 0) || { (exit 1); exit 1; }
-
-(
-  as_lineno_1=\$LINENO
-  as_lineno_2=\$LINENO
-  test \"x\$as_lineno_1\" != \"x\$as_lineno_2\" &&
-  test \"x\`expr \$as_lineno_1 + 1\`\" = \"x\$as_lineno_2\") || { (exit 1); exit 1; }
-") 2> /dev/null; then
-  :
-else
-  as_candidate_shells=
-    as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in /usr/bin/posix$PATH_SEPARATOR/bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  case $as_dir in
-	 /*)
-	   for as_base in sh bash ksh sh5; do
-	     as_candidate_shells="$as_candidate_shells $as_dir/$as_base"
-	   done;;
-       esac
-done
-IFS=$as_save_IFS
-
-
-      for as_shell in $as_candidate_shells $SHELL; do
-	 # Try only shells that exist, to save several forks.
-	 if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
-		{ ("$as_shell") 2> /dev/null <<\_ASEOF
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
-fi
-BIN_SH=xpg4; export BIN_SH # for Tru64
-DUALCASE=1; export DUALCASE # for MKS sh
-
-:
-_ASEOF
-}; then
-  CONFIG_SHELL=$as_shell
-	       as_have_required=yes
-	       if { "$as_shell" 2> /dev/null <<\_ASEOF
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
-fi
-BIN_SH=xpg4; export BIN_SH # for Tru64
-DUALCASE=1; export DUALCASE # for MKS sh
-
-:
-(as_func_return () {
-  (exit $1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = "$1" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test $exitcode = 0) || { (exit 1); exit 1; }
-
-(
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2") || { (exit 1); exit 1; }
-
-_ASEOF
-}; then
-  break
-fi
-
-fi
-
-      done
-
-      if test "x$CONFIG_SHELL" != x; then
-  for as_var in BASH_ENV ENV
-        do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-        done
-        export CONFIG_SHELL
-        exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
-fi
-
-
-    if test $as_have_required = no; then
-  echo This script requires a shell more modern than all the
-      echo shells that I found on your system.  Please install a
-      echo modern shell, or manually run the script under such a
-      echo shell if you do have one.
-      { (exit 1); exit 1; }
-fi
-
-
-fi
-
-fi
-
-
-
-(eval "as_func_return () {
-  (exit \$1)
-}
-as_func_success () {
-  as_func_return 0
-}
-as_func_failure () {
-  as_func_return 1
-}
-as_func_ret_success () {
-  return 0
-}
-as_func_ret_failure () {
-  return 1
-}
-
-exitcode=0
-if as_func_success; then
-  :
-else
-  exitcode=1
-  echo as_func_success failed.
-fi
-
-if as_func_failure; then
-  exitcode=1
-  echo as_func_failure succeeded.
-fi
-
-if as_func_ret_success; then
-  :
-else
-  exitcode=1
-  echo as_func_ret_success failed.
-fi
-
-if as_func_ret_failure; then
-  exitcode=1
-  echo as_func_ret_failure succeeded.
-fi
-
-if ( set x; as_func_ret_success y && test x = \"\$1\" ); then
-  :
-else
-  exitcode=1
-  echo positional parameters were not saved.
-fi
-
-test \$exitcode = 0") || {
-  echo No shell found that supports shell functions.
-  echo Please tell autoconf@gnu.org about your system,
-  echo including any error possibly output before this
-  echo message
-}
-
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
--n*)
-  case `echo 'x\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir
-fi
-echo >conf$$.file
-if ln -s conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s='ln -s'
-  # ... but there are two gotchas:
-  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-  # In both cases, we have to default to `cp -p'.
-  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-    as_ln_s='cp -p'
-elif ln conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s=ln
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-# Find out whether ``test -x'' works.  Don't use a zero-byte file, as
-# systems may use methods other than mode bits to determine executability.
-cat >conf$$.file <<_ASEOF
-#! /bin/sh
-exit 0
-_ASEOF
-chmod +x conf$$.file
-if test -x conf$$.file >/dev/null 2>&1; then
-  as_executable_p="test -x"
-else
-  as_executable_p=:
-fi
-rm -f conf$$.file
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-
-exec 7<&0 </dev/null 6>&1
-
-# Name of the host.
-# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
-# so uname gets run too.
-ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
-
-#
-# Initializations.
-#
-ac_default_prefix=/usr/local
-ac_clean_files=
-ac_config_libobj_dir=.
-LIBOBJS=
-cross_compiling=no
-subdirs=
-MFLAGS=
-MAKEFLAGS=
-SHELL=${CONFIG_SHELL-/bin/sh}
-
-# Identity of this package.
-PACKAGE_NAME=
-PACKAGE_TARNAME=
-PACKAGE_VERSION=
-PACKAGE_STRING=
-PACKAGE_BUGREPORT=
-
-ac_unique_file="byteorder.h"
-# Factoring default headers for most tests.
-ac_includes_default="\
-#include <stdio.h>
-#ifdef HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#ifdef HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#ifdef STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# ifdef HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-#ifdef HAVE_STRING_H
-# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
-#  include <memory.h>
-# endif
-# include <string.h>
-#endif
-#ifdef HAVE_STRINGS_H
-# include <strings.h>
-#endif
-#ifdef HAVE_INTTYPES_H
-# include <inttypes.h>
-#endif
-#ifdef HAVE_STDINT_H
-# include <stdint.h>
-#endif
-#ifdef HAVE_UNISTD_H
-# include <unistd.h>
-#endif"
-
-ac_subst_vars='SHELL
-PATH_SEPARATOR
-PACKAGE_NAME
-PACKAGE_TARNAME
-PACKAGE_VERSION
-PACKAGE_STRING
-PACKAGE_BUGREPORT
-exec_prefix
-prefix
-program_transform_name
-bindir
-sbindir
-libexecdir
-datarootdir
-datadir
-sysconfdir
-sharedstatedir
-localstatedir
-includedir
-oldincludedir
-docdir
-infodir
-htmldir
-dvidir
-pdfdir
-psdir
-libdir
-localedir
-mandir
-DEFS
-ECHO_C
-ECHO_N
-ECHO_T
-LIBS
-build_alias
-host_alias
-target_alias
-RSYNC_VERSION
-build
-build_cpu
-build_vendor
-build_os
-host
-host_cpu
-host_vendor
-host_os
-target
-target_cpu
-target_vendor
-target_os
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-ac_ct_CC
-EXEEXT
-OBJEXT
-CPP
-GREP
-EGREP
-INSTALL_PROGRAM
-INSTALL_SCRIPT
-INSTALL_DATA
-HAVE_REMSH
-LIBOBJS
-ALLOCA
-OBJ_SAVE
-OBJ_RESTORE
-CC_SHOBJ_FLAG
-BUILD_POPT
-LTLIBOBJS'
-ac_subst_files=''
-      ac_precious_vars='build_alias
-host_alias
-target_alias
-CC
-CFLAGS
-LDFLAGS
-CPPFLAGS
-CPP'
-
-
-# Initialize some variables set by options.
-ac_init_help=
-ac_init_version=false
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-cache_file=/dev/null
-exec_prefix=NONE
-no_create=
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-verbose=
-x_includes=NONE
-x_libraries=NONE
-
-# Installation directory options.
-# These are left unexpanded so users can "make install exec_prefix=/foo"
-# and all the variables that are supposed to be based on exec_prefix
-# by default will actually change.
-# Use braces instead of parens because sh, perl, etc. also accept them.
-# (The list follows the same order as the GNU Coding Standards.)
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datarootdir='${prefix}/share'
-datadir='${datarootdir}'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-docdir='${datarootdir}/doc/${PACKAGE}'
-infodir='${datarootdir}/info'
-htmldir='${docdir}'
-dvidir='${docdir}'
-pdfdir='${docdir}'
-psdir='${docdir}'
-libdir='${exec_prefix}/lib'
-localedir='${datarootdir}/locale'
-mandir='${datarootdir}/man'
-
-ac_prev=
-ac_dashdash=
-for ac_option
-do
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval $ac_prev=\$ac_option
-    ac_prev=
-    continue
-  fi
-
-  case $ac_option in
-  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *)	ac_optarg=yes ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case $ac_dashdash$ac_option in
-  --)
-    ac_dashdash=yes ;;
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir=$ac_optarg ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build_alias ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build_alias=$ac_optarg ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file=$ac_optarg ;;
-
-  --config-cache | -C)
-    cache_file=config.cache ;;
-
-  -datadir | --datadir | --datadi | --datad)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=*)
-    datadir=$ac_optarg ;;
-
-  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
-  | --dataroo | --dataro | --datar)
-    ac_prev=datarootdir ;;
-  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
-  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
-    datarootdir=$ac_optarg ;;
-
-  -disable-* | --disable-*)
-    ac_feature=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
-   { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
-    eval enable_$ac_feature=no ;;
-
-  -docdir | --docdir | --docdi | --doc | --do)
-    ac_prev=docdir ;;
-  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
-    docdir=$ac_optarg ;;
-
-  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
-    ac_prev=dvidir ;;
-  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
-    dvidir=$ac_optarg ;;
-
-  -enable-* | --enable-*)
-    ac_feature=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_feature" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid feature name: $ac_feature" >&2
-   { (exit 1); exit 1; }; }
-    ac_feature=`echo $ac_feature | sed 's/-/_/g'`
-    eval enable_$ac_feature=\$ac_optarg ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix=$ac_optarg ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he | -h)
-    ac_init_help=long ;;
-  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
-    ac_init_help=recursive ;;
-  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
-    ac_init_help=short ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host_alias ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host_alias=$ac_optarg ;;
-
-  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
-    ac_prev=htmldir ;;
-  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
-  | --ht=*)
-    htmldir=$ac_optarg ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir=$ac_optarg ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir=$ac_optarg ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir=$ac_optarg ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir=$ac_optarg ;;
-
-  -localedir | --localedir | --localedi | --localed | --locale)
-    ac_prev=localedir ;;
-  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
-    localedir=$ac_optarg ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst | --locals)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
-    localstatedir=$ac_optarg ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir=$ac_optarg ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c | -n)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir=$ac_optarg ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix=$ac_optarg ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix=$ac_optarg ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix=$ac_optarg ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name=$ac_optarg ;;
-
-  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
-    ac_prev=pdfdir ;;
-  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
-    pdfdir=$ac_optarg ;;
-
-  -psdir | --psdir | --psdi | --psd | --ps)
-    ac_prev=psdir ;;
-  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
-    psdir=$ac_optarg ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir=$ac_optarg ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir=$ac_optarg ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site=$ac_optarg ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir=$ac_optarg ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir=$ac_optarg ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target_alias ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target_alias=$ac_optarg ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers | -V)
-    ac_init_version=: ;;
-
-  -with-* | --with-*)
-    ac_package=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid package name: $ac_package" >&2
-   { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package| sed 's/-/_/g'`
-    eval with_$ac_package=\$ac_optarg ;;
-
-  -without-* | --without-*)
-    ac_package=`expr "x$ac_option" : 'x-*without-\(.*\)'`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_package" : ".*[^-_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid package name: $ac_package" >&2
-   { (exit 1); exit 1; }; }
-    ac_package=`echo $ac_package | sed 's/-/_/g'`
-    eval with_$ac_package=no ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes=$ac_optarg ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries=$ac_optarg ;;
-
-  -*) { echo "$as_me: error: unrecognized option: $ac_option
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; }
-    ;;
-
-  *=*)
-    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
-    # Reject names that are not valid shell variable names.
-    expr "x$ac_envvar" : ".*[^_$as_cr_alnum]" >/dev/null &&
-      { echo "$as_me: error: invalid variable name: $ac_envvar" >&2
-   { (exit 1); exit 1; }; }
-    eval $ac_envvar=\$ac_optarg
-    export $ac_envvar ;;
-
-  *)
-    # FIXME: should be removed in autoconf 3.0.
-    echo "$as_me: WARNING: you should use --build, --host, --target" >&2
-    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
-      echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  { echo "$as_me: error: missing argument to $ac_option" >&2
-   { (exit 1); exit 1; }; }
-fi
-
-# Be sure to have absolute directory names.
-for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
-		datadir sysconfdir sharedstatedir localstatedir includedir \
-		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
-		libdir localedir mandir
-do
-  eval ac_val=\$$ac_var
-  case $ac_val in
-    [\\/$]* | ?:[\\/]* )  continue;;
-    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
-  esac
-  { echo "$as_me: error: expected an absolute directory name for --$ac_var: $ac_val" >&2
-   { (exit 1); exit 1; }; }
-done
-
-# There might be people who depend on the old broken behavior: `$host'
-# used to hold the argument of --host etc.
-# FIXME: To remove some day.
-build=$build_alias
-host=$host_alias
-target=$target_alias
-
-# FIXME: To remove some day.
-if test "x$host_alias" != x; then
-  if test "x$build_alias" = x; then
-    cross_compiling=maybe
-    echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used." >&2
-  elif test "x$build_alias" != "x$host_alias"; then
-    cross_compiling=yes
-  fi
-fi
-
-ac_tool_prefix=
-test -n "$host_alias" && ac_tool_prefix=$host_alias-
-
-test "$silent" = yes && exec 6>/dev/null
-
-
-ac_pwd=`pwd` && test -n "$ac_pwd" &&
-ac_ls_di=`ls -di .` &&
-ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  { echo "$as_me: error: Working directory cannot be determined" >&2
-   { (exit 1); exit 1; }; }
-test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  { echo "$as_me: error: pwd does not report name of working directory" >&2
-   { (exit 1); exit 1; }; }
-
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then the parent directory.
-  ac_confdir=`$as_dirname -- "$0" ||
-$as_expr X"$0" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$0" : 'X\(//\)[^/]' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$0" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  srcdir=$ac_confdir
-  if test ! -r "$srcdir/$ac_unique_file"; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r "$srcdir/$ac_unique_file"; then
-  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  { echo "$as_me: error: cannot find sources ($ac_unique_file) in $srcdir" >&2
-   { (exit 1); exit 1; }; }
-fi
-ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
-ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || { echo "$as_me: error: $ac_msg" >&2
-   { (exit 1); exit 1; }; }
-	pwd)`
-# When building in place, set srcdir=.
-if test "$ac_abs_confdir" = "$ac_pwd"; then
-  srcdir=.
-fi
-# Remove unnecessary trailing slashes from srcdir.
-# Double slashes in file names in object file debugging info
-# mess up M-x gdb in Emacs.
-case $srcdir in
-*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
-esac
-for ac_var in $ac_precious_vars; do
-  eval ac_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_env_${ac_var}_value=\$${ac_var}
-  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
-  eval ac_cv_env_${ac_var}_value=\$${ac_var}
-done
-
-#
-# Report the --help message.
-#
-if test "$ac_init_help" = "long"; then
-  # Omit some internal or obsolete options to make the list less imposing.
-  # This message is too long to be a string in the A/UX 3.1 sh.
-  cat <<_ACEOF
-\`configure' configures this package to adapt to many kinds of systems.
-
-Usage: $0 [OPTION]... [VAR=VALUE]...
-
-To assign environment variables (e.g., CC, CFLAGS...), specify them as
-VAR=VALUE.  See below for descriptions of some of the useful variables.
-
-Defaults for the options are specified in brackets.
-
-Configuration:
-  -h, --help              display this help and exit
-      --help=short        display options specific to this package
-      --help=recursive    display the short help of all the included packages
-  -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking...' messages
-      --cache-file=FILE   cache test results in FILE [disabled]
-  -C, --config-cache      alias for \`--cache-file=config.cache'
-  -n, --no-create         do not create output files
-      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
-
-Installation directories:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-			  [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-			  [PREFIX]
-
-By default, \`make install' will install all the files in
-\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
-an installation prefix other than \`$ac_default_prefix' using \`--prefix',
-for instance \`--prefix=\$HOME'.
-
-For better control, use the options below.
-
-Fine tuning of the installation directories:
-  --bindir=DIR           user executables [EPREFIX/bin]
-  --sbindir=DIR          system admin executables [EPREFIX/sbin]
-  --libexecdir=DIR       program executables [EPREFIX/libexec]
-  --sysconfdir=DIR       read-only single-machine data [PREFIX/etc]
-  --sharedstatedir=DIR   modifiable architecture-independent data [PREFIX/com]
-  --localstatedir=DIR    modifiable single-machine data [PREFIX/var]
-  --libdir=DIR           object code libraries [EPREFIX/lib]
-  --includedir=DIR       C header files [PREFIX/include]
-  --oldincludedir=DIR    C header files for non-gcc [/usr/include]
-  --datarootdir=DIR      read-only arch.-independent data root [PREFIX/share]
-  --datadir=DIR          read-only architecture-independent data [DATAROOTDIR]
-  --infodir=DIR          info documentation [DATAROOTDIR/info]
-  --localedir=DIR        locale-dependent data [DATAROOTDIR/locale]
-  --mandir=DIR           man documentation [DATAROOTDIR/man]
-  --docdir=DIR           documentation root [DATAROOTDIR/doc/PACKAGE]
-  --htmldir=DIR          html documentation [DOCDIR]
-  --dvidir=DIR           dvi documentation [DOCDIR]
-  --pdfdir=DIR           pdf documentation [DOCDIR]
-  --psdir=DIR            ps documentation [DOCDIR]
-_ACEOF
-
-  cat <<\_ACEOF
-
-System types:
-  --build=BUILD     configure for building on BUILD [guessed]
-  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
-  --target=TARGET   configure for building compilers for TARGET [HOST]
-_ACEOF
-fi
-
-if test -n "$ac_init_help"; then
-
-  cat <<\_ACEOF
-
-Optional Features:
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --disable-debug         turn off debugging symbols and features
-  --enable-profile        turn on CPU profiling
-  --enable-maintainer-mode
-                          turn on extra debug features
-  --disable-largefile     omit support for large files
-  --disable-ipv6          don't even try to use IPv6
-  --disable-locale        turn off locale features
-
-Optional Packages:
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --with-included-popt    use bundled popt library, not from system
-  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)
-  --with-rsyncd-conf=PATH set configuration file for rsync server to PATH
-                          (default: /etc/rsyncd.conf)
-  --with-rsh=CMD          set remote shell command to CMD (default: ssh)
-  --with-nobody-group=GROUP
-                          set the default unprivileged group (default nobody
-                          or nogroup)
-
-Some influential environment variables:
-  CC          C compiler command
-  CFLAGS      C compiler flags
-  LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
-              nonstandard directory <lib dir>
-  CPPFLAGS    C/C++/Objective C preprocessor flags, e.g. -I<include dir> if
-              you have headers in a nonstandard directory <include dir>
-  CPP         C preprocessor
-
-Use these variables to override the choices made by `configure' or to help
-it to find libraries and programs with nonstandard names/locations.
-
-_ACEOF
-ac_status=$?
-fi
-
-if test "$ac_init_help" = "recursive"; then
-  # If there are subdirs, report their specific --help.
-  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
-    test -d "$ac_dir" || continue
-    ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-    cd "$ac_dir" || { ac_status=$?; continue; }
-    # Check for guested configure.
-    if test -f "$ac_srcdir/configure.gnu"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
-    elif test -f "$ac_srcdir/configure"; then
-      echo &&
-      $SHELL "$ac_srcdir/configure" --help=recursive
-    else
-      echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
-    fi || ac_status=$?
-    cd "$ac_pwd" || { ac_status=$?; break; }
-  done
-fi
-
-test -n "$ac_init_help" && exit $ac_status
-if $ac_init_version; then
-  cat <<\_ACEOF
-configure
-generated by GNU Autoconf 2.60a
-
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
-This configure script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it.
-_ACEOF
-  exit
-fi
-cat >config.log <<_ACEOF
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-
-It was created by $as_me, which was
-generated by GNU Autoconf 2.60a.  Invocation command line was
-
-  $ $0 $@
-
-_ACEOF
-exec 5>>config.log
-{
-cat <<_ASUNAME
-## --------- ##
-## Platform. ##
-## --------- ##
-
-hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
-
-/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
-/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
-/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
-/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
-
-_ASUNAME
-
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  echo "PATH: $as_dir"
-done
-IFS=$as_save_IFS
-
-} >&5
-
-cat >&5 <<_ACEOF
-
-
-## ----------- ##
-## Core tests. ##
-## ----------- ##
-
-_ACEOF
-
-
-# Keep a trace of the command line.
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Strip out --silent because we don't want to record it for future runs.
-# Also quote any args containing shell meta-characters.
-# Make two passes to allow for proper duplicate-argument suppression.
-ac_configure_args=
-ac_configure_args0=
-ac_configure_args1=
-ac_must_keep_next=false
-for ac_pass in 1 2
-do
-  for ac_arg
-  do
-    case $ac_arg in
-    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
-    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-    | -silent | --silent | --silen | --sile | --sil)
-      continue ;;
-    *\'*)
-      ac_arg=`echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    esac
-    case $ac_pass in
-    1) ac_configure_args0="$ac_configure_args0 '$ac_arg'" ;;
-    2)
-      ac_configure_args1="$ac_configure_args1 '$ac_arg'"
-      if test $ac_must_keep_next = true; then
-	ac_must_keep_next=false # Got value, back to normal.
-      else
-	case $ac_arg in
-	  *=* | --config-cache | -C | -disable-* | --disable-* \
-	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
-	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
-	  | -with-* | --with-* | -without-* | --without-* | --x)
-	    case "$ac_configure_args0 " in
-	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
-	    esac
-	    ;;
-	  -* ) ac_must_keep_next=true ;;
-	esac
-      fi
-      ac_configure_args="$ac_configure_args '$ac_arg'"
-      ;;
-    esac
-  done
-done
-$as_unset ac_configure_args0 || test "${ac_configure_args0+set}" != set || { ac_configure_args0=; export ac_configure_args0; }
-$as_unset ac_configure_args1 || test "${ac_configure_args1+set}" != set || { ac_configure_args1=; export ac_configure_args1; }
-
-# When interrupted or exit'd, cleanup temporary files, and complete
-# config.log.  We remove comments because anyway the quotes in there
-# would cause problems or look ugly.
-# WARNING: Use '\'' to represent an apostrophe within the trap.
-# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
-trap 'exit_status=$?
-  # Save into config.log some information that might help in debugging.
-  {
-    echo
-
-    cat <<\_ASBOX
-## ---------------- ##
-## Cache variables. ##
-## ---------------- ##
-_ASBOX
-    echo
-    # The following way of writing the cache mishandles newlines in values,
-(
-  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      *) $as_unset $ac_var ;;
-      esac ;;
-    esac
-  done
-  (set) 2>&1 |
-    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      sed -n \
-	"s/'\''/'\''\\\\'\'''\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
-      ;; #(
-    *)
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-)
-    echo
-
-    cat <<\_ASBOX
-## ----------------- ##
-## Output variables. ##
-## ----------------- ##
-_ASBOX
-    echo
-    for ac_var in $ac_subst_vars
-    do
-      eval ac_val=\$$ac_var
-      case $ac_val in
-      *\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-      esac
-      echo "$ac_var='\''$ac_val'\''"
-    done | sort
-    echo
-
-    if test -n "$ac_subst_files"; then
-      cat <<\_ASBOX
-## ------------------- ##
-## File substitutions. ##
-## ------------------- ##
-_ASBOX
-      echo
-      for ac_var in $ac_subst_files
-      do
-	eval ac_val=\$$ac_var
-	case $ac_val in
-	*\'\''*) ac_val=`echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
-	esac
-	echo "$ac_var='\''$ac_val'\''"
-      done | sort
-      echo
-    fi
-
-    if test -s confdefs.h; then
-      cat <<\_ASBOX
-## ----------- ##
-## confdefs.h. ##
-## ----------- ##
-_ASBOX
-      echo
-      cat confdefs.h
-      echo
-    fi
-    test "$ac_signal" != 0 &&
-      echo "$as_me: caught signal $ac_signal"
-    echo "$as_me: exit $exit_status"
-  } >&5
-  rm -f core *.core core.conftest.* &&
-    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
-    exit $exit_status
-' 0
-for ac_signal in 1 2 13 15; do
-  trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
-done
-ac_signal=0
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -f -r conftest* confdefs.h
-
-# Predefined preprocessor variables.
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_NAME "$PACKAGE_NAME"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_VERSION "$PACKAGE_VERSION"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_STRING "$PACKAGE_STRING"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
-_ACEOF
-
-
-# Let the site file select an alternate cache file if it wants to.
-# Prefer explicitly selected file to automatically selected ones.
-if test -n "$CONFIG_SITE"; then
-  set x "$CONFIG_SITE"
-elif test "x$prefix" != xNONE; then
-  set x "$prefix/share/config.site" "$prefix/etc/config.site"
-else
-  set x "$ac_default_prefix/share/config.site" \
-	"$ac_default_prefix/etc/config.site"
-fi
-shift
-for ac_site_file
-do
-  if test -r "$ac_site_file"; then
-    { echo "$as_me:$LINENO: loading site script $ac_site_file" >&5
-echo "$as_me: loading site script $ac_site_file" >&6;}
-    sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file"
-  fi
-done
-
-if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special
-  # files actually), so we avoid doing that.
-  if test -f "$cache_file"; then
-    { echo "$as_me:$LINENO: loading cache $cache_file" >&5
-echo "$as_me: loading cache $cache_file" >&6;}
-    case $cache_file in
-      [\\/]* | ?:[\\/]* ) . "$cache_file";;
-      *)                      . "./$cache_file";;
-    esac
-  fi
-else
-  { echo "$as_me:$LINENO: creating cache $cache_file" >&5
-echo "$as_me: creating cache $cache_file" >&6;}
-  >$cache_file
-fi
-
-# Check that the precious variables saved in the cache have kept the same
-# value.
-ac_cache_corrupted=false
-for ac_var in $ac_precious_vars; do
-  eval ac_old_set=\$ac_cv_env_${ac_var}_set
-  eval ac_new_set=\$ac_env_${ac_var}_set
-  eval ac_old_val=\$ac_cv_env_${ac_var}_value
-  eval ac_new_val=\$ac_env_${ac_var}_value
-  case $ac_old_set,$ac_new_set in
-    set,)
-      { echo "$as_me:$LINENO: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
-echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,set)
-      { echo "$as_me:$LINENO: error: \`$ac_var' was not set in the previous run" >&5
-echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
-      ac_cache_corrupted=: ;;
-    ,);;
-    *)
-      if test "x$ac_old_val" != "x$ac_new_val"; then
-	{ echo "$as_me:$LINENO: error: \`$ac_var' has changed since the previous run:" >&5
-echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
-	{ echo "$as_me:$LINENO:   former value:  $ac_old_val" >&5
-echo "$as_me:   former value:  $ac_old_val" >&2;}
-	{ echo "$as_me:$LINENO:   current value: $ac_new_val" >&5
-echo "$as_me:   current value: $ac_new_val" >&2;}
-	ac_cache_corrupted=:
-      fi;;
-  esac
-  # Pass precious variables to config.status.
-  if test "$ac_new_set" = set; then
-    case $ac_new_val in
-    *\'*) ac_arg=$ac_var=`echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
-    *) ac_arg=$ac_var=$ac_new_val ;;
-    esac
-    case " $ac_configure_args " in
-      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
-      *) ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-    esac
-  fi
-done
-if $ac_cache_corrupted; then
-  { echo "$as_me:$LINENO: error: changes in the environment can compromise the build" >&5
-echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  { { echo "$as_me:$LINENO: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&5
-echo "$as_me: error: run \`make distclean' and/or \`rm $cache_file' and start over" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-
-
-ac_config_headers="$ac_config_headers config.h"
-
-
-
-RSYNC_VERSION=2.6.9
-
-{ echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
-echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
-
-
-cat >>confdefs.h <<_ACEOF
-#define RSYNC_VERSION "$RSYNC_VERSION"
-_ACEOF
-
-
-LDFLAGS=${LDFLAGS-""}
-
-ac_aux_dir=
-for ac_dir in "$srcdir" "$srcdir/.." "$srcdir/../.."; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
-done
-if test -z "$ac_aux_dir"; then
-  { { echo "$as_me:$LINENO: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&5
-echo "$as_me: error: cannot find install-sh or install.sh in \"$srcdir\" \"$srcdir/..\" \"$srcdir/../..\"" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-# These three variables are undocumented and unsupported,
-# and are intended to be withdrawn in a future Autoconf release.
-# They can cause serious problems if a builder's source tree is in a directory
-# whose full name contains unusual characters.
-ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
-ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
-ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
-
-
-# Make sure we can run config.sub.
-$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  { { echo "$as_me:$LINENO: error: cannot run $SHELL $ac_aux_dir/config.sub" >&5
-echo "$as_me: error: cannot run $SHELL $ac_aux_dir/config.sub" >&2;}
-   { (exit 1); exit 1; }; }
-
-{ echo "$as_me:$LINENO: checking build system type" >&5
-echo $ECHO_N "checking build system type... $ECHO_C" >&6; }
-if test "${ac_cv_build+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_build_alias=$build_alias
-test "x$ac_build_alias" = x &&
-  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
-test "x$ac_build_alias" = x &&
-  { { echo "$as_me:$LINENO: error: cannot guess build type; you must specify one" >&5
-echo "$as_me: error: cannot guess build type; you must specify one" >&2;}
-   { (exit 1); exit 1; }; }
-ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $ac_build_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_build" >&5
-echo "${ECHO_T}$ac_cv_build" >&6; }
-case $ac_cv_build in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical build" >&5
-echo "$as_me: error: invalid value of canonical build" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-build=$ac_cv_build
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_build
-shift
-build_cpu=$1
-build_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-build_os=$*
-IFS=$ac_save_IFS
-case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
-
-
-{ echo "$as_me:$LINENO: checking host system type" >&5
-echo $ECHO_N "checking host system type... $ECHO_C" >&6; }
-if test "${ac_cv_host+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "x$host_alias" = x; then
-  ac_cv_host=$ac_cv_build
-else
-  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $host_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_host" >&5
-echo "${ECHO_T}$ac_cv_host" >&6; }
-case $ac_cv_host in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical host" >&5
-echo "$as_me: error: invalid value of canonical host" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-host=$ac_cv_host
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_host
-shift
-host_cpu=$1
-host_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-host_os=$*
-IFS=$ac_save_IFS
-case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
-
-
-{ echo "$as_me:$LINENO: checking target system type" >&5
-echo $ECHO_N "checking target system type... $ECHO_C" >&6; }
-if test "${ac_cv_target+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "x$target_alias" = x; then
-  ac_cv_target=$ac_cv_host
-else
-  ac_cv_target=`$SHELL "$ac_aux_dir/config.sub" $target_alias` ||
-    { { echo "$as_me:$LINENO: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&5
-echo "$as_me: error: $SHELL $ac_aux_dir/config.sub $target_alias failed" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_target" >&5
-echo "${ECHO_T}$ac_cv_target" >&6; }
-case $ac_cv_target in
-*-*-*) ;;
-*) { { echo "$as_me:$LINENO: error: invalid value of canonical target" >&5
-echo "$as_me: error: invalid value of canonical target" >&2;}
-   { (exit 1); exit 1; }; };;
-esac
-target=$ac_cv_target
-ac_save_IFS=$IFS; IFS='-'
-set x $ac_cv_target
-shift
-target_cpu=$1
-target_vendor=$2
-shift; shift
-# Remember, the first character of IFS is used to create $*,
-# except with old shells:
-target_os=$*
-IFS=$ac_save_IFS
-case $target_os in *\ *) target_os=`echo "$target_os" | sed 's/ /-/g'`;; esac
-
-
-# The aliases save the names the user supplied, while $host etc.
-# will get canonicalized.
-test -n "$target_alias" &&
-  test "$program_prefix$program_suffix$program_transform_name" = \
-    NONENONEs,x,x, &&
-  program_prefix=${target_alias}-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-if test -n "$ac_tool_prefix"; then
-  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}gcc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}gcc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-
-fi
-if test -z "$ac_cv_prog_CC"; then
-  ac_ct_CC=$CC
-  # Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="gcc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-else
-  CC="$ac_cv_prog_CC"
-fi
-
-if test -z "$CC"; then
-          if test -n "$ac_tool_prefix"; then
-    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
-set dummy ${ac_tool_prefix}cc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="${ac_tool_prefix}cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-
-  fi
-fi
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  ac_prog_rejected=no
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
-       ac_prog_rejected=yes
-       continue
-     fi
-    ac_cv_prog_CC="cc"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# != 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
-  fi
-fi
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-
-fi
-if test -z "$CC"; then
-  if test -n "$ac_tool_prefix"; then
-  for ac_prog in cl.exe
-  do
-    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
-set dummy $ac_tool_prefix$ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-CC=$ac_cv_prog_CC
-if test -n "$CC"; then
-  { echo "$as_me:$LINENO: result: $CC" >&5
-echo "${ECHO_T}$CC" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-
-    test -n "$CC" && break
-  done
-fi
-if test -z "$CC"; then
-  ac_ct_CC=$CC
-  for ac_prog in cl.exe
-do
-  # Extract the first word of "$ac_prog", so it can be a program name with args.
-set dummy $ac_prog; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_ac_ct_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$ac_ct_CC"; then
-  ac_cv_prog_ac_ct_CC="$ac_ct_CC" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_ac_ct_CC="$ac_prog"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-fi
-fi
-ac_ct_CC=$ac_cv_prog_ac_ct_CC
-if test -n "$ac_ct_CC"; then
-  { echo "$as_me:$LINENO: result: $ac_ct_CC" >&5
-echo "${ECHO_T}$ac_ct_CC" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-
-  test -n "$ac_ct_CC" && break
-done
-
-  if test "x$ac_ct_CC" = x; then
-    CC=""
-  else
-    case $cross_compiling:$ac_tool_warned in
-yes:)
-{ echo "$as_me:$LINENO: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&5
-echo "$as_me: WARNING: In the future, Autoconf will not detect cross-tools
-whose name does not start with the host triplet.  If you think this
-configuration is useful to you, please write to autoconf@gnu.org." >&2;}
-ac_tool_warned=yes ;;
-esac
-    CC=$ac_ct_CC
-  fi
-fi
-
-fi
-
-
-test -z "$CC" && { { echo "$as_me:$LINENO: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&5
-echo "$as_me: error: no acceptable C compiler found in \$PATH
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-
-# Provide some information about the compiler.
-echo "$as_me:$LINENO: checking for C compiler version" >&5
-ac_compiler=`set X $ac_compile; echo $2`
-{ (ac_try="$ac_compiler --version >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler --version >&5") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -v >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler -v >&5") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-{ (ac_try="$ac_compiler -V >&5"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compiler -V >&5") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files a.out a.exe b.out"
-# Try to create an executable without -o first, disregard a.out.
-# It will help us diagnose broken compilers, and finding out an intuition
-# of exeext.
-{ echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
-echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6; }
-ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
-#
-# List of possible output files, starting from the most likely.
-# The algorithm is not robust to junk in `.', hence go to wildcards (a.*)
-# only as a last resort.  b.out is created by i960 compilers.
-ac_files='a_out.exe a.exe conftest.exe a.out conftest a.* conftest.* b.out'
-#
-# The IRIX 6 linker writes into existing files which may not be
-# executable, retaining their permissions.  Remove them first so a
-# subsequent execution test works.
-ac_rmfiles=
-for ac_file in $ac_files
-do
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
-    * ) ac_rmfiles="$ac_rmfiles $ac_file";;
-  esac
-done
-rm -f $ac_rmfiles
-
-if { (ac_try="$ac_link_default"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link_default") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
-# So ignore a value of `no', otherwise this would lead to `EXEEXT = no'
-# in a Makefile.  We should not override ac_cv_exeext if it was cached,
-# so that the user can short-circuit this test for compilers unknown to
-# Autoconf.
-for ac_file in $ac_files ''
-do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj )
-	;;
-    [ab].out )
-	# We found the default executable, but exeext='' is most
-	# certainly right.
-	break;;
-    *.* )
-        if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
-	then :; else
-	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	fi
-	# We set ac_cv_exeext here because the later test for it is not
-	# safe: cross compilers may not add the suffix if given an `-o'
-	# argument, so we may need to know it at that point already.
-	# Even if this section looks crufty: it has the advantage of
-	# actually working.
-	break;;
-    * )
-	break;;
-  esac
-done
-test "$ac_cv_exeext" = no && ac_cv_exeext=
-
-else
-  ac_file=''
-fi
-
-{ echo "$as_me:$LINENO: result: $ac_file" >&5
-echo "${ECHO_T}$ac_file" >&6; }
-if test -z "$ac_file"; then
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { echo "$as_me:$LINENO: error: C compiler cannot create executables
-See \`config.log' for more details." >&5
-echo "$as_me: error: C compiler cannot create executables
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-fi
-
-ac_exeext=$ac_cv_exeext
-
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ echo "$as_me:$LINENO: checking whether the C compiler works" >&5
-echo $ECHO_N "checking whether the C compiler works... $ECHO_C" >&6; }
-# FIXME: These cross compiler hacks should be removed for Autoconf 3.0
-# If not cross compiling, check that we can run a simple program.
-if test "$cross_compiling" != yes; then
-  if { ac_try='./$ac_file'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-    cross_compiling=no
-  else
-    if test "$cross_compiling" = maybe; then
-	cross_compiling=yes
-    else
-	{ { echo "$as_me:$LINENO: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run C compiled programs.
-If you meant to cross compile, use \`--host'.
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-    fi
-  fi
-fi
-{ echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-
-rm -f a.out a.exe conftest$ac_cv_exeext b.out
-ac_clean_files=$ac_clean_files_save
-# Check that the compiler produces executables we can run.  If not, either
-# the compiler is broken, or we cross compile.
-{ echo "$as_me:$LINENO: checking whether we are cross compiling" >&5
-echo $ECHO_N "checking whether we are cross compiling... $ECHO_C" >&6; }
-{ echo "$as_me:$LINENO: result: $cross_compiling" >&5
-echo "${ECHO_T}$cross_compiling" >&6; }
-
-{ echo "$as_me:$LINENO: checking for suffix of executables" >&5
-echo $ECHO_N "checking for suffix of executables... $ECHO_C" >&6; }
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  # If both `conftest.exe' and `conftest' are `present' (well, observable)
-# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
-# work properly (i.e., refer to `conftest.exe'), while it won't with
-# `rm'.
-for ac_file in conftest.exe conftest conftest.*; do
-  test -f "$ac_file" || continue
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.o | *.obj ) ;;
-    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
-	  break;;
-    * ) break;;
-  esac
-done
-else
-  { { echo "$as_me:$LINENO: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute suffix of executables: cannot compile and link
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-rm -f conftest$ac_cv_exeext
-{ echo "$as_me:$LINENO: result: $ac_cv_exeext" >&5
-echo "${ECHO_T}$ac_cv_exeext" >&6; }
-
-rm -f conftest.$ac_ext
-EXEEXT=$ac_cv_exeext
-ac_exeext=$EXEEXT
-{ echo "$as_me:$LINENO: checking for suffix of object files" >&5
-echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6; }
-if test "${ac_cv_objext+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.o conftest.obj
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; then
-  for ac_file in conftest.o conftest.obj conftest.*; do
-  test -f "$ac_file" || continue;
-  case $ac_file in
-    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf ) ;;
-    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
-       break;;
-  esac
-done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-{ { echo "$as_me:$LINENO: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute suffix of object files: cannot compile
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-rm -f conftest.$ac_cv_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_objext" >&5
-echo "${ECHO_T}$ac_cv_objext" >&6; }
-OBJEXT=$ac_cv_objext
-ac_objext=$OBJEXT
-{ echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
-echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6; }
-if test "${ac_cv_c_compiler_gnu+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-#ifndef __GNUC__
-       choke me
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_compiler_gnu=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_compiler_gnu=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-ac_cv_c_compiler_gnu=$ac_compiler_gnu
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
-echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6; }
-GCC=`test $ac_compiler_gnu = yes && echo yes`
-ac_test_CFLAGS=${CFLAGS+set}
-ac_save_CFLAGS=$CFLAGS
-{ echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
-echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6; }
-if test "${ac_cv_prog_cc_g+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_save_c_werror_flag=$ac_c_werror_flag
-   ac_c_werror_flag=yes
-   ac_cv_prog_cc_g=no
-   CFLAGS="-g"
-   cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_g=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	CFLAGS=""
-      cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_c_werror_flag=$ac_save_c_werror_flag
-	 CFLAGS="-g"
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_g=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-   ac_c_werror_flag=$ac_save_c_werror_flag
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_g" >&6; }
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS=$ac_save_CFLAGS
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-{ echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
-echo $ECHO_N "checking for $CC option to accept ISO C89... $ECHO_C" >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_c89=$ac_arg
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6; } ;;
-  xno)
-    { echo "$as_me:$LINENO: result: unsupported" >&5
-echo "${ECHO_T}unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-{ echo "$as_me:$LINENO: checking how to run the C preprocessor" >&5
-echo $ECHO_N "checking how to run the C preprocessor... $ECHO_C" >&6; }
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-  if test "${ac_cv_prog_CPP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-      # Double quotes because CPP needs to be expanded
-    for CPP in "$CC -E" "$CC -E -traditional-cpp" "/lib/cpp"
-    do
-      ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Broken: fails on valid input.
-continue
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  # Broken: success on invalid input.
-continue
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  break
-fi
-
-    done
-    ac_cv_prog_CPP=$CPP
-
-fi
-  CPP=$ac_cv_prog_CPP
-else
-  ac_cv_prog_CPP=$CPP
-fi
-{ echo "$as_me:$LINENO: result: $CPP" >&5
-echo "${ECHO_T}$CPP" >&6; }
-ac_preproc_ok=false
-for ac_c_preproc_warn_flag in '' yes
-do
-  # Use a header file that comes with gcc, so configuring glibc
-  # with a fresh cross-compiler works.
-  # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-  # <limits.h> exists even on freestanding compilers.
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp. "Syntax error" is here to catch this case.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-		     Syntax error
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  :
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Broken: fails on valid input.
-continue
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-  # OK, works on sane cases.  Now check whether nonexistent headers
-  # can be detected and how.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ac_nonexistent.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  # Broken: success on invalid input.
-continue
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  # Passes both tests.
-ac_preproc_ok=:
-break
-fi
-
-rm -f conftest.err conftest.$ac_ext
-
-done
-# Because of `break', _AC_PREPROC_IFELSE's cleaning code was skipped.
-rm -f conftest.err conftest.$ac_ext
-if $ac_preproc_ok; then
-  :
-else
-  { { echo "$as_me:$LINENO: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&5
-echo "$as_me: error: C preprocessor \"$CPP\" fails sanity check
-See \`config.log' for more details." >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-ac_ext=c
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
-ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
-ac_compiler_gnu=$ac_cv_c_compiler_gnu
-
-{ echo "$as_me:$LINENO: checking for grep that handles long lines and -e" >&5
-echo $ECHO_N "checking for grep that handles long lines and -e... $ECHO_C" >&6; }
-if test "${ac_cv_path_GREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  # Extract the first word of "grep ggrep" to use in msg output
-if test -z "$GREP"; then
-set dummy grep ggrep; ac_prog_name=$2
-if test "${ac_cv_path_GREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_path_GREP_found=false
-# Loop through the user's path and test for each of PROGNAME-LIST
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in grep ggrep; do
-  for ac_exec_ext in '' $ac_executable_extensions; do
-    ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
-    { test -f "$ac_path_GREP" && $as_executable_p "$ac_path_GREP"; } || continue
-    # Check for GNU ac_path_GREP and select it if it is found.
-  # Check for GNU $ac_path_GREP
-case `"$ac_path_GREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_GREP="$ac_path_GREP" ac_path_GREP_found=:;;
-*)
-  ac_count=0
-  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    echo 'GREP' >> "conftest.nl"
-    "$ac_path_GREP" -e 'GREP$' -e '-(cannot match)-' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
-    if test $ac_count -gt ${ac_path_GREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_GREP="$ac_path_GREP"
-      ac_path_GREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-
-    $ac_path_GREP_found && break 3
-  done
-done
-
-done
-IFS=$as_save_IFS
-
-
-fi
-
-GREP="$ac_cv_path_GREP"
-if test -z "$GREP"; then
-  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-else
-  ac_cv_path_GREP=$GREP
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_path_GREP" >&5
-echo "${ECHO_T}$ac_cv_path_GREP" >&6; }
- GREP="$ac_cv_path_GREP"
-
-
-{ echo "$as_me:$LINENO: checking for egrep" >&5
-echo $ECHO_N "checking for egrep... $ECHO_C" >&6; }
-if test "${ac_cv_path_EGREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if echo a | $GREP -E '(a|b)' >/dev/null 2>&1
-   then ac_cv_path_EGREP="$GREP -E"
-   else
-     # Extract the first word of "egrep" to use in msg output
-if test -z "$EGREP"; then
-set dummy egrep; ac_prog_name=$2
-if test "${ac_cv_path_EGREP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_path_EGREP_found=false
-# Loop through the user's path and test for each of PROGNAME-LIST
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_prog in egrep; do
-  for ac_exec_ext in '' $ac_executable_extensions; do
-    ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
-    { test -f "$ac_path_EGREP" && $as_executable_p "$ac_path_EGREP"; } || continue
-    # Check for GNU ac_path_EGREP and select it if it is found.
-  # Check for GNU $ac_path_EGREP
-case `"$ac_path_EGREP" --version 2>&1` in
-*GNU*)
-  ac_cv_path_EGREP="$ac_path_EGREP" ac_path_EGREP_found=:;;
-*)
-  ac_count=0
-  echo $ECHO_N "0123456789$ECHO_C" >"conftest.in"
-  while :
-  do
-    cat "conftest.in" "conftest.in" >"conftest.tmp"
-    mv "conftest.tmp" "conftest.in"
-    cp "conftest.in" "conftest.nl"
-    echo 'EGREP' >> "conftest.nl"
-    "$ac_path_EGREP" 'EGREP$' < "conftest.nl" >"conftest.out" 2>/dev/null || break
-    diff "conftest.out" "conftest.nl" >/dev/null 2>&1 || break
-    ac_count=`expr $ac_count + 1`
-    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
-      # Best one so far, save it but keep looking for a better one
-      ac_cv_path_EGREP="$ac_path_EGREP"
-      ac_path_EGREP_max=$ac_count
-    fi
-    # 10*(2^10) chars as input seems more than enough
-    test $ac_count -gt 10 && break
-  done
-  rm -f conftest.in conftest.tmp conftest.nl conftest.out;;
-esac
-
-
-    $ac_path_EGREP_found && break 3
-  done
-done
-
-done
-IFS=$as_save_IFS
-
-
-fi
-
-EGREP="$ac_cv_path_EGREP"
-if test -z "$EGREP"; then
-  { { echo "$as_me:$LINENO: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&5
-echo "$as_me: error: no acceptable $ac_prog_name could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" >&2;}
-   { (exit 1); exit 1; }; }
-fi
-
-else
-  ac_cv_path_EGREP=$EGREP
-fi
-
-
-   fi
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_path_EGREP" >&5
-echo "${ECHO_T}$ac_cv_path_EGREP" >&6; }
- EGREP="$ac_cv_path_EGREP"
-
-
-# Find a good install program.  We prefer a C program (faster),
-# so one script is as good as another.  But avoid the broken or
-# incompatible versions:
-# SysV /etc/install, /usr/sbin/install
-# SunOS /usr/etc/install
-# IRIX /sbin/install
-# AIX /bin/install
-# AmigaOS /C/install, which installs bootblocks on floppy discs
-# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
-# AFS /usr/afsws/bin/install, which mishandles nonexistent args
-# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
-# OS/2's system install, which has a completely different semantic
-# ./install, which can be erroneously created by make from ./install.sh.
-{ echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
-echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6; }
-if test -z "$INSTALL"; then
-if test "${ac_cv_path_install+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  # Account for people who put trailing slashes in PATH elements.
-case $as_dir/ in
-  ./ | .// | /cC/* | \
-  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
-  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
-  /usr/ucb/* ) ;;
-  *)
-    # OSF1 and SCO ODT 3.0 have their own names for install.
-    # Don't use installbsd from OSF since it installs stuff as root
-    # by default.
-    for ac_prog in ginstall scoinst install; do
-      for ac_exec_ext in '' $ac_executable_extensions; do
-	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_executable_p "$as_dir/$ac_prog$ac_exec_ext"; }; then
-	  if test $ac_prog = install &&
-	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # AIX install.  It has an incompatible calling convention.
-	    :
-	  elif test $ac_prog = install &&
-	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
-	    # program-specific install script used by HP pwplus--don't use.
-	    :
-	  else
-	    ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
-	    break 3
-	  fi
-	fi
-      done
-    done
-    ;;
-esac
-done
-IFS=$as_save_IFS
-
-
-fi
-  if test "${ac_cv_path_install+set}" = set; then
-    INSTALL=$ac_cv_path_install
-  else
-    # As a last resort, use the slow shell script.  Don't cache a
-    # value for INSTALL within a source directory, because that will
-    # break other packages using the cache if that directory is
-    # removed, or if the value is a relative name.
-    INSTALL=$ac_install_sh
-  fi
-fi
-{ echo "$as_me:$LINENO: result: $INSTALL" >&5
-echo "${ECHO_T}$INSTALL" >&6; }
-
-# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
-# It thinks the first close brace ends the variable substitution.
-test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
-
-test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
-
-test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
-
-   case $ac_cv_prog_cc_stdc in
-  no) ac_cv_prog_cc_c99=no; ac_cv_prog_cc_c89=no ;;
-  *) { echo "$as_me:$LINENO: checking for $CC option to accept ISO C99" >&5
-echo $ECHO_N "checking for $CC option to accept ISO C99... $ECHO_C" >&6; }
-if test "${ac_cv_prog_cc_c99+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_prog_cc_c99=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdbool.h>
-#include <stdlib.h>
-#include <wchar.h>
-#include <stdio.h>
-
-// Check varargs macros.  These examples are taken from C99 6.10.3.5.
-#define debug(...) fprintf (stderr, __VA_ARGS__)
-#define showlist(...) puts (#__VA_ARGS__)
-#define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))
-static void
-test_varargs_macros (void)
-{
-  int x = 1234;
-  int y = 5678;
-  debug ("Flag");
-  debug ("X = %d\n", x);
-  showlist (The first, second, and third items.);
-  report (x>y, "x is %d but y is %d", x, y);
-}
-
-// Check long long types.
-#define BIG64 18446744073709551615ull
-#define BIG32 4294967295ul
-#define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)
-#if !BIG_OK
-  your preprocessor is broken;
-#endif
-#if BIG_OK
-#else
-  your preprocessor is broken;
-#endif
-static long long int bignum = -9223372036854775807LL;
-static unsigned long long int ubignum = BIG64;
-
-struct incomplete_array
-{
-  int datasize;
-  double data[];
-};
-
-struct named_init {
-  int number;
-  const wchar_t *name;
-  double average;
-};
-
-typedef const char *ccp;
-
-static inline int
-test_restrict (ccp restrict text)
-{
-  // See if C++-style comments work.
-  // Iterate through items via the restricted pointer.
-  // Also check for declarations in for loops.
-  for (unsigned int i = 0; *(text+i) != '\0'; ++i)
-    continue;
-  return 0;
-}
-
-// Check varargs and va_copy.
-static void
-test_varargs (const char *format, ...)
-{
-  va_list args;
-  va_start (args, format);
-  va_list args_copy;
-  va_copy (args_copy, args);
-
-  const char *str;
-  int number;
-  float fnumber;
-
-  while (*format)
-    {
-      switch (*format++)
-	{
-	case 's': // string
-	  str = va_arg (args_copy, const char *);
-	  break;
-	case 'd': // int
-	  number = va_arg (args_copy, int);
-	  break;
-	case 'f': // float
-	  fnumber = va_arg (args_copy, double);
-	  break;
-	default:
-	  break;
-	}
-    }
-  va_end (args_copy);
-  va_end (args);
-}
-
-int
-main ()
-{
-
-  // Check bool.
-  _Bool success = false;
-
-  // Check restrict.
-  if (test_restrict ("String literal") == 0)
-    success = true;
-  char *restrict newvar = "Another string";
-
-  // Check varargs.
-  test_varargs ("s, d' f .", "string", 65, 34.234);
-  test_varargs_macros ();
-
-  // Check flexible array members.
-  struct incomplete_array *ia =
-    malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));
-  ia->datasize = 10;
-  for (int i = 0; i < ia->datasize; ++i)
-    ia->data[i] = i * 1.234;
-
-  // Check named initializers.
-  struct named_init ni = {
-    .number = 34,
-    .name = L"Test wide string",
-    .average = 543.34343,
-  };
-
-  ni.number = 58;
-
-  int dynamic_array[ni.number];
-  dynamic_array[ni.number - 1] = 543;
-
-  // work around unused variable warnings
-  return (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == 'x'
-	  || dynamic_array[ni.number - 1] != 543);
-
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -std=gnu99 -c99 -qlanglvl=extc99
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_c99=$ac_arg
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c99" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c99" in
-  x)
-    { echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6; } ;;
-  xno)
-    { echo "$as_me:$LINENO: result: unsupported" >&5
-echo "${ECHO_T}unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c99"
-    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c99" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_c99" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c99" != xno; then
-  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c99
-else
-  { echo "$as_me:$LINENO: checking for $CC option to accept ISO C89" >&5
-echo $ECHO_N "checking for $CC option to accept ISO C89... $ECHO_C" >&6; }
-if test "${ac_cv_prog_cc_c89+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_prog_cc_c89=no
-ac_save_CC=$CC
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdarg.h>
-#include <stdio.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-/* Most of the following tests are stolen from RCS 5.7's src/conf.sh.  */
-struct buf { int x; };
-FILE * (*rcsopen) (struct buf *, struct stat *, int);
-static char *e (p, i)
-     char **p;
-     int i;
-{
-  return p[i];
-}
-static char *f (char * (*g) (char **, int), char **p, ...)
-{
-  char *s;
-  va_list v;
-  va_start (v,p);
-  s = g (p, va_arg (v,int));
-  va_end (v);
-  return s;
-}
-
-/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
-   function prototypes and stuff, but not '\xHH' hex character constants.
-   These don't provoke an error unfortunately, instead are silently treated
-   as 'x'.  The following induces an error, until -std is added to get
-   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
-   array size at least.  It's necessary to write '\x00'==0 to get something
-   that's true only with -std.  */
-int osf4_cc_array ['\x00' == 0 ? 1 : -1];
-
-/* IBM C 6 for AIX is almost-ANSI by default, but it replaces macro parameters
-   inside strings and character constants.  */
-#define FOO(x) 'x'
-int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
-
-int test (int i, double x);
-struct s1 {int (*f) (int a);};
-struct s2 {int (*f) (double a);};
-int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
-int argc;
-char **argv;
-int
-main ()
-{
-return f (e, argv, 0) != argv[0]  ||  f (e, argv, 1) != argv[1];
-  ;
-  return 0;
-}
-_ACEOF
-for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
-	-Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
-do
-  CC="$ac_save_CC $ac_arg"
-  rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_prog_cc_c89=$ac_arg
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext
-  test "x$ac_cv_prog_cc_c89" != "xno" && break
-done
-rm -f conftest.$ac_ext
-CC=$ac_save_CC
-
-fi
-# AC_CACHE_VAL
-case "x$ac_cv_prog_cc_c89" in
-  x)
-    { echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6; } ;;
-  xno)
-    { echo "$as_me:$LINENO: result: unsupported" >&5
-echo "${ECHO_T}unsupported" >&6; } ;;
-  *)
-    CC="$CC $ac_cv_prog_cc_c89"
-    { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_c89" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_c89" >&6; } ;;
-esac
-if test "x$ac_cv_prog_cc_c89" != xno; then
-  ac_cv_prog_cc_stdc=$ac_cv_prog_cc_c89
-else
-  ac_cv_prog_cc_stdc=no
-fi
-
-
-fi
-
- ;;
-esac
-  { echo "$as_me:$LINENO: checking for $CC option to accept ISO Standard C" >&5
-echo $ECHO_N "checking for $CC option to accept ISO Standard C... $ECHO_C" >&6; }
-  if test "${ac_cv_prog_cc_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-
-  case $ac_cv_prog_cc_stdc in
-  no) { echo "$as_me:$LINENO: result: unsupported" >&5
-echo "${ECHO_T}unsupported" >&6; } ;;
-  '') { echo "$as_me:$LINENO: result: none needed" >&5
-echo "${ECHO_T}none needed" >&6; } ;;
-  *) { echo "$as_me:$LINENO: result: $ac_cv_prog_cc_stdc" >&5
-echo "${ECHO_T}$ac_cv_prog_cc_stdc" >&6; } ;;
-esac
-
-
-
-
-
-cat >>confdefs.h <<\_ACEOF
-#define _GNU_SOURCE 1
-_ACEOF
-
-
-if test x"$ac_cv_prog_cc_stdc" = x"no"; then
-	{ echo "$as_me:$LINENO: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&5
-echo "$as_me: WARNING: rsync requires an ANSI C compiler and you don't seem to have one" >&2;}
-fi
-
-# We must decide this before testing the compiler.
-
-# Please allow this to default to yes, so that your users have more
-# chance of getting a useful stack trace if problems occur.
-
-{ echo "$as_me:$LINENO: checking whether to include debugging symbols" >&5
-echo $ECHO_N "checking whether to include debugging symbols... $ECHO_C" >&6; }
-# Check whether --enable-debug was given.
-if test "${enable_debug+set}" = set; then
-  enableval=$enable_debug;
-fi
-
-
-if test x"$enable_debug" = x"no"; then
-    { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-    CFLAGS=${CFLAGS-"-O"}
-else
-    { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-    # leave CFLAGS alone; AC_PROG_CC will try to include -g if it can
-        fi
-
-
-# Check whether --enable-profile was given.
-if test "${enable_profile+set}" = set; then
-  enableval=$enable_profile;
-fi
-
-if test x"$enable_profile" = x"yes"; then
-	CFLAGS="$CFLAGS -pg"
-fi
-
-
-# Specifically, this turns on panic_action handling.
-# Check whether --enable-maintainer-mode was given.
-if test "${enable_maintainer_mode+set}" = set; then
-  enableval=$enable_maintainer_mode;
-fi
-
-if test x"$enable_maintainer_mode" = x"yes"; then
-	CFLAGS="$CFLAGS -DMAINTAINER_MODE"
-fi
-
-
-# This is needed for our included version of popt.  Kind of silly, but
-# I don't want our version too far out of sync.
-CFLAGS="$CFLAGS -DHAVE_CONFIG_H"
-
-# If GCC, turn on warnings.
-if test x"$GCC" = x"yes"; then
-	CFLAGS="$CFLAGS -Wall -W"
-fi
-
-
-# Check whether --with-included-popt was given.
-if test "${with_included_popt+set}" = set; then
-  withval=$with_included_popt;
-fi
-
-
-
-# Check whether --with-rsync-path was given.
-if test "${with_rsync_path+set}" = set; then
-  withval=$with_rsync_path;  RSYNC_PATH="$with_rsync_path"
-else
-   RSYNC_PATH="rsync"
-fi
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define RSYNC_PATH "$RSYNC_PATH"
-_ACEOF
-
-
-
-# Check whether --with-rsyncd-conf was given.
-if test "${with_rsyncd_conf+set}" = set; then
-  withval=$with_rsyncd_conf;  if test ! -z "$with_rsyncd_conf" ; then
-		case $with_rsyncd_conf in
-			yes|no)
-				RSYNCD_SYSCONF="/etc/rsyncd.conf"
-				;;
-			/*)
-				RSYNCD_SYSCONF="$with_rsyncd_conf"
-				;;
-			*)
-                                { { echo "$as_me:$LINENO: error: You must specify an absolute path to --with-rsyncd-conf=PATH" >&5
-echo "$as_me: error: You must specify an absolute path to --with-rsyncd-conf=PATH" >&2;}
-   { (exit 1); exit 1; }; }
-				;;
-		esac
-	else
-		RSYNCD_SYSCONF="/etc/rsyncd.conf"
-	fi
-else
-   RSYNCD_SYSCONF="/etc/rsyncd.conf"
-fi
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define RSYNCD_SYSCONF "$RSYNCD_SYSCONF"
-_ACEOF
-
-
-
-# Check whether --with-rsh was given.
-if test "${with_rsh+set}" = set; then
-  withval=$with_rsh;
-fi
-
-
-# Extract the first word of "remsh", so it can be a program name with args.
-set dummy remsh; ac_word=$2
-{ echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6; }
-if test "${ac_cv_prog_HAVE_REMSH+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test -n "$HAVE_REMSH"; then
-  ac_cv_prog_HAVE_REMSH="$HAVE_REMSH" # Let the user override the test.
-else
-as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  for ac_exec_ext in '' $ac_executable_extensions; do
-  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; }; then
-    ac_cv_prog_HAVE_REMSH="1"
-    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
-    break 2
-  fi
-done
-done
-IFS=$as_save_IFS
-
-  test -z "$ac_cv_prog_HAVE_REMSH" && ac_cv_prog_HAVE_REMSH="0"
-fi
-fi
-HAVE_REMSH=$ac_cv_prog_HAVE_REMSH
-if test -n "$HAVE_REMSH"; then
-  { echo "$as_me:$LINENO: result: $HAVE_REMSH" >&5
-echo "${ECHO_T}$HAVE_REMSH" >&6; }
-else
-  { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-
-if test x$HAVE_REMSH = x1; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_REMSH 1
-_ACEOF
-
-fi
-
-if test x"$with_rsh" != x; then
-	RSYNC_RSH="$with_rsh"
-else
-	RSYNC_RSH="ssh"
-fi
-
-cat >>confdefs.h <<_ACEOF
-#define RSYNC_RSH "$RSYNC_RSH"
-_ACEOF
-
-
-
-# Check whether --with-nobody-group was given.
-if test "${with_nobody_group+set}" = set; then
-  withval=$with_nobody_group;  NOBODY_GROUP="$with_nobody_group"
-fi
-
-
-if test x"$with_nobody_group" = x; then
-    { echo "$as_me:$LINENO: checking the group for user \"nobody\"" >&5
-echo $ECHO_N "checking the group for user \"nobody\"... $ECHO_C" >&6; }
-    if grep '^nobody:' /etc/group >/dev/null 2>&1; then
-	NOBODY_GROUP=nobody
-    elif grep '^nogroup:' /etc/group >/dev/null 2>&1; then
-	NOBODY_GROUP=nogroup
-    else
-	NOBODY_GROUP=nobody # test for others?
-    fi
-    { echo "$as_me:$LINENO: result: $NOBODY_GROUP" >&5
-echo "${ECHO_T}$NOBODY_GROUP" >&6; }
-fi
-
-
-cat >>confdefs.h <<_ACEOF
-#define NOBODY_USER "nobody"
-_ACEOF
-
-
-cat >>confdefs.h <<_ACEOF
-#define NOBODY_GROUP "$NOBODY_GROUP"
-_ACEOF
-
-
-# arrgh. libc in some old debian version screwed up the largefile
-# stuff, getting byte range locking wrong
-
-{ echo "$as_me:$LINENO: checking for broken largefile support" >&5
-echo $ECHO_N "checking for broken largefile support... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_BROKEN_LARGEFILE+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_HAVE_BROKEN_LARGEFILE=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#define _FILE_OFFSET_BITS 64
-#include <stdio.h>
-#include <fcntl.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-
-int main(void)
-{
-	struct flock lock;
-	int status;
-	char tpl[32] = "/tmp/locktest.XXXXXX";
-	int fd = mkstemp(tpl);
-	if (fd < 0) {
-		strcpy(tpl, "conftest.dat");
-		fd = open(tpl, O_CREAT|O_RDWR, 0600);
-	}
-
-	lock.l_type = F_WRLCK;
-	lock.l_whence = SEEK_SET;
-	lock.l_start = 0;
-	lock.l_len = 1;
-	lock.l_pid = 0;
-	fcntl(fd,F_SETLK,&lock);
-	if (fork() == 0) {
-		lock.l_start = 1;
-		_exit(fcntl(fd,F_SETLK,&lock) == 0);
-	}
-	wait(&status);
-	unlink(tpl);
-	exit(WEXITSTATUS(status));
-}
-
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_BROKEN_LARGEFILE=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_HAVE_BROKEN_LARGEFILE=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_BROKEN_LARGEFILE" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_BROKEN_LARGEFILE" >&6; }
-if test x"$rsync_cv_HAVE_BROKEN_LARGEFILE" != x"yes"; then
-   # Check whether --enable-largefile was given.
-if test "${enable_largefile+set}" = set; then
-  enableval=$enable_largefile;
-fi
-
-if test "$enable_largefile" != no; then
-
-  { echo "$as_me:$LINENO: checking for special C compiler options needed for large files" >&5
-echo $ECHO_N "checking for special C compiler options needed for large files... $ECHO_C" >&6; }
-if test "${ac_cv_sys_largefile_CC+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_sys_largefile_CC=no
-     if test "$GCC" != yes; then
-       ac_save_CC=$CC
-       while :; do
-	 # IRIX 6.2 and later do not support large files by default,
-	 # so use the C compiler's -n32 option if that helps.
-	 cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-	 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext
-	 CC="$CC -n32"
-	 rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sys_largefile_CC=' -n32'; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext
-	 break
-       done
-       CC=$ac_save_CC
-       rm -f conftest.$ac_ext
-    fi
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sys_largefile_CC" >&5
-echo "${ECHO_T}$ac_cv_sys_largefile_CC" >&6; }
-  if test "$ac_cv_sys_largefile_CC" != no; then
-    CC=$CC$ac_cv_sys_largefile_CC
-  fi
-
-  { echo "$as_me:$LINENO: checking for _FILE_OFFSET_BITS value needed for large files" >&5
-echo $ECHO_N "checking for _FILE_OFFSET_BITS value needed for large files... $ECHO_C" >&6; }
-if test "${ac_cv_sys_file_offset_bits+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  while :; do
-  ac_cv_sys_file_offset_bits=no
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#define _FILE_OFFSET_BITS 64
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sys_file_offset_bits=64; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  break
-done
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sys_file_offset_bits" >&5
-echo "${ECHO_T}$ac_cv_sys_file_offset_bits" >&6; }
-if test "$ac_cv_sys_file_offset_bits" != no; then
-
-cat >>confdefs.h <<_ACEOF
-#define _FILE_OFFSET_BITS $ac_cv_sys_file_offset_bits
-_ACEOF
-
-fi
-rm -f conftest*
-  { echo "$as_me:$LINENO: checking for _LARGE_FILES value needed for large files" >&5
-echo $ECHO_N "checking for _LARGE_FILES value needed for large files... $ECHO_C" >&6; }
-if test "${ac_cv_sys_large_files+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  while :; do
-  ac_cv_sys_large_files=no
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#define _LARGE_FILES 1
-#include <sys/types.h>
- /* Check that off_t can represent 2**63 - 1 correctly.
-    We can't simply define LARGE_OFF_T to be 9223372036854775807,
-    since some C++ compilers masquerading as C compilers
-    incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
-  int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
-		       && LARGE_OFF_T % 2147483647 == 1)
-		      ? 1 : -1];
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sys_large_files=1; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  break
-done
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sys_large_files" >&5
-echo "${ECHO_T}$ac_cv_sys_large_files" >&6; }
-if test "$ac_cv_sys_large_files" != no; then
-
-cat >>confdefs.h <<_ACEOF
-#define _LARGE_FILES $ac_cv_sys_large_files
-_ACEOF
-
-fi
-rm -f conftest*
-fi
-
-fi
-
-ipv6type=unknown
-ipv6lib=none
-ipv6trylibc=yes
-
-# Check whether --enable-ipv6 was given.
-if test "${enable_ipv6+set}" = set; then
-  enableval=$enable_ipv6;
-fi
-
-if test x"$enable_ipv6" != x"no"; then
-	{ echo "$as_me:$LINENO: checking ipv6 stack type" >&5
-echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6; }
-	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
-		case $i in
-		inria)
-			# http://www.kame.net/
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <netinet/in.h>
-#ifdef IPV6_INRIA_VERSION
-yes
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  ipv6type=$i;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-
-fi
-rm -f conftest*
-
-			;;
-		kame)
-			# http://www.kame.net/
-			cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <netinet/in.h>
-#ifdef __KAME__
-yes
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  ipv6type=$i;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-fi
-rm -f conftest*
-
-			;;
-		linux-glibc)
-			# http://www.v6.linux.or.jp/
-			cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <features.h>
-#if defined(__GLIBC__) && __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1
-yes
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  ipv6type=$i;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-fi
-rm -f conftest*
-
-			;;
-		linux-inet6)
-			# http://www.v6.linux.or.jp/
-			if test -d /usr/inet6 -o -f /usr/inet6/lib/libinet6.a; then
-				ipv6type=$i
-				ipv6lib=inet6
-				ipv6libdir=/usr/inet6/lib
-				ipv6trylibc=yes;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-				CFLAGS="-I/usr/inet6/include $CFLAGS"
-			fi
-			;;
-		toshiba)
-			cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/param.h>
-#ifdef _TOSHIBA_INET6
-yes
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  ipv6type=$i;
-				ipv6lib=inet6;
-				ipv6libdir=/usr/local/v6/lib;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-fi
-rm -f conftest*
-
-			;;
-		v6d)
-			cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include </usr/local/v6/include/sys/v6config.h>
-#ifdef __V6D__
-yes
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  ipv6type=$i;
-				ipv6lib=v6;
-				ipv6libdir=/usr/local/v6/lib;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-fi
-rm -f conftest*
-
-			;;
-		zeta)
-			cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/param.h>
-#ifdef _ZETA_MINAMI_INET6
-yes
-#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  ipv6type=$i;
-				ipv6lib=inet6;
-				ipv6libdir=/usr/local/v6/lib;
-
-cat >>confdefs.h <<\_ACEOF
-#define INET6 1
-_ACEOF
-
-fi
-rm -f conftest*
-
-			;;
-		esac
-		if test "$ipv6type" != "unknown"; then
-			break
-		fi
-	done
-	{ echo "$as_me:$LINENO: result: $ipv6type" >&5
-echo "${ECHO_T}$ipv6type" >&6; }
-
-	{ echo "$as_me:$LINENO: checking for library containing getaddrinfo" >&5
-echo $ECHO_N "checking for library containing getaddrinfo... $ECHO_C" >&6; }
-if test "${ac_cv_search_getaddrinfo+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char getaddrinfo ();
-int
-main ()
-{
-return getaddrinfo ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' inet6; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_search_getaddrinfo=$ac_res
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_getaddrinfo+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_getaddrinfo+set}" = set; then
-  :
-else
-  ac_cv_search_getaddrinfo=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_search_getaddrinfo" >&5
-echo "${ECHO_T}$ac_cv_search_getaddrinfo" >&6; }
-ac_res=$ac_cv_search_getaddrinfo
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-fi
-
-# Check whether --enable-locale was given.
-if test "${enable_locale+set}" = set; then
-  enableval=$enable_locale;
-fi
-
-
-
-if test x"$enable_locale" != x"no"; then
-	cat >>confdefs.h <<\_ACEOF
-#define CONFIG_LOCALE 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking whether to call shutdown on all sockets" >&5
-echo $ECHO_N "checking whether to call shutdown on all sockets... $ECHO_C" >&6; }
-case $host_os in
-	*cygwin* ) { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define SHUTDOWN_ALL_SOCKETS 1
-_ACEOF
-
-		   ;;
-	       * ) { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; };;
-esac
-
-{ echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6; }
-if test "${ac_cv_header_stdc+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_header_stdc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_stdc=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <string.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then
-  :
-else
-  ac_cv_header_stdc=no
-fi
-rm -f conftest*
-
-fi
-
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
-  :
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <ctype.h>
-#include <stdlib.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-		   (('a' <= (c) && (c) <= 'i') \
-		     || ('j' <= (c) && (c) <= 'r') \
-		     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-	|| toupper (i) != TOUPPER (i))
-      return 2;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  :
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_header_stdc=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-echo "${ECHO_T}$ac_cv_header_stdc" >&6; }
-if test $ac_cv_header_stdc = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define STDC_HEADERS 1
-_ACEOF
-
-fi
-
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-
-
-
-
-
-
-
-
-
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-		  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_Header=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_Header=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-{ echo "$as_me:$LINENO: checking whether byte ordering is bigendian" >&5
-echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6; }
-if test "${ac_cv_c_bigendian+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  # See if sys/param.h defines the BYTE_ORDER macro.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/param.h>
-
-int
-main ()
-{
-#if  ! (defined BYTE_ORDER && defined BIG_ENDIAN && defined LITTLE_ENDIAN \
-	&& BYTE_ORDER && BIG_ENDIAN && LITTLE_ENDIAN)
- bogus endian macros
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  # It does; now see whether it defined to BIG_ENDIAN or not.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/param.h>
-
-int
-main ()
-{
-#if BYTE_ORDER != BIG_ENDIAN
- not big endian
-#endif
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_c_bigendian=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_c_bigendian=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	# It does not; compile a test program.
-if test "$cross_compiling" = yes; then
-  # try to guess the endianness by grepping values into an object file
-  ac_cv_c_bigendian=unknown
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-short int ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
-short int ascii_ii[] = { 0x694C, 0x5454, 0x656C, 0x6E45, 0x6944, 0x6E61, 0 };
-void _ascii () { char *s = (char *) ascii_mm; s = (char *) ascii_ii; }
-short int ebcdic_ii[] = { 0x89D3, 0xE3E3, 0x8593, 0x95C5, 0x89C4, 0x9581, 0 };
-short int ebcdic_mm[] = { 0xC2C9, 0xC785, 0x95C4, 0x8981, 0x95E2, 0xA8E2, 0 };
-void _ebcdic () { char *s = (char *) ebcdic_mm; s = (char *) ebcdic_ii; }
-int
-main ()
-{
- _ascii (); _ebcdic ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  if grep BIGenDianSyS conftest.$ac_objext >/dev/null ; then
-  ac_cv_c_bigendian=yes
-fi
-if grep LiTTleEnDian conftest.$ac_objext >/dev/null ; then
-  if test "$ac_cv_c_bigendian" = unknown; then
-    ac_cv_c_bigendian=no
-  else
-    # finding both strings is unlikely to happen, but who knows?
-    ac_cv_c_bigendian=unknown
-  fi
-fi
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-
-  /* Are we little or big endian?  From Harbison&Steele.  */
-  union
-  {
-    long int l;
-    char c[sizeof (long int)];
-  } u;
-  u.l = 1;
-  return u.c[sizeof (long int) - 1] == 1;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_c_bigendian=no
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_c_bigendian=yes
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
-echo "${ECHO_T}$ac_cv_c_bigendian" >&6; }
-case $ac_cv_c_bigendian in
-  yes)
-
-cat >>confdefs.h <<\_ACEOF
-#define WORDS_BIGENDIAN 1
-_ACEOF
- ;;
-  no)
-     ;;
-  *)
-    { { echo "$as_me:$LINENO: error: unknown endianness
-presetting ac_cv_c_bigendian=no (or yes) will help" >&5
-echo "$as_me: error: unknown endianness
-presetting ac_cv_c_bigendian=no (or yes) will help" >&2;}
-   { (exit 1); exit 1; }; } ;;
-esac
-
-
-
-
-
-
-ac_header_dirent=no
-for ac_hdr in dirent.h sys/ndir.h sys/dir.h ndir.h; do
-  as_ac_Header=`echo "ac_cv_header_dirent_$ac_hdr" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_hdr that defines DIR" >&5
-echo $ECHO_N "checking for $ac_hdr that defines DIR... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <$ac_hdr>
-
-int
-main ()
-{
-if ((DIR *) 0)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_Header=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_Header=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
-_ACEOF
-
-ac_header_dirent=$ac_hdr; break
-fi
-
-done
-# Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
-if test $ac_header_dirent = dirent.h; then
-  { echo "$as_me:$LINENO: checking for library containing opendir" >&5
-echo $ECHO_N "checking for library containing opendir... $ECHO_C" >&6; }
-if test "${ac_cv_search_opendir+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char opendir ();
-int
-main ()
-{
-return opendir ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' dir; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_search_opendir=$ac_res
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_opendir+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_opendir+set}" = set; then
-  :
-else
-  ac_cv_search_opendir=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
-echo "${ECHO_T}$ac_cv_search_opendir" >&6; }
-ac_res=$ac_cv_search_opendir
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-else
-  { echo "$as_me:$LINENO: checking for library containing opendir" >&5
-echo $ECHO_N "checking for library containing opendir... $ECHO_C" >&6; }
-if test "${ac_cv_search_opendir+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char opendir ();
-int
-main ()
-{
-return opendir ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' x; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_search_opendir=$ac_res
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_opendir+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_opendir+set}" = set; then
-  :
-else
-  ac_cv_search_opendir=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
-echo "${ECHO_T}$ac_cv_search_opendir" >&6; }
-ac_res=$ac_cv_search_opendir
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-fi
-
-{ echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
-echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6; }
-if test "${ac_cv_header_time+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/time.h>
-#include <time.h>
-
-int
-main ()
-{
-if ((struct tm *) 0)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_header_time=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_time=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
-echo "${ECHO_T}$ac_cv_header_time" >&6; }
-if test $ac_cv_header_time = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define TIME_WITH_SYS_TIME 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for sys/wait.h that is POSIX.1 compatible" >&5
-echo $ECHO_N "checking for sys/wait.h that is POSIX.1 compatible... $ECHO_C" >&6; }
-if test "${ac_cv_header_sys_wait_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/wait.h>
-#ifndef WEXITSTATUS
-# define WEXITSTATUS(stat_val) ((unsigned int) (stat_val) >> 8)
-#endif
-#ifndef WIFEXITED
-# define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
-#endif
-
-int
-main ()
-{
-  int s;
-  wait (&s);
-  s = WIFEXITED (s) ? WEXITSTATUS (s) : 1;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_header_sys_wait_h=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_sys_wait_h=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_wait_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_wait_h" >&6; }
-if test $ac_cv_header_sys_wait_h = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SYS_WAIT_H 1
-_ACEOF
-
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
-    unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
-    sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
-    sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
-    netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  { echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6; }
-if { as_var=$as_ac_Header; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=\$ac_header_preproc"
-fi
-ac_res=`eval echo '${'$as_ac_Header'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-{ echo "$as_me:$LINENO: checking whether sys/types.h defines makedev" >&5
-echo $ECHO_N "checking whether sys/types.h defines makedev... $ECHO_C" >&6; }
-if test "${ac_cv_header_sys_types_h_makedev+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-int
-main ()
-{
-return makedev(0, 0);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_header_sys_types_h_makedev=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_header_sys_types_h_makedev=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_types_h_makedev" >&5
-echo "${ECHO_T}$ac_cv_header_sys_types_h_makedev" >&6; }
-
-if test $ac_cv_header_sys_types_h_makedev = no; then
-if test "${ac_cv_header_sys_mkdev_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for sys/mkdev.h" >&5
-echo $ECHO_N "checking for sys/mkdev.h... $ECHO_C" >&6; }
-if test "${ac_cv_header_sys_mkdev_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_mkdev_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_mkdev_h" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking sys/mkdev.h usability" >&5
-echo $ECHO_N "checking sys/mkdev.h usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <sys/mkdev.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking sys/mkdev.h presence" >&5
-echo $ECHO_N "checking sys/mkdev.h presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/mkdev.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: sys/mkdev.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: sys/mkdev.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: present but cannot be compiled" >&5
-echo "$as_me: WARNING: sys/mkdev.h: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: sys/mkdev.h:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: sys/mkdev.h: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: sys/mkdev.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: sys/mkdev.h: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: sys/mkdev.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for sys/mkdev.h" >&5
-echo $ECHO_N "checking for sys/mkdev.h... $ECHO_C" >&6; }
-if test "${ac_cv_header_sys_mkdev_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_header_sys_mkdev_h=$ac_header_preproc
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_mkdev_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_mkdev_h" >&6; }
-
-fi
-if test $ac_cv_header_sys_mkdev_h = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define MAJOR_IN_MKDEV 1
-_ACEOF
-
-fi
-
-
-
-  if test $ac_cv_header_sys_mkdev_h = no; then
-    if test "${ac_cv_header_sys_sysmacros_h+set}" = set; then
-  { echo "$as_me:$LINENO: checking for sys/sysmacros.h" >&5
-echo $ECHO_N "checking for sys/sysmacros.h... $ECHO_C" >&6; }
-if test "${ac_cv_header_sys_sysmacros_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_sysmacros_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_sysmacros_h" >&6; }
-else
-  # Is the header compilable?
-{ echo "$as_me:$LINENO: checking sys/sysmacros.h usability" >&5
-echo $ECHO_N "checking sys/sysmacros.h usability... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <sys/sysmacros.h>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_header_compiler=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6; }
-
-# Is the header present?
-{ echo "$as_me:$LINENO: checking sys/sysmacros.h presence" >&5
-echo $ECHO_N "checking sys/sysmacros.h presence... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/sysmacros.h>
-_ACEOF
-if { (ac_try="$ac_cpp conftest.$ac_ext"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-
-rm -f conftest.err conftest.$ac_ext
-{ echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6; }
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
-  yes:no: )
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: sys/sysmacros.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: proceeding with the compiler's result" >&5
-echo "$as_me: WARNING: sys/sysmacros.h: proceeding with the compiler's result" >&2;}
-    ac_header_preproc=yes
-    ;;
-  no:yes:* )
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: present but cannot be compiled" >&5
-echo "$as_me: WARNING: sys/sysmacros.h: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h:     check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: sys/sysmacros.h:     check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: see the Autoconf documentation" >&5
-echo "$as_me: WARNING: sys/sysmacros.h: see the Autoconf documentation" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h:     section \"Present But Cannot Be Compiled\"" >&5
-echo "$as_me: WARNING: sys/sysmacros.h:     section \"Present But Cannot Be Compiled\"" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: sys/sysmacros.h: proceeding with the preprocessor's result" >&2;}
-    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: in the future, the compiler will take precedence" >&5
-echo "$as_me: WARNING: sys/sysmacros.h: in the future, the compiler will take precedence" >&2;}
-
-    ;;
-esac
-{ echo "$as_me:$LINENO: checking for sys/sysmacros.h" >&5
-echo $ECHO_N "checking for sys/sysmacros.h... $ECHO_C" >&6; }
-if test "${ac_cv_header_sys_sysmacros_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_header_sys_sysmacros_h=$ac_header_preproc
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_header_sys_sysmacros_h" >&5
-echo "${ECHO_T}$ac_cv_header_sys_sysmacros_h" >&6; }
-
-fi
-if test $ac_cv_header_sys_sysmacros_h = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define MAJOR_IN_SYSMACROS 1
-_ACEOF
-
-fi
-
-
-  fi
-fi
-
-
-{ echo "$as_me:$LINENO: checking if makedev takes 3 args" >&5
-echo $ECHO_N "checking if makedev takes 3 args... $ECHO_C" >&6; }
-if test "${rsync_cv_MAKEDEV_TAKES_3_ARGS+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_MAKEDEV_TAKES_3_ARGS=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#ifdef MAJOR_IN_MKDEV
-#include <sys/mkdev.h>
-# if !defined makedev && (defined mkdev || defined _WIN32 || defined __WIN32__)
-#  define makedev mkdev
-# endif
-#elif defined MAJOR_IN_SYSMACROS
-#include <sys/sysmacros.h>
-#endif
-
-int main(void)
-{
-	dev_t dev = makedev(0, 5, 7);
-	if (major(dev) != 5 || minor(dev) != 7)
-		exit(1);
-	return 0;
-}
-
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_MAKEDEV_TAKES_3_ARGS=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_MAKEDEV_TAKES_3_ARGS=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_MAKEDEV_TAKES_3_ARGS" >&5
-echo "${ECHO_T}$rsync_cv_MAKEDEV_TAKES_3_ARGS" >&6; }
-if test x"$rsync_cv_MAKEDEV_TAKES_3_ARGS" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define MAKEDEV_TAKES_3_ARGS 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for int" >&5
-echo $ECHO_N "checking for int... $ECHO_C" >&6; }
-if test "${ac_cv_type_int+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef int ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_int=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_int=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_int" >&5
-echo "${ECHO_T}$ac_cv_type_int" >&6; }
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of int" >&5
-echo $ECHO_N "checking size of int... $ECHO_C" >&6; }
-if test "${ac_cv_sizeof_int+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef int ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef int ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef int ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef int ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef int ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_int=$ac_lo;;
-'') if test "$ac_cv_type_int" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_int=0
-	       fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef int ac__type_sizeof_;
-
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%ld\n", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%lu\n", i);
-    }
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_int=`cat conftest.val`
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_int" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (int)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_int=0
-	       fi
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_int" >&5
-echo "${ECHO_T}$ac_cv_sizeof_int" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_INT $ac_cv_sizeof_int
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for long" >&5
-echo $ECHO_N "checking for long... $ECHO_C" >&6; }
-if test "${ac_cv_type_long+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef long ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_long=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_long=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_long" >&5
-echo "${ECHO_T}$ac_cv_type_long" >&6; }
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of long" >&5
-echo $ECHO_N "checking size of long... $ECHO_C" >&6; }
-if test "${ac_cv_sizeof_long+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_long=$ac_lo;;
-'') if test "$ac_cv_type_long" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_long=0
-	       fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long ac__type_sizeof_;
-
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%ld\n", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%lu\n", i);
-    }
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_long=`cat conftest.val`
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_long" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_long=0
-	       fi
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_long" >&5
-echo "${ECHO_T}$ac_cv_sizeof_long" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_LONG $ac_cv_sizeof_long
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for long long" >&5
-echo $ECHO_N "checking for long long... $ECHO_C" >&6; }
-if test "${ac_cv_type_long_long+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef long long ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_long_long=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_long_long=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_long_long" >&5
-echo "${ECHO_T}$ac_cv_type_long_long" >&6; }
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of long long" >&5
-echo $ECHO_N "checking size of long long... $ECHO_C" >&6; }
-if test "${ac_cv_sizeof_long_long+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long long ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_long_long=$ac_lo;;
-'') if test "$ac_cv_type_long_long" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_long_long=0
-	       fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef long long ac__type_sizeof_;
-
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%ld\n", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%lu\n", i);
-    }
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_long_long=`cat conftest.val`
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_long_long" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (long long)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_long_long=0
-	       fi
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_long_long" >&5
-echo "${ECHO_T}$ac_cv_sizeof_long_long" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_LONG_LONG $ac_cv_sizeof_long_long
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for short" >&5
-echo $ECHO_N "checking for short... $ECHO_C" >&6; }
-if test "${ac_cv_type_short+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef short ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_short=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_short=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_short" >&5
-echo "${ECHO_T}$ac_cv_type_short" >&6; }
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of short" >&5
-echo $ECHO_N "checking size of short... $ECHO_C" >&6; }
-if test "${ac_cv_sizeof_short+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef short ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef short ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef short ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef short ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef short ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_short=$ac_lo;;
-'') if test "$ac_cv_type_short" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_short=0
-	       fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef short ac__type_sizeof_;
-
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%ld\n", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%lu\n", i);
-    }
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_short=`cat conftest.val`
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_short" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (short)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_short=0
-	       fi
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_short" >&5
-echo "${ECHO_T}$ac_cv_sizeof_short" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_SHORT $ac_cv_sizeof_short
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for off_t" >&5
-echo $ECHO_N "checking for off_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_off_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef off_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_off_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_off_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
-echo "${ECHO_T}$ac_cv_type_off_t" >&6; }
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of off_t" >&5
-echo $ECHO_N "checking size of off_t... $ECHO_C" >&6; }
-if test "${ac_cv_sizeof_off_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_off_t=$ac_lo;;
-'') if test "$ac_cv_type_off_t" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (off_t)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (off_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_off_t=0
-	       fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off_t ac__type_sizeof_;
-
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%ld\n", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%lu\n", i);
-    }
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_off_t=`cat conftest.val`
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_off_t" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (off_t)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (off_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_off_t=0
-	       fi
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_off_t" >&5
-echo "${ECHO_T}$ac_cv_sizeof_off_t" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_OFF_T $ac_cv_sizeof_off_t
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for off64_t" >&5
-echo $ECHO_N "checking for off64_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_off64_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef off64_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_off64_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_off64_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_off64_t" >&5
-echo "${ECHO_T}$ac_cv_type_off64_t" >&6; }
-
-# The cast to long int works around a bug in the HP C Compiler
-# version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-# declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-# This bug is HP SR number 8606223364.
-{ echo "$as_me:$LINENO: checking size of off64_t" >&5
-echo $ECHO_N "checking size of off64_t... $ECHO_C" >&6; }
-if test "${ac_cv_sizeof_off64_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off64_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=0 ac_mid=0
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off64_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr $ac_mid + 1`
-			if test $ac_lo -le $ac_mid; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off64_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) < 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=-1 ac_mid=-1
-  while :; do
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off64_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) >= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_lo=$ac_mid; break
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_hi=`expr '(' $ac_mid ')' - 1`
-			if test $ac_mid -le $ac_hi; then
-			  ac_lo= ac_hi=
-			  break
-			fi
-			ac_mid=`expr 2 '*' $ac_mid`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  done
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo= ac_hi=
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-# Binary search between lo and hi bounds.
-while test "x$ac_lo" != "x$ac_hi"; do
-  ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off64_t ac__type_sizeof_;
-
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long int) (sizeof (ac__type_sizeof_))) <= $ac_mid)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_hi=$ac_mid
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_lo=`expr '(' $ac_mid ')' + 1`
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-done
-case $ac_lo in
-?*) ac_cv_sizeof_off64_t=$ac_lo;;
-'') if test "$ac_cv_type_off64_t" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (off64_t)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (off64_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_off64_t=0
-	       fi ;;
-esac
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-	        typedef off64_t ac__type_sizeof_;
-
-static long int longval () { return (long int) (sizeof (ac__type_sizeof_)); }
-static unsigned long int ulongval () { return (long int) (sizeof (ac__type_sizeof_)); }
-#include <stdio.h>
-#include <stdlib.h>
-int
-main ()
-{
-
-  FILE *f = fopen ("conftest.val", "w");
-  if (! f)
-    return 1;
-  if (((long int) (sizeof (ac__type_sizeof_))) < 0)
-    {
-      long int i = longval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%ld\n", i);
-    }
-  else
-    {
-      unsigned long int i = ulongval ();
-      if (i != ((long int) (sizeof (ac__type_sizeof_))))
-	return 1;
-      fprintf (f, "%lu\n", i);
-    }
-  return ferror (f) || fclose (f) != 0;
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_sizeof_off64_t=`cat conftest.val`
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-if test "$ac_cv_type_off64_t" = yes; then
-	         { { echo "$as_me:$LINENO: error: cannot compute sizeof (off64_t)
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot compute sizeof (off64_t)
-See \`config.log' for more details." >&2;}
-   { (exit 77); exit 77; }; }
-	       else
-	         ac_cv_sizeof_off64_t=0
-	       fi
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.val
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_sizeof_off64_t" >&5
-echo "${ECHO_T}$ac_cv_sizeof_off64_t" >&6; }
-
-
-
-cat >>confdefs.h <<_ACEOF
-#define SIZEOF_OFF64_T $ac_cv_sizeof_off64_t
-_ACEOF
-
-
-
-{ echo "$as_me:$LINENO: checking for inline" >&5
-echo $ECHO_N "checking for inline... $ECHO_C" >&6; }
-if test "${ac_cv_c_inline+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_cv_c_inline=no
-for ac_kw in inline __inline__ __inline; do
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifndef __cplusplus
-typedef int foo_t;
-static $ac_kw foo_t static_foo () {return 0; }
-$ac_kw foo_t foo () {return 0; }
-#endif
-
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_c_inline=$ac_kw
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-  test "$ac_cv_c_inline" != no && break
-done
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
-echo "${ECHO_T}$ac_cv_c_inline" >&6; }
-
-
-case $ac_cv_c_inline in
-  inline | yes) ;;
-  *)
-    case $ac_cv_c_inline in
-      no) ac_val=;;
-      *) ac_val=$ac_cv_c_inline;;
-    esac
-    cat >>confdefs.h <<_ACEOF
-#ifndef __cplusplus
-#define inline $ac_val
-#endif
-_ACEOF
-    ;;
-esac
-
-
-
-  { echo "$as_me:$LINENO: checking for long double with more range or precision than double" >&5
-echo $ECHO_N "checking for long double with more range or precision than double... $ECHO_C" >&6; }
-if test "${ac_cv_type_long_double_wider+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <float.h>
-	    long double const a[] =
-	      {
-		 0.0L, DBL_MIN, DBL_MAX, DBL_EPSILON,
-		 LDBL_MIN, LDBL_MAX, LDBL_EPSILON
-	      };
-	    long double
-	    f (long double x)
-	    {
-	       return ((x + (unsigned long int) 10) * (-1 / x) + a[0]
-			+ (x ? f (x) : 'c'));
-	    }
-
-int
-main ()
-{
-static int test_array [1 - 2 * !((0 < ((DBL_MAX_EXP < LDBL_MAX_EXP)
-		   + (DBL_MANT_DIG < LDBL_MANT_DIG)
-		   - (LDBL_MAX_EXP < DBL_MAX_EXP)
-		   - (LDBL_MANT_DIG < DBL_MANT_DIG)))
-	    && (int) LDBL_EPSILON == 0
-	  )];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_long_double_wider=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_long_double_wider=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_long_double_wider" >&5
-echo "${ECHO_T}$ac_cv_type_long_double_wider" >&6; }
-  if test $ac_cv_type_long_double_wider = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LONG_DOUBLE_WIDER 1
-_ACEOF
-
-  fi
-
-    ac_cv_c_long_double=$ac_cv_type_long_double_wider
-    if test $ac_cv_c_long_double = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_LONG_DOUBLE 1
-_ACEOF
-
-    fi
-
-
-{ echo "$as_me:$LINENO: checking return type of signal handlers" >&5
-echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6; }
-if test "${ac_cv_type_signal+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <signal.h>
-
-int
-main ()
-{
-return *(signal (0, 0)) (0) == 1;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_signal=int
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_signal=void
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
-echo "${ECHO_T}$ac_cv_type_signal" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define RETSIGTYPE $ac_cv_type_signal
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for uid_t in sys/types.h" >&5
-echo $ECHO_N "checking for uid_t in sys/types.h... $ECHO_C" >&6; }
-if test "${ac_cv_type_uid_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "uid_t" >/dev/null 2>&1; then
-  ac_cv_type_uid_t=yes
-else
-  ac_cv_type_uid_t=no
-fi
-rm -f conftest*
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_uid_t" >&5
-echo "${ECHO_T}$ac_cv_type_uid_t" >&6; }
-if test $ac_cv_type_uid_t = no; then
-
-cat >>confdefs.h <<\_ACEOF
-#define uid_t int
-_ACEOF
-
-
-cat >>confdefs.h <<\_ACEOF
-#define gid_t int
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for mode_t" >&5
-echo $ECHO_N "checking for mode_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_mode_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef mode_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_mode_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_mode_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
-echo "${ECHO_T}$ac_cv_type_mode_t" >&6; }
-if test $ac_cv_type_mode_t = yes; then
-  :
-else
-
-cat >>confdefs.h <<_ACEOF
-#define mode_t int
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for off_t" >&5
-echo $ECHO_N "checking for off_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_off_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef off_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_off_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_off_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
-echo "${ECHO_T}$ac_cv_type_off_t" >&6; }
-if test $ac_cv_type_off_t = yes; then
-  :
-else
-
-cat >>confdefs.h <<_ACEOF
-#define off_t long int
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for size_t" >&5
-echo $ECHO_N "checking for size_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_size_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef size_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_size_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_size_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
-echo "${ECHO_T}$ac_cv_type_size_t" >&6; }
-if test $ac_cv_type_size_t = yes; then
-  :
-else
-
-cat >>confdefs.h <<_ACEOF
-#define size_t unsigned int
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for pid_t" >&5
-echo $ECHO_N "checking for pid_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_pid_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-typedef pid_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_pid_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_pid_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
-echo "${ECHO_T}$ac_cv_type_pid_t" >&6; }
-if test $ac_cv_type_pid_t = yes; then
-  :
-else
-
-cat >>confdefs.h <<_ACEOF
-#define pid_t int
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking type of array argument to getgroups" >&5
-echo $ECHO_N "checking type of array argument to getgroups... $ECHO_C" >&6; }
-if test "${ac_cv_type_getgroups+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_type_getgroups=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Thanks to Mike Rendell for this test.  */
-$ac_includes_default
-#define NGID 256
-#undef MAX
-#define MAX(x, y) ((x) > (y) ? (x) : (y))
-
-int
-main ()
-{
-  gid_t gidset[NGID];
-  int i, n;
-  union { gid_t gval; long int lval; }  val;
-
-  val.lval = -1;
-  for (i = 0; i < NGID; i++)
-    gidset[i] = val.gval;
-  n = getgroups (sizeof (gidset) / MAX (sizeof (int), sizeof (gid_t)) - 1,
-		 gidset);
-  /* Exit non-zero if getgroups seems to require an array of ints.  This
-     happens when gid_t is short int but getgroups modifies an array
-     of ints.  */
-  return n > 0 && gidset[n] != val.gval;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_getgroups=gid_t
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_type_getgroups=int
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-if test $ac_cv_type_getgroups = cross; then
-        cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <unistd.h>
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "getgroups.*int.*gid_t" >/dev/null 2>&1; then
-  ac_cv_type_getgroups=gid_t
-else
-  ac_cv_type_getgroups=int
-fi
-rm -f conftest*
-
-fi
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_getgroups" >&5
-echo "${ECHO_T}$ac_cv_type_getgroups" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define GETGROUPS_T $ac_cv_type_getgroups
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking for struct stat.st_rdev" >&5
-echo $ECHO_N "checking for struct stat.st_rdev... $ECHO_C" >&6; }
-if test "${ac_cv_member_struct_stat_st_rdev+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static struct stat ac_aggr;
-if (ac_aggr.st_rdev)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_stat_st_rdev=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static struct stat ac_aggr;
-if (sizeof ac_aggr.st_rdev)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_stat_st_rdev=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_member_struct_stat_st_rdev=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_member_struct_stat_st_rdev" >&5
-echo "${ECHO_T}$ac_cv_member_struct_stat_st_rdev" >&6; }
-if test $ac_cv_member_struct_stat_st_rdev = yes; then
-
-cat >>confdefs.h <<_ACEOF
-#define HAVE_STRUCT_STAT_ST_RDEV 1
-_ACEOF
-
-
-fi
-
-
-
-   { echo "$as_me:$LINENO: checking for socklen_t" >&5
-echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6; }
-if test "${ac_cv_type_socklen_t+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/socket.h>
-
-typedef socklen_t ac__type_new_;
-int
-main ()
-{
-if ((ac__type_new_ *) 0)
-  return 0;
-if (sizeof (ac__type_new_))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_socklen_t=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_type_socklen_t=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
-echo "${ECHO_T}$ac_cv_type_socklen_t" >&6; }
-if test $ac_cv_type_socklen_t = yes; then
-  :
-else
-
-      { echo "$as_me:$LINENO: checking for socklen_t equivalent" >&5
-echo $ECHO_N "checking for socklen_t equivalent... $ECHO_C" >&6; }
-      if test "${rsync_cv_socklen_t_equiv+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-         # Systems have either "struct sockaddr *" or
-         # "void *" as the second argument to getpeername
-         rsync_cv_socklen_t_equiv=
-         for arg2 in "struct sockaddr" void; do
-            for t in int size_t unsigned long "unsigned long"; do
-               cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-
-                  int getpeername (int, $arg2 *, $t *);
-
-int
-main ()
-{
-
-                  $t len;
-                  getpeername(0,0,&len);
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-
-                  rsync_cv_socklen_t_equiv="$t"
-                  break
-
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-            done
-         done
-
-         if test "x$rsync_cv_socklen_t_equiv" = x; then
-            { { echo "$as_me:$LINENO: error: Cannot find a type to use in place of socklen_t" >&5
-echo "$as_me: error: Cannot find a type to use in place of socklen_t" >&2;}
-   { (exit 1); exit 1; }; }
-         fi
-
-fi
-
-      { echo "$as_me:$LINENO: result: $rsync_cv_socklen_t_equiv" >&5
-echo "${ECHO_T}$rsync_cv_socklen_t_equiv" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define socklen_t $rsync_cv_socklen_t_equiv
-_ACEOF
-
-fi
-
-
-
-{ echo "$as_me:$LINENO: checking for errno in errno.h" >&5
-echo $ECHO_N "checking for errno in errno.h... $ECHO_C" >&6; }
-if test "${rsync_cv_errno+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-    cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <errno.h>
-int
-main ()
-{
-int i = errno
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_errno=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	rsync_cv_have_errno_decl=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_errno" >&5
-echo "${ECHO_T}$rsync_cv_errno" >&6; }
-if test x"$rsync_cv_errno" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ERRNO_DECL 1
-_ACEOF
-
-fi
-
-# The following test taken from the cvs sources
-# If we can't find connect, try looking in -lsocket, -lnsl, and -linet.
-# These need checks to be before checks for any other functions that
-#    might be in the same libraries.
-# The Irix 5 libc.so has connect and gethostbyname, but Irix 5 also has
-# libsocket.so which has a bad implementation of gethostbyname (it
-# only looks in /etc/hosts), so we only look for -lsocket if we need
-# it.
-
-for ac_func in connect
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-if test x"$ac_cv_func_connect" = x"no"; then
-    case "$LIBS" in
-    *-lnsl*) ;;
-    *)
-{ echo "$as_me:$LINENO: checking for printf in -lnsl_s" >&5
-echo $ECHO_N "checking for printf in -lnsl_s... $ECHO_C" >&6; }
-if test "${ac_cv_lib_nsl_s_printf+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnsl_s  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char printf ();
-int
-main ()
-{
-return printf ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_nsl_s_printf=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_nsl_s_printf=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_s_printf" >&5
-echo "${ECHO_T}$ac_cv_lib_nsl_s_printf" >&6; }
-if test $ac_cv_lib_nsl_s_printf = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBNSL_S 1
-_ACEOF
-
-  LIBS="-lnsl_s $LIBS"
-
-fi
- ;;
-    esac
-    case "$LIBS" in
-    *-lnsl*) ;;
-    *)
-{ echo "$as_me:$LINENO: checking for printf in -lnsl" >&5
-echo $ECHO_N "checking for printf in -lnsl... $ECHO_C" >&6; }
-if test "${ac_cv_lib_nsl_printf+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnsl  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char printf ();
-int
-main ()
-{
-return printf ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_nsl_printf=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_nsl_printf=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_printf" >&5
-echo "${ECHO_T}$ac_cv_lib_nsl_printf" >&6; }
-if test $ac_cv_lib_nsl_printf = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBNSL 1
-_ACEOF
-
-  LIBS="-lnsl $LIBS"
-
-fi
- ;;
-    esac
-    case "$LIBS" in
-    *-lsocket*) ;;
-    *)
-{ echo "$as_me:$LINENO: checking for connect in -lsocket" >&5
-echo $ECHO_N "checking for connect in -lsocket... $ECHO_C" >&6; }
-if test "${ac_cv_lib_socket_connect+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsocket  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char connect ();
-int
-main ()
-{
-return connect ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_socket_connect=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_socket_connect=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
-echo "${ECHO_T}$ac_cv_lib_socket_connect" >&6; }
-if test $ac_cv_lib_socket_connect = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBSOCKET 1
-_ACEOF
-
-  LIBS="-lsocket $LIBS"
-
-fi
- ;;
-    esac
-    case "$LIBS" in
-    *-linet*) ;;
-    *)
-{ echo "$as_me:$LINENO: checking for connect in -linet" >&5
-echo $ECHO_N "checking for connect in -linet... $ECHO_C" >&6; }
-if test "${ac_cv_lib_inet_connect+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-linet  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char connect ();
-int
-main ()
-{
-return connect ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_inet_connect=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_inet_connect=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_inet_connect" >&5
-echo "${ECHO_T}$ac_cv_lib_inet_connect" >&6; }
-if test $ac_cv_lib_inet_connect = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBINET 1
-_ACEOF
-
-  LIBS="-linet $LIBS"
-
-fi
- ;;
-    esac
-            if test x"$ac_cv_lib_socket_connect" = x"yes" ||
-       test x"$ac_cv_lib_inet_connect" = x"yes"; then
-        # ac_cv_func_connect=yes
-        # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_CONNECT 1
-_ACEOF
-
-    fi
-fi
-
-{ echo "$as_me:$LINENO: checking for library containing inet_ntop" >&5
-echo $ECHO_N "checking for library containing inet_ntop... $ECHO_C" >&6; }
-if test "${ac_cv_search_inet_ntop+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char inet_ntop ();
-int
-main ()
-{
-return inet_ntop ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' resolv; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_search_inet_ntop=$ac_res
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_inet_ntop+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_inet_ntop+set}" = set; then
-  :
-else
-  ac_cv_search_inet_ntop=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_search_inet_ntop" >&5
-echo "${ECHO_T}$ac_cv_search_inet_ntop" >&6; }
-ac_res=$ac_cv_search_inet_ntop
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-
-# Solaris and HP-UX weirdness:
-# Search for libiconv_open (not iconv_open) to discover if -liconv is needed!
-{ echo "$as_me:$LINENO: checking for library containing libiconv_open" >&5
-echo $ECHO_N "checking for library containing libiconv_open... $ECHO_C" >&6; }
-if test "${ac_cv_search_libiconv_open+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_func_search_save_LIBS=$LIBS
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char libiconv_open ();
-int
-main ()
-{
-return libiconv_open ();
-  ;
-  return 0;
-}
-_ACEOF
-for ac_lib in '' iconv; do
-  if test -z "$ac_lib"; then
-    ac_res="none required"
-  else
-    ac_res=-l$ac_lib
-    LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
-  fi
-  rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_search_libiconv_open=$ac_res
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext
-  if test "${ac_cv_search_libiconv_open+set}" = set; then
-  break
-fi
-done
-if test "${ac_cv_search_libiconv_open+set}" = set; then
-  :
-else
-  ac_cv_search_libiconv_open=no
-fi
-rm conftest.$ac_ext
-LIBS=$ac_func_search_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_search_libiconv_open" >&5
-echo "${ECHO_T}$ac_cv_search_libiconv_open" >&6; }
-ac_res=$ac_cv_search_libiconv_open
-if test "$ac_res" != no; then
-  test "$ac_res" = "none required" || LIBS="$ac_res $LIBS"
-
-fi
-
-
-
-
-for ac_func in inet_ntop
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-else
-  case " $LIBOBJS " in
-  *" lib/inet_ntop.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS lib/inet_ntop.$ac_objext"
- ;;
-esac
-
-fi
-done
-
-
-for ac_func in inet_pton
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-else
-  case " $LIBOBJS " in
-  *" lib/inet_pton.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS lib/inet_pton.$ac_objext"
- ;;
-esac
-
-fi
-done
-
-
-# Irix 6.5 has getaddrinfo but not the corresponding defines, so use
-#   builtin getaddrinfo if one of the defines don't exist
-{ echo "$as_me:$LINENO: checking whether defines needed by getaddrinfo exist" >&5
-echo $ECHO_N "checking whether defines needed by getaddrinfo exist... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_GETADDR_DEFINES+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-			cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-			#include <sys/types.h>
-			#include <sys/socket.h>
-			#include <netdb.h>
-			#ifdef AI_PASSIVE
-			yes
-			#endif
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "yes" >/dev/null 2>&1; then
-  rsync_cv_HAVE_GETADDR_DEFINES=yes
-else
-  rsync_cv_HAVE_GETADDR_DEFINES=no
-fi
-rm -f conftest*
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_GETADDR_DEFINES" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_GETADDR_DEFINES" >&6; }
-if test x"$rsync_cv_HAVE_GETADDR_DEFINES" = x"yes"; then
-	# Tru64 UNIX has getaddrinfo() but has it renamed in libc as
-	# something else so we must include <netdb.h> to get the
-	# redefinition.
-
-for ac_func in getaddrinfo
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-else
-  { echo "$as_me:$LINENO: checking for getaddrinfo by including <netdb.h>" >&5
-echo $ECHO_N "checking for getaddrinfo by including <netdb.h>... $ECHO_C" >&6; }
-		cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-		#include <sys/socket.h>
-		#include <netdb.h>
-int
-main ()
-{
-getaddrinfo(NULL, NULL, NULL, NULL);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GETADDRINFO 1
-_ACEOF
-
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-			case " $LIBOBJS " in
-  *" lib/getaddrinfo.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
- ;;
-esac
-
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-done
-
-
-for ac_func in getnameinfo
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-else
-  case " $LIBOBJS " in
-  *" lib/getnameinfo.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext"
- ;;
-esac
-
-fi
-done
-
-else
-	case " $LIBOBJS " in
-  *" lib/getaddrinfo.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
- ;;
-esac
-
-	case " $LIBOBJS " in
-  *" lib/getnameinfo.$ac_objext "* ) ;;
-  *) LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext"
- ;;
-esac
-
-fi
-
-{ echo "$as_me:$LINENO: checking for struct sockaddr.sa_len" >&5
-echo $ECHO_N "checking for struct sockaddr.sa_len... $ECHO_C" >&6; }
-if test "${ac_cv_member_struct_sockaddr_sa_len+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-
-
-int
-main ()
-{
-static struct sockaddr ac_aggr;
-if (ac_aggr.sa_len)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_sa_len=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-
-
-int
-main ()
-{
-static struct sockaddr ac_aggr;
-if (sizeof ac_aggr.sa_len)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_sa_len=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_member_struct_sockaddr_sa_len=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_sa_len" >&5
-echo "${ECHO_T}$ac_cv_member_struct_sockaddr_sa_len" >&6; }
-if test $ac_cv_member_struct_sockaddr_sa_len = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_LEN 1
-_ACEOF
-
-fi
-
-
-{ echo "$as_me:$LINENO: checking for struct sockaddr_in.sin_len" >&5
-echo $ECHO_N "checking for struct sockaddr_in.sin_len... $ECHO_C" >&6; }
-if test "${ac_cv_member_struct_sockaddr_in_sin_len+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_in ac_aggr;
-if (ac_aggr.sin_len)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_in_sin_len=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_in ac_aggr;
-if (sizeof ac_aggr.sin_len)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_in_sin_len=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_member_struct_sockaddr_in_sin_len=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in_sin_len" >&5
-echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in_sin_len" >&6; }
-if test $ac_cv_member_struct_sockaddr_in_sin_len = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_IN_LEN 1
-_ACEOF
-
-fi
-
-
-{ echo "$as_me:$LINENO: checking for struct sockaddr_un.sun_len" >&5
-echo $ECHO_N "checking for struct sockaddr_un.sun_len... $ECHO_C" >&6; }
-if test "${ac_cv_member_struct_sockaddr_un_sun_len+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_un ac_aggr;
-if (ac_aggr.sun_len)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_un_sun_len=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_un ac_aggr;
-if (sizeof ac_aggr.sun_len)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_un_sun_len=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_member_struct_sockaddr_un_sun_len=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_un_sun_len" >&5
-echo "${ECHO_T}$ac_cv_member_struct_sockaddr_un_sun_len" >&6; }
-if test $ac_cv_member_struct_sockaddr_un_sun_len = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_UN_LEN 1
-_ACEOF
-
-fi
-
-
-{ echo "$as_me:$LINENO: checking struct sockaddr_storage" >&5
-echo $ECHO_N "checking struct sockaddr_storage... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/socket.h>
-int
-main ()
-{
-struct sockaddr_storage x;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_STORAGE 1
-_ACEOF
-
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-{ echo "$as_me:$LINENO: checking for struct sockaddr_in6.sin6_scope_id" >&5
-echo $ECHO_N "checking for struct sockaddr_in6.sin6_scope_id... $ECHO_C" >&6; }
-if test "${ac_cv_member_struct_sockaddr_in6_sin6_scope_id+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_in6 ac_aggr;
-if (ac_aggr.sin6_scope_id)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_in6 ac_aggr;
-if (sizeof ac_aggr.sin6_scope_id)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_member_struct_sockaddr_in6_sin6_scope_id=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&5
-echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&6; }
-if test $ac_cv_member_struct_sockaddr_in6_sin6_scope_id = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_IN6_SCOPE_ID 1
-_ACEOF
-
-fi
-
-
-{ echo "$as_me:$LINENO: checking struct stat64" >&5
-echo $ECHO_N "checking struct stat64... $ECHO_C" >&6; }
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdio.h>
-#if HAVE_SYS_TYPES_H
-# include <sys/types.h>
-#endif
-#if HAVE_SYS_STAT_H
-# include <sys/stat.h>
-#endif
-#if STDC_HEADERS
-# include <stdlib.h>
-# include <stddef.h>
-#else
-# if HAVE_STDLIB_H
-#  include <stdlib.h>
-# endif
-#endif
-
-int
-main ()
-{
-struct stat64 st;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  { echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6; }
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_STRUCT_STAT64 1
-_ACEOF
-
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	{ echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-# if we can't find strcasecmp, look in -lresolv (for Unixware at least)
-#
-
-for ac_func in strcasecmp
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-if test x"$ac_cv_func_strcasecmp" = x"no"; then
-
-{ echo "$as_me:$LINENO: checking for strcasecmp in -lresolv" >&5
-echo $ECHO_N "checking for strcasecmp in -lresolv... $ECHO_C" >&6; }
-if test "${ac_cv_lib_resolv_strcasecmp+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lresolv  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char strcasecmp ();
-int
-main ()
-{
-return strcasecmp ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_resolv_strcasecmp=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_resolv_strcasecmp=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_strcasecmp" >&5
-echo "${ECHO_T}$ac_cv_lib_resolv_strcasecmp" >&6; }
-if test $ac_cv_lib_resolv_strcasecmp = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBRESOLV 1
-_ACEOF
-
-  LIBS="-lresolv $LIBS"
-
-fi
-
-fi
-
-
-{ echo "$as_me:$LINENO: checking whether utime accepts a null argument" >&5
-echo $ECHO_N "checking whether utime accepts a null argument... $ECHO_C" >&6; }
-if test "${ac_cv_func_utime_null+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  rm -f conftest.data; >conftest.data
-# Sequent interprets utime(file, 0) to mean use start of epoch.  Wrong.
-if test "$cross_compiling" = yes; then
-  ac_cv_func_utime_null=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-struct stat s, t;
-  return ! (stat ("conftest.data", &s) == 0
-	    && utime ("conftest.data", 0) == 0
-	    && stat ("conftest.data", &t) == 0
-	    && t.st_mtime >= s.st_mtime
-	    && t.st_mtime - s.st_mtime < 120);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_utime_null=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_func_utime_null=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_utime_null" >&5
-echo "${ECHO_T}$ac_cv_func_utime_null" >&6; }
-if test $ac_cv_func_utime_null = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_UTIME_NULL 1
-_ACEOF
-
-fi
-rm -f conftest.data
-
-# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
-# for constant arguments.  Useless!
-{ echo "$as_me:$LINENO: checking for working alloca.h" >&5
-echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6; }
-if test "${ac_cv_working_alloca_h+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <alloca.h>
-int
-main ()
-{
-char *p = (char *) alloca (2 * sizeof (int));
-			  if (p) return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_working_alloca_h=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_working_alloca_h=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
-echo "${ECHO_T}$ac_cv_working_alloca_h" >&6; }
-if test $ac_cv_working_alloca_h = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ALLOCA_H 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for alloca" >&5
-echo $ECHO_N "checking for alloca... $ECHO_C" >&6; }
-if test "${ac_cv_func_alloca_works+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#ifdef __GNUC__
-# define alloca __builtin_alloca
-#else
-# ifdef _MSC_VER
-#  include <malloc.h>
-#  define alloca _alloca
-# else
-#  ifdef HAVE_ALLOCA_H
-#   include <alloca.h>
-#  else
-#   ifdef _AIX
- #pragma alloca
-#   else
-#    ifndef alloca /* predefined by HP cc +Olibcalls */
-char *alloca ();
-#    endif
-#   endif
-#  endif
-# endif
-#endif
-
-int
-main ()
-{
-char *p = (char *) alloca (1);
-				    if (p) return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_alloca_works=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_alloca_works=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
-echo "${ECHO_T}$ac_cv_func_alloca_works" >&6; }
-
-if test $ac_cv_func_alloca_works = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ALLOCA 1
-_ACEOF
-
-else
-  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
-# that cause trouble.  Some versions do not even contain alloca or
-# contain a buggy version.  If you still want to use their alloca,
-# use ar to extract alloca.o from them instead of compiling alloca.c.
-
-ALLOCA=\${LIBOBJDIR}alloca.$ac_objext
-
-cat >>confdefs.h <<\_ACEOF
-#define C_ALLOCA 1
-_ACEOF
-
-
-{ echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
-echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6; }
-if test "${ac_cv_os_cray+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#if defined CRAY && ! defined CRAY2
-webecray
-#else
-wenotbecray
-#endif
-
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "webecray" >/dev/null 2>&1; then
-  ac_cv_os_cray=yes
-else
-  ac_cv_os_cray=no
-fi
-rm -f conftest*
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
-echo "${ECHO_T}$ac_cv_os_cray" >&6; }
-if test $ac_cv_os_cray = yes; then
-  for ac_func in _getb67 GETB67 getb67; do
-    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-
-cat >>confdefs.h <<_ACEOF
-#define CRAY_STACKSEG_END $ac_func
-_ACEOF
-
-    break
-fi
-
-  done
-fi
-
-{ echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
-echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6; }
-if test "${ac_cv_c_stack_direction+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_c_stack_direction=0
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-find_stack_direction ()
-{
-  static char *addr = 0;
-  auto char dummy;
-  if (addr == 0)
-    {
-      addr = &dummy;
-      return find_stack_direction ();
-    }
-  else
-    return (&dummy > addr) ? 1 : -1;
-}
-
-int
-main ()
-{
-  return find_stack_direction () < 0;
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_c_stack_direction=1
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_c_stack_direction=-1
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
-echo "${ECHO_T}$ac_cv_c_stack_direction" >&6; }
-
-cat >>confdefs.h <<_ACEOF
-#define STACK_DIRECTION $ac_cv_c_stack_direction
-_ACEOF
-
-
-fi
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-for ac_func in waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
-    fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
-    memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
-    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
-    setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
-    strerror putenv iconv_open locale_charset nl_langinfo \
-    sigaction sigprocmask
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-
-
-
-for ac_func in getpgrp tcgetpgrp
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-{ echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6; }
-if { as_var=$as_ac_var; eval "test \"\${$as_var+set}\" = set"; }; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
-   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
-#define $ac_func innocuous_$ac_func
-
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-
-#undef $ac_func
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined __stub_$ac_func || defined __stub___$ac_func
-choke me
-#endif
-
-int
-main ()
-{
-return $ac_func ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	eval "$as_ac_var=no"
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-fi
-ac_res=`eval echo '${'$as_ac_var'}'`
-	       { echo "$as_me:$LINENO: result: $ac_res" >&5
-echo "${ECHO_T}$ac_res" >&6; }
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-if test $ac_cv_func_getpgrp = yes; then
-    { echo "$as_me:$LINENO: checking whether getpgrp requires zero arguments" >&5
-echo $ECHO_N "checking whether getpgrp requires zero arguments... $ECHO_C" >&6; }
-if test "${ac_cv_func_getpgrp_void+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  # Use it with a single arg.
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-getpgrp (0);
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_func_getpgrp_void=no
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_func_getpgrp_void=yes
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_func_getpgrp_void" >&5
-echo "${ECHO_T}$ac_cv_func_getpgrp_void" >&6; }
-if test $ac_cv_func_getpgrp_void = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define GETPGRP_VOID 1
-_ACEOF
-
-fi
-
-fi
-
-{ echo "$as_me:$LINENO: checking whether chown() modifies symlinks" >&5
-echo $ECHO_N "checking whether chown() modifies symlinks... $ECHO_C" >&6; }
-if test "${rsync_cv_chown_modifies_symlink+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-  if test "$cross_compiling" = yes; then
-  rsync_cv_chown_modifies_symlink=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <errno.h>
-    main() {
-	char const *dangling_symlink = "conftest.dangle";
-	unlink(dangling_symlink);
-	if (symlink("conftest.no-such", dangling_symlink) < 0) abort();
-	if (chown(dangling_symlink, getuid(), getgid()) < 0 && errno == ENOENT) exit(1);
-	exit(0);
-    }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_chown_modifies_symlink=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_chown_modifies_symlink=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_chown_modifies_symlink" >&5
-echo "${ECHO_T}$rsync_cv_chown_modifies_symlink" >&6; }
-if test $rsync_cv_chown_modifies_symlink = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define CHOWN_MODIFIES_SYMLINK 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking whether link() can hard-link symlinks" >&5
-echo $ECHO_N "checking whether link() can hard-link symlinks... $ECHO_C" >&6; }
-if test "${rsync_cv_can_hardlink_symlink+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-  if test "$cross_compiling" = yes; then
-  rsync_cv_can_hardlink_symlink=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <errno.h>
-#define FILENAME "conftest.dangle"
-    main() {
-	unlink(FILENAME);
-	if (symlink("conftest.no-such", FILENAME) < 0) abort();
-	if (link(FILENAME, FILENAME "2") < 0) exit(1);
-	exit(0);
-    }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_can_hardlink_symlink=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_can_hardlink_symlink=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_can_hardlink_symlink" >&5
-echo "${ECHO_T}$rsync_cv_can_hardlink_symlink" >&6; }
-if test $rsync_cv_can_hardlink_symlink = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define CAN_HARDLINK_SYMLINK 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking whether link() can hard-link special files" >&5
-echo $ECHO_N "checking whether link() can hard-link special files... $ECHO_C" >&6; }
-if test "${rsync_cv_can_hardlink_special+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-  if test "$cross_compiling" = yes; then
-  rsync_cv_can_hardlink_special=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#if HAVE_UNISTD_H
-# include <unistd.h>
-#endif
-#include <stdlib.h>
-#include <errno.h>
-#define FILENAME "conftest.fifi"
-    main() {
-	unlink(FILENAME);
-	if (mkfifo(FILENAME, 0777) < 0) abort();
-	if (link(FILENAME, FILENAME "2") < 0) exit(1);
-	exit(0);
-    }
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_can_hardlink_special=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_can_hardlink_special=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_can_hardlink_special" >&5
-echo "${ECHO_T}$rsync_cv_can_hardlink_special" >&6; }
-if test $rsync_cv_can_hardlink_special = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define CAN_HARDLINK_SPECIAL 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for working socketpair" >&5
-echo $ECHO_N "checking for working socketpair... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_SOCKETPAIR+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_HAVE_SOCKETPAIR=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-
-main() {
-       int fd[2];
-       exit((socketpair(AF_UNIX, SOCK_STREAM, 0, fd) != -1) ? 0 : 1);
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_SOCKETPAIR=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_HAVE_SOCKETPAIR=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SOCKETPAIR" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_SOCKETPAIR" >&6; }
-if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKETPAIR 1
-_ACEOF
-
-fi
-
-if test x"$with_included_popt" != x"yes"; then
-
-{ echo "$as_me:$LINENO: checking for poptGetContext in -lpopt" >&5
-echo $ECHO_N "checking for poptGetContext in -lpopt... $ECHO_C" >&6; }
-if test "${ac_cv_lib_popt_poptGetContext+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpopt  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-/* Override any GCC internal prototype to avoid an error.
-   Use char because int might match the return type of a GCC
-   builtin and then its argument prototype would still apply.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-char poptGetContext ();
-int
-main ()
-{
-return poptGetContext ();
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_lib_popt_poptGetContext=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	ac_cv_lib_popt_poptGetContext=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest_ipa8_conftest.oo \
-      conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
-fi
-{ echo "$as_me:$LINENO: result: $ac_cv_lib_popt_poptGetContext" >&5
-echo "${ECHO_T}$ac_cv_lib_popt_poptGetContext" >&6; }
-if test $ac_cv_lib_popt_poptGetContext = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBPOPT 1
-_ACEOF
-
-  LIBS="-lpopt $LIBS"
-
-else
-  with_included_popt=yes
-fi
-
-fi
-
-{ echo "$as_me:$LINENO: checking whether to use included libpopt" >&5
-echo $ECHO_N "checking whether to use included libpopt... $ECHO_C" >&6; }
-if test x"$with_included_popt" = x"yes"; then
-    { echo "$as_me:$LINENO: result: $srcdir/popt" >&5
-echo "${ECHO_T}$srcdir/popt" >&6; }
-    BUILD_POPT='$(popt_OBJS)'
-    CFLAGS="$CFLAGS -I$srcdir/popt"
-    if test x"$ALLOCA" != x
-    then
-	# this can be removed when/if we add an included alloca.c;
-	#  see autoconf documentation on AC_FUNC_ALLOCA
-	{ echo "$as_me:$LINENO: WARNING: included libpopt will use malloc, not alloca (which wastes a small amount of memory)" >&5
-echo "$as_me: WARNING: included libpopt will use malloc, not alloca (which wastes a small amount of memory)" >&2;}
-    fi
-else
-    { echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6; }
-fi
-
-{ echo "$as_me:$LINENO: checking for unsigned char" >&5
-echo $ECHO_N "checking for unsigned char... $ECHO_C" >&6; }
-if test "${rsync_cv_SIGNED_CHAR_OK+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-int
-main ()
-{
-signed char *s = ""
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_SIGNED_CHAR_OK=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	rsync_cv_SIGNED_CHAR_OK=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_SIGNED_CHAR_OK" >&5
-echo "${ECHO_T}$rsync_cv_SIGNED_CHAR_OK" >&6; }
-if test x"$rsync_cv_SIGNED_CHAR_OK" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define SIGNED_CHAR_OK 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for broken readdir" >&5
-echo $ECHO_N "checking for broken readdir... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_BROKEN_READDIR+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_HAVE_BROKEN_READDIR=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <dirent.h>
-main() { struct dirent *di; DIR *d = opendir("."); di = readdir(d);
-if (di && di->d_name[-2] == '.' && di->d_name[-1] == 0 &&
-di->d_name[0] == 0) exit(0); exit(1);}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_BROKEN_READDIR=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_HAVE_BROKEN_READDIR=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_BROKEN_READDIR" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_BROKEN_READDIR" >&6; }
-if test x"$rsync_cv_HAVE_BROKEN_READDIR" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_BROKEN_READDIR 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for utimbuf" >&5
-echo $ECHO_N "checking for utimbuf... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_UTIMBUF+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <utime.h>
-int
-main ()
-{
-struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_UTIMBUF=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	rsync_cv_HAVE_UTIMBUF=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_UTIMBUF" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_UTIMBUF" >&6; }
-if test x"$rsync_cv_HAVE_UTIMBUF" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_UTIMBUF 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking if gettimeofday takes tz argument" >&5
-echo $ECHO_N "checking if gettimeofday takes tz argument... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_GETTIMEOFDAY_TZ+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/time.h>
-#include <unistd.h>
-int
-main ()
-{
-struct timeval tv; exit(gettimeofday(&tv, NULL));
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (ac_try="$ac_compile"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_compile") 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-	 { ac_try='test -z "$ac_c_werror_flag" || test ! -s conftest.err'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; } &&
-	 { ac_try='test -s conftest.$ac_objext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_GETTIMEOFDAY_TZ=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-	rsync_cv_HAVE_GETTIMEOFDAY_TZ=no
-fi
-
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&6; }
-if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" != x"no"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_GETTIMEOFDAY_TZ 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking for C99 vsnprintf" >&5
-echo $ECHO_N "checking for C99 vsnprintf... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_C99_VSNPRINTF+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_HAVE_C99_VSNPRINTF=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <stdarg.h>
-void foo(const char *format, ...) {
-       va_list ap;
-       int len;
-       char buf[5];
-
-       va_start(ap, format);
-       len = vsnprintf(0, 0, format, ap);
-       va_end(ap);
-       if (len != 5) exit(1);
-
-       if (snprintf(buf, 3, "hello") != 5 || strcmp(buf, "he") != 0) exit(1);
-
-       exit(0);
-}
-main() { foo("hello"); }
-
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_C99_VSNPRINTF=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_HAVE_C99_VSNPRINTF=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_C99_VSNPRINTF" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_C99_VSNPRINTF" >&6; }
-if test x"$rsync_cv_HAVE_C99_VSNPRINTF" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_C99_VSNPRINTF 1
-_ACEOF
-
-fi
-
-
-{ echo "$as_me:$LINENO: checking for secure mkstemp" >&5
-echo $ECHO_N "checking for secure mkstemp... $ECHO_C" >&6; }
-if test "${rsync_cv_HAVE_SECURE_MKSTEMP+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_HAVE_SECURE_MKSTEMP=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <stdlib.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <unistd.h>
-main() {
-  struct stat st;
-  char tpl[20]="/tmp/test.XXXXXX";
-  int fd = mkstemp(tpl);
-  if (fd == -1) exit(1);
-  unlink(tpl);
-  if (fstat(fd, &st) != 0) exit(1);
-  if ((st.st_mode & 0777) != 0600) exit(1);
-  exit(0);
-}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_HAVE_SECURE_MKSTEMP=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_HAVE_SECURE_MKSTEMP=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SECURE_MKSTEMP" >&5
-echo "${ECHO_T}$rsync_cv_HAVE_SECURE_MKSTEMP" >&6; }
-if test x"$rsync_cv_HAVE_SECURE_MKSTEMP" = x"yes"; then
-    case $target_os in
-    hpux*)
-				{ echo "$as_me:$LINENO: WARNING: Skipping broken HP-UX mkstemp() -- using mktemp() instead" >&5
-echo "$as_me: WARNING: Skipping broken HP-UX mkstemp() -- using mktemp() instead" >&2;}
-	;;
-    *)
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_SECURE_MKSTEMP 1
-_ACEOF
-
-	;;
-    esac
-fi
-
-
-{ echo "$as_me:$LINENO: checking if mknod creates FIFOs" >&5
-echo $ECHO_N "checking if mknod creates FIFOs... $ECHO_C" >&6; }
-if test "${rsync_cv_MKNOD_CREATES_FIFOS+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_MKNOD_CREATES_FIFOS=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <stdio.h>
-#include <sys/stat.h>
-#include <errno.h>
-main() { int rc, ec; char *fn = "fifo-test";
-unlink(fn); rc = mknod(fn,S_IFIFO,0600); ec = errno; unlink(fn);
-if (rc) {printf("(%d %d) ",rc,ec); return ec;}
-return 0;}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_MKNOD_CREATES_FIFOS=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_MKNOD_CREATES_FIFOS=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_MKNOD_CREATES_FIFOS" >&5
-echo "${ECHO_T}$rsync_cv_MKNOD_CREATES_FIFOS" >&6; }
-if test x"$rsync_cv_MKNOD_CREATES_FIFOS" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define MKNOD_CREATES_FIFOS 1
-_ACEOF
-
-fi
-
-{ echo "$as_me:$LINENO: checking if mknod creates sockets" >&5
-echo $ECHO_N "checking if mknod creates sockets... $ECHO_C" >&6; }
-if test "${rsync_cv_MKNOD_CREATES_SOCKETS+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-if test "$cross_compiling" = yes; then
-  rsync_cv_MKNOD_CREATES_SOCKETS=cross
-else
-  cat >conftest.$ac_ext <<_ACEOF
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <stdio.h>
-#include <sys/stat.h>
-#include <errno.h>
-main() { int rc, ec; char *fn = "sock-test";
-unlink(fn); rc = mknod(fn,S_IFSOCK,0600); ec = errno; unlink(fn);
-if (rc) {printf("(%d %d) ",rc,ec); return ec;}
-return 0;}
-_ACEOF
-rm -f conftest$ac_exeext
-if { (ac_try="$ac_link"
-case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_link") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
-  { (case "(($ac_try" in
-  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
-  *) ac_try_echo=$ac_try;;
-esac
-eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
-  (eval "$ac_try") 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  rsync_cv_MKNOD_CREATES_SOCKETS=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-rsync_cv_MKNOD_CREATES_SOCKETS=no
-fi
-rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_MKNOD_CREATES_SOCKETS" >&5
-echo "${ECHO_T}$rsync_cv_MKNOD_CREATES_SOCKETS" >&6; }
-if test x"$rsync_cv_MKNOD_CREATES_SOCKETS" = x"yes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define MKNOD_CREATES_SOCKETS 1
-_ACEOF
-
-fi
-
-#
-# The following test was mostly taken from the tcl/tk plus patches
-#
-{ echo "$as_me:$LINENO: checking whether -c -o works" >&5
-echo $ECHO_N "checking whether -c -o works... $ECHO_C" >&6; }
-if test "${rsync_cv_DASHC_WORKS_WITH_DASHO+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-
-rm -rf conftest*
-cat > conftest.$ac_ext <<EOF
-int main() { return 0; }
-EOF
-${CC-cc} -c -o conftest..o conftest.$ac_ext
-if test -f conftest..o; then
-    rsync_cv_DASHC_WORKS_WITH_DASHO=yes
-else
-    rsync_cv_DASHC_WORKS_WITH_DASHO=no
-fi
-rm -rf conftest*
-
-fi
-{ echo "$as_me:$LINENO: result: $rsync_cv_DASHC_WORKS_WITH_DASHO" >&5
-echo "${ECHO_T}$rsync_cv_DASHC_WORKS_WITH_DASHO" >&6; }
-if test x"$rsync_cv_DASHC_WORKS_WITH_DASHO" = x"yes"; then
-    OBJ_SAVE="#"
-    OBJ_RESTORE="#"
-    CC_SHOBJ_FLAG='-o $@'
-else
-    OBJ_SAVE='	@b=`basename $@ .o`;rm -f $$b.o.sav;if test -f $$b.o; then mv $$b.o $$b.o.sav;fi;'
-    OBJ_RESTORE='	@b=`basename $@ .o`;if test "$$b.o" != "$@"; then mv $$b.o $@; if test -f $$b.o.sav; then mv $$b.o.sav $$b.o; fi; fi'
-    CC_SHOBJ_FLAG=""
-fi
-
-
-
-
-
-
-ac_config_files="$ac_config_files Makefile lib/dummy zlib/dummy popt/dummy shconfig"
-
-cat >confcache <<\_ACEOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs, see configure's option --config-cache.
-# It is not useful on other systems.  If it contains results you don't
-# want to keep, you may remove or edit it.
-#
-# config.status only pays attention to the cache file if you give it
-# the --recheck option to rerun configure.
-#
-# `ac_cv_env_foo' variables (set or unset) will be overridden when
-# loading this file, other *unset* `ac_cv_foo' will be assigned the
-# following values.
-
-_ACEOF
-
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, we kill variables containing newlines.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(
-  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
-    eval ac_val=\$$ac_var
-    case $ac_val in #(
-    *${as_nl}*)
-      case $ac_var in #(
-      *_cv_*) { echo "$as_me:$LINENO: WARNING: Cache variable $ac_var contains a newline." >&5
-echo "$as_me: WARNING: Cache variable $ac_var contains a newline." >&2;} ;;
-      esac
-      case $ac_var in #(
-      _ | IFS | as_nl) ;; #(
-      *) $as_unset $ac_var ;;
-      esac ;;
-    esac
-  done
-
-  (set) 2>&1 |
-    case $as_nl`(ac_space=' '; set) 2>&1` in #(
-    *${as_nl}ac_space=\ *)
-      # `set' does not quote correctly, so add quotes (double-quote
-      # substitution turns \\\\ into \\, and sed turns \\ into \).
-      sed -n \
-	"s/'/'\\\\''/g;
-	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
-      ;; #(
-    *)
-      # `set' quotes correctly as required by POSIX, so do not add quotes.
-      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
-      ;;
-    esac |
-    sort
-) |
-  sed '
-     /^ac_cv_env_/b end
-     t clear
-     :clear
-     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
-     t end
-     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
-     :end' >>confcache
-if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
-  if test -w "$cache_file"; then
-    test "x$cache_file" != "x/dev/null" &&
-      { echo "$as_me:$LINENO: updating cache $cache_file" >&5
-echo "$as_me: updating cache $cache_file" >&6;}
-    cat confcache >$cache_file
-  else
-    { echo "$as_me:$LINENO: not updating unwritable cache $cache_file" >&5
-echo "$as_me: not updating unwritable cache $cache_file" >&6;}
-  fi
-fi
-rm -f confcache
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-DEFS=-DHAVE_CONFIG_H
-
-ac_libobjs=
-ac_ltlibobjs=
-for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
-  # 1. Remove the extension, and $U if already installed.
-  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
-  ac_i=`echo "$ac_i" | sed "$ac_script"`
-  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
-  #    will be set to the directory where LIBOBJS objects are built.
-  ac_libobjs="$ac_libobjs \${LIBOBJDIR}$ac_i\$U.$ac_objext"
-  ac_ltlibobjs="$ac_ltlibobjs \${LIBOBJDIR}$ac_i"'$U.lo'
-done
-LIBOBJS=$ac_libobjs
-
-LTLIBOBJS=$ac_ltlibobjs
-
-
-
-: ${CONFIG_STATUS=./config.status}
-ac_clean_files_save=$ac_clean_files
-ac_clean_files="$ac_clean_files $CONFIG_STATUS"
-{ echo "$as_me:$LINENO: creating $CONFIG_STATUS" >&5
-echo "$as_me: creating $CONFIG_STATUS" >&6;}
-cat >$CONFIG_STATUS <<_ACEOF
-#! $SHELL
-# Generated by $as_me.
-# Run this file to recreate the current configuration.
-# Compiler output produced by configure, useful for debugging
-# configure, is in config.log if it exists.
-
-debug=false
-ac_cs_recheck=false
-ac_cs_silent=false
-SHELL=\${CONFIG_SHELL-$SHELL}
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-## --------------------- ##
-## M4sh Initialization.  ##
-## --------------------- ##
-
-# Be Bourne compatible
-if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then
-  emulate sh
-  NULLCMD=:
-  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
-  # is contrary to our usage.  Disable this feature.
-  alias -g '${1+"$@"}'='"$@"'
-  setopt NO_GLOB_SUBST
-else
-  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
-fi
-BIN_SH=xpg4; export BIN_SH # for Tru64
-DUALCASE=1; export DUALCASE # for MKS sh
-
-
-# PATH needs CR
-# Avoid depending upon Character Ranges.
-as_cr_letters='abcdefghijklmnopqrstuvwxyz'
-as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
-as_cr_Letters=$as_cr_letters$as_cr_LETTERS
-as_cr_digits='0123456789'
-as_cr_alnum=$as_cr_Letters$as_cr_digits
-
-# The user is always right.
-if test "${PATH_SEPARATOR+set}" != set; then
-  echo "#! /bin/sh" >conf$$.sh
-  echo  "exit 0"   >>conf$$.sh
-  chmod +x conf$$.sh
-  if (PATH="/nonexistent;."; conf$$.sh) >/dev/null 2>&1; then
-    PATH_SEPARATOR=';'
-  else
-    PATH_SEPARATOR=:
-  fi
-  rm -f conf$$.sh
-fi
-
-# Support unset when possible.
-if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
-  as_unset=unset
-else
-  as_unset=false
-fi
-
-
-# IFS
-# We need space, tab and new line, in precisely that order.  Quoting is
-# there to prevent editors from complaining about space-tab.
-# (If _AS_PATH_WALK were called with IFS unset, it would disable word
-# splitting by setting IFS to empty value.)
-as_nl='
-'
-IFS=" ""	$as_nl"
-
-# Find who we are.  Look in the path if we contain no directory separator.
-case $0 in
-  *[\\/]* ) as_myself=$0 ;;
-  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
-for as_dir in $PATH
-do
-  IFS=$as_save_IFS
-  test -z "$as_dir" && as_dir=.
-  test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
-done
-IFS=$as_save_IFS
-
-     ;;
-esac
-# We did not find ourselves, most probably we were run as `sh COMMAND'
-# in which case we are not to be found in the path.
-if test "x$as_myself" = x; then
-  as_myself=$0
-fi
-if test ! -f "$as_myself"; then
-  echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
-  { (exit 1); exit 1; }
-fi
-
-# Work around bugs in pre-3.0 UWIN ksh.
-for as_var in ENV MAIL MAILPATH
-do ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-done
-PS1='$ '
-PS2='> '
-PS4='+ '
-
-# NLS nuisances.
-for as_var in \
-  LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
-  LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
-  LC_TELEPHONE LC_TIME
-do
-  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
-    eval $as_var=C; export $as_var
-  else
-    ($as_unset $as_var) >/dev/null 2>&1 && $as_unset $as_var
-  fi
-done
-
-# Required to use basename.
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
-  as_basename=basename
-else
-  as_basename=false
-fi
-
-
-# Name of the executable.
-as_me=`$as_basename -- "$0" ||
-$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
-	 X"$0" : 'X\(//\)$' \| \
-	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
-echo X/"$0" |
-    sed '/^.*\/\([^/][^/]*\)\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\/\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-
-# CDPATH.
-$as_unset CDPATH
-
-
-
-  as_lineno_1=$LINENO
-  as_lineno_2=$LINENO
-  test "x$as_lineno_1" != "x$as_lineno_2" &&
-  test "x`expr $as_lineno_1 + 1`" = "x$as_lineno_2" || {
-
-  # Create $as_me.lineno as a copy of $as_myself, but with $LINENO
-  # uniformly replaced by the line number.  The first 'sed' inserts a
-  # line-number line after each line using $LINENO; the second 'sed'
-  # does the real work.  The second script uses 'N' to pair each
-  # line-number line with the line containing $LINENO, and appends
-  # trailing '-' during substitution so that $LINENO is not a special
-  # case at line end.
-  # (Raja R Harinath suggested sed '=', and Paul Eggert wrote the
-  # scripts with optimization help from Paolo Bonzini.  Blame Lee
-  # E. McMahon (1931-1989) for sed's syntax.  :-)
-  sed -n '
-    p
-    /[$]LINENO/=
-  ' <$as_myself |
-    sed '
-      s/[$]LINENO.*/&-/
-      t lineno
-      b
-      :lineno
-      N
-      :loop
-      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
-      t loop
-      s/-\n.*//
-    ' >$as_me.lineno &&
-  chmod +x "$as_me.lineno" ||
-    { echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2
-   { (exit 1); exit 1; }; }
-
-  # Don't try to exec as it changes $[0], causing all sort of problems
-  # (the dirname of $[0] is not the place where we might find the
-  # original and so on.  Autoconf is especially sensitive to this).
-  . "./$as_me.lineno"
-  # Exit status is that of the last command.
-  exit
-}
-
-
-if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
-  as_dirname=dirname
-else
-  as_dirname=false
-fi
-
-ECHO_C= ECHO_N= ECHO_T=
-case `echo -n x` in
--n*)
-  case `echo 'x\c'` in
-  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
-  *)   ECHO_C='\c';;
-  esac;;
-*)
-  ECHO_N='-n';;
-esac
-
-if expr a : '\(a\)' >/dev/null 2>&1 &&
-   test "X`expr 00001 : '.*\(...\)'`" = X001; then
-  as_expr=expr
-else
-  as_expr=false
-fi
-
-rm -f conf$$ conf$$.exe conf$$.file
-if test -d conf$$.dir; then
-  rm -f conf$$.dir/conf$$.file
-else
-  rm -f conf$$.dir
-  mkdir conf$$.dir
-fi
-echo >conf$$.file
-if ln -s conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s='ln -s'
-  # ... but there are two gotchas:
-  # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
-  # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
-  # In both cases, we have to default to `cp -p'.
-  ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
-    as_ln_s='cp -p'
-elif ln conf$$.file conf$$ 2>/dev/null; then
-  as_ln_s=ln
-else
-  as_ln_s='cp -p'
-fi
-rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
-rmdir conf$$.dir 2>/dev/null
-
-if mkdir -p . 2>/dev/null; then
-  as_mkdir_p=:
-else
-  test -d ./-p && rmdir ./-p
-  as_mkdir_p=false
-fi
-
-# Find out whether ``test -x'' works.  Don't use a zero-byte file, as
-# systems may use methods other than mode bits to determine executability.
-cat >conf$$.file <<_ASEOF
-#! /bin/sh
-exit 0
-_ASEOF
-chmod +x conf$$.file
-if test -x conf$$.file >/dev/null 2>&1; then
-  as_executable_p="test -x"
-else
-  as_executable_p=:
-fi
-rm -f conf$$.file
-
-# Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
-
-# Sed expression to map a string onto a valid variable name.
-as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
-
-
-exec 6>&1
-
-# Save the log message, to keep $[0] and so on meaningful, and to
-# report actual input values of CONFIG_FILES etc. instead of their
-# values after options handling.
-ac_log="
-This file was extended by $as_me, which was
-generated by GNU Autoconf 2.60a.  Invocation command line was
-
-  CONFIG_FILES    = $CONFIG_FILES
-  CONFIG_HEADERS  = $CONFIG_HEADERS
-  CONFIG_LINKS    = $CONFIG_LINKS
-  CONFIG_COMMANDS = $CONFIG_COMMANDS
-  $ $0 $@
-
-on `(hostname || uname -n) 2>/dev/null | sed 1q`
-"
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<_ACEOF
-# Files that config.status was made for.
-config_files="$ac_config_files"
-config_headers="$ac_config_headers"
-
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-ac_cs_usage="\
-\`$as_me' instantiates files from templates according to the
-current configuration.
-
-Usage: $0 [OPTIONS] [FILE]...
-
-  -h, --help       print this help, then exit
-  -V, --version    print version number and configuration settings, then exit
-  -q, --quiet      do not print progress messages
-  -d, --debug      don't remove temporary files
-      --recheck    update $as_me by reconfiguring in the same conditions
-  --file=FILE[:TEMPLATE]
-		   instantiate the configuration file FILE
-  --header=FILE[:TEMPLATE]
-		   instantiate the configuration header FILE
-
-Configuration files:
-$config_files
-
-Configuration headers:
-$config_headers
-
-Report bugs to <bug-autoconf@gnu.org>."
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-ac_cs_version="\\
-config.status
-configured by $0, generated by GNU Autoconf 2.60a,
-  with options \\"`echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
-
-Copyright (C) 2006 Free Software Foundation, Inc.
-This config.status script is free software; the Free Software Foundation
-gives unlimited permission to copy, distribute and modify it."
-
-ac_pwd='$ac_pwd'
-srcdir='$srcdir'
-INSTALL='$INSTALL'
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-# If no file are specified by the user, then we need to provide default
-# value.  By we need to know if files were specified by the user.
-ac_need_defaults=:
-while test $# != 0
-do
-  case $1 in
-  --*=*)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
-    ac_shift=:
-    ;;
-  *)
-    ac_option=$1
-    ac_optarg=$2
-    ac_shift=shift
-    ;;
-  esac
-
-  case $ac_option in
-  # Handling of the options.
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    ac_cs_recheck=: ;;
-  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
-    echo "$ac_cs_version"; exit ;;
-  --debug | --debu | --deb | --de | --d | -d )
-    debug=: ;;
-  --file | --fil | --fi | --f )
-    $ac_shift
-    CONFIG_FILES="$CONFIG_FILES $ac_optarg"
-    ac_need_defaults=false;;
-  --header | --heade | --head | --hea )
-    $ac_shift
-    CONFIG_HEADERS="$CONFIG_HEADERS $ac_optarg"
-    ac_need_defaults=false;;
-  --he | --h)
-    # Conflict between --help and --header
-    { echo "$as_me: error: ambiguous option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; };;
-  --help | --hel | -h )
-    echo "$ac_cs_usage"; exit ;;
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil | --si | --s)
-    ac_cs_silent=: ;;
-
-  # This is an error.
-  -*) { echo "$as_me: error: unrecognized option: $1
-Try \`$0 --help' for more information." >&2
-   { (exit 1); exit 1; }; } ;;
-
-  *) ac_config_targets="$ac_config_targets $1"
-     ac_need_defaults=false ;;
-
-  esac
-  shift
-done
-
-ac_configure_extra_args=
-
-if $ac_cs_silent; then
-  exec 6>/dev/null
-  ac_configure_extra_args="$ac_configure_extra_args --silent"
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-if \$ac_cs_recheck; then
-  echo "running CONFIG_SHELL=$SHELL $SHELL $0 "$ac_configure_args \$ac_configure_extra_args " --no-create --no-recursion" >&6
-  CONFIG_SHELL=$SHELL
-  export CONFIG_SHELL
-  exec $SHELL "$0"$ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
-fi
-
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
-exec 5>>config.log
-{
-  echo
-  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
-## Running $as_me. ##
-_ASBOX
-  echo "$ac_log"
-} >&5
-
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-
-# Handling of arguments.
-for ac_config_target in $ac_config_targets
-do
-  case $ac_config_target in
-    "config.h") CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
-    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
-    "lib/dummy") CONFIG_FILES="$CONFIG_FILES lib/dummy" ;;
-    "zlib/dummy") CONFIG_FILES="$CONFIG_FILES zlib/dummy" ;;
-    "popt/dummy") CONFIG_FILES="$CONFIG_FILES popt/dummy" ;;
-    "shconfig") CONFIG_FILES="$CONFIG_FILES shconfig" ;;
-
-  *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
-echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
-   { (exit 1); exit 1; }; };;
-  esac
-done
-
-
-# If the user did not use the arguments to specify the items to instantiate,
-# then the envvar interface is used.  Set only those that are not.
-# We use the long form for the default assignment because of an extremely
-# bizarre bug on SunOS 4.1.3.
-if $ac_need_defaults; then
-  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
-  test "${CONFIG_HEADERS+set}" = set || CONFIG_HEADERS=$config_headers
-fi
-
-# Have a temporary directory for convenience.  Make it in the build tree
-# simply because there is no reason against having it here, and in addition,
-# creating and moving files from /tmp can sometimes cause problems.
-# Hook for its removal unless debugging.
-# Note that there is a small window in which the directory will not be cleaned:
-# after its creation but before its name has been assigned to `$tmp'.
-$debug ||
-{
-  tmp=
-  trap 'exit_status=$?
-  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
-' 0
-  trap '{ (exit 1); exit 1; }' 1 2 13 15
-}
-# Create a (secure) tmp directory for tmp files.
-
-{
-  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -n "$tmp" && test -d "$tmp"
-}  ||
-{
-  tmp=./conf$$-$RANDOM
-  (umask 077 && mkdir "$tmp")
-} ||
-{
-   echo "$me: cannot create a temporary directory in ." >&2
-   { (exit 1); exit 1; }
-}
-
-#
-# Set up the sed scripts for CONFIG_FILES section.
-#
-
-# No need to generate the scripts if there are no CONFIG_FILES.
-# This happens for instance when ./config.status config.h
-if test -n "$CONFIG_FILES"; then
-
-_ACEOF
-
-
-
-ac_delim='%!_!# '
-for ac_last_try in false false false false false :; do
-  cat >conf$$subs.sed <<_ACEOF
-SHELL!$SHELL$ac_delim
-PATH_SEPARATOR!$PATH_SEPARATOR$ac_delim
-PACKAGE_NAME!$PACKAGE_NAME$ac_delim
-PACKAGE_TARNAME!$PACKAGE_TARNAME$ac_delim
-PACKAGE_VERSION!$PACKAGE_VERSION$ac_delim
-PACKAGE_STRING!$PACKAGE_STRING$ac_delim
-PACKAGE_BUGREPORT!$PACKAGE_BUGREPORT$ac_delim
-exec_prefix!$exec_prefix$ac_delim
-prefix!$prefix$ac_delim
-program_transform_name!$program_transform_name$ac_delim
-bindir!$bindir$ac_delim
-sbindir!$sbindir$ac_delim
-libexecdir!$libexecdir$ac_delim
-datarootdir!$datarootdir$ac_delim
-datadir!$datadir$ac_delim
-sysconfdir!$sysconfdir$ac_delim
-sharedstatedir!$sharedstatedir$ac_delim
-localstatedir!$localstatedir$ac_delim
-includedir!$includedir$ac_delim
-oldincludedir!$oldincludedir$ac_delim
-docdir!$docdir$ac_delim
-infodir!$infodir$ac_delim
-htmldir!$htmldir$ac_delim
-dvidir!$dvidir$ac_delim
-pdfdir!$pdfdir$ac_delim
-psdir!$psdir$ac_delim
-libdir!$libdir$ac_delim
-localedir!$localedir$ac_delim
-mandir!$mandir$ac_delim
-DEFS!$DEFS$ac_delim
-ECHO_C!$ECHO_C$ac_delim
-ECHO_N!$ECHO_N$ac_delim
-ECHO_T!$ECHO_T$ac_delim
-LIBS!$LIBS$ac_delim
-build_alias!$build_alias$ac_delim
-host_alias!$host_alias$ac_delim
-target_alias!$target_alias$ac_delim
-RSYNC_VERSION!$RSYNC_VERSION$ac_delim
-build!$build$ac_delim
-build_cpu!$build_cpu$ac_delim
-build_vendor!$build_vendor$ac_delim
-build_os!$build_os$ac_delim
-host!$host$ac_delim
-host_cpu!$host_cpu$ac_delim
-host_vendor!$host_vendor$ac_delim
-host_os!$host_os$ac_delim
-target!$target$ac_delim
-target_cpu!$target_cpu$ac_delim
-target_vendor!$target_vendor$ac_delim
-target_os!$target_os$ac_delim
-CC!$CC$ac_delim
-CFLAGS!$CFLAGS$ac_delim
-LDFLAGS!$LDFLAGS$ac_delim
-CPPFLAGS!$CPPFLAGS$ac_delim
-ac_ct_CC!$ac_ct_CC$ac_delim
-EXEEXT!$EXEEXT$ac_delim
-OBJEXT!$OBJEXT$ac_delim
-CPP!$CPP$ac_delim
-GREP!$GREP$ac_delim
-EGREP!$EGREP$ac_delim
-INSTALL_PROGRAM!$INSTALL_PROGRAM$ac_delim
-INSTALL_SCRIPT!$INSTALL_SCRIPT$ac_delim
-INSTALL_DATA!$INSTALL_DATA$ac_delim
-HAVE_REMSH!$HAVE_REMSH$ac_delim
-LIBOBJS!$LIBOBJS$ac_delim
-ALLOCA!$ALLOCA$ac_delim
-OBJ_SAVE!$OBJ_SAVE$ac_delim
-OBJ_RESTORE!$OBJ_RESTORE$ac_delim
-CC_SHOBJ_FLAG!$CC_SHOBJ_FLAG$ac_delim
-BUILD_POPT!$BUILD_POPT$ac_delim
-LTLIBOBJS!$LTLIBOBJS$ac_delim
-_ACEOF
-
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 71; then
-    break
-  elif $ac_last_try; then
-    { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5
-echo "$as_me: error: could not make $CONFIG_STATUS" >&2;}
-   { (exit 1); exit 1; }; }
-  else
-    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
-  fi
-done
-
-ac_eof=`sed -n '/^CEOF[0-9]*$/s/CEOF/0/p' conf$$subs.sed`
-if test -n "$ac_eof"; then
-  ac_eof=`echo "$ac_eof" | sort -nru | sed 1q`
-  ac_eof=`expr $ac_eof + 1`
-fi
-
-cat >>$CONFIG_STATUS <<_ACEOF
-cat >"\$tmp/subs-1.sed" <<\CEOF$ac_eof
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b end
-_ACEOF
-sed '
-s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g
-s/^/s,@/; s/!/@,|#_!!_#|/
-:n
-t n
-s/'"$ac_delim"'$/,g/; t
-s/$/\\/; p
-N; s/^.*\n//; s/[,\\&]/\\&/g; s/@/@|#_!!_#|/g; b n
-' >>$CONFIG_STATUS <conf$$subs.sed
-rm -f conf$$subs.sed
-cat >>$CONFIG_STATUS <<_ACEOF
-:end
-s/|#_!!_#|//g
-CEOF$ac_eof
-_ACEOF
-
-
-# VPATH may cause trouble with some makes, so we remove $(srcdir),
-# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
-# trailing colons and then remove the whole line if VPATH becomes empty
-# (actually we leave an empty line to preserve line numbers).
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
-s/:*\$(srcdir):*/:/
-s/:*\${srcdir}:*/:/
-s/:*@srcdir@:*/:/
-s/^\([^=]*=[	 ]*\):*/\1/
-s/:*$//
-s/^[^=]*=[	 ]*$//
-}'
-fi
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-fi # test -n "$CONFIG_FILES"
-
-
-for ac_tag in  :F $CONFIG_FILES  :H $CONFIG_HEADERS
-do
-  case $ac_tag in
-  :[FHLC]) ac_mode=$ac_tag; continue;;
-  esac
-  case $ac_mode$ac_tag in
-  :[FHL]*:*);;
-  :L* | :C*:*) { { echo "$as_me:$LINENO: error: Invalid tag $ac_tag." >&5
-echo "$as_me: error: Invalid tag $ac_tag." >&2;}
-   { (exit 1); exit 1; }; };;
-  :[FH]-) ac_tag=-:-;;
-  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
-  esac
-  ac_save_IFS=$IFS
-  IFS=:
-  set x $ac_tag
-  IFS=$ac_save_IFS
-  shift
-  ac_file=$1
-  shift
-
-  case $ac_mode in
-  :L) ac_source=$1;;
-  :[FH])
-    ac_file_inputs=
-    for ac_f
-    do
-      case $ac_f in
-      -) ac_f="$tmp/stdin";;
-      *) # Look for the file first in the build tree, then in the source tree
-	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
-	 # because $ac_f cannot contain `:'.
-	 test -f "$ac_f" ||
-	   case $ac_f in
-	   [\\/$]*) false;;
-	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
-	   esac ||
-	   { { echo "$as_me:$LINENO: error: cannot find input file: $ac_f" >&5
-echo "$as_me: error: cannot find input file: $ac_f" >&2;}
-   { (exit 1); exit 1; }; };;
-      esac
-      ac_file_inputs="$ac_file_inputs $ac_f"
-    done
-
-    # Let's still pretend it is `configure' which instantiates (i.e., don't
-    # use $as_me), people would be surprised to read:
-    #    /* config.h.  Generated by config.status.  */
-    configure_input="Generated from "`IFS=:
-	  echo $* | sed 's|^[^:]*/||;s|:[^:]*/|, |g'`" by configure."
-    if test x"$ac_file" != x-; then
-      configure_input="$ac_file.  $configure_input"
-      { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
+#!/bin/sh -e
+# This configure script ensures that the configure.sh script exists, and
+# if not, it tries to fetch rsync's generated files or build them.  We
+# then transfer control to the configure.sh script to do the real work.
+
+dir=`dirname $0`
+realconfigure="$dir/configure.sh"
+
+if test ! -f "$realconfigure"; then
+    if test -f "$HOME/build_farm/build_test.fns"; then
+	# Allow the build farm to grab latest files via rsync.
+	actions='build fetch'
+    else
+	actions='build'
     fi
-
-    case $ac_tag in
-    *:-:* | *:-) cat >"$tmp/stdin";;
-    esac
-    ;;
-  esac
-
-  ac_dir=`$as_dirname -- "$ac_file" ||
-$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$ac_file" : 'X\(//\)[^/]' \| \
-	 X"$ac_file" : 'X\(//\)$' \| \
-	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$ac_file" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-  { as_dir="$ac_dir"
-  case $as_dir in #(
-  -*) as_dir=./$as_dir;;
-  esac
-  test -d "$as_dir" || { $as_mkdir_p && mkdir -p "$as_dir"; } || {
-    as_dirs=
-    while :; do
-      case $as_dir in #(
-      *\'*) as_qdir=`echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #(
-      *) as_qdir=$as_dir;;
-      esac
-      as_dirs="'$as_qdir' $as_dirs"
-      as_dir=`$as_dirname -- "$as_dir" ||
-$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
-	 X"$as_dir" : 'X\(//\)[^/]' \| \
-	 X"$as_dir" : 'X\(//\)$' \| \
-	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
-echo X"$as_dir" |
-    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)[^/].*/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\/\)$/{
-	    s//\1/
-	    q
-	  }
-	  /^X\(\/\).*/{
-	    s//\1/
-	    q
-	  }
-	  s/.*/./; q'`
-      test -d "$as_dir" && break
-    done
-    test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || { { echo "$as_me:$LINENO: error: cannot create directory $as_dir" >&5
-echo "$as_me: error: cannot create directory $as_dir" >&2;}
-   { (exit 1); exit 1; }; }; }
-  ac_builddir=.
-
-case "$ac_dir" in
-.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
-*)
-  ac_dir_suffix=/`echo "$ac_dir" | sed 's,^\.[\\/],,'`
-  # A ".." for each directory in $ac_dir_suffix.
-  ac_top_builddir_sub=`echo "$ac_dir_suffix" | sed 's,/[^\\/]*,/..,g;s,/,,'`
-  case $ac_top_builddir_sub in
-  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
-  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
-  esac ;;
-esac
-ac_abs_top_builddir=$ac_pwd
-ac_abs_builddir=$ac_pwd$ac_dir_suffix
-# for backward compatibility:
-ac_top_builddir=$ac_top_build_prefix
-
-case $srcdir in
-  .)  # We are building in place.
-    ac_srcdir=.
-    ac_top_srcdir=$ac_top_builddir_sub
-    ac_abs_top_srcdir=$ac_pwd ;;
-  [\\/]* | ?:[\\/]* )  # Absolute name.
-    ac_srcdir=$srcdir$ac_dir_suffix;
-    ac_top_srcdir=$srcdir
-    ac_abs_top_srcdir=$srcdir ;;
-  *) # Relative name.
-    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
-    ac_top_srcdir=$ac_top_build_prefix$srcdir
-    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
-esac
-ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
-
-
-  case $ac_mode in
-  :F)
-  #
-  # CONFIG_FILE
-  #
-
-  case $INSTALL in
-  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
-  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
-  esac
-_ACEOF
-
-cat >>$CONFIG_STATUS <<\_ACEOF
-# If the template does not know about datarootdir, expand it.
-# FIXME: This hack should be removed a few years after 2.60.
-ac_datarootdir_hack=; ac_datarootdir_seen=
-
-case `sed -n '/datarootdir/ {
-  p
-  q
-}
-/@datadir@/p
-/@docdir@/p
-/@infodir@/p
-/@localedir@/p
-/@mandir@/p
-' $ac_file_inputs` in
-*datarootdir*) ac_datarootdir_seen=yes;;
-*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
-  { echo "$as_me:$LINENO: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
-echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
-_ACEOF
-cat >>$CONFIG_STATUS <<_ACEOF
-  ac_datarootdir_hack='
-  s&@datadir@&$datadir&g
-  s&@docdir@&$docdir&g
-  s&@infodir@&$infodir&g
-  s&@localedir@&$localedir&g
-  s&@mandir@&$mandir&g
-    s&\\\${datarootdir}&$datarootdir&g' ;;
-esac
-_ACEOF
-
-# Neutralize VPATH when `$srcdir' = `.'.
-# Shell code in configure.ac might set extrasub.
-# FIXME: do we really want to maintain this feature?
-cat >>$CONFIG_STATUS <<_ACEOF
-  sed "$ac_vpsub
-$extrasub
-_ACEOF
-cat >>$CONFIG_STATUS <<\_ACEOF
-:t
-/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
-s&@configure_input@&$configure_input&;t t
-s&@top_builddir@&$ac_top_builddir_sub&;t t
-s&@srcdir@&$ac_srcdir&;t t
-s&@abs_srcdir@&$ac_abs_srcdir&;t t
-s&@top_srcdir@&$ac_top_srcdir&;t t
-s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
-s&@builddir@&$ac_builddir&;t t
-s&@abs_builddir@&$ac_abs_builddir&;t t
-s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
-s&@INSTALL@&$ac_INSTALL&;t t
-$ac_datarootdir_hack
-" $ac_file_inputs | sed -f "$tmp/subs-1.sed" >$tmp/out
-
-test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
-  { echo "$as_me:$LINENO: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&5
-echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined." >&2;}
-
-  rm -f "$tmp/stdin"
-  case $ac_file in
-  -) cat "$tmp/out"; rm -f "$tmp/out";;
-  *) rm -f "$ac_file"; mv "$tmp/out" $ac_file;;
-  esac
- ;;
-  :H)
-  #
-  # CONFIG_HEADER
-  #
-_ACEOF
-
-# Transform confdefs.h into a sed script `conftest.defines', that
-# substitutes the proper values into config.h.in to produce config.h.
-rm -f conftest.defines conftest.tail
-# First, append a space to every undef/define line, to ease matching.
-echo 's/$/ /' >conftest.defines
-# Then, protect against being on the right side of a sed subst, or in
-# an unquoted here document, in config.status.  If some macros were
-# called several times there might be several #defines for the same
-# symbol, which is useless.  But do not sort them, since the last
-# AC_DEFINE must be honored.
-ac_word_re=[_$as_cr_Letters][_$as_cr_alnum]*
-# These sed commands are passed to sed as "A NAME B PARAMS C VALUE D", where
-# NAME is the cpp macro being defined, VALUE is the value it is being given.
-# PARAMS is the parameter list in the macro definition--in most cases, it's
-# just an empty string.
-ac_dA='s,^\\([	 #]*\\)[^	 ]*\\([	 ]*'
-ac_dB='\\)[	 (].*,\\1define\\2'
-ac_dC=' '
-ac_dD=' ,'
-
-uniq confdefs.h |
-  sed -n '
-	t rset
-	:rset
-	s/^[	 ]*#[	 ]*define[	 ][	 ]*//
-	t ok
-	d
-	:ok
-	s/[\\&,]/\\&/g
-	s/^\('"$ac_word_re"'\)\(([^()]*)\)[	 ]*\(.*\)/ '"$ac_dA"'\1'"$ac_dB"'\2'"${ac_dC}"'\3'"$ac_dD"'/p
-	s/^\('"$ac_word_re"'\)[	 ]*\(.*\)/'"$ac_dA"'\1'"$ac_dB$ac_dC"'\2'"$ac_dD"'/p
-  ' >>conftest.defines
-
-# Remove the space that was appended to ease matching.
-# Then replace #undef with comments.  This is necessary, for
-# example, in the case of _POSIX_SOURCE, which is predefined and required
-# on some systems where configure will not decide to define it.
-# (The regexp can be short, since the line contains either #define or #undef.)
-echo 's/ $//
-s,^[	 #]*u.*,/* & */,' >>conftest.defines
-
-# Break up conftest.defines:
-ac_max_sed_lines=50
-
-# First sed command is:	 sed -f defines.sed $ac_file_inputs >"$tmp/out1"
-# Second one is:	 sed -f defines.sed "$tmp/out1" >"$tmp/out2"
-# Third one will be:	 sed -f defines.sed "$tmp/out2" >"$tmp/out1"
-# et cetera.
-ac_in='$ac_file_inputs'
-ac_out='"$tmp/out1"'
-ac_nxt='"$tmp/out2"'
-
-while :
-do
-  # Write a here document:
-    cat >>$CONFIG_STATUS <<_ACEOF
-    # First, check the format of the line:
-    cat >"\$tmp/defines.sed" <<\\CEOF
-/^[	 ]*#[	 ]*undef[	 ][	 ]*$ac_word_re[	 ]*\$/b def
-/^[	 ]*#[	 ]*define[	 ][	 ]*$ac_word_re[(	 ]/b def
-b
-:def
-_ACEOF
-  sed ${ac_max_sed_lines}q conftest.defines >>$CONFIG_STATUS
-  echo 'CEOF
-    sed -f "$tmp/defines.sed"' "$ac_in >$ac_out" >>$CONFIG_STATUS
-  ac_in=$ac_out; ac_out=$ac_nxt; ac_nxt=$ac_in
-  sed 1,${ac_max_sed_lines}d conftest.defines >conftest.tail
-  grep . conftest.tail >/dev/null || break
-  rm -f conftest.defines
-  mv conftest.tail conftest.defines
-done
-rm -f conftest.defines conftest.tail
-
-echo "ac_result=$ac_in" >>$CONFIG_STATUS
-cat >>$CONFIG_STATUS <<\_ACEOF
-  if test x"$ac_file" != x-; then
-    echo "/* $configure_input  */" >"$tmp/config.h"
-    cat "$ac_result" >>"$tmp/config.h"
-    if diff $ac_file "$tmp/config.h" >/dev/null 2>&1; then
-      { echo "$as_me:$LINENO: $ac_file is unchanged" >&5
-echo "$as_me: $ac_file is unchanged" >&6;}
+    if "$dir/prepare-source" $actions; then
+	:
     else
-      rm -f $ac_file
-      mv "$tmp/config.h" $ac_file
+	echo 'Failed to build configure.sh and/or config.h.in -- giving up.' >&2
+	rm -f "$realconfigure"
+	exit 1
     fi
-  else
-    echo "/* $configure_input  */"
-    cat "$ac_result"
-  fi
-  rm -f "$tmp/out12"
- ;;
-
-
-  esac
-
-done # for ac_tag
-
-
-{ (exit 0); exit 0; }
-_ACEOF
-chmod +x $CONFIG_STATUS
-ac_clean_files=$ac_clean_files_save
-
-
-# configure is writing to config.log, and then calls config.status.
-# config.status does its own redirection, appending to config.log.
-# Unfortunately, on DOS this fails, as config.log is still kept open
-# by configure, so config.status won't be able to write to it; its
-# output is simply discarded.  So we exec the FD to /dev/null,
-# effectively closing config.log, so it can be properly (re)opened and
-# appended to by config.status.  When coming back to configure, we
-# need to make the FD available again.
-if test "$no_create" != yes; then
-  ac_cs_success=:
-  ac_config_status_args=
-  test "$silent" = yes &&
-    ac_config_status_args="$ac_config_status_args --quiet"
-  exec 5>/dev/null
-  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
-  exec 5>>config.log
-  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
-  # would make configure fail if this is the last instruction.
-  $ac_cs_success || { (exit 1); exit 1; }
 fi
 
-
-{ echo "$as_me:$LINENO: result: " >&5
-echo "${ECHO_T}" >&6; }
-{ echo "$as_me:$LINENO: result:     rsync ${RSYNC_VERSION} configuration successful" >&5
-echo "${ECHO_T}    rsync ${RSYNC_VERSION} configuration successful" >&6; }
-{ echo "$as_me:$LINENO: result: " >&5
-echo "${ECHO_T}" >&6; }
+exec "$realconfigure" "${@}"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/configure.in	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/configure.in	2008-03-02 04:12:04.000000000 +0800
@@ -2,13 +2,13 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.59)
 
-RSYNC_VERSION=2.6.9
+RSYNC_VERSION=3.0.0
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
@@ -35,13 +35,13 @@
 # Please allow this to default to yes, so that your users have more
 # chance of getting a useful stack trace if problems occur.
 
 AC_MSG_CHECKING([whether to include debugging symbols])
 AC_ARG_ENABLE(debug,
 	AC_HELP_STRING([--disable-debug],
-		[turn off debugging symbols and features]))
+		[disable debugging symbols and features]))
 
 if test x"$enable_debug" = x"no"; then
     AC_MSG_RESULT(no)
     CFLAGS=${CFLAGS-"-O"}
 else
     AC_MSG_RESULT([yes])
@@ -120,12 +120,17 @@
 	RSYNC_RSH="$with_rsh"
 else
 	RSYNC_RSH="ssh"
 fi
 AC_DEFINE_UNQUOTED(RSYNC_RSH, "$RSYNC_RSH", [default -e command])
 
+AC_CHECK_PROG(HAVE_YODL2MAN, yodl2man, 1, 0)
+if test x$HAVE_YODL2MAN = x1; then
+    MAKE_MAN=man
+fi
+
 AC_ARG_WITH(nobody-group,
     AC_HELP_STRING([--with-nobody-group=GROUP],
 		   [set the default unprivileged group (default nobody or nogroup)]),
     [ NOBODY_GROUP="$with_nobody_group" ])
 
 if test x"$with_nobody_group" = x; then
@@ -280,13 +285,13 @@
 	AC_SEARCH_LIBS(getaddrinfo, inet6)
 fi
 
 dnl Do you want to disable use of locale functions
 AC_ARG_ENABLE([locale],
 	AC_HELP_STRING([--disable-locale],
-		[turn off locale features]))
+		[disable locale features]))
 AH_TEMPLATE([CONFIG_LOCALE],
 [Undefine if you don't want locale features.  By default this is defined.])
 if test x"$enable_locale" != x"no"; then
 	AC_DEFINE(CONFIG_LOCALE)
 fi
 
@@ -303,13 +308,13 @@
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
     unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
     sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
-    sys/un.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
+    sys/un.h sys/attr.h glob.h mcheck.h arpa/inet.h arpa/nameser.h locale.h \
     netdb.h malloc.h float.h limits.h iconv.h libcharset.h langinfo.h)
 AC_HEADER_MAJOR
 
 AC_CACHE_CHECK([if makedev takes 3 args],rsync_cv_MAKEDEV_TAKES_3_ARGS,[
 AC_TRY_RUN([
 #include <sys/types.h>
@@ -336,24 +341,27 @@
 fi
 
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
 AC_CHECK_SIZEOF(long long)
 AC_CHECK_SIZEOF(short)
+AC_CHECK_SIZEOF(int16_t)
+AC_CHECK_SIZEOF(uint16_t)
+AC_CHECK_SIZEOF(int32_t)
+AC_CHECK_SIZEOF(uint32_t)
+AC_CHECK_SIZEOF(int64_t)
 AC_CHECK_SIZEOF(off_t)
 AC_CHECK_SIZEOF(off64_t)
+AC_CHECK_SIZEOF(time_t)
 
 AC_C_INLINE
 AC_C_LONG_DOUBLE
 
 AC_TYPE_SIGNAL
 AC_TYPE_UID_T
-AC_TYPE_MODE_T
-AC_TYPE_OFF_T
-AC_TYPE_SIZE_T
-AC_TYPE_PID_T
+AC_CHECK_TYPES([mode_t,off_t,size_t,pid_t,id_t])
 AC_TYPE_GETGROUPS
 AC_CHECK_MEMBERS([struct stat.st_rdev])
 
 TYPE_SOCKLEN_T
 
 AC_CACHE_CHECK([for errno in errno.h],rsync_cv_errno, [
@@ -402,17 +410,43 @@
 AC_SEARCH_LIBS(inet_ntop, resolv)
 
 # Solaris and HP-UX weirdness:
 # Search for libiconv_open (not iconv_open) to discover if -liconv is needed!
 AC_SEARCH_LIBS(libiconv_open, iconv)
 
+AC_MSG_CHECKING([for iconv declaration])
+AC_CACHE_VAL(am_cv_proto_iconv, [
+    AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], am_cv_proto_iconv_arg1="", am_cv_proto_iconv_arg1="const")
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+AC_MSG_RESULT([$]{ac_t:-
+         }[$]am_cv_proto_iconv)
+AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,
+		   [Define as const if the declaration of iconv() needs const.])
+
 dnl AC_MSG_NOTICE([Looking in libraries: $LIBS])
 
 AC_CHECK_FUNCS(inet_ntop, , [AC_LIBOBJ(lib/inet_ntop)])
 AC_CHECK_FUNCS(inet_pton, , [AC_LIBOBJ(lib/inet_pton)])
 
+AC_HAVE_TYPE([struct addrinfo], [#include <netdb.h>])
+AC_HAVE_TYPE([struct sockaddr_storage], [#include <sys/types.h>
+#include <sys/socket.h>])
+
 # Irix 6.5 has getaddrinfo but not the corresponding defines, so use
 #   builtin getaddrinfo if one of the defines don't exist
 AC_CACHE_CHECK([whether defines needed by getaddrinfo exist],
                rsync_cv_HAVE_GETADDR_DEFINES,[
 			AC_EGREP_CPP(yes, [
 			#include <sys/types.h>
@@ -420,30 +454,28 @@
 			#include <netdb.h>
 			#ifdef AI_PASSIVE
 			yes
 			#endif],
 			rsync_cv_HAVE_GETADDR_DEFINES=yes,
 			rsync_cv_HAVE_GETADDR_DEFINES=no)])
-if test x"$rsync_cv_HAVE_GETADDR_DEFINES" = x"yes"; then
+if test x"$rsync_cv_HAVE_GETADDR_DEFINES" = x"yes" -a x"$ac_cv_type_struct_addrinfo" = x"yes"; then
 	# Tru64 UNIX has getaddrinfo() but has it renamed in libc as
 	# something else so we must include <netdb.h> to get the
 	# redefinition.
 	AC_CHECK_FUNCS(getaddrinfo, ,
 		[AC_MSG_CHECKING([for getaddrinfo by including <netdb.h>])
 		AC_TRY_LINK([#include <sys/types.h>
 		#include <sys/socket.h>
 		#include <netdb.h>],[getaddrinfo(NULL, NULL, NULL, NULL);],
 			[AC_MSG_RESULT([yes])
 			AC_DEFINE(HAVE_GETADDRINFO, 1,
-				[Define to 1 if you have the "getaddrinfo" function.])],
+				[Define to 1 if you have the "getaddrinfo" function and required types.])],
 			[AC_MSG_RESULT([no])
 			AC_LIBOBJ(lib/getaddrinfo)])])
-	AC_CHECK_FUNCS(getnameinfo, , [AC_LIBOBJ(lib/getnameinfo)])
 else
 	AC_LIBOBJ(lib/getaddrinfo)
-	AC_LIBOBJ(lib/getnameinfo)
 fi
 
 AC_CHECK_MEMBER([struct sockaddr.sa_len],
 		[ AC_DEFINE(HAVE_SOCKADDR_LEN, 1, [Do we have sockaddr.sa_len?]) ],
 		[],
 		[
@@ -466,32 +498,22 @@
 		[
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 ])
 
-AC_MSG_CHECKING(struct sockaddr_storage)
-AC_TRY_COMPILE([#include <sys/types.h>
-#include <sys/socket.h>],
-[struct sockaddr_storage x;],
-	AC_MSG_RESULT(yes)
-	AC_DEFINE(HAVE_SOCKADDR_STORAGE, 1,
-		[Define to 1 if you have struct sockaddr_storage.] ),
-	AC_MSG_RESULT(no))
-
 AC_CHECK_MEMBER([struct sockaddr_in6.sin6_scope_id],
 		[ AC_DEFINE(HAVE_SOCKADDR_IN6_SCOPE_ID, 1, [Do we have sockaddr_in6.sin6_scope_id?]) ],
 		[],
 		[
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 ])
 
-AC_MSG_CHECKING(struct stat64)
-AC_TRY_COMPILE([#include <stdio.h>
+AC_HAVE_TYPE([struct stat64], [#include <stdio.h>
 #if HAVE_SYS_TYPES_H
 # include <sys/types.h>
 #endif
 #if HAVE_SYS_STAT_H
 # include <sys/stat.h>
 #endif
@@ -500,44 +522,67 @@
 # include <stddef.h>
 #else
 # if HAVE_STDLIB_H
 #  include <stdlib.h>
 # endif
 #endif
-],[struct stat64 st;],
-    AC_MSG_RESULT(yes)
-	AC_DEFINE(HAVE_STRUCT_STAT64,1,[Define to 1 if you have struct stat64.]),
-    AC_MSG_RESULT(no))
+])
 
 # if we can't find strcasecmp, look in -lresolv (for Unixware at least)
 #
 AC_CHECK_FUNCS(strcasecmp)
 if test x"$ac_cv_func_strcasecmp" = x"no"; then
     AC_CHECK_LIB(resolv, strcasecmp)
 fi
 
+AC_CHECK_FUNCS(aclsort)
+if test x"$ac_cv_func_aclsort" = x"no"; then
+    AC_CHECK_LIB(sec, aclsort)
+fi
+
 dnl At the moment we don't test for a broken memcmp(), because all we
 dnl need to do is test for equality, not comparison, and it seems that
 dnl every platform has a memcmp that can do at least that.
 dnl AC_FUNC_MEMCMP
 
 AC_FUNC_UTIME_NULL
 AC_FUNC_ALLOCA
 AC_CHECK_FUNCS(waitpid wait4 getcwd strdup chown chmod lchmod mknod mkfifo \
     fchmod fstat ftruncate strchr readlink link utime utimes lutimes strftime \
     memmove lchown vsnprintf snprintf vasprintf asprintf setsid glob strpbrk \
     strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid \
     setlocale setmode open64 lseek64 mkstemp64 mtrace va_copy __va_copy \
-    strerror putenv iconv_open locale_charset nl_langinfo \
-    sigaction sigprocmask)
+    strerror putenv iconv_open locale_charset nl_langinfo getxattr \
+    extattr_get_link sigaction sigprocmask setattrlist)
+
+dnl cygwin iconv.h defines iconv_open as libiconv_open
+if test x"$ac_cv_func_iconv_open" != x"yes"; then
+    AC_CHECK_FUNC(libiconv_open, [ac_cv_func_iconv_open=yes; AC_DEFINE(HAVE_ICONV_OPEN, 1)])
+fi
 
 AC_CHECK_FUNCS(getpgrp tcgetpgrp)
 if test $ac_cv_func_getpgrp = yes; then
     AC_FUNC_GETPGRP
 fi
 
+AC_ARG_ENABLE(iconv,
+    AC_HELP_STRING([--disable-iconv],
+	    [disable rsync's --iconv option]),
+    [], [enable_iconv=$ac_cv_func_iconv_open])
+AH_TEMPLATE([ICONV_OPTION],
+[Define if you want the --iconv option.  Specifing a value will set the
+default iconv setting (a NULL means no --iconv processing by default).])
+if test x"$enable_iconv" != x"no"; then
+	if test x"$enable_iconv" = x"yes"; then
+		AC_DEFINE(ICONV_OPTION, NULL)
+	else
+		AC_DEFINE_UNQUOTED(ICONV_OPTION, "$enable_iconv")
+	fi
+	AC_DEFINE(UTF8_CHARSET, "UTF-8", [String to pass to iconv() for the UTF-8 charset.])
+fi
+
 AC_CACHE_CHECK([whether chown() modifies symlinks],rsync_cv_chown_modifies_symlink,[
   AC_TRY_RUN([
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 #include <stdlib.h>
@@ -640,19 +685,19 @@
 di->d_name[0] == 0) exit(0); exit(1);} ],
 rsync_cv_HAVE_BROKEN_READDIR=yes,rsync_cv_HAVE_BROKEN_READDIR=no,rsync_cv_HAVE_BROKEN_READDIR=cross)])
 if test x"$rsync_cv_HAVE_BROKEN_READDIR" = x"yes"; then
     AC_DEFINE(HAVE_BROKEN_READDIR, 1, [Define to 1 if readdir() is broken])
 fi
 
-AC_CACHE_CHECK([for utimbuf],rsync_cv_HAVE_UTIMBUF,[
+AC_CACHE_CHECK([for utimbuf],rsync_cv_HAVE_STRUCT_UTIMBUF,[
 AC_TRY_COMPILE([#include <sys/types.h>
 #include <utime.h>],
 [struct utimbuf tbuf;  tbuf.actime = 0; tbuf.modtime = 1; exit(utime("foo.c",&tbuf));],
-rsync_cv_HAVE_UTIMBUF=yes,rsync_cv_HAVE_UTIMBUF=no)])
-if test x"$rsync_cv_HAVE_UTIMBUF" = x"yes"; then
-    AC_DEFINE(HAVE_UTIMBUF, 1, [Define to 1 if you have the "struct utimbuf" type])
+rsync_cv_HAVE_STRUCT_UTIMBUF=yes,rsync_cv_HAVE_STRUCT_UTIMBUF=no)])
+if test x"$rsync_cv_HAVE_STRUCT_UTIMBUF" = x"yes"; then
+    AC_DEFINE(HAVE_STRUCT_UTIMBUF, 1, [Define to 1 if you have the "struct utimbuf" type])
 fi
 
 AC_CACHE_CHECK([if gettimeofday takes tz argument],rsync_cv_HAVE_GETTIMEOFDAY_TZ,[
 AC_TRY_COMPILE([#include <sys/time.h>
 #include <unistd.h>],
 [struct timeval tv; exit(gettimeofday(&tv, NULL));],
@@ -775,12 +820,140 @@
 fi
 
 AC_SUBST(OBJ_SAVE)
 AC_SUBST(OBJ_RESTORE)
 AC_SUBST(CC_SHOBJ_FLAG)
 AC_SUBST(BUILD_POPT)
+AC_SUBST(MAKE_MAN)
+
+AC_CHECK_HEADERS(sys/acl.h acl/libacl.h)
+AC_CHECK_FUNCS(_acl __acl _facl __facl)
+#################################################
+# check for ACL support
+
+AC_MSG_CHECKING([whether to support ACLs])
+AC_ARG_ENABLE(acl-support,
+	AC_HELP_STRING([--disable-acl-support],
+		       [disable ACL support]))
+
+if test x"$enable_acl_support" = x"no"; then
+    AC_MSG_RESULT(no)
+else
+    case "$host_os" in
+    *sysv5*)
+	AC_MSG_RESULT(Using UnixWare ACLs)
+	AC_DEFINE(HAVE_UNIXWARE_ACLS, 1, [true if you have UnixWare ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1, [Define to 1 to add support for ACLs])
+	;;
+    *solaris*|*cygwin*)
+	AC_MSG_RESULT(Using solaris ACLs)
+	AC_DEFINE(HAVE_SOLARIS_ACLS, 1, [true if you have solaris ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1)
+	;;
+    *hpux*)
+	AC_MSG_RESULT(Using HPUX ACLs)
+	AC_DEFINE(HAVE_HPUX_ACLS, 1, [true if you have HPUX ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1)
+	;;
+    *irix*)
+	AC_MSG_RESULT(Using IRIX ACLs)
+	AC_DEFINE(HAVE_IRIX_ACLS, 1, [true if you have IRIX ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1)
+	;;
+    *aix*)
+	AC_MSG_RESULT(Using AIX ACLs)
+	AC_DEFINE(HAVE_AIX_ACLS, 1, [true if you have AIX ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1)
+	;;
+    *osf*)
+	AC_MSG_RESULT(Using Tru64 ACLs)
+	AC_DEFINE(HAVE_TRU64_ACLS, 1, [true if you have Tru64 ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1)
+	LIBS="$LIBS -lpacl"
+	;;
+    darwin*)
+	AC_MSG_RESULT(Using OS X ACLs)
+	AC_DEFINE(HAVE_OSX_ACLS, 1, [true if you have Mac OS X ACLs])
+	AC_DEFINE(SUPPORT_ACLS, 1)
+	;;
+    *)
+	AC_MSG_RESULT(running tests:)
+	AC_CHECK_LIB(acl,acl_get_file)
+	    AC_CACHE_CHECK([for ACL support],samba_cv_HAVE_POSIX_ACLS,[
+	    AC_TRY_LINK([#include <sys/types.h>
+#include <sys/acl.h>],
+[ acl_t acl; int entry_id; acl_entry_t *entry_p; return acl_get_entry( acl, entry_id, entry_p);],
+samba_cv_HAVE_POSIX_ACLS=yes,samba_cv_HAVE_POSIX_ACLS=no)])
+	AC_MSG_CHECKING(ACL test results)
+	if test x"$samba_cv_HAVE_POSIX_ACLS" = x"yes"; then
+	    AC_MSG_RESULT(Using posix ACLs)
+	    AC_DEFINE(HAVE_POSIX_ACLS, 1, [true if you have posix ACLs])
+	    AC_DEFINE(SUPPORT_ACLS, 1)
+	    AC_CACHE_CHECK([for acl_get_perm_np],samba_cv_HAVE_ACL_GET_PERM_NP,[
+		AC_TRY_LINK([#include <sys/types.h>
+#include <sys/acl.h>],
+[ acl_permset_t permset_d; acl_perm_t perm; return acl_get_perm_np( permset_d, perm);],
+samba_cv_HAVE_ACL_GET_PERM_NP=yes,samba_cv_HAVE_ACL_GET_PERM_NP=no)])
+	    if test x"$samba_cv_HAVE_ACL_GET_PERM_NP" = x"yes"; then
+		AC_DEFINE(HAVE_ACL_GET_PERM_NP, 1, [true if you have acl_get_perm_np])
+	    fi
+	else
+	    if test x"$enable_acl_support" = x"yes"; then
+		AC_MSG_ERROR(Failed to find ACL support)
+	    else
+		AC_MSG_RESULT(No ACL support found)
+	    fi
+	fi
+	;;
+    esac
+fi
+
+AC_CHECK_HEADERS(attr/xattr.h)
+AC_CHECK_HEADERS(sys/xattr.h)
+AC_CHECK_HEADERS(sys/extattr.h)
+
+#################################################
+# check for extended attribute support
+AC_MSG_CHECKING(whether to support extended attributes)
+AC_ARG_ENABLE(xattr-support,
+    AC_HELP_STRING([--disable-xattr-support],
+	    [disable extended attributes]),
+    [], [case "$ac_cv_func_getxattr$ac_cv_func_extattr_get_link" in
+	*yes*) enable_xattr_support=maybe ;;
+	*) enable_xattr_support=no ;;
+	esac])
+AH_TEMPLATE([SUPPORT_XATTRS],
+[Define to 1 to add support for extended attributes])
+if test x"$enable_xattr_support" = x"no"; then
+    AC_MSG_RESULT(no)
+else
+    case "$host_os" in
+    *linux*)
+	AC_MSG_RESULT(Using Linux xattrs)
+	AC_DEFINE(HAVE_LINUX_XATTRS, 1, [True if you have Linux xattrs])
+	AC_DEFINE(SUPPORT_XATTRS, 1)
+	;;
+    darwin*)
+	AC_MSG_RESULT(Using OS X xattrs)
+	AC_DEFINE(HAVE_OSX_XATTRS, 1, [True if you have Mac OS X xattrs])
+	AC_DEFINE(SUPPORT_XATTRS, 1)
+	;;
+    freebsd*)
+	AC_MSG_RESULT(Using FreeBSD extattrs)
+	AC_DEFINE(HAVE_FREEBSD_XATTRS, 1, [True if you have FreeBSD xattrs])
+	AC_DEFINE(SUPPORT_XATTRS, 1)
+	;;
+    *)
+	if test x"$enable_xattr_support" = x"yes"; then
+	    AC_MSG_ERROR(Failed to find extended attribute support)
+	else
+	    AC_MSG_RESULT(No extended attribute support found)
+	fi
+	;;
+    esac
+fi
 
 AC_CONFIG_FILES([Makefile lib/dummy zlib/dummy popt/dummy shconfig])
 AC_OUTPUT
 
 AC_MSG_RESULT()
 AC_MSG_RESULT([    rsync ${RSYNC_VERSION} configuration successful])
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: configure.sh
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/connection.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/connection.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/connection.c	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/connection.c	2007-09-18 22:14:22.000000000 +0800
@@ -2,48 +2,45 @@
  * Support the max connections option.
  *
  * Copyright (C) 1998 Andrew Tridgell
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
-/****************************************************************************
-simple routine to do connection counting
-****************************************************************************/
-int claim_connection(char *fname,int max_connections)
+/* A simple routine to do connection counting.  This returns 1 on success
+ * and 0 on failure, with errno also being set if the open() failed (errno
+ * will be 0 if the lock request failed). */
+int claim_connection(char *fname, int max_connections)
 {
 	int fd, i;
 
-	if (max_connections <= 0)
+	if (max_connections == 0)
 		return 1;
 
-	fd = open(fname,O_RDWR|O_CREAT, 0600);
-
-	if (fd == -1) {
+	if ((fd = open(fname, O_RDWR|O_CREAT, 0600)) < 0)
 		return 0;
-	}
 
-	/* find a free spot */
-	for (i=0;i<max_connections;i++) {
-		if (lock_range(fd, i*4, 4)) return 1;
+	/* Find a free spot. */
+	for (i = 0; i < max_connections; i++) {
+		if (lock_range(fd, i*4, 4))
+			return 1;
 	}
 
-	/* only interested in open failures */
-	errno = 0;
-
 	close(fd);
+
+	/* A lock failure needs to return an errno of 0. */
+	errno = 0;
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/COPYING /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/COPYING
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/COPYING	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/COPYING	2007-07-07 13:33:14.000000000 +0800
@@ -1,340 +1,674 @@
 		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
+                       Version 3, 29 June 2007
 
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-     51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  Everyone is permitted to copy and distribute verbatim copies
  of this license document, but changing it is not allowed.
 
 			    Preamble
 
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
 your programs, too.
 
   When we speak of free software, we are referring to freedom, not
 price.  Our General Public Licenses are designed to make sure that you
 have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
 
   For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
 
   The precise terms and conditions for copying, distribution and
 modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
 
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The "Program", below,
-refers to any such program or work, and a "work based on the Program"
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term "modification".)  Each licensee is addressed as "you".
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
 this License.
 
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
 otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
 
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
 be similar in spirit to the present version, but may differ in detail to
 address new problems or concerns.
 
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and "any
-later version", you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
 
 		     END OF TERMS AND CONDITIONS
-
+
 	    How to Apply These Terms to Your New Programs
 
   If you develop a new program, and you want it to be of the greatest
 possible use to the public, the best way to achieve this is to make it
 free software which everyone can redistribute and change under these terms.
 
   To do so, attach the following notices to the program.  It is safest
 to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
+state the exclusion of warranty; and each file should have at least
 the "copyright" line and a pointer to where the full notice is found.
 
     <one line to give the program's name and a brief idea of what it does.>
     Copyright (C) <year>  <name of author>
 
-    This program is free software; you can redistribute it and/or modify
+    This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
+    the Free Software Foundation, either version 3 of the License, or
     (at your option) any later version.
 
     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.
 
     You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 
 Also add information on how to contact you by electronic and paper mail.
 
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
 
-    Gnomovision version 69, Copyright (C) year  name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type `show c' for details.
 
 The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  <signature of Ty Coon>, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/csprotocol.txt /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/csprotocol.txt
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/csprotocol.txt	2001-08-23 14:14:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/csprotocol.txt	2007-11-12 23:12:48.000000000 +0800
@@ -1,26 +1,27 @@
 This is kind of informal and may be wrong, but it helped me.  It's
 basically a summary of clientserver.c and authenticate.c.
 
  -- Martin Pool <mbp@samba.org>
 
-$Id: csprotocol.txt,v 1.4 2001/08/23 06:14:54 mbp Exp $
-
-
-
 
 This is the protocol used for rsync --daemon; i.e. connections to port
 873 rather than invocations over a remote shell.
 
 When the server accepts a connection, it prints a greeting
 
-  @RSYNCD: <version>
+  @RSYNCD: <version>.<subprotocol>
 
-where <version> is the numeric version; currently 24.  It follows this
-with a free text message-of-the-day.  It expects to see a similar
-greeting back from the client.
+where <version> is the numeric version (see PROTOCOL_VERSION in rsync.h)
+'.' is a literal period, and <subprotocol> is the numeric subprotocol
+version (see SUBPROTOCOL_VERSION -- it will be 0 for final releases).
+Protocols prior to 30 only output <version> alone.  The daemon expects
+to see a similar greeting back from the client.  For protocols prior to
+30, an absent ".<subprotocol>" value is assumed to be 0.  For protocol
+30, an absent value is a fatal error.  The daemon then follows this line
+with a free-format text message-of-the-day (if any is defined).
 
 The server is now in the connected state.  The client can either send
 the command
 
   #list
 
@@ -72,11 +73,16 @@
 
 
 
 ------------
 Protocol version changes
 
-25	 (2001-08-20, 2.4.7pre2) 
+30	(2007-10-04, 3.0.0pre1)
+
+	The use of a ".<subprotocol>" number was added to
+	@RSYNCD: <version>.<subprotocol>
+
+25	(2001-08-20, 2.4.7pre2) 
 
-	 Send an explicit "@RSYNC EXIT" command at the end of the
-	 module listing.  We never intentionally end the transmission
-	 by just closing the socket anymore.
+	Send an explicit "@RSYNC EXIT" command at the end of the
+	module listing.  We never intentionally end the transmission
+	by just closing the socket anymore.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/errcode.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/errcode.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/errcode.h	2006-04-26 07:51:12.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/errcode.h	2008-03-02 04:01:41.000000000 +0800
@@ -1,25 +1,24 @@
 /*
  * Error codes returned by rsync.
  *
  * Copyright (C) 1998-2000 Andrew Tridgell
- * Copyright (C) 2003, 2005 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* If you change these, please also update the string mappings in log.c and
  * the EXIT VALUES in rsync.yo. */
 
 #define RERR_OK         0
@@ -43,12 +42,13 @@
 #define RERR_MALLOC     22      /* error allocating core memory buffers */
 #define RERR_PARTIAL    23      /* partial transfer */
 #define RERR_VANISHED   24      /* file(s) vanished on sender side */
 #define RERR_DEL_LIMIT  25      /* skipped some deletes due to --max-delete */
 
 #define RERR_TIMEOUT    30      /* timeout in data send/receive */
+#define RERR_CONTIMEOUT 35      /* timeout waiting for daemon connection */
 
 /* Although it doesn't seem to be specified anywhere,
  * ssh and the shell seem to return these values:
  *
  * 124 if the command exited with status 255
  * 125 if the command is killed by a signal
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/exclude.c	2006-10-13 14:24:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/exclude.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,40 +1,38 @@
 /*
  * The filter include/exclude routines.
  *
  * Copyright (C) 1996-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int am_server;
 extern int am_sender;
 extern int eol_nulls;
-extern int list_only;
-extern int recurse;
 extern int io_error;
 extern int local_server;
 extern int prune_empty_dirs;
+extern int ignore_perishable;
 extern int delete_mode;
 extern int delete_excluded;
 extern int cvs_exclude;
 extern int sanitize_paths;
 extern int protocol_version;
 extern int module_id;
@@ -48,14 +46,14 @@
 struct filter_list_struct server_filter_list = { 0, 0, " [daemon]" };
 
 /* Need room enough for ":MODS " prefix plus some room to grow. */
 #define MAX_RULE_PREFIX (16)
 
 #define MODIFIERS_MERGE_FILE "-+Cenw"
-#define MODIFIERS_INCL_EXCL "/!Crs"
-#define MODIFIERS_HIDE_PROTECT "/!"
+#define MODIFIERS_INCL_EXCL "/!Crsp"
+#define MODIFIERS_HIDE_PROTECT "/!p"
 
 /* The dirbuf is set by push_local_filters() to the current subdirectory
  * relative to curr_dir that is being processed.  The path always has a
  * trailing slash appended, and the variable dirbuf_len contains the length
  * of this path prefix.  The path is always absolute. */
 static char dirbuf[MAXPATHLEN+1];
@@ -141,15 +139,14 @@
 		} else {
 			if (mf == MATCHFLG_SENDER_SIDE)
 				return;
 		}
 	}
 
-	if (!(ret = new(struct filter_struct)))
+	if (!(ret = new0(struct filter_struct)))
 		out_of_memory("add_rule");
-	memset(ret, 0, sizeof ret[0]);
 
 	if (!(mflags & (MATCHFLG_ABS_PATH | MATCHFLG_MERGE_FILE))
 	 && ((xflags & (XFLG_ANCHORED2ABS|XFLG_ABS_IF_SLASH) && *pat == '/')
 	  || (xflags & XFLG_ABS_IF_SLASH && strchr(pat, '/') != NULL))) {
 		mflags |= MATCHFLG_ABS_PATH;
 		if (*pat == '/')
@@ -295,32 +292,32 @@
 		/* null-terminate the name if it isn't already */
 		if (len_ptr && merge_file[*len_ptr]) {
 			char *to = fn == buf ? tmpbuf : buf;
 			strlcpy(to, merge_file, *len_ptr + 1);
 			merge_file = to;
 		}
-		if (!sanitize_path(fn, merge_file, r, dirbuf_depth, NULL)) {
+		if (!sanitize_path(fn, merge_file, r, dirbuf_depth)) {
 			rprintf(FERROR, "merge-file name overflows: %s\n",
 				merge_file);
 			return NULL;
 		}
 		fn_len = strlen(fn);
 	} else {
 		strlcpy(fn, merge_file, len_ptr ? *len_ptr + 1 : MAXPATHLEN);
-		fn_len = clean_fname(fn, 1);
+		fn_len = clean_fname(fn, CFN_COLLAPSE_DOT_DOT_DIRS);
 	}
 
 	/* If the name isn't in buf yet, it's wasn't absolute. */
 	if (fn != buf) {
 		if (dirbuf_len + fn_len >= MAXPATHLEN) {
 			rprintf(FERROR, "merge-file name overflows: %s\n", fn);
 			return NULL;
 		}
 		memcpy(buf, dirbuf + prefix_skip, dirbuf_len - prefix_skip);
 		memcpy(buf + dirbuf_len - prefix_skip, fn, fn_len + 1);
-		fn_len = clean_fname(buf, 1);
+		fn_len = clean_fname(buf, CFN_COLLAPSE_DOT_DOT_DIRS);
 	}
 
 	if (len_ptr)
 		*len_ptr = fn_len;
 	return buf;
 }
@@ -336,13 +333,13 @@
 		if (len + dirlen >= MAXPATHLEN)
 			dirlen = 0;
 	} else
 		len = 0;
 	memcpy(dirbuf + len, dir, dirlen);
 	dirbuf[dirlen + len] = '\0';
-	dirbuf_len = clean_fname(dirbuf, 1);
+	dirbuf_len = clean_fname(dirbuf, CFN_COLLAPSE_DOT_DOT_DIRS);
 	if (dirbuf_len > 1 && dirbuf[dirbuf_len-1] == '.'
 	    && dirbuf[dirbuf_len-2] == '/')
 		dirbuf_len -= 2;
 	if (dirbuf_len != 1)
 		dirbuf[dirbuf_len++] = '/';
 	dirbuf[dirbuf_len] = '\0';
@@ -372,13 +369,13 @@
 		x = "/";
 	if (*x == '/')
 		strlcpy(buf, x, MAXPATHLEN);
 	else
 		pathjoin(buf, MAXPATHLEN, dirbuf, x);
 
-	len = clean_fname(buf, 1);
+	len = clean_fname(buf, CFN_COLLAPSE_DOT_DOT_DIRS);
 	if (len != 1 && len < MAXPATHLEN-1) {
 		buf[len++] = '/';
 		buf[len] = '\0';
 	}
 	/* This ensures that the specified dir is a parent of the transfer. */
 	for (x = buf, y = dirbuf; *x && *x == *y; x++, y++) {}
@@ -489,37 +486,64 @@
 		       sizeof (struct filter_list_struct));
 	}
 
 	free(pop);
 }
 
-static int rule_matches(char *name, struct filter_struct *ex, int name_is_dir)
+void change_local_filter_dir(const char *dname, int dlen, int dir_depth)
+{
+	static int cur_depth = -1;
+	static void *filt_array[MAXPATHLEN/2+1];
+
+	if (!dname) {
+		for ( ; cur_depth >= 0; cur_depth--) {
+			if (filt_array[cur_depth]) {
+				pop_local_filters(filt_array[cur_depth]);
+				filt_array[cur_depth] = NULL;
+			}
+		}
+		return;
+	}
+
+	assert(dir_depth < MAXPATHLEN/2+1);
+
+	for ( ; cur_depth >= dir_depth; cur_depth--) {
+		if (filt_array[cur_depth]) {
+			pop_local_filters(filt_array[cur_depth]);
+			filt_array[cur_depth] = NULL;
+		}
+	}
+
+	cur_depth = dir_depth;
+	filt_array[cur_depth] = push_local_filters(dname, dlen);
+}
+
+static int rule_matches(char *fname, struct filter_struct *ex, int name_is_dir)
 {
 	int slash_handling, str_cnt = 0, anchored_match = 0;
 	int ret_match = ex->match_flags & MATCHFLG_NEGATE ? 0 : 1;
 	char *p, *pattern = ex->pattern;
 	const char *strings[16]; /* more than enough */
+	char *name = fname + (*fname == '/');
 
-	if (*name == '/')
-		name++;
 	if (!*name)
 		return 0;
 
 	if (!ex->u.slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
 		/* If the pattern does not have any slashes AND it does
 		 * not have a "**" (which could match a slash), then we
 		 * just match the name portion of the path. */
 		if ((p = strrchr(name,'/')) != NULL)
 			name = p+1;
-	} else if (ex->match_flags & MATCHFLG_ABS_PATH && *name != '/'
+	} else if (ex->match_flags & MATCHFLG_ABS_PATH && *fname != '/'
 	    && curr_dir_len > module_dirlen + 1) {
 		/* If we're matching against an absolute-path pattern,
 		 * we need to prepend our full path info. */
 		strings[str_cnt++] = curr_dir + module_dirlen + 1;
 		strings[str_cnt++] = "/";
-	} else if (ex->match_flags & MATCHFLG_WILD2_PREFIX && *name != '/') {
+	} else if (ex->match_flags & MATCHFLG_WILD2_PREFIX && *fname != '/') {
 		/* Allow "**"+"/" to match at the start of the string. */
 		strings[str_cnt++] = "/";
 	}
 	strings[str_cnt++] = name;
 	if (name_is_dir) {
 		/* Allow a trailing "/"+"***" to match the directory. */
@@ -598,12 +622,14 @@
  */
 int check_filter(struct filter_list_struct *listp, char *name, int name_is_dir)
 {
 	struct filter_struct *ent;
 
 	for (ent = listp->head; ent; ent = ent->next) {
+		if (ignore_perishable && ent->match_flags & MATCHFLG_PERISHABLE)
+			continue;
 		if (ent->match_flags & MATCHFLG_PERDIR_MERGE) {
 			int rc = check_filter(ent->u.mergelist, name,
 					      name_is_dir);
 			if (rc)
 				return rc;
 			continue;
@@ -805,12 +831,15 @@
 			case 'e':
 				new_mflags |= MATCHFLG_EXCLUDE_SELF;
 				break;
 			case 'n':
 				new_mflags |= MATCHFLG_NO_INHERIT;
 				break;
+			case 'p':
+				new_mflags |= MATCHFLG_PERISHABLE;
+				break;
 			case 'r':
 				new_mflags |= MATCHFLG_RECEIVER_SIDE;
 				break;
 			case 's':
 				new_mflags |= MATCHFLG_SENDER_SIDE;
 				break;
@@ -866,24 +895,26 @@
 	"RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS"
 	" .make.state .nse_depinfo *~ #* .#* ,* _$* *$"
 	" *.old *.bak *.BAK *.orig *.rej .del-*"
 	" *.a *.olb *.o *.obj *.so *.exe"
 	" *.Z *.elc *.ln core"
 	/* The rest we added to suit ourself. */
-	" .svn/ .bzr/";
+	" .svn/ .git/ .bzr/";
 
 static void get_cvs_excludes(uint32 mflags)
 {
-	char *p, fname[MAXPATHLEN];
 	static int initialized = 0;
+	char *p, fname[MAXPATHLEN];
 
 	if (initialized)
 		return;
 	initialized = 1;
 
-	parse_rule(&cvs_filter_list, default_cvsignore, mflags, 0);
+	parse_rule(&cvs_filter_list, default_cvsignore,
+		   mflags | (protocol_version >= 30 ? MATCHFLG_PERISHABLE : 0),
+		   0);
 
 	p = module_id >= 0 && lp_use_chroot(module_id) ? "/" : getenv("HOME");
 	if (p && pathjoin(fname, MAXPATHLEN, p, ".cvsignore") < MAXPATHLEN)
 		parse_filter_file(&cvs_filter_list, fname, mflags, 0);
 
 	parse_rule(&cvs_filter_list, getenv("CVSIGNORE"), mflags, 0);
@@ -977,13 +1008,13 @@
 	if (!fname || !*fname)
 		return;
 
 	if (*fname != '-' || fname[1] || am_server) {
 		if (server_filter_list.head) {
 			strlcpy(line, fname, sizeof line);
-			clean_fname(line, 1);
+			clean_fname(line, CFN_COLLAPSE_DOT_DOT_DIRS);
 			if (check_filter(&server_filter_list, line, 0) < 0)
 				fp = NULL;
 			else
 				fp = fopen(line, "rb");
 		} else
 			fp = fopen(fname, "rb");
@@ -1061,12 +1092,14 @@
 	else if (legal_len != 1
 	    || ((*pat == '-' || *pat == '+') && pat[1] == ' '))
 		*op++ = '-';
 	else
 		legal_len = 0;
 
+	if (match_flags & MATCHFLG_NEGATE)
+		*op++ = '!';
 	if (match_flags & MATCHFLG_CVS_IGNORE)
 		*op++ = 'C';
 	else {
 		if (match_flags & MATCHFLG_NO_INHERIT)
 			*op++ = 'n';
 		if (match_flags & MATCHFLG_WORD_SPLIT)
@@ -1084,12 +1117,18 @@
 	    && (!for_xfer || protocol_version >= 29))
 		*op++ = 's';
 	if (match_flags & MATCHFLG_RECEIVER_SIDE
 	    && (!for_xfer || protocol_version >= 29
 	     || (delete_excluded && am_sender)))
 		*op++ = 'r';
+	if (match_flags & MATCHFLG_PERISHABLE) {
+		if (!for_xfer || protocol_version >= 30)
+			*op++ = 'p';
+		else if (am_sender)
+			return NULL;
+	}
 	if (op - buf > legal_len)
 		return NULL;
 	if (legal_len)
 		*op++ = ' ';
 	*op = '\0';
 	if (plen_ptr)
@@ -1138,13 +1177,13 @@
 				continue;
 		}
 		p = get_rule_prefix(ent->match_flags, ent->pattern, 1, &plen);
 		if (!p) {
 			rprintf(FERROR,
 				"filter rules are too modern for remote rsync.\n");
-			exit_cleanup(RERR_SYNTAX);
+			exit_cleanup(RERR_PROTOCOL);
 		}
 		if (f_out < 0)
 			continue;
 		len = strlen(ent->pattern);
 		dlen = ent->match_flags & MATCHFLG_DIRECTORY ? 1 : 0;
 		if (!(plen + len + dlen))
@@ -1170,17 +1209,12 @@
 	if (cvs_exclude && am_sender) {
 		if (protocol_version >= 29)
 			parse_rule(&filter_list, ":C", 0, 0);
 		parse_rule(&filter_list, "-C", 0, 0);
 	}
 
-	/* This is a complete hack - blame Rusty.  FIXME!
-	 * Remove this hack when older rsyncs (below 2.6.4) are gone. */
-	if (list_only == 1 && !recurse)
-		parse_rule(&filter_list, "/*/*", MATCHFLG_NO_PREFIXES, 0);
-
 	send_rules(f_out, &filter_list);
 
 	if (f_out >= 0)
 		write_int(f_out, 0);
 
 	if (cvs_exclude) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/fileio.c	2006-04-26 07:51:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/fileio.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,78 +1,85 @@
 /*
  * File IO utilities used in rsync.
  *
  * Copyright (C) 1998 Andrew Tridgell
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 #ifndef ENODATA
 #define ENODATA EAGAIN
 #endif
 
 extern int sparse_files;
 
 static char last_byte;
-static int last_sparse;
+static size_t sparse_seek = 0;
 
 int sparse_end(int f)
 {
-	if (last_sparse) {
-		do_lseek(f,-1,SEEK_CUR);
-		return (write(f,&last_byte,1) == 1 ? 0 : -1);
-	}
-	last_sparse = 0;
-	return 0;
+	int ret;
+
+	if (!sparse_seek)
+		return 0;
+
+	do_lseek(f, sparse_seek-1, SEEK_CUR);
+	sparse_seek = 0;
+
+	do {
+		ret = write(f, "", 1);
+	} while (ret < 0 && errno == EINTR);
+
+	return ret <= 0 ? -1 : 0;
 }
 
 
-static int write_sparse(int f,char *buf,size_t len)
+static int write_sparse(int f, char *buf, size_t len)
 {
-	size_t l1=0, l2=0;
+	size_t l1 = 0, l2 = 0;
 	int ret;
 
 	for (l1 = 0; l1 < len && buf[l1] == 0; l1++) {}
 	for (l2 = 0; l2 < len-l1 && buf[len-(l2+1)] == 0; l2++) {}
 
+	/* XXX Riddle me this: why does this function SLOW DOWN when I
+	 * remove the following (unneeded) line?? Core Duo weirdness? */
 	last_byte = buf[len-1];
 
-	if (l1 == len || l2 > 0)
-		last_sparse=1;
-
-	if (l1 > 0) {
-		do_lseek(f,l1,SEEK_CUR);
-	}
+	sparse_seek += l1;
 
 	if (l1 == len)
 		return len;
 
-	ret = write(f, buf + l1, len - (l1+l2));
-	if (ret == -1 || ret == 0)
+	if (sparse_seek)
+		do_lseek(f, sparse_seek, SEEK_CUR);
+	sparse_seek = l2;
+
+	while ((ret = write(f, buf + l1, len - (l1+l2))) <= 0) {
+		if (ret < 0 && errno == EINTR)
+			continue;
 		return ret;
-	else if (ret != (int) (len - (l1+l2)))
-		return (l1+ret);
+	}
 
-	if (l2 > 0)
-		do_lseek(f,l2,SEEK_CUR);
+	if (ret != (int)(len - (l1+l2)))
+		return l1+ret;
 
 	return len;
 }
 
 
 static char *wf_writeBuf;
@@ -104,13 +111,13 @@
 int write_file(int f,char *buf,size_t len)
 {
 	int ret = 0;
 
 	while (len > 0) {
 		int r1;
-		if (sparse_files) {
+		if (sparse_files > 0) {
 			int len1 = MIN(len, SPARSE_WRITE_SIZE);
 			r1 = write_sparse(f, buf, len1);
 		} else {
 			if (!wf_writeBuf) {
 				wf_writeBufSize = WRITE_SIZE * 8;
 				wf_writeBufCnt  = 0;
@@ -149,19 +156,18 @@
  * file thus giving us a SIGBUS. */
 struct map_struct *map_file(int fd, OFF_T len, int32 read_size,
 			    int32 blk_size)
 {
 	struct map_struct *map;
 
-	if (!(map = new(struct map_struct)))
+	if (!(map = new0(struct map_struct)))
 		out_of_memory("map_file");
 
 	if (blk_size && (read_size % blk_size))
 		read_size += blk_size - (read_size % blk_size);
 
-	memset(map, 0, sizeof map[0]);
 	map->fd = fd;
 	map->file_size = len;
 	map->def_window_size = read_size;
 
 	return map;
 }
@@ -187,13 +193,13 @@
 		return map->p + (offset - map->p_offset);
 
 	/* nope, we are going to have to do a read. Work out our desired window */
 	window_start = offset;
 	window_size = map->def_window_size;
 	if (window_start + window_size > map->file_size)
-		window_size = map->file_size - window_start;
+		window_size = (int32)(map->file_size - window_start);
 	if (len > window_size)
 		window_size = len;
 
 	/* make sure we have allocated enough memory for the window */
 	if (window_size > map->p_size) {
 		map->p = realloc_array(map->p, char, window_size);
@@ -205,13 +211,13 @@
 	/* Now try to avoid re-reading any bytes by reusing any bytes
 	 * from the previous buffer. */
 	if (window_start >= map->p_offset &&
 	    window_start < map->p_offset + map->p_len &&
 	    window_start + window_size >= map->p_offset + map->p_len) {
 		read_start = map->p_offset + map->p_len;
-		read_offset = read_start - window_start;
+		read_offset = (int32)(read_start - window_start);
 		read_size = window_size - read_offset;
 		memmove(map->p, map->p + (map->p_len - read_offset), read_offset);
 	} else {
 		read_start = window_start;
 		read_size = window_size;
 		read_offset = 0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/flist.c	2006-10-14 09:17:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/flist.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,94 +1,149 @@
 /*
  * Generate and receive file lists.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002, 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2002-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
+#include "rounding.h"
+#include "io.h"
 
 extern int verbose;
-extern int list_only;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
+extern int am_generator;
+extern int inc_recurse;
 extern int do_progress;
 extern int always_checksum;
 extern int module_id;
 extern int ignore_errors;
 extern int numeric_ids;
 extern int recurse;
+extern int use_qsort;
 extern int xfer_dirs;
 extern int filesfrom_fd;
 extern int one_file_system;
 extern int copy_dirlinks;
 extern int keep_dirlinks;
+extern int preserve_uid;
+extern int preserve_gid;
+extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_devices;
 extern int preserve_specials;
-extern int preserve_uid;
-extern int preserve_gid;
+extern int uid_ndx;
+extern int gid_ndx;
+extern int eol_nulls;
 extern int relative_paths;
 extern int implied_dirs;
+extern int file_extra_cnt;
+extern int ignore_perishable;
+extern int non_perishable_cnt;
 extern int prune_empty_dirs;
 extern int copy_links;
 extern int copy_unsafe_links;
 extern int protocol_version;
 extern int sanitize_paths;
+extern int munge_symlinks;
+extern int need_unsorted_flist;
+extern int unsort_ndx;
 extern struct stats stats;
-extern struct file_list *the_file_list;
+extern char *filesfrom_host;
 
 extern char curr_dir[MAXPATHLEN];
 
 extern struct chmod_mode_struct *chmod_modes;
 
 extern struct filter_list_struct filter_list;
 extern struct filter_list_struct server_filter_list;
 
+#ifdef ICONV_OPTION
+extern int filesfrom_convert;
+extern iconv_t ic_send, ic_recv;
+#endif
+
+#define PTR_SIZE (sizeof (struct file_struct *))
+
 int io_error;
 int checksum_len;
 dev_t filesystem_dev; /* used to implement -x */
-unsigned int file_struct_len;
 
-static char empty_sum[MD4_SUM_LENGTH];
-static int flist_count_offset;
+struct file_list *cur_flist, *first_flist, *dir_flist;
+int send_dir_ndx = -1, send_dir_depth = -1;
+int flist_cnt = 0; /* how many (non-tmp) file list objects exist */
+int file_total = 0; /* total of all active items over all file-lists */
+int flist_eof = 0; /* all the file-lists are now known */
+
+#define NORMAL_NAME 0
+#define SLASH_ENDING_NAME 1
+#define DOT_NAME 2
+
+/* Starting from protocol version 26, we always use 64-bit ino_t and dev_t
+ * internally, even if this platform does not allow files to have 64-bit inums.
+ * The only exception is if we're on a platform with no 64-bit type at all.
+ *
+ * Because we use read_longint() to get these off the wire, if you transfer
+ * devices or (for protocols < 30) hardlinks with dev or inum > 2**32 to a
+ * machine with no 64-bit types then you will get an overflow error.
+ *
+ * Note that if you transfer devices from a 64-bit-devt machine (say, Solaris)
+ * to a 32-bit-devt machine (say, Linux-2.2/x86) then the device numbers will
+ * be truncated.  But it's a kind of silly thing to do anyhow. */
+
+/* The tmp_* vars are used as a cache area by make_file() to store data
+ * that the sender doesn't need to remember in its file list.  The data
+ * will survive just long enough to be used by send_file_entry(). */
+static dev_t tmp_rdev;
+#ifdef SUPPORT_HARD_LINKS
+static int64 tmp_dev, tmp_ino;
+#endif
+static char tmp_sum[MAX_DIGEST_LEN];
+
+static char empty_sum[MAX_DIGEST_LEN];
+static int flist_count_offset; /* for --delete --progress */
+static int dir_count = 0;
 
-static void clean_flist(struct file_list *flist, int strip_root, int no_dups);
+static void flist_sort_and_clean(struct file_list *flist, int strip_root);
 static void output_flist(struct file_list *flist);
 
 void init_flist(void)
 {
-	struct file_struct f;
-
-	/* Figure out how big the file_struct is without trailing padding */
-	file_struct_len = offsetof(struct file_struct, flags) + sizeof f.flags;
-	checksum_len = protocol_version < 21 ? 2 : MD4_SUM_LENGTH;
+	if (verbose > 4) {
+		rprintf(FINFO, "FILE_STRUCT_LEN=%d, EXTRA_LEN=%d\n",
+			(int)FILE_STRUCT_LEN, (int)EXTRA_LEN);
+	}
+	checksum_len = protocol_version < 21 ? 2
+		     : protocol_version < 30 ? MD4_DIGEST_LEN
+		     : MD5_DIGEST_LEN;
 }
 
 static int show_filelist_p(void)
 {
-	return verbose && xfer_dirs && !am_server;
+	return verbose && xfer_dirs && !am_server && !inc_recurse;
 }
 
 static void start_filelist_progress(char *kind)
 {
 	rprintf(FCLIENT, "%s ... ", kind);
 	if (verbose > 1 || do_progress)
@@ -109,49 +164,22 @@
 
 static void finish_filelist_progress(const struct file_list *flist)
 {
 	if (do_progress) {
 		/* This overwrites the progress line */
 		rprintf(FINFO, "%d file%sto consider\n",
-			flist->count, flist->count == 1 ? " " : "s ");
+			flist->used, flist->used == 1 ? " " : "s ");
 	} else
 		rprintf(FINFO, "done\n");
 }
 
 void show_flist_stats(void)
 {
 	/* Nothing yet */
 }
 
-static void list_file_entry(struct file_struct *f)
-{
-	char permbuf[PERMSTRING_SIZE];
-
-	if (!f->basename) {
-		/* this can happen if duplicate names were removed */
-		return;
-	}
-
-	permstring(permbuf, f->mode);
-
-#ifdef SUPPORT_LINKS
-	if (preserve_links && S_ISLNK(f->mode)) {
-		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
-			permbuf,
-			(double)f->length, timestring(f->modtime),
-			f_name(f, NULL), f->u.link);
-	} else
-#endif
-	{
-		rprintf(FINFO, "%s %11.0f %s %s\n",
-			permbuf,
-			(double)f->length, timestring(f->modtime),
-			f_name(f, NULL));
-	}
-}
-
 /* Stat either a symlink or its referent, depending on the settings of
  * copy_links, copy_unsafe_links, etc.  Returns -1 on error, 0 on success.
  *
  * If path is the name of a symlink, then the linkbuf buffer (which must hold
  * MAXPATHLEN chars) will be set to the symlink's target string.
  *
@@ -169,36 +197,41 @@
 		linkbuf[llen] = '\0';
 		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
 			if (verbose > 1) {
 				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n",
 					path, linkbuf);
 			}
-			return do_stat(path, stp);
+			return x_stat(path, stp, NULL);
+		}
+		if (munge_symlinks && am_sender && llen > SYMLINK_PREFIX_LEN
+		 && strncmp(linkbuf, SYMLINK_PREFIX, SYMLINK_PREFIX_LEN) == 0) {
+			memmove(linkbuf, linkbuf + SYMLINK_PREFIX_LEN,
+				llen - SYMLINK_PREFIX_LEN + 1);
 		}
 	}
 	return 0;
 #else
-	return do_stat(path, stp);
+	return x_stat(path, stp, NULL);
 #endif
 }
 
 int link_stat(const char *path, STRUCT_STAT *stp, int follow_dirlinks)
 {
 #ifdef SUPPORT_LINKS
 	if (copy_links)
-		return do_stat(path, stp);
-	if (do_lstat(path, stp) < 0)
+		return x_stat(path, stp, NULL);
+	if (x_lstat(path, stp, NULL) < 0)
 		return -1;
 	if (follow_dirlinks && S_ISLNK(stp->st_mode)) {
 		STRUCT_STAT st;
-		if (do_stat(path, &st) == 0 && S_ISDIR(st.st_mode))
+		if (x_stat(path, &st, NULL) == 0 && S_ISDIR(st.st_mode))
 			*stp = st;
 	}
 	return 0;
 #else
-	return do_stat(path, stp);
+	return x_stat(path, stp, NULL);
 #endif
 }
 
 /* This function is used to check if a file should be included/excluded
  * from the list of files based on its name and type etc.  The value of
  * filter_level is set to either SERVER_FILTERS or ALL_FILTERS. */
@@ -227,795 +260,1221 @@
 	if (filter_list.head
 	    && check_filter(&filter_list, fname, is_dir) < 0)
 		return 1;
 	return 0;
 }
 
-static int to_wire_mode(mode_t mode)
-{
-#ifdef SUPPORT_LINKS
-#if _S_IFLNK != 0120000
-	if (S_ISLNK(mode))
-		return (mode & ~(_S_IFMT)) | 0120000;
-#endif
-#endif
-	return mode;
-}
-
-static mode_t from_wire_mode(int mode)
-{
-#if _S_IFLNK != 0120000
-	if ((mode & (_S_IFMT)) == 0120000)
-		return (mode & ~(_S_IFMT)) | _S_IFLNK;
-#endif
-	return mode;
-}
-
 static void send_directory(int f, struct file_list *flist,
-			   char *fbuf, int len);
+			   char *fbuf, int len, int flags);
 
-static char *flist_dir;
-static int flist_dir_len;
+static const char *pathname, *orig_dir;
+static int pathname_len;
 
 
-/**
- * Make sure @p flist is big enough to hold at least @p flist->count
- * entries.
- **/
-void flist_expand(struct file_list *flist)
+/* Make sure flist can hold at least flist->used + extra entries. */
+static void flist_expand(struct file_list *flist, int extra)
 {
 	struct file_struct **new_ptr;
 
-	if (flist->count < flist->malloced)
+	if (flist->used + extra <= flist->malloced)
 		return;
 
 	if (flist->malloced < FLIST_START)
 		flist->malloced = FLIST_START;
 	else if (flist->malloced >= FLIST_LINEAR)
 		flist->malloced += FLIST_LINEAR;
 	else
 		flist->malloced *= 2;
 
-	/*
-	 * In case count jumped or we are starting the list
-	 * with a known size just set it.
-	 */
-	if (flist->malloced < flist->count)
-		flist->malloced = flist->count;
+	/* In case count jumped or we are starting the list
+	 * with a known size just set it. */
+	if (flist->malloced < flist->used + extra)
+		flist->malloced = flist->used + extra;
 
 	new_ptr = realloc_array(flist->files, struct file_struct *,
 				flist->malloced);
 
 	if (verbose >= 2 && flist->malloced != FLIST_START) {
-		rprintf(FCLIENT, "[%s] expand file_list to %.0f bytes, did%s move\n",
+		rprintf(FCLIENT, "[%s] expand file_list pointer array to %.0f bytes, did%s move\n",
 		    who_am_i(),
 		    (double)sizeof flist->files[0] * flist->malloced,
 		    (new_ptr == flist->files) ? " not" : "");
 	}
 
 	flist->files = new_ptr;
 
 	if (!flist->files)
 		out_of_memory("flist_expand");
 }
 
-static void send_file_entry(struct file_struct *file, int f)
+static void flist_done_allocating(struct file_list *flist)
+{
+	void *ptr = pool_boundary(flist->file_pool, 8*1024);
+	if (flist->pool_boundary == ptr)
+		flist->pool_boundary = NULL; /* list didn't use any pool memory */
+	else
+		flist->pool_boundary = ptr;
+}
+
+int push_pathname(const char *dir, int len)
+{
+	if (dir == pathname)
+		return 1;
+
+	if (!orig_dir)
+		orig_dir = strdup(curr_dir);
+
+	if (pathname && !pop_dir(orig_dir)) {
+		rsyserr(FERROR, errno, "pop_dir %s failed",
+			full_fname(orig_dir));
+		exit_cleanup(RERR_FILESELECT);
+	}
+
+	if (dir && !push_dir(dir, 0)) {
+		io_error |= IOERR_GENERAL;
+		rsyserr(FERROR, errno, "push_dir %s failed in %s",
+			full_fname(dir), curr_dir);
+		return 0;
+	}
+
+	pathname = dir;
+	pathname_len = len >= 0 ? len : dir ? (int)strlen(dir) : 0;
+
+	return 1;
+}
+
+static void send_file_entry(int f, struct file_struct *file, int ndx, int first_ndx)
 {
-	unsigned short flags;
 	static time_t modtime;
 	static mode_t mode;
+#ifdef SUPPORT_HARD_LINKS
 	static int64 dev;
+#endif
 	static dev_t rdev;
 	static uint32 rdev_major;
 	static uid_t uid;
 	static gid_t gid;
+	static const char *user_name, *group_name;
 	static char lastname[MAXPATHLEN];
 	char fname[MAXPATHLEN];
+	int first_hlink_ndx = -1;
 	int l1, l2;
+	int xflags;
 
-	if (f < 0)
-		return;
-
-	if (!file) {
-		write_byte(f, 0);
-		modtime = 0, mode = 0;
-		dev = 0, rdev = MAKEDEV(0, 0);
-		rdev_major = 0;
-		uid = 0, gid = 0;
-		*lastname = '\0';
-		return;
-	}
-
-	f_name(file, fname);
+#ifdef ICONV_OPTION
+	if (ic_send != (iconv_t)-1) {
+		xbuf outbuf, inbuf;
+
+		INIT_CONST_XBUF(outbuf, fname);
+
+		if (file->dirname) {
+			INIT_XBUF_STRLEN(inbuf, (char*)file->dirname);
+			outbuf.size -= 2; /* Reserve room for '/' & 1 more char. */
+			if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0)
+				goto convert_error;
+			outbuf.size += 2;
+			outbuf.buf[outbuf.len++] = '/';
+		}
+
+		INIT_XBUF_STRLEN(inbuf, (char*)file->basename);
+		if (iconvbufs(ic_send, &inbuf, &outbuf, 0) < 0) {
+		  convert_error:
+			io_error |= IOERR_GENERAL;
+			rprintf(FINFO,
+			    "[%s] cannot convert filename: %s (%s)\n",
+			    who_am_i(), f_name(file, fname), strerror(errno));
+			return;
+		}
+		outbuf.buf[outbuf.len] = '\0';
+	} else
+#endif
+		f_name(file, fname);
 
-	flags = file->flags & XMIT_TOP_DIR;
+	/* Initialize starting value of xflags. */
+	if (protocol_version >= 30 && S_ISDIR(file->mode)) {
+		dir_count++;
+		if (file->flags & FLAG_CONTENT_DIR)
+			xflags = file->flags & FLAG_TOP_DIR;
+		else if (file->flags & FLAG_IMPLIED_DIR)
+			xflags = XMIT_TOP_DIR | XMIT_NO_CONTENT_DIR;
+		else
+			xflags = XMIT_NO_CONTENT_DIR;
+	} else
+		xflags = file->flags & FLAG_TOP_DIR; /* FLAG_TOP_DIR == XMIT_TOP_DIR */
 
 	if (file->mode == mode)
-		flags |= XMIT_SAME_MODE;
+		xflags |= XMIT_SAME_MODE;
 	else
 		mode = file->mode;
+
 	if ((preserve_devices && IS_DEVICE(mode))
 	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
-			if (file->u.rdev == rdev)
-				flags |= XMIT_SAME_RDEV_pre28;
+			if (tmp_rdev == rdev)
+				xflags |= XMIT_SAME_RDEV_pre28;
 			else
-				rdev = file->u.rdev;
+				rdev = tmp_rdev;
 		} else {
-			rdev = file->u.rdev;
+			rdev = tmp_rdev;
 			if ((uint32)major(rdev) == rdev_major)
-				flags |= XMIT_SAME_RDEV_MAJOR;
+				xflags |= XMIT_SAME_RDEV_MAJOR;
 			else
 				rdev_major = major(rdev);
-			if ((uint32)minor(rdev) <= 0xFFu)
-				flags |= XMIT_RDEV_MINOR_IS_SMALL;
+			if (protocol_version < 30 && (uint32)minor(rdev) <= 0xFFu)
+				xflags |= XMIT_RDEV_MINOR_8_pre30;
 		}
 	} else if (protocol_version < 28)
 		rdev = MAKEDEV(0, 0);
-	if (file->uid == uid)
-		flags |= XMIT_SAME_UID;
-	else
-		uid = file->uid;
-	if (file->gid == gid)
-		flags |= XMIT_SAME_GID;
-	else
-		gid = file->gid;
+	if (preserve_uid) {
+		if ((uid_t)F_OWNER(file) == uid && *lastname)
+			xflags |= XMIT_SAME_UID;
+		else {
+			uid = F_OWNER(file);
+			if (!numeric_ids) {
+				user_name = add_uid(uid);
+				if (inc_recurse && user_name)
+					xflags |= XMIT_USER_NAME_FOLLOWS;
+			}
+		}
+	}
+	if (preserve_gid) {
+		if ((gid_t)F_GROUP(file) == gid && *lastname)
+			xflags |= XMIT_SAME_GID;
+		else {
+			gid = F_GROUP(file);
+			if (!numeric_ids) {
+				group_name = add_gid(gid);
+				if (inc_recurse && group_name)
+					xflags |= XMIT_GROUP_NAME_FOLLOWS;
+			}
+		}
+	}
 	if (file->modtime == modtime)
-		flags |= XMIT_SAME_TIME;
+		xflags |= XMIT_SAME_TIME;
 	else
 		modtime = file->modtime;
 
 #ifdef SUPPORT_HARD_LINKS
-	if (file->link_u.idev) {
-		if (file->F_DEV == dev) {
-			if (protocol_version >= 28)
-				flags |= XMIT_SAME_DEV;
-		} else
-			dev = file->F_DEV;
-		flags |= XMIT_HAS_IDEV_DATA;
+	if (tmp_dev != 0) {
+		if (protocol_version >= 30) {
+			struct ht_int64_node *np = idev_find(tmp_dev, tmp_ino);
+			first_hlink_ndx = (int32)(long)np->data - 1;
+			if (first_hlink_ndx < 0) {
+				np->data = (void*)(long)(first_ndx + ndx + 1);
+				xflags |= XMIT_HLINK_FIRST;
+			}
+			xflags |= XMIT_HLINKED;
+		} else {
+			if (tmp_dev == dev) {
+				if (protocol_version >= 28)
+					xflags |= XMIT_SAME_DEV_pre30;
+			} else
+				dev = tmp_dev;
+			xflags |= XMIT_HLINKED;
+		}
 	}
 #endif
 
 	for (l1 = 0;
 	    lastname[l1] && (fname[l1] == lastname[l1]) && (l1 < 255);
 	    l1++) {}
 	l2 = strlen(fname+l1);
 
 	if (l1 > 0)
-		flags |= XMIT_SAME_NAME;
+		xflags |= XMIT_SAME_NAME;
 	if (l2 > 255)
-		flags |= XMIT_LONG_NAME;
+		xflags |= XMIT_LONG_NAME;
 
 	/* We must make sure we don't send a zero flag byte or the
 	 * other end will terminate the flist transfer.  Note that
 	 * the use of XMIT_TOP_DIR on a non-dir has no meaning, so
 	 * it's harmless way to add a bit to the first flag byte. */
 	if (protocol_version >= 28) {
-		if (!flags && !S_ISDIR(mode))
-			flags |= XMIT_TOP_DIR;
-		if ((flags & 0xFF00) || !flags) {
-			flags |= XMIT_EXTENDED_FLAGS;
-			write_byte(f, flags);
-			write_byte(f, flags >> 8);
+		if (!xflags && !S_ISDIR(mode))
+			xflags |= XMIT_TOP_DIR;
+		if ((xflags & 0xFF00) || !xflags) {
+			xflags |= XMIT_EXTENDED_FLAGS;
+			write_shortint(f, xflags);
 		} else
-			write_byte(f, flags);
+			write_byte(f, xflags);
 	} else {
-		if (!(flags & 0xFF))
-			flags |= S_ISDIR(mode) ? XMIT_LONG_NAME : XMIT_TOP_DIR;
-		write_byte(f, flags);
+		if (!(xflags & 0xFF))
+			xflags |= S_ISDIR(mode) ? XMIT_LONG_NAME : XMIT_TOP_DIR;
+		write_byte(f, xflags);
 	}
-	if (flags & XMIT_SAME_NAME)
+	if (xflags & XMIT_SAME_NAME)
 		write_byte(f, l1);
-	if (flags & XMIT_LONG_NAME)
-		write_int(f, l2);
+	if (xflags & XMIT_LONG_NAME)
+		write_varint30(f, l2);
 	else
 		write_byte(f, l2);
 	write_buf(f, fname + l1, l2);
 
-	write_longint(f, file->length);
-	if (!(flags & XMIT_SAME_TIME))
-		write_int(f, modtime);
-	if (!(flags & XMIT_SAME_MODE))
+	if (first_hlink_ndx >= 0) {
+		write_varint(f, first_hlink_ndx);
+		if (first_hlink_ndx >= first_ndx)
+			goto the_end;
+	}
+
+	write_varlong30(f, F_LENGTH(file), 3);
+	if (!(xflags & XMIT_SAME_TIME)) {
+		if (protocol_version >= 30)
+			write_varlong(f, modtime, 4);
+		else
+			write_int(f, modtime);
+	}
+	if (!(xflags & XMIT_SAME_MODE))
 		write_int(f, to_wire_mode(mode));
-	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
-		if (!numeric_ids)
-			add_uid(uid);
-		write_int(f, uid);
-	}
-	if (preserve_gid && !(flags & XMIT_SAME_GID)) {
-		if (!numeric_ids)
-			add_gid(gid);
-		write_int(f, gid);
+	if (preserve_uid && !(xflags & XMIT_SAME_UID)) {
+		if (protocol_version < 30)
+			write_int(f, uid);
+		else {
+			write_varint(f, uid);
+			if (xflags & XMIT_USER_NAME_FOLLOWS) {
+				int len = strlen(user_name);
+				write_byte(f, len);
+				write_buf(f, user_name, len);
+			}
+		}
+	}
+	if (preserve_gid && !(xflags & XMIT_SAME_GID)) {
+		if (protocol_version < 30)
+			write_int(f, gid);
+		else {
+			write_varint(f, gid);
+			if (xflags & XMIT_GROUP_NAME_FOLLOWS) {
+				int len = strlen(group_name);
+				write_byte(f, len);
+				write_buf(f, group_name, len);
+			}
+		}
 	}
 	if ((preserve_devices && IS_DEVICE(mode))
 	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
-			if (!(flags & XMIT_SAME_RDEV_pre28))
+			if (!(xflags & XMIT_SAME_RDEV_pre28))
 				write_int(f, (int)rdev);
 		} else {
-			if (!(flags & XMIT_SAME_RDEV_MAJOR))
-				write_int(f, major(rdev));
-			if (flags & XMIT_RDEV_MINOR_IS_SMALL)
+			if (!(xflags & XMIT_SAME_RDEV_MAJOR))
+				write_varint30(f, major(rdev));
+			if (protocol_version >= 30)
+				write_varint(f, minor(rdev));
+			else if (xflags & XMIT_RDEV_MINOR_8_pre30)
 				write_byte(f, minor(rdev));
 			else
 				write_int(f, minor(rdev));
 		}
 	}
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(mode)) {
-		int len = strlen(file->u.link);
-		write_int(f, len);
-		write_buf(f, file->u.link, len);
+		const char *sl = F_SYMLINK(file);
+		int len = strlen(sl);
+		write_varint30(f, len);
+		write_buf(f, sl, len);
 	}
 #endif
 
 #ifdef SUPPORT_HARD_LINKS
-	if (file->link_u.idev) {
+	if (tmp_dev != 0 && protocol_version < 30) {
 		if (protocol_version < 26) {
 			/* 32-bit dev_t and ino_t */
-			write_int(f, dev);
-			write_int(f, file->F_INODE);
+			write_int(f, (int32)dev);
+			write_int(f, (int32)tmp_ino);
 		} else {
 			/* 64-bit dev_t and ino_t */
-			if (!(flags & XMIT_SAME_DEV))
+			if (!(xflags & XMIT_SAME_DEV_pre30))
 				write_longint(f, dev);
-			write_longint(f, file->F_INODE);
+			write_longint(f, tmp_ino);
 		}
 	}
 #endif
 
 	if (always_checksum && (S_ISREG(mode) || protocol_version < 28)) {
-		char *sum;
+		const char *sum;
 		if (S_ISREG(mode))
-			sum = file->u.sum;
+			sum = tmp_sum;
 		else {
 			/* Prior to 28, we sent a useless set of nulls. */
 			sum = empty_sum;
 		}
 		write_buf(f, sum, checksum_len);
 	}
 
+  the_end:
 	strlcpy(lastname, fname, MAXPATHLEN);
+
+	if (S_ISREG(mode) || S_ISLNK(mode))
+		stats.total_size += F_LENGTH(file);
 }
 
-static struct file_struct *receive_file_entry(struct file_list *flist,
-					      unsigned short flags, int f)
+static struct file_struct *recv_file_entry(struct file_list *flist,
+					   int xflags, int f)
 {
-	static time_t modtime;
+	static int64 modtime;
 	static mode_t mode;
+#ifdef SUPPORT_HARD_LINKS
 	static int64 dev;
+#endif
 	static dev_t rdev;
 	static uint32 rdev_major;
 	static uid_t uid;
 	static gid_t gid;
+	static uint16 gid_flags;
 	static char lastname[MAXPATHLEN], *lastdir;
 	static int lastdir_depth, lastdir_len = -1;
 	static unsigned int del_hier_name_len = 0;
 	static int in_del_hier = 0;
 	char thisname[MAXPATHLEN];
 	unsigned int l1 = 0, l2 = 0;
-	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
+	int alloc_len, basename_len, linkname_len;
+	int extra_len = file_extra_cnt * EXTRA_LEN;
+	int first_hlink_ndx = -1;
 	OFF_T file_length;
-	char *basename, *dirname, *bp;
+	const char *basename;
 	struct file_struct *file;
+	alloc_pool_t *pool;
+	char *bp;
 
-	if (!flist) {
-		modtime = 0, mode = 0;
-		dev = 0, rdev = MAKEDEV(0, 0);
-		rdev_major = 0;
-		uid = 0, gid = 0;
-		*lastname = '\0';
-		lastdir_len = -1;
-		in_del_hier = 0;
-		return NULL;
-	}
-
-	if (flags & XMIT_SAME_NAME)
+	if (xflags & XMIT_SAME_NAME)
 		l1 = read_byte(f);
 
-	if (flags & XMIT_LONG_NAME)
-		l2 = read_int(f);
+	if (xflags & XMIT_LONG_NAME)
+		l2 = read_varint30(f);
 	else
 		l2 = read_byte(f);
 
 	if (l2 >= MAXPATHLEN - l1) {
 		rprintf(FERROR,
-			"overflow: flags=0x%x l1=%d l2=%d lastname=%s\n",
-			flags, l1, l2, lastname);
-		overflow_exit("receive_file_entry");
+			"overflow: xflags=0x%x l1=%d l2=%d lastname=%s [%s]\n",
+			xflags, l1, l2, lastname, who_am_i());
+		overflow_exit("recv_file_entry");
 	}
 
 	strlcpy(thisname, lastname, l1 + 1);
 	read_sbuf(f, &thisname[l1], l2);
 	thisname[l1 + l2] = 0;
 
-	strlcpy(lastname, thisname, MAXPATHLEN);
+	/* Abuse basename_len for a moment... */
+	basename_len = strlcpy(lastname, thisname, MAXPATHLEN);
+
+#ifdef ICONV_OPTION
+	if (ic_recv != (iconv_t)-1) {
+		xbuf outbuf, inbuf;
+
+		INIT_CONST_XBUF(outbuf, thisname);
+		INIT_XBUF(inbuf, lastname, basename_len, -1);
+
+		if (iconvbufs(ic_recv, &inbuf, &outbuf, 0) < 0) {
+			io_error |= IOERR_GENERAL;
+			rprintf(FINFO,
+			    "[%s] cannot convert filename: %s (%s)\n",
+			    who_am_i(), lastname, strerror(errno));
+			outbuf.len = 0;
+		}
+		outbuf.buf[outbuf.len] = '\0';
+	}
+#endif
 
 	clean_fname(thisname, 0);
 
 	if (sanitize_paths)
-		sanitize_path(thisname, thisname, "", 0, NULL);
+		sanitize_path(thisname, thisname, "", 0);
 
 	if ((basename = strrchr(thisname, '/')) != NULL) {
-		dirname_len = ++basename - thisname; /* counts future '\0' */
-		if (lastdir_len == dirname_len - 1
-		    && strncmp(thisname, lastdir, lastdir_len) == 0) {
-			dirname = lastdir;
-			dirname_len = 0; /* indicates no copy is needed */
-		} else
-			dirname = thisname;
-	} else {
+		int len = basename++ - thisname;
+		if (len != lastdir_len || memcmp(thisname, lastdir, len) != 0) {
+			lastdir = new_array(char, len + 1);
+			memcpy(lastdir, thisname, len);
+			lastdir[len] = '\0';
+			lastdir_len = len;
+			lastdir_depth = count_dir_elements(lastdir);
+		}
+	} else
 		basename = thisname;
-		dirname = NULL;
-		dirname_len = 0;
-	}
 	basename_len = strlen(basename) + 1; /* count the '\0' */
 
-	file_length = read_longint(f);
-	if (!(flags & XMIT_SAME_TIME))
-		modtime = (time_t)read_int(f);
-	if (!(flags & XMIT_SAME_MODE))
+#ifdef SUPPORT_HARD_LINKS
+	if (protocol_version >= 30
+	 && BITS_SETnUNSET(xflags, XMIT_HLINKED, XMIT_HLINK_FIRST)) {
+		first_hlink_ndx = read_varint(f);
+		if (first_hlink_ndx < 0 || first_hlink_ndx >= flist->ndx_start + flist->used) {
+			rprintf(FERROR,
+				"hard-link reference out of range: %d (%d)\n",
+				first_hlink_ndx, flist->ndx_start + flist->used);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+		if (first_hlink_ndx >= flist->ndx_start) {
+			struct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];
+			file_length = F_LENGTH(first);
+			modtime = first->modtime;
+			mode = first->mode;
+			if (preserve_uid)
+				uid = F_OWNER(first);
+			if (preserve_gid)
+				gid = F_GROUP(first);
+			if ((preserve_devices && IS_DEVICE(mode))
+			 || (preserve_specials && IS_SPECIAL(mode))) {
+				uint32 *devp = F_RDEV_P(first);
+				rdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
+				extra_len += DEV_EXTRA_CNT * EXTRA_LEN;
+			}
+			if (preserve_links && S_ISLNK(mode))
+				linkname_len = strlen(F_SYMLINK(first)) + 1;
+			else
+				linkname_len = 0;
+			goto create_object;
+		}
+	}
+#endif
+
+	file_length = read_varlong30(f, 3);
+	if (!(xflags & XMIT_SAME_TIME)) {
+		if (protocol_version >= 30) {
+			modtime = read_varlong(f, 4);
+#if SIZEOF_TIME_T < SIZEOF_INT64
+			if (!am_generator && (int64)(time_t)modtime != modtime) {
+				rprintf(FERROR_XFER,
+				    "Time value of %s truncated on receiver.\n",
+				    lastname);
+			}
+#endif
+		} else
+			modtime = read_int(f);
+	}
+	if (!(xflags & XMIT_SAME_MODE))
 		mode = from_wire_mode(read_int(f));
 
 	if (chmod_modes && !S_ISLNK(mode))
 		mode = tweak_mode(mode, chmod_modes);
 
-	if (preserve_uid && !(flags & XMIT_SAME_UID))
-		uid = (uid_t)read_int(f);
-	if (preserve_gid && !(flags & XMIT_SAME_GID))
-		gid = (gid_t)read_int(f);
+	if (preserve_uid && !(xflags & XMIT_SAME_UID)) {
+		if (protocol_version < 30)
+			uid = (uid_t)read_int(f);
+		else {
+			uid = (uid_t)read_varint(f);
+			if (xflags & XMIT_USER_NAME_FOLLOWS)
+				uid = recv_user_name(f, uid);
+			else if (inc_recurse && am_root && !numeric_ids)
+				uid = match_uid(uid);
+		}
+	}
+	if (preserve_gid && !(xflags & XMIT_SAME_GID)) {
+		if (protocol_version < 30)
+			gid = (gid_t)read_int(f);
+		else {
+			gid = (gid_t)read_varint(f);
+			gid_flags = 0;
+			if (xflags & XMIT_GROUP_NAME_FOLLOWS)
+				gid = recv_group_name(f, gid, &gid_flags);
+			else if (inc_recurse && (!am_root || !numeric_ids))
+				gid = match_gid(gid, &gid_flags);
+		}
+	}
 
 	if ((preserve_devices && IS_DEVICE(mode))
 	 || (preserve_specials && IS_SPECIAL(mode))) {
 		if (protocol_version < 28) {
-			if (!(flags & XMIT_SAME_RDEV_pre28))
+			if (!(xflags & XMIT_SAME_RDEV_pre28))
 				rdev = (dev_t)read_int(f);
 		} else {
 			uint32 rdev_minor;
-			if (!(flags & XMIT_SAME_RDEV_MAJOR))
-				rdev_major = read_int(f);
-			if (flags & XMIT_RDEV_MINOR_IS_SMALL)
+			if (!(xflags & XMIT_SAME_RDEV_MAJOR))
+				rdev_major = read_varint30(f);
+			if (protocol_version >= 30)
+				rdev_minor = read_varint(f);
+			else if (xflags & XMIT_RDEV_MINOR_8_pre30)
 				rdev_minor = read_byte(f);
 			else
 				rdev_minor = read_int(f);
 			rdev = MAKEDEV(rdev_major, rdev_minor);
 		}
+		extra_len += DEV_EXTRA_CNT * EXTRA_LEN;
+		file_length = 0;
 	} else if (protocol_version < 28)
 		rdev = MAKEDEV(0, 0);
 
 #ifdef SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(mode)) {
-		linkname_len = read_int(f) + 1; /* count the '\0' */
+		linkname_len = read_varint30(f) + 1; /* count the '\0' */
 		if (linkname_len <= 0 || linkname_len > MAXPATHLEN) {
 			rprintf(FERROR, "overflow: linkname_len=%d\n",
 				linkname_len - 1);
-			overflow_exit("receive_file_entry");
+			overflow_exit("recv_file_entry");
 		}
+		if (munge_symlinks)
+			linkname_len += SYMLINK_PREFIX_LEN;
 	}
 	else
 #endif
 		linkname_len = 0;
 
-	sum_len = always_checksum && S_ISREG(mode) ? MD4_SUM_LENGTH : 0;
+#ifdef SUPPORT_HARD_LINKS
+  create_object:
+	if (preserve_hard_links) {
+		if (protocol_version < 28 && S_ISREG(mode))
+			xflags |= XMIT_HLINKED;
+		if (xflags & XMIT_HLINKED)
+			extra_len += (inc_recurse+1) * EXTRA_LEN;
+	}
+#endif
+
+#ifdef SUPPORT_ACLS
+	/* We need one or two index int32s when we're preserving ACLs. */
+	if (preserve_acls)
+		extra_len += (S_ISDIR(mode) ? 2 : 1) * EXTRA_LEN;
+#endif
+
+	if (always_checksum && S_ISREG(mode))
+		extra_len += SUM_EXTRA_CNT * EXTRA_LEN;
+
+	if (file_length > 0xFFFFFFFFu && S_ISREG(mode))
+		extra_len += EXTRA_LEN;
+
+	if (inc_recurse && S_ISDIR(mode)) {
+		if (one_file_system) {
+			/* Room to save the dir's device for -x */
+			extra_len += DEV_EXTRA_CNT * EXTRA_LEN;
+		}
+		pool = dir_flist->file_pool;
+	} else
+		pool = flist->file_pool;
+
+#if EXTRA_ROUNDING > 0
+	if (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))
+		extra_len = (extra_len | (EXTRA_ROUNDING * EXTRA_LEN)) + EXTRA_LEN;
+#endif
 
-	alloc_len = file_struct_len + dirname_len + basename_len
-		  + linkname_len + sum_len;
-	bp = pool_alloc(flist->file_pool, alloc_len, "receive_file_entry");
+	alloc_len = FILE_STRUCT_LEN + extra_len + basename_len
+		  + linkname_len;
+	bp = pool_alloc(pool, alloc_len, "recv_file_entry");
 
+	memset(bp, 0, extra_len + FILE_STRUCT_LEN);
+	bp += extra_len;
 	file = (struct file_struct *)bp;
-	memset(bp, 0, file_struct_len);
-	bp += file_struct_len;
+	bp += FILE_STRUCT_LEN;
 
-	file->modtime = modtime;
-	file->length = file_length;
-	file->mode = mode;
-	file->uid = uid;
-	file->gid = gid;
+	memcpy(bp, basename, basename_len);
+	bp += basename_len + linkname_len; /* skip space for symlink too */
 
-	if (dirname_len) {
-		file->dirname = lastdir = bp;
-		lastdir_len = dirname_len - 1;
-		memcpy(bp, dirname, dirname_len - 1);
-		bp += dirname_len;
-		bp[-1] = '\0';
-		lastdir_depth = count_dir_elements(lastdir);
-		file->dir.depth = lastdir_depth + 1;
-	} else if (dirname) {
-		file->dirname = dirname; /* we're reusing lastname */
-		file->dir.depth = lastdir_depth + 1;
+#ifdef SUPPORT_HARD_LINKS
+	if (xflags & XMIT_HLINKED)
+		file->flags |= FLAG_HLINKED;
+#endif
+	file->modtime = (time_t)modtime;
+	file->len32 = (uint32)file_length;
+	if (file_length > 0xFFFFFFFFu && S_ISREG(mode)) {
+		file->flags |= FLAG_LENGTH64;
+		OPT_EXTRA(file, 0)->unum = (uint32)(file_length >> 32);
+	}
+	file->mode = mode;
+	if (preserve_uid)
+		F_OWNER(file) = uid;
+	if (preserve_gid) {
+		F_GROUP(file) = gid;
+		file->flags |= gid_flags;
+	}
+	if (unsort_ndx)
+		F_NDX(file) = flist->used + flist->ndx_start;
+
+	if (basename != thisname) {
+		file->dirname = lastdir;
+		F_DEPTH(file) = lastdir_depth + 1;
 	} else
-		file->dir.depth = 1;
+		F_DEPTH(file) = 1;
 
 	if (S_ISDIR(mode)) {
 		if (basename_len == 1+1 && *basename == '.') /* +1 for '\0' */
-			file->dir.depth--;
-		if (flags & XMIT_TOP_DIR) {
+			F_DEPTH(file)--;
+		if (protocol_version >= 30) {
+			if (!(xflags & XMIT_NO_CONTENT_DIR)) {
+				if (xflags & XMIT_TOP_DIR)
+					file->flags |= FLAG_TOP_DIR;
+				file->flags |= FLAG_CONTENT_DIR;
+			} else if (xflags & XMIT_TOP_DIR)
+				file->flags |= FLAG_IMPLIED_DIR;
+		} else if (xflags & XMIT_TOP_DIR) {
 			in_del_hier = recurse;
-			del_hier_name_len = file->dir.depth == 0 ? 0 : l1 + l2;
+			del_hier_name_len = F_DEPTH(file) == 0 ? 0 : l1 + l2;
 			if (relative_paths && del_hier_name_len > 2
 			    && lastname[del_hier_name_len-1] == '.'
 			    && lastname[del_hier_name_len-2] == '/')
 				del_hier_name_len -= 2;
-			file->flags |= FLAG_TOP_DIR | FLAG_DEL_HERE;
+			file->flags |= FLAG_TOP_DIR | FLAG_CONTENT_DIR;
 		} else if (in_del_hier) {
 			if (!relative_paths || !del_hier_name_len
 			 || (l1 >= del_hier_name_len
 			  && lastname[del_hier_name_len] == '/'))
-				file->flags |= FLAG_DEL_HERE;
+				file->flags |= FLAG_CONTENT_DIR;
 			else
 				in_del_hier = 0;
 		}
 	}
 
-	file->basename = bp;
-	memcpy(bp, basename, basename_len);
-	bp += basename_len;
-
 	if ((preserve_devices && IS_DEVICE(mode))
-	 || (preserve_specials && IS_SPECIAL(mode)))
-		file->u.rdev = rdev;
+	 || (preserve_specials && IS_SPECIAL(mode))) {
+		uint32 *devp = F_RDEV_P(file);
+		DEV_MAJOR(devp) = major(rdev);
+		DEV_MINOR(devp) = minor(rdev);
+	}
 
 #ifdef SUPPORT_LINKS
 	if (linkname_len) {
-		file->u.link = bp;
-		read_sbuf(f, bp, linkname_len - 1);
-		if (sanitize_paths)
-			sanitize_path(bp, bp, "", lastdir_depth, NULL);
-		bp += linkname_len;
+		bp = (char*)file->basename + basename_len;
+		if (first_hlink_ndx >= flist->ndx_start) {
+			struct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];
+			memcpy(bp, F_SYMLINK(first), linkname_len);
+		} else if (munge_symlinks) {
+			strlcpy(bp, SYMLINK_PREFIX, linkname_len);
+			bp += SYMLINK_PREFIX_LEN;
+			linkname_len -= SYMLINK_PREFIX_LEN;
+			read_sbuf(f, bp, linkname_len - 1);
+		} else {
+			read_sbuf(f, bp, linkname_len - 1);
+			if (sanitize_paths)
+				sanitize_path(bp, bp, "", lastdir_depth);
+		}
 	}
 #endif
 
 #ifdef SUPPORT_HARD_LINKS
-	if (preserve_hard_links && protocol_version < 28 && S_ISREG(mode))
-		flags |= XMIT_HAS_IDEV_DATA;
-	if (flags & XMIT_HAS_IDEV_DATA) {
-		int64 inode;
-		if (protocol_version < 26) {
-			dev = read_int(f);
-			inode = read_int(f);
+	if (preserve_hard_links && xflags & XMIT_HLINKED) {
+		if (protocol_version >= 30) {
+			if (xflags & XMIT_HLINK_FIRST) {
+				F_HL_GNUM(file) = flist->ndx_start + flist->used;
+			} else
+				F_HL_GNUM(file) = first_hlink_ndx;
 		} else {
-			if (!(flags & XMIT_SAME_DEV))
-				dev = read_longint(f);
-			inode = read_longint(f);
-		}
-		if (flist->hlink_pool) {
-			file->link_u.idev = pool_talloc(flist->hlink_pool,
-			    struct idev, 1, "inode_table");
-			file->F_INODE = inode;
-			file->F_DEV = dev;
+			static int32 cnt = 0;
+			struct ht_int64_node *np;
+			int64 ino;
+			int32 ndx;
+			if (protocol_version < 26) {
+				dev = read_int(f);
+				ino = read_int(f);
+			} else {
+				if (!(xflags & XMIT_SAME_DEV_pre30))
+					dev = read_longint(f);
+				ino = read_longint(f);
+			}
+			np = idev_find(dev, ino);
+			ndx = (int32)(long)np->data - 1;
+			if (ndx < 0) {
+				ndx = cnt++;
+				np->data = (void*)(long)cnt;
+			}
+			F_HL_GNUM(file) = ndx;
 		}
 	}
 #endif
 
-	if (always_checksum && (sum_len || protocol_version < 28)) {
-		char *sum;
-		if (sum_len) {
-			file->u.sum = sum = bp;
-			/*bp += sum_len;*/
-		} else {
+	if (always_checksum && (S_ISREG(mode) || protocol_version < 28)) {
+		if (S_ISREG(mode))
+			bp = F_SUM(file);
+		else {
 			/* Prior to 28, we get a useless set of nulls. */
-			sum = empty_sum;
+			bp = tmp_sum;
 		}
-		read_buf(f, sum, checksum_len);
+		if (first_hlink_ndx >= flist->ndx_start) {
+			struct file_struct *first = flist->files[first_hlink_ndx - flist->ndx_start];
+			memcpy(bp, F_SUM(first), checksum_len);
+		} else
+			read_buf(f, bp, checksum_len);
 	}
 
+#ifdef SUPPORT_ACLS
+	if (preserve_acls && !S_ISLNK(mode))
+		receive_acl(file, f);
+#endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs)
+		receive_xattr(file, f );
+#endif
+
+	if (S_ISREG(mode) || S_ISLNK(mode))
+		stats.total_size += file_length;
+
 	return file;
 }
 
-/**
- * Create a file_struct for a named file by reading its stat()
- * information and performing extensive checks against global
- * options.
+/* Create a file_struct for a named file by reading its stat() information
+ * and performing extensive checks against global options.
  *
- * @return the new file, or NULL if there was an error or this file
- * should be excluded.
- *
- * @todo There is a small optimization opportunity here to avoid
- * stat()ing the file in some circumstances, which has a certain cost.
- * We are called immediately after doing readdir(), and so we may
- * already know the d_type of the file.  We could for example avoid
- * statting directories if we're not recursing, but this is not a very
- * important case.  Some systems may not have d_type.
- **/
-struct file_struct *make_file(char *fname, struct file_list *flist,
-			      STRUCT_STAT *stp, unsigned short flags,
-			      int filter_level)
+ * Returns a pointer to the new file struct, or NULL if there was an error
+ * or this file should be excluded. */
+struct file_struct *make_file(const char *fname, struct file_list *flist,
+			      STRUCT_STAT *stp, int flags, int filter_level)
 {
 	static char *lastdir;
 	static int lastdir_len = -1;
 	struct file_struct *file;
-	STRUCT_STAT st;
-	char sum[SUM_LENGTH];
 	char thisname[MAXPATHLEN];
 	char linkname[MAXPATHLEN];
-	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
-	char *basename, *dirname, *bp;
-
-	if (!flist || !flist->count)	/* Ignore lastdir when invalid. */
-		lastdir_len = -1;
+	int alloc_len, basename_len, linkname_len;
+	int extra_len = file_extra_cnt * EXTRA_LEN;
+	const char *basename;
+	alloc_pool_t *pool;
+	STRUCT_STAT st;
+	char *bp;
 
-	if (strlcpy(thisname, fname, sizeof thisname)
-	    >= sizeof thisname - flist_dir_len) {
+	if (strlcpy(thisname, fname, sizeof thisname) >= sizeof thisname) {
 		rprintf(FINFO, "skipping overly long name: %s\n", fname);
 		return NULL;
 	}
 	clean_fname(thisname, 0);
 	if (sanitize_paths)
-		sanitize_path(thisname, thisname, "", 0, NULL);
-
-	memset(sum, 0, SUM_LENGTH);
+		sanitize_path(thisname, thisname, "", 0);
 
 	if (stp && S_ISDIR(stp->st_mode)) {
 		st = *stp; /* Needed for "symlink/." with --relative. */
 		*linkname = '\0'; /* make IBM code checker happy */
 	} else if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
 		/* See if file is excluded before reporting an error. */
 		if (filter_level != NO_FILTERS
-		    && is_excluded(thisname, 0, filter_level))
+		 && (is_excluded(thisname, 0, filter_level)
+		  || is_excluded(thisname, 1, filter_level))) {
+			if (ignore_perishable && save_errno != ENOENT)
+				non_perishable_cnt++;
 			return NULL;
+		}
 		if (save_errno == ENOENT) {
 #ifdef SUPPORT_LINKS
-			/* Avoid "vanished" error if symlink points nowhere. */
-			if (copy_links && do_lstat(thisname, &st) == 0
-			    && S_ISLNK(st.st_mode)) {
+			/* When our options tell us to follow a symlink that
+			 * points nowhere, tell the user about the symlink
+			 * instead of giving a "vanished" message.  We only
+			 * dereference a symlink if one of the --copy*links
+			 * options was specified, so there's no need for the
+			 * extra lstat() if one of these options isn't on. */
+			if ((copy_links || copy_unsafe_links || copy_dirlinks)
+			 && x_lstat(thisname, &st, NULL) == 0
+			 && S_ISLNK(st.st_mode)) {
 				io_error |= IOERR_GENERAL;
-				rprintf(FERROR, "symlink has no referent: %s\n",
+				rprintf(FERROR_XFER, "symlink has no referent: %s\n",
 					full_fname(thisname));
 			} else
 #endif
 			{
 				enum logcode c = am_daemon && protocol_version < 28
-				    ? FERROR : FINFO;
+					       ? FERROR : FWARNING;
 				io_error |= IOERR_VANISHED;
 				rprintf(c, "file has vanished: %s\n",
 					full_fname(thisname));
 			}
 		} else {
 			io_error |= IOERR_GENERAL;
-			rsyserr(FERROR, save_errno, "readlink %s failed",
+			rsyserr(FERROR_XFER, save_errno, "readlink %s failed",
 				full_fname(thisname));
 		}
 		return NULL;
 	}
 
 	/* backup.c calls us with filter_level set to NO_FILTERS. */
 	if (filter_level == NO_FILTERS)
 		goto skip_filters;
 
-	if (S_ISDIR(st.st_mode) && !xfer_dirs) {
-		rprintf(FINFO, "skipping directory %s\n", thisname);
-		return NULL;
-	}
-
-	/* We only care about directories because we need to avoid recursing
-	 * into a mount-point directory, not to avoid copying a symlinked
-	 * file if -L (or similar) was specified. */
-	if (one_file_system && st.st_dev != filesystem_dev
-	 && S_ISDIR(st.st_mode)) {
-		if (one_file_system > 1) {
-			if (verbose > 2) {
-				rprintf(FINFO, "skipping mount-point dir %s\n",
-					thisname);
-			}
+	if (S_ISDIR(st.st_mode)) {
+		if (!xfer_dirs) {
+			rprintf(FINFO, "skipping directory %s\n", thisname);
 			return NULL;
 		}
-		flags |= FLAG_MOUNT_POINT;
-	}
+		/* -x only affects dirs because we need to avoid recursing
+		 * into a mount-point directory, not to avoid copying a
+		 * symlinked file if -L (or similar) was specified. */
+		if (one_file_system && st.st_dev != filesystem_dev
+		 && BITS_SETnUNSET(flags, FLAG_CONTENT_DIR, FLAG_TOP_DIR)) {
+			if (one_file_system > 1) {
+				if (verbose > 1) {
+					rprintf(FINFO,
+					    "[%s] skipping mount-point dir %s\n",
+					    who_am_i(), thisname);
+				}
+				return NULL;
+			}
+			flags |= FLAG_MOUNT_DIR;
+			flags &= ~FLAG_CONTENT_DIR;
+		}
+	} else
+		flags &= ~FLAG_CONTENT_DIR;
 
-	if (is_excluded(thisname, S_ISDIR(st.st_mode) != 0, filter_level))
+	if (is_excluded(thisname, S_ISDIR(st.st_mode) != 0, filter_level)) {
+		if (ignore_perishable)
+			non_perishable_cnt++;
 		return NULL;
+	}
 
 	if (lp_ignore_nonreadable(module_id)) {
 #ifdef SUPPORT_LINKS
 		if (!S_ISLNK(st.st_mode))
 #endif
 			if (access(thisname, R_OK) != 0)
 				return NULL;
 	}
 
   skip_filters:
 
+	/* Only divert a directory in the main transfer. */
+	if (flist) {
+		if (flist->prev && S_ISDIR(st.st_mode)
+		 && flags & FLAG_DIVERT_DIRS) {
+			/* Room for parent/sibling/next-child info. */
+			extra_len += DIRNODE_EXTRA_CNT * EXTRA_LEN;
+			if (relative_paths)
+				extra_len += PTR_EXTRA_CNT * EXTRA_LEN;
+			pool = dir_flist->file_pool;
+		} else
+			pool = flist->file_pool;
+	} else
+		pool = NULL;
+
 	if (verbose > 2) {
 		rprintf(FINFO, "[%s] make_file(%s,*,%d)\n",
 			who_am_i(), thisname, filter_level);
 	}
 
 	if ((basename = strrchr(thisname, '/')) != NULL) {
-		dirname_len = ++basename - thisname; /* counts future '\0' */
-		if (lastdir_len == dirname_len - 1
-		    && strncmp(thisname, lastdir, lastdir_len) == 0) {
-			dirname = lastdir;
-			dirname_len = 0; /* indicates no copy is needed */
-		} else
-			dirname = thisname;
-	} else {
+		int len = basename++ - thisname;
+		if (len != lastdir_len || memcmp(thisname, lastdir, len) != 0) {
+			lastdir = new_array(char, len + 1);
+			memcpy(lastdir, thisname, len);
+			lastdir[len] = '\0';
+			lastdir_len = len;
+		}
+	} else
 		basename = thisname;
-		dirname = NULL;
-		dirname_len = 0;
-	}
 	basename_len = strlen(basename) + 1; /* count the '\0' */
 
 #ifdef SUPPORT_LINKS
 	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
 #else
 	linkname_len = 0;
 #endif
 
-	sum_len = always_checksum && am_sender && S_ISREG(st.st_mode)
-	        ? MD4_SUM_LENGTH : 0;
+	if (st.st_size > 0xFFFFFFFFu && S_ISREG(st.st_mode))
+		extra_len += EXTRA_LEN;
+
+#if EXTRA_ROUNDING > 0
+	if (extra_len & (EXTRA_ROUNDING * EXTRA_LEN))
+		extra_len = (extra_len | (EXTRA_ROUNDING * EXTRA_LEN)) + EXTRA_LEN;
+#endif
 
-	alloc_len = file_struct_len + dirname_len + basename_len
-		  + linkname_len + sum_len;
-	if (flist)
-		bp = pool_alloc(flist->file_pool, alloc_len, "make_file");
+	alloc_len = FILE_STRUCT_LEN + extra_len + basename_len
+		  + linkname_len;
+	if (pool)
+		bp = pool_alloc(pool, alloc_len, "make_file");
 	else {
 		if (!(bp = new_array(char, alloc_len)))
 			out_of_memory("make_file");
 	}
 
+	memset(bp, 0, extra_len + FILE_STRUCT_LEN);
+	bp += extra_len;
 	file = (struct file_struct *)bp;
-	memset(bp, 0, file_struct_len);
-	bp += file_struct_len;
+	bp += FILE_STRUCT_LEN;
 
-	file->flags = flags;
-	file->modtime = st.st_mtime;
-	file->length = st.st_size;
-	file->mode = st.st_mode;
-	file->uid = st.st_uid;
-	file->gid = st.st_gid;
+	memcpy(bp, basename, basename_len);
+	bp += basename_len + linkname_len; /* skip space for symlink too */
 
 #ifdef SUPPORT_HARD_LINKS
-	if (flist && flist->hlink_pool) {
-		if (protocol_version < 28) {
-			if (S_ISREG(st.st_mode))
-				file->link_u.idev = pool_talloc(
-				    flist->hlink_pool, struct idev, 1,
-				    "inode_table");
-		} else {
-			if (!S_ISDIR(st.st_mode) && st.st_nlink > 1)
-				file->link_u.idev = pool_talloc(
-				    flist->hlink_pool, struct idev, 1,
-				    "inode_table");
-		}
-	}
-	if (file->link_u.idev) {
-		file->F_DEV = st.st_dev;
-		file->F_INODE = st.st_ino;
+	if (preserve_hard_links && flist && flist->prev) {
+		if (protocol_version >= 28
+		 ? (!S_ISDIR(st.st_mode) && st.st_nlink > 1)
+		 : S_ISREG(st.st_mode)) {
+			tmp_dev = st.st_dev;
+			tmp_ino = st.st_ino;
+		} else
+			tmp_dev = 0;
 	}
 #endif
 
-	if (dirname_len) {
-		file->dirname = lastdir = bp;
-		lastdir_len = dirname_len - 1;
-		memcpy(bp, dirname, dirname_len - 1);
-		bp += dirname_len;
-		bp[-1] = '\0';
-	} else if (dirname)
-		file->dirname = dirname;
-
-	file->basename = bp;
-	memcpy(bp, basename, basename_len);
-	bp += basename_len;
-
 #ifdef HAVE_STRUCT_STAT_ST_RDEV
-	if ((preserve_devices && IS_DEVICE(st.st_mode))
-	 || (preserve_specials && IS_SPECIAL(st.st_mode)))
-		file->u.rdev = st.st_rdev;
+	if (IS_DEVICE(st.st_mode) || IS_SPECIAL(st.st_mode)) {
+		tmp_rdev = st.st_rdev;
+		st.st_size = 0;
+	}
 #endif
 
+	file->flags = flags;
+	file->modtime = st.st_mtime;
+	file->len32 = (uint32)st.st_size;
+	if (st.st_size > 0xFFFFFFFFu && S_ISREG(st.st_mode)) {
+		file->flags |= FLAG_LENGTH64;
+		OPT_EXTRA(file, 0)->unum = (uint32)(st.st_size >> 32);
+	}
+	file->mode = st.st_mode;
+	if (uid_ndx) /* Check uid_ndx instead of preserve_uid for del support */
+		F_OWNER(file) = st.st_uid;
+	if (gid_ndx) /* Check gid_ndx instead of preserve_gid for del support */
+		F_GROUP(file) = st.st_gid;
+
+	if (basename != thisname)
+		file->dirname = lastdir;
+
 #ifdef SUPPORT_LINKS
 	if (linkname_len) {
-		file->u.link = bp;
+		bp = (char*)file->basename + basename_len;
 		memcpy(bp, linkname, linkname_len);
-		bp += linkname_len;
 	}
 #endif
 
-	if (sum_len) {
-		file->u.sum = bp;
-		file_checksum(thisname, bp, st.st_size);
-		/*bp += sum_len;*/
-	}
+	if (always_checksum && am_sender && S_ISREG(st.st_mode))
+		file_checksum(thisname, tmp_sum, st.st_size);
 
-	file->dir.root = flist_dir;
+	F_PATHNAME(file) = pathname;
 
 	/* This code is only used by the receiver when it is building
 	 * a list of files for a delete pass. */
 	if (keep_dirlinks && linkname_len && flist) {
 		STRUCT_STAT st2;
 		int save_mode = file->mode;
 		file->mode = S_IFDIR; /* Find a directory with our name. */
-		if (flist_find(the_file_list, file) >= 0
-		    && do_stat(thisname, &st2) == 0 && S_ISDIR(st2.st_mode)) {
+		if (flist_find(dir_flist, file) >= 0
+		 && x_stat(thisname, &st2, NULL) == 0 && S_ISDIR(st2.st_mode)) {
 			file->modtime = st2.st_mtime;
-			file->length = st2.st_size;
+			file->len32 = 0;
 			file->mode = st2.st_mode;
-			file->uid = st2.st_uid;
-			file->gid = st2.st_gid;
-			file->u.link = NULL;
+			if (uid_ndx)
+				F_OWNER(file) = st2.st_uid;
+			if (gid_ndx)
+				F_GROUP(file) = st2.st_gid;
 		} else
 			file->mode = save_mode;
 	}
 
-	if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode))
-		stats.total_size += st.st_size;
+	if (basename_len == 0+1) {
+		if (!pool)
+			unmake_file(file);
+		return NULL;
+	}
+
+	if (unsort_ndx)
+		F_NDX(file) = dir_count;
 
 	return file;
 }
 
+/* Only called for temporary file_struct entries created by make_file(). */
+void unmake_file(struct file_struct *file)
+{
+	int extra_cnt = file_extra_cnt + LEN64_BUMP(file);
+#if EXTRA_ROUNDING > 0
+	if (extra_cnt & EXTRA_ROUNDING)
+		extra_cnt = (extra_cnt | EXTRA_ROUNDING) + 1;
+#endif
+	free(REQ_EXTRA(file, extra_cnt));
+}
+
 static struct file_struct *send_file_name(int f, struct file_list *flist,
 					  char *fname, STRUCT_STAT *stp,
-					  unsigned short flags)
+					  int flags, int filter_level)
 {
 	struct file_struct *file;
+#if defined SUPPORT_ACLS || defined SUPPORT_XATTRS
+	stat_x sx;
+#endif
 
-	file = make_file(fname, flist, stp, flags,
-			 f == -2 ? SERVER_FILTERS : ALL_FILTERS);
+	file = make_file(fname, flist, stp, flags, filter_level);
 	if (!file)
 		return NULL;
 
 	if (chmod_modes && !S_ISLNK(file->mode))
 		file->mode = tweak_mode(file->mode, chmod_modes);
 
-	maybe_emit_filelist_progress(flist->count + flist_count_offset);
+#ifdef SUPPORT_ACLS
+	if (preserve_acls && !S_ISLNK(file->mode) && f >= 0) {
+		sx.st.st_mode = file->mode;
+		sx.acc_acl = sx.def_acl = NULL;
+		if (get_acl(fname, &sx) < 0)
+			return NULL;
+	}
+#endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs && f >= 0) {
+		sx.xattr = NULL;
+		if (get_xattr(fname, &sx) < 0)
+			return NULL;
+	}
+#endif
 
-	flist_expand(flist);
+	maybe_emit_filelist_progress(flist->used + flist_count_offset);
 
-	if (file->basename[0]) {
-		flist->files[flist->count++] = file;
-		send_file_entry(file, f);
+	flist_expand(flist, 1);
+	flist->files[flist->used++] = file;
+	if (f >= 0) {
+		send_file_entry(f, file, flist->used - 1, flist->ndx_start);
+#ifdef SUPPORT_ACLS
+		if (preserve_acls && !S_ISLNK(file->mode)) {
+			send_acl(&sx, f);
+			free_acl(&sx);
+		}
+#endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs) {
+			F_XATTR(file) = send_xattr(&sx, f);
+			free_xattr(&sx);
+		}
+#endif
 	}
 	return file;
 }
 
 static void send_if_directory(int f, struct file_list *flist,
 			      struct file_struct *file,
-			      char *fbuf, unsigned int ol)
+			      char *fbuf, unsigned int ol,
+			      int flags)
 {
 	char is_dot_dir = fbuf[ol-1] == '.' && (ol == 1 || fbuf[ol-2] == '/');
 
 	if (S_ISDIR(file->mode)
-	    && !(file->flags & FLAG_MOUNT_POINT) && f_name(file, fbuf)) {
+	    && !(file->flags & FLAG_MOUNT_DIR) && f_name(file, fbuf)) {
 		void *save_filters;
 		unsigned int len = strlen(fbuf);
 		if (len > 1 && fbuf[len-1] == '/')
 			fbuf[--len] = '\0';
 		if (len >= MAXPATHLEN - 1) {
 			io_error |= IOERR_GENERAL;
-			rprintf(FERROR, "skipping long-named directory: %s\n",
+			rprintf(FERROR_XFER, "skipping long-named directory: %s\n",
 				full_fname(fbuf));
 			return;
 		}
 		save_filters = push_local_filters(fbuf, len);
-		send_directory(f, flist, fbuf, len);
+		send_directory(f, flist, fbuf, len, flags);
 		pop_local_filters(save_filters);
 		fbuf[ol] = '\0';
 		if (is_dot_dir)
 			fbuf[ol-1] = '.';
 	}
 }
 
+static int file_compare(const void *file1, const void *file2)
+{
+	return f_name_cmp(*(struct file_struct **)file1,
+			  *(struct file_struct **)file2);
+}
+
+/* The guts of a merge-sort algorithm.  This was derived from the glibc
+ * version, but I (Wayne) changed the merge code to do less copying and
+ * to require only half the amount of temporary memory. */
+static void fsort_tmp(struct file_struct **fp, size_t num,
+		      struct file_struct **tmp)
+{
+	struct file_struct **f1, **f2, **t;
+	size_t n1, n2;
+
+	n1 = num / 2;
+	n2 = num - n1;
+	f1 = fp;
+	f2 = fp + n1;
+
+	if (n1 > 1)
+		fsort_tmp(f1, n1, tmp);
+	if (n2 > 1)
+		fsort_tmp(f2, n2, tmp);
+
+	while (f_name_cmp(*f1, *f2) <= 0) {
+		if (!--n1)
+			return;
+		f1++;
+	}
+
+	t = tmp;
+	memcpy(t, f1, n1 * PTR_SIZE);
+
+	*f1++ = *f2++, n2--;
+
+	while (n1 > 0 && n2 > 0) {
+		if (f_name_cmp(*t, *f2) <= 0)
+			*f1++ = *t++, n1--;
+		else
+			*f1++ = *f2++, n2--;
+	}
+
+	if (n1 > 0)
+		memcpy(f1, t, n1 * PTR_SIZE);
+}
+
+/* This file-struct sorting routine makes sure that any identical names in
+ * the file list stay in the same order as they were in the original list.
+ * This is particularly vital in inc_recurse mode where we expect a sort
+ * on the flist to match the exact order of a sort on the dir_flist. */
+static void fsort(struct file_struct **fp, size_t num)
+{
+	if (num <= 1)
+		return;
+
+	if (use_qsort)
+		qsort(fp, num, PTR_SIZE, file_compare);
+	else {
+		struct file_struct **tmp = new_array(struct file_struct *,
+						     (num+1) / 2);
+		fsort_tmp(fp, num, tmp);
+		free(tmp);
+	}
+}
+
+/* We take an entire set of sibling dirs from the sorted flist and link them
+ * into the tree, setting the appropriate parent/child/sibling pointers. */
+static void add_dirs_to_tree(int parent_ndx, struct file_list *from_flist,
+			     int dir_cnt)
+{
+	int i;
+	int32 *dp = NULL;
+	int32 *parent_dp = parent_ndx < 0 ? NULL
+			 : F_DIR_NODE_P(dir_flist->sorted[parent_ndx]);
+
+	flist_expand(dir_flist, dir_cnt);
+	dir_flist->sorted = dir_flist->files;
+
+	for (i = 0; dir_cnt; i++) {
+		struct file_struct *file = from_flist->sorted[i];
+
+		if (!S_ISDIR(file->mode))
+			continue;
+
+		dir_flist->files[dir_flist->used++] = file;
+		dir_cnt--;
+
+		if (file->basename[0] == '.' && file->basename[1] == '\0')
+			continue;
+
+		if (dp)
+			DIR_NEXT_SIBLING(dp) = dir_flist->used - 1;
+		else if (parent_dp)
+			DIR_FIRST_CHILD(parent_dp) = dir_flist->used - 1;
+		else
+			send_dir_ndx = dir_flist->used - 1;
+
+		dp = F_DIR_NODE_P(file);
+		DIR_PARENT(dp) = parent_ndx;
+		DIR_FIRST_CHILD(dp) = -1;
+	}
+	if (dp)
+		DIR_NEXT_SIBLING(dp) = -1;
+}
+
 /* This function is normally called by the sender, but the receiving side also
  * calls it from get_dirlist() with f set to -1 so that we just construct the
  * file list in memory without sending it over the wire.  Also, get_dirlist()
  * might call this with f set to -2, which also indicates that local filter
  * rules should be ignored. */
-static void send_directory(int f, struct file_list *flist,
-			   char *fbuf, int len)
+static void send_directory(int f, struct file_list *flist, char *fbuf, int len,
+			   int flags)
 {
 	struct dirent *di;
 	unsigned remainder;
 	char *p;
 	DIR *d;
-	int start = flist->count;
+	int divert_dirs = (flags & FLAG_DIVERT_DIRS) != 0;
+	int start = flist->used;
+	int filter_level = f == -2 ? SERVER_FILTERS : ALL_FILTERS;
+
+	assert(flist != NULL);
 
 	if (!(d = opendir(fbuf))) {
 		io_error |= IOERR_GENERAL;
-		rsyserr(FERROR, errno, "opendir %s failed", full_fname(fbuf));
+		rsyserr(FERROR_XFER, errno, "opendir %s failed", full_fname(fbuf));
 		return;
 	}
 
 	p = fbuf + len;
 	if (len != 1 || *fbuf != '/')
 		*p++ = '/';
@@ -1031,121 +1490,384 @@
 			io_error |= IOERR_GENERAL;
 			rprintf(FINFO,
 				"cannot send long-named file %s\n",
 				full_fname(fbuf));
 			continue;
 		}
+		if (dname[0] == '\0') {
+			io_error |= IOERR_GENERAL;
+			rprintf(FINFO,
+				"cannot send file with empty name in %s\n",
+				full_fname(fbuf));
+			continue;
+		}
 
-		send_file_name(f, flist, fbuf, NULL, 0);
+		send_file_name(f, flist, fbuf, NULL, flags, filter_level);
 	}
 
 	fbuf[len] = '\0';
 
 	if (errno) {
 		io_error |= IOERR_GENERAL;
-		rsyserr(FERROR, errno, "readdir(%s)", full_fname(fbuf));
+		rsyserr(FERROR_XFER, errno, "readdir(%s)", full_fname(fbuf));
 	}
 
 	closedir(d);
 
-	if (recurse) {
-		int i, end = flist->count - 1;
+	if (f >= 0 && recurse && !divert_dirs) {
+		int i, end = flist->used - 1;
+		/* send_if_directory() bumps flist->used, so use "end". */
 		for (i = start; i <= end; i++)
-			send_if_directory(f, flist, flist->files[i], fbuf, len);
+			send_if_directory(f, flist, flist->files[i], fbuf, len, flags);
+	}
+}
+
+static char lastpath[MAXPATHLEN] = "";
+static int lastpath_len = 0;
+static struct file_struct *lastpath_struct;
+
+static void send_implied_dirs(int f, struct file_list *flist, char *fname,
+			      char *start, char *limit, int flags, char name_type)
+{
+	struct file_struct *file;
+	item_list *relname_list;
+	relnamecache **rnpp;
+	char *slash;
+	int len, need_new_dir;
+	struct filter_list_struct save_filter_list = filter_list;
+
+	flags = (flags | FLAG_IMPLIED_DIR) & ~(FLAG_TOP_DIR | FLAG_CONTENT_DIR);
+	filter_list.head = filter_list.tail = NULL; /* Don't filter implied dirs. */
+
+	if (inc_recurse) {
+		if (lastpath_struct && F_PATHNAME(lastpath_struct) == pathname
+		 && lastpath_len == limit - fname
+		 && strncmp(lastpath, fname, lastpath_len) == 0)
+			need_new_dir = 0;
+		else
+			need_new_dir = 1;
+	} else
+		need_new_dir = 1;
+
+	if (need_new_dir) {
+		int save_copy_links = copy_links;
+		int save_xfer_dirs = xfer_dirs;
+
+		copy_links = xfer_dirs = 1;
+
+		*limit = '\0';
+
+		for (slash = start; (slash = strchr(slash+1, '/')) != NULL; ) {
+			*slash = '\0';
+			send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);
+			*slash = '/';
+		}
+
+		file = send_file_name(f, flist, fname, NULL, flags, ALL_FILTERS);
+		if (inc_recurse) {
+			if (file && !S_ISDIR(file->mode))
+				file = NULL;
+			lastpath_struct = file;
+		}
+
+		strlcpy(lastpath, fname, sizeof lastpath);
+		lastpath_len = limit - fname;
+
+		*limit = '/';
+
+		copy_links = save_copy_links;
+		xfer_dirs = save_xfer_dirs;
+
+		if (!inc_recurse)
+			goto done;
+	}
+
+	if (!lastpath_struct)
+		goto done; /* dir must have vanished */
+
+	len = strlen(limit+1);
+	memcpy(&relname_list, F_DIR_RELNAMES_P(lastpath_struct), sizeof relname_list);
+	if (!relname_list) {
+		if (!(relname_list = new0(item_list)))
+			out_of_memory("send_implied_dirs");
+		memcpy(F_DIR_RELNAMES_P(lastpath_struct), &relname_list, sizeof relname_list);
+	}
+	rnpp = EXPAND_ITEM_LIST(relname_list, relnamecache *, 32);
+	if (!(*rnpp = (relnamecache*)new_array(char, sizeof (relnamecache) + len)))
+		out_of_memory("send_implied_dirs");
+	(*rnpp)->name_type = name_type;
+	strlcpy((*rnpp)->fname, limit+1, len + 1);
+
+done:
+	filter_list = save_filter_list;
+}
+
+static void send1extra(int f, struct file_struct *file, struct file_list *flist)
+{
+	char fbuf[MAXPATHLEN];
+	item_list *relname_list;
+	int len, dlen, flags = FLAG_DIVERT_DIRS | FLAG_CONTENT_DIR;
+	size_t j;
+
+	f_name(file, fbuf);
+	dlen = strlen(fbuf);
+
+	if (F_PATHNAME(file) != pathname) {
+		if (!push_pathname(F_PATHNAME(file), -1))
+			exit_cleanup(RERR_FILESELECT);
+	}
+
+	change_local_filter_dir(fbuf, dlen, send_dir_depth);
+
+	if (file->flags & FLAG_CONTENT_DIR) {
+		if (one_file_system) {
+			STRUCT_STAT st;
+			if (link_stat(fbuf, &st, copy_dirlinks) != 0) {
+				io_error |= IOERR_GENERAL;
+				rsyserr(FERROR_XFER, errno, "link_stat %s failed",
+					full_fname(fbuf));
+				return;
+			}
+			filesystem_dev = st.st_dev;
+		}
+		send_directory(f, flist, fbuf, dlen, flags);
+	}
+
+	if (!relative_paths)
+		return;
+
+	memcpy(&relname_list, F_DIR_RELNAMES_P(file), sizeof relname_list);
+	if (!relname_list)
+		return;
+
+	for (j = 0; j < relname_list->count; j++) {
+		char *slash;
+		relnamecache *rnp = ((relnamecache**)relname_list->items)[j];
+		char name_type = rnp->name_type;
+
+		fbuf[dlen] = '/';
+		len = strlcpy(fbuf + dlen + 1, rnp->fname, sizeof fbuf - dlen - 1);
+		free(rnp);
+		if (len >= (int)sizeof fbuf)
+			continue; /* Impossible... */
+
+		slash = strchr(fbuf+dlen+1, '/');
+		if (slash) {
+			send_implied_dirs(f, flist, fbuf, fbuf+dlen+1, slash, flags, name_type);
+			continue;
+		}
+
+		if (name_type != NORMAL_NAME) {
+			STRUCT_STAT st;
+			if (link_stat(fbuf, &st, 1) != 0) {
+				io_error |= IOERR_GENERAL;
+				rsyserr(FERROR_XFER, errno, "link_stat %s failed",
+					full_fname(fbuf));
+				continue;
+			}
+			send_file_name(f, flist, fbuf, &st, FLAG_TOP_DIR | flags, ALL_FILTERS);
+		} else
+			send_file_name(f, flist, fbuf, NULL, FLAG_TOP_DIR | flags, ALL_FILTERS);
 	}
+
+	free(relname_list);
+}
+
+void send_extra_file_list(int f, int at_least)
+{
+	struct file_list *flist;
+	int64 start_write;
+	uint16 prev_flags;
+	int old_cnt, save_io_error = io_error;
+
+	if (flist_eof)
+		return;
+
+	/* Keep sending data until we have the requested number of
+	 * files in the upcoming file-lists. */
+	old_cnt = cur_flist->used;
+	for (flist = first_flist; flist != cur_flist; flist = flist->next)
+		old_cnt += flist->used;
+	while (file_total - old_cnt < at_least) {
+		struct file_struct *file = dir_flist->sorted[send_dir_ndx];
+		int dir_ndx, dstart = dir_count;
+		const char *pathname = F_PATHNAME(file);
+		int32 *dp;
+
+		flist = flist_new(0, "send_extra_file_list");
+		start_write = stats.total_written;
+
+		if (unsort_ndx)
+			dir_ndx = F_NDX(file);
+		else
+			dir_ndx = send_dir_ndx;
+		write_ndx(f, NDX_FLIST_OFFSET - dir_ndx);
+		flist->parent_ndx = dir_ndx;
+
+		send1extra(f, file, flist);
+		prev_flags = file->flags;
+		dp = F_DIR_NODE_P(file);
+
+		/* If there are any duplicate directory names that follow, we
+		 * send all the dirs together in one file-list.  The dir_flist
+		 * tree links all the child subdirs onto the last dup dir. */
+		while ((dir_ndx = DIR_NEXT_SIBLING(dp)) >= 0
+		    && dir_flist->sorted[dir_ndx]->flags & FLAG_DUPLICATE) {
+			send_dir_ndx = dir_ndx;
+			file = dir_flist->sorted[dir_ndx];
+			/* Try to avoid some duplicate scanning of identical dirs. */
+			if (F_PATHNAME(file) == pathname && prev_flags & FLAG_CONTENT_DIR)
+				file->flags &= ~FLAG_CONTENT_DIR;
+			send1extra(f, file, flist);
+			prev_flags = file->flags;
+			dp = F_DIR_NODE_P(file);
+		}
+
+		write_byte(f, 0);
+
+		if (need_unsorted_flist) {
+			if (!(flist->sorted = new_array(struct file_struct *, flist->used)))
+				out_of_memory("send_extra_file_list");
+			memcpy(flist->sorted, flist->files,
+			       flist->used * sizeof (struct file_struct*));
+		} else
+			flist->sorted = flist->files;
+
+		flist_sort_and_clean(flist, 0);
+
+		add_dirs_to_tree(send_dir_ndx, flist, dir_count - dstart);
+		flist_done_allocating(flist);
+
+		file_total += flist->used;
+		stats.flist_size += stats.total_written - start_write;
+		stats.num_files += flist->used;
+		if (verbose > 3)
+			output_flist(flist);
+
+		if (DIR_FIRST_CHILD(dp) >= 0) {
+			send_dir_ndx = DIR_FIRST_CHILD(dp);
+			send_dir_depth++;
+		} else {
+			while (DIR_NEXT_SIBLING(dp) < 0) {
+				if ((send_dir_ndx = DIR_PARENT(dp)) < 0) {
+					write_ndx(f, NDX_FLIST_EOF);
+					flist_eof = 1;
+					change_local_filter_dir(NULL, 0, 0);
+					goto finish;
+				}
+				send_dir_depth--;
+				file = dir_flist->sorted[send_dir_ndx];
+				dp = F_DIR_NODE_P(file);
+			}
+			send_dir_ndx = DIR_NEXT_SIBLING(dp);
+		}
+	}
+
+  finish:
+	if (io_error != save_io_error && !ignore_errors)
+		send_msg_int(MSG_IO_ERROR, io_error);
 }
 
 struct file_list *send_file_list(int f, int argc, char *argv[])
 {
-	int len;
+	static const char *lastdir;
+	static int lastdir_len = -1;
+	int len, dirlen;
 	STRUCT_STAT st;
-	char *p, *dir, olddir[sizeof curr_dir];
-	char lastpath[MAXPATHLEN] = "";
+	char *p, *dir;
 	struct file_list *flist;
 	struct timeval start_tv, end_tv;
 	int64 start_write;
 	int use_ff_fd = 0;
+	int disable_buffering;
+	int flags = recurse ? FLAG_CONTENT_DIR : 0;
+	int reading_remotely = filesfrom_host != NULL;
+	int rl_flags = (reading_remotely ? 0 : RL_DUMP_COMMENTS)
+#ifdef ICONV_OPTION
+		     | (filesfrom_convert ? RL_CONVERT : 0)
+#endif
+		     | (eol_nulls || reading_remotely ? RL_EOL_NULLS : 0);
 
 	rprintf(FLOG, "building file list\n");
 	if (show_filelist_p())
 		start_filelist_progress("building file list");
+	else if (inc_recurse && verbose && !am_server)
+		rprintf(FCLIENT, "sending incremental file list\n");
 
 	start_write = stats.total_written;
 	gettimeofday(&start_tv, NULL);
 
-	flist = flist_new(WITH_HLINK, "send_file_list");
+	if (relative_paths && protocol_version >= 30)
+		implied_dirs = 1; /* We send flagged implied dirs */
+
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && protocol_version >= 30 && !cur_flist)
+		init_hard_links();
+#endif
+
+	flist = cur_flist = flist_new(0, "send_file_list");
+	if (inc_recurse) {
+		dir_flist = flist_new(FLIST_TEMP, "send_file_list");
+		flags |= FLAG_DIVERT_DIRS;
+	} else
+		dir_flist = cur_flist;
 
-	io_start_buffering_out();
+	disable_buffering = io_start_buffering_out(f);
 	if (filesfrom_fd >= 0) {
 		if (argv[0] && !push_dir(argv[0], 0)) {
-			rsyserr(FERROR, errno, "push_dir %s failed",
-				full_fname(argv[0]));
+			rsyserr(FERROR_XFER, errno, "push_dir %s failed in %s",
+				full_fname(argv[0]), curr_dir);
 			exit_cleanup(RERR_FILESELECT);
 		}
 		use_ff_fd = 1;
 	}
 
 	while (1) {
-		char fbuf[MAXPATHLEN];
-		char *fn;
-		int is_dot_dir;
+		char fbuf[MAXPATHLEN], *fn, name_type;
 
 		if (use_ff_fd) {
-			if (read_filesfrom_line(filesfrom_fd, fbuf) == 0)
+			if (read_line(filesfrom_fd, fbuf, sizeof fbuf, rl_flags) == 0)
 				break;
-			sanitize_path(fbuf, fbuf, "", 0, NULL);
+			sanitize_path(fbuf, fbuf, "", 0);
 		} else {
 			if (argc-- == 0)
 				break;
 			strlcpy(fbuf, *argv++, MAXPATHLEN);
 			if (sanitize_paths)
-				sanitize_path(fbuf, fbuf, "", 0, NULL);
+				sanitize_path(fbuf, fbuf, "", 0);
 		}
 
 		len = strlen(fbuf);
 		if (relative_paths) {
 			/* We clean up fbuf below. */
-			is_dot_dir = 0;
+			name_type = NORMAL_NAME;
 		} else if (!len || fbuf[len - 1] == '/') {
 			if (len == 2 && fbuf[0] == '.') {
 				/* Turn "./" into just "." rather than "./." */
-				fbuf[1] = '\0';
+				fbuf[--len] = '\0';
 			} else {
 				if (len + 1 >= MAXPATHLEN)
 					overflow_exit("send_file_list");
 				fbuf[len++] = '.';
 				fbuf[len] = '\0';
 			}
-			is_dot_dir = 1;
+			name_type = DOT_NAME;
 		} else if (len > 1 && fbuf[len-1] == '.' && fbuf[len-2] == '.'
 		    && (len == 2 || fbuf[len-3] == '/')) {
 			if (len + 2 >= MAXPATHLEN)
 				overflow_exit("send_file_list");
 			fbuf[len++] = '/';
 			fbuf[len++] = '.';
 			fbuf[len] = '\0';
-			is_dot_dir = 1;
-		} else {
-			is_dot_dir = fbuf[len-1] == '.'
-				   && (len == 1 || fbuf[len-2] == '/');
-		}
-
-		if (link_stat(fbuf, &st, copy_dirlinks) != 0) {
-			io_error |= IOERR_GENERAL;
-			rsyserr(FERROR, errno, "link_stat %s failed",
-				full_fname(fbuf));
-			continue;
-		}
-
-		if (S_ISDIR(st.st_mode) && !xfer_dirs) {
-			rprintf(FINFO, "skipping directory %s\n", fbuf);
-			continue;
-		}
+			name_type = DOT_NAME;
+		} else if (fbuf[len-1] == '.' && (len == 1 || fbuf[len-2] == '/'))
+			name_type = DOT_NAME;
+		else
+			name_type = NORMAL_NAME;
 
 		dir = NULL;
-		olddir[0] = '\0';
 
 		if (!relative_paths) {
 			p = strrchr(fbuf, '/');
 			if (p) {
 				*p = '\0';
 				if (p == fbuf)
@@ -1160,304 +1882,397 @@
 			if ((p = strstr(fbuf, "/./")) != NULL) {
 				*p = '\0';
 				if (p == fbuf)
 					dir = "/";
 				else
 					dir = fbuf;
-				len -= p - fbuf + 3;
 				fn = p + 3;
+				while (*fn == '/')
+					fn++;
+				if (!*fn)
+					*--fn = '\0'; /* ensure room for '.' */
 			} else
 				fn = fbuf;
-			/* Get rid of trailing "/" and "/.". */
-			while (len) {
-				if (fn[len - 1] == '/') {
-					is_dot_dir = 1;
-					if (!--len && !dir) {
-						len++;
-						break;
-					}
-				}
-				else if (len >= 2 && fn[len - 1] == '.'
-						  && fn[len - 2] == '/') {
-					is_dot_dir = 1;
-					if (!(len -= 2) && !dir) {
-						len++;
-						break;
-					}
-				} else
-					break;
+			len = clean_fname(fn, CFN_KEEP_LEADING_DOT_DIR
+					    | CFN_KEEP_TRAILING_SLASH
+					    | CFN_DROP_TRAILING_DOT_DIR);
+			if (len == 1) {
+				if (fn[0] == '/') {
+					fn = "/.";
+					len = 2;
+					name_type = DOT_NAME;
+				} else if (fn[0] == '.')
+					name_type = DOT_NAME;
+			} else if (fn[len-1] == '/') {
+				fn[--len] = '\0';
+				if (len == 1 && *fn == '.')
+					name_type = DOT_NAME;
+				else
+					name_type = SLASH_ENDING_NAME;
 			}
-			if (len == 1 && fn[0] == '/')
-				fn[len++] = '.';
-			fn[len] = '\0';
 			/* Reject a ".." dir in the active part of the path. */
 			for (p = fn; (p = strstr(p, "..")) != NULL; p += 2) {
 				if ((p[2] == '/' || p[2] == '\0')
 				 && (p == fn || p[-1] == '/')) {
 					rprintf(FERROR,
 					    "found \"..\" dir in relative path: %s\n",
-					    fbuf);
+					    fn);
 					exit_cleanup(RERR_SYNTAX);
 				}
 			}
 		}
 
 		if (!*fn) {
 			len = 1;
 			fn = ".";
+			name_type = DOT_NAME;
 		}
 
-		if (dir && *dir) {
-			static char *lastdir;
-			static int lastdir_len;
-
-			strlcpy(olddir, curr_dir, sizeof olddir);
-
-			if (!push_dir(dir, 0)) {
-				io_error |= IOERR_GENERAL;
-				rsyserr(FERROR, errno, "push_dir %s failed",
-					full_fname(dir));
+		dirlen = dir ? strlen(dir) : 0;
+		if (dirlen != lastdir_len || memcmp(lastdir, dir, dirlen) != 0) {
+			if (!push_pathname(dir ? strdup(dir) : NULL, dirlen))
 				continue;
-			}
-
-			if (lastdir && strcmp(lastdir, dir) == 0) {
-				flist_dir = lastdir;
-				flist_dir_len = lastdir_len;
-			} else {
-				flist_dir = lastdir = strdup(dir);
-				flist_dir_len = lastdir_len = strlen(dir);
-			}
-		}
+			lastdir = pathname;
+			lastdir_len = pathname_len;
+		} else if (!push_pathname(lastdir, lastdir_len))
+			continue;
 
 		if (fn != fbuf)
 			memmove(fbuf, fn, len + 1);
 
-		if (implied_dirs && (p=strrchr(fbuf,'/')) && p != fbuf) {
+		if (link_stat(fbuf, &st, copy_dirlinks || name_type != NORMAL_NAME) != 0) {
+			io_error |= IOERR_GENERAL;
+			rsyserr(FERROR_XFER, errno, "link_stat %s failed",
+				full_fname(fbuf));
+			continue;
+		}
+
+		if (S_ISDIR(st.st_mode) && !xfer_dirs) {
+			rprintf(FINFO, "skipping directory %s\n", fbuf);
+			continue;
+		}
+
+		if (inc_recurse && relative_paths && *fbuf) {
+			if ((p = strchr(fbuf+1, '/')) != NULL) {
+				if (p - fbuf == 1 && *fbuf == '.') {
+					if ((fn = strchr(p+1, '/')) != NULL)
+						p = fn;
+				} else
+					fn = p;
+				send_implied_dirs(f, flist, fbuf, fbuf, p, flags, name_type);
+				if (fn == p)
+					continue;
+			}
+		} else if (implied_dirs && (p=strrchr(fbuf,'/')) && p != fbuf) {
 			/* Send the implied directories at the start of the
 			 * source spec, so we get their permissions right. */
 			char *lp = lastpath, *slash = fbuf;
 			*p = '\0';
 			/* Skip any initial directories in our path that we
 			 * have in common with lastpath. */
 			for (fn = fbuf; *fn && *lp == *fn; lp++, fn++) {
 				if (*fn == '/')
 					slash = fn;
 			}
 			*p = '/';
-			if (fn != p || (*lp && *lp != '/')) {
-				int save_copy_links = copy_links;
-				int save_xfer_dirs = xfer_dirs;
-				copy_links |= copy_unsafe_links;
-				xfer_dirs = 1;
-				while ((slash = strchr(slash+1, '/')) != 0) {
-					*slash = '\0';
-					send_file_name(f, flist, fbuf, NULL, 0);
-					*slash = '/';
-				}
-				copy_links = save_copy_links;
-				xfer_dirs = save_xfer_dirs;
-				*p = '\0';
-				strlcpy(lastpath, fbuf, sizeof lastpath);
-				*p = '/';
-			}
+			if (fn != p || (*lp && *lp != '/'))
+				send_implied_dirs(f, flist, fbuf, slash, p, flags, 0);
 		}
 
 		if (one_file_system)
 			filesystem_dev = st.st_dev;
 
-		if (recurse || (xfer_dirs && is_dot_dir)) {
+		if (recurse || (xfer_dirs && name_type != NORMAL_NAME)) {
 			struct file_struct *file;
-			file = send_file_name(f, flist, fbuf, &st, FLAG_TOP_DIR);
-			if (file)
-				send_if_directory(f, flist, file, fbuf, len);
+			int top_flags = FLAG_TOP_DIR | FLAG_CONTENT_DIR | flags;
+			file = send_file_name(f, flist, fbuf, &st,
+					      top_flags, ALL_FILTERS);
+			if (inc_recurse) {
+				if (name_type == DOT_NAME && file) {
+					if (send_dir_depth < 0) {
+						send_dir_depth = 0;
+						change_local_filter_dir(fbuf, len, send_dir_depth);
+					}
+					send_directory(f, flist, fbuf, len, flags);
+				}
+			} else if (file)
+				send_if_directory(f, flist, file, fbuf, len, flags);
 		} else
-			send_file_name(f, flist, fbuf, &st, 0);
-
-		if (olddir[0]) {
-			flist_dir = NULL;
-			flist_dir_len = 0;
-			if (!pop_dir(olddir)) {
-				rsyserr(FERROR, errno, "pop_dir %s failed",
-					full_fname(olddir));
-				exit_cleanup(RERR_FILESELECT);
-			}
-		}
+			send_file_name(f, flist, fbuf, &st, flags, ALL_FILTERS);
 	}
 
 	gettimeofday(&end_tv, NULL);
 	stats.flist_buildtime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000
 			      + (end_tv.tv_usec - start_tv.tv_usec) / 1000;
 	if (stats.flist_buildtime == 0)
 		stats.flist_buildtime = 1;
 	start_tv = end_tv;
 
-	send_file_entry(NULL, f);
+	write_byte(f, 0); /* Indicate end of file list */
+
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && protocol_version >= 30 && !inc_recurse)
+		idev_destroy();
+#endif
 
 	if (show_filelist_p())
 		finish_filelist_progress(flist);
 
 	gettimeofday(&end_tv, NULL);
 	stats.flist_xfertime = (int64)(end_tv.tv_sec - start_tv.tv_sec) * 1000
 			     + (end_tv.tv_usec - start_tv.tv_usec) / 1000;
 
-	if (flist->hlink_pool) {
-		pool_destroy(flist->hlink_pool);
-		flist->hlink_pool = NULL;
-	}
+	/* When converting names, both sides keep an unsorted file-list array
+	 * because the names will differ on the sending and receiving sides
+	 * (both sides will use the unsorted index number for each item). */
 
 	/* Sort the list without removing any duplicates.  This allows the
-	 * receiving side to ask for any name they like, which gives us the
-	 * flexibility to change the way we unduplicate names in the future
-	 * without causing a compatibility problem with older versions. */
-	clean_flist(flist, 0, 0);
+	 * receiving side to ask for whatever name it kept.  For incremental
+	 * recursion mode, the sender marks duplicate dirs so that it can
+	 * send them together in a single file-list. */
+	if (need_unsorted_flist) {
+		if (!(flist->sorted = new_array(struct file_struct *, flist->used)))
+			out_of_memory("send_file_list");
+		memcpy(flist->sorted, flist->files,
+		       flist->used * sizeof (struct file_struct*));
+	} else
+		flist->sorted = flist->files;
+	flist_sort_and_clean(flist, 0);
+	file_total += flist->used;
 
-	send_uid_list(f);
+	if (numeric_ids <= 0 && !inc_recurse)
+		send_id_list(f);
 
 	/* send the io_error flag */
-	write_int(f, lp_ignore_errors(module_id) ? 0 : io_error);
+	if (protocol_version < 30)
+		write_int(f, ignore_errors ? 0 : io_error);
+	else if (io_error && !ignore_errors)
+		send_msg_int(MSG_IO_ERROR, io_error);
+
+	if (disable_buffering)
+		io_end_buffering_out();
 
-	io_end_buffering();
 	stats.flist_size = stats.total_written - start_write;
-	stats.num_files = flist->count;
+	stats.num_files = flist->used;
 
 	if (verbose > 3)
 		output_flist(flist);
 
 	if (verbose > 2)
 		rprintf(FINFO, "send_file_list done\n");
 
+	if (inc_recurse) {
+		send_dir_depth = 1;
+		add_dirs_to_tree(-1, flist, dir_count);
+		if (!file_total || strcmp(flist->sorted[0]->basename, ".") != 0) 
+			flist->parent_ndx = -1;
+		flist_done_allocating(flist);
+		if (send_dir_ndx < 0) {
+			write_ndx(f, NDX_FLIST_EOF);
+			flist_eof = 1;
+		}
+		else if (file_total == 1) {
+			/* If we're creating incremental file-lists and there
+			 * was just 1 item in the first file-list, send 1 more
+			 * file-list to check if this is a 1-file xfer. */
+			send_extra_file_list(f, 1);
+		}
+	}
+
 	return flist;
 }
 
 struct file_list *recv_file_list(int f)
 {
 	struct file_list *flist;
-	unsigned short flags;
+	int dstart, flags;
 	int64 start_read;
 
-	rprintf(FLOG, "receiving file list\n");
+	if (!first_flist)
+		rprintf(FLOG, "receiving file list\n");
 	if (show_filelist_p())
 		start_filelist_progress("receiving file list");
+	else if (inc_recurse && verbose && !am_server && !first_flist)
+		rprintf(FCLIENT, "receiving incremental file list\n");
 
 	start_read = stats.total_read;
 
-	flist = flist_new(WITH_HLINK, "recv_file_list");
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && !first_flist)
+		init_hard_links();
+#endif
 
-	flist->count = 0;
-	flist->malloced = 1000;
-	flist->files = new_array(struct file_struct *, flist->malloced);
-	if (!flist->files)
-		goto oom;
+	flist = flist_new(0, "recv_file_list");
+
+	if (inc_recurse) {
+		if (flist->ndx_start == 1)
+			dir_flist = flist_new(FLIST_TEMP, "recv_file_list");
+		dstart = dir_flist->used;
+	} else {
+		dir_flist = flist;
+		dstart = 0;
+	}
 
 	while ((flags = read_byte(f)) != 0) {
 		struct file_struct *file;
 
-		flist_expand(flist);
+		flist_expand(flist, 1);
 
 		if (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))
 			flags |= read_byte(f) << 8;
-		file = receive_file_entry(flist, flags, f);
+		file = recv_file_entry(flist, flags, f);
 
-		if (S_ISREG(file->mode) || S_ISLNK(file->mode))
-			stats.total_size += file->length;
+		if (inc_recurse && S_ISDIR(file->mode)) {
+			flist_expand(dir_flist, 1);
+			dir_flist->files[dir_flist->used++] = file;
+		}
 
-		flist->files[flist->count++] = file;
+		flist->files[flist->used++] = file;
 
-		maybe_emit_filelist_progress(flist->count);
+		maybe_emit_filelist_progress(flist->used);
 
 		if (verbose > 2) {
 			rprintf(FINFO, "recv_file_name(%s)\n",
 				f_name(file, NULL));
 		}
 	}
-	receive_file_entry(NULL, 0, 0); /* Signal that we're done. */
+	file_total += flist->used;
 
 	if (verbose > 2)
-		rprintf(FINFO, "received %d names\n", flist->count);
+		rprintf(FINFO, "received %d names\n", flist->used);
 
 	if (show_filelist_p())
 		finish_filelist_progress(flist);
 
-	clean_flist(flist, relative_paths, 1);
+	if (need_unsorted_flist) {
+		/* Create an extra array of index pointers that we can sort for
+		 * the generator's use (for wading through the files in sorted
+		 * order and for calling flist_find()).  We keep the "files"
+		 * list unsorted for our exchange of index numbers with the
+		 * other side (since their names may not sort the same). */
+		if (!(flist->sorted = new_array(struct file_struct *, flist->used)))
+			out_of_memory("recv_file_list");
+		memcpy(flist->sorted, flist->files,
+		       flist->used * sizeof (struct file_struct*));
+		if (inc_recurse && dir_flist->used > dstart) {
+			static int dir_flist_malloced = 0;
+			if (dir_flist_malloced < dir_flist->malloced) {
+				dir_flist->sorted = realloc_array(dir_flist->sorted,
+							struct file_struct *,
+							dir_flist->malloced);
+				dir_flist_malloced = dir_flist->malloced;
+			}
+			memcpy(dir_flist->sorted + dstart, dir_flist->files + dstart,
+			       (dir_flist->used - dstart) * sizeof (struct file_struct*));
+			fsort(dir_flist->sorted + dstart, dir_flist->used - dstart);
+		}
+	} else {
+		flist->sorted = flist->files;
+		if (inc_recurse && dir_flist->used > dstart) {
+			dir_flist->sorted = dir_flist->files;
+			fsort(dir_flist->sorted + dstart, dir_flist->used - dstart);
+		}
+	}
+
+	if (inc_recurse)
+		flist_done_allocating(flist);
+	else if (f >= 0)
+		recv_id_list(f, flist);
 
-	if (f >= 0) {
-		recv_uid_list(f, flist);
+	flist_sort_and_clean(flist, relative_paths);
 
+	if (protocol_version < 30) {
 		/* Recv the io_error flag */
-		if (lp_ignore_errors(module_id) || ignore_errors)
+		if (ignore_errors)
 			read_int(f);
 		else
 			io_error |= read_int(f);
+	} else if (inc_recurse && flist->ndx_start == 1) {
+		if (!file_total || strcmp(flist->sorted[0]->basename, ".") != 0) 
+			flist->parent_ndx = -1;
 	}
 
 	if (verbose > 3)
 		output_flist(flist);
 
-	if (list_only) {
-		int i;
-		for (i = 0; i < flist->count; i++)
-			list_file_entry(flist->files[i]);
-	}
-
 	if (verbose > 2)
 		rprintf(FINFO, "recv_file_list done\n");
 
-	stats.flist_size = stats.total_read - start_read;
-	stats.num_files = flist->count;
+	stats.flist_size += stats.total_read - start_read;
+	stats.num_files += flist->used;
 
 	return flist;
-
-  oom:
-	out_of_memory("recv_file_list");
-	return NULL;		/* not reached */
 }
 
-static int file_compare(struct file_struct **file1, struct file_struct **file2)
+/* This is only used once by the receiver if the very first file-list
+ * has exactly one item in it. */
+void recv_additional_file_list(int f)
 {
-	return f_name_cmp(*file1, *file2);
+	struct file_list *flist;
+	int ndx = read_ndx(f);
+	if (ndx == NDX_FLIST_EOF) {
+		flist_eof = 1;
+		change_local_filter_dir(NULL, 0, 0);
+	} else {
+		ndx = NDX_FLIST_OFFSET - ndx;
+		if (ndx < 0 || ndx >= dir_flist->used) {
+			ndx = NDX_FLIST_OFFSET - ndx;
+			rprintf(FERROR,
+				"[%s] Invalid dir index: %d (%d - %d)\n",
+				who_am_i(), ndx, NDX_FLIST_OFFSET,
+				NDX_FLIST_OFFSET - dir_flist->used + 1);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+		if (verbose > 3) {
+			rprintf(FINFO, "[%s] receiving flist for dir %d\n",
+				who_am_i(), ndx);
+		}
+		flist = recv_file_list(f);
+		flist->parent_ndx = ndx;
+	}
 }
 
 /* Search for an identically-named item in the file list.  Note that the
  * items must agree in their directory-ness, or no match is returned. */
 int flist_find(struct file_list *flist, struct file_struct *f)
 {
 	int low = flist->low, high = flist->high;
 	int diff, mid, mid_up;
 
 	while (low <= high) {
 		mid = (low + high) / 2;
-		if (flist->files[mid]->basename)
+		if (F_IS_ACTIVE(flist->sorted[mid]))
 			mid_up = mid;
 		else {
 			/* Scan for the next non-empty entry using the cached
 			 * distance values.  If the value isn't fully up-to-
 			 * date, update it. */
-			mid_up = mid + flist->files[mid]->dir.depth;
-			if (!flist->files[mid_up]->basename) {
+			mid_up = mid + F_DEPTH(flist->sorted[mid]);
+			if (!F_IS_ACTIVE(flist->sorted[mid_up])) {
 				do {
-				    mid_up += flist->files[mid_up]->dir.depth;
-				} while (!flist->files[mid_up]->basename);
-				flist->files[mid]->dir.depth = mid_up - mid;
+				    mid_up += F_DEPTH(flist->sorted[mid_up]);
+				} while (!F_IS_ACTIVE(flist->sorted[mid_up]));
+				F_DEPTH(flist->sorted[mid]) = mid_up - mid;
 			}
 			if (mid_up > high) {
 				/* If there's nothing left above us, set high to
 				 * a non-empty entry below us and continue. */
-				high = mid - flist->files[mid]->length;
-				if (!flist->files[high]->basename) {
+				high = mid - (int)flist->sorted[mid]->len32;
+				if (!F_IS_ACTIVE(flist->sorted[high])) {
 					do {
-					    high -= flist->files[high]->length;
-					} while (!flist->files[high]->basename);
-					flist->files[mid]->length = mid - high;
+					    high -= (int)flist->sorted[high]->len32;
+					} while (!F_IS_ACTIVE(flist->sorted[high]));
+					flist->sorted[mid]->len32 = mid - high;
 				}
 				continue;
 			}
 		}
-		diff = f_name_cmp(flist->files[mid_up], f);
+		diff = f_name_cmp(flist->sorted[mid_up], f);
 		if (diff == 0) {
 			if (protocol_version < 29
-			    && S_ISDIR(flist->files[mid_up]->mode)
+			    && S_ISDIR(flist->sorted[mid_up]->mode)
 			    != S_ISDIR(f->mode))
 				return -1;
 			return mid_up;
 		}
 		if (diff < 0)
 			low = mid_up + 1;
@@ -1468,259 +2283,324 @@
 }
 
 /*
  * Free up any resources a file_struct has allocated
  * and clear the file.
  */
-void clear_file(struct file_struct *file, struct file_list *flist)
+void clear_file(struct file_struct *file)
 {
-	if (flist->hlink_pool && file->link_u.idev)
-		pool_free(flist->hlink_pool, 0, file->link_u.idev);
-	memset(file, 0, file_struct_len);
-	/* In an empty entry, dir.depth is an offset to the next non-empty
-	 * entry.  Likewise for length in the opposite direction.  We assume
+	/* The +1 zeros out the first char of the basename. */
+	memset(file, 0, FILE_STRUCT_LEN + 1);
+	/* In an empty entry, F_DEPTH() is an offset to the next non-empty
+	 * entry.  Likewise for len32 in the opposite direction.  We assume
 	 * that we're alone for now since flist_find() will adjust the counts
 	 * it runs into that aren't up-to-date. */
-	file->length = file->dir.depth = 1;
+	file->len32 = F_DEPTH(file) = 1;
 }
 
-/*
- * allocate a new file list
- */
-struct file_list *flist_new(int with_hlink, char *msg)
+/* Allocate a new file list. */
+struct file_list *flist_new(int flags, char *msg)
 {
 	struct file_list *flist;
 
-	flist = new(struct file_list);
-	if (!flist)
+	if (!(flist = new0(struct file_list)))
 		out_of_memory(msg);
 
-	memset(flist, 0, sizeof (struct file_list));
+	if (flags & FLIST_TEMP) {
+		if (!(flist->file_pool = pool_create(SMALL_EXTENT, 0,
+						out_of_memory, POOL_INTERN)))
+			out_of_memory(msg);
+	} else {
+		/* This is a doubly linked list with prev looping back to
+		 * the end of the list, but the last next pointer is NULL. */
+		if (!first_flist) {
+			flist->file_pool = pool_create(NORMAL_EXTENT, 0,
+						out_of_memory, POOL_INTERN);
+			if (!flist->file_pool)
+				out_of_memory(msg);
 
-	if (!(flist->file_pool = pool_create(FILE_EXTENT, 0,
-	    out_of_memory, POOL_INTERN)))
-		out_of_memory(msg);
+			flist->ndx_start = flist->flist_num = inc_recurse ? 1 : 0;
 
-#ifdef SUPPORT_HARD_LINKS
-	if (with_hlink && preserve_hard_links) {
-		if (!(flist->hlink_pool = pool_create(HLINK_EXTENT,
-		    sizeof (struct idev), out_of_memory, POOL_INTERN)))
-			out_of_memory(msg);
+			first_flist = cur_flist = flist->prev = flist;
+		} else {
+			struct file_list *prev = first_flist->prev;
+
+			flist->file_pool = first_flist->file_pool;
+
+			flist->ndx_start = prev->ndx_start + prev->used + 1;
+			flist->flist_num = prev->flist_num + 1;
+
+			flist->prev = prev;
+			prev->next = first_flist->prev = flist;
+		}
+		flist->pool_boundary = pool_boundary(flist->file_pool, 0);
+		flist_cnt++;
 	}
-#endif
 
 	return flist;
 }
 
-/*
- * free up all elements in a flist
- */
+/* Free up all elements in a flist. */
 void flist_free(struct file_list *flist)
 {
-	pool_destroy(flist->file_pool);
-	pool_destroy(flist->hlink_pool);
+	if (!flist->prev) {
+		/* Was FLIST_TEMP dir-list. */
+	} else if (flist == flist->prev) {
+		first_flist = cur_flist = NULL;
+		file_total = 0;
+		flist_cnt = 0;
+	} else {
+		if (flist == cur_flist)
+			cur_flist = flist->next;
+		if (flist == first_flist)
+			first_flist = first_flist->next;
+		else {
+			flist->prev->next = flist->next;
+			if (!flist->next)
+				flist->next = first_flist;
+		}
+		flist->next->prev = flist->prev;
+		file_total -= flist->used;
+		flist_cnt--;
+	}
+
+	if (!flist->prev || !flist_cnt)
+		pool_destroy(flist->file_pool);
+	else
+		pool_free_old(flist->file_pool, flist->pool_boundary);
+
+	if (flist->sorted && flist->sorted != flist->files)
+		free(flist->sorted);
 	free(flist->files);
 	free(flist);
 }
 
-/*
- * This routine ensures we don't have any duplicate names in our file list.
- * duplicate names can cause corruption because of the pipelining
- */
-static void clean_flist(struct file_list *flist, int strip_root, int no_dups)
+/* This routine ensures we don't have any duplicate names in our file list.
+ * duplicate names can cause corruption because of the pipelining. */
+static void flist_sort_and_clean(struct file_list *flist, int strip_root)
 {
 	char fbuf[MAXPATHLEN];
-	int i, prev_i = 0;
+	int i, prev_i;
 
 	if (!flist)
 		return;
-	if (flist->count == 0) {
+	if (flist->used == 0) {
 		flist->high = -1;
+		flist->low = 0;
 		return;
 	}
 
-	qsort(flist->files, flist->count,
-	    sizeof flist->files[0], (int (*)())file_compare);
+	fsort(flist->sorted, flist->used);
 
-	for (i = no_dups? 0 : flist->count; i < flist->count; i++) {
-		if (flist->files[i]->basename) {
-			prev_i = i;
-			break;
+	if (!am_sender || inc_recurse) {
+		for (i = prev_i = 0; i < flist->used; i++) {
+			if (F_IS_ACTIVE(flist->sorted[i])) {
+				prev_i = i;
+				break;
+			}
 		}
+		flist->low = prev_i;
+	} else {
+		i = prev_i = flist->used - 1;
+		flist->low = 0;
 	}
-	flist->low = prev_i;
-	while (++i < flist->count) {
+
+	while (++i < flist->used) {
 		int j;
-		struct file_struct *file = flist->files[i];
+		struct file_struct *file = flist->sorted[i];
 
-		if (!file->basename)
+		if (!F_IS_ACTIVE(file))
 			continue;
-		if (f_name_cmp(file, flist->files[prev_i]) == 0)
+		if (f_name_cmp(file, flist->sorted[prev_i]) == 0)
 			j = prev_i;
 		else if (protocol_version >= 29 && S_ISDIR(file->mode)) {
 			int save_mode = file->mode;
 			/* Make sure that this directory doesn't duplicate a
 			 * non-directory earlier in the list. */
 			flist->high = prev_i;
 			file->mode = S_IFREG;
 			j = flist_find(flist, file);
 			file->mode = save_mode;
 		} else
 			j = -1;
 		if (j >= 0) {
-			struct file_struct *fp = flist->files[j];
 			int keep, drop;
 			/* If one is a dir and the other is not, we want to
 			 * keep the dir because it might have contents in the
-			 * list. */
-			if (S_ISDIR(file->mode) != S_ISDIR(fp->mode)) {
-				if (S_ISDIR(file->mode))
+			 * list.  Otherwise keep the first one. */
+			if (S_ISDIR(file->mode)) {
+				struct file_struct *fp = flist->sorted[j];
+				if (!S_ISDIR(fp->mode))
 					keep = i, drop = j;
-				else
+				else {
+					if (am_sender)
+						file->flags |= FLAG_DUPLICATE;
+					else { /* Make sure we merge our vital flags. */
+						fp->flags |= file->flags & (FLAG_TOP_DIR|FLAG_CONTENT_DIR);
+						fp->flags &= file->flags | ~FLAG_IMPLIED_DIR;
+					}
 					keep = j, drop = i;
+				}
 			} else
 				keep = j, drop = i;
-			if (verbose > 1 && !am_server) {
-				rprintf(FINFO,
-					"removing duplicate name %s from file list (%d)\n",
-					f_name(file, fbuf), drop);
-			}
-			/* Make sure we don't lose track of a user-specified
-			 * top directory. */
-			flist->files[keep]->flags |= flist->files[drop]->flags
-						   & (FLAG_TOP_DIR|FLAG_DEL_HERE);
 
-			clear_file(flist->files[drop], flist);
+			if (!am_sender) {
+				if (verbose > 1) {
+					rprintf(FINFO,
+					    "removing duplicate name %s from file list (%d)\n",
+					    f_name(file, fbuf), drop + flist->ndx_start);
+				}
+				clear_file(flist->sorted[drop]);
+			}
 
 			if (keep == i) {
 				if (flist->low == drop) {
 					for (j = drop + 1;
-					     j < i && !flist->files[j]->basename;
+					     j < i && !F_IS_ACTIVE(flist->sorted[j]);
 					     j++) {}
 					flist->low = j;
 				}
 				prev_i = i;
 			}
 		} else
 			prev_i = i;
 	}
-	flist->high = no_dups ? prev_i : flist->count - 1;
+	flist->high = prev_i;
 
 	if (strip_root) {
 		/* We need to strip off the leading slashes for relative
 		 * paths, but this must be done _after_ the sorting phase. */
 		for (i = flist->low; i <= flist->high; i++) {
-			struct file_struct *file = flist->files[i];
+			struct file_struct *file = flist->sorted[i];
 
 			if (!file->dirname)
 				continue;
 			while (*file->dirname == '/')
 				file->dirname++;
 			if (!*file->dirname)
 				file->dirname = NULL;
 		}
 	}
 
-	if (prune_empty_dirs && no_dups) {
+	if (prune_empty_dirs && !am_sender) {
 		int j, prev_depth = 0;
 
 		prev_i = 0; /* It's OK that this isn't really true. */
 
 		for (i = flist->low; i <= flist->high; i++) {
-			struct file_struct *fp, *file = flist->files[i];
+			struct file_struct *fp, *file = flist->sorted[i];
 
-			/* This temporarily abuses the dir.depth value for a
+			/* This temporarily abuses the F_DEPTH() value for a
 			 * directory that is in a chain that might get pruned.
 			 * We restore the old value if it gets a reprieve. */
-			if (S_ISDIR(file->mode) && file->dir.depth) {
+			if (S_ISDIR(file->mode) && F_DEPTH(file)) {
 				/* Dump empty dirs when coming back down. */
-				for (j = prev_depth; j >= file->dir.depth; j--) {
-					fp = flist->files[prev_i];
-					if (fp->dir.depth >= 0)
+				for (j = prev_depth; j >= F_DEPTH(file); j--) {
+					fp = flist->sorted[prev_i];
+					if (F_DEPTH(fp) >= 0)
 						break;
-					prev_i = -fp->dir.depth-1;
-					clear_file(fp, flist);
+					prev_i = -F_DEPTH(fp)-1;
+					clear_file(fp);
 				}
-				prev_depth = file->dir.depth;
+				prev_depth = F_DEPTH(file);
 				if (is_excluded(f_name(file, fbuf), 1,
 						       ALL_FILTERS)) {
 					/* Keep dirs through this dir. */
 					for (j = prev_depth-1; ; j--) {
-						fp = flist->files[prev_i];
-						if (fp->dir.depth >= 0)
+						fp = flist->sorted[prev_i];
+						if (F_DEPTH(fp) >= 0)
 							break;
-						prev_i = -fp->dir.depth-1;
-						fp->dir.depth = j;
+						prev_i = -F_DEPTH(fp)-1;
+						F_DEPTH(fp) = j;
 					}
 				} else
-					file->dir.depth = -prev_i-1;
+					F_DEPTH(file) = -prev_i-1;
 				prev_i = i;
 			} else {
 				/* Keep dirs through this non-dir. */
 				for (j = prev_depth; ; j--) {
-					fp = flist->files[prev_i];
-					if (fp->dir.depth >= 0)
+					fp = flist->sorted[prev_i];
+					if (F_DEPTH(fp) >= 0)
 						break;
-					prev_i = -fp->dir.depth-1;
-					fp->dir.depth = j;
+					prev_i = -F_DEPTH(fp)-1;
+					F_DEPTH(fp) = j;
 				}
 			}
 		}
-		/* Dump empty all remaining empty dirs. */
+		/* Dump all remaining empty dirs. */
 		while (1) {
-			struct file_struct *fp = flist->files[prev_i];
-			if (fp->dir.depth >= 0)
+			struct file_struct *fp = flist->sorted[prev_i];
+			if (F_DEPTH(fp) >= 0)
 				break;
-			prev_i = -fp->dir.depth-1;
-			clear_file(fp, flist);
+			prev_i = -F_DEPTH(fp)-1;
+			clear_file(fp);
 		}
 
 		for (i = flist->low; i <= flist->high; i++) {
-			if (flist->files[i]->basename)
+			if (F_IS_ACTIVE(flist->sorted[i]))
 				break;
 		}
 		flist->low = i;
 		for (i = flist->high; i >= flist->low; i--) {
-			if (flist->files[i]->basename)
+			if (F_IS_ACTIVE(flist->sorted[i]))
 				break;
 		}
 		flist->high = i;
 	}
 }
 
 static void output_flist(struct file_list *flist)
 {
 	char uidbuf[16], gidbuf[16], depthbuf[16];
 	struct file_struct *file;
+	const char *root, *dir, *slash, *name, *trail;
 	const char *who = who_am_i();
 	int i;
 
-	for (i = 0; i < flist->count; i++) {
+	rprintf(FINFO, "[%s] flist start=%d, used=%d, low=%d, high=%d\n",
+		who, flist->ndx_start, flist->used, flist->low, flist->high);
+	for (i = 0; i < flist->used; i++) {
 		file = flist->files[i];
-		if ((am_root || am_sender) && preserve_uid)
-			snprintf(uidbuf, sizeof uidbuf, " uid=%ld", (long)file->uid);
-		else
+		if ((am_root || am_sender) && uid_ndx) {
+			snprintf(uidbuf, sizeof uidbuf, " uid=%u",
+				 F_OWNER(file));
+		} else
 			*uidbuf = '\0';
-		if (preserve_gid && file->gid != GID_NONE)
-			snprintf(gidbuf, sizeof gidbuf, " gid=%ld", (long)file->gid);
-		else
+		if (gid_ndx) {
+			static char parens[] = "(\0)\0\0\0";
+			char *pp = parens + (file->flags & FLAG_SKIP_GROUP ? 0 : 3);
+			snprintf(gidbuf, sizeof gidbuf, " gid=%s%u%s",
+				 pp, F_GROUP(file), pp + 2);
+		} else
 			*gidbuf = '\0';
 		if (!am_sender)
-			snprintf(depthbuf, sizeof depthbuf, "%d", file->dir.depth);
-		rprintf(FINFO, "[%s] i=%d %s %s%s%s%s mode=0%o len=%.0f%s%s flags=%x\n",
-			who, i, am_sender ? NS(file->dir.root) : depthbuf,
-			file->dirname ? file->dirname : "",
-			file->dirname ? "/" : "", NS(file->basename),
-			S_ISDIR(file->mode) ? "/" : "", (int)file->mode,
-			(double)file->length, uidbuf, gidbuf, file->flags);
+			snprintf(depthbuf, sizeof depthbuf, "%d", F_DEPTH(file));
+		if (F_IS_ACTIVE(file)) {
+			root = am_sender ? NS(F_PATHNAME(file)) : depthbuf;
+			if ((dir = file->dirname) == NULL)
+				dir = slash = "";
+			else
+				slash = "/";
+			name = file->basename;
+			trail = S_ISDIR(file->mode) ? "/" : "";
+		} else
+			root = dir = slash = name = trail = "";
+		rprintf(FINFO,
+			"[%s] i=%d %s %s%s%s%s mode=0%o len=%.0f%s%s flags=%x\n",
+			who, i + flist->ndx_start,
+			root, dir, slash, name, trail,
+			(int)file->mode, (double)F_LENGTH(file),
+			uidbuf, gidbuf, file->flags);
 	}
 }
 
 enum fnc_state { s_DIR, s_SLASH, s_BASE, s_TRAILING };
 enum fnc_type { t_PATH, t_ITEM };
 
+static int found_prefix;
+
 /* Compare the names of two file_struct entities, similar to how strcmp()
  * would do if it were operating on the joined strings.
  *
  * Some differences beginning with protocol_version 29: (1) directory names
  * are compared with an assumed trailing slash so that they compare in a
  * way that would cause them to sort immediately prior to any content they
@@ -1730,48 +2610,48 @@
  * with the same name will not compare as equal (protocol_version >= 29).
  *
  * The dirname component can be an empty string, but the basename component
  * cannot (and never is in the current codebase).  The basename component
  * may be NULL (for a removed item), in which case it is considered to be
  * after any existing item. */
-int f_name_cmp(struct file_struct *f1, struct file_struct *f2)
+int f_name_cmp(const struct file_struct *f1, const struct file_struct *f2)
 {
 	int dif;
 	const uchar *c1, *c2;
 	enum fnc_state state1, state2;
 	enum fnc_type type1, type2;
 	enum fnc_type t_path = protocol_version >= 29 ? t_PATH : t_ITEM;
 
-	if (!f1 || !f1->basename) {
-		if (!f2 || !f2->basename)
+	if (!f1 || !F_IS_ACTIVE(f1)) {
+		if (!f2 || !F_IS_ACTIVE(f2))
 			return 0;
 		return -1;
 	}
-	if (!f2 || !f2->basename)
+	if (!f2 || !F_IS_ACTIVE(f2))
 		return 1;
 
 	c1 = (uchar*)f1->dirname;
 	c2 = (uchar*)f2->dirname;
 	if (c1 == c2)
 		c1 = c2 = NULL;
 	if (!c1) {
 		type1 = S_ISDIR(f1->mode) ? t_path : t_ITEM;
-		c1 = (uchar*)f1->basename;
+		c1 = (const uchar*)f1->basename;
 		if (type1 == t_PATH && *c1 == '.' && !c1[1]) {
 			type1 = t_ITEM;
 			state1 = s_TRAILING;
 			c1 = (uchar*)"";
 		} else
 			state1 = s_BASE;
 	} else {
 		type1 = t_path;
 		state1 = s_DIR;
 	}
 	if (!c2) {
 		type2 = S_ISDIR(f2->mode) ? t_path : t_ITEM;
-		c2 = (uchar*)f2->basename;
+		c2 = (const uchar*)f2->basename;
 		if (type2 == t_PATH && *c2 == '.' && !c2[1]) {
 			type2 = t_ITEM;
 			state2 = s_TRAILING;
 			c2 = (uchar*)"";
 		} else
 			state2 = s_BASE;
@@ -1789,13 +2669,13 @@
 			case s_DIR:
 				state1 = s_SLASH;
 				c1 = (uchar*)"/";
 				break;
 			case s_SLASH:
 				type1 = S_ISDIR(f1->mode) ? t_path : t_ITEM;
-				c1 = (uchar*)f1->basename;
+				c1 = (const uchar*)f1->basename;
 				if (type1 == t_PATH && *c1 == '.' && !c1[1]) {
 					type1 = t_ITEM;
 					state1 = s_TRAILING;
 					c1 = (uchar*)"";
 				} else
 					state1 = s_BASE;
@@ -1819,13 +2699,13 @@
 			case s_DIR:
 				state2 = s_SLASH;
 				c2 = (uchar*)"/";
 				break;
 			case s_SLASH:
 				type2 = S_ISDIR(f2->mode) ? t_path : t_ITEM;
-				c2 = (uchar*)f2->basename;
+				c2 = (const uchar*)f2->basename;
 				if (type2 == t_PATH && *c2 == '.' && !c2[1]) {
 					type2 = t_ITEM;
 					state2 = s_TRAILING;
 					c2 = (uchar*)"";
 				} else
 					state2 = s_BASE;
@@ -1835,12 +2715,13 @@
 				if (type2 == t_PATH) {
 					c2 = (uchar*)"/";
 					break;
 				}
 				/* FALL THROUGH */
 			case s_TRAILING:
+				found_prefix = 1;
 				if (!*c1)
 					return 0;
 				type2 = t_ITEM;
 				break;
 			}
 			if (type1 != type2)
@@ -1848,29 +2729,43 @@
 		}
 	} while ((dif = (int)*c1++ - (int)*c2++) == 0);
 
 	return dif;
 }
 
+/* Returns 1 if f1's filename has all of f2's filename as a prefix.  This does
+ * not match if f2's basename is not an exact match of a path element in f1.
+ * E.g. /path/foo is not a prefix of /path/foobar/baz, but /path/foobar is. */
+int f_name_has_prefix(const struct file_struct *f1, const struct file_struct *f2)
+{
+	found_prefix = 0;
+	f_name_cmp(f1, f2);
+	return found_prefix;
+}
+
+char *f_name_buf(void)
+{
+	static char names[5][MAXPATHLEN];
+	static unsigned int n;
+
+	n = (n + 1) % (sizeof names / sizeof names[0]);
+
+	return names[n];
+}
+
 /* Return a copy of the full filename of a flist entry, using the indicated
  * buffer or one of 5 static buffers if fbuf is NULL.  No size-checking is
  * done because we checked the size when creating the file_struct entry.
  */
-char *f_name(struct file_struct *f, char *fbuf)
+char *f_name(const struct file_struct *f, char *fbuf)
 {
-	if (!f || !f->basename)
+	if (!f || !F_IS_ACTIVE(f))
 		return NULL;
 
-	if (!fbuf) {
-		static char names[5][MAXPATHLEN];
-		static unsigned int n;
-
-		n = (n + 1) % (sizeof names / sizeof names[0]);
-
-		fbuf = names[n];
-	}
+	if (!fbuf)
+		fbuf = f_name_buf();
 
 	if (f->dirname) {
 		int len = strlen(f->dirname);
 		memcpy(fbuf, f->dirname, len);
 		fbuf[len] = '/';
 		strlcpy(fbuf + len + 1, f->basename, MAXPATHLEN - (len + 1));
@@ -1882,38 +2777,41 @@
 
 /* Do a non-recursive scan of the named directory, possibly ignoring all
  * exclude rules except for the daemon's.  If "dlen" is >=0, it is the length
  * of the dirname string, and also indicates that "dirname" is a MAXPATHLEN
  * buffer (the functions we call will append names onto the end, but the old
  * dir value will be restored on exit). */
-struct file_list *get_dirlist(char *dirname, int dlen,
-			      int ignore_filter_rules)
+struct file_list *get_dirlist(char *dirname, int dlen, int ignore_filter_rules)
 {
 	struct file_list *dirlist;
 	char dirbuf[MAXPATHLEN];
 	int save_recurse = recurse;
 	int save_xfer_dirs = xfer_dirs;
+	int save_prune_empty_dirs = prune_empty_dirs;
 
 	if (dlen < 0) {
 		dlen = strlcpy(dirbuf, dirname, MAXPATHLEN);
 		if (dlen >= MAXPATHLEN)
 			return NULL;
 		dirname = dirbuf;
 	}
 
-	dirlist = flist_new(WITHOUT_HLINK, "get_dirlist");
+	dirlist = flist_new(FLIST_TEMP, "get_dirlist");
 
 	recurse = 0;
 	xfer_dirs = 1;
-	send_directory(ignore_filter_rules ? -2 : -1, dirlist, dirname, dlen);
+	send_directory(ignore_filter_rules ? -2 : -1, dirlist, dirname, dlen, 0);
 	xfer_dirs = save_xfer_dirs;
 	recurse = save_recurse;
 	if (do_progress)
-		flist_count_offset += dirlist->count;
+		flist_count_offset += dirlist->used;
 
-	clean_flist(dirlist, 0, 0);
+	prune_empty_dirs = 0;
+	dirlist->sorted = dirlist->files;
+	flist_sort_and_clean(dirlist, 0);
+	prune_empty_dirs = save_prune_empty_dirs;
 
 	if (verbose > 3)
 		output_flist(dirlist);
 
 	return dirlist;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/generator.c	2006-10-23 06:36:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/generator.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,57 +1,60 @@
 /*
  * Routines that are exclusive to the generator process.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
 extern int do_xfers;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
+extern int receiver_symlink_times;
 extern int am_root;
 extern int am_server;
 extern int am_daemon;
+extern int inc_recurse;
 extern int do_progress;
 extern int relative_paths;
 extern int implied_dirs;
 extern int keep_dirlinks;
+extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_links;
 extern int preserve_devices;
 extern int preserve_specials;
 extern int preserve_hard_links;
+extern int preserve_executability;
 extern int preserve_perms;
-extern int preserve_uid;
-extern int preserve_gid;
 extern int preserve_times;
-extern int omit_dir_times;
+extern int uid_ndx;
+extern int gid_ndx;
 extern int delete_mode;
 extern int delete_before;
 extern int delete_during;
 extern int delete_after;
-extern int module_id;
+extern int msgdone_cnt;
 extern int ignore_errors;
 extern int remove_source_files;
 extern int delay_updates;
 extern int update_only;
 extern int ignore_existing;
 extern int ignore_non_existing;
@@ -61,338 +64,653 @@
 extern int csum_length;
 extern int ignore_times;
 extern int size_only;
 extern OFF_T max_size;
 extern OFF_T min_size;
 extern int io_error;
+extern int flist_eof;
 extern int allowed_lull;
 extern int sock_f_out;
 extern int ignore_timeout;
 extern int protocol_version;
+extern int file_total;
 extern int fuzzy_basis;
 extern int always_checksum;
 extern int checksum_len;
 extern char *partial_dir;
 extern char *basis_dir[];
 extern int compare_dest;
 extern int copy_dest;
 extern int link_dest;
 extern int whole_file;
 extern int list_only;
-extern int new_root_dir;
 extern int read_batch;
 extern int safe_symlinks;
 extern long block_size; /* "long" because popt can't set an int32. */
+extern int unsort_ndx;
 extern int max_delete;
 extern int force_delete;
 extern int one_file_system;
 extern struct stats stats;
 extern dev_t filesystem_dev;
+extern mode_t orig_umask;
+extern uid_t our_uid;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
-extern struct file_list *the_file_list;
+extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct filter_list_struct server_filter_list;
 
-static int deletion_count = 0; /* used to implement --max-delete */
+int ignore_perishable = 0;
+int non_perishable_cnt = 0;
+int maybe_ATTRS_REPORT = 0;
 
-/* For calling delete_file() */
-#define DEL_FORCE_RECURSE	(1<<1) /* recurse even w/o --force */
-#define DEL_TERSE		(1<<3)
+static dev_t dev_zero;
+static int deletion_count = 0; /* used to implement --max-delete */
+static int deldelay_size = 0, deldelay_cnt = 0;
+static char *deldelay_buf = NULL;
+static int deldelay_fd = -1;
+static int lull_mod;
+static int dir_tweaking;
+static int need_retouch_dir_times;
+static int need_retouch_dir_perms;
+static const char *solo_file = NULL;
+
+/* For calling delete_item() and delete_dir_contents(). */
+#define DEL_NO_UID_WRITE 	(1<<0) /* file/dir has our uid w/o write perm */
+#define DEL_RECURSE		(1<<1) /* if dir, delete all contents */
+#define DEL_DIR_IS_EMPTY	(1<<2) /* internal delete_FUNCTIONS use only */
+#define DEL_FOR_FILE		(1<<3) /* making room for a replacement file */
+#define DEL_FOR_DIR		(1<<4) /* making room for a replacement dir */
+#define DEL_FOR_SYMLINK 	(1<<5) /* making room for a replacement symlink */
+#define DEL_FOR_DEVICE		(1<<6) /* making room for a replacement device */
+#define DEL_FOR_SPECIAL 	(1<<7) /* making room for a replacement special */
+
+#define DEL_MAKE_ROOM (DEL_FOR_FILE|DEL_FOR_DIR|DEL_FOR_SYMLINK|DEL_FOR_DEVICE|DEL_FOR_SPECIAL)
+
+enum nonregtype {
+    TYPE_DIR, TYPE_SPECIAL, TYPE_DEVICE, TYPE_SYMLINK
+};
+
+enum delret {
+    DR_SUCCESS = 0, DR_FAILURE, DR_AT_LIMIT, DR_NOT_EMPTY
+};
 
+/* Forward declaration for delete_item(). */
+static enum delret delete_dir_contents(char *fname, uint16 flags);
 
 static int is_backup_file(char *fn)
 {
 	int k = strlen(fn) - backup_suffix_len;
 	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
 }
 
-
-/* Delete a file or directory.  If DEL_FORCE_RECURSE is set in the flags, or if
- * force_delete is set, this will delete recursively.
+/* Delete a file or directory.  If DEL_RECURSE is set in the flags, this will
+ * delete recursively.
  *
- * Note that fname must point to a MAXPATHLEN buffer if the mode indicates it's
+ * Note that fbuf must point to a MAXPATHLEN buffer if the mode indicates it's
  * a directory! (The buffer is used for recursion, but returned unchanged.)
  */
-static int delete_item(char *fname, int mode, int flags)
+static enum delret delete_item(char *fbuf, uint16 mode, uint16 flags)
 {
-	struct file_list *dirlist;
-	int j, dlen, zap_dir, ok;
-	unsigned remainder;
-	void *save_filters;
-	char *p;
+	enum delret ret;
+	char *what;
+	int ok;
 
-	if (!S_ISDIR(mode)) {
-		if (max_delete && ++deletion_count > max_delete)
-			return 0;
-		if (make_backups && (backup_dir || !is_backup_file(fname)))
-			ok = make_backup(fname);
-		else
-			ok = robust_unlink(fname) == 0;
-		if (ok) {
-			if (!(flags & DEL_TERSE))
-				log_delete(fname, mode);
-			return 0;
-		}
-		if (errno == ENOENT) {
-			deletion_count--;
-			return 0;
-		}
-		rsyserr(FERROR, errno, "delete_file: unlink %s failed",
-			full_fname(fname));
-		return -1;
+	if (verbose > 2) {
+		rprintf(FINFO, "delete_item(%s) mode=%o flags=%d\n",
+			fbuf, (int)mode, (int)flags);
+	}
+
+	if (flags & DEL_NO_UID_WRITE)
+		do_chmod(fbuf, mode | S_IWUSR);
+
+	if (S_ISDIR(mode) && !(flags & DEL_DIR_IS_EMPTY)) {
+		int save_uid_ndx = uid_ndx;
+		/* This only happens on the first call to delete_item() since
+		 * delete_dir_contents() always calls us w/DEL_DIR_IS_EMPTY. */
+		if (!uid_ndx)
+			uid_ndx = ++file_extra_cnt;
+		ignore_perishable = 1;
+		/* If DEL_RECURSE is not set, this just reports emptiness. */
+		ret = delete_dir_contents(fbuf, flags);
+		ignore_perishable = 0;
+		if (!save_uid_ndx) {
+			--file_extra_cnt;
+			uid_ndx = 0;
+		}
+		if (ret == DR_NOT_EMPTY || ret == DR_AT_LIMIT)
+			goto check_ret;
+		/* OK: try to delete the directory. */
+	}
+
+	if (!(flags & DEL_MAKE_ROOM) && max_delete >= 0 && ++deletion_count > max_delete)
+		return DR_AT_LIMIT;
+
+	if (S_ISDIR(mode)) {
+		what = "rmdir";
+		ok = do_rmdir(fbuf) == 0;
+	} else if (make_backups > 0 && (backup_dir || !is_backup_file(fbuf))) {
+		what = "make_backup";
+		ok = make_backup(fbuf);
+	} else {
+		what = "unlink";
+		ok = robust_unlink(fbuf) == 0;
 	}
 
-	zap_dir = flags & DEL_FORCE_RECURSE || force_delete;
-	if ((max_delete && ++deletion_count > max_delete)
-	    || (dry_run && zap_dir)) {
-		ok = 0;
-		errno = ENOTEMPTY;
-	} else if (make_backups && !backup_dir && !is_backup_file(fname)
-	    && !(flags & DEL_FORCE_RECURSE))
-		ok = make_backup(fname);
-	else
-		ok = do_rmdir(fname) == 0;
 	if (ok) {
-		if (!(flags & DEL_TERSE))
-			log_delete(fname, mode);
-		return 0;
+		if (!(flags & DEL_MAKE_ROOM))
+			log_delete(fbuf, mode);
+		ret = DR_SUCCESS;
+	} else {
+		if (S_ISDIR(mode) && errno == ENOTEMPTY) {
+			rprintf(FINFO, "cannot delete non-empty directory: %s\n",
+				fbuf);
+			ret = DR_NOT_EMPTY;
+		} else if (errno != ENOENT) {
+			rsyserr(FERROR, errno, "delete_file: %s(%s) failed",
+				what, fbuf);
+			ret = DR_FAILURE;
+		} else {
+			deletion_count--;
+			ret = DR_SUCCESS;
+		}
 	}
-	if (errno == ENOENT) {
-		deletion_count--;
-		return 0;
+
+  check_ret:
+	if (ret != DR_SUCCESS && flags & DEL_MAKE_ROOM) {
+		const char *desc;
+		switch (flags & DEL_MAKE_ROOM) {
+		case DEL_FOR_FILE: desc = "regular file"; break;
+		case DEL_FOR_DIR: desc = "directory"; break;
+		case DEL_FOR_SYMLINK: desc = "symlink"; break;
+		case DEL_FOR_DEVICE: desc = "device file"; break;
+		case DEL_FOR_SPECIAL: desc = "special file"; break;
+		default: exit_cleanup(RERR_UNSUPPORTED); /* IMPOSSIBLE */
+		}
+		rprintf(FERROR_XFER, "could not make way for new %s: %s\n",
+			desc, fbuf);
 	}
-	if (!zap_dir) {
-		rsyserr(FERROR, errno, "delete_file: rmdir %s failed",
-			full_fname(fname));
-		return -1;
+	return ret;
+}
+
+/* The directory is about to be deleted: if DEL_RECURSE is given, delete all
+ * its contents, otherwise just checks for content.  Returns DR_SUCCESS or
+ * DR_NOT_EMPTY.  Note that fname must point to a MAXPATHLEN buffer!  (The
+ * buffer is used for recursion, but returned unchanged.)
+ */
+static enum delret delete_dir_contents(char *fname, uint16 flags)
+{
+	struct file_list *dirlist;
+	enum delret ret;
+	unsigned remainder;
+	void *save_filters;
+	int j, dlen;
+	char *p;
+
+	if (verbose > 3) {
+		rprintf(FINFO, "delete_dir_contents(%s) flags=%d\n",
+			fname, flags);
 	}
-	flags |= DEL_FORCE_RECURSE; /* mark subdir dels as not "in the way" */
-	deletion_count--;
 
 	dlen = strlen(fname);
 	save_filters = push_local_filters(fname, dlen);
 
+	non_perishable_cnt = 0;
 	dirlist = get_dirlist(fname, dlen, 0);
+	ret = non_perishable_cnt ? DR_NOT_EMPTY : DR_SUCCESS;
+
+	if (!dirlist->used)
+		goto done;
+
+	if (!(flags & DEL_RECURSE)) {
+		ret = DR_NOT_EMPTY;
+		goto done;
+	}
 
 	p = fname + dlen;
 	if (dlen != 1 || *fname != '/')
 		*p++ = '/';
 	remainder = MAXPATHLEN - (p - fname);
 
-	for (j = dirlist->count; j--; ) {
+	/* We do our own recursion, so make delete_item() non-recursive. */
+	flags = (flags & ~(DEL_RECURSE|DEL_MAKE_ROOM|DEL_NO_UID_WRITE))
+	      | DEL_DIR_IS_EMPTY;
+
+	for (j = dirlist->used; j--; ) {
 		struct file_struct *fp = dirlist->files[j];
 
-		if (fp->flags & FLAG_MOUNT_POINT)
+		if (fp->flags & FLAG_MOUNT_DIR) {
+			if (verbose > 1) {
+				rprintf(FINFO,
+				    "mount point, %s, pins parent directory\n",
+				    f_name(fp, NULL));
+			}
+			ret = DR_NOT_EMPTY;
 			continue;
+		}
 
 		strlcpy(p, fp->basename, remainder);
-		delete_item(fname, fp->mode, flags & ~DEL_TERSE);
+		if (!(fp->mode & S_IWUSR) && !am_root && (uid_t)F_OWNER(fp) == our_uid)
+			do_chmod(fname, fp->mode | S_IWUSR);
+		/* Save stack by recursing to ourself directly. */
+		if (S_ISDIR(fp->mode)) {
+			if (delete_dir_contents(fname, flags | DEL_RECURSE) != DR_SUCCESS)
+				ret = DR_NOT_EMPTY;
+		}
+		if (delete_item(fname, fp->mode, flags) != DR_SUCCESS)
+			ret = DR_NOT_EMPTY;
 	}
-	flist_free(dirlist);
 
 	fname[dlen] = '\0';
 
+  done:
+	flist_free(dirlist);
 	pop_local_filters(save_filters);
 
-	if (max_delete && ++deletion_count > max_delete)
+	if (ret == DR_NOT_EMPTY) {
+		rprintf(FINFO, "cannot delete non-empty directory: %s\n",
+			fname);
+	}
+	return ret;
+}
+
+static int start_delete_delay_temp(void)
+{
+	char fnametmp[MAXPATHLEN];
+	int save_dry_run = dry_run;
+
+	dry_run = 0;
+	if (!get_tmpname(fnametmp, "deldelay")
+	 || (deldelay_fd = do_mkstemp(fnametmp, 0600)) < 0) {
+		rprintf(FINFO, "NOTE: Unable to create delete-delay temp file%s.\n",
+			inc_recurse ? "" : " -- switching to --delete-after");
+		delete_during = 0;
+		delete_after = !inc_recurse;
+		dry_run = save_dry_run;
 		return 0;
+	}
+	unlink(fnametmp);
+	dry_run = save_dry_run;
+	return 1;
+}
 
-	if (do_rmdir(fname) == 0) {
-		if (!(flags & DEL_TERSE))
-			log_delete(fname, mode);
-	} else if (errno != ENOTEMPTY && errno != EEXIST && errno != ENOENT) {
-		rsyserr(FERROR, errno, "delete_file: rmdir %s failed",
-			full_fname(fname));
+static int flush_delete_delay(void)
+{
+	if (deldelay_fd < 0 && !start_delete_delay_temp())
+		return 0;
+	if (write(deldelay_fd, deldelay_buf, deldelay_cnt) != deldelay_cnt) {
+		rsyserr(FERROR, errno, "flush of delete-delay buffer");
+		delete_during = 0;
+		delete_after = !inc_recurse;
+		close(deldelay_fd);
+		return 0;
+	}
+	deldelay_cnt = 0;
+	return 1;
+}
+
+static int remember_delete(struct file_struct *file, const char *fname, int flags)
+{
+	int len;
+
+	if (deldelay_cnt == deldelay_size && !flush_delete_delay())
+		return 0;
+
+	if (flags & DEL_NO_UID_WRITE)
+		deldelay_buf[deldelay_cnt++] = '!';
+
+	while (1) {
+		len = snprintf(deldelay_buf + deldelay_cnt,
+			       deldelay_size - deldelay_cnt,
+			       "%x %s%c",
+			       (int)file->mode, fname, '\0');
+		if ((deldelay_cnt += len) <= deldelay_size)
+			break;
+		deldelay_cnt -= len;
+		if (!flush_delete_delay())
+			return 0;
+	}
+
+	return 1;
+}
+
+static int read_delay_line(char *buf, int *flags_p)
+{
+	static int read_pos = 0;
+	int j, len, mode;
+	char *bp, *past_space;
+
+	while (1) {
+		for (j = read_pos; j < deldelay_cnt && deldelay_buf[j]; j++) {}
+		if (j < deldelay_cnt)
+			break;
+		if (deldelay_fd < 0) {
+			if (j > read_pos)
+				goto invalid_data;
+			return -1;
+		}
+		deldelay_cnt -= read_pos;
+		if (deldelay_cnt == deldelay_size)
+			goto invalid_data;
+		if (deldelay_cnt && read_pos) {
+			memmove(deldelay_buf, deldelay_buf + read_pos,
+				deldelay_cnt);
+		}
+		len = read(deldelay_fd, deldelay_buf + deldelay_cnt,
+			   deldelay_size - deldelay_cnt);
+		if (len == 0) {
+			if (deldelay_cnt) {
+				rprintf(FERROR,
+				    "ERROR: unexpected EOF in delete-delay file.\n");
+			}
+			return -1;
+		}
+		if (len < 0) {
+			rsyserr(FERROR, errno,
+				"reading delete-delay file");
+			return -1;
+		}
+		deldelay_cnt += len;
+		read_pos = 0;
+	}
+
+	bp = deldelay_buf + read_pos;
+	if (*bp == '!') {
+		bp++;
+		*flags_p = DEL_NO_UID_WRITE;
+	} else
+		*flags_p = 0;
+
+	if (sscanf(bp, "%x ", &mode) != 1) {
+	  invalid_data:
+		rprintf(FERROR, "ERROR: invalid data in delete-delay file.\n");
+		return -1;
+	}
+	past_space = strchr(bp, ' ') + 1;
+	len = j - read_pos - (past_space - bp) + 1; /* count the '\0' */
+	read_pos = j + 1;
+
+	if (len > MAXPATHLEN) {
+		rprintf(FERROR, "ERROR: filename too long in delete-delay file.\n");
 		return -1;
 	}
 
-	return 0;
+	/* The caller needs the name in a MAXPATHLEN buffer, so we copy it
+	 * instead of returning a pointer to our buffer. */
+	memcpy(buf, past_space, len);
+
+	return mode;
 }
 
+static void do_delayed_deletions(char *delbuf)
+{
+	int mode, flags;
+
+	if (deldelay_fd >= 0) {
+		if (deldelay_cnt && !flush_delete_delay())
+			return;
+		lseek(deldelay_fd, 0, 0);
+	}
+	while ((mode = read_delay_line(delbuf, &flags)) >= 0)
+		delete_item(delbuf, mode, flags | DEL_RECURSE);
+	if (deldelay_fd >= 0)
+		close(deldelay_fd);
+}
 
 /* This function is used to implement per-directory deletion, and is used by
  * all the --delete-WHEN options.  Note that the fbuf pointer must point to a
  * MAXPATHLEN buffer with the name of the directory in it (the functions we
  * call will append names onto the end, but the old dir value will be restored
  * on exit). */
-static void delete_in_dir(struct file_list *flist, char *fbuf,
-			  struct file_struct *file, STRUCT_STAT *stp)
+static void delete_in_dir(char *fbuf, struct file_struct *file, dev_t *fs_dev)
 {
-	static int min_depth = MAXPATHLEN, cur_depth = -1;
-	static void *filt_array[MAXPATHLEN/2+1];
 	static int already_warned = 0;
 	struct file_list *dirlist;
 	char delbuf[MAXPATHLEN];
 	int dlen, i;
+	int save_uid_ndx = uid_ndx;
 
-	if (!flist) {
-		while (cur_depth >= min_depth)
-			pop_local_filters(filt_array[cur_depth--]);
-		min_depth = MAXPATHLEN;
-		cur_depth = -1;
+	if (!fbuf) {
+		change_local_filter_dir(NULL, 0, 0);
 		return;
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO, "delete_in_dir(%s)\n", fbuf);
 
 	if (allowed_lull)
 		maybe_send_keepalive();
 
-	if (file->dir.depth >= MAXPATHLEN/2+1)
-		return; /* Impossible... */
-
-	if (io_error && !(lp_ignore_errors(module_id) || ignore_errors)) {
+	if (io_error && !ignore_errors) {
 		if (already_warned)
 			return;
 		rprintf(FINFO,
 			"IO error encountered -- skipping file deletion\n");
 		already_warned = 1;
 		return;
 	}
 
-	while (cur_depth >= file->dir.depth && cur_depth >= min_depth)
-		pop_local_filters(filt_array[cur_depth--]);
-	cur_depth = file->dir.depth;
-	if (min_depth > cur_depth)
-		min_depth = cur_depth;
 	dlen = strlen(fbuf);
-	filt_array[cur_depth] = push_local_filters(fbuf, dlen);
+	change_local_filter_dir(fbuf, dlen, F_DEPTH(file));
 
 	if (one_file_system) {
 		if (file->flags & FLAG_TOP_DIR)
-			filesystem_dev = stp->st_dev;
-		else if (filesystem_dev != stp->st_dev)
+			filesystem_dev = *fs_dev;
+		else if (filesystem_dev != *fs_dev)
 			return;
 	}
 
+	if (!uid_ndx)
+		uid_ndx = ++file_extra_cnt;
+
 	dirlist = get_dirlist(fbuf, dlen, 0);
 
 	/* If an item in dirlist is not found in flist, delete it
 	 * from the filesystem. */
-	for (i = dirlist->count; i--; ) {
+	for (i = dirlist->used; i--; ) {
 		struct file_struct *fp = dirlist->files[i];
-		if (!fp->basename || fp->flags & FLAG_MOUNT_POINT)
+		if (!F_IS_ACTIVE(fp))
 			continue;
-		if (flist_find(flist, fp) < 0) {
+		if (fp->flags & FLAG_MOUNT_DIR) {
+			if (verbose > 1)
+				rprintf(FINFO, "cannot delete mount point: %s\n",
+					f_name(fp, NULL));
+			continue;
+		}
+		if (flist_find(cur_flist, fp) < 0) {
+			int flags = DEL_RECURSE;
+			if (!(fp->mode & S_IWUSR) && !am_root && (uid_t)F_OWNER(fp) == our_uid)
+				flags |= DEL_NO_UID_WRITE;
 			f_name(fp, delbuf);
-			delete_item(delbuf, fp->mode, DEL_FORCE_RECURSE);
+			if (delete_during == 2) {
+				if (!remember_delete(fp, delbuf, flags))
+					break;
+			} else
+				delete_item(delbuf, fp->mode, flags);
 		}
 	}
 
 	flist_free(dirlist);
+
+	if (!save_uid_ndx) {
+		--file_extra_cnt;
+		uid_ndx = 0;
+	}
 }
 
 /* This deletes any files on the receiving side that are not present on the
  * sending side.  This is used by --delete-before and --delete-after. */
-static void do_delete_pass(struct file_list *flist)
+static void do_delete_pass(void)
 {
 	char fbuf[MAXPATHLEN];
 	STRUCT_STAT st;
 	int j;
 
 	/* dry_run is incremented when the destination doesn't exist yet. */
 	if (dry_run > 1 || list_only)
 		return;
 
-	for (j = 0; j < flist->count; j++) {
-		struct file_struct *file = flist->files[j];
+	for (j = 0; j < cur_flist->used; j++) {
+		struct file_struct *file = cur_flist->sorted[j];
 
-		if (!(file->flags & FLAG_DEL_HERE))
+		if (!(file->flags & FLAG_CONTENT_DIR))
 			continue;
 
 		f_name(file, fbuf);
 		if (verbose > 1 && file->flags & FLAG_TOP_DIR)
 			rprintf(FINFO, "deleting in %s\n", fbuf);
 
 		if (link_stat(fbuf, &st, keep_dirlinks) < 0
 		 || !S_ISDIR(st.st_mode))
 			continue;
 
-		delete_in_dir(flist, fbuf, file, &st);
+		delete_in_dir(fbuf, file, &st.st_dev);
 	}
-	delete_in_dir(NULL, NULL, NULL, NULL);
+	delete_in_dir(NULL, NULL, &dev_zero);
 
 	if (do_progress && !am_server)
 		rprintf(FINFO, "                    \r");
 }
 
-int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st)
+int unchanged_attrs(const char *fname, struct file_struct *file, stat_x *sxp)
 {
-	if (preserve_perms
-	 && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
+#if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
+	if (S_ISLNK(file->mode)) {
+		;
+	} else
+#endif
+	if (preserve_times && cmp_time(sxp->st.st_mtime, file->modtime) != 0)
+		return 0;
+
+	if (preserve_perms && !BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
+		return 0;
+
+	if (preserve_executability && ((sxp->st.st_mode & 0111 ? 1 : 0) ^ (file->mode & 0111 ? 1 : 0)))
 		return 0;
 
-	if (am_root && preserve_uid && st->st_uid != file->uid)
+	if (am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file))
 		return 0;
 
-	if (preserve_gid && file->gid != GID_NONE && st->st_gid != file->gid)
+	if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP) && sxp->st.st_gid != (gid_t)F_GROUP(file))
 		return 0;
 
+#ifdef SUPPORT_ACLS
+	if (preserve_acls && !S_ISLNK(file->mode)) {
+		if (!ACL_READY(*sxp))
+			get_acl(fname, sxp);
+		if (set_acl(NULL, file, sxp) == 0)
+			return 0;
+	}
+#endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs) {
+		if (!XATTR_READY(*sxp))
+			get_xattr(fname, sxp);
+		if (xattr_diff(file, sxp, 0))
+			return 0;
+	}
+#endif
+
 	return 1;
 }
 
-void itemize(struct file_struct *file, int ndx, int statret, STRUCT_STAT *st,
-	     int32 iflags, uchar fnamecmp_type, char *xname)
+void itemize(const char *fnamecmp, struct file_struct *file, int ndx, int statret,
+	     stat_x *sxp, int32 iflags, uchar fnamecmp_type,
+	     const char *xname)
 {
 	if (statret >= 0) { /* A from-dest-dir statret can == 1! */
 		int keep_time = !preserve_times ? 0
-		    : S_ISDIR(file->mode) ? !omit_dir_times
-		    : !S_ISLNK(file->mode);
+		    : S_ISDIR(file->mode) ? preserve_times > 1 :
+#if defined HAVE_LUTIMES && defined HAVE_UTIMES
+		    (receiver_symlink_times && !(file->flags & FLAG_TIME_FAILED)) ||
+#endif
+		    !S_ISLNK(file->mode);
 
-		if (S_ISREG(file->mode) && file->length != st->st_size)
+		if (S_ISREG(file->mode) && F_LENGTH(file) != sxp->st.st_size)
 			iflags |= ITEM_REPORT_SIZE;
 		if ((iflags & (ITEM_TRANSFER|ITEM_LOCAL_CHANGE) && !keep_time
-		     && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
-		    || (keep_time && cmp_time(file->modtime, st->st_mtime) != 0))
+		  && !(iflags & ITEM_MATCHED)
+		  && (!(iflags & ITEM_XNAME_FOLLOWS) || *xname))
+		 || (keep_time && cmp_time(file->modtime, sxp->st.st_mtime) != 0))
 			iflags |= ITEM_REPORT_TIME;
-		if ((file->mode & CHMOD_BITS) != (st->st_mode & CHMOD_BITS))
+#if !defined HAVE_LCHMOD && !defined HAVE_SETATTRLIST
+		if (S_ISLNK(file->mode)) {
+			;
+		} else
+#endif
+		if ((preserve_perms || preserve_executability)
+		 && !BITS_EQUAL(sxp->st.st_mode, file->mode, CHMOD_BITS))
 			iflags |= ITEM_REPORT_PERMS;
-		if (preserve_uid && am_root && file->uid != st->st_uid)
+		if (uid_ndx && am_root && (uid_t)F_OWNER(file) != sxp->st.st_uid)
 			iflags |= ITEM_REPORT_OWNER;
-		if (preserve_gid && file->gid != GID_NONE
-		    && st->st_gid != file->gid)
+		if (gid_ndx && !(file->flags & FLAG_SKIP_GROUP)
+		    && sxp->st.st_gid != (gid_t)F_GROUP(file))
 			iflags |= ITEM_REPORT_GROUP;
-	} else
+#ifdef SUPPORT_ACLS
+		if (preserve_acls && !S_ISLNK(file->mode)) {
+			if (!ACL_READY(*sxp))
+				get_acl(fnamecmp, sxp);
+			if (set_acl(NULL, file, sxp) == 0)
+				iflags |= ITEM_REPORT_ACL;
+		}
+#endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs) {
+			if (!XATTR_READY(*sxp))
+				get_xattr(fnamecmp, sxp);
+			if (xattr_diff(file, sxp, 1))
+				iflags |= ITEM_REPORT_XATTR;
+		}
+#endif
+	} else {
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs && xattr_diff(file, NULL, 1))
+			iflags |= ITEM_REPORT_XATTR;
+#endif
 		iflags |= ITEM_IS_NEW;
+	}
 
 	iflags &= 0xffff;
-	if ((iflags & SIGNIFICANT_ITEM_FLAGS || verbose > 1
+	if ((iflags & (SIGNIFICANT_ITEM_FLAGS|ITEM_REPORT_XATTR) || verbose > 1
 	  || stdout_format_has_i > 1 || (xname && *xname)) && !read_batch) {
 		if (protocol_version >= 29) {
 			if (ndx >= 0)
-				write_int(sock_f_out, ndx);
+				write_ndx(sock_f_out, ndx);
 			write_shortint(sock_f_out, iflags);
 			if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
 				write_byte(sock_f_out, fnamecmp_type);
 			if (iflags & ITEM_XNAME_FOLLOWS)
 				write_vstring(sock_f_out, xname, strlen(xname));
+#ifdef SUPPORT_XATTRS
+			if (iflags & ITEM_REPORT_XATTR && !dry_run)
+				send_xattr_request(NULL, file, sock_f_out);
+#endif
 		} else if (ndx >= 0) {
 			enum logcode code = logfile_format_has_i ? FINFO : FCLIENT;
 			log_item(code, file, &stats, iflags, xname);
 		}
 	}
 }
 
 
 /* Perform our quick-check heuristic for determining if a file is unchanged. */
 int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st)
 {
-	if (st->st_size != file->length)
+	if (st->st_size != F_LENGTH(file))
 		return 0;
 
 	/* if always checksum is set then we use the checksum instead
 	   of the file time to determine whether to sync */
-	if (always_checksum && S_ISREG(st->st_mode)) {
-		char sum[MD4_SUM_LENGTH];
+	if (always_checksum > 0 && S_ISREG(st->st_mode)) {
+		char sum[MAX_DIGEST_LEN];
 		file_checksum(fn, sum, st->st_size);
-		return memcmp(sum, file->u.sum, checksum_len) == 0;
+		return memcmp(sum, F_SUM(file), checksum_len) == 0;
 	}
 
-	if (size_only)
+	if (size_only > 0)
 		return 1;
 
 	if (ignore_times)
 		return 0;
 
 	return cmp_time(st->st_mtime, file->modtime) == 0;
@@ -460,14 +778,14 @@
 		s2length = MIN(s2length, SUM_LENGTH);
 	}
 
 	sum->flength	= len;
 	sum->blength	= blength;
 	sum->s2length	= s2length;
-	sum->remainder	= len % blength;
-	sum->count	= len / blength + (sum->remainder != 0);
+	sum->remainder	= (int32)(len % blength);
+	sum->count	= (int32)(len / blength) + (sum->remainder != 0);
 
 	if (sum->count && verbose > 2) {
 		rprintf(FINFO,
 			"count=%.0f rem=%ld blength=%ld s2length=%d flength=%.0f\n",
 			(double)sum->count, (long)sum->remainder, (long)sum->blength,
 			sum->s2length, (double)sum->flength);
@@ -539,25 +857,25 @@
 	uint32 lowest_dist = 25 << 16; /* ignore a distance greater than 25 */
 	int j, lowest_j = -1;
 
 	fname_len = strlen(fname);
 	fname_suf = find_filename_suffix(fname, fname_len, &fname_suf_len);
 
-	for (j = 0; j < dirlist->count; j++) {
+	for (j = 0; j < dirlist->used; j++) {
 		struct file_struct *fp = dirlist->files[j];
 		const char *suf, *name;
 		int len, suf_len;
 		uint32 dist;
 
-		if (!S_ISREG(fp->mode) || !fp->length
-		    || fp->flags & FLAG_NO_FUZZY)
+		if (!S_ISREG(fp->mode) || !F_LENGTH(fp)
+		 || fp->flags & FLAG_FILE_SENT)
 			continue;
 
 		name = fp->basename;
 
-		if (fp->length == file->length
+		if (F_LENGTH(fp) == F_LENGTH(file)
 		    && cmp_time(fp->modtime, file->modtime) == 0) {
 			if (verbose > 4) {
 				rprintf(FINFO,
 					"fuzzy size/modtime match for %s\n",
 					name);
 			}
@@ -581,60 +899,74 @@
 		}
 	}
 
 	return lowest_j;
 }
 
-void check_for_finished_hlinks(int itemizing, enum logcode code)
+/* Copy a file found in our --copy-dest handling. */
+static int copy_altdest_file(const char *src, const char *dest, struct file_struct *file)
 {
-	struct file_struct *file;
-	int ndx;
-
-	while ((ndx = get_hlink_num()) != -1) {
-		if (ndx < 0 || ndx >= the_file_list->count)
-			continue;
-
-		file = the_file_list->files[ndx];
-		if (!file->link_u.links)
-			continue;
-
-		hard_link_cluster(file, ndx, itemizing, code);
+	char buf[MAXPATHLEN];
+	const char *copy_to, *partialptr;
+	int ok, fd_w;
+
+	if (inplace) {
+		/* Let copy_file open the destination in place. */
+		fd_w = -1;
+		copy_to = dest;
+	} else {
+		fd_w = open_tmpfile(buf, dest, file);
+		if (fd_w < 0)
+			return -1;
+		copy_to = buf;
 	}
+	cleanup_set(copy_to, NULL, NULL, -1, -1);
+	if (copy_file(src, copy_to, fd_w, file->mode, 0) < 0) {
+		if (verbose) {
+			rsyserr(FINFO, errno, "copy_file %s => %s",
+				full_fname(src), copy_to);
+		}
+		/* Try to clean up. */
+		unlink(copy_to);
+		cleanup_disable();
+		return -1;
+	}
+	partialptr = partial_dir ? partial_dir_fname(dest) : NULL;
+	ok = finish_transfer(dest, copy_to, src, partialptr, file, 1, 0);
+	cleanup_disable();
+	return ok ? 0 : -1;
 }
 
 /* This is only called for regular files.  We return -2 if we've finished
  * handling the file, -1 if no dest-linking occurred, or a non-negative
  * value if we found an alternate basis file. */
 static int try_dests_reg(struct file_struct *file, char *fname, int ndx,
-			 char *cmpbuf, STRUCT_STAT *stp, int itemizing,
-			 int maybe_ATTRS_REPORT, enum logcode code)
+			 char *cmpbuf, stat_x *sxp, int itemizing,
+			 enum logcode code)
 {
 	int best_match = -1;
 	int match_level = 0;
 	int j = 0;
 
 	do {
 		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
-		if (link_stat(cmpbuf, stp, 0) < 0 || !S_ISREG(stp->st_mode))
+		if (link_stat(cmpbuf, &sxp->st, 0) < 0 || !S_ISREG(sxp->st.st_mode))
 			continue;
 		switch (match_level) {
 		case 0:
 			best_match = j;
 			match_level = 1;
 			/* FALL THROUGH */
 		case 1:
-			if (!unchanged_file(cmpbuf, file, stp))
+			if (!unchanged_file(cmpbuf, file, &sxp->st))
 				continue;
 			best_match = j;
 			match_level = 2;
 			/* FALL THROUGH */
 		case 2:
-			if (!unchanged_attrs(file, stp))
-				continue;
-			if (always_checksum && preserve_times
-			 && cmp_time(stp->st_mtime, file->modtime))
+			if (!unchanged_attrs(cmpbuf, file, sxp))
 				continue;
 			best_match = j;
 			match_level = 3;
 			break;
 		}
 		break;
@@ -643,537 +975,730 @@
 	if (!match_level)
 		return -1;
 
 	if (j != best_match) {
 		j = best_match;
 		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
-		if (link_stat(cmpbuf, stp, 0) < 0)
+		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
 			return -1;
 	}
 
 	if (match_level == 3 && !copy_dest) {
 #ifdef SUPPORT_HARD_LINKS
 		if (link_dest) {
-			if (hard_link_one(file, ndx, fname, 0, stp,
-					  cmpbuf, 1,
-					  itemizing && verbose > 1,
-					  code) < 0)
+			if (!hard_link_one(file, fname, cmpbuf, 1))
 				goto try_a_copy;
-			if (preserve_hard_links && file->link_u.links) {
-				if (dry_run)
-					file->link_u.links->link_dest_used = j + 1;
-				hard_link_cluster(file, ndx, itemizing, code);
+			if (preserve_hard_links && F_IS_HLINKED(file))
+				finish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, j);
+			if (!maybe_ATTRS_REPORT && (verbose > 1 || stdout_format_has_i > 1)) {
+				itemize(cmpbuf, file, ndx, 1, sxp,
+					ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
+					0, "");
 			}
 		} else
 #endif
 		if (itemizing)
-			itemize(file, ndx, 0, stp, 0, 0, NULL);
-		if (verbose > 1 && maybe_ATTRS_REPORT) {
+			itemize(cmpbuf, file, ndx, 0, sxp, 0, 0, NULL);
+		if (verbose > 1 && maybe_ATTRS_REPORT)
 			rprintf(FCLIENT, "%s is uptodate\n", fname);
-		}
 		return -2;
 	}
 
 	if (match_level >= 2) {
+#ifdef SUPPORT_HARD_LINKS
 	  try_a_copy: /* Copy the file locally. */
-		if (copy_file(cmpbuf, fname, file->mode) < 0) {
-			if (verbose) {
-				rsyserr(FINFO, errno, "copy_file %s => %s",
-					full_fname(cmpbuf), fname);
-			}
+#endif
+		if (!dry_run && copy_altdest_file(cmpbuf, fname, file) < 0)
 			return -1;
-		}
 		if (itemizing)
-			itemize(file, ndx, 0, stp, ITEM_LOCAL_CHANGE, 0, NULL);
-		set_file_attrs(fname, file, NULL, 0);
+			itemize(cmpbuf, file, ndx, 0, sxp, ITEM_LOCAL_CHANGE, 0, NULL);
 		if (maybe_ATTRS_REPORT
 		 && ((!itemizing && verbose && match_level == 2)
 		  || (verbose > 1 && match_level == 3))) {
 			code = match_level == 3 ? FCLIENT : FINFO;
 			rprintf(code, "%s%s\n", fname,
 				match_level == 3 ? " is uptodate" : "");
 		}
-		if (preserve_hard_links && file->link_u.links)
-			hard_link_cluster(file, ndx, itemizing, code);
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_IS_HLINKED(file))
+			finish_hard_link(file, fname, ndx, &sxp->st, itemizing, code, -1);
+#endif
 		return -2;
 	}
 
 	return FNAMECMP_BASIS_DIR_LOW + j;
 }
 
 /* This is only called for non-regular files.  We return -2 if we've finished
- * handling the file, or -1 if no dest-linking occurred. */
+ * handling the file, or -1 if no dest-linking occurred, or a non-negative
+ * value if we found an alternate basis file. */
 static int try_dests_non(struct file_struct *file, char *fname, int ndx,
-			 int itemizing, int maybe_ATTRS_REPORT,
+			 char *cmpbuf, stat_x *sxp, int itemizing,
 			 enum logcode code)
 {
-	char fnamebuf[MAXPATHLEN];
-	STRUCT_STAT st;
-	int i = 0;
+	char lnk[MAXPATHLEN];
+	int best_match = -1;
+	int match_level = 0;
+	enum nonregtype type;
+	uint32 *devp;
+	int len, j = 0;
+
+#ifndef SUPPORT_LINKS
+	if (S_ISLNK(file->mode))
+		return -1;
+#endif
+	if (S_ISDIR(file->mode)) {
+		type = TYPE_DIR;
+	} else if (IS_SPECIAL(file->mode))
+		type = TYPE_SPECIAL;
+	else if (IS_DEVICE(file->mode))
+		type = TYPE_DEVICE;
+#ifdef SUPPORT_LINKS
+	else if (S_ISLNK(file->mode))
+		type = TYPE_SYMLINK;
+#endif
+	else {
+		rprintf(FERROR,
+			"internal: try_dests_non() called with invalid mode (%o)\n",
+			(int)file->mode);
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
 
 	do {
-		pathjoin(fnamebuf, MAXPATHLEN, basis_dir[i], fname);
-		if (link_stat(fnamebuf, &st, 0) < 0 || S_ISDIR(st.st_mode)
-		 || !unchanged_attrs(file, &st))
+		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
+		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
 			continue;
-		if (S_ISLNK(file->mode)) {
+		switch (type) {
+		case TYPE_DIR:
+			if (!S_ISDIR(sxp->st.st_mode))
+				continue;
+			break;
+		case TYPE_SPECIAL:
+			if (!IS_SPECIAL(sxp->st.st_mode))
+				continue;
+			break;
+		case TYPE_DEVICE:
+			if (!IS_DEVICE(sxp->st.st_mode))
+				continue;
+			break;
 #ifdef SUPPORT_LINKS
-			char lnk[MAXPATHLEN];
-			int len;
-			if ((len = readlink(fnamebuf, lnk, MAXPATHLEN-1)) <= 0)
+		case TYPE_SYMLINK:
+			if (!S_ISLNK(sxp->st.st_mode))
 				continue;
-			lnk[len] = '\0';
-			if (strcmp(lnk, file->u.link) != 0)
+			break;
 #endif
+		}
+		if (match_level < 1) {
+			match_level = 1;
+			best_match = j;
+		}
+		switch (type) {
+		case TYPE_DIR:
+			break;
+		case TYPE_SPECIAL:
+		case TYPE_DEVICE:
+			devp = F_RDEV_P(file);
+			if (sxp->st.st_rdev != MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp)))
 				continue;
-		} else if (IS_SPECIAL(file->mode)) {
-			if (!IS_SPECIAL(st.st_mode) || st.st_rdev != file->u.rdev)
+			break;
+#ifdef SUPPORT_LINKS
+		case TYPE_SYMLINK:
+			if ((len = readlink(cmpbuf, lnk, MAXPATHLEN-1)) <= 0)
 				continue;
-		} else if (IS_DEVICE(file->mode)) {
-			if (!IS_DEVICE(st.st_mode) || st.st_rdev != file->u.rdev)
+			lnk[len] = '\0';
+			if (strcmp(lnk, F_SYMLINK(file)) != 0)
 				continue;
-		} else {
-			rprintf(FERROR,
-				"internal: try_dests_non() called with invalid mode (%o)\n",
-				(int)file->mode);
-			exit_cleanup(RERR_UNSUPPORTED);
+			break;
+#endif
+		}
+		if (match_level < 2) {
+			match_level = 2;
+			best_match = j;
+		}
+		if (unchanged_attrs(cmpbuf, file, sxp)) {
+			match_level = 3;
+			best_match = j;
+			break;
 		}
+	} while (basis_dir[++j] != NULL);
+
+	if (!match_level)
+		return -1;
+
+	if (j != best_match) {
+		j = best_match;
+		pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
+		if (link_stat(cmpbuf, &sxp->st, 0) < 0)
+			return -1;
+	}
+
+	if (match_level == 3) {
 #ifdef SUPPORT_HARD_LINKS
 		if (link_dest
 #ifndef CAN_HARDLINK_SYMLINK
 		 && !S_ISLNK(file->mode)
 #endif
 #ifndef CAN_HARDLINK_SPECIAL
 		 && !IS_SPECIAL(file->mode) && !IS_DEVICE(file->mode)
 #endif
-		) {
-			if (do_link(fnamebuf, fname) < 0) {
-				rsyserr(FERROR, errno,
+		 && !S_ISDIR(file->mode)) {
+			if (do_link(cmpbuf, fname) < 0) {
+				rsyserr(FERROR_XFER, errno,
 					"failed to hard-link %s with %s",
-					fnamebuf, fname);
-				break;
+					cmpbuf, fname);
+				return j;
 			}
-			if (preserve_hard_links && file->link_u.links)
-				hard_link_cluster(file, ndx, itemizing, code);
-		}
+			if (preserve_hard_links && F_IS_HLINKED(file))
+				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
+		} else
 #endif
-		if (itemizing && stdout_format_has_i && verbose > 1) {
-			int changes = compare_dest ? 0 : ITEM_LOCAL_CHANGE
-				    + (link_dest ? ITEM_XNAME_FOLLOWS : 0);
-			char *lp = link_dest ? "" : NULL;
-			itemize(file, ndx, 0, &st, changes, 0, lp);
+			match_level = 2;
+		if (itemizing && stdout_format_has_i
+		 && (verbose > 1 || stdout_format_has_i > 1)) {
+			int chg = compare_dest && type != TYPE_DIR ? 0
+			    : ITEM_LOCAL_CHANGE
+			     + (match_level == 3 ? ITEM_XNAME_FOLLOWS : 0);
+			char *lp = match_level == 3 ? "" : NULL;
+			itemize(cmpbuf, file, ndx, 0, sxp, chg + ITEM_MATCHED, 0, lp);
 		}
 		if (verbose > 1 && maybe_ATTRS_REPORT) {
-			rprintf(FCLIENT, "%s is uptodate\n", fname);
+			rprintf(FCLIENT, "%s%s is uptodate\n",
+				fname, type == TYPE_DIR ? "/" : "");
 		}
 		return -2;
-	} while (basis_dir[++i] != NULL);
+	}
+
+	return j;
+}
 
-	return -1;
+static void list_file_entry(struct file_struct *f)
+{
+	char permbuf[PERMSTRING_SIZE];
+	double len;
+
+	if (!F_IS_ACTIVE(f)) {
+		/* this can happen if duplicate names were removed */
+		return;
+	}
+
+	permstring(permbuf, f->mode);
+	len = F_LENGTH(f);
+
+	/* TODO: indicate '+' if the entry has an ACL. */
+
+#ifdef SUPPORT_LINKS
+	if (preserve_links && S_ISLNK(f->mode)) {
+		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
+			permbuf, len, timestring(f->modtime),
+			f_name(f, NULL), F_SYMLINK(f));
+	} else
+#endif
+	{
+		rprintf(FINFO, "%s %11.0f %s %s\n",
+			permbuf, len, timestring(f->modtime),
+			f_name(f, NULL));
+	}
 }
 
 static int phase = 0;
+static int dflt_perms;
 
-/* Acts on the_file_list->file's ndx'th item, whose name is fname.  If a dir,
+/* Acts on the indicated item in cur_flist whose name is fname.  If a dir,
  * make sure it exists, and has the right permissions/timestamp info.  For
  * all other non-regular files (symlinks, etc.) we create them here.  For
  * regular files that have changed, we try to find a basis file and then
- * start sending checksums.
+ * start sending checksums.  The ndx is the file's unique index value.
  *
  * When fname is non-null, it must point to a MAXPATHLEN buffer!
  *
  * Note that f_out is set to -1 when doing final directory-permission and
  * modification-time repair. */
 static void recv_generator(char *fname, struct file_struct *file, int ndx,
-			   int itemizing, int maybe_ATTRS_REPORT,
-			   enum logcode code, int f_out)
+			   int itemizing, enum logcode code, int f_out)
 {
 	static int missing_below = -1, excluded_below = -1;
-	static char *parent_dirname = "";
+	static const char *parent_dirname = "";
+	static struct file_struct *missing_dir = NULL, *excluded_dir = NULL;
 	static struct file_list *fuzzy_dirlist = NULL;
 	static int need_fuzzy_dirlist = 0;
 	struct file_struct *fuzzy_file = NULL;
 	int fd = -1, f_copy = -1;
-	STRUCT_STAT st, real_st, partial_st;
+	stat_x sx, real_sx;
+	STRUCT_STAT partial_st;
 	struct file_struct *back_file = NULL;
 	int statret, real_ret, stat_errno;
 	char *fnamecmp, *partialptr, *backupptr = NULL;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
-	int del_opts = DEL_TERSE | (delete_mode ? DEL_FORCE_RECURSE : 0);
+	int implied_dirs_are_missing = relative_paths && !implied_dirs && protocol_version < 30;
+	int del_opts = delete_mode || force_delete ? DEL_RECURSE : 0;
+	int is_dir = !S_ISDIR(file->mode) ? 0
+		   : inc_recurse && ndx != cur_flist->ndx_start - 1 ? -1
+		   : 1;
 
-	if (list_only)
-		return;
+	if (verbose > 2)
+		rprintf(FINFO, "recv_generator(%s,%d)\n", fname, ndx);
 
-	if (!fname) {
-		if (fuzzy_dirlist) {
-			flist_free(fuzzy_dirlist);
-			fuzzy_dirlist = NULL;
-		}
-		if (missing_below >= 0) {
-			if (dry_run)
-				dry_run--;
-			missing_below = -1;
-		}
-		parent_dirname = "";
+	if (list_only) {
+		if (is_dir < 0
+		 || (is_dir && !implied_dirs && file->flags & FLAG_IMPLIED_DIR))
+			return;
+		list_file_entry(file);
 		return;
 	}
 
-	if (verbose > 2)
-		rprintf(FINFO, "recv_generator(%s,%d)\n", fname, ndx);
-
 	if (server_filter_list.head) {
+		int filtered = check_filter(&server_filter_list, fname, is_dir) < 0;
+		if (is_dir < 0 && filtered)
+			return;
 		if (excluded_below >= 0) {
-			if (file->dir.depth > excluded_below)
+			if (F_DEPTH(file) > excluded_below
+			 && (!implied_dirs_are_missing || f_name_has_prefix(file, excluded_dir)))
 				goto skipping;
 			excluded_below = -1;
 		}
-		if (check_filter(&server_filter_list, fname,
-				 S_ISDIR(file->mode)) < 0) {
-			if (S_ISDIR(file->mode))
-				excluded_below = file->dir.depth;
-		  skipping:
-			if (verbose) {
-				rprintf(FINFO,
-					"skipping server-excluded file \"%s\"\n",
-					fname);
+		if (filtered) {
+			if (is_dir) {
+				excluded_below = F_DEPTH(file);
+				excluded_dir = file;
 			}
+		  skipping:
+			rprintf(FERROR_XFER,
+				"skipping daemon-excluded file \"%s\"\n",
+				fname);
 			return;
 		}
 	}
 
 	if (missing_below >= 0) {
-		if (file->dir.depth <= missing_below) {
+		if (F_DEPTH(file) <= missing_below
+		 || (implied_dirs_are_missing && !f_name_has_prefix(file, missing_dir))) {
 			if (dry_run)
 				dry_run--;
 			missing_below = -1;
-		} else if (!dry_run)
+		} else if (!dry_run) {
+			if (is_dir)
+				file->flags |= FLAG_MISSING_DIR;
 			return;
+		}
 	}
+#ifdef SUPPORT_ACLS
+	sx.acc_acl = sx.def_acl = NULL;
+#endif
+#ifdef SUPPORT_XATTRS
+	sx.xattr = NULL;
+#endif
 	if (dry_run > 1) {
+		if (fuzzy_dirlist) {
+			flist_free(fuzzy_dirlist);
+			fuzzy_dirlist = NULL;
+		}
+		parent_dirname = "";
 		statret = -1;
 		stat_errno = ENOENT;
 	} else {
-		char *dn = file->dirname ? file->dirname : ".";
+		const char *dn = file->dirname ? file->dirname : ".";
 		if (parent_dirname != dn && strcmp(parent_dirname, dn) != 0) {
 			if (relative_paths && !implied_dirs
-			 && do_stat(dn, &st) < 0
+			 && do_stat(dn, &sx.st) < 0
 			 && create_directory_path(fname) < 0) {
-				rsyserr(FERROR, errno,
+				rsyserr(FERROR_XFER, errno,
 					"recv_generator: mkdir %s failed",
 					full_fname(dn));
 			}
 			if (fuzzy_dirlist) {
 				flist_free(fuzzy_dirlist);
 				fuzzy_dirlist = NULL;
 			}
 			if (fuzzy_basis)
 				need_fuzzy_dirlist = 1;
+#ifdef SUPPORT_ACLS
+			if (!preserve_perms)
+				dflt_perms = default_perms_for_dir(dn);
+#endif
 		}
 		parent_dirname = dn;
 
 		if (need_fuzzy_dirlist && S_ISREG(file->mode)) {
-			fuzzy_dirlist = get_dirlist(dn, -1, 1);
+			strlcpy(fnamecmpbuf, dn, sizeof fnamecmpbuf);
+			fuzzy_dirlist = get_dirlist(fnamecmpbuf, -1, 1);
 			need_fuzzy_dirlist = 0;
 		}
 
-		statret = link_stat(fname, &st,
-				    keep_dirlinks && S_ISDIR(file->mode));
+		statret = link_stat(fname, &sx.st, keep_dirlinks && is_dir);
 		stat_errno = errno;
 	}
 
-	if (ignore_non_existing && statret == -1 && stat_errno == ENOENT) {
+	if (ignore_non_existing > 0 && statret == -1 && stat_errno == ENOENT) {
+		if (is_dir) {
+			if (is_dir < 0)
+				return;
+			if (missing_below < 0) {
+				if (dry_run)
+					dry_run++;
+				missing_below = F_DEPTH(file);
+				missing_dir = file;
+			}
+			file->flags |= FLAG_MISSING_DIR;
+		}
 		if (verbose > 1) {
 			rprintf(FINFO, "not creating new %s \"%s\"\n",
-				S_ISDIR(file->mode) ? "directory" : "file",
-				fname);
+				is_dir ? "directory" : "file", fname);
 		}
 		return;
 	}
 
-	/* If we're not preserving permissions, change the file-list's
-	 * mode based on the local permissions and some heuristics. */
-	if (!preserve_perms) {
-		int exists = statret == 0
-			  && S_ISDIR(st.st_mode) == S_ISDIR(file->mode);
-		file->mode = dest_mode(file->mode, st.st_mode, exists);
-	}
+	if (statret == 0 && !(sx.st.st_mode & S_IWUSR)
+	 && !am_root && sx.st.st_uid == our_uid)
+		del_opts |= DEL_NO_UID_WRITE;
 
-	if (S_ISDIR(file->mode)) {
+	if (is_dir) {
+		if (!implied_dirs && file->flags & FLAG_IMPLIED_DIR)
+			goto cleanup;
+		if (is_dir < 0) {
+			/* In inc_recurse mode we want to make sure any missing
+			 * directories get created while we're still processing
+			 * the parent dir (which allows us to touch the parent
+			 * dir's mtime right away).  We will handle the dir in
+			 * full later (right before we handle its contents). */
+			if (statret == 0
+			 && (S_ISDIR(sx.st.st_mode)
+			  || delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0))
+				goto cleanup; /* Any errors get reported later. */
+			if (do_mkdir(fname, file->mode & 0700) == 0)
+				file->flags |= FLAG_DIR_CREATED;
+			goto cleanup;
+		}
 		/* The file to be received is a directory, so we need
 		 * to prepare appropriately.  If there is already a
 		 * file of that name and it is *not* a directory, then
 		 * we need to delete it.  If it doesn't exist, then
 		 * (perhaps recursively) create it. */
-		if (statret == 0 && !S_ISDIR(st.st_mode)) {
-			if (delete_item(fname, st.st_mode, del_opts) < 0)
-				return;
+		if (statret == 0 && !S_ISDIR(sx.st.st_mode)) {
+			if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_DIR) != 0)
+				goto skipping_dir_contents;
 			statret = -1;
 		}
 		if (dry_run && statret != 0 && missing_below < 0) {
-			missing_below = file->dir.depth;
+			missing_below = F_DEPTH(file);
+			missing_dir = file;
 			dry_run++;
 		}
+		real_ret = statret;
+		real_sx = sx;
+		if (file->flags & FLAG_DIR_CREATED)
+			statret = -1;
+		if (!preserve_perms) { /* See comment in non-dir code below. */
+			file->mode = dest_mode(file->mode, sx.st.st_mode,
+					       dflt_perms, statret == 0);
+		}
+		if (statret != 0 && basis_dir[0] != NULL) {
+			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx,
+					      itemizing, code);
+			if (j == -2) {
+				itemizing = 0;
+				code = FNONE;
+			} else if (j >= 0)
+				statret = 1;
+		}
 		if (itemizing && f_out != -1) {
-			int sr = statret;
-			if (new_root_dir) {
-				if (*fname == '.' && fname[1] == '\0')
-					sr = -1;
-				new_root_dir = 0;
-			}
-			itemize(file, ndx, sr, &st,
-				sr ? ITEM_LOCAL_CHANGE : 0, 0, NULL);
+			itemize(fname, file, ndx, statret, &sx,
+				statret ? ITEM_LOCAL_CHANGE : 0, 0, NULL);
 		}
-		if (statret != 0 && do_mkdir(fname,file->mode) < 0 && errno != EEXIST) {
+		if (real_ret != 0 && do_mkdir(fname,file->mode) < 0 && errno != EEXIST) {
 			if (!relative_paths || errno != ENOENT
 			    || create_directory_path(fname) < 0
 			    || (do_mkdir(fname, file->mode) < 0 && errno != EEXIST)) {
-				rsyserr(FERROR, errno,
+				rsyserr(FERROR_XFER, errno,
 					"recv_generator: mkdir %s failed",
 					full_fname(fname));
-				file->flags |= FLAG_MISSING;
-				if (ndx+1 < the_file_list->count
-				 && the_file_list->files[ndx+1]->dir.depth > file->dir.depth) {
-					rprintf(FERROR,
-					    "*** Skipping everything below this failed directory ***\n");
-					missing_below = file->dir.depth;
-				}
-				return;
+			  skipping_dir_contents:
+				rprintf(FERROR,
+				    "*** Skipping any contents from this failed directory ***\n");
+				missing_below = F_DEPTH(file);
+				missing_dir = file;
+				file->flags |= FLAG_MISSING_DIR;
+				goto cleanup;
 			}
 		}
-		if (set_file_attrs(fname, file, statret ? NULL : &st, 0)
+		if (set_file_attrs(fname, file, real_ret ? NULL : &real_sx, NULL, 0)
 		    && verbose && code != FNONE && f_out != -1)
 			rprintf(code, "%s/\n", fname);
-		if (delete_during && f_out != -1 && !phase && dry_run < 2
-		    && (file->flags & FLAG_DEL_HERE))
-			delete_in_dir(the_file_list, fname, file, &st);
-		return;
+
+		/* We need to ensure that the dirs in the transfer have writable
+		 * permissions during the time we are putting files within them.
+		 * This is then fixed after the transfer is done. */
+#ifdef HAVE_CHMOD
+		if (!am_root && !(file->mode & S_IWUSR) && dir_tweaking) {
+			mode_t mode = file->mode | S_IWUSR;
+			if (do_chmod(fname, mode) < 0) {
+				rsyserr(FERROR_XFER, errno,
+					"failed to modify permissions on %s",
+					full_fname(fname));
+			}
+			need_retouch_dir_perms = 1;
+		}
+#endif
+
+		if (real_ret != 0 && one_file_system)
+			real_sx.st.st_dev = filesystem_dev;
+		if (inc_recurse) {
+			if (one_file_system) {
+				uint32 *devp = F_DIR_DEV_P(file);
+				DEV_MAJOR(devp) = major(real_sx.st.st_dev);
+				DEV_MINOR(devp) = minor(real_sx.st.st_dev);
+			}
+		}
+		else if (delete_during && f_out != -1 && !phase && dry_run < 2
+		    && (file->flags & FLAG_CONTENT_DIR))
+			delete_in_dir(fname, file, &real_sx.st.st_dev);
+		goto cleanup;
 	}
 
-	if (preserve_hard_links && file->link_u.links
-	    && hard_link_check(file, ndx, fname, statret, &st,
-			       itemizing, code, HL_CHECK_MASTER))
-		return;
+	/* If we're not preserving permissions, change the file-list's
+	 * mode based on the local permissions and some heuristics. */
+	if (!preserve_perms) {
+		int exists = statret == 0 && !S_ISDIR(sx.st.st_mode);
+		file->mode = dest_mode(file->mode, sx.st.st_mode, dflt_perms,
+				       exists);
+	}
+
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && F_HLINK_NOT_FIRST(file)
+	 && hard_link_check(file, ndx, fname, statret, &sx, itemizing, code))
+		goto cleanup;
+#endif
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 #ifdef SUPPORT_LINKS
-		if (safe_symlinks && unsafe_symlink(file->u.link, fname)) {
+		const char *sl = F_SYMLINK(file);
+		if (safe_symlinks && unsafe_symlink(sl, fname)) {
 			if (verbose) {
-				if (the_file_list->count == 1)
+				if (solo_file)
 					fname = f_name(file, NULL);
 				rprintf(FINFO,
 					"ignoring unsafe symlink %s -> \"%s\"\n",
-					full_fname(fname), file->u.link);
+					full_fname(fname), sl);
 			}
 			return;
 		}
 		if (statret == 0) {
 			char lnk[MAXPATHLEN];
 			int len;
 
-			if (!S_ISDIR(st.st_mode)
-			    && (len = readlink(fname, lnk, MAXPATHLEN-1)) > 0) {
-				lnk[len] = 0;
-				/* A link already pointing to the
-				 * right place -- no further action
-				 * required. */
-				if (strcmp(lnk, file->u.link) == 0) {
-					if (itemizing) {
-						itemize(file, ndx, 0, &st, 0,
-							0, NULL);
-					}
-					set_file_attrs(fname, file, &st,
-						       maybe_ATTRS_REPORT);
-					if (preserve_hard_links
-					    && file->link_u.links) {
-						hard_link_cluster(file, ndx,
-								  itemizing,
-								  code);
-					}
-					if (remove_source_files == 1)
-						goto return_with_success;
-					return;
-				}
+			if (!S_ISLNK(sx.st.st_mode))
+				statret = -1;
+			else if ((len = readlink(fname, lnk, MAXPATHLEN-1)) > 0
+			      && strncmp(lnk, sl, len) == 0 && sl[len] == '\0') {
+				/* The link is pointing to the right place. */
+				set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);
+				if (itemizing)
+					itemize(fname, file, ndx, 0, &sx, 0, 0, NULL);
+#if defined SUPPORT_HARD_LINKS && defined CAN_HARDLINK_SYMLINK
+				if (preserve_hard_links && F_IS_HLINKED(file))
+					finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
+#endif
+				if (remove_source_files == 1)
+					goto return_with_success;
+				goto cleanup;
 			}
 			/* Not the right symlink (or not a symlink), so
 			 * delete it. */
-			if (delete_item(fname, st.st_mode, del_opts) < 0)
-				return;
-			if (!S_ISLNK(st.st_mode))
-				statret = -1;
+			if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_SYMLINK) != 0)
+				goto cleanup;
 		} else if (basis_dir[0] != NULL) {
-			if (try_dests_non(file, fname, ndx, itemizing,
-					  maybe_ATTRS_REPORT, code) == -2) {
+			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx,
+					      itemizing, code);
+			if (j == -2) {
 #ifndef CAN_HARDLINK_SYMLINK
 				if (link_dest) {
 					/* Resort to --copy-dest behavior. */
 				} else
 #endif
 				if (!copy_dest)
-					return;
+					goto cleanup;
 				itemizing = 0;
 				code = FNONE;
-			}
+			} else if (j >= 0)
+				statret = 1;
 		}
-		if (preserve_hard_links && file->link_u.links
-		    && hard_link_check(file, ndx, fname, -1, &st,
-				       itemizing, code, HL_SKIP))
-			return;
-		if (do_symlink(file->u.link,fname) != 0) {
-			rsyserr(FERROR, errno, "symlink %s -> \"%s\" failed",
-				full_fname(fname), file->u.link);
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
+			cur_flist->in_progress++;
+			goto cleanup;
+		}
+#endif
+		if (do_symlink(sl, fname) != 0) {
+			rsyserr(FERROR_XFER, errno, "symlink %s -> \"%s\" failed",
+				full_fname(fname), sl);
 		} else {
-			set_file_attrs(fname, file, NULL, 0);
+			set_file_attrs(fname, file, NULL, NULL, 0);
 			if (itemizing) {
-				itemize(file, ndx, statret, &st,
+				itemize(fname, file, ndx, statret, &sx,
 					ITEM_LOCAL_CHANGE, 0, NULL);
 			}
-			if (code != FNONE && verbose) {
-				rprintf(code, "%s -> %s\n", fname,
-					file->u.link);
-			}
-			if (preserve_hard_links && file->link_u.links)
-				hard_link_cluster(file, ndx, itemizing, code);
+			if (code != FNONE && verbose)
+				rprintf(code, "%s -> %s\n", fname, sl);
+#ifdef SUPPORT_HARD_LINKS
+			if (preserve_hard_links && F_IS_HLINKED(file))
+				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
+#endif
 			/* This does not check remove_source_files == 1
 			 * because this is one of the items that the old
 			 * --remove-sent-files option would remove. */
 			if (remove_source_files)
 				goto return_with_success;
 		}
 #endif
-		return;
+		goto cleanup;
 	}
 
 	if ((am_root && preserve_devices && IS_DEVICE(file->mode))
 	 || (preserve_specials && IS_SPECIAL(file->mode))) {
-		if (statret != 0 && basis_dir[0] != NULL) {
-			if (try_dests_non(file, fname, ndx, itemizing,
-					  maybe_ATTRS_REPORT, code) == -2) {
+		uint32 *devp = F_RDEV_P(file);
+		dev_t rdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
+		if (statret == 0) {
+			int del_for_flag;
+			if (IS_DEVICE(file->mode)) {
+				if (!IS_DEVICE(sx.st.st_mode))
+					statret = -1;
+				del_for_flag = DEL_FOR_DEVICE;
+			} else {
+				if (!IS_SPECIAL(sx.st.st_mode))
+					statret = -1;
+				del_for_flag = DEL_FOR_SPECIAL;
+			}
+			if (statret == 0
+			 && BITS_EQUAL(sx.st.st_mode, file->mode, _S_IFMT)
+			 && sx.st.st_rdev == rdev) {
+				/* The device or special file is identical. */
+				set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);
+				if (itemizing)
+					itemize(fname, file, ndx, 0, &sx, 0, 0, NULL);
+#ifdef SUPPORT_HARD_LINKS
+				if (preserve_hard_links && F_IS_HLINKED(file))
+					finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
+#endif
+				if (remove_source_files == 1)
+					goto return_with_success;
+				goto cleanup;
+			}
+			if (delete_item(fname, sx.st.st_mode, del_opts | del_for_flag) != 0)
+				goto cleanup;
+		} else if (basis_dir[0] != NULL) {
+			int j = try_dests_non(file, fname, ndx, fnamecmpbuf, &sx,
+					      itemizing, code);
+			if (j == -2) {
 #ifndef CAN_HARDLINK_SPECIAL
 				if (link_dest) {
 					/* Resort to --copy-dest behavior. */
 				} else
 #endif
 				if (!copy_dest)
-					return;
+					goto cleanup;
 				itemizing = 0;
 				code = FNONE;
-			}
+			} else if (j >= 0)
+				statret = 1;
 		}
-		if (statret != 0
-		 || (st.st_mode & ~CHMOD_BITS) != (file->mode & ~CHMOD_BITS)
-		 || st.st_rdev != file->u.rdev) {
-			if (statret == 0
-			 && delete_item(fname, st.st_mode, del_opts) < 0)
-				return;
-			if (preserve_hard_links && file->link_u.links
-			    && hard_link_check(file, ndx, fname, -1, &st,
-					       itemizing, code, HL_SKIP))
-				return;
-			if ((IS_DEVICE(file->mode) && !IS_DEVICE(st.st_mode))
-			 || (IS_SPECIAL(file->mode) && !IS_SPECIAL(st.st_mode)))
-				statret = -1;
-			if (verbose > 2) {
-				rprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
-					fname,
-					(int)file->mode, (int)file->u.rdev);
-			}
-			if (do_mknod(fname,file->mode,file->u.rdev) < 0) {
-				rsyserr(FERROR, errno, "mknod %s failed",
-					full_fname(fname));
-			} else {
-				set_file_attrs(fname, file, NULL, 0);
-				if (itemizing) {
-					itemize(file, ndx, statret, &st,
-						ITEM_LOCAL_CHANGE, 0, NULL);
-				}
-				if (code != FNONE && verbose)
-					rprintf(code, "%s\n", fname);
-				if (preserve_hard_links && file->link_u.links) {
-					hard_link_cluster(file, ndx,
-							  itemizing, code);
-				}
-				if (remove_source_files == 1)
-					goto return_with_success;
-			}
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
+			cur_flist->in_progress++;
+			goto cleanup;
+		}
+#endif
+		if (verbose > 2) {
+			rprintf(FINFO, "mknod(%s, 0%o, [%ld,%ld])\n",
+				fname, (int)file->mode,
+				(long)major(rdev), (long)minor(rdev));
+		}
+		if (do_mknod(fname, file->mode, rdev) < 0) {
+			rsyserr(FERROR_XFER, errno, "mknod %s failed",
+				full_fname(fname));
 		} else {
-			if (itemizing)
-				itemize(file, ndx, statret, &st, 0, 0, NULL);
-			set_file_attrs(fname, file, &st, maybe_ATTRS_REPORT);
-			if (preserve_hard_links && file->link_u.links)
-				hard_link_cluster(file, ndx, itemizing, code);
+			set_file_attrs(fname, file, NULL, NULL, 0);
+			if (itemizing) {
+				itemize(fname, file, ndx, statret, &sx,
+					ITEM_LOCAL_CHANGE, 0, NULL);
+			}
+			if (code != FNONE && verbose)
+				rprintf(code, "%s\n", fname);
+#ifdef SUPPORT_HARD_LINKS
+			if (preserve_hard_links && F_IS_HLINKED(file))
+				finish_hard_link(file, fname, ndx, NULL, itemizing, code, -1);
+#endif
 			if (remove_source_files == 1)
 				goto return_with_success;
 		}
-		return;
+		goto cleanup;
 	}
 
 	if (!S_ISREG(file->mode)) {
-		if (the_file_list->count == 1)
+		if (solo_file)
 			fname = f_name(file, NULL);
 		rprintf(FINFO, "skipping non-regular file \"%s\"\n", fname);
-		return;
+		goto cleanup;
 	}
 
-	if (max_size && file->length > max_size) {
+	if (max_size > 0 && F_LENGTH(file) > max_size) {
 		if (verbose > 1) {
-			if (the_file_list->count == 1)
+			if (solo_file)
 				fname = f_name(file, NULL);
 			rprintf(FINFO, "%s is over max-size\n", fname);
 		}
-		return;
+		goto cleanup;
 	}
-	if (min_size && file->length < min_size) {
+	if (min_size > 0 && F_LENGTH(file) < min_size) {
 		if (verbose > 1) {
-			if (the_file_list->count == 1)
+			if (solo_file)
 				fname = f_name(file, NULL);
 			rprintf(FINFO, "%s is under min-size\n", fname);
 		}
-		return;
+		goto cleanup;
 	}
 
-	if (ignore_existing && statret == 0) {
+	if (ignore_existing > 0 && statret == 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s exists\n", fname);
-		return;
+		goto cleanup;
 	}
 
-	if (update_only && statret == 0
-	    && cmp_time(st.st_mtime, file->modtime) > 0) {
+	if (update_only > 0 && statret == 0
+	    && cmp_time(sx.st.st_mtime, file->modtime) > 0) {
 		if (verbose > 1)
 			rprintf(FINFO, "%s is newer\n", fname);
-		return;
+		goto cleanup;
 	}
 
 	fnamecmp = fname;
 	fnamecmp_type = FNAMECMP_FNAME;
 
-	if (statret == 0 && !S_ISREG(st.st_mode)) {
-		if (delete_item(fname, st.st_mode, del_opts) != 0)
-			return;
+	if (statret == 0 && !S_ISREG(sx.st.st_mode)) {
+		if (delete_item(fname, sx.st.st_mode, del_opts | DEL_FOR_FILE) != 0)
+			goto cleanup;
 		statret = -1;
 		stat_errno = ENOENT;
 	}
 
 	if (statret != 0 && basis_dir[0] != NULL) {
-		int j = try_dests_reg(file, fname, ndx, fnamecmpbuf, &st,
-				      itemizing, maybe_ATTRS_REPORT, code);
+		int j = try_dests_reg(file, fname, ndx, fnamecmpbuf, &sx,
+				      itemizing, code);
 		if (j == -2) {
 			if (remove_source_files == 1)
 				goto return_with_success;
-			return;
+			goto cleanup;
 		}
 		if (j >= 0) {
 			fnamecmp = fnamecmpbuf;
 			fnamecmp_type = j;
 			statret = 0;
 		}
 	}
 
 	real_ret = statret;
-	real_st = st;
+	real_sx = sx;
 
 	if (partial_dir && (partialptr = partial_dir_fname(fname)) != NULL
 	    && link_stat(partialptr, &partial_st, 0) == 0
 	    && S_ISREG(partial_st.st_mode)) {
 		if (statret != 0)
 			goto prepare_to_open;
@@ -1186,187 +1711,344 @@
 			fuzzy_file = fuzzy_dirlist->files[j];
 			f_name(fuzzy_file, fnamecmpbuf);
 			if (verbose > 2) {
 				rprintf(FINFO, "fuzzy basis selected for %s: %s\n",
 					fname, fnamecmpbuf);
 			}
-			st.st_size = fuzzy_file->length;
+			sx.st.st_size = F_LENGTH(fuzzy_file);
 			statret = 0;
 			fnamecmp = fnamecmpbuf;
 			fnamecmp_type = FNAMECMP_FUZZY;
 		}
 	}
 
 	if (statret != 0) {
-		if (preserve_hard_links && file->link_u.links
-		    && hard_link_check(file, ndx, fname, statret, &st,
-				       itemizing, code, HL_SKIP))
-			return;
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
+			cur_flist->in_progress++;
+			goto cleanup;
+		}
+#endif
 		if (stat_errno == ENOENT)
 			goto notify_others;
-		rsyserr(FERROR, stat_errno, "recv_generator: failed to stat %s",
+		rsyserr(FERROR_XFER, stat_errno, "recv_generator: failed to stat %s",
 			full_fname(fname));
-		return;
+		goto cleanup;
 	}
 
-	if (append_mode && st.st_size > file->length)
-		return;
+	if (append_mode > 0 && sx.st.st_size >= F_LENGTH(file))
+		goto cleanup;
 
 	if (fnamecmp_type <= FNAMECMP_BASIS_DIR_HIGH)
 		;
 	else if (fnamecmp_type == FNAMECMP_FUZZY)
 		;
-	else if (unchanged_file(fnamecmp, file, &st)) {
+	else if (unchanged_file(fnamecmp, file, &sx.st)) {
 		if (partialptr) {
 			do_unlink(partialptr);
 			handle_partial_dir(partialptr, PDIR_DELETE);
 		}
-		if (itemizing) {
-			itemize(file, ndx, real_ret, &real_st,
-				0, 0, NULL);
-		}
-		set_file_attrs(fname, file, &st, maybe_ATTRS_REPORT);
-		if (preserve_hard_links && file->link_u.links)
-			hard_link_cluster(file, ndx, itemizing, code);
+		set_file_attrs(fname, file, &sx, NULL, maybe_ATTRS_REPORT);
+		if (itemizing)
+			itemize(fnamecmp, file, ndx, statret, &sx, 0, 0, NULL);
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_IS_HLINKED(file))
+			finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
+#endif
 		if (remove_source_files != 1)
-			return;
+			goto cleanup;
 	  return_with_success:
-		if (!dry_run) {
-			char numbuf[4];
-			SIVAL(numbuf, 0, ndx);
-			send_msg(MSG_SUCCESS, numbuf, 4);
-		}
-		return;
+		if (!dry_run)
+			send_msg_int(MSG_SUCCESS, ndx);
+		goto cleanup;
 	}
 
   prepare_to_open:
 	if (partialptr) {
-		st = partial_st;
+		sx.st = partial_st;
 		fnamecmp = partialptr;
 		fnamecmp_type = FNAMECMP_PARTIAL_DIR;
 		statret = 0;
 	}
 
-	if (!do_xfers || read_batch || whole_file)
+	if (!do_xfers)
 		goto notify_others;
 
+	if (read_batch || whole_file) {
+		if (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {
+			if (!(backupptr = get_backup_name(fname)))
+				goto cleanup;
+			if (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS)))
+				goto pretend_missing;
+			if (copy_file(fname, backupptr, -1, back_file->mode, 1) < 0) {
+				unmake_file(back_file);
+				back_file = NULL;
+				goto cleanup;
+			}
+		}
+		goto notify_others;
+	}
+
 	if (fuzzy_dirlist) {
 		int j = flist_find(fuzzy_dirlist, file);
 		if (j >= 0) /* don't use changing file as future fuzzy basis */
-			fuzzy_dirlist->files[j]->flags |= FLAG_NO_FUZZY;
+			fuzzy_dirlist->files[j]->flags |= FLAG_FILE_SENT;
 	}
 
 	/* open the file */
-	fd = do_open(fnamecmp, O_RDONLY, 0);
-
-	if (fd == -1) {
+	if ((fd = do_open(fnamecmp, O_RDONLY, 0)) < 0) {
 		rsyserr(FERROR, errno, "failed to open %s, continuing",
 			full_fname(fnamecmp));
 	  pretend_missing:
 		/* pretend the file didn't exist */
-		if (preserve_hard_links && file->link_u.links
-		    && hard_link_check(file, ndx, fname, statret, &st,
-				       itemizing, code, HL_SKIP))
-			return;
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_HLINK_NOT_LAST(file)) {
+			cur_flist->in_progress++;
+			goto cleanup;
+		}
+#endif
 		statret = real_ret = -1;
 		goto notify_others;
 	}
 
-	if (inplace && make_backups && fnamecmp_type == FNAMECMP_FNAME) {
+	if (inplace && make_backups > 0 && fnamecmp_type == FNAMECMP_FNAME) {
 		if (!(backupptr = get_backup_name(fname))) {
 			close(fd);
-			return;
+			goto cleanup;
 		}
 		if (!(back_file = make_file(fname, NULL, NULL, 0, NO_FILTERS))) {
 			close(fd);
 			goto pretend_missing;
 		}
 		if (robust_unlink(backupptr) && errno != ENOENT) {
-			rsyserr(FERROR, errno, "unlink %s",
+			rsyserr(FERROR_XFER, errno, "unlink %s",
 				full_fname(backupptr));
-			free(back_file);
+			unmake_file(back_file);
+			back_file = NULL;
 			close(fd);
-			return;
+			goto cleanup;
 		}
-		if ((f_copy = do_open(backupptr,
-		    O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0) {
-			rsyserr(FERROR, errno, "open %s",
+		if ((f_copy = do_open(backupptr, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0
+		 && (errno != ENOENT || make_bak_dir(backupptr) < 0
+		  || (f_copy = do_open(backupptr, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, 0600)) < 0)) {
+			rsyserr(FERROR_XFER, errno, "open %s",
 				full_fname(backupptr));
-			free(back_file);
+			unmake_file(back_file);
+			back_file = NULL;
 			close(fd);
-			return;
+			goto cleanup;
 		}
 		fnamecmp_type = FNAMECMP_BACKUP;
 	}
 
 	if (verbose > 3) {
 		rprintf(FINFO, "gen mapped %s of size %.0f\n",
-			fnamecmp, (double)st.st_size);
+			fnamecmp, (double)sx.st.st_size);
 	}
 
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", ndx);
 
   notify_others:
 	if (remove_source_files && !delay_updates && !phase)
 		increment_active_files(ndx, itemizing, code);
-	write_int(f_out, ndx);
+	if (inc_recurse && !dry_run)
+		cur_flist->in_progress++;
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && F_IS_HLINKED(file))
+		file->flags |= FLAG_FILE_SENT;
+#endif
+	write_ndx(f_out, ndx);
 	if (itemizing) {
 		int iflags = ITEM_TRANSFER;
-		if (always_checksum)
+		if (always_checksum > 0)
 			iflags |= ITEM_REPORT_CHECKSUM;
 		if (fnamecmp_type != FNAMECMP_FNAME)
 			iflags |= ITEM_BASIS_TYPE_FOLLOWS;
 		if (fnamecmp_type == FNAMECMP_FUZZY)
 			iflags |= ITEM_XNAME_FOLLOWS;
-		itemize(file, -1, real_ret, &real_st, iflags, fnamecmp_type,
+		itemize(fnamecmp, file, -1, real_ret, &real_sx, iflags, fnamecmp_type,
 			fuzzy_file ? fuzzy_file->basename : NULL);
+#ifdef SUPPORT_ACLS
+		if (preserve_acls)
+			free_acl(&real_sx);
+#endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs)
+			free_xattr(&real_sx);
+#endif
 	}
 
 	if (!do_xfers) {
-		if (preserve_hard_links && file->link_u.links)
-			hard_link_cluster(file, ndx, itemizing, code);
-		return;
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && F_IS_HLINKED(file))
+			finish_hard_link(file, fname, ndx, &sx.st, itemizing, code, -1);
+#endif
+		goto cleanup;
 	}
 	if (read_batch)
-		return;
+		goto cleanup;
 
-	if (statret != 0 || whole_file) {
+	if (statret != 0 || whole_file)
 		write_sum_head(f_out, NULL);
-		return;
+	else {
+		generate_and_send_sums(fd, sx.st.st_size, f_out, f_copy);
+		close(fd);
 	}
 
-	generate_and_send_sums(fd, st.st_size, f_out, f_copy);
-
-	if (f_copy >= 0) {
-		close(f_copy);
-		set_file_attrs(backupptr, back_file, NULL, 0);
+  cleanup:
+	if (back_file) {
+		if (f_copy >= 0)
+			close(f_copy);
+		set_file_attrs(backupptr, back_file, NULL, NULL, 0);
 		if (verbose > 1) {
 			rprintf(FINFO, "backed up %s to %s\n",
 				fname, backupptr);
 		}
-		free(back_file);
+		unmake_file(back_file);
+	}
+
+#ifdef SUPPORT_ACLS
+	if (preserve_acls)
+		free_acl(&sx);
+#endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs)
+		free_xattr(&sx);
+#endif
+	return;
+}
+
+static void touch_up_dirs(struct file_list *flist, int ndx)
+{
+	static int counter = 0;
+	struct file_struct *file;
+	char *fname;
+	int i, start, end;
+
+	if (ndx < 0) {
+		start = 0;
+		end = flist->used - 1;
+	} else
+		start = end = ndx;
+
+	/* Fix any directory permissions that were modified during the
+	 * transfer and/or re-set any tweaked modified-time values. */
+	for (i = start; i <= end; i++, counter++) {
+		file = flist->files[i];
+		if (!S_ISDIR(file->mode)
+		 || (!implied_dirs && file->flags & FLAG_IMPLIED_DIR))
+			continue;
+		if (verbose > 3) {
+			fname = f_name(file, NULL);
+			rprintf(FINFO, "touch_up_dirs: %s (%d)\n",
+				NS(fname), i);
+		}
+		if (!F_IS_ACTIVE(file) || file->flags & FLAG_MISSING_DIR
+		 || (!need_retouch_dir_times && file->mode & S_IWUSR))
+			continue;
+		fname = f_name(file, NULL);
+		if (!(file->mode & S_IWUSR))
+			do_chmod(fname, file->mode);
+		if (need_retouch_dir_times)
+			set_modtime(fname, file->modtime, file->mode);
+		if (allowed_lull && !(counter % lull_mod))
+			maybe_send_keepalive();
+		else if (!(counter & 0xFF))
+			maybe_flush_socket(0);
 	}
+}
+
+void check_for_finished_files(int itemizing, enum logcode code, int check_redo)
+{
+	struct file_struct *file;
+	struct file_list *flist;
+	char fbuf[MAXPATHLEN];
+	int ndx;
+
+	while (1) {
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && (ndx = get_hlink_num()) != -1) {
+			flist = flist_for_ndx(ndx);
+			assert(flist != NULL);
+			file = flist->files[ndx - flist->ndx_start];
+			assert(file->flags & FLAG_HLINKED);
+			finish_hard_link(file, f_name(file, fbuf), ndx, NULL, itemizing, code, -1);
+			flist->in_progress--;
+			continue;
+		}
+#endif
+
+		if (check_redo && (ndx = get_redo_num()) != -1) {
+			csum_length = SUM_LENGTH;
+			max_size = -max_size;
+			min_size = -min_size;
+			ignore_existing = -ignore_existing;
+			ignore_non_existing = -ignore_non_existing;
+			update_only = -update_only;
+			always_checksum = -always_checksum;
+			size_only = -size_only;
+			append_mode = -append_mode;
+			make_backups = -make_backups; /* avoid dup backup w/inplace */
+			ignore_times++;
+
+			flist = cur_flist;
+			cur_flist = flist_for_ndx(ndx);
+
+			file = cur_flist->files[ndx - cur_flist->ndx_start];
+			if (solo_file)
+				strlcpy(fbuf, solo_file, sizeof fbuf);
+			else
+				f_name(file, fbuf);
+			recv_generator(fbuf, file, ndx, itemizing, code, sock_f_out);
+			cur_flist->to_redo--;
+
+			cur_flist = flist;
+
+			csum_length = SHORT_SUM_LENGTH;
+			max_size = -max_size;
+			min_size = -min_size;
+			ignore_existing = -ignore_existing;
+			ignore_non_existing = -ignore_non_existing;
+			update_only = -update_only;
+			always_checksum = -always_checksum;
+			size_only = -size_only;
+			append_mode = -append_mode;
+			make_backups = -make_backups;
+			ignore_times--;
+			continue;
+		}
+
+		if (cur_flist == first_flist)
+			break;
 
-	close(fd);
+		/* We only get here if inc_recurse is enabled. */
+		if (first_flist->in_progress || first_flist->to_redo)
+			break;
+
+		if (!read_batch) {
+			write_ndx(sock_f_out, NDX_DONE);
+			maybe_flush_socket(1);
+		}
+
+		if (delete_during == 2 || !dir_tweaking) {
+			/* Skip directory touch-up. */
+		} else if (first_flist->parent_ndx >= 0)
+			touch_up_dirs(dir_flist, first_flist->parent_ndx);
+
+		flist_free(first_flist); /* updates first_flist */
+	}
 }
 
-void generate_files(int f_out, struct file_list *flist, char *local_name)
+void generate_files(int f_out, const char *local_name)
 {
-	int i;
+	int i, ndx;
 	char fbuf[MAXPATHLEN];
-	int itemizing, maybe_ATTRS_REPORT;
+	int itemizing;
 	enum logcode code;
-	int lull_mod = allowed_lull * 5;
-	int need_retouch_dir_times = preserve_times && !omit_dir_times;
-	int need_retouch_dir_perms = 0;
-	int save_ignore_existing = ignore_existing;
-	int save_ignore_non_existing = ignore_non_existing;
 	int save_do_progress = do_progress;
-	int save_make_backups = make_backups;
-	int dir_tweaking = !(list_only || local_name || dry_run);
 
 	if (protocol_version >= 29) {
 		itemizing = 1;
 		maybe_ATTRS_REPORT = stdout_format_has_i ? 0 : ATTRS_REPORT;
 		code = logfile_format_has_i ? FNONE : FLOG;
 	} else if (am_daemon) {
@@ -1379,23 +2061,31 @@
 		code = itemizing ? FNONE : FINFO;
 	} else {
 		itemizing = 0;
 		maybe_ATTRS_REPORT = ATTRS_REPORT;
 		code = FINFO;
 	}
+	solo_file = local_name;
+	dir_tweaking = !(list_only || solo_file || dry_run);
+	need_retouch_dir_times = preserve_times > 1;
+	lull_mod = allowed_lull * 5;
 
-	if (verbose > 2) {
-		rprintf(FINFO, "generator starting pid=%ld count=%d\n",
-			(long)getpid(), flist->count);
-	}
+	if (verbose > 2)
+		rprintf(FINFO, "generator starting pid=%ld\n", (long)getpid());
 
-	if (delete_before && !local_name && flist->count > 0)
-		do_delete_pass(flist);
+	if (delete_before && !solo_file && cur_flist->used > 0)
+		do_delete_pass();
+	if (delete_during == 2) {
+		deldelay_size = BIGPATHBUFLEN * 4;
+		deldelay_buf = new_array(char, deldelay_size);
+		if (!deldelay_buf)
+			out_of_memory("delete-delay");
+	}
 	do_progress = 0;
 
-	if (append_mode || whole_file < 0)
+	if (append_mode > 0 || whole_file < 0)
 		whole_file = 0;
 	if (verbose >= 2) {
 		rprintf(FINFO, "delta-transmission %s\n",
 			whole_file
 			? "disabled for local transfer or --whole-file"
 			: "enabled");
@@ -1404,146 +2094,132 @@
 	/* Since we often fill up the outgoing socket and then just sit around
 	 * waiting for the other 2 processes to do their thing, we don't want
 	 * to exit on a timeout.  If the data stops flowing, the receiver will
 	 * notice that and let us know via the redo pipe (or its closing). */
 	ignore_timeout = 1;
 
-	for (i = 0; i < flist->count; i++) {
-		struct file_struct *file = flist->files[i];
+	dflt_perms = (ACCESSPERMS & ~orig_umask);
 
-		if (!file->basename)
-			continue;
+	do {
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links && inc_recurse) {
+			while (!flist_eof && file_total < FILECNT_LOOKAHEAD/2)
+				wait_for_receiver();
+		}
+#endif
 
-		if (local_name)
-			strlcpy(fbuf, local_name, sizeof fbuf);
-		else
-			f_name(file, fbuf);
-		recv_generator(fbuf, file, i, itemizing, maybe_ATTRS_REPORT,
-			       code, f_out);
-
-		/* We need to ensure that any dirs we create have writeable
-		 * permissions during the time we are putting files within
-		 * them.  This is then fixed after the transfer is done. */
-#ifdef HAVE_CHMOD
-		if (!am_root && S_ISDIR(file->mode) && !(file->mode & S_IWUSR)
-		 && dir_tweaking) {
-			mode_t mode = file->mode | S_IWUSR; /* user write */
-			char *fname = local_name ? local_name : fbuf;
-			if (do_chmod(fname, mode) < 0) {
-				rsyserr(FERROR, errno,
-					"failed to modify permissions on %s",
-					full_fname(fname));
+		if (inc_recurse && cur_flist->parent_ndx >= 0) {
+			struct file_struct *fp = dir_flist->files[cur_flist->parent_ndx];
+			f_name(fp, fbuf);
+			ndx = cur_flist->ndx_start - 1;
+			recv_generator(fbuf, fp, ndx, itemizing, code, f_out);
+			if (delete_during && dry_run < 2 && !list_only) {
+				if (BITS_SETnUNSET(fp->flags, FLAG_CONTENT_DIR, FLAG_MISSING_DIR)) {
+					dev_t dirdev;
+					if (one_file_system) {
+						uint32 *devp = F_DIR_DEV_P(fp);
+						dirdev = MAKEDEV(DEV_MAJOR(devp), DEV_MINOR(devp));
+					} else
+						dirdev = MAKEDEV(0, 0);
+					delete_in_dir(f_name(fp, fbuf), fp, &dirdev);
+				}
 			}
-			need_retouch_dir_perms = 1;
 		}
-#endif
+		for (i = cur_flist->low; i <= cur_flist->high; i++) {
+			struct file_struct *file = cur_flist->sorted[i];
+
+			if (!F_IS_ACTIVE(file))
+				continue;
 
-		if (preserve_hard_links)
-			check_for_finished_hlinks(itemizing, code);
+			if (unsort_ndx)
+				ndx = F_NDX(file);
+			else
+				ndx = i + cur_flist->ndx_start;
+
+			if (solo_file)
+				strlcpy(fbuf, solo_file, sizeof fbuf);
+			else
+				f_name(file, fbuf);
+			recv_generator(fbuf, file, ndx, itemizing, code, f_out);
 
-		if (allowed_lull && !(i % lull_mod))
-			maybe_send_keepalive();
-		else if (!(i % 200))
-			maybe_flush_socket();
-	}
-	recv_generator(NULL, NULL, 0, 0, 0, code, -1);
-	if (delete_during)
-		delete_in_dir(NULL, NULL, NULL, NULL);
+			check_for_finished_files(itemizing, code, 0);
 
-	phase++;
-	csum_length = SUM_LENGTH;
-	max_size = min_size = ignore_existing = ignore_non_existing = 0;
-	update_only = always_checksum = size_only = 0;
-	ignore_times = 1;
-	if (append_mode)  /* resend w/o append mode */
-		append_mode = -1; /* ... but only longer files */
-	make_backups = 0; /* avoid a duplicate backup for inplace processing */
+			if (allowed_lull && !(i % lull_mod))
+				maybe_send_keepalive();
+			else if (!(i & 0xFF))
+				maybe_flush_socket(0);
+		}
 
-	if (verbose > 2)
-		rprintf(FINFO,"generate_files phase=%d\n",phase);
+		if (!inc_recurse) {
+			write_ndx(f_out, NDX_DONE);
+			break;
+		}
 
-	write_int(f_out, -1);
+		while (1) {
+			check_for_finished_files(itemizing, code, 1);
+			if (cur_flist->next || flist_eof)
+				break;
+			wait_for_receiver();
+		}
+	} while ((cur_flist = cur_flist->next) != NULL);
+
+	if (delete_during)
+		delete_in_dir(NULL, NULL, &dev_zero);
+	phase++;
+	if (verbose > 2)
+		rprintf(FINFO, "generate_files phase=%d\n", phase);
 
-	/* files can cycle through the system more than once
-	 * to catch initial checksum errors */
-	while ((i = get_redo_num(itemizing, code)) != -1) {
-		struct file_struct *file = flist->files[i];
-		if (local_name)
-			strlcpy(fbuf, local_name, sizeof fbuf);
-		else
-			f_name(file, fbuf);
-		recv_generator(fbuf, file, i, itemizing, maybe_ATTRS_REPORT,
-			       code, f_out);
+	while (1) {
+		check_for_finished_files(itemizing, code, 1);
+		if (msgdone_cnt)
+			break;
+		wait_for_receiver();
 	}
 
 	phase++;
-	ignore_non_existing = save_ignore_non_existing;
-	ignore_existing = save_ignore_existing;
-	make_backups = save_make_backups;
-
 	if (verbose > 2)
-		rprintf(FINFO,"generate_files phase=%d\n",phase);
+		rprintf(FINFO, "generate_files phase=%d\n", phase);
 
-	write_int(f_out, -1);
+	write_ndx(f_out, NDX_DONE);
 	/* Reduce round-trip lag-time for a useless delay-updates phase. */
 	if (protocol_version >= 29 && !delay_updates)
-		write_int(f_out, -1);
+		write_ndx(f_out, NDX_DONE);
 
 	/* Read MSG_DONE for the redo phase (and any prior messages). */
-	get_redo_num(itemizing, code);
+	while (1) {
+		check_for_finished_files(itemizing, code, 0);
+		if (msgdone_cnt > 1)
+			break;
+		wait_for_receiver();
+	}
 
 	if (protocol_version >= 29) {
 		phase++;
 		if (verbose > 2)
 			rprintf(FINFO, "generate_files phase=%d\n", phase);
 		if (delay_updates)
-			write_int(f_out, -1);
+			write_ndx(f_out, NDX_DONE);
 		/* Read MSG_DONE for delay-updates phase & prior messages. */
-		get_redo_num(itemizing, code);
+		while (msgdone_cnt == 2)
+			wait_for_receiver();
 	}
 
 	do_progress = save_do_progress;
-	if (delete_after && !local_name && flist->count > 0)
-		do_delete_pass(flist);
-
-	if ((need_retouch_dir_perms || need_retouch_dir_times) && dir_tweaking) {
-		int j = 0;
-		/* Now we need to fix any directory permissions that were
-		 * modified during the transfer and/or re-set any tweaked
-		 * modified-time values. */
-		for (i = 0; i < flist->count; i++) {
-			struct file_struct *file = flist->files[i];
-
-			if (!file->basename || !S_ISDIR(file->mode))
-				continue;
-			if (!need_retouch_dir_times && file->mode & S_IWUSR)
-				continue;
-			if (file->flags & FLAG_MISSING) {
-				int missing = file->dir.depth;
-				while (++i < flist->count) {
-					file = flist->files[i];
-					if (file->dir.depth <= missing)
-						break;
-				}
-				i--;
-				continue;
-			}
-			recv_generator(f_name(file, NULL), file, i, itemizing,
-				       maybe_ATTRS_REPORT, code, -1);
-			if (allowed_lull && !(++j % lull_mod))
-				maybe_send_keepalive();
-			else if (!(j % 200))
-				maybe_flush_socket();
-		}
-	}
-	recv_generator(NULL, NULL, 0, 0, 0, code, -1);
+	if (delete_during == 2)
+		do_delayed_deletions(fbuf);
+	if (delete_after && !solo_file && file_total > 0)
+		do_delete_pass();
+
+	if ((need_retouch_dir_perms || need_retouch_dir_times)
+	 && dir_tweaking && (!inc_recurse || delete_during == 2))
+		touch_up_dirs(dir_flist, -1);
 
-	if (max_delete > 0 && deletion_count > max_delete) {
+	if (max_delete >= 0 && deletion_count > max_delete) {
 		rprintf(FINFO,
 			"Deletions stopped due to --max-delete limit (%d skipped)\n",
 			deletion_count - max_delete);
 		io_error |= IOERR_DEL_LIMIT;
 	}
 
 	if (verbose > 2)
-		rprintf(FINFO,"generate_files finished\n");
+		rprintf(FINFO, "generate_files finished\n");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/getgroups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/getgroups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/getgroups.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/getgroups.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,26 +1,24 @@
 /*
  * Print out the gids of all groups for the current user.  This is like
  * `id -G` on Linux, but it's too hard to find a portable equivalent.
  *
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003, 2004 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
+ * it under the terms of the GNU General Public License version 3 as
+ * published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 int
 main(UNUSED(int argc), UNUSED(char *argv[]))
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: .gitignore
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: hashtable.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/hlink.c	2006-10-18 02:49:04.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/hlink.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,315 +1,477 @@
 /*
  * Routines to support hard-linking.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
+extern int dry_run;
+extern int list_only;
+extern int am_sender;
+extern int inc_recurse;
 extern int do_xfers;
 extern int link_dest;
+extern int preserve_acls;
 extern int make_backups;
+extern int protocol_version;
 extern int remove_source_files;
 extern int stdout_format_has_i;
+extern int maybe_ATTRS_REPORT;
+extern int unsort_ndx;
 extern char *basis_dir[];
-extern struct file_list *the_file_list;
+extern struct file_list *cur_flist;
 
 #ifdef SUPPORT_HARD_LINKS
 
-#define SKIPPED_LINK (-1)
-#define FINISHED_LINK (-2)
+/* Starting with protocol 30, we use a simple hashtable on the sending side
+ * for hashing the st_dev and st_ino info.  The receiving side gets told
+ * (via flags and a "group index") which items are hard-linked together, so
+ * we can avoid the pool of dev+inode data.  For incremental recursion mode,
+ * the receiver will use a ndx hash to remember old pathnames. */
 
-#define FPTR(i) (the_file_list->files[i])
-#define LINKED(p1,p2) (FPTR(p1)->F_DEV == FPTR(p2)->F_DEV \
-		    && FPTR(p1)->F_INODE == FPTR(p2)->F_INODE)
+static struct hashtable *dev_tbl;
 
-static int hlink_compare(int *int1, int *int2)
+static struct hashtable *prior_hlinks;
+
+static struct file_list *hlink_flist;
+
+void init_hard_links(void)
 {
-	struct file_struct *f1 = FPTR(*int1);
-	struct file_struct *f2 = FPTR(*int2);
+	if (am_sender || protocol_version < 30)
+		dev_tbl = hashtable_create(16, SIZEOF_INT64 == 8);
+	else if (inc_recurse)
+		prior_hlinks = hashtable_create(1024, 0);
+}
 
-	if (f1->F_DEV != f2->F_DEV)
-		return (int) (f1->F_DEV > f2->F_DEV ? 1 : -1);
+struct ht_int64_node *idev_find(int64 dev, int64 ino)
+{
+	static struct ht_int64_node *dev_node = NULL;
+	struct hashtable *tbl;
 
-	if (f1->F_INODE != f2->F_INODE)
-		return (int) (f1->F_INODE > f2->F_INODE ? 1 : -1);
+	if (!dev_node || dev_node->key != dev) {
+		/* We keep a separate hash table of inodes for every device. */
+		dev_node = hashtable_find(dev_tbl, dev, 1);
+		if (!(tbl = dev_node->data))
+			tbl = dev_node->data = hashtable_create(512, SIZEOF_INT64 == 8);
+	} else
+		tbl = dev_node->data;
 
-	return f_name_cmp(f1, f2);
+	return hashtable_find(tbl, ino, 1);
 }
 
-static int32 *hlink_list;
-static int32 hlink_count;
+void idev_destroy(void)
+{
+	int i;
+
+	for (i = 0; i < dev_tbl->size; i++) {
+		struct ht_int32_node *node = HT_NODE(dev_tbl, dev_tbl->nodes, i);
+		if (node->data)
+			hashtable_destroy(node->data);
+	}
+
+	hashtable_destroy(dev_tbl);
+}
 
-/* Analyze the data in the hlink_list[], remove items that aren't multiply
- * linked, and replace the dev+inode data with the hlindex+next linked list. */
-static void link_idev_data(void)
+static int hlink_compare_gnum(int *int1, int *int2)
 {
-	int32 cur, from, to, start;
+	struct file_struct *f1 = hlink_flist->sorted[*int1];
+	struct file_struct *f2 = hlink_flist->sorted[*int2];
+	int32 gnum1 = F_HL_GNUM(f1);
+	int32 gnum2 = F_HL_GNUM(f2);
 
-	alloc_pool_t hlink_pool;
-	alloc_pool_t idev_pool = the_file_list->hlink_pool;
+	if (gnum1 != gnum2)
+		return gnum1 > gnum2 ? 1 : -1;
 
-	hlink_pool = pool_create(128 * 1024, sizeof (struct hlink),
-	    out_of_memory, POOL_INTERN);
+	return *int1 > *int2 ? 1 : -1;
+}
 
-	for (from = to = 0; from < hlink_count; from++) {
-		start = from;
-		while (1) {
-			cur = hlink_list[from];
-			if (from == hlink_count-1
-			    || !LINKED(cur, hlink_list[from+1]))
+static void match_gnums(int32 *ndx_list, int ndx_count)
+{
+	int32 from, prev;
+	struct file_struct *file, *file_next;
+	struct ht_int32_node *node = NULL;
+	int32 gnum, gnum_next;
+
+	qsort(ndx_list, ndx_count, sizeof ndx_list[0],
+	     (int (*)()) hlink_compare_gnum);
+
+	for (from = 0; from < ndx_count; from++) {
+		file = hlink_flist->sorted[ndx_list[from]];
+		gnum = F_HL_GNUM(file);
+		if (inc_recurse) {
+			node = hashtable_find(prior_hlinks, gnum, 1);
+			if (!node->data) {
+				node->data = new_array0(char, 5);
+				assert(gnum >= hlink_flist->ndx_start);
+				file->flags |= FLAG_HLINK_FIRST;
+				prev = -1;
+			} else if (CVAL(node->data, 0) == 0) {
+				struct file_list *flist;
+				struct file_struct *fp;
+				prev = IVAL(node->data, 1);
+				flist = flist_for_ndx(prev);
+				assert(flist != NULL);
+				fp = flist->files[prev - flist->ndx_start];
+				fp->flags &= ~FLAG_HLINK_LAST;
+			} else
+				prev = -1;
+		} else {
+			file->flags |= FLAG_HLINK_FIRST;
+			prev = -1;
+		}
+		for ( ; from < ndx_count-1; file = file_next, gnum = gnum_next, from++) { /*SHARED ITERATOR*/
+			file_next = hlink_flist->sorted[ndx_list[from+1]];
+			gnum_next = F_HL_GNUM(file_next);
+			if (gnum != gnum_next)
 				break;
-			pool_free(idev_pool, 0, FPTR(cur)->link_u.idev);
-			FPTR(cur)->link_u.links = pool_talloc(hlink_pool,
-			    struct hlink, 1, "hlink_list");
-
-			FPTR(cur)->F_HLINDEX = to;
-			FPTR(cur)->F_NEXT = hlink_list[++from];
-			FPTR(cur)->link_u.links->link_dest_used = 0;
-		}
-		pool_free(idev_pool, 0, FPTR(cur)->link_u.idev);
-		if (from > start) {
-			int head = hlink_list[start];
-			FPTR(cur)->link_u.links = pool_talloc(hlink_pool,
-			    struct hlink, 1, "hlink_list");
-
-			FPTR(head)->flags |= FLAG_HLINK_TOL;
-			FPTR(cur)->F_HLINDEX = to;
-			FPTR(cur)->F_NEXT = head;
-			FPTR(cur)->flags |= FLAG_HLINK_EOL;
-			FPTR(cur)->link_u.links->link_dest_used = 0;
-			hlink_list[to++] = head;
-		} else
-			FPTR(cur)->link_u.links = NULL;
-	}
+			F_HL_PREV(file) = prev;
+			/* The linked list uses over-the-wire ndx values. */
+			if (unsort_ndx)
+				prev = F_NDX(file);
+			else
+				prev = ndx_list[from] + hlink_flist->ndx_start;
+		}
+		if (prev < 0 && !inc_recurse) {
+			/* Disable hard-link bit and set DONE so that
+			 * HLINK_BUMP()-dependent values are unaffected. */
+			file->flags &= ~(FLAG_HLINKED | FLAG_HLINK_FIRST);
+			file->flags |= FLAG_HLINK_DONE;
+			continue;
+		}
 
-	if (!to) {
-		free(hlink_list);
-		hlink_list = NULL;
-		pool_destroy(hlink_pool);
-		hlink_pool = NULL;
-	} else {
-		hlink_count = to;
-		hlink_list = realloc_array(hlink_list, int32, hlink_count);
-		if (!hlink_list)
-			out_of_memory("init_hard_links");
+		file->flags |= FLAG_HLINK_LAST;
+		F_HL_PREV(file) = prev;
+		if (inc_recurse && CVAL(node->data, 0) == 0) {
+			if (unsort_ndx)
+				prev = F_NDX(file);
+			else
+				prev = ndx_list[from] + hlink_flist->ndx_start;
+			SIVAL(node->data, 1, prev);
+		}
 	}
-	the_file_list->hlink_pool = hlink_pool;
-	pool_destroy(idev_pool);
 }
-#endif
 
-void init_hard_links(void)
+/* Analyze the hard-links in the file-list by creating a list of all the
+ * items that have hlink data, sorting them, and matching up identical
+ * values into clusters.  These will be a single linked list from last
+ * to first when we're done. */
+void match_hard_links(struct file_list *flist)
 {
-#ifdef SUPPORT_HARD_LINKS
-	int i;
+	if (!list_only) {
+		int i, ndx_count = 0;
+		int32 *ndx_list;
+
+		if (!(ndx_list = new_array(int32, flist->used)))
+			out_of_memory("match_hard_links");
+
+		for (i = 0; i < flist->used; i++) {
+			if (F_IS_HLINKED(flist->sorted[i]))
+				ndx_list[ndx_count++] = i;
+		}
 
-	if (hlink_list)
-		free(hlink_list);
+		hlink_flist = flist;
 
-	if (!(hlink_list = new_array(int32, the_file_list->count)))
-		out_of_memory("init_hard_links");
+		if (ndx_count)
+			match_gnums(ndx_list, ndx_count);
 
-	hlink_count = 0;
-	for (i = 0; i < the_file_list->count; i++) {
-		if (FPTR(i)->link_u.idev)
-			hlink_list[hlink_count++] = i;
+		free(ndx_list);
 	}
-
-	qsort(hlink_list, hlink_count,
-	    sizeof hlink_list[0], (int (*)()) hlink_compare);
-
-	if (!hlink_count) {
-		free(hlink_list);
-		hlink_list = NULL;
-	} else
-		link_idev_data();
-#endif
+	if (protocol_version < 30)
+		idev_destroy();
 }
 
-#ifdef SUPPORT_HARD_LINKS
 static int maybe_hard_link(struct file_struct *file, int ndx,
-			   char *fname, int statret, STRUCT_STAT *st,
-			   char *toname, STRUCT_STAT *to_st,
-			   int itemizing, enum logcode code)
+			   const char *fname, int statret, stat_x *sxp,
+			   const char *oldname, STRUCT_STAT *old_stp,
+			   const char *realname, int itemizing, enum logcode code)
 {
 	if (statret == 0) {
-		if (st->st_dev == to_st->st_dev
-		 && st->st_ino == to_st->st_ino) {
+		if (sxp->st.st_dev == old_stp->st_dev
+		 && sxp->st.st_ino == old_stp->st_ino) {
 			if (itemizing) {
-				itemize(file, ndx, statret, st,
+				itemize(fname, file, ndx, statret, sxp,
 					ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS,
 					0, "");
 			}
+			if (verbose > 1 && maybe_ATTRS_REPORT)
+				rprintf(FCLIENT, "%s is uptodate\n", fname);
+			file->flags |= FLAG_HLINK_DONE;
 			return 0;
 		}
-		if (make_backups) {
+		if (make_backups > 0) {
 			if (!make_backup(fname))
 				return -1;
 		} else if (robust_unlink(fname)) {
-			rsyserr(FERROR, errno, "unlink %s failed",
+			rsyserr(FERROR_XFER, errno, "unlink %s failed",
 				full_fname(fname));
 			return -1;
 		}
 	}
-	return hard_link_one(file, ndx, fname, statret, st, toname,
-			     0, itemizing, code);
+
+	if (hard_link_one(file, fname, oldname, 0)) {
+		if (itemizing) {
+			itemize(fname, file, ndx, statret, sxp,
+				ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS, 0,
+				realname);
+		}
+		if (code != FNONE && verbose)
+			rprintf(code, "%s => %s\n", fname, realname);
+		return 0;
+	}
+	return -1;
 }
-#endif
 
-int hard_link_check(struct file_struct *file, int ndx, char *fname,
-		    int statret, STRUCT_STAT *st, int itemizing,
-		    enum logcode code, int skip)
+/* Figure out if a prior entry is still there or if we just have a
+ * cached name for it.  Never called with a FLAG_HLINK_FIRST entry. */
+static char *check_prior(int prev_ndx, int gnum, struct file_list **flist_p)
 {
-#ifdef SUPPORT_HARD_LINKS
-	int head;
-	if (skip && !(file->flags & FLAG_HLINK_EOL))
-		head = hlink_list[file->F_HLINDEX] = file->F_NEXT;
-	else
-		head = hlink_list[file->F_HLINDEX];
-	if (ndx != head) {
-		struct file_struct *head_file = FPTR(head);
-		if (!stdout_format_has_i && verbose > 1) {
-			rprintf(FINFO, "\"%s\" is a hard link\n",
-				f_name(file, NULL));
-		}
-		if (head_file->F_HLINDEX == FINISHED_LINK) {
-			STRUCT_STAT st2, st3;
-			char toname[MAXPATHLEN];
-			int ldu = head_file->link_u.links->link_dest_used;
-			if (ldu) {
-				pathjoin(toname, MAXPATHLEN, basis_dir[ldu-1],
-					 f_name(head_file, NULL));
-			} else
-				f_name(head_file, toname);
-			if (link_stat(toname, &st2, 0) < 0) {
-				rsyserr(FERROR, errno, "stat %s failed",
-					full_fname(toname));
-				return -1;
-			}
-			if (statret < 0 && basis_dir[0] != NULL) {
-				char cmpbuf[MAXPATHLEN];
-				int j = 0;
-				do {
-					pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
-					if (link_stat(cmpbuf, &st3, 0) < 0)
-						continue;
-					if (link_dest) {
-						if (st2.st_dev != st3.st_dev
-						 || st2.st_ino != st3.st_ino)
-							continue;
-						statret = 1;
-						st = &st3;
-						if (verbose < 2 || !stdout_format_has_i) {
-							itemizing = 0;
-							code = FNONE;
-						}
-						break;
-					}
-					if (!unchanged_file(cmpbuf, file, &st3))
-						continue;
-					statret = 1;
-					st = &st3;
-					if (unchanged_attrs(file, &st3))
-						break;
-				} while (basis_dir[++j] != NULL);
+	struct file_list *flist = flist_for_ndx(prev_ndx);
+	struct ht_int32_node *node;
+
+	if (flist) {
+		*flist_p = flist;
+		return NULL;
+	}
+
+	node = hashtable_find(prior_hlinks, gnum, 0);
+	assert(node != NULL && node->data);
+	assert(CVAL(node->data, 0) != 0);
+	return node->data;
+}
+
+/* Only called if FLAG_HLINKED is set and FLAG_HLINK_FIRST is not.  Returns:
+ * 0 = process the file, 1 = skip the file, -1 = error occurred. */
+int hard_link_check(struct file_struct *file, int ndx, const char *fname,
+		    int statret, stat_x *sxp, int itemizing,
+		    enum logcode code)
+{
+	STRUCT_STAT prev_st;
+	char namebuf[MAXPATHLEN], altbuf[MAXPATHLEN];
+	char *realname, *prev_name;
+	struct file_list *flist;
+	int gnum = inc_recurse ? F_HL_GNUM(file) : -1;
+	int prev_ndx = F_HL_PREV(file);
+
+	prev_name = realname = check_prior(prev_ndx, gnum, &flist);
+
+	if (!prev_name) {
+		struct file_struct *prev_file = flist->files[prev_ndx - flist->ndx_start];
+
+		/* Is the previous link not complete yet? */
+		if (!(prev_file->flags & FLAG_HLINK_DONE)) {
+			/* Is the previous link being transferred? */
+			if (prev_file->flags & FLAG_FILE_SENT) {
+				/* Add ourselves to the list of files that will
+				 * be updated when the transfer completes, and
+				 * mark ourself as waiting for the transfer. */
+				F_HL_PREV(file) = F_HL_PREV(prev_file);
+				F_HL_PREV(prev_file) = ndx;
+				file->flags |= FLAG_FILE_SENT;
+				cur_flist->in_progress++;
+				return 1;
 			}
-			maybe_hard_link(file, ndx, fname, statret, st,
-					toname, &st2, itemizing, code);
-			if (remove_source_files == 1 && do_xfers) {
-				char numbuf[4];
-				SIVAL(numbuf, 0, ndx);
-				send_msg(MSG_SUCCESS, numbuf, 4);
+			return 0;
+		}
+
+		/* There is a finished file to link with! */
+		if (!(prev_file->flags & FLAG_HLINK_FIRST)) {
+			/* The previous previous is FIRST when prev is not. */
+			prev_ndx = F_HL_PREV(prev_file);
+			prev_name = realname = check_prior(prev_ndx, gnum, &flist);
+			/* Update our previous pointer to point to the FIRST. */
+			F_HL_PREV(file) = prev_ndx;
+		}
+
+		if (!prev_name) {
+			int alt_dest;
+
+			prev_file = flist->files[prev_ndx - flist->ndx_start];
+			/* F_HL_PREV() is alt_dest value when DONE && FIRST. */
+			alt_dest = F_HL_PREV(prev_file);
+
+			if (alt_dest >= 0 && dry_run) {
+				pathjoin(namebuf, MAXPATHLEN, basis_dir[alt_dest],
+					 f_name(prev_file, NULL));
+				prev_name = namebuf;
+				realname = f_name(prev_file, altbuf);
+			} else {
+				prev_name = f_name(prev_file, namebuf);
+				realname = prev_name;
 			}
-			file->F_HLINDEX = FINISHED_LINK;
-		} else
-			file->F_HLINDEX = SKIPPED_LINK;
-		return 1;
+		}
+	}
+
+	if (link_stat(prev_name, &prev_st, 0) < 0) {
+		rsyserr(FERROR_XFER, errno, "stat %s failed",
+			full_fname(prev_name));
+		return -1;
 	}
+
+	if (statret < 0 && basis_dir[0] != NULL) {
+		/* If we match an alt-dest item, we don't output this as a change. */
+		char cmpbuf[MAXPATHLEN];
+		stat_x alt_sx;
+		int j = 0;
+#ifdef SUPPORT_ACLS
+		alt_sx.acc_acl = alt_sx.def_acl = NULL;
+#endif
+		do {
+			pathjoin(cmpbuf, MAXPATHLEN, basis_dir[j], fname);
+			if (link_stat(cmpbuf, &alt_sx.st, 0) < 0)
+				continue;
+			if (link_dest) {
+				if (prev_st.st_dev != alt_sx.st.st_dev
+				 || prev_st.st_ino != alt_sx.st.st_ino)
+					continue;
+				statret = 1;
+				if (stdout_format_has_i == 0
+				 || (verbose < 2 && stdout_format_has_i < 2)) {
+					itemizing = 0;
+					code = FNONE;
+					if (verbose > 1 && maybe_ATTRS_REPORT)
+						rprintf(FCLIENT, "%s is uptodate\n", fname);
+				}
+				break;
+			}
+			if (!unchanged_file(cmpbuf, file, &alt_sx.st))
+				continue;
+			statret = 1;
+			if (unchanged_attrs(cmpbuf, file, &alt_sx))
+				break;
+		} while (basis_dir[++j] != NULL);
+		if (statret == 1) {
+			sxp->st = alt_sx.st;
+#ifdef SUPPORT_ACLS
+			if (preserve_acls && !S_ISLNK(file->mode)) {
+				if (!ACL_READY(*sxp))
+					get_acl(cmpbuf, sxp);
+				else {
+					sxp->acc_acl = alt_sx.acc_acl;
+					sxp->def_acl = alt_sx.def_acl;
+				}
+			}
 #endif
-	return 0;
+		}
+#ifdef SUPPORT_ACLS
+		else if (preserve_acls)
+			free_acl(&alt_sx);
+#endif
+	}
+
+	if (maybe_hard_link(file, ndx, fname, statret, sxp, prev_name, &prev_st,
+			    realname, itemizing, code) < 0)
+		return -1;
+
+	if (remove_source_files == 1 && do_xfers)
+		send_msg_int(MSG_SUCCESS, ndx);
+
+	return 1;
 }
 
-#ifdef SUPPORT_HARD_LINKS
-int hard_link_one(struct file_struct *file, int ndx, char *fname,
-		  int statret, STRUCT_STAT *st, char *toname, int terse,
-		  int itemizing, enum logcode code)
+int hard_link_one(struct file_struct *file, const char *fname,
+		  const char *oldname, int terse)
 {
-	if (do_link(toname, fname)) {
+	if (do_link(oldname, fname) < 0) {
+		enum logcode code;
 		if (terse) {
 			if (!verbose)
-				return -1;
+				return 0;
 			code = FINFO;
 		} else
-			code = FERROR;
+			code = FERROR_XFER;
 		rsyserr(code, errno, "link %s => %s failed",
-			full_fname(fname), toname);
-		return -1;
+			full_fname(fname), oldname);
+		return 0;
 	}
 
-	if (itemizing) {
-		itemize(file, ndx, statret, st,
-			ITEM_LOCAL_CHANGE | ITEM_XNAME_FOLLOWS, 0,
-			terse ? "" : toname);
-	}
-	if (code != FNONE && verbose && !terse)
-		rprintf(code, "%s => %s\n", fname, toname);
-	return 0;
-}
-#endif
+	file->flags |= FLAG_HLINK_DONE;
 
+	return 1;
+}
 
-void hard_link_cluster(struct file_struct *file, int master, int itemizing,
-		       enum logcode code)
+void finish_hard_link(struct file_struct *file, const char *fname, int fin_ndx,
+		      STRUCT_STAT *stp, int itemizing, enum logcode code,
+		      int alt_dest)
 {
-#ifdef SUPPORT_HARD_LINKS
-	char hlink1[MAXPATHLEN];
-	char *hlink2;
-	STRUCT_STAT st1, st2;
-	int statret, ndx = master;
-
-	file->F_HLINDEX = FINISHED_LINK;
-	if (link_stat(f_name(file, hlink1), &st1, 0) < 0)
-		return;
-	if (!(file->flags & FLAG_HLINK_TOL)) {
-		while (!(file->flags & FLAG_HLINK_EOL)) {
-			ndx = file->F_NEXT;
-			file = FPTR(ndx);
-		}
-	}
-	do {
-		ndx = file->F_NEXT;
-		file = FPTR(ndx);
-		if (file->F_HLINDEX != SKIPPED_LINK)
-			continue;
-		hlink2 = f_name(file, NULL);
-		statret = link_stat(hlink2, &st2, 0);
-		maybe_hard_link(file, ndx, hlink2, statret, &st2,
-				hlink1, &st1, itemizing, code);
-		if (remove_source_files == 1 && do_xfers) {
-			char numbuf[4];
-			SIVAL(numbuf, 0, ndx);
-			send_msg(MSG_SUCCESS, numbuf, 4);
+	stat_x prev_sx;
+	STRUCT_STAT st;
+	char alt_name[MAXPATHLEN], *prev_name;
+	const char *our_name;
+	struct file_list *flist;
+	int prev_statret, ndx, prev_ndx = F_HL_PREV(file);
+
+	if (stp == NULL && prev_ndx >= 0) {
+		if (link_stat(fname, &st, 0) < 0) {
+			rsyserr(FERROR_XFER, errno, "stat %s failed",
+				full_fname(fname));
+			return;
 		}
-		file->F_HLINDEX = FINISHED_LINK;
-	} while (!(file->flags & FLAG_HLINK_EOL));
+		stp = &st;
+	}
+
+	/* FIRST combined with DONE means we were the first to get done. */
+	file->flags |= FLAG_HLINK_FIRST | FLAG_HLINK_DONE;
+	F_HL_PREV(file) = alt_dest;
+	if (alt_dest >= 0 && dry_run) {
+		pathjoin(alt_name, MAXPATHLEN, basis_dir[alt_dest],
+			 f_name(file, NULL));
+		our_name = alt_name;
+	} else
+		our_name = fname;
+
+#ifdef SUPPORT_ACLS
+	prev_sx.acc_acl = prev_sx.def_acl = NULL;
+#endif
+
+	while ((ndx = prev_ndx) >= 0) {
+		int val;
+		flist = flist_for_ndx(ndx);
+		assert(flist != NULL);
+		file = flist->files[ndx - flist->ndx_start];
+		file->flags = (file->flags & ~FLAG_HLINK_FIRST) | FLAG_HLINK_DONE;
+		prev_ndx = F_HL_PREV(file);
+		F_HL_PREV(file) = fin_ndx;
+		prev_name = f_name(file, NULL);
+		prev_statret = link_stat(prev_name, &prev_sx.st, 0);
+		val = maybe_hard_link(file, ndx, prev_name, prev_statret, &prev_sx,
+				      our_name, stp, fname, itemizing, code);
+		flist->in_progress--;
+#ifdef SUPPORT_ACLS
+		if (preserve_acls)
+			free_acl(&prev_sx);
 #endif
+		if (val < 0)
+			continue;
+		if (remove_source_files == 1 && do_xfers)
+			send_msg_int(MSG_SUCCESS, ndx);
+	}
+
+	if (inc_recurse) {
+		int gnum = F_HL_GNUM(file);
+		struct ht_int32_node *node = hashtable_find(prior_hlinks, gnum, 0);
+		assert(node != NULL && node->data != NULL);
+		assert(CVAL(node->data, 0) == 0);
+		free(node->data);
+		if (!(node->data = strdup(our_name)))
+			out_of_memory("finish_hard_link");
+	}
 }
+#endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: ifuncs.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/io.c	2006-10-01 06:11:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/io.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,94 +1,126 @@
 /*
  * Socket and pipe I/O utilities used in rsync.
  *
  * Copyright (C) 1996-2001 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* Rsync provides its own multiplexing system, which is used to send
  * stderr and stdout over a single socket.
  *
  * For historical reasons this is off during the start of the
  * connection, but it's switched on quite early using
  * io_start_multiplex_out() and io_start_multiplex_in(). */
 
 #include "rsync.h"
+#include "ifuncs.h"
 
 /** If no timeout is specified then use a 60 second select timeout */
 #define SELECT_TIMEOUT 60
 
 extern int bwlimit;
 extern size_t bwlimit_writemax;
 extern int io_timeout;
 extern int allowed_lull;
 extern int am_server;
 extern int am_daemon;
 extern int am_sender;
 extern int am_generator;
+extern int inc_recurse;
+extern int io_error;
 extern int eol_nulls;
+extern int flist_eof;
 extern int read_batch;
 extern int csum_length;
+extern int protect_args;
 extern int checksum_seed;
 extern int protocol_version;
 extern int remove_source_files;
 extern int preserve_hard_links;
-extern char *filesfrom_host;
 extern struct stats stats;
-extern struct file_list *the_file_list;
+extern struct file_list *cur_flist;
+#ifdef ICONV_OPTION
+extern int filesfrom_convert;
+extern iconv_t ic_send, ic_recv;
+#endif
 
 const char phase_unknown[] = "unknown";
 int ignore_timeout = 0;
 int batch_fd = -1;
-int batch_gen_fd = -1;
+int msgdone_cnt = 0;
 
 /* Ignore an EOF error if non-zero. See whine_about_eof(). */
 int kluge_around_eof = 0;
 
 int msg_fd_in = -1;
 int msg_fd_out = -1;
 int sock_f_in = -1;
 int sock_f_out = -1;
 
+static int iobuf_f_in = -1;
+static char *iobuf_in;
+static size_t iobuf_in_siz;
+static size_t iobuf_in_ndx;
+static size_t iobuf_in_remaining;
+
+static int iobuf_f_out = -1;
+static char *iobuf_out;
+static int iobuf_out_cnt;
+
+int flist_forward_from = -1;
+
 static int io_multiplexing_out;
 static int io_multiplexing_in;
 static time_t last_io_in;
 static time_t last_io_out;
 static int no_flush;
 
 static int write_batch_monitor_in = -1;
 static int write_batch_monitor_out = -1;
 
 static int io_filesfrom_f_in = -1;
 static int io_filesfrom_f_out = -1;
-static char io_filesfrom_buf[2048];
-static char *io_filesfrom_bp;
-static char io_filesfrom_lastchar;
-static int io_filesfrom_buflen;
-static int defer_forwarding_messages = 0;
+static xbuf ff_buf = EMPTY_XBUF;
+static char ff_lastchar;
+#ifdef ICONV_OPTION
+static xbuf iconv_buf = EMPTY_XBUF;
+#endif
+static int defer_forwarding_messages = 0, defer_forwarding_keep = 0;
 static int select_timeout = SELECT_TIMEOUT;
 static int active_filecnt = 0;
 static OFF_T active_bytecnt = 0;
 
-static void read_loop(int fd, char *buf, size_t len);
+static char int_byte_extra[64] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (00 - 3F)/4 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, /* (40 - 7F)/4 */
+	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, /* (80 - BF)/4 */
+	2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 6, /* (C0 - FF)/4 */
+};
+
+enum festatus { FES_SUCCESS, FES_REDO, FES_NO_SEND };
+
+static void readfd(int fd, char *buffer, size_t N);
+static void writefd(int fd, const char *buf, size_t len);
+static void writefd_unbuffered(int fd, const char *buf, size_t len);
+static void mplex_write(int fd, enum msgcode code, const char *buf, size_t len, int convert);
 
 struct flist_ndx_item {
 	struct flist_ndx_item *next;
 	int ndx;
 };
 
@@ -97,21 +129,21 @@
 };
 
 static struct flist_ndx_list redo_list, hlink_list;
 
 struct msg_list_item {
 	struct msg_list_item *next;
-	int len;
+	char convert;
 	char buf[1];
 };
 
 struct msg_list {
 	struct msg_list_item *head, *tail;
 };
 
-static struct msg_list msg2genr, msg2sndr;
+static struct msg_list msg_queue;
 
 static void flist_ndx_push(struct flist_ndx_list *lp, int ndx)
 {
 	struct flist_ndx_item *item;
 
 	if (!(item = new(struct flist_ndx_item)))
@@ -140,12 +172,49 @@
 	if (!next)
 		lp->tail = NULL;
 
 	return ndx;
 }
 
+static void got_flist_entry_status(enum festatus status, const char *buf)
+{
+	int ndx = IVAL(buf, 0);
+	struct file_list *flist = flist_for_ndx(ndx);
+
+	assert(flist != NULL);
+
+	if (remove_source_files) {
+		active_filecnt--;
+		active_bytecnt -= F_LENGTH(flist->files[ndx - flist->ndx_start]);
+	}
+
+	if (inc_recurse)
+		flist->in_progress--;
+
+	switch (status) {
+	case FES_SUCCESS:
+		if (remove_source_files)
+			send_msg(MSG_SUCCESS, buf, 4, 0);
+		if (preserve_hard_links) {
+			struct file_struct *file = flist->files[ndx - flist->ndx_start];
+			if (F_IS_HLINKED(file)) {
+				flist_ndx_push(&hlink_list, ndx);
+				flist->in_progress++;
+			}
+		}
+		break;
+	case FES_REDO:
+		if (inc_recurse)
+			flist->to_redo++;
+		flist_ndx_push(&redo_list, ndx);
+		break;
+	case FES_NO_SEND:
+		break;
+	}
+}
+
 static void check_timeout(void)
 {
 	time_t t;
 
 	if (!io_timeout || ignore_timeout)
 		return;
@@ -201,204 +270,280 @@
 {
 	msg_fd_out = fd;
 	set_nonblocking(msg_fd_out);
 }
 
 /* Add a message to the pending MSG_* list. */
-static void msg_list_add(struct msg_list *lst, int code, char *buf, int len)
+static void msg_list_add(struct msg_list *lst, int code, const char *buf, int len, int convert)
 {
 	struct msg_list_item *m;
 	int sz = len + 4 + sizeof m[0] - 1;
 
 	if (!(m = (struct msg_list_item *)new_array(char, sz)))
 		out_of_memory("msg_list_add");
 	m->next = NULL;
-	m->len = len + 4;
+	m->convert = convert;
 	SIVAL(m->buf, 0, ((code+MPLEX_BASE)<<24) | len);
 	memcpy(m->buf + 4, buf, len);
 	if (lst->tail)
 		lst->tail->next = m;
 	else
 		lst->head = m;
 	lst->tail = m;
 }
 
+static void msg_flush(void)
+{
+	if (am_generator) {
+		while (msg_queue.head && io_multiplexing_out) {
+			struct msg_list_item *m = msg_queue.head;
+			int len = IVAL(m->buf, 0) & 0xFFFFFF;
+			int tag = *((uchar*)m->buf+3) - MPLEX_BASE;
+			if (!(msg_queue.head = m->next))
+				msg_queue.tail = NULL;
+			stats.total_written += len + 4;
+			defer_forwarding_messages++;
+			mplex_write(sock_f_out, tag, m->buf + 4, len, m->convert);
+			defer_forwarding_messages--;
+			free(m);
+		}
+	} else {
+		while (msg_queue.head) {
+			struct msg_list_item *m = msg_queue.head;
+			int len = IVAL(m->buf, 0) & 0xFFFFFF;
+			int tag = *((uchar*)m->buf+3) - MPLEX_BASE;
+			if (!(msg_queue.head = m->next))
+				msg_queue.tail = NULL;
+			defer_forwarding_messages++;
+			mplex_write(msg_fd_out, tag, m->buf + 4, len, m->convert);
+			defer_forwarding_messages--;
+			free(m);
+		}
+	}
+}
+
 /* Read a message from the MSG_* fd and handle it.  This is called either
  * during the early stages of being a local sender (up through the sending
  * of the file list) or when we're the generator (to fetch the messages
  * from the receiver). */
 static void read_msg_fd(void)
 {
 	char buf[2048];
 	size_t n;
+	struct file_list *flist;
 	int fd = msg_fd_in;
 	int tag, len;
 
 	/* Temporarily disable msg_fd_in.  This is needed to avoid looping back
 	 * to this routine from writefd_unbuffered(). */
+	no_flush++;
 	msg_fd_in = -1;
+	defer_forwarding_messages++;
 
-	read_loop(fd, buf, 4);
+	readfd(fd, buf, 4);
 	tag = IVAL(buf, 0);
 
 	len = tag & 0xFFFFFF;
 	tag = (tag >> 24) - MPLEX_BASE;
 
 	switch (tag) {
 	case MSG_DONE:
-		if (len != 0 || !am_generator) {
-			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
+		if (len < 0 || len > 1 || !am_generator) {
+		  invalid_msg:
+			rprintf(FERROR, "invalid message %d:%d [%s%s]\n",
+				tag, len, who_am_i(),
+				inc_recurse ? "/inc" : "");
 			exit_cleanup(RERR_STREAMIO);
 		}
-		flist_ndx_push(&redo_list, -1);
+		if (len) {
+			readfd(fd, buf, len);
+			stats.total_read = read_varlong(fd, 3);
+		}
+		msgdone_cnt++;
 		break;
 	case MSG_REDO:
-		if (len != 4 || !am_generator) {
-			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
-			exit_cleanup(RERR_STREAMIO);
-		}
-		read_loop(fd, buf, 4);
-		if (remove_source_files)
-			decrement_active_files(IVAL(buf,0));
-		flist_ndx_push(&redo_list, IVAL(buf,0));
+		if (len != 4 || !am_generator)
+			goto invalid_msg;
+		readfd(fd, buf, 4);
+		got_flist_entry_status(FES_REDO, buf);
+		break;
+	case MSG_FLIST:
+		if (len != 4 || !am_generator || !inc_recurse)
+			goto invalid_msg;
+		readfd(fd, buf, 4);
+		/* Read extra file list from receiver. */
+		assert(iobuf_in != NULL);
+		assert(iobuf_f_in == fd);
+		if (verbose > 3) {
+			rprintf(FINFO, "[%s] receiving flist for dir %d\n",
+				who_am_i(), IVAL(buf,0));
+		}
+		flist = recv_file_list(fd);
+		flist->parent_ndx = IVAL(buf,0);
+#ifdef SUPPORT_HARD_LINKS
+		if (preserve_hard_links)
+			match_hard_links(flist);
+#endif
+		break;
+	case MSG_FLIST_EOF:
+		if (len != 0 || !am_generator || !inc_recurse)
+			goto invalid_msg;
+		flist_eof = 1;
+		break;
+	case MSG_IO_ERROR:
+		if (len != 4)
+			goto invalid_msg;
+		readfd(fd, buf, len);
+		io_error |= IVAL(buf, 0);
 		break;
 	case MSG_DELETED:
-		if (len >= (int)sizeof buf || !am_generator) {
-			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
-			exit_cleanup(RERR_STREAMIO);
-		}
-		read_loop(fd, buf, len);
-		send_msg(MSG_DELETED, buf, len);
+		if (len >= (int)sizeof buf || !am_generator)
+			goto invalid_msg;
+		readfd(fd, buf, len);
+		send_msg(MSG_DELETED, buf, len, 1);
 		break;
 	case MSG_SUCCESS:
-		if (len != 4 || !am_generator) {
-			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
-			exit_cleanup(RERR_STREAMIO);
-		}
-		read_loop(fd, buf, len);
-		if (remove_source_files) {
-			decrement_active_files(IVAL(buf,0));
-			send_msg(MSG_SUCCESS, buf, len);
-		}
-		if (preserve_hard_links)
-			flist_ndx_push(&hlink_list, IVAL(buf,0));
+		if (len != 4 || !am_generator)
+			goto invalid_msg;
+		readfd(fd, buf, 4);
+		got_flist_entry_status(FES_SUCCESS, buf);
 		break;
-	case MSG_SOCKERR:
-		if (!am_generator) {
-			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
-			exit_cleanup(RERR_STREAMIO);
-		}
-		close_multiplexing_out();
+	case MSG_NO_SEND:
+		if (len != 4 || !am_generator)
+			goto invalid_msg;
+		readfd(fd, buf, 4);
+		got_flist_entry_status(FES_NO_SEND, buf);
+		break;
+	case MSG_ERROR_SOCKET:
+	case MSG_CLIENT:
+		if (!am_generator)
+			goto invalid_msg;
+		if (tag == MSG_ERROR_SOCKET)
+			io_end_multiplex_out();
 		/* FALL THROUGH */
 	case MSG_INFO:
 	case MSG_ERROR:
+	case MSG_ERROR_XFER:
+	case MSG_WARNING:
 	case MSG_LOG:
 		while (len) {
 			n = len;
 			if (n >= sizeof buf)
 				n = sizeof buf - 1;
-			read_loop(fd, buf, n);
-			rwrite(tag, buf, n);
+			readfd(fd, buf, n);
+			rwrite((enum logcode)tag, buf, n, !am_generator);
 			len -= n;
 		}
 		break;
 	default:
 		rprintf(FERROR, "unknown message %d:%d [%s]\n",
 			tag, len, who_am_i());
 		exit_cleanup(RERR_STREAMIO);
 	}
 
+	no_flush--;
 	msg_fd_in = fd;
+	if (!--defer_forwarding_messages && !no_flush)
+		msg_flush();
 }
 
 /* This is used by the generator to limit how many file transfers can
  * be active at once when --remove-source-files is specified.  Without
  * this, sender-side deletions were mostly happening at the end. */
 void increment_active_files(int ndx, int itemizing, enum logcode code)
 {
 	/* TODO: tune these limits? */
 	while (active_filecnt >= (active_bytecnt >= 128*1024 ? 10 : 50)) {
-		if (hlink_list.head)
-			check_for_finished_hlinks(itemizing, code);
-		read_msg_fd();
+		check_for_finished_files(itemizing, code, 0);
+		if (iobuf_out_cnt)
+			io_flush(NORMAL_FLUSH);
+		else
+			read_msg_fd();
 	}
 
 	active_filecnt++;
-	active_bytecnt += the_file_list->files[ndx]->length;
+	active_bytecnt += F_LENGTH(cur_flist->files[ndx - cur_flist->ndx_start]);
 }
 
-void decrement_active_files(int ndx)
+/* Write an message to a multiplexed stream. If this fails, rsync exits. */
+static void mplex_write(int fd, enum msgcode code, const char *buf, size_t len, int convert)
 {
-	active_filecnt--;
-	active_bytecnt -= the_file_list->files[ndx]->length;
-}
+	char buffer[BIGPATHBUFLEN]; /* Oversized for use by iconv code. */
+	size_t n = len;
 
-/* Try to push messages off the list onto the wire.  If we leave with more
- * to do, return 0.  On error, return -1.  If everything flushed, return 1.
- * This is only active in the receiver. */
-static int msg2genr_flush(int flush_it_all)
-{
-	static int written = 0;
-	struct timeval tv;
-	fd_set fds;
+#ifdef ICONV_OPTION
+	/* We need to convert buf before doing anything else so that we
+	 * can include the (converted) byte length in the message header. */
+	if (convert && ic_send != (iconv_t)-1) {
+		xbuf outbuf, inbuf;
+
+		INIT_XBUF(outbuf, buffer + 4, 0, sizeof buffer - 4);
+		INIT_XBUF(inbuf, (char*)buf, len, -1);
+
+		iconvbufs(ic_send, &inbuf, &outbuf,
+			  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
+		if (inbuf.len > 0) {
+			rprintf(FERROR, "overflowed conversion buffer in mplex_write");
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
 
-	if (msg_fd_out < 0)
-		return -1;
+		n = len = outbuf.len;
+	} else
+#endif
+	if (n > 1024 - 4) /* BIGPATHBUFLEN can handle 1024 bytes */
+		n = 0;    /* We'd rather do 2 writes than too much memcpy(). */
+	else
+		memcpy(buffer + 4, buf, n);
 
-	while (msg2genr.head) {
-		struct msg_list_item *m = msg2genr.head;
-		int n = write(msg_fd_out, m->buf + written, m->len - written);
-		if (n < 0) {
-			if (errno == EINTR)
-				continue;
-			if (errno != EWOULDBLOCK && errno != EAGAIN)
-				return -1;
-			if (!flush_it_all)
-				return 0;
-			FD_ZERO(&fds);
-			FD_SET(msg_fd_out, &fds);
-			tv.tv_sec = select_timeout;
-			tv.tv_usec = 0;
-			if (!select(msg_fd_out+1, NULL, &fds, NULL, &tv))
-				check_timeout();
-		} else if ((written += n) == m->len) {
-			msg2genr.head = m->next;
-			if (!msg2genr.head)
-				msg2genr.tail = NULL;
-			free(m);
-			written = 0;
-		}
-	}
-	return 1;
+	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
+
+	defer_forwarding_keep = 1; /* defer_forwarding_messages++ on return */
+	writefd_unbuffered(fd, buffer, n+4);
+	defer_forwarding_keep = 0;
+
+	if (len > n)
+		writefd_unbuffered(fd, buf+n, len-n);
+
+	if (!--defer_forwarding_messages && !no_flush)
+		msg_flush();
 }
 
-int send_msg(enum msgcode code, char *buf, int len)
+int send_msg(enum msgcode code, const char *buf, int len, int convert)
 {
 	if (msg_fd_out < 0) {
 		if (!defer_forwarding_messages)
-			return io_multiplex_write(code, buf, len);
+			return io_multiplex_write(code, buf, len, convert);
 		if (!io_multiplexing_out)
 			return 0;
-		msg_list_add(&msg2sndr, code, buf, len);
+		msg_list_add(&msg_queue, code, buf, len, convert);
 		return 1;
 	}
-	msg_list_add(&msg2genr, code, buf, len);
-	msg2genr_flush(NORMAL_FLUSH);
+	if (flist_forward_from >= 0)
+		msg_list_add(&msg_queue, code, buf, len, convert);
+	else
+		mplex_write(msg_fd_out, code, buf, len, convert);
 	return 1;
 }
 
-int get_redo_num(int itemizing, enum logcode code)
+void send_msg_int(enum msgcode code, int num)
 {
-	while (1) {
-		if (hlink_list.head)
-			check_for_finished_hlinks(itemizing, code);
-		if (redo_list.head)
-			break;
+	char numbuf[4];
+	SIVAL(numbuf, 0, num);
+	send_msg(code, numbuf, 4, 0);
+}
+
+void wait_for_receiver(void)
+{
+	if (iobuf_out_cnt)
+		io_flush(NORMAL_FLUSH);
+	else
 		read_msg_fd();
-	}
+}
 
+int get_redo_num(void)
+{
 	return flist_ndx_pop(&redo_list);
 }
 
 int get_hlink_num(void)
 {
 	return flist_ndx_pop(&hlink_list);
@@ -407,23 +552,25 @@
 /**
  * When we're the receiver and we have a local --files-from list of names
  * that needs to be sent over the socket to the sender, we have to do two
  * things at the same time: send the sender a list of what files we're
  * processing and read the incoming file+info list from the sender.  We do
  * this by augmenting the read_timeout() function to copy this data.  It
- * uses the io_filesfrom_buf to read a block of data from f_in (when it is
- * ready, since it might be a pipe) and then blast it out f_out (when it
- * is ready to receive more data).
+ * uses ff_buf to read a block of data from f_in (when it is ready, since
+ * it might be a pipe) and then blast it out f_out (when it is ready to
+ * receive more data).
  */
 void io_set_filesfrom_fds(int f_in, int f_out)
 {
 	io_filesfrom_f_in = f_in;
 	io_filesfrom_f_out = f_out;
-	io_filesfrom_bp = io_filesfrom_buf;
-	io_filesfrom_lastchar = '\0';
-	io_filesfrom_buflen = 0;
+	alloc_xbuf(&ff_buf, 2048);
+#ifdef ICONV_OPTION
+	if (protect_args)
+		alloc_xbuf(&iconv_buf, 1024);
+#endif
 }
 
 /* It's almost always an error to get an EOF when we're trying to read from the
  * network, because the protocol is (for the most part) self-terminating.
  *
  * There is one case for the receiver when it is at the end of the transfer
@@ -465,32 +612,27 @@
  * started by looking e.g. at whether the remote version is known yet.
  */
 static int read_timeout(int fd, char *buf, size_t len)
 {
 	int n, cnt = 0;
 
-	io_flush(NORMAL_FLUSH);
+	io_flush(FULL_FLUSH);
 
 	while (cnt == 0) {
 		/* until we manage to read *something* */
 		fd_set r_fds, w_fds;
 		struct timeval tv;
 		int maxfd = fd;
 		int count;
 
 		FD_ZERO(&r_fds);
 		FD_ZERO(&w_fds);
 		FD_SET(fd, &r_fds);
-		if (msg2genr.head) {
-			FD_SET(msg_fd_out, &w_fds);
-			if (msg_fd_out > maxfd)
-				maxfd = msg_fd_out;
-		}
 		if (io_filesfrom_f_out >= 0) {
 			int new_fd;
-			if (io_filesfrom_buflen == 0) {
+			if (ff_buf.len == 0) {
 				if (io_filesfrom_f_in >= 0) {
 					FD_SET(io_filesfrom_f_in, &r_fds);
 					new_fd = io_filesfrom_f_in;
 				} else {
 					io_filesfrom_f_out = -1;
 					new_fd = -1;
@@ -508,79 +650,92 @@
 
 		errno = 0;
 
 		count = select(maxfd + 1, &r_fds, &w_fds, NULL, &tv);
 
 		if (count <= 0) {
-			if (errno == EBADF)
+			if (errno == EBADF) {
+				defer_forwarding_messages = 0;
 				exit_cleanup(RERR_SOCKETIO);
+			}
 			check_timeout();
 			continue;
 		}
 
-		if (msg2genr.head && FD_ISSET(msg_fd_out, &w_fds))
-			msg2genr_flush(NORMAL_FLUSH);
-
 		if (io_filesfrom_f_out >= 0) {
-			if (io_filesfrom_buflen) {
+			if (ff_buf.len) {
 				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
 					int l = write(io_filesfrom_f_out,
-						      io_filesfrom_bp,
-						      io_filesfrom_buflen);
+						      ff_buf.buf + ff_buf.pos,
+						      ff_buf.len);
 					if (l > 0) {
-						if (!(io_filesfrom_buflen -= l))
-							io_filesfrom_bp = io_filesfrom_buf;
+						if (!(ff_buf.len -= l))
+							ff_buf.pos = 0;
 						else
-							io_filesfrom_bp += l;
-					} else {
+							ff_buf.pos += l;
+					} else if (errno != EINTR) {
 						/* XXX should we complain? */
 						io_filesfrom_f_out = -1;
 					}
 				}
 			} else if (io_filesfrom_f_in >= 0) {
 				if (FD_ISSET(io_filesfrom_f_in, &r_fds)) {
-					int l = read(io_filesfrom_f_in,
-						     io_filesfrom_buf,
-						     sizeof io_filesfrom_buf);
+#ifdef ICONV_OPTION
+					xbuf *ibuf = filesfrom_convert ? &iconv_buf : &ff_buf;
+#else
+					xbuf *ibuf = &ff_buf;
+#endif
+					int l = read(io_filesfrom_f_in, ibuf->buf, ibuf->size);
 					if (l <= 0) {
-						/* Send end-of-file marker */
-						io_filesfrom_buf[0] = '\0';
-						io_filesfrom_buf[1] = '\0';
-						io_filesfrom_buflen = io_filesfrom_lastchar? 2 : 1;
-						io_filesfrom_f_in = -1;
+						if (l == 0 || errno != EINTR) {
+							/* Send end-of-file marker */
+							memcpy(ff_buf.buf, "\0\0", 2);
+							ff_buf.len = ff_lastchar? 2 : 1;
+							ff_buf.pos = 0;
+							io_filesfrom_f_in = -1;
+						}
 					} else {
+#ifdef ICONV_OPTION
+						if (filesfrom_convert) {
+							iconv_buf.pos = 0;
+							iconv_buf.len = l;
+							iconvbufs(ic_send, &iconv_buf, &ff_buf,
+							    ICB_EXPAND_OUT|ICB_INCLUDE_BAD|ICB_INCLUDE_INCOMPLETE);
+							l = ff_buf.len;
+						}
+#endif
 						if (!eol_nulls) {
-							char *s = io_filesfrom_buf + l;
+							char *s = ff_buf.buf + l;
 							/* Transform CR and/or LF into '\0' */
-							while (s-- > io_filesfrom_buf) {
+							while (s-- > ff_buf.buf) {
 								if (*s == '\n' || *s == '\r')
 									*s = '\0';
 							}
 						}
-						if (!io_filesfrom_lastchar) {
+						if (!ff_lastchar) {
 							/* Last buf ended with a '\0', so don't
 							 * let this buf start with one. */
-							while (l && !*io_filesfrom_bp)
-								io_filesfrom_bp++, l--;
+							while (l && ff_buf.buf[ff_buf.pos] == '\0')
+								ff_buf.pos++, l--;
 						}
 						if (!l)
-							io_filesfrom_bp = io_filesfrom_buf;
+							ff_buf.pos = 0;
 						else {
-							char *f = io_filesfrom_bp;
+							char *f = ff_buf.buf + ff_buf.pos;
 							char *t = f;
 							char *eob = f + l;
 							/* Eliminate any multi-'\0' runs. */
 							while (f != eob) {
 								if (!(*t++ = *f++)) {
 									while (f != eob && !*f)
 										f++, l--;
 								}
 							}
-							io_filesfrom_lastchar = f[-1];
+							ff_lastchar = f[-1];
 						}
-						io_filesfrom_buflen = l;
+						ff_buf.len = l;
 					}
 				}
 			}
 		}
 
 		if (!FD_ISSET(fd, &r_fds))
@@ -594,14 +749,14 @@
 			if (errno == EINTR || errno == EWOULDBLOCK
 			    || errno == EAGAIN)
 				continue;
 
 			/* Don't write errors on a dead socket. */
 			if (fd == sock_f_in) {
-				close_multiplexing_out();
-				rsyserr(FSOCKERR, errno, "read error");
+				io_end_multiplex_out();
+				rsyserr(FERROR_SOCKET, errno, "read error");
 			} else
 				rsyserr(FERROR, errno, "read error");
 			exit_cleanup(RERR_STREAMIO);
 		}
 
 		buf += n;
@@ -612,25 +767,30 @@
 			last_io_in = time(NULL);
 	}
 
 	return cnt;
 }
 
-/**
- * Read a line into the "fname" buffer (which must be at least MAXPATHLEN
- * characters long).
- */
-int read_filesfrom_line(int fd, char *fname)
+/* Read a line into the "buf" buffer. */
+int read_line(int fd, char *buf, size_t bufsiz, int flags)
 {
-	char ch, *s, *eob = fname + MAXPATHLEN - 1;
+	char ch, *s, *eob;
 	int cnt;
-	int reading_remotely = filesfrom_host != NULL;
-	int nulls = eol_nulls || reading_remotely;
+
+#ifdef ICONV_OPTION
+	if (flags & RL_CONVERT && iconv_buf.size < bufsiz)
+		realloc_xbuf(&iconv_buf, bufsiz + 1024);
+#endif
 
   start:
-	s = fname;
+#ifdef ICONV_OPTION
+	s = flags & RL_CONVERT ? iconv_buf.buf : buf;
+#else
+	s = buf;
+#endif
+	eob = s + bufsiz - 1;
 	while (1) {
 		cnt = read(fd, &ch, 1);
 		if (cnt < 0 && (errno == EWOULDBLOCK
 		  || errno == EINTR || errno == EAGAIN)) {
 			struct timeval tv;
 			fd_set r_fds, e_fds;
@@ -639,91 +799,185 @@
 			FD_ZERO(&e_fds);
 			FD_SET(fd, &e_fds);
 			tv.tv_sec = select_timeout;
 			tv.tv_usec = 0;
 			if (!select(fd+1, &r_fds, NULL, &e_fds, &tv))
 				check_timeout();
-			if (FD_ISSET(fd, &e_fds)) {
-				rsyserr(FINFO, errno,
-					"select exception on fd %d", fd);
-			}
+			/*if (FD_ISSET(fd, &e_fds))
+				rprintf(FINFO, "select exception on fd %d\n", fd); */
 			continue;
 		}
 		if (cnt != 1)
 			break;
-		if (nulls? !ch : (ch == '\r' || ch == '\n')) {
-			/* Skip empty lines if reading locally. */
-			if (!reading_remotely && s == fname)
+		if (flags & RL_EOL_NULLS ? ch == '\0' : (ch == '\r' || ch == '\n')) {
+			/* Skip empty lines if dumping comments. */
+			if (flags & RL_DUMP_COMMENTS && s == buf)
 				continue;
 			break;
 		}
 		if (s < eob)
 			*s++ = ch;
 	}
 	*s = '\0';
 
-	/* Dump comments. */
-	if (*fname == '#' || *fname == ';')
+	if (flags & RL_DUMP_COMMENTS && (*buf == '#' || *buf == ';'))
 		goto start;
 
-	return s - fname;
+#ifdef ICONV_OPTION
+	if (flags & RL_CONVERT) {
+		xbuf outbuf;
+		INIT_XBUF(outbuf, buf, 0, bufsiz);
+		iconv_buf.pos = 0;
+		iconv_buf.len = s - iconv_buf.buf;
+		iconvbufs(ic_recv, &iconv_buf, &outbuf,
+			  ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
+		outbuf.buf[outbuf.len] = '\0';
+		return outbuf.len;
+	}
+#endif
+
+	return s - buf;
 }
 
-static char *iobuf_out;
-static int iobuf_out_cnt;
+int read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
+	      char ***argv_p, int *argc_p, char **request_p)
+{
+	int maxargs = MAX_ARGS;
+	int dot_pos = 0;
+	int argc = 0;
+	char **argv, *p;
+	int rl_flags = (rl_nulls ? RL_EOL_NULLS : 0);
 
-void io_start_buffering_out(void)
+#ifdef ICONV_OPTION
+	rl_flags |= (protect_args && ic_recv != (iconv_t)-1 ? RL_CONVERT : 0);
+#endif
+
+	if (!(argv = new_array(char *, maxargs)))
+		out_of_memory("read_args");
+	if (mod_name)
+		argv[argc++] = "rsyncd";
+
+	while (1) {
+		if (read_line(f_in, buf, bufsiz, rl_flags) == 0)
+			break;
+
+		if (argc == maxargs) {
+			maxargs += MAX_ARGS;
+			if (!(argv = realloc_array(argv, char *, maxargs)))
+				out_of_memory("read_args");
+		}
+
+		if (dot_pos) {
+			if (request_p) {
+				*request_p = strdup(buf);
+				request_p = NULL;
+			}
+			if (mod_name)
+				glob_expand_module(mod_name, buf, &argv, &argc, &maxargs);
+			else
+				glob_expand(buf, &argv, &argc, &maxargs);
+		} else {
+			if (!(p = strdup(buf)))
+				out_of_memory("read_args");
+			argv[argc++] = p;
+			if (*p == '.' && p[1] == '\0')
+				dot_pos = argc;
+		}
+	}
+
+	*argc_p = argc;
+	*argv_p = argv;
+
+	return dot_pos ? dot_pos : argc;
+}
+
+int io_start_buffering_out(int f_out)
 {
-	if (iobuf_out)
-		return;
+	if (iobuf_out) {
+		assert(f_out == iobuf_f_out);
+		return 0;
+	}
 	if (!(iobuf_out = new_array(char, IO_BUFFER_SIZE)))
 		out_of_memory("io_start_buffering_out");
 	iobuf_out_cnt = 0;
+	iobuf_f_out = f_out;
+	return 1;
 }
 
-static char *iobuf_in;
-static size_t iobuf_in_siz;
-
-void io_start_buffering_in(void)
+int io_start_buffering_in(int f_in)
 {
-	if (iobuf_in)
-		return;
+	if (iobuf_in) {
+		assert(f_in == iobuf_f_in);
+		return 0;
+	}
 	iobuf_in_siz = 2 * IO_BUFFER_SIZE;
 	if (!(iobuf_in = new_array(char, iobuf_in_siz)))
 		out_of_memory("io_start_buffering_in");
+	iobuf_f_in = f_in;
+	return 1;
 }
 
-void io_end_buffering(void)
+void io_end_buffering_in(void)
 {
-	io_flush(NORMAL_FLUSH);
-	if (!io_multiplexing_out) {
-		free(iobuf_out);
-		iobuf_out = NULL;
-	}
+	if (!iobuf_in)
+		return;
+	free(iobuf_in);
+	iobuf_in = NULL;
+	iobuf_in_ndx = 0;
+	iobuf_in_remaining = 0;
+	iobuf_f_in = -1;
+}
+
+void io_end_buffering_out(void)
+{
+	if (!iobuf_out)
+		return;
+	io_flush(FULL_FLUSH);
+	free(iobuf_out);
+	iobuf_out = NULL;
+	iobuf_f_out = -1;
 }
 
-void maybe_flush_socket(void)
+void maybe_flush_socket(int important)
 {
-	if (iobuf_out && iobuf_out_cnt && time(NULL) - last_io_out >= 5)
+	if (iobuf_out && iobuf_out_cnt
+	 && (important || time(NULL) - last_io_out >= 5))
 		io_flush(NORMAL_FLUSH);
 }
 
 void maybe_send_keepalive(void)
 {
 	if (time(NULL) - last_io_out >= allowed_lull) {
 		if (!iobuf_out || !iobuf_out_cnt) {
 			if (protocol_version < 29)
 				return; /* there's nothing we can do */
-			write_int(sock_f_out, the_file_list->count);
-			write_shortint(sock_f_out, ITEM_IS_NEW);
+			if (protocol_version >= 30)
+				send_msg(MSG_NOOP, "", 0, 0);
+			else {
+				write_int(sock_f_out, cur_flist->used);
+				write_shortint(sock_f_out, ITEM_IS_NEW);
+			}
 		}
 		if (iobuf_out)
 			io_flush(NORMAL_FLUSH);
 	}
 }
 
+void start_flist_forward(int f_in)
+{
+	assert(iobuf_out != NULL);
+	assert(iobuf_f_out == msg_fd_out);
+	flist_forward_from = f_in;
+}
+
+void stop_flist_forward()
+{
+	flist_forward_from = -1;
+	io_flush(FULL_FLUSH);
+}
+
 /**
  * Continue trying to read len bytes - don't return until len has been
  * read.
  **/
 static void read_loop(int fd, char *buf, size_t len)
 {
@@ -740,32 +994,30 @@
  * of bytes read.
  *
  * Never returns <= 0.
  */
 static int readfd_unbuffered(int fd, char *buf, size_t len)
 {
-	static size_t remaining;
-	static size_t iobuf_in_ndx;
 	size_t msg_bytes;
 	int tag, cnt = 0;
 	char line[BIGPATHBUFLEN];
 
-	if (!iobuf_in || fd != sock_f_in)
+	if (!iobuf_in || fd != iobuf_f_in)
 		return read_timeout(fd, buf, len);
 
-	if (!io_multiplexing_in && remaining == 0) {
-		remaining = read_timeout(fd, iobuf_in, iobuf_in_siz);
+	if (!io_multiplexing_in && iobuf_in_remaining == 0) {
+		iobuf_in_remaining = read_timeout(fd, iobuf_in, iobuf_in_siz);
 		iobuf_in_ndx = 0;
 	}
 
 	while (cnt == 0) {
-		if (remaining) {
-			len = MIN(len, remaining);
+		if (iobuf_in_remaining) {
+			len = MIN(len, iobuf_in_remaining);
 			memcpy(buf, iobuf_in + iobuf_in_ndx, len);
 			iobuf_in_ndx += len;
-			remaining -= len;
+			iobuf_in_remaining -= len;
 			cnt = len;
 			break;
 		}
 
 		read_loop(fd, line, 4);
 		tag = IVAL(line, 0);
@@ -779,66 +1031,113 @@
 				if (!(iobuf_in = realloc_array(iobuf_in, char,
 							       msg_bytes)))
 					out_of_memory("readfd_unbuffered");
 				iobuf_in_siz = msg_bytes;
 			}
 			read_loop(fd, iobuf_in, msg_bytes);
-			remaining = msg_bytes;
+			iobuf_in_remaining = msg_bytes;
 			iobuf_in_ndx = 0;
 			break;
+		case MSG_NOOP:
+			if (am_sender)
+				maybe_send_keepalive();
+			break;
+		case MSG_IO_ERROR:
+			if (msg_bytes != 4)
+				goto invalid_msg;
+			read_loop(fd, line, msg_bytes);
+			send_msg_int(MSG_IO_ERROR, IVAL(line, 0));
+			io_error |= IVAL(line, 0);
+			break;
 		case MSG_DELETED:
 			if (msg_bytes >= sizeof line)
 				goto overflow;
-			read_loop(fd, line, msg_bytes);
+#ifdef ICONV_OPTION
+			if (ic_recv != (iconv_t)-1) {
+				xbuf outbuf, inbuf;
+				char ibuf[512];
+				int add_null = 0;
+				int pos = 0;
+
+				INIT_CONST_XBUF(outbuf, line);
+				INIT_XBUF(inbuf, ibuf, 0, -1);
+
+				while (msg_bytes) {
+					inbuf.len = msg_bytes > sizeof ibuf
+						  ? sizeof ibuf : msg_bytes;
+					read_loop(fd, inbuf.buf, inbuf.len);
+					if (!(msg_bytes -= inbuf.len)
+					 && !ibuf[inbuf.len-1])
+						inbuf.len--, add_null = 1;
+					if (iconvbufs(ic_send, &inbuf, &outbuf,
+					    ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE) < 0)
+						goto overflow;
+					pos = -1;
+				}
+				if (add_null) {
+					if (outbuf.len == outbuf.size)
+						goto overflow;
+					outbuf.buf[outbuf.len++] = '\0';
+				}
+				msg_bytes = outbuf.len;
+			} else
+#endif
+				read_loop(fd, line, msg_bytes);
 			/* A directory name was sent with the trailing null */
 			if (msg_bytes > 0 && !line[msg_bytes-1])
 				log_delete(line, S_IFDIR);
 			else {
 				line[msg_bytes] = '\0';
 				log_delete(line, S_IFREG);
 			}
 			break;
 		case MSG_SUCCESS:
 			if (msg_bytes != 4) {
+			  invalid_msg:
 				rprintf(FERROR, "invalid multi-message %d:%ld [%s]\n",
 					tag, (long)msg_bytes, who_am_i());
 				exit_cleanup(RERR_STREAMIO);
 			}
 			read_loop(fd, line, msg_bytes);
 			successful_send(IVAL(line, 0));
 			break;
+		case MSG_NO_SEND:
+			if (msg_bytes != 4)
+				goto invalid_msg;
+			read_loop(fd, line, msg_bytes);
+			send_msg_int(MSG_NO_SEND, IVAL(line, 0));
+			break;
 		case MSG_INFO:
 		case MSG_ERROR:
+		case MSG_ERROR_XFER:
+		case MSG_WARNING:
 			if (msg_bytes >= sizeof line) {
 			    overflow:
 				rprintf(FERROR,
 					"multiplexing overflow %d:%ld [%s]\n",
 					tag, (long)msg_bytes, who_am_i());
 				exit_cleanup(RERR_STREAMIO);
 			}
 			read_loop(fd, line, msg_bytes);
-			rwrite((enum logcode)tag, line, msg_bytes);
+			rwrite((enum logcode)tag, line, msg_bytes, 1);
 			break;
 		default:
 			rprintf(FERROR, "unexpected tag %d [%s]\n",
 				tag, who_am_i());
 			exit_cleanup(RERR_STREAMIO);
 		}
 	}
 
-	if (remaining == 0)
+	if (iobuf_in_remaining == 0)
 		io_flush(NORMAL_FLUSH);
 
 	return cnt;
 }
 
-/**
- * Do a buffered read from @p fd.  Don't return until all @p n bytes
- * have been read.  If all @p n can't be read then exit with an
- * error.
- **/
+/* Do a buffered read from fd.  Don't return until all N bytes have
+ * been read.  If all N can't be read then exit with an error. */
 static void readfd(int fd, char *buffer, size_t N)
 {
 	int  cnt;
 	size_t total = 0;
 
 	while (total < N) {
@@ -848,61 +1147,138 @@
 
 	if (fd == write_batch_monitor_in) {
 		if ((size_t)write(batch_fd, buffer, total) != total)
 			exit_cleanup(RERR_FILEIO);
 	}
 
+	if (fd == flist_forward_from)
+		writefd(iobuf_f_out, buffer, total);
+
 	if (fd == sock_f_in)
 		stats.total_read += total;
 }
 
-int read_shortint(int f)
+unsigned short read_shortint(int f)
 {
-	uchar b[2];
-	readfd(f, (char *)b, 2);
-	return (b[1] << 8) + b[0];
+	char b[2];
+	readfd(f, b, 2);
+	return (UVAL(b, 1) << 8) + UVAL(b, 0);
 }
 
 int32 read_int(int f)
 {
 	char b[4];
 	int32 num;
 
-	readfd(f,b,4);
-	num = IVAL(b,0);
-	if (num == (int32)0xffffffff)
-		return -1;
+	readfd(f, b, 4);
+	num = IVAL(b, 0);
+#if SIZEOF_INT32 > 4
+	if (num & (int32)0x80000000)
+		num |= ~(int32)0xffffffff;
+#endif
 	return num;
 }
 
+int32 read_varint(int f)
+{
+	union {
+	    char b[5];
+	    int32 x;
+	} u;
+	uchar ch;
+	int extra;
+
+	u.x = 0;
+	readfd(f, (char*)&ch, 1);
+	extra = int_byte_extra[ch / 4];
+	if (extra) {
+		uchar bit = ((uchar)1<<(8-extra));
+		if (extra >= (int)sizeof u.b) {
+			rprintf(FERROR, "Overflow in read_varint()\n");
+			exit_cleanup(RERR_STREAMIO);
+		}
+		readfd(f, u.b, extra);
+		u.b[extra] = ch & (bit-1);
+	} else
+		u.b[0] = ch;
+#if CAREFUL_ALIGNMENT
+	u.x = IVAL(u.b,0);
+#endif
+#if SIZEOF_INT32 > 4
+	if (u.x & (int32)0x80000000)
+		u.x |= ~(int32)0xffffffff;
+#endif
+	return u.x;
+}
+
+int64 read_varlong(int f, uchar min_bytes)
+{
+	union {
+	    char b[9];
+	    int64 x;
+	} u;
+	char b2[8];
+	int extra;
+
+#if SIZEOF_INT64 < 8
+	memset(u.b, 0, 8);
+#else
+	u.x = 0;
+#endif
+	readfd(f, b2, min_bytes);
+	memcpy(u.b, b2+1, min_bytes-1);
+	extra = int_byte_extra[CVAL(b2, 0) / 4];
+	if (extra) {
+		uchar bit = ((uchar)1<<(8-extra));
+		if (min_bytes + extra > (int)sizeof u.b) {
+			rprintf(FERROR, "Overflow in read_varlong()\n");
+			exit_cleanup(RERR_STREAMIO);
+		}
+		readfd(f, u.b + min_bytes - 1, extra);
+		u.b[min_bytes + extra - 1] = CVAL(b2, 0) & (bit-1);
+#if SIZEOF_INT64 < 8
+		if (min_bytes + extra > 5 || u.b[4] || CVAL(u.b,3) & 0x80) {
+			rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
+			exit_cleanup(RERR_UNSUPPORTED);
+		}
+#endif
+	} else
+		u.b[min_bytes + extra - 1] = CVAL(b2, 0);
+#if SIZEOF_INT64 < 8
+	u.x = IVAL(u.b,0);
+#elif CAREFUL_ALIGNMENT
+	u.x = IVAL(u.b,0) | (((int64)IVAL(u.b,4))<<32);
+#endif
+	return u.x;
+}
+
 int64 read_longint(int f)
 {
-	int64 num;
-	char b[8];
-	num = read_int(f);
+#if SIZEOF_INT64 >= 8
+	char b[9];
+#endif
+	int32 num = read_int(f);
 
-	if ((int32)num != (int32)0xffffffff)
+	if (num != (int32)0xffffffff)
 		return num;
 
 #if SIZEOF_INT64 < 8
 	rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
 	exit_cleanup(RERR_UNSUPPORTED);
 #else
-	readfd(f,b,8);
-	num = IVAL(b,0) | (((int64)IVAL(b,4))<<32);
+	readfd(f, b, 8);
+	return IVAL(b,0) | (((int64)IVAL(b,4))<<32);
 #endif
-
-	return num;
 }
 
-void read_buf(int f,char *buf,size_t len)
+void read_buf(int f, char *buf, size_t len)
 {
 	readfd(f,buf,len);
 }
 
-void read_sbuf(int f,char *buf,size_t len)
+void read_sbuf(int f, char *buf, size_t len)
 {
 	readfd(f, buf, len);
 	buf[len] = '\0';
 }
 
 uchar read_byte(int f)
@@ -945,13 +1321,13 @@
 	if (sum->blength < 0 || sum->blength > MAX_BLOCK_SIZE) {
 		rprintf(FERROR, "Invalid block length %ld [%s]\n",
 			(long)sum->blength, who_am_i());
 		exit_cleanup(RERR_PROTOCOL);
 	}
 	sum->s2length = protocol_version < 27 ? csum_length : (int)read_int(f);
-	if (sum->s2length < 0 || sum->s2length > MD4_SUM_LENGTH) {
+	if (sum->s2length < 0 || sum->s2length > MAX_DIGEST_LEN) {
 		rprintf(FERROR, "Invalid checksum length %d [%s]\n",
 			sum->s2length, who_am_i());
 		exit_cleanup(RERR_PROTOCOL);
 	}
 	sum->remainder = read_int(f);
 	if (sum->remainder < 0 || sum->remainder > sum->blength) {
@@ -1036,21 +1412,22 @@
 /* Write len bytes to the file descriptor fd, looping as necessary to get
  * the job done and also (in certain circumstances) reading any data on
  * msg_fd_in to avoid deadlock.
  *
  * This function underlies the multiplexing system.  The body of the
  * application never calls this function directly. */
-static void writefd_unbuffered(int fd,char *buf,size_t len)
+static void writefd_unbuffered(int fd, const char *buf, size_t len)
 {
 	size_t n, total = 0;
 	fd_set w_fds, r_fds, e_fds;
 	int maxfd, count, cnt, using_r_fds;
-	int defer_save = defer_forwarding_messages;
+	int defer_inc = 0;
 	struct timeval tv;
 
-	no_flush++;
+	if (no_flush++)
+		defer_forwarding_messages++, defer_inc++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
 		FD_SET(fd, &w_fds);
 		FD_ZERO(&e_fds);
 		FD_SET(fd, &e_fds);
@@ -1076,16 +1453,14 @@
 			if (count < 0 && errno == EBADF)
 				exit_cleanup(RERR_SOCKETIO);
 			check_timeout();
 			continue;
 		}
 
-		if (FD_ISSET(fd, &e_fds)) {
-			rsyserr(FINFO, errno,
-				"select exception on fd %d", fd);
-		}
+		/*if (FD_ISSET(fd, &e_fds))
+			rprintf(FINFO, "select exception on fd %d\n", fd); */
 
 		if (using_r_fds && FD_ISSET(msg_fd_in, &r_fds))
 			read_msg_fd();
 
 		if (!FD_ISSET(fd, &w_fds))
 			continue;
@@ -1104,118 +1479,72 @@
 					continue;
 				}
 			}
 
 			/* Don't try to write errors back across the stream. */
 			if (fd == sock_f_out)
-				close_multiplexing_out();
+				io_end_multiplex_out();
+			/* Don't try to write errors down a failing msg pipe. */
+			if (am_server && fd == msg_fd_out)
+				exit_cleanup(RERR_STREAMIO);
 			rsyserr(FERROR, errno,
 				"writefd_unbuffered failed to write %ld bytes [%s]",
 				(long)len, who_am_i());
 			/* If the other side is sending us error messages, try
 			 * to grab any messages they sent before they died. */
-			while (fd == sock_f_out && io_multiplexing_in) {
+			while (!am_server && fd == sock_f_out && io_multiplexing_in) {
+				char buf[1024];
 				set_io_timeout(30);
 				ignore_timeout = 0;
-				readfd_unbuffered(sock_f_in, io_filesfrom_buf,
-						  sizeof io_filesfrom_buf);
+				readfd_unbuffered(sock_f_in, buf, sizeof buf);
 			}
 			exit_cleanup(RERR_STREAMIO);
 		}
 
 		total += cnt;
-		defer_forwarding_messages = 1;
+		defer_forwarding_messages++, defer_inc++;
 
 		if (fd == sock_f_out) {
 			if (io_timeout || am_generator)
 				last_io_out = time(NULL);
 			sleep_for_bwlimit(cnt);
 		}
 	}
 
-	defer_forwarding_messages = defer_save;
 	no_flush--;
-}
-
-static void msg2sndr_flush(void)
-{
-	if (defer_forwarding_messages)
-		return;
-
-	while (msg2sndr.head && io_multiplexing_out) {
-		struct msg_list_item *m = msg2sndr.head;
-		if (!(msg2sndr.head = m->next))
-			msg2sndr.tail = NULL;
-		stats.total_written += m->len;
-		defer_forwarding_messages = 1;
-		writefd_unbuffered(sock_f_out, m->buf, m->len);
-		defer_forwarding_messages = 0;
-		free(m);
-	}
-}
-
-/**
- * Write an message to a multiplexed stream. If this fails then rsync
- * exits.
- **/
-static void mplex_write(enum msgcode code, char *buf, size_t len)
-{
-	char buffer[1024];
-	size_t n = len;
-
-	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
-
-	if (n > sizeof buffer - 4)
-		n = 0;
-	else
-		memcpy(buffer + 4, buf, n);
-
-	writefd_unbuffered(sock_f_out, buffer, n+4);
-
-	len -= n;
-	buf += n;
-
-	if (len) {
-		defer_forwarding_messages = 1;
-		writefd_unbuffered(sock_f_out, buf, len);
-		defer_forwarding_messages = 0;
-		msg2sndr_flush();
-	}
+	defer_inc -= defer_forwarding_keep;
+	if (!(defer_forwarding_messages -= defer_inc) && !no_flush)
+		msg_flush();
 }
 
 void io_flush(int flush_it_all)
 {
-	msg2genr_flush(flush_it_all);
-	msg2sndr_flush();
-
 	if (!iobuf_out_cnt || no_flush)
 		return;
 
 	if (io_multiplexing_out)
-		mplex_write(MSG_DATA, iobuf_out, iobuf_out_cnt);
+		mplex_write(sock_f_out, MSG_DATA, iobuf_out, iobuf_out_cnt, 0);
 	else
-		writefd_unbuffered(sock_f_out, iobuf_out, iobuf_out_cnt);
+		writefd_unbuffered(iobuf_f_out, iobuf_out, iobuf_out_cnt);
 	iobuf_out_cnt = 0;
+
+	if (flush_it_all && !defer_forwarding_messages)
+		msg_flush();
 }
 
-static void writefd(int fd,char *buf,size_t len)
+static void writefd(int fd, const char *buf, size_t len)
 {
-	if (fd == msg_fd_out) {
-		rprintf(FERROR, "Internal error: wrong write used in receiver.\n");
-		exit_cleanup(RERR_PROTOCOL);
-	}
-
 	if (fd == sock_f_out)
 		stats.total_written += len;
 
 	if (fd == write_batch_monitor_out) {
 		if ((size_t)write(batch_fd, buf, len) != len)
 			exit_cleanup(RERR_FILEIO);
 	}
 
-	if (!iobuf_out || fd != sock_f_out) {
+	if (!iobuf_out || fd != iobuf_f_out) {
 		writefd_unbuffered(fd, buf, len);
 		return;
 	}
 
 	while (len) {
 		int n = MIN((int)len, IO_BUFFER_SIZE - iobuf_out_cnt);
@@ -1228,69 +1557,122 @@
 
 		if (iobuf_out_cnt == IO_BUFFER_SIZE)
 			io_flush(NORMAL_FLUSH);
 	}
 }
 
-void write_shortint(int f, int x)
+void write_shortint(int f, unsigned short x)
 {
-	uchar b[2];
-	b[0] = x;
-	b[1] = x >> 8;
-	writefd(f, (char *)b, 2);
+	char b[2];
+	b[0] = (char)x;
+	b[1] = (char)(x >> 8);
+	writefd(f, b, 2);
 }
 
-void write_int(int f,int32 x)
+void write_int(int f, int32 x)
 {
 	char b[4];
-	SIVAL(b,0,x);
-	writefd(f,b,4);
+	SIVAL(b, 0, x);
+	writefd(f, b, 4);
+}
+
+void write_varint(int f, int32 x)
+{
+	char b[5];
+	uchar bit;
+	int cnt = 4;
+
+	SIVAL(b, 1, x);
+
+	while (cnt > 1 && b[cnt] == 0)
+		cnt--;
+	bit = ((uchar)1<<(7-cnt+1));
+	if (CVAL(b, cnt) >= bit) {
+		cnt++;
+		*b = ~(bit-1);
+	} else if (cnt > 1)
+		*b = b[cnt] | ~(bit*2-1);
+	else
+		*b = b[cnt];
+
+	writefd(f, b, cnt);
+}
+
+void write_varlong(int f, int64 x, uchar min_bytes)
+{
+	char b[9];
+	uchar bit;
+	int cnt = 8;
+
+	SIVAL(b, 1, x);
+#if SIZEOF_INT64 >= 8
+	SIVAL(b, 5, x >> 32);
+#else
+	if (x <= 0x7FFFFFFF && x >= 0)
+		memset(b + 5, 0, 4);
+	else {
+		rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+#endif
+
+	while (cnt > min_bytes && b[cnt] == 0)
+		cnt--;
+	bit = ((uchar)1<<(7-cnt+min_bytes));
+	if (CVAL(b, cnt) >= bit) {
+		cnt++;
+		*b = ~(bit-1);
+	} else if (cnt > min_bytes)
+		*b = b[cnt] | ~(bit*2-1);
+	else
+		*b = b[cnt];
+
+	writefd(f, b, cnt);
 }
 
 /*
  * Note: int64 may actually be a 32-bit type if ./configure couldn't find any
  * 64-bit types on this platform.
  */
 void write_longint(int f, int64 x)
 {
-	char b[8];
+	char b[12], * const s = b+4;
 
-	if (x <= 0x7FFFFFFF) {
-		write_int(f, (int)x);
+	SIVAL(s, 0, x);
+	if (x <= 0x7FFFFFFF && x >= 0) {
+		writefd(f, s, 4);
 		return;
 	}
 
 #if SIZEOF_INT64 < 8
 	rprintf(FERROR, "Integer overflow: attempted 64-bit offset\n");
 	exit_cleanup(RERR_UNSUPPORTED);
 #else
-	write_int(f, (int32)0xFFFFFFFF);
-	SIVAL(b,0,(x&0xFFFFFFFF));
-	SIVAL(b,4,((x>>32)&0xFFFFFFFF));
-
-	writefd(f,b,8);
+	memset(b, 0xFF, 4);
+	SIVAL(s, 4, x >> 32);
+	writefd(f, b, 12);
 #endif
 }
 
-void write_buf(int f,char *buf,size_t len)
+void write_buf(int f, const char *buf, size_t len)
 {
 	writefd(f,buf,len);
 }
 
 /** Write a string to the connection */
-void write_sbuf(int f, char *buf)
+void write_sbuf(int f, const char *buf)
 {
 	writefd(f, buf, strlen(buf));
 }
 
 void write_byte(int f, uchar c)
 {
 	writefd(f, (char *)&c, 1);
 }
 
-void write_vstring(int f, char *str, int len)
+void write_vstring(int f, const char *str, int len)
 {
 	uchar lenbuf[3], *lb = lenbuf;
 
 	if (len > 0x7F) {
 		if (len > 0x7FFF) {
 			rprintf(FERROR,
@@ -1304,35 +1686,114 @@
 
 	writefd(f, (char*)lenbuf, lb - lenbuf + 1);
 	if (len)
 		writefd(f, str, len);
 }
 
-/**
- * Read a line of up to @p maxlen characters into @p buf (not counting
- * the trailing null).  Strips the (required) trailing newline and all
- * carriage returns.
- *
- * @return 1 for success; 0 for I/O error or truncation.
- **/
-int read_line(int f, char *buf, size_t maxlen)
+/* Send a file-list index using a byte-reduction method. */
+void write_ndx(int f, int32 ndx)
+{
+	static int32 prev_positive = -1, prev_negative = 1;
+	int32 diff, cnt = 0;
+	char b[6];
+
+	if (protocol_version < 30 || read_batch) {
+		write_int(f, ndx);
+		return;
+	}
+
+	/* Send NDX_DONE as a single-byte 0 with no side effects.  Send
+	 * negative nums as a positive after sending a leading 0xFF. */
+	if (ndx >= 0) {
+		diff = ndx - prev_positive;
+		prev_positive = ndx;
+	} else if (ndx == NDX_DONE) {
+		*b = 0;
+		writefd(f, b, 1);
+		return;
+	} else {
+		b[cnt++] = (char)0xFF;
+		ndx = -ndx;
+		diff = ndx - prev_negative;
+		prev_negative = ndx;
+	}
+
+	/* A diff of 1 - 253 is sent as a one-byte diff; a diff of 254 - 32767
+	 * or 0 is sent as a 0xFE + a two-byte diff; otherwise we send 0xFE
+	 * & all 4 bytes of the (non-negative) num with the high-bit set. */
+	if (diff < 0xFE && diff > 0)
+		b[cnt++] = (char)diff;
+	else if (diff < 0 || diff > 0x7FFF) {
+		b[cnt++] = (char)0xFE;
+		b[cnt++] = (char)((ndx >> 24) | 0x80);
+		b[cnt++] = (char)ndx;
+		b[cnt++] = (char)(ndx >> 8);
+		b[cnt++] = (char)(ndx >> 16);
+	} else {
+		b[cnt++] = (char)0xFE;
+		b[cnt++] = (char)(diff >> 8);
+		b[cnt++] = (char)diff;
+	}
+	writefd(f, b, cnt);
+}
+
+/* Receive a file-list index using a byte-reduction method. */
+int32 read_ndx(int f)
+{
+	static int32 prev_positive = -1, prev_negative = 1;
+	int32 *prev_ptr, num;
+	char b[4];
+
+	if (protocol_version < 30)
+		return read_int(f);
+
+	readfd(f, b, 1);
+	if (CVAL(b, 0) == 0xFF) {
+		readfd(f, b, 1);
+		prev_ptr = &prev_negative;
+	} else if (CVAL(b, 0) == 0)
+		return NDX_DONE;
+	else
+		prev_ptr = &prev_positive;
+	if (CVAL(b, 0) == 0xFE) {
+		readfd(f, b, 2);
+		if (CVAL(b, 0) & 0x80) {
+			b[3] = CVAL(b, 0) & ~0x80;
+			b[0] = b[1];
+			readfd(f, b+1, 2);
+			num = IVAL(b, 0);
+		} else
+			num = (UVAL(b,0)<<8) + UVAL(b,1) + *prev_ptr;
+	} else
+		num = UVAL(b, 0) + *prev_ptr;
+	*prev_ptr = num;
+	if (prev_ptr == &prev_negative)
+		num = -num;
+	return num;
+}
+
+/* Read a line of up to bufsiz-1 characters into buf.  Strips
+ * the (required) trailing newline and all carriage returns.
+ * Returns 1 for success; 0 for I/O error or truncation. */
+int read_line_old(int f, char *buf, size_t bufsiz)
 {
-	while (maxlen) {
+	bufsiz--; /* leave room for the null */
+	while (bufsiz > 0) {
 		buf[0] = 0;
 		read_buf(f, buf, 1);
 		if (buf[0] == 0)
 			return 0;
 		if (buf[0] == '\n')
 			break;
 		if (buf[0] != '\r') {
 			buf++;
-			maxlen--;
+			bufsiz--;
 		}
 	}
 	*buf = '\0';
-	return maxlen > 0;
+	return bufsiz > 0;
 }
 
 void io_printf(int fd, const char *format, ...)
 {
 	va_list ap;
 	char buf[BIGPATHBUFLEN];
@@ -1354,57 +1815,58 @@
 }
 
 /** Setup for multiplexing a MSG_* stream with the data stream. */
 void io_start_multiplex_out(void)
 {
 	io_flush(NORMAL_FLUSH);
-	io_start_buffering_out();
+	io_start_buffering_out(sock_f_out);
 	io_multiplexing_out = 1;
 }
 
 /** Setup for multiplexing a MSG_* stream with the data stream. */
 void io_start_multiplex_in(void)
 {
 	io_flush(NORMAL_FLUSH);
-	io_start_buffering_in();
+	io_start_buffering_in(sock_f_in);
 	io_multiplexing_in = 1;
 }
 
 /** Write an message to the multiplexed data stream. */
-int io_multiplex_write(enum msgcode code, char *buf, size_t len)
+int io_multiplex_write(enum msgcode code, const char *buf, size_t len, int convert)
 {
 	if (!io_multiplexing_out)
 		return 0;
-
 	io_flush(NORMAL_FLUSH);
 	stats.total_written += (len+4);
-	mplex_write(code, buf, len);
+	mplex_write(sock_f_out, code, buf, len, convert);
 	return 1;
 }
 
-void close_multiplexing_in(void)
+void io_end_multiplex_in(void)
 {
 	io_multiplexing_in = 0;
+	io_end_buffering_in();
 }
 
 /** Stop output multiplexing. */
-void close_multiplexing_out(void)
+void io_end_multiplex_out(void)
 {
 	io_multiplexing_out = 0;
+	io_end_buffering_out();
 }
 
 void start_write_batch(int fd)
 {
-	write_stream_flags(batch_fd);
-
 	/* Some communication has already taken place, but we don't
 	 * enable batch writing until here so that we can write a
 	 * canonical record of the communication even though the
 	 * actual communication so far depends on whether a daemon
 	 * is involved. */
 	write_int(batch_fd, protocol_version);
+	if (protocol_version >= 30)
+		write_byte(batch_fd, inc_recurse);
 	write_int(batch_fd, checksum_seed);
 
 	if (am_sender)
 		write_batch_monitor_out = fd;
 	else
 		write_batch_monitor_in = fd;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: io.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/addrinfo.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/addrinfo.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/addrinfo.h	2004-02-27 15:22:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/addrinfo.h	2007-11-08 09:10:34.000000000 +0800
@@ -1,115 +1,180 @@
 /*
- * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.
- * All rights reserved.
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the project nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
+PostgreSQL Database Management System
+(formerly known as Postgres, then as Postgres95)
 
-/**
- * @file addrinfo.h
- *
- * Replacement getaddrinfo() for machines that don't have it.  The new
- * getaddrinfo()/getnameinfo() interface is implemented on top of the
- * traditional resolver calls.
- **/
+Portions Copyright (c) 1996-2005, The PostgreSQL Global Development Group
 
-#ifndef HAVE_GETADDRINFO
+Portions Copyright (c) 1994, The Regents of the University of California
 
-#ifndef EAI_ADDRFAMILY
-/*
- * Error return codes from getaddrinfo()
- */
-#define	EAI_ADDRFAMILY	 1	/* address family for hostname not supported */
-#define	EAI_AGAIN	 2	/* temporary failure in name resolution */
-#define	EAI_BADFLAGS	 3	/* invalid value for ai_flags */
-#define	EAI_FAIL	 4	/* non-recoverable failure in name resolution */
-#define	EAI_FAMILY	 5	/* ai_family not supported */
-#define	EAI_MEMORY	 6	/* memory allocation failure */
-#define	EAI_NODATA	 7	/* no address associated with hostname */
-#define	EAI_NONAME	 8	/* hostname nor servname provided, or not known */
-#define	EAI_SERVICE	 9	/* servname not supported for ai_socktype */
-#define	EAI_SOCKTYPE	10	/* ai_socktype not supported */
-#define	EAI_SYSTEM	11	/* system error returned in errno */
-#define EAI_BADHINTS	12
-#define EAI_PROTOCOL	13
-#define EAI_MAX		14
-#endif /* ndef EAI_ADDRFAMILY */
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose, without fee, and without a written agreement
+is hereby granted, provided that the above copyright notice and this paragraph
+and the following two paragraphs appear in all copies.
 
-/*
- * Flag values for getaddrinfo()
+IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+
+THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS
+ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS
+TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+*/
+
+/*-------------------------------------------------------------------------
+ *
+ * getaddrinfo.h
+ *	  Support getaddrinfo() on platforms that don't have it.
+ *
+ * Note: we use our own routines on platforms that don't HAVE_STRUCT_ADDRINFO,
+ * whether or not the library routine getaddrinfo() can be found.  This
+ * policy is needed because on some platforms a manually installed libbind.a
+ * may provide getaddrinfo(), yet the system headers may not provide the
+ * struct definitions needed to call it.  To avoid conflict with the libbind
+ * definition in such cases, we rename our routines to pg_xxx() via macros.
+ *
+ * This code will also work on platforms where struct addrinfo is defined
+ * in the system headers but no getaddrinfo() can be located.
+ *
+ * Copyright (c) 2003-2007, PostgreSQL Global Development Group
+ *
+ *-------------------------------------------------------------------------
  */
+#ifndef ADDRINFO_H
+#define ADDRINFO_H
 
-#ifndef AI_PASSIVE
 
-#define	AI_PASSIVE	0x00000001 /* get address to use bind() */
-#define	AI_CANONNAME	0x00000002 /* fill ai_canonname */
-#define	AI_NUMERICHOST	0x00000004 /* prevent name resolution */
-/* valid flags for addrinfo */
-#define	AI_MASK		(AI_PASSIVE | AI_CANONNAME | AI_NUMERICHOST)
-
-#define	AI_ALL		0x00000100 /* IPv6 and IPv4-mapped (with AI_V4MAPPED) */
-#define	AI_V4MAPPED_CFG	0x00000200 /* accept IPv4-mapped if kernel supports */
-#define	AI_ADDRCONFIG	0x00000400 /* only if any address is assigned */
-#define	AI_V4MAPPED	0x00000800 /* accept IPv4-mapped IPv6 address */
-/* special recommended flags for getipnodebyname */
-#define	AI_DEFAULT	(AI_V4MAPPED_CFG | AI_ADDRCONFIG)
+/* Various macros that ought to be in <netdb.h>, but might not be */
+
+#ifndef EAI_FAIL
+#define EAI_BADFLAGS	(-1)
+#define EAI_NONAME		(-2)
+#define EAI_AGAIN		(-3)
+#define EAI_FAIL		(-4)
+#define EAI_FAMILY		(-6)
+#define EAI_SOCKTYPE	(-7)
+#define EAI_SERVICE		(-8)
+#define EAI_MEMORY		(-10)
+#define EAI_SYSTEM		(-11)
+#endif   /* !EAI_FAIL */
 
+#ifndef AI_PASSIVE
+#define AI_PASSIVE		0x0001
+#endif
+
+#ifndef AI_NUMERICHOST
 /*
- * Constants for getnameinfo()
+ * some platforms don't support AI_NUMERICHOST; define as zero if using
+ * the system version of getaddrinfo...
  */
+#if defined(HAVE_STRUCT_ADDRINFO) && defined(HAVE_GETADDRINFO)
+#define AI_NUMERICHOST	0
+#else
+#define AI_NUMERICHOST	0x0004
+#endif
+#endif
+
+#ifndef AI_CANONNAME
+#if defined(HAVE_STRUCT_ADDRINFO) && defined(HAVE_GETADDRINFO)
+#define AI_CANONNAME 0
+#else
+#define AI_CANONNAME 0x0008
+#endif
+#endif
+
+#ifndef AI_NUMERICSERV
+#if defined(HAVE_STRUCT_ADDRINFO) && defined(HAVE_GETADDRINFO)
+#define AI_NUMERICSERV 0
+#else
+#define AI_NUMERICSERV 0x0010
+#endif
+#endif
+
+#ifndef NI_NUMERICHOST
+#define NI_NUMERICHOST	1
+#endif
+
+#ifndef NI_NUMERICSERV
+#define NI_NUMERICSERV	2
+#endif
+
+#ifndef NI_NOFQDN
+#define NI_NOFQDN	4
+#endif
+
+#ifndef NI_NAMEREQD
+#define NI_NAMEREQD 	8
+#endif
+
+#ifndef NI_DGRAM
+#define NI_DGRAM	16
+#endif
+
+
+#ifndef NI_MAXHOST
 #define	NI_MAXHOST	1025
+#endif
+
+#ifndef NI_MAXSERV
 #define	NI_MAXSERV	32
+#endif
 
-/*
- * Flag values for getnameinfo()
- */
-#define	NI_NOFQDN	0x00000001
-#define	NI_NUMERICHOST	0x00000002
-#define	NI_NAMEREQD	0x00000004
-#define	NI_NUMERICSERV	0x00000008
-#define	NI_DGRAM	0x00000010
-
-struct addrinfo {
-	int	ai_flags;	/* AI_PASSIVE, AI_CANONNAME */
-	int	ai_family;	/* PF_xxx */
-	int	ai_socktype;	/* SOCK_xxx */
-	int	ai_protocol;	/* 0 or IPPROTO_xxx for IPv4 and IPv6 */
-	size_t	ai_addrlen;	/* length of ai_addr */
-	char	*ai_canonname;	/* canonical name for hostname */
-	struct sockaddr *ai_addr;	/* binary address */
-	struct addrinfo *ai_next;	/* next structure in linked list */
+#ifndef HAVE_STRUCT_ADDRINFO
+struct addrinfo
+{
+	int			ai_flags;
+	int			ai_family;
+	int			ai_socktype;
+	int			ai_protocol;
+	size_t		ai_addrlen;
+	struct sockaddr *ai_addr;
+	char	   *ai_canonname;
+	struct addrinfo *ai_next;
 };
+#endif   /* !HAVE_STRUCT_ADDRINFO */
 
-extern void freehostent(struct hostent *);
-extern char *gai_strerror(int);
-#endif /* AI_PASSIVE */
-#endif /* HAVE_GETADDRINFO */
-
-#ifndef HAVE_SOCKADDR_STORAGE
+#ifndef HAVE_STRUCT_SOCKADDR_STORAGE
 struct sockaddr_storage {
-	unsigned long	align;
-	unsigned char	fill[128 - sizeof (unsigned long)];
+	unsigned short ss_family;
+	unsigned long ss_align;
+	char ss_padding[128 - sizeof (unsigned long)];
 };
+#endif	/* !HAVE_STRUCT_SOCKADDR_STORAGE */
+
+#ifndef HAVE_GETADDRINFO
+
+/* Rename private copies per comments above */
+#ifdef getaddrinfo
+#undef getaddrinfo
+#endif
+#define getaddrinfo pg_getaddrinfo
+
+#ifdef freeaddrinfo
+#undef freeaddrinfo
+#endif
+#define freeaddrinfo pg_freeaddrinfo
+
+#ifdef gai_strerror
+#undef gai_strerror
 #endif
+#define gai_strerror pg_gai_strerror
+
+#ifdef getnameinfo
+#undef getnameinfo
+#endif
+#define getnameinfo pg_getnameinfo
+
+extern int getaddrinfo(const char *node, const char *service,
+			const struct addrinfo * hints, struct addrinfo ** res);
+extern void freeaddrinfo(struct addrinfo * res);
+extern const char *gai_strerror(int errcode);
+extern int getnameinfo(const struct sockaddr * sa, socklen_t salen,
+			char *node, size_t nodelen,
+			char *service, size_t servicelen, int flags);
+#endif   /* !HAVE_GETADDRINFO */
+
+#endif   /* ADDRINFO_H */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/compat.c	2006-10-14 07:17:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/compat.c	2007-07-10 21:55:49.000000000 +0800
@@ -4,23 +4,22 @@
  * Copyright (C) 1998 Andrew Tridgell
  * Copyright (C) 2002 Martin Pool
  * Copyright (C) 2004, 2005, 2006 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 #ifndef HAVE_STRDUP
  char *strdup(char *s)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/getaddrinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/getaddrinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/getaddrinfo.c	2006-10-28 05:14:28.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/getaddrinfo.c	2007-11-09 04:30:17.000000000 +0800
@@ -1,630 +1,508 @@
 /*
- * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
- *
- * Changes Copyright (C) 2001 Martin Pool <mbp@samba.org>
- * 
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the project nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- * 
- * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
+PostgreSQL Database Management System
+(formerly known as Postgres, then as Postgres95)
 
-/*
- * "#ifdef FAITH" part is local hack for supporting IPv4-v6 translator.
+Portions Copyright (c) 1996-2005, The PostgreSQL Global Development Group
+
+Portions Copyright (c) 1994, The Regents of the University of California
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose, without fee, and without a written agreement
+is hereby granted, provided that the above copyright notice and this paragraph
+and the following two paragraphs appear in all copies.
+
+IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, INCLUDING
+LOST PROFITS, ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION,
+EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+
+THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
+INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
+AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE PROVIDED HEREUNDER IS
+ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATIONS
+TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
+
+*/
+
+/*-------------------------------------------------------------------------
+ *
+ * getaddrinfo.c
+ *	  Support getaddrinfo() on platforms that don't have it.
+ *
+ * We also supply getnameinfo() here, assuming that the platform will have
+ * it if and only if it has getaddrinfo().	If this proves false on some
+ * platform, we'll need to split this file and provide a separate configure
+ * test for getnameinfo().
  *
- * Issues to be discussed:
- * - Thread safe-ness must be checked.
- * - Return values.  There are nonstandard return values defined and used
- *   in the source code.  This is because RFC2133 is silent about which error
- *   code must be returned for which situation.
- * - PF_UNSPEC case would be handled in getipnodebyname() with the AI_ALL flag.
+ * Copyright (c) 2003-2007, PostgreSQL Global Development Group
+ *
+ * Copyright (C) 2007 Jeremy Allison.
+ * Modified to return multiple IPv4 addresses for Samba.
+ *
+ *-------------------------------------------------------------------------
  */
 
-#include <rsync.h>
+#include "rsync.h"
 
-#if defined(__KAME__) && defined(INET6)
-# define FAITH
+#ifndef SMB_MALLOC
+#define SMB_MALLOC(s) malloc(s)
 #endif
 
-#define SUCCESS 0
-#define ANY 0
-#define YES 1
-#define NO  0
-
-#ifdef FAITH
-static int translate = NO;
-static struct in6_addr faith_prefix = IN6ADDR_ANY_INIT;
-#endif /* FAITH */
-
-/* Amdahl's UTS 2.1.2 defines NO_ADDRESS instead of NO_DATA. */
-
-#ifndef NO_DATA
-#ifdef NO_ADDRESS
-#define NO_DATA NO_ADDRESS
+#ifndef SMB_STRDUP
+#define SMB_STRDUP(s) strdup(s)
 #endif
-#endif /* ndef NO_DATA */
 
-static const char in_addrany[] = { 0, 0, 0, 0 };
-static const char in_loopback[] = { 127, 0, 0, 1 }; 
-#ifdef INET6
-static const char in6_addrany[] = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-};
-static const char in6_loopback[] = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
-};
+#ifndef HOST_NAME_MAX
+#define HOST_NAME_MAX 255
 #endif
 
-struct sockinet {
-	u_char	si_len;
-	u_char	si_family;
-	u_short	si_port;
-};
-
-static struct afd {
-	int a_af;
-	int a_addrlen;
-	int a_socklen;
-	int a_off;
-	const char *a_addrany;
-	const char *a_loopback;	
-} afdl [] = {
-#ifdef INET6
-#define N_INET6 0
-	{PF_INET6, sizeof(struct in6_addr),
-	 sizeof(struct sockaddr_in6),
-	 offsetof(struct sockaddr_in6, sin6_addr),
-	 in6_addrany, in6_loopback},
-#define N_INET  1
-#else
-#define N_INET  0
-#endif
-	{PF_INET, sizeof(struct in_addr),
-	 sizeof(struct sockaddr_in),
-	 offsetof(struct sockaddr_in, sin_addr),
-	 in_addrany, in_loopback},
-	{0, 0, 0, 0, NULL, NULL},
-};
-
-#ifdef INET6
-#define PTON_MAX	16
-#else
-#define PTON_MAX	4
+static int check_hostent_err(struct hostent *hp)
+{
+#ifndef INET6
+	extern int h_errno;
 #endif
+	if (!hp) {
+		switch (h_errno) {
+			case HOST_NOT_FOUND:
+			case NO_DATA:
+				return EAI_NONAME;
+			case TRY_AGAIN:
+				return EAI_AGAIN;
+			case NO_RECOVERY:
+			default:
+				return EAI_FAIL;
+		}
+	}
+	if (!hp->h_name || hp->h_addrtype != AF_INET) {
+		return EAI_FAIL;
+	}
+	return 0;
+}
 
+static char *canon_name_from_hostent(struct hostent *hp,
+				int *perr)
+{
+	char *ret = NULL;
 
-static int get_name (const char *, struct afd *,
-		     struct addrinfo **, char *, struct addrinfo *,
-		     int);
-static int get_addr (const char *, int, struct addrinfo **,
-			struct addrinfo *, int);
-static int str_isnumber (const char *);
-	
-static char *ai_errlist[] = {
-	"success.",
-	"address family for hostname not supported.",	/* EAI_ADDRFAMILY */
-	"temporary failure in name resolution.",	/* EAI_AGAIN      */
-	"invalid value for ai_flags.",		       	/* EAI_BADFLAGS   */
-	"non-recoverable failure in name resolution.", 	/* EAI_FAIL       */
-	"ai_family not supported.",			/* EAI_FAMILY     */
-	"memory allocation failure.", 			/* EAI_MEMORY     */
-	"no address associated with hostname.", 	/* EAI_NODATA     */
-	"hostname nor servname provided, or not known.",/* EAI_NONAME     */
-	"servname not supported for ai_socktype.",	/* EAI_SERVICE    */
-	"ai_socktype not supported.", 			/* EAI_SOCKTYPE   */
-	"system error returned in errno.", 		/* EAI_SYSTEM     */
-	"invalid value for hints.",			/* EAI_BADHINTS	  */
-	"resolved protocol is unknown.",		/* EAI_PROTOCOL   */
-	"unknown error.", 				/* EAI_MAX        */
-};
-
-#define GET_CANONNAME(ai, str) \
-if (pai->ai_flags & AI_CANONNAME) {\
-	int name_size = strlen(str) + 1;\
-	if (((ai)->ai_canonname = (char *)malloc(name_size)) != NULL) {\
-		memcpy((ai)->ai_canonname, (str), name_size);\
-	} else {\
-		error = EAI_MEMORY;\
-		goto free;\
-	}\
+	*perr = check_hostent_err(hp);
+	if (*perr) {
+		return NULL;
+	}
+	ret = SMB_STRDUP(hp->h_name);
+	if (!ret) {
+		*perr = EAI_MEMORY;
+	}
+	return ret;
 }
 
+static char *get_my_canon_name(int *perr)
+{
+	char name[HOST_NAME_MAX+1];
 
-static int get_ai(struct addrinfo ** to_ai,
-		   struct addrinfo const * pai,
-		   struct afd *afd,
-		   const char *addr,
-		   short port)
-{
-	char *p;
-	if ((*to_ai = (struct addrinfo *)malloc(sizeof(struct addrinfo) +
-					      ((afd)->a_socklen)))
-	    == NULL) 
-		return 0;
-	memcpy(*to_ai, pai, sizeof(struct addrinfo));
-	(*to_ai)->ai_addr = (struct sockaddr *)((*to_ai) + 1);
-	memset((*to_ai)->ai_addr, 0, (afd)->a_socklen);
-	(*to_ai)->ai_addrlen = (afd)->a_socklen;
-#ifdef HAVE_SOCKADDR_LEN
-	(*to_ai)->ai_addr->sa_len = (afd)->a_socklen;
-#endif
-	(*to_ai)->ai_addr->sa_family = (*to_ai)->ai_family = (afd)->a_af;
-	((struct sockinet *)(*to_ai)->ai_addr)->si_port = port;
-	p = (char *)((*to_ai)->ai_addr);
-	memcpy(p + (afd)->a_off, (addr), (afd)->a_addrlen);
-	return 1;
+	if (gethostname(name, HOST_NAME_MAX) == -1) {
+		*perr = EAI_FAIL;
+		return NULL;
+	}
+	/* Ensure null termination. */
+	name[HOST_NAME_MAX] = '\0';
+	return canon_name_from_hostent(gethostbyname(name), perr);
 }
 
-#define ERR(err) do { error = (err); if (1) goto bad; } while (0)
-
-char *
-gai_strerror(ecode)
-	int ecode;
+static char *get_canon_name_from_addr(struct in_addr ip,
+				int *perr)
 {
-	if (ecode < 0 || ecode > EAI_MAX)
-		ecode = EAI_MAX;
-	return ai_errlist[ecode];
+	return canon_name_from_hostent(
+			gethostbyaddr((void *)&ip, sizeof ip, AF_INET),
+			perr);
 }
 
-void
-freeaddrinfo(ai)
-	struct addrinfo *ai;
+static struct addrinfo *alloc_entry(const struct addrinfo *hints,
+				struct in_addr ip,
+				unsigned short port)
 {
-	struct addrinfo *next;
+	struct sockaddr_in *psin = NULL;
+	struct addrinfo *ai = SMB_MALLOC(sizeof(*ai));
 
-	do {
-		next = ai->ai_next;
-		if (ai->ai_canonname)
-			free(ai->ai_canonname);
-		/* no need to free(ai->ai_addr) */
+	if (!ai) {
+		return NULL;
+	}
+	memset(ai, '\0', sizeof(*ai));
+
+	psin = SMB_MALLOC(sizeof(*psin));
+	if (!psin) {
 		free(ai);
-	} while ((ai = next) != NULL);
+		return NULL;
+	}
+
+	memset(psin, '\0', sizeof(*psin));
+
+	psin->sin_family = AF_INET;
+	psin->sin_port = htons(port);
+	psin->sin_addr = ip;
+
+	ai->ai_flags = 0;
+	ai->ai_family = AF_INET;
+	ai->ai_socktype = hints->ai_socktype;
+	ai->ai_protocol = hints->ai_protocol;
+	ai->ai_addrlen = sizeof(*psin);
+	ai->ai_addr = (struct sockaddr *) psin;
+	ai->ai_canonname = NULL;
+	ai->ai_next = NULL;
+
+	return ai;
 }
 
-static int
-str_isnumber(p)
-	const char *p;
-{
-	char *q = (char *)p;
-	while (*q) {
-		if (! isdigit(*q))
-			return NO;
-		q++;
-	}
-	return YES;
-}
-
-int
-getaddrinfo(hostname, servname, hints, res)
-	const char *hostname, *servname;
-	const struct addrinfo *hints;
-	struct addrinfo **res;
-{
-	struct addrinfo sentinel;
-	struct addrinfo *top = NULL;
-	struct addrinfo *cur;
-	int i, error = 0;
-	char pton[PTON_MAX];
-	struct addrinfo ai;
-	struct addrinfo *pai;
-	u_short port;
-
-#ifdef FAITH
-	static int firsttime = 1;
-
-	if (firsttime) {
-		/* translator hack */
-		{
-			char *q = getenv("GAI");
-			if (q && inet_pton(AF_INET6, q, &faith_prefix) == 1)
-				translate = YES;
+/*
+ * get address info for a single ipv4 address.
+ *
+ *	Bugs:	- servname can only be a number, not text.
+ */
+
+static int getaddr_info_single_addr(const char *service,
+				uint32 addr,
+				const struct addrinfo *hints,
+				struct addrinfo **res)
+{
+
+	struct addrinfo *ai = NULL;
+	struct in_addr ip;
+	unsigned short port = 0;
+
+	if (service) {
+		port = (unsigned short)atoi(service);
+	}
+	ip.s_addr = htonl(addr);
+
+	ai = alloc_entry(hints, ip, port);
+	if (!ai) {
+		return EAI_MEMORY;
+	}
+
+	/* If we're asked for the canonical name,
+	 * make sure it returns correctly. */
+	if (!(hints->ai_flags & AI_NUMERICSERV) &&
+			hints->ai_flags & AI_CANONNAME) {
+		int err;
+		if (addr == INADDR_LOOPBACK || addr == INADDR_ANY) {
+			ai->ai_canonname = get_my_canon_name(&err);
+		} else {
+			ai->ai_canonname =
+			get_canon_name_from_addr(ip,&err);
+		}
+		if (ai->ai_canonname == NULL) {
+			freeaddrinfo(ai);
+			return err;
 		}
-		firsttime = 0;
 	}
-#endif
 
-	/* initialize file static vars */
-	sentinel.ai_next = NULL;
-	cur = &sentinel;
-	pai = &ai;
-	pai->ai_flags = 0;
-	pai->ai_family = PF_UNSPEC;
-	pai->ai_socktype = ANY;
-	pai->ai_protocol = ANY;
-	pai->ai_addrlen = 0;
-	pai->ai_canonname = NULL;
-	pai->ai_addr = NULL;
-	pai->ai_next = NULL;
-	port = ANY;
-	
-	if (hostname == NULL && servname == NULL)
-		return EAI_NONAME;
-	if (hints) {
-		/* error check for hints */
-		if (hints->ai_addrlen || hints->ai_canonname ||
-		    hints->ai_addr || hints->ai_next)
-			ERR(EAI_BADHINTS); /* xxx */
-		if (hints->ai_flags & ~AI_MASK)
-			ERR(EAI_BADFLAGS);
-		switch (hints->ai_family) {
-		case PF_UNSPEC:
-		case PF_INET:
-#ifdef INET6
-		case PF_INET6:
-#endif
-			break;
-		default:
-			ERR(EAI_FAMILY);
+	*res = ai;
+	return 0;
+}
+
+/*
+ * get address info for multiple ipv4 addresses.
+ *
+ *	Bugs:	- servname can only be a number, not text.
+ */
+
+static int getaddr_info_name(const char *node,
+				const char *service,
+				const struct addrinfo *hints,
+				struct addrinfo **res)
+{
+	struct addrinfo *listp = NULL, *prevp = NULL;
+	char **pptr = NULL;
+	int err;
+	struct hostent *hp = NULL;
+	unsigned short port = 0;
+
+	if (service) {
+		port = (unsigned short)atoi(service);
+	}
+
+	hp = gethostbyname(node);
+	err = check_hostent_err(hp);
+	if (err) {
+		return err;
+	}
+
+	for(pptr = hp->h_addr_list; *pptr; pptr++) {
+		struct in_addr ip = *(struct in_addr *)*pptr;
+		struct addrinfo *ai = alloc_entry(hints, ip, port);
+
+		if (!ai) {
+			freeaddrinfo(listp);
+			return EAI_MEMORY;
 		}
-		memcpy(pai, hints, sizeof(*pai));
-		switch (pai->ai_socktype) {
-		case ANY:
-			switch (pai->ai_protocol) {
-			case ANY:
-				break;
-			case IPPROTO_UDP:
-				pai->ai_socktype = SOCK_DGRAM;
-				break;
-			case IPPROTO_TCP:
-				pai->ai_socktype = SOCK_STREAM;
-				break;
-			default:
-				pai->ai_socktype = SOCK_RAW;
-				break;
+
+		if (!listp) {
+			listp = ai;
+			prevp = ai;
+			ai->ai_canonname = SMB_STRDUP(hp->h_name);
+			if (!ai->ai_canonname) {
+				freeaddrinfo(listp);
+				return EAI_MEMORY;
 			}
-			break;
-		case SOCK_RAW:
-			break;
-		case SOCK_DGRAM:
-			if (pai->ai_protocol != IPPROTO_UDP &&
-			    pai->ai_protocol != ANY)
-				ERR(EAI_BADHINTS);	/*xxx*/
-			pai->ai_protocol = IPPROTO_UDP;
-			break;
-		case SOCK_STREAM:
-			if (pai->ai_protocol != IPPROTO_TCP &&
-			    pai->ai_protocol != ANY)
-				ERR(EAI_BADHINTS);	/*xxx*/
-			pai->ai_protocol = IPPROTO_TCP;
-			break;
-		default:
-			ERR(EAI_SOCKTYPE);
-			break;
+		} else {
+			prevp->ai_next = ai;
+			prevp = ai;
 		}
 	}
+	*res = listp;
+	return 0;
+}
 
-	/*
-	 * service port
-	 */
-	if (servname) {
-		if (str_isnumber(servname)) {
-			if (pai->ai_socktype == ANY) {
-				/* caller accept *ANY* socktype */
-				pai->ai_socktype = SOCK_DGRAM;
-				pai->ai_protocol = IPPROTO_UDP;
-			}
-			port = htons(atoi(servname));
-		} else {
-			struct servent *sp;
-			char *proto;
+/*
+ * get address info for ipv4 sockets.
+ *
+ *	Bugs:	- servname can only be a number, not text.
+ */
 
-			proto = NULL;
-			switch (pai->ai_socktype) {
-			case ANY:
-				proto = NULL;
-				break;
-			case SOCK_DGRAM:
-				proto = "udp";
-				break;
-			case SOCK_STREAM:
-				proto = "tcp";
-				break;
-			default:
-				fprintf(stderr, "panic!\n");
-				break;
-			}
-			if ((sp = getservbyname(servname, proto)) == NULL)
-				ERR(EAI_SERVICE);
-			port = sp->s_port;
-			if (pai->ai_socktype == ANY) {
-				if (strcmp(sp->s_proto, "udp") == 0) {
-					pai->ai_socktype = SOCK_DGRAM;
-					pai->ai_protocol = IPPROTO_UDP;
-				} else if (strcmp(sp->s_proto, "tcp") == 0) {
-					pai->ai_socktype = SOCK_STREAM;
-					pai->ai_protocol = IPPROTO_TCP;
-				} else
-					ERR(EAI_PROTOCOL);	/*xxx*/
-			}
-		}
+int getaddrinfo(const char *node,
+		const char *service,
+		const struct addrinfo * hintp,
+		struct addrinfo ** res)
+{
+	struct addrinfo hints;
+
+	/* Setup the hints struct. */
+	if (hintp == NULL) {
+		memset(&hints, 0, sizeof(hints));
+		hints.ai_family = AF_INET;
+		hints.ai_socktype = SOCK_STREAM;
+	} else {
+		memcpy(&hints, hintp, sizeof(hints));
+	}
+
+	if (hints.ai_family != AF_INET && hints.ai_family != AF_UNSPEC) {
+		return EAI_FAMILY;
+	}
+
+	if (hints.ai_socktype == 0) {
+		hints.ai_socktype = SOCK_STREAM;
 	}
-	
-	/*
-	 * hostname == NULL.
-	 * passive socket -> anyaddr (0.0.0.0 or ::)
-	 * non-passive socket -> localhost (127.0.0.1 or ::1)
-	 */
-	if (hostname == NULL) {
-		struct afd *afd;
-
-		for (afd = &afdl[0]; afd->a_af; afd++) {
-			if (!(pai->ai_family == PF_UNSPEC
-			   || pai->ai_family == afd->a_af)) {
-				continue;
-			}
 
-			if (pai->ai_flags & AI_PASSIVE) {
-				if (!get_ai(&cur->ai_next, pai, afd, afd->a_addrany, port))
-					goto free;
-				/* xxx meaningless?
-				 * GET_CANONNAME(cur->ai_next, "anyaddr");
-				 */
-			} else {
-				if (!get_ai(&cur->ai_next, pai, afd, afd->a_loopback,
-					port))
-					goto free;
-				/* xxx meaningless?
-				 * GET_CANONNAME(cur->ai_next, "localhost");
-				 */
+	if (!node && !service) {
+		return EAI_NONAME;
+	}
+
+	if (node) {
+		if (node[0] == '\0') {
+			return getaddr_info_single_addr(service,
+					INADDR_ANY,
+					&hints,
+					res);
+		} else if (hints.ai_flags & AI_NUMERICHOST) {
+			struct in_addr ip;
+			if (!inet_aton(node, &ip)) {
+				return EAI_FAIL;
 			}
-			cur = cur->ai_next;
+			return getaddr_info_single_addr(service,
+					ntohl(ip.s_addr),
+					&hints,
+					res);
+		} else {
+			return getaddr_info_name(node,
+						service,
+						&hints,
+						res);
 		}
-		top = sentinel.ai_next;
-		if (top)
-			goto good;
-		else
-			ERR(EAI_FAMILY);
-	}
-	
-	/* hostname as numeric name */
-	for (i = 0; afdl[i].a_af; i++) {
-		if (inet_pton(afdl[i].a_af, hostname, pton)) {
-			u_long v4a;
-
-			switch (afdl[i].a_af) {
-			case AF_INET:
-				v4a = ((struct in_addr *)pton)->s_addr;
-				if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
-					pai->ai_flags &= ~AI_CANONNAME;
-				v4a >>= IN_CLASSA_NSHIFT;
-				if (v4a == 0 || v4a == IN_LOOPBACKNET)
-					pai->ai_flags &= ~AI_CANONNAME;
-				break;
-#ifdef INET6
-			case AF_INET6:
-			{
-				u_char pfx;
-				pfx = ((struct in6_addr *)pton)->s6_addr[0];
-				if (pfx == 0 || pfx == 0xfe || pfx == 0xff)
-					pai->ai_flags &= ~AI_CANONNAME;
-				break;
-			}
-#endif
-			}
-			
-			if (pai->ai_family == afdl[i].a_af ||
-			    pai->ai_family == PF_UNSPEC) {
-				if (! (pai->ai_flags & AI_CANONNAME)) {
-					if (get_ai(&top, pai, &afdl[i], pton, port))
-						goto good;
-					else
-						goto free;
-				}
-				/*
-				 * if AI_CANONNAME and if reverse lookup
-				 * fail, return ai anyway to pacify
-				 * calling application.
-				 *
-				 * XXX getaddrinfo() is a name->address
-				 * translation function, and it looks strange
-				 * that we do addr->name translation here.
-				 */
-				get_name(pton, &afdl[i], &top, pton, pai, port);
-				goto good;
-			} else 
-				ERR(EAI_FAMILY);	/*xxx*/
+	} else if (hints.ai_flags & AI_PASSIVE) {
+		return getaddr_info_single_addr(service,
+					INADDR_ANY,
+					&hints,
+					res);
+	}
+	return getaddr_info_single_addr(service,
+					INADDR_LOOPBACK,
+					&hints,
+					res);
+}
+
+
+void freeaddrinfo(struct addrinfo *res)
+{
+	struct addrinfo *next = NULL;
+
+	for (;res; res = next) {
+		next = res->ai_next;
+		if (res->ai_canonname) {
+			free(res->ai_canonname);
 		}
+		if (res->ai_addr) {
+			free(res->ai_addr);
+		}
+		free(res);
 	}
+}
 
-	if (pai->ai_flags & AI_NUMERICHOST)
-		ERR(EAI_NONAME);
-
-	/* hostname as alphabetical name */
-	error = get_addr(hostname, pai->ai_family, &top, pai, port);
-	if (error == 0) {
-		if (top) {
- good:
-			*res = top;
-			return SUCCESS;
-		} else
-			error = EAI_FAIL;
-	}
- free:
-	if (top)
-		freeaddrinfo(top);
- bad:
-	*res = NULL;
-	return error;
-}
-
-static int
-get_name(addr, afd, res, numaddr, pai, port0)
-	const char *addr;
-	struct afd *afd;
-	struct addrinfo **res;
-	char *numaddr;
-	struct addrinfo *pai;
-	int port0;
-{
-	u_short port = port0 & 0xffff;
-	struct hostent *hp;
-	struct addrinfo *cur;
-	int error = 0;
-	
-#ifdef INET6
-	{
-		int h_error;
-		hp = getipnodebyaddr(addr, afd->a_addrlen, afd->a_af, &h_error);
-	}
-#else
-	hp = gethostbyaddr(addr, afd->a_addrlen, AF_INET);
-#endif
-	if (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {
-		if (!get_ai(&cur, pai, afd, hp->h_addr_list[0], port))
-			goto free;
-		GET_CANONNAME(cur, hp->h_name);
-	} else {
-		if (!get_ai(&cur, pai, afd, numaddr, port))
-			goto free;
-	}
-	
-#ifdef INET6
-	if (hp)
-		freehostent(hp);
-#endif
-	*res = cur;
-	return SUCCESS;
- free:
-	if (cur)
-		freeaddrinfo(cur);
-#ifdef INET6
-	if (hp)
-		freehostent(hp);
-#endif
- /* bad: */
-	*res = NULL;
-	return error;
-}
-
-static int
-get_addr(hostname, af, res, pai, port0)
-	const char *hostname;
-	int af;
-	struct addrinfo **res;
-	struct addrinfo *pai;
-	int port0;
-{
-	u_short port = port0 & 0xffff;
-	struct addrinfo sentinel;
-	struct hostent *hp;
-	struct addrinfo *top, *cur;
-	struct afd *afd;
-	int i, error = 0, h_error;
-	char *ap;
-#ifndef INET6
-	extern int h_errno;
-#endif
 
-	top = NULL;
-	sentinel.ai_next = NULL;
-	cur = &sentinel;
-#ifdef INET6
-	if (af == AF_UNSPEC) {
-		hp = getipnodebyname(hostname, AF_INET6,
-				AI_ADDRCONFIG|AI_ALL|AI_V4MAPPED, &h_error);
-	} else
-		hp = getipnodebyname(hostname, af, AI_ADDRCONFIG, &h_error);
-#else
-	hp = gethostbyname(hostname);
-	h_error = h_errno;
-#endif
-	if (hp == NULL) {
-		switch (h_error) {
-		case HOST_NOT_FOUND:
-		case NO_DATA:
-			error = EAI_NODATA;
+const char *gai_strerror(int errcode)
+{
+#ifdef HAVE_HSTRERROR
+	int			hcode;
+
+	switch (errcode)
+	{
+		case EAI_NONAME:
+			hcode = HOST_NOT_FOUND;
 			break;
-		case TRY_AGAIN:
-			error = EAI_AGAIN;
+		case EAI_AGAIN:
+			hcode = TRY_AGAIN;
 			break;
-		case NO_RECOVERY:
+		case EAI_FAIL:
 		default:
-			error = EAI_FAIL;
+			hcode = NO_RECOVERY;
 			break;
-		}
-		goto bad;
 	}
 
-	if ((hp->h_name == NULL) || (hp->h_name[0] == 0) ||
-	    (hp->h_addr_list[0] == NULL))
-		ERR(EAI_FAIL);
-	
-	for (i = 0; (ap = hp->h_addr_list[i]) != NULL; i++) {
-		switch (af) {
-#ifdef INET6
-		case AF_INET6:
-			afd = &afdl[N_INET6];
-			break;
-#endif
-#ifndef INET6
-		default:	/* AF_UNSPEC */
-#endif
-		case AF_INET:
-			afd = &afdl[N_INET];
-			break;
-#ifdef INET6
-		default:	/* AF_UNSPEC */
-			if (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)ap)) {
-				ap += sizeof(struct in6_addr) -
-					sizeof(struct in_addr);
-				afd = &afdl[N_INET];
-			} else
-				afd = &afdl[N_INET6];
-			break;
+	return hstrerror(hcode);
+#else							/* !HAVE_HSTRERROR */
+
+	switch (errcode)
+	{
+		case EAI_NONAME:
+			return "Unknown host";
+		case EAI_AGAIN:
+			return "Host name lookup failure";
+#ifdef EAI_BADFLAGS
+		case EAI_BADFLAGS:
+			return "Invalid argument";
+#endif
+#ifdef EAI_FAMILY
+		case EAI_FAMILY:
+			return "Address family not supported";
+#endif
+#ifdef EAI_MEMORY
+		case EAI_MEMORY:
+			return "Not enough memory";
+#endif
+#ifdef EAI_NODATA
+		case EAI_NODATA:
+			return "No host data of that type was found";
+#endif
+#ifdef EAI_SERVICE
+		case EAI_SERVICE:
+			return "Class type not found";
+#endif
+#ifdef EAI_SOCKTYPE
+		case EAI_SOCKTYPE:
+			return "Socket type not supported";
 #endif
+		default:
+			return "Unknown server error";
+	}
+#endif   /* HAVE_HSTRERROR */
+}
+
+static int gethostnameinfo(const struct sockaddr *sa,
+			char *node,
+			size_t nodelen,
+			int flags)
+{
+	int ret = -1;
+	char *p = NULL;
+
+	if (!(flags & NI_NUMERICHOST)) {
+		struct hostent *hp = gethostbyaddr(
+				(void *)&((struct sockaddr_in *)sa)->sin_addr,
+				sizeof (struct in_addr),
+				sa->sa_family);
+		ret = check_hostent_err(hp);
+		if (ret == 0) {
+			/* Name looked up successfully. */
+			ret = snprintf(node, nodelen, "%s", hp->h_name);
+			if (ret < 0 || (size_t)ret >= nodelen) {
+				return EAI_MEMORY;
+			}
+			if (flags & NI_NOFQDN) {
+				p = strchr(node,'.');
+				if (p) {
+					*p = '\0';
+				}
+			}
+			return 0;
 		}
-#ifdef FAITH
-		if (translate && afd->a_af == AF_INET) {
-			struct in6_addr *in6;
-
-			if (!get_ai(&cur->ai_next, pai, &afdl[N_INET6], ap, port))
-				goto free;
-			in6 = &((struct sockaddr_in6 *)cur->ai_next->ai_addr)->sin6_addr;
-			memcpy(&in6->s6_addr32[0], &faith_prefix,
-			    sizeof(struct in6_addr) - sizeof(struct in_addr));
-			memcpy(&in6->s6_addr32[3], ap, sizeof(struct in_addr));
-		} else
-#endif /* FAITH */
-		if (!get_ai(&cur->ai_next, pai, afd, ap, port))
-			goto free;
-		if (cur == &sentinel) {
-			top = cur->ai_next;
-			GET_CANONNAME(top, hp->h_name);
+
+		if (flags & NI_NAMEREQD) {
+			/* If we require a name and didn't get one,
+			 * automatically fail. */
+			return ret;
 		}
-		cur = cur->ai_next;
+		/* Otherwise just fall into the numeric host code... */
 	}
-#ifdef INET6
-	freehostent(hp);
-#endif
-	*res = top;
-	return SUCCESS;
- free:
-	if (top)
-		freeaddrinfo(top);
-#ifdef INET6
-	if (hp)
-		freehostent(hp);
-#endif
- bad:
-	*res = NULL;
-	return error;
+	p = inet_ntoa(((struct sockaddr_in *)sa)->sin_addr);
+	ret = snprintf(node, nodelen, "%s", p);
+	if (ret < 0 || (size_t)ret >= nodelen) {
+		return EAI_MEMORY;
+	}
+	return 0;
+}
+
+static int getservicenameinfo(const struct sockaddr *sa,
+			char *service,
+			size_t servicelen,
+			int flags)
+{
+	int ret = -1;
+	int port = ntohs(((struct sockaddr_in *)sa)->sin_port);
+
+	if (!(flags & NI_NUMERICSERV)) {
+		struct servent *se = getservbyport(
+				port,
+				(flags & NI_DGRAM) ? "udp" : "tcp");
+		if (se && se->s_name) {
+			/* Service name looked up successfully. */
+			ret = snprintf(service, servicelen, "%s", se->s_name);
+			if (ret < 0 || (size_t)ret >= servicelen) {
+				return EAI_MEMORY;
+			}
+			return 0;
+		}
+		/* Otherwise just fall into the numeric service code... */
+	}
+	ret = snprintf(service, servicelen, "%d", port);
+	if (ret < 0 || (size_t)ret >= servicelen) {
+		return EAI_MEMORY;
+	}
+	return 0;
+}
+
+/*
+ * Convert an ipv4 address to a hostname.
+ *
+ * Bugs:	- No IPv6 support.
+ */
+int getnameinfo(const struct sockaddr *sa, socklen_t salen,
+			char *node, size_t nodelen,
+			char *service, size_t servicelen, int flags)
+{
+
+	/* Invalid arguments. */
+	if (sa == NULL || (node == NULL && service == NULL)) {
+		return EAI_FAIL;
+	}
+
+	if (sa->sa_family != AF_INET) {
+		return EAI_FAIL;
+	}
+
+	if (salen < (socklen_t)sizeof (struct sockaddr_in)) {
+		return EAI_FAIL;
+	}
+
+	/* We don't support those. */
+	if ((node && !(flags & NI_NUMERICHOST))
+		|| (service && !(flags & NI_NUMERICSERV)))
+		return EAI_FAIL;
+
+	if (node) {
+		return gethostnameinfo(sa, node, nodelen, flags);
+	}
+
+	if (service) {
+		return getservicenameinfo(sa, service, servicelen, flags);
+	}
+	return 0;
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib: getnameinfo.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib: md5.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/mdfour.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/mdfour.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/mdfour.c	2006-04-26 07:51:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/mdfour.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,36 +1,35 @@
 /* 
  * Unix SMB/Netbios implementation.
  * Version 1.9.
  * An implementation of MD4 designed for use in the SMB authentication protocol.
  *
  * Copyright (C) 1997-1998 Andrew Tridgell
- * Copyright (C) 2005 Wayne Davison
+ * Copyright (C) 2005-2008 Wayne Davison
  * 
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  * 
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  * 
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 /* NOTE: This code makes no attempt to be fast! 
  *
  * It assumes that a int is at least 32 bits long. */
 
-static struct mdfour *m;
+static md_context *m;
 
 #define MASK32 (0xffffffff)
 
 #define F(X,Y,Z) ((((X)&(Y)) | ((~(X))&(Z))))
 #define G(X,Y,Z) ((((X)&(Y)) | ((X)&(Z)) | ((Y)&(Z))))
 #define H(X,Y,Z) (((X)^(Y)^(Z)))
@@ -83,208 +81,166 @@
 	A &= MASK32; B &= MASK32; 
 	C &= MASK32; D &= MASK32;
 
 	m->A = A; m->B = B; m->C = C; m->D = D;
 }
 
-static void copy64(uint32 *M, unsigned char *in)
+static void copy64(uint32 *M, const uchar *in)
 {
 	int i;
 
-	for (i=0;i<16;i++)
-		M[i] = (in[i*4+3]<<24) | (in[i*4+2]<<16) |
-			(in[i*4+1]<<8) | (in[i*4+0]<<0);
+	for (i = 0; i < MD4_DIGEST_LEN; i++) {
+		M[i] = (in[i*4+3] << 24) | (in[i*4+2] << 16)
+		     | (in[i*4+1] << 8)  | (in[i*4+0] << 0);
+	}
 }
 
-static void copy4(unsigned char *out,uint32 x)
+static void copy4(uchar *out,uint32 x)
 {
 	out[0] = x&0xFF;
 	out[1] = (x>>8)&0xFF;
 	out[2] = (x>>16)&0xFF;
 	out[3] = (x>>24)&0xFF;
 }
 
-void mdfour_begin(struct mdfour *md)
+void mdfour_begin(md_context *md)
 {
 	md->A = 0x67452301;
 	md->B = 0xefcdab89;
 	md->C = 0x98badcfe;
 	md->D = 0x10325476;
 	md->totalN = 0;
 	md->totalN2 = 0;
 }
 
-
-static void mdfour_tail(unsigned char *in, uint32 n)
+static void mdfour_tail(const uchar *in, uint32 length)
 {
-	unsigned char buf[128];
+	uchar buf[128];
 	uint32 M[16];
 	extern int protocol_version;
 
 	/*
 	 * Count total number of bits, modulo 2^64
 	 */
-	m->totalN += n << 3;
-	if (m->totalN < (n << 3)) {
+	m->totalN += length << 3;
+	if (m->totalN < (length << 3))
 		m->totalN2++;
-	}
-	m->totalN2 += n >> 29;
+	m->totalN2 += length >> 29;
 
 	memset(buf, 0, 128);
-	if (n) memcpy(buf, in, n);
-	buf[n] = 0x80;
+	if (length)
+		memcpy(buf, in, length);
+	buf[length] = 0x80;
 
-	if (n <= 55) {
+	if (length <= 55) {
 		copy4(buf+56, m->totalN);
 		/*
 		 * Prior to protocol version 27 only the number of bits
 		 * modulo 2^32 was included.  MD4 requires the number
 		 * of bits modulo 2^64, which was fixed starting with
 		 * protocol version 27.
 		 */
-		if (protocol_version >= 27) {
+		if (protocol_version >= 27)
 			copy4(buf+60, m->totalN2);
-		}
 		copy64(M, buf);
 		mdfour64(M);
 	} else {
 		copy4(buf+120, m->totalN); 
 		/*
 		 * Prior to protocol version 27 only the number of bits
 		 * modulo 2^32 was included.  MD4 requires the number
 		 * of bits modulo 2^64, which was fixed starting with
 		 * protocol version 27.
 		 */
-		if (protocol_version >= 27) {
+		if (protocol_version >= 27)
 			copy4(buf+124, m->totalN2); 
-		}
 		copy64(M, buf);
 		mdfour64(M);
 		copy64(M, buf+64);
 		mdfour64(M);
 	}
 }
 
-void mdfour_update(struct mdfour *md, unsigned char *in, uint32 n)
+void mdfour_update(md_context *md, const uchar *in, uint32 length)
 {
 	uint32 M[16];
 
 	m = md;
 
-	if (n == 0) mdfour_tail(in, n);
+	if (length == 0)
+		mdfour_tail(in, length);
 
-	while (n >= 64) {
+	while (length >= 64) {
 		copy64(M, in);
 		mdfour64(M);
 		in += 64;
-		n -= 64;
+		length -= 64;
 		m->totalN += 64 << 3;
-		if (m->totalN < 64 << 3) {
+		if (m->totalN < 64 << 3)
 			m->totalN2++;
-		}
 	}
 
-	if (n) mdfour_tail(in, n);
+	if (length)
+		mdfour_tail(in, length);
 }
 
-
-void mdfour_result(struct mdfour *md, unsigned char *out)
+void mdfour_result(md_context *md, uchar digest[MD4_DIGEST_LEN])
 {
 	m = md;
 
-	copy4(out, m->A);
-	copy4(out+4, m->B);
-	copy4(out+8, m->C);
-	copy4(out+12, m->D);
+	copy4(digest, m->A);
+	copy4(digest+4, m->B);
+	copy4(digest+8, m->C);
+	copy4(digest+12, m->D);
 }
 
-
-void mdfour(unsigned char *out, unsigned char *in, int n)
+void mdfour(uchar digest[MD4_DIGEST_LEN], uchar *in, int length)
 {
-	struct mdfour md;
+	md_context md;
 	mdfour_begin(&md);
-	mdfour_update(&md, in, n);
-	mdfour_result(&md, out);
+	mdfour_update(&md, in, length);
+	mdfour_result(&md, digest);
 }
 
 #ifdef TEST_MDFOUR
 int protocol_version = 28;
 
 static void file_checksum1(char *fname)
 {
 	int fd, i, was_multiple_of_64 = 1;
-	struct mdfour md;
-	unsigned char buf[64*1024], sum[16];
+	md_context md;
+	uchar buf[64*1024], sum[MD4_DIGEST_LEN];
 	
 	fd = open(fname,O_RDONLY);
 	if (fd == -1) {
 		perror("fname");
 		exit(1);
 	}
 	
 	mdfour_begin(&md);
 
 	while (1) {
-		int n = read(fd, buf, sizeof(buf));
+		int n = read(fd, buf, sizeof buf);
 		if (n <= 0)
 			break;
 		was_multiple_of_64 = !(n % 64);
 		mdfour_update(&md, buf, n);
 	}
 	if (was_multiple_of_64 && protocol_version >= 27)
 		mdfour_update(&md, buf, 0);
 
 	close(fd);
 
 	mdfour_result(&md, sum);
 
-	for (i=0;i<16;i++)
-		printf("%02X", sum[i]);
-	printf("\n");
-}
-
-#if 0
-#include "../md4.h"
-
-static void file_checksum2(char *fname)
-{
-	int fd, i;
-	MDstruct md;
-	unsigned char buf[64], sum[16];
-
-	fd = open(fname,O_RDONLY);
-	if (fd == -1) {
-		perror("fname");
-		exit(1);
-	}
-	
-	MDbegin(&md);
-
-	while (1) {
-		int n = read(fd, buf, sizeof(buf));
-		if (n <= 0) break;
-		MDupdate(&md, buf, n*8);
-	}
-
-	if (!md.done) {
-		MDupdate(&md, buf, 0);
-	}
-
-	close(fd);
-
-	memcpy(sum, md.buffer, 16);
-
-	for (i=0;i<16;i++)
+	for (i = 0; i < MD4_DIGEST_LEN; i++)
 		printf("%02X", sum[i]);
 	printf("\n");
 }
-#endif
 
  int main(int argc, char *argv[])
 {
-	file_checksum1(argv[1]);
-#if 0
-	file_checksum2(argv[1]);
-#endif
+	while (--argc)
+		file_checksum1(*++argv);
 	return 0;
 }
 #endif
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib: mdfour.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib: mdigest.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/permstring.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/permstring.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/permstring.c	2006-10-14 07:17:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/permstring.c	2007-07-10 21:55:49.000000000 +0800
@@ -5,23 +5,22 @@
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001 Martin Pool <mbp@samba.org>
  * Copyright (C) 2003, 2006 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 /* Produce a string representation of Unix mode bits like that used by ls(1).
  * The "buf" buffer must be at least 11 characters. */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/pool_alloc.3 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/pool_alloc.3
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/pool_alloc.3	2004-02-10 11:26:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/pool_alloc.3	2007-05-29 12:19:41.000000000 +0800
@@ -25,59 +25,62 @@
 ..
 .de SeeIn
 See \fB\\$1\fP in \fB\\$2\fP for details.
 ..
 .TH POOL_ALLOC 3
 .SH NAME
-pool_alloc, pool_free, pool_talloc, pool_tfree, pool_create, pool_destroy
+pool_alloc, pool_free, pool_free_old, pool_talloc, pool_tfree, pool_create, pool_destroy, pool_boundary
 \- Allocate and free memory in managed allocation pools.
 .SH SYNOPSIS
 .B #include "pool_alloc.h"
 
 \fBstruct alloc_pool *pool_create(size_t \fIsize\fB, size_t \fIquantum\fB, void (*\fIbomb\fB)(char *), int \fIflags\fB);
 
 \fBvoid pool_destroy(struct alloc_pool *\fIpool\fB);
 
 \fBvoid *pool_alloc(struct alloc_pool *\fIpool\fB, size_t \fIsize\fB, char *\fImsg\fB);
 
-\fBvoid pool_free(struct alloc_pool *\fIpool\fB, sise_t \fIsize\fB, void *\fIaddr\fB);
+\fBvoid pool_free(struct alloc_pool *\fIpool\fB, size_t \fIsize\fB, void *\fIaddr\fB);
+
+\fBvoid pool_free_old(struct alloc_pool *\fIpool\fB, void *\fIaddr\fB);
 
 \fBvoid *pool_talloc(struct alloc_pool *\fIpool\fB, \fItype\fB), int \fIcount\fB, char *\fImsg\fB);
 
 \fBvoid pool_tfree(struct alloc_pool *\fIpool\fB, \fItype\fB, int \fIcount\fB, void *\fIaddr\fB);
+
+\fBvoid pool_boundary(struct alloc_pool *\fIpool\fB, sise_t \fIsize\fB);
 .SH DESCRIPTION
 .P
 The pool allocation routines use
 .B malloc()
 for underlying memory management.
-What allocation pools do is cause
-memory within a given pool to be in large contigious blocks
-(called extents) that when freed will be reusable.  Unlike
-.B malloc()
+What allocation pools do is cause memory within a given pool
+to be allocated in large contiguous blocks
+(called extents) that will be reusable when freed.  Unlike
+.BR malloc() ,
 the allocations are not managed individually.
-Instead each extent tracks the total free memory within the
+Instead, each extent tracks the total free memory within the
 extent.  Each extent can either be used to allocate memory
 or to manage the freeing of memory within that extent.
 When an extent has less free memory than a given
-allocation request or when the first request to free
-memory within that extent is received the extent ceases to
-be used for allocation.
+allocation request, the current extent ceases to be used
+for allocation.  See also the
+.B pool_boundary()
+function.
 .P
 This form of memory management is suited to large numbers of small
 related allocations that are held for a while
 and then freed as a group.
 Because the
-underlying allocations are done in large contigious extents
-when an extent is freed it releases a large enough
-contigious block of memory to be useful to subsequent
+underlying allocations are done in large contiguous extents,
+when an extent is freed, it can release a large enough
+contiguous block of memory to allow the memory to be returned
+to the OS for use by whatever program needs it.
+You can allocate from one or more memory pools and/or
 .B malloc()
-and
-.B pool_alloc()
-calls even if allocations from other pools or from
-.B malloc()
-are made between allocations from a given pool.
+all at the same time without interfering with how pools work.
 .P
 .B pool_create()
 Creates an allocation pool for subsequent calls to the pool
 allocation functions.
 When an extent is created for allocations it will be
 .I size 
@@ -87,109 +90,161 @@
 .I quantum
 bytes in length.
 Specifying
 .B 0
 for
 .I quantum
-Will produce a quantum that should meet maximal allignment
+will produce a quantum that should meet maximal alignment
 on most platforms.
-If the
+If
 .B POOL_QALIGN
-.I flag
-is set allocations will be aligned to addresses that are a
+is set in the
+.IR flags ,
+allocations will be aligned to addresses that are a
 multiple of
 .IR quantum .
-If the
+If
 .B POOL_CLEAR
-.I flag
-is set all allocations from the pool will be zero filled.
+is set in the
+.IR flags ,
+all allocations from the pool will be initialized to zeros.
+You may specify a
+.B NULL
+for the
+.I bomb
+function pointer if you don't wish to use it.  (See the
+.B pool_alloc()
+function for how it is used.)
 .P
 .B pool_destroy()
-destroys an allocation pool and frees all memory allocated
-in that pool.
+destroys an allocation
+.I pool
+and frees all its associated memory.
 .P
 .B pool_alloc()
 allocates
 .I size
 bytes from the specified
 .IR pool .
 If
 .I size
 is
-.B 0
+.BR 0 ,
 .I quantum
-bytes will be freed.
-If the requested memory cannot be allocated
-.B pool_alloc()
-will call
+bytes will be allocated.
+If the pool has been created with
+.BR POOL_QALIGN ,
+every chunk of memory that is returned will be suitably aligned.
+You can use this with the default
+.I quantum
+size to ensure that all memory can store a variable of any type.
+If the requested memory cannot be allocated, the
 .I bomb()
-function, if defined, with
+function will be called with
 .I msg
-as it's sole argument and
+as its sole argument (if the function was defined at the time
+the pool was created), and then a
 .B NULL
-will be returned.
+address is returned (assuming that the bomb function didn't exit).
 .P
 .B pool_free()
 frees
 .I size
-bytes pointed to by
+bytes pointed to by an
 .I addr
-previously allocated in the specified
+that was previously allocated in the specified
 .IR pool .
-The memory freed within an extent will not be reusable until
-all of the memory in that extent has been freed but 
-depending on the order in which the
-allocations are freed some extents may be released for reuse
-while others are still in use.
 If
 .I size
 is
-.B 0
+.BR 0 ,
 .I quantum
 bytes will be freed.
+The memory freed within an extent will not be reusable until
+all of the memory in that extent has been freed with one
+exception: the most recent pool allocation may be freed back
+into the pool prior to making any further allocations.
+If enough free calls are made to indicate that an extent has no
+remaining allocated objects (as computed by the total freed size for
+an extent), its memory will be completely freed back to the system.
 If
 .I addr
 is
-.B 0
-no memory will be freed but subsequent allocations will come
+.BR 0 ,
+no memory will be freed, but subsequent allocations will come
 from a new extent.
 .P
+.B pool_free_old()
+takes a boundary
+.I addr
+value that was returned by
+.B pool_boundary()
+and frees up any extents in the
+.I pool
+that have data allocated from that point backward in time.
+NOTE: you must NOT mix calls to both
+.B pool_free
+and
+.B pool_free_old
+on the same pool!
+.P
+.B pool_boundary()
+asks for a boundary value that can be sent to 
+.B pool_free_old()
+at a later time to free up all memory allocated prior to a particular
+moment in time.
+If the extent that holds the boundary point has allocations from after the
+boundary point, it will not be freed until a future
+.B pool_free_old()
+call encompasses the entirety of the extent's data.
+If
+.I len
+is non-zero, the call will also check if the active extent has at least
+that much free memory available in it, and if not, it will mark the
+extent as inactive, forcing a new extent to be used for future allocations.
+(You can specify -1 for
+.I len
+if you want to force a new extent to start.)
+.P
 .B pool_talloc()
-is a macro that take a
+is a macro that takes a
 .I type
-and
+and a
 .I count
-instead of
-.I size
-and will cast the return value to the correct type.
+instead of a
+.IR size .
+It casts the return value to the correct pointer type.
 .P
 .B pool_tfree
-is a macro to free memory previously allocated in the
-specified
-.IR pool .
+is a macro that calls
+.B pool_free
+on memory that was allocated by
+.BR pool_talloc() .
 .SH RETURN VALUE
 .B pool_create()
 returns a pointer to
 .BR "struct alloc_pool" .
 .P
 .B pool_alloc()
 and
 .B pool_talloc()
 return pointers to the allocated memory,
 or NULL if the request fails.
-For each extent so long as no allocations are smaller than varaible
-allignment requirements this pointer will be suitably
-alligned for any kind of variable.
 The return type of
 .B pool_alloc()
 will normally require casting to the desired type but
 .B pool_talloc()
 will returns a pointer of the requested
 .IR type .
 .P
+.B pool_boundary()
+returns a pointer that should only be used in a call to
+.BR pool_free_old() .
+.P
 .BR pool_free() ,
+.BR pool_free_old() ,
 .B pool_tfree()
 and
 .B pool_destroy()
 return no value.
 .SH SEE ALSO
 .nf
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/pool_alloc.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/pool_alloc.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/pool_alloc.c	2006-10-14 07:17:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/pool_alloc.c	2007-08-21 13:04:02.000000000 +0800
@@ -3,17 +3,14 @@
 #define POOL_DEF_EXTENT	(32 * 1024)
 
 struct alloc_pool
 {
 	size_t			size;		/* extent size		*/
 	size_t			quantum;	/* allocation quantum	*/
-	struct pool_extent	*live;		/* current extent for
-						 * allocations		*/
-	struct pool_extent	*free;		/* unfreed extent list	*/
-	void			(*bomb)();
-						/* function to call if
+	struct pool_extent	*extents;	/* top extent is "live" */
+	void			(*bomb)();	/* function to call if
 						 * malloc fails		*/
 	int			flags;
 
 	/* statistical data */
 	unsigned long		e_created;	/* extents created	*/
 	unsigned long		e_freed;	/* extents detroyed	*/
@@ -30,36 +27,35 @@
 	size_t			bound;		/* bytes bound by padding,
 						 * overhead and freed	*/
 	struct pool_extent	*next;
 };
 
 struct align_test {
-    void *foo;
-    int64 bar;
+	void *foo;
+	int64 bar;
 };
 
 #define MINALIGN	offsetof(struct align_test, bar)
 
 /* Temporarily cast a void* var into a char* var when adding an offset (to
  * keep some compilers from complaining about the pointer arithmetic). */
 #define PTR_ADD(b,o)	( (void*) ((char*)(b) + (o)) )
 
 alloc_pool_t
-pool_create(size_t size, size_t quantum,
-    void (*bomb)(char *), int flags)
+pool_create(size_t size, size_t quantum, void (*bomb)(const char *), int flags)
 {
 	struct alloc_pool	*pool;
 
-	if (!(pool = (struct alloc_pool*) malloc(sizeof (struct alloc_pool))))
+	if (!(pool = new(struct alloc_pool)))
 		return pool;
 	memset(pool, 0, sizeof (struct alloc_pool));
 
 	pool->size = size	/* round extent size to min alignment reqs */
 	    ? (size + MINALIGN - 1) & ~(MINALIGN - 1)
 	    : POOL_DEF_EXTENT;
-	if (pool->flags & POOL_INTERN) {
+	if (flags & POOL_INTERN) {
 		pool->size -= sizeof (struct pool_extent);
 		flags |= POOL_APPEND;
 	}
 	pool->quantum = quantum ? quantum : MINALIGN;
 	pool->bomb = bomb;
 	pool->flags = flags;
@@ -73,167 +69,232 @@
 	struct alloc_pool *pool = (struct alloc_pool *) p;
 	struct pool_extent	*cur, *next;
 
 	if (!pool)
 		return;
 
-	if (pool->live) {
-		cur = pool->live;
-		free(cur->start);
-		if (!(pool->flags & POOL_APPEND))
-			free(cur);
-	}
-	for (cur = pool->free; cur; cur = next) {
+	for (cur = pool->extents; cur; cur = next) {
 		next = cur->next;
 		free(cur->start);
 		if (!(pool->flags & POOL_APPEND))
 			free(cur);
 	}
 	free(pool);
 }
 
 void *
-pool_alloc(alloc_pool_t p, size_t len, char *bomb)
+pool_alloc(alloc_pool_t p, size_t len, const char *bomb_msg)
 {
 	struct alloc_pool *pool = (struct alloc_pool *) p;
 	if (!pool)
 		return NULL;
 
 	if (!len)
 		len = pool->quantum;
 	else if (pool->quantum > 1 && len % pool->quantum)
 		len += pool->quantum - len % pool->quantum;
 
 	if (len > pool->size)
-		goto bomb;
+		goto bomb_out;
 
-	if (!pool->live || len > pool->live->free) {
+	if (!pool->extents || len > pool->extents->free) {
 		void	*start;
 		size_t	free;
 		size_t	bound;
-		size_t	sqew;
+		size_t	skew;
 		size_t	asize;
-
-		if (pool->live) {
-			pool->live->next = pool->free;
-			pool->free = pool->live;
-		}
+		struct pool_extent *ext;
 
 		free = pool->size;
 		bound = 0;
 
 		asize = pool->size;
 		if (pool->flags & POOL_APPEND)
 			asize += sizeof (struct pool_extent);
 
-		if (!(start = (void *) malloc(asize)))
-			goto bomb;
+		if (!(start = new_array(char, asize)))
+			goto bomb_out;
 
 		if (pool->flags & POOL_CLEAR)
-			memset(start, 0, pool->size);
+			memset(start, 0, free);
 
 		if (pool->flags & POOL_APPEND)
-			pool->live = PTR_ADD(start, free);
-		else if (!(pool->live = (struct pool_extent *) malloc(sizeof (struct pool_extent))))
-			goto bomb;
+			ext = PTR_ADD(start, free);
+		else if (!(ext = new(struct pool_extent)))
+			goto bomb_out;
 		if (pool->flags & POOL_QALIGN && pool->quantum > 1
-		    && (sqew = (size_t)PTR_ADD(start, free) % pool->quantum)) {
-			bound  += sqew;
-			free -= sqew;
+		    && (skew = (size_t)PTR_ADD(start, free) % pool->quantum)) {
+			bound  += skew;
+			free -= skew;
 		}
-		pool->live->start = start;
-		pool->live->free = free;
-		pool->live->bound = bound;
-		pool->live->next = NULL;
+		ext->start = start;
+		ext->free = free;
+		ext->bound = bound;
+		ext->next = pool->extents;
+		pool->extents = ext;
 
 		pool->e_created++;
 	}
 
 	pool->n_allocated++;
 	pool->b_allocated += len;
 
-	pool->live->free -= len;
+	pool->extents->free -= len;
 
-	return PTR_ADD(pool->live->start, pool->live->free);
+	return PTR_ADD(pool->extents->start, pool->extents->free);
 
-bomb:
+  bomb_out:
 	if (pool->bomb)
-		(*pool->bomb)(bomb);
+		(*pool->bomb)(bomb_msg);
 	return NULL;
 }
 
+/* This function allows you to declare memory in the pool that you are done
+ * using.  If you free all the memory in a pool's extent, that extent will
+ * be freed. */
 void
 pool_free(alloc_pool_t p, size_t len, void *addr)
 {
-	struct alloc_pool *pool = (struct alloc_pool *) p;
-	struct pool_extent	*cur;
-	struct pool_extent	*prev;
+	struct alloc_pool *pool = (struct alloc_pool *)p;
+	struct pool_extent *cur, *prev;
 
 	if (!pool)
 		return;
 
 	if (!len)
 		len = pool->quantum;
 	else if (pool->quantum > 1 && len % pool->quantum)
 		len += pool->quantum - len % pool->quantum;
 
-	if (!addr && pool->live) {
-		pool->live->next = pool->free;
-		pool->free = pool->live;
-		pool->live = NULL;
-		return;
-	}
 	pool->n_freed++;
 	pool->b_freed += len;
 
-	cur = pool->live;
-	if (cur && addr >= cur->start
-	    && addr < PTR_ADD(cur->start, pool->size)) {
-		if (addr == PTR_ADD(cur->start, cur->free)) {
-			if (pool->flags & POOL_CLEAR)
-				memset(addr, 0, len);
-			pool->b_freed += len;
-		} else
-			cur->bound += len;
-		if (cur->free + cur->bound >= pool->size) {
-			size_t sqew;
+	for (prev = NULL, cur = pool->extents; cur; prev = cur, cur = cur->next) {
+		if (addr >= cur->start
+		    && addr < PTR_ADD(cur->start, pool->size))
+			break;
+	}
+	if (!cur)
+		return;
 
+	if (!prev) {
+		/* The "live" extent is kept ready for more allocations. */
+		if (cur->free + cur->bound + len >= pool->size) {
+			size_t skew;
+
+			if (pool->flags & POOL_CLEAR) {
+				memset(PTR_ADD(cur->start, cur->free), 0,
+				       pool->size - cur->free);
+			}
 			cur->free = pool->size;
 			cur->bound = 0;
 			if (pool->flags & POOL_QALIGN && pool->quantum > 1
-			    && (sqew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum)) {
-				cur->bound += sqew;
-				cur->free -= sqew;
+			    && (skew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum)) {
+				cur->bound += skew;
+				cur->free -= skew;
 			}
+		} else if (addr == PTR_ADD(cur->start, cur->free)) {
+			if (pool->flags & POOL_CLEAR)
+				memset(addr, 0, len);
+			cur->free += len;
+		} else
+			cur->bound += len;
+	} else {
+		cur->bound += len;
+
+		if (cur->free + cur->bound >= pool->size) {
+			prev->next = cur->next;
+			free(cur->start);
+			if (!(pool->flags & POOL_APPEND))
+				free(cur);
+			pool->e_freed++;
+		} else if (prev != pool->extents) {
+			/* Move the extent to be the first non-live extent. */
+			prev->next = cur->next;
+			cur->next = pool->extents->next;
+			pool->extents->next = cur;
 		}
-		return;
 	}
-	for (prev = NULL, cur = pool->free; cur; prev = cur, cur = cur->next) {
+}
+
+/* This allows you to declare that the given address marks the edge of some
+ * pool memory that is no longer needed.  Any extents that hold only data
+ * older than the boundary address are freed.  NOTE: You MUST NOT USE BOTH
+ * pool_free() and pool_free_old() on the same pool!! */
+void
+pool_free_old(alloc_pool_t p, void *addr)
+{
+	struct alloc_pool *pool = (struct alloc_pool *)p;
+	struct pool_extent *cur, *prev, *next;
+
+	if (!pool || !addr)
+		return;
+
+	for (prev = NULL, cur = pool->extents; cur; prev = cur, cur = cur->next) {
 		if (addr >= cur->start
 		    && addr < PTR_ADD(cur->start, pool->size))
 			break;
 	}
 	if (!cur)
 		return;
 
-	if (prev) {
-		prev->next = cur->next;
-		cur->next = pool->free;
-		pool->free = cur;
-	}
-	cur->bound += len;
+	if (addr == PTR_ADD(cur->start, cur->free)) {
+		if (prev) {
+			prev->next = NULL;
+			next = cur;
+		} else {
+			size_t skew;
 
-	if (cur->free + cur->bound >= pool->size) {
-		pool->free = cur->next;
+			/* The most recent live extent can just be reset. */
+			if (pool->flags & POOL_CLEAR)
+				memset(addr, 0, pool->size - cur->free);
+			cur->free = pool->size;
+			cur->bound = 0;
+			if (pool->flags & POOL_QALIGN && pool->quantum > 1
+			    && (skew = (size_t)PTR_ADD(cur->start, cur->free) % pool->quantum)) {
+				cur->bound += skew;
+				cur->free -= skew;
+			}
+			next = cur->next;
+			cur->next = NULL;
+		}
+	} else {
+		next = cur->next;
+		cur->next = NULL;
+	}
 
+	while ((cur = next) != NULL) {
+		next = cur->next;
 		free(cur->start);
 		if (!(pool->flags & POOL_APPEND))
 			free(cur);
 		pool->e_freed++;
 	}
-	return;
+}
+
+/* If the current extent doesn't have "len" free space in it, mark it as full
+ * so that the next alloc will start a new extent.  If len is (size_t)-1, this
+ * bump will always occur.  The function returns a boundary address that can
+ * be used with pool_free_old(), or a NULL if no memory is allocated. */
+void *
+pool_boundary(alloc_pool_t p, size_t len)
+{
+	struct alloc_pool *pool = (struct alloc_pool *)p;
+	struct pool_extent *cur;
+
+	if (!pool || !pool->extents)
+		return NULL;
+
+	cur = pool->extents;
+
+	if (cur->free < len) {
+		cur->bound += cur->free;
+		cur->free = 0;
+	}
+
+	return PTR_ADD(cur->start, cur->free);
 }
 
 #define FDPRINT(label, value) \
 	snprintf(buf, sizeof buf, label, value), \
 	write(fd, buf, strlen(buf))
 
@@ -256,25 +317,20 @@
 	FDPRINT("  Extent size:       %12ld\n",	(long)	pool->size);
 	FDPRINT("  Alloc quantum:     %12ld\n",	(long)	pool->quantum);
 	FDPRINT("  Extents created:   %12ld\n",		pool->e_created);
 	FDPRINT("  Extents freed:     %12ld\n",		pool->e_freed);
 	FDPRINT("  Alloc count:       %12.0f\n", (double) pool->n_allocated);
 	FDPRINT("  Free Count:        %12.0f\n", (double) pool->n_freed);
-	FDPRINT("  Alloc bytes:       %12.0f\n", (double) pool->b_allocated);
-	FDPRINT("  Free bytes:        %12.0f\n", (double) pool->b_freed);
+	FDPRINT("  Bytes allocated:   %12.0f\n", (double) pool->b_allocated);
+	FDPRINT("  Bytes freed:       %12.0f\n", (double) pool->b_freed);
 
 	if (summarize)
 		return;
 
-	if (!pool->live && !pool->free)
+	if (!pool->extents)
 		return;
 
 	write(fd, "\n", 1);
 
-	if (pool->live)
-		FDEXTSTAT(pool->live);
-	strlcpy(buf, "   FREE    BOUND\n", sizeof buf);
-	write(fd, buf, strlen(buf));
-
-	for (cur = pool->free; cur; cur = cur->next)
+	for (cur = pool->extents; cur; cur = cur->next)
 		FDEXTSTAT(cur);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/pool_alloc.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/pool_alloc.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/pool_alloc.h	2004-02-10 11:26:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/pool_alloc.h	2007-05-29 12:19:41.000000000 +0800
@@ -4,17 +4,18 @@
 #define POOL_QALIGN	(1<<1)		/* align data to quanta		*/
 #define POOL_INTERN	(1<<2)		/* Allocate extent structures	*/
 #define POOL_APPEND	(1<<3)		/*   or appended to extent data	*/
 
 typedef void *alloc_pool_t;
 
-alloc_pool_t pool_create(size_t size, size_t quantum, void (*bomb)(char *), int flags);
+alloc_pool_t pool_create(size_t size, size_t quantum, void (*bomb)(const char *), int flags);
 void pool_destroy(alloc_pool_t pool);
-void *pool_alloc(alloc_pool_t pool, size_t size, char *bomb);
+void *pool_alloc(alloc_pool_t pool, size_t size, const char *bomb_msg);
 void pool_free(alloc_pool_t pool, size_t size, void *addr);
+void pool_free_old(alloc_pool_t pool, void *addr);
+void *pool_boundary(alloc_pool_t pool, size_t size);
 
-#define pool_talloc(pool, type, count, bomb) \
-	((type *)pool_alloc(pool, sizeof(type) * count, bomb))
+#define pool_talloc(pool, type, count, bomb_msg) \
+	((type *)pool_alloc(pool, sizeof(type) * count, bomb_msg))
 
 #define pool_tfree(pool, type, count, addr) \
 	(pool_free(pool, sizeof(type) * count, addr))
-
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib: sysacls.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib: sysacls.h
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib: sysxattrs.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib: sysxattrs.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/wildmatch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/wildmatch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/lib/wildmatch.c	2006-01-03 01:46:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/lib/wildmatch.c	2007-05-22 13:58:59.000000000 +0800
@@ -162,13 +162,13 @@
 		    if (t_ch <= p_ch && t_ch >= prev_ch)
 			matched = TRUE;
 		    p_ch = 0; /* This makes "prev_ch" get set to 0. */
 		} else if (p_ch == '[' && p[1] == ':') {
 		    const uchar *s;
 		    int i;
-		    for (s = p += 2; (p_ch = *p) && p_ch != ']'; p++) {}
+		    for (s = p += 2; (p_ch = *p) && p_ch != ']'; p++) {} /*SHARED ITERATOR*/
 		    if (!p_ch)
 			return ABORT_ALL;
 		    i = p - s - 1;
 		    if (i < 0 || p[-1] != ':') {
 			/* Didn't find ":]", so treat like a normal set. */
 			p = s - 2;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/loadparm.c	2006-10-13 14:49:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/loadparm.c	2008-02-16 14:19:43.000000000 +0800
@@ -1,23 +1,22 @@
 /* This is based on loadparm.c from Samba, written by Andrew Tridgell
    and Karl Auer */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* some fixes
  *
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
  */
@@ -48,22 +47,26 @@
  *
  */
 
 /* TODO: Parameter to set debug level on server. */
 
 #include "rsync.h"
+#include "ifuncs.h"
 #define PTR_DIFF(p1,p2) ((ptrdiff_t)(((char *)(p1)) - (char *)(p2)))
 #define strequal(a,b) (strcasecmp(a,b)==0)
 #define BOOLSTR(b) ((b) ? "Yes" : "No")
 typedef char pstring[1024];
 #define pstrcpy(a,b) strlcpy(a,b,sizeof(pstring))
 
 #ifndef LOG_DAEMON
 #define LOG_DAEMON 0
 #endif
 
+#define DEFAULT_DONT_COMPRESS "*.gz *.zip *.z *.rpm *.deb *.iso *.bz2" \
+	" *.t[gb]z *.7z *.mp[34] *.mov *.avi *.ogg *.jpg *.jpeg"
+
 /* the following are used by loadparm for option lists */
 typedef enum
 {
 	P_BOOL,P_BOOLREV,P_CHAR,P_INTEGER,P_OCTAL,
 	P_PATH,P_STRING,P_GSTRING,P_ENUM,P_SEP
 } parm_type;
@@ -118,12 +121,13 @@
  * initializers below, which you can accomplish by keeping each sub-section
  * sorted.  (e.g. in vim, just visually select each subsection and use !sort.)
  */
 typedef struct
 {
 	char *auth_users;
+	char *charset;
 	char *comment;
 	char *dont_compress;
 	char *exclude;
 	char *exclude_from;
 	char *filter;
 	char *gid;
@@ -147,15 +151,18 @@
 
 	int max_connections;
 	int max_verbosity;
 	int syslog_facility;
 	int timeout;
 
+	BOOL fake_super;
 	BOOL ignore_errors;
 	BOOL ignore_nonreadable;
 	BOOL list;
+	BOOL munge_symlinks;
+	BOOL numeric_ids;
 	BOOL read_only;
 	BOOL strict_modes;
 	BOOL transfer_logging;
 	BOOL use_chroot;
 	BOOL write_only;
 } service;
@@ -165,14 +172,15 @@
  * to make these easy to keep sorted in the same way as the variables
  * above, use the variable name in the leading comment, including a
  * trailing ';' (to avoid a sorting problem with trailing digits). */
 static service sDefault =
 {
  /* auth_users; */		NULL,
+ /* charset; */ 		NULL,
  /* comment; */			NULL,
- /* dont_compress; */		"*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz",
+ /* dont_compress; */		DEFAULT_DONT_COMPRESS,
  /* exclude; */			NULL,
  /* exclude_from; */		NULL,
  /* filter; */			NULL,
  /* gid; */			NOBODY_GROUP,
  /* hosts_allow; */		NULL,
  /* hosts_deny; */		NULL,
@@ -194,15 +202,18 @@
 
  /* max_connections; */		0,
  /* max_verbosity; */		1,
  /* syslog_facility; */		LOG_DAEMON,
  /* timeout; */			0,
 
+ /* fake_super; */		False,
  /* ignore_errors; */		False,
  /* ignore_nonreadable; */	False,
  /* list; */			True,
+ /* munge_symlinks; */		(BOOL)-1,
+ /* numeric_ids; */		(BOOL)-1,
  /* read_only; */		True,
  /* strict_modes; */		True,
  /* transfer_logging; */	False,
  /* use_chroot; */		True,
  /* write_only; */		False,
 };
@@ -291,16 +302,18 @@
  {"motd file",         P_STRING, P_GLOBAL,&Globals.motd_file,          NULL,0},
  {"pid file",          P_STRING, P_GLOBAL,&Globals.pid_file,           NULL,0},
  {"port",              P_INTEGER,P_GLOBAL,&Globals.rsync_port,         NULL,0},
  {"socket options",    P_STRING, P_GLOBAL,&Globals.socket_options,     NULL,0},
 
  {"auth users",        P_STRING, P_LOCAL, &sDefault.auth_users,        NULL,0},
+ {"charset",           P_STRING, P_LOCAL, &sDefault.charset,           NULL,0},
  {"comment",           P_STRING, P_LOCAL, &sDefault.comment,           NULL,0},
  {"dont compress",     P_STRING, P_LOCAL, &sDefault.dont_compress,     NULL,0},
  {"exclude from",      P_STRING, P_LOCAL, &sDefault.exclude_from,      NULL,0},
  {"exclude",           P_STRING, P_LOCAL, &sDefault.exclude,           NULL,0},
+ {"fake super",        P_BOOL,   P_LOCAL, &sDefault.fake_super,        NULL,0},
  {"filter",            P_STRING, P_LOCAL, &sDefault.filter,            NULL,0},
  {"gid",               P_STRING, P_LOCAL, &sDefault.gid,               NULL,0},
  {"hosts allow",       P_STRING, P_LOCAL, &sDefault.hosts_allow,       NULL,0},
  {"hosts deny",        P_STRING, P_LOCAL, &sDefault.hosts_deny,        NULL,0},
  {"ignore errors",     P_BOOL,   P_LOCAL, &sDefault.ignore_errors,     NULL,0},
  {"ignore nonreadable",P_BOOL,   P_LOCAL, &sDefault.ignore_nonreadable,NULL,0},
@@ -310,13 +323,15 @@
  {"list",              P_BOOL,   P_LOCAL, &sDefault.list,              NULL,0},
  {"lock file",         P_STRING, P_LOCAL, &sDefault.lock_file,         NULL,0},
  {"log file",          P_STRING, P_LOCAL, &sDefault.log_file,          NULL,0},
  {"log format",        P_STRING, P_LOCAL, &sDefault.log_format,        NULL,0},
  {"max connections",   P_INTEGER,P_LOCAL, &sDefault.max_connections,   NULL,0},
  {"max verbosity",     P_INTEGER,P_LOCAL, &sDefault.max_verbosity,     NULL,0},
+ {"munge symlinks",    P_BOOL,   P_LOCAL, &sDefault.munge_symlinks,    NULL,0},
  {"name",              P_STRING, P_LOCAL, &sDefault.name,              NULL,0},
+ {"numeric ids",       P_BOOL,   P_LOCAL, &sDefault.numeric_ids,       NULL,0},
  {"outgoing chmod",    P_STRING, P_LOCAL, &sDefault.outgoing_chmod,    NULL,0},
  {"path",              P_PATH,   P_LOCAL, &sDefault.path,              NULL,0},
 #ifdef HAVE_PUTENV
  {"post-xfer exec",    P_STRING, P_LOCAL, &sDefault.postxfer_exec,     NULL,0},
  {"pre-xfer exec",     P_STRING, P_LOCAL, &sDefault.prexfer_exec,      NULL,0},
 #endif
@@ -380,12 +395,13 @@
 FN_GLOBAL_STRING(lp_pid_file, &Globals.pid_file)
 FN_GLOBAL_STRING(lp_socket_options, &Globals.socket_options)
 
 FN_GLOBAL_INTEGER(lp_rsync_port, &Globals.rsync_port)
 
 FN_LOCAL_STRING(lp_auth_users, auth_users)
+FN_LOCAL_STRING(lp_charset, charset)
 FN_LOCAL_STRING(lp_comment, comment)
 FN_LOCAL_STRING(lp_dont_compress, dont_compress)
 FN_LOCAL_STRING(lp_exclude, exclude)
 FN_LOCAL_STRING(lp_exclude_from, exclude_from)
 FN_LOCAL_STRING(lp_filter, filter)
 FN_LOCAL_STRING(lp_gid, gid)
@@ -401,23 +417,26 @@
 FN_LOCAL_STRING(lp_outgoing_chmod, outgoing_chmod)
 FN_LOCAL_STRING(lp_path, path)
 FN_LOCAL_STRING(lp_postxfer_exec, postxfer_exec)
 FN_LOCAL_STRING(lp_prexfer_exec, prexfer_exec)
 FN_LOCAL_STRING(lp_refuse_options, refuse_options)
 FN_LOCAL_STRING(lp_secrets_file, secrets_file)
-FN_LOCAL_INTEGER(lp_syslog_facility, syslog_facility)
 FN_LOCAL_STRING(lp_temp_dir, temp_dir)
 FN_LOCAL_STRING(lp_uid, uid)
 
 FN_LOCAL_INTEGER(lp_max_connections, max_connections)
 FN_LOCAL_INTEGER(lp_max_verbosity, max_verbosity)
+FN_LOCAL_INTEGER(lp_syslog_facility, syslog_facility)
 FN_LOCAL_INTEGER(lp_timeout, timeout)
 
+FN_LOCAL_BOOL(lp_fake_super, fake_super)
 FN_LOCAL_BOOL(lp_ignore_errors, ignore_errors)
 FN_LOCAL_BOOL(lp_ignore_nonreadable, ignore_nonreadable)
 FN_LOCAL_BOOL(lp_list, list)
+FN_LOCAL_BOOL(lp_munge_symlinks, munge_symlinks)
+FN_LOCAL_BOOL(lp_numeric_ids, numeric_ids)
 FN_LOCAL_BOOL(lp_read_only, read_only)
 FN_LOCAL_BOOL(lp_strict_modes, strict_modes)
 FN_LOCAL_BOOL(lp_transfer_logging, transfer_logging)
 FN_LOCAL_BOOL(lp_use_chroot, use_chroot)
 FN_LOCAL_BOOL(lp_write_only, write_only)
 
@@ -521,18 +540,17 @@
           if (psz2 == NULL)
               return (1);
 
    /* sync the strings on first non-whitespace */
    while (1)
    {
-      while (isspace(* (unsigned char *) psz1))
+      while (isSpace(psz1))
          psz1++;
-      while (isspace(* (unsigned char *) psz2))
+      while (isSpace(psz2))
          psz2++;
-      if (toupper(* (unsigned char *) psz1) != toupper(* (unsigned char *) psz2)
-	  || *psz1 == '\0' || *psz2 == '\0')
+      if (toUpper(psz1) != toUpper(psz2) || *psz1 == '\0' || *psz2 == '\0')
          break;
       psz1++;
       psz2++;
    }
    return (*psz1 - *psz2);
 }
@@ -549,13 +567,13 @@
      return(-1);
 
    for (iIndex = 0; parm_table[iIndex].label; iIndex++)
       if (strwicmp(parm_table[iIndex].label, parmname) == 0)
          return(iIndex);
 
-   rprintf(FERROR, "Unknown Parameter encountered: \"%s\"\n", parmname);
+   rprintf(FLOG, "Unknown Parameter encountered: \"%s\"\n", parmname);
    return(-1);
 }
 
 
 /***************************************************************************
 * Set a boolean variable from the text value stored in the passed string.
@@ -575,13 +593,13 @@
       if (strwicmp(parmvalue, "no") == 0 ||
           strwicmp(parmvalue, "False") == 0 ||
           strwicmp(parmvalue, "0") == 0)
          *pb = False;
       else
       {
-         rprintf(FERROR, "Badly formed boolean in configuration file: \"%s\".\n",
+         rprintf(FLOG, "Badly formed boolean in configuration file: \"%s\".\n",
                parmvalue);
          bRetval = False;
       }
    return (bRetval);
 }
 
@@ -662,24 +680,24 @@
    char *cp;
 
    parmnum = map_parameter(parmname);
 
    if (parmnum < 0)
      {
-       rprintf(FERROR, "IGNORING unknown parameter \"%s\"\n", parmname);
+       rprintf(FLOG, "IGNORING unknown parameter \"%s\"\n", parmname);
        return(True);
      }
 
    def_ptr = parm_table[parmnum].ptr;
 
    /* we might point at a service, the default service or a global */
    if (snum < 0) {
      parm_ptr = def_ptr;
    } else {
        if (parm_table[parmnum].class == P_GLOBAL) {
-	   rprintf(FERROR, "Global parameter %s found in service section!\n",parmname);
+	   rprintf(FLOG, "Global parameter %s found in service section!\n",parmname);
 	   return(True);
 	 }
        parm_ptr = ((char *)pSERVICE(snum)) + PTR_DIFF(def_ptr,&sDefault);
    }
 
    /* now switch on the type of variable it is */
@@ -771,12 +789,17 @@
    /* check for multiple global sections */
    if (bInGlobalSection)
    {
      return(True);
    }
 
+   if (strchr(sectionname, '/') != NULL) {
+     rprintf(FLOG, "Warning: invalid section name in configuration file: %s\n", sectionname);
+     return False;
+   }
+
    /* if we have a current service, tidy it up before moving on */
    bRetval = True;
 
    if (iServiceIndex >= 0)
      bRetval = True;
 
@@ -785,13 +808,13 @@
      {
        /* We put this here to avoid an odd message order if messages are */
        /* issued by the post-processing of a previous section. */
 
        if ((iServiceIndex=add_a_service(&sDefault,sectionname)) < 0)
 	 {
-	   rprintf(FERROR,"Failed to add a new service\n");
+	   rprintf(FLOG, "Failed to add a new service\n");
 	   return(False);
 	 }
      }
 
    return (bRetval);
 }
@@ -800,29 +823,22 @@
 /***************************************************************************
 * Load the services array from the services file. Return True on success,
 * False on failure.
 ***************************************************************************/
 BOOL lp_load(char *pszFname, int globals_only)
 {
-	extern int am_server;
-	extern int am_root;
 	pstring n2;
 	BOOL bRetval;
 
 	bRetval = False;
 
 	bInGlobalSection = True;
 
 	init_globals();
 
-	if (pszFname)
-	    pstrcpy(n2,pszFname);
-	else if (am_server && !am_root)
-	    pstrcpy(n2,RSYNCD_USERCONF);
-	else
-	    pstrcpy(n2,RSYNCD_SYSCONF);
+	pstrcpy(n2, pszFname);
 
 	/* We get sections first, so have to start 'behind' to make up */
 	iServiceIndex = -1;
 	bRetval = pm_process(n2, globals_only?NULL:do_section, do_parameter);
 
 	return (bRetval);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/log.c	2006-10-15 02:51:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/log.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,66 +1,71 @@
 /*
  * Logging and utility functions.
  *
  * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2000-2001 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
-#include <iconv.h>
-#endif
+#include "ifuncs.h"
 
 extern int verbose;
 extern int dry_run;
 extern int am_daemon;
 extern int am_server;
 extern int am_sender;
+extern int am_generator;
 extern int local_server;
 extern int quiet;
 extern int module_id;
 extern int msg_fd_out;
 extern int allow_8bit_chars;
 extern int protocol_version;
 extern int preserve_times;
+extern int uid_ndx;
+extern int gid_ndx;
 extern int stdout_format_has_i;
 extern int stdout_format_has_o_or_i;
 extern int logfile_format_has_i;
 extern int logfile_format_has_o_or_i;
+extern int receiver_symlink_times;
 extern mode_t orig_umask;
 extern char *auth_user;
 extern char *stdout_format;
 extern char *logfile_format;
 extern char *logfile_name;
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+#ifdef ICONV_CONST
 extern iconv_t ic_chck;
 #endif
+#ifdef ICONV_OPTION
+extern iconv_t ic_send, ic_recv;
+#endif
 extern char curr_dir[];
+extern char *module_dir;
 extern unsigned int module_dirlen;
 
 static int log_initialised;
 static int logfile_was_closed;
 static FILE *logfile_fp;
 struct stats stats;
 
-int log_got_error = 0;
+int got_xfer_error = 0;
 
 struct {
         int code;
         char const *name;
 } const rerr_names[] = {
 	{ RERR_SYNTAX     , "syntax or usage error" },
@@ -79,12 +84,13 @@
 	{ RERR_SIGNAL     , "received SIGINT, SIGTERM, or SIGHUP" },
 	{ RERR_WAITCHILD  , "waitpid() failed" },
 	{ RERR_MALLOC     , "error allocating core memory buffers" },
 	{ RERR_PARTIAL    , "some files could not be transferred" },
 	{ RERR_VANISHED   , "some files vanished before they could be transferred" },
 	{ RERR_TIMEOUT    , "timeout in data send/receive" },
+	{ RERR_CONTIMEOUT , "timeout waiting for daemon connection" },
 	{ RERR_CMD_FAILED , "remote shell failed" },
 	{ RERR_CMD_KILLED , "remote shell killed" },
 	{ RERR_CMD_RUN    , "remote command could not be run" },
 	{ RERR_CMD_NOTFOUND,"remote command not found" },
 	{ RERR_DEL_LIMIT  , "the --max-delete limit stopped deletions" },
 	{ 0, NULL }
@@ -100,13 +106,13 @@
 		if (rerr_names[i].code == code)
 			return rerr_names[i].name;
 	}
 	return NULL;
 }
 
-static void logit(int priority, char *buf)
+static void logit(int priority, const char *buf)
 {
 	if (logfile_was_closed)
 		logfile_reopen();
 	if (logfile_fp) {
 		fprintf(logfile_fp, "%s [%d] %s",
 			timestring(time(NULL)), (int)getpid(), buf);
@@ -211,54 +217,62 @@
 static void filtered_fwrite(FILE *f, const char *buf, int len, int use_isprint)
 {
 	const char *s, *end = buf + len;
 	for (s = buf; s < end; s++) {
 		if ((s < end - 4
 		  && *s == '\\' && s[1] == '#'
-		  && isdigit(*(uchar*)(s+2))
-		  && isdigit(*(uchar*)(s+3))
-		  && isdigit(*(uchar*)(s+4)))
+		  && isDigit(s + 2)
+		  && isDigit(s + 3)
+		  && isDigit(s + 4))
 		 || (*s != '\t'
-		  && ((use_isprint && !isprint(*(uchar*)s))
+		  && ((use_isprint && !isPrint(s))
 		   || *(uchar*)s < ' '))) {
 			if (s != buf && fwrite(buf, s - buf, 1, f) != 1)
 				exit_cleanup(RERR_MESSAGEIO);
 			fprintf(f, "\\#%03o", *(uchar*)s);
 			buf = s + 1;
 		}
 	}
 	if (buf != end && fwrite(buf, end - buf, 1, f) != 1)
 		exit_cleanup(RERR_MESSAGEIO);
 }
 
 /* this is the underlying (unformatted) rsync debugging function. Call
- * it with FINFO, FERROR or FLOG.  Note: recursion can happen with
- * certain fatal conditions. */
-void rwrite(enum logcode code, char *buf, int len)
+ * it with FINFO, FERROR_*, FWARNING, FLOG, or FCLIENT.  Note: recursion
+ * can happen with certain fatal conditions. */
+void rwrite(enum logcode code, const char *buf, int len, int is_utf8)
 {
 	int trailing_CR_or_NL;
 	FILE *f = NULL;
+#ifdef ICONV_OPTION
+	iconv_t ic = is_utf8 && ic_recv != (iconv_t)-1 ? ic_recv : ic_chck;
+#else
+#ifdef ICONV_CONST
+	iconv_t ic = ic_chck;
+#endif
+#endif
 
 	if (len < 0)
 		exit_cleanup(RERR_MESSAGEIO);
 
 	if (am_server && msg_fd_out >= 0) {
+		assert(!is_utf8);
 		/* Pass the message to our sibling. */
-		send_msg((enum msgcode)code, buf, len);
+		send_msg((enum msgcode)code, buf, len, 0);
 		return;
 	}
 
-	if (code == FSOCKERR) /* This gets simplified for a non-sibling. */
+	if (code == FERROR_SOCKET) /* This gets simplified for a non-sibling. */
 		code = FERROR;
 
 	if (code == FCLIENT)
 		code = FINFO;
 	else if (am_daemon || logfile_name) {
 		static int in_block;
 		char msg[2048];
-		int priority = code == FERROR ? LOG_WARNING : LOG_INFO;
+		int priority = code == FINFO || code == FLOG ? LOG_INFO :  LOG_WARNING;
 
 		if (in_block)
 			return;
 		in_block = 1;
 		if (!log_initialised)
 			log_init(0);
@@ -268,73 +282,83 @@
 
 		if (code == FLOG || (am_daemon && !am_server))
 			return;
 	} else if (code == FLOG)
 		return;
 
-	if (quiet && code != FERROR)
+	if (quiet && code == FINFO)
 		return;
 
 	if (am_server) {
+		enum msgcode msg = (enum msgcode)code;
+		if (protocol_version < 30) {
+			if (msg == MSG_ERROR)
+				msg = MSG_ERROR_XFER;
+			else if (msg == MSG_WARNING)
+				msg = MSG_INFO;
+		}
 		/* Pass the message to the non-server side. */
-		if (send_msg((enum msgcode)code, buf, len))
+		if (send_msg(msg, buf, len, !is_utf8))
 			return;
 		if (am_daemon) {
 			/* TODO: can we send the error to the user somehow? */
 			return;
 		}
 	}
 
 	switch (code) {
+	case FERROR_XFER:
+		got_xfer_error = 1;
+		/* FALL THROUGH */
 	case FERROR:
-		log_got_error = 1;
+	case FWARNING:
 		f = stderr;
 		break;
 	case FINFO:
 		f = am_server ? stderr : stdout;
 		break;
 	default:
 		exit_cleanup(RERR_MESSAGEIO);
 	}
 
 	trailing_CR_or_NL = len && (buf[len-1] == '\n' || buf[len-1] == '\r')
 			  ? buf[--len] : 0;
 
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
-	if (ic_chck != (iconv_t)-1) {
+#ifdef ICONV_CONST
+	if (ic != (iconv_t)-1) {
+		xbuf outbuf, inbuf;
 		char convbuf[1024];
-		char *in_buf = buf, *out_buf = convbuf;
-		size_t in_cnt = len, out_cnt = sizeof convbuf - 1;
+		int ierrno;
+
+		INIT_CONST_XBUF(outbuf, convbuf);
+		INIT_XBUF(inbuf, (char*)buf, len, -1);
 
-		iconv(ic_chck, NULL, 0, NULL, 0);
-		while (iconv(ic_chck, &in_buf,&in_cnt,
-				 &out_buf,&out_cnt) == (size_t)-1) {
-			if (out_buf != convbuf) {
-				filtered_fwrite(f, convbuf, out_buf - convbuf, 0);
-				out_buf = convbuf;
-				out_cnt = sizeof convbuf - 1;
+		while (inbuf.len) {
+			iconvbufs(ic, &inbuf, &outbuf, 0);
+			ierrno = errno;
+			if (outbuf.len) {
+				filtered_fwrite(f, convbuf, outbuf.len, 0);
+				outbuf.len = 0;
 			}
-			if (errno == E2BIG)
+			if (!ierrno || ierrno == E2BIG)
 				continue;
-			fprintf(f, "\\#%03o", *(uchar*)in_buf++);
-			in_cnt--;
+			fprintf(f, "\\#%03o", CVAL(inbuf.buf, inbuf.pos++));
+			inbuf.len--;
 		}
-		if (out_buf != convbuf)
-			filtered_fwrite(f, convbuf, out_buf - convbuf, 0);
 	} else
 #endif
 		filtered_fwrite(f, buf, len, !allow_8bit_chars);
 
 	if (trailing_CR_or_NL) {
 		fputc(trailing_CR_or_NL, f);
 		fflush(f);
 	}
 }
 
-/* This is the rsync debugging function. Call it with FINFO, FERROR or
- * FLOG. */
+/* This is the rsync debugging function. Call it with FINFO, FERROR_*,
+ * FWARNING, FLOG, or FCLIENT. */
 void rprintf(enum logcode code, const char *format, ...)
 {
 	va_list ap;
 	char buf[BIGPATHBUFLEN];
 	size_t len;
 
@@ -365,13 +389,13 @@
 		memcpy(buf+len-sizeof ellipsis, ellipsis, sizeof ellipsis);
 		if (format[strlen(format)-1] == '\n') {
 			buf[len-1] = '\n';
 		}
 	}
 
-	rwrite(code, buf, len);
+	rwrite(code, buf, len, 0);
 }
 
 /* This is like rprintf, but it also tries to print some
  * representation of the error code.  Normally errcode = errno.
  *
  * Unlike rprintf, this always adds a newline and there should not be
@@ -396,37 +420,39 @@
 		len += snprintf(buf + len, sizeof buf - len,
 				": %s (%d)\n", strerror(errcode), errcode);
 	}
 	if (len >= sizeof buf)
 		exit_cleanup(RERR_MESSAGEIO);
 
-	rwrite(code, buf, len);
+	rwrite(code, buf, len, 0);
 }
 
 void rflush(enum logcode code)
 {
 	FILE *f = NULL;
 
 	if (am_daemon || code == FLOG)
 		return;
 
-	if (code == FERROR || am_server)
-		f = stderr;
-	else
+	if (code == FINFO && !am_server)
 		f = stdout;
+	else
+		f = stderr;
 
 	fflush(f);
 }
 
 /* A generic logging routine for send/recv, with parameter substitiution. */
-static void log_formatted(enum logcode code, char *format, char *op,
-			  struct file_struct *file, struct stats *initial_stats,
-			  int iflags, char *hlink)
+static void log_formatted(enum logcode code, const char *format, const char *op,
+			  struct file_struct *file, const char *fname,
+			  struct stats *initial_stats, int iflags,
+			  const char *hlink)
 {
 	char buf[MAXPATHLEN+1024], buf2[MAXPATHLEN], fmt[32];
-	char *p, *s, *n;
+	char *p, *s, *c;
+	const char *n;
 	size_t len, total;
 	int64 b;
 
 	*fmt = '%';
 
 	/* We expand % codes one by one in place in buf.  We don't
@@ -439,20 +465,20 @@
 	}
 	buf[total++] = '\n';
 	buf[total] = '\0';
 
 	for (p = buf; (p = strchr(p, '%')) != NULL; ) {
 		s = p++;
-		n = fmt + 1;
+		c = fmt + 1;
 		if (*p == '-')
-			*n++ = *p++;
-		while (isdigit(*(uchar*)p) && n - fmt < (int)(sizeof fmt) - 8)
-			*n++ = *p++;
+			*c++ = *p++;
+		while (isDigit(p) && c - fmt < (int)(sizeof fmt) - 8)
+			*c++ = *p++;
 		if (!*p)
 			break;
-		*n = '\0';
+		*c = '\0';
 		n = NULL;
 
 		switch (*p) {
 		case 'h':
 			if (am_daemon)
 				n = client_name(0);
@@ -461,86 +487,97 @@
 			if (am_daemon)
 				n = client_addr(0);
 			break;
 		case 'l':
 			strlcat(fmt, ".0f", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
-				 (double)file->length);
+				 (double)F_LENGTH(file));
 			n = buf2;
 			break;
 		case 'U':
-			strlcat(fmt, "ld", sizeof fmt);
+			strlcat(fmt, "u", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
-				 (long)file->uid);
+				 uid_ndx ? F_OWNER(file) : 0);
 			n = buf2;
 			break;
 		case 'G':
-			if (file->gid == GID_NONE)
+			if (!gid_ndx || file->flags & FLAG_SKIP_GROUP)
 				n = "DEFAULT";
 			else {
-				strlcat(fmt, "ld", sizeof fmt);
+				strlcat(fmt, "u", sizeof fmt);
 				snprintf(buf2, sizeof buf2, fmt,
-					 (long)file->gid);
+					 F_GROUP(file));
 				n = buf2;
 			}
 			break;
 		case 'p':
 			strlcat(fmt, "ld", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt,
 				 (long)getpid());
 			n = buf2;
 			break;
 		case 'M':
-			n = timestring(file->modtime);
-			{
-				char *cp = n;
-				while ((cp = strchr(cp, ' ')) != NULL)
-					*cp = '-';
-			}
+			n = c = timestring(file->modtime);
+			while ((c = strchr(p, ' ')) != NULL)
+				*c = '-';
 			break;
 		case 'B':
-			n = buf2 + MAXPATHLEN - PERMSTRING_SIZE;
-			permstring(n - 1, file->mode); /* skip the type char */
+			c = buf2 + MAXPATHLEN - PERMSTRING_SIZE - 1;
+			permstring(c, file->mode);
+			n = c + 1; /* skip the type char */
 			break;
 		case 'o':
 			n = op;
 			break;
 		case 'f':
-			n = f_name(file, NULL);
-			if (am_sender && file->dir.root) {
+			if (fname) {
+				c = f_name_buf();
+				strlcpy(c, fname, MAXPATHLEN);
+			} else
+				c = f_name(file, NULL);
+			if (am_sender && F_PATHNAME(file)) {
 				pathjoin(buf2, sizeof buf2,
-					 file->dir.root, n);
+					 F_PATHNAME(file), c);
 				clean_fname(buf2, 0);
-				if (fmt[1])
-					strlcpy(n, buf2, MAXPATHLEN);
-				else
+				if (fmt[1]) {
+					strlcpy(c, buf2, MAXPATHLEN);
+					n = c;
+				} else
 					n = buf2;
-			} else if (*n != '/') {
+			} else if (am_daemon && *c != '/') {
 				pathjoin(buf2, sizeof buf2,
-					 curr_dir + module_dirlen, n);
+					 curr_dir + module_dirlen, c);
 				clean_fname(buf2, 0);
-				if (fmt[1])
-					strlcpy(n, buf2, MAXPATHLEN);
-				else
+				if (fmt[1]) {
+					strlcpy(c, buf2, MAXPATHLEN);
+					n = c;
+				} else
 					n = buf2;
-			} else
-				clean_fname(n, 0);
+			} else {
+				clean_fname(c, 0);
+				n = c;
+			}
 			if (*n == '/')
 				n++;
 			break;
 		case 'n':
-			n = f_name(file, NULL);
+			if (fname) {
+				c = f_name_buf();
+				strlcpy(c, fname, MAXPATHLEN);
+			} else
+				c = f_name(file, NULL);
 			if (S_ISDIR(file->mode))
-				strlcat(n, "/", MAXPATHLEN);
+				strlcat(c, "/", MAXPATHLEN);
+			n = c;
 			break;
 		case 'L':
 			if (hlink && *hlink) {
 				n = hlink;
 				strlcpy(buf2, " => ", sizeof buf2);
-			} else if (S_ISLNK(file->mode) && file->u.link) {
-				n = file->u.link;
+			} else if (S_ISLNK(file->mode) && !fname) {
+				n = F_SYMLINK(file);
 				strlcpy(buf2, " -> ", sizeof buf2);
 			} else {
 				n = "";
 				if (!fmt[1])
 					break;
 				strlcpy(buf2, "    ", sizeof buf2);
@@ -553,13 +590,13 @@
 			n = lp_name(module_id);
 			break;
 		case 't':
 			n = timestring(time(NULL));
 			break;
 		case 'P':
-			n = lp_path(module_id);
+			n = module_dir;
 			break;
 		case 'u':
 			n = auth_user;
 			break;
 		case 'b':
 			if (am_sender) {
@@ -584,49 +621,51 @@
 			strlcat(fmt, ".0f", sizeof fmt);
 			snprintf(buf2, sizeof buf2, fmt, (double)b);
 			n = buf2;
 			break;
 		case 'i':
 			if (iflags & ITEM_DELETED) {
-				n = "*deleting";
+				n = "*deleting  ";
 				break;
 			}
-			n = buf2 + MAXPATHLEN - 32;
-			n[0] = iflags & ITEM_LOCAL_CHANGE
+			n  = c = buf2 + MAXPATHLEN - 32;
+			c[0] = iflags & ITEM_LOCAL_CHANGE
 			      ? iflags & ITEM_XNAME_FOLLOWS ? 'h' : 'c'
 			     : !(iflags & ITEM_TRANSFER) ? '.'
 			     : !local_server && *op == 's' ? '<' : '>';
-			n[1] = S_ISDIR(file->mode) ? 'd'
+			c[1] = S_ISDIR(file->mode) ? 'd'
 			     : IS_SPECIAL(file->mode) ? 'S'
 			     : IS_DEVICE(file->mode) ? 'D'
 			     : S_ISLNK(file->mode) ? 'L' : 'f';
-			n[2] = !(iflags & ITEM_REPORT_CHECKSUM) ? '.' : 'c';
-			n[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';
-			n[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
-			     : !preserve_times || S_ISLNK(file->mode) ? 'T' : 't';
-			n[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
-			n[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
-			n[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
-			n[8] = '.';
-			n[9] = '\0';
+			c[2] = !(iflags & ITEM_REPORT_CHECKSUM) ? '.' : 'c';
+			c[3] = !(iflags & ITEM_REPORT_SIZE) ? '.' : 's';
+			c[4] = !(iflags & ITEM_REPORT_TIME) ? '.'
+			     : !preserve_times || (!receiver_symlink_times && S_ISLNK(file->mode))
+			     ? 'T' : 't';
+			c[5] = !(iflags & ITEM_REPORT_PERMS) ? '.' : 'p';
+			c[6] = !(iflags & ITEM_REPORT_OWNER) ? '.' : 'o';
+			c[7] = !(iflags & ITEM_REPORT_GROUP) ? '.' : 'g';
+			c[8] = !(iflags & ITEM_REPORT_ATIME) ? '.' : 'u';
+			c[9] = !(iflags & ITEM_REPORT_ACL) ? '.' : 'a';
+			c[10] = !(iflags & ITEM_REPORT_XATTR) ? '.' : 'x';
+			c[11] = '\0';
 
 			if (iflags & (ITEM_IS_NEW|ITEM_MISSING_DATA)) {
 				char ch = iflags & ITEM_IS_NEW ? '+' : '?';
 				int i;
-				for (i = 2; n[i]; i++)
-					n[i] = ch;
-			} else if (n[0] == '.' || n[0] == 'h'
-			        || (n[0] == 'c' && n[1] == 'f')) {
+				for (i = 2; c[i]; i++)
+					c[i] = ch;
+			} else if (c[0] == '.' || c[0] == 'h' || c[0] == 'c') {
 				int i;
-				for (i = 2; n[i]; i++) {
-					if (n[i] != '.')
+				for (i = 2; c[i]; i++) {
+					if (c[i] != '.')
 						break;
 				}
-				if (!n[i]) {
-					for (i = 2; n[i]; i++)
-						n[i] = ' ';
+				if (!c[i]) {
+					for (i = 2; c[i]; i++)
+						c[i] = ' ';
 				}
 			}
 			break;
 		}
 
 		/* "n" is the string to be inserted in place of this % code. */
@@ -659,13 +698,13 @@
 			memcpy(s, n, len);
 
 		/* Skip over inserted string; continue looking */
 		p = s + len;
 	}
 
-	rwrite(code, buf, total);
+	rwrite(code, buf, total, 0);
 }
 
 /* Return 1 if the format escape is in the log-format string (e.g. look for
  * the 'b' in the "%9b" format escape). */
 int log_format_has(const char *format, char esc)
 {
@@ -674,13 +713,13 @@
 	if (!format)
 		return 0;
 
 	for (p = format; (p = strchr(p, '%')) != NULL; ) {
 		if (*++p == '-')
 			p++;
-		while (isdigit(*(uchar*)p))
+		while (isDigit(p))
 			p++;
 		if (!*p)
 			break;
 		if (*p == esc)
 			return 1;
 	}
@@ -688,28 +727,28 @@
 }
 
 /* Log the transfer of a file.  If the code is FCLIENT, the output just goes
  * to stdout.  If it is FLOG, it just goes to the log file.  Otherwise we
  * output to both. */
 void log_item(enum logcode code, struct file_struct *file,
-	      struct stats *initial_stats, int iflags, char *hlink)
+	      struct stats *initial_stats, int iflags, const char *hlink)
 {
-	char *s_or_r = am_sender ? "send" : "recv";
+	const char *s_or_r = am_sender ? "send" : "recv";
 
 	if (code != FLOG && stdout_format && !am_server) {
 		log_formatted(FCLIENT, stdout_format, s_or_r,
-			      file, initial_stats, iflags, hlink);
+			      file, NULL, initial_stats, iflags, hlink);
 	}
 	if (code != FCLIENT && logfile_format && *logfile_format) {
 		log_formatted(FLOG, logfile_format, s_or_r,
-			      file, initial_stats, iflags, hlink);
+			      file, NULL, initial_stats, iflags, hlink);
 	}
 }
 
 void maybe_log_item(struct file_struct *file, int iflags, int itemizing,
-		    char *buf)
+		    const char *buf)
 {
 	int significant_flags = iflags & SIGNIFICANT_ITEM_FLAGS;
 	int see_item = itemizing && (significant_flags || *buf
 		|| stdout_format_has_i > 1 || (verbose > 1 && stdout_format_has_i));
 	int local_change = iflags & ITEM_LOCAL_CHANGE && significant_flags;
 	if (am_server) {
@@ -720,38 +759,40 @@
 	    || (S_ISDIR(file->mode) && significant_flags)) {
 		enum logcode code = significant_flags || logfile_format_has_i ? FINFO : FCLIENT;
 		log_item(code, file, &stats, iflags, buf);
 	}
 }
 
-void log_delete(char *fname, int mode)
+void log_delete(const char *fname, int mode)
 {
-	static struct file_struct file;
+	static struct {
+		union file_extras ex[4]; /* just in case... */
+		struct file_struct file;
+	} x;
 	int len = strlen(fname);
-	char *fmt;
+	const char *fmt;
 
-	file.mode = mode;
-	file.basename = fname;
+	x.file.mode = mode;
 
 	if (!verbose && !stdout_format)
 		;
 	else if (am_server && protocol_version >= 29 && len < MAXPATHLEN) {
 		if (S_ISDIR(mode))
 			len++; /* directories include trailing null */
-		send_msg(MSG_DELETED, fname, len);
+		send_msg(MSG_DELETED, fname, len, am_generator);
 	} else {
 		fmt = stdout_format_has_o_or_i ? stdout_format : "deleting %n";
-		log_formatted(FCLIENT, fmt, "del.", &file, &stats,
+		log_formatted(FCLIENT, fmt, "del.", &x.file, fname, &stats,
 			      ITEM_DELETED, NULL);
 	}
 
 	if (!logfile_name || dry_run || !logfile_format)
 		return;
 
 	fmt = logfile_format_has_o_or_i ? logfile_format : "deleting %n";
-	log_formatted(FLOG, fmt, "del.", &file, &stats, ITEM_DELETED, NULL);
+	log_formatted(FLOG, fmt, "del.", &x.file, fname, &stats, ITEM_DELETED, NULL);
 }
 
 /*
  * Called when the transfer is interrupted for some reason.
  *
  * Code is one of the RERR_* codes from errcode.h, or terminating
@@ -761,22 +802,22 @@
 {
 	if (code == 0) {
 		rprintf(FLOG,"sent %.0f bytes  received %.0f bytes  total size %.0f\n",
 			(double)stats.total_written,
 			(double)stats.total_read,
 			(double)stats.total_size);
-	} else {
+	} else if (am_server != 2) {
 		const char *name;
 
 		name = rerr_name(code);
 		if (!name)
 			name = "unexplained error";
 
 		/* VANISHED is not an error, only a warning */
 		if (code == RERR_VANISHED) {
-			rprintf(FINFO, "rsync warning: %s (code %d) at %s(%d) [%s=%s]\n",
+			rprintf(FWARNING, "rsync warning: %s (code %d) at %s(%d) [%s=%s]\n",
 				name, code, file, line, who_am_i(), RSYNC_VERSION);
 		} else {
 			rprintf(FERROR, "rsync error: %s (code %d) at %s(%d) [%s=%s]\n",
 				name, code, file, line, who_am_i(), RSYNC_VERSION);
 		}
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/main.c	2006-10-14 07:46:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/main.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,83 +1,96 @@
 /*
  * The startup routines, including main(), for rsync.
  *
  * Copyright (C) 1996-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
+#include "io.h"
 #if defined CONFIG_LOCALE && defined HAVE_LOCALE_H
 #include <locale.h>
 #endif
 
 extern int verbose;
 extern int dry_run;
 extern int list_only;
 extern int am_root;
 extern int am_server;
 extern int am_sender;
 extern int am_generator;
 extern int am_daemon;
+extern int inc_recurse;
 extern int blocking_io;
 extern int remove_source_files;
-extern int daemon_over_rsh;
 extern int need_messages_from_generator;
 extern int kluge_around_eof;
 extern int do_stats;
-extern int log_got_error;
+extern int got_xfer_error;
 extern int module_id;
 extern int copy_links;
 extern int copy_dirlinks;
+extern int copy_unsafe_links;
 extern int keep_dirlinks;
 extern int preserve_hard_links;
 extern int protocol_version;
+extern int file_total;
 extern int recurse;
+extern int xfer_dirs;
+extern int protect_args;
 extern int relative_paths;
 extern int sanitize_paths;
 extern int curr_dir_depth;
 extern int curr_dir_len;
 extern int module_id;
 extern int rsync_port;
 extern int whole_file;
 extern int read_batch;
 extern int write_batch;
 extern int batch_fd;
-extern int batch_gen_fd;
 extern int filesfrom_fd;
+extern int connect_timeout;
 extern pid_t cleanup_child_pid;
+extern unsigned int module_dirlen;
 extern struct stats stats;
 extern char *filesfrom_host;
 extern char *partial_dir;
+extern char *dest_option;
 extern char *basis_dir[];
 extern char *rsync_path;
 extern char *shell_cmd;
 extern char *batch_name;
+extern char *password_file;
 extern char curr_dir[MAXPATHLEN];
+extern struct file_list *first_flist;
 extern struct filter_list_struct server_filter_list;
+#ifdef ICONV_OPTION
+extern iconv_t ic_send;
+#endif
 
+uid_t our_uid;
 int local_server = 0;
-int new_root_dir = 0;
+int daemon_over_rsh = 0;
 mode_t orig_umask = 0;
-struct file_list *the_file_list;
+int batch_gen_fd = -1;
 
 /* There's probably never more than at most 2 outstanding child processes,
  * but set it higher, just in case. */
 #define MAXCHILDPROCS 7
 
 #ifdef HAVE_SIGACTION
@@ -100,13 +113,17 @@
 static void show_malloc_stats(void);
 
 /* Works like waitpid(), but if we already harvested the child pid in our
  * remember_children(), we succeed instead of returning an error. */
 pid_t wait_process(pid_t pid, int *status_ptr, int flags)
 {
-	pid_t waited_pid = waitpid(pid, status_ptr, flags);
+	pid_t waited_pid;
+	
+	do {
+		waited_pid = waitpid(pid, status_ptr, flags);
+	} while (waited_pid == -1 && errno == EINTR);
 
 	if (waited_pid == -1 && errno == ECHILD) {
 		/* Status of requested child no longer available:  check to
 		 * see if it was processed by remember_children(). */
 		int cnt;
 		for (cnt = 0; cnt < MAXCHILDPROCS; cnt++) {
@@ -182,46 +199,46 @@
 		if (f == -1 || !am_sender)
 			return;
 	}
 
 	if (am_server) {
 		if (am_sender) {
-			write_longint(f, total_read);
-			write_longint(f, total_written);
-			write_longint(f, stats.total_size);
+			write_varlong30(f, total_read, 3);
+			write_varlong30(f, total_written, 3);
+			write_varlong30(f, stats.total_size, 3);
 			if (protocol_version >= 29) {
-				write_longint(f, stats.flist_buildtime);
-				write_longint(f, stats.flist_xfertime);
+				write_varlong30(f, stats.flist_buildtime, 3);
+				write_varlong30(f, stats.flist_xfertime, 3);
 			}
 		}
 		return;
 	}
 
 	/* this is the client */
 
 	if (f < 0 && !am_sender) /* e.g. when we got an empty file list. */
 		;
 	else if (!am_sender) {
 		/* Read the first two in opposite order because the meaning of
 		 * read/write swaps when switching from sender to receiver. */
-		total_written = read_longint(f);
-		total_read = read_longint(f);
-		stats.total_size = read_longint(f);
+		total_written = read_varlong30(f, 3);
+		total_read = read_varlong30(f, 3);
+		stats.total_size = read_varlong30(f, 3);
 		if (protocol_version >= 29) {
-			stats.flist_buildtime = read_longint(f);
-			stats.flist_xfertime = read_longint(f);
+			stats.flist_buildtime = read_varlong30(f, 3);
+			stats.flist_xfertime = read_varlong30(f, 3);
 		}
 	} else if (write_batch) {
 		/* The --read-batch process is going to be a client
 		 * receiver, so we need to give it the stats. */
-		write_longint(batch_fd, total_read);
-		write_longint(batch_fd, total_written);
-		write_longint(batch_fd, stats.total_size);
+		write_varlong30(batch_fd, total_read, 3);
+		write_varlong30(batch_fd, total_written, 3);
+		write_varlong30(batch_fd, stats.total_size, 3);
 		if (protocol_version >= 29) {
-			write_longint(batch_fd, stats.flist_buildtime);
-			write_longint(batch_fd, stats.flist_xfertime);
+			write_varlong30(batch_fd, stats.flist_buildtime, 3);
+			write_varlong30(batch_fd, stats.flist_xfertime, 3);
 		}
 	}
 }
 
 static void output_summary(void)
 {
@@ -235,13 +252,14 @@
 		rprintf(FINFO,"Total transferred file size: %s bytes\n",
 			human_num(stats.total_transferred_size));
 		rprintf(FINFO,"Literal data: %s bytes\n",
 			human_num(stats.literal_data));
 		rprintf(FINFO,"Matched data: %s bytes\n",
 			human_num(stats.matched_data));
-		rprintf(FINFO,"File list size: %d\n", stats.flist_size);
+		rprintf(FINFO,"File list size: %s\n",
+			human_num(stats.flist_size));
 		if (stats.flist_buildtime) {
 			rprintf(FINFO,
 				"File list generation time: %.3f seconds\n",
 				(double)stats.flist_buildtime / 1000);
 			rprintf(FINFO,
 				"File list transfer time: %.3f seconds\n",
@@ -256,15 +274,16 @@
 	if (verbose || do_stats) {
 		rprintf(FCLIENT, "\n");
 		rprintf(FINFO,
 			"sent %s bytes  received %s bytes  %s bytes/sec\n",
 			human_num(total_written), human_num(total_read),
 			human_dnum((total_written + total_read)/(0.5 + (endtime - starttime)), 2));
-		rprintf(FINFO, "total size is %s  speedup is %.2f\n",
+		rprintf(FINFO, "total size is %s  speedup is %.2f%s\n",
 			human_num(stats.total_size),
-			(double)stats.total_size / (total_written+total_read));
+			(double)stats.total_size / (total_written+total_read),
+			write_batch < 0 ? " (BATCH ONLY)" : dry_run ? " (DRY RUN)" : "");
 	}
 
 	fflush(stdout);
 	fflush(stderr);
 }
 
@@ -307,19 +326,18 @@
 		(long)mi.keepcost);
 #endif /* HAVE_MALLINFO */
 }
 
 
 /* Start the remote shell.   cmd may be NULL to use the default. */
-static pid_t do_cmd(char *cmd, char *machine, char *user, char *path,
-		    int *f_in, int *f_out)
+static pid_t do_cmd(char *cmd, char *machine, char *user, char **remote_argv, int remote_argc,
+		    int *f_in_p, int *f_out_p)
 {
 	int i, argc = 0;
 	char *args[MAX_ARGS];
 	pid_t ret;
-	char *dir = NULL;
 	int dash_l_set = 0;
 
 	if (!read_batch && !local_server) {
 		char *t, *f, in_quote = '\0';
 		char *rsh_env = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
@@ -331,16 +349,14 @@
 			goto oom;
 
 		for (t = f = cmd; *f; f++) {
 			if (*f == ' ')
 				continue;
 			/* Comparison leaves rooms for server_options(). */
-			if (argc >= MAX_ARGS - MAX_SERVER_ARGS) {
-				rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
-				exit_cleanup(RERR_SYNTAX);
-			}
+			if (argc >= MAX_ARGS - MAX_SERVER_ARGS)
+				goto arg_overflow;
 			args[argc++] = t;
 			while (*f != ' ' || in_quote) {
 				if (!*f) {
 					if (in_quote) {
 						rprintf(FERROR,
 						    "Missing trailing-%c in remote-shell command.\n",
@@ -398,52 +414,104 @@
 			if (strcmp(cp, "rsh") == 0 || strcmp(cp, "remsh") == 0)
 				blocking_io = 1;
 		}
 
 		server_options(args,&argc);
 
-		if (argc >= MAX_ARGS - 2) {
-			rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
-			exit_cleanup(RERR_SYNTAX);
-		}
+		if (argc >= MAX_ARGS - 2)
+			goto arg_overflow;
 	}
 
 	args[argc++] = ".";
 
-	if (!daemon_over_rsh && path && *path)
-		args[argc++] = path;
+	if (!daemon_over_rsh) {
+		while (remote_argc > 0) {
+			if (argc >= MAX_ARGS - 1) {
+			  arg_overflow:
+				rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
+			args[argc++] = *remote_argv++;
+			remote_argc--;
+		}
+	}
 
 	args[argc] = NULL;
 
 	if (verbose > 3) {
 		for (i = 0; i < argc; i++)
 			rprintf(FCLIENT, "cmd[%d]=%s ", i, args[i]);
 		rprintf(FCLIENT, "\n");
 	}
 
 	if (read_batch) {
 		int from_gen_pipe[2];
+		set_allow_inc_recurse();
 		if (fd_pair(from_gen_pipe) < 0) {
 			rsyserr(FERROR, errno, "pipe");
 			exit_cleanup(RERR_IPC);
 		}
 		batch_gen_fd = from_gen_pipe[0];
-		*f_out = from_gen_pipe[1];
-		*f_in = batch_fd;
+		*f_out_p = from_gen_pipe[1];
+		*f_in_p = batch_fd;
 		ret = -1; /* no child pid */
+#ifdef ICONV_CONST
+		setup_iconv();
+#endif
 	} else if (local_server) {
 		/* If the user didn't request --[no-]whole-file, force
 		 * it on, but only if we're not batch processing. */
 		if (whole_file < 0 && !write_batch)
 			whole_file = 1;
-		ret = local_child(argc, args, f_in, f_out, child_main);
-	} else
-		ret = piped_child(args,f_in,f_out);
+		set_allow_inc_recurse();
+		ret = local_child(argc, args, f_in_p, f_out_p, child_main);
+#ifdef ICONV_CONST
+		setup_iconv();
+#endif
+	} else {
+#ifdef ICONV_CONST
+		setup_iconv();
+#endif
+		if (protect_args) {
+			int fd;
+#ifdef ICONV_OPTION
+			int convert = ic_send != (iconv_t)-1;
+			xbuf outbuf, inbuf;
 
-	if (dir)
-		free(dir);
+			if (convert)
+				alloc_xbuf(&outbuf, 1024);
+#endif
+
+			ret = piped_child(args, f_in_p, f_out_p);
+
+			for (i = 0; args[i]; i++) {} /* find first NULL */
+			args[i] = "rsync"; /* set a new arg0 */
+			if (verbose > 1)
+				print_child_argv("protected args:", args + i + 1);
+			fd = *f_out_p;
+			do {
+#ifdef ICONV_OPTION
+				if (convert) {
+					INIT_XBUF_STRLEN(inbuf, args[i]);
+					iconvbufs(ic_send, &inbuf, &outbuf,
+						  ICB_EXPAND_OUT | ICB_INCLUDE_BAD | ICB_INCLUDE_INCOMPLETE);
+					outbuf.buf[outbuf.len] = '\0';
+					write_buf(fd, outbuf.buf, outbuf.len + 1);
+					outbuf.len = 0;
+				} else
+#endif
+					write_buf(fd, args[i], strlen(args[i]) + 1);
+			} while (args[++i]);
+			write_byte(fd, 0);
+#ifdef ICONV_OPTION
+			if (convert)
+				free(outbuf.buf);
+#endif
+		} else
+			ret = piped_child(args, f_in_p, f_out_p);
+	}
 
 	return ret;
 
   oom:
 	out_of_memory("do_cmd");
 	return 0; /* not reached */
@@ -467,13 +535,13 @@
 	STRUCT_STAT st;
 	int statret;
 	char *cp;
 
 	if (verbose > 2) {
 		rprintf(FINFO, "get_local_name count=%d %s\n",
-			flist->count, NS(dest_path));
+			file_total, NS(dest_path));
 	}
 
 	if (!dest_path || list_only)
 		return NULL;
 
 	/* See what currently exists at the destination. */
@@ -484,20 +552,19 @@
 				rsyserr(FERROR, errno, "push_dir#1 %s failed",
 					full_fname(dest_path));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
-		if (flist->count > 1) {
+		if (file_total > 1) {
 			rprintf(FERROR,
 				"ERROR: destination must be a directory when"
 				" copying more than 1 file\n");
 			exit_cleanup(RERR_FILESELECT);
 		}
-		/* Caution: flist->count could be 0! */
-		if (flist->count == 1 && S_ISDIR(flist->files[0]->mode)) {
+		if (file_total == 1 && S_ISDIR(flist->files[0]->mode)) {
 			rprintf(FERROR,
 				"ERROR: cannot overwrite non-directory"
 				" with a directory\n");
 			exit_cleanup(RERR_FILESELECT);
 		}
 	} else if (errno != ENOENT) {
@@ -509,13 +576,13 @@
 
 	cp = strrchr(dest_path, '/');
 
 	/* If we need a destination directory because the transfer is not
 	 * of a single non-directory or the user has requested one via a
 	 * destination path ending in a slash, create one and use mode 1. */
-	if (flist->count > 1 || (cp && !cp[1])) {
+	if (file_total > 1 || (cp && !cp[1])) {
 		/* Lop off the final slash (if any). */
 		if (cp && !cp[1])
 			*cp = '\0';
 
 		if (statret == 0) {
 			rprintf(FERROR,
@@ -526,13 +593,15 @@
 		if (mkdir_defmode(dest_path) != 0) {
 			rsyserr(FERROR, errno, "mkdir %s failed",
 				full_fname(dest_path));
 			exit_cleanup(RERR_FILEIO);
 		}
 
-		new_root_dir = 1;
+		if (flist->high >= flist->low
+		 && strcmp(flist->files[flist->low]->basename, ".") == 0)
+			flist->files[0]->flags |= FLAG_DIR_CREATED;
 
 		if (verbose)
 			rprintf(FINFO, "created directory %s\n", dest_path);
 
 		if (dry_run) {
 			/* Indicate that dest dir doesn't really exist. */
@@ -566,62 +635,65 @@
 	}
 	*cp = '/';
 
 	return cp + 1;
 }
 
-/* Call this if the destination dir (which is assumed to be in curr_dir)
- * does not yet exist and we can't create it due to being in dry-run
- * mode.  We'll fix dirs that can be relative to the non-existent dir. */
-static void fix_basis_dirs(void)
+/* This function checks on our alternate-basis directories.  If we're in
+ * dry-run mode and the destination dir does not yet exist, we'll try to
+ * tweak any dest-relative paths to make them work for a dry-run (the
+ * destination dir must be in curr_dir[] when this function is called).
+ * We also warn about any arg that is non-existent or not a directory. */
+static void check_alt_basis_dirs(void)
 {
-	char **dir, *new, *slash;
-	int len;
-
-	if (dry_run <= 1)
-		return;
-
-	slash = strrchr(curr_dir, '/');
+	STRUCT_STAT st;
+	char **dir_p, *slash = strrchr(curr_dir, '/');
 
-	for (dir = basis_dir; *dir; dir++) {
-		if (**dir == '/')
-			continue;
-		len = curr_dir_len + 1 + strlen(*dir) + 1;
-		if (!(new = new_array(char, len)))
-			out_of_memory("fix_basis_dirs");
-		if (slash && strncmp(*dir, "../", 3) == 0) {
-		    /* We want to remove only one leading "../" prefix for
-		     * the directory we couldn't create in dry-run mode:
-		     * this ensures that any other ".." references get
-		     * evaluated the same as they would for a live copy. */
-		    *slash = '\0';
-		    pathjoin(new, len, curr_dir, *dir + 3);
-		    *slash = '/';
-		} else
-		    pathjoin(new, len, curr_dir, *dir);
-		*dir = new;
+	for (dir_p = basis_dir; *dir_p; dir_p++) {
+		if (dry_run > 1 && **dir_p != '/') {
+			int len = curr_dir_len + 1 + strlen(*dir_p) + 1;
+			char *new = new_array(char, len);
+			if (!new)
+				out_of_memory("check_alt_basis_dirs");
+			if (slash && strncmp(*dir_p, "../", 3) == 0) {
+			    /* We want to remove only one leading "../" prefix for
+			     * the directory we couldn't create in dry-run mode:
+			     * this ensures that any other ".." references get
+			     * evaluated the same as they would for a live copy. */
+			    *slash = '\0';
+			    pathjoin(new, len, curr_dir, *dir_p + 3);
+			    *slash = '/';
+			} else
+			    pathjoin(new, len, curr_dir, *dir_p);
+			*dir_p = new;
+		}
+		if (do_stat(*dir_p, &st) < 0) {
+			rprintf(FWARNING, "%s arg does not exist: %s\n",
+				dest_option, *dir_p);
+		} else if (!S_ISDIR(st.st_mode)) {
+			rprintf(FWARNING, "%s arg is not a dir: %s\n",
+				dest_option, *dir_p);
+		}
 	}
 }
 
 /* This is only called by the sender. */
-static void read_final_goodbye(int f_in, int f_out)
+static void read_final_goodbye(int f_in)
 {
-	int i;
+	int i, iflags, xlen;
+	uchar fnamecmp_type;
+	char xname[MAXPATHLEN];
 
 	if (protocol_version < 29)
 		i = read_int(f_in);
 	else {
-		while ((i = read_int(f_in)) == the_file_list->count
-		    && read_shortint(f_in) == ITEM_IS_NEW) {
-			/* Forward the keep-alive (no-op) to the receiver. */
-			write_int(f_out, the_file_list->count);
-			write_shortint(f_out, ITEM_IS_NEW);
-		}
+		i = read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
+				       xname, &xlen);
 	}
 
-	if (i != -1) {
+	if (i != NDX_DONE) {
 		rprintf(FERROR, "Invalid packet at end of run (%d) [%s]\n",
 			i, who_am_i());
 		exit_cleanup(RERR_PROTOCOL);
 	}
 }
 
@@ -656,49 +727,48 @@
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 	argc--;
 	argv++;
 
-	if (argc == 0 && (recurse || list_only)) {
+	if (argc == 0 && (recurse || xfer_dirs || list_only)) {
 		argc = 1;
 		argv--;
 		argv[0] = ".";
 	}
 
 	flist = send_file_list(f_out,argc,argv);
-	if (!flist || flist->count == 0) {
+	if (!flist || flist->used == 0)
 		exit_cleanup(0);
-	}
-	the_file_list = flist;
 
-	io_start_buffering_in();
-	io_start_buffering_out();
+	io_start_buffering_in(f_in);
 
-	send_files(flist,f_out,f_in);
+	send_files(f_in, f_out);
 	io_flush(FULL_FLUSH);
 	handle_stats(f_out);
 	if (protocol_version >= 24)
-		read_final_goodbye(f_in, f_out);
+		read_final_goodbye(f_in);
 	io_flush(FULL_FLUSH);
 	exit_cleanup(0);
 }
 
 
-static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
+static int do_recv(int f_in, int f_out, char *local_name)
 {
 	int pid;
 	int exit_code = 0;
 	int error_pipe[2];
 
 	/* The receiving side mustn't obey this, or an existing symlink that
 	 * points to an identical file won't be replaced by the referent. */
-	copy_links = copy_dirlinks = 0;
+	copy_links = copy_dirlinks = copy_unsafe_links = 0;
 
-	if (preserve_hard_links)
-		init_hard_links();
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && !inc_recurse)
+		match_hard_links(first_flist);
+#endif
 
 	if (fd_pair(error_pipe) < 0) {
 		rsyserr(FERROR, errno, "pipe failed in do_recv");
 		exit_cleanup(RERR_IPC);
 	}
 
@@ -712,32 +782,38 @@
 	if (pid == 0) {
 		close(error_pipe[0]);
 		if (f_in != f_out)
 			close(f_out);
 
 		/* we can't let two processes write to the socket at one time */
-		close_multiplexing_out();
+		io_end_multiplex_out();
 
 		/* set place to send errors */
 		set_msg_fd_out(error_pipe[1]);
+		io_start_buffering_out(error_pipe[1]);
 
-		recv_files(f_in, flist, local_name);
+		recv_files(f_in, local_name);
 		io_flush(FULL_FLUSH);
 		handle_stats(f_in);
 
-		send_msg(MSG_DONE, "", 0);
+		send_msg(MSG_DONE, "", 1, 0);
+		write_varlong(error_pipe[1], stats.total_read, 3);
 		io_flush(FULL_FLUSH);
 
 		/* Handle any keep-alive packets from the post-processing work
 		 * that the generator does. */
 		if (protocol_version >= 29) {
+			int iflags, xlen;
+			uchar fnamecmp_type;
+			char xname[MAXPATHLEN];
+
 			kluge_around_eof = -1;
 
 			/* This should only get stopped via a USR2 signal. */
-			while (read_int(f_in) == flist->count
-			    && read_shortint(f_in) == ITEM_IS_NEW) {}
+			read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
+					   xname, &xlen);
 
 			rprintf(FERROR, "Invalid packet at end of run [%s]\n",
 				who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
@@ -746,47 +822,55 @@
 		 * a signal won't interrupt a sleep! */
 		while (1)
 			msleep(20);
 	}
 
 	am_generator = 1;
-	close_multiplexing_in();
+
+	io_end_multiplex_in();
 	if (write_batch && !am_server)
 		stop_write_batch();
 
 	close(error_pipe[1]);
 	if (f_in != f_out)
 		close(f_in);
 
-	io_start_buffering_out();
+	io_start_buffering_out(f_out);
 
 	set_msg_fd_in(error_pipe[0]);
+	io_start_buffering_in(error_pipe[0]);
+
+#ifdef SUPPORT_HARD_LINKS
+	if (preserve_hard_links && inc_recurse) {
+		struct file_list *flist;
+		for (flist = first_flist; flist; flist = flist->next)
+			match_hard_links(flist);
+	}
+#endif
 
-	generate_files(f_out, flist, local_name);
+	generate_files(f_out, local_name);
 
 	handle_stats(-1);
 	io_flush(FULL_FLUSH);
 	if (protocol_version >= 24) {
 		/* send a final goodbye message */
-		write_int(f_out, -1);
+		write_ndx(f_out, NDX_DONE);
 	}
 	io_flush(FULL_FLUSH);
 
 	set_msg_fd_in(-1);
 	kill(pid, SIGUSR2);
 	wait_process_with_flush(pid, &exit_code);
 	return exit_code;
 }
 
-
-static void do_server_recv(int f_in, int f_out, int argc,char *argv[])
+static void do_server_recv(int f_in, int f_out, int argc, char *argv[])
 {
 	int exit_code;
 	struct file_list *flist;
 	char *local_name = NULL;
-	char *dir = NULL;
 	int save_verbose = verbose;
 
 	if (filesfrom_fd >= 0) {
 		/* We can't mix messages with files-from data on the socket,
 		 * so temporarily turn off verbose messages. */
 		verbose = 0;
@@ -801,23 +885,26 @@
 		rprintf(FERROR,"ERROR: module is read only\n");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
 
 	if (argc > 0) {
-		dir = argv[0];
+		char *dir = argv[0];
 		argc--;
 		argv++;
 		if (!am_daemon && !push_dir(dir, 0)) {
 			rsyserr(FERROR, errno, "push_dir#4 %s failed",
 				full_fname(dir));
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 
-	io_start_buffering_in();
+	if (protocol_version >= 30)
+		io_start_multiplex_in();
+	else
+		io_start_buffering_in(f_in);
 	recv_filter_list(f_in);
 
 	if (filesfrom_fd >= 0) {
 		/* We need to send the files-from names to the sender at the
 		 * same time that we receive the file-list from them, so we
 		 * need the IO routines to automatically write out the names
@@ -825,53 +912,55 @@
 		 * avoids both deadlock and extra delays/buffers. */
 		io_set_filesfrom_fds(filesfrom_fd, f_out);
 		filesfrom_fd = -1;
 	}
 
 	flist = recv_file_list(f_in);
-	verbose = save_verbose;
 	if (!flist) {
 		rprintf(FERROR,"server_recv: recv_file_list error\n");
 		exit_cleanup(RERR_FILESELECT);
 	}
-	the_file_list = flist;
+	if (inc_recurse && file_total == 1)
+		recv_additional_file_list(f_in);
+	verbose = save_verbose;
 
 	if (argc > 0)
 		local_name = get_local_name(flist,argv[0]);
 
 	/* Now that we know what our destination directory turned out to be,
 	 * we can sanitize the --link-/copy-/compare-dest args correctly. */
 	if (sanitize_paths) {
-		char **dir;
-		for (dir = basis_dir; *dir; dir++) {
-			*dir = sanitize_path(NULL, *dir, NULL, curr_dir_depth, NULL);
-		}
-		if (partial_dir) {
-			partial_dir = sanitize_path(NULL, partial_dir, NULL, curr_dir_depth, NULL);
-		}
+		char **dir_p;
+		for (dir_p = basis_dir; *dir_p; dir_p++)
+			*dir_p = sanitize_path(NULL, *dir_p, NULL, curr_dir_depth);
+		if (partial_dir)
+			partial_dir = sanitize_path(NULL, partial_dir, NULL, curr_dir_depth);
 	}
-	fix_basis_dirs();
+	check_alt_basis_dirs();
 
 	if (server_filter_list.head) {
-		char **dir;
+		char **dir_p;
 		struct filter_list_struct *elp = &server_filter_list;
 
-		for (dir = basis_dir; *dir; dir++) {
-			if (check_filter(elp, *dir, 1) < 0)
+		for (dir_p = basis_dir; *dir_p; dir_p++) {
+			char *dir = *dir_p;
+			if (*dir == '/')
+				dir += module_dirlen;
+			if (check_filter(elp, dir, 1) < 0)
 				goto options_rejected;
 		}
 		if (partial_dir && *partial_dir == '/'
-		 && check_filter(elp, partial_dir, 1) < 0) {
+		 && check_filter(elp, partial_dir + module_dirlen, 1) < 0) {
 		    options_rejected:
 			rprintf(FERROR,
 				"Your options have been rejected by the server.\n");
 			exit_cleanup(RERR_SYNTAX);
 		}
 	}
 
-	exit_code = do_recv(f_in,f_out,flist,local_name);
+	exit_code = do_recv(f_in, f_out, local_name);
 	exit_cleanup(exit_code);
 }
 
 
 int child_main(int argc, char *argv[])
 {
@@ -884,15 +973,12 @@
 {
 	set_nonblocking(f_in);
 	set_nonblocking(f_out);
 
 	io_set_sock_fds(f_in, f_out);
 	setup_protocol(f_out, f_in);
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
-	setup_iconv();
-#endif
 
 	if (protocol_version >= 23)
 		io_start_multiplex_out();
 
 	if (am_sender) {
 		keep_dirlinks = 0; /* Must be disabled on the sender. */
@@ -895,18 +981,16 @@
 		io_start_multiplex_out();
 
 	if (am_sender) {
 		keep_dirlinks = 0; /* Must be disabled on the sender. */
 		if (need_messages_from_generator)
 			io_start_multiplex_in();
-
 		recv_filter_list(f_in);
 		do_server_sender(f_in, f_out, argc, argv);
-	} else {
+	} else
 		do_server_recv(f_in, f_out, argc, argv);
-	}
 	exit_cleanup(0);
 }
 
 
 /*
  * This is called once the connection has been negotiated.  It is used
@@ -923,18 +1007,12 @@
 		set_nonblocking(f_in);
 		set_nonblocking(f_out);
 	}
 
 	io_set_sock_fds(f_in, f_out);
 	setup_protocol(f_out,f_in);
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
-	setup_iconv();
-#endif
-
-	if (protocol_version >= 23 && !read_batch)
-		io_start_multiplex_in();
 
 	/* We set our stderr file handle to blocking because ssh might have
 	 * set it to non-blocking.  This can be particularly troublesome if
 	 * stderr is a clone of stdout, because ssh would have set our stdout
 	 * to non-blocking at the same time (which can easily cause us to lose
 	 * output from our print statements).  This kluge shouldn't cause ssh
@@ -942,68 +1020,80 @@
 	 * this until after the above protocol setup so that we know for sure
 	 * that ssh is done twiddling its file descriptors.  */
 	set_blocking(STDERR_FILENO);
 
 	if (am_sender) {
 		keep_dirlinks = 0; /* Must be disabled on the sender. */
-		io_start_buffering_out();
+		if (protocol_version >= 30)
+			io_start_multiplex_out();
+		else
+			io_start_buffering_out(f_out);
 		if (!filesfrom_host)
 			set_msg_fd_in(f_in);
 		send_filter_list(f_out);
 		if (filesfrom_host)
 			filesfrom_fd = f_in;
 
 		if (write_batch && !am_server)
 			start_write_batch(f_out);
 		flist = send_file_list(f_out, argc, argv);
 		set_msg_fd_in(-1);
 		if (verbose > 3)
 			rprintf(FINFO,"file list sent\n");
-		the_file_list = flist;
+
+		if (protocol_version >= 23)
+			io_start_multiplex_in();
 
 		io_flush(NORMAL_FLUSH);
-		send_files(flist,f_out,f_in);
+		send_files(f_in, f_out);
 		io_flush(FULL_FLUSH);
 		handle_stats(-1);
 		if (protocol_version >= 24)
-			read_final_goodbye(f_in, f_out);
+			read_final_goodbye(f_in);
 		if (pid != -1) {
 			if (verbose > 3)
 				rprintf(FINFO,"client_run waiting on %d\n", (int) pid);
 			io_flush(FULL_FLUSH);
 			wait_process_with_flush(pid, &exit_code);
 		}
 		output_summary();
 		io_flush(FULL_FLUSH);
 		exit_cleanup(exit_code);
 	}
 
-	if (need_messages_from_generator && !read_batch)
-		io_start_multiplex_out();
+	if (!read_batch) {
+		if (protocol_version >= 23)
+			io_start_multiplex_in();
+		if (need_messages_from_generator)
+			io_start_multiplex_out();
+	}
 
-	if (argc == 0)
+	if (argc == 0) {
 		list_only |= 1;
+		xfer_dirs |= 1;
+	}
 
 	send_filter_list(read_batch ? -1 : f_out);
 
 	if (filesfrom_fd >= 0) {
 		io_set_filesfrom_fds(filesfrom_fd, f_out);
 		filesfrom_fd = -1;
 	}
 
 	if (write_batch && !am_server)
 		start_write_batch(f_in);
 	flist = recv_file_list(f_in);
-	the_file_list = flist;
+	if (inc_recurse && file_total == 1)
+		recv_additional_file_list(f_in);
 
-	if (flist && flist->count > 0) {
+	if (flist && flist->used > 0) {
 		local_name = get_local_name(flist, argv[0]);
 
-		fix_basis_dirs();
+		check_alt_basis_dirs();
 
-		exit_code2 = do_recv(f_in, f_out, flist, local_name);
+		exit_code2 = do_recv(f_in, f_out, local_name);
 	} else {
 		handle_stats(-1);
 		output_summary();
 	}
 
 	if (pid != -1) {
@@ -1013,13 +1103,13 @@
 		wait_process_with_flush(pid, &exit_code);
 	}
 
 	return MAX(exit_code, exit_code2);
 }
 
-static int copy_argv (char *argv[])
+static int copy_argv(char *argv[])
 {
 	int i;
 
 	for (i = 0; argv[i]; i++) {
 		if (!(argv[i] = strdup(argv[i]))) {
 			rprintf (FERROR, "out of memory at %s(%d)\n",
@@ -1039,96 +1129,154 @@
  *
  * Calls either start_socket_client (for sockets) or do_cmd and
  * client_run (for ssh).
  **/
 static int start_client(int argc, char *argv[])
 {
-	char *p;
-	char *shell_machine = NULL;
-	char *shell_path = NULL;
-	char *shell_user = NULL;
+	char *p, *shell_machine = NULL, *shell_user = NULL;
+	char **remote_argv;
+	int remote_argc;
+	int f_in, f_out;
 	int ret;
 	pid_t pid;
-	int f_in,f_out;
-	int rc;
 
 	/* Don't clobber argv[] so that ps(1) can still show the right
 	 * command line. */
-	if ((rc = copy_argv(argv)))
-		return rc;
+	if ((ret = copy_argv(argv)) != 0)
+		return ret;
 
 	if (!read_batch) { /* for read_batch, NO source is specified */
-		shell_path = check_for_hostspec(argv[0], &shell_machine, &rsync_port);
-		if (shell_path) { /* source is remote */
-			char *dummy1;
-			int dummy2;
-			if (--argc
-			 && check_for_hostspec(argv[argc], &dummy1, &dummy2)) {
+		char *path = check_for_hostspec(argv[0], &shell_machine, &rsync_port);
+		if (path) { /* source is remote */
+			char *dummy_host;
+			int dummy_port = 0;
+			*argv = path;
+			remote_argv = argv;
+			remote_argc = argc;
+			argv += argc - 1;
+			if (argc == 1 || **argv == ':')
+				argc = 0; /* no dest arg */
+			else if (check_for_hostspec(*argv, &dummy_host, &dummy_port)) {
 				rprintf(FERROR,
 					"The source and destination cannot both be remote.\n");
 				exit_cleanup(RERR_SYNTAX);
+			} else {
+				remote_argc--; /* don't count dest */
+				argc = 1;
 			}
-			argv++;
 			if (filesfrom_host && *filesfrom_host
 			    && strcmp(filesfrom_host, shell_machine) != 0) {
 				rprintf(FERROR,
 					"--files-from hostname is not the same as the transfer hostname\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
-			if (rsync_port) {
-				if (!shell_cmd) {
-					return start_socket_client(shell_machine,
-								   shell_path,
-								   argc, argv);
-				}
-				daemon_over_rsh = 1;
-			}
-
 			am_sender = 0;
+			if (rsync_port)
+				daemon_over_rsh = shell_cmd ? 1 : -1;
 		} else { /* source is local, check dest arg */
 			am_sender = 1;
 
-			if (argc > 1)
+			if (argc > 1) {
 				p = argv[--argc];
-			else {
-				p = ".";
-				list_only = 1;
+				remote_argv = argv + argc;
+			} else {
+				static char *dotarg[1] = { "." };
+				p = dotarg[0];
+				remote_argv = dotarg;
+				list_only |= 1;
+				xfer_dirs |= 1;
 			}
+			remote_argc = 1;
 
-			shell_path = check_for_hostspec(p, &shell_machine, &rsync_port);
-			if (shell_path && filesfrom_host && *filesfrom_host
+			path = check_for_hostspec(p, &shell_machine, &rsync_port);
+			if (path && filesfrom_host && *filesfrom_host
 			    && strcmp(filesfrom_host, shell_machine) != 0) {
 				rprintf(FERROR,
 					"--files-from hostname is not the same as the transfer hostname\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
-			if (!shell_path) { /* no hostspec found, so src & dest are local */
+			if (!path) { /* no hostspec found, so src & dest are local */
 				local_server = 1;
 				if (filesfrom_host) {
 					rprintf(FERROR,
 						"--files-from cannot be remote when the transfer is local\n");
 					exit_cleanup(RERR_SYNTAX);
 				}
 				shell_machine = NULL;
-				shell_path = p;
-			} else if (rsync_port) {
-				if (!shell_cmd) {
-					return start_socket_client(shell_machine,
-								   shell_path,
-								   argc, argv);
-				}
-				daemon_over_rsh = 1;
+			} else { /* hostspec was found, so dest is remote */
+				argv[argc] = path;
+				if (rsync_port)
+					daemon_over_rsh = shell_cmd ? 1 : -1;
 			}
 		}
 	} else {  /* read_batch */
 		local_server = 1;
-		shell_path = argv[argc-1];
-		if (check_for_hostspec(shell_path, &shell_machine, &rsync_port)) {
+		if (check_for_hostspec(argv[argc-1], &shell_machine, &rsync_port)) {
 			rprintf(FERROR, "remote destination is not allowed with --read-batch\n");
 			exit_cleanup(RERR_SYNTAX);
 		}
+		remote_argv = argv + argc - 1;
+		remote_argc = 1;
+	}
+
+	if (am_sender) {
+		char *dummy_host;
+		int dummy_port = rsync_port;
+		int i;
+		/* For local source, extra source args must not have hostspec. */
+		for (i = 1; i < argc; i++) {
+			if (check_for_hostspec(argv[i], &dummy_host, &dummy_port)) {
+				rprintf(FERROR, "Unexpected remote arg: %s\n", argv[i]);
+				exit_cleanup(RERR_SYNTAX);
+			}
+		}
+	} else {
+		char *dummy_host;
+		int dummy_port = rsync_port;
+		int i;
+		/* For remote source, any extra source args must have either
+		 * the same hostname or an empty hostname. */
+		for (i = 1; i < remote_argc; i++) {
+			char *arg = check_for_hostspec(remote_argv[i], &dummy_host, &dummy_port);
+			if (!arg) {
+				rprintf(FERROR, "Unexpected local arg: %s\n", remote_argv[i]);
+				rprintf(FERROR, "If arg is a remote file/dir, prefix it with a colon (:).\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
+			if (*dummy_host && strcmp(dummy_host, shell_machine) != 0) {
+				rprintf(FERROR, "All source args must come from the same machine.\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
+			if (rsync_port != dummy_port) {
+				if (!rsync_port || !dummy_port)
+					rprintf(FERROR, "All source args must use the same hostspec format.\n");
+				else
+					rprintf(FERROR, "All source args must use the same port number.\n");
+				exit_cleanup(RERR_SYNTAX);
+			}
+			remote_argv[i] = arg;
+		}
+		if (argc == 0) {
+			list_only |= 1;
+			xfer_dirs |= 1;
+		}
+	}
+
+	if (daemon_over_rsh < 0)
+		return start_socket_client(shell_machine, remote_argc, remote_argv, argc, argv);
+
+	if (password_file && !daemon_over_rsh) {
+		rprintf(FERROR, "The --password-file option may only be "
+				"used when accessing an rsync daemon.\n");
+		exit_cleanup(RERR_SYNTAX);
+	}
+
+	if (connect_timeout) {
+		rprintf(FERROR, "The --contimeout option may only be "
+				"used when connecting to an rsync daemon.\n");
+		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (shell_machine) {
 		p = strrchr(shell_machine,'@');
 		if (p) {
 			*p = 0;
@@ -1136,37 +1284,24 @@
 			shell_machine = p+1;
 		}
 	}
 
 	if (verbose > 3) {
 		rprintf(FINFO,"cmd=%s machine=%s user=%s path=%s\n",
-			shell_cmd ? shell_cmd : "",
-			shell_machine ? shell_machine : "",
-			shell_user ? shell_user : "",
-			shell_path ? shell_path : "");
-	}
-
-	/* for remote source, only single dest arg can remain ... */
-	if (!am_sender && argc > 1) {
-		usage(FERROR);
-		exit_cleanup(RERR_SYNTAX);
+			NS(shell_cmd), NS(shell_machine), NS(shell_user),
+			remote_argv ? NS(remote_argv[0]) : "");
 	}
 
-	/* ... or no dest at all */
-	if (!am_sender && argc == 0)
-		list_only |= 1;
-
-	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,
-		     &f_in,&f_out);
+	pid = do_cmd(shell_cmd, shell_machine, shell_user, remote_argv, remote_argc,
+		     &f_in, &f_out);
 
 	/* if we're running an rsync server on the remote host over a
 	 * remote shell command, we need to do the RSYNCD protocol first */
 	if (daemon_over_rsh) {
 		int tmpret;
-		tmpret = start_inband_exchange(shell_user, shell_path,
-					       f_in, f_out, argc);
+		tmpret = start_inband_exchange(f_in, f_out, shell_user, remote_argc, remote_argv);
 		if (tmpret < 0)
 			return tmpret;
 	}
 
 	ret = client_run(f_in, f_out, pid, argc, argv);
 
@@ -1184,13 +1319,13 @@
 
 static RETSIGTYPE sigusr2_handler(UNUSED(int val))
 {
 	if (!am_server)
 		output_summary();
 	close_all();
-	if (log_got_error)
+	if (got_xfer_error)
 		_exit(RERR_PARTIAL);
 	_exit(0);
 }
 
 RETSIGTYPE remember_children(UNUSED(int val))
 {
@@ -1291,13 +1426,14 @@
 	SIGACTMASK(SIGFPE, rsync_panic_handler);
 	SIGACTMASK(SIGABRT, rsync_panic_handler);
 	SIGACTMASK(SIGBUS, rsync_panic_handler);
 #endif
 
 	starttime = time(NULL);
-	am_root = (MY_UID() == 0);
+	our_uid = MY_UID();
+	am_root = our_uid == 0;
 
 	memset(&stats, 0, sizeof(stats));
 
 	if (argc < 2) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
@@ -1355,19 +1491,36 @@
 			rsyserr(FERROR, errno, "Batch file %s open error",
 				full_fname(batch_name));
 			exit_cleanup(RERR_FILEIO);
 		}
 		if (read_batch)
 			read_stream_flags(batch_fd);
+		else
+			write_stream_flags(batch_fd);
+
 	}
 	if (write_batch < 0)
 		dry_run = 1;
 
-	if (am_daemon && !am_server)
+	if (am_server) {
+#ifdef ICONV_CONST
+		setup_iconv();
+#endif
+	} else if (am_daemon)
 		return daemon_main();
 
+	if (am_server && protect_args) {
+		char buf[MAXPATHLEN];
+		protect_args = 2;
+		read_args(STDIN_FILENO, NULL, buf, sizeof buf, 1, &argv, &argc, NULL);
+		if (!parse_arguments(&argc, (const char ***) &argv, 1)) {
+			option_error();
+			exit_cleanup(RERR_SYNTAX);
+		}
+	}
+
 	if (argc < 1) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (am_server) {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/Makefile.in	2006-10-24 23:09:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/Makefile.in	2008-02-13 09:29:09.000000000 +0800
@@ -23,59 +23,81 @@
 
 VERSION=@VERSION@
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
-HEADERS=byteorder.h config.h errcode.h proto.h rsync.h lib/pool_alloc.h
-LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
-	lib/permstring.o lib/pool_alloc.o @LIBOBJS@
+GENFILES=configure.sh config.h.in proto.h proto.h-tstamp rsync.1 rsyncd.conf.5
+HEADERS=byteorder.h config.h errcode.h proto.h rsync.h ifuncs.h lib/pool_alloc.h
+LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o lib/md5.o \
+	lib/permstring.o lib/pool_alloc.o lib/sysacls.o lib/sysxattrs.o @LIBOBJS@
 ZLIBOBJ=zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o \
 	zlib/trees.o zlib/zutil.o zlib/adler32.o zlib/compress.o zlib/crc32.o
-OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
-	main.o checksum.o match.o syscall.o log.o backup.o
-OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
-	fileio.o batch.o clientname.o chmod.o
+OBJS1=flist.o rsync.o generator.o receiver.o cleanup.o sender.o exclude.o \
+	util.o main.o checksum.o match.o syscall.o log.o backup.o
+OBJS2=options.o io.o compat.o hlink.o token.o uidlist.o socket.o hashtable.o \
+	fileio.o batch.o clientname.o chmod.o acls.o xattrs.o
 OBJS3=progress.o pipe.o
 DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
 popt_OBJS=popt/findme.o  popt/popt.o  popt/poptconfig.o \
 	popt/popthelp.o popt/poptparse.o
 OBJS=$(OBJS1) $(OBJS2) $(OBJS3) $(DAEMON_OBJ) $(LIBOBJ) $(ZLIBOBJ) @BUILD_POPT@
 
-TLS_OBJ = tls.o syscall.o lib/compat.o lib/snprintf.o lib/permstring.o
+TLS_OBJ = tls.o syscall.o lib/compat.o lib/snprintf.o lib/permstring.o lib/sysxattrs.o @BUILD_POPT@
 
 # Programs we must have to run the test cases
 CHECK_PROGS = rsync$(EXEEXT) tls$(EXEEXT) getgroups$(EXEEXT) getfsdev$(EXEEXT) \
 	trimslash$(EXEEXT) t_unsafe$(EXEEXT) wildtest$(EXEEXT)
 
+CHECK_SYMLINKS = testsuite/chown-fake.test testsuite/devices-fake.test
+
 # Objects for CHECK_PROGS to clean
-CHECK_OBJS=getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.o wildtest.o
+CHECK_OBJS=tls.o getgroups.o getfsdev.o t_stub.o t_unsafe.o trimslash.o wildtest.o
 
 # note that the -I. is needed to handle config.h when using VPATH
 .c.o:
 @OBJ_SAVE@
 	$(CC) -I. -I$(srcdir) $(CFLAGS) $(CPPFLAGS) -c $< @CC_SHOBJ_FLAG@
 @OBJ_RESTORE@
 
-all: rsync$(EXEEXT)
+all: conf_stop make_stop rsync$(EXEEXT) @MAKE_MAN@
 
 install: all
 	-mkdir -p ${DESTDIR}${bindir}
 	${INSTALLCMD} ${INSTALL_STRIP} -m 755 rsync$(EXEEXT) ${DESTDIR}${bindir}
 	-mkdir -p ${DESTDIR}${mandir}/man1
 	-mkdir -p ${DESTDIR}${mandir}/man5
-	${INSTALLMAN} -m 644 $(srcdir)/rsync.1 ${DESTDIR}${mandir}/man1
-	${INSTALLMAN} -m 644 $(srcdir)/rsyncd.conf.5 ${DESTDIR}${mandir}/man5
+	if test -f $(srcdir)/rsync.1; then ${INSTALLMAN} -m 644 $(srcdir)/rsync.1 ${DESTDIR}${mandir}/man1; fi
+	if test -f $(srcdir)/rsyncd.conf.5; then ${INSTALLMAN} -m 644 $(srcdir)/rsyncd.conf.5 ${DESTDIR}${mandir}/man5; fi
 
 install-strip:
 	$(MAKE) INSTALL_STRIP='-s' install
 
 rsync$(EXEEXT): $(OBJS)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LIBS)
 
 $(OBJS): $(HEADERS)
+$(CHECK_OBJS): $(HEADERS)
+
+flist.o: rounding.h
+
+rounding.h: rounding.c rsync.h
+	@for r in 0 1 3; do \
+	    if $(CC) $(CFLAGS) $(LDFLAGS) -o rounding -DEXTRA_ROUNDING=$$r -I. $(srcdir)/rounding.c >/dev/null 2>&1; then \
+		echo "#define EXTRA_ROUNDING $$r" >rounding.h; \
+		if test -f "$$HOME/build_farm/build_test.fns"; then \
+		    echo "EXTRA_ROUNDING is $$r" >&2; \
+		fi; \
+		break; \
+	    fi; \
+	done
+	@rm -f rounding
+	@if test -f rounding.h; then : ; else \
+	    echo "Failed to create rounding.h!"; \
+	    exit 1; \
+	fi
 
 tls$(EXEEXT): $(TLS_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TLS_OBJ) $(LIBS)
 
 getgroups$(EXEEXT): getgroups.o
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ getgroups.o $(LIBS)
@@ -88,38 +110,78 @@
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(TRIMSLASH_OBJ) $(LIBS)
 
 T_UNSAFE_OBJ = t_unsafe.o syscall.o util.o t_stub.o lib/compat.o lib/snprintf.o
 t_unsafe$(EXEEXT): $(T_UNSAFE_OBJ)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(T_UNSAFE_OBJ) $(LIBS)
 
-gen:
-	cd $(srcdir) && $(MAKE) -f prepare-source.mak gen
+gen: conf proto.h man
+
+gensend: gen
+	rsync -aivzc $(GENFILES) samba.org:/home/ftp/pub/rsync/generated-files/
+
+conf:
+	cd $(srcdir) && $(MAKE) -f prepare-source.mak conf
+
+conf_stop: configure.sh config.h.in
+
+configure.sh config.h.in: configure.in aclocal.m4
+	autoconf -o configure.sh
+	autoheader && touch config.h.in
+	@echo 'Configure files changed -- perhaps run:'
+	@echo '  make reconfigure'
+	@exit 1
+
+reconfigure: configure.sh
+	./config.status --recheck
+	./config.status
+
+make_stop: Makefile
+
+Makefile: Makefile.in config.status
+	@./config.status
+	@echo "Makefile updated -- rerun your make command."
+	@exit 1
 
-man:
-	cd $(srcdir) && $(MAKE) -f prepare-source.mak man
+proto: proto.h-tstamp
 
-proto:
-	cd $(srcdir) && $(MAKE) -f prepare-source.mak proto.h
+proto.h: proto.h-tstamp
+	@echo ' ' >/dev/null
+
+proto.h-tstamp: $(srcdir)/*.c $(srcdir)/lib/compat.c
+	perl $(srcdir)/mkproto.pl $(srcdir)/*.c $(srcdir)/lib/compat.c
+
+man: rsync.1 rsyncd.conf.5
+
+rsync.1: rsync.yo
+	yodl2man -o rsync.1 $(srcdir)/rsync.yo
+	-$(srcdir)/tweak_manpage rsync.1
+
+rsyncd.conf.5: rsyncd.conf.yo
+	yodl2man -o rsyncd.conf.5 $(srcdir)/rsyncd.conf.yo
+	-$(srcdir)/tweak_manpage rsyncd.conf.5
 
 clean: cleantests
-	rm -f *~ $(OBJS) $(TLS_OBJ) $(CHECK_PROGS) $(CHECK_OBJS)
+	rm -f *~ $(OBJS) $(CHECK_PROGS) $(CHECK_OBJS) $(CHECK_SYMLINKS) \
+		rounding rounding.h
 
 cleantests:
 	rm -rf ./testtmp*
 
 # We try to delete built files from both the source and build
 # directories, just in case somebody previously configured things in
 # the source directory.
 distclean: clean
 	rm -f Makefile config.h config.status
+	rm -f lib/dummy popt/dummy zlib/dummy
 	rm -f $(srcdir)/Makefile $(srcdir)/config.h $(srcdir)/config.status
-
+	rm -f $(srcdir)/lib/dummy $(srcdir)/popt/dummy $(srcdir)/zlib/dummy
 	rm -f config.cache config.log
 	rm -f $(srcdir)/config.cache $(srcdir)/config.log
-
 	rm -f shconfig $(srcdir)/shconfig
+	rm -f $(GENFILES)
+	rm -rf autom4te.cache
 
 # this target is really just for my use. It only works on a limited
 # range of machines and is used to produce a list of potentially
 # dead (ie. unused) functions in the code. (tridge)
 finddead:
 	nm *.o */*.o |grep 'U ' | awk '{print $$2}' | sort -u > nmused.txt
@@ -139,24 +200,33 @@
 # should depend on them too.
 
 # We try to run the scripts with POSIX mode on, in the hope that will
 # catch Bash-isms earlier even if we're running on GNU.  Of course, we
 # might lose in the future where POSIX diverges from old sh.
 
-check: all $(CHECK_PROGS)
+check: all $(CHECK_PROGS) $(CHECK_SYMLINKS)
 	rsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh
 
-wildtest.o: wildtest.c lib/wildmatch.c rsync.h
-wildtest$(EXEEXT): wildtest.o lib/compat.o
-	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o lib/compat.o @BUILD_POPT@ $(LIBS)
+check29: all $(CHECK_PROGS) $(CHECK_SYMLINKS)
+	rsync_bin=`pwd`/rsync$(EXEEXT) $(srcdir)/runtests.sh --protocol=29
+
+wildtest.o: wildtest.c lib/wildmatch.c rsync.h config.h
+wildtest$(EXEEXT): wildtest.o lib/compat.o lib/snprintf.o @BUILD_POPT@
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ wildtest.o lib/compat.o lib/snprintf.o @BUILD_POPT@ $(LIBS)
+
+testsuite/chown-fake.test:
+	ln -s chown.test $(srcdir)/testsuite/chown-fake.test
+
+testsuite/devices-fake.test:
+	ln -s devices.test $(srcdir)/testsuite/devices-fake.test
 
 # This does *not* depend on building or installing: you can use it to
 # check a version installed from a binary or some other source tree,
 # if you want.
 
-installcheck: $(CHECK_PROGS)
+installcheck: $(CHECK_PROGS) $(CHECK_SYMLINKS)
 	POSIXLY_CORRECT=1 TOOLDIR=`pwd` rsync_bin="$(bindir)/rsync$(EXEEXT)" srcdir="$(srcdir)" $(srcdir)/runtests.sh
 
 # TODO: Add 'dist' target; need to know which files will be included
 
 # Run the SPLINT (Secure Programming Lint) tool.  <www.splint.org>
 .PHONY: splint
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/match.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/match.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,26 +1,25 @@
 /*
  * Block matching used by the file-transfer code.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int do_progress;
@@ -37,35 +36,56 @@
 static int total_false_alarms;
 static int total_hash_hits;
 static int total_matches;
 
 extern struct stats stats;
 
-#define TABLESIZE (1<<16)
+#define TRADITIONAL_TABLESIZE (1<<16)
 
+static uint32 tablesize;
 static int32 *hash_table;
 
 #define SUM2HASH2(s1,s2) (((s1) + (s2)) & 0xFFFF)
 #define SUM2HASH(sum) SUM2HASH2((sum)&0xFFFF,(sum)>>16)
 
+#define BIG_SUM2HASH(sum) ((sum)%tablesize)
+
 static void build_hash_table(struct sum_struct *s)
 {
+	static uint32 alloc_size;
 	int32 i;
 
-	if (!hash_table) {
-		hash_table = new_array(int32, TABLESIZE);
+	/* Dynamically calculate the hash table size so that the hash load
+	 * for big files is about 80%.  A number greater than the traditional
+	 * size must be odd or s2 will not be able to span the entire set. */
+	tablesize = (uint32)(s->count/8) * 10 + 11;
+	if (tablesize < TRADITIONAL_TABLESIZE)
+		tablesize = TRADITIONAL_TABLESIZE;
+	if (tablesize > alloc_size || tablesize < alloc_size - 16*1024) {
+		if (hash_table)
+			free(hash_table);
+		hash_table = new_array(int32, tablesize);
 		if (!hash_table)
 			out_of_memory("build_hash_table");
+		alloc_size = tablesize;
 	}
 
-	memset(hash_table, 0xFF, TABLESIZE * sizeof hash_table[0]);
+	memset(hash_table, 0xFF, tablesize * sizeof hash_table[0]);
 
-	for (i = 0; i < s->count; i++) {
-		uint32 t = SUM2HASH(s->sums[i].sum1);
-		s->sums[i].chain = hash_table[t];
-		hash_table[t] = i;
+	if (tablesize == TRADITIONAL_TABLESIZE) {
+		for (i = 0; i < s->count; i++) {
+			uint32 t = SUM2HASH(s->sums[i].sum1);
+			s->sums[i].chain = hash_table[t];
+			hash_table[t] = i;
+		}
+	} else {
+		for (i = 0; i < s->count; i++) {
+			uint32 t = BIG_SUM2HASH(s->sums[i].sum1);
+			s->sums[i].chain = hash_table[t];
+			hash_table[t] = i;
+		}
 	}
 }
 
 
 static OFF_T last_match;
 
@@ -82,13 +102,13 @@
  * @param i If >0, the number of a matched token.  If 0, indicates we
  * have only literal data.
  **/
 static void matched(int f, struct sum_struct *s, struct map_struct *buf,
 		    OFF_T offset, int32 i)
 {
-	int32 n = offset - last_match; /* max value: block_size (int32) */
+	int32 n = (int32)(offset - last_match); /* max value: block_size (int32) */
 	int32 j;
 
 	if (verbose > 2 && i >= 0) {
 		rprintf(FINFO,
 			"match at %.0f last_match=%.0f j=%d len=%ld n=%ld\n",
 			(double)offset, (double)last_match, i,
@@ -118,14 +138,14 @@
 }
 
 
 static void hash_search(int f,struct sum_struct *s,
 			struct map_struct *buf, OFF_T len)
 {
-	OFF_T offset, end, backup;
-	int32 k, want_i;
+	OFF_T offset, end;
+	int32 k, want_i, backup;
 	char sum2[SUM_LENGTH];
 	uint32 s1, s2, sum;
 	int more;
 	schar *map;
 
 	/* want_i is used to encourage adjacent matches, allowing the RLL
@@ -162,17 +182,22 @@
 
 		if (verbose > 4) {
 			rprintf(FINFO, "offset=%.0f sum=%04x%04x\n",
 				(double)offset, s2 & 0xFFFF, s1 & 0xFFFF);
 		}
 
-		i = hash_table[SUM2HASH2(s1,s2)];
-		if (i < 0)
-			goto null_hash;
+		if (tablesize == TRADITIONAL_TABLESIZE) {
+			if ((i = hash_table[SUM2HASH2(s1,s2)]) < 0)
+				goto null_hash;
+			sum = (s1 & 0xffff) | (s2 << 16);
+		} else {
+			sum = (s1 & 0xffff) | (s2 << 16);
+			if ((i = hash_table[BIG_SUM2HASH(sum)]) < 0)
+				goto null_hash;
+		}
 
-		sum = (s1 & 0xffff) | (s2 << 16);
 		hash_hits++;
 		do {
 			int32 l;
 
 			if (sum != s->sums[i].sum1)
 				continue;
@@ -251,13 +276,13 @@
 			s2 = sum >> 16;
 			matches++;
 			break;
 		} while ((i = s->sums[i].chain) >= 0);
 
 	  null_hash:
-		backup = offset - last_match;
+		backup = (int32)(offset - last_match);
 		/* We sometimes read 1 byte prior to last_match... */
 		if (backup < 0)
 			backup = 0;
 
 		/* Trim off the first byte from the checksum */
 		more = offset + k < len;
@@ -301,67 +326,70 @@
  * 0</tt>, then there are actually no checksums for this file.
  *
  * @param len Length of the file to send.
  **/
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)
 {
-	char file_sum[MD4_SUM_LENGTH];
+	char file_sum[MAX_DIGEST_LEN];
+	int sum_len;
 
 	last_match = 0;
 	false_alarms = 0;
 	hash_hits = 0;
 	matches = 0;
 	data_transfer = 0;
 
 	sum_init(checksum_seed);
 
-	if (append_mode) {
-		OFF_T j = 0;
-		for (j = CHUNK_SIZE; j < s->flength; j += CHUNK_SIZE) {
-			if (buf && do_progress)
-				show_progress(last_match, buf->file_size);
-			sum_update(map_ptr(buf, last_match, CHUNK_SIZE),
-				   CHUNK_SIZE);
-			last_match = j;
-		}
-		if (last_match < s->flength) {
-			int32 len = s->flength - last_match;
-			if (buf && do_progress)
-				show_progress(last_match, buf->file_size);
-			sum_update(map_ptr(buf, last_match, len), len);
-			last_match = s->flength;
+	if (append_mode > 0) {
+		if (append_mode == 2) {
+			OFF_T j = 0;
+			for (j = CHUNK_SIZE; j < s->flength; j += CHUNK_SIZE) {
+				if (buf && do_progress)
+					show_progress(last_match, buf->file_size);
+				sum_update(map_ptr(buf, last_match, CHUNK_SIZE),
+					   CHUNK_SIZE);
+				last_match = j;
+			}
+			if (last_match < s->flength) {
+				int32 n = (int32)(s->flength - last_match);
+				if (buf && do_progress)
+					show_progress(last_match, buf->file_size);
+				sum_update(map_ptr(buf, last_match, n), n);
+			}
 		}
+		last_match = s->flength;
 		s->count = 0;
 	}
 
 	if (len > 0 && s->count > 0) {
 		build_hash_table(s);
 
 		if (verbose > 2)
 			rprintf(FINFO,"built hash table\n");
 
-		hash_search(f,s,buf,len);
+		hash_search(f, s, buf, len);
 
 		if (verbose > 2)
 			rprintf(FINFO,"done hash search\n");
 	} else {
 		OFF_T j;
 		/* by doing this in pieces we avoid too many seeks */
 		for (j = last_match + CHUNK_SIZE; j < len; j += CHUNK_SIZE)
 			matched(f, s, buf, j, -2);
 		matched(f, s, buf, len, -1);
 	}
 
-	sum_end(file_sum);
+	sum_len = sum_end(file_sum);
 	/* If we had a read error, send a bad checksum. */
 	if (buf && buf->status != 0)
 		file_sum[0]++;
 
 	if (verbose > 2)
 		rprintf(FINFO,"sending file_sum\n");
-	write_buf(f,file_sum,MD4_SUM_LENGTH);
+	write_buf(f, file_sum, sum_len);
 
 	if (verbose > 2)
 		rprintf(FINFO, "false_alarms=%d hash_hits=%d matches=%d\n",
 			false_alarms, hash_hits, matches);
 
 	total_hash_hits += hash_hits;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9: mkproto.awk
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: mkproto.pl
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/NEWS	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/NEWS	2008-03-02 04:12:04.000000000 +0800
@@ -1,158 +1,341 @@
-NEWS for rsync 2.6.9 (6 Nov 2006)
-Protocol: 29 (unchanged)
-Changes since 2.6.8:
+NEWS for rsync 3.0.0 (1 Mar 2008)
+Protocol: 30 (changed)
+Changes since 2.6.9:
+
+  NOTABLE CHANGES IN BEHAVIOR:
+
+    - The handling of implied directories when using --relative has changed to
+      send them as directories (e.g. no implied dir is ever sent as a symlink).
+      This avoids unexpected behavior and should not adversely affect most
+      people.  If you're one of those rare individuals who relied upon having
+      an implied dir be duplicated as a symlink, you should specify the
+      transfer of the symlink and the transfer of the referent directory as
+      separate args.  (See also --keep-dirlinks and --no-implied-dirs.)
+      Also, exclude rules no longer have a partial effect on implied dirs.
+
+    - Requesting a remote file-listing without specifying -r (--recursive) now
+      sends the -d (--dirs) option to the remote rsync rather than sending -r
+      along with an extra exclude of /*/*.  If the remote rsync does not
+      understand the -d option (i.e. it is 2.6.3 or older), you will need to
+      either turn off -d (--no-d), or specify  -r --exclude='/*/*'  manually.
+
+    - In --dry-run mode, the last line of the verbose summary text is output
+      with a "(DRY RUN)" suffix to help remind you that no updates were made.
+      Similarly, --only-write-batch outputs "(BATCH ONLY)".
+
+    - A writable rsync daemon with "use chroot" disabled now defaults to a
+      symlink-munging behavior designed to make symlinks safer while also
+      allowing absolute symlinks to be stored and retrieved.  This also has
+      the effect of making symlinks unusable while they're in the daemon's
+      hierarchy.  See the daemon's "munge symlinks" parameter for details.
+
+    - Starting up an extra copy of an rsync daemon will not clobber the pidfile
+      for the running daemon -- if the pidfile exists, the new daemon will exit
+      with an error.  This means that your wrapper script that starts the rsync
+      daemon should be made to handle lock-breaking (if you want any automatic
+      breaking of locks to be done).
 
   BUG FIXES:
 
-    - If rsync is interrupted via a handled signal (such as SIGINT), it will
-      once again clean-up its temp file from the destination dir.
+    - A daemon with "use chroot = no" and excluded items listed in the daemon
+      config file now properly checks an absolute-path arg specified for these
+      options:  --compare-dest, --link-dest, --copy-dest, --partial-dir,
+      --backup-dir, --temp-dir, and --files-from.
 
-    - Fixed an overzealous sanitizing bug in the handling of the --link-dest,
-      --copy-dest, and --compare-dest options to a daemon without chroot: if
-      the copy's destination dir is deeper than the top of the module's path,
-      these options now accept a safe number of parent-dir (../) references
-      (since these options are relative to the destination dir).  The old code
-      incorrectly chopped off all "../" prefixes for these options, no matter
-      how deep the destination directory was in the module's hierarchy.
-
-    - Fixed a bug where a deferred info/error/log message could get sent
-      directly to the sender instead of being handled by rwrite() in the
-      generator.  This fixes an "unexpected tag 3" fatal error, and should
-      also fix a potential problem where a deferred info/error message from
-      the receiver might bypass the log file and get sent only to the client
-      process.  (These problems could only affect an rsync daemon that was
-      receiving files.)
-
-    - Fixed a bug when --inplace was combined with a --*-dest option and we
-      update a file's data using an alternate basis file.  The code now
-      notices that it needs to copy the matching data from the basis file
-      instead of (wrongly) assuming that it was already present in the file.
-
-    - Fixed a bug where using --dry-run with a --*-dest option with a path
-      relative to a directory that does not yet exist:  the affected option
-      gets its proper path value so that the output of the dry-run is right.
-
-    - Fixed a bug in the %f logfile escape when receiving files: the
-      destination path is now included in the output (e.g. you can now tell
-      when a user specifies a subdir inside a module).
-
-    - If the receiving side fails to create a directory, it will now skip
-      trying to update everything that is inside that directory.
-
-    - If --link-dest is specified with --checksum but without --times, rsync
-      will now allow a hard-link to be created to a matching link-dest file
-      even when the file's modify-time doesn't match the server's file.
-
-    - The daemon now calls more timezone-using functions prior to doing a
-      chroot.  This should help some C libraries to generate proper timestamps
-      from inside a chrooted daemon (and to not try to access /etc/timezone
-      over and over again).
-
-    - Fixed a bug in the handling of an absolute --partial-dir=ABS_PATH option:
-      it now deletes an alternate basis file from the partial-dir that was used
-      to successfully update a destination file.
-
-    - Fixed a bug in the handling of --delete-excluded when using a per-dir
-      merge file:  the merge file is now honored on the receiving side, and
-      only its unqualified include/exclude commands are ignored (just as is
-      done for global include/excludes).
-
-    - Fixed a recent bug where --delete was not working when transferring from
-      the root (/) of the filesystem with --relative enabled.
-
-    - Fixed a recent bug where an --exclude='*' could affect the root (/) of
-      the filesystem with --relative enabled.
-
-    - When --inplace creates a file, it is now created with owner read/write
-      permissions (0600) instead of no permissions at all.  This avoids a
-      problem continuing a transfer that was interrupted (since --inplace
-      will not update a file that has no write permissions).
-
-    - If either --remove-source-files or --remove-sent-files is enabled and we
-      are unable to remove the source file, rsync now outputs an error.
-
-    - Fixed a bug in the daemon's "incoming chmod" rule:  newly-created
-      directories no longer get the 'F' (file) rules applied to them.
-
-    - Fixed an infinite loop bug when a filter rule was rejected due to being
-      overly long.
-
-    - When the server receives a --partial-dir option from the client, it no
-      longer runs the client-side code that adds an assumed filter rule (since
-      the client will be sending us the rules in the usual manner, and they
-      may have chosen to override the auto-added rule).
+    - A daemon can now be told to disable all user- and group-name translation
+      on a per-module basis.  This avoids a potential problem with a writable
+      daemon module that has "use chroot" enabled -- if precautions weren't
+      taken, a user could try to add a missing library and get rsync to use
+      it.  This makes rsync safer by default, and more configurable when id-
+      translation is not desired.  See the daemon's "numeric ids" parameter
+      for full details.
+
+    - A chroot daemon can now indicate which part of its path should affect the
+      chroot call, and which part should become an inside-chroot path for the
+      module.  This allows you to have outside-the-transfer paths (such as for
+      libraries) even when you enable chroot protection.  The idiom used in the
+      rsyncd.conf file is:  path = /chroot/dirs/./dirs/inside
+
+    - If a file's data arrived successfully on the receiving side but the
+      rename of the temporary file to the destination file failed AND the
+      --remove-source-files (or the deprecated --remove-sent-files) option
+      was specified, rsync no longer erroneously removes the associated
+      source file.
+
+    - Fixed the output of -ii when combined with one of the --*-dest options:
+      it now itemizes all the items, not just the changed ones.
+
+    - Made the output of all file types consistent when using a --*-dest
+      option.  Prior versions would output too many creation events for
+      matching items.
+
+    - The code that waits for a child pid now handles being interrupted by a
+      signal.  This fixes a problem with the pre-xfer exec function not being
+      able to get the exit status from the script.
+
+    - A negated filter rule (i.e. with a '!' modifier) no longer loses the
+      negation when sending the filter rules to the remote rsync.
+
+    - Fixed a problem with the --out-format (aka --log-format) option %f:  it
+      no longer outputs superfluous directory info for a non-daemon rsync.
+
+    - Fixed a problem with -vv (double --verbose) and --stats when "pushing"
+      files (which includes local copies).  Version 2.6.9 would complete the
+      copy, but exit with an error when the receiver output its memory stats.
+
+    - If --password-file is used on a non-daemon transfer, rsync now complains
+      and exits.  This should help users figure out that they can't use this
+      option to control a remote shell's password prompt.
+
+    - Make sure that directory permissions of a newly-created destination
+      directory are handled right when --perms is left off.
+
+    - The itemized output of a newly-created destination directory is now
+      output as a creation event, not a change event.
+
+    - Improved --hard-link so that more corner cases are handled correctly
+      when combined with options such as --link-dest and/or --ignore-existing.
+
+    - The --append option no longer updates a file that has the same size.
+
+    - Fixed a bug when combining --backup and --backup-dir with --inplace:
+      any missing backup directories are now created.
+
+    - Fixed a bug when using --backup and --inplace with --whole-file or
+      --read-batch: backup files are actually created now.
+
+    - The daemon pidfile is checked and created sooner in the startup sequence.
+
+    - If a daemon module's "path" value is not an absolute pathname, the code
+      now makes it absolute internally (making it work properly).
+
+    - Ensure that a temporary file always has owner-write permission while we
+      are writing to it.  This avoids problems with some network filesystems
+      when transfering read-only files.
+
+    - Any errors output about password-file reading no longer cause an error at
+      the end of the run about a partial transfer.
+
+    - The --read-batch option for protocol 30 now ensures that several more
+      options are set correctly for the current batch file:  --iconv, --acls,
+      --xattrs, --inplace, --append, and --append-verify.
+
+    - Using --only-write-batch to a daemon receiver now works properly (older
+      versions would update some files while writing the batch).
+
+    - Avoid outputting a "file has vanished" message when the file is a broken
+      symlink and --copy-unsafe-links or --copy-dirlinks is used (the code
+      already handled this for --copy-links).
+
+    - Fixed the combination of --only-write-batch and --dry-run.
+
+    - Fixed rsync's ability to remove files that are not writable by the file's
+      owner when rsync is running as the same user.
 
   ENHANCEMENTS:
 
-    - Added the --log-file=FILE and --log-file-format=FORMAT options.  These
-      can be used to tell any rsync to output what it is doing to a log file.
-      They work with a client rsync, a non-daemon server rsync (see the man
-      page for instructions), and also allows the overriding of rsyncd.conf
-      settings when starting a daemon.
-
-    - The --log-format option was renamed to be --out-format to avoid confusing
-      it with affecting the log-file output.  (The old option remains as an
-      alias for the new to preserve backward compatibility.)
-
-    - Made "log file" and "syslog facility" settable on a per-module basis in
-      the daemon's config file.
-
-    - Added the --remove-source-files option as a replacement for the (now
-      deprecated) --remove-sent-files option.  This new option removes all
-      non-dirs from the source directories, even if the file was already
-      up-to-date.  This fixes a problem where interrupting an rsync that
-      was using --remove-sent-files and restarting it could leave behind
-      a file that the earlier rsync synchronized, but didn't get to remove.
-      (The deprecated --remove-sent-files is still understood for now, and
-      still behaves in the same way as before.)
-
-    - Added the option --no-motd to suppress the message-of-the-day output
-      from a daemon when doing a copy.  (See the manpage for a caveat.)
-
-    - Added a new environment variable to the pre-/post-xfer exec commands (in
-      the daemon's config file):  RSYNC_PID.  This value will be the same in
-      both the pre- and post-xfer commands, so it can be used if the pre-xfer
-      command wants to cache some arg/request info for the post-xfer command.
+    - A new incremental-recursion algorithm is now used when rsync is talking
+      to another 3.x version.  This starts the transfer going more quickly
+      (before all the files have been found), and requires much less memory.
+      See the --recursive option in the manpage for some restrictions.
+
+    - Lowered memory use in the non-incremental-recursion algorithm for typical
+      option values (usually saving from 21-29 bytes per file).
+
+    - The default --delete algorithm is now --delete-during when talking to a
+      3.x rsync.  This is a faster scan than using --delete-before (which is
+      the default when talking to older rsync versions), and is compatible with
+      the new incremental recursion mode.
+
+    - Rsync now allows multiple remote-source args to be specified rather than
+      having to rely on a special space-splitting side-effect of the remote-
+      shell.  Additional remote args must specify the same host or an empty one
+      (e.g. empty:  :file1  or  ::module/file2).  For example, this means that
+      local use of brace expansion now works:  rsync -av host:dir/{f1,f2} .
+
+    - Added the --protect-args (-s) option, that tells rsync to send most of
+      the command-line args at the start of the transfer rather than as args
+      to the remote-shell command.  This protects them from space-splitting,
+      and only interprets basic wildcard special shell characters (*?[).
+
+    - Added the --delete-delay option, which is a more efficient way to delete
+      files at the end of the transfer without needing a separate delete pass.
+
+    - Added the --acls (-A) option to preserve Access Control Lists.  This is
+      an improved version of the prior patch that was available, and it even
+      supports OS X ACLs.  If you need to have backward compatibility with old,
+      ACL-patched versions of rsync, apply the acls.diff file from the patches
+      dir.
+
+    - Added the --xattrs (-X) option to preserve extended attributes.  This is
+      an improved version of the prior patch that was available, and it even
+      supports OS X xattrs (which includes their resource fork data).  If you
+      need to have backward compatibility with old, xattr-patched versions of
+      rsync, apply the xattrs.diff file from the patches dir.
+
+    - Added the --fake-super option that allows a non-super user to preserve
+      all attributes of a file by using a special extended-attribute idiom.
+      It even supports the storing of foreign ACL data on your backup server.
+      There is also an analogous "fake super" parameter for an rsync daemon.
+
+    - Added the --iconv option, which allows rsync to convert filenames from
+      one character-set to another during the transfer.  The default is to
+      make this feature available as long as your system has iconv_open().
+      If compilation fails, specify --disable-iconv to configure, and then
+      rebuild.  If you want rsync to perform character-set conversions by
+      default, you can specify --enable-iconv=CONVERT_STRING with the default
+      value for the --iconv option that you wish to use.  For example,
+      "--enable-iconv=." is a good choice.  See the rsync manpage for an
+      explanation of the --iconv option's settings.
+
+    - A new daemon config parameter, "charset", lets you control the character-
+      set that is used during an --iconv transfer to/from a daemon module.  You
+      can also set your daemon to refuse "no-iconv" if you want to force the
+      client to use an --iconv transfer (requiring an rsync 3.x client).
+
+    - Added the --skip-compress=LIST option to override the default list of
+      file suffixes that will not be compressed when using --compress (-z).
+
+    - The daemon's default for "dont compress" was extended to include:
+	  *.7z *.mp[34] *.mov *.avi *.ogg *.jpg *.jpeg
+      The name-matching routine was also optimized to run more quickly.
+
+    - The --max-delete option now outputs a warning if it skipped any file
+      deletions, including a count of how many deletions were skipped.  (Older
+      versions just silently stopped deleting things.)
+
+    - You may specify --max-delete=0 to a 3.0.0 client to request that it warn
+      about extraneous files without deleting anything.  If you're not sure
+      what version the client is, you can use the less-obvious --max-delete=-1,
+      as both old and new versions will treat that as the same request (though
+      older versions don't warn).
+
+    - The --hard-link option now uses less memory on both the sending and
+      receiving side for all protocol versions.  For protocol 30, the use of a
+      hashtable on the sending side allows us to more efficiently convey to the
+      receiver what files are linked together.  This reduces the amount of data
+      sent over the socket by a considerable margin (rather than adding more
+      data), and limits the in-memory storage of the device+inode information
+      to just the sending side for the new protocol 30, or to the receiving
+      side when speaking an older protocol (note that older rsync versions kept
+      the device+inode information on both sides).
+
+    - The filter rules now support a perishable ("p") modifier that marks rules
+      that should not have an effect in a directory that is being deleted.  e.g.
+      -f '-p .svn/' would only affect "live" .svn directories.
+
+    - Rsync checks all the alternate-destination args for validity (e.g.
+      --link-dest).  This lets the user know when they specified a directory
+      that does not exist.
+
+    - If we get an error setting the time on a symlink, we don't complain about
+      it anymore (since some operating systems don't support that, and it's not
+      that important).
+
+    - Protocol 30 now uses MD5 checksums instead of MD4.
+
+    - Changed the --append option to not checksum the existing data in the
+      destination file, which speeds up file appending.
+
+    - Added the --append-verify option, which works like the older --append
+      option (verifying the existing data in the destination file).  For
+      compatibility with older rsync versions, any use of --append that is
+      talking protocol 29 or older will revert to the --append-verify method.
+
+    - Added the --contimeout=SECONDS option that lets the user specify a
+      connection timeout for rsync daemon access.
+
+    - Documented and extended the support for the RSYNC_CONNECT_PROG variable
+      that can be used to enhance the client side of a daemon connection.
+
+    - Improved the dashes and double-quotes in the nroff manpage output.
+
+    - Rsync now supports a lot more --no-OPTION override options.
 
   INTERNAL:
 
-    - Did a code audit using IBM's code-checker program and made several
-      changes, including: replacing most of the strcpy() and sprintf()
-      calls with strlcpy(), snprintf(), and memcpy(), adding a 0-value to
-      an enum that had been intermingling a literal 0 with the defined enum
-      values, silencing some uninitialized memory checks, marking some
-      functions with a "noreturn" attribute, and changing an "if" that
-      could never succeed on some platforms into a pre-processor directive
-      that conditionally compiles the code.
-
-    - Fixed a potential bug in f_name_cmp() when both the args are a
-      top-level "." dir (which doesn't happen in normal operations).
-
-    - Changed exit_cleanup() so that it can never return instead of exit.
-      The old code might return if it found the exit_cleanup() function
-      was being called recursively.  The new code is segmented so that
-      any recursive calls move on to the next step of the exit-processing.
+    - The file-list sorting algorithm now uses a sort that keeps any same-
+      named items in the same order as they were specified.  This allows
+      rsync to always ensure that the first of the duplicates is the one
+      that will be included in the copy.  The new sort is also faster
+      than the glibc version of qsort() and mergesort().
 
-    - The macro WIFEXITED(stat) will now be defined if the OS didn't already
-      define it.
+    - Rsync now supports the transfer of 64-bit timestamps (time_t values).
 
-  DEVELOPER RELATED:
+    - Made the file-deletion code use a little less stack when recursing
+      through a directory hierarchy of extraneous files.
+
+    - Fixed a build problem with older (2.x) versions of gcc.
+
+    - Added some isType() functions that make dealing with signed characters
+      easier without forcing variables via casts.
+
+    - Changed strcat/strcpy/sprintf function calls to use safer versions.
 
-    - The acls.diff and xattrs.diff patches have received a bunch of work to
-      make them much closer to being acceptable in the main distribution.
-      The xattrs patch also has some preliminary Mac OS X compatibility code
-      that allows Macs and non-macs to exchange extended attributes.
-
-    - A new diff in the patches dir, fake-root.diff, allows rsync to
-      maintain a backup hierarchy with full owner, group, and device info
-      without actually running as root.  It does this using a special
-      extended attribute, so it depends on xattrs.diff (which depends on
-      acls.diff).
+    - Upgraded the included popt version to 1.10.2 and improved its use of
+      string-handling functions.
+
+    - Added missing prototypes for compatibility functions from the lib dir.
+
+    - Configure determines if iconv() has a const arg, allowing us to avoid a
+      compiler warning.
+
+    - Made the sending of some numbers more efficient for protocol 30.
+
+    - Make sure that a daemon process doesn't mind if the client was weird and
+      omitted the --server option.
+
+    - There are more internal logging categories available in protocol 30 than
+      the age-old FINFO and FERROR, including FERROR_XFER and FWARN.  These new
+      categories allow some errors and warnings to go to stderr without causing
+      an erroneous end-of-run warning about some files not being able to be
+      transferred.
+
+    - Improved the use of "const" on pointers.
+
+    - Improved J.W.'s pool_alloc routines to add a way of incrementally freeing
+      older sections of a pool's memory.
+
+    - The getaddrinfo.c compatibility code in the "lib" dir was replaced with
+      some new code (derived from samba, derived from PostgreSQL) that has a
+      better license than the old code.
+
+  DEVELOPER RELATED:
 
-    - The rsync.yo and rsyncd.conf.yo files have been updated to work
-      better with the latest yodl 2.x releases.
+    - Rsync is now licensed under the GPLv3 or later.
 
-    - Updated config.guess and config.sub to their 2006-02-23 version.
+    - Rsync is now being maintained in a "git" repository instead of CVS
+      (though the old CVS repository still exists for historical access).
+      Several maintenance scripts were updated to work with git.
+
+    - Generated files are no longer committed into the source repository.  The
+      autoconf and autoheader commands are now automatically run during the
+      normal use of "configure" and "make".  The latest dev versions of all
+      generated files can also be copied from the samba.org web site (see the
+      prepare-source script's fetch option).
+
+    - The "patches" directory of diff files is now built from branches in the
+      rsync git repository (branch patch/FOO creates file patches/FOO.diff).
+      This directory is now distributed in a separate separate tar file named
+      rsync-patches-VERSION.tar.gz instead of the main rsync-VERSION.tar.gz.
+
+    - The proto.h file is now built using a simple perl script rather than a
+      complex awk script, which proved to be more widely compatible.
+
+    - When running the tests, we now put our per-test temp dirs into a sub-
+      directory named testtmp (which is created, if missing).  This allows
+      someone to symlink the testtmp directory to another filesystem (which is
+      useful if the build dir's filesystem does not support ACLs and xattrs,
+      but another filesystem does).
+
+    - Rsync now has a way of handling protocol-version changes during the
+      development of a new protocol version.  This causes any out-of-sync
+      versions to speak an older protocol rather than fail in a cryptic manner.
+      This addition makes it safer to deploy a pre-release version that may
+      interact with the public.  This new exchange of sub-version info does not
+      interfere with the {MIN,MAX}_PROTOCOL_VERSION checking algorithm (which
+      does not have enough range to allow the main protocol number to be
+      incremented for every minor tweak in that happens during development).
 
-    - Updated various files to include the latest FSF address and to have
-      consistent opening comments.
+    - The csprotocol.txt file was updated to mention the daemon protocol change
+      in the 3.0.0 release.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/OLDNEWS	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/OLDNEWS	2008-03-02 04:12:04.000000000 +0800
@@ -1,6 +1,168 @@
+NEWS for rsync 2.6.9 (6 Nov 2006)
+Protocol: 29 (unchanged)
+Changes since 2.6.8:
+
+  BUG FIXES:
+
+    - If rsync is interrupted via a handled signal (such as SIGINT), it will
+      once again clean-up its temp file from the destination dir.
+
+    - Fixed an overzealous sanitizing bug in the handling of the --link-dest,
+      --copy-dest, and --compare-dest options to a daemon without chroot: if
+      the copy's destination dir is deeper than the top of the module's path,
+      these options now accept a safe number of parent-dir (../) references
+      (since these options are relative to the destination dir).  The old code
+      incorrectly chopped off all "../" prefixes for these options, no matter
+      how deep the destination directory was in the module's hierarchy.
+
+    - Fixed a bug where a deferred info/error/log message could get sent
+      directly to the sender instead of being handled by rwrite() in the
+      generator.  This fixes an "unexpected tag 3" fatal error, and should
+      also fix a potential problem where a deferred info/error message from
+      the receiver might bypass the log file and get sent only to the client
+      process.  (These problems could only affect an rsync daemon that was
+      receiving files.)
+
+    - Fixed a bug when --inplace was combined with a --*-dest option and we
+      update a file's data using an alternate basis file.  The code now
+      notices that it needs to copy the matching data from the basis file
+      instead of (wrongly) assuming that it was already present in the file.
+
+    - Fixed a bug where using --dry-run with a --*-dest option with a path
+      relative to a directory that does not yet exist:  the affected option
+      gets its proper path value so that the output of the dry-run is right.
+
+    - Fixed a bug in the %f logfile escape when receiving files: the
+      destination path is now included in the output (e.g. you can now tell
+      when a user specifies a subdir inside a module).
+
+    - If the receiving side fails to create a directory, it will now skip
+      trying to update everything that is inside that directory.
+
+    - If --link-dest is specified with --checksum but without --times, rsync
+      will now allow a hard-link to be created to a matching link-dest file
+      even when the file's modify-time doesn't match the server's file.
+
+    - The daemon now calls more timezone-using functions prior to doing a
+      chroot.  This should help some C libraries to generate proper timestamps
+      from inside a chrooted daemon (and to not try to access /etc/timezone
+      over and over again).
+
+    - Fixed a bug in the handling of an absolute --partial-dir=ABS_PATH option:
+      it now deletes an alternate basis file from the partial-dir that was used
+      to successfully update a destination file.
+
+    - Fixed a bug in the handling of --delete-excluded when using a per-dir
+      merge file:  the merge file is now honored on the receiving side, and
+      only its unqualified include/exclude commands are ignored (just as is
+      done for global include/excludes).
+
+    - Fixed a recent bug where --delete was not working when transferring from
+      the root (/) of the filesystem with --relative enabled.
+
+    - Fixed a recent bug where an --exclude='*' could affect the root (/) of
+      the filesystem with --relative enabled.
+
+    - When --inplace creates a file, it is now created with owner read/write
+      permissions (0600) instead of no permissions at all.  This avoids a
+      problem continuing a transfer that was interrupted (since --inplace
+      will not update a file that has no write permissions).
+
+    - If either --remove-source-files or --remove-sent-files is enabled and we
+      are unable to remove the source file, rsync now outputs an error.
+
+    - Fixed a bug in the daemon's "incoming chmod" rule:  newly-created
+      directories no longer get the 'F' (file) rules applied to them.
+
+    - Fixed an infinite loop bug when a filter rule was rejected due to being
+      overly long.
+
+    - When the server receives a --partial-dir option from the client, it no
+      longer runs the client-side code that adds an assumed filter rule (since
+      the client will be sending us the rules in the usual manner, and they
+      may have chosen to override the auto-added rule).
+
+  ENHANCEMENTS:
+
+    - Added the --log-file=FILE and --log-file-format=FORMAT options.  These
+      can be used to tell any rsync to output what it is doing to a log file.
+      They work with a client rsync, a non-daemon server rsync (see the man
+      page for instructions), and also allows the overriding of rsyncd.conf
+      settings when starting a daemon.
+
+    - The --log-format option was renamed to be --out-format to avoid confusing
+      it with affecting the log-file output.  (The old option remains as an
+      alias for the new to preserve backward compatibility.)
+
+    - Made "log file" and "syslog facility" settable on a per-module basis in
+      the daemon's config file.
+
+    - Added the --remove-source-files option as a replacement for the (now
+      deprecated) --remove-sent-files option.  This new option removes all
+      non-dirs from the source directories, even if the file was already
+      up-to-date.  This fixes a problem where interrupting an rsync that
+      was using --remove-sent-files and restarting it could leave behind
+      a file that the earlier rsync synchronized, but didn't get to remove.
+      (The deprecated --remove-sent-files is still understood for now, and
+      still behaves in the same way as before.)
+
+    - Added the option --no-motd to suppress the message-of-the-day output
+      from a daemon when doing a copy.  (See the manpage for a caveat.)
+
+    - Added a new environment variable to the pre-/post-xfer exec commands (in
+      the daemon's config file):  RSYNC_PID.  This value will be the same in
+      both the pre- and post-xfer commands, so it can be used as a unique ID
+      if the pre-xfer command wants to cache some arg/request info for the
+      post-xfer command.
+
+  INTERNAL:
+
+    - Did a code audit using IBM's code-checker program and made several
+      changes, including: replacing most of the strcpy() and sprintf()
+      calls with strlcpy(), snprintf(), and memcpy(), adding a 0-value to
+      an enum that had been intermingling a literal 0 with the defined enum
+      values, silencing some uninitialized memory checks, marking some
+      functions with a "noreturn" attribute, and changing an "if" that
+      could never succeed on some platforms into a pre-processor directive
+      that conditionally compiles the code.
+
+    - Fixed a potential bug in f_name_cmp() when both the args are a
+      top-level "." dir (which doesn't happen in normal operations).
+
+    - Changed exit_cleanup() so that it can never return instead of exit.
+      The old code might return if it found the exit_cleanup() function
+      was being called recursively.  The new code is segmented so that
+      any recursive calls move on to the next step of the exit-processing.
+
+    - The macro WIFEXITED(stat) will now be defined if the OS didn't already
+      define it.
+
+  DEVELOPER RELATED:
+
+    - The acls.diff and xattrs.diff patches have received a bunch of work to
+      make them much closer to being acceptable in the main distribution.
+      The xattrs patch also has some preliminary Mac OS X and FreeBSD
+      compatibility code that various system types to exchange extended
+      file-attributes.
+
+    - A new diff in the patches dir, fake-root.diff, allows rsync to
+      maintain a backup hierarchy with full owner, group, and device info
+      without actually running as root.  It does this using a special
+      extended attribute, so it depends on xattrs.diff (which depends on
+      acls.diff).
+
+    - The rsync.yo and rsyncd.conf.yo files have been updated to work
+      better with the latest yodl 2.x releases.
+
+    - Updated config.guess and config.sub to their 2006-07-02 versions.
+
+    - Updated various files to include the latest FSF address and to have
+      consistent opening comments.
+
+
 NEWS for rsync 2.6.8 (22 Apr 2006)
 Protocol: 29 (unchanged)
 Changes since 2.6.7:
 
   BUG FIXES:
 
@@ -141,14 +303,14 @@
       handles hard-links (within the transfer) that had an up-to-date alternate
       "dest" file, and copied files (via --copy-dest).
 
     - Fixed the matching of the dont-compress items (e.g. *.gz) against files
       that have a path component containing a slash.
 
-    - If code reading a filter/exclude file an EINTR error, rsync now clears
-      the error flag on the file handle so it can keep on reading.
+    - If the code reading a filter/exclude file gets an EINTR error, rsync now
+      clears the error flag on the file handle so it can keep on reading.
 
     - If --relative is active, the sending side cleans up trailing "/" or "/."
       suffixes to avoid triggering a bug in older rsync versions.  Also, we now
       reject a ".." dir if it would be sent as a relative dir.
 
     - If a non-directory is in the way of a directory and rsync is run with
@@ -2079,12 +2241,13 @@
     * The existing test.sh script by Phil Hands has been merged into a
       test framework that works from both "make check" and the Samba
       build farm.
 
 Partial Protocol History
 	RELEASE DATE	VER.	DATE OF COMMIT*	PROTOCOL
+	01 Mar 2008	3.0.0	11 Nov 2006	30
 	06 Nov 2006	2.6.9			29
 	22 Apr 2006	2.6.8			29
 	11 Mar 2006	2.6.7			29
 	28 Jul 2005	2.6.6			29
 	01 Jun 2005	2.6.5			29
 	30 Mar 2005	2.6.4	17 Jan 2005	29
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/options.c	2006-10-24 08:36:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/options.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,34 +1,36 @@
 /*
  * Command-line (and received via daemon-socket) option parsing.
  *
  * Copyright (C) 1998-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2000, 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2002, 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2002-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
 #include <popt.h>
 #include "zlib/zlib.h"
 
 extern int module_id;
 extern int sanitize_paths;
+extern int daemon_over_rsh;
+extern unsigned int module_dirlen;
 extern struct filter_list_struct filter_list;
 extern struct filter_list_struct server_filter_list;
 
 int make_backups = 0;
 
 /**
@@ -44,20 +46,21 @@
 int append_mode = 0;
 int keep_dirlinks = 0;
 int copy_dirlinks = 0;
 int copy_links = 0;
 int preserve_links = 0;
 int preserve_hard_links = 0;
+int preserve_acls = 0;
+int preserve_xattrs = 0;
 int preserve_perms = 0;
 int preserve_executability = 0;
 int preserve_devices = 0;
 int preserve_specials = 0;
 int preserve_uid = 0;
 int preserve_gid = 0;
 int preserve_times = 0;
-int omit_dir_times = 0;
 int update_only = 0;
 int cvs_exclude = 0;
 int dry_run = 0;
 int do_xfers = 1;
 int ignore_times = 0;
 int delete_mode = 0;
@@ -68,64 +71,72 @@
 int remove_source_files = 0;
 int one_file_system = 0;
 int protocol_version = PROTOCOL_VERSION;
 int sparse_files = 0;
 int do_compression = 0;
 int def_compress_level = Z_DEFAULT_COMPRESSION;
-int am_root = 0;
+int am_root = 0; /* 0 = normal, 1 = root, 2 = --super, -1 = --fake-super */
 int am_server = 0;
 int am_sender = 0;
 int am_generator = 0;
 int am_starting_up = 1;
 int relative_paths = -1;
 int implied_dirs = 1;
 int numeric_ids = 0;
 int allow_8bit_chars = 0;
 int force_delete = 0;
 int io_timeout = 0;
 int allowed_lull = 0;
 int prune_empty_dirs = 0;
+int use_qsort = 0;
 char *files_from = NULL;
 int filesfrom_fd = -1;
 char *filesfrom_host = NULL;
 int eol_nulls = 0;
+int protect_args = 0;
 int human_readable = 0;
 int recurse = 0;
+int allow_inc_recurse = 1;
 int xfer_dirs = -1;
 int am_daemon = 0;
-int daemon_over_rsh = 0;
 int do_stats = 0;
 int do_progress = 0;
+int connect_timeout = 0;
 int keep_partial = 0;
 int safe_symlinks = 0;
 int copy_unsafe_links = 0;
 int size_only = 0;
 int daemon_bwlimit = 0;
 int bwlimit = 0;
 int fuzzy_basis = 0;
 size_t bwlimit_writemax = 0;
 int ignore_existing = 0;
 int ignore_non_existing = 0;
 int need_messages_from_generator = 0;
-int max_delete = 0;
+int max_delete = INT_MIN;
 OFF_T max_size = 0;
 OFF_T min_size = 0;
 int ignore_errors = 0;
 int modify_window = 0;
 int blocking_io = -1;
 int checksum_seed = 0;
 int inplace = 0;
 int delay_updates = 0;
 long block_size = 0; /* "long" because popt can't set an int32. */
-
+char *skip_compress = NULL;
 
 /** Network address family. **/
+int default_af_hint
 #ifdef INET6
-int default_af_hint = 0;	/* Any protocol */
+	= 0;		/* Any protocol */
 #else
-int default_af_hint = AF_INET;	/* Must use IPv4 */
+	= AF_INET;	/* Must use IPv4 */
+# ifdef AF_INET6
+#  undef AF_INET6
+# endif
+# define AF_INET6 AF_INET /* make -6 option a no-op */
 #endif
 
 /** Do not go into the background when run as --daemon.  Good
  * for debugging and required for running as a service on W32,
  * or under Unix process-monitors. **/
 int no_detach
@@ -173,76 +184,97 @@
 int always_checksum = 0;
 int list_only = 0;
 
 #define MAX_BATCH_NAME_LEN 256	/* Must be less than MAXPATHLEN-13 */
 char *batch_name = NULL;
 
+int need_unsorted_flist = 0;
+#ifdef ICONV_OPTION
+char *iconv_opt = ICONV_OPTION;
+#endif
+
 struct chmod_mode_struct *chmod_modes = NULL;
 
 static int daemon_opt;   /* sets am_daemon after option error-reporting */
+static int omit_dir_times = 0;
 static int F_option_cnt = 0;
 static int modify_window_set;
 static int itemize_changes = 0;
 static int refused_delete, refused_archive_part, refused_compress;
 static int refused_partial, refused_progress, refused_delete_before;
-static int refused_inplace;
+static int refused_delete_during;
+static int refused_inplace, refused_no_iconv;
 static char *max_size_arg, *min_size_arg;
 static char tmp_partialdir[] = ".~tmp~";
 
 /** Local address to bind.  As a character string because it's
  * interpreted by the IPv6 layer: should be a numeric IP4 or IP6
  * address, or a hostname. **/
 char *bind_address;
 
 
 static void print_rsync_version(enum logcode f)
 {
+	char *subprotocol = "";
 	char const *got_socketpair = "no ";
 	char const *have_inplace = "no ";
 	char const *hardlinks = "no ";
+	char const *symtimes = "no ";
+	char const *acls = "no ";
+	char const *xattrs = "no ";
 	char const *links = "no ";
+	char const *iconv = "no ";
 	char const *ipv6 = "no ";
 	STRUCT_STAT *dumstat;
 
+#if SUBPROTOCOL_VERSION != 0
+	asprintf(&subprotocol, ".PR%d", SUBPROTOCOL_VERSION);
+#endif
 #ifdef HAVE_SOCKETPAIR
 	got_socketpair = "";
 #endif
-
 #ifdef HAVE_FTRUNCATE
 	have_inplace = "";
 #endif
-
 #ifdef SUPPORT_HARD_LINKS
 	hardlinks = "";
 #endif
-
+#ifdef SUPPORT_ACLS
+	acls = "";
+#endif
+#ifdef SUPPORT_XATTRS
+	xattrs = "";
+#endif
 #ifdef SUPPORT_LINKS
 	links = "";
 #endif
-
 #ifdef INET6
 	ipv6 = "";
 #endif
+#ifdef ICONV_OPTION
+	iconv = "";
+#endif
+#if defined HAVE_LUTIMES && defined HAVE_UTIMES
+	symtimes = "";
+#endif
+
+	rprintf(f, "%s  version %s  protocol version %d%s\n",
+		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION, subprotocol);
+	rprintf(f, "Copyright (C) 1996-2007 by Andrew Tridgell, Wayne Davison, and others.\n");
+	rprintf(f, "Web site: http://rsync.samba.org/\n");
+	rprintf(f, "Capabilities:\n");
+	rprintf(f, "    %d-bit files, %d-bit inums, %d-bit timestamps, %d-bit long ints,\n",
+		(int)(sizeof (OFF_T) * 8),
+		(int)(sizeof dumstat->st_ino * 8), /* Don't check ino_t! */
+		(int)(sizeof (time_t) * 8),
+		(int)(sizeof (int64) * 8));
+	rprintf(f, "    %ssocketpairs, %shardlinks, %ssymlinks, %sIPv6, batchfiles, %sinplace,\n",
+		got_socketpair, hardlinks, links, ipv6, have_inplace);
+	rprintf(f, "    %sappend, %sACLs, %sxattrs, %siconv, %ssymtimes\n",
+		have_inplace, acls, xattrs, iconv, symtimes);
 
-	rprintf(f, "%s  version %s  protocol version %d\n",
-		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
-	rprintf(f, "Copyright (C) 1996-2006 by Andrew Tridgell, Wayne Davison, and others.\n");
-	rprintf(f, "<http://rsync.samba.org/>\n");
-	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
-		"%shard links, %ssymlinks, batchfiles,\n",
-		(int) (sizeof (OFF_T) * 8),
-		got_socketpair, hardlinks, links);
-
-	/* Note that this field may not have type ino_t.  It depends
-	 * on the complicated interaction between largefile feature
-	 * macros. */
-	rprintf(f, "              %sinplace, %sIPv6, "
-		"%d-bit system inums, %d-bit internal inums\n",
-		have_inplace, ipv6,
-		(int) (sizeof dumstat->st_ino * 8),
-		(int) (sizeof (int64) * 8));
 #ifdef MAINTAINER_MODE
 	rprintf(f, "Panic Action: \"%s\"\n", get_panic_action());
 #endif
 
 #if SIZEOF_INT64 < 8
 	rprintf(f, "WARNING: no 64-bit integers on this platform!\n");
@@ -281,89 +313,103 @@
   rprintf(F,"\n");
   rprintf(F,"Options\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
   rprintf(F," -q, --quiet                 suppress non-error messages\n");
   rprintf(F,"     --no-motd               suppress daemon-mode MOTD (see manpage caveat)\n");
   rprintf(F," -c, --checksum              skip based on checksum, not mod-time & size\n");
-  rprintf(F," -a, --archive               archive mode; same as -rlptgoD (no -H)\n");
+  rprintf(F," -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)\n");
   rprintf(F,"     --no-OPTION             turn off an implied OPTION (e.g. --no-D)\n");
   rprintf(F," -r, --recursive             recurse into directories\n");
   rprintf(F," -R, --relative              use relative path names\n");
   rprintf(F,"     --no-implied-dirs       don't send implied dirs with --relative\n");
   rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir=DIR        make backups into hierarchy based in DIR\n");
   rprintf(F,"     --suffix=SUFFIX         set backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
   rprintf(F," -u, --update                skip files that are newer on the receiver\n");
   rprintf(F,"     --inplace               update destination files in-place (SEE MAN PAGE)\n");
   rprintf(F,"     --append                append data onto shorter files\n");
+  rprintf(F,"     --append-verify         like --append, but with old data in file checksum\n");
   rprintf(F," -d, --dirs                  transfer directories without recursing\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
   rprintf(F," -L, --copy-links            transform symlink into referent file/dir\n");
   rprintf(F,"     --copy-unsafe-links     only \"unsafe\" symlinks are transformed\n");
   rprintf(F,"     --safe-links            ignore symlinks that point outside the source tree\n");
   rprintf(F," -k, --copy-dirlinks         transform symlink to a dir into referent dir\n");
   rprintf(F," -K, --keep-dirlinks         treat symlinked dir on receiver as dir\n");
   rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
   rprintf(F," -E, --executability         preserve the file's executability\n");
   rprintf(F,"     --chmod=CHMOD           affect file and/or directory permissions\n");
+#ifdef SUPPORT_ACLS
+  rprintf(F," -A, --acls                  preserve ACLs (implies --perms)\n");
+#endif
+#ifdef SUPPORT_XATTRS
+  rprintf(F," -X, --xattrs                preserve extended attributes\n");
+#endif
   rprintf(F," -o, --owner                 preserve owner (super-user only)\n");
   rprintf(F," -g, --group                 preserve group\n");
   rprintf(F,"     --devices               preserve device files (super-user only)\n");
   rprintf(F,"     --specials              preserve special files\n");
   rprintf(F," -D                          same as --devices --specials\n");
-  rprintf(F," -t, --times                 preserve times\n");
-  rprintf(F," -O, --omit-dir-times        omit directories when preserving times\n");
+  rprintf(F," -t, --times                 preserve modification times\n");
+  rprintf(F," -O, --omit-dir-times        omit directories from --times\n");
   rprintf(F,"     --super                 receiver attempts super-user activities\n");
+#ifdef SUPPORT_XATTRS
+  rprintf(F,"     --fake-super            store/recover privileged attrs using xattrs\n");
+#endif
   rprintf(F," -S, --sparse                handle sparse files efficiently\n");
-  rprintf(F," -n, --dry-run               show what would have been transferred\n");
-  rprintf(F," -W, --whole-file            copy files whole (without rsync algorithm)\n");
+  rprintf(F," -n, --dry-run               perform a trial run with no changes made\n");
+  rprintf(F," -W, --whole-file            copy files whole (without delta-xfer algorithm)\n");
   rprintf(F," -x, --one-file-system       don't cross filesystem boundaries\n");
   rprintf(F," -B, --block-size=SIZE       force a fixed checksum block-size\n");
   rprintf(F," -e, --rsh=COMMAND           specify the remote shell to use\n");
   rprintf(F,"     --rsync-path=PROGRAM    specify the rsync to run on the remote machine\n");
   rprintf(F,"     --existing              skip creating new files on receiver\n");
   rprintf(F,"     --ignore-existing       skip updating files that already exist on receiver\n");
   rprintf(F,"     --remove-source-files   sender removes synchronized files (non-dirs)\n");
   rprintf(F,"     --del                   an alias for --delete-during\n");
   rprintf(F,"     --delete                delete extraneous files from destination dirs\n");
-  rprintf(F,"     --delete-before         receiver deletes before transfer (default)\n");
-  rprintf(F,"     --delete-during         receiver deletes during transfer, not before\n");
-  rprintf(F,"     --delete-after          receiver deletes after transfer, not before\n");
+  rprintf(F,"     --delete-before         receiver deletes before transfer, not during\n");
+  rprintf(F,"     --delete-during         receiver deletes during transfer (default)\n");
+  rprintf(F,"     --delete-delay          find deletions during, delete after\n");
+  rprintf(F,"     --delete-after          receiver deletes after transfer, not during\n");
   rprintf(F,"     --delete-excluded       also delete excluded files from destination dirs\n");
   rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --max-size=SIZE         don't transfer any file larger than SIZE\n");
   rprintf(F,"     --min-size=SIZE         don't transfer any file smaller than SIZE\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --partial-dir=DIR       put a partially transferred file into DIR\n");
   rprintf(F,"     --delay-updates         put all updated files into place at transfer's end\n");
   rprintf(F," -m, --prune-empty-dirs      prune empty directory chains from the file-list\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
-  rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
+  rprintf(F,"     --timeout=SECONDS       set I/O timeout in seconds\n");
+  rprintf(F,"     --contimeout=SECONDS    set daemon connection timeout in seconds\n");
   rprintf(F," -I, --ignore-times          don't skip files that match in size and mod-time\n");
   rprintf(F,"     --size-only             skip files that match in size\n");
   rprintf(F,"     --modify-window=NUM     compare mod-times with reduced accuracy\n");
   rprintf(F," -T, --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F," -y, --fuzzy                 find similar file for basis if no dest file\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --copy-dest=DIR         ... and include copies of unchanged files\n");
   rprintf(F,"     --link-dest=DIR         hardlink to files in DIR when unchanged\n");
   rprintf(F," -z, --compress              compress file data during the transfer\n");
   rprintf(F,"     --compress-level=NUM    explicitly set compression level\n");
+  rprintf(F,"     --skip-compress=LIST    skip compressing files with a suffix in LIST\n");
   rprintf(F," -C, --cvs-exclude           auto-ignore files the same way CVS does\n");
   rprintf(F," -f, --filter=RULE           add a file-filtering RULE\n");
   rprintf(F," -F                          same as --filter='dir-merge /.rsync-filter'\n");
   rprintf(F,"                             repeated: --filter='- .rsync-filter'\n");
   rprintf(F,"     --exclude=PATTERN       exclude files matching PATTERN\n");
   rprintf(F,"     --exclude-from=FILE     read exclude patterns from FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     read include patterns from FILE\n");
   rprintf(F,"     --files-from=FILE       read list of source-file names from FILE\n");
   rprintf(F," -0, --from0                 all *-from/filter files are delimited by 0s\n");
+  rprintf(F," -s, --protect-args          no space-splitting; only wildcard special-chars\n");
   rprintf(F,"     --address=ADDRESS       bind address for outgoing socket to daemon\n");
   rprintf(F,"     --port=PORT             specify double-colon alternate port number\n");
   rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
   rprintf(F,"     --blocking-io           use blocking I/O for the remote shell\n");
   rprintf(F,"     --stats                 give some file-transfer stats\n");
   rprintf(F," -8, --8-bit-output          leave high-bit chars unescaped in output\n");
@@ -371,23 +417,24 @@
   rprintf(F,"     --progress              show progress during transfer\n");
   rprintf(F," -P                          same as --partial --progress\n");
   rprintf(F," -i, --itemize-changes       output a change-summary for all updates\n");
   rprintf(F,"     --out-format=FORMAT     output updates using the specified FORMAT\n");
   rprintf(F,"     --log-file=FILE         log what we're doing to the specified FILE\n");
   rprintf(F,"     --log-file-format=FMT   log updates using the specified FMT\n");
-  rprintf(F,"     --password-file=FILE    read password from FILE\n");
+  rprintf(F,"     --password-file=FILE    read daemon-access password from FILE\n");
   rprintf(F,"     --list-only             list the files instead of copying them\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth; KBytes per second\n");
   rprintf(F,"     --write-batch=FILE      write a batched update to FILE\n");
   rprintf(F,"     --only-write-batch=FILE like --write-batch but w/o updating destination\n");
   rprintf(F,"     --read-batch=FILE       read a batched update from FILE\n");
   rprintf(F,"     --protocol=NUM          force an older protocol version to be used\n");
-#ifdef INET6
+#ifdef ICONV_OPTION
+  rprintf(F,"     --iconv=CONVERT_SPEC    request charset conversion of filenames\n");
+#endif
   rprintf(F," -4, --ipv4                  prefer IPv4\n");
   rprintf(F," -6, --ipv6                  prefer IPv6\n");
-#endif
   rprintf(F,"     --version               print version number\n");
   rprintf(F,"(-h) --help                  show this help (-h works with no other options)\n");
 
   rprintf(F,"\n");
   rprintf(F,"Use \"rsync --daemon --help\" to see the daemon-mode command-line options.\n");
   rprintf(F,"Please see the rsync(1) and rsyncd.conf(5) man pages for full documentation.\n");
@@ -395,13 +442,13 @@
 }
 
 enum {OPT_VERSION = 1000, OPT_DAEMON, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_FILTER, OPT_COMPARE_DEST, OPT_COPY_DEST, OPT_LINK_DEST, OPT_HELP,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW, OPT_MIN_SIZE, OPT_CHMOD,
       OPT_READ_BATCH, OPT_WRITE_BATCH, OPT_ONLY_WRITE_BATCH, OPT_MAX_SIZE,
-      OPT_NO_D,
+      OPT_NO_D, OPT_APPEND, OPT_NO_ICONV,
       OPT_SERVER, OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"help",             0,  POPT_ARG_NONE,   0, OPT_HELP, 0, 0 },
   {"version",          0,  POPT_ARG_NONE,   0, OPT_VERSION, 0, 0},
@@ -410,31 +457,46 @@
   {"no-v",             0,  POPT_ARG_VAL,    &verbose, 0, 0, 0 },
   {"quiet",           'q', POPT_ARG_NONE,   0, 'q', 0, 0 },
   {"motd",             0,  POPT_ARG_VAL,    &output_motd, 1, 0, 0 },
   {"no-motd",          0,  POPT_ARG_VAL,    &output_motd, 0, 0, 0 },
   {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
   {"human-readable",  'h', POPT_ARG_NONE,   0, 'h', 0, 0},
+  {"no-human-readable",0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},
+  {"no-h",             0,  POPT_ARG_VAL,    &human_readable, 0, 0, 0},
   {"dry-run",         'n', POPT_ARG_NONE,   &dry_run, 0, 0, 0 },
   {"archive",         'a', POPT_ARG_NONE,   0, 'a', 0, 0 },
   {"recursive",       'r', POPT_ARG_VAL,    &recurse, 2, 0, 0 },
   {"no-recursive",     0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },
   {"no-r",             0,  POPT_ARG_VAL,    &recurse, 0, 0, 0 },
+  {"inc-recursive",    0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },
+  {"no-inc-recursive", 0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },
+  {"i-r",              0,  POPT_ARG_VAL,    &allow_inc_recurse, 1, 0, 0 },
+  {"no-i-r",           0,  POPT_ARG_VAL,    &allow_inc_recurse, 0, 0, 0 },
   {"dirs",            'd', POPT_ARG_VAL,    &xfer_dirs, 2, 0, 0 },
   {"no-dirs",          0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
   {"no-d",             0,  POPT_ARG_VAL,    &xfer_dirs, 0, 0, 0 },
   {"perms",           'p', POPT_ARG_VAL,    &preserve_perms, 1, 0, 0 },
   {"no-perms",         0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
   {"no-p",             0,  POPT_ARG_VAL,    &preserve_perms, 0, 0, 0 },
   {"executability",   'E', POPT_ARG_NONE,   &preserve_executability, 0, 0, 0 },
-  {"times",           't', POPT_ARG_VAL,    &preserve_times, 1, 0, 0 },
+  {"acls",            'A', POPT_ARG_NONE,   0, 'A', 0, 0 },
+  {"no-acls",          0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
+  {"no-A",             0,  POPT_ARG_VAL,    &preserve_acls, 0, 0, 0 },
+  {"xattrs",          'X', POPT_ARG_NONE,   0, 'X', 0, 0 },
+  {"no-xattrs",        0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
+  {"no-X",             0,  POPT_ARG_VAL,    &preserve_xattrs, 0, 0, 0 },
+  {"times",           't', POPT_ARG_VAL,    &preserve_times, 2, 0, 0 },
   {"no-times",         0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
   {"no-t",             0,  POPT_ARG_VAL,    &preserve_times, 0, 0, 0 },
-  {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 2, 0, 0 },
+  {"omit-dir-times",  'O', POPT_ARG_VAL,    &omit_dir_times, 1, 0, 0 },
+  {"no-omit-dir-times",0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },
+  {"no-O",             0,  POPT_ARG_VAL,    &omit_dir_times, 0, 0, 0 },
   {"modify-window",    0,  POPT_ARG_INT,    &modify_window, OPT_MODIFY_WINDOW, 0, 0 },
   {"super",            0,  POPT_ARG_VAL,    &am_root, 2, 0, 0 },
   {"no-super",         0,  POPT_ARG_VAL,    &am_root, 0, 0, 0 },
+  {"fake-super",       0,  POPT_ARG_VAL,    &am_root, -1, 0, 0 },
   {"owner",           'o', POPT_ARG_VAL,    &preserve_uid, 1, 0, 0 },
   {"no-owner",         0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
   {"no-o",             0,  POPT_ARG_VAL,    &preserve_uid, 0, 0, 0 },
   {"group",           'g', POPT_ARG_VAL,    &preserve_gid, 1, 0, 0 },
   {"no-group",         0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },
   {"no-g",             0,  POPT_ARG_VAL,    &preserve_gid, 0, 0, 0 },
@@ -449,37 +511,44 @@
   {"no-l",             0,  POPT_ARG_VAL,    &preserve_links, 0, 0, 0 },
   {"copy-links",      'L', POPT_ARG_NONE,   &copy_links, 0, 0, 0 },
   {"copy-unsafe-links",0,  POPT_ARG_NONE,   &copy_unsafe_links, 0, 0, 0 },
   {"safe-links",       0,  POPT_ARG_NONE,   &safe_symlinks, 0, 0, 0 },
   {"copy-dirlinks",   'k', POPT_ARG_NONE,   &copy_dirlinks, 0, 0, 0 },
   {"keep-dirlinks",   'K', POPT_ARG_NONE,   &keep_dirlinks, 0, 0, 0 },
-  {"hard-links",      'H', POPT_ARG_VAL,    &preserve_hard_links, 1, 0, 0 },
+  {"hard-links",      'H', POPT_ARG_NONE,   0, 'H', 0, 0 },
   {"no-hard-links",    0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
   {"no-H",             0,  POPT_ARG_VAL,    &preserve_hard_links, 0, 0, 0 },
   {"relative",        'R', POPT_ARG_VAL,    &relative_paths, 1, 0, 0 },
   {"no-relative",      0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
   {"no-R",             0,  POPT_ARG_VAL,    &relative_paths, 0, 0, 0 },
   {"implied-dirs",     0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },
   {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
+  {"i-d",              0,  POPT_ARG_VAL,    &implied_dirs, 1, 0, 0 },
+  {"no-i-d",           0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
   {"chmod",            0,  POPT_ARG_STRING, 0, OPT_CHMOD, 0, 0 },
   {"ignore-times",    'I', POPT_ARG_NONE,   &ignore_times, 0, 0, 0 },
   {"size-only",        0,  POPT_ARG_NONE,   &size_only, 0, 0, 0 },
   {"one-file-system", 'x', POPT_ARG_NONE,   0, 'x', 0, 0 },
+  {"no-one-file-system",'x',POPT_ARG_VAL,   &one_file_system, 0, 0, 0 },
+  {"no-x",            'x', POPT_ARG_VAL,    &one_file_system, 0, 0, 0 },
   {"update",          'u', POPT_ARG_NONE,   &update_only, 0, 0, 0 },
   {"existing",         0,  POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
   {"ignore-non-existing",0,POPT_ARG_NONE,   &ignore_non_existing, 0, 0, 0 },
   {"ignore-existing",  0,  POPT_ARG_NONE,   &ignore_existing, 0, 0, 0 },
   {"max-size",         0,  POPT_ARG_STRING, &max_size_arg, OPT_MAX_SIZE, 0, 0 },
   {"min-size",         0,  POPT_ARG_STRING, &min_size_arg, OPT_MIN_SIZE, 0, 0 },
   {"sparse",          'S', POPT_ARG_NONE,   &sparse_files, 0, 0, 0 },
   {"inplace",          0,  POPT_ARG_NONE,   &inplace, 0, 0, 0 },
-  {"append",           0,  POPT_ARG_VAL,    &append_mode, 1, 0, 0 },
+  {"append",           0,  POPT_ARG_NONE,   0, OPT_APPEND, 0, 0 },
+  {"append-verify",    0,  POPT_ARG_VAL,    &append_mode, 2, 0, 0 },
+  {"no-append",        0,  POPT_ARG_VAL,    &append_mode, 0, 0, 0 },
   {"del",              0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
   {"delete",           0,  POPT_ARG_NONE,   &delete_mode, 0, 0, 0 },
-  {"delete-before",    0,  POPT_ARG_VAL,    &delete_before, 2, 0, 0 },
-  {"delete-during",    0,  POPT_ARG_NONE,   &delete_during, 0, 0, 0 },
+  {"delete-before",    0,  POPT_ARG_NONE,   &delete_before, 0, 0, 0 },
+  {"delete-during",    0,  POPT_ARG_VAL,    &delete_during, 1, 0, 0 },
+  {"delete-delay",     0,  POPT_ARG_VAL,    &delete_during, 2, 0, 0 },
   {"delete-after",     0,  POPT_ARG_NONE,   &delete_after, 0, 0, 0 },
   {"delete-excluded",  0,  POPT_ARG_NONE,   &delete_excluded, 0, 0, 0 },
   {"remove-sent-files",0,  POPT_ARG_VAL,    &remove_source_files, 2, 0, 0 }, /* deprecated */
   {"remove-source-files",0,POPT_ARG_VAL,    &remove_source_files, 1, 0, 0 },
   {"force",            0,  POPT_ARG_NONE,   &force_delete, 0, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
@@ -491,53 +560,73 @@
   {"exclude-from",     0,  POPT_ARG_STRING, 0, OPT_EXCLUDE_FROM, 0, 0 },
   {"include-from",     0,  POPT_ARG_STRING, 0, OPT_INCLUDE_FROM, 0, 0 },
   {"cvs-exclude",     'C', POPT_ARG_NONE,   &cvs_exclude, 0, 0, 0 },
   {"whole-file",      'W', POPT_ARG_VAL,    &whole_file, 1, 0, 0 },
   {"no-whole-file",    0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
   {"no-W",             0,  POPT_ARG_VAL,    &whole_file, 0, 0, 0 },
-  {"checksum",        'c', POPT_ARG_NONE,   &always_checksum, 0, 0, 0 },
+  {"checksum",        'c', POPT_ARG_VAL,    &always_checksum, 1, 0, 0 },
+  {"no-checksum",      0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
+  {"no-c",             0,  POPT_ARG_VAL,    &always_checksum, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_LONG,   &block_size, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, 0, OPT_COMPARE_DEST, 0, 0 },
   {"copy-dest",        0,  POPT_ARG_STRING, 0, OPT_COPY_DEST, 0, 0 },
   {"link-dest",        0,  POPT_ARG_STRING, 0, OPT_LINK_DEST, 0, 0 },
   {"fuzzy",           'y', POPT_ARG_NONE,   &fuzzy_basis, 0, 0, 0 },
   {"compress",        'z', POPT_ARG_NONE,   0, 'z', 0, 0 },
+  {"no-compress",      0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
+  {"skip-compress",    0,  POPT_ARG_STRING, &skip_compress, 0, 0, 0 },
+  {"no-z",             0,  POPT_ARG_VAL,    &do_compression, 0, 0, 0 },
   {"compress-level",   0,  POPT_ARG_INT,    &def_compress_level, 'z', 0, 0 },
   {0,                 'P', POPT_ARG_NONE,   0, 'P', 0, 0 },
   {"progress",         0,  POPT_ARG_VAL,    &do_progress, 1, 0, 0 },
   {"no-progress",      0,  POPT_ARG_VAL,    &do_progress, 0, 0, 0 },
   {"partial",          0,  POPT_ARG_VAL,    &keep_partial, 1, 0, 0 },
   {"no-partial",       0,  POPT_ARG_VAL,    &keep_partial, 0, 0, 0 },
   {"partial-dir",      0,  POPT_ARG_STRING, &partial_dir, 0, 0, 0 },
-  {"delay-updates",    0,  POPT_ARG_NONE,   &delay_updates, 0, 0, 0 },
+  {"delay-updates",    0,  POPT_ARG_VAL,    &delay_updates, 1, 0, 0 },
+  {"no-delay-updates", 0,  POPT_ARG_VAL,    &delay_updates, 0, 0, 0 },
   {"prune-empty-dirs",'m', POPT_ARG_NONE,   &prune_empty_dirs, 0, 0, 0 },
   {"log-file",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },
   {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
   {"out-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 },
   {"log-format",       0,  POPT_ARG_STRING, &stdout_format, 0, 0, 0 }, /* DEPRECATED */
   {"itemize-changes", 'i', POPT_ARG_NONE,   0, 'i', 0, 0 },
+  {"no-itemize-changes",0, POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
+  {"no-i",             0,  POPT_ARG_VAL,    &itemize_changes, 0, 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &bwlimit, 0, 0, 0 },
-  {"backup",          'b', POPT_ARG_NONE,   &make_backups, 0, 0, 0 },
+  {"no-bwlimit",       0,  POPT_ARG_VAL,    &bwlimit, 0, 0, 0 },
+  {"backup",          'b', POPT_ARG_VAL,    &make_backups, 1, 0, 0 },
+  {"no-backup",        0,  POPT_ARG_VAL,    &make_backups, 0, 0, 0 },
   {"backup-dir",       0,  POPT_ARG_STRING, &backup_dir, 0, 0, 0 },
   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
   {"list-only",        0,  POPT_ARG_VAL,    &list_only, 2, 0, 0 },
   {"read-batch",       0,  POPT_ARG_STRING, &batch_name, OPT_READ_BATCH, 0, 0 },
   {"write-batch",      0,  POPT_ARG_STRING, &batch_name, OPT_WRITE_BATCH, 0, 0 },
   {"only-write-batch", 0,  POPT_ARG_STRING, &batch_name, OPT_ONLY_WRITE_BATCH, 0, 0 },
   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
-  {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
-  {"numeric-ids",      0,  POPT_ARG_NONE,   &numeric_ids, 0, 0, 0 },
+  {"from0",           '0', POPT_ARG_VAL,    &eol_nulls, 1, 0, 0},
+  {"no-from0",         0,  POPT_ARG_VAL,    &eol_nulls, 0, 0, 0},
+  {"protect-args",    's', POPT_ARG_VAL,    &protect_args, 1, 0, 0},
+  {"no-protect-args",  0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
+  {"no-s",             0,  POPT_ARG_VAL,    &protect_args, 0, 0, 0},
+  {"numeric-ids",      0,  POPT_ARG_VAL,    &numeric_ids, 1, 0, 0 },
+  {"no-numeric-ids",   0,  POPT_ARG_VAL,    &numeric_ids, 0, 0, 0 },
   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
+  {"no-timeout",       0,  POPT_ARG_VAL,    &io_timeout, 0, 0, 0 },
+  {"contimeout",       0,  POPT_ARG_INT,    &connect_timeout, 0, 0, 0 },
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path, 0, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
-#ifdef INET6
+#ifdef ICONV_OPTION
+  {"iconv",            0,  POPT_ARG_STRING, &iconv_opt, 0, 0, 0 },
+  {"no-iconv",         0,  POPT_ARG_NONE,   0, OPT_NO_ICONV, 0, 0 },
+#endif
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
-#endif
   {"8-bit-output",    '8', POPT_ARG_NONE,   &allow_8bit_chars, 0, 0, 0 },
+  {"qsort",            0,  POPT_ARG_NONE,   &use_qsort, 0, 0, 0 },
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
   {"password-file",    0,  POPT_ARG_STRING, &password_file, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
   {"no-blocking-io",   0,  POPT_ARG_VAL,    &blocking_io, 0, 0, 0 },
@@ -565,16 +654,14 @@
   rprintf(F,"     --no-detach             do not detach from the parent\n");
   rprintf(F,"     --port=PORT             listen on alternate port number\n");
   rprintf(F,"     --log-file=FILE         override the \"log file\" setting\n");
   rprintf(F,"     --log-file-format=FMT   override the \"log format\" setting\n");
   rprintf(F,"     --sockopts=OPTIONS      specify custom TCP options\n");
   rprintf(F," -v, --verbose               increase verbosity\n");
-#ifdef INET6
   rprintf(F," -4, --ipv4                  prefer IPv4\n");
   rprintf(F," -6, --ipv6                  prefer IPv6\n");
-#endif
   rprintf(F,"     --help                  show this help screen\n");
 
   rprintf(F,"\n");
   rprintf(F,"If you were not trying to invoke rsync as a daemon, avoid using any of the\n");
   rprintf(F,"daemon-specific rsync options.  See also the rsyncd.conf(5) man page.\n");
 }
@@ -582,20 +669,18 @@
 static struct poptOption long_daemon_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"address",          0,  POPT_ARG_STRING, &bind_address, 0, 0, 0 },
   {"bwlimit",          0,  POPT_ARG_INT,    &daemon_bwlimit, 0, 0, 0 },
   {"config",           0,  POPT_ARG_STRING, &config_file, 0, 0, 0 },
   {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
-#ifdef INET6
   {"ipv4",            '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
   {"ipv6",            '6', POPT_ARG_VAL,    &default_af_hint, AF_INET6, 0, 0 },
-#endif
   {"detach",           0,  POPT_ARG_VAL,    &no_detach, 0, 0, 0 },
+  {"no-detach",        0,  POPT_ARG_VAL,    &no_detach, 1, 0, 0 },
   {"log-file",         0,  POPT_ARG_STRING, &logfile_name, 0, 0, 0 },
   {"log-file-format",  0,  POPT_ARG_STRING, &logfile_format, 0, 0, 0 },
-  {"no-detach",        0,  POPT_ARG_VAL,    &no_detach, 1, 0, 0 },
   {"port",             0,  POPT_ARG_INT,    &rsync_port, 0, 0, 0 },
   {"sockopts",         0,  POPT_ARG_STRING, &sockopts, 0, 0, 0 },
   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
   {"server",           0,  POPT_ARG_NONE,   &am_server, 0, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"verbose",         'v', POPT_ARG_NONE,   0, 'v', 0, 0 },
@@ -669,18 +754,22 @@
 					break;
 				case '\0':
 					if (wildmatch("delete", op->longName))
 						refused_delete = op->val;
 					else if (wildmatch("delete-before", op->longName))
 						refused_delete_before = op->val;
+					else if (wildmatch("delete-during", op->longName))
+						refused_delete_during = op->val;
 					else if (wildmatch("partial", op->longName))
 						refused_partial = op->val;
 					else if (wildmatch("progress", op->longName))
 						refused_progress = op->val;
 					else if (wildmatch("inplace", op->longName))
 						refused_inplace = op->val;
+					else if (wildmatch("no-iconv", op->longName))
+						refused_no_iconv = op->val;
 					break;
 				}
 				if (!is_wild)
 					break;
 			}
 		}
@@ -712,15 +801,15 @@
 static OFF_T parse_size_arg(char **size_arg, char def_suf)
 {
 	int reps, mult, make_compatible = 0;
 	const char *arg;
 	OFF_T size = 1;
 
-	for (arg = *size_arg; isdigit(*(uchar*)arg); arg++) {}
+	for (arg = *size_arg; isDigit(arg); arg++) {}
 	if (*arg == '.')
-		for (arg++; isdigit(*(uchar*)arg); arg++) {}
+		for (arg++; isDigit(arg); arg++) {}
 	switch (*arg && *arg != '+' && *arg != '-' ? *arg++ : def_suf) {
 	case 'b': case 'B':
 		reps = 0;
 		break;
 	case 'k': case 'K':
 		reps = 1;
@@ -753,13 +842,13 @@
 		/* We convert this manually because we may need %lld precision,
 		 * and that's not a portable sprintf() escape. */
 		char buf[128], *s = buf + sizeof buf - 1;
 		OFF_T num = size;
 		*s = '\0';
 		while (num) {
-			*--s = (num % 10) + '0';
+			*--s = (char)(num % 10) + '0';
 			num /= 10;
 		}
 		if (!(*size_arg = strdup(s)))
 			out_of_memory("parse_size_arg");
 	}
 	return size;
@@ -785,30 +874,42 @@
  *
  * @retval 1 if all options are OK; with globals set to appropriate
  * values
  *
  * @retval 0 on error, with err_buf containing an explanation
  **/
-int parse_arguments(int *argc, const char ***argv, int frommain)
+int parse_arguments(int *argc_p, const char ***argv_p, int frommain)
 {
-	int opt;
+	static poptContext pc;
 	char *ref = lp_refuse_options(module_id);
-	const char *arg;
-	poptContext pc;
+	const char *arg, **argv = *argv_p;
+	int argc = *argc_p;
+	int opt;
 
 	if (ref && *ref)
 		set_refuse_options(ref);
-	if (am_daemon)
+	if (am_daemon) {
 		set_refuse_options("log-file*");
+		if (!*lp_charset(module_id))
+			set_refuse_options("iconv");
+	}
+
+#ifdef ICONV_OPTION
+	if (!am_daemon && !protect_args && (arg = getenv("RSYNC_ICONV")) != NULL && *arg)
+		iconv_opt = strdup(arg);
+#endif
 
 	/* TODO: Call poptReadDefaultConfig; handle errors. */
 
 	/* The context leaks in case of an error, but if there's a
 	 * problem we always exit anyhow. */
-	pc = poptGetContext(RSYNC_NAME, *argc, *argv, long_options, 0);
-	poptReadDefaultConfig(pc, 0);
+	if (pc)
+		poptFreeContext(pc);
+	pc = poptGetContext(RSYNC_NAME, argc, argv, long_options, 0);
+	if (!am_server)
+		poptReadDefaultConfig(pc, 0);
 
 	while ((opt = poptGetNextOpt(pc)) != -1) {
 		/* most options are handled automatically by popt;
 		 * only special cases are returned and listed here. */
 
 		switch (opt) {
@@ -818,16 +919,19 @@
 
 		case OPT_SERVER:
 			if (!am_server) {
 				/* Disable popt aliases on the server side and
 				 * then start parsing the options again. */
 				poptFreeContext(pc);
-				pc = poptGetContext(RSYNC_NAME, *argc, *argv,
+				pc = poptGetContext(RSYNC_NAME, argc, argv,
 						    long_options, 0);
 				am_server = 1;
 			}
+#ifdef ICONV_OPTION
+			iconv_opt = NULL;
+#endif
 			break;
 
 		case OPT_SENDER:
 			if (!am_server) {
 				usage(FERROR);
 				exit_cleanup(RERR_SYNTAX);
@@ -839,14 +943,17 @@
 			if (am_daemon) {
 				strlcpy(err_buf,
 					"Attempt to hack rsync thwarted!\n",
 					sizeof err_buf);
 				return 0;
 			}
+#ifdef ICONV_OPTION
+			iconv_opt = NULL;
+#endif
 			poptFreeContext(pc);
-			pc = poptGetContext(RSYNC_NAME, *argc, *argv,
+			pc = poptGetContext(RSYNC_NAME, argc, argv,
 					    long_daemon_options, 0);
 			while ((opt = poptGetNextOpt(pc)) != -1) {
 				switch (opt) {
 				case 'h':
 					daemon_usage(FINFO);
 					exit_cleanup(0);
@@ -875,14 +982,14 @@
 			    daemon_error:
 				rprintf(FERROR,
 				    "(Type \"rsync --daemon --help\" for assistance with daemon mode.)\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
 
-			*argv = poptGetArgs(pc);
-			*argc = count_args(*argv);
+			*argv_p = argv = poptGetArgs(pc);
+			*argc_p = argc = count_args(argv);
 			am_starting_up = 0;
 			daemon_opt = 0;
 			am_daemon = 1;
 			return 1;
 
 		case OPT_MODIFY_WINDOW:
@@ -907,23 +1014,26 @@
 			break;
 
 		case OPT_EXCLUDE_FROM:
 		case OPT_INCLUDE_FROM:
 			arg = poptGetOptArg(pc);
 			if (sanitize_paths)
-				arg = sanitize_path(NULL, arg, NULL, 0, NULL);
+				arg = sanitize_path(NULL, arg, NULL, 0);
 			if (server_filter_list.head) {
-				char *cp = strdup(arg);
+				int rej;
+				char *dir, *cp = strdup(arg);
 				if (!cp)
 					out_of_memory("parse_arguments");
 				if (!*cp)
 					goto options_rejected;
-				clean_fname(cp, 1);
-				if (check_filter(&server_filter_list, cp, 0) < 0)
-					goto options_rejected;
+				dir = cp + (*cp == '/' ? module_dirlen : 0);
+				clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
+				rej = check_filter(&server_filter_list, dir, 0) < 0;
 				free(cp);
+				if (rej)
+					goto options_rejected;
 			}
 			parse_filter_file(&filter_list, arg,
 				opt == OPT_INCLUDE_FROM ? MATCHFLG_INCLUDE : 0,
 				XFLG_FATAL_ERRORS | XFLG_OLD_PREFIXES);
 			break;
 
@@ -935,13 +1045,13 @@
 			if (!recurse) /* preserve recurse == 2 */
 				recurse = 1;
 #ifdef SUPPORT_LINKS
 			preserve_links = 1;
 #endif
 			preserve_perms = 1;
-			preserve_times = 1;
+			preserve_times = 2;
 			preserve_gid = 1;
 			preserve_uid = 1;
 			preserve_devices = 1;
 			preserve_specials = 1;
 			break;
 
@@ -954,12 +1064,16 @@
 			break;
 
 		case 'h':
 			human_readable++;
 			break;
 
+		case 'H':
+			preserve_hard_links++;
+			break;
+
 		case 'i':
 			itemize_changes++;
 			break;
 
 		case 'v':
 			verbose++;
@@ -1022,12 +1136,18 @@
 
 		case OPT_READ_BATCH:
 			/* batch_name is already set */
 			read_batch = 1;
 			break;
 
+		case OPT_NO_ICONV:
+#ifdef ICONV_OPTION
+			iconv_opt = NULL;
+#endif
+			break;
+
 		case OPT_MAX_SIZE:
 			if ((max_size = parse_size_arg(&max_size_arg, 'b')) <= 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"--max-size value is invalid: %s\n",
 					max_size_arg);
 				return 0;
@@ -1040,12 +1160,19 @@
 					"--min-size value is invalid: %s\n",
 					min_size_arg);
 				return 0;
 			}
 			break;
 
+		case OPT_APPEND:
+			if (am_server)
+				append_mode++;
+			else
+				append_mode = 1;
+			break;
+
 		case OPT_LINK_DEST:
 #ifdef SUPPORT_HARD_LINKS
 			link_dest = 1;
 			dest_option = "--link-dest";
 			goto set_dest_dir;
 #else
@@ -1086,12 +1213,40 @@
 			break;
 
 		case OPT_HELP:
 			usage(FINFO);
 			exit_cleanup(0);
 
+		case 'A':
+#ifdef SUPPORT_ACLS
+			preserve_acls = 1;
+			preserve_perms = 1;
+			break;
+#else
+			/* FIXME: this should probably be ignored with a
+			 * warning and then countermeasures taken to
+			 * restrict group and other access in the presence
+			 * of any more restrictive ACLs, but this is safe
+			 * for now */
+			snprintf(err_buf,sizeof(err_buf),
+                                 "ACLs are not supported on this %s\n",
+				 am_server ? "server" : "client");
+			return 0;
+#endif
+
+		case 'X':
+#ifdef SUPPORT_XATTRS
+			preserve_xattrs++;
+			break;
+#else
+			snprintf(err_buf,sizeof(err_buf),
+				 "extended attributes are not supported on this %s\n",
+				 am_server ? "server" : "client");
+			return 0;
+#endif
+
 		default:
 			/* A large opt value means that set_refuse_options()
 			 * turned this option off. */
 			if (opt >= OPT_REFUSED_BASE) {
 				create_refuse_error(opt);
 				return 0;
@@ -1101,18 +1256,38 @@
 				 poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 				 poptStrerror(opt));
 			return 0;
 		}
 	}
 
-	if (human_readable && *argc == 2) {
+	if (human_readable && argc == 2) {
 		/* Allow the old meaning of 'h' (--help) on its own. */
 		usage(FINFO);
 		exit_cleanup(0);
 	}
 
+#ifdef ICONV_OPTION
+	if (iconv_opt && protect_args != 2) {
+		if (!am_server && strcmp(iconv_opt, "-") == 0)
+			iconv_opt = NULL;
+		else
+			need_unsorted_flist = 1;
+	}
+	if (refused_no_iconv && !iconv_opt) {
+		create_refuse_error(refused_no_iconv);
+		return 0;
+	}
+#endif
+
+	if (protect_args == 1) {
+		if (!frommain)
+			protect_args = 0;
+		else if (am_server)
+			return 1;
+	}
+
 #ifndef SUPPORT_LINKS
 	if (preserve_links && !am_sender) {
 		snprintf(err_buf, sizeof err_buf,
 			 "symlinks are not supported on this %s\n",
 			 am_server ? "server" : "client");
 		return 0;
@@ -1125,12 +1300,20 @@
 			 "hard links are not supported on this %s\n",
 			 am_server ? "server" : "client");
 		return 0;
 	}
 #endif
 
+#ifndef SUPPORT_XATTRS
+	if (am_root < 0) {
+		snprintf(err_buf, sizeof err_buf,
+			 "--fake-super requires an rsync with extended attributes enabled\n");
+		return 0;
+	}
+#endif
+
 	if (write_batch && read_batch) {
 		snprintf(err_buf, sizeof err_buf,
 			"--write-batch and --read-batch can not be used together\n");
 		return 0;
 	}
 	if (write_batch > 0 || read_batch) {
@@ -1142,13 +1325,14 @@
 			 * still service older version clients that still send
 			 * batch args to server. */
 			read_batch = write_batch = 0;
 			batch_name = NULL;
 		} else if (dry_run)
 			write_batch = 0;
-	}
+	} else if (write_batch < 0 && dry_run)
+		write_batch = 0;
 	if (read_batch && files_from) {
 		snprintf(err_buf, sizeof err_buf,
 			"--read-batch cannot be used with --files-from\n");
 		return 0;
 	}
 	if (batch_name && strlen(batch_name) > MAX_BATCH_NAME_LEN) {
@@ -1161,12 +1345,17 @@
 	if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
 		snprintf(err_buf, sizeof err_buf,
 			 "the --temp-dir path is WAY too long.\n");
 		return 0;
 	}
 
+	if (max_delete < 0 && max_delete != INT_MIN) {
+		/* Negative numbers are treated as "no deletions". */
+		max_delete = 0;
+	}
+
 	if (compare_dest + copy_dest + link_dest > 1) {
 		snprintf(err_buf, sizeof err_buf,
 			"You may not mix --compare-dest, --copy-dest, and --link-dest.\n");
 		return 0;
 	}
 
@@ -1182,25 +1371,31 @@
 
 	if (relative_paths < 0)
 		relative_paths = files_from? 1 : 0;
 	if (!relative_paths)
 		implied_dirs = 0;
 
-	if (!!delete_before + delete_during + delete_after > 1) {
+	if (delete_before + !!delete_during + delete_after > 1) {
 		snprintf(err_buf, sizeof err_buf,
 			"You may not combine multiple --delete-WHEN options.\n");
 		return 0;
 	}
 	if (delete_before || delete_during || delete_after)
 		delete_mode = 1;
 	else if (delete_mode || delete_excluded) {
+		/* Only choose now between before & during if one is refused. */
 		if (refused_delete_before) {
-			create_refuse_error(refused_delete_before);
-			return 0;
-		}
-		delete_mode = delete_before = 1;
+			if (!refused_delete_during)
+				delete_during = 1;
+			else {
+				create_refuse_error(refused_delete_before);
+				return 0;
+			}
+		} else if (refused_delete_during)
+			delete_before = 1;
+		delete_mode = 1;
 	}
 	if (!xfer_dirs && delete_mode) {
 		snprintf(err_buf, sizeof err_buf,
 			"--delete does not work without -r or -d.\n");
 		return 0;
 	}
@@ -1218,43 +1413,43 @@
 			create_refuse_error(refused_delete);
 			return 0;
 		}
 		need_messages_from_generator = 1;
 	}
 
-	*argv = poptGetArgs(pc);
-	*argc = count_args(*argv);
+	*argv_p = argv = poptGetArgs(pc);
+	*argc_p = argc = count_args(argv);
 
 	if (sanitize_paths) {
 		int i;
-		for (i = *argc; i-- > 0; )
-			(*argv)[i] = sanitize_path(NULL, (*argv)[i], "", 0, NULL);
+		for (i = argc; i-- > 0; )
+			argv[i] = sanitize_path(NULL, argv[i], "", 0);
 		if (tmpdir)
-			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0, NULL);
+			tmpdir = sanitize_path(NULL, tmpdir, NULL, 0);
 		if (backup_dir)
-			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0, NULL);
+			backup_dir = sanitize_path(NULL, backup_dir, NULL, 0);
 	}
 	if (server_filter_list.head && !am_sender) {
 		struct filter_list_struct *elp = &server_filter_list;
 		if (tmpdir) {
+			char *dir;
 			if (!*tmpdir)
 				goto options_rejected;
-			clean_fname(tmpdir, 1);
-			if (check_filter(elp, tmpdir, 1) < 0)
+			dir = tmpdir + (*tmpdir == '/' ? module_dirlen : 0);
+			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
+			if (check_filter(elp, dir, 1) < 0)
 				goto options_rejected;
 		}
 		if (backup_dir) {
+			char *dir;
 			if (!*backup_dir)
 				goto options_rejected;
-			clean_fname(backup_dir, 1);
-			if (check_filter(elp, backup_dir, 1) < 0) {
-			    options_rejected:
-				snprintf(err_buf, sizeof err_buf,
-				    "Your options have been rejected by the server.\n");
-				return 0;
-			}
+			dir = backup_dir + (*backup_dir == '/' ? module_dirlen : 0);
+			clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
+			if (check_filter(elp, dir, 1) < 0)
+				goto options_rejected;
 		}
 	}
 
 	if (!backup_suffix)
 		backup_suffix = backup_dir ? "" : BACKUP_SUFFIX;
 	backup_suffix_len = strlen(backup_suffix);
@@ -1279,19 +1474,26 @@
 		if (verbose > 1 && !am_sender)
 			rprintf(FINFO, "backup_dir is %s\n", backup_dir_buf);
 	} else if (!backup_suffix_len && (!am_server || !am_sender)) {
 		snprintf(err_buf, sizeof err_buf,
 			"--suffix cannot be a null string without --backup-dir\n");
 		return 0;
-	} else if (make_backups && delete_mode && !delete_excluded) {
+	} else if (make_backups && delete_mode && !delete_excluded && !am_server) {
 		snprintf(backup_dir_buf, sizeof backup_dir_buf,
 			"P *%s", backup_suffix);
 		parse_rule(&filter_list, backup_dir_buf, 0, 0);
 	}
-	if (make_backups && !backup_dir)
-		omit_dir_times = 1;
+
+	if (make_backups && !backup_dir) {
+		omit_dir_times = 0; /* Implied, so avoid -O to sender. */
+		if (preserve_times > 1)
+			preserve_times = 1;
+	} else if (omit_dir_times) {
+		if (preserve_times > 1)
+			preserve_times = 1;
+	}
 
 	if (stdout_format) {
 		if (am_server && log_format_has(stdout_format, 'I'))
 			stdout_format_has_i = 2;
 		else if (log_format_has(stdout_format, 'i'))
 			stdout_format_has_i = itemize_changes | 1;
@@ -1392,31 +1594,27 @@
 		if (keep_partial && !partial_dir && !am_server) {
 			if ((arg = getenv("RSYNC_PARTIAL_DIR")) != NULL && *arg)
 				partial_dir = strdup(arg);
 		}
 		if (partial_dir) {
 			if (*partial_dir)
-				clean_fname(partial_dir, 1);
+				clean_fname(partial_dir, CFN_COLLAPSE_DOT_DOT_DIRS);
 			if (!*partial_dir || strcmp(partial_dir, ".") == 0)
 				partial_dir = NULL;
-			else if (*partial_dir != '/' && !am_server) {
-				parse_rule(&filter_list, partial_dir,
-				    MATCHFLG_NO_PREFIXES|MATCHFLG_DIRECTORY, 0);
-			}
 			if (!partial_dir && refused_partial) {
 				create_refuse_error(refused_partial);
 				return 0;
 			}
 			keep_partial = 1;
 		}
 	}
 
 	if (files_from) {
 		char *h, *p;
 		int q;
-		if (*argc > 2 || (!am_daemon && *argc == 1)) {
+		if (argc > 2 || (!am_daemon && argc == 1)) {
 			usage(FERROR);
 			exit_cleanup(RERR_SYNTAX);
 		}
 		if (strcmp(files_from, "-") == 0) {
 			filesfrom_fd = 0;
 			if (am_server)
@@ -1433,18 +1631,20 @@
 				snprintf(err_buf, sizeof err_buf,
 					"Invalid --files-from remote filename\n");
 				return 0;
 			}
 		} else {
 			if (sanitize_paths)
-				files_from = sanitize_path(NULL, files_from, NULL, 0, NULL);
+				files_from = sanitize_path(NULL, files_from, NULL, 0);
 			if (server_filter_list.head) {
+				char *dir;
 				if (!*files_from)
 					goto options_rejected;
-				clean_fname(files_from, 1);
-				if (check_filter(&server_filter_list, files_from, 0) < 0)
+				dir = files_from + (*files_from == '/' ? module_dirlen : 0);
+				clean_fname(dir, CFN_COLLAPSE_DOT_DOT_DIRS);
+				if (check_filter(&server_filter_list, dir, 0) < 0)
 					goto options_rejected;
 			}
 			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
 			if (filesfrom_fd < 0) {
 				snprintf(err_buf, sizeof err_buf,
 					"failed to open files-from file %s: %s\n",
@@ -1454,69 +1654,75 @@
 		}
 	}
 
 	am_starting_up = 0;
 
 	return 1;
+
+  options_rejected:
+	snprintf(err_buf, sizeof err_buf,
+		"Your options have been rejected by the server.\n");
+	return 0;
 }
 
 
 /**
  * Construct a filtered list of options to pass through from the
  * client to the server.
  *
  * This involves setting options that will tell the server how to
  * behave, and also filtering out options that are processed only
  * locally.
  **/
-void server_options(char **args,int *argc)
+void server_options(char **args, int *argc_p)
 {
 	static char argstr[64];
-	int ac = *argc;
+	int ac = *argc_p;
 	char *arg;
-
 	int i, x;
 
-	if (blocking_io == -1)
-		blocking_io = 0;
-
 	/* This should always remain first on the server's command-line. */
 	args[ac++] = "--server";
 
-	if (daemon_over_rsh) {
+	if (daemon_over_rsh > 0) {
 		args[ac++] = "--daemon";
-		*argc = ac;
+		*argc_p = ac;
 		/* if we're passing --daemon, we're done */
 		return;
 	}
 
 	if (!am_sender)
 		args[ac++] = "--sender";
 
 	x = 1;
 	argstr[0] = '-';
+
+	if (protect_args)
+		argstr[x++] = 's';
+
 	for (i = 0; i < verbose; i++)
 		argstr[x++] = 'v';
 
 	/* the -q option is intentionally left out */
 	if (make_backups)
 		argstr[x++] = 'b';
 	if (update_only)
 		argstr[x++] = 'u';
 	if (!do_xfers) /* Note: NOT "dry_run"! */
 		argstr[x++] = 'n';
 	if (preserve_links)
 		argstr[x++] = 'l';
-	if (xfer_dirs > (recurse || !delete_mode || !am_sender ? 1 : 0))
+	if ((list_only && !recurse) || xfer_dirs > 1
+	 || (xfer_dirs && !recurse && delete_mode && am_sender))
 		argstr[x++] = 'd';
 	if (am_sender) {
 		if (keep_dirlinks)
 			argstr[x++] = 'K';
 		if (prune_empty_dirs)
 			argstr[x++] = 'm';
-		if (omit_dir_times == 2)
+		if (omit_dir_times)
 			argstr[x++] = 'O';
 	} else {
 		if (copy_links)
 			argstr[x++] = 'L';
 		if (copy_dirlinks)
 			argstr[x++] = 'k';
@@ -1525,26 +1731,40 @@
 	if (whole_file > 0)
 		argstr[x++] = 'W';
 	/* We don't need to send --no-whole-file, because it's the
 	 * default for remote transfers, and in any case old versions
 	 * of rsync will not understand it. */
 
-	if (preserve_hard_links)
+	if (preserve_hard_links) {
 		argstr[x++] = 'H';
+		if (preserve_hard_links > 1)
+			argstr[x++] = 'H';
+	}
 	if (preserve_uid)
 		argstr[x++] = 'o';
 	if (preserve_gid)
 		argstr[x++] = 'g';
 	if (preserve_devices) /* ignore preserve_specials here */
 		argstr[x++] = 'D';
 	if (preserve_times)
 		argstr[x++] = 't';
 	if (preserve_perms)
 		argstr[x++] = 'p';
 	else if (preserve_executability && am_sender)
 		argstr[x++] = 'E';
+#ifdef SUPPORT_ACLS
+	if (preserve_acls)
+		argstr[x++] = 'A';
+#endif
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs) {
+		argstr[x++] = 'X';
+		if (preserve_xattrs > 1)
+			argstr[x++] = 'X';
+	}
+#endif
 	if (recurse)
 		argstr[x++] = 'r';
 	if (always_checksum)
 		argstr[x++] = 'c';
 	if (cvs_exclude)
 		argstr[x++] = 'C';
@@ -1559,22 +1779,47 @@
 	}
 	if (sparse_files)
 		argstr[x++] = 'S';
 	if (do_compression)
 		argstr[x++] = 'z';
 
-	/* This is a complete hack - blame Rusty.  FIXME!
-	 * This hack is only needed for older rsync versions that
-	 * don't understand the --list-only option. */
-	if (list_only == 1 && !recurse)
-		argstr[x++] = 'r';
-
+	/* We make use of the -e option to let the server know about any
+	 * pre-release protocol version && some behavior flags. */
+	argstr[x++] = 'e';
+#if SUBPROTOCOL_VERSION != 0
+	if (protocol_version == PROTOCOL_VERSION) {
+		x += snprintf(argstr+x, sizeof argstr - x,
+			      "%d.%d", PROTOCOL_VERSION, SUBPROTOCOL_VERSION);
+	} else
+#endif
+		argstr[x++] = '.';
+	set_allow_inc_recurse();
+	if (allow_inc_recurse)
+		argstr[x++] = 'i';
+#if defined HAVE_LUTIMES && defined HAVE_UTIMES
+	argstr[x++] = 'L';
+#endif
 	argstr[x] = '\0';
 
-	if (x != 1)
-		args[ac++] = argstr;
+	args[ac++] = argstr;
+
+#ifdef ICONV_OPTION
+	if (iconv_opt) {
+		char *set = strchr(iconv_opt, ',');
+		if (set)
+			set++;
+		else
+			set = iconv_opt;
+		if (asprintf(&arg, "--iconv=%s", set) < 0)
+			goto oom;
+		args[ac++] = arg;
+	}
+#endif
+
+	if (protect_args) /* initial args break here */
+		args[ac++] = NULL;
 
 	if (list_only > 1)
 		args[ac++] = "--list-only";
 
 	/* This makes sure that the remote rsync can handle deleting with -d
 	 * sans -r because the --no-r option was added at the same time. */
@@ -1611,28 +1856,12 @@
 	if (block_size) {
 		if (asprintf(&arg, "-B%lu", block_size) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
-	if (max_delete && am_sender) {
-		if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
-			goto oom;
-		args[ac++] = arg;
-	}
-
-	if (min_size && am_sender) {
-		args[ac++] = "--min-size";
-		args[ac++] = min_size_arg;
-	}
-
-	if (max_size && am_sender) {
-		args[ac++] = "--max-size";
-		args[ac++] = max_size_arg;
-	}
-
 	if (io_timeout) {
 		if (asprintf(&arg, "--timeout=%d", io_timeout) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
@@ -1653,30 +1882,52 @@
 		if (asprintf(&arg, "--suffix=%s", backup_suffix) < 0)
 			goto oom;
 		args[ac++] = arg;
 	}
 
 	if (am_sender) {
-		if (delete_excluded)
-			args[ac++] = "--delete-excluded";
-		else if (delete_before == 1 || delete_after)
-			args[ac++] = "--delete";
-		if (delete_before > 1)
+		if (max_delete > 0) {
+			if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
+				goto oom;
+			args[ac++] = arg;
+		} else if (max_delete == 0)
+			args[ac++] = "--max-delete=-1";
+		if (min_size) {
+			args[ac++] = "--min-size";
+			args[ac++] = min_size_arg;
+		}
+		if (max_size) {
+			args[ac++] = "--max-size";
+			args[ac++] = max_size_arg;
+		}
+		if (delete_before)
 			args[ac++] = "--delete-before";
-		if (delete_during)
+		else if (delete_during == 2)
+			args[ac++] = "--delete-delay";
+		else if (delete_during)
 			args[ac++] = "--delete-during";
-		if (delete_after)
+		else if (delete_after)
 			args[ac++] = "--delete-after";
+		else if (delete_mode && !delete_excluded)
+			args[ac++] = "--delete";
+		if (delete_excluded)
+			args[ac++] = "--delete-excluded";
 		if (force_delete)
 			args[ac++] = "--force";
 		if (write_batch < 0)
 			args[ac++] = "--only-write-batch=X";
 		if (am_root > 1)
 			args[ac++] = "--super";
 		if (size_only)
 			args[ac++] = "--size-only";
+	} else {
+		if (skip_compress) {
+			if (asprintf(&arg, "--skip-compress=%s", skip_compress) < 0)
+				goto oom;
+			args[ac++] = arg;
+		}
 	}
 
 	if (modify_window_set) {
 		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
 			goto oom;
 		args[ac++] = arg;
@@ -1707,41 +1958,48 @@
 	if (safe_symlinks)
 		args[ac++] = "--safe-links";
 
 	if (numeric_ids)
 		args[ac++] = "--numeric-ids";
 
-	if (ignore_existing && am_sender)
-		args[ac++] = "--ignore-existing";
+	if (use_qsort)
+		args[ac++] = "--use-qsort";
 
-	/* Backward compatibility: send --existing, not --ignore-non-existing. */
-	if (ignore_non_existing && am_sender)
-		args[ac++] = "--existing";
+	if (am_sender) {
+		if (ignore_existing)
+			args[ac++] = "--ignore-existing";
 
-	if (append_mode)
-		args[ac++] = "--append";
-	else if (inplace)
-		args[ac++] = "--inplace";
+		/* Backward compatibility: send --existing, not --ignore-non-existing. */
+		if (ignore_non_existing)
+			args[ac++] = "--existing";
 
-	if (tmpdir && am_sender) {
-		args[ac++] = "--temp-dir";
-		args[ac++] = tmpdir;
-	}
+		if (tmpdir) {
+			args[ac++] = "--temp-dir";
+			args[ac++] = tmpdir;
+		}
 
-	if (basis_dir[0] && am_sender) {
-		/* the server only needs this option if it is not the sender,
-		 *   and it may be an older version that doesn't know this
-		 *   option, so don't send it if client is the sender.
-		 */
-		int i;
-		for (i = 0; i < basis_dir_cnt; i++) {
-			args[ac++] = dest_option;
-			args[ac++] = basis_dir[i];
+		if (basis_dir[0]) {
+			/* the server only needs this option if it is not the sender,
+			 *   and it may be an older version that doesn't know this
+			 *   option, so don't send it if client is the sender.
+			 */
+			int i;
+			for (i = 0; i < basis_dir_cnt; i++) {
+				args[ac++] = dest_option;
+				args[ac++] = basis_dir[i];
+			}
 		}
 	}
 
+	if (append_mode) {
+		if (append_mode > 1)
+			args[ac++] = "--append";
+		args[ac++] = "--append";
+	} else if (inplace)
+		args[ac++] = "--inplace";
+
 	if (files_from && (!am_sender || filesfrom_host)) {
 		if (filesfrom_host) {
 			args[ac++] = "--files-from";
 			args[ac++] = files_from;
 			if (eol_nulls)
 				args[ac++] = "--from0";
@@ -1749,24 +2007,25 @@
 			args[ac++] = "--files-from=-";
 			args[ac++] = "--from0";
 		}
 		if (!relative_paths)
 			args[ac++] = "--no-relative";
 	}
-	if (relative_paths && !implied_dirs && !am_sender)
+	/* It's OK that this checks the upper-bound of the protocol_version. */
+	if (relative_paths && !implied_dirs && (!am_sender || protocol_version >= 30))
 		args[ac++] = "--no-implied-dirs";
 
 	if (fuzzy_basis && am_sender)
 		args[ac++] = "--fuzzy";
 
 	if (remove_source_files == 1)
 		args[ac++] = "--remove-source-files";
 	else if (remove_source_files)
 		args[ac++] = "--remove-sent-files";
 
-	*argc = ac;
+	*argc_p = ac;
 	return;
 
     oom:
 	out_of_memory("server_options");
 }
 
@@ -1796,13 +2055,13 @@
 		if (*s == '[' && (p = strchr(s, ']')) != NULL) {
 			s++;
 			hostlen = p - s;
 			if (p[1] == ':')
 				*port_ptr = atoi(p+2);
 		} else {
-			if ((p = strchr(s, ':')) != NULL) {
+			if ((p = strchr(s, ':')) != NULL && p < s + hostlen) {
 				hostlen = p - s;
 				*port_ptr = atoi(p+1);
 			}
 		}
 		if (!*port_ptr)
 			*port_ptr = RSYNC_PORT;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/packaging/lsb/rsync.spec	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/lsb/rsync.spec	2008-03-02 04:12:04.000000000 +0800
@@ -1,26 +1,28 @@
-Summary: A program for synchronizing files over a network.
+Summary: A fast, versatile, remote (and local) file-copying tool
 Name: rsync
-Version: 2.6.9
+Version: 3.0.0
 Release: 1
 Group: Applications/Internet
-Source:	ftp://rsync.samba.org/pub/rsync/rsync-%{version}.tar.gz
+Source:	http://rsync.samba.org/ftp/rsync/rsync-%{version}.tar.gz
 URL: http://rsync.samba.org/
 
 Prefix: %{_prefix}
 BuildRoot: /var/tmp/%{name}-root
 License: GPL
 
 %description
-Rsync uses a reliable algorithm to bring remote and host files into
-sync very quickly. Rsync is fast because it just sends the differences
-in the files over the network instead of sending the complete
-files. Rsync is often used as a very powerful mirroring process or
-just as a more capable replacement for the rcp command. A technical
-report which describes the rsync algorithm is included in this
-package.
+Rsync is a fast and extraordinarily versatile file copying tool.  It can
+copy locally, to/from another host over any remote shell, or to/from a
+remote rsync daemon.  It offers a large number of options that control
+every aspect of its behavior and permit very flexible specification of the
+set of files to be copied.  It is famous for its delta-transfer algorithm,
+which reduces the amount of data sent over the network by sending only the
+differences between the source files and the existing files in the
+destination.  Rsync is widely used for backups and mirroring and as an
+improved copy command for everyday use.
 
 %prep
 %setup -q
 
 %build
 %configure
@@ -40,49 +42,8 @@
 %doc COPYING README tech_report.tex
 %{_prefix}/bin/rsync
 %{_mandir}/man1/rsync.1*
 %{_mandir}/man5/rsyncd.conf.5*
 
 %changelog
-* Thu Jan 30 2003 Horst von Brand <vonbrand@inf.utfsm.cl>
-  Fixed "Sept" date in %changelog here
-  Use %{_mandir} to point to manpages
-  Support for compressed manpages (* at end catches them in %files)
-  Add doc/README-SGML and doc/rsync.sgml to %doc
-
-* Mon Sep 11 2000 John H Terpstra <jht@turbolinux.com>
-  Changed target paths to be Linux Standards Base compliant
-
-* Mon Jan 25 1999 Stefan Hornburg <racke@linuxia.de>
-  quoted RPM_OPT_FLAGS for the sake of robustness
-
-* Mon May 18 1998 Andrew Tridgell <tridge@samba.anu.edu.au>
-  reworked for auto-building when I release rsync (tridge@samba.anu.edu.au)
-
-* Sat May 16 1998 John H Terpstra <jht@aquasoft.com.au>
-  Upgraded to Rsync 2.0.6
-    -new feature anonymous rsync
-
-* Mon Apr  6 1998 Douglas N. Arnold <dna@math.psu.edu>
-
-Upgrade to rsync version 1.7.2.
-
-* Sun Mar  1 1998 Douglas N. Arnold <dna@math.psu.edu>
-
-Built 1.6.9-1 based on the 1.6.3-2 spec file of John A. Martin.
-Changes from 1.6.3-2 packaging: added latex and dvips commands
-to create tech_report.ps.
-
-* Mon Aug 25 1997 John A. Martin <jam@jamux.com>
-
-Built 1.6.3-2 after finding no rsync-1.6.3-1.src.rpm although there
-was an ftp://ftp.redhat.com/pub/contrib/alpha/rsync-1.6.3-1.alpha.rpm
-showing no packager nor signature but giving 
-"Source RPM: rsync-1.6.3-1.src.rpm".
-
-Changes from 1.6.2-1 packaging: added '$RPM_OPT_FLAGS' to make, strip
-to '%build', removed '%prefix'.
-
-* Thu Apr 10 1997 Michael De La Rue <miked@ed.ac.uk>
-
-rsync-1.6.2-1 packaged.  (This entry by jam to credit Michael for the
-previous package(s).)
+* Sat Mar 01 2008 Wayne Davison <wayned@samba.org>
+Released 3.0.0.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/packaging/nightly-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/nightly-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/packaging/nightly-rsync	2006-10-18 13:14:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/nightly-rsync	2008-01-12 05:20:14.000000000 +0800
@@ -11,95 +11,95 @@
 # HTML man pages in the nightly dir, and then rsync the changes to the
 # samba.org server.
 
 use Getopt::Long;
 use Date::Format;
 
-# Choose any dir where a pristine rsync has been checked out of CVS.
-our $unpacked = $ENV{HOME} . '/release/nightly';
 # Where the local copy of /home/ftp/pub/rsync/nightly should be updated.
-our $nightly = $ENV{HOME} . '/samba-rsync-ftp/nightly';
-our $nightly_symlink = "$nightly/rsync-HEAD.tar.gz";
+our $dest = $ENV{HOME} . '/samba-rsync-ftp/nightly';
+our $nightly_symlink = "$dest/rsync-HEAD.tar.gz";
 
-our($cvs_update, $make_tar, $upload, $help_opt);
+our($make_tar, $upload, $help_opt);
 &Getopt::Long::Configure('bundling');
 &usage if !&GetOptions(
-    'cvs-update|c' => \$cvs_update,
     'make-tar|t' => \$make_tar,
     'upload|u' => \$upload,
     'help|h' => \$help_opt,
 ) || $help_opt;
 
 our $name = time2str('rsync-HEAD-%Y%m%d-%H%M%Z', time, 'GMT');
 our $ztoday = time2str('%d %b %Y', time);
 our $today = $ztoday;
+our $gen_target = $upload ? 'gensend' : 'gen';
 
-chdir($unpacked) or die $!;
-
-if ($cvs_update) {
-    print "Updating from cvs...\n";
-    system 'cvs -q up' and die $!;
-}
+die "$dest does not exist\n" unless -d $dest;
+die "There is no .git dir in the current directory.\n" unless -d '.git';
+die "There is no rsync checkout in the current directory.\n" unless -f 'rsyncd.conf.yo';
 
 if ($make_tar) {
-    print "Generating list of active CVS files...\n";
-    my($dir, @files);
-    open(CVS, '-|', 'cvs status 2>&1') or die $!;
-    while (<CVS>) {
-	if (/^cvs status: Examining (.*)/) {
-	    if ($1 eq '.') {
-		$dir = '';
-	    } else {
-		push(@files, $1);
-		$dir = $1 . '/';
-	    }
-	} elsif (/^File: (.*?)\s+Status: (.*)/ && $1 ne '.cvsignore') {
-	    push(@files, $dir . $1);
-	    if ($2 ne 'Up-to-date') {
-		print "*** Not up-to-date: $dir$1\n";
+    open(IN, '-|', 'git status') or die $!;
+    my $status = join('', <IN>);
+    close IN;
+    die "The checkout is not clean:\n", $status unless $status =~ /\nnothing to commit \(working directory clean\)/;
+    die "The checkout is not on the master branch.\n" unless $status =~ /^# On branch master\n/;
+    system "make $gen_target" and die "make $gen_target failed!\n";
+
+    my @extra_files;
+    open(IN, '<', 'Makefile.in') or die "Couldn't open Makefile.in: $!\n";
+    while (<IN>) {
+	if (s/^GENFILES=//) {
+	    while (s/\\$//) {
+		$_ .= <IN>;
 	    }
+	    @extra_files = split(' ', $_);
+	    last;
 	}
     }
-    close CVS;
+    close IN;
+
+    print "Creating $name.tar.gz\n";
+    system "rsync -a @extra_files $name/";
+    system "git archive --format=tar --prefix=$name/ HEAD | tar xf -";
+    system "support/git-set-file-times --prefix=$name/";
+    system "fakeroot tar czf $dest/$name.tar.gz $name; rm -rf $name";
 
-    print "Creating $unpacked/$name.tar.gz\n";
-    chdir('..') or die $!;
-    rename($unpacked, $name) or die $!;
-    open(TAR, '|-', "fakeroot tar --files-from=- --no-recursion --mode=g-w -czf $nightly/$name.tar.gz $name") or die $!;
-    foreach (@files) {
-	print TAR "$name/$_\n";
-    }
-    close TAR;
-    rename($name, $unpacked) or die $!;
     unlink($nightly_symlink);
     symlink("$name.tar.gz", $nightly_symlink);
 }
 
-chdir($nightly) or die $!;
-
 foreach my $fn (qw( rsync.yo rsyncd.conf.yo )) {
-    my $html_fn = $fn;
-    $html_fn =~ s/\.yo/.html/;
+    my $yo_tmp = "$dest/$fn";
+    (my $html_fn = "$dest/$fn") =~ s/\.yo/.html/;
 
-    open(IN, '<', "$unpacked/$fn") or die $!;
+    open(IN, '<', $fn) or die $!;
     undef $/; $_ = <IN>; $/ = "\n";
     close IN;
 
     s/^(manpage\([^)]+\)\(\d+\)\()[^)]+(\).*)/$1$today$2/m;
     #s/^(This man ?page is current for version) \S+ (of rsync)/$1 $version $2/m;
 
-    open(OUT, '>', $fn) or die $!;
+    open(OUT, '>', $yo_tmp) or die $!;
     print OUT $_;
     close OUT;
 
-    system "yodl2html -o $html_fn $fn";
+    system 'yodl2html', '-o', $html_fn, $yo_tmp;
+
+    unlink($yo_tmp);
+}
+
+chdir($dest) or die $!;
 
-    unlink($fn);
+my $cnt = 0;
+open(PIPE, '-|', 'ls -1t rsync-HEAD-*') or die $!;
+while (<PIPE>) {
+    chomp;
+    next if $cnt++ < 10;
+    unlink($_);
 }
+close PIPE;
 
-system "find . -name 'rsync-HEAD-*' -daystart -mtime +14 | xargs rm -f";
 system 'ls -ltr';
 
 if ($upload) {
     my $opt = '';
     if (defined $ENV{RSYNC_PARTIAL_DIR}) {
 	$opt = " -f 'R $ENV{RSYNC_PARTIAL_DIR}'";
@@ -111,12 +111,11 @@
 
 sub usage
 {
     die <<EOT;
 Usage: nightly-rsync [OPTIONS]
 
- -c, --cvs-update  update $unpacked via CVS.
- -t, --make-tar    create a new tar file in $nightly
+ -t, --make-tar    create a new tar file in $dest
  -u, --upload      upload the revised nightly dir to samba.org
  -h, --help        display this help
 EOT
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/packaging/release-rsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/release-rsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/packaging/release-rsync	2006-10-25 00:17:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/packaging/release-rsync	2008-03-02 04:00:13.000000000 +0800
@@ -1,242 +1,206 @@
 #!/usr/bin/perl
 use strict;
 
-# This script expects the directory ~/samba-rsync-ftp to exist and to
-# be a copy of the /home/ftp/pub/rsync dir on samba.org.  If it is run
-# in test mode, it instead expects a dir named ~/tmp/samba-rsync-ftp
-# (e.g. copy ~/samba-rsync-ftp into ~/tmp and you can do a trial-run of
-# a release without affecting the files in the ~/samba-rsync-ftp dir).
-#
-# Run this as "release-rsync live" to affect ~/samba-rsync-ftp instead
-# of ~/tmp/samba-rsync-ftp.
+# This script expects the directory ~/samba-rsync-ftp to exist and to be a
+# copy of the /home/ftp/pub/rsync dir on samba.org.  When the script is done,
+# the git repository in the current directory will be updated, and the local
+# ~/samba-rsync-ftp dir will be ready to be rsynced to samba.org.
 
+use Cwd;
 use Date::Format;
 
 my $dest = $ENV{HOME} . '/samba-rsync-ftp';
-my $releasedir = $ENV{HOME} . '/release';
-my $cvsroot = $ENV{CVSROOT} = 'samba.org:/data/cvs';
 
+my $cl_today = time2str('* %a %b %d %Y', time);
 my $ztoday = time2str('%d %b %Y', time);
-my $today = $ztoday;
-$today =~ s/^0//;
+(my $today = $ztoday) =~ s/^0//;
+
+my $curdir = Cwd::cwd;
+
+my @extra_files;
+open(IN, '<', 'Makefile.in') or die "Couldn't open Makefile.in: $!\n";
+while (<IN>) {
+    if (s/^GENFILES=//) {
+	while (s/\\$//) {
+	    $_ .= <IN>;
+	}
+	@extra_files = split(' ', $_);
+	last;
+    }
+}
+close IN;
 
 my $break = <<EOT;
 ==========================================================================
 EOT
-my $note = <<EOT;
-== Note: type "-a u,n" if you want to auto-accept the U,N suggestions.  ==
-EOT
-
-my $live = shift;
-my $skipping = '';
 
-print $break;
-if ($live) {
-    print <<EOT;
+print $break, <<EOT, $break, "\n";
 == This will release a new version of rsync onto an unsuspecting world. ==
 EOT
-} else {
-    print <<EOT;
-==     **** TESTMODE ****    (Add "live" arg to avoid this.)            ==
-EOT
-    $dest =~ s#([^/]+$)#tmp/$1#;
-    $skipping = ' ** SKIPPING **';
-}
-die "$dest does not exist\n" unless -d $dest;
-
-print $break, "\nChecking out the latest rsync into $releasedir ...\n";
-
-mkdir($releasedir, 0755) or die $! unless -d $releasedir;
-chdir($releasedir) or die $!;
-
-system 'rm -rf rsync';
 
-my(%dirs, @files);
-open(CVS, '-|', 'cvs checkout -P rsync') or die $!;
-while (<CVS>) {
-    print $_;
-    next if /\.(cvs)?ignore$/;
-    if (m#^[UP] rsync/(.*)#) {
-	my $fn = $1;
-	my($dir) = $fn =~ m#^(.+)/#;
-	push(@files, $dir) if defined($dir) && !$dirs{$1}++;
-	push(@files, $fn);
-    }
-}
+die "$dest does not exist\n" unless -d $dest;
+die "There is no .git dir in the current directory.\n" unless -d '.git';
+die "'a' must not exist in the current directory.\n" if -e 'a';
+die "'b' must not exist in the current directory.\n" if -e 'b';
 
-chdir('rsync') or die $!;
+open(IN, '-|', 'git status') or die $!;
+my $status = join('', <IN>);
+close IN;
+die "The checkout is not clean:\n", $status unless $status =~ /\nnothing to commit \(working directory clean\)/;
+die "The checkout is not on the master branch.\n" unless $status =~ /^# On branch master\n/;
 
-my($version, $lastversion);
-open(IN, 'configure.in') or die $!;
+my $lastversion;
+open(IN, '<', 'configure.in') or die $!;
 while (<IN>) {
     if (/^RSYNC_VERSION=(.*)/) {
-	$version = $lastversion = $1;
+	$lastversion = $1;
 	last;
     }
 }
 close IN;
 
-$lastversion =~ s/(\d+)cvs$/ $1 - 1 /e;
-$version =~ s/cvs/pre1/ || $version =~ s/pre(\d+)/ 'pre' . ($1 + 1) /e;
+open(IN, '<', 'OLDNEWS') or die $!;
+$_ = <IN>;
+close IN;
+my($lastrelease) = /(\d+\.\d+\.\d+)/;
+
+$lastversion = $lastrelease if $lastversion =~ /dev$/;
+my $version = $lastversion;
+$version =~ s/dev/pre1/ || $version =~ s/pre(\d+)/ 'pre' . ($1 + 1) /e;
 
-print $break, "\nPlease enter the version number of this release: [$version] ";
+print "Please enter the version number of this release: [$version] ";
 chomp($_ = <STDIN>);
 if ($_ eq '.') {
     $version =~ s/pre\d+//;
 } elsif ($_ ne '') {
     $version = $_;
 }
-$version =~ s/[-.]*pre[-.]*/pre/;
-
-$lastversion =~ s/(\d+)pre\d+$/ $1 - 1 /e unless $version =~ /pre/;
-
-my $cvstag = "release-$version";
-$cvstag =~ s/[.]/-/g;
-$cvstag =~ s/pre/-pre/;
+$lastversion = $lastrelease unless $version =~ s/[-.]*pre[-.]*/pre/;
 
 print "Enter the previous version to produce a patch against: [$lastversion] ";
 chomp($_ = <STDIN>);
 $lastversion = $_ if $_ ne '';
 $lastversion =~ s/[-.]*pre[-.]*/pre/;
 
 my $release = 1;
 print "Please enter the RPM release number of this release: [$release] ";
 chomp($_ = <STDIN>);
 $release = $_ if $_ ne '';
 
 my $diffdir;
-my $skipping2;
+my $skipping;
 if ($lastversion =~ /pre/) {
     if ($version !~ /pre/) {
 	die "You should not diff a release version against a pre-release version.\n";
     }
     $diffdir = "$dest/old-previews";
-    $skipping2 = ' ** SKIPPING **';
+    $skipping = ' ** SKIPPING **';
 } elsif ($version =~ /pre/) {
     $diffdir = $dest;
-    $skipping2 = ' ** SKIPPING **';
+    $skipping = ' ** SKIPPING **';
 } else {
     $diffdir = "$dest/old-versions";
-    $skipping2 = '';
+    $skipping = '';
 }
 
 print "\n", $break, <<EOT;
 \$version is "$version"
 \$lastversion is "$lastversion"
-\$cvstag is "$cvstag"
 \$dest is "$dest"
-\$releasedir is "$releasedir"
+\$curdir is "$curdir"
 \$diffdir is "$diffdir"
 \$release is "$release"
 
 About to:
-    - make sure that configure, config.h.in, and proto.h are updated
-    - tweak the version in configure.in, configure, and the spec files
-    - tweak NEWS and OLDNEWS to update the release date$skipping2
-    - tweak the date in the *.yo files and re-generate the man pages
-    - make sure that the patches dir has been updated
-    - page through the "cvs diff" output
+    - make sure that SUBPROTOCOL_VERSION is 0$skipping
+    - tweak the version in configure.in and the spec files
+    - tweak NEWS and OLDNEWS to update the release date$skipping
+    - tweak the date in the *.yo files and generate the man pages
+    - generate configure.sh, config.h.in, and proto.h
+    - page through the differences
 
 EOT
 print "<Press Enter to continue> ";
 $_ = <STDIN>;
-my $f_opt = /f/ ? ' -f' : '';
-
-print $break;
-system "./prepare-source && touch proto.h";
 
 my @tweak_files = ( glob('packaging/*.spec'), glob('packaging/*/*.spec'),
-		    glob('*.yo'), qw( configure.in configure ) );
+		    glob('*.yo'), qw( configure.in ) );
+
 if ($version !~ /pre/) {
-    push(@tweak_files, qw( NEWS OLDNEWS ));
+    push(@tweak_files, qw( rsync.h NEWS OLDNEWS ));
 }
 foreach my $fn (@tweak_files) {
     open(IN, '<', $fn) or die $!;
     undef $/; $_ = <IN>; $/ = "\n";
     close IN;
     if ($fn =~ /configure/) {
 	s/^RSYNC_VERSION=.*/RSYNC_VERSION=$version/m;
     } elsif ($fn =~ /\.spec/) {
 	s/^(Version:) .*/$1 $version/m;
 	s/^(Release:) .*/$1 $release/m;
+	s/^(Released) .*/$1 $version./m;
+	s/^\* \w\w\w \w\w\w \d\d \d\d\d\d (.*)/$cl_today $1/m;
     } elsif ($fn =~ /\.yo/) {
 	s/^(manpage\([^)]+\)\(\d+\)\()[^)]+(\).*)/$1$today$2/m;
 	s/^(This man ?page is current for version) \S+ (of rsync)/$1 $version $2/m;
     } elsif ($fn eq 'NEWS') {
 	s/^(NEWS for rsync \Q$version\E) \(UNRELEASED\)\s*\n/$1 ($today)\n/mi
 	    or die "Couldn't update NEWS file with release date!\n";
+    } elsif ($fn eq 'rsync.h') {
+	s/(#define\s+SUBPROTOCOL_VERSION)\s+\d+/$1 0/;
     } elsif ($fn eq 'OLDNEWS') {
 	s/^\t\S\S\s\S\S\S\s\d\d\d\d(\t\Q$version\E)/\t$ztoday$1/m
 	    or die "Couldn't update OLDNEWS file with release date!\n";
     } else {
 	die "Unrecognized file in \@tweak_files: $fn\n";
     }
     open(OUT, '>', $fn) or die $!;
     print OUT $_;
     close OUT;
 }
 
-system "yodl2man -o rsync.1 rsync.yo; ./tweak_manpage_dashes rsync.1";
-system "yodl2man -o rsyncd.conf.5 rsyncd.conf.yo; ./tweak_manpage_dashes rsyncd.conf.5";
-
-mkdir('patches/tmp') or die $!;
-system "rsync -a --exclude=patches/ --exclude-from=.cvsignore . patches/tmp/cvsdir/";
-
-print "\n", $break, $note, $break;
-system "patches/verify-patches -n -an$f_opt";
-
 print $break;
-system "cvs -q diff | egrep -v '^(===============|RCS file: |retrieving revision |Index: )' | less -p '^diff .*'";
-
-print $break, <<EOT;
+system "git diff --color | less -p '^diff .*'";
 
-About to:
-    - "cvs commit" all changes$skipping
-    - "cvs tag" this release as $cvstag$skipping
-    - change the diffs in the patches dir to include generated files
-
-EOT
-print "<Press Enter to continue> ";
-$_ = <STDIN>;
-
-if ($live) {
-    system "cvs commit -m 'Preparing for release of $version'";
-    system "cvs tag -F $cvstag .";
-}
-
-if (!/skip/i) {
-    print "\n", $break, $note, $break;
-    system "patches/verify-patches -pun -an";
-}
-
-my $tar_name = "rsync-$version.tar.gz";
+my $srctar_name = "rsync-$version.tar.gz";
+my $pattar_name = "rsync-patches-$version.tar.gz";
 my $diff_name = "rsync-$lastversion-$version.diffs.gz";
-my $tar_file = "$dest/$tar_name";
+my $srctar_file = "$dest/$srctar_name";
+my $pattar_file = "$dest/$pattar_name";
 my $diff_file = "$dest/$diff_name";
+my $lasttar_file = "$dest/rsync-$lastversion.tar.gz";
 
 print $break, <<EOT;
 
-About to do the following in the samba-rsync-ftp dir:
+About to:
+    - commit all changes
+    - tag this release as v$version
     - move the old tar/diff files into the appropriate old-* dirs
-    - hard-link the moved tar/diff files on samba.org$skipping
-    - create release tar, "$tar_name"
+    - hard-link the moved tar/diff files on samba.org
+    - create release tar, "$srctar_name"
+    - create patches tar, "$pattar_name"
     - create release diffs, "$diff_name"
-    - update README, *NEWS, TODO, and cvs.log
+    - update patch branches and generate patch/* files
+    - update README, *NEWS, TODO, and ChangeLog
     - update rsync*.html man pages
-    - gpg-sign the release files$skipping
+    - gpg-sign the release files
 
 EOT
 print "<Press Enter to continue> ";
 $_ = <STDIN>;
 
-chdir($releasedir) or die $!;
-
-print $break;
-system "rm -rf rsync-$version";
-rename('rsync', "rsync-$version") or die $!;
+system "git commit -a -m 'Preparing for release of $version'" and exit 1;
+print "\nSign the tag:";
+system "git tag -s -m 'Version $version.' v$version" and exit 1;
+
+# Extract some files from the old tar before we do the shuffle.
+@_ = @extra_files;
+map { s#^#rsync-$lastversion/# } @_;
+system "tar xzf $lasttar_file @_";
+rename("rsync-$lastversion", 'a');
 
 # When creating a pre-release after a normal release, there's nothing to move.
 if ($diffdir ne $dest) {
     chdir($dest) or die $!;
 
     print "Shuffling old files ...\n";
@@ -264,56 +228,52 @@
 	    push(@moved_files, $fn);
 	}
     }
 
     # Optimize our future upload (in the absence of --detect-renamed) by
     # using rsync to hard-link the above files on samba.org.
-    if ($live) {
-	system "rsync -avHOC --include='rsync*.gz*' --include='old-*/' --exclude='*' . samba.org:/home/ftp/pub/rsync";
-    }
+    system "rsync -avHOC --include='rsync*.gz*' --include='old-*/' --exclude='*' . samba.org:/home/ftp/pub/rsync";
     foreach (@moved_files) {
 	unlink($_);
     }
 
-    chdir($releasedir) or die $!;
+    chdir($curdir) or die $!;
 }
 
-print "Creating $tar_file ...\n";
-system "fakeroot tar czf $tar_file rsync-$version";
-open(TAR, '|-', "fakeroot tar --files-from=- --no-recursion --mode=g+w -czf $tar_file rsync-$version") or die $!;
-foreach (@files) {
-    print TAR "rsync-$version/$_\n";
-}
-close TAR;
-
 print "Creating $diff_file ...\n";
-system "rm -rf rsync-$version rsync-$lastversion";
-system "tar xzf $tar_file; tar xzf $diffdir/rsync-$lastversion.tar.gz";
-## TWEAK THE VERSIONS AS DESIRED HERE ##
-#mkdir("rsync-$lastversion/support", 0755) or die $!;
-#rename("rsync-$lastversion/rsyncstats", "rsync-$lastversion/support/rsyncstats");
-#unlink("rsync-$lastversion/.ignore");
-## END ##
-system "diff -urN --exclude=patches rsync-$lastversion rsync-$version| gzip -9 >$diff_file";
+system "./config.status Makefile; make gen; rsync -a @extra_files b/";
+my $sed_script = 's:^((---|\+\+\+) [ab]/[^\t]+)\t.*:\1:';
+system "(git diff v$lastversion v$version; diff -upN a b | sed -r '$sed_script') | gzip -9 >$diff_file";
+system "rm -rf a";
+rename('b', "rsync-$version");
+
+print "Creating $srctar_file ...\n";
+system "git archive --format=tar --prefix=rsync-$version/ v$version | tar xf -";
+system "support/git-set-file-times --prefix=rsync-$version/";
+system "fakeroot tar czf $srctar_file rsync-$version; rm -rf rsync-$version";
+
+mkdir("rsync-$version", 0755);
+mkdir("rsync-$version/patches", 0755);
+system "support/patch-update --skip-check --gen=rsync-$version/patches";
+system "fakeroot tar chzf $pattar_file rsync-$version/patches; rm -rf rsync-$version";
 
 print "Updating the other files in $dest ...\n";
-system "rsync -a rsync-$version/{README,NEWS,OLDNEWS,TODO} $dest";
+system "rsync -a README NEWS OLDNEWS TODO $dest";
 unlink("$dest/rsync-$version-NEWS");
 link("$dest/NEWS", "$dest/rsync-$version-NEWS");
-system "rsync -a $cvsroot/CVSROOT/rsync.updates $dest/cvs.log";
+system "git log --name-status | gzip -9 >$dest/ChangeLog.gz";
 
-system "yodl2html -o $dest/rsync.html rsync-$version/rsync.yo";
-system "yodl2html -o $dest/rsyncd.conf.html rsync-$version/rsyncd.conf.yo";
+system "yodl2html -o $dest/rsync.html rsync.yo";
+system "yodl2html -o $dest/rsyncd.conf.html rsyncd.conf.yo";
 
-system "rm -rf rsync-*";
-
-if ($live) {
-    chdir($dest) or die $!;
-    system "gpg -ba $tar_name; gpg -ba $diff_name";
-    print $break, <<EOT;
-
-All done.  Remember to announce the release on *BOTH*
-rsync-announce\@lists.samba.org and rsync\@lists.samba.org!
+chdir($dest) or die $!;
+my $cnt = 0;
+foreach my $fn ($srctar_name, $pattar_name, $diff_name) {
+    print ++$cnt, ". Sign file \"$fn\":";
+    system "gpg -ba $fn";
+}
+print $break, <<'EOT';
+
+Local changes are done.  When you're satisfied, push the git repository
+and rsync the release files.  Remember to announce the release on *BOTH*
+rsync-announce@lists.samba.org and rsync@lists.samba.org (and the web)!
 EOT
-} else {
-    print $break, "All done.\n";
-}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/params.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/params.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/params.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/params.c	2007-11-23 01:51:21.000000000 +0800
@@ -1,23 +1,22 @@
 /* This modules is based on the params.c module from Samba, written by Karl Auer
    and much modifed by Christopher Hertel. */
 
 /*
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* -------------------------------------------------------------------------- **
  *
  * Module name: params
  *
@@ -72,12 +71,13 @@
  *  are used to identify other tokens.
  *
  * -------------------------------------------------------------------------- **
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
 
 /* -------------------------------------------------------------------------- **
  * Constants...
  */
 
 #define BUFR_INC 1024
@@ -162,13 +162,13 @@
    *          indicate that it was not.
    *
    * ------------------------------------------------------------------------ **
    */
   {
   pos--;
-  while( (pos >= 0) && isspace(((unsigned char *)line)[pos]) )
+  while( pos >= 0 && isSpace(line + pos) )
      pos--;
 
   return( ((pos >= 0) && ('\\' == line[pos])) ? pos : -1 );
   } /* Continuation */
 
 
@@ -208,38 +208,38 @@
     if( i > (bSize - 2) )
       {
       bSize += BUFR_INC;
       bufr   = realloc_array( bufr, char, bSize );
       if( NULL == bufr )
         {
-        rprintf(FERROR, "%s Memory re-allocation failure.", func);
+        rprintf(FLOG, "%s Memory re-allocation failure.", func);
         return( False );
         }
       }
 
     /* Handle a single character. */
     switch( c )
       {
       case ']':                       /* Found the closing bracket.         */
         bufr[end] = '\0';
         if( 0 == end )                  /* Don't allow an empty name.       */
           {
-          rprintf(FERROR, "%s Empty section name in configuration file.\n", func );
+          rprintf(FLOG, "%s Empty section name in configuration file.\n", func );
           return( False );
           }
         if( !sfunc( bufr ) )            /* Got a valid name.  Deal with it. */
           return( False );
         (void)EatComment( InFile );     /* Finish off the line.             */
         return( True );
 
       case '\n':                      /* Got newline before closing ']'.    */
         i = Continuation( bufr, i );    /* Check for line continuation.     */
         if( i < 0 )
           {
           bufr[end] = '\0';
-          rprintf(FERROR, "%s Badly formed line in configuration file: %s\n",
+          rprintf(FLOG, "%s Badly formed line in configuration file: %s\n",
                    func, bufr );
           return( False );
           }
         end = ( (i > 0) && (' ' == bufr[i - 1]) ) ? (i - 1) : (i);
         c = getc( InFile );             /* Continue with next line.         */
         break;
@@ -258,13 +258,13 @@
           c = getc( InFile );
           }
       }
     }
 
   /* We arrive here if we've met the EOF before the closing bracket. */
-  rprintf(FERROR, "%s Unexpected EOF in the configuration file: %s\n", func, bufr );
+  rprintf(FLOG, "%s Unexpected EOF in the configuration file: %s\n", func, bufr );
   return( False );
   } /* Section */
 
 static BOOL Parameter( FILE *InFile, BOOL (*pfunc)(char *, char *), int c )
   /* ------------------------------------------------------------------------ **
    * Scan a parameter name and value, and pass these two fields to pfunc().
@@ -302,23 +302,23 @@
     if( i > (bSize - 2) )       /* Ensure there's space for next char.    */
       {
       bSize += BUFR_INC;
       bufr   = realloc_array( bufr, char, bSize );
       if( NULL == bufr )
         {
-        rprintf(FERROR, "%s Memory re-allocation failure.", func) ;
+        rprintf(FLOG, "%s Memory re-allocation failure.", func) ;
         return( False );
         }
       }
 
     switch( c )
       {
       case '=':                 /* Equal sign marks end of param name. */
         if( 0 == end )              /* Don't allow an empty name.      */
           {
-          rprintf(FERROR, "%s Invalid parameter name in config. file.\n", func );
+          rprintf(FLOG, "%s Invalid parameter name in config. file.\n", func );
           return( False );
           }
         bufr[end++] = '\0';         /* Mark end of string & advance.   */
         i       = end;              /* New string starts here.         */
         vstart  = end;              /* New string is parameter value.  */
         bufr[i] = '\0';             /* New string is nul, for now.     */
@@ -326,24 +326,24 @@
 
       case '\n':                /* Find continuation char, else error. */
         i = Continuation( bufr, i );
         if( i < 0 )
           {
           bufr[end] = '\0';
-          rprintf(FERROR, "%s Ignoring badly formed line in configuration file: %s\n",
+          rprintf(FLOG, "%s Ignoring badly formed line in configuration file: %s\n",
                    func, bufr );
           return( True );
           }
         end = ( (i > 0) && (' ' == bufr[i - 1]) ) ? (i - 1) : (i);
         c = getc( InFile );       /* Read past eoln.                   */
         break;
 
       case '\0':                /* Shouldn't have EOF within param name. */
       case EOF:
         bufr[i] = '\0';
-        rprintf(FERROR, "%s Unexpected end-of-file at: %s\n", func, bufr );
+        rprintf(FLOG, "%s Unexpected end-of-file at: %s\n", func, bufr );
         return( True );
 
       default:
         if( isspace( c ) )     /* One ' ' per whitespace region.       */
           {
           bufr[end] = ' ';
@@ -367,13 +367,13 @@
     if( i > (bSize - 2) )       /* Make sure there's enough room. */
       {
       bSize += BUFR_INC;
       bufr   = realloc_array( bufr, char, bSize );
       if( NULL == bufr )
         {
-        rprintf(FERROR, "%s Memory re-allocation failure.", func) ;
+        rprintf(FLOG, "%s Memory re-allocation failure.", func) ;
         return( False );
         }
       }
 
     switch( c )
       {
@@ -384,13 +384,13 @@
       case '\n':              /* Marks end of value unless there's a '\'. */
         i = Continuation( bufr, i );
         if( i < 0 )
           c = 0;
         else
           {
-          for( end = i; (end >= 0) && isspace(((unsigned char *) bufr)[end]); end-- )
+          for( end = i; end >= 0 && isSpace(bufr + end); end-- )
             ;
           c = getc( InFile );
           }
         break;
 
       default:               /* All others verbatim.  Note that spaces do */
@@ -482,20 +482,20 @@
   {
   FILE *OpenedFile;
   char *func = "params.c:OpenConfFile() -";
 
   if( NULL == FileName || 0 == *FileName )
     {
-    rprintf(FERROR,"%s No configuration filename specified.\n", func);
+    rprintf(FLOG, "%s No configuration filename specified.\n", func);
     return( NULL );
     }
 
   OpenedFile = fopen( FileName, "r" );
   if( NULL == OpenedFile )
     {
-    rsyserr(FERROR, errno, "unable to open configuration file \"%s\"",
+    rsyserr(FLOG, errno, "unable to open configuration file \"%s\"",
 	    FileName);
     }
 
   return( OpenedFile );
   } /* OpenConfFile */
 
@@ -531,13 +531,13 @@
   else                                        /* If we don't have a buffer   */
     {                                         /* allocate one, then parse,   */
     bSize = BUFR_INC;                         /* then free.                  */
     bufr = new_array( char, bSize );
     if( NULL == bufr )
       {
-      rprintf(FERROR,"%s memory allocation failure.\n", func);
+      rprintf(FLOG, "%s memory allocation failure.\n", func);
       fclose(InFile);
       return( False );
       }
     result = Parse( InFile, sfunc, pfunc );
     free( bufr );
     bufr  = NULL;
@@ -545,13 +545,13 @@
     }
 
   fclose(InFile);
 
   if( !result )                               /* Generic failure. */
     {
-    rprintf(FERROR,"%s Failed.  Error returned from params.c:parse().\n", func);
+    rprintf(FLOG, "%s Failed.  Error returned from params.c:parse().\n", func);
     return( False );
     }
 
   return( True );                             /* Generic success. */
   } /* pm_process */
 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9: patches
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/pipe.c	2006-05-30 06:56:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/pipe.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,27 +1,26 @@
 /*
  * Routines used to setup various kinds of inter-process pipes.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int am_sender;
 extern int am_server;
@@ -47,15 +46,14 @@
 pid_t piped_child(char **command, int *f_in, int *f_out)
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
 
-	if (verbose >= 2) {
-		print_child_argv(command);
-	}
+	if (verbose >= 2)
+		print_child_argv("opening connection using:", command);
 
 	if (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {
 		rsyserr(FERROR, errno, "pipe");
 		exit_cleanup(RERR_IPC);
 	}
 
@@ -132,32 +130,35 @@
 	if (pid == 0) {
 		am_sender = 0;
 		am_server = 1;
 		filesfrom_fd = -1;
 		chmod_modes = NULL; /* Let the sending side handle this. */
 
+		/* Let the client side handle this. */
+		if (logfile_name) {
+			logfile_name = NULL;
+			logfile_close();
+		}
+
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 			rsyserr(FERROR, errno, "Failed to dup/close");
 			exit_cleanup(RERR_IPC);
 		}
 		if (to_child_pipe[0] != STDIN_FILENO)
 			close(to_child_pipe[0]);
 		if (from_child_pipe[1] != STDOUT_FILENO)
 			close(from_child_pipe[1]);
+#ifdef ICONV_CONST
+		setup_iconv();
+#endif
 		child_main(argc, argv);
 	}
 
-	/* Let the client side handle this. */
-	if (logfile_name) {
-		logfile_name = NULL;
-		logfile_close();
-	}
-
 	if (close(from_child_pipe[1]) < 0 ||
 	    close(to_child_pipe[0]) < 0) {
 		rsyserr(FERROR, errno, "Failed to close");
 		exit_cleanup(RERR_IPC);
 	}
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/findme.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/findme.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/findme.c	2002-07-28 02:32:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/findme.c	2006-11-09 08:57:55.000000000 +0800
@@ -1,41 +1,46 @@
 /** \ingroup popt
  * \file popt/findme.c
  */
 
-/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
+/* (C) 1998-2002 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
    ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 #include "findme.h"
 
-const char * findProgramPath(const char * argv0) {
+const char * findProgramPath(const char * argv0)
+{
     char * path = getenv("PATH");
     char * pathbuf;
     char * start, * chptr;
     char * buf;
+    size_t bufsize;
 
     if (argv0 == NULL) return NULL;	/* XXX can't happen */
     /* If there is a / in the argv[0], it has to be an absolute path */
     if (strchr(argv0, '/'))
 	return xstrdup(argv0);
 
     if (path == NULL) return NULL;
 
-    start = pathbuf = alloca(strlen(path) + 1);
-    buf = malloc(strlen(path) + strlen(argv0) + sizeof("/"));
+    bufsize = strlen(path) + 1;
+    start = pathbuf = alloca(bufsize);
+    if (pathbuf == NULL) return NULL;	/* XXX can't happen */
+    strlcpy(pathbuf, path, bufsize);
+    bufsize += sizeof "/" - 1 + strlen(argv0);
+    buf = malloc(bufsize);
     if (buf == NULL) return NULL;	/* XXX can't happen */
-    strcpy(pathbuf, path);
 
     chptr = NULL;
     /*@-branchstate@*/
     do {
 	if ((chptr = strchr(start, ':')))
 	    *chptr = '\0';
-	sprintf(buf, "%s/%s", start, argv0);
+	snprintf(buf, bufsize, "%s/%s", start, argv0);
 
 	if (!access(buf, X_OK))
 	    return buf;
 
 	if (chptr) 
 	    start = chptr + 1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/popt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/popt.c	2005-02-21 01:21:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popt.c	2006-11-23 11:28:58.000000000 +0800
@@ -1,11 +1,11 @@
 /** \ingroup popt
  * \file popt/popt.c
  */
 
-/* (C) 19982000 Red Hat, Inc. -- Licensing details are in the COPYING
+/* (C) 1998-2002 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from
    ftp://ftp.rpm.org/pub/rpm/dist */
 
 #undef	MYDEBUG
 
 #include "system.h"
@@ -15,26 +15,37 @@
 #endif
 #include <math.h>
 
 #include "findme.h"
 #include "poptint.h"
 
-#ifndef HAVE_STRERROR
-static char * strerror(int errno) {
+#ifndef DBL_EPSILON
+#define DBL_EPSILON 2.2204460492503131e-16
+#endif
+
+#ifdef	MYDEBUG
+/*@unchecked@*/
+int _popt_debug = 0;
+#endif
+
+#if !defined(HAVE_STRERROR) && !defined(__LCLINT__)
+static char * strerror(int errno)
+{
     extern int sys_nerr;
     extern char * sys_errlist[];
 
     if ((0 <= errno) && (errno < sys_nerr))
 	return sys_errlist[errno];
     else
 	return POPT_("unknown errno");
 }
 #endif
 
 #ifdef MYDEBUG
-/*@unused@*/ static void prtcon(const char *msg, poptContext con)
+/*@unused@*/
+static void prtcon(const char *msg, poptContext con)
 {
     if (msg) fprintf(stderr, "%s", msg);
     fprintf(stderr, "\tcon %p os %p nextCharArg \"%s\" nextArg \"%s\" argv[%d] \"%s\"\n",
 	con, con->os,
 	(con->os->nextCharArg ? con->os->nextCharArg : ""),
 	(con->os->nextArg ? con->os->nextArg : ""),
@@ -46,59 +57,69 @@
 
 void poptSetExecPath(poptContext con, const char * path, int allowAbsolute)
 {
     con->execPath = _free(con->execPath);
     con->execPath = xstrdup(path);
     con->execAbsolute = allowAbsolute;
-    /*@-nullstate@*/ /* LCL: con->execPath can be NULL? */
+    /*@-nullstate@*/ /* LCL: con->execPath not NULL */
     return;
     /*@=nullstate@*/
 }
 
 static void invokeCallbacksPRE(poptContext con, const struct poptOption * opt)
 	/*@globals internalState@*/
 	/*@modifies internalState@*/
 {
     if (opt != NULL)
     for (; opt->longName || opt->shortName || opt->arg; opt++) {
 	if (opt->arg == NULL) continue;		/* XXX program error. */
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    void * arg = opt->arg;
+/*@-branchstate@*/
+	    /* XXX sick hack to preserve pretense of ABI. */
+	    if (arg == poptHelpOptions) arg = poptHelpOptionsI18N;
+/*@=branchstate@*/
 	    /* Recurse on included sub-tables. */
-	    invokeCallbacksPRE(con, opt->arg);
+	    invokeCallbacksPRE(con, arg);
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK &&
 		   (opt->argInfo & POPT_CBFLAG_PRE))
 	{   /*@-castfcnptr@*/
 	    poptCallbackType cb = (poptCallbackType)opt->arg;
 	    /*@=castfcnptr@*/
 	    /* Perform callback. */
-	    /*@-moduncon -noeffectuncon @*/
+	    /*@-noeffectuncon @*/
 	    cb(con, POPT_CALLBACK_REASON_PRE, NULL, NULL, opt->descrip);
-	    /*@=moduncon =noeffectuncon @*/
+	    /*@=noeffectuncon @*/
 	}
     }
 }
 
 static void invokeCallbacksPOST(poptContext con, const struct poptOption * opt)
 	/*@globals internalState@*/
 	/*@modifies internalState@*/
 {
     if (opt != NULL)
     for (; opt->longName || opt->shortName || opt->arg; opt++) {
 	if (opt->arg == NULL) continue;		/* XXX program error. */
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    void * arg = opt->arg;
+/*@-branchstate@*/
+	    /* XXX sick hack to preserve pretense of ABI. */
+	    if (arg == poptHelpOptions) arg = poptHelpOptionsI18N;
+/*@=branchstate@*/
 	    /* Recurse on included sub-tables. */
-	    invokeCallbacksPOST(con, opt->arg);
+	    invokeCallbacksPOST(con, arg);
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK &&
 		   (opt->argInfo & POPT_CBFLAG_POST))
 	{   /*@-castfcnptr@*/
 	    poptCallbackType cb = (poptCallbackType)opt->arg;
 	    /*@=castfcnptr@*/
 	    /* Perform callback. */
-	    /*@-moduncon -noeffectuncon @*/
+	    /*@-noeffectuncon @*/
 	    cb(con, POPT_CALLBACK_REASON_POST, NULL, NULL, opt->descrip);
-	    /*@=moduncon =noeffectuncon @*/
+	    /*@=noeffectuncon @*/
 	}
     }
 }
 
 static void invokeCallbacksOPTION(poptContext con,
 				  const struct poptOption * opt,
@@ -109,12 +130,17 @@
 {
     const struct poptOption * cbopt = NULL;
 
     if (opt != NULL)
     for (; opt->longName || opt->shortName || opt->arg; opt++) {
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
+	    void * arg = opt->arg;
+/*@-branchstate@*/
+	    /* XXX sick hack to preserve pretense of ABI. */
+	    if (arg == poptHelpOptions) arg = poptHelpOptionsI18N;
+/*@=branchstate@*/
 	    /* Recurse on included sub-tables. */
 	    if (opt->arg != NULL)	/* XXX program error */
 		invokeCallbacksOPTION(con, opt->arg, myOpt, myData, shorty);
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_CALLBACK &&
 		  !(opt->argInfo & POPT_CBFLAG_SKIPOPTION)) {
 	    /* Save callback info. */
@@ -130,16 +156,16 @@
 	{   /*@-castfcnptr@*/
 	    poptCallbackType cb = (poptCallbackType)cbopt->arg;
 	    /*@=castfcnptr@*/
 	    const void * cbData = (cbopt->descrip ? cbopt->descrip : myData);
 	    /* Perform callback. */
 	    if (cb != NULL) {	/* XXX program error */
-		/*@-moduncon -noeffectuncon @*/
+		/*@-noeffectuncon @*/
 		cb(con, POPT_CALLBACK_REASON_OPTION, myOpt,
 			con->os->nextArg, cbData);
-		/*@=moduncon =noeffectuncon @*/
+		/*@=noeffectuncon @*/
 	    }
 	    /* Terminate (unless explcitly continuing). */
 	    if (!(cbopt->argInfo & POPT_CBFLAG_CONTINUE))
 		return;
 	}
     }
@@ -178,14 +204,18 @@
     con->arg_strip = NULL;
 
     if (getenv("POSIXLY_CORRECT") || getenv("POSIX_ME_HARDER"))
 	con->flags |= POPT_CONTEXT_POSIXMEHARDER;
 
     if (name) {
-	char * t = malloc(strlen(name) + 1);
-	if (t) con->appName = strcpy(t, name);
+	size_t bufsize = strlen(name) + 1;
+	char * t = malloc(bufsize);
+	if (t) {
+	    strlcpy(t, name, bufsize);
+	    con->appName = t;
+	}
     }
 
     /*@-internalglobs@*/
     invokeCallbacksPRE(con, con->options);
     /*@=internalglobs@*/
 
@@ -199,12 +229,13 @@
 {
     os->nextArg = _free(os->nextArg);
     os->argv = _free(os->argv);
     os->argb = PBM_FREE(os->argb);
 }
 
+/*@-boundswrite@*/
 void poptResetContext(poptContext con)
 {
     int i;
 
     if (con == NULL) return;
     while (con->os > con->optionStack) {
@@ -219,25 +250,28 @@
     con->numLeftovers = 0;
     con->nextLeftover = 0;
     con->restLeftover = 0;
     con->doExec = NULL;
 
     if (con->finalArgv != NULL)
-    for (i = 0; i < con->finalArgvCount; i++)
+    for (i = 0; i < con->finalArgvCount; i++) {
 	/*@-unqualifiedtrans@*/		/* FIX: typedef double indirection. */
 	con->finalArgv[i] = _free(con->finalArgv[i]);
 	/*@=unqualifiedtrans@*/
+    }
 
     con->finalArgvCount = 0;
     con->arg_strip = PBM_FREE(con->arg_strip);
     /*@-nullstate@*/	/* FIX: con->finalArgv != NULL */
     return;
     /*@=nullstate@*/
 }
+/*@=boundswrite@*/
 
 /* Only one of longName, shortName should be set, not both. */
+/*@-boundswrite@*/
 static int handleExec(/*@special@*/ poptContext con,
 		/*@null@*/ const char * longName, char shortName)
 	/*@uses con->execs, con->numExecs, con->flags, con->doExec,
 		con->finalArgv, con->finalArgvAlloced, con->finalArgvCount @*/
 	/*@modifies con @*/
 {
@@ -274,32 +308,34 @@
 	con->finalArgv = realloc(con->finalArgv,
 			sizeof(*con->finalArgv) * con->finalArgvAlloced);
     }
 
     i = con->finalArgvCount++;
     if (con->finalArgv != NULL)	/* XXX can't happen */
-    {	char *s  = malloc((longName ? strlen(longName) : 0) + 3);
+    {	size_t bufsize = (longName ? strlen(longName) : 0) + 3;
+	char *s  = malloc(bufsize);
 	if (s != NULL) {	/* XXX can't happen */
 	    if (longName)
-		sprintf(s, "--%s", longName);
+		snprintf(s, bufsize, "--%s", longName);
 	    else
-		sprintf(s, "-%c", shortName);
+		snprintf(s, bufsize, "-%c", shortName);
 	    con->finalArgv[i] = s;
 	} else
 	    con->finalArgv[i] = NULL;
     }
 
     /*@-nullstate@*/	/* FIX: con->finalArgv[] == NULL */
     return 1;
     /*@=nullstate@*/
 }
+/*@=boundswrite@*/
 
 /* Only one of longName, shortName may be set at a time */
 static int handleAlias(/*@special@*/ poptContext con,
 		/*@null@*/ const char * longName, char shortName,
-		/*@keep@*/ /*@null@*/ const char * nextCharArg)
+		/*@exposed@*/ /*@null@*/ const char * nextCharArg)
 	/*@uses con->aliases, con->numAliases, con->optionStack, con->os,
 		con->os->currAlias, con->os->currAlias->option.longName @*/
 	/*@modifies con @*/
 {
     poptItem item = con->os->currAlias;
     int rc;
@@ -327,14 +363,16 @@
     }
     if (i < 0) return 0;
 
     if ((con->os - con->optionStack + 1) == POPT_OPTION_DEPTH)
 	return POPT_ERROR_OPTSTOODEEP;
 
+/*@-boundsread@*/
     if (nextCharArg && *nextCharArg)
 	con->os->nextCharArg = nextCharArg;
+/*@=boundsread@*/
 
     con->os++;
     con->os->next = 0;
     con->os->stuffed = 0;
     con->os->nextArg = NULL;
     con->os->nextCharArg = NULL;
@@ -343,38 +381,39 @@
 		&con->os->argc, &con->os->argv);
     con->os->argb = NULL;
 
     return (rc ? rc : 1);
 }
 
+/*@-bounds -boundswrite @*/
 static int execCommand(poptContext con)
-    /*@*/
+	/*@globals internalState @*/
+	/*@modifies internalState @*/
 {
     poptItem item = con->doExec;
     const char ** argv;
     int argc = 0;
-    int rc;
 
     if (item == NULL) /*XXX can't happen*/
 	return POPT_ERROR_NOARG;
 
     if (item->argv == NULL || item->argc < 1 ||
 	(!con->execAbsolute && strchr(item->argv[0], '/')))
 	    return POPT_ERROR_NOARG;
 
     argv = malloc(sizeof(*argv) *
 			(6 + item->argc + con->numLeftovers + con->finalArgvCount));
-    if (argv == NULL) return POPT_ERROR_MALLOC;	/* XXX can't happen */
+    if (argv == NULL) return POPT_ERROR_MALLOC;
 
-    if (!strchr(item->argv[0], '/') && con->execPath) {
-	char *s = alloca(strlen(con->execPath) + strlen(item->argv[0]) + sizeof("/"));
-	sprintf(s, "%s/%s", con->execPath, item->argv[0]);
+    if (!strchr(item->argv[0], '/') && con->execPath != NULL) {
+	size_t bufsize = strlen(con->execPath) + strlen(item->argv[0]) + sizeof "/";
+	char *s = alloca(bufsize);
+	snprintf(s, bufsize, "%s/%s", con->execPath, item->argv[0]);
 	argv[argc] = s;
-    } else {
+    } else
 	argv[argc] = findProgramPath(item->argv[0]);
-    }
     if (argv[argc++] == NULL) return POPT_ERROR_NOARG;
 
     if (item->argc > 1) {
 	memcpy(argv + argc, item->argv + 1, sizeof(*argv) * (item->argc - 1));
 	argc += (item->argc - 1);
     }
@@ -383,56 +422,66 @@
 	memcpy(argv + argc, con->finalArgv,
 		sizeof(*argv) * con->finalArgvCount);
 	argc += con->finalArgvCount;
     }
 
     if (con->leftovers != NULL && con->numLeftovers > 0) {
-#if 0
-	argv[argc++] = "--";
-#endif
 	memcpy(argv + argc, con->leftovers, sizeof(*argv) * con->numLeftovers);
 	argc += con->numLeftovers;
     }
 
     argv[argc] = NULL;
 
+  {
 #ifdef __hpux
+    int rc = setresgid(getgid(), getgid(),-1);
+    if (rc) return POPT_ERROR_ERRNO;
     rc = setresuid(getuid(), getuid(),-1);
     if (rc) return POPT_ERROR_ERRNO;
 #else
 /*
  * XXX " ... on BSD systems setuid() should be preferred over setreuid()"
  * XXX 	sez' Timur Bakeyev <mc@bat.ru>
  * XXX	from Norbert Warmuth <nwarmuth@privat.circular.de>
  */
 #if defined(HAVE_SETUID)
+    int rc = setgid(getgid());
+    if (rc) return POPT_ERROR_ERRNO;
     rc = setuid(getuid());
     if (rc) return POPT_ERROR_ERRNO;
 #elif defined (HAVE_SETREUID)
-    rc = setreuid(getuid(), getuid()); /*hlauer: not portable to hpux9.01 */
+    int rc = setregid(getgid(), getgid());
+    if (rc) return POPT_ERROR_ERRNO;
+    rc = setreuid(getuid(), getuid());
     if (rc) return POPT_ERROR_ERRNO;
 #else
     ; /* Can't drop privileges */
 #endif
 #endif
+  }
 
     if (argv[0] == NULL)
 	return POPT_ERROR_NOARG;
-#ifdef MYDEBUG
+
+#ifdef	MYDEBUG
+if (_popt_debug)
     {	const char ** avp;
 	fprintf(stderr, "==> execvp(%s) argv[%d]:", argv[0], argc);
 	for (avp = argv; *avp; avp++)
 	    fprintf(stderr, " '%s'", *avp);
 	fprintf(stderr, "\n");
     }
 #endif
 
-    rc = execvp(argv[0], (char *const *)argv);
+    execvp(argv[0], (char *const *)argv);
+
     return POPT_ERROR_ERRNO;
 }
+/*@=bounds =boundswrite @*/
 
+/*@-boundswrite@*/
 /*@observer@*/ /*@null@*/ static const struct poptOption *
 findOption(const struct poptOption * opt, /*@null@*/ const char * longName,
 		char shortName,
 		/*@null@*/ /*@out@*/ poptCallbackType * callback,
 		/*@null@*/ /*@out@*/ const void ** callbackData,
 		int singleDash)
@@ -445,16 +494,21 @@
 	shortName = '-';
 
     for (; opt->longName || opt->shortName || opt->arg; opt++) {
 
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
 	    const struct poptOption * opt2;
+	    void * arg = opt->arg;
 
+/*@-branchstate@*/
+	    /* XXX sick hack to preserve pretense of ABI. */
+	    if (arg == poptHelpOptions) arg = poptHelpOptionsI18N;
+/*@=branchstate@*/
 	    /* Recurse on included sub-tables. */
-	    if (opt->arg == NULL) continue;	/* XXX program error */
-	    opt2 = findOption(opt->arg, longName, shortName, callback,
+	    if (arg == NULL) continue;	/* XXX program error */
+	    opt2 = findOption(arg, longName, shortName, callback,
 			      callbackData, singleDash);
 	    if (opt2 == NULL) continue;
 	    /* Sub-table data will be inheirited if no data yet. */
 	    if (!(callback && *callback)) return opt2;
 	    if (!(callbackData && *callbackData == NULL)) return opt2;
 	    /*@-observertrans -dependenttrans @*/
@@ -493,12 +547,13 @@
 	}
     }
     /*@=modobserver =mods @*/
 
     return opt;
 }
+/*@=boundswrite@*/
 
 static const char * findNextArg(/*@special@*/ poptContext con,
 		unsigned argx, int delete_arg)
 	/*@uses con->optionStack, con->os,
 		con->os->next, con->os->argb, con->os->argc, con->os->argv @*/
 	/*@modifies con @*/
@@ -531,20 +586,21 @@
 	}
 	if (os > con->optionStack) os--;
     } while (arg == NULL);
     return arg;
 }
 
+/*@-boundswrite@*/
 static /*@only@*/ /*@null@*/ const char *
 expandNextArg(/*@special@*/ poptContext con, const char * s)
 	/*@uses con->optionStack, con->os,
 		con->os->next, con->os->argb, con->os->argc, con->os->argv @*/
 	/*@modifies con @*/
 {
     const char * a = NULL;
-    size_t alen;
+    size_t alen, pos;
     char *t, *te;
     size_t tn = strlen(s) + 1;
     char c;
 
     te = t = malloc(tn);;
     if (t == NULL) return NULL;		/* XXX can't happen */
@@ -564,27 +620,28 @@
 		    /*@switchbreak@*/ break;
 	    }
 	    s += 3;
 
 	    alen = strlen(a);
 	    tn += alen;
-	    *te = '\0';
+	    pos = te - t;
 	    t = realloc(t, tn);
-	    te = t + strlen(t);
+	    te = t + pos;
 	    strncpy(te, a, alen); te += alen;
 	    continue;
 	    /*@notreached@*/ /*@switchbreak@*/ break;
 	default:
 	    /*@switchbreak@*/ break;
 	}
 	*te++ = c;
     }
     *te = '\0';
     t = realloc(t, strlen(t) + 1);	/* XXX memory leak, hard to plug */
     return t;
 }
+/*@=boundswrite@*/
 
 static void poptStripArg(/*@special@*/ poptContext con, int which)
 	/*@uses con->arg_strip, con->optionStack @*/
 	/*@defines con->arg_strip @*/
 	/*@modifies con @*/
 {
@@ -596,68 +653,69 @@
     /*@=sizeoftype@*/
     /*@-compdef@*/ /* LCL: con->arg_strip udefined? */
     return;
     /*@=compdef@*/
 }
 
-static int poptSaveLong(const struct poptOption * opt, long aLong)
-	/*@modifies opt->arg @*/
+int poptSaveLong(long * arg, int argInfo, long aLong)
 {
-    if (opt->arg == NULL)
+    /* XXX Check alignment, may fail on funky platforms. */
+    if (arg == NULL || (((unsigned long)arg) & (sizeof(*arg)-1)))
 	return POPT_ERROR_NULLARG;
 
-    if (opt->argInfo & POPT_ARGFLAG_NOT)
+    if (argInfo & POPT_ARGFLAG_NOT)
 	aLong = ~aLong;
-    switch (opt->argInfo & POPT_ARGFLAG_LOGICALOPS) {
+    switch (argInfo & POPT_ARGFLAG_LOGICALOPS) {
     case 0:
-	*((long *) opt->arg) = aLong;
+	*arg = aLong;
 	break;
     case POPT_ARGFLAG_OR:
-	*((long *) opt->arg) |= aLong;
+	*arg |= aLong;
 	break;
     case POPT_ARGFLAG_AND:
-	*((long *) opt->arg) &= aLong;
+	*arg &= aLong;
 	break;
     case POPT_ARGFLAG_XOR:
-	*((long *) opt->arg) ^= aLong;
+	*arg ^= aLong;
 	break;
     default:
 	return POPT_ERROR_BADOPERATION;
 	/*@notreached@*/ break;
     }
     return 0;
 }
 
-static int poptSaveInt(const struct poptOption * opt, long aLong)
-	/*@modifies opt->arg @*/
+int poptSaveInt(/*@null@*/ int * arg, int argInfo, long aLong)
 {
-    if (opt->arg == NULL)
+    /* XXX Check alignment, may fail on funky platforms. */
+    if (arg == NULL || (((unsigned long)arg) & (sizeof(*arg)-1)))
 	return POPT_ERROR_NULLARG;
 
-    if (opt->argInfo & POPT_ARGFLAG_NOT)
+    if (argInfo & POPT_ARGFLAG_NOT)
 	aLong = ~aLong;
-    switch (opt->argInfo & POPT_ARGFLAG_LOGICALOPS) {
+    switch (argInfo & POPT_ARGFLAG_LOGICALOPS) {
     case 0:
-	*((int *) opt->arg) = aLong;
+	*arg = aLong;
 	break;
     case POPT_ARGFLAG_OR:
-	*((int *) opt->arg) |= aLong;
+	*arg |= aLong;
 	break;
     case POPT_ARGFLAG_AND:
-	*((int *) opt->arg) &= aLong;
+	*arg &= aLong;
 	break;
     case POPT_ARGFLAG_XOR:
-	*((int *) opt->arg) ^= aLong;
+	*arg ^= aLong;
 	break;
     default:
 	return POPT_ERROR_BADOPERATION;
 	/*@notreached@*/ break;
     }
     return 0;
 }
 
+/*@-boundswrite@*/
 /* returns 'val' element, -1 on last item, POPT_ERROR_* on error */
 int poptGetNextOpt(poptContext con)
 {
     const struct poptOption * opt = NULL;
     int done = 0;
 
@@ -711,14 +769,18 @@
 		if (con->leftovers != NULL)	/* XXX can't happen */
 		    con->leftovers[con->numLeftovers++] = origOptString;
 		continue;
 	    }
 
 	    /* Make a copy we can hack at */
-	    localOptString = optString =
-		strcpy(alloca(strlen(origOptString) + 1), origOptString);
+	    {   size_t bufsize = strlen(origOptString) + 1;
+		localOptString = optString = alloca(bufsize);
+		if (optString == NULL) /* XXX can't happen */
+		    return POPT_ERROR_BADOPT;
+		strlcpy(optString, origOptString, bufsize);
+	    }
 
 	    if (optString[0] == '\0')
 		return POPT_ERROR_BADOPT;
 
 	    if (optString[1] == '-' && !optString[2]) {
 		con->restLeftover = 1;
@@ -797,17 +859,17 @@
 		con->os->nextCharArg = origOptString;
 	}
 	/*@=branchstate@*/
 
 	if (opt == NULL) return POPT_ERROR_BADOPT;	/* XXX can't happen */
 	if (opt->arg && (opt->argInfo & POPT_ARG_MASK) == POPT_ARG_NONE) {
-	    if (poptSaveInt(opt, 1L))
+	    if (poptSaveInt((int *)opt->arg, opt->argInfo, 1L))
 		return POPT_ERROR_BADOPERATION;
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_VAL) {
 	    if (opt->arg) {
-		if (poptSaveInt(opt, (long)opt->val))
+		if (poptSaveInt((int *)opt->arg, opt->argInfo, (long)opt->val))
 		    return POPT_ERROR_BADOPERATION;
 	    }
 	} else if ((opt->argInfo & POPT_ARG_MASK) != POPT_ARG_NONE) {
 	    con->os->nextArg = _free(con->os->nextArg);
 	    /*@-usedef@*/	/* FIX: W2DO? */
 	    if (longArg) {
@@ -870,18 +932,18 @@
 			    return POPT_ERROR_BADNUMBER;
 		    }
 
 		    if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_LONG) {
 			if (aLong == LONG_MIN || aLong == LONG_MAX)
 			    return POPT_ERROR_OVERFLOW;
-			if (poptSaveLong(opt, aLong))
+			if (poptSaveLong((long *)opt->arg, opt->argInfo, aLong))
 			    return POPT_ERROR_BADOPERATION;
 		    } else {
 			if (aLong > INT_MAX || aLong < INT_MIN)
 			    return POPT_ERROR_OVERFLOW;
-			if (poptSaveInt(opt, aLong))
+			if (poptSaveInt((int *)opt->arg, opt->argInfo, aLong))
 			    return POPT_ERROR_BADOPERATION;
 		    }
 		}   /*@switchbreak@*/ break;
 
 		case POPT_ARG_FLOAT:
 		case POPT_ARG_DOUBLE:
@@ -901,15 +963,12 @@
 			    return POPT_ERROR_BADNUMBER;
 		    }
 
 		    if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_DOUBLE) {
 			*((double *) opt->arg) = aDouble;
 		    } else {
-#ifndef DBL_EPSILON
-#define DBL_EPSILON 2.2204460492503131e-16
-#endif
 #define MY_ABS(a) ((((a) - 0.0) < DBL_EPSILON) ? -(a) : (a))
 			if ((MY_ABS(aDouble) - FLT_MAX) > DBL_EPSILON)
 			    return POPT_ERROR_OVERFLOW;
 			if ((FLT_MIN - MY_ABS(aDouble)) > DBL_EPSILON)
 			    return POPT_ERROR_OVERFLOW;
 			*((float *) opt->arg) = aDouble;
@@ -936,20 +995,21 @@
 	    con->finalArgvAlloced += 10;
 	    con->finalArgv = realloc(con->finalArgv,
 			    sizeof(*con->finalArgv) * con->finalArgvAlloced);
 	}
 
 	if (con->finalArgv != NULL)
-	{   char *s = malloc((opt->longName ? strlen(opt->longName) : 0) + 3);
+	{   ssize_t bufsize = (opt->longName ? strlen(opt->longName) : 0) + 3;
+	    char *s = malloc(bufsize);
 	    if (s != NULL) {	/* XXX can't happen */
 		if (opt->longName)
-		    sprintf(s, "%s%s",
+		    snprintf(s, bufsize, "%s%s",
 			((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "-" : "--"),
 			opt->longName);
 		else
-		    sprintf(s, "-%c", opt->shortName);
+		    snprintf(s, bufsize, "-%c", opt->shortName);
 		con->finalArgv[con->finalArgvCount++] = s;
 	    } else
 		con->finalArgv[con->finalArgvCount++] = NULL;
 	}
 
 	if (opt->arg && (opt->argInfo & POPT_ARG_MASK) == POPT_ARG_NONE)
@@ -964,12 +1024,13 @@
 			/*@=nullpass@*/
 	}
     }
 
     return (opt ? opt->val : -1);	/* XXX can't happen */
 }
+/*@=boundswrite@*/
 
 const char * poptGetOptArg(poptContext con)
 {
     const char * ret = NULL;
     /*@-branchstate@*/
     if (con) {
@@ -993,12 +1054,13 @@
     const char * ret = NULL;
     if (con && con->leftovers != NULL && con->nextLeftover < con->numLeftovers)
 	ret = con->leftovers[con->nextLeftover];
     return ret;
 }
 
+/*@-boundswrite@*/
 const char ** poptGetArgs(poptContext con)
 {
     if (con == NULL ||
 	con->leftovers == NULL || con->numLeftovers == con->nextLeftover)
 	return NULL;
 
@@ -1006,12 +1068,13 @@
     con->leftovers[con->numLeftovers] = NULL;
 
     /*@-nullret -nullstate @*/	/* FIX: typedef double indirection. */
     return (con->leftovers + con->nextLeftover);
     /*@=nullret =nullstate @*/
 }
+/*@=boundswrite@*/
 
 poptContext poptFreeContext(poptContext con)
 {
     poptItem item;
     int i;
 
@@ -1068,12 +1131,13 @@
     item->option.argDescrip = NULL;
     item->argc = alias.argc;
     item->argv = alias.argv;
     return poptAddItem(con, item, 0);
 }
 
+/*@-boundswrite@*/
 /*@-mustmod@*/ /* LCL: con not modified? */
 int poptAddItem(poptContext con, poptItem newItem, int flags)
 {
     poptItem * items, item;
     int * nitems;
 
@@ -1112,12 +1176,13 @@
 
     (*nitems)++;
 
     return 0;
 }
 /*@=mustmod@*/
+/*@=boundswrite@*/
 
 const char * poptBadOption(poptContext con, int flags)
 {
     struct optionStackEntry * os = NULL;
 
     if (con != NULL)
@@ -1181,12 +1246,13 @@
 
 const char * poptGetInvocationName(poptContext con)
 {
     return (con->os->argv ? con->os->argv[0] : "");
 }
 
+/*@-boundswrite@*/
 int poptStrippedArgv(poptContext con, int argc, char ** argv)
 {
     int numargs = argc;
     int j = 1;
     int i;
     
@@ -1204,6 +1270,7 @@
 	j++;
     }
     /*@=sizeoftype@*/
     
     return numargs;
 }
+/*@=boundswrite@*/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/poptconfig.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptconfig.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/poptconfig.c	2004-06-10 05:41:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptconfig.c	2006-11-09 10:14:38.000000000 +0800
@@ -1,50 +1,52 @@
 /** \ingroup popt
  * \file popt/poptconfig.c
  */
 
-/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
+/* (C) 1998-2002 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
    ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 #include "poptint.h"
+/*@access poptContext @*/
 
 /*@-compmempass@*/	/* FIX: item->option.longName kept, not dependent. */
-static void configLine(poptContext con, unsigned char * line)
+static void configLine(poptContext con, char * line)
 	/*@modifies con @*/
 {
-    /*@-type@*/
-    int nameLength = strlen(con->appName);
-    /*@=type@*/
+    size_t nameLength;
     const char * entryType;
     const char * opt;
     poptItem item = (poptItem) alloca(sizeof(*item));
     int i, j;
+
+    if (con->appName == NULL)
+	return;
+    nameLength = strlen(con->appName);
     
+/*@-boundswrite@*/
     memset(item, 0, sizeof(*item));
 
-    /*@-type@*/
     if (strncmp(line, con->appName, nameLength)) return;
-    /*@=type@*/
 
     line += nameLength;
-    if (*line == '\0' || !isspace(*line)) return;
+    if (*line == '\0' || !isSpace(line)) return;
 
-    while (*line != '\0' && isspace(*line)) line++;
+    while (*line != '\0' && isSpace(line)) line++;
     entryType = line;
-    while (*line == '\0' || !isspace(*line)) line++;
+    while (*line == '\0' || !isSpace(line)) line++;
     *line++ = '\0';
 
-    while (*line != '\0' && isspace(*line)) line++;
+    while (*line != '\0' && isSpace(line)) line++;
     if (*line == '\0') return;
     opt = line;
-    while (*line == '\0' || !isspace(*line)) line++;
+    while (*line == '\0' || !isSpace(line)) line++;
     *line++ = '\0';
 
-    while (*line != '\0' && isspace(*line)) line++;
+    while (*line != '\0' && isSpace(line)) line++;
     if (*line == '\0') return;
 
     /*@-temptrans@*/ /* FIX: line alias is saved */
     if (opt[0] == '-' && opt[1] == '-')
 	item->option.longName = opt + 2;
     else if (opt[0] == '-' && opt[2] == '\0')
@@ -77,67 +79,65 @@
     }
     if (j != i) {
 	item->argv[j] = NULL;
 	item->argc = j;
     }
     /*@=modobserver@*/
+/*@=boundswrite@*/
 	
     /*@-nullstate@*/ /* FIX: item->argv[] may be NULL */
     if (!strcmp(entryType, "alias"))
 	(void) poptAddItem(con, item, 0);
     else if (!strcmp(entryType, "exec"))
 	(void) poptAddItem(con, item, 1);
     /*@=nullstate@*/
 }
 /*@=compmempass@*/
 
 int poptReadConfigFile(poptContext con, const char * fn)
 {
-    const unsigned char * file, * chptr, * end;
-    unsigned char * buf;
-/*@dependent@*/ unsigned char * dst;
+    const char * file, * chptr, * end;
+    char * buf;
+/*@dependent@*/ char * dst;
     int fd, rc;
     off_t fileLength;
 
     fd = open(fn, O_RDONLY);
     if (fd < 0)
 	return (errno == ENOENT ? 0 : POPT_ERROR_ERRNO);
 
     fileLength = lseek(fd, 0, SEEK_END);
     if (fileLength == -1 || lseek(fd, 0, 0) == -1) {
 	rc = errno;
 	(void) close(fd);
-	/*@-mods@*/
 	errno = rc;
-	/*@=mods@*/
 	return POPT_ERROR_ERRNO;
     }
 
     file = alloca(fileLength + 1);
     if (read(fd, (char *)file, fileLength) != fileLength) {
 	rc = errno;
 	(void) close(fd);
-	/*@-mods@*/
 	errno = rc;
-	/*@=mods@*/
 	return POPT_ERROR_ERRNO;
     }
     if (close(fd) == -1)
 	return POPT_ERROR_ERRNO;
 
+/*@-boundswrite@*/
     dst = buf = alloca(fileLength + 1);
 
     chptr = file;
     end = (file + fileLength);
     /*@-infloops@*/	/* LCL: can't detect chptr++ */
     while (chptr < end) {
 	switch (*chptr) {
 	  case '\n':
 	    *dst = '\0';
 	    dst = buf;
-	    while (*dst && isspace(*dst)) dst++;
+	    while (*dst && isSpace(dst)) dst++;
 	    if (*dst && *dst != '#')
 		configLine(con, dst);
 	    chptr++;
 	    /*@switchbreak@*/ break;
 	  case '\\':
 	    *dst++ = *chptr++;
@@ -152,33 +152,32 @@
 	  default:
 	    *dst++ = *chptr++;
 	    /*@switchbreak@*/ break;
 	}
     }
     /*@=infloops@*/
+/*@=boundswrite@*/
 
     return 0;
 }
 
 int poptReadDefaultConfig(poptContext con, /*@unused@*/ UNUSED(int useEnv))
 {
     char * fn, * home;
     int rc;
 
-    /*@-type@*/
-    if (!con->appName) return 0;
-    /*@=type@*/
+    if (con->appName == NULL) return 0;
 
     rc = poptReadConfigFile(con, "/etc/popt");
     if (rc) return rc;
-    if (getuid() != geteuid()) return 0;
 
     if ((home = getenv("HOME"))) {
-	fn = alloca(strlen(home) + 20);
-	strcpy(fn, home);
-	strcat(fn, "/.popt");
+	size_t bufsize = strlen(home) + 20;
+	fn = alloca(bufsize);
+	if (fn == NULL) return 0;
+	snprintf(fn, bufsize, "%s/.popt", home);
 	rc = poptReadConfigFile(con, fn);
 	if (rc) return rc;
     }
 
     return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/popt.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popt.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/popt.h	2005-02-21 01:21:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popt.h	2006-11-09 08:57:55.000000000 +0800
@@ -109,79 +109,104 @@
 #define POPT_CONTEXT_ARG_OPTS	(1 << 4) /*!< return args as options with value 0 */
 /*@}*/
 
 /** \ingroup popt
  */
 struct poptOption {
-/*@observer@*/ /*@null@*/ const char * longName; /*!< may be NULL */
-    char shortName;			/*!< may be '\0' */
+/*@observer@*/ /*@null@*/
+    const char * longName;	/*!< may be NULL */
+    char shortName;		/*!< may be NUL */
     int argInfo;
-/*@shared@*/ /*@null@*/ void * arg;	/*!< depends on argInfo */
+/*@shared@*/ /*@null@*/
+    void * arg;			/*!< depends on argInfo */
     int val;			/*!< 0 means don't return, just update flag */
-/*@observer@*/ /*@null@*/ const char * descrip;	/*!< description for autohelp -- may be NULL */
-/*@observer@*/ /*@null@*/ const char * argDescrip; /*!< argument description for autohelp */
+/*@observer@*/ /*@null@*/
+    const char * descrip;	/*!< description for autohelp -- may be NULL */
+/*@observer@*/ /*@null@*/
+    const char * argDescrip;	/*!< argument description for autohelp */
 };
 
 /** \ingroup popt
  * A popt alias argument for poptAddAlias().
  */
 struct poptAlias {
-/*@owned@*/ /*@null@*/ const char * longName;	/*!< may be NULL */
-    char shortName;		/*!< may be '\0' */
+/*@owned@*/ /*@null@*/
+    const char * longName;	/*!< may be NULL */
+    char shortName;		/*!< may be NUL */
     int argc;
-/*@owned@*/ const char ** argv;	/*!< must be free()able */
+/*@owned@*/
+    const char ** argv;		/*!< must be free()able */
 };
 
 /** \ingroup popt
  * A popt alias or exec argument for poptAddItem().
  */
+/*@-exporttype@*/
 typedef struct poptItem_s {
     struct poptOption option;	/*!< alias/exec name(s) and description. */
     int argc;			/*!< (alias) no. of args. */
-/*@owned@*/ const char ** argv;	/*!< (alias) args, must be free()able. */
+/*@owned@*/
+    const char ** argv;		/*!< (alias) args, must be free()able. */
 } * poptItem;
+/*@=exporttype@*/
 
 /** \ingroup popt
  * \name Auto-generated help/usage
  */
 /*@{*/
 
 /**
  * Empty table marker to enable displaying popt alias/exec options.
  */
-/*@observer@*/ /*@checked@*/
+/*@-exportvar@*/
+/*@unchecked@*/ /*@observer@*/
 extern struct poptOption poptAliasOptions[];
+/*@=exportvar@*/
 #define POPT_AUTOALIAS { NULL, '\0', POPT_ARG_INCLUDE_TABLE, poptAliasOptions, \
 			0, "Options implemented via popt alias/exec:", NULL },
 
 /**
  * Auto help table options.
  */
-/*@observer@*/ /*@checked@*/
+/*@-exportvar@*/
+/*@unchecked@*/ /*@observer@*/
 extern struct poptOption poptHelpOptions[];
+/*@=exportvar@*/
+
+/*@-exportvar@*/
+/*@unchecked@*/ /*@observer@*/
+extern struct poptOption * poptHelpOptionsI18N;
+/*@=exportvar@*/
+
 #define POPT_AUTOHELP { NULL, '\0', POPT_ARG_INCLUDE_TABLE, poptHelpOptions, \
 			0, "Help options:", NULL },
 
 #define POPT_TABLEEND { NULL, '\0', 0, 0, 0, NULL, NULL }
 /*@}*/
 
 /** \ingroup popt
  */
+/*@-exporttype@*/
 typedef /*@abstract@*/ struct poptContext_s * poptContext;
+/*@=exporttype@*/
 
 /** \ingroup popt
  */
 #ifndef __cplusplus
-/*@-typeuse@*/
+/*@-exporttype -typeuse@*/
 typedef struct poptOption * poptOption;
-/*@=typeuse@*/
+/*@=exporttype =typeuse@*/
 #endif
 
-enum poptCallbackReason { POPT_CALLBACK_REASON_PRE, 
-			  POPT_CALLBACK_REASON_POST,
-			  POPT_CALLBACK_REASON_OPTION };
+/*@-exportconst@*/
+enum poptCallbackReason {
+    POPT_CALLBACK_REASON_PRE	= 0, 
+    POPT_CALLBACK_REASON_POST	= 1,
+    POPT_CALLBACK_REASON_OPTION = 2
+};
+/*@=exportconst@*/
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 /*@-type@*/
 
@@ -195,102 +220,111 @@
  */
 typedef void (*poptCallbackType) (poptContext con, 
 		enum poptCallbackReason reason,
 		/*@null@*/ const struct poptOption * opt,
 		/*@null@*/ const char * arg,
 		/*@null@*/ const void * data)
-	/*@*/;
+	/*@globals internalState @*/
+	/*@modifies internalState @*/;
 
 /** \ingroup popt
  * Initialize popt context.
- * @param name
+ * @param name		context name (usually argv[0] program name)
  * @param argc		no. of arguments
  * @param argv		argument array
  * @param options	address of popt option table
  * @param flags		or'd POPT_CONTEXT_* bits
  * @return		initialized popt context
  */
-/*@only@*/ /*@null@*/ poptContext poptGetContext(
+/*@only@*/ /*@null@*/
+poptContext poptGetContext(
 		/*@dependent@*/ /*@keep@*/ const char * name,
 		int argc, /*@dependent@*/ /*@keep@*/ const char ** argv,
 		/*@dependent@*/ /*@keep@*/ const struct poptOption * options,
 		int flags)
 	/*@*/;
 
 /** \ingroup popt
  * Reinitialize popt context.
  * @param con		context
  */
+/*@unused@*/
 void poptResetContext(/*@null@*/poptContext con)
 	/*@modifies con @*/;
 
 /** \ingroup popt
  * Return value of next option found.
  * @param con		context
  * @return		next option val, -1 on last item, POPT_ERROR_* on error
  */
 int poptGetNextOpt(/*@null@*/poptContext con)
-	/*@globals fileSystem@*/
-	/*@modifies con, fileSystem @*/;
+	/*@globals fileSystem, internalState @*/
+	/*@modifies con, fileSystem, internalState @*/;
 
-/*@-redecl@*/
 /** \ingroup popt
  * Return next option argument (if any).
  * @param con		context
- * @return		option argument, NULL if no more options are available
+ * @return		option argument, NULL if no argument is available
  */
-/*@observer@*/ /*@null@*/ const char * poptGetOptArg(/*@null@*/poptContext con)
+/*@observer@*/ /*@null@*/ /*@unused@*/
+const char * poptGetOptArg(/*@null@*/poptContext con)
 	/*@modifies con @*/;
 
 /** \ingroup popt
- * Return current option's argument.
+ * Return next argument.
  * @param con		context
- * @return		option argument, NULL if no more options are available
+ * @return		next argument, NULL if no argument is available
  */
-/*@observer@*/ /*@null@*/ const char * poptGetArg(/*@null@*/poptContext con)
+/*@observer@*/ /*@null@*/ /*@unused@*/
+const char * poptGetArg(/*@null@*/poptContext con)
 	/*@modifies con @*/;
 
 /** \ingroup popt
- * Peek at current option's argument.
+ * Peek at current argument.
  * @param con		context
- * @return		option argument
+ * @return		current argument, NULL if no argument is available
  */
-/*@observer@*/ /*@null@*/ const char * poptPeekArg(/*@null@*/poptContext con)
+/*@observer@*/ /*@null@*/ /*@unused@*/
+const char * poptPeekArg(/*@null@*/poptContext con)
 	/*@*/;
 
 /** \ingroup popt
  * Return remaining arguments.
  * @param con		context
- * @return		argument array, terminated with NULL
+ * @return		argument array, NULL terminated
  */
-/*@observer@*/ /*@null@*/ const char ** poptGetArgs(/*@null@*/poptContext con)
+/*@observer@*/ /*@null@*/
+const char ** poptGetArgs(/*@null@*/poptContext con)
 	/*@modifies con @*/;
 
 /** \ingroup popt
  * Return the option which caused the most recent error.
  * @param con		context
+ * @param flags
  * @return		offending option
  */
-/*@observer@*/ const char * poptBadOption(/*@null@*/poptContext con, int flags)
+/*@observer@*/
+const char * poptBadOption(/*@null@*/poptContext con, int flags)
 	/*@*/;
-/*@=redecl@*/
 
 /** \ingroup popt
  * Destroy context.
  * @param con		context
  * @return		NULL always
  */
-/*@null@*/ poptContext poptFreeContext( /*@only@*/ /*@null@*/ poptContext con)
+/*@null@*/
+poptContext poptFreeContext( /*@only@*/ /*@null@*/ poptContext con)
 	/*@modifies con @*/;
 
 /** \ingroup popt
  * Add arguments to context.
  * @param con		context
  * @param argv		argument array, NULL terminated
  * @return		0 on success, POPT_ERROR_OPTSTOODEEP on failure
  */
+/*@unused@*/
 int poptStuffArgs(poptContext con, /*@keep@*/ const char ** argv)
 	/*@modifies con @*/;
 
 /** \ingroup popt
  * Add alias to context.
  * @todo Pass alias by reference, not value.
@@ -304,13 +338,13 @@
 int poptAddAlias(poptContext con, struct poptAlias alias, int flags)
 	/*@modifies con @*/;
 
 /** \ingroup popt
  * Add alias/exec item to context.
  * @param con		context
- * @param item		alias/exec item to add
+ * @param newItem	alias/exec item to add
  * @param flags		0 for alias, 1 for exec
  * @return		0 on success
  */
 int poptAddItem(poptContext con, poptItem newItem, int flags)
 	/*@modifies con @*/;
 
@@ -318,26 +352,27 @@
  * Read configuration file.
  * @param con		context
  * @param fn		file name to read
  * @return		0 on success, POPT_ERROR_ERRNO on failure
  */
 int poptReadConfigFile(poptContext con, const char * fn)
-	/*@globals fileSystem@*/
-	/*@modifies fileSystem,
-		con->execs, con->numExecs @*/;
+	/*@globals errno, fileSystem, internalState @*/
+	/*@modifies con->execs, con->numExecs,
+		errno, fileSystem, internalState @*/;
 
 /** \ingroup popt
  * Read default configuration from /etc/popt and $HOME/.popt.
  * @param con		context
  * @param useEnv	(unused)
  * @return		0 on success, POPT_ERROR_ERRNO on failure
  */
+/*@unused@*/
 int poptReadDefaultConfig(poptContext con, /*@unused@*/ int useEnv)
-	/*@globals fileSystem@*/
-	/*@modifies fileSystem,
-		con->execs, con->numExecs @*/;
+	/*@globals fileSystem, internalState @*/
+	/*@modifies con->execs, con->numExecs,
+		fileSystem, internalState @*/;
 
 /** \ingroup popt
  * Duplicate an argument array.
  * @note: The argument array is malloc'd as a single area, so only argv must
  * be free'd.
  *
@@ -360,32 +395,84 @@
  * be free'd.
  *
  * @param s		string to parse
  * @retval argcPtr	address of returned no. of arguments
  * @retval argvPtr	address of returned argument array
  */
-int poptParseArgvString(const unsigned char * s,
+int poptParseArgvString(const char * s,
 		/*@out@*/ int * argcPtr, /*@out@*/ const char *** argvPtr)
 	/*@modifies *argcPtr, *argvPtr @*/;
 
 /** \ingroup popt
+ * Parses an input configuration file and returns an string that is a 
+ * command line.  For use with popt.  You must free the return value when done.
+ *
+ * Given the file:
+\verbatim
+# this line is ignored
+    #   this one too
+aaa
+  bbb
+    ccc   
+bla=bla
+
+this_is   =   fdsafdas
+     bad_line=        
+  reall bad line  
+  reall bad line  = again
+5555=   55555   
+  test = with lots of spaces
+\endverbatim
+*
+* The result is:
+\verbatim
+--aaa --bbb --ccc --bla="bla" --this_is="fdsafdas" --5555="55555" --test="with lots of spaces"
+\endverbatim
+*
+* Passing this to poptParseArgvString() yields an argv of:
+\verbatim
+'--aaa'
+'--bbb' 
+'--ccc' 
+'--bla=bla' 
+'--this_is=fdsafdas' 
+'--5555=55555' 
+'--test=with lots of spaces' 
+\endverbatim
+ *
+ * @bug NULL is returned if file line is too long.
+ * @bug Silently ignores invalid lines.
+ *
+ * @param fp		file handle to read
+ * @param *argstrp	return string of options (malloc'd)
+ * @param flags		unused
+ * @return		0 on success
+ * @see			poptParseArgvString
+ */
+/*@-fcnuse@*/
+int poptConfigFileToString(FILE *fp, /*@out@*/ char ** argstrp, int flags)
+	/*@globals fileSystem @*/
+	/*@modifies *fp, *argstrp, fileSystem @*/;
+/*@=fcnuse@*/
+
+/** \ingroup popt
  * Return formatted error string for popt failure.
  * @param error		popt error
  * @return		error string
  */
-/*@-redecl@*/
-/*@observer@*/ const char * poptStrerror(const int error)
+/*@observer@*/
+const char * poptStrerror(const int error)
 	/*@*/;
-/*@=redecl@*/
 
 /** \ingroup popt
  * Limit search for executables.
  * @param con		context
  * @param path		single path to search for executables
  * @param allowAbsolute	absolute paths only?
  */
+/*@unused@*/
 void poptSetExecPath(poptContext con, const char * path, int allowAbsolute)
 	/*@modifies con @*/;
 
 /** \ingroup popt
  * Print detailed description of options.
  * @param con		context
@@ -418,16 +505,17 @@
 
 /** \ingroup popt
  * Return argv[0] from context.
  * @param con		context
  * @return		argv[0]
  */
-/*@-redecl -fcnuse@*/
-/*@observer@*/ const char * poptGetInvocationName(poptContext con)
+/*@-fcnuse@*/
+/*@observer@*/
+const char * poptGetInvocationName(poptContext con)
 	/*@*/;
-/*@=redecl =fcnuse@*/
+/*@=fcnuse@*/
 
 /** \ingroup popt
  * Shuffle argv pointers to remove stripped args, returns new argc.
  * @param con		context
  * @param argc		no. of args
  * @param argv		arg vector
@@ -435,12 +523,42 @@
  */
 /*@-fcnuse@*/
 int poptStrippedArgv(poptContext con, int argc, char ** argv)
 	/*@modifies *argv @*/;
 /*@=fcnuse@*/
 
+/**
+ * Save a long, performing logical operation with value.
+ * @warning Alignment check may be too strict on certain platorms.
+ * @param arg		integer pointer, aligned on int boundary.
+ * @param argInfo	logical operation (see POPT_ARGFLAG_*)
+ * @param aLong		value to use
+ * @return		0 on success, POPT_ERROR_NULLARG/POPT_ERROR_BADOPERATION
+ */
+/*@-incondefs@*/
+/*@unused@*/
+int poptSaveLong(/*@null@*/ long * arg, int argInfo, long aLong)
+	/*@modifies *arg @*/
+	/*@requires maxSet(arg) >= 0 /\ maxRead(arg) == 0 @*/;
+/*@=incondefs@*/
+
+/**
+ * Save an integer, performing logical operation with value.
+ * @warning Alignment check may be too strict on certain platorms.
+ * @param arg		integer pointer, aligned on int boundary.
+ * @param argInfo	logical operation (see POPT_ARGFLAG_*)
+ * @param aLong		value to use
+ * @return		0 on success, POPT_ERROR_NULLARG/POPT_ERROR_BADOPERATION
+ */
+/*@-incondefs@*/
+/*@unused@*/
+int poptSaveInt(/*@null@*/ int * arg, int argInfo, long aLong)
+	/*@modifies *arg @*/
+	/*@requires maxSet(arg) >= 0 /\ maxRead(arg) == 0 @*/;
+/*@=incondefs@*/
+
 /*@=type@*/
 #ifdef  __cplusplus
 }
 #endif
 
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/popthelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popthelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/popthelp.c	2005-02-21 01:20:14.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/popthelp.c	2006-11-09 10:55:32.000000000 +0800
@@ -1,23 +1,34 @@
 /* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 4 -*- */
 
-/*@-type@*/
 /** \ingroup popt
  * \file popt/popthelp.c
  */
 
-/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
+/* (C) 1998-2002 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
    ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
+
+/*#define POPT_WCHAR_HACK*/
+#ifdef 	POPT_WCHAR_HACK
+#include <wchar.h>			/* for mbsrtowcs */
+/*@access mbstate_t @*/
+#endif
 #include "poptint.h"
 
+/*@access poptContext@*/
+
 /**
+ * Display arguments.
  * @param con		context
+ * @param foo		(unused)
  * @param key		option(s)
+ * @param arg		(unused)
+ * @param data		(unused)
  */
 static void displayArgs(poptContext con,
 		/*@unused@*/ UNUSED(enum poptCallbackReason foo),
 		struct poptOption * key, 
 		/*@unused@*/ UNUSED(const char * arg), /*@unused@*/ UNUSED(void * data))
 	/*@globals fileSystem@*/
@@ -49,18 +60,32 @@
 /*@-castfcnptr@*/
 /*@observer@*/ /*@unchecked@*/
 struct poptOption poptHelpOptions[] = {
   { NULL, '\0', POPT_ARG_CALLBACK, (void *)&displayArgs, '\0', NULL, NULL },
   { "help", '?', 0, NULL, '?', N_("Show this help message"), NULL },
   { "usage", '\0', 0, NULL, 'u', N_("Display brief usage message"), NULL },
+    POPT_TABLEEND
+} ;
+
+/*@observer@*/ /*@unchecked@*/
+static struct poptOption poptHelpOptions2[] = {
+/*@-readonlytrans@*/
+  { NULL, '\0', POPT_ARG_INTL_DOMAIN, PACKAGE, 0, NULL, NULL},
+/*@=readonlytrans@*/
+  { NULL, '\0', POPT_ARG_CALLBACK, (void *)&displayArgs, '\0', NULL, NULL },
+  { "help", '?', 0, NULL, '?', N_("Show this help message"), NULL },
+  { "usage", '\0', 0, NULL, 'u', N_("Display brief usage message"), NULL },
 #ifdef	NOTYET
   { "defaults", '\0', POPT_ARG_NONE, &show_option_defaults, 0,
 	N_("Display option defaults in message"), NULL },
 #endif
     POPT_TABLEEND
 } ;
+
+/*@observer@*/ /*@unchecked@*/
+struct poptOption * poptHelpOptionsI18N = poptHelpOptions2;
 /*@=castfcnptr@*/
 
 /**
  * @param table		option(s)
  */
 /*@observer@*/ /*@null@*/ static const char *
@@ -80,13 +105,13 @@
 /**
  * @param opt		option(s)
  * @param translation_domain	translation domain
  */
 /*@observer@*/ /*@null@*/ static const char *
 getArgDescrip(const struct poptOption * opt,
-		/*@-paramuse@*/		/* FIX: wazzup? */
+		/*@-paramuse@*/ /* FIX: i18n macros disabled with lclint */
 		/*@null@*/ UNUSED(const char * translation_domain))
 		/*@=paramuse@*/
 	/*@*/
 {
     if (!(opt->argInfo & POPT_ARG_MASK)) return NULL;
 
@@ -94,133 +119,148 @@
 	if (opt->argDescrip) return POPT_(opt->argDescrip);
 
     if (opt->argDescrip) return D_(translation_domain, opt->argDescrip);
 
     switch (opt->argInfo & POPT_ARG_MASK) {
     case POPT_ARG_NONE:		return POPT_("NONE");
+#ifdef	DYING
     case POPT_ARG_VAL:		return POPT_("VAL");
+#else
+    case POPT_ARG_VAL:		return NULL;
+#endif
     case POPT_ARG_INT:		return POPT_("INT");
     case POPT_ARG_LONG:		return POPT_("LONG");
     case POPT_ARG_STRING:	return POPT_("STRING");
     case POPT_ARG_FLOAT:	return POPT_("FLOAT");
     case POPT_ARG_DOUBLE:	return POPT_("DOUBLE");
     default:			return POPT_("ARG");
     }
 }
 
 /**
+ * Display default value for an option.
+ * @param lineLength	display positions remaining
  * @param opt		option(s)
  * @param translation_domain	translation domain
+ * @return
  */
 static /*@only@*/ /*@null@*/ char *
-singleOptionDefaultValue(int lineLength,
+singleOptionDefaultValue(size_t lineLength,
 		const struct poptOption * opt,
-		/*@-paramuse@*/	/* FIX: i18n macros disable with lclint */
+		/*@-paramuse@*/ /* FIX: i18n macros disabled with lclint */
 		/*@null@*/ UNUSED(const char * translation_domain))
 		/*@=paramuse@*/
 	/*@*/
 {
     const char * defstr = D_(translation_domain, "default");
-    char * le = malloc(4*lineLength + 1);
+    size_t limit, bufsize = 4*lineLength + 1;
+    char * le = malloc(bufsize);
     char * l = le;
 
     if (le == NULL) return NULL;	/* XXX can't happen */
-    *le = '\0';
+/*@-boundswrite@*/
     *le++ = '(';
-    strcpy(le, defstr);	le += strlen(le);
+    le += strlcpy(le, defstr, bufsize - 3);
     *le++ = ':';
     *le++ = ' ';
+    limit = bufsize - (le - l) - 1; /* -1 for closing paren */
     if (opt->arg)	/* XXX programmer error */
     switch (opt->argInfo & POPT_ARG_MASK) {
     case POPT_ARG_VAL:
     case POPT_ARG_INT:
     {	long aLong = *((int *)opt->arg);
-	sprintf(le, "%ld", aLong);
-	le += strlen(le);
+	le += snprintf(le, limit, "%ld", aLong);
     }	break;
     case POPT_ARG_LONG:
     {	long aLong = *((long *)opt->arg);
-	sprintf(le, "%ld", aLong);
-	le += strlen(le);
+	le += snprintf(le, limit, "%ld", aLong);
     }	break;
     case POPT_ARG_FLOAT:
     {	double aDouble = *((float *)opt->arg);
-	sprintf(le, "%g", aDouble);
-	le += strlen(le);
+	le += snprintf(le, limit, "%g", aDouble);
     }	break;
     case POPT_ARG_DOUBLE:
     {	double aDouble = *((double *)opt->arg);
-	sprintf(le, "%g", aDouble);
-	le += strlen(le);
+	le += snprintf(le, limit, "%g", aDouble);
     }	break;
     case POPT_ARG_STRING:
     {	const char * s = *(const char **)opt->arg;
 	if (s == NULL) {
-	    strcpy(le, "null");	le += strlen(le);
+	    le += strlcpy(le, "null", limit);
 	} else {
-	    size_t slen = 4*lineLength - (le - l) - sizeof("\"...\")");
+	    size_t len;
+	    limit -= 2; /* make room for quotes */
 	    *le++ = '"';
-	    strncpy(le, s, slen); le[slen] = '\0'; le += strlen(le);	
-	    if (slen < strlen(s)) {
-		strcpy(le, "...");	le += strlen(le);
-	    }
+	    len = strlcpy(le, s, limit);
+	    if (len >= limit) {
+		le += limit - 3 - 1;
+		*le++ = '.'; *le++ = '.'; *le++ = '.';
+	    } else
+		le += len;
 	    *le++ = '"';
 	}
     }	break;
     case POPT_ARG_NONE:
     default:
 	l = _free(l);
 	return NULL;
 	/*@notreached@*/ break;
     }
     *le++ = ')';
     *le = '\0';
+/*@=boundswrite@*/
 
     return l;
 }
 
 /**
+ * Display help text for an option.
  * @param fp		output file handle
+ * @param maxLeftCol	largest argument display width
  * @param opt		option(s)
  * @param translation_domain	translation domain
  */
-static void singleOptionHelp(FILE * fp, int maxLeftCol, 
+static void singleOptionHelp(FILE * fp, size_t maxLeftCol, 
 		const struct poptOption * opt,
-		/*@null@*/ const char * translation_domain)
+		/*@null@*/ UNUSED(const char * translation_domain))
 	/*@globals fileSystem @*/
 	/*@modifies *fp, fileSystem @*/
 {
-    int indentLength = maxLeftCol + 5;
-    int lineLength = 79 - indentLength;
-    const unsigned char * help = D_(translation_domain, opt->descrip);
+    size_t indentLength = maxLeftCol + 5;
+    size_t lineLength = 79 - indentLength;
+    const char * help = D_(translation_domain, opt->descrip);
     const char * argDescrip = getArgDescrip(opt, translation_domain);
-    int helpLength;
-    unsigned char * defs = NULL;
-    unsigned char * left;
-    int nb = maxLeftCol + 1;
+    size_t helpLength;
+    char * defs = NULL;
+    char * left;
+    size_t lelen, limit;
+    size_t nb = maxLeftCol + 1;
+    int displaypad = 0;
 
     /* Make sure there's more than enough room in target buffer. */
     if (opt->longName)	nb += strlen(opt->longName);
     if (argDescrip)	nb += strlen(argDescrip);
 
+/*@-boundswrite@*/
     left = malloc(nb);
     if (left == NULL) return;	/* XXX can't happen */
     left[0] = '\0';
     left[maxLeftCol] = '\0';
 
     if (opt->longName && opt->shortName)
-	sprintf(left, "-%c, %s%s", opt->shortName,
+	snprintf(left, nb, "-%c, %s%s", opt->shortName,
 		((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "-" : "--"),
 		opt->longName);
     else if (opt->shortName != '\0') 
-	sprintf(left, "-%c", opt->shortName);
+	snprintf(left, nb, "-%c", opt->shortName);
     else if (opt->longName)
-	sprintf(left, "%s%s",
+	snprintf(left, nb, "%s%s",
 		((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "-" : "--"),
 		opt->longName);
     if (!*left) goto out;
+
     if (argDescrip) {
 	char * le = left + strlen(left);
 
 	if (opt->argInfo & POPT_ARGFLAG_OPTIONAL)
 	    *le++ = '[';
 
@@ -226,34 +266,29 @@
 
 	/* Choose type of output */
 	/*@-branchstate@*/
 	if (opt->argInfo & POPT_ARGFLAG_SHOW_DEFAULT) {
 	    defs = singleOptionDefaultValue(lineLength, opt, translation_domain);
 	    if (defs) {
-		char * t = malloc((help ? strlen(help) : 0) +
-				strlen(defs) + sizeof(" "));
+		size_t bufsize = (help ? strlen(help) : 0) + sizeof " " + strlen(defs);
+		char * t = malloc(bufsize);
 		if (t) {
-		    char * te = t;
-		    *te = '\0';
-		    if (help) {
-			strcpy(te, help);	te += strlen(te);
-		    }
-		    *te++ = ' ';
-		    strcpy(te, defs);
+		    snprintf(t, bufsize, "%s %s", help ? help : "", defs);
 		    defs = _free(defs);
 		}
 		defs = t;
 	    }
 	}
 	/*@=branchstate@*/
 
 	if (opt->argDescrip == NULL) {
 	    switch (opt->argInfo & POPT_ARG_MASK) {
 	    case POPT_ARG_NONE:
 		break;
 	    case POPT_ARG_VAL:
+#ifdef	NOTNOW	/* XXX pug ugly nerdy output */
 	    {	long aLong = opt->val;
 		int ops = (opt->argInfo & POPT_ARGFLAG_LOGICALOPS);
 		int negate = (opt->argInfo & POPT_ARGFLAG_NOT);
 
 		/* Don't bother displaying typical values */
 		if (!ops && (aLong == 0L || aLong == 1L || aLong == -1L))
@@ -269,91 +304,122 @@
 		case POPT_ARGFLAG_XOR:
 		    *le++ = '^';
 		    /*@innerbreak@*/ break;
 		default:
 		    /*@innerbreak@*/ break;
 		}
-		*le++ = '=';
+		*le++ = (opt->longName != NULL ? '=' : ' ');
 		if (negate) *le++ = '~';
 		/*@-formatconst@*/
-		sprintf(le, (ops ? "0x%lx" : "%ld"), aLong);
-		le += strlen(le);
+		limit = nb - (le - left);
+		lelen = snprintf(le, limit, (ops ? "0x%lx" : "%ld"), aLong);
+		le += lelen >= limit ? limit - 1 : lelen;
 		/*@=formatconst@*/
 		*le++ = ']';
-	    }	break;
+	    }
+#endif
+		break;
 	    case POPT_ARG_INT:
 	    case POPT_ARG_LONG:
 	    case POPT_ARG_FLOAT:
 	    case POPT_ARG_DOUBLE:
 	    case POPT_ARG_STRING:
-		*le++ = '=';
-		strcpy(le, argDescrip);		le += strlen(le);
+		*le++ = (opt->longName != NULL ? '=' : ' ');
+		limit = nb - (le - left);
+		lelen = strlcpy(le, argDescrip, limit);
+		le += lelen >= limit ? limit - 1 : lelen;
 		break;
 	    default:
 		break;
 	    }
 	} else {
+
 	    *le++ = '=';
-	    strcpy(le, argDescrip);		le += strlen(le);
+	    limit = nb - (le - left);
+	    lelen = strlcpy(le, argDescrip, limit);
+	    if (lelen >= limit)
+		lelen = limit - 1;
+	    le += lelen;
+
+#ifdef	POPT_WCHAR_HACK
+	    {	const char * scopy = argDescrip;
+		mbstate_t t;
+		size_t n;
+
+		memset ((void *)&t, '\0', sizeof (t));	/* In initial state.  */
+		/* Determine number of characters.  */
+		n = mbsrtowcs (NULL, &scopy, strlen(scopy), &t);
+
+		displaypad = (int) (lelen-n);
+	    }
+#endif
 	}
 	if (opt->argInfo & POPT_ARGFLAG_OPTIONAL)
 	    *le++ = ']';
 	*le = '\0';
     }
+/*@=boundswrite@*/
 
     if (help)
-	fprintf(fp,"  %-*s   ", maxLeftCol, left);
+	fprintf(fp,"  %-*s   ", (int)maxLeftCol+displaypad, left);
     else {
 	fprintf(fp,"  %s\n", left); 
 	goto out;
     }
 
     left = _free(left);
+/*@-branchstate@*/
     if (defs) {
-	help = defs; defs = NULL;
+	help = defs;
+	defs = NULL;
     }
+/*@=branchstate@*/
 
     helpLength = strlen(help);
+/*@-boundsread@*/
     while (helpLength > lineLength) {
-	const unsigned char * ch;
-	char format[10];
+	const char * ch;
+	char format[16];
 
 	ch = help + lineLength - 1;
-	while (ch > help && !isspace(*ch)) ch--;
+	while (ch > help && !isSpace(ch)) ch--;
 	if (ch == help) break;		/* give up */
-	while (ch > (help + 1) && isspace(*ch)) ch--;
+	while (ch > (help + 1) && isSpace(ch)) ch--;
 	ch++;
 
-	sprintf(format, "%%.%ds\n%%%ds", (int) (ch - help), indentLength);
+	snprintf(format, sizeof format, "%%.%ds\n%%%ds", (int) (ch - help), (int) indentLength);
 	/*@-formatconst@*/
 	fprintf(fp, format, help, " ");
 	/*@=formatconst@*/
 	help = ch;
-	while (isspace(*help) && *help) help++;
+	while (isSpace(help) && *help) help++;
 	helpLength = strlen(help);
     }
+/*@=boundsread@*/
 
     if (helpLength) fprintf(fp, "%s\n", help);
 
 out:
     /*@-dependenttrans@*/
     defs = _free(defs);
     /*@=dependenttrans@*/
     left = _free(left);
 }
 
 /**
+ * Find display width for longest argument string.
  * @param opt		option(s)
  * @param translation_domain	translation domain
+ * @return		display width
  */
-static int maxArgWidth(const struct poptOption * opt,
-		       /*@null@*/ const char * translation_domain)
+static size_t maxArgWidth(const struct poptOption * opt,
+		       /*@null@*/ UNUSED(const char * translation_domain))
 	/*@*/
 {
-    int max = 0;
-    int len = 0;
+    size_t max = 0;
+    size_t len = 0;
     const char * s;
     
     if (opt != NULL)
     while (opt->longName || opt->shortName || opt->arg) {
 	if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
 	    if (opt->arg)	/* XXX program error */
@@ -367,14 +433,32 @@
 		len += ((opt->argInfo & POPT_ARGFLAG_ONEDASH)
 			? sizeof("-")-1 : sizeof("--")-1);
 		len += strlen(opt->longName);
 	    }
 
 	    s = getArgDescrip(opt, translation_domain);
+
+#ifdef POPT_WCHAR_HACK
+	    /* XXX Calculate no. of display characters. */
+	    if (s) {
+		const char * scopy = s;
+		mbstate_t t;
+		size_t n;
+
+/*@-boundswrite@*/
+		memset ((void *)&t, '\0', sizeof (t));	/* In initial state.  */
+/*@=boundswrite@*/
+		/* Determine number of characters.  */
+		n = mbsrtowcs (NULL, &scopy, strlen(scopy), &t);
+		len += sizeof("=")-1 + n;
+	    }
+#else
 	    if (s)
 		len += sizeof("=")-1 + strlen(s);
+#endif
+
 	    if (opt->argInfo & POPT_ARGFLAG_OPTIONAL) len += sizeof("[]")-1;
 	    if (len > max) max = len;
 	}
 
 	opt++;
     }
@@ -384,17 +468,18 @@
 
 /**
  * Display popt alias and exec help.
  * @param fp		output file handle
  * @param items		alias/exec array
  * @param nitems	no. of alias/exec entries
+ * @param left		largest argument display width
  * @param translation_domain	translation domain
  */
 static void itemHelp(FILE * fp,
-		/*@null@*/ poptItem items, int nitems, int left,
-		/*@null@*/ const char * translation_domain)
+		/*@null@*/ poptItem items, int nitems, size_t left,
+		/*@null@*/ UNUSED(const char * translation_domain))
 	/*@globals fileSystem @*/
 	/*@modifies *fp, fileSystem @*/
 {
     poptItem item;
     int i;
 
@@ -406,19 +491,22 @@
 	    !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN))
 	    singleOptionHelp(fp, left, opt, translation_domain);
     }
 }
 
 /**
+ * Display help text for a table of options.
+ * @param con		context
  * @param fp		output file handle
  * @param table		option(s)
+ * @param left		largest argument display width
  * @param translation_domain	translation domain
  */
 static void singleTableHelp(poptContext con, FILE * fp,
-		/*@null@*/ const struct poptOption * table, int left,
-		/*@null@*/ const char * translation_domain)
+		/*@null@*/ const struct poptOption * table, size_t left,
+		/*@null@*/ UNUSED(const char * translation_domain))
 	/*@globals fileSystem @*/
 	/*@modifies *fp, fileSystem @*/
 {
     const struct poptOption * opt;
     const char *sub_transdom;
 
@@ -460,93 +548,126 @@
 {
     int len = 6;
     const char * fn;
 
     fprintf(fp, POPT_("Usage:"));
     if (!(con->flags & POPT_CONTEXT_KEEP_FIRST)) {
-	/*@-nullderef@*/	/* LCL: wazzup? */
+/*@-boundsread@*/
+	/*@-nullderef -type@*/	/* LCL: wazzup? */
 	fn = con->optionStack->argv[0];
-	/*@=nullderef@*/
+	/*@=nullderef =type@*/
+/*@=boundsread@*/
 	if (fn == NULL) return len;
 	if (strchr(fn, '/')) fn = strrchr(fn, '/') + 1;
 	fprintf(fp, " %s", fn);
 	len += strlen(fn) + 1;
     }
 
     return len;
 }
 
 void poptPrintHelp(poptContext con, FILE * fp, /*@unused@*/ UNUSED(int flags))
 {
-    int leftColWidth;
+    size_t leftColWidth;
 
     (void) showHelpIntro(con, fp);
     if (con->otherHelp)
 	fprintf(fp, " %s\n", con->otherHelp);
     else
 	fprintf(fp, " %s\n", POPT_("[OPTION...]"));
 
     leftColWidth = maxArgWidth(con->options, NULL);
     singleTableHelp(con, fp, con->options, leftColWidth, NULL);
 }
 
 /**
+ * Display usage text for an option.
  * @param fp		output file handle
+ * @param cursor	current display position
  * @param opt		option(s)
  * @param translation_domain	translation domain
  */
-static int singleOptionUsage(FILE * fp, int cursor, 
+static size_t singleOptionUsage(FILE * fp, size_t cursor, 
 		const struct poptOption * opt,
 		/*@null@*/ const char *translation_domain)
 	/*@globals fileSystem @*/
 	/*@modifies *fp, fileSystem @*/
 {
-    int len = 3;
+    size_t len = 4;
     char shortStr[2] = { '\0', '\0' };
     const char * item = shortStr;
     const char * argDescrip = getArgDescrip(opt, translation_domain);
 
-    if (opt->shortName!= '\0' ) {
-	if (!(opt->argInfo & POPT_ARG_MASK)) 
-	    return cursor;	/* we did these already */
+    if (opt->shortName != '\0' && opt->longName != NULL) {
+	len += 2;
+	if (!(opt->argInfo & POPT_ARGFLAG_ONEDASH)) len++;
+	len += strlen(opt->longName);
+    } else if (opt->shortName != '\0') {
 	len++;
 	shortStr[0] = opt->shortName;
 	shortStr[1] = '\0';
     } else if (opt->longName) {
-	len += 1 + strlen(opt->longName);
+	len += strlen(opt->longName);
+	if (!(opt->argInfo & POPT_ARGFLAG_ONEDASH)) len++;
 	item = opt->longName;
     }
 
-    if (len == 3) return cursor;
+    if (len == 4) return cursor;
 
+#ifdef POPT_WCHAR_HACK
+    /* XXX Calculate no. of display characters. */
+    if (argDescrip) {
+	const char * scopy = argDescrip;
+	mbstate_t t;
+	size_t n;
+
+/*@-boundswrite@*/
+	memset ((void *)&t, '\0', sizeof (t));	/* In initial state.  */
+/*@=boundswrite@*/
+	/* Determine number of characters.  */
+	n = mbsrtowcs (NULL, &scopy, strlen(scopy), &t);
+	len += sizeof("=")-1 + n;
+    }
+#else
     if (argDescrip) 
-	len += strlen(argDescrip) + 1;
+	len += sizeof("=")-1 + strlen(argDescrip);
+#endif
 
     if ((cursor + len) > 79) {
 	fprintf(fp, "\n       ");
 	cursor = 7;
     } 
 
-    fprintf(fp, " [-%s%s%s%s]",
-	((opt->shortName || (opt->argInfo & POPT_ARGFLAG_ONEDASH)) ? "" : "-"),
-	item,
-	(argDescrip ? (opt->shortName != '\0' ? " " : "=") : ""),
-	(argDescrip ? argDescrip : ""));
+    if (opt->longName && opt->shortName) {
+	fprintf(fp, " [-%c|-%s%s%s%s]",
+	    opt->shortName, ((opt->argInfo & POPT_ARGFLAG_ONEDASH) ? "" : "-"),
+	    opt->longName,
+	    (argDescrip ? " " : ""),
+	    (argDescrip ? argDescrip : ""));
+    } else {
+	fprintf(fp, " [-%s%s%s%s]",
+	    ((opt->shortName || (opt->argInfo & POPT_ARGFLAG_ONEDASH)) ? "" : "-"),
+	    item,
+	    (argDescrip ? (opt->shortName != '\0' ? " " : "=") : ""),
+	    (argDescrip ? argDescrip : ""));
+    }
 
     return cursor + len + 1;
 }
 
 /**
  * Display popt alias and exec usage.
  * @param fp		output file handle
+ * @param cursor	current display position
  * @param item		alias/exec array
  * @param nitems	no. of ara/exec entries
  * @param translation_domain	translation domain
  */
-static int itemUsage(FILE * fp, int cursor, poptItem item, int nitems,
-		/*@null@*/ const char * translation_domain)
+static size_t itemUsage(FILE * fp, size_t cursor,
+		/*@null@*/ poptItem item, int nitems,
+		/*@null@*/ UNUSED(const char * translation_domain))
 	/*@globals fileSystem @*/
 	/*@modifies *fp, fileSystem @*/
 {
     int i;
 
     /*@-branchstate@*/		/* FIX: W2DO? */
@@ -564,88 +685,130 @@
     /*@=branchstate@*/
 
     return cursor;
 }
 
 /**
+ * Keep track of option tables already processed.
+ */
+typedef struct poptDone_s {
+    int nopts;
+    int maxopts;
+    const void ** opts;
+} * poptDone;
+
+/**
+ * Display usage text for a table of options.
+ * @param con		context
  * @param fp		output file handle
+ * @param cursor	current display position
  * @param opt		option(s)
  * @param translation_domain	translation domain
+ * @param done		tables already processed
+ * @return
  */
-static int singleTableUsage(poptContext con, FILE * fp,
-		int cursor, const struct poptOption * opt,
-		/*@null@*/ const char * translation_domain)
+static size_t singleTableUsage(poptContext con, FILE * fp, size_t cursor,
+		/*@null@*/ const struct poptOption * opt,
+		/*@null@*/ UNUSED(const char * translation_domain),
+		/*@null@*/ poptDone done)
 	/*@globals fileSystem @*/
-	/*@modifies *fp, fileSystem @*/
+	/*@modifies *fp, done, fileSystem @*/
 {
     /*@-branchstate@*/		/* FIX: W2DO? */
     if (opt != NULL)
     for (; (opt->longName || opt->shortName || opt->arg) ; opt++) {
         if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INTL_DOMAIN) {
 	    translation_domain = (const char *)opt->arg;
 	} else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE) {
-	    if (opt->arg)	/* XXX program error */
+	    if (done) {
+		int i = 0;
+		for (i = 0; i < done->nopts; i++) {
+/*@-boundsread@*/
+		    const void * that = done->opts[i];
+/*@=boundsread@*/
+		    if (that == NULL || that != opt->arg)
+			/*@innercontinue@*/ continue;
+		    /*@innerbreak@*/ break;
+		}
+		/* Skip if this table has already been processed. */
+		if (opt->arg == NULL || i < done->nopts)
+		    continue;
+/*@-boundswrite@*/
+		if (done->nopts < done->maxopts)
+		    done->opts[done->nopts++] = (const void *) opt->arg;
+/*@=boundswrite@*/
+	    }
 	    cursor = singleTableUsage(con, fp, cursor, opt->arg,
-			translation_domain);
+			translation_domain, done);
 	} else if ((opt->longName || opt->shortName) &&
 		 !(opt->argInfo & POPT_ARGFLAG_DOC_HIDDEN)) {
 	    cursor = singleOptionUsage(fp, cursor, opt, translation_domain);
 	}
     }
     /*@=branchstate@*/
 
     return cursor;
 }
 
 /**
  * Return concatenated short options for display.
+ * @todo Sub-tables should be recursed.
  * @param opt		option(s)
  * @param fp		output file handle
  * @retval str		concatenation of short options
  * @return		length of display string
  */
 static int showShortOptions(const struct poptOption * opt, FILE * fp,
 		/*@null@*/ char * str)
 	/*@globals fileSystem @*/
 	/*@modifies *str, *fp, fileSystem @*/
+	/*@requires maxRead(str) >= 0 @*/
 {
-    char * s = alloca(300);	/* larger then the ascii set */
-
-    s[0] = '\0';
-    /*@-branchstate@*/		/* FIX: W2DO? */
-    if (str == NULL) {
-	memset(s, 0, sizeof(s));
-	str = s;
-    }
-    /*@=branchstate@*/
+    /* bufsize larger then the ascii set, lazy alloca on top level call. */
+    char * s = (str != NULL ? str : memset(alloca(300), 0, 300));
+    int len = 0;
 
+/*@-boundswrite@*/
     if (opt != NULL)
     for (; (opt->longName || opt->shortName || opt->arg); opt++) {
 	if (opt->shortName && !(opt->argInfo & POPT_ARG_MASK))
-	    str[strlen(str)] = opt->shortName;
+	    s[strlen(s)] = opt->shortName;
 	else if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_INCLUDE_TABLE)
 	    if (opt->arg)	/* XXX program error */
-		(void) showShortOptions(opt->arg, fp, str);
+		len = showShortOptions(opt->arg, fp, s);
     } 
+/*@=boundswrite@*/
 
-    if (s != str || *s != '\0')
-	return 0;
-
-    fprintf(fp, " [-%s]", s);
-    return strlen(s) + 4;
+    /* On return to top level, print the short options, return print length. */
+    if (s == str && *s != '\0') {
+	fprintf(fp, " [-%s]", s);
+	len = strlen(s) + sizeof(" [-]")-1;
+    }
+    return len;
 }
 
 void poptPrintUsage(poptContext con, FILE * fp, /*@unused@*/ UNUSED(int flags))
 {
-    int cursor;
+    poptDone done = memset(alloca(sizeof(*done)), 0, sizeof(*done));
+    size_t cursor;
+
+    done->nopts = 0;
+    done->maxopts = 64;
+    cursor = done->maxopts * sizeof(*done->opts);
+/*@-boundswrite@*/
+    done->opts = memset(alloca(cursor), 0, cursor);
+    /*@-keeptrans@*/
+    done->opts[done->nopts++] = (const void *) con->options;
+    /*@=keeptrans@*/
+/*@=boundswrite@*/
 
     cursor = showHelpIntro(con, fp);
     cursor += showShortOptions(con->options, fp, NULL);
-    (void) singleTableUsage(con, fp, cursor, con->options, NULL);
-    (void) itemUsage(fp, cursor, con->aliases, con->numAliases, NULL);
-    (void) itemUsage(fp, cursor, con->execs, con->numExecs, NULL);
+    cursor = singleTableUsage(con, fp, cursor, con->options, NULL, done);
+    cursor = itemUsage(fp, cursor, con->aliases, con->numAliases, NULL);
+    cursor = itemUsage(fp, cursor, con->execs, con->numExecs, NULL);
 
     if (con->otherHelp) {
 	cursor += strlen(con->otherHelp) + 1;
 	if (cursor > 79) fprintf(fp, "\n       ");
 	fprintf(fp, " %s", con->otherHelp);
     }
@@ -655,7 +818,6 @@
 
 void poptSetOtherOptionHelp(poptContext con, const char * text)
 {
     con->otherHelp = _free(con->otherHelp);
     con->otherHelp = xstrdup(text);
 }
-/*@=type@*/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/poptint.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptint.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/poptint.h	2002-07-28 02:32:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptint.h	2006-11-09 10:14:38.000000000 +0800
@@ -19,74 +19,100 @@
 	/*@modifies p @*/
 {
     if (p != NULL)	free((void *)p);
     return NULL;
 }
 
+static inline int
+isSpace(const char *ptr)
+{
+    return isspace(*(unsigned char *)ptr);
+}
+
 /* Bit mask macros. */
+/*@-exporttype -redef @*/
 typedef	unsigned int __pbm_bits;
+/*@=exporttype =redef @*/
 #define	__PBM_NBITS		(8 * sizeof (__pbm_bits))
 #define	__PBM_IX(d)		((d) / __PBM_NBITS)
 #define __PBM_MASK(d)		((__pbm_bits) 1 << (((unsigned)(d)) % __PBM_NBITS))
+/*@-exporttype -redef @*/
 typedef struct {
     __pbm_bits bits[1];
 } pbm_set;
+/*@=exporttype =redef @*/
 #define	__PBM_BITS(set)	((set)->bits)
 
 #define	PBM_ALLOC(d)	calloc(__PBM_IX (d) + 1, sizeof(__pbm_bits))
 #define	PBM_FREE(s)	_free(s);
 #define PBM_SET(d, s)   (__PBM_BITS (s)[__PBM_IX (d)] |= __PBM_MASK (d))
 #define PBM_CLR(d, s)   (__PBM_BITS (s)[__PBM_IX (d)] &= ~__PBM_MASK (d))
 #define PBM_ISSET(d, s) ((__PBM_BITS (s)[__PBM_IX (d)] & __PBM_MASK (d)) != 0)
 
 struct optionStackEntry {
     int argc;
-/*@only@*/ /*@null@*/ const char ** argv;
-/*@only@*/ /*@null@*/ pbm_set * argb;
+/*@only@*/ /*@null@*/
+    const char ** argv;
+/*@only@*/ /*@null@*/
+    pbm_set * argb;
     int next;
-/*@only@*/ /*@null@*/ const char * nextArg;
-/*@keep@*/ /*@null@*/ const char * nextCharArg;
-/*@dependent@*/ /*@null@*/ poptItem currAlias;
+/*@only@*/ /*@null@*/
+    const char * nextArg;
+/*@observer@*/ /*@null@*/
+    const char * nextCharArg;
+/*@dependent@*/ /*@null@*/
+    poptItem currAlias;
     int stuffed;
 };
 
 struct poptContext_s {
     struct optionStackEntry optionStack[POPT_OPTION_DEPTH];
-/*@dependent@*/ struct optionStackEntry * os;
-/*@owned@*/ /*@null@*/ const char ** leftovers;
+/*@dependent@*/
+    struct optionStackEntry * os;
+/*@owned@*/ /*@null@*/
+    const char ** leftovers;
     int numLeftovers;
     int nextLeftover;
-/*@keep@*/ const struct poptOption * options;
+/*@keep@*/
+    const struct poptOption * options;
     int restLeftover;
-/*@only@*/ /*@null@*/ const char * appName;
-/*@only@*/ /*@null@*/ poptItem aliases;
+/*@only@*/ /*@null@*/
+    const char * appName;
+/*@only@*/ /*@null@*/
+    poptItem aliases;
     int numAliases;
     int flags;
-/*@owned@*/ /*@null@*/ poptItem execs;
+/*@owned@*/ /*@null@*/
+    poptItem execs;
     int numExecs;
-/*@only@*/ /*@null@*/ const char ** finalArgv;
+/*@only@*/ /*@null@*/
+    const char ** finalArgv;
     int finalArgvCount;
     int finalArgvAlloced;
-/*@dependent@*/ /*@null@*/ poptItem doExec;
-/*@only@*/ const char * execPath;
+/*@dependent@*/ /*@null@*/
+    poptItem doExec;
+/*@only@*/
+    const char * execPath;
     int execAbsolute;
-/*@only@*/ const char * otherHelp;
-/*@null@*/ pbm_set * arg_strip;
+/*@only@*/ /*@relnull@*/
+    const char * otherHelp;
+/*@null@*/
+    pbm_set * arg_strip;
 };
 
 #ifdef HAVE_LIBINTL_H
 #include <libintl.h>
 #endif
 
 #if defined(HAVE_GETTEXT) && !defined(__LCLINT__)
 #define _(foo) gettext(foo)
 #else
 #define _(foo) foo
 #endif
 
-#if defined(HAVE_DGETTEXT) && !defined(__LCLINT__)
+#if defined(HAVE_DCGETTEXT) && !defined(__LCLINT__)
 #define D_(dom, str) dgettext(dom, str)
 #define POPT_(foo) D_("popt", foo)
 #else
 #define D_(dom, str) str
 #define POPT_(foo) foo
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/poptparse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptparse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/poptparse.c	2004-01-28 00:27:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/poptparse.c	2006-11-10 11:34:51.000000000 +0800
@@ -1,18 +1,21 @@
 /** \ingroup popt
  * \file popt/poptparse.c
  */
 
-/* (C) 1998-2000 Red Hat, Inc. -- Licensing details are in the COPYING
+/* (C) 1998-2002 Red Hat, Inc. -- Licensing details are in the COPYING
    file accompanying popt source distributions, available from 
    ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 
+#include "poptint.h"
+
 #define POPT_ARGV_ARRAY_GROW_DELTA 5
 
+/*@-boundswrite@*/
 int poptDupArgv(int argc, const char **argv,
 		int * argcPtr, const char *** argvPtr)
 {
     size_t nb = (argc + 1) * sizeof(*argv);
     const char ** argv2;
     char * dst;
@@ -32,13 +35,13 @@
     argv2 = (void *) dst;
     dst += (argc + 1) * sizeof(*argv);
 
     /*@-branchstate@*/
     for (i = 0; i < argc; i++) {
 	argv2[i] = dst;
-	dst += strlen(strcpy(dst, argv[i])) + 1;
+	dst += strlcpy(dst, argv[i], nb) + 1;
     }
     /*@=branchstate@*/
     argv2[argc] = NULL;
 
     if (argvPtr) {
 	*argvPtr = argv2;
@@ -47,17 +50,19 @@
 	argv2 = NULL;
     }
     if (argcPtr)
 	*argcPtr = argc;
     return 0;
 }
+/*@=boundswrite@*/
 
-int poptParseArgvString(const unsigned char * s, int * argcPtr, const char *** argvPtr)
+/*@-bounds@*/
+int poptParseArgvString(const char * s, int * argcPtr, const char *** argvPtr)
 {
-    const unsigned char * src;
-    unsigned char quote = '\0';
+    const char * src;
+    char quote = '\0';
     int argvAlloced = POPT_ARGV_ARRAY_GROW_DELTA;
     const char ** argv = malloc(sizeof(*argv) * argvAlloced);
     int argc = 0;
     int buflen = strlen(s) + 1;
     char * buf = memset(alloca(buflen), 0, buflen);
     int rc = POPT_ERROR_MALLOC;
@@ -75,13 +80,13 @@
 		    rc = POPT_ERROR_BADQUOTE;
 		    goto exit;
 		}
 		if (*src != quote) *buf++ = '\\';
 	    }
 	    *buf++ = *src;
-	} else if (isspace(*src)) {
+	} else if (isSpace(src)) {
 	    if (*argv[argc] != '\0') {
 		buf++, argc++;
 		if (argc == argvAlloced) {
 		    argvAlloced += POPT_ARGV_ARRAY_GROW_DELTA;
 		    argv = realloc(argv, sizeof(*argv) * argvAlloced);
 		    if (argv == NULL) goto exit;
@@ -113,6 +118,112 @@
     rc = poptDupArgv(argc, argv, argcPtr, argvPtr);
 
 exit:
     if (argv) free(argv);
     return rc;
 }
+/*@=bounds@*/
+
+/* still in the dev stage.
+ * return values, perhaps 1== file erro
+ * 2== line to long
+ * 3== umm.... more?
+ */
+int poptConfigFileToString(FILE *fp, char ** argstrp, /*@unused@*/ UNUSED(int flags))
+{
+    char line[999];
+    char * argstr;
+    char * p;
+    char * q;
+    char * x;
+    int t;
+    int argvlen = 0;
+    size_t maxlinelen = sizeof(line);
+    size_t linelen;
+    int maxargvlen = 480;
+    int linenum = 0;
+
+    *argstrp = NULL;
+
+    /*   |   this_is   =   our_line
+     *	     p             q      x
+     */
+
+    if (fp == NULL)
+	return POPT_ERROR_NULLARG;
+
+    argstr = calloc(maxargvlen, sizeof(*argstr));
+    if (argstr == NULL) return POPT_ERROR_MALLOC;
+
+    while (fgets(line, (int)maxlinelen, fp) != NULL) {
+	linenum++;
+	p = line;
+
+	/* loop until first non-space char or EOL */
+	while( *p != '\0' && isSpace(p) )
+	    p++;
+
+	linelen = strlen(p);
+	if (linelen >= maxlinelen-1)
+	    return POPT_ERROR_OVERFLOW;	/* XXX line too long */
+
+	if (*p == '\0' || *p == '\n') continue;	/* line is empty */
+	if (*p == '#') continue;		/* comment line */
+
+	q = p;
+
+	while (*q != '\0' && (!isSpace(q)) && *q != '=')
+	    q++;
+
+	if (isSpace(q)) {
+	    /* a space after the name, find next non space */
+	    *q++='\0';
+	    while( *q != '\0' && isSpace(q) ) q++;
+	}
+	if (*q == '\0') {
+	    /* single command line option (ie, no name=val, just name) */
+	    q[-1] = '\0';		/* kill off newline from fgets() call */
+	    argvlen += (t = q - p) + (sizeof(" --")-1);
+	    if (argvlen >= maxargvlen) {
+		maxargvlen = (t > maxargvlen) ? t*2 : maxargvlen*2;
+		argstr = realloc(argstr, maxargvlen);
+		if (argstr == NULL) return POPT_ERROR_MALLOC;
+	    }
+	    strlcat(argstr, " --", maxargvlen);
+	    strlcat(argstr, p, maxargvlen);
+	    continue;
+	}
+	if (*q != '=')
+	    continue;	/* XXX for now, silently ignore bogus line */
+		
+	/* *q is an equal sign. */
+	*q++ = '\0';
+
+	/* find next non-space letter of value */
+	while (*q != '\0' && isSpace(q))
+	    q++;
+	if (*q == '\0')
+	    continue;	/* XXX silently ignore missing value */
+
+	/* now, loop and strip all ending whitespace */
+	x = p + linelen;
+	while (isSpace(--x))
+	    *x = 0;	/* null out last char if space (including fgets() NL) */
+
+	/* rest of line accept */
+	t = x - p;
+	argvlen += t + (sizeof("' --='")-1);
+	if (argvlen >= maxargvlen) {
+	    maxargvlen = (t > maxargvlen) ? t*2 : maxargvlen*2;
+	    argstr = realloc(argstr, maxargvlen);
+	    if (argstr == NULL) return POPT_ERROR_MALLOC;
+	}
+	strlcat(argstr, " --", maxargvlen);
+	strlcat(argstr, p, maxargvlen);
+	strlcat(argstr, "=\"", maxargvlen);
+	strlcat(argstr, q, maxargvlen);
+	strlcat(argstr, "\"", maxargvlen);
+    }
+
+    *argstrp = argstr;
+    return 0;
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/system.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/system.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/popt/system.h	2004-06-10 05:41:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/popt/system.h	2006-11-09 10:37:38.000000000 +0800
@@ -1,11 +1,21 @@
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#if defined (__GLIBC__) && defined(__LCLINT__)
+/*@-declundef@*/
+/*@unchecked@*/
+extern __const __int32_t *__ctype_tolower;
+/*@unchecked@*/
+extern __const __int32_t *__ctype_toupper;
+/*@=declundef@*/
+#endif
+
 #include <ctype.h>
+
 #include <errno.h>
 #include <fcntl.h>
 #include <limits.h>
 
 #if HAVE_MCHECK_H 
 #include <mcheck.h>
@@ -9,25 +19,38 @@
 
 #if HAVE_MCHECK_H 
 #include <mcheck.h>
 #endif
 
 #include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#if HAVE_UNISTD_H
-#include <unistd.h>
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif
+#ifdef STDC_HEADERS
+# include <stdlib.h>
+# include <stddef.h>
+#else
+# ifdef HAVE_STDLIB_H
+#  include <stdlib.h>
+# endif
+#endif
+#ifdef HAVE_STRING_H
+# if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+#  include <memory.h>
+# endif
+# include <string.h>
+#endif
+#ifdef HAVE_STRINGS_H
+# include <strings.h>
+#endif
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
 #endif
 
-#if !defined(__GNUC__) || defined(APPLE)
-/* Apparently the OS X port of gcc gags on __attribute__.
- *
- * <http://www.opensource.apple.com/bugs/X/gcc/2512150.html> */
+#ifndef __GNUC__
 #define __attribute__(x) 
-
 #endif
 
 #ifdef __NeXT
 /* access macros are not declared in non posix mode in unistd.h -
  don't try to use posix on NeXTstep 3.3 ! */
 #include <libc.h>
@@ -31,30 +54,31 @@
 /* access macros are not declared in non posix mode in unistd.h -
  don't try to use posix on NeXTstep 3.3 ! */
 #include <libc.h>
 #endif
 
 #if defined(__LCLINT__)
-/*@-declundef -incondefs -redecl@*/ /* LCL: missing annotation */
-/*@only@*/ void * alloca (size_t __size)
+/*@-declundef -incondefs @*/ /* LCL: missing annotation */
+/*@only@*/ /*@out@*/
+void * alloca (size_t __size)
 	/*@ensures MaxSet(result) == (__size - 1) @*/
 	/*@*/;
-/*@=declundef =incondefs =redecl@*/
+/*@=declundef =incondefs @*/
 #endif
 
 /* AIX requires this to be the first thing in the file.  */ 
 #ifndef __GNUC__
 # if HAVE_ALLOCA_H
 #  include <alloca.h>
 # else
 #  ifdef _AIX
 #pragma alloca
 #  else
-#   if HAVE_ALLOCA
+#   ifdef HAVE_ALLOCA
 #    ifndef alloca /* predefined by HP cc +Olibcalls */
-char *alloca ();
+char *alloca(size_t size);
 #    endif
 #   else
 #    ifdef alloca
 #     undef alloca
 #    endif
 #    define alloca(sz) malloc(sz) /* Kludge this for now */
@@ -62,21 +86,45 @@
 #  endif
 # endif
 #elif defined(__GNUC__) && defined(__STRICT_ANSI__)
 #define alloca __builtin_alloca
 #endif
 
-/*@-redecl -redef@*/
-/*@mayexit@*/ /*@only@*/ char * xstrdup (const char *str)
-	/*@*/;
-/*@=redecl =redef@*/
+#ifndef HAVE_STRLCPY
+size_t strlcpy(char *d, const char *s, size_t bufsize);
+#endif
+
+#ifndef HAVE_STRLCAT
+size_t strlcat(char *d, const char *s, size_t bufsize);
+#endif
 
 #if HAVE_MCHECK_H && defined(__GNUC__)
-#define	vmefail()	(fprintf(stderr, "virtual memory exhausted.\n"), exit(EXIT_FAILURE), NULL)
-#define xstrdup(_str)   (strcpy((malloc(strlen(_str)+1) ? : vmefail()), (_str)))
+static inline char *
+xstrdup(const char *s)
+{
+    size_t memsize = strlen(s) + 1;
+    char *ptr = malloc(memsize);
+    if (!ptr) {
+	fprintf(stderr, "virtual memory exhausted.\n");
+	exit(EXIT_FAILURE);
+    }
+    strlcpy(ptr, s, memsize);
+    return ptr;
+}
 #else
 #define	xstrdup(_str)	strdup(_str)
 #endif  /* HAVE_MCHECK_H && defined(__GNUC__) */
 
+#if HAVE___SECURE_GETENV && !defined(__LCLINT__)
+#define	getenv(_s)	__secure_getenv(_s)
+#endif
+
+#if !defined HAVE_SNPRINTF || !defined HAVE_C99_VSNPRINTF
+#define snprintf rsync_snprintf
+int snprintf(char *str,size_t count,const char *fmt,...);
+#endif
+
 #define UNUSED(x) x __attribute__((__unused__))
 
+#define PACKAGE "rsync"
+
 #include "popt.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/prepare-source /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/prepare-source
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/prepare-source	2006-10-07 22:39:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/prepare-source	2007-12-18 15:32:47.000000000 +0800
@@ -1,12 +1,51 @@
 #!/bin/sh
-# Use autoconf, autoheader, yodl, etc. to ready the generated files in the
-# release.  This is typically used after applying a diff from the "patches"
-# directory in a CVS-checked-out version.
+# Either use autoconf and autoheader to create configure.sh and config.h.in
+# or (optionally) fetch the latest development versions of generated files.
 #
-# NOTE:  if you use a diff from the "patches" directory of a *release tar*
-# (as opposed to from CVS), this is not needed (but doesn't hurt anything).
+# Specify one action or more than one to provide a fall-back:
+#
+#   build     build the config files [the default w/no arg]
+#   fetch     fetch the latest dev config files
+#   fetchgen  fetch all the latest dev generated files
+#   fetchSRC  fetch the latest dev source files [NON-GENERATED FILES]
+#
+# The script stops after the first successful action.
+
 dir=`dirname $0`
 if test x"$dir" != x -a x"$dir" != x.; then
     cd "$dir"
 fi
-make -f prepare-source.mak
+
+if test $# = 0; then
+    set -- build
+fi
+
+for action in "${@}"; do
+    case "$action" in
+    build|make)
+	make -f prepare-source.mak
+	;;
+    fetch)
+	if perl --version >/dev/null 2>/dev/null; then
+	    files='c*'
+	else
+	    files='[cp]*'
+	fi
+	rsync -pvz rsync://rsync.samba.org/rsyncftp/generated-files/"$files" .
+	;;
+    fetchgen)
+	rsync -pvz rsync://rsync.samba.org/rsyncftp/generated-files/'*' .
+	;;
+    fetchSRC)
+	rsync -pvrz --exclude=/.git/ rsync://rsync.samba.org/ftp/pub/unpacked/rsync/ .
+	;;
+    *)
+	echo "Unknown action: $action"
+	exit 1
+    esac
+    if test $? = 0; then
+	exit
+    fi
+done
+
+exit 1
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/prepare-source.mak /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/prepare-source.mak
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/prepare-source.mak	2006-10-24 08:33:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/prepare-source.mak	2007-11-25 02:54:35.000000000 +0800
@@ -1,25 +1,7 @@
-gen: configure config.h.in proto.h man
+conf: configure.sh config.h.in
 
-configure: configure.in aclocal.m4
-	autoconf
+configure.sh: configure.in aclocal.m4
+	autoconf -o configure.sh
 
 config.h.in: configure.in aclocal.m4
 	autoheader && touch config.h.in
-
-proto.h: *.c lib/compat.c
-	cat *.c lib/compat.c | awk -f mkproto.awk >proto.h.new
-	if diff proto.h proto.h.new >/dev/null; then \
-	  rm proto.h.new; \
-	else \
-	  mv proto.h.new proto.h; \
-	fi
-
-man: rsync.1 rsyncd.conf.5
-
-rsync.1: rsync.yo
-	yodl2man -o rsync.1 rsync.yo
-	-./tweak_manpage_dashes rsync.1
-
-rsyncd.conf.5: rsyncd.conf.yo
-	yodl2man -o rsyncd.conf.5 rsyncd.conf.yo
-	-./tweak_manpage_dashes rsyncd.conf.5
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/progress.c	2006-10-14 07:17:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/progress.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,33 +1,34 @@
 /*
  * Routines to output progress information during a file transfer.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
-extern struct stats stats;
 extern int am_server;
+extern int need_unsorted_flist;
+extern struct stats stats;
+extern struct file_list *cur_flist;
 
 #define PROGRESS_HISTORY_SECS 5
 
 #ifdef GETPGRP_VOID
 #define GETPGRP_ARG
 #else
@@ -39,12 +40,13 @@
 	OFF_T ofs;
 };
 
 static struct progress_history ph_start;
 static struct progress_history ph_list[PROGRESS_HISTORY_SECS];
 static int newest_hpos, oldest_hpos;
+static int current_file_index;
 
 static unsigned long msdiff(struct timeval *t1, struct timeval *t2)
 {
 	return (t2->tv_sec - t1->tv_sec) * 1000L
 	     + (t2->tv_usec - t1->tv_usec) / 1000;
 }
@@ -57,18 +59,17 @@
  * printed for this file, so we should output a newline.  (Not
  * necessarily the same as all bytes being received.)
  **/
 static void rprint_progress(OFF_T ofs, OFF_T size, struct timeval *now,
 			    int is_last)
 {
-	char eol[256];
+	char rembuf[64], eol[128];
 	const char *units;
 	int pct = ofs == size ? 100 : (int) (100.0 * ofs / size);
 	unsigned long diff;
 	double rate, remain;
-	int remain_h, remain_m, remain_s;
 
 	if (is_last) {
 		/* Compute stats based on the starting info. */
 		if (!ph_start.time.tv_sec
 		    || !(diff = msdiff(&ph_start.time, now)))
 			diff = 1;
@@ -91,26 +92,39 @@
 		rate /= 1024.0;
 		units = "MB/s";
 	} else {
 		units = "kB/s";
 	}
 
-	remain_s = (int) remain % 60;
-	remain_m = (int) (remain / 60.0) % 60;
-	remain_h = (int) (remain / 3600.0);
+	if (remain < 0)
+		strlcpy(rembuf, "  ??:??:??", sizeof rembuf);
+	else {
+		snprintf(rembuf, sizeof rembuf, "%4d:%02d:%02d",
+			 (int) (remain / 3600.0),
+			 (int) (remain / 60.0) % 60,
+			 (int) remain % 60);
+	}
 
 	if (is_last) {
 		snprintf(eol, sizeof eol, " (xfer#%d, to-check=%d/%d)\n",
 			stats.num_transferred_files,
-			stats.num_files - stats.current_file_index - 1,
+			stats.num_files - current_file_index - 1,
 			stats.num_files);
 	} else
 		strlcpy(eol, "\r", sizeof eol);
-	rprintf(FCLIENT, "%12s %3d%% %7.2f%s %4d:%02d:%02d%s",
-		human_num(ofs), pct, rate, units,
-		remain_h, remain_m, remain_s, eol);
+	rprintf(FCLIENT, "%12s %3d%% %7.2f%s %s%s",
+		human_num(ofs), pct, rate, units, rembuf, eol);
+}
+
+void set_current_file_index(struct file_struct *file, int ndx)
+{
+	if (need_unsorted_flist)
+		current_file_index = flist_find(cur_flist, file) + cur_flist->ndx_start;
+	else
+		current_file_index = ndx;
+	current_file_index -= cur_flist->flist_num;
 }
 
 void end_progress(OFF_T size)
 {
 	if (!am_server) {
 		struct timeval now;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/proto.h	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/proto.h	2008-03-02 04:12:14.000000000 +0800
@@ -1,32 +1,42 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
-void base64_encode(char *buf, int len, char *out, int pad);
-char *auth_server(int f_in, int f_out, int module, char *host, char *addr,
-		  char *leader);
-void auth_client(int fd, char *user, char *challenge);
-char *get_backup_name(char *fname);
-int make_backup(char *fname);
+void free_acl(stat_x *sxp);
+int get_acl(const char *fname, stat_x *sxp);
+void send_acl(stat_x *sxp, int f);
+void receive_acl(struct file_struct *file, int f);
+void cache_acl(struct file_struct *file, stat_x *sxp);
+int set_acl(const char *fname, const struct file_struct *file, stat_x *sxp);
+void match_acl_ids(void);
+int default_perms_for_dir(const char *dir);
+void base64_encode(const char *buf, int len, char *out, int pad);
+char *auth_server(int f_in, int f_out, int module, const char *host,
+		  const char *addr, const char *leader);
+void auth_client(int fd, const char *user, const char *challenge);
+char *get_backup_name(const char *fname);
+int make_bak_dir(const char *fullpath);
+int make_backup(const char *fname);
 void write_stream_flags(int fd);
 void read_stream_flags(int fd);
+void check_batch_flags(void);
 void write_batch_shell_file(int argc, char *argv[], int file_arg_cnt);
 uint32 get_checksum1(char *buf1, int32 len);
 void get_checksum2(char *buf, int32 len, char *sum);
-void file_checksum(char *fname,char *sum,OFF_T size);
+void file_checksum(char *fname, char *sum, OFF_T size);
 void sum_init(int seed);
-void sum_update(char *p, int32 len);
-void sum_end(char *sum);
+void sum_update(const char *p, int32 len);
+int sum_end(char *sum);
 struct chmod_mode_struct *parse_chmod(const char *modestr,
 				      struct chmod_mode_struct **root_mode_ptr);
 int tweak_mode(int mode, struct chmod_mode_struct *chmod_modes);
 int free_chmod_mode(struct chmod_mode_struct *chmod_modes);
 void close_all(void);
 NORETURN void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
-void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
+void cleanup_set(const char *fnametmp, const char *fname, struct file_struct *file,
 		 int fd_r, int fd_w);
 void cleanup_set_pid(pid_t pid);
 char *client_addr(int fd);
 char *client_name(int fd);
 void client_sockaddr(int fd,
 		     struct sockaddr_storage *ss,
@@ -37,22 +47,24 @@
 		char *port_buf, size_t port_buf_size);
 int compare_addrinfo_sockaddr(const struct addrinfo *ai,
 			      const struct sockaddr_storage *ss);
 int check_name(int fd,
 	       const struct sockaddr_storage *ss,
 	       char *name_buf, size_t name_buf_size);
-int start_socket_client(char *host, char *path, int argc, char *argv[]);
-int start_inband_exchange(char *user, char *path, int f_in, int f_out,
-			  int argc);
+int start_socket_client(char *host, int remote_argc, char *remote_argv[],
+			int argc, char *argv[]);
+int start_inband_exchange(int f_in, int f_out, const char *user, int argc, char *argv[]);
 int start_daemon(int f_in, int f_out);
 int daemon_main(void);
+void set_allow_inc_recurse(void);
 void setup_protocol(int f_out,int f_in);
-int claim_connection(char *fname,int max_connections);
+int claim_connection(char *fname, int max_connections);
 void set_filter_dir(const char *dir, unsigned int dirlen);
 void *push_local_filters(const char *dir, unsigned int dirlen);
 void pop_local_filters(void *mem);
+void change_local_filter_dir(const char *dname, int dlen, int dir_depth);
 int check_filter(struct filter_list_struct *listp, char *name, int name_is_dir);
 void parse_rule(struct filter_list_struct *listp, const char *pattern,
 		uint32 mflags, int xflags);
 void parse_filter_file(struct filter_list_struct *listp, const char *fname,
 		       uint32 mflags, int xflags);
 char *get_rule_prefix(int match_flags, const char *pat, int for_xfer,
@@ -66,258 +78,315 @@
 			    int32 blk_size);
 char *map_ptr(struct map_struct *map, OFF_T offset, int32 len);
 int unmap_file(struct map_struct *map);
 void init_flist(void);
 void show_flist_stats(void);
 int link_stat(const char *path, STRUCT_STAT *stp, int follow_dirlinks);
-void flist_expand(struct file_list *flist);
-struct file_struct *make_file(char *fname, struct file_list *flist,
-			      STRUCT_STAT *stp, unsigned short flags,
-			      int filter_level);
+int push_pathname(const char *dir, int len);
+struct file_struct *make_file(const char *fname, struct file_list *flist,
+			      STRUCT_STAT *stp, int flags, int filter_level);
+void unmake_file(struct file_struct *file);
+void send_extra_file_list(int f, int at_least);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
+void recv_additional_file_list(int f);
 int flist_find(struct file_list *flist, struct file_struct *f);
-void clear_file(struct file_struct *file, struct file_list *flist);
-struct file_list *flist_new(int with_hlink, char *msg);
+void clear_file(struct file_struct *file);
+struct file_list *flist_new(int flags, char *msg);
 void flist_free(struct file_list *flist);
-int f_name_cmp(struct file_struct *f1, struct file_struct *f2);
-char *f_name(struct file_struct *f, char *fbuf);
-struct file_list *get_dirlist(char *dirname, int dlen,
-			      int ignore_filter_rules);
-int unchanged_attrs(struct file_struct *file, STRUCT_STAT *st);
-void itemize(struct file_struct *file, int ndx, int statret, STRUCT_STAT *st,
-	     int32 iflags, uchar fnamecmp_type, char *xname);
+int f_name_cmp(const struct file_struct *f1, const struct file_struct *f2);
+int f_name_has_prefix(const struct file_struct *f1, const struct file_struct *f2);
+char *f_name_buf(void);
+char *f_name(const struct file_struct *f, char *fbuf);
+struct file_list *get_dirlist(char *dirname, int dlen, int ignore_filter_rules);
+int unchanged_attrs(const char *fname, struct file_struct *file, stat_x *sxp);
+void itemize(const char *fnamecmp, struct file_struct *file, int ndx, int statret,
+	     stat_x *sxp, int32 iflags, uchar fnamecmp_type,
+	     const char *xname);
 int unchanged_file(char *fn, struct file_struct *file, STRUCT_STAT *st);
-void check_for_finished_hlinks(int itemizing, enum logcode code);
-void generate_files(int f_out, struct file_list *flist, char *local_name);
+void check_for_finished_files(int itemizing, enum logcode code, int check_redo);
+void generate_files(int f_out, const char *local_name);
+struct hashtable *hashtable_create(int size, int key64);
+void hashtable_destroy(struct hashtable *tbl);
+void *hashtable_find(struct hashtable *tbl, int64 key, int allocate_if_missing);
 void init_hard_links(void);
-int hard_link_check(struct file_struct *file, int ndx, char *fname,
-		    int statret, STRUCT_STAT *st, int itemizing,
-		    enum logcode code, int skip);
-int hard_link_one(struct file_struct *file, int ndx, char *fname,
-		  int statret, STRUCT_STAT *st, char *toname, int terse,
-		  int itemizing, enum logcode code);
-void hard_link_cluster(struct file_struct *file, int master, int itemizing,
-		       enum logcode code);
+struct ht_int64_node *idev_find(int64 dev, int64 ino);
+void idev_destroy(void);
+void match_hard_links(struct file_list *flist);
+int hard_link_check(struct file_struct *file, int ndx, const char *fname,
+		    int statret, stat_x *sxp, int itemizing,
+		    enum logcode code);
+int hard_link_one(struct file_struct *file, const char *fname,
+		  const char *oldname, int terse);
+void finish_hard_link(struct file_struct *file, const char *fname, int fin_ndx,
+		      STRUCT_STAT *stp, int itemizing, enum logcode code,
+		      int alt_dest);
 void io_set_sock_fds(int f_in, int f_out);
 void set_io_timeout(int secs);
 void set_msg_fd_in(int fd);
 void set_msg_fd_out(int fd);
 void increment_active_files(int ndx, int itemizing, enum logcode code);
-void decrement_active_files(int ndx);
-int send_msg(enum msgcode code, char *buf, int len);
-int get_redo_num(int itemizing, enum logcode code);
+int send_msg(enum msgcode code, const char *buf, int len, int convert);
+void send_msg_int(enum msgcode code, int num);
+void wait_for_receiver(void);
+int get_redo_num(void);
 int get_hlink_num(void);
 void io_set_filesfrom_fds(int f_in, int f_out);
-int read_filesfrom_line(int fd, char *fname);
-void io_start_buffering_out(void);
-void io_start_buffering_in(void);
-void io_end_buffering(void);
-void maybe_flush_socket(void);
+int read_line(int fd, char *buf, size_t bufsiz, int flags);
+int read_args(int f_in, char *mod_name, char *buf, size_t bufsiz, int rl_nulls,
+	      char ***argv_p, int *argc_p, char **request_p);
+int io_start_buffering_out(int f_out);
+int io_start_buffering_in(int f_in);
+void io_end_buffering_in(void);
+void io_end_buffering_out(void);
+void maybe_flush_socket(int important);
 void maybe_send_keepalive(void);
-int read_shortint(int f);
+void start_flist_forward(int f_in);
+void stop_flist_forward();
+unsigned short read_shortint(int f);
 int32 read_int(int f);
+int32 read_varint(int f);
+int64 read_varlong(int f, uchar min_bytes);
 int64 read_longint(int f);
-void read_buf(int f,char *buf,size_t len);
-void read_sbuf(int f,char *buf,size_t len);
+void read_buf(int f, char *buf, size_t len);
+void read_sbuf(int f, char *buf, size_t len);
 uchar read_byte(int f);
 int read_vstring(int f, char *buf, int bufsize);
 void read_sum_head(int f, struct sum_struct *sum);
 void write_sum_head(int f, struct sum_struct *sum);
 void io_flush(int flush_it_all);
-void write_shortint(int f, int x);
-void write_int(int f,int32 x);
+void write_shortint(int f, unsigned short x);
+void write_int(int f, int32 x);
+void write_varint(int f, int32 x);
+void write_varlong(int f, int64 x, uchar min_bytes);
 void write_longint(int f, int64 x);
-void write_buf(int f,char *buf,size_t len);
-void write_sbuf(int f, char *buf);
+void write_buf(int f, const char *buf, size_t len);
+void write_sbuf(int f, const char *buf);
 void write_byte(int f, uchar c);
-void write_vstring(int f, char *str, int len);
-int read_line(int f, char *buf, size_t maxlen);
+void write_vstring(int f, const char *str, int len);
+void write_ndx(int f, int32 ndx);
+int32 read_ndx(int f);
+int read_line_old(int f, char *buf, size_t bufsiz);
 void io_printf(int fd, const char *format, ...);
 void io_start_multiplex_out(void);
 void io_start_multiplex_in(void);
-int io_multiplex_write(enum msgcode code, char *buf, size_t len);
-void close_multiplexing_in(void);
-void close_multiplexing_out(void);
+int io_multiplex_write(enum msgcode code, const char *buf, size_t len, int convert);
+void io_end_multiplex_in(void);
+void io_end_multiplex_out(void);
 void start_write_batch(int fd);
 void stop_write_batch(void);
 char *lp_bind_address(void);
 char *lp_motd_file(void);
 char *lp_pid_file(void);
 char *lp_socket_options(void);
 int lp_rsync_port(void);
-char *lp_auth_users(int );
-char *lp_comment(int );
-char *lp_dont_compress(int );
-char *lp_exclude(int );
-char *lp_exclude_from(int );
-char *lp_filter(int );
-char *lp_gid(int );
-char *lp_hosts_allow(int );
-char *lp_hosts_deny(int );
-char *lp_include(int );
-char *lp_include_from(int );
-char *lp_incoming_chmod(int );
-char *lp_lock_file(int );
-char *lp_log_file(int );
-char *lp_log_format(int );
-char *lp_name(int );
-char *lp_outgoing_chmod(int );
-char *lp_path(int );
-char *lp_postxfer_exec(int );
-char *lp_prexfer_exec(int );
-char *lp_refuse_options(int );
-char *lp_secrets_file(int );
-int lp_syslog_facility(int );
-char *lp_temp_dir(int );
-char *lp_uid(int );
-int lp_max_connections(int );
-int lp_max_verbosity(int );
-int lp_timeout(int );
-BOOL lp_ignore_errors(int );
-BOOL lp_ignore_nonreadable(int );
-BOOL lp_list(int );
-BOOL lp_read_only(int );
-BOOL lp_strict_modes(int );
-BOOL lp_transfer_logging(int );
-BOOL lp_use_chroot(int );
-BOOL lp_write_only(int );
+char *lp_auth_users(int module_id);
+char *lp_charset(int module_id);
+char *lp_comment(int module_id);
+char *lp_dont_compress(int module_id);
+char *lp_exclude(int module_id);
+char *lp_exclude_from(int module_id);
+char *lp_filter(int module_id);
+char *lp_gid(int module_id);
+char *lp_hosts_allow(int module_id);
+char *lp_hosts_deny(int module_id);
+char *lp_include(int module_id);
+char *lp_include_from(int module_id);
+char *lp_incoming_chmod(int module_id);
+char *lp_lock_file(int module_id);
+char *lp_log_file(int module_id);
+char *lp_log_format(int module_id);
+char *lp_name(int module_id);
+char *lp_outgoing_chmod(int module_id);
+char *lp_path(int module_id);
+char *lp_postxfer_exec(int module_id);
+char *lp_prexfer_exec(int module_id);
+char *lp_refuse_options(int module_id);
+char *lp_secrets_file(int module_id);
+char *lp_temp_dir(int module_id);
+char *lp_uid(int module_id);
+int lp_max_connections(int module_id);
+int lp_max_verbosity(int module_id);
+int lp_syslog_facility(int module_id);
+int lp_timeout(int module_id);
+BOOL lp_fake_super(int module_id);
+BOOL lp_ignore_errors(int module_id);
+BOOL lp_ignore_nonreadable(int module_id);
+BOOL lp_list(int module_id);
+BOOL lp_munge_symlinks(int module_id);
+BOOL lp_numeric_ids(int module_id);
+BOOL lp_read_only(int module_id);
+BOOL lp_strict_modes(int module_id);
+BOOL lp_transfer_logging(int module_id);
+BOOL lp_use_chroot(int module_id);
+BOOL lp_write_only(int module_id);
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
 void log_init(int restart);
 void logfile_close(void);
 void logfile_reopen(void);
-void rwrite(enum logcode code, char *buf, int len);
+void rwrite(enum logcode code, const char *buf, int len, int is_utf8);
 void rprintf(enum logcode code, const char *format, ...);
 void rsyserr(enum logcode code, int errcode, const char *format, ...);
 void rflush(enum logcode code);
 int log_format_has(const char *format, char esc);
 void log_item(enum logcode code, struct file_struct *file,
-	      struct stats *initial_stats, int iflags, char *hlink);
+	      struct stats *initial_stats, int iflags, const char *hlink);
 void maybe_log_item(struct file_struct *file, int iflags, int itemizing,
-		    char *buf);
-void log_delete(char *fname, int mode);
+		    const char *buf);
+void log_delete(const char *fname, int mode);
 void log_exit(int code, const char *file, int line);
 pid_t wait_process(pid_t pid, int *status_ptr, int flags);
 int child_main(int argc, char *argv[]);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
 RETSIGTYPE remember_children(UNUSED(int val));
 const char *get_panic_action(void);
 int main(int argc,char *argv[]);
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
 void usage(enum logcode F);
 void option_error(void);
-int parse_arguments(int *argc, const char ***argv, int frommain);
-void server_options(char **args,int *argc);
+int parse_arguments(int *argc_p, const char ***argv_p, int frommain);
+void server_options(char **args, int *argc_p);
 char *check_for_hostspec(char *s, char **host_ptr, int *port_ptr);
 BOOL pm_process( char *FileName,
                  BOOL (*sfunc)(char *),
                  BOOL (*pfunc)(char *, char *) );
 pid_t piped_child(char **command, int *f_in, int *f_out);
 pid_t local_child(int argc, char **argv, int *f_in, int *f_out,
 		  int (*child_main)(int, char*[]));
+void set_current_file_index(struct file_struct *file, int ndx);
 void end_progress(OFF_T size);
 void show_progress(OFF_T ofs, OFF_T size);
-int recv_files(int f_in, struct file_list *flist, char *local_name);
-void setup_iconv();
+int get_tmpname(char *fnametmp, const char *fname);
+int open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file);
+int recv_files(int f_in, char *local_name);
+void setup_iconv(void);
+int iconvbufs(iconv_t ic, xbuf *in, xbuf *out, int flags);
+int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
+		       char *buf, int *len_ptr);
 void free_sums(struct sum_struct *s);
-mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int exists);
-int set_file_attrs(char *fname, struct file_struct *file, STRUCT_STAT *st,
-		   int flags);
+mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms,
+		 int exists);
+int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
+		   const char *fnamecmp, int flags);
 RETSIGTYPE sig_int(UNUSED(int val));
-void finish_transfer(char *fname, char *fnametmp, char *partialptr,
-		     struct file_struct *file, int ok_to_set_time,
-		     int overwriting_basis);
+int finish_transfer(const char *fname, const char *fnametmp,
+		    const char *fnamecmp, const char *partialptr,
+		    struct file_struct *file, int ok_to_set_time,
+		    int overwriting_basis);
+struct file_list *flist_for_ndx(int ndx);
 const char *who_am_i(void);
 void successful_send(int ndx);
-int read_item_attrs(int f_in, int f_out, int ndx, uchar *type_ptr,
-		    char *buf, int *len_ptr);
-void send_files(struct file_list *flist, int f_out, int f_in);
+void send_files(int f_in, int f_out);
 int try_bind_local(int s, int ai_family, int ai_socktype,
 		   const char *bind_addr);
 int open_socket_out(char *host, int port, const char *bind_addr,
 		    int af_hint);
 int open_socket_out_wrapped(char *host, int port, const char *bind_addr,
 			    int af_hint);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int, int));
 void set_socket_options(int fd, char *options);
-void become_daemon(void);
 int sock_exec(const char *prog);
 int do_unlink(const char *fname);
 int do_symlink(const char *fname1, const char *fname2);
 int do_link(const char *fname1, const char *fname2);
 int do_lchown(const char *path, uid_t owner, gid_t group);
-int do_mknod(char *pathname, mode_t mode, dev_t dev);
+int do_mknod(const char *pathname, mode_t mode, dev_t dev);
 int do_rmdir(const char *pathname);
 int do_open(const char *pathname, int flags, mode_t mode);
 int do_chmod(const char *path, mode_t mode);
 int do_rename(const char *fname1, const char *fname2);
 void trim_trailing_slashes(char *name);
 int do_mkdir(char *fname, mode_t mode);
 int do_mkstemp(char *template, mode_t perms);
 int do_stat(const char *fname, STRUCT_STAT *st);
 int do_lstat(const char *fname, STRUCT_STAT *st);
 int do_fstat(int fd, STRUCT_STAT *st);
 OFF_T do_lseek(int fd, OFF_T offset, int whence);
 char *d_name(struct dirent *di);
-void set_compression(char *fname);
+void set_compression(const char *fname);
 void send_token(int f, int32 token, struct map_struct *buf, OFF_T offset,
 		int32 n, int32 toklen);
 int32 recv_token(int f, char **data);
 void see_token(char *data, int32 toklen);
-void add_uid(uid_t uid);
-void add_gid(gid_t gid);
-void send_uid_list(int f);
-void recv_uid_list(int f, struct file_list *flist);
+uid_t match_uid(uid_t uid);
+gid_t match_gid(gid_t gid, uint16 *flags_ptr);
+const char *add_uid(uid_t uid);
+const char *add_gid(gid_t gid);
+void send_id_list(int f);
+uid_t recv_user_name(int f, uid_t uid);
+gid_t recv_group_name(int f, gid_t gid, uint16 *flags_ptr);
+void recv_id_list(int f, struct file_list *flist);
 void set_nonblocking(int fd);
 void set_blocking(int fd);
 int fd_pair(int fd[2]);
-void print_child_argv(char **cmd);
-NORETURN void out_of_memory(char *str);
-NORETURN void overflow_exit(char *str);
-int set_modtime(char *fname, time_t modtime, mode_t mode);
+void print_child_argv(const char *prefix, char **cmd);
+NORETURN void out_of_memory(const char *str);
+NORETURN void overflow_exit(const char *str);
+int set_modtime(const char *fname, time_t modtime, mode_t mode);
 int mkdir_defmode(char *fname);
 int create_directory_path(char *fname);
-int full_write(int desc, char *ptr, size_t len);
-int copy_file(const char *source, const char *dest, mode_t mode);
+int full_write(int desc, const char *ptr, size_t len);
+int copy_file(const char *source, const char *dest, int ofd,
+	      mode_t mode, int create_bak_dir);
 int robust_unlink(const char *fname);
-int robust_rename(char *from, char *to, char *partialptr,
+int robust_rename(const char *from, const char *to, const char *partialptr,
 		  int mode);
 pid_t do_fork(void);
 void kill_all(int sig);
-int name_to_uid(char *name, uid_t *uid);
-int name_to_gid(char *name, gid_t *gid);
+int name_to_uid(const char *name, uid_t *uid_p);
+int name_to_gid(const char *name, gid_t *gid_p);
 int lock_range(int fd, int offset, int len);
-void glob_expand(char *base1, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
+void glob_expand(char *s, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
+void glob_expand_module(char *base1, char *arg, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr);
 void strlower(char *s);
 size_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2);
 size_t stringjoin(char *dest, size_t destsize, ...);
 int count_dir_elements(const char *p);
-unsigned int clean_fname(char *name, BOOL collapse_dot_dot);
-char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth,
-		    const char *symlink);
-int push_dir(char *dir, int set_path_only);
-int pop_dir(char *dir);
+unsigned int clean_fname(char *name, int flags);
+char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth);
+int push_dir(const char *dir, int set_path_only);
+int pop_dir(const char *dir);
 char *full_fname(const char *fn);
 char *partial_dir_fname(const char *fname);
 int handle_partial_dir(const char *fname, int create);
 int unsafe_symlink(const char *dest, const char *src);
 char *human_num(int64 num);
 char *human_dnum(double dnum, int decimal_digits);
 char *timestring(time_t t);
 int msleep(int t);
 int cmp_time(time_t file1, time_t file2);
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
-void *_new_array(unsigned int size, unsigned long num);
+void *_new_array(unsigned long num, unsigned int size, int use_calloc);
 void *_realloc_array(void *ptr, unsigned int size, unsigned long num);
 const char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr);
 uint32 fuzzy_distance(const char *s1, int len1, const char *s2, int len2);
 struct bitbag *bitbag_create(int max_ndx);
 void bitbag_set_bit(struct bitbag *bb, int ndx);
 void bitbag_clear_bit(struct bitbag *bb, int ndx);
 int bitbag_check_bit(struct bitbag *bb, int ndx);
 int bitbag_next_bit(struct bitbag *bb, int after);
+void *expand_item_list(item_list *lp, size_t item_size,
+		       const char *desc, int incr);
+void free_xattr(stat_x *sxp);
+int get_xattr(const char *fname, stat_x *sxp);
+int send_xattr(stat_x *sxp, int f);
+int xattr_diff(struct file_struct *file, stat_x *sxp, int find_all);
+void send_xattr_request(const char *fname, struct file_struct *file, int f_out);
+int recv_xattr_request(struct file_struct *file, int f_in);
+void receive_xattr(struct file_struct *file, int f);
+void cache_xattr(struct file_struct *file, stat_x *sxp);
+int set_xattr(const char *fname, const struct file_struct *file,
+	      const char *fnamecmp, stat_x *sxp);
+char *get_xattr_acl(const char *fname, int is_access_acl, size_t *len_p);
+int set_xattr_acl(const char *fname, int is_access_acl, const char *buf, size_t buf_len);
+int del_def_xattr_acl(const char *fname);
+int get_stat_xattr(const char *fname, int fd, STRUCT_STAT *fst, STRUCT_STAT *xst);
+int set_stat_xattr(const char *fname, struct file_struct *file, mode_t new_mode);
+int x_stat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst);
+int x_lstat(const char *fname, STRUCT_STAT *fst, STRUCT_STAT *xst);
+int x_fstat(int fd, STRUCT_STAT *fst, STRUCT_STAT *xst);
 int sys_gettimeofday(struct timeval *tv);
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: proto.h-tstamp
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/README /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/README
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/README	2005-04-24 06:17:10.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/README	2007-01-28 14:39:52.000000000 +0800
@@ -48,31 +48,31 @@
 to the name of your native compiler before running configure in this
 case. 
 
 Once built put a copy of rsync in your search path on the local and
 remote systems (or use "make install"). That's it!
 
-RSYNC SERVERS
+RSYNC DAEMONS
 -------------
 
-rsync can also talk to "rsync servers" which can provide anonymous or
+rsync can also talk to "rsync daemons" which can provide anonymous or
 authenticated rsync. See the rsyncd.conf(5) man page for details on how
-to setup a rsync server. See the rsync(1) man page for info on how to
-connect to a rsync server.
+to setup an rsync daemon. See the rsync(1) man page for info on how to
+connect to an rsync daemon.
 
 
 MAILING LIST
 ------------
 
 There is a mailing list for the discussion of rsync and its
 applications. It is open to anyone to join. I will announce new
 versions on this list. 
 
 To join the mailing list see the web page at http://lists.samba.org/
 
-To send mail to everyone on the list send it to rsync@samba.org
+To send mail to everyone on the list send it to rsync@lists.samba.org
 
 
 BUG REPORTS
 -----------
 
 If you have web access then please look at
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/receiver.c	2006-10-13 15:18:29.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/receiver.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,68 +1,69 @@
 /*
  * Routines only used by the receiving process.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
+extern int dry_run;
 extern int do_xfers;
 extern int am_server;
 extern int do_progress;
+extern int inc_recurse;
 extern int log_before_transfer;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
 extern int csum_length;
 extern int read_batch;
 extern int write_batch;
 extern int batch_gen_fd;
 extern int protocol_version;
 extern int relative_paths;
 extern int preserve_hard_links;
 extern int preserve_perms;
+extern int preserve_xattrs;
 extern int basis_dir_cnt;
 extern int make_backups;
 extern int cleanup_got_literal;
 extern int remove_source_files;
 extern int append_mode;
 extern int sparse_files;
 extern int keep_partial;
 extern int checksum_seed;
 extern int inplace;
 extern int delay_updates;
+extern mode_t orig_umask;
 extern struct stats stats;
-extern char *stdout_format;
 extern char *tmpdir;
 extern char *partial_dir;
 extern char *basis_dir[];
-extern struct file_list *the_file_list;
+extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct filter_list_struct server_filter_list;
 
 static struct bitbag *delayed_bits = NULL;
-static int phase = 0;
+static int phase = 0, redoing = 0;
 /* We're either updating the basis file or an identical copy: */
-static int updating_basis;
-
+static int updating_basis_or_equiv;
 
 /*
  * get_tmpname() - create a tmp filename for a given filename
  *
  *   If a tmpdir is defined, use that as the directory to
  *   put it in.  Otherwise, the tmp filename is in the same
@@ -79,16 +80,16 @@
  *
  *   Of course, there's no real reason for the tmp name to
  *   look like the original, except to satisfy us humans.
  *   As long as it's unique, rsync will work.
  */
 
-static int get_tmpname(char *fnametmp, char *fname)
+int get_tmpname(char *fnametmp, const char *fname)
 {
 	int maxname, added, length = 0;
-	char *f;
+	const char *f;
 
 	if (tmpdir) {
 		/* Note: this can't overflow, so the return value is safe */
 		length = strlcpy(fnametmp, tmpdir, MAXPATHLEN - 2);
 		fnametmp[length++] = '/';
 	}
@@ -106,34 +107,71 @@
 
 	/* The maxname value is bufsize, and includes space for the '\0'.
 	 * (Note that NAME_MAX get -8 for the leading '.' above.) */
 	maxname = MIN(MAXPATHLEN - 7 - length, NAME_MAX - 8);
 
 	if (maxname < 1) {
-		rprintf(FERROR, "temporary filename too long: %s\n", fname);
+		rprintf(FERROR_XFER, "temporary filename too long: %s\n", fname);
 		fnametmp[0] = '\0';
 		return 0;
 	}
 
 	added = strlcpy(fnametmp + length, f, maxname);
 	if (added >= maxname)
 		added = maxname - 1;
 	memcpy(fnametmp + length + added, ".XXXXXX", 8);
 
 	return 1;
 }
 
+/* Opens a temporary file for writing.
+ * Success: Writes name into fnametmp, returns fd.
+ * Failure: Clobbers fnametmp, returns -1.
+ * Calling cleanup_set() is the caller's job. */
+int open_tmpfile(char *fnametmp, const char *fname, struct file_struct *file)
+{
+	int fd;
+
+	if (!get_tmpname(fnametmp, fname))
+		return -1;
+
+	/* We initially set the perms without the setuid/setgid bits or group
+	 * access to ensure that there is no race condition.  They will be
+	 * correctly updated after the right owner and group info is set.
+	 * (Thanks to snabb@epipe.fi for pointing this out.) */
+	fd = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
+
+#if 0
+	/* In most cases parent directories will already exist because their
+	 * information should have been previously transferred, but that may
+	 * not be the case with -R */
+	if (fd == -1 && relative_paths && errno == ENOENT
+	    && create_directory_path(fnametmp) == 0) {
+		/* Get back to name with XXXXXX in it. */
+		get_tmpname(fnametmp, fname);
+		fd = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
+	}
+#endif
+
+	if (fd == -1) {
+		rsyserr(FERROR_XFER, errno, "mkstemp %s failed",
+			full_fname(fnametmp));
+		return -1;
+	}
+
+	return fd;
+}
 
 static int receive_data(int f_in, char *fname_r, int fd_r, OFF_T size_r,
-			char *fname, int fd, OFF_T total_size)
+			const char *fname, int fd, OFF_T total_size)
 {
-	static char file_sum1[MD4_SUM_LENGTH];
-	static char file_sum2[MD4_SUM_LENGTH];
+	static char file_sum1[MAX_DIGEST_LEN];
+	static char file_sum2[MAX_DIGEST_LEN];
 	struct map_struct *mapbuf;
 	struct sum_struct sum;
-	int32 len;
+	int32 len, sum_len;
 	OFF_T offset = 0;
 	OFF_T offset2;
 	char *data;
 	int32 i;
 	char *map = NULL;
 
@@ -148,33 +186,35 @@
 		}
 	} else
 		mapbuf = NULL;
 
 	sum_init(checksum_seed);
 
-	if (append_mode) {
+	if (append_mode > 0) {
 		OFF_T j;
 		sum.flength = (OFF_T)sum.count * sum.blength;
 		if (sum.remainder)
 			sum.flength -= sum.blength - sum.remainder;
-		for (j = CHUNK_SIZE; j < sum.flength; j += CHUNK_SIZE) {
-			if (do_progress)
-				show_progress(offset, total_size);
-			sum_update(map_ptr(mapbuf, offset, CHUNK_SIZE),
-				   CHUNK_SIZE);
-			offset = j;
-		}
-		if (offset < sum.flength) {
-			int32 len = sum.flength - offset;
-			if (do_progress)
-				show_progress(offset, total_size);
-			sum_update(map_ptr(mapbuf, offset, len), len);
-			offset = sum.flength;
+		if (append_mode == 2) {
+			for (j = CHUNK_SIZE; j < sum.flength; j += CHUNK_SIZE) {
+				if (do_progress)
+					show_progress(offset, total_size);
+				sum_update(map_ptr(mapbuf, offset, CHUNK_SIZE),
+					   CHUNK_SIZE);
+				offset = j;
+			}
+			if (offset < sum.flength) {
+				int32 len = (int32)(sum.flength - offset);
+				if (do_progress)
+					show_progress(offset, total_size);
+				sum_update(map_ptr(mapbuf, offset, len), len);
+			}
 		}
+		offset = sum.flength;
 		if (fd != -1 && (j = do_lseek(fd, offset, SEEK_SET)) != offset) {
-			rsyserr(FERROR, errno, "lseek of %s returned %.0f, not %.0f",
+			rsyserr(FERROR_XFER, errno, "lseek of %s returned %.0f, not %.0f",
 				full_fname(fname), (double)j, (double)offset);
 			exit_cleanup(RERR_FILEIO);
 		}
 	}
 
 	while ((i = recv_token(f_in, &data)) != 0) {
@@ -216,20 +256,20 @@
 			map = map_ptr(mapbuf,offset2,len);
 
 			see_token(map, len);
 			sum_update(map, len);
 		}
 
-		if (updating_basis) {
+		if (updating_basis_or_equiv) {
 			if (offset == offset2 && fd != -1) {
 				OFF_T pos;
 				if (flush_write_file(fd) < 0)
 					goto report_write_error;
 				offset += len;
 				if ((pos = do_lseek(fd, len, SEEK_CUR)) != offset) {
-					rsyserr(FERROR, errno,
+					rsyserr(FERROR_XFER, errno,
 						"lseek of %s returned %.0f, not %.0f",
 						full_fname(fname),
 						(double)pos, (double)offset);
 					exit_cleanup(RERR_FILEIO);
 				}
 				continue;
@@ -250,207 +290,239 @@
 
 	if (do_progress)
 		end_progress(total_size);
 
 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
 	    report_write_error:
-		rsyserr(FERROR, errno, "write failed on %s",
+		rsyserr(FERROR_XFER, errno, "write failed on %s",
 			full_fname(fname));
 		exit_cleanup(RERR_FILEIO);
 	}
 
-	sum_end(file_sum1);
+	sum_len = sum_end(file_sum1);
 
 	if (mapbuf)
 		unmap_file(mapbuf);
 
-	read_buf(f_in,file_sum2,MD4_SUM_LENGTH);
+	read_buf(f_in, file_sum2, sum_len);
 	if (verbose > 2)
 		rprintf(FINFO,"got file_sum\n");
-	if (fd != -1 && memcmp(file_sum1, file_sum2, MD4_SUM_LENGTH) != 0)
+	if (fd != -1 && memcmp(file_sum1, file_sum2, sum_len) != 0)
 		return 0;
 	return 1;
 }
 
 
 static void discard_receive_data(int f_in, OFF_T length)
 {
 	receive_data(f_in, NULL, -1, 0, NULL, -1, length);
 }
 
-static void handle_delayed_updates(struct file_list *flist, char *local_name)
+static void handle_delayed_updates(char *local_name)
 {
-	char *fname, *partialptr, numbuf[4];
-	int i;
+	char *fname, *partialptr;
+	int ndx;
 
-	for (i = -1; (i = bitbag_next_bit(delayed_bits, i)) >= 0; ) {
-		struct file_struct *file = flist->files[i];
+	for (ndx = -1; (ndx = bitbag_next_bit(delayed_bits, ndx)) >= 0; ) {
+		struct file_struct *file = cur_flist->files[ndx];
 		fname = local_name ? local_name : f_name(file, NULL);
 		if ((partialptr = partial_dir_fname(fname)) != NULL) {
-			if (make_backups && !make_backup(fname))
+			if (make_backups > 0 && !make_backup(fname))
 				continue;
 			if (verbose > 2) {
 				rprintf(FINFO, "renaming %s to %s\n",
 					partialptr, fname);
 			}
 			/* We don't use robust_rename() here because the
 			 * partial-dir must be on the same drive. */
 			if (do_rename(partialptr, fname) < 0) {
-				rsyserr(FERROR, errno,
+				rsyserr(FERROR_XFER, errno,
 					"rename failed for %s (from %s)",
 					full_fname(fname), partialptr);
 			} else {
 				if (remove_source_files
-				    || (preserve_hard_links
-				     && file->link_u.links)) {
-					SIVAL(numbuf, 0, i);
-					send_msg(MSG_SUCCESS,numbuf,4);
-				}
+				 || (preserve_hard_links && F_IS_HLINKED(file)))
+					send_msg_int(MSG_SUCCESS, ndx);
 				handle_partial_dir(partialptr, PDIR_DELETE);
 			}
 		}
 	}
 }
 
-static int get_next_gen_i(int batch_gen_fd, int next_gen_i, int desired_i)
+static int get_next_gen_ndx(int fd, int next_gen_ndx, int desired_ndx)
 {
-	while (next_gen_i < desired_i) {
-		if (next_gen_i >= 0) {
-			rprintf(FINFO,
+	while (next_gen_ndx < desired_ndx) {
+		if (next_gen_ndx >= 0) {
+			struct file_struct *file = cur_flist->files[next_gen_ndx];
+			rprintf(FERROR_XFER,
 				"(No batched update for%s \"%s\")\n",
-				phase ? " resend of" : "",
-				f_name(the_file_list->files[next_gen_i], NULL));
+				file->flags & FLAG_FILE_SENT ? " resend of" : "",
+				f_name(file, NULL));
+		}
+		next_gen_ndx = read_int(fd);
+		if (next_gen_ndx == -1) {
+			if (inc_recurse)
+				next_gen_ndx = first_flist->prev->used + first_flist->prev->ndx_start;
+			else
+				next_gen_ndx = cur_flist->used;
 		}
-		next_gen_i = read_int(batch_gen_fd);
-		if (next_gen_i == -1)
-			next_gen_i = the_file_list->count;
 	}
-	return next_gen_i;
+	return next_gen_ndx;
 }
 
-
 /**
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
-int recv_files(int f_in, struct file_list *flist, char *local_name)
+int recv_files(int f_in, char *local_name)
 {
-	int next_gen_i = -1;
+	int next_gen_ndx = -1;
 	int fd1,fd2;
 	STRUCT_STAT st;
 	int iflags, xlen;
 	char *fname, fbuf[MAXPATHLEN];
 	char xname[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
-	char *fnamecmp, *partialptr, numbuf[4];
+	char *fnamecmp, *partialptr;
 	char fnamecmpbuf[MAXPATHLEN];
 	uchar fnamecmp_type;
 	struct file_struct *file;
 	struct stats initial_stats;
-	int save_make_backups = make_backups;
 	int itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;
 	enum logcode log_code = log_before_transfer ? FLOG : FINFO;
 	int max_phase = protocol_version >= 29 ? 2 : 1;
-	int i, recv_ok;
+	int dflt_perms = (ACCESSPERMS & ~orig_umask);
+#ifdef SUPPORT_ACLS
+	const char *parent_dirname = "";
+#endif
+	int ndx, recv_ok;
 
 	if (verbose > 2)
-		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
-
-	if (flist->hlink_pool) {
-		pool_destroy(flist->hlink_pool);
-		flist->hlink_pool = NULL;
-	}
+		rprintf(FINFO, "recv_files(%d) starting\n", cur_flist->used);
 
 	if (delay_updates)
-		delayed_bits = bitbag_create(flist->count);
-
-	updating_basis = inplace;
+		delayed_bits = bitbag_create(cur_flist->used + 1);
 
 	while (1) {
 		cleanup_disable();
 
-		i = read_int(f_in);
-		if (i == -1) {
-			if (read_batch) {
-				get_next_gen_i(batch_gen_fd, next_gen_i,
-					       flist->count);
-				next_gen_i = -1;
+		/* This call also sets cur_flist. */
+		ndx = read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
+					 xname, &xlen);
+		if (ndx == NDX_DONE) {
+			if (inc_recurse && first_flist) {
+				flist_free(first_flist);
+				if (first_flist)
+					continue;
+			}
+			if (read_batch && cur_flist) {
+				int high = inc_recurse
+				    ? first_flist->prev->used + first_flist->prev->ndx_start
+				    : cur_flist->used;
+				get_next_gen_ndx(batch_gen_fd, next_gen_ndx, high);
+				next_gen_ndx = -1;
 			}
 			if (++phase > max_phase)
 				break;
-			csum_length = SUM_LENGTH;
 			if (verbose > 2)
 				rprintf(FINFO, "recv_files phase=%d\n", phase);
 			if (phase == 2 && delay_updates)
-				handle_delayed_updates(flist, local_name);
-			send_msg(MSG_DONE, "", 0);
-			if (keep_partial && !partial_dir)
-				make_backups = 0; /* prevents double backup */
-			if (append_mode) {
-				append_mode = 0;
-				sparse_files = 0;
-			}
+				handle_delayed_updates(local_name);
+			send_msg(MSG_DONE, "", 0, 0);
 			continue;
 		}
 
-		iflags = read_item_attrs(f_in, -1, i, &fnamecmp_type,
-					 xname, &xlen);
-		if (iflags == ITEM_IS_NEW) /* no-op packet */
-			continue;
-
-		file = flist->files[i];
+		if (ndx - cur_flist->ndx_start >= 0)
+			file = cur_flist->files[ndx - cur_flist->ndx_start];
+		else
+			file = dir_flist->files[cur_flist->parent_ndx];
 		fname = local_name ? local_name : f_name(file, fbuf);
 
 		if (verbose > 2)
 			rprintf(FINFO, "recv_files(%s)\n", fname);
 
+#ifdef SUPPORT_XATTRS
+		if (iflags & ITEM_REPORT_XATTR && !dry_run)
+			recv_xattr_request(file, f_in);
+#endif
+
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
+#ifdef SUPPORT_XATTRS
+			if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && !dry_run)
+				set_file_attrs(fname, file, NULL, fname, 0);
+#endif
 			continue;
 		}
 		if (phase == 2) {
 			rprintf(FERROR,
 				"got transfer request in phase 2 [%s]\n",
 				who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
-		stats.current_file_index = i;
+		if (file->flags & FLAG_FILE_SENT) {
+			if (csum_length == SHORT_SUM_LENGTH) {
+				if (keep_partial && !partial_dir)
+					make_backups = -make_backups; /* prevents double backup */
+				if (append_mode)
+					sparse_files = -sparse_files;
+				append_mode = -append_mode;
+				csum_length = SUM_LENGTH;
+				redoing = 1;
+			}
+		} else {
+			if (csum_length != SHORT_SUM_LENGTH) {
+				if (keep_partial && !partial_dir)
+					make_backups = -make_backups;
+				if (append_mode)
+					sparse_files = -sparse_files;
+				append_mode = -append_mode;
+				csum_length = SHORT_SUM_LENGTH;
+				redoing = 0;
+			}
+		}
+
+		if (!am_server && do_progress)
+			set_current_file_index(file, ndx);
 		stats.num_transferred_files++;
-		stats.total_transferred_size += file->length;
+		stats.total_transferred_size += F_LENGTH(file);
+
 		cleanup_got_literal = 0;
 
 		if (server_filter_list.head
 		    && check_filter(&server_filter_list, fname, 0) < 0) {
 			rprintf(FERROR, "attempt to hack rsync failed.\n");
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		if (!do_xfers) { /* log the transfer */
 			log_item(FCLIENT, file, &stats, iflags, NULL);
 			if (read_batch)
-				discard_receive_data(f_in, file->length);
+				discard_receive_data(f_in, F_LENGTH(file));
 			continue;
 		}
 		if (write_batch < 0) {
-			log_item(FINFO, file, &stats, iflags, NULL);
+			log_item(FCLIENT, file, &stats, iflags, NULL);
 			if (!am_server)
-				discard_receive_data(f_in, file->length);
+				discard_receive_data(f_in, F_LENGTH(file));
 			continue;
 		}
 
 		if (read_batch) {
-			next_gen_i = get_next_gen_i(batch_gen_fd, next_gen_i, i);
-			if (i < next_gen_i) {
+			next_gen_ndx = get_next_gen_ndx(batch_gen_fd, next_gen_ndx, ndx);
+			if (ndx < next_gen_ndx) {
 				rprintf(FINFO,
 					"(Skipping batched update for \"%s\")\n",
 					fname);
-				discard_receive_data(f_in, file->length);
+				discard_receive_data(f_in, F_LENGTH(file));
+				if (inc_recurse)
+					send_msg_int(MSG_NO_SEND, ndx);
 				continue;
 			}
-			next_gen_i = -1;
+			next_gen_ndx = -1;
 		}
 
 		partialptr = partial_dir ? partial_dir_fname(fname) : fname;
 
 		if (protocol_version >= 29) {
 			switch (fnamecmp_type) {
@@ -461,42 +533,44 @@
 				fnamecmp = partialptr;
 				break;
 			case FNAMECMP_BACKUP:
 				fnamecmp = get_backup_name(fname);
 				break;
 			case FNAMECMP_FUZZY:
-				updating_basis = 0;
 				if (file->dirname) {
 					pathjoin(fnamecmpbuf, MAXPATHLEN,
 						 file->dirname, xname);
 					fnamecmp = fnamecmpbuf;
 				} else
 					fnamecmp = xname;
 				break;
 			default:
-				updating_basis = 0;
 				if (fnamecmp_type >= basis_dir_cnt) {
 					rprintf(FERROR,
 						"invalid basis_dir index: %d.\n",
 						fnamecmp_type);
 					exit_cleanup(RERR_PROTOCOL);
 				}
 				pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
 					 basis_dir[fnamecmp_type], fname);
 				fnamecmp = fnamecmpbuf;
 				break;
 			}
 			if (!fnamecmp || (server_filter_list.head
-			  && check_filter(&server_filter_list, fname, 0) < 0))
+			  && check_filter(&server_filter_list, fname, 0) < 0)) {
 				fnamecmp = fname;
+				fnamecmp_type = FNAMECMP_FNAME;
+			}
 		} else {
 			/* Reminder: --inplace && --partial-dir are never
 			 * enabled at the same time. */
-			if (inplace && make_backups) {
+			if (inplace && make_backups > 0) {
 				if (!(fnamecmp = get_backup_name(fname)))
 					fnamecmp = fname;
+				else
+					fnamecmp_type = FNAMECMP_BACKUP;
 			} else if (partial_dir && partialptr)
 				fnamecmp = partialptr;
 			else
 				fnamecmp = fname;
 		}
 
@@ -517,182 +591,179 @@
 					 basis_dir[0], fname);
 				fnamecmp = fnamecmpbuf;
 				fd1 = do_open(fnamecmp, O_RDONLY, 0);
 			}
 		}
 
+		updating_basis_or_equiv = inplace
+		    && (fnamecmp == fname || fnamecmp_type == FNAMECMP_BACKUP);
+
 		if (fd1 == -1) {
 			st.st_mode = 0;
 			st.st_size = 0;
 		} else if (do_fstat(fd1,&st) != 0) {
-			rsyserr(FERROR, errno, "fstat %s failed",
+			rsyserr(FERROR_XFER, errno, "fstat %s failed",
 				full_fname(fnamecmp));
-			discard_receive_data(f_in, file->length);
+			discard_receive_data(f_in, F_LENGTH(file));
 			close(fd1);
+			if (inc_recurse)
+				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		if (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {
 			/* this special handling for directories
 			 * wouldn't be necessary if robust_rename()
 			 * and the underlying robust_unlink could cope
 			 * with directories
 			 */
-			rprintf(FERROR,"recv_files: %s is a directory\n",
+			rprintf(FERROR_XFER, "recv_files: %s is a directory\n",
 				full_fname(fnamecmp));
-			discard_receive_data(f_in, file->length);
+			discard_receive_data(f_in, F_LENGTH(file));
 			close(fd1);
+			if (inc_recurse)
+				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
 			close(fd1);
 			fd1 = -1;
 		}
 
 		/* If we're not preserving permissions, change the file-list's
 		 * mode based on the local permissions and some heuristics. */
 		if (!preserve_perms) {
 			int exists = fd1 != -1;
-			file->mode = dest_mode(file->mode, st.st_mode, exists);
+#ifdef SUPPORT_ACLS
+			const char *dn = file->dirname ? file->dirname : ".";
+			if (parent_dirname != dn
+			 && strcmp(parent_dirname, dn) != 0) {
+				dflt_perms = default_perms_for_dir(dn);
+				parent_dirname = dn;
+			}
+#endif
+			file->mode = dest_mode(file->mode, st.st_mode,
+					       dflt_perms, exists);
 		}
 
 		/* We now check to see if we are writing the file "inplace" */
 		if (inplace)  {
 			fd2 = do_open(fname, O_WRONLY|O_CREAT, 0600);
 			if (fd2 == -1) {
-				rsyserr(FERROR, errno, "open %s failed",
+				rsyserr(FERROR_XFER, errno, "open %s failed",
 					full_fname(fname));
-				discard_receive_data(f_in, file->length);
-				if (fd1 != -1)
-					close(fd1);
-				continue;
 			}
 		} else {
-			if (!get_tmpname(fnametmp,fname)) {
-				discard_receive_data(f_in, file->length);
-				if (fd1 != -1)
-					close(fd1);
-				continue;
-			}
-
-			/* we initially set the perms without the
-			 * setuid/setgid bits to ensure that there is no race
-			 * condition. They are then correctly updated after
-			 * the lchown. Thanks to snabb@epipe.fi for pointing
-			 * this out.  We also set it initially without group
-			 * access because of a similar race condition. */
-			fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
-
-			/* in most cases parent directories will already exist
-			 * because their information should have been previously
-			 * transferred, but that may not be the case with -R */
-			if (fd2 == -1 && relative_paths && errno == ENOENT
-			    && create_directory_path(fnametmp) == 0) {
-				/* Get back to name with XXXXXX in it. */
-				get_tmpname(fnametmp, fname);
-				fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
-			}
-			if (fd2 == -1) {
-				rsyserr(FERROR, errno, "mkstemp %s failed",
-					full_fname(fnametmp));
-				discard_receive_data(f_in, file->length);
-				if (fd1 != -1)
-					close(fd1);
-				continue;
-			}
+			fd2 = open_tmpfile(fnametmp, fname, file);
+			if (fd2 != -1)
+				cleanup_set(fnametmp, partialptr, file, fd1, fd2);
+		}
 
-			cleanup_set(fnametmp, partialptr, file, fd1, fd2);
+		if (fd2 == -1) {
+			discard_receive_data(f_in, F_LENGTH(file));
+			if (fd1 != -1)
+				close(fd1);
+			if (inc_recurse)
+				send_msg_int(MSG_NO_SEND, ndx);
+			continue;
 		}
 
 		/* log the transfer */
 		if (log_before_transfer)
 			log_item(FCLIENT, file, &initial_stats, iflags, NULL);
 		else if (!am_server && verbose && do_progress)
 			rprintf(FINFO, "%s\n", fname);
 
 		/* recv file data */
 		recv_ok = receive_data(f_in, fnamecmp, fd1, st.st_size,
-				       fname, fd2, file->length);
+				       fname, fd2, F_LENGTH(file));
 
 		log_item(log_code, file, &initial_stats, iflags, NULL);
 
 		if (fd1 != -1)
 			close(fd1);
 		if (close(fd2) < 0) {
 			rsyserr(FERROR, errno, "close failed on %s",
 				full_fname(fnametmp));
 			exit_cleanup(RERR_FILEIO);
 		}
 
 		if ((recv_ok && (!delay_updates || !partialptr)) || inplace) {
-			char *temp_copy_name;
 			if (partialptr == fname)
-				partialptr = temp_copy_name = NULL;
-			else if (*partial_dir == '/')
-				temp_copy_name = NULL;
-			else
-				temp_copy_name = partialptr;
-			finish_transfer(fname, fnametmp, temp_copy_name,
-					file, recv_ok, 1);
-			if (fnamecmp == partialptr) {
+				partialptr = NULL;
+			if (!finish_transfer(fname, fnametmp, fnamecmp,
+					     partialptr, file, recv_ok, 1))
+				recv_ok = -1;
+			else if (fnamecmp == partialptr) {
 				do_unlink(partialptr);
 				handle_partial_dir(partialptr, PDIR_DELETE);
 			}
 		} else if (keep_partial && partialptr
 		    && handle_partial_dir(partialptr, PDIR_CREATE)) {
-			finish_transfer(partialptr, fnametmp, NULL,
-					file, recv_ok, !partial_dir);
-			if (delay_updates && recv_ok) {
-				bitbag_set_bit(delayed_bits, i);
+			if (!finish_transfer(partialptr, fnametmp, fnamecmp, NULL,
+					     file, recv_ok, !partial_dir))
 				recv_ok = -1;
+			else if (delay_updates && recv_ok) {
+				bitbag_set_bit(delayed_bits, ndx);
+				recv_ok = 2;
 			}
 		} else {
 			partialptr = NULL;
 			do_unlink(fnametmp);
 		}
 
 		cleanup_disable();
 
-		if (recv_ok > 0) {
-			if (remove_source_files
-			    || (preserve_hard_links && file->link_u.links)) {
-				SIVAL(numbuf, 0, i);
-				send_msg(MSG_SUCCESS, numbuf, 4);
-			}
-		} else if (!recv_ok) {
-			int msgtype = phase || read_batch ? FERROR : FINFO;
-			if (msgtype == FERROR || verbose) {
+		switch (recv_ok) {
+		case 1:
+			if (remove_source_files || inc_recurse
+			 || (preserve_hard_links && F_IS_HLINKED(file)))
+				send_msg_int(MSG_SUCCESS, ndx);
+			break;
+		case 0: {
+			enum logcode msgtype = redoing ? FERROR_XFER : FWARNING;
+			if (msgtype == FERROR_XFER || verbose) {
 				char *errstr, *redostr, *keptstr;
 				if (!(keep_partial && partialptr) && !inplace)
 					keptstr = "discarded";
 				else if (partial_dir)
 					keptstr = "put into partial-dir";
 				else
 					keptstr = "retained";
-				if (msgtype == FERROR) {
+				if (msgtype == FERROR_XFER) {
 					errstr = "ERROR";
 					redostr = "";
 				} else {
 					errstr = "WARNING";
-					redostr = " (will try again)";
+					redostr = read_batch ? " (may try again)"
+							     : " (will try again)";
 				}
 				rprintf(msgtype,
 					"%s: %s failed verification -- update %s%s.\n",
-					errstr, fname, keptstr, redostr);
-			}
-			if (!phase) {
-				SIVAL(numbuf, 0, i);
-				send_msg(MSG_REDO, numbuf, 4);
+					errstr, local_name ? f_name(file, NULL) : fname,
+					keptstr, redostr);
 			}
+			if (!redoing) {
+				send_msg_int(MSG_REDO, ndx);
+				file->flags |= FLAG_FILE_SENT;
+			} else if (inc_recurse)
+				send_msg_int(MSG_NO_SEND, ndx);
+			break;
+		    }
+		case -1:
+			if (inc_recurse)
+				send_msg_int(MSG_NO_SEND, ndx);
+			break;
 		}
 	}
-	make_backups = save_make_backups;
+	if (make_backups < 0)
+		make_backups = -make_backups;
 
 	if (phase == 2 && delay_updates) /* for protocol_version < 29 */
-		handle_delayed_updates(flist, local_name);
+		handle_delayed_updates(local_name);
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_files finished\n");
 
 	return 0;
 }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: rounding.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.1	2006-11-07 12:39:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.1	2008-03-02 04:12:15.000000000 +0800
@@ -1,40 +1,48 @@
-.TH "rsync" "1" "6 Nov 2006" "" ""
+.TH "rsync" "1" "1 Mar 2008" "" ""
 .SH "NAME"
-rsync \- faster, flexible replacement for rcp
+rsync \(em a fast, versatile, remote (and local) file-copying tool
 .SH "SYNOPSIS"
 
 .PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. DEST
-.PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
-.PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST::DEST
-.PP 
-rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. rsync://[USER@]HOST[:PORT]/DEST
-.PP 
-rsync [OPTION]\&.\&.\&. SRC
-.PP 
-rsync [OPTION]\&.\&.\&. [USER@]HOST:SRC [DEST]
-.PP 
-rsync [OPTION]\&.\&.\&. [USER@]HOST::SRC [DEST]
+.nf 
+Local:  rsync [OPTION...] SRC... [DEST]
+
+Access via remote shell:
+  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]
+  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST
+
+Access via rsync daemon:
+  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
+        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
+  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
+        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST
+.fi 
+
 .PP 
-rsync [OPTION]\&.\&.\&. rsync://[USER@]HOST[:PORT]/SRC [DEST]
+Usages with just one SRC arg and no DEST arg will list the source files
+instead of copying.
 .PP 
 .SH "DESCRIPTION"
 
 .PP 
-rsync is a program that behaves in much the same way that rcp does,
-but has many more options and uses the rsync remote-update protocol to
-greatly speed up file transfers when the destination file is being
-updated\&.
-.PP 
-The rsync remote-update protocol allows rsync to transfer just the
-differences between two sets of files across the network connection, using
-an efficient checksum-search algorithm described in the technical
-report that accompanies this package\&.
+Rsync is a fast and extraordinarily versatile file copying tool.  It can
+copy locally, to/from another host over any remote shell, or to/from a
+remote rsync daemon.  It offers a large number of options that control
+every aspect of its behavior and permit very flexible specification of the
+set of files to be copied.  It is famous for its delta-transfer algorithm,
+which reduces the amount of data sent over the network by sending only the
+differences between the source files and the existing files in the
+destination.  Rsync is widely used for backups and mirroring and as an
+improved copy command for everyday use.
+.PP 
+Rsync finds files that need to be transferred using a \(lqquick check\(rq
+algorithm (by default) that looks for files that have changed in size or
+in last-modified time.  Any changes in the other preserved attributes (as
+requested by options) are made on the destination file directly when the
+quick check indicates that the file's data does not need to be updated.
 .PP 
 Some of the additional features of rsync are:
 .PP 
 .IP o 
 support for copying links, devices, owners, groups, and permissions
 .IP o 
@@ -53,420 +61,446 @@
 
 .PP 
 .SH "GENERAL"
 
 .PP 
 Rsync copies files either to or from a remote host, or locally on the
-current host (it does not support copying files between two remote hosts)\&.
+current host (it does not support copying files between two remote hosts).
 .PP 
 There are two different ways for rsync to contact a remote system: using a
 remote-shell program as the transport (such as ssh or rsh) or contacting an
-rsync daemon directly via TCP\&.  The remote-shell transport is used whenever
+rsync daemon directly via TCP.  The remote-shell transport is used whenever
 the source or destination path contains a single colon (:) separator after
-a host specification\&.  Contacting an rsync daemon directly happens when the
+a host specification.  Contacting an rsync daemon directly happens when the
 source or destination path contains a double colon (::) separator after a
 host specification, OR when an rsync:// URL is specified (see also the
-"USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION" section for
-an exception to this latter rule)\&.
+\(lqUSING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION\(rq section for
+an exception to this latter rule).
 .PP 
 As a special case, if a single source arg is specified without a
-destination, the files are listed in an output format similar to "ls \-l"\&.
+destination, the files are listed in an output format similar to \(lqls \-l\(rq.
 .PP 
 As expected, if neither the source or destination path specify a remote
-host, the copy occurs locally (see also the \fB\-\-list\-only\fP option)\&.
+host, the copy occurs locally (see also the \fB\-\-list\-only\fP option).
 .PP 
 .SH "SETUP"
 
 .PP 
-See the file README for installation instructions\&.
+See the file README for installation instructions.
 .PP 
 Once installed, you can use rsync to any machine that you can access via
 a remote shell (as well as some that you can access using the rsync
-daemon-mode protocol)\&.  For remote transfers, a modern rsync uses ssh
+daemon-mode protocol).  For remote transfers, a modern rsync uses ssh
 for its communications, but it may have been configured to use a
-different remote shell by default, such as rsh or remsh\&.
+different remote shell by default, such as rsh or remsh.
 .PP 
 You can also specify any remote shell you like, either by using the \fB\-e\fP
-command line option, or by setting the RSYNC_RSH environment variable\&.
+command line option, or by setting the RSYNC_RSH environment variable.
 .PP 
 Note that rsync must be installed on both the source and destination
-machines\&.
+machines.
 .PP 
 .SH "USAGE"
 
 .PP 
-You use rsync in the same way you use rcp\&. You must specify a source
-and a destination, one of which may be remote\&.
+You use rsync in the same way you use rcp. You must specify a source
+and a destination, one of which may be remote.
 .PP 
 Perhaps the best way to explain the syntax is with some examples:
 .PP 
 .RS 
-\f(CWrsync \-t *\&.c foo:src/\fP
+\f(CWrsync \-t *.c foo:src/\fP
 .RE
 
 .PP 
-This would transfer all files matching the pattern *\&.c from the
-current directory to the directory src on the machine foo\&. If any of
+This would transfer all files matching the pattern *.c from the
+current directory to the directory src on the machine foo. If any of
 the files already exist on the remote system then the rsync
 remote-update protocol is used to update the file by sending only the
-differences\&. See the tech report for details\&.
+differences. See the tech report for details.
 .PP 
 .RS 
 \f(CWrsync \-avz foo:src/bar /data/tmp\fP
 .RE
 
 .PP 
 This would recursively transfer all files from the directory src/bar on the
-machine foo into the /data/tmp/bar directory on the local machine\&. The
-files are transferred in "archive" mode, which ensures that symbolic
-links, devices, attributes, permissions, ownerships, etc\&. are preserved
-in the transfer\&.  Additionally, compression will be used to reduce the
-size of data portions of the transfer\&.
+machine foo into the /data/tmp/bar directory on the local machine. The
+files are transferred in \(lqarchive\(rq mode, which ensures that symbolic
+links, devices, attributes, permissions, ownerships, etc. are preserved
+in the transfer.  Additionally, compression will be used to reduce the
+size of data portions of the transfer.
 .PP 
 .RS 
 \f(CWrsync \-avz foo:src/bar/ /data/tmp\fP
 .RE
 
 .PP 
 A trailing slash on the source changes this behavior to avoid creating an
-additional directory level at the destination\&.  You can think of a trailing
-/ on a source as meaning "copy the contents of this directory" as opposed
-to "copy the directory by name", but in both cases the attributes of the
+additional directory level at the destination.  You can think of a trailing
+/ on a source as meaning \(lqcopy the contents of this directory\(rq as opposed
+to \(lqcopy the directory by name\(rq, but in both cases the attributes of the
 containing directory are transferred to the containing directory on the
-destination\&.  In other words, each of the following commands copies the
+destination.  In other words, each of the following commands copies the
 files in the same way, including their setting of the attributes of
 /dest/foo:
 .PP 
 .RS 
 \f(CWrsync \-av /src/foo /dest\fP
 .br 
 \f(CWrsync \-av /src/foo/ /dest/foo\fP
 .br 
 .RE
 
 .PP 
-Note also that host and module references don\&'t require a trailing slash to
-copy the contents of the default directory\&.  For example, both of these
-copy the remote directory\&'s contents into "/dest":
+Note also that host and module references don't require a trailing slash to
+copy the contents of the default directory.  For example, both of these
+copy the remote directory's contents into \(lq/dest\(rq:
 .PP 
 .RS 
 \f(CWrsync \-av host: /dest\fP
 .br 
 \f(CWrsync \-av host::module /dest\fP
 .br 
 .RE
 
 .PP 
 You can also use rsync in local-only mode, where both the source and
-destination don\&'t have a \&':\&' in the name\&. In this case it behaves like
-an improved copy command\&.
+destination don't have a \(oq:\(cq in the name. In this case it behaves like
+an improved copy command.
 .PP 
 Finally, you can list all the (listable) modules available from a
 particular rsync daemon by leaving off the module name:
 .PP 
 .RS 
-\f(CWrsync somehost\&.mydomain\&.com::\fP
+\f(CWrsync somehost.mydomain.com::\fP
 .RE
 
 .PP 
-See the following section for more details\&.
+See the following section for more details.
 .PP 
 .SH "ADVANCED USAGE"
 
 .PP 
-The syntax for requesting multiple files from a remote host involves using
-quoted spaces in the SRC\&.  Some examples:
+The syntax for requesting multiple files from a remote host is done by
+specifying additional remote-host args in the same style as the first,
+or with the hostname omitted.  For instance, all these work:
 .PP 
 .RS 
-\f(CWrsync host::\&'modname/dir1/file1 modname/dir2/file2\&' /dest\fP
+\f(CWrsync \-av host:file1 :file2 host:file{3,4} /dest/\fP
+.br 
+\f(CWrsync \-av host::modname/file{1,2} host::modname/file3 /dest/\fP
+.br 
+\f(CWrsync \-av host::modname/file1 ::modname/file{3,4}\fP
 .RE
 
 .PP 
-This would copy file1 and file2 into /dest from an rsync daemon\&.  Each
-additional arg must include the same "modname/" prefix as the first one,
-and must be preceded by a single space\&.  All other spaces are assumed
-to be a part of the filenames\&.
+Older versions of rsync required using quoted spaces in the SRC, like these
+examples:
 .PP 
 .RS 
-\f(CWrsync \-av host:\&'dir1/file1 dir2/file2\&' /dest\fP
+\f(CWrsync \-av host:'dir1/file1 dir2/file2' /dest\fP
+.br 
+\f(CWrsync host::'modname/dir1/file1 modname/dir2/file2' /dest\fP
 .RE
 
 .PP 
-This would copy file1 and file2 into /dest using a remote shell\&.  This
-word-splitting is done by the remote shell, so if it doesn\&'t work it means
-that the remote shell isn\&'t configured to split its args based on
-whitespace (a very rare setting, but not unknown)\&.  If you need to transfer
-a filename that contains whitespace, you\&'ll need to either escape the
-whitespace in a way that the remote shell will understand, or use wildcards
-in place of the spaces\&.  Two examples of this are:
+This word-splitting still works (by default) in the latest rsync, but is
+not as easy to use as the first method.
+.PP 
+If you need to transfer a filename that contains whitespace, you can either
+specify the \fB\-\-protect\-args\fP (\fB\-s\fP) option, or you'll need to escape
+the whitespace in a way that the remote shell will understand.  For
+instance:
 .PP 
 .RS 
-\f(CWrsync \-av host:\&'file\e name\e with\e spaces\&' /dest\fP
-.br 
-\f(CWrsync \-av host:file?name?with?spaces /dest\fP
-.br 
+\f(CWrsync \-av host:'file\e name\e with\e spaces' /dest\fP
 .RE
 
 .PP 
-This latter example assumes that your shell passes through unmatched
-wildcards\&.  If it complains about "no match", put the name in quotes\&.
-.PP 
 .SH "CONNECTING TO AN RSYNC DAEMON"
 
 .PP 
-It is also possible to use rsync without a remote shell as the transport\&.
+It is also possible to use rsync without a remote shell as the transport.
 In this case you will directly connect to a remote rsync daemon, typically
-using TCP port 873\&.  (This obviously requires the daemon to be running on
+using TCP port 873.  (This obviously requires the daemon to be running on
 the remote system, so refer to the STARTING AN RSYNC DAEMON TO ACCEPT
-CONNECTIONS section below for information on that\&.)
+CONNECTIONS section below for information on that.)
 .PP 
 Using rsync in this way is the same as using it with a remote shell except
 that:
 .PP 
 .IP o 
 you either use a double colon :: instead of a single colon to
-separate the hostname from the path, or you use an rsync:// URL\&.
+separate the hostname from the path, or you use an rsync:// URL.
 .IP o 
-the first word of the "path" is actually a module name\&.
+the first word of the \(lqpath\(rq is actually a module name.
 .IP o 
 the remote daemon may print a message of the day when you
-connect\&.
+connect.
 .IP o 
 if you specify no path name on the remote daemon then the
-list of accessible paths on the daemon will be shown\&.
+list of accessible paths on the daemon will be shown.
 .IP o 
 if you specify no local destination then a listing of the
-specified files on the remote daemon is provided\&.
+specified files on the remote daemon is provided.
 .IP o 
-you must not specify the \fB\-\-rsh\fP (\fB\-e\fP) option\&.
+you must not specify the \fB\-\-rsh\fP (\fB\-e\fP) option.
 
 .PP 
-An example that copies all the files in a remote module named "src":
+An example that copies all the files in a remote module named \(lqsrc\(rq:
 .PP 
 .nf 
     rsync \-av host::src /dest
 .fi 
 
 .PP 
-Some modules on the remote daemon may require authentication\&. If so,
-you will receive a password prompt when you connect\&. You can avoid the
+Some modules on the remote daemon may require authentication. If so,
+you will receive a password prompt when you connect. You can avoid the
 password prompt by setting the environment variable RSYNC_PASSWORD to
-the password you want to use or using the \fB\-\-password\-file\fP option\&. This
-may be useful when scripting rsync\&.
+the password you want to use or using the \fB\-\-password\-file\fP option. This
+may be useful when scripting rsync.
 .PP 
 WARNING: On some systems environment variables are visible to all
-users\&. On those systems using \fB\-\-password\-file\fP is recommended\&.
+users. On those systems using \fB\-\-password\-file\fP is recommended.
 .PP 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
-your web proxy\&.  Note that your web proxy\&'s configuration must support
-proxy connections to port 873\&.
+your web proxy.  Note that your web proxy's configuration must support
+proxy connections to port 873.
+.PP 
+You may also establish a daemon connection using a program as a proxy by
+setting the environment variable RSYNC_CONNECT_PROG to the commands you
+wish to run in place of making a direct socket connection.  The string may
+contain the escape \(lq%H\(rq to represent the hostname specified in the rsync
+command (so use \(lq%%\(rq if you need a single \(lq%\(rq in your string).  For
+example:
+.PP 
+.nf 
+  export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
+  rsync \-av targethost1::module/src/ /dest/
+  rsync \-av rsync:://targethost2/module/src/ /dest/ 
+.fi 
+
+.PP 
+The command specified above uses ssh to run nc (netcat) on a proxyhost,
+which forwards all data to port 873 (the rsync daemon) on the targethost
+(%H).
 .PP 
 .SH "USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION"
 
 .PP 
 It is sometimes useful to use various features of an rsync daemon (such as
 named modules) without actually allowing any new socket connections into a
-system (other than what is already required to allow remote-shell access)\&.
+system (other than what is already required to allow remote-shell access).
 Rsync supports connecting to a host using a remote shell and then spawning
-a single-use "daemon" server that expects to read its config file in the
-home dir of the remote user\&.  This can be useful if you want to encrypt a
-daemon-style transfer\&'s data, but since the daemon is started up fresh by
+a single-use \(lqdaemon\(rq server that expects to read its config file in the
+home dir of the remote user.  This can be useful if you want to encrypt a
+daemon-style transfer's data, but since the daemon is started up fresh by
 the remote user, you may not be able to use features such as chroot or
-change the uid used by the daemon\&.  (For another way to encrypt a daemon
+change the uid used by the daemon.  (For another way to encrypt a daemon
 transfer, consider using ssh to tunnel a local port to a remote machine and
 configure a normal rsync daemon on that remote host to only allow
-connections from "localhost"\&.)
+connections from \(lqlocalhost\(rq.)
 .PP 
-From the user\&'s perspective, a daemon transfer via a remote-shell
+From the user's perspective, a daemon transfer via a remote-shell
 connection uses nearly the same command-line syntax as a normal
 rsync-daemon transfer, with the only exception being that you must
 explicitly set the remote shell program on the command-line with the
-\fB\-\-rsh=COMMAND\fP option\&.  (Setting the RSYNC_RSH in the environment
-will not turn on this functionality\&.)  For example:
+\fB\-\-rsh=COMMAND\fP option.  (Setting the RSYNC_RSH in the environment
+will not turn on this functionality.)  For example:
 .PP 
 .nf 
     rsync \-av \-\-rsh=ssh host::module /dest
 .fi 
 
 .PP 
 If you need to specify a different remote-shell user, keep in mind that the
 user@ prefix in front of the host is specifying the rsync-user value (for a
-module that requires user-based authentication)\&.  This means that you must
-give the \&'\-l user\&' option to ssh when specifying the remote-shell, as in
+module that requires user-based authentication).  This means that you must
+give the '\-l user' option to ssh when specifying the remote-shell, as in
 this example that uses the short version of the \fB\-\-rsh\fP option:
 .PP 
 .nf 
     rsync \-av \-e "ssh \-l ssh-user" rsync-user@host::module /dest
 .fi 
 
 .PP 
-The "ssh-user" will be used at the ssh level; the "rsync-user" will be
-used to log-in to the "module"\&.
+The \(lqssh-user\(rq will be used at the ssh level; the \(lqrsync-user\(rq will be
+used to log-in to the \(lqmodule\(rq.
 .PP 
 .SH "STARTING AN RSYNC DAEMON TO ACCEPT CONNECTIONS"
 
 .PP 
 In order to connect to an rsync daemon, the remote system needs to have a
 daemon already running (or it needs to have configured something like inetd
-to spawn an rsync daemon for incoming connections on a particular port)\&.
+to spawn an rsync daemon for incoming connections on a particular port).
 For full information on how to start a daemon that will handling incoming
-socket connections, see the \fBrsyncd\&.conf\fP(5) man page -- that is the config
+socket connections, see the \fBrsyncd.conf\fP(5) man page \(em that is the config
 file for the daemon, and it contains the full details for how to run the
-daemon (including stand-alone and inetd configurations)\&.
+daemon (including stand-alone and inetd configurations).
 .PP 
-If you\&'re using one of the remote-shell transports for the transfer, there is
-no need to manually start an rsync daemon\&.
+If you're using one of the remote-shell transports for the transfer, there is
+no need to manually start an rsync daemon.
 .PP 
 .SH "EXAMPLES"
 
 .PP 
-Here are some examples of how I use rsync\&.
+Here are some examples of how I use rsync.
 .PP 
-To backup my wife\&'s home directory, which consists of large MS Word
+To backup my wife's home directory, which consists of large MS Word
 files and mail folders, I use a cron job that runs
 .PP 
 .RS 
-\f(CWrsync \-Cavz \&. arvidsjaur:backup\fP
+\f(CWrsync \-Cavz . arvidsjaur:backup\fP
 .RE
 
 .PP 
 each night over a PPP connection to a duplicate directory on my machine
-"arvidsjaur"\&.
+\(lqarvidsjaur\(rq.
 .PP 
 To synchronize my samba source trees I use the following Makefile
 targets:
 .PP 
 .nf 
     get:
-            rsync \-avuzb \-\-exclude \&'*~\&' samba:samba/ \&.
+            rsync \-avuzb \-\-exclude '*~' samba:samba/ .
     put:
-            rsync \-Cavuzb \&. samba:samba/
+            rsync \-Cavuzb . samba:samba/
     sync: get put
 .fi 
 
 .PP 
 this allows me to sync with a CVS directory at the other end of the
-connection\&. I then do CVS operations on the remote machine, which saves a
-lot of time as the remote CVS protocol isn\&'t very efficient\&.
+connection. I then do CVS operations on the remote machine, which saves a
+lot of time as the remote CVS protocol isn't very efficient.
 .PP 
-I mirror a directory between my "old" and "new" ftp sites with the
+I mirror a directory between my \(lqold\(rq and \(lqnew\(rq ftp sites with the
 command:
 .PP 
 \f(CWrsync \-az \-e ssh \-\-delete ~ftp/pub/samba nimbus:"~ftp/pub/tridge"\fP
 .PP 
-This is launched from cron every few hours\&.
+This is launched from cron every few hours.
 .PP 
 .SH "OPTIONS SUMMARY"
 
 .PP 
-Here is a short summary of the options available in rsync\&. Please refer
-to the detailed description below for a complete description\&.  
+Here is a short summary of the options available in rsync. Please refer
+to the detailed description below for a complete description.  
 .nf 
 
  \-v, \-\-verbose               increase verbosity
  \-q, \-\-quiet                 suppress non-error messages
      \-\-no\-motd               suppress daemon-mode MOTD (see caveat)
  \-c, \-\-checksum              skip based on checksum, not mod-time & size
- \-a, \-\-archive               archive mode; same as \-rlptgoD (no \-H)
-     \-\-no\-OPTION             turn off an implied OPTION (e\&.g\&. \-\-no\-D)
+ \-a, \-\-archive               archive mode; equals \-rlptgoD (no \-H,\-A,\-X)
+     \-\-no\-OPTION             turn off an implied OPTION (e.g. \-\-no\-D)
  \-r, \-\-recursive             recurse into directories
  \-R, \-\-relative              use relative path names
-     \-\-no\-implied\-dirs       don\&'t send implied dirs with \-\-relative
+     \-\-no\-implied\-dirs       don't send implied dirs with \-\-relative
  \-b, \-\-backup                make backups (see \-\-suffix & \-\-backup\-dir)
      \-\-backup\-dir=DIR        make backups into hierarchy based in DIR
      \-\-suffix=SUFFIX         backup suffix (default ~ w/o \-\-backup\-dir)
  \-u, \-\-update                skip files that are newer on the receiver
      \-\-inplace               update destination files in-place
      \-\-append                append data onto shorter files
+     \-\-append\-verify         \-\-append w/old data in file checksum
  \-d, \-\-dirs                  transfer directories without recursing
  \-l, \-\-links                 copy symlinks as symlinks
  \-L, \-\-copy\-links            transform symlink into referent file/dir
      \-\-copy\-unsafe\-links     only "unsafe" symlinks are transformed
      \-\-safe\-links            ignore symlinks that point outside the tree
  \-k, \-\-copy\-dirlinks         transform symlink to dir into referent dir
  \-K, \-\-keep\-dirlinks         treat symlinked dir on receiver as dir
  \-H, \-\-hard\-links            preserve hard links
  \-p, \-\-perms                 preserve permissions
  \-E, \-\-executability         preserve executability
      \-\-chmod=CHMOD           affect file and/or directory permissions
+ \-A, \-\-acls                  preserve ACLs (implies \-p)
+ \-X, \-\-xattrs                preserve extended attributes
  \-o, \-\-owner                 preserve owner (super-user only)
  \-g, \-\-group                 preserve group
      \-\-devices               preserve device files (super-user only)
      \-\-specials              preserve special files
  \-D                          same as \-\-devices \-\-specials
- \-t, \-\-times                 preserve times
- \-O, \-\-omit\-dir\-times        omit directories when preserving times
+ \-t, \-\-times                 preserve modification times
+ \-O, \-\-omit\-dir\-times        omit directories from \-\-times
      \-\-super                 receiver attempts super-user activities
+     \-\-fake\-super            store/recover privileged attrs using xattrs
  \-S, \-\-sparse                handle sparse files efficiently
- \-n, \-\-dry\-run               show what would have been transferred
- \-W, \-\-whole\-file            copy files whole (without rsync algorithm)
- \-x, \-\-one\-file\-system       don\&'t cross filesystem boundaries
+ \-n, \-\-dry\-run               perform a trial run with no changes made
+ \-W, \-\-whole\-file            copy files whole (w/o delta-xfer algorithm)
+ \-x, \-\-one\-file\-system       don't cross filesystem boundaries
  \-B, \-\-block\-size=SIZE       force a fixed checksum block-size
  \-e, \-\-rsh=COMMAND           specify the remote shell to use
      \-\-rsync\-path=PROGRAM    specify the rsync to run on remote machine
      \-\-existing              skip creating new files on receiver
      \-\-ignore\-existing       skip updating files that exist on receiver
      \-\-remove\-source\-files   sender removes synchronized files (non-dir)
      \-\-del                   an alias for \-\-delete\-during
      \-\-delete                delete extraneous files from dest dirs
      \-\-delete\-before         receiver deletes before transfer (default)
      \-\-delete\-during         receiver deletes during xfer, not before
+     \-\-delete\-delay          find deletions during, delete after
      \-\-delete\-after          receiver deletes after transfer, not before
      \-\-delete\-excluded       also delete excluded files from dest dirs
      \-\-ignore\-errors         delete even if there are I/O errors
      \-\-force                 force deletion of dirs even if not empty
-     \-\-max\-delete=NUM        don\&'t delete more than NUM files
-     \-\-max\-size=SIZE         don\&'t transfer any file larger than SIZE
-     \-\-min\-size=SIZE         don\&'t transfer any file smaller than SIZE
+     \-\-max\-delete=NUM        don't delete more than NUM files
+     \-\-max\-size=SIZE         don't transfer any file larger than SIZE
+     \-\-min\-size=SIZE         don't transfer any file smaller than SIZE
      \-\-partial               keep partially transferred files
      \-\-partial\-dir=DIR       put a partially transferred file into DIR
      \-\-delay\-updates         put all updated files into place at end
  \-m, \-\-prune\-empty\-dirs      prune empty directory chains from file-list
-     \-\-numeric\-ids           don\&'t map uid/gid values by user/group name
-     \-\-timeout=TIME          set I/O timeout in seconds
- \-I, \-\-ignore\-times          don\&'t skip files that match size and time
+     \-\-numeric\-ids           don't map uid/gid values by user/group name
+     \-\-timeout=SECONDS       set I/O timeout in seconds
+     \-\-contimeout=SECONDS    set daemon connection timeout in seconds
+ \-I, \-\-ignore\-times          don't skip files that match size and time
      \-\-size\-only             skip files that match in size
      \-\-modify\-window=NUM     compare mod-times with reduced accuracy
  \-T, \-\-temp\-dir=DIR          create temporary files in directory DIR
  \-y, \-\-fuzzy                 find similar file for basis if no dest file
      \-\-compare\-dest=DIR      also compare received files relative to DIR
-     \-\-copy\-dest=DIR         \&.\&.\&. and include copies of unchanged files
+     \-\-copy\-dest=DIR         ... and include copies of unchanged files
      \-\-link\-dest=DIR         hardlink to files in DIR when unchanged
  \-z, \-\-compress              compress file data during the transfer
      \-\-compress\-level=NUM    explicitly set compression level
+     \-\-skip\-compress=LIST    skip compressing files with suffix in LIST
  \-C, \-\-cvs\-exclude           auto-ignore files in the same way CVS does
  \-f, \-\-filter=RULE           add a file-filtering RULE
- \-F                          same as \-\-filter=\&'dir-merge /\&.rsync\-filter\&'
-                             repeated: \-\-filter=\&'\- \&.rsync\-filter\&'
+ \-F                          same as \-\-filter='dir-merge /.rsync\-filter'
+                             repeated: \-\-filter='\- .rsync\-filter'
      \-\-exclude=PATTERN       exclude files matching PATTERN
      \-\-exclude\-from=FILE     read exclude patterns from FILE
-     \-\-include=PATTERN       don\&'t exclude files matching PATTERN
+     \-\-include=PATTERN       don't exclude files matching PATTERN
      \-\-include\-from=FILE     read include patterns from FILE
      \-\-files\-from=FILE       read list of source-file names from FILE
  \-0, \-\-from0                 all *from/filter files are delimited by 0s
+ \-s, \-\-protect\-args          no space-splitting; wildcard chars only
      \-\-address=ADDRESS       bind address for outgoing socket to daemon
      \-\-port=PORT             specify double-colon alternate port number
      \-\-sockopts=OPTIONS      specify custom TCP options
      \-\-blocking\-io           use blocking I/O for the remote shell
      \-\-stats                 give some file-transfer stats
  \-8, \-\-8\-bit\-output          leave high-bit chars unescaped in output
  \-h, \-\-human\-readable        output numbers in a human-readable format
      \-\-progress              show progress during transfer
  \-P                          same as \-\-partial \-\-progress
  \-i, \-\-itemize\-changes       output a change-summary for all updates
      \-\-out\-format=FORMAT     output updates using the specified FORMAT
-     \-\-log\-file=FILE         log what we\&'re doing to the specified FILE
+     \-\-log\-file=FILE         log what we're doing to the specified FILE
      \-\-log\-file\-format=FMT   log updates using the specified FMT
-     \-\-password\-file=FILE    read password from FILE
+     \-\-password\-file=FILE    read daemon-access password from FILE
      \-\-list\-only             list the files instead of copying them
      \-\-bwlimit=KBPS          limit I/O bandwidth; KBytes per second
      \-\-write\-batch=FILE      write a batched update to FILE
      \-\-only\-write\-batch=FILE like \-\-write\-batch but w/o updating dest
      \-\-read\-batch=FILE       read a batched update from FILE
      \-\-protocol=NUM          force an older protocol version to be used
+     \-\-iconv=CONVERT_SPEC    request charset conversion of filenames
      \-\-checksum\-seed=NUM     set block/file checksum seed (advanced)
  \-4, \-\-ipv4                  prefer IPv4
  \-6, \-\-ipv6                  prefer IPv6
      \-\-version               print version number
 (\-h) \-\-help                  show this help (see below for \-h comment)
 .fi 
@@ -476,13 +510,13 @@
 accepted: 
 .nf 
 
      \-\-daemon                run as an rsync daemon
      \-\-address=ADDRESS       bind to the specified address
      \-\-bwlimit=KBPS          limit I/O bandwidth; KBytes per second
-     \-\-config=FILE           specify alternate rsyncd\&.conf file
+     \-\-config=FILE           specify alternate rsyncd.conf file
      \-\-no\-detach             do not detach from the parent
      \-\-port=PORT             listen on alternate port number
      \-\-log\-file=FILE         override the "log file" setting
      \-\-log\-file\-format=FMT   override the "log format" setting
      \-\-sockopts=OPTIONS      specify custom TCP options
  \-v, \-\-verbose               increase verbosity
@@ -492,1833 +526,2128 @@
 .fi 
 
 .PP 
 .SH "OPTIONS"
 
 .PP 
-rsync uses the GNU long options package\&. Many of the command line
-options have two variants, one short and one long\&.  These are shown
-below, separated by commas\&. Some options only have a long variant\&.
-The \&'=\&' for options that take a parameter is optional; whitespace
-can be used instead\&.
+rsync uses the GNU long options package. Many of the command line
+options have two variants, one short and one long.  These are shown
+below, separated by commas. Some options only have a long variant.
+The \(oq=\(cq for options that take a parameter is optional; whitespace
+can be used instead.
 .PP 
 .IP "\fB\-\-help\fP"
 Print a short help page describing the options
-available in rsync and exit\&.  For backward-compatibility with older
+available in rsync and exit.  For backward-compatibility with older
 versions of rsync, the help will also be output if you use the \fB\-h\fP
-option without any other args\&.
+option without any other args.
 .IP 
 .IP "\fB\-\-version\fP"
-print the rsync version number and exit\&.
+print the rsync version number and exit.
 .IP 
 .IP "\fB\-v, \-\-verbose\fP"
 This option increases the amount of information you
-are given during the transfer\&.  By default, rsync works silently\&. A
+are given during the transfer.  By default, rsync works silently. A
 single \fB\-v\fP will give you information about what files are being
-transferred and a brief summary at the end\&. Two \fB\-v\fP flags will give you
+transferred and a brief summary at the end. Two \fB\-v\fP flags will give you
 information on what files are being skipped and slightly more
-information at the end\&. More than two \fB\-v\fP flags should only be used if
-you are debugging rsync\&.
+information at the end. More than two \fB\-v\fP flags should only be used if
+you are debugging rsync.
 .IP 
 Note that the names of the transferred files that are output are done using
-a default \fB\-\-out\-format\fP of "%n%L", which tells you just the name of the
-file and, if the item is a link, where it points\&.  At the single \fB\-v\fP
+a default \fB\-\-out\-format\fP of \(lq%n%L\(rq, which tells you just the name of the
+file and, if the item is a link, where it points.  At the single \fB\-v\fP
 level of verbosity, this does not mention when a file gets its attributes
-changed\&.  If you ask for an itemized list of changed attributes (either
-\fB\-\-itemize\-changes\fP or adding "%i" to the \fB\-\-out\-format\fP setting), the
+changed.  If you ask for an itemized list of changed attributes (either
+\fB\-\-itemize\-changes\fP or adding \(lq%i\(rq to the \fB\-\-out\-format\fP setting), the
 output (on the client) increases to mention all items that are changed in
-any way\&.  See the \fB\-\-out\-format\fP option for more details\&.
+any way.  See the \fB\-\-out\-format\fP option for more details.
 .IP 
 .IP "\fB\-q, \-\-quiet\fP"
 This option decreases the amount of information you
 are given during the transfer, notably suppressing information messages
-from the remote server\&. This flag is useful when invoking rsync from
-cron\&.
+from the remote server. This flag is useful when invoking rsync from
+cron.
 .IP 
 .IP "\fB\-\-no\-motd\fP"
 This option affects the information that is output
-by the client at the start of a daemon transfer\&.  This suppresses the
+by the client at the start of a daemon transfer.  This suppresses the
 message-of-the-day (MOTD) text, but it also affects the list of modules
-that the daemon sends in response to the "rsync host::" request (due to
+that the daemon sends in response to the \(lqrsync host::\(rq request (due to
 a limitation in the rsync protocol), so omit this option if you want to
-request the list of modules from the deamon\&.
+request the list of modules from the daemon.
 .IP 
 .IP "\fB\-I, \-\-ignore\-times\fP"
 Normally rsync will skip any files that are
-already the same size and have the same modification time-stamp\&.
-This option turns off this "quick check" behavior, causing all files to
-be updated\&.
+already the same size and have the same modification timestamp.
+This option turns off this \(lqquick check\(rq behavior, causing all files to
+be updated.
 .IP 
 .IP "\fB\-\-size\-only\fP"
-Normally rsync will not transfer any files that are
-already the same size and have the same modification time-stamp\&. With the
-\fB\-\-size\-only\fP option, files will not be transferred if they have the same size,
-regardless of timestamp\&. This is useful when starting to use rsync
-after using another mirroring system which may not preserve timestamps
-exactly\&.
+This modifies rsync's \(lqquick check\(rq algorithm for
+finding files that need to be transferred, changing it from the default of
+transferring files with either a changed size or a changed last-modified
+time to just looking for files that have changed in size.  This is useful
+when starting to use rsync after using another mirroring system which may
+not preserve timestamps exactly.
 .IP 
 .IP "\fB\-\-modify\-window\fP"
 When comparing two timestamps, rsync treats the
 timestamps as being equal if they differ by no more than the modify-window
-value\&.  This is normally 0 (for an exact match), but you may find it useful
-to set this to a larger value in some situations\&.  In particular, when
+value.  This is normally 0 (for an exact match), but you may find it useful
+to set this to a larger value in some situations.  In particular, when
 transferring to or from an MS Windows FAT filesystem (which represents
 times with a 2-second resolution), \fB\-\-modify\-window=1\fP is useful
-(allowing times to differ by up to 1 second)\&.
+(allowing times to differ by up to 1 second).
 .IP 
 .IP "\fB\-c, \-\-checksum\fP"
-This forces the sender to checksum \fIevery\fP
-regular file using a 128-bit MD4 checksum\&.  It does this during the initial
-file-system scan as it builds the list of all available files\&. The receiver
-then checksums its version of each file (if it exists and it has the same
-size as its sender-side counterpart) in order to decide which files need to
-be updated: files with either a changed size or a changed checksum are
-selected for transfer\&.  Since this whole-file checksumming of all files on
-both sides of the connection occurs in addition to the automatic checksum
-verifications that occur during a file\&'s transfer, this option can be quite
-slow\&.
-.IP 
-Note that rsync always verifies that each \fItransferred\fP file was correctly
-reconstructed on the receiving side by checking its whole-file checksum, but
-that automatic after-the-transfer verification has nothing to do with this
-option\&'s before-the-transfer "Does this file need to be updated?" check\&.
+This changes the way rsync checks if the files have
+been changed and are in need of a transfer.  Without this option, rsync
+uses a \(lqquick check\(rq that (by default) checks if each file's size and time
+of last modification match between the sender and receiver.  This option
+changes this to compare a 128-bit MD4 checksum for each file that has a
+matching size.  Generating the checksums means that both sides will expend
+a lot of disk I/O reading all the data in the files in the transfer (and
+this is prior to any reading that will be done to transfer changed files),
+so this can slow things down significantly.
+.IP 
+The sending side generates its checksums while it is doing the file-system
+scan that builds the list of the available files.  The receiver generates
+its checksums when it is scanning for changed files, and will checksum any
+file that has the same size as the corresponding sender's file:  files with
+either a changed size or a changed checksum are selected for transfer.
+.IP 
+Note that rsync always verifies that each \fItransferred\fP file was
+correctly reconstructed on the receiving side by checking a whole-file
+checksum that is generated as the file is transferred, but that
+automatic after-the-transfer verification has nothing to do with this
+option's before-the-transfer \(lqDoes this file need to be updated?\(rq check.
 .IP 
 .IP "\fB\-a, \-\-archive\fP"
-This is equivalent to \fB\-rlptgoD\fP\&. It is a quick
+This is equivalent to \fB\-rlptgoD\fP. It is a quick
 way of saying you want recursion and want to preserve almost
-everything (with \-H being a notable omission)\&.
+everything (with \-H being a notable omission).
 The only exception to the above equivalence is when \fB\-\-files\-from\fP is
-specified, in which case \fB\-r\fP is not implied\&.
+specified, in which case \fB\-r\fP is not implied.
 .IP 
 Note that \fB\-a\fP \fBdoes not preserve hardlinks\fP, because
-finding multiply-linked files is expensive\&.  You must separately
-specify \fB\-H\fP\&.
+finding multiply-linked files is expensive.  You must separately
+specify \fB\-H\fP.
 .IP 
 .IP "\-\-no\-OPTION"
 You may turn off one or more implied options by prefixing
-the option name with "no\-"\&.  Not all options may be prefixed with a "no\-":
-only options that are implied by other options (e\&.g\&. \fB\-\-no\-D\fP,
+the option name with \(lqno\-\(rq.  Not all options may be prefixed with a \(lqno\-\(rq:
+only options that are implied by other options (e.g. \fB\-\-no\-D\fP,
 \fB\-\-no\-perms\fP) or have different defaults in various circumstances
-(e\&.g\&. \fB\-\-no\-whole\-file\fP, \fB\-\-no\-blocking\-io\fP, \fB\-\-no\-dirs\fP)\&.  You may
-specify either the short or the long option name after the "no\-" prefix
-(e\&.g\&. \fB\-\-no\-R\fP is the same as \fB\-\-no\-relative\fP)\&.
+(e.g. \fB\-\-no\-whole\-file\fP, \fB\-\-no\-blocking\-io\fP, \fB\-\-no\-dirs\fP).  You may
+specify either the short or the long option name after the \(lqno\-\(rq prefix
+(e.g. \fB\-\-no\-R\fP is the same as \fB\-\-no\-relative\fP).
 .IP 
-For example: if you want to use \fB\-a\fP (\fB\-\-archive\fP) but don\&'t want
+For example: if you want to use \fB\-a\fP (\fB\-\-archive\fP) but don't want
 \fB\-o\fP (\fB\-\-owner\fP), instead of converting \fB\-a\fP into \fB\-rlptgD\fP, you
-could specify \fB\-a \-\-no\-o\fP (or \fB\-a \-\-no\-owner\fP)\&.
+could specify \fB\-a \-\-no\-o\fP (or \fB\-a \-\-no\-owner\fP).
 .IP 
 The order of the options is important:  if you specify \fB\-\-no\-r \-a\fP, the
-\fB\-r\fP option would end up being turned on, the opposite of \fB\-a \-\-no\-r\fP\&.
+\fB\-r\fP option would end up being turned on, the opposite of \fB\-a \-\-no\-r\fP.
 Note also that the side-effects of the \fB\-\-files\-from\fP option are NOT
 positional, as it affects the default state of several options and slightly
 changes the meaning of \fB\-a\fP (see the \fB\-\-files\-from\fP option for more
-details)\&.
+details).
 .IP 
 .IP "\fB\-r, \-\-recursive\fP"
 This tells rsync to copy directories
-recursively\&.  See also \fB\-\-dirs\fP (\fB\-d\fP)\&.
+recursively.  See also \fB\-\-dirs\fP (\fB\-d\fP).
+.IP 
+Beginning with rsync 3.0.0, the recursive algorithm used is now an
+incremental scan that uses much less memory than before and begins the
+transfer after the scanning of the first few directories have been
+completed.  This incremental scan only affects our recursion algorithm, and
+does not change a non-recursive transfer.  It is also only possible when
+both ends of the transfer are at least version 3.0.0.
+.IP 
+Some options require rsync to know the full file list, so these options
+disable the incremental recursion mode.  These include: \fB\-\-delete\-before\fP,
+\fB\-\-delete\-after\fP, \fB\-\-prune\-empty\-dirs\fP, and \fB\-\-delay\-updates\fP.
+Because of this, the default delete mode when you specify \fB\-\-delete\fP is now
+\fB\-\-delete\-during\fP when both ends of the connection are at least 3.0.0
+(use \fB\-\-del\fP or \fB\-\-delete\-during\fP to request this improved deletion mode
+explicitly).  See also the \fB\-\-delete\-delay\fP option that is a better choice
+than using \fB\-\-delete\-after\fP.
+.IP 
+Incremental recursion can be disabled using the \fB\-\-no\-inc\-recursive\fP
+option or its shorter \fB\-\-no\-i\-r\fP alias.
 .IP 
 .IP "\fB\-R, \-\-relative\fP"
-Use relative paths\&. This means that the full path
+Use relative paths. This means that the full path
 names specified on the command line are sent to the server rather than
-just the last parts of the filenames\&. This is particularly useful when
-you want to send several different directories at the same time\&. For
+just the last parts of the filenames. This is particularly useful when
+you want to send several different directories at the same time. For
 example, if you used this command:
 .IP 
 .RS 
-\f(CW   rsync \-av /foo/bar/baz\&.c remote:/tmp/\fP
+\f(CW   rsync \-av /foo/bar/baz.c remote:/tmp/\fP
 .RE
 
 .IP 
-\&.\&.\&. this would create a file named baz\&.c in /tmp/ on the remote
-machine\&. If instead you used
+\&... this would create a file named baz.c in /tmp/ on the remote
+machine. If instead you used
 .IP 
 .RS 
-\f(CW   rsync \-avR /foo/bar/baz\&.c remote:/tmp/\fP
+\f(CW   rsync \-avR /foo/bar/baz.c remote:/tmp/\fP
 .RE
 
 .IP 
-then a file named /tmp/foo/bar/baz\&.c would be created on the remote
-machine -- the full path name is preserved\&.  To limit the amount of
-path information that is sent, you have a couple options:  (1) With
-a modern rsync on the sending side (beginning with 2\&.6\&.7), you can
-insert a dot and a slash into the source path, like this:
+then a file named /tmp/foo/bar/baz.c would be created on the remote
+machine, preserving its full path.  These extra path elements are called
+\(lqimplied directories\(rq (i.e. the \(lqfoo\(rq and the \(lqfoo/bar\(rq directories in the
+above example).
+.IP 
+Beginning with rsync 3.0.0, rsync always sends these implied directories as
+real directories in the file list, even if a path element is really a
+symlink on the sending side.  This prevents some really unexpected
+behaviors when copying the full path of a file that you didn't realize had
+a symlink in its path.  If you want to duplicate a server-side symlink,
+include both the symlink via its path, and referent directory via its real
+path.  If you're dealing with an older rsync on the sending side, you may
+need to use the \fB\-\-no\-implied\-dirs\fP option.
+.IP 
+It is also possible to limit the amount of path information that is sent as
+implied directories for each path you specify.  With a modern rsync on the
+sending side (beginning with 2.6.7), you can insert a dot and a slash into
+the source path, like this:
 .IP 
 .RS 
-\f(CW   rsync \-avR /foo/\&./bar/baz\&.c remote:/tmp/\fP
+\f(CW   rsync \-avR /foo/./bar/baz.c remote:/tmp/\fP
 .RE
 
 .IP 
-That would create /tmp/bar/baz\&.c on the remote machine\&.  (Note that the
-dot must be followed by a slash, so "/foo/\&." would not be abbreviated\&.)
+That would create /tmp/bar/baz.c on the remote machine.  (Note that the
+dot must be followed by a slash, so \(lq/foo/.\(rq would not be abbreviated.)
 (2) For older rsync versions, you would need to use a chdir to limit the
-source path\&.  For example, when pushing files:
+source path.  For example, when pushing files:
 .IP 
 .RS 
-\f(CW   (cd /foo; rsync \-avR bar/baz\&.c remote:/tmp/) \fP
+\f(CW   (cd /foo; rsync \-avR bar/baz.c remote:/tmp/) \fP
 .RE
 
 .IP 
 (Note that the parens put the two commands into a sub-shell, so that the
-"cd" command doesn\&'t remain in effect for future commands\&.)
-If you\&'re pulling files, use this idiom (which doesn\&'t work with an
-rsync daemon):
+\(lqcd\(rq command doesn't remain in effect for future commands.)
+If you're pulling files from an older rsync, use this idiom (but only
+for a non-daemon transfer):
 .IP 
 .RS 
 \f(CW   rsync \-avR \-\-rsync\-path="cd /foo; rsync" \e \fP
 .br 
-\f(CW       remote:bar/baz\&.c /tmp/\fP
+\f(CW       remote:bar/baz.c /tmp/\fP
 .RE
 
 .IP 
 .IP "\fB\-\-no\-implied\-dirs\fP"
 This option affects the default behavior of the
-\fB\-\-relative\fP option\&.  When it is specified, the attributes of the implied
-directories from the source names are not included in the transfer\&.  This
+\fB\-\-relative\fP option.  When it is specified, the attributes of the implied
+directories from the source names are not included in the transfer.  This
 means that the corresponding path elements on the destination system are
 left unchanged if they exist, and any missing implied directories are
-created with default attributes\&.  This even allows these implied path
+created with default attributes.  This even allows these implied path
 elements to have big differences, such as being a symlink to a directory on
-one side of the transfer, and a real directory on the other side\&.
+the receiving side.
 .IP 
 For instance, if a command-line arg or a files-from entry told rsync to
-transfer the file "path/foo/file", the directories "path" and "path/foo"
-are implied when \fB\-\-relative\fP is used\&.  If "path/foo" is a symlink to
-"bar" on the destination system, the receiving rsync would ordinarily
-delete "path/foo", recreate it as a directory, and receive the file into
-the new directory\&.  With \fB\-\-no\-implied\-dirs\fP, the receiving rsync updates
-"path/foo/file" using the existing path elements, which means that the file
-ends up being created in "path/bar"\&.  Another way to accomplish this link
+transfer the file \(lqpath/foo/file\(rq, the directories \(lqpath\(rq and \(lqpath/foo\(rq
+are implied when \fB\-\-relative\fP is used.  If \(lqpath/foo\(rq is a symlink to
+\(lqbar\(rq on the destination system, the receiving rsync would ordinarily
+delete \(lqpath/foo\(rq, recreate it as a directory, and receive the file into
+the new directory.  With \fB\-\-no\-implied\-dirs\fP, the receiving rsync updates
+\(lqpath/foo/file\(rq using the existing path elements, which means that the file
+ends up being created in \(lqpath/bar\(rq.  Another way to accomplish this link
 preservation is to use the \fB\-\-keep\-dirlinks\fP option (which will also
-affect symlinks to directories in the rest of the transfer)\&.
+affect symlinks to directories in the rest of the transfer).
 .IP 
-In a similar but opposite scenario, if the transfer of "path/foo/file" is
-requested and "path/foo" is a symlink on the sending side, running without
-\fB\-\-no\-implied\-dirs\fP would cause rsync to transform "path/foo" on the
-receiving side into an identical symlink, and then attempt to transfer
-"path/foo/file", which might fail if the duplicated symlink did not point
-to a directory on the receiving side\&.  Another way to avoid this sending of
-a symlink as an implied directory is to use \fB\-\-copy\-unsafe\-links\fP, or
-\fB\-\-copy\-dirlinks\fP (both of which also affect symlinks in the rest of the
-transfer -- see their descriptions for full details)\&.
+When pulling files from an rsync older than 3.0.0, you may need to use this
+option if the sending side has a symlink in the path you request and you
+wish the implied directories to be transferred as normal directories.
 .IP 
 .IP "\fB\-b, \-\-backup\fP"
 With this option, preexisting destination files are
-renamed as each file is transferred or deleted\&.  You can control where the
+renamed as each file is transferred or deleted.  You can control where the
 backup file goes and what (if any) suffix gets appended using the
-\fB\-\-backup\-dir\fP and \fB\-\-suffix\fP options\&.
+\fB\-\-backup\-dir\fP and \fB\-\-suffix\fP options.
 .IP 
-Note that if you don\&'t specify \fB\-\-backup\-dir\fP, (1) the
+Note that if you don't specify \fB\-\-backup\-dir\fP, (1) the
 \fB\-\-omit\-dir\-times\fP option will be implied, and (2) if \fB\-\-delete\fP is
-also in effect (without \fB\-\-delete\-excluded\fP), rsync will add a "protect"
+also in effect (without \fB\-\-delete\-excluded\fP), rsync will add a \(lqprotect\(rq
 filter-rule for the backup suffix to the end of all your existing excludes
-(e\&.g\&. \-f "P *~")\&.  This will prevent previously backed-up files from being
-deleted\&.  Note that if you are supplying your own filter rules, you may
+(e.g. \fB\-f "Pp *~"\fP).  This will prevent previously backed-up files from being
+deleted.  Note that if you are supplying your own filter rules, you may
 need to manually insert your own exclude/protect rule somewhere higher up
-in the list so that it has a high enough priority to be effective (e\&.g\&., if
-your rules specify a trailing inclusion/exclusion of \&'*\&', the auto-added
-rule would never be reached)\&.
+in the list so that it has a high enough priority to be effective (e.g., if
+your rules specify a trailing inclusion/exclusion of \(oq*\(cq, the auto-added
+rule would never be reached).
 .IP 
 .IP "\fB\-\-backup\-dir=DIR\fP"
 In combination with the \fB\-\-backup\fP option, this
 tells rsync to store all backups in the specified directory on the receiving
-side\&.  This can be used for incremental backups\&.  You can additionally
+side.  This can be used for incremental backups.  You can additionally
 specify a backup suffix using the \fB\-\-suffix\fP option
 (otherwise the files backed up in the specified directory
-will keep their original filenames)\&.
+will keep their original filenames).
 .IP 
 .IP "\fB\-\-suffix=SUFFIX\fP"
 This option allows you to override the default
-backup suffix used with the \fB\-\-backup\fP (\fB\-b\fP) option\&. The default suffix is a ~
-if no \-\fB\-backup-dir\fP was specified, otherwise it is an empty string\&.
+backup suffix used with the \fB\-\-backup\fP (\fB\-b\fP) option. The default suffix is a ~
+if no \-\fB\-backup-dir\fP was specified, otherwise it is an empty string.
 .IP 
 .IP "\fB\-u, \-\-update\fP"
 This forces rsync to skip any files which exist on
 the destination and have a modified time that is newer than the source
-file\&.  (If an existing destination file has a modify time equal to the
-source file\&'s, it will be updated if the sizes are different\&.)
+file.  (If an existing destination file has a modification time equal to the
+source file's, it will be updated if the sizes are different.)
 .IP 
-In the current implementation of \fB\-\-update\fP, a difference of file format
-between the sender and receiver is always
-considered to be important enough for an update, no matter what date
-is on the objects\&.  In other words, if the source has a directory or a
-symlink where the destination has a file, the transfer would occur
-regardless of the timestamps\&.  This might change in the future (feel
-free to comment on this on the mailing list if you have an opinion)\&.
+Note that this does not affect the copying of symlinks or other special
+files.  Also, a difference of file format between the sender and receiver
+is always considered to be important enough for an update, no matter what
+date is on the objects.  In other words, if the source has a directory
+where the destination has a file, the transfer would occur regardless of
+the timestamps.
 .IP 
 .IP "\fB\-\-inplace\fP"
 This causes rsync not to create a new copy of the file
-and then move it into place\&.  Instead rsync will overwrite the existing
-file, meaning that the rsync algorithm can\&'t accomplish the full amount of
+and then move it into place.  Instead rsync will overwrite the existing
+file, meaning that the rsync algorithm can't accomplish the full amount of
 network reduction it might be able to otherwise (since it does not yet try
-to sort data matches)\&.  One exception to this is if you combine the option
+to sort data matches).  One exception to this is if you combine the option
 with \fB\-\-backup\fP, since rsync is smart enough to use the backup file as the
-basis file for the transfer\&.
+basis file for the transfer.
 .IP 
 This option is useful for transfer of large files with block-based changes
 or appended data, and also on systems that are disk bound, not network
-bound\&.
+bound.
 .IP 
 The option implies \fB\-\-partial\fP (since an interrupted transfer does not delete
-the file), but conflicts with \fB\-\-partial\-dir\fP and \fB\-\-delay\-updates\fP\&.
-Prior to rsync 2\&.6\&.4 \fB\-\-inplace\fP was also incompatible with \fB\-\-compare\-dest\fP
-and \fB\-\-link\-dest\fP\&.
+the file), but conflicts with \fB\-\-partial\-dir\fP and \fB\-\-delay\-updates\fP.
+Prior to rsync 2.6.4 \fB\-\-inplace\fP was also incompatible with \fB\-\-compare\-dest\fP
+and \fB\-\-link\-dest\fP.
 .IP 
-WARNING: The file\&'s data will be in an inconsistent state during the
+WARNING: The file's data will be in an inconsistent state during the
 transfer (and possibly afterward if the transfer gets interrupted), so you
-should not use this option to update files that are in use\&.  Also note that
+should not use this option to update files that are in use.  Also note that
 rsync will be unable to update a file in-place that is not writable by the
-receiving user\&.
+receiving user.
 .IP 
 .IP "\fB\-\-append\fP"
 This causes rsync to update a file by appending data onto
 the end of the file, which presumes that the data that already exists on
 the receiving side is identical with the start of the file on the sending
-side\&.  If that is not true, the file will fail the checksum test, and the
-resend will do a normal \fB\-\-inplace\fP update to correct the mismatched data\&.
-Only files on the receiving side that are shorter than the corresponding
-file on the sending side (as well as new files) are sent\&.
-Implies \fB\-\-inplace\fP, but does not conflict with \fB\-\-sparse\fP (though the
-\fB\-\-sparse\fP option will be auto-disabled if a resend of the already-existing
-data is required)\&.
+side.  Any files that are the same size or shorter on the receiving size
+are skipped.  Files that do not yet exist on the receiving side are also
+sent, since they are considered to have 0 length.  Implies \fB\-\-inplace\fP,
+but does not conflict with \fB\-\-sparse\fP (since it is always extending a
+file's length).
+.IP 
+.IP "\fB\-\-append\-verify\fP"
+This works just like the \fB\-\-append\fP option, but
+the existing data on the receiving side is included in the full-file
+checksum verification step, which will cause a file to be resent if the
+final verification step fails (rsync uses a normal, non-appending
+\fB\-\-inplace\fP transfer for the resend).
+.IP 
+Note: prior to rsync 3.0.0, the \fB\-\-append\fP option worked like
+\fB\-\-append\-verify\fP, so if you are interacting with an older rsync (or the
+transfer is using a protocol prior to 30), specifying either append option
+will initiate an \fB\-\-append\-verify\fP transfer.
 .IP 
 .IP "\fB\-d, \-\-dirs\fP"
 Tell the sending side to include any directories that
-are encountered\&.  Unlike \fB\-\-recursive\fP, a directory\&'s contents are not copied
-unless the directory name specified is "\&." or ends with a trailing slash
-(e\&.g\&. "\&.", "dir/\&.", "dir/", etc\&.)\&.  Without this option or the
+are encountered.  Unlike \fB\-\-recursive\fP, a directory's contents are not copied
+unless the directory name specified is \(lq.\(rq or ends with a trailing slash
+(e.g. \(lq.\(rq, \(lqdir/.\(rq, \(lqdir/\(rq, etc.).  Without this option or the
 \fB\-\-recursive\fP option, rsync will skip all directories it encounters (and
-output a message to that effect for each one)\&.  If you specify both
-\fB\-\-dirs\fP and \fB\-\-recursive\fP, \fB\-\-recursive\fP takes precedence\&.
+output a message to that effect for each one).  If you specify both
+\fB\-\-dirs\fP and \fB\-\-recursive\fP, \fB\-\-recursive\fP takes precedence.
+.IP 
+This option is implied by the \fB\-\-list\-only\fP option (including an implied
+\fB\-\-list\-only\fP usage) if \fB\-\-recursive\fP wasn't specified (so that
+directories are seen in the listing).  Specify \fB\-\-no\-dirs\fP (or \fB\-\-no\-d\fP)
+if you want to override this.  This option is also implied by
+\fB\-\-files\-from\fP.
 .IP 
 .IP "\fB\-l, \-\-links\fP"
 When symlinks are encountered, recreate the
-symlink on the destination\&.
+symlink on the destination.
 .IP 
 .IP "\fB\-L, \-\-copy\-links\fP"
 When symlinks are encountered, the item that
-they point to (the referent) is copied, rather than the symlink\&.  In older
+they point to (the referent) is copied, rather than the symlink.  In older
 versions of rsync, this option also had the side-effect of telling the
-receiving side to follow symlinks, such as symlinks to directories\&.  In a
-modern rsync such as this one, you\&'ll need to specify \fB\-\-keep\-dirlinks\fP (\fB\-K\fP)
-to get this extra behavior\&.  The only exception is when sending files to
-an rsync that is too old to understand \fB\-K\fP -- in that case, the \fB\-L\fP option
-will still have the side-effect of \fB\-K\fP on that older receiving rsync\&.
+receiving side to follow symlinks, such as symlinks to directories.  In a
+modern rsync such as this one, you'll need to specify \fB\-\-keep\-dirlinks\fP (\fB\-K\fP)
+to get this extra behavior.  The only exception is when sending files to
+an rsync that is too old to understand \fB\-K\fP \(em in that case, the \fB\-L\fP option
+will still have the side-effect of \fB\-K\fP on that older receiving rsync.
 .IP 
 .IP "\fB\-\-copy\-unsafe\-links\fP"
 This tells rsync to copy the referent of
-symbolic links that point outside the copied tree\&.  Absolute symlinks
+symbolic links that point outside the copied tree.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
-source path itself when \fB\-\-relative\fP is used\&.  This option has no
-additional effect if \fB\-\-copy\-links\fP was also specified\&.
+source path itself when \fB\-\-relative\fP is used.  This option has no
+additional effect if \fB\-\-copy\-links\fP was also specified.
 .IP 
 .IP "\fB\-\-safe\-links\fP"
 This tells rsync to ignore any symbolic links
-which point outside the copied tree\&. All absolute symlinks are
-also ignored\&. Using this option in conjunction with \fB\-\-relative\fP may
-give unexpected results\&.
+which point outside the copied tree. All absolute symlinks are
+also ignored. Using this option in conjunction with \fB\-\-relative\fP may
+give unexpected results.
 .IP 
-.IP "\fB\-K, \-\-copy\-dirlinks\fP"
+.IP "\fB\-k, \-\-copy\-dirlinks\fP"
 This option causes the sending side to treat
-a symlink to a directory as though it were a real directory\&.  This is
-useful if you don\&'t want symlinks to non-directories to be affected, as
-they would be using \fB\-\-copy\-links\fP\&.
+a symlink to a directory as though it were a real directory.  This is
+useful if you don't want symlinks to non-directories to be affected, as
+they would be using \fB\-\-copy\-links\fP.
 .IP 
 Without this option, if the sending side has replaced a directory with a
 symlink to a directory, the receiving side will delete anything that is in
 the way of the new symlink, including a directory hierarchy (as long as
-\fB\-\-force\fP or \fB\-\-delete\fP is in effect)\&.
+\fB\-\-force\fP or \fB\-\-delete\fP is in effect).
 .IP 
 See also \fB\-\-keep\-dirlinks\fP for an analogous option for the receiving
-side\&.
+side.
 .IP 
 .IP "\fB\-K, \-\-keep\-dirlinks\fP"
 This option causes the receiving side to treat
 a symlink to a directory as though it were a real directory, but only if it
-matches a real directory from the sender\&.  Without this option, the
-receiver\&'s symlink would be deleted and replaced with a real directory\&.
+matches a real directory from the sender.  Without this option, the
+receiver's symlink would be deleted and replaced with a real directory.
 .IP 
-For example, suppose you transfer a directory "foo" that contains a file
-"file", but "foo" is a symlink to directory "bar" on the receiver\&.  Without
-\fB\-\-keep\-dirlinks\fP, the receiver deletes symlink "foo", recreates it as a
-directory, and receives the file into the new directory\&.  With
-\fB\-\-keep\-dirlinks\fP, the receiver keeps the symlink and "file" ends up in
-"bar"\&.
+For example, suppose you transfer a directory \(lqfoo\(rq that contains a file
+\(lqfile\(rq, but \(lqfoo\(rq is a symlink to directory \(lqbar\(rq on the receiver.  Without
+\fB\-\-keep\-dirlinks\fP, the receiver deletes symlink \(lqfoo\(rq, recreates it as a
+directory, and receives the file into the new directory.  With
+\fB\-\-keep\-dirlinks\fP, the receiver keeps the symlink and \(lqfile\(rq ends up in
+\(lqbar\(rq.
+.IP 
+One note of caution:  if you use \fB\-\-keep\-dirlinks\fP, you must trust all
+the symlinks in the copy!  If it is possible for an untrusted user to
+create their own symlink to any directory, the user could then (on a
+subsequent copy) replace the symlink with a real directory and affect the
+content of whatever directory the symlink references.  For backup copies,
+you are better off using something like a bind mount instead of a symlink
+to modify your receiving hierarchy.
 .IP 
-See also \fB\-\-copy\-dirlinks\fP for an analogous option for the sending side\&.
+See also \fB\-\-copy\-dirlinks\fP for an analogous option for the sending side.
 .IP 
 .IP "\fB\-H, \-\-hard\-links\fP"
 This tells rsync to look for hard-linked files in
 the transfer and link together the corresponding files on the receiving
-side\&.  Without this option, hard-linked files in the transfer are treated
-as though they were separate files\&.
+side.  Without this option, hard-linked files in the transfer are treated
+as though they were separate files.
 .IP 
-Note that rsync can only detect hard links if both parts of the link
-are in the list of files being sent\&.
+When you are updating a non-empty destination, this option only ensures
+that files that are hard-linked together on the source are hard-linked
+together on the destination.  It does NOT currently endeavor to break
+already existing hard links on the destination that do not exist between
+the source files.  Note, however, that if one or more extra-linked files
+have content changes, they will become unlinked when updated (assuming you
+are not using the \fB\-\-inplace\fP option).
+.IP 
+Note that rsync can only detect hard links between files that are inside
+the transfer set.  If rsync updates a file that has extra hard-link
+connections to files outside the transfer, that linkage will be broken.  If
+you are tempted to use the \fB\-\-inplace\fP option to avoid this breakage, be
+very careful that you know how your files are being updated so that you are
+certain that no unintended changes happen due to lingering hard links (and
+see the \fB\-\-inplace\fP option for more caveats).
+.IP 
+If incremental recursion is active (see \fB\-\-recursive\fP), rsync may transfer
+a missing hard-linked file before it finds that another link for that contents
+exists elsewhere in the hierarchy.  This does not affect the accuracy of
+the transfer, just its efficiency.  One way to avoid this is to disable
+incremental recursion using the \fB\-\-no\-inc\-recursive\fP option.
 .IP 
 .IP "\fB\-p, \-\-perms\fP"
 This option causes the receiving rsync to set the
-destination permissions to be the same as the source permissions\&.  (See
+destination permissions to be the same as the source permissions.  (See
 also the \fB\-\-chmod\fP option for a way to modify what rsync considers to
-be the source permissions\&.)
+be the source permissions.)
 .IP 
 When this option is \fIoff\fP, permissions are set as follows:
 .IP 
 .RS 
 .IP o 
 Existing files (including updated files) retain their existing
 permissions, though the \fB\-\-executability\fP option might change just
-the execute permission for the file\&.
+the execute permission for the file.
 .IP o 
-New files get their "normal" permission bits set to the source
-file\&'s permissions masked with the receiving end\&'s umask setting, and
+New files get their \(lqnormal\(rq permission bits set to the source
+file's permissions masked with the receiving directory's default
+permissions (either the receiving process's umask, or the permissions
+specified via the destination directory's default ACL), and
 their special permission bits disabled except in the case where a new
-directory inherits a setgid bit from its parent directory\&.
+directory inherits a setgid bit from its parent directory.
 .RE
 
 .IP 
 Thus, when \fB\-\-perms\fP and \fB\-\-executability\fP are both disabled,
-rsync\&'s behavior is the same as that of other file-copy utilities,
-such as \fBcp\fP(1) and \fBtar\fP(1)\&.
+rsync's behavior is the same as that of other file-copy utilities,
+such as \fBcp\fP(1) and \fBtar\fP(1).
 .IP 
 In summary: to give destination files (both old and new) the source
-permissions, use \fB\-\-perms\fP\&.  To give new files the destination-default
+permissions, use \fB\-\-perms\fP.  To give new files the destination-default
 permissions (while leaving existing files unchanged), make sure that the
 \fB\-\-perms\fP option is off and use \fB\-\-chmod=ugo=rwX\fP (which ensures that
-all non-masked bits get enabled)\&.  If you\&'d care to make this latter
+all non-masked bits get enabled).  If you'd care to make this latter
 behavior easier to type, you could define a popt alias for it, such as
-putting this line in the file ~/\&.popt (this defines the \fB\-s\fP option,
+putting this line in the file ~/.popt (the following defines the \fB\-Z\fP option,
 and includes \-\-no\-g to use the default group of the destination dir):
 .IP 
 .RS 
-\f(CW   rsync alias \-s \-\-no\-p \-\-no\-g \-\-chmod=ugo=rwX\fP
+\f(CW   rsync alias \-Z \-\-no\-p \-\-no\-g \-\-chmod=ugo=rwX\fP
 .RE
 
 .IP 
 You could then use this new option in a command such as this one:
 .IP 
 .RS 
-\f(CW   rsync \-asv src/ dest/\fP
+\f(CW   rsync \-avZ src/ dest/\fP
 .RE
 
 .IP 
-(Caveat: make sure that \fB\-a\fP does not follow \fB\-s\fP, or it will re-enable
-the "\-\-no\-*" options\&.)
+(Caveat: make sure that \fB\-a\fP does not follow \fB\-Z\fP, or it will re-enable
+the two \(lq\-\-no\-*\(rq options mentioned above.)
 .IP 
-The preservation of the destination\&'s setgid bit on newly-created
-directories when \fB\-\-perms\fP is off was added in rsync 2\&.6\&.7\&.  Older rsync
+The preservation of the destination's setgid bit on newly-created
+directories when \fB\-\-perms\fP is off was added in rsync 2.6.7.  Older rsync
 versions erroneously preserved the three special permission bits for
 newly-created files when \fB\-\-perms\fP was off, while overriding the
-destination\&'s setgid bit setting on a newly-created directory\&.  (Keep in
-mind that it is the version of the receiving rsync that affects this
-behavior\&.)
+destination's setgid bit setting on a newly-created directory.  Default ACL
+observance was added to the ACL patch for rsync 2.6.7, so older (or
+non-ACL-enabled) rsyncs use the umask even if default ACLs are present.
+(Keep in mind that it is the version of the receiving rsync that affects
+these behaviors.)
 .IP 
 .IP "\fB\-E, \-\-executability\fP"
 This option causes rsync to preserve the
 executability (or non-executability) of regular files when \fB\-\-perms\fP is
-not enabled\&.  A regular file is considered to be executable if at least one
-\&'x\&' is turned on in its permissions\&.  When an existing destination file\&'s
+not enabled.  A regular file is considered to be executable if at least one
+\(oqx\(cq is turned on in its permissions.  When an existing destination file's
 executability differs from that of the corresponding source file, rsync
-modifies the destination file\&'s permissions as follows:
+modifies the destination file's permissions as follows:
 .IP 
 .RS 
 .IP o 
-To make a file non-executable, rsync turns off all its \&'x\&'
-permissions\&.
+To make a file non-executable, rsync turns off all its \(oqx\(cq
+permissions.
 .IP o 
-To make a file executable, rsync turns on each \&'x\&' permission that
-has a corresponding \&'r\&' permission enabled\&.
+To make a file executable, rsync turns on each \(oqx\(cq permission that
+has a corresponding \(oqr\(cq permission enabled.
 .RE
 
 .IP 
-If \fB\-\-perms\fP is enabled, this option is ignored\&.
+If \fB\-\-perms\fP is enabled, this option is ignored.
+.IP 
+.IP "\fB\-A, \-\-acls\fP"
+This option causes rsync to update the destination
+ACLs to be the same as the source ACLs.
+The option also implies \fB\-\-perms\fP.
+.IP 
+The source and destination systems must have compatible ACL entries for this
+option to work properly.  See the \fB\-\-fake\-super\fP option for a way to backup
+and restore ACLs that are not compatible.
+.IP 
+.IP "\fB\-X, \-\-xattrs\fP"
+This option causes rsync to update the remote
+extended attributes to be the same as the local ones.
+.IP 
+For systems that support extended-attribute namespaces, a copy being done by a
+super-user copies all namespaces except system.*.  A normal user only copies
+the user.* namespace.  To be able to backup and restore non-user namespaces as
+a normal user, see the \fB\-\-fake\-super\fP option.
 .IP 
 .IP "\fB\-\-chmod\fP"
 This option tells rsync to apply one or more
-comma-separated "chmod" strings to the permission of the files in the
-transfer\&.  The resulting value is treated as though it was the permissions
+comma-separated \(lqchmod\(rq strings to the permission of the files in the
+transfer.  The resulting value is treated as though it was the permissions
 that the sending side supplied for the file, which means that this option
-can seem to have no effect on existing files if \fB\-\-perms\fP is not enabled\&.
+can seem to have no effect on existing files if \fB\-\-perms\fP is not enabled.
 .IP 
 In addition to the normal parsing rules specified in the \fBchmod\fP(1)
 manpage, you can specify an item that should only apply to a directory by
-prefixing it with a \&'D\&', or specify an item that should only apply to a
-file by prefixing it with a \&'F\&'\&.  For example:
+prefixing it with a \(oqD\(cq, or specify an item that should only apply to a
+file by prefixing it with a \(oqF\(cq.  For example:
 .IP 
 .RS 
 \-\-chmod=Dg+s,ug+w,Fo-w,+X
 .RE
 
 .IP 
 It is also legal to specify multiple \fB\-\-chmod\fP options, as each
-additional option is just appended to the list of changes to make\&.
+additional option is just appended to the list of changes to make.
 .IP 
 See the \fB\-\-perms\fP and \fB\-\-executability\fP options for how the resulting
-permission value can be applied to the files in the transfer\&.
+permission value can be applied to the files in the transfer.
 .IP 
 .IP "\fB\-o, \-\-owner\fP"
 This option causes rsync to set the owner of the
 destination file to be the same as the source file, but only if the
 receiving rsync is being run as the super-user (see also the \fB\-\-super\fP
-option to force rsync to attempt super-user activities)\&.
-Without this option, the owner is set to the invoking user on the
-receiving side\&.
+and \fB\-\-fake\-super\fP options).
+Without this option, the owner of new and/or transferred files are set to
+the invoking user on the receiving side.
 .IP 
 The preservation of ownership will associate matching names by default, but
 may fall back to using the ID number in some circumstances (see also the
-\fB\-\-numeric\-ids\fP option for a full discussion)\&.
+\fB\-\-numeric\-ids\fP option for a full discussion).
 .IP 
 .IP "\fB\-g, \-\-group\fP"
 This option causes rsync to set the group of the
-destination file to be the same as the source file\&.  If the receiving
+destination file to be the same as the source file.  If the receiving
 program is not running as the super-user (or if \fB\-\-no\-super\fP was
 specified), only groups that the invoking user on the receiving side
-is a member of will be preserved\&.
+is a member of will be preserved.
 Without this option, the group is set to the default group of the invoking
-user on the receiving side\&.
+user on the receiving side.
 .IP 
 The preservation of group information will associate matching names by
 default, but may fall back to using the ID number in some circumstances
-(see also the \fB\-\-numeric\-ids\fP option for a full discussion)\&.
+(see also the \fB\-\-numeric\-ids\fP option for a full discussion).
 .IP 
 .IP "\fB\-\-devices\fP"
 This option causes rsync to transfer character and
-block device files to the remote system to recreate these devices\&.
+block device files to the remote system to recreate these devices.
 This option has no effect if the receiving rsync is not run as the
-super-user and \fB\-\-super\fP is not specified\&.
+super-user (see also the \fB\-\-super\fP and \fB\-\-fake\-super\fP options).
 .IP 
 .IP "\fB\-\-specials\fP"
 This option causes rsync to transfer special files
-such as named sockets and fifos\&.
+such as named sockets and fifos.
 .IP 
 .IP "\fB\-D\fP"
-The \fB\-D\fP option is equivalent to \fB\-\-devices\fP \fB\-\-specials\fP\&.
+The \fB\-D\fP option is equivalent to \fB\-\-devices\fP \fB\-\-specials\fP.
 .IP 
 .IP "\fB\-t, \-\-times\fP"
 This tells rsync to transfer modification times along
-with the files and update them on the remote system\&.  Note that if this
+with the files and update them on the remote system.  Note that if this
 option is not used, the optimization that excludes files that have not been
 modified cannot be effective; in other words, a missing \fB\-t\fP or \fB\-a\fP will
 cause the next transfer to behave as if it used \fB\-I\fP, causing all files to be
 updated (though the rsync algorithm will make the update fairly efficient
-if the files haven\&'t actually changed, you\&'re much better off using \fB\-t\fP)\&.
+if the files haven't actually changed, you're much better off using \fB\-t\fP).
 .IP 
 .IP "\fB\-O, \-\-omit\-dir\-times\fP"
 This tells rsync to omit directories when
-it is preserving modification times (see \fB\-\-times\fP)\&.  If NFS is sharing
-the directories on the receiving side, it is a good idea to use \fB\-O\fP\&.
-This option is inferred if you use \fB\-\-backup\fP without \fB\-\-backup\-dir\fP\&.
+it is preserving modification times (see \fB\-\-times\fP).  If NFS is sharing
+the directories on the receiving side, it is a good idea to use \fB\-O\fP.
+This option is inferred if you use \fB\-\-backup\fP without \fB\-\-backup\-dir\fP.
 .IP 
 .IP "\fB\-\-super\fP"
 This tells the receiving side to attempt super-user
-activities even if the receiving rsync wasn\&'t run by the super-user\&.  These
+activities even if the receiving rsync wasn't run by the super-user.  These
 activities include: preserving users via the \fB\-\-owner\fP option, preserving
-all groups (not just the current user\&'s groups) via the \fB\-\-groups\fP
-option, and copying devices via the \fB\-\-devices\fP option\&.  This is useful
+all groups (not just the current user's groups) via the \fB\-\-groups\fP
+option, and copying devices via the \fB\-\-devices\fP option.  This is useful
 for systems that allow such activities without being the super-user, and
-also for ensuring that you will get errors if the receiving side isn\&'t
-being running as the super-user\&.  To turn off super-user activities, the
-super-user can use \fB\-\-no\-super\fP\&.
+also for ensuring that you will get errors if the receiving side isn't
+being running as the super-user.  To turn off super-user activities, the
+super-user can use \fB\-\-no\-super\fP.
+.IP 
+.IP "\fB\-\-fake\-super\fP"
+When this option is enabled, rsync simulates
+super-user activities by saving/restoring the privileged attributes via
+special extended attributes that are attached to each file (as needed).  This
+includes the file's owner and group (if it is not the default), the file's
+device info (device & special files are created as empty text files), and
+any permission bits that we won't allow to be set on the real file (e.g.
+the real file gets u-s,g-s,o-t for safety) or that would limit the owner's
+access (since the real super-user can always access/change a file, the
+files we create can always be accessed/changed by the creating user).
+This option also handles ACLs (if \fB\-\-acls\fP was specified) and non-user
+extended attributes (if \fB\-\-xattrs\fP was specified).
+.IP 
+This is a good way to backup data without using a super-user, and to store
+ACLs from incompatible systems.
+.IP 
+The \fB\-\-fake\-super\fP option only affects the side where the option is used.
+To affect the remote side of a remote-shell connection, specify an rsync
+path:
+.IP 
+.RS 
+\f(CW  rsync \-av \-\-rsync\-path="rsync \-\-fake\-super" /src/ host:/dest/\fP
+.RE
+
+.IP 
+Since there is only one \(lqside\(rq in a local copy, this option affects both
+the sending and receiving of files.  You'll need to specify a copy using
+\(lqlocalhost\(rq if you need to avoid this, possibly using the \(lqlsh\(rq shell
+script (from the support directory) as a substitute for an actual remote
+shell (see \fB\-\-rsh\fP).
+.IP 
+This option is overridden by both \fB\-\-super\fP and \fB\-\-no\-super\fP.
+.IP 
+See also the \(lqfake super\(rq setting in the daemon's rsyncd.conf file.
 .IP 
 .IP "\fB\-S, \-\-sparse\fP"
 Try to handle sparse files efficiently so they take
-up less space on the destination\&.  Conflicts with \fB\-\-inplace\fP because it\&'s
-not possible to overwrite data in a sparse fashion\&.
+up less space on the destination.  Conflicts with \fB\-\-inplace\fP because it's
+not possible to overwrite data in a sparse fashion.
 .IP 
-NOTE: Don\&'t use this option when the destination is a Solaris "tmpfs"
-filesystem\&. It doesn\&'t seem to handle seeks over null regions
-correctly and ends up corrupting the files\&.
+NOTE: Don't use this option when the destination is a Solaris \(lqtmpfs\(rq
+filesystem. It doesn't seem to handle seeks over null regions
+correctly and ends up corrupting the files.
 .IP 
 .IP "\fB\-n, \-\-dry\-run\fP"
-This tells rsync to not do any file transfers,
-instead it will just report the actions it would have taken\&.
+This makes rsync perform a trial run that doesn't
+make any changes (and produces mostly the same output as a real run).  It
+is most commonly used in combination with the \fB\-v, \-\-verbose\fP and/or
+\fB\-i, \-\-itemize\-changes\fP options to see what an rsync command is going
+to do before one actually runs it.
+.IP 
+The output of \fB\-\-itemize\-changes\fP is supposed to be exactly the same on a
+dry run and a subsequent real run (barring intentional trickery and system
+call failures); if it isn't, that's a bug.  Other output is the same to the
+extent practical, but may differ in some areas.  Notably, a dry run does not
+send the actual data for file transfers, so \fB\-\-progress\fP has no effect,
+the \(lqbytes sent\(rq, \(lqbytes received\(rq, \(lqliteral data\(rq, and \(lqmatched data\(rq
+statistics are too small, and the \(lqspeedup\(rq value is equivalent to a run
+where no file transfers are needed.
 .IP 
 .IP "\fB\-W, \-\-whole\-file\fP"
-With this option the incremental rsync algorithm
-is not used and the whole file is sent as-is instead\&.  The transfer may be
+With this option the delta-transfer algorithm
+is not used and the whole file is sent as-is instead.  The transfer may be
 faster if this option is used when the bandwidth between the source and
 destination machines is higher than the bandwidth to disk (especially when the
-"disk" is actually a networked filesystem)\&.  This is the default when both
-the source and destination are specified as local paths\&.
+\(lqdisk\(rq is actually a networked filesystem).  This is the default when both
+the source and destination are specified as local paths.
 .IP 
 .IP "\fB\-x, \-\-one\-file\-system\fP"
 This tells rsync to avoid crossing a
-filesystem boundary when recursing\&.  This does not limit the user\&'s ability
-to specify items to copy from multiple filesystems, just rsync\&'s recursion
+filesystem boundary when recursing.  This does not limit the user's ability
+to specify items to copy from multiple filesystems, just rsync's recursion
 through the hierarchy of each directory that the user specified, and also
-the analogous recursion on the receiving side during deletion\&.  Also keep
-in mind that rsync treats a "bind" mount to the same device as being on the
-same filesystem\&.
+the analogous recursion on the receiving side during deletion.  Also keep
+in mind that rsync treats a \(lqbind\(rq mount to the same device as being on the
+same filesystem.
 .IP 
 If this option is repeated, rsync omits all mount-point directories from
-the copy\&.  Otherwise, it includes an empty directory at each mount-point it
+the copy.  Otherwise, it includes an empty directory at each mount-point it
 encounters (using the attributes of the mounted directory because those of
-the underlying mount-point directory are inaccessible)\&.
+the underlying mount-point directory are inaccessible).
 .IP 
 If rsync has been told to collapse symlinks (via \fB\-\-copy\-links\fP or
 \fB\-\-copy\-unsafe\-links\fP), a symlink to a directory on another device is
-treated like a mount-point\&.  Symlinks to non-directories are unaffected
-by this option\&.
+treated like a mount-point.  Symlinks to non-directories are unaffected
+by this option.
 .IP 
 .IP "\fB\-\-existing, \-\-ignore\-non\-existing\fP"
 This tells rsync to skip
 creating files (including directories) that do not exist
-yet on the destination\&.  If this option is
+yet on the destination.  If this option is
 combined with the \fB\-\-ignore\-existing\fP option, no files will be updated
-(which can be useful if all you want to do is to delete extraneous files)\&.
+(which can be useful if all you want to do is delete extraneous files).
 .IP 
 .IP "\fB\-\-ignore\-existing\fP"
 This tells rsync to skip updating files that
 already exist on the destination (this does \fInot\fP ignore existing
-directores, or nothing would get done)\&.  See also \fB\-\-existing\fP\&.
+directories, or nothing would get done).  See also \fB\-\-existing\fP.
+.IP 
+This option can be useful for those doing backups using the \fB\-\-link\-dest\fP
+option when they need to continue a backup run that got interrupted.  Since
+a \fB\-\-link\-dest\fP run is copied into a new directory hierarchy (when it is
+used properly), using \fB\-\-ignore existing\fP will ensure that the
+already-handled files don't get tweaked (which avoids a change in
+permissions on the hard-linked files).  This does mean that this option
+is only looking at the existing files in the destination hierarchy itself.
 .IP 
 .IP "\fB\-\-remove\-source\-files\fP"
 This tells rsync to remove from the sending
 side the files (meaning non-directories) that are a part of the transfer
-and have been successfully duplicated on the receiving side\&.
+and have been successfully duplicated on the receiving side.
 .IP 
 .IP "\fB\-\-delete\fP"
 This tells rsync to delete extraneous files from the
-receiving side (ones that aren\&'t on the sending side), but only for the
-directories that are being synchronized\&.  You must have asked rsync to
-send the whole directory (e\&.g\&. "dir" or "dir/") without using a wildcard
-for the directory\&'s contents (e\&.g\&. "dir/*") since the wildcard is expanded
+receiving side (ones that aren't on the sending side), but only for the
+directories that are being synchronized.  You must have asked rsync to
+send the whole directory (e.g. \(lqdir\(rq or \(lqdir/\(rq) without using a wildcard
+for the directory's contents (e.g. \(lqdir/*\(rq) since the wildcard is expanded
 by the shell and rsync thus gets a request to transfer individual files, not
-the files\&' parent directory\&.  Files that are excluded from transfer are
+the files' parent directory.  Files that are excluded from transfer are
 also excluded from being deleted unless you use the \fB\-\-delete\-excluded\fP
 option or mark the rules as only matching on the sending side (see the
-include/exclude modifiers in the FILTER RULES section)\&.
+include/exclude modifiers in the FILTER RULES section).
 .IP 
-Prior to rsync 2\&.6\&.7, this option would have no effect unless \fB\-\-recursive\fP
-was in effect\&.  Beginning with 2\&.6\&.7, deletions will also occur when \fB\-\-dirs\fP
-(\fB\-d\fP) is in effect, but only for directories whose contents are being copied\&.
-.IP 
-This option can be dangerous if used incorrectly!  It is a very good idea
-to run first using the \fB\-\-dry\-run\fP option (\fB\-n\fP) to see what files would be
-deleted to make sure important files aren\&'t listed\&.
+Prior to rsync 2.6.7, this option would have no effect unless \fB\-\-recursive\fP
+was enabled.  Beginning with 2.6.7, deletions will also occur when \fB\-\-dirs\fP
+(\fB\-d\fP) is enabled, but only for directories whose contents are being copied.
+.IP 
+This option can be dangerous if used incorrectly!  It is a very good idea to
+first try a run using the \fB\-\-dry\-run\fP option (\fB\-n\fP) to see what files are
+going to be deleted.
 .IP 
 If the sending side detects any I/O errors, then the deletion of any
-files at the destination will be automatically disabled\&. This is to
+files at the destination will be automatically disabled. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
-destination\&.  You can override this with the \fB\-\-ignore\-errors\fP option\&.
+destination.  You can override this with the \fB\-\-ignore\-errors\fP option.
 .IP 
 The \fB\-\-delete\fP option may be combined with one of the \-\-delete\-WHEN options
-without conflict, as well as \fB\-\-delete\-excluded\fP\&.  However, if none of the
-\-\-delete\-WHEN options are specified, rsync will currently choose the
-\fB\-\-delete\-before\fP algorithm\&.  A future version may change this to choose the
-\fB\-\-delete\-during\fP algorithm\&.  See also \fB\-\-delete\-after\fP\&.
+without conflict, as well as \fB\-\-delete\-excluded\fP.  However, if none of the
+\-\-delete\-WHEN options are specified, rsync will choose the
+\fB\-\-delete\-during\fP algorithm when talking to an rsync 3.0.0 or newer, and
+the \fB\-\-delete\-before\fP algorithm when talking to an older rsync.  See also
+\fB\-\-delete\-delay\fP and \fB\-\-delete\-after\fP.
 .IP 
 .IP "\fB\-\-delete\-before\fP"
 Request that the file-deletions on the receiving
-side be done before the transfer starts\&.  This is the default if \fB\-\-delete\fP
-or \fB\-\-delete\-excluded\fP is specified without one of the \-\-delete\-WHEN options\&.
-See \fB\-\-delete\fP (which is implied) for more details on file-deletion\&.
+side be done before the transfer starts.
+See \fB\-\-delete\fP (which is implied) for more details on file-deletion.
 .IP 
 Deleting before the transfer is helpful if the filesystem is tight for space
-and removing extraneous files would help to make the transfer possible\&.
+and removing extraneous files would help to make the transfer possible.
 However, it does introduce a delay before the start of the transfer,
 and this delay might cause the transfer to timeout (if \fB\-\-timeout\fP was
-specified)\&.
+specified).  It also forces rsync to use the old, non-incremental recursion
+algorithm that requires rsync to scan all the files in the transfer into
+memory at once (see \fB\-\-recursive\fP).
 .IP 
 .IP "\fB\-\-delete\-during, \-\-del\fP"
 Request that the file-deletions on the
-receiving side be done incrementally as the transfer happens\&.  This is
+receiving side be done incrementally as the transfer happens.  This is
 a faster method than choosing the before- or after-transfer algorithm,
-but it is only supported beginning with rsync version 2\&.6\&.4\&.
-See \fB\-\-delete\fP (which is implied) for more details on file-deletion\&.
+but it is only supported beginning with rsync version 2.6.4.
+See \fB\-\-delete\fP (which is implied) for more details on file-deletion.
+.IP 
+.IP "\fB\-\-delete\-delay\fP"
+Request that the file-deletions on the receiving
+side be computed during the transfer, and then removed after the transfer
+completes.  If the number of removed files overflows an internal buffer, a
+temporary file will be created on the receiving side to hold the names (it
+is removed while open, so you shouldn't see it during the transfer).  If
+the creation of the temporary file fails, rsync will try to fall back to
+using \fB\-\-delete\-after\fP (which it cannot do if \fB\-\-recursive\fP is doing an
+incremental scan).
 .IP 
 .IP "\fB\-\-delete\-after\fP"
 Request that the file-deletions on the receiving
-side be done after the transfer has completed\&.  This is useful if you
+side be done after the transfer has completed.  This is useful if you
 are sending new per-directory merge files as a part of the transfer and
 you want their exclusions to take effect for the delete phase of the
-current transfer\&.
-See \fB\-\-delete\fP (which is implied) for more details on file-deletion\&.
+current transfer.  It also forces rsync to use the old, non-incremental
+recursion algorithm that requires rsync to scan all the files in the
+transfer into memory at once (see \fB\-\-recursive\fP).
+See \fB\-\-delete\fP (which is implied) for more details on file-deletion.
 .IP 
 .IP "\fB\-\-delete\-excluded\fP"
 In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
-delete any files on the receiving side that are excluded (see \fB\-\-exclude\fP)\&.
+delete any files on the receiving side that are excluded (see \fB\-\-exclude\fP).
 See the FILTER RULES section for a way to make individual exclusions behave
 this way on the receiver, and for a way to protect files from
-\fB\-\-delete\-excluded\fP\&.
-See \fB\-\-delete\fP (which is implied) for more details on file-deletion\&.
+\fB\-\-delete\-excluded\fP.
+See \fB\-\-delete\fP (which is implied) for more details on file-deletion.
 .IP 
 .IP "\fB\-\-ignore\-errors\fP"
 Tells \fB\-\-delete\fP to go ahead and delete files
-even when there are I/O errors\&.
+even when there are I/O errors.
 .IP 
 .IP "\fB\-\-force\fP"
 This option tells rsync to delete a non-empty directory
-when it is to be replaced by a non-directory\&.  This is only relevant if
-deletions are not active (see \fB\-\-delete\fP for details)\&.
+when it is to be replaced by a non-directory.  This is only relevant if
+deletions are not active (see \fB\-\-delete\fP for details).
 .IP 
 Note for older rsync versions: \fB\-\-force\fP used to still be required when
 using \fB\-\-delete\-after\fP, and it used to be non-functional unless the
-\fB\-\-recursive\fP option was also enabled\&.
+\fB\-\-recursive\fP option was also enabled.
 .IP 
 .IP "\fB\-\-max\-delete=NUM\fP"
 This tells rsync not to delete more than NUM
-files or directories (NUM must be non-zero)\&.
-This is useful when mirroring very large trees to prevent disasters\&.
+files or directories.  If that limit is exceeded, a warning is output
+and rsync exits with an error code of 25 (new for 3.0.0).
+.IP 
+Also new for version 3.0.0, you may specify \fB\-\-max\-delete=0\fP to be warned
+about any extraneous files in the destination without removing any of them.
+Older clients interpreted this as \(lqunlimited\(rq, so if you don't know what
+version the client is, you can use the less obvious \fB\-\-max\-delete=\-1\fP as
+a backward-compatible way to specify that no deletions be allowed (though
+older versions didn't warn when the limit was exceeded).
 .IP 
 .IP "\fB\-\-max\-size=SIZE\fP"
 This tells rsync to avoid transferring any
-file that is larger than the specified SIZE\&. The SIZE value can be
+file that is larger than the specified SIZE. The SIZE value can be
 suffixed with a string to indicate a size multiplier, and
-may be a fractional value (e\&.g\&. "\fB\-\-max\-size=1\&.5m\fP")\&.
+may be a fractional value (e.g. \(lq\fB\-\-max\-size=1.5m\fP\(rq).
 .IP 
-The suffixes are as follows: "K" (or "KiB") is a kibibyte (1024),
-"M" (or "MiB") is a mebibyte (1024*1024), and "G" (or "GiB") is a
-gibibyte (1024*1024*1024)\&.
-If you want the multiplier to be 1000 instead of 1024, use "KB",
-"MB", or "GB"\&.  (Note: lower-case is also accepted for all values\&.)
-Finally, if the suffix ends in either "+1" or "\-1", the value will
-be offset by one byte in the indicated direction\&.
+The suffixes are as follows: \(lqK\(rq (or \(lqKiB\(rq) is a kibibyte (1024),
+\(lqM\(rq (or \(lqMiB\(rq) is a mebibyte (1024*1024), and \(lqG\(rq (or \(lqGiB\(rq) is a
+gibibyte (1024*1024*1024).
+If you want the multiplier to be 1000 instead of 1024, use \(lqKB\(rq,
+\(lqMB\(rq, or \(lqGB\(rq.  (Note: lower-case is also accepted for all values.)
+Finally, if the suffix ends in either \(lq+1\(rq or \(lq\-1\(rq, the value will
+be offset by one byte in the indicated direction.
 .IP 
-Examples: \-\-max\-size=1\&.5mb\-1 is 1499999 bytes, and \-\-max\-size=2g+1 is
-2147483649 bytes\&.
+Examples: \-\-max\-size=1.5mb\-1 is 1499999 bytes, and \-\-max\-size=2g+1 is
+2147483649 bytes.
 .IP 
 .IP "\fB\-\-min\-size=SIZE\fP"
 This tells rsync to avoid transferring any
 file that is smaller than the specified SIZE, which can help in not
-transferring small, junk files\&.
-See the \fB\-\-max\-size\fP option for a description of SIZE\&.
+transferring small, junk files.
+See the \fB\-\-max\-size\fP option for a description of SIZE.
 .IP 
 .IP "\fB\-B, \-\-block\-size=BLOCKSIZE\fP"
 This forces the block size used in
-the rsync algorithm to a fixed value\&.  It is normally selected based on
-the size of each file being updated\&.  See the technical report for details\&.
+the rsync algorithm to a fixed value.  It is normally selected based on
+the size of each file being updated.  See the technical report for details.
 .IP 
 .IP "\fB\-e, \-\-rsh=COMMAND\fP"
 This option allows you to choose an alternative
 remote shell program to use for communication between the local and
-remote copies of rsync\&. Typically, rsync is configured to use ssh by
-default, but you may prefer to use rsh on a local network\&.
+remote copies of rsync. Typically, rsync is configured to use ssh by
+default, but you may prefer to use rsh on a local network.
 .IP 
 If this option is used with \fB[user@]host::module/path\fP, then the
 remote shell \fICOMMAND\fP will be used to run an rsync daemon on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
-running rsync daemon on the remote host\&.  See the section "USING
-RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION" above\&.
+running rsync daemon on the remote host.  See the section \(lqUSING
+RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION\(rq above.
 .IP 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
-presented to rsync as a single argument\&.  You must use spaces (not tabs
+presented to rsync as a single argument.  You must use spaces (not tabs
 or other whitespace) to separate the command and args from each other,
 and you can use single- and/or double-quotes to preserve spaces in an
-argument (but not backslashes)\&.  Note that doubling a single-quote
+argument (but not backslashes).  Note that doubling a single-quote
 inside a single-quoted string gives you a single-quote; likewise for
 double-quotes (though you need to pay attention to which quotes your
-shell is parsing and which quotes rsync is parsing)\&.  Some examples:
+shell is parsing and which quotes rsync is parsing).  Some examples:
 .IP 
 .RS 
-\f(CW    \-e \&'ssh \-p 2234\&'\fP
+\f(CW    \-e 'ssh \-p 2234'\fP
 .br 
-\f(CW    \-e \&'ssh \-o "ProxyCommand nohup ssh firewall nc \-w1 %h %p"\&'\fP
+\f(CW    \-e 'ssh \-o "ProxyCommand nohup ssh firewall nc \-w1 %h %p"'\fP
 .br 
 .RE
 
 .IP 
 (Note that ssh users can alternately customize site-specific connect
-options in their \&.ssh/config file\&.)
+options in their .ssh/config file.)
 .IP 
 You can also choose the remote shell program using the RSYNC_RSH
-environment variable, which accepts the same range of values as \fB\-e\fP\&.
+environment variable, which accepts the same range of values as \fB\-e\fP.
 .IP 
-See also the \fB\-\-blocking\-io\fP option which is affected by this option\&.
+See also the \fB\-\-blocking\-io\fP option which is affected by this option.
 .IP 
 .IP "\fB\-\-rsync\-path=PROGRAM\fP"
 Use this to specify what program is to be run
-on the remote machine to start-up rsync\&.  Often used when rsync is not in
-the default remote-shell\&'s path (e\&.g\&. \-\-rsync\-path=/usr/local/bin/rsync)\&.
+on the remote machine to start-up rsync.  Often used when rsync is not in
+the default remote-shell's path (e.g. \-\-rsync\-path=/usr/local/bin/rsync).
 Note that PROGRAM is run with the help of a shell, so it can be any
-program, script, or command sequence you\&'d care to run, so long as it does
+program, script, or command sequence you'd care to run, so long as it does
 not corrupt the standard-in & standard-out that rsync is using to
-communicate\&.
+communicate.
 .IP 
 One tricky example is to set a different default directory on the remote
-machine for use with the \fB\-\-relative\fP option\&.  For instance:
+machine for use with the \fB\-\-relative\fP option.  For instance:
 .IP 
 .RS 
-\f(CW    rsync \-avR \-\-rsync\-path="cd /a/b && rsync" hst:c/d /e/\fP
+\f(CW    rsync \-avR \-\-rsync\-path="cd /a/b && rsync" host:c/d /e/\fP
 .RE
 
 .IP 
 .IP "\fB\-C, \-\-cvs\-exclude\fP"
 This is a useful shorthand for excluding a
-broad range of files that you often don\&'t want to transfer between
-systems\&. It uses the same algorithm that CVS uses to determine if
-a file should be ignored\&.
+broad range of files that you often don't want to transfer between
+systems. It uses a similar algorithm to CVS to determine if
+a file should be ignored.
 .IP 
-The exclude list is initialized to:
+The exclude list is initialized to exclude the following items (these
+initial items are marked as perishable \(em see the FILTER RULES section):
 .IP 
 .RS 
 .RS 
-\f(CWRCS SCCS CVS CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
-\&.nse_depinfo *~ #* \&.#* ,* _$* *$ *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej
-\&.del\-* *\&.a *\&.olb *\&.o *\&.obj *\&.so *\&.exe *\&.Z *\&.elc *\&.ln core \&.svn/\fP
+\f(CWRCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS .make.state
+\&.nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig *.rej .del\-*
+*.a *.olb *.o *.obj *.so *.exe *.Z *.elc *.ln core .svn/ .git/ .bzr/\fP
 .RE
 .RE
 
 .IP 
-then files listed in a $HOME/\&.cvsignore are added to the list and any
+then, files listed in a $HOME/.cvsignore are added to the list and any
 files listed in the CVSIGNORE environment variable (all cvsignore names
-are delimited by whitespace)\&.
+are delimited by whitespace).
 .IP 
 Finally, any file is ignored if it is in the same directory as a
-\&.cvsignore file and matches one of the patterns listed therein\&.  Unlike
-rsync\&'s filter/exclude files, these patterns are split on whitespace\&.
-See the \fBcvs\fP(1) manual for more information\&.
+\&.cvsignore file and matches one of the patterns listed therein.  Unlike
+rsync's filter/exclude files, these patterns are split on whitespace.
+See the \fBcvs\fP(1) manual for more information.
 .IP 
-If you\&'re combining \fB\-C\fP with your own \fB\-\-filter\fP rules, you should
+If you're combining \fB\-C\fP with your own \fB\-\-filter\fP rules, you should
 note that these CVS excludes are appended at the end of your own rules,
-regardless of where the \fB\-C\fP was placed on the command-line\&.  This makes them
-a lower priority than any rules you specified explicitly\&.  If you want to
+regardless of where the \fB\-C\fP was placed on the command-line.  This makes them
+a lower priority than any rules you specified explicitly.  If you want to
 control where these CVS excludes get inserted into your filter rules, you
 should omit the \fB\-C\fP as a command-line option and use a combination of
 \fB\-\-filter=:C\fP and \fB\-\-filter=\-C\fP (either on your command-line or by
-putting the ":C" and "\-C" rules into a filter file with your other rules)\&.
-The first option turns on the per-directory scanning for the \&.cvsignore
-file\&.  The second option does a one-time import of the CVS excludes
-mentioned above\&.
+putting the \(lq:C\(rq and \(lq\-C\(rq rules into a filter file with your other rules).
+The first option turns on the per-directory scanning for the .cvsignore
+file.  The second option does a one-time import of the CVS excludes
+mentioned above.
 .IP 
 .IP "\fB\-f, \-\-filter=RULE\fP"
 This option allows you to add rules to selectively
-exclude certain files from the list of files to be transferred\&. This is
-most useful in combination with a recursive transfer\&.
+exclude certain files from the list of files to be transferred. This is
+most useful in combination with a recursive transfer.
 .IP 
 You may use as many \fB\-\-filter\fP options on the command line as you like
-to build up the list of files to exclude\&.
+to build up the list of files to exclude.  If the filter contains whitespace,
+be sure to quote it so that the shell gives the rule to rsync as a single
+argument.  The text below also mentions that you can use an underscore to
+replace the space that separates a rule from its arg.
 .IP 
-See the FILTER RULES section for detailed information on this option\&.
+See the FILTER RULES section for detailed information on this option.
 .IP 
 .IP "\fB\-F\fP"
 The \fB\-F\fP option is a shorthand for adding two \fB\-\-filter\fP rules to
-your command\&.  The first time it is used is a shorthand for this rule:
+your command.  The first time it is used is a shorthand for this rule:
 .IP 
 .RS 
-\f(CW   \-\-filter=\&'dir\-merge /\&.rsync\-filter\&'\fP
+\f(CW   \-\-filter='dir\-merge /.rsync\-filter'\fP
 .RE
 
 .IP 
-This tells rsync to look for per-directory \&.rsync\-filter files that have
+This tells rsync to look for per-directory .rsync\-filter files that have
 been sprinkled through the hierarchy and use their rules to filter the
-files in the transfer\&.  If \fB\-F\fP is repeated, it is a shorthand for this
+files in the transfer.  If \fB\-F\fP is repeated, it is a shorthand for this
 rule:
 .IP 
 .RS 
-\f(CW   \-\-filter=\&'exclude \&.rsync\-filter\&'\fP
+\f(CW   \-\-filter='exclude .rsync\-filter'\fP
 .RE
 
 .IP 
-This filters out the \&.rsync\-filter files themselves from the transfer\&.
+This filters out the .rsync\-filter files themselves from the transfer.
 .IP 
 See the FILTER RULES section for detailed information on how these options
-work\&.
+work.
 .IP 
 .IP "\fB\-\-exclude=PATTERN\fP"
 This option is a simplified form of the
 \fB\-\-filter\fP option that defaults to an exclude rule and does not allow
-the full rule-parsing syntax of normal filter rules\&.
+the full rule-parsing syntax of normal filter rules.
 .IP 
-See the FILTER RULES section for detailed information on this option\&.
+See the FILTER RULES section for detailed information on this option.
 .IP 
 .IP "\fB\-\-exclude\-from=FILE\fP"
 This option is related to the \fB\-\-exclude\fP
-option, but it specifies a FILE that contains exclude patterns (one per line)\&.
-Blank lines in the file and lines starting with \&';\&' or \&'#\&' are ignored\&.
-If \fIFILE\fP is \fB\-\fP, the list will be read from standard input\&.
+option, but it specifies a FILE that contains exclude patterns (one per line).
+Blank lines in the file and lines starting with \(oq;\(cq or \(oq#\(cq are ignored.
+If \fIFILE\fP is \fB\-\fP, the list will be read from standard input.
 .IP 
 .IP "\fB\-\-include=PATTERN\fP"
 This option is a simplified form of the
 \fB\-\-filter\fP option that defaults to an include rule and does not allow
-the full rule-parsing syntax of normal filter rules\&.
+the full rule-parsing syntax of normal filter rules.
 .IP 
-See the FILTER RULES section for detailed information on this option\&.
+See the FILTER RULES section for detailed information on this option.
 .IP 
 .IP "\fB\-\-include\-from=FILE\fP"
 This option is related to the \fB\-\-include\fP
-option, but it specifies a FILE that contains include patterns (one per line)\&.
-Blank lines in the file and lines starting with \&';\&' or \&'#\&' are ignored\&.
-If \fIFILE\fP is \fB\-\fP, the list will be read from standard input\&.
+option, but it specifies a FILE that contains include patterns (one per line).
+Blank lines in the file and lines starting with \(oq;\(cq or \(oq#\(cq are ignored.
+If \fIFILE\fP is \fB\-\fP, the list will be read from standard input.
 .IP 
 .IP "\fB\-\-files\-from=FILE\fP"
 Using this option allows you to specify the
 exact list of files to transfer (as read from the specified FILE or \fB\-\fP
-for standard input)\&.  It also tweaks the default behavior of rsync to make
+for standard input).  It also tweaks the default behavior of rsync to make
 transferring just the specified files and directories easier:
 .IP 
 .RS 
 .IP o 
 The \fB\-\-relative\fP (\fB\-R\fP) option is implied, which preserves the path
 information that is specified for each item in the file (use
-\fB\-\-no\-relative\fP or \fB\-\-no\-R\fP if you want to turn that off)\&.
+\fB\-\-no\-relative\fP or \fB\-\-no\-R\fP if you want to turn that off).
 .IP o 
 The \fB\-\-dirs\fP (\fB\-d\fP) option is implied, which will create directories
 specified in the list on the destination rather than noisily skipping
-them (use \fB\-\-no\-dirs\fP or \fB\-\-no\-d\fP if you want to turn that off)\&.
+them (use \fB\-\-no\-dirs\fP or \fB\-\-no\-d\fP if you want to turn that off).
 .IP o 
-The \fB\-\-archive\fP (\fB\-a\fP) option\&'s behavior does not imply \fB\-\-recursive\fP
-(\fB\-r\fP), so specify it explicitly, if you want it\&.
+The \fB\-\-archive\fP (\fB\-a\fP) option's behavior does not imply \fB\-\-recursive\fP
+(\fB\-r\fP), so specify it explicitly, if you want it.
 .IP o 
 These side-effects change the default state of rsync, so the position
 of the \fB\-\-files\-from\fP option on the command-line has no bearing on how
-other options are parsed (e\&.g\&. \fB\-a\fP works the same before or after
-\fB\-\-files\-from\fP, as does \fB\-\-no\-R\fP and all other options)\&.
+other options are parsed (e.g. \fB\-a\fP works the same before or after
+\fB\-\-files\-from\fP, as does \fB\-\-no\-R\fP and all other options).
 .RE
 
 .IP 
-The file names that are read from the FILE are all relative to the
-source dir -- any leading slashes are removed and no "\&.\&." references are
-allowed to go higher than the source dir\&.  For example, take this
+The filenames that are read from the FILE are all relative to the
+source dir \(em any leading slashes are removed and no \(lq..\(rq references are
+allowed to go higher than the source dir.  For example, take this
 command:
 .IP 
 .RS 
 \f(CW   rsync \-a \-\-files\-from=/tmp/foo /usr remote:/backup\fP
 .RE
 
 .IP 
-If /tmp/foo contains the string "bin" (or even "/bin"), the /usr/bin
-directory will be created as /backup/bin on the remote host\&.  If it
-contains "bin/" (note the trailing slash), the immediate contents of
+If /tmp/foo contains the string \(lqbin\(rq (or even \(lq/bin\(rq), the /usr/bin
+directory will be created as /backup/bin on the remote host.  If it
+contains \(lqbin/\(rq (note the trailing slash), the immediate contents of
 the directory would also be sent (without needing to be explicitly
-mentioned in the file -- this began in version 2\&.6\&.4)\&.  In both cases,
-if the \fB\-r\fP option was enabled, that dir\&'s entire hierarchy would
+mentioned in the file \(em this began in version 2.6.4).  In both cases,
+if the \fB\-r\fP option was enabled, that dir's entire hierarchy would
 also be transferred (keep in mind that \fB\-r\fP needs to be specified
-explicitly with \fB\-\-files\-from\fP, since it is not implied by \fB\-a\fP)\&.
+explicitly with \fB\-\-files\-from\fP, since it is not implied by \fB\-a\fP).
 Also note
 that the effect of the (enabled by default) \fB\-\-relative\fP option is to
-duplicate only the path info that is read from the file -- it does not
-force the duplication of the source-spec path (/usr in this case)\&.
+duplicate only the path info that is read from the file \(em it does not
+force the duplication of the source-spec path (/usr in this case).
 .IP 
 In addition, the \fB\-\-files\-from\fP file can be read from the remote host
-instead of the local host if you specify a "host:" in front of the file
-(the host must match one end of the transfer)\&.  As a short-cut, you can
-specify just a prefix of ":" to mean "use the remote end of the
-transfer"\&.  For example:
+instead of the local host if you specify a \(lqhost:\(rq in front of the file
+(the host must match one end of the transfer).  As a short-cut, you can
+specify just a prefix of \(lq:\(rq to mean \(lquse the remote end of the
+transfer\(rq.  For example:
 .IP 
 .RS 
 \f(CW   rsync \-a \-\-files\-from=:/path/file\-list src:/ /tmp/copy\fP
 .RE
 
 .IP 
 This would copy all the files specified in the /path/file-list file that
-was located on the remote "src" host\&.
+was located on the remote \(lqsrc\(rq host.
 .IP 
 .IP "\fB\-0, \-\-from0\fP"
 This tells rsync that the rules/filenames it reads from a
-file are terminated by a null (\&'\e0\&') character, not a NL, CR, or CR+LF\&.
+file are terminated by a null ('\e0') character, not a NL, CR, or CR+LF.
 This affects \fB\-\-exclude\-from\fP, \fB\-\-include\-from\fP, \fB\-\-files\-from\fP, and any
-merged files specified in a \fB\-\-filter\fP rule\&.
-It does not affect \fB\-\-cvs\-exclude\fP (since all names read from a \&.cvsignore
-file are split on whitespace)\&.
+merged files specified in a \fB\-\-filter\fP rule.
+It does not affect \fB\-\-cvs\-exclude\fP (since all names read from a .cvsignore
+file are split on whitespace).
+.IP 
+If the \fB\-\-iconv\fP and \fB\-\-protect\-args\fP options are specified and the
+\fB\-\-files\-from\fP filenames are being sent from one host to another, the
+filenames will be translated from the sending host's charset to the
+receiving host's charset.
+.IP 
+.IP "\fB\-s, \-\-protect\-args\fP"
+This option sends all filenames and some options to
+the remote rsync without allowing the remote shell to interpret them.  This
+means that spaces are not split in names, and any non-wildcard special
+characters are not translated (such as ~, $, ;, &, etc.).  Wildcards are
+expanded on the remote host by rsync (instead of the shell doing it).
+.IP 
+If you use this option with \fB\-\-iconv\fP, the args will also be translated
+from the local to the remote character-set.  The translation happens before
+wild-cards are expanded.  See also the \fB\-\-files\-from\fP option.
 .IP 
 .IP "\fB\-T, \-\-temp\-dir=DIR\fP"
 This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files transferred
-on the receiving side\&.  The default behavior is to create each temporary
-file in the same directory as the associated destination file\&.
+on the receiving side.  The default behavior is to create each temporary
+file in the same directory as the associated destination file.
 .IP 
 This option is most often used when the receiving disk partition does not
-have enough free space to hold a copy of the largest file in the transfer\&.
-In this case (i\&.e\&. when the scratch directory in on a different disk
+have enough free space to hold a copy of the largest file in the transfer.
+In this case (i.e. when the scratch directory is on a different disk
 partition), rsync will not be able to rename each received temporary file
 over the top of the associated destination file, but instead must copy it
-into place\&.  Rsync does this by copying the file over the top of the
+into place.  Rsync does this by copying the file over the top of the
 destination file, which means that the destination file will contain
-truncated data during this copy\&.  If this were not done this way (even if
+truncated data during this copy.  If this were not done this way (even if
 the destination file were first removed, the data locally copied to a
 temporary file in the destination directory, and then renamed into place)
 it would be possible for the old file to continue taking up disk space (if
 someone had it open), and thus there might not be enough room to fit the
-new version on the disk at the same time\&.
+new version on the disk at the same time.
 .IP 
 If you are using this option for reasons other than a shortage of disk
 space, you may wish to combine it with the \fB\-\-delay\-updates\fP option,
 which will ensure that all copied files get put into subdirectories in the
-destination hierarchy, awaiting the end of the transfer\&.  If you don\&'t
+destination hierarchy, awaiting the end of the transfer.  If you don't
 have enough room to duplicate all the arriving files on the destination
-partition, another way to tell rsync that you aren\&'t overly concerned
+partition, another way to tell rsync that you aren't overly concerned
 about disk space is to use the \fB\-\-partial\-dir\fP option with a relative
 path; because this tells rsync that it is OK to stash off a copy of a
 single file in a subdir in the destination hierarchy, rsync will use the
 partial-dir as a staging area to bring over the copied file, and then
-rename it into place from there\&. (Specifying a \fB\-\-partial\-dir\fP with
-an absolute path does not have this side-effect\&.)
+rename it into place from there. (Specifying a \fB\-\-partial\-dir\fP with
+an absolute path does not have this side-effect.)
 .IP 
 .IP "\fB\-y, \-\-fuzzy\fP"
 This option tells rsync that it should look for a
-basis file for any destination file that is missing\&.  The current algorithm
+basis file for any destination file that is missing.  The current algorithm
 looks in the same directory as the destination file for either a file that
-has an identical size and modified-time, or a similarly-named file\&.  If
-found, rsync uses the fuzzy basis file to try to speed up the transfer\&.
+has an identical size and modified-time, or a similarly-named file.  If
+found, rsync uses the fuzzy basis file to try to speed up the transfer.
 .IP 
 Note that the use of the \fB\-\-delete\fP option might get rid of any potential
 fuzzy-match files, so either use \fB\-\-delete\-after\fP or specify some
-filename exclusions if you need to prevent this\&.
+filename exclusions if you need to prevent this.
 .IP 
 .IP "\fB\-\-compare\-dest=DIR\fP"
 This option instructs rsync to use \fIDIR\fP on
 the destination machine as an additional hierarchy to compare destination
 files against doing transfers (if the files are missing in the destination
-directory)\&.  If a file is found in \fIDIR\fP that is identical to the
-sender\&'s file, the file will NOT be transferred to the destination
-directory\&.  This is useful for creating a sparse backup of just files that
-have changed from an earlier backup\&.
+directory).  If a file is found in \fIDIR\fP that is identical to the
+sender's file, the file will NOT be transferred to the destination
+directory.  This is useful for creating a sparse backup of just files that
+have changed from an earlier backup.
 .IP 
-Beginning in version 2\&.6\&.4, multiple \fB\-\-compare\-dest\fP directories may be
+Beginning in version 2.6.4, multiple \fB\-\-compare\-dest\fP directories may be
 provided, which will cause rsync to search the list in the order specified
-for an exact match\&.
+for an exact match.
 If a match is found that differs only in attributes, a local copy is made
-and the attributes updated\&.
+and the attributes updated.
 If a match is not found, a basis file from one of the \fIDIR\fPs will be
-selected to try to speed up the transfer\&.
+selected to try to speed up the transfer.
 .IP 
-If \fIDIR\fP is a relative path, it is relative to the destination directory\&.
-See also \fB\-\-copy\-dest\fP and \fB\-\-link\-dest\fP\&.
+If \fIDIR\fP is a relative path, it is relative to the destination directory.
+See also \fB\-\-copy\-dest\fP and \fB\-\-link\-dest\fP.
 .IP 
 .IP "\fB\-\-copy\-dest=DIR\fP"
 This option behaves like \fB\-\-compare\-dest\fP, but
 rsync will also copy unchanged files found in \fIDIR\fP to the destination
-directory using a local copy\&.
+directory using a local copy.
 This is useful for doing transfers to a new destination while leaving
 existing files intact, and then doing a flash-cutover when all files have
-been successfully transferred\&.
+been successfully transferred.
 .IP 
 Multiple \fB\-\-copy\-dest\fP directories may be provided, which will cause
-rsync to search the list in the order specified for an unchanged file\&.
+rsync to search the list in the order specified for an unchanged file.
 If a match is not found, a basis file from one of the \fIDIR\fPs will be
-selected to try to speed up the transfer\&.
+selected to try to speed up the transfer.
 .IP 
-If \fIDIR\fP is a relative path, it is relative to the destination directory\&.
-See also \fB\-\-compare\-dest\fP and \fB\-\-link\-dest\fP\&.
+If \fIDIR\fP is a relative path, it is relative to the destination directory.
+See also \fB\-\-compare\-dest\fP and \fB\-\-link\-dest\fP.
 .IP 
 .IP "\fB\-\-link\-dest=DIR\fP"
 This option behaves like \fB\-\-copy\-dest\fP, but
-unchanged files are hard linked from \fIDIR\fP to the destination directory\&.
-The files must be identical in all preserved attributes (e\&.g\&. permissions,
-possibly ownership) in order for the files to be linked together\&.
+unchanged files are hard linked from \fIDIR\fP to the destination directory.
+The files must be identical in all preserved attributes (e.g. permissions,
+possibly ownership) in order for the files to be linked together.
 An example:
 .IP 
 .RS 
 \f(CW  rsync \-av \-\-link\-dest=$PWD/prior_dir host:src_dir/ new_dir/\fP
 .RE
 
 .IP 
-Beginning in version 2\&.6\&.4, multiple \fB\-\-link\-dest\fP directories may be
+Beginning in version 2.6.4, multiple \fB\-\-link\-dest\fP directories may be
 provided, which will cause rsync to search the list in the order specified
-for an exact match\&.
+for an exact match.
 If a match is found that differs only in attributes, a local copy is made
-and the attributes updated\&.
+and the attributes updated.
 If a match is not found, a basis file from one of the \fIDIR\fPs will be
-selected to try to speed up the transfer\&.
+selected to try to speed up the transfer.
+.IP 
+This option works best when copying into an empty destination hierarchy, as
+rsync treats existing files as definitive (so it never looks in the link-dest
+dirs when a destination file already exists), and as malleable (so it might
+change the attributes of a destination file, which affects all the hard-linked
+versions).
 .IP 
 Note that if you combine this option with \fB\-\-ignore\-times\fP, rsync will not
 link any files together because it only links identical files together as a
 substitute for transferring the file, never as an additional check after the
-file is updated\&.
+file is updated.
 .IP 
-If \fIDIR\fP is a relative path, it is relative to the destination directory\&.
-See also \fB\-\-compare\-dest\fP and \fB\-\-copy\-dest\fP\&.
+If \fIDIR\fP is a relative path, it is relative to the destination directory.
+See also \fB\-\-compare\-dest\fP and \fB\-\-copy\-dest\fP.
 .IP 
-Note that rsync versions prior to 2\&.6\&.1 had a bug that could prevent
+Note that rsync versions prior to 2.6.1 had a bug that could prevent
 \fB\-\-link\-dest\fP from working properly for a non-super-user when \fB\-o\fP was
-specified (or implied by \fB\-a\fP)\&.  You can work-around this bug by avoiding
-the \fB\-o\fP option when sending to an old rsync\&.
+specified (or implied by \fB\-a\fP).  You can work-around this bug by avoiding
+the \fB\-o\fP option when sending to an old rsync.
 .IP 
 .IP "\fB\-z, \-\-compress\fP"
 With this option, rsync compresses the file data
 as it is sent to the destination machine, which reduces the amount of data
-being transmitted -- something that is useful over a slow connection\&.
+being transmitted \(em something that is useful over a slow connection.
 .IP 
 Note that this option typically achieves better compression ratios than can
 be achieved by using a compressing remote shell or a compressing transport
 because it takes advantage of the implicit information in the matching data
-blocks that are not explicitly sent over the connection\&.
+blocks that are not explicitly sent over the connection.
+.IP 
+See the \fB\-\-skip\-compress\fP option for the default list of file suffixes
+that will not be compressed.
 .IP 
 .IP "\fB\-\-compress\-level=NUM\fP"
 Explicitly set the compression level to use
-(see \fB\-\-compress\fP) instead of letting it default\&.  If NUM is non-zero,
-the \fB\-\-compress\fP option is implied\&.
+(see \fB\-\-compress\fP) instead of letting it default.  If NUM is non-zero,
+the \fB\-\-compress\fP option is implied.
+.IP 
+.IP "\fB\-\-skip\-compress=LIST\fP"
+Override the list of file suffixes that will
+not be compressed.  The \fBLIST\fP should be one or more file suffixes
+(without the dot) separated by slashes (/).
+.IP 
+You may specify an empty string to indicate that no file should be skipped.
+.IP 
+Simple character-class matching is supported: each must consist of a list
+of letters inside the square brackets (e.g. no special classes, such as
+\(lq[:alpha:]\(rq, are supported).
+.IP 
+The characters asterisk (*) and question-mark (?) have no special meaning.
+.IP 
+Here's an example that specifies 6 suffixes to skip (since 1 of the 5 rules
+matches 2 suffixes):
+.IP 
+.nf 
+    \-\-skip\-compress=gz/jpg/mp[34]/7z/bz2
+.fi 
+
+.IP 
+The default list of suffixes that will not be compressed is this (several
+of these are newly added for 3.0.0):
+.IP 
+.nf 
+    gz/zip/z/rpm/deb/iso/bz2/t[gb]z/7z/mp[34]/mov/avi/ogg/jpg/jpeg
+.fi 
+
+.IP 
+This list will be replaced by your \fB\-\-skip\-compress\fP list in all but one
+situation: a copy from a daemon rsync will add your skipped suffixes to
+its list of non-compressing files (and its list may be configured to a
+different default).
 .IP 
 .IP "\fB\-\-numeric\-ids\fP"
 With this option rsync will transfer numeric group
 and user IDs rather than using user and group names and mapping them
-at both ends\&.
+at both ends.
 .IP 
 By default rsync will use the username and groupname to determine
-what ownership to give files\&. The special uid 0 and the special group
+what ownership to give files. The special uid 0 and the special group
 0 are never mapped via user/group names even if the \fB\-\-numeric\-ids\fP
-option is not specified\&.
+option is not specified.
 .IP 
 If a user or group has no name on the source system or it has no match
 on the destination system, then the numeric ID
-from the source system is used instead\&.  See also the comments on the
-"use chroot" setting in the rsyncd\&.conf manpage for information on how
-the chroot setting affects rsync\&'s ability to look up the names of the
-users and groups and what you can do about it\&.
+from the source system is used instead.  See also the comments on the
+\(lquse chroot\(rq setting in the rsyncd.conf manpage for information on how
+the chroot setting affects rsync's ability to look up the names of the
+users and groups and what you can do about it.
 .IP 
 .IP "\fB\-\-timeout=TIMEOUT\fP"
 This option allows you to set a maximum I/O
-timeout in seconds\&. If no data is transferred for the specified time
-then rsync will exit\&. The default is 0, which means no timeout\&.
+timeout in seconds. If no data is transferred for the specified time
+then rsync will exit. The default is 0, which means no timeout.
+.IP 
+.IP "\fB\-\-contimeout\fP"
+This option allows you to set the amount of time
+that rsync will wait for its connection to an rsync daemon to succeed.
+If the timeout is reached, rsync exits with an error.
 .IP 
 .IP "\fB\-\-address\fP"
 By default rsync will bind to the wildcard address when
-connecting to an rsync daemon\&.  The \fB\-\-address\fP option allows you to
-specify a specific IP address (or hostname) to bind to\&.  See also this
-option in the \fB\-\-daemon\fP mode section\&.
+connecting to an rsync daemon.  The \fB\-\-address\fP option allows you to
+specify a specific IP address (or hostname) to bind to.  See also this
+option in the \fB\-\-daemon\fP mode section.
 .IP 
 .IP "\fB\-\-port=PORT\fP"
 This specifies an alternate TCP port number to use
-rather than the default of 873\&.  This is only needed if you are using the
+rather than the default of 873.  This is only needed if you are using the
 double-colon (::) syntax to connect with an rsync daemon (since the URL
-syntax has a way to specify the port as a part of the URL)\&.  See also this
-option in the \fB\-\-daemon\fP mode section\&.
+syntax has a way to specify the port as a part of the URL).  See also this
+option in the \fB\-\-daemon\fP mode section.
 .IP 
 .IP "\fB\-\-sockopts\fP"
 This option can provide endless fun for people
-who like to tune their systems to the utmost degree\&. You can set all
+who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
-slower!)\&. Read the man page for the 
+slower!). Read the man page for the 
 \f(CWsetsockopt()\fP
 system call for
-details on some of the options you may be able to set\&. By default no
-special socket options are set\&. This only affects direct socket
-connections to a remote rsync daemon\&.  This option also exists in the
-\fB\-\-daemon\fP mode section\&.
+details on some of the options you may be able to set. By default no
+special socket options are set. This only affects direct socket
+connections to a remote rsync daemon.  This option also exists in the
+\fB\-\-daemon\fP mode section.
 .IP 
 .IP "\fB\-\-blocking\-io\fP"
 This tells rsync to use blocking I/O when launching
-a remote shell transport\&.  If the remote shell is either rsh or remsh,
+a remote shell transport.  If the remote shell is either rsh or remsh,
 rsync defaults to using
-blocking I/O, otherwise it defaults to using non-blocking I/O\&.  (Note that
-ssh prefers non-blocking I/O\&.)
+blocking I/O, otherwise it defaults to using non-blocking I/O.  (Note that
+ssh prefers non-blocking I/O.)
 .IP 
 .IP "\fB\-i, \-\-itemize\-changes\fP"
 Requests a simple itemized list of the
-changes that are being made to each file, including attribute changes\&.
-This is exactly the same as specifying \fB\-\-out\-format=\&'%i %n%L\&'\fP\&.
+changes that are being made to each file, including attribute changes.
+This is exactly the same as specifying \fB\-\-out\-format='%i %n%L'\fP.
 If you repeat the option, unchanged files will also be output, but only
-if the receiving rsync is at least version 2\&.6\&.7 (you can use \fB\-vv\fP
+if the receiving rsync is at least version 2.6.7 (you can use \fB\-vv\fP
 with older versions of rsync, but that also turns on the output of other
-verbose messages)\&.
+verbose messages).
 .IP 
-The "%i" escape has a cryptic output that is 9 letters long\&.  The general
-format is like the string \fBYXcstpogz\fP, where \fBY\fP is replaced by the
+The \(lq%i\(rq escape has a cryptic output that is 11 letters long.  The general
+format is like the string \fBYXcstpoguax\fP, where \fBY\fP is replaced by the
 type of update being done, \fBX\fP is replaced by the file-type, and the
 other letters represent attributes that may be output if they are being
-modified\&.
+modified.
 .IP 
 The update types that replace the \fBY\fP are as follows:
 .IP 
 .RS 
 .IP o 
 A \fB<\fP means that a file is being transferred to the remote host
-(sent)\&.
+(sent).
 .IP o 
 A \fB>\fP means that a file is being transferred to the local host
-(received)\&.
+(received).
 .IP o 
 A \fBc\fP means that a local change/creation is occurring for the item
-(such as the creation of a directory or the changing of a symlink, etc\&.)\&.
+(such as the creation of a directory or the changing of a symlink, etc.).
 .IP o 
 A \fBh\fP means that the item is a hard link to another item (requires
-\fB\-\-hard\-links\fP)\&.
+\fB\-\-hard\-links\fP).
+.IP o 
+A \fB.\fP means that the item is not being updated (though it might
+have attributes that are being modified).
 .IP o 
-A \fB\&.\fP means that the item is not being updated (though it might
-have attributes that are being modified)\&.
+A \fB*\fP means that the rest of the itemized-output area contains
+a message (e.g. \(lqdeleting\(rq).
 .RE
 
 .IP 
 The file-types that replace the \fBX\fP are: \fBf\fP for a file, a \fBd\fP for a
 directory, an \fBL\fP for a symlink, a \fBD\fP for a device, and a \fBS\fP for a
-special file (e\&.g\&. named sockets and fifos)\&.
+special file (e.g. named sockets and fifos).
 .IP 
 The other letters in the string above are the actual letters that
 will be output if the associated attribute for the item is being updated or
-a "\&." for no change\&.  Three exceptions to this are: (1) a newly created
-item replaces each letter with a "+", (2) an identical item replaces the
+a \(lq.\(rq for no change.  Three exceptions to this are: (1) a newly created
+item replaces each letter with a \(lq+\(rq, (2) an identical item replaces the
 dots with spaces, and (3) an unknown attribute replaces each letter with
-a "?" (this can happen when talking to an older rsync)\&.
+a \(lq?\(rq (this can happen when talking to an older rsync).
 .IP 
 The attribute that is associated with each letter is as follows:
 .IP 
 .RS 
 .IP o 
 A \fBc\fP means the checksum of the file is different and will be
-updated by the file transfer (requires \fB\-\-checksum\fP)\&.
+updated by the file transfer (requires \fB\-\-checksum\fP).
 .IP o 
 A \fBs\fP means the size of the file is different and will be updated
-by the file transfer\&.
+by the file transfer.
 .IP o 
 A \fBt\fP means the modification time is different and is being updated
-to the sender\&'s value (requires \fB\-\-times\fP)\&.  An alternate value of \fBT\fP
-means that the time will be set to the transfer time, which happens
-anytime a symlink is transferred, or when a file or device is transferred
-without \fB\-\-times\fP\&.
+to the sender's value (requires \fB\-\-times\fP).  An alternate value of \fBT\fP
+means that the modification time will be set to the transfer time, which happens
+when a file/symlink/device is updated without \fB\-\-times\fP and when a
+symlink is changed and the receiver can't set its time.
 .IP o 
 A \fBp\fP means the permissions are different and are being updated to
-the sender\&'s value (requires \fB\-\-perms\fP)\&.
+the sender's value (requires \fB\-\-perms\fP).
 .IP o 
 An \fBo\fP means the owner is different and is being updated to the
-sender\&'s value (requires \fB\-\-owner\fP and super-user privileges)\&.
+sender's value (requires \fB\-\-owner\fP and super-user privileges).
 .IP o 
 A \fBg\fP means the group is different and is being updated to the
-sender\&'s value (requires \fB\-\-group\fP and the authority to set the group)\&.
+sender's value (requires \fB\-\-group\fP and the authority to set the group).
+.IP o 
+The \fBu\fP slot is reserved for future use.
 .IP o 
-The \fBz\fP slot is reserved for future use\&.
+The \fBa\fP means that the ACL information changed.
+.IP o 
+The \fBx\fP means that the extended attribute information changed.
 .RE
 
 .IP 
-One other output is possible:  when deleting files, the "%i" will output
-the string "*deleting" for each item that is being removed (assuming that
+One other output is possible:  when deleting files, the \(lq%i\(rq will output
+the string \(lq*deleting\(rq for each item that is being removed (assuming that
 you are talking to a recent enough rsync that it logs deletions instead of
-outputting them as a verbose message)\&.
+outputting them as a verbose message).
 .IP 
 .IP "\fB\-\-out\-format=FORMAT\fP"
 This allows you to specify exactly what the
-rsync client outputs to the user on a per-update basis\&.  The format is a text
+rsync client outputs to the user on a per-update basis.  The format is a text
 string containing embedded single-character escape sequences prefixed with
-a percent (%) character\&.  For a list of the possible escape characters, see
-the "log format" setting in the rsyncd\&.conf manpage\&.
+a percent (%) character.  For a list of the possible escape characters, see
+the \(lqlog format\(rq setting in the rsyncd.conf manpage.
 .IP 
-Specifying this option will mention each file, dir, etc\&. that gets updated
+Specifying this option will mention each file, dir, etc. that gets updated
 in a significant way (a transferred file, a recreated symlink/device, or a
-touched directory)\&.  In addition, if the itemize-changes escape (%i) is
+touched directory).  In addition, if the itemize-changes escape (%i) is
 included in the string, the logging of names increases to mention any
 item that is changed in any way (as long as the receiving side is at least
-2\&.6\&.4)\&.  See the \fB\-\-itemize\-changes\fP option for a description of the
-output of "%i"\&.
+2.6.4).  See the \fB\-\-itemize\-changes\fP option for a description of the
+output of \(lq%i\(rq.
 .IP 
-The \fB\-\-verbose\fP option implies a format of "%n%L", but you can use
+The \fB\-\-verbose\fP option implies a format of \(lq%n%L\(rq, but you can use
 \fB\-\-out\-format\fP without \fB\-\-verbose\fP if you like, or you can override
-the format of its per-file output using this option\&.
+the format of its per-file output using this option.
 .IP 
-Rsync will output the out-format string prior to a file\&'s transfer unless
+Rsync will output the out-format string prior to a file's transfer unless
 one of the transfer-statistic escapes is requested, in which case the
-logging is done at the end of the file\&'s transfer\&.  When this late logging
+logging is done at the end of the file's transfer.  When this late logging
 is in effect and \fB\-\-progress\fP is also specified, rsync will also output
 the name of the file being transferred prior to its progress information
-(followed, of course, by the out-format output)\&.
+(followed, of course, by the out-format output).
 .IP 
 .IP "\fB\-\-log\-file=FILE\fP"
 This option causes rsync to log what it is doing
-to a file\&.  This is similar to the logging that a daemon does, but can be
+to a file.  This is similar to the logging that a daemon does, but can be
 requested for the client side and/or the server side of a non-daemon
-transfer\&.  If specified as a client option, transfer logging will be
-enabled with a default format of "%i %n%L"\&.  See the \fB\-\-log\-file\-format\fP
-option if you wish to override this\&.
+transfer.  If specified as a client option, transfer logging will be
+enabled with a default format of \(lq%i %n%L\(rq.  See the \fB\-\-log\-file\-format\fP
+option if you wish to override this.
 .IP 
-Here\&'s a example command that requests the remote side to log what is
+Here's a example command that requests the remote side to log what is
 happening:
 .IP 
 .nf 
   rsync \-av \-\-rsync\-path="rsync \-\-log\-file=/tmp/rlog" src/ dest/
 .fi 
 
 .IP 
 This is very useful if you need to debug why a connection is closing
-unexpectedly\&.
+unexpectedly.
 .IP 
 .IP "\fB\-\-log\-file\-format=FORMAT\fP"
 This allows you to specify exactly what
 per-update logging is put into the file specified by the \fB\-\-log\-file\fP option
-(which must also be specified for this option to have any effect)\&.  If you
-specify an empty string, updated files will not be mentioned in the log file\&.
-For a list of the possible escape characters, see the "log format" setting
-in the rsyncd\&.conf manpage\&.
+(which must also be specified for this option to have any effect).  If you
+specify an empty string, updated files will not be mentioned in the log file.
+For a list of the possible escape characters, see the \(lqlog format\(rq setting
+in the rsyncd.conf manpage.
 .IP 
 .IP "\fB\-\-stats\fP"
 This tells rsync to print a verbose set of statistics
 on the file transfer, allowing you to tell how effective the rsync
-algorithm is for your data\&.
+algorithm is for your data.
 .IP 
 The current statistics are as follows: 
 .RS 
 .IP o 
-\fBNumber of files\fP is the count of all "files" (in the generic
-sense), which includes directories, symlinks, etc\&.
+\fBNumber of files\fP is the count of all \(lqfiles\(rq (in the generic
+sense), which includes directories, symlinks, etc.
 .IP o 
 \fBNumber of files transferred\fP is the count of normal files that
 were updated via the rsync algorithm, which does not include created
-dirs, symlinks, etc\&.
+dirs, symlinks, etc.
 .IP o 
-\fBTotal file size\fP is the total sum of all file sizes in the transfer\&.
+\fBTotal file size\fP is the total sum of all file sizes in the transfer.
 This does not count any size for directories or special files, but does
-include the size of symlinks\&.
+include the size of symlinks.
 .IP o 
 \fBTotal transferred file size\fP is the total sum of all files sizes
-for just the transferred files\&.
+for just the transferred files.
 .IP o 
 \fBLiteral data\fP is how much unmatched file-update data we had to
-send to the receiver for it to recreate the updated files\&.
+send to the receiver for it to recreate the updated files.
 .IP o 
 \fBMatched data\fP is how much data the receiver got locally when
-recreating the updated files\&.
+recreating the updated files.
 .IP o 
 \fBFile list size\fP is how big the file-list data was when the sender
-sent it to the receiver\&.  This is smaller than the in-memory size for the
+sent it to the receiver.  This is smaller than the in-memory size for the
 file list due to some compressing of duplicated data when rsync sends the
-list\&.
+list.
 .IP o 
 \fBFile list generation time\fP is the number of seconds that the
-sender spent creating the file list\&.  This requires a modern rsync on the
-sending side for this to be present\&.
+sender spent creating the file list.  This requires a modern rsync on the
+sending side for this to be present.
 .IP o 
 \fBFile list transfer time\fP is the number of seconds that the sender
-spent sending the file list to the receiver\&.
+spent sending the file list to the receiver.
 .IP o 
 \fBTotal bytes sent\fP is the count of all the bytes that rsync sent
-from the client side to the server side\&.
+from the client side to the server side.
 .IP o 
 \fBTotal bytes received\fP is the count of all non-message bytes that
-rsync received by the client side from the server side\&.  "Non-message"
-bytes means that we don\&'t count the bytes for a verbose message that the
-server sent to us, which makes the stats more consistent\&.
+rsync received by the client side from the server side.  \(lqNon-message\(rq
+bytes means that we don't count the bytes for a verbose message that the
+server sent to us, which makes the stats more consistent.
 .RE
 
 .IP 
 .IP "\fB\-8, \-\-8\-bit\-output\fP"
 This tells rsync to leave all high-bit characters
-unescaped in the output instead of trying to test them to see if they\&'re
-valid in the current locale and escaping the invalid ones\&.  All control
-characters (but never tabs) are always escaped, regardless of this option\&'s
-setting\&.
-.IP 
-The escape idiom that started in 2\&.6\&.7 is to output a literal backslash (\e)
-and a hash (#), followed by exactly 3 octal digits\&.  For example, a newline
-would output as "\e#012"\&.  A literal backslash that is in a filename is not
-escaped unless it is followed by a hash and 3 digits (0\-9)\&.
+unescaped in the output instead of trying to test them to see if they're
+valid in the current locale and escaping the invalid ones.  All control
+characters (but never tabs) are always escaped, regardless of this option's
+setting.
+.IP 
+The escape idiom that started in 2.6.7 is to output a literal backslash (\e)
+and a hash (#), followed by exactly 3 octal digits.  For example, a newline
+would output as \(lq\e#012\(rq.  A literal backslash that is in a filename is not
+escaped unless it is followed by a hash and 3 digits (0\-9).
 .IP 
 .IP "\fB\-h, \-\-human\-readable\fP"
-Output numbers in a more human-readable format\&.
-This makes big numbers output using larger units, with a K, M, or G suffix\&.  If
+Output numbers in a more human-readable format.
+This makes big numbers output using larger units, with a K, M, or G suffix.  If
 this option was specified once, these units are K (1000), M (1000*1000), and
 G (1000*1000*1000); if the option is repeated, the units are powers of 1024
-instead of 1000\&.
+instead of 1000.
 .IP 
 .IP "\fB\-\-partial\fP"
 By default, rsync will delete any partially
-transferred file if the transfer is interrupted\&. In some circumstances
-it is more desirable to keep partially transferred files\&. Using the
+transferred file if the transfer is interrupted. In some circumstances
+it is more desirable to keep partially transferred files. Using the
 \fB\-\-partial\fP option tells rsync to keep the partial file which should
-make a subsequent transfer of the rest of the file much faster\&.
+make a subsequent transfer of the rest of the file much faster.
 .IP 
 .IP "\fB\-\-partial\-dir=DIR\fP"
 A better way to keep partial files than the
 \fB\-\-partial\fP option is to specify a \fIDIR\fP that will be used to hold the
-partial data (instead of writing it out to the destination file)\&.
+partial data (instead of writing it out to the destination file).
 On the next transfer, rsync will use a file found in this
 dir as data to speed up the resumption of the transfer and then delete it
-after it has served its purpose\&.
+after it has served its purpose.
 .IP 
 Note that if \fB\-\-whole\-file\fP is specified (or implied), any partial-dir
 file that is found for a file that is being updated will simply be removed
 (since
-rsync is sending files without using the incremental rsync algorithm)\&.
+rsync is sending files without using the delta transfer algorithm).
 .IP 
-Rsync will create the \fIDIR\fP if it is missing (just the last dir -- not
-the whole path)\&.  This makes it easy to use a relative path (such as
-"\fB\-\-partial\-dir=\&.rsync\-partial\fP") to have rsync create the
-partial-directory in the destination file\&'s directory when needed, and then
-remove it again when the partial file is deleted\&.
+Rsync will create the \fIDIR\fP if it is missing (just the last dir \(em not
+the whole path).  This makes it easy to use a relative path (such as
+\(lq\fB\-\-partial\-dir=.rsync\-partial\fP\(rq) to have rsync create the
+partial-directory in the destination file's directory when needed, and then
+remove it again when the partial file is deleted.
 .IP 
 If the partial-dir value is not an absolute path, rsync will add an exclude
-rule at the end of all your existing excludes\&.  This will prevent the
+rule at the end of all your existing excludes.  This will prevent the
 sending of any partial-dir files that may exist on the sending side, and
 will also prevent the untimely deletion of partial-dir items on the
-receiving side\&.  An example: the above \fB\-\-partial\-dir\fP option would add
-the equivalent of "\fB\-\-exclude=\&.rsync\-partial/\fP" at the end of any other
-filter rules\&.
+receiving side.  An example: the above \fB\-\-partial\-dir\fP option would add
+the equivalent of \(lq\fB\-f '\-p .rsync\-partial/'\fP\(rq at the end of any other
+filter rules.
 .IP 
 If you are supplying your own exclude rules, you may need to add your own
 exclude/hide/protect rule for the partial-dir because (1) the auto-added
 rule may be ineffective at the end of your other rules, or (2) you may wish
-to override rsync\&'s exclude choice\&.  For instance, if you want to make
+to override rsync's exclude choice.  For instance, if you want to make
 rsync clean-up any left-over partial-dirs that may be lying around, you
-should specify \fB\-\-delete\-after\fP and add a "risk" filter rule, e\&.g\&.
-\fB\-f \&'R \&.rsync\-partial/\&'\fP\&.  (Avoid using \fB\-\-delete\-before\fP or
-\fB\-\-delete\-during\fP unless you don\&'t need rsync to use any of the
-left-over partial-dir data during the current run\&.)
+should specify \fB\-\-delete\-after\fP and add a \(lqrisk\(rq filter rule, e.g.
+\fB\-f 'R .rsync\-partial/'\fP.  (Avoid using \fB\-\-delete\-before\fP or
+\fB\-\-delete\-during\fP unless you don't need rsync to use any of the
+left-over partial-dir data during the current run.)
 .IP 
 IMPORTANT: the \fB\-\-partial\-dir\fP should not be writable by other users or it
-is a security risk\&.  E\&.g\&. AVOID "/tmp"\&.
+is a security risk.  E.g. AVOID \(lq/tmp\(rq.
 .IP 
 You can also set the partial-dir value the RSYNC_PARTIAL_DIR environment
-variable\&.  Setting this in the environment does not force \fB\-\-partial\fP to be
+variable.  Setting this in the environment does not force \fB\-\-partial\fP to be
 enabled, but rather it affects where partial files go when \fB\-\-partial\fP is
-specified\&.  For instance, instead of using \fB\-\-partial\-dir=\&.rsync\-tmp\fP
-along with \fB\-\-progress\fP, you could set RSYNC_PARTIAL_DIR=\&.rsync\-tmp in your
+specified.  For instance, instead of using \fB\-\-partial\-dir=.rsync\-tmp\fP
+along with \fB\-\-progress\fP, you could set RSYNC_PARTIAL_DIR=.rsync\-tmp in your
 environment and then just use the \fB\-P\fP option to turn on the use of the
-\&.rsync\-tmp dir for partial transfers\&.  The only times that the \fB\-\-partial\fP
+\&.rsync\-tmp dir for partial transfers.  The only times that the \fB\-\-partial\fP
 option does not look for this environment value are (1) when \fB\-\-inplace\fP was
 specified (since \fB\-\-inplace\fP conflicts with \fB\-\-partial\-dir\fP), and (2) when
-\fB\-\-delay\-updates\fP was specified (see below)\&.
+\fB\-\-delay\-updates\fP was specified (see below).
 .IP 
-For the purposes of the daemon-config\&'s "refuse options" setting,
-\fB\-\-partial\-dir\fP does \fInot\fP imply \fB\-\-partial\fP\&.  This is so that a
+For the purposes of the daemon-config's \(lqrefuse options\(rq setting,
+\fB\-\-partial\-dir\fP does \fInot\fP imply \fB\-\-partial\fP.  This is so that a
 refusal of the \fB\-\-partial\fP option can be used to disallow the overwriting
 of destination files with a partial transfer, while still allowing the
-safer idiom provided by \fB\-\-partial\-dir\fP\&.
+safer idiom provided by \fB\-\-partial\-dir\fP.
 .IP 
 .IP "\fB\-\-delay\-updates\fP"
 This option puts the temporary file from each
 updated file into a holding directory until the end of the
 transfer, at which time all the files are renamed into place in rapid
-succession\&.  This attempts to make the updating of the files a little more
-atomic\&.  By default the files are placed into a directory named "\&.~tmp~" in
-each file\&'s destination directory, but if you\&'ve specified the
-\fB\-\-partial\-dir\fP option, that directory will be used instead\&.  See the
+succession.  This attempts to make the updating of the files a little more
+atomic.  By default the files are placed into a directory named \(lq.~tmp~\(rq in
+each file's destination directory, but if you've specified the
+\fB\-\-partial\-dir\fP option, that directory will be used instead.  See the
 comments in the \fB\-\-partial\-dir\fP section for a discussion of how this
-"\&.~tmp~" dir will be excluded from the transfer, and what you can do if
-you wnat rsync to cleanup old "\&.~tmp~" dirs that might be lying around\&.
-Conflicts with \fB\-\-inplace\fP and \fB\-\-append\fP\&.
+\(lq.~tmp~\(rq dir will be excluded from the transfer, and what you can do if
+you want rsync to cleanup old \(lq.~tmp~\(rq dirs that might be lying around.
+Conflicts with \fB\-\-inplace\fP and \fB\-\-append\fP.
 .IP 
 This option uses more memory on the receiving side (one bit per file
 transferred) and also requires enough free disk space on the receiving
-side to hold an additional copy of all the updated files\&.  Note also that
+side to hold an additional copy of all the updated files.  Note also that
 you should not use an absolute path to \fB\-\-partial\-dir\fP unless (1)
 there is no
 chance of any of the files in the transfer having the same name (since all
 the updated files will be put into a single directory if the path is
 absolute)
 and (2) there are no mount points in the hierarchy (since the
-delayed updates will fail if they can\&'t be renamed into place)\&.
+delayed updates will fail if they can't be renamed into place).
 .IP 
-See also the "atomic-rsync" perl script in the "support" subdir for an
+See also the \(lqatomic-rsync\(rq perl script in the \(lqsupport\(rq subdir for an
 update algorithm that is even more atomic (it uses \fB\-\-link\-dest\fP and a
-parallel hierarchy of files)\&.
+parallel hierarchy of files).
 .IP 
 .IP "\fB\-m, \-\-prune\-empty\-dirs\fP"
 This option tells the receiving rsync to get
 rid of empty directories from the file-list, including nested directories
-that have no non-directory children\&.  This is useful for avoiding the
+that have no non-directory children.  This is useful for avoiding the
 creation of a bunch of useless directories when the sending rsync is
 recursively scanning a hierarchy of files using include/exclude/filter
-rules\&.
+rules.
 .IP 
 Because the file-list is actually being pruned, this option also affects
-what directories get deleted when a delete is active\&.  However, keep in
+what directories get deleted when a delete is active.  However, keep in
 mind that excluded files and directories can prevent existing items from
 being deleted (because an exclude hides source files and protects
-destination files)\&.
+destination files).
 .IP 
 You can prevent the pruning of certain empty directories from the file-list
-by using a global "protect" filter\&.  For instance, this option would ensure
-that the directory "emptydir" was kept in the file-list:
+by using a global \(lqprotect\(rq filter.  For instance, this option would ensure
+that the directory \(lqemptydir\(rq was kept in the file-list:
 .IP 
 .RS 
-\-\-filter \&'protect emptydir/\&'
+\-\-filter 'protect emptydir/'
 .RE
 
 .IP 
-Here\&'s an example that copies all \&.pdf files in a hierarchy, only creating
-the necessary destination directories to hold the \&.pdf files, and ensures
+Here's an example that copies all .pdf files in a hierarchy, only creating
+the necessary destination directories to hold the .pdf files, and ensures
 that any superfluous files and directories in the destination are removed
 (note the hide filter of non-directories being used instead of an exclude):
 .IP 
 .RS 
-rsync \-avm \-\-del \-\-include=\&'*\&.pdf\&' \-f \&'hide,! */\&' src/ dest
+rsync \-avm \-\-del \-\-include='*.pdf' \-f 'hide,! */' src/ dest
 .RE
 
 .IP 
-If you didn\&'t want to remove superfluous destination files, the more
-time-honored options of "\-\-include=\&'*/\&' \-\-exclude=\&'*\&'" would work fine
-in place of the hide-filter (if that is more natural to you)\&.
+If you didn't want to remove superfluous destination files, the more
+time-honored options of \(lq\fB\-\-include='*/' \-\-exclude='*'\fP\(rq would work fine
+in place of the hide-filter (if that is more natural to you).
 .IP 
 .IP "\fB\-\-progress\fP"
 This option tells rsync to print information
-showing the progress of the transfer\&. This gives a bored user
-something to watch\&.
-Implies \fB\-\-verbose\fP if it wasn\&'t already specified\&.
+showing the progress of the transfer. This gives a bored user
+something to watch.
+Implies \fB\-\-verbose\fP if it wasn't already specified.
 .IP 
 While rsync is transferring a regular file, it updates a progress line that
 looks like this:
 .IP 
 .nf 
-      782448  63%  110\&.64kB/s    0:00:04
+      782448  63%  110.64kB/s    0:00:04
 .fi 
 
 .IP 
 In this example, the receiver has reconstructed 782448 bytes or 63% of the
-sender\&'s file, which is being reconstructed at a rate of 110\&.64 kilobytes
+sender's file, which is being reconstructed at a rate of 110.64 kilobytes
 per second, and the transfer will finish in 4 seconds if the current rate
-is maintained until the end\&.
+is maintained until the end.
 .IP 
-These statistics can be misleading if the incremental transfer algorithm is
-in use\&.  For example, if the sender\&'s file consists of the basis file
+These statistics can be misleading if the delta transfer algorithm is
+in use.  For example, if the sender's file consists of the basis file
 followed by additional data, the reported rate will probably drop
 dramatically when the receiver gets to the literal data, and the transfer
 will probably take much longer to finish than the receiver estimated as it
-was finishing the matched part of the file\&.
+was finishing the matched part of the file.
 .IP 
 When the file transfer finishes, rsync replaces the progress line with a
 summary line that looks like this:
 .IP 
 .nf 
-     1238099 100%  146\&.38kB/s    0:00:08  (xfer#5, to-check=169/396)
+     1238099 100%  146.38kB/s    0:00:08  (xfer#5, to-check=169/396)
 .fi 
 
 .IP 
 In this example, the file was 1238099 bytes long in total, the average rate
-of transfer for the whole file was 146\&.38 kilobytes per second over the 8
+of transfer for the whole file was 146.38 kilobytes per second over the 8
 seconds that it took to complete, it was the 5th transfer of a regular file
 during the current rsync session, and there are 169 more files for the
 receiver to check (to see if they are up-to-date or not) remaining out of
-the 396 total files in the file-list\&.
+the 396 total files in the file-list.
 .IP 
 .IP "\fB\-P\fP"
-The \fB\-P\fP option is equivalent to \fB\-\-partial\fP \fB\-\-progress\fP\&.  Its
+The \fB\-P\fP option is equivalent to \fB\-\-partial\fP \fB\-\-progress\fP.  Its
 purpose is to make it much easier to specify these two options for a long
-transfer that may be interrupted\&.
+transfer that may be interrupted.
 .IP 
 .IP "\fB\-\-password\-file\fP"
-This option allows you to provide a password
-in a file for accessing a remote rsync daemon\&. Note that this option
-is only useful when accessing an rsync daemon using the built in
-transport, not when using a remote shell as the transport\&. The file
-must not be world readable\&. It should contain just the password as a
-single line\&.
+This option allows you to provide a password in a
+file for accessing an rsync daemon.  The file must not be world readable.
+It should contain just the password as a single line.
+.IP 
+This option does not supply a password to a remote shell transport such as
+ssh; to learn how to do that, consult the remote shell's documentation.
+When accessing an rsync daemon using a remote shell as the transport, this
+option only comes into effect after the remote shell finishes its
+authentication (i.e. if you have also specified a password in the daemon's
+config file).
 .IP 
 .IP "\fB\-\-list\-only\fP"
 This option will cause the source files to be listed
-instead of transferred\&.  This option is inferred if there is a single source
+instead of transferred.  This option is inferred if there is a single source
 arg and no destination specified, so its main uses are: (1) to turn a copy
 command that includes a
-destination arg into a file-listing command, (2) to be able to specify more
-than one local source arg (note: be sure to include the destination), or
-(3) to avoid the automatically added "\fB\-r \-\-exclude=\&'/*/*\&'\fP" options that
-rsync usually uses as a compatibility kluge when generating a non-recursive
-listing\&.  Caution: keep in mind that a source arg with a wild-card is expanded
-by the shell into multiple args, so it is never safe to try to list such an arg
-without using this option\&.  For example:
+destination arg into a file-listing command, or (2) to be able to specify
+more than one source arg (note: be sure to include the destination).
+Caution: keep in mind that a source arg with a wild-card is expanded by the
+shell into multiple args, so it is never safe to try to list such an arg
+without using this option.  For example:
 .IP 
 .nf 
     rsync \-av \-\-list\-only foo* dest/
 .fi 
 
 .IP 
+Compatibility note:  when requesting a remote listing of files from an rsync
+that is version 2.6.3 or older, you may encounter an error if you ask for a
+non-recursive listing.  This is because a file listing implies the \fB\-\-dirs\fP
+option w/o \fB\-\-recursive\fP, and older rsyncs don't have that option.  To
+avoid this problem, either specify the \fB\-\-no\-dirs\fP option (if you don't
+need to expand a directory's content), or turn on recursion and exclude
+the content of subdirectories: \fB\-r \-\-exclude='/*/*'\fP.
+.IP 
 .IP "\fB\-\-bwlimit=KBPS\fP"
 This option allows you to specify a maximum
-transfer rate in kilobytes per second\&. This option is most effective when
-using rsync with large files (several megabytes and up)\&. Due to the nature
+transfer rate in kilobytes per second. This option is most effective when
+using rsync with large files (several megabytes and up). Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
-transfer was too fast, it will wait before sending the next data block\&. The
-result is an average transfer rate equaling the specified limit\&. A value
-of zero specifies no limit\&.
+transfer was too fast, it will wait before sending the next data block. The
+result is an average transfer rate equaling the specified limit. A value
+of zero specifies no limit.
 .IP 
 .IP "\fB\-\-write\-batch=FILE\fP"
 Record a file that can later be applied to
-another identical destination with \fB\-\-read\-batch\fP\&. See the "BATCH MODE"
-section for details, and also the \fB\-\-only\-write\-batch\fP option\&.
+another identical destination with \fB\-\-read\-batch\fP. See the \(lqBATCH MODE\(rq
+section for details, and also the \fB\-\-only\-write\-batch\fP option.
 .IP 
 .IP "\fB\-\-only\-write\-batch=FILE\fP"
 Works like \fB\-\-write\-batch\fP, except that
-no updates are made on the destination system when creating the batch\&.
+no updates are made on the destination system when creating the batch.
 This lets you transport the changes to the destination system via some
-other means and then apply the changes via \fB\-\-read\-batch\fP\&.
+other means and then apply the changes via \fB\-\-read\-batch\fP.
 .IP 
 Note that you can feel free to write the batch directly to some portable
 media: if this media fills to capacity before the end of the transfer, you
 can just apply that partial transfer to the destination and repeat the
-whole process to get the rest of the changes (as long as you don\&'t mind a
+whole process to get the rest of the changes (as long as you don't mind a
 partially updated destination system while the multi-update cycle is
-happening)\&.
+happening).
 .IP 
 Also note that you only save bandwidth when pushing changes to a remote
 system because this allows the batched data to be diverted from the sender
 into the batch file without having to flow over the wire to the receiver
-(when pulling, the sender is remote, and thus can\&'t write the batch)\&.
+(when pulling, the sender is remote, and thus can't write the batch).
 .IP 
 .IP "\fB\-\-read\-batch=FILE\fP"
 Apply all of the changes stored in FILE, a
-file previously generated by \fB\-\-write\-batch\fP\&.
-If \fIFILE\fP is \fB\-\fP, the batch data will be read from standard input\&.
-See the "BATCH MODE" section for details\&.
+file previously generated by \fB\-\-write\-batch\fP.
+If \fIFILE\fP is \fB\-\fP, the batch data will be read from standard input.
+See the \(lqBATCH MODE\(rq section for details.
 .IP 
 .IP "\fB\-\-protocol=NUM\fP"
-Force an older protocol version to be used\&.  This
+Force an older protocol version to be used.  This
 is useful for creating a batch file that is compatible with an older
-version of rsync\&.  For instance, if rsync 2\&.6\&.4 is being used with the
-\fB\-\-write\-batch\fP option, but rsync 2\&.6\&.3 is what will be used to run the
-\fB\-\-read\-batch\fP option, you should use "\-\-protocol=28" when creating the
+version of rsync.  For instance, if rsync 2.6.4 is being used with the
+\fB\-\-write\-batch\fP option, but rsync 2.6.3 is what will be used to run the
+\fB\-\-read\-batch\fP option, you should use \(lq\-\-protocol=28\(rq when creating the
 batch file to force the older protocol version to be used in the batch
-file (assuming you can\&'t upgrade the rsync on the reading system)\&.
+file (assuming you can't upgrade the rsync on the reading system).
+.IP 
+.IP "\fB\-\-iconv=CONVERT_SPEC\fP"
+Rsync can convert filenames between character
+sets using this option.  Using a CONVERT_SPEC of \(lq.\(rq tells rsync to look up
+the default character-set via the locale setting.  Alternately, you can
+fully specify what conversion to do by giving a local and a remote charset
+separated by a comma in the order \fB\-\-iconv=LOCAL,REMOTE\fP, e.g.
+\fB\-\-iconv=utf8,iso88591\fP.  This order ensures that the option
+will stay the same whether you're pushing or pulling files.
+Finally, you can specify either \fB\-\-no\-iconv\fP or a CONVERT_SPEC of \(lq\-\(rq
+to turn off any conversion.
+The default setting of this option is site-specific, and can also be
+affected via the RSYNC_ICONV environment variable.
+.IP 
+For a list of what charset names your local iconv library supports, you can
+run \(lqiconv \-\-list\(rq.
+.IP 
+If you specify the \fB\-\-protect\-args\fP option (\fB\-s\fP), rsync will translate
+the filenames you specify on the command-line that are being sent to the
+remote host.  See also the \fB\-\-files\-from\fP option.
+.IP 
+Note that rsync does not do any conversion of names in filter files
+(including include/exclude files).  It is up to you to ensure that you're
+specifying matching rules that can match on both sides of the transfer.
+For instance, you can specify extra include/exclude rules if there are
+filename differences on the two sides that need to be accounted for.
+.IP 
+When you pass an \fB\-\-iconv\fP option to an rsync daemon that allows it, the
+daemon uses the charset specified in its \(lqcharset\(rq configuration parameter
+regardless of the remote charset you actually pass.  Thus, you may feel free to
+specify just the local charset for a daemon transfer (e.g. \fB\-\-iconv=utf8\fP).
 .IP 
 .IP "\fB\-4, \-\-ipv4\fP or \fB\-6, \-\-ipv6\fP"
 Tells rsync to prefer IPv4/IPv6
-when creating sockets\&.  This only affects sockets that rsync has direct
+when creating sockets.  This only affects sockets that rsync has direct
 control over, such as the outgoing socket when directly contacting an
-rsync daemon\&.  See also these options in the \fB\-\-daemon\fP mode section\&.
+rsync daemon.  See also these options in the \fB\-\-daemon\fP mode section.
+.IP 
+If rsync was complied without support for IPv6, the \fB\-\-ipv6\fP option
+will have no effect.  The \fB\-\-version\fP output will tell you if this
+is the case.
 .IP 
 .IP "\fB\-\-checksum\-seed=NUM\fP"
 Set the MD4 checksum seed to the integer
-NUM\&.  This 4 byte checksum seed is included in each block and file
-MD4 checksum calculation\&.  By default the checksum seed is generated
+NUM.  This 4 byte checksum seed is included in each block and file
+MD4 checksum calculation.  By default the checksum seed is generated
 by the server and defaults to the current 
 \f(CWtime()\fP
 \&.  This option
 is used to set a specific checksum seed, which is useful for
 applications that want repeatable block and file checksums, or
-in the case where the user wants a more random checksum seed\&.
+in the case where the user wants a more random checksum seed.
 Note that setting NUM to 0 causes rsync to use the default of 
 \f(CWtime()\fP
-for checksum seed\&.
+for checksum seed.
 
 .PP 
 .SH "DAEMON OPTIONS"
 
 .PP 
 The options allowed when starting an rsync daemon are as follows:
 .PP 
 .IP "\fB\-\-daemon\fP"
-This tells rsync that it is to run as a daemon\&.  The
+This tells rsync that it is to run as a daemon.  The
 daemon you start running may be accessed using an rsync client using
-the \fBhost::module\fP or \fBrsync://host/module/\fP syntax\&.
+the \fBhost::module\fP or \fBrsync://host/module/\fP syntax.
 .IP 
 If standard input is a socket then rsync will assume that it is being
 run via inetd, otherwise it will detach from the current terminal and
-become a background daemon\&.  The daemon will read the config file
-(rsyncd\&.conf) on each connect made by a client and respond to
-requests accordingly\&.  See the \fBrsyncd\&.conf\fP(5) man page for more
-details\&.
+become a background daemon.  The daemon will read the config file
+(rsyncd.conf) on each connect made by a client and respond to
+requests accordingly.  See the \fBrsyncd.conf\fP(5) man page for more
+details.
 .IP 
 .IP "\fB\-\-address\fP"
 By default rsync will bind to the wildcard address when
-run as a daemon with the \fB\-\-daemon\fP option\&.  The \fB\-\-address\fP option
-allows you to specify a specific IP address (or hostname) to bind to\&.  This
-makes virtual hosting possible in conjunction with the \fB\-\-config\fP option\&.
-See also the "address" global option in the rsyncd\&.conf manpage\&.
+run as a daemon with the \fB\-\-daemon\fP option.  The \fB\-\-address\fP option
+allows you to specify a specific IP address (or hostname) to bind to.  This
+makes virtual hosting possible in conjunction with the \fB\-\-config\fP option.
+See also the \(lqaddress\(rq global option in the rsyncd.conf manpage.
 .IP 
 .IP "\fB\-\-bwlimit=KBPS\fP"
 This option allows you to specify a maximum
-transfer rate in kilobytes per second for the data the daemon sends\&.
+transfer rate in kilobytes per second for the data the daemon sends.
 The client can still specify a smaller \fB\-\-bwlimit\fP value, but their
-requested value will be rounded down if they try to exceed it\&.  See the
-client version of this option (above) for some extra details\&.
+requested value will be rounded down if they try to exceed it.  See the
+client version of this option (above) for some extra details.
 .IP 
 .IP "\fB\-\-config=FILE\fP"
 This specifies an alternate config file than
-the default\&.  This is only relevant when \fB\-\-daemon\fP is specified\&.
-The default is /etc/rsyncd\&.conf unless the daemon is running over
+the default.  This is only relevant when \fB\-\-daemon\fP is specified.
+The default is /etc/rsyncd.conf unless the daemon is running over
 a remote shell program and the remote user is not the super-user; in that case
-the default is rsyncd\&.conf in the current directory (typically $HOME)\&.
+the default is rsyncd.conf in the current directory (typically $HOME).
 .IP 
 .IP "\fB\-\-no\-detach\fP"
 When running as a daemon, this option instructs
-rsync to not detach itself and become a background process\&.  This
+rsync to not detach itself and become a background process.  This
 option is required when running as a service on Cygwin, and may also
 be useful when rsync is supervised by a program such as
-\fBdaemontools\fP or AIX\&'s \fBSystem Resource Controller\fP\&.
+\fBdaemontools\fP or AIX's \fBSystem Resource Controller\fP.
 \fB\-\-no\-detach\fP is also recommended when rsync is run under a
-debugger\&.  This option has no effect if rsync is run from inetd or
-sshd\&.
+debugger.  This option has no effect if rsync is run from inetd or
+sshd.
 .IP 
 .IP "\fB\-\-port=PORT\fP"
 This specifies an alternate TCP port number for the
-daemon to listen on rather than the default of 873\&.  See also the "port"
-global option in the rsyncd\&.conf manpage\&.
+daemon to listen on rather than the default of 873.  See also the \(lqport\(rq
+global option in the rsyncd.conf manpage.
 .IP 
 .IP "\fB\-\-log\-file=FILE\fP"
 This option tells the rsync daemon to use the
-given log-file name instead of using the "log file" setting in the config
-file\&.
+given log-file name instead of using the \(lqlog file\(rq setting in the config
+file.
 .IP 
 .IP "\fB\-\-log\-file\-format=FORMAT\fP"
 This option tells the rsync daemon to use the
-given FORMAT string instead of using the "log format" setting in the config
-file\&.  It also enables "transfer logging" unless the string is empty, in which
-case transfer logging is turned off\&.
+given FORMAT string instead of using the \(lqlog format\(rq setting in the config
+file.  It also enables \(lqtransfer logging\(rq unless the string is empty, in which
+case transfer logging is turned off.
 .IP 
 .IP "\fB\-\-sockopts\fP"
 This overrides the \fBsocket options\fP setting in the
-rsyncd\&.conf file and has the same syntax\&.
+rsyncd.conf file and has the same syntax.
 .IP 
 .IP "\fB\-v, \-\-verbose\fP"
 This option increases the amount of information the
-daemon logs during its startup phase\&.  After the client connects, the
-daemon\&'s verbosity level will be controlled by the options that the client
-used and the "max verbosity" setting in the module\&'s config section\&.
+daemon logs during its startup phase.  After the client connects, the
+daemon's verbosity level will be controlled by the options that the client
+used and the \(lqmax verbosity\(rq setting in the module's config section.
 .IP 
 .IP "\fB\-4, \-\-ipv4\fP or \fB\-6, \-\-ipv6\fP"
 Tells rsync to prefer IPv4/IPv6
 when creating the incoming sockets that the rsync daemon will use to
-listen for connections\&.  One of these options may be required in older
+listen for connections.  One of these options may be required in older
 versions of Linux to work around an IPv6 bug in the kernel (if you see
-an "address already in use" error when nothing else is using the port,
-try specifying \fB\-\-ipv6\fP or \fB\-\-ipv4\fP when starting the daemon)\&.
+an \(lqaddress already in use\(rq error when nothing else is using the port,
+try specifying \fB\-\-ipv6\fP or \fB\-\-ipv4\fP when starting the daemon).
+.IP 
+If rsync was complied without support for IPv6, the \fB\-\-ipv6\fP option
+will have no effect.  The \fB\-\-version\fP output will tell you if this
+is the case.
 .IP 
 .IP "\fB\-h, \-\-help\fP"
 When specified after \fB\-\-daemon\fP, print a short help
-page describing the options available for starting an rsync daemon\&.
+page describing the options available for starting an rsync daemon.
 
 .PP 
 .SH "FILTER RULES"
 
 .PP 
 The filter rules allow for flexible selection of which files to transfer
-(include) and which files to skip (exclude)\&.  The rules either directly
+(include) and which files to skip (exclude).  The rules either directly
 specify include/exclude patterns or they specify a way to acquire more
-include/exclude patterns (e\&.g\&. to read them from a file)\&.
+include/exclude patterns (e.g. to read them from a file).
 .PP 
 As the list of files/directories to transfer is built, rsync checks each
 name to be transferred against the list of include/exclude patterns in
 turn, and the first matching pattern is acted on:  if it is an exclude
 pattern, then that file is skipped; if it is an include pattern then that
 filename is not skipped; if no matching pattern is found, then the
-filename is not skipped\&.
+filename is not skipped.
 .PP 
 Rsync builds an ordered list of filter rules as specified on the
-command-line\&.  Filter rules have the following syntax:
+command-line.  Filter rules have the following syntax:
 .PP 
 .RS 
 \f(CWRULE [PATTERN_OR_FILENAME]\fP
 .br 
 \f(CWRULE,MODIFIERS [PATTERN_OR_FILENAME]\fP
 .br 
 .RE
 
 .PP 
 You have your choice of using either short or long RULE names, as described
-below\&.  If you use a short-named rule, the \&',\&' separating the RULE from the
-MODIFIERS is optional\&.  The PATTERN or FILENAME that follows (when present)
-must come after either a single space or an underscore (_)\&.
+below.  If you use a short-named rule, the \(oq,\(cq separating the RULE from the
+MODIFIERS is optional.  The PATTERN or FILENAME that follows (when present)
+must come after either a single space or an underscore (_).
 Here are the available rule prefixes:
 .PP 
 .RS 
-\fBexclude, \-\fP specifies an exclude pattern\&. 
+\fBexclude, \-\fP specifies an exclude pattern. 
 .br 
-\fBinclude, +\fP specifies an include pattern\&. 
+\fBinclude, +\fP specifies an include pattern. 
 .br 
-\fBmerge, \&.\fP specifies a merge-file to read for more rules\&. 
+\fBmerge, .\fP specifies a merge-file to read for more rules. 
 .br 
-\fBdir-merge, :\fP specifies a per-directory merge-file\&. 
+\fBdir-merge, :\fP specifies a per-directory merge-file. 
 .br 
-\fBhide, H\fP specifies a pattern for hiding files from the transfer\&. 
+\fBhide, H\fP specifies a pattern for hiding files from the transfer. 
 .br 
-\fBshow, S\fP files that match the pattern are not hidden\&. 
+\fBshow, S\fP files that match the pattern are not hidden. 
 .br 
-\fBprotect, P\fP specifies a pattern for protecting files from deletion\&. 
+\fBprotect, P\fP specifies a pattern for protecting files from deletion. 
 .br 
-\fBrisk, R\fP files that match the pattern are not protected\&. 
+\fBrisk, R\fP files that match the pattern are not protected. 
 .br 
 \fBclear, !\fP clears the current include/exclude list (takes no arg) 
 .br 
 .RE
 
 .PP 
 When rules are being read from a file, empty lines are ignored, as are
-comment lines that start with a "#"\&.
+comment lines that start with a \(lq#\(rq.
 .PP 
 Note that the \fB\-\-include\fP/\fB\-\-exclude\fP command-line options do not allow the
-full range of rule parsing as described above -- they only allow the
-specification of include/exclude patterns plus a "!" token to clear the
-list (and the normal comment parsing when rules are read from a file)\&.
+full range of rule parsing as described above \(em they only allow the
+specification of include/exclude patterns plus a \(lq!\(rq token to clear the
+list (and the normal comment parsing when rules are read from a file).
 If a pattern
-does not begin with "\- " (dash, space) or "+ " (plus, space), then the
-rule will be interpreted as if "+ " (for an include option) or "\- " (for
-an exclude option) were prefixed to the string\&.  A \fB\-\-filter\fP option, on
+does not begin with \(lq\- \(rq (dash, space) or \(lq+ \(rq (plus, space), then the
+rule will be interpreted as if \(lq+ \(rq (for an include option) or \(lq\- \(rq (for
+an exclude option) were prefixed to the string.  A \fB\-\-filter\fP option, on
 the other hand, must always contain either a short or long rule name at the
-start of the rule\&.
+start of the rule.
 .PP 
 Note also that the \fB\-\-filter\fP, \fB\-\-include\fP, and \fB\-\-exclude\fP options take one
-rule/pattern each\&. To add multiple ones, you can repeat the options on
+rule/pattern each. To add multiple ones, you can repeat the options on
 the command-line, use the merge-file syntax of the \fB\-\-filter\fP option, or
-the \fB\-\-include\-from\fP/\fB\-\-exclude\-from\fP options\&.
+the \fB\-\-include\-from\fP/\fB\-\-exclude\-from\fP options.
 .PP 
 .SH "INCLUDE/EXCLUDE PATTERN RULES"
 
 .PP 
-You can include and exclude files by specifying patterns using the "+",
-"\-", etc\&. filter rules (as introduced in the FILTER RULES section above)\&.
+You can include and exclude files by specifying patterns using the \(lq+\(rq,
+\(lq\-\(rq, etc. filter rules (as introduced in the FILTER RULES section above).
 The include/exclude rules each specify a pattern that is matched against
-the names of the files that are going to be transferred\&.  These patterns
+the names of the files that are going to be transferred.  These patterns
 can take several forms:
 .PP 
 .IP o 
 if the pattern starts with a / then it is anchored to a
 particular spot in the hierarchy of files, otherwise it is matched
-against the end of the pathname\&.  This is similar to a leading ^ in
-regular expressions\&.
-Thus "/foo" would match a file named "foo" at either the "root of the
-transfer" (for a global rule) or in the merge-file\&'s directory (for a
-per-directory rule)\&.
-An unqualified "foo" would match any file or directory named "foo"
-anywhere in the tree because the algorithm is applied recursively from
-the
+against the end of the pathname.  This is similar to a leading ^ in
+regular expressions.
+Thus \(lq/foo\(rq would match a name of \(lqfoo\(rq at either the \(lqroot of the
+transfer\(rq (for a global rule) or in the merge-file's directory (for a
+per-directory rule).
+An unqualified \(lqfoo\(rq would match a name of \(lqfoo\(rq anywhere in the
+tree because the algorithm is applied recursively from the
 top down; it behaves as if each path component gets a turn at being the
-end of the file name\&.  Even the unanchored "sub/foo" would match at
-any point in the hierarchy where a "foo" was found within a directory
-named "sub"\&.  See the section on ANCHORING INCLUDE/EXCLUDE PATTERNS for
+end of the filename.  Even the unanchored \(lqsub/foo\(rq would match at
+any point in the hierarchy where a \(lqfoo\(rq was found within a directory
+named \(lqsub\(rq.  See the section on ANCHORING INCLUDE/EXCLUDE PATTERNS for
 a full discussion of how to specify a pattern that matches at the root
-of the transfer\&.
+of the transfer.
 .IP o 
 if the pattern ends with a / then it will only match a
-directory, not a file, link, or device\&.
+directory, not a regular file, symlink, or device.
 .IP o 
 rsync chooses between doing a simple string match and wildcard
 matching by checking if the pattern contains one of these three wildcard
-characters: \&'*\&', \&'?\&', and \&'[\&' \&.
+characters: \(oq*\(cq, \(oq?\(cq, and \(oq[\(cq .
 .IP o 
-a \&'*\&' matches any non-empty path component (it stops at slashes)\&.
+a \(oq*\(cq matches any non-empty path component (it stops at slashes).
 .IP o 
-use \&'**\&' to match anything, including slashes\&.
+use '**' to match anything, including slashes.
 .IP o 
-a \&'?\&' matches any character except a slash (/)\&.
+a \(oq?\(cq matches any character except a slash (/).
 .IP o 
-a \&'[\&' introduces a character class, such as [a\-z] or [[:alpha:]]\&.
+a \(oq[\(cq introduces a character class, such as [a\-z] or [[:alpha:]].
 .IP o 
 in a wildcard pattern, a backslash can be used to escape a wildcard
-character, but it is matched literally when no wildcards are present\&.
+character, but it is matched literally when no wildcards are present.
 .IP o 
-if the pattern contains a / (not counting a trailing /) or a "**",
+if the pattern contains a / (not counting a trailing /) or a \(lq**\(rq,
 then it is matched against the full pathname, including any leading
-directories\&. If the pattern doesn\&'t contain a / or a "**", then it is
-matched only against the final component of the filename\&.
-(Remember that the algorithm is applied recursively so "full filename"
+directories. If the pattern doesn't contain a / or a \(lq**\(rq, then it is
+matched only against the final component of the filename.
+(Remember that the algorithm is applied recursively so \(lqfull filename\(rq
 can actually be any portion of a path from the starting directory on
-down\&.)
+down.)
 .IP o 
-a trailing "dir_name/***" will match both the directory (as if
-"dir_name/" had been specified) and all the files in the directory
-(as if "dir_name/**" had been specified)\&.  (This behavior is new for
-version 2\&.6\&.7\&.)
+a trailing \(lqdir_name/***\(rq will match both the directory (as if
+\(lqdir_name/\(rq had been specified) and everything in the directory
+(as if \(lqdir_name/**\(rq had been specified).  This behavior was added in
+version 2.6.7.
 
 .PP 
 Note that, when using the \fB\-\-recursive\fP (\fB\-r\fP) option (which is implied by
 \fB\-a\fP), every subcomponent of every path is visited from the top down, so
-include/exclude patterns get applied recursively to each subcomponent\&'s
-full name (e\&.g\&. to include "/foo/bar/baz" the subcomponents "/foo" and
-"/foo/bar" must not be excluded)\&.
+include/exclude patterns get applied recursively to each subcomponent's
+full name (e.g. to include \(lq/foo/bar/baz\(rq the subcomponents \(lq/foo\(rq and
+\(lq/foo/bar\(rq must not be excluded).
 The exclude patterns actually short-circuit the directory traversal stage
-when rsync finds the files to send\&.  If a pattern excludes a particular
+when rsync finds the files to send.  If a pattern excludes a particular
 parent directory, it can render a deeper include pattern ineffectual
 because rsync did not descend through that excluded section of the
-hierarchy\&.  This is particularly important when using a trailing \&'*\&' rule\&.
-For instance, this won\&'t work:
+hierarchy.  This is particularly important when using a trailing \(oq*\(cq rule.
+For instance, this won't work:
 .PP 
 .RS 
 \f(CW+ /some/path/this\-file\-will\-not\-be\-found\fP
 .br 
 \f(CW+ /file\-is\-included\fP
 .br 
 \f(CW\- *\fP
 .br 
 .RE
 
 .PP 
-This fails because the parent directory "some" is excluded by the \&'*\&'
-rule, so rsync never visits any of the files in the "some" or "some/path"
-directories\&.  One solution is to ask for all directories in the hierarchy
-to be included by using a single rule: "+ */" (put it somewhere before the
-"\- *" rule), and perhaps use the \fB\-\-prune\-empty\-dirs\fP option\&.  Another
+This fails because the parent directory \(lqsome\(rq is excluded by the \(oq*\(cq
+rule, so rsync never visits any of the files in the \(lqsome\(rq or \(lqsome/path\(rq
+directories.  One solution is to ask for all directories in the hierarchy
+to be included by using a single rule: \(lq+ */\(rq (put it somewhere before the
+\(lq\- *\(rq rule), and perhaps use the \fB\-\-prune\-empty\-dirs\fP option.  Another
 solution is to add specific include rules for all
-the parent dirs that need to be visited\&.  For instance, this set of rules
+the parent dirs that need to be visited.  For instance, this set of rules
 works fine:
 .PP 
 .RS 
 \f(CW+ /some/\fP
 .br 
 \f(CW+ /some/path/\fP
@@ -2332,269 +2661,275 @@
 .RE
 
 .PP 
 Here are some examples of exclude/include matching:
 .PP 
 .IP o 
-"\- *\&.o" would exclude all filenames matching *\&.o
+\(lq\- *.o\(rq would exclude all names matching *.o
 .IP o 
-"\- /foo" would exclude a file (or directory) named foo in the
+\(lq\- /foo\(rq would exclude a file (or directory) named foo in the
 transfer-root directory
 .IP o 
-"\- foo/" would exclude any directory named foo
+\(lq\- foo/\(rq would exclude any directory named foo
 .IP o 
-"\- /foo/*/bar" would exclude any file named bar which is at two
+\(lq\- /foo/*/bar\(rq would exclude any file named bar which is at two
 levels below a directory named foo in the transfer-root directory
 .IP o 
-"\- /foo/**/bar" would exclude any file named bar two
+\(lq\- /foo/**/bar\(rq would exclude any file named bar two
 or more levels below a directory named foo in the transfer-root directory
 .IP o 
-The combination of "+ */", "+ *\&.c", and "\- *" would include all
+The combination of \(lq+ */\(rq, \(lq+ *.c\(rq, and \(lq\- *\(rq would include all
 directories and C source files but nothing else (see also the
 \fB\-\-prune\-empty\-dirs\fP option)
 .IP o 
-The combination of "+ foo/", "+ foo/bar\&.c", and "\- *" would include
-only the foo directory and foo/bar\&.c (the foo directory must be
-explicitly included or it would be excluded by the "*")
+The combination of \(lq+ foo/\(rq, \(lq+ foo/bar.c\(rq, and \(lq\- *\(rq would include
+only the foo directory and foo/bar.c (the foo directory must be
+explicitly included or it would be excluded by the \(lq*\(rq)
 
 .PP 
 .SH "MERGE-FILE FILTER RULES"
 
 .PP 
 You can merge whole files into your filter rules by specifying either a
-merge (\&.) or a dir-merge (:) filter rule (as introduced in the FILTER RULES
-section above)\&.
+merge (.) or a dir-merge (:) filter rule (as introduced in the FILTER RULES
+section above).
 .PP 
-There are two kinds of merged files -- single-instance (\&'\&.\&') and
-per-directory (\&':\&')\&.  A single-instance merge file is read one time, and
-its rules are incorporated into the filter list in the place of the "\&."
-rule\&.  For per-directory merge files, rsync will scan every directory that
+There are two kinds of merged files \(em single-instance (\(oq.\(cq) and
+per-directory (\(oq:\(cq).  A single-instance merge file is read one time, and
+its rules are incorporated into the filter list in the place of the \(lq.\(rq
+rule.  For per-directory merge files, rsync will scan every directory that
 it traverses for the named file, merging its contents when the file exists
-into the current list of inherited rules\&.  These per-directory rule files
+into the current list of inherited rules.  These per-directory rule files
 must be created on the sending side because it is the sending side that is
-being scanned for the available files to transfer\&.  These rule files may
+being scanned for the available files to transfer.  These rule files may
 also need to be transferred to the receiving side if you want them to
-affect what files don\&'t get deleted (see PER-DIRECTORY RULES AND DELETE
-below)\&.
+affect what files don't get deleted (see PER-DIRECTORY RULES AND DELETE
+below).
 .PP 
 Some examples:
 .PP 
 .RS 
-\f(CWmerge /etc/rsync/default\&.rules\fP
+\f(CWmerge /etc/rsync/default.rules\fP
 .br 
-\f(CW\&. /etc/rsync/default\&.rules\fP
+\f(CW. /etc/rsync/default.rules\fP
 .br 
-\f(CWdir\-merge \&.per\-dir\-filter\fP
+\f(CWdir\-merge .per\-dir\-filter\fP
 .br 
-\f(CWdir\-merge,n\- \&.non\-inherited\-per\-dir\-excludes\fP
+\f(CWdir\-merge,n\- .non\-inherited\-per\-dir\-excludes\fP
 .br 
-\f(CW:n\- \&.non\-inherited\-per\-dir\-excludes\fP
+\f(CW:n\- .non\-inherited\-per\-dir\-excludes\fP
 .br 
 .RE
 
 .PP 
 The following modifiers are accepted after a merge or dir-merge rule:
 .PP 
 .IP o 
 A \fB\-\fP specifies that the file should consist of only exclude
-patterns, with no other rule-parsing except for in-file comments\&.
+patterns, with no other rule-parsing except for in-file comments.
 .IP o 
 A \fB+\fP specifies that the file should consist of only include
-patterns, with no other rule-parsing except for in-file comments\&.
+patterns, with no other rule-parsing except for in-file comments.
 .IP o 
 A \fBC\fP is a way to specify that the file should be read in a
-CVS-compatible manner\&.  This turns on \&'n\&', \&'w\&', and \&'\-\&', but also
-allows the list-clearing token (!) to be specified\&.  If no filename is
-provided, "\&.cvsignore" is assumed\&.
+CVS-compatible manner.  This turns on \(oqn\(cq, \(oqw\(cq, and '\-', but also
+allows the list-clearing token (!) to be specified.  If no filename is
+provided, \(lq.cvsignore\(rq is assumed.
 .IP o 
-A \fBe\fP will exclude the merge-file name from the transfer; e\&.g\&.
-"dir-merge,e \&.rules" is like "dir-merge \&.rules" and "\- \&.rules"\&.
+A \fBe\fP will exclude the merge-file name from the transfer; e.g.
+\(lqdir-merge,e .rules\(rq is like \(lqdir-merge .rules\(rq and \(lq\- .rules\(rq.
 .IP o 
-An \fBn\fP specifies that the rules are not inherited by subdirectories\&.
+An \fBn\fP specifies that the rules are not inherited by subdirectories.
 .IP o 
 A \fBw\fP specifies that the rules are word-split on whitespace instead
-of the normal line-splitting\&.  This also turns off comments\&.  Note: the
+of the normal line-splitting.  This also turns off comments.  Note: the
 space that separates the prefix from the rule is treated specially, so
-"\- foo + bar" is parsed as two rules (assuming that prefix-parsing wasn\&'t
-also disabled)\&.
+\(lq\- foo + bar\(rq is parsed as two rules (assuming that prefix-parsing wasn't
+also disabled).
 .IP o 
-You may also specify any of the modifiers for the "+" or "\-" rules
+You may also specify any of the modifiers for the \(lq+\(rq or \(lq\-\(rq rules
 (below) in order to have the rules that are read in from the file
-default to having that modifier set\&.  For instance, "merge,\-/ \&.excl" would
-treat the contents of \&.excl as absolute-path excludes,
-while "dir-merge,s \&.filt" and ":sC" would each make all their
-per-directory rules apply only on the sending side\&.
+default to having that modifier set.  For instance, \(lqmerge,\-/ .excl\(rq would
+treat the contents of .excl as absolute-path excludes,
+while \(lqdir-merge,s .filt\(rq and \(lq:sC\(rq would each make all their
+per-directory rules apply only on the sending side.
 
 .PP 
-The following modifiers are accepted after a "+" or "\-":
+The following modifiers are accepted after a \(lq+\(rq or \(lq\-\(rq:
 .PP 
 .IP o 
-A "/" specifies that the include/exclude rule should be matched
-against the absolute pathname of the current item\&.  For example,
-"\-/ /etc/passwd" would exclude the passwd file any time the transfer
-was sending files from the "/etc" directory, and "\-/ subdir/foo"
-would always exclude "foo" when it is in a dir named "subdir", even
-if "foo" is at the root of the current transfer\&.
+A \fB/\fP specifies that the include/exclude rule should be matched
+against the absolute pathname of the current item.  For example,
+\(lq\-/ /etc/passwd\(rq would exclude the passwd file any time the transfer
+was sending files from the \(lq/etc\(rq directory, and \(lq\-/ subdir/foo\(rq
+would always exclude \(lqfoo\(rq when it is in a dir named \(lqsubdir\(rq, even
+if \(lqfoo\(rq is at the root of the current transfer.
 .IP o 
-A "!" specifies that the include/exclude should take effect if
-the pattern fails to match\&.  For instance, "\-! */" would exclude all
-non-directories\&.
+A \fB!\fP specifies that the include/exclude should take effect if
+the pattern fails to match.  For instance, \(lq\-! */\(rq would exclude all
+non-directories.
 .IP o 
 A \fBC\fP is used to indicate that all the global CVS-exclude rules
-should be inserted as excludes in place of the "\-C"\&.  No arg should
-follow\&.
+should be inserted as excludes in place of the \(lq\-C\(rq.  No arg should
+follow.
 .IP o 
 An \fBs\fP is used to indicate that the rule applies to the sending
-side\&.  When a rule affects the sending side, it prevents files from
-being transferred\&.  The default is for a rule to affect both sides
+side.  When a rule affects the sending side, it prevents files from
+being transferred.  The default is for a rule to affect both sides
 unless \fB\-\-delete\-excluded\fP was specified, in which case default rules
-become sender-side only\&.  See also the hide (H) and show (S) rules,
-which are an alternate way to specify sending-side includes/excludes\&.
+become sender-side only.  See also the hide (H) and show (S) rules,
+which are an alternate way to specify sending-side includes/excludes.
 .IP o 
 An \fBr\fP is used to indicate that the rule applies to the receiving
-side\&.  When a rule affects the receiving side, it prevents files from
-being deleted\&.  See the \fBs\fP modifier for more info\&.  See also the
+side.  When a rule affects the receiving side, it prevents files from
+being deleted.  See the \fBs\fP modifier for more info.  See also the
 protect (P) and risk (R) rules, which are an alternate way to
-specify receiver-side includes/excludes\&.
+specify receiver-side includes/excludes.
+.IP o 
+A \fBp\fP indicates that a rule is perishable, meaning that it is
+ignored in directories that are being deleted.  For instance, the \fB\-C\fP
+option's default rules that exclude things like \(lqCVS\(rq and \(lq*.o\(rq are
+marked as perishable, and will not prevent a directory that was removed
+on the source from being deleted on the destination.
 
 .PP 
 Per-directory rules are inherited in all subdirectories of the directory
-where the merge-file was found unless the \&'n\&' modifier was used\&.  Each
-subdirectory\&'s rules are prefixed to the inherited per-directory rules
+where the merge-file was found unless the \(oqn\(cq modifier was used.  Each
+subdirectory's rules are prefixed to the inherited per-directory rules
 from its parents, which gives the newest rules a higher priority than the
-inherited rules\&.  The entire set of dir-merge rules are grouped together in
+inherited rules.  The entire set of dir-merge rules are grouped together in
 the spot where the merge-file was specified, so it is possible to override
 dir-merge rules via a rule that got specified earlier in the list of global
-rules\&.  When the list-clearing rule ("!") is read from a per-directory
-file, it only clears the inherited rules for the current merge file\&.
+rules.  When the list-clearing rule (\(lq!\(rq) is read from a per-directory
+file, it only clears the inherited rules for the current merge file.
 .PP 
 Another way to prevent a single rule from a dir-merge file from being inherited is to
-anchor it with a leading slash\&.  Anchored rules in a per-directory
-merge-file are relative to the merge-file\&'s directory, so a pattern "/foo"
-would only match the file "foo" in the directory where the dir-merge filter
-file was found\&.
+anchor it with a leading slash.  Anchored rules in a per-directory
+merge-file are relative to the merge-file's directory, so a pattern \(lq/foo\(rq
+would only match the file \(lqfoo\(rq in the directory where the dir-merge filter
+file was found.
 .PP 
-Here\&'s an example filter file which you\&'d specify via \fB\-\-filter="\&. file":\fP
+Here's an example filter file which you'd specify via \fB\-\-filter=". file":\fP
 .PP 
 .RS 
-\f(CWmerge /home/user/\&.global\-filter\fP
+\f(CWmerge /home/user/.global\-filter\fP
 .br 
-\f(CW\- *\&.gz\fP
+\f(CW\- *.gz\fP
 .br 
-\f(CWdir\-merge \&.rules\fP
+\f(CWdir\-merge .rules\fP
 .br 
-\f(CW+ *\&.[ch]\fP
+\f(CW+ *.[ch]\fP
 .br 
-\f(CW\- *\&.o\fP
+\f(CW\- *.o\fP
 .br 
 .RE
 
 .PP 
-This will merge the contents of the /home/user/\&.global\-filter file at the
-start of the list and also turns the "\&.rules" filename into a per-directory
-filter file\&.  All rules read in prior to the start of the directory scan
-follow the global anchoring rules (i\&.e\&. a leading slash matches at the root
-of the transfer)\&.
+This will merge the contents of the /home/user/.global\-filter file at the
+start of the list and also turns the \(lq.rules\(rq filename into a per-directory
+filter file.  All rules read in prior to the start of the directory scan
+follow the global anchoring rules (i.e. a leading slash matches at the root
+of the transfer).
 .PP 
 If a per-directory merge-file is specified with a path that is a parent
 directory of the first transfer directory, rsync will scan all the parent
 dirs from that starting point to the transfer directory for the indicated
-per-directory file\&.  For instance, here is a common filter (see \fB\-F\fP):
+per-directory file.  For instance, here is a common filter (see \fB\-F\fP):
 .PP 
 .RS 
-\f(CW\-\-filter=\&': /\&.rsync\-filter\&'\fP
+\f(CW\-\-filter=': /.rsync\-filter'\fP
 .RE
 
 .PP 
-That rule tells rsync to scan for the file \&.rsync\-filter in all
+That rule tells rsync to scan for the file .rsync\-filter in all
 directories from the root down through the parent directory of the
 transfer prior to the start of the normal directory scan of the file in
-the directories that are sent as a part of the transfer\&.  (Note: for an
-rsync daemon, the root is always the same as the module\&'s "path"\&.)
+the directories that are sent as a part of the transfer.  (Note: for an
+rsync daemon, the root is always the same as the module's \(lqpath\(rq.)
 .PP 
 Some examples of this pre-scanning for per-directory files:
 .PP 
 .RS 
 \f(CWrsync \-avF /src/path/ /dest/dir\fP
 .br 
-\f(CWrsync \-av \-\-filter=\&': \&.\&./\&.\&./\&.rsync\-filter\&' /src/path/ /dest/dir\fP
+\f(CWrsync \-av \-\-filter=': ../../.rsync\-filter' /src/path/ /dest/dir\fP
 .br 
-\f(CWrsync \-av \-\-filter=\&': \&.rsync\-filter\&' /src/path/ /dest/dir\fP
+\f(CWrsync \-av \-\-filter=': .rsync\-filter' /src/path/ /dest/dir\fP
 .br 
 .RE
 
 .PP 
-The first two commands above will look for "\&.rsync\-filter" in "/" and
-"/src" before the normal scan begins looking for the file in "/src/path"
-and its subdirectories\&.  The last command avoids the parent-dir scan
-and only looks for the "\&.rsync\-filter" files in each directory that is
-a part of the transfer\&.
+The first two commands above will look for \(lq.rsync\-filter\(rq in \(lq/\(rq and
+\(lq/src\(rq before the normal scan begins looking for the file in \(lq/src/path\(rq
+and its subdirectories.  The last command avoids the parent-dir scan
+and only looks for the \(lq.rsync\-filter\(rq files in each directory that is
+a part of the transfer.
 .PP 
-If you want to include the contents of a "\&.cvsignore" in your patterns,
-you should use the rule ":C", which creates a dir-merge of the \&.cvsignore
-file, but parsed in a CVS-compatible manner\&.  You can
-use this to affect where the \fB\-\-cvs\-exclude\fP (\fB\-C\fP) option\&'s inclusion of the
-per-directory \&.cvsignore file gets placed into your rules by putting the
-":C" wherever you like in your filter rules\&.  Without this, rsync would
-add the dir-merge rule for the \&.cvsignore file at the end of all your other
-rules (giving it a lower priority than your command-line rules)\&.  For
+If you want to include the contents of a \(lq.cvsignore\(rq in your patterns,
+you should use the rule \(lq:C\(rq, which creates a dir-merge of the .cvsignore
+file, but parsed in a CVS-compatible manner.  You can
+use this to affect where the \fB\-\-cvs\-exclude\fP (\fB\-C\fP) option's inclusion of the
+per-directory .cvsignore file gets placed into your rules by putting the
+\(lq:C\(rq wherever you like in your filter rules.  Without this, rsync would
+add the dir-merge rule for the .cvsignore file at the end of all your other
+rules (giving it a lower priority than your command-line rules).  For
 example:
 .PP 
 .RS 
-\f(CWcat <<EOT | rsync \-avC \-\-filter=\&'\&. \-\&' a/ b\fP
+\f(CWcat <<EOT | rsync \-avC \-\-filter='. \-' a/ b\fP
 .br 
-\f(CW+ foo\&.o\fP
+\f(CW+ foo.o\fP
 .br 
 \f(CW:C\fP
 .br 
-\f(CW\- *\&.old\fP
+\f(CW\- *.old\fP
 .br 
 \f(CWEOT\fP
 .br 
-\f(CWrsync \-avC \-\-include=foo\&.o \-f :C \-\-exclude=\&'*\&.old\&' a/ b\fP
+\f(CWrsync \-avC \-\-include=foo.o \-f :C \-\-exclude='*.old' a/ b\fP
 .br 
 .RE
 
 .PP 
-Both of the above rsync commands are identical\&.  Each one will merge all
-the per-directory \&.cvsignore rules in the middle of the list rather than
-at the end\&.  This allows their dir-specific rules to supersede the rules
-that follow the :C instead of being subservient to all your rules\&.  To
-affect the other CVS exclude rules (i\&.e\&. the default list of exclusions,
-the contents of $HOME/\&.cvsignore, and the value of $CVSIGNORE) you should
-omit the \fB\-C\fP command-line option and instead insert a "\-C" rule into
-your filter rules; e\&.g\&. "\-\-filter=\-C"\&.
+Both of the above rsync commands are identical.  Each one will merge all
+the per-directory .cvsignore rules in the middle of the list rather than
+at the end.  This allows their dir-specific rules to supersede the rules
+that follow the :C instead of being subservient to all your rules.  To
+affect the other CVS exclude rules (i.e. the default list of exclusions,
+the contents of $HOME/.cvsignore, and the value of $CVSIGNORE) you should
+omit the \fB\-C\fP command-line option and instead insert a \(lq\-C\(rq rule into
+your filter rules; e.g. \(lq\fB\-\-filter=\-C\fP\(rq.
 .PP 
 .SH "LIST-CLEARING FILTER RULE"
 
 .PP 
-You can clear the current include/exclude list by using the "!" filter
-rule (as introduced in the FILTER RULES section above)\&.  The "current"
+You can clear the current include/exclude list by using the \(lq!\(rq filter
+rule (as introduced in the FILTER RULES section above).  The \(lqcurrent\(rq
 list is either the global list of rules (if the rule is encountered while
 parsing the filter options) or a set of per-directory rules (which are
 inherited in their own sub-list, so a subdirectory can use this to clear
-out the parent\&'s rules)\&.
+out the parent's rules).
 .PP 
 .SH "ANCHORING INCLUDE/EXCLUDE PATTERNS"
 
 .PP 
 As mentioned earlier, global include/exclude patterns are anchored at the
-"root of the transfer" (as opposed to per-directory patterns, which are
-anchored at the merge-file\&'s directory)\&.  If you think of the transfer as
+\(lqroot of the transfer\(rq (as opposed to per-directory patterns, which are
+anchored at the merge-file's directory).  If you think of the transfer as
 a subtree of names that are being sent from sender to receiver, the
 transfer-root is where the tree starts to be duplicated in the destination
-directory\&.  This root governs where patterns that start with a / match\&.
+directory.  This root governs where patterns that start with a / match.
 .PP 
 Because the matching is relative to the transfer-root, changing the
 trailing slash on a source path or changing your use of the \fB\-\-relative\fP
 option affects the path you need to use in your matching (in addition to
 changing how much of the file tree is duplicated on the destination
-host)\&.  The following examples demonstrate this\&.
+host).  The following examples demonstrate this.
 .PP 
-Let\&'s say that we want to match two source files, one with an absolute
-path of "/home/me/foo/bar", and one with a path of "/home/you/bar/baz"\&.
+Let's say that we want to match two source files, one with an absolute
+path of \(lq/home/me/foo/bar\(rq, and one with a path of \(lq/home/you/bar/baz\(rq.
 Here is how the various command choices differ for a 2-source transfer:
 .PP 
 .RS 
 Example cmd: rsync \-a /home/me /home/you /dest 
 .br 
 +/\- pattern: /me/foo/bar 
@@ -2608,15 +2943,15 @@
 .RE
 
 .PP 
 .RS 
 Example cmd: rsync \-a /home/me/ /home/you/ /dest 
 .br 
-+/\- pattern: /foo/bar               (note missing "me") 
++/\- pattern: /foo/bar               (note missing \(lqme\(rq) 
 .br 
-+/\- pattern: /bar/baz               (note missing "you") 
++/\- pattern: /bar/baz               (note missing \(lqyou\(rq) 
 .br 
 Target file: /dest/foo/bar 
 .br 
 Target file: /dest/bar/baz 
 .br 
 .RE
@@ -2649,115 +2984,115 @@
 .br 
 .RE
 
 .PP 
 The easiest way to see what name you should filter is to just
 look at the output when using \fB\-\-verbose\fP and put a / in front of the name
-(use the \fB\-\-dry\-run\fP option if you\&'re not yet ready to copy any files)\&.
+(use the \fB\-\-dry\-run\fP option if you're not yet ready to copy any files).
 .PP 
 .SH "PER-DIRECTORY RULES AND DELETE"
 
 .PP 
 Without a delete option, per-directory rules are only relevant on the
 sending side, so you can feel free to exclude the merge files themselves
-without affecting the transfer\&.  To make this easy, the \&'e\&' modifier adds
+without affecting the transfer.  To make this easy, the \(oqe\(cq modifier adds
 this exclude for you, as seen in these two equivalent commands:
 .PP 
 .RS 
-\f(CWrsync \-av \-\-filter=\&': \&.excl\&' \-\-exclude=\&.excl host:src/dir /dest\fP
+\f(CWrsync \-av \-\-filter=': .excl' \-\-exclude=.excl host:src/dir /dest\fP
 .br 
-\f(CWrsync \-av \-\-filter=\&':e \&.excl\&' host:src/dir /dest\fP
+\f(CWrsync \-av \-\-filter=':e .excl' host:src/dir /dest\fP
 .br 
 .RE
 
 .PP 
 However, if you want to do a delete on the receiving side AND you want some
-files to be excluded from being deleted, you\&'ll need to be sure that the
-receiving side knows what files to exclude\&.  The easiest way is to include
+files to be excluded from being deleted, you'll need to be sure that the
+receiving side knows what files to exclude.  The easiest way is to include
 the per-directory merge files in the transfer and use \fB\-\-delete\-after\fP,
 because this ensures that the receiving side gets all the same exclude
 rules as the sending side before it tries to delete anything:
 .PP 
 .RS 
 \f(CWrsync \-avF \-\-delete\-after host:src/dir /dest\fP
 .RE
 
 .PP 
-However, if the merge files are not a part of the transfer, you\&'ll need to
-either specify some global exclude rules (i\&.e\&. specified on the command
-line), or you\&'ll need to maintain your own per-directory merge files on
-the receiving side\&.  An example of the first is this (assume that the
-remote \&.rules files exclude themselves):
+However, if the merge files are not a part of the transfer, you'll need to
+either specify some global exclude rules (i.e. specified on the command
+line), or you'll need to maintain your own per-directory merge files on
+the receiving side.  An example of the first is this (assume that the
+remote .rules files exclude themselves):
 .PP 
 .nf 
-rsync \-av \-\-filter=\&': \&.rules\&' \-\-filter=\&'\&. /my/extra\&.rules\&'
+rsync \-av \-\-filter=': .rules' \-\-filter='. /my/extra.rules'
    \-\-delete host:src/dir /dest
 .fi 
 
 .PP 
-In the above example the extra\&.rules file can affect both sides of the
+In the above example the extra.rules file can affect both sides of the
 transfer, but (on the sending side) the rules are subservient to the rules
-merged from the \&.rules files because they were specified after the
-per-directory merge rule\&.
+merged from the .rules files because they were specified after the
+per-directory merge rule.
 .PP 
-In one final example, the remote side is excluding the \&.rsync\-filter
-files from the transfer, but we want to use our own \&.rsync\-filter files
-to control what gets deleted on the receiving side\&.  To do this we must
-specifically exclude the per-directory merge files (so that they don\&'t get
+In one final example, the remote side is excluding the .rsync\-filter
+files from the transfer, but we want to use our own .rsync\-filter files
+to control what gets deleted on the receiving side.  To do this we must
+specifically exclude the per-directory merge files (so that they don't get
 deleted) and then put rules into the local files to control what else
-should not get deleted\&.  Like one of these commands:
+should not get deleted.  Like one of these commands:
 .PP 
 .nf 
-    rsync \-av \-\-filter=\&':e /\&.rsync\-filter\&' \-\-delete \e 
+    rsync \-av \-\-filter=':e /.rsync\-filter' \-\-delete \e 
         host:src/dir /dest
     rsync \-avFF \-\-delete host:src/dir /dest
 .fi 
 
 .PP 
 .SH "BATCH MODE"
 
 .PP 
 Batch mode can be used to apply the same set of updates to many
-identical systems\&. Suppose one has a tree which is replicated on a
-number of hosts\&.  Now suppose some changes have been made to this
+identical systems. Suppose one has a tree which is replicated on a
+number of hosts.  Now suppose some changes have been made to this
 source tree and those changes need to be propagated to the other
-hosts\&. In order to do this using batch mode, rsync is run with the
+hosts. In order to do this using batch mode, rsync is run with the
 write-batch option to apply the changes made to the source tree to one
-of the destination trees\&.  The write-batch option causes the rsync
-client to store in a "batch file" all the information needed to repeat
-this operation against other, identical destination trees\&.
+of the destination trees.  The write-batch option causes the rsync
+client to store in a \(lqbatch file\(rq all the information needed to repeat
+this operation against other, identical destination trees.
 .PP 
 To apply the recorded changes to another destination tree, run rsync
 with the read-batch option, specifying the name of the same batch
-file, and the destination tree\&.  Rsync updates the destination tree
-using the information stored in the batch file\&.
+file, and the destination tree.  Rsync updates the destination tree
+using the information stored in the batch file.
 .PP 
 For convenience, one additional file is creating when the write-batch
-option is used\&.  This file\&'s name is created by appending
-"\&.sh" to the batch filename\&.  The \&.sh file contains
+option is used.  This file's name is created by appending
+\(lq.sh\(rq to the batch filename.  The .sh file contains
 a command-line suitable for updating a destination tree using that
-batch file\&. It can be executed using a Bourne (or Bourne-like) shell,
+batch file. It can be executed using a Bourne (or Bourne-like) shell,
 optionally
 passing in an alternate destination tree pathname which is then used
-instead of the original path\&. This is useful when the destination tree
-path differs from the original destination tree path\&.
+instead of the original path. This is useful when the destination tree
+path differs from the original destination tree path.
 .PP 
 Generating the batch file once saves having to perform the file
 status, checksum, and data block generation more than once when
-updating multiple destination trees\&. Multicast transport protocols can
+updating multiple destination trees. Multicast transport protocols can
 be used to transfer the batch update files in parallel to many hosts
-at once, instead of sending the same data to every host individually\&.
+at once, instead of sending the same data to every host individually.
 .PP 
 Examples:
 .PP 
 .RS 
 \f(CW$ rsync \-\-write\-batch=foo \-a host:/source/dir/ /adest/dir/\fP
 .br 
 \f(CW$ scp foo* remote:\fP
 .br 
-\f(CW$ ssh remote \&./foo\&.sh /bdest/dir/\fP
+\f(CW$ ssh remote ./foo.sh /bdest/dir/\fP
 .br 
 .RE
 
 .PP 
 .RS 
 \f(CW$ rsync \-\-write\-batch=foo \-a /source/dir/ /adest/dir/\fP
@@ -2765,156 +3100,156 @@
 \f(CW$ ssh remote rsync \-\-read\-batch=\- \-a /bdest/dir/ <foo\fP
 .br 
 .RE
 
 .PP 
 In these examples, rsync is used to update /adest/dir/ from /source/dir/
-and the information to repeat this operation is stored in "foo" and
-"foo\&.sh"\&.  The host "remote" is then updated with the batched data going
-into the directory /bdest/dir\&.  The differences between the two examples
+and the information to repeat this operation is stored in \(lqfoo\(rq and
+\(lqfoo.sh\(rq.  The host \(lqremote\(rq is then updated with the batched data going
+into the directory /bdest/dir.  The differences between the two examples
 reveals some of the flexibility you have in how you deal with batches:
 .PP 
 .IP o 
-The first example shows that the initial copy doesn\&'t have to be
-local -- you can push or pull data to/from a remote host using either the
-remote-shell syntax or rsync daemon syntax, as desired\&.
+The first example shows that the initial copy doesn't have to be
+local \(em you can push or pull data to/from a remote host using either the
+remote-shell syntax or rsync daemon syntax, as desired.
 .IP o 
-The first example uses the created "foo\&.sh" file to get the right
-rsync options when running the read-batch command on the remote host\&.
+The first example uses the created \(lqfoo.sh\(rq file to get the right
+rsync options when running the read-batch command on the remote host.
 .IP o 
 The second example reads the batch data via standard input so that
-the batch file doesn\&'t need to be copied to the remote machine first\&.
-This example avoids the foo\&.sh script because it needed to use a modified
+the batch file doesn't need to be copied to the remote machine first.
+This example avoids the foo.sh script because it needed to use a modified
 \fB\-\-read\-batch\fP option, but you could edit the script file if you wished to
 make use of it (just be sure that no other option is trying to use
-standard input, such as the "\fB\-\-exclude\-from=\-\fP" option)\&.
+standard input, such as the \(lq\fB\-\-exclude\-from=\-\fP\(rq option).
 
 .PP 
 Caveats:
 .PP 
 The read-batch option expects the destination tree that it is updating
 to be identical to the destination tree that was used to create the
-batch update fileset\&.  When a difference between the destination trees
+batch update fileset.  When a difference between the destination trees
 is encountered the update might be discarded with a warning (if the file
 appears to be up-to-date already) or the file-update may be attempted
 and then, if the file fails to verify, the update discarded with an
-error\&.  This means that it should be safe to re-run a read-batch operation
-if the command got interrupted\&.  If you wish to force the batched-update to
-always be attempted regardless of the file\&'s size and date, use the \fB\-I\fP
-option (when reading the batch)\&.
+error.  This means that it should be safe to re-run a read-batch operation
+if the command got interrupted.  If you wish to force the batched-update to
+always be attempted regardless of the file's size and date, use the \fB\-I\fP
+option (when reading the batch).
 If an error occurs, the destination tree will probably be in a
-partially updated state\&. In that case, rsync can
+partially updated state. In that case, rsync can
 be used in its regular (non-batch) mode of operation to fix up the
-destination tree\&.
+destination tree.
 .PP 
 The rsync version used on all destinations must be at least as new as the
-one used to generate the batch file\&.  Rsync will die with an error if the
+one used to generate the batch file.  Rsync will die with an error if the
 protocol version in the batch file is too new for the batch-reading rsync
-to handle\&.  See also the \fB\-\-protocol\fP option for a way to have the
-creating rsync generate a batch file that an older rsync can understand\&.
-(Note that batch files changed format in version 2\&.6\&.3, so mixing versions
-older than that with newer versions will not work\&.)
+to handle.  See also the \fB\-\-protocol\fP option for a way to have the
+creating rsync generate a batch file that an older rsync can understand.
+(Note that batch files changed format in version 2.6.3, so mixing versions
+older than that with newer versions will not work.)
 .PP 
 When reading a batch file, rsync will force the value of certain options
-to match the data in the batch file if you didn\&'t set them to the same
-as the batch-writing command\&.  Other options can (and should) be changed\&.
+to match the data in the batch file if you didn't set them to the same
+as the batch-writing command.  Other options can (and should) be changed.
 For instance \fB\-\-write\-batch\fP changes to \fB\-\-read\-batch\fP,
 \fB\-\-files\-from\fP is dropped, and the
 \fB\-\-filter\fP/\fB\-\-include\fP/\fB\-\-exclude\fP options are not needed unless
-one of the \fB\-\-delete\fP options is specified\&.
+one of the \fB\-\-delete\fP options is specified.
 .PP 
-The code that creates the BATCH\&.sh file transforms any filter/include/exclude
-options into a single list that is appended as a "here" document to the
-shell script file\&.  An advanced user can use this to modify the exclude
-list if a change in what gets deleted by \fB\-\-delete\fP is desired\&.  A normal
+The code that creates the BATCH.sh file transforms any filter/include/exclude
+options into a single list that is appended as a \(lqhere\(rq document to the
+shell script file.  An advanced user can use this to modify the exclude
+list if a change in what gets deleted by \fB\-\-delete\fP is desired.  A normal
 user can ignore this detail and just use the shell script as an easy way
-to run the appropriate \fB\-\-read\-batch\fP command for the batched data\&.
+to run the appropriate \fB\-\-read\-batch\fP command for the batched data.
 .PP 
-The original batch mode in rsync was based on "rsync+", but the latest
-version uses a new implementation\&.
+The original batch mode in rsync was based on \(lqrsync+\(rq, but the latest
+version uses a new implementation.
 .PP 
 .SH "SYMBOLIC LINKS"
 
 .PP 
 Three basic behaviors are possible when rsync encounters a symbolic
-link in the source directory\&.
+link in the source directory.
 .PP 
-By default, symbolic links are not transferred at all\&.  A message
-"skipping non-regular" file is emitted for any symlinks that exist\&.
+By default, symbolic links are not transferred at all.  A message
+\(lqskipping non-regular\(rq file is emitted for any symlinks that exist.
 .PP 
 If \fB\-\-links\fP is specified, then symlinks are recreated with the same
-target on the destination\&.  Note that \fB\-\-archive\fP implies
-\fB\-\-links\fP\&.
+target on the destination.  Note that \fB\-\-archive\fP implies
+\fB\-\-links\fP.
 .PP 
-If \fB\-\-copy\-links\fP is specified, then symlinks are "collapsed" by
-copying their referent, rather than the symlink\&.
+If \fB\-\-copy\-links\fP is specified, then symlinks are \(lqcollapsed\(rq by
+copying their referent, rather than the symlink.
 .PP 
-rsync also distinguishes "safe" and "unsafe" symbolic links\&.  An
+rsync also distinguishes \(lqsafe\(rq and \(lqunsafe\(rq symbolic links.  An
 example where this might be used is a web site mirror that wishes
 ensure the rsync module they copy does not include symbolic links to
-\fB/etc/passwd\fP in the public section of the site\&.  Using
+\fB/etc/passwd\fP in the public section of the site.  Using
 \fB\-\-copy\-unsafe\-links\fP will cause any links to be copied as the file
-they point to on the destination\&.  Using \fB\-\-safe\-links\fP will cause
-unsafe links to be omitted altogether\&.  (Note that you must specify
-\fB\-\-links\fP for \fB\-\-safe\-links\fP to have any effect\&.)
+they point to on the destination.  Using \fB\-\-safe\-links\fP will cause
+unsafe links to be omitted altogether.  (Note that you must specify
+\fB\-\-links\fP for \fB\-\-safe\-links\fP to have any effect.)
 .PP 
 Symbolic links are considered unsafe if they are absolute symlinks
-(start with \fB/\fP), empty, or if they contain enough \fB"\&.\&."\fP
-components to ascend from the directory being copied\&.
+(start with \fB/\fP), empty, or if they contain enough \(lq..\(rq
+components to ascend from the directory being copied.
 .PP 
-Here\&'s a summary of how the symlink options are interpreted\&.  The list is
-in order of precedence, so if your combination of options isn\&'t mentioned,
+Here's a summary of how the symlink options are interpreted.  The list is
+in order of precedence, so if your combination of options isn't mentioned,
 use the first line that is a complete subset of your options:
 .PP 
 .IP "\fB\-\-copy\-links\fP"
 Turn all symlinks into normal files (leaving no
-symlinks for any other options to affect)\&.
+symlinks for any other options to affect).
 .PP 
 .IP "\fB\-\-links \-\-copy\-unsafe\-links\fP"
 Turn all unsafe symlinks into files
-and duplicate all safe symlinks\&.
+and duplicate all safe symlinks.
 .PP 
 .IP "\fB\-\-copy\-unsafe\-links\fP"
 Turn all unsafe symlinks into files, noisily
-skip all safe symlinks\&.
+skip all safe symlinks.
 .PP 
 .IP "\fB\-\-links \-\-safe\-links\fP"
 Duplicate safe symlinks and skip unsafe
-ones\&.
+ones.
 .PP 
 .IP "\fB\-\-links\fP"
-Duplicate all symlinks\&.
+Duplicate all symlinks.
 .PP 
 .SH "DIAGNOSTICS"
 
 .PP 
 rsync occasionally produces error messages that may seem a little
-cryptic\&. The one that seems to cause the most confusion is "protocol
-version mismatch -- is your shell clean?"\&.
+cryptic. The one that seems to cause the most confusion is \(lqprotocol
+version mismatch \(em is your shell clean?\(rq.
 .PP 
 This message is usually caused by your startup scripts or remote shell
 facility producing unwanted garbage on the stream that rsync is using
-for its transport\&. The way to diagnose this problem is to run your
+for its transport. The way to diagnose this problem is to run your
 remote shell like this:
 .PP 
 .RS 
-\f(CWssh remotehost /bin/true > out\&.dat\fP
+\f(CWssh remotehost /bin/true > out.dat\fP
 .RE
 
 .PP 
-then look at out\&.dat\&. If everything is working correctly then out\&.dat
-should be a zero length file\&. If you are getting the above error from
-rsync then you will probably find that out\&.dat contains some text or
-data\&. Look at the contents and try to work out what is producing
-it\&. The most common cause is incorrectly configured shell startup
-scripts (such as \&.cshrc or \&.profile) that contain output statements
-for non-interactive logins\&.
+then look at out.dat. If everything is working correctly then out.dat
+should be a zero length file. If you are getting the above error from
+rsync then you will probably find that out.dat contains some text or
+data. Look at the contents and try to work out what is producing
+it. The most common cause is incorrectly configured shell startup
+scripts (such as .cshrc or .profile) that contain output statements
+for non-interactive logins.
 .PP 
 If you are having trouble debugging filter patterns, then
-try specifying the \fB\-vv\fP option\&.  At this level of verbosity rsync will
-show why each individual file is included or excluded\&.
+try specifying the \fB\-vv\fP option.  At this level of verbosity rsync will
+show why each individual file is included or excluded.
 .PP 
 .SH "EXIT VALUES"
 
 .PP 
 .IP "\fB0\fP"
 Success
@@ -2925,13 +3260,13 @@
 .IP "\fB3\fP"
 Errors selecting input/output files, dirs
 .IP "\fB4\fP"
 Requested action not supported: an attempt
 was made to manipulate 64-bit files on a platform that cannot support
 them; or an option was specified that is supported by the client and
-not by the server\&.
+not by the server.
 .IP "\fB5\fP"
 Error starting client-server protocol
 .IP "\fB6\fP"
 Daemon unable to append to log-file
 .IP "\fB10\fP"
 Error in socket I/O
@@ -2955,117 +3290,125 @@
 .IP "\fB24\fP"
 Partial transfer due to vanished source files
 .IP "\fB25\fP"
 The \-\-max\-delete limit stopped deletions
 .IP "\fB30\fP"
 Timeout in data send/receive
+.IP "\fB35\fP"
+Timeout waiting for daemon connection
 
 .PP 
 .SH "ENVIRONMENT VARIABLES"
 
 .PP 
 .IP "\fBCVSIGNORE\fP"
 The CVSIGNORE environment variable supplements any
-ignore patterns in \&.cvsignore files\&. See the \fB\-\-cvs\-exclude\fP option for
-more details\&.
+ignore patterns in .cvsignore files. See the \fB\-\-cvs\-exclude\fP option for
+more details.
+.IP "\fBRSYNC_ICONV\fP"
+Specify a default \fB\-\-iconv\fP setting using this
+environment variable.
 .IP "\fBRSYNC_RSH\fP"
 The RSYNC_RSH environment variable allows you to
-override the default shell used as the transport for rsync\&.  Command line
-options are permitted after the command name, just as in the \fB\-e\fP option\&.
+override the default shell used as the transport for rsync.  Command line
+options are permitted after the command name, just as in the \fB\-e\fP option.
 .IP "\fBRSYNC_PROXY\fP"
 The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
-rsync daemon\&. You should set RSYNC_PROXY to a hostname:port pair\&.
+rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
 .IP "\fBRSYNC_PASSWORD\fP"
 Setting RSYNC_PASSWORD to the required
 password allows you to run authenticated rsync connections to an rsync
-daemon without user intervention\&. Note that this does not supply a
-password to a shell transport such as ssh\&.
+daemon without user intervention. Note that this does not supply a
+password to a remote shell transport such as ssh; to learn how to do that,
+consult the remote shell's documentation.
 .IP "\fBUSER\fP or \fBLOGNAME\fP"
 The USER or LOGNAME environment variables
-are used to determine the default username sent to an rsync daemon\&.
-If neither is set, the username defaults to "nobody"\&.
+are used to determine the default username sent to an rsync daemon.
+If neither is set, the username defaults to \(lqnobody\(rq.
 .IP "\fBHOME\fP"
-The HOME environment variable is used to find the user\&'s
-default \&.cvsignore file\&.
+The HOME environment variable is used to find the user's
+default .cvsignore file.
 
 .PP 
 .SH "FILES"
 
 .PP 
-/etc/rsyncd\&.conf or rsyncd\&.conf
+/etc/rsyncd.conf or rsyncd.conf
 .PP 
 .SH "SEE ALSO"
 
 .PP 
-\fBrsyncd\&.conf\fP(5)
+\fBrsyncd.conf\fP(5)
 .PP 
 .SH "BUGS"
 
 .PP 
 times are transferred as *nix time_t values
 .PP 
 When transferring to FAT filesystems rsync may re-sync
-unmodified files\&.
-See the comments on the \fB\-\-modify\-window\fP option\&.
+unmodified files.
+See the comments on the \fB\-\-modify\-window\fP option.
 .PP 
-file permissions, devices, etc\&. are transferred as native numerical
+file permissions, devices, etc. are transferred as native numerical
 values
 .PP 
 see also the comments on the \fB\-\-delete\fP option
 .PP 
-Please report bugs! See the website at
-http://rsync\&.samba\&.org/
+Please report bugs! See the web site at
+http://rsync.samba.org/
 .PP 
 .SH "VERSION"
 
 .PP 
-This man page is current for version 2\&.6\&.9 of rsync\&.
+This man page is current for version 3.0.0 of rsync.
 .PP 
 .SH "INTERNAL OPTIONS"
 
 .PP 
 The options \fB\-\-server\fP and \fB\-\-sender\fP are used internally by rsync,
-and should never be typed by a user under normal circumstances\&.  Some
+and should never be typed by a user under normal circumstances.  Some
 awareness of these options may be needed in certain scenarios, such as
-when setting up a login that can only run an rsync command\&.  For instance,
+when setting up a login that can only run an rsync command.  For instance,
 the support directory of the rsync distribution has an example script
 named rrsync (for restricted rsync) that can be used with a restricted
-ssh login\&.
+ssh login.
 .PP 
 .SH "CREDITS"
 
 .PP 
-rsync is distributed under the GNU public license\&.  See the file
-COPYING for details\&.
+rsync is distributed under the GNU public license.  See the file
+COPYING for details.
 .PP 
 A WEB site is available at
-http://rsync\&.samba\&.org/\&.  The site
+http://rsync.samba.org/.  The site
 includes an FAQ-O-Matic which may cover questions unanswered by this
-manual page\&.
+manual page.
 .PP 
 The primary ftp site for rsync is
-ftp://rsync\&.samba\&.org/pub/rsync\&.
+ftp://rsync.samba.org/pub/rsync.
 .PP 
-We would be delighted to hear from you if you like this program\&.
+We would be delighted to hear from you if you like this program.
+Please contact the mailing-list at rsync@lists.samba.org.
 .PP 
 This program uses the excellent zlib compression library written by
-Jean-loup Gailly and Mark Adler\&.
+Jean-loup Gailly and Mark Adler.
 .PP 
 .SH "THANKS"
 
 .PP 
-Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
-and David Bell for helpful suggestions, patches and testing of rsync\&.
-I\&'ve probably missed some people, my apologies if I have\&.
+Especial thanks go out to: John Van Essen, Matt McCutchen, Wesley W. Terpstra,
+David Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, and our
+gone-but-not-forgotten compadre, J.W. Schultz.
 .PP 
-Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer,
-Martin Pool, Wayne Davison, J\&.W\&. Schultz\&.
+Thanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
+and David Bell.  I've probably missed some people, my apologies if I have.
 .PP 
 .SH "AUTHOR"
 
 .PP 
-rsync was originally written by Andrew Tridgell and Paul Mackerras\&.
-Many people have later contributed to it\&.
+rsync was originally written by Andrew Tridgell and Paul Mackerras.
+Many people have later contributed to it.  It is currently maintained
+by Wayne Davison.
 .PP 
 Mailing lists for support and development are available at
-http://lists\&.samba\&.org
+http://lists.samba.org
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.c	2006-10-09 06:02:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,77 +1,89 @@
 /*
  * Routines common to more than one of the rsync processes.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
-#include <iconv.h>
-#endif
+#include "ifuncs.h"
 #if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
 #include <libcharset.h>
 #elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
 #include <langinfo.h>
 #endif
 
 extern int verbose;
 extern int dry_run;
+extern int preserve_acls;
+extern int preserve_xattrs;
 extern int preserve_perms;
 extern int preserve_executability;
 extern int preserve_times;
-extern int omit_dir_times;
 extern int am_root;
 extern int am_server;
 extern int am_sender;
 extern int am_generator;
 extern int am_starting_up;
 extern int allow_8bit_chars;
-extern int preserve_uid;
-extern int preserve_gid;
+extern int protocol_version;
+extern int receiver_symlink_times;
+extern int uid_ndx;
+extern int gid_ndx;
+extern int inc_recurse;
 extern int inplace;
+extern int flist_eof;
 extern int keep_dirlinks;
 extern int make_backups;
-extern mode_t orig_umask;
-extern struct stats stats;
+extern struct file_list *cur_flist, *first_flist, *dir_flist;
 extern struct chmod_mode_struct *daemon_chmod_modes;
+#ifdef ICONV_OPTION
+extern char *iconv_opt;
+#endif
 
-#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+#ifdef ICONV_CONST
 iconv_t ic_chck = (iconv_t)-1;
+# ifdef ICONV_OPTION
+iconv_t ic_send = (iconv_t)-1, ic_recv = (iconv_t)-1;
+# endif
 
 static const char *default_charset(void)
 {
-#if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
+# if defined HAVE_LIBCHARSET_H && defined HAVE_LOCALE_CHARSET
 	return locale_charset();
-#elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
+# elif defined HAVE_LANGINFO_H && defined HAVE_NL_LANGINFO
 	return nl_langinfo(CODESET);
-#else
+# else
 	return ""; /* Works with (at the very least) gnu iconv... */
-#endif
+# endif
 }
 
-void setup_iconv()
+void setup_iconv(void)
 {
+	const char *defset = default_charset();
+# ifdef ICONV_OPTION
+	const char *charset;
+	char *cp;
+# endif
+
 	if (!am_server && !allow_8bit_chars) {
-		const char *defset = default_charset();
 
 		/* It's OK if this fails... */
 		ic_chck = iconv_open(defset, defset);
 
 		if (verbose > 3) {
 			if (ic_chck == (iconv_t)-1) {
@@ -83,27 +95,230 @@
 				rprintf(FINFO,
 					"note: iconv_open(\"%s\", \"%s\") succeeded.\n",
 					defset, defset);
 			}
 		}
 	}
+
+# ifdef ICONV_OPTION
+	if (!iconv_opt)
+		return;
+
+	if ((cp = strchr(iconv_opt, ',')) != NULL) {
+		if (am_server) /* A local transfer needs this. */
+			iconv_opt = cp + 1;
+		else
+			*cp = '\0';
+	}
+
+	if (!*iconv_opt || (*iconv_opt == '.' && iconv_opt[1] == '\0'))
+		charset = defset;
+	else
+		charset = iconv_opt;
+
+	if ((ic_send = iconv_open(UTF8_CHARSET, charset)) == (iconv_t)-1) {
+		rprintf(FERROR, "iconv_open(\"%s\", \"%s\") failed\n",
+			UTF8_CHARSET, charset);
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+
+	if ((ic_recv = iconv_open(charset, UTF8_CHARSET)) == (iconv_t)-1) {
+		rprintf(FERROR, "iconv_open(\"%s\", \"%s\") failed\n",
+			charset, UTF8_CHARSET);
+		exit_cleanup(RERR_UNSUPPORTED);
+	}
+
+	if (verbose > 1) {
+		rprintf(FINFO, "%s charset: %s\n",
+			am_server ? "server" : "client",
+			*charset ? charset : "[LOCALE]");
+	}
+# endif
+}
+
+/* This function converts the characters in the "in" xbuf into characters
+ * in the "out" xbuf.  The "len" of the "in" xbuf is used starting from its
+ * "pos".  The "size" of the "out" xbuf restricts how many characters can be
+ * stored, starting at its "pos+len" position.  Note that the last byte of
+ * the buffer is never used, which reserves space for a terminating '\0'.
+ * We return a 0 on success or a -1 on error.  An error also sets errno to
+ * E2BIG, EILSEQ, or EINVAL (see below); otherwise errno will be set to 0.
+ * The "in" xbuf is altered to update "pos" and "len".  The "out" xbuf has
+ * data appended, and its "len" incremented.   If ICB_EXPAND_OUT is set in
+ * "flags", the "out" xbuf will also be allocated if empty, and expanded if
+ * too small (so E2BIG will not be returned).  If ICB_INCLUDE_BAD is set in
+ * "flags", any badly-encoded chars are included verbatim in the "out" xbuf,
+ * so EILSEQ will not be returned.  Likewise for ICB_INCLUDE_INCOMPLETE with
+ * respect to an incomplete multi-byte char at the end, which ensures that
+ * EINVAL is not returned.  Anytime "in.pos" is 0 we will reset the iconv()
+ * state prior to processing the characters. */
+int iconvbufs(iconv_t ic, xbuf *in, xbuf *out, int flags)
+{
+	ICONV_CONST char *ibuf;
+	size_t icnt, ocnt;
+	char *obuf;
+
+	if (!out->size && flags & ICB_EXPAND_OUT)
+		alloc_xbuf(out, 1024);
+
+	if (!in->pos)
+		iconv(ic, NULL, 0, NULL, 0);
+
+	ibuf = in->buf + in->pos;
+	icnt = in->len;
+
+	obuf = out->buf + (out->pos + out->len);
+	ocnt = out->size - (out->pos + out->len) - 1;
+
+	while (icnt) {
+		while (iconv(ic, &ibuf, &icnt, &obuf, &ocnt) == (size_t)-1) {
+			if (errno == EINTR)
+				continue;
+			if (errno == EINVAL) {
+				if (!(flags & ICB_INCLUDE_INCOMPLETE))
+					goto finish;
+			} else if (errno == EILSEQ) {
+				if (!(flags & ICB_INCLUDE_BAD))
+					goto finish;
+			} else {
+				size_t opos = obuf - out->buf;
+				if (!(flags & ICB_EXPAND_OUT)) {
+					errno = E2BIG;
+					goto finish;
+				}
+				realloc_xbuf(out, out->size + 1024);
+				obuf = out->buf + opos;
+				ocnt += 1024;
+				continue;
+			}
+			*obuf++ = *ibuf++;
+			ocnt--, icnt--;
+		}
+	}
+
+	errno = 0;
+
+  finish:
+	in->len = icnt;
+	in->pos = ibuf - in->buf;
+	out->len = obuf - out->buf - out->pos;
+
+	return errno ? -1 : 0;
 }
 #endif
 
+int read_ndx_and_attrs(int f_in, int *iflag_ptr, uchar *type_ptr,
+		       char *buf, int *len_ptr)
+{
+	int len, iflags = 0;
+	struct file_list *flist;
+	uchar fnamecmp_type = FNAMECMP_FNAME;
+	int ndx, save_verbose = verbose;
+
+  read_loop:
+	while (1) {
+		ndx = read_ndx(f_in);
+
+		if (ndx >= 0)
+			break;
+		if (ndx == NDX_DONE)
+			return ndx;
+		if (!inc_recurse || am_sender)
+			goto invalid_ndx;
+		if (ndx == NDX_FLIST_EOF) {
+			flist_eof = 1;
+			send_msg(MSG_FLIST_EOF, "", 0, 0);
+			continue;
+		}
+		ndx = NDX_FLIST_OFFSET - ndx;
+		if (ndx < 0 || ndx >= dir_flist->used) {
+			ndx = NDX_FLIST_OFFSET - ndx;
+			rprintf(FERROR,
+				"[%s] Invalid dir index: %d (%d - %d)\n",
+				who_am_i(), ndx, NDX_FLIST_OFFSET,
+				NDX_FLIST_OFFSET - dir_flist->used + 1);
+			exit_cleanup(RERR_PROTOCOL);
+		}
+
+		/* Send everything read from f_in to msg_fd_out. */
+		if (verbose > 3) {
+			rprintf(FINFO, "[%s] receiving flist for dir %d\n",
+				who_am_i(), ndx);
+		}
+		verbose = 0;
+		send_msg_int(MSG_FLIST, ndx);
+		start_flist_forward(f_in);
+		flist = recv_file_list(f_in);
+		flist->parent_ndx = ndx;
+		stop_flist_forward();
+		verbose = save_verbose;
+	}
+
+	iflags = protocol_version >= 29 ? read_shortint(f_in)
+		   : ITEM_TRANSFER | ITEM_MISSING_DATA;
+
+	/* Honor the old-style keep-alive indicator. */
+	if (protocol_version < 30
+	 && ndx == cur_flist->used && iflags == ITEM_IS_NEW) {
+		if (am_sender)
+			maybe_send_keepalive();
+		goto read_loop;
+	}
+
+	if (!(flist = flist_for_ndx(ndx))) {
+		int start, used;
+	  invalid_ndx:
+		start = first_flist ? first_flist->ndx_start : 0;
+		used = first_flist ? first_flist->used : 0;
+		rprintf(FERROR,
+			"Invalid file index: %d (%d - %d) with iflags %x [%s]\n",
+			ndx, start - 1, start + used -1, iflags, who_am_i());
+		exit_cleanup(RERR_PROTOCOL);
+	}
+	cur_flist = flist;
+
+	if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
+		fnamecmp_type = read_byte(f_in);
+	*type_ptr = fnamecmp_type;
+
+	if (iflags & ITEM_XNAME_FOLLOWS) {
+		if ((len = read_vstring(f_in, buf, MAXPATHLEN)) < 0)
+			exit_cleanup(RERR_PROTOCOL);
+	} else {
+		*buf = '\0';
+		len = -1;
+	}
+	*len_ptr = len;
+
+	if (iflags & ITEM_TRANSFER) {
+		int i = ndx - cur_flist->ndx_start;
+		if (i < 0 || !S_ISREG(cur_flist->files[i]->mode)) {
+			rprintf(FERROR,
+				"received request to transfer non-regular file: %d [%s]\n",
+				ndx, who_am_i());
+			exit_cleanup(RERR_PROTOCOL);
+		}
+	}
+
+	*iflag_ptr = iflags;
+	return ndx;
+}
+
 /*
   free a sums struct
   */
 void free_sums(struct sum_struct *s)
 {
 	if (s->sums) free(s->sums);
 	free(s);
 }
 
 /* This is only called when we aren't preserving permissions.  Figure out what
  * the permissions should be and return them merged back into the mode. */
-mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int exists)
+mode_t dest_mode(mode_t flist_mode, mode_t stat_mode, int dflt_perms,
+		 int exists)
 {
 	int new_mode;
 	/* If the file already exists, we'll return the local permissions,
 	 * possibly tweaked by the --executability option. */
 	if (exists) {
 		new_mode = (flist_mode & ~CHMOD_BITS) | (stat_mode & CHMOD_BITS);
@@ -114,122 +329,169 @@
 			if (!(flist_mode & 0111))
 				new_mode &= ~0111;
 			else if (!(stat_mode & 0111))
 				new_mode |= (new_mode & 0444) >> 2;
 		}
 	} else {
-		/* Apply the umask and turn off special permissions. */
-		new_mode = flist_mode & (~CHMOD_BITS | (ACCESSPERMS & ~orig_umask));
+		/* Apply destination default permissions and turn
+		 * off special permissions. */
+		new_mode = flist_mode & (~CHMOD_BITS | dflt_perms);
 	}
 	return new_mode;
 }
 
-int set_file_attrs(char *fname, struct file_struct *file, STRUCT_STAT *st,
-		   int flags)
+int set_file_attrs(const char *fname, struct file_struct *file, stat_x *sxp,
+		   const char *fnamecmp, int flags)
 {
 	int updated = 0;
-	STRUCT_STAT st2;
+	stat_x sx2;
 	int change_uid, change_gid;
 	mode_t new_mode = file->mode;
+	int inherit;
 
-	if (!st) {
+	if (!sxp) {
 		if (dry_run)
 			return 1;
-		if (link_stat(fname, &st2, 0) < 0) {
-			rsyserr(FERROR, errno, "stat %s failed",
+		if (link_stat(fname, &sx2.st, 0) < 0) {
+			rsyserr(FERROR_XFER, errno, "stat %s failed",
 				full_fname(fname));
 			return 0;
 		}
-		st = &st2;
-		if (!preserve_perms && S_ISDIR(new_mode)
-		 && st->st_mode & S_ISGID) {
-			/* We just created this directory and its setgid
-			 * bit is on, so make sure it stays on. */
-			new_mode |= S_ISGID;
-		}
+#ifdef SUPPORT_ACLS
+		sx2.acc_acl = sx2.def_acl = NULL;
+#endif
+#ifdef SUPPORT_XATTRS
+		sx2.xattr = NULL;
+#endif
+		sxp = &sx2;
+		inherit = !preserve_perms;
+	} else
+		inherit = !preserve_perms && file->flags & FLAG_DIR_CREATED;
+
+	if (inherit && S_ISDIR(new_mode) && sxp->st.st_mode & S_ISGID) {
+		/* We just created this directory and its setgid
+		 * bit is on, so make sure it stays on. */
+		new_mode |= S_ISGID;
 	}
 
-	if (!preserve_times || (S_ISDIR(st->st_mode) && omit_dir_times))
+	if (daemon_chmod_modes && !S_ISLNK(new_mode))
+		new_mode = tweak_mode(new_mode, daemon_chmod_modes);
+
+#ifdef SUPPORT_ACLS
+	if (preserve_acls && !S_ISLNK(file->mode) && !ACL_READY(*sxp))
+		get_acl(fname, sxp);
+#endif
+
+#ifdef SUPPORT_XATTRS
+	if (am_root < 0)
+		set_stat_xattr(fname, file, new_mode);
+	if (preserve_xattrs && fnamecmp)
+		set_xattr(fname, file, fnamecmp, sxp);
+#endif
+
+	if (!preserve_times || (S_ISDIR(sxp->st.st_mode) && preserve_times == 1))
 		flags |= ATTRS_SKIP_MTIME;
 	if (!(flags & ATTRS_SKIP_MTIME)
-	    && cmp_time(st->st_mtime, file->modtime) != 0) {
-		int ret = set_modtime(fname, file->modtime, st->st_mode);
+	    && cmp_time(sxp->st.st_mtime, file->modtime) != 0) {
+		int ret = set_modtime(fname, file->modtime, sxp->st.st_mode);
 		if (ret < 0) {
-			rsyserr(FERROR, errno, "failed to set times on %s",
+			rsyserr(FERROR_XFER, errno, "failed to set times on %s",
 				full_fname(fname));
-			return 0;
+			goto cleanup;
 		}
 		if (ret == 0) /* ret == 1 if symlink could not be set */
 			updated = 1;
+		else if (receiver_symlink_times)
+			file->flags |= FLAG_TIME_FAILED;
 	}
 
-	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
-	change_gid = preserve_gid && file->gid != GID_NONE
-		&& st->st_gid != file->gid;
+	change_uid = am_root && uid_ndx && sxp->st.st_uid != (uid_t)F_OWNER(file);
+	change_gid = gid_ndx && !(file->flags & FLAG_SKIP_GROUP)
+		  && sxp->st.st_gid != (gid_t)F_GROUP(file);
 #if !defined HAVE_LCHOWN && !defined CHOWN_MODIFIES_SYMLINK
-	if (S_ISLNK(st->st_mode))
+	if (S_ISLNK(sxp->st.st_mode)) {
 		;
-	else
+	} else
 #endif
 	if (change_uid || change_gid) {
 		if (verbose > 2) {
 			if (change_uid) {
 				rprintf(FINFO,
-					"set uid of %s from %ld to %ld\n",
-					fname,
-					(long)st->st_uid, (long)file->uid);
+					"set uid of %s from %u to %u\n",
+					fname, (unsigned)sxp->st.st_uid, F_OWNER(file));
 			}
 			if (change_gid) {
 				rprintf(FINFO,
-					"set gid of %s from %ld to %ld\n",
-					fname,
-					(long)st->st_gid, (long)file->gid);
+					"set gid of %s from %u to %u\n",
+					fname, (unsigned)sxp->st.st_gid, F_GROUP(file));
 			}
 		}
-		if (do_lchown(fname,
-		    change_uid ? file->uid : st->st_uid,
-		    change_gid ? file->gid : st->st_gid) != 0) {
-			/* shouldn't have attempted to change uid or gid
-			 * unless have the privilege */
-			rsyserr(FERROR, errno, "%s %s failed",
-			    change_uid ? "chown" : "chgrp",
-			    full_fname(fname));
-			return 0;
-		}
-		/* a lchown had been done - we have to re-stat if the
-		 * destination had the setuid or setgid bits set due
-		 * to the side effect of the chown call */
-		if (st->st_mode & (S_ISUID | S_ISGID)) {
-			link_stat(fname, st,
-				  keep_dirlinks && S_ISDIR(st->st_mode));
+		if (am_root >= 0) {
+			if (do_lchown(fname,
+			    change_uid ? (uid_t)F_OWNER(file) : sxp->st.st_uid,
+			    change_gid ? (gid_t)F_GROUP(file) : sxp->st.st_gid) != 0) {
+				/* We shouldn't have attempted to change uid
+				 * or gid unless have the privilege. */
+				rsyserr(FERROR_XFER, errno, "%s %s failed",
+				    change_uid ? "chown" : "chgrp",
+				    full_fname(fname));
+				goto cleanup;
+			}
+			/* A lchown had been done, so we need to re-stat if
+			 * the destination had the setuid or setgid bits set
+			 * (due to the side effect of the chown call). */
+			if (sxp->st.st_mode & (S_ISUID | S_ISGID)) {
+				link_stat(fname, &sxp->st,
+					  keep_dirlinks && S_ISDIR(sxp->st.st_mode));
+			}
 		}
 		updated = 1;
 	}
 
-	if (daemon_chmod_modes && !S_ISLNK(new_mode))
-		new_mode = tweak_mode(new_mode, daemon_chmod_modes);
+#ifdef SUPPORT_ACLS
+	/* It's OK to call set_acl() now, even for a dir, as the generator
+	 * will enable owner-writability using chmod, if necessary.
+	 * 
+	 * If set_acl() changes permission bits in the process of setting
+	 * an access ACL, it changes sxp->st.st_mode so we know whether we
+	 * need to chmod(). */
+	if (preserve_acls && !S_ISLNK(new_mode) && set_acl(fname, file, sxp) == 0)
+		updated = 1;
+#endif
+
 #ifdef HAVE_CHMOD
-	if ((st->st_mode & CHMOD_BITS) != (new_mode & CHMOD_BITS)) {
-		int ret = do_chmod(fname, new_mode);
+	if (!BITS_EQUAL(sxp->st.st_mode, new_mode, CHMOD_BITS)) {
+		int ret = am_root < 0 ? 0 : do_chmod(fname, new_mode);
 		if (ret < 0) {
-			rsyserr(FERROR, errno,
+			rsyserr(FERROR_XFER, errno,
 				"failed to set permissions on %s",
 				full_fname(fname));
-			return 0;
+			goto cleanup;
 		}
 		if (ret == 0) /* ret == 1 if symlink could not be set */
 			updated = 1;
 	}
 #endif
 
 	if (verbose > 1 && flags & ATTRS_REPORT) {
 		if (updated)
 			rprintf(FCLIENT, "%s\n", fname);
 		else
 			rprintf(FCLIENT, "%s is uptodate\n", fname);
 	}
+  cleanup:
+	if (sxp == &sx2) {
+#ifdef SUPPORT_ACLS
+		if (preserve_acls)
+			free_acl(&sx2);
+#endif
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs)
+			free_xattr(&sx2);
+#endif
+	}
 	return updated;
 }
 
 RETSIGTYPE sig_int(UNUSED(int val))
 {
 	/* KLUGE: if the user hits Ctrl-C while ssh is prompting
@@ -242,66 +504,93 @@
 	 * shouldn't hurt anything. */
 	msleep(400);
 	exit_cleanup(RERR_SIGNAL);
 }
 
 /* Finish off a file transfer: renaming the file and setting the file's
- * attributes (e.g. permissions, ownership, etc.).  If partialptr is not
- * NULL and the robust_rename() call is forced to copy the temp file, we
- * stage the file into the partial-dir and then rename it into place. */
-void finish_transfer(char *fname, char *fnametmp, char *partialptr,
-		     struct file_struct *file, int ok_to_set_time,
-		     int overwriting_basis)
+ * attributes (e.g. permissions, ownership, etc.).  If the robust_rename()
+ * call is forced to copy the temp file and partialptr is both non-NULL and
+ * not an absolute path, we stage the file into the partial-dir and then
+ * rename it into place.  This returns 1 on succcess or 0 on failure. */
+int finish_transfer(const char *fname, const char *fnametmp,
+		    const char *fnamecmp, const char *partialptr,
+		    struct file_struct *file, int ok_to_set_time,
+		    int overwriting_basis)
 {
 	int ret;
+	const char *temp_copy_name = partialptr && *partialptr != '/' ? partialptr : NULL;
 
 	if (inplace) {
 		if (verbose > 2)
 			rprintf(FINFO, "finishing %s\n", fname);
 		fnametmp = fname;
 		goto do_set_file_attrs;
 	}
 
-	if (make_backups && overwriting_basis && !make_backup(fname))
-		return;
+	if (make_backups > 0 && overwriting_basis && !make_backup(fname))
+		return 1;
 
 	/* Change permissions before putting the file into place. */
-	set_file_attrs(fnametmp, file, NULL,
+	set_file_attrs(fnametmp, file, NULL, fnamecmp,
 		       ok_to_set_time ? 0 : ATTRS_SKIP_MTIME);
 
 	/* move tmp file over real file */
 	if (verbose > 2)
 		rprintf(FINFO, "renaming %s to %s\n", fnametmp, fname);
-	ret = robust_rename(fnametmp, fname, partialptr,
+	ret = robust_rename(fnametmp, fname, temp_copy_name,
 			    file->mode & INITACCESSPERMS);
 	if (ret < 0) {
-		rsyserr(FERROR, errno, "%s %s -> \"%s\"",
+		rsyserr(FERROR_XFER, errno, "%s %s -> \"%s\"",
 			ret == -2 ? "copy" : "rename",
 			full_fname(fnametmp), fname);
-		do_unlink(fnametmp);
-		return;
+		if (!partialptr || (ret == -2 && temp_copy_name)
+		 || robust_rename(fnametmp, partialptr, NULL,
+				  file->mode & INITACCESSPERMS) < 0)
+			do_unlink(fnametmp);
+		return 0;
 	}
 	if (ret == 0) {
 		/* The file was moved into place (not copied), so it's done. */
-		return;
+		return 1;
 	}
 	/* The file was copied, so tweak the perms of the copied file.  If it
 	 * was copied to partialptr, move it into its final destination. */
-	fnametmp = partialptr ? partialptr : fname;
+	fnametmp = temp_copy_name ? temp_copy_name : fname;
 
   do_set_file_attrs:
-	set_file_attrs(fnametmp, file, NULL,
+	set_file_attrs(fnametmp, file, NULL, fnamecmp,
 		       ok_to_set_time ? 0 : ATTRS_SKIP_MTIME);
 
-	if (partialptr) {
+	if (temp_copy_name) {
 		if (do_rename(fnametmp, fname) < 0) {
-			rsyserr(FERROR, errno, "rename %s -> \"%s\"",
+			rsyserr(FERROR_XFER, errno, "rename %s -> \"%s\"",
 				full_fname(fnametmp), fname);
-		} else
-			handle_partial_dir(partialptr, PDIR_DELETE);
+			return 0;
+		}
+		handle_partial_dir(temp_copy_name, PDIR_DELETE);
+	}
+	return 1;
+}
+
+struct file_list *flist_for_ndx(int ndx)
+{
+	struct file_list *flist = cur_flist;
+
+	if (!flist && !(flist = first_flist))
+		return NULL;
+
+	while (ndx < flist->ndx_start-1) {
+		if (flist == first_flist)
+			return NULL;
+		flist = flist->prev;
+	}
+	while (ndx >= flist->ndx_start + flist->used) {
+		if (!(flist = flist->next))
+			return NULL;
 	}
+	return flist;
 }
 
 const char *who_am_i(void)
 {
 	if (am_starting_up)
 		return am_server ? "server" : "client";
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsyncd.conf.5	2006-11-07 12:39:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.5	2008-03-02 04:12:15.000000000 +0800
@@ -1,411 +1,510 @@
-.TH "rsyncd\&.conf" "5" "6 Nov 2006" "" ""
+.TH "rsyncd.conf" "5" "1 Mar 2008" "" ""
 .SH "NAME"
-rsyncd\&.conf \- configuration file for rsync in daemon mode
+rsyncd.conf \(em configuration file for rsync in daemon mode
 .SH "SYNOPSIS"
 
 .PP 
-rsyncd\&.conf
+rsyncd.conf
 .PP 
 .SH "DESCRIPTION"
 
 .PP 
-The rsyncd\&.conf file is the runtime configuration file for rsync when
-run as an rsync daemon\&.
+The rsyncd.conf file is the runtime configuration file for rsync when
+run as an rsync daemon.
 .PP 
-The rsyncd\&.conf file controls authentication, access, logging and
-available modules\&.
+The rsyncd.conf file controls authentication, access, logging and
+available modules.
 .PP 
 .SH "FILE FORMAT"
 
 .PP 
-The file consists of modules and parameters\&. A module begins with the
+The file consists of modules and parameters. A module begins with the
 name of the module in square brackets and continues until the next
-module begins\&. Modules contain parameters of the form \&'name = value\&'\&.
+module begins. Modules contain parameters of the form \(lqname = value\(rq.
 .PP 
-The file is line-based -- that is, each newline-terminated line represents
-either a comment, a module name or a parameter\&.
+The file is line-based \(em that is, each newline-terminated line represents
+either a comment, a module name or a parameter.
 .PP 
-Only the first equals sign in a parameter is significant\&. Whitespace before
-or after the first equals sign is discarded\&. Leading, trailing and internal
-whitespace in module and parameter names is irrelevant\&. Leading and
-trailing whitespace in a parameter value is discarded\&. Internal whitespace
-within a parameter value is retained verbatim\&.
+Only the first equals sign in a parameter is significant. Whitespace before
+or after the first equals sign is discarded. Leading, trailing and internal
+whitespace in module and parameter names is irrelevant. Leading and
+trailing whitespace in a parameter value is discarded. Internal whitespace
+within a parameter value is retained verbatim.
 .PP 
 Any line beginning with a hash (#) is ignored, as are lines containing
-only whitespace\&.
+only whitespace.
 .PP 
-Any line ending in a \e is "continued" on the next line in the
-customary UNIX fashion\&.
+Any line ending in a \e is \(lqcontinued\(rq on the next line in the
+customary UNIX fashion.
 .PP 
 The values following the equals sign in parameters are all either a string
 (no quotes needed) or a boolean, which may be given as yes/no, 0/1 or
-true/false\&. Case is not significant in boolean values, but is preserved
-in string values\&.
+true/false. Case is not significant in boolean values, but is preserved
+in string values.
 .PP 
 .SH "LAUNCHING THE RSYNC DAEMON"
 
 .PP 
 The rsync daemon is launched by specifying the \fB\-\-daemon\fP option to
-rsync\&.
+rsync.
 .PP 
 The daemon must run with root privileges if you wish to use chroot, to
 bind to a port numbered under 1024 (as is the default 873), or to set
-file ownership\&.  Otherwise, it must just have permission to read and
-write the appropriate data, log, and lock files\&.
+file ownership.  Otherwise, it must just have permission to read and
+write the appropriate data, log, and lock files.
 .PP 
 You can launch it either via inetd, as a stand-alone daemon, or from
-an rsync client via a remote shell\&.  If run as a stand-alone daemon then
-just run the command "\fBrsync \-\-daemon\fP" from a suitable startup script\&.
+an rsync client via a remote shell.  If run as a stand-alone daemon then
+just run the command \(lq\fBrsync \-\-daemon\fP\(rq from a suitable startup script.
 .PP 
 When run via inetd you should add a line like this to /etc/services:
 .PP 
 .nf 
   rsync           873/tcp
 .fi 
 
 .PP 
-and a single line something like this to /etc/inetd\&.conf:
+and a single line something like this to /etc/inetd.conf:
 .PP 
 .nf 
   rsync   stream  tcp     nowait  root   /usr/bin/rsync rsyncd \-\-daemon
 .fi 
 
 .PP 
-Replace "/usr/bin/rsync" with the path to where you have rsync installed on
-your system\&.  You will then need to send inetd a HUP signal to tell it to
-reread its config file\&.
+Replace \(lq/usr/bin/rsync\(rq with the path to where you have rsync installed on
+your system.  You will then need to send inetd a HUP signal to tell it to
+reread its config file.
 .PP 
 Note that you should \fBnot\fP send the rsync daemon a HUP signal to force
-it to reread the \f(CWrsyncd\&.conf\fP file\&. The file is re-read on each client
-connection\&.
+it to reread the \f(CWrsyncd.conf\fP file. The file is re-read on each client
+connection.
 .PP 
 .SH "GLOBAL OPTIONS"
 
 .PP 
 The first parameters in the file (before a [module] header) are the
-global parameters\&.
+global parameters.
 .PP 
 You may also include any module parameters in the global part of the
 config file in which case the supplied value will override the
-default for that parameter\&.
+default for that parameter.
 .PP 
 .IP "\fBmotd file\fP"
-The "motd file" option allows you to specify a
-"message of the day" to display to clients on each connect\&. This
-usually contains site information and any legal notices\&. The default
-is no motd file\&.
+The \(lqmotd file\(rq option allows you to specify a
+\(lqmessage of the day\(rq to display to clients on each connect. This
+usually contains site information and any legal notices. The default
+is no motd file.
 .IP 
 .IP "\fBpid file\fP"
-The "pid file" option tells the rsync daemon to write
-its process ID to that file\&.
+The \(lqpid file\(rq option tells the rsync daemon to write
+its process ID to that file.  If the file already exists, the rsync
+daemon will abort rather than overwrite the file.
 .IP 
 .IP "\fBport\fP"
 You can override the default port the daemon will listen on
-by specifying this value (defaults to 873)\&.  This is ignored if the daemon
-is being run by inetd, and is superseded by the \fB\-\-port\fP command-line option\&.
+by specifying this value (defaults to 873).  This is ignored if the daemon
+is being run by inetd, and is superseded by the \fB\-\-port\fP command-line option.
 .IP 
 .IP "\fBaddress\fP"
 You can override the default IP address the daemon
-will listen on by specifying this value\&.  This is ignored if the daemon is
-being run by inetd, and is superseded by the \fB\-\-address\fP command-line option\&.
+will listen on by specifying this value.  This is ignored if the daemon is
+being run by inetd, and is superseded by the \fB\-\-address\fP command-line option.
 .IP 
 .IP "\fBsocket options\fP"
 This option can provide endless fun for people
-who like to tune their systems to the utmost degree\&. You can set all
+who like to tune their systems to the utmost degree. You can set all
 sorts of socket options which may make transfers faster (or
-slower!)\&. Read the man page for the 
+slower!). Read the man page for the 
 \f(CWsetsockopt()\fP
 system call for
-details on some of the options you may be able to set\&. By default no
-special socket options are set\&.  These settings are superseded by the
-\fB\-\-sockopts\fP command-line option\&.
+details on some of the options you may be able to set. By default no
+special socket options are set.  These settings are superseded by the
+\fB\-\-sockopts\fP command-line option.
 .IP 
 .SH "MODULE OPTIONS"
 
 .PP 
 After the global options you should define a number of modules, each
-module exports a directory tree as a symbolic name\&. Modules are
+module exports a directory tree as a symbolic name. Modules are
 exported by specifying a module name in square brackets [module]
-followed by the options for that module\&.
+followed by the options for that module.
+The module name cannot contain a slash or a closing square bracket.  If the
+name contains whitespace, each internal sequence of whitespace will be
+changed into a single space, while leading or trailing whitespace will be
+discarded.
 .PP 
 .IP "\fBcomment\fP"
-The "comment" option specifies a description string
+The \(lqcomment\(rq option specifies a description string
 that is displayed next to the module name when clients obtain a list
-of available modules\&. The default is no comment\&.
+of available modules. The default is no comment.
 .IP 
 .IP "\fBpath\fP"
-The "path" option specifies the directory in the daemon\&'s
-filesystem to make available in this module\&.  You must specify this option
-for each module in \f(CWrsyncd\&.conf\fP\&.
+The \(lqpath\(rq option specifies the directory in the daemon's
+filesystem to make available in this module.  You must specify this option
+for each module in \f(CWrsyncd.conf\fP.
 .IP 
 .IP "\fBuse chroot\fP"
-If "use chroot" is true, the rsync daemon will chroot
-to the "path" before starting the file transfer with the client\&.  This has
+If \(lquse chroot\(rq is true, the rsync daemon will chroot
+to the \(lqpath\(rq before starting the file transfer with the client.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges,
 of not being able to follow symbolic links that are either absolute or outside
-of the new root path, and of complicating the preservation of usernames and groups
-(see below)\&.  When "use chroot" is false, for security reasons,
-symlinks may only be relative paths pointing to other files within the root
-path, and leading slashes are removed from most absolute paths (options
-such as \fB\-\-backup\-dir\fP, \fB\-\-compare\-dest\fP, etc\&. interpret an absolute path as
-rooted in the module\&'s "path" dir, just as if chroot was specified)\&.
-The default for "use chroot" is true\&.
+of the new root path, and of complicating the preservation of users and groups
+by name (see below).
 .IP 
-In order to preserve usernames and groupnames, rsync needs to be able to
-use the standard library functions for looking up names and IDs (i\&.e\&.
+As an additional safety feature, you can specify a dot-dir in the module's
+\(lqpath\(rq to indicate the point where the chroot should occur.  This allows rsync
+to run in a chroot with a non\-"/\(rq path for the top of the transfer hierarchy.
+Doing this guards against unintended library loading (since those absolute
+paths will not be inside the transfer hierarchy unless you have used an unwise
+pathname), and lets you setup libraries for the chroot that are outside of the
+transfer.  For example, specifying \(lq/var/rsync/./module1\(rq will chroot to the
+\(lq/var/rsync\(rq directory and set the inside-chroot path to \(lq/module1\(rq.  If you
+had omitted the dot-dir, the chroot would have used the whole path, and the
+inside-chroot path would have been \(lq/\(rq.
+.IP 
+When \(lquse chroot\(rq is false or the inside-chroot path is not \(lq/\(rq, rsync will:
+(1) munge symlinks by
+default for security reasons (see \(lqmunge symlinks\(rq for a way to turn this
+off, but only if you trust your users), (2) substitute leading slashes in
+absolute paths with the module's path (so that options such as
+\fB\-\-backup\-dir\fP, \fB\-\-compare\-dest\fP, etc. interpret an absolute path as
+rooted in the module's \(lqpath\(rq dir), and (3) trim \(lq..\(rq path elements from
+args if rsync believes they would escape the module hierarchy.
+The default for \(lquse chroot\(rq is true, and is the safer choice (especially
+if the module is not read-only).
+.IP 
+When this option is enabled, rsync will not attempt to map users and groups
+by name (by default), but instead copy IDs as though \fB\-\-numeric\-ids\fP had
+been specified.  In order to enable name-mapping, rsync needs to be able to
+use the standard library functions for looking up names and IDs (i.e.
 \f(CWgetpwuid()\fP
 , 
 \f(CWgetgrgid()\fP
 , 
 \f(CWgetpwname()\fP
 , and 
 \f(CWgetgrnam()\fP
-)\&.  This means a
-process in the chroot namespace will need to have access to the resources
+).
+This means the rsync
+process in the chroot hierarchy will need to have access to the resources
 used by these library functions (traditionally /etc/passwd and
-/etc/group)\&.  If these resources are not available, rsync will only be
-able to copy the IDs, just as if the \fB\-\-numeric\-ids\fP option had been
-specified\&.
-.IP 
-Note that you are free to setup user/group information in the chroot area
-differently from your normal system\&.  For example, you could abbreviate
-the list of users and groups\&.  Also, you can protect this information from
-being downloaded/uploaded by adding an exclude rule to the rsyncd\&.conf file
-(e\&.g\&. "exclude = /etc/**")\&.  Note that having the exclusion affect uploads
-is a relatively new feature in rsync, so make sure your daemon is
-at least 2\&.6\&.3 to effect this\&.  Also note that it is safest to exclude a
-directory and all its contents combining the rule "/some/dir/" with the
-rule "/some/dir/**" just to be sure that rsync will not allow deeper
-access to some of the excluded files inside the directory (rsync tries to
-do this automatically, but you might as well specify both to be extra
-sure)\&.
+/etc/group, but perhaps additional dynamic libraries as well).
+.IP 
+If you copy the necessary resources into the module's chroot area, you
+should protect them through your OS's normal user/group or ACL settings (to
+prevent the rsync module's user from being able to change them), and then
+hide them from the user's view via \(lqexclude\(rq (see how in the discussion of
+that option).  At that point it will be safe to enable the mapping of users
+and groups by name using the \(lqnumeric ids\(rq daemon option (see below).
+.IP 
+Note also that you are free to setup custom user/group information in the
+chroot area that is different from your normal system.  For example, you
+could abbreviate the list of users and groups.
+.IP 
+.IP "\fBnumeric ids\fP"
+Enabling the \(lqnumeric ids\(rq option disables the mapping
+of users and groups by name for the current daemon module.  This prevents
+the daemon from trying to load any user/group-related files or libraries.
+Enabling this option makes the transfer behave as if the client had passed
+the \fB\-\-numeric\-ids\fP command-line option.  By default, this parameter is
+enabled for chroot modules and disabled for non-chroot modules.
+.IP 
+A chroot-enabled module should not have this option enabled unless you've
+taken steps to ensure that the module has the necessary resources it needs
+to translate names, and that it is not possible for a user to change those
+resources.
+.IP 
+.IP "\fBmunge symlinks\fP"
+The \(lqmunge symlinks\(rq option tells rsync to modify
+all incoming symlinks in a way that makes them unusable but recoverable
+(see below).  This should help protect your files from user trickery when
+your daemon module is writable.  The default is disabled when \(lquse chroot\(rq
+is on and the inside-chroot path is \(lq/\(rq, otherwise it is enabled.
+.IP 
+If you disable this option on a daemon that is not read-only, there
+are tricks that a user can play with uploaded symlinks to access
+daemon-excluded items (if your module has any), and, if \(lquse chroot\(rq
+is off, rsync can even be tricked into showing or changing data that
+is outside the module's path (as access-permissions allow).
+.IP 
+The way rsync disables the use of symlinks is to prefix each one with
+the string \(lq/rsyncd-munged/\(rq.  This prevents the links from being used
+as long as that directory does not exist.  When this option is enabled,
+rsync will refuse to run if that path is a directory or a symlink to
+a directory.  When using the \(lqmunge symlinks\(rq option in a chroot area
+that has an inside-chroot path of \(lq/\(rq, you should add \(lq/rsyncd-munged/\(rq
+to the exclude setting for the module so that
+a user can't try to create it.
+.IP 
+Note:  rsync makes no attempt to verify that any pre-existing symlinks in
+the hierarchy are as safe as you want them to be.  If you setup an rsync
+daemon on a new area or locally add symlinks, you can manually protect your
+symlinks from being abused by prefixing \(lq/rsyncd-munged/\(rq to the start of
+every symlink's value.  There is a perl script in the support directory
+of the source code named \(lqmunge-symlinks\(rq that can be used to add or remove
+this prefix from your symlinks.
+.IP 
+When this option is disabled on a writable module and \(lquse chroot\(rq is off
+(or the inside-chroot path is not \(lq/\(rq),
+incoming symlinks will be modified to drop a leading slash and to remove \(lq..\(rq
+path elements that rsync believes will allow a symlink to escape the module's
+hierarchy.  There are tricky ways to work around this, though, so you had
+better trust your users if you choose this combination of options.
+.IP 
+.IP "\fBcharset\fP"
+This specifies the name of the character set in which the
+module's filenames are stored.  If the client uses an \fB\-\-iconv\fP option,
+the daemon will use the value of the \(lqcharset\(rq parameter regardless of the
+character set the client actually passed.  This allows the daemon to
+support charset conversion in a chroot module without extra files in the
+chroot area, and also ensures that name-translation is done in a consistent
+manner.  If the \(lqcharset\(rq parameter is not set, the \fB\-\-iconv\fP option is
+refused, just as if \(lqiconv\(rq had been specified via \(lqrefuse options\(rq.
+.IP 
+If you wish to force users to always use \fB\-\-iconv\fP for a particular
+module, add \(lqno-iconv\(rq to the \(lqrefuse options\(rq parameter.  Keep in mind
+that this will restrict access to your module to very new rsync clients.
 .IP 
 .IP "\fBmax connections\fP"
-The "max connections" option allows you to
-specify the maximum number of simultaneous connections you will allow\&.
+The \(lqmax connections\(rq option allows you to
+specify the maximum number of simultaneous connections you will allow.
 Any clients connecting when the maximum has been reached will receive a
-message telling them to try later\&.  The default is 0 which means no limit\&.
-See also the "lock file" option\&.
+message telling them to try later.  The default is 0, which means no limit.
+A negative value disables the module.
+See also the \(lqlock file\(rq option.
 .IP 
 .IP "\fBlog file\fP"
-When the "log file" option is set to a non-empty
+When the \(lqlog file\(rq option is set to a non-empty
 string, the rsync daemon will log messages to the indicated file rather
-than using syslog\&. This is particularly useful on systems (such as AIX)
+than using syslog. This is particularly useful on systems (such as AIX)
 where 
 \f(CWsyslog()\fP
-doesn\&'t work for chrooted programs\&.  The file is
+doesn't work for chrooted programs.  The file is
 opened before 
 \f(CWchroot()\fP
 is called, allowing it to be placed outside
-the transfer\&.  If this value is set on a per-module basis instead of
+the transfer.  If this value is set on a per-module basis instead of
 globally, the global log will still contain any authorization failures
-or config-file error messages\&.
+or config-file error messages.
 .IP 
 If the daemon fails to open to specified file, it will fall back to
-using syslog and output an error about the failure\&.  (Note that the
-failure to open the specified log file used to be a fatal error\&.)
+using syslog and output an error about the failure.  (Note that the
+failure to open the specified log file used to be a fatal error.)
 .IP 
 .IP "\fBsyslog facility\fP"
-The "syslog facility" option allows you to
+The \(lqsyslog facility\(rq option allows you to
 specify the syslog facility name to use when logging messages from the
-rsync daemon\&. You may use any standard syslog facility name which is
-defined on your system\&. Common names are auth, authpriv, cron, daemon,
+rsync daemon. You may use any standard syslog facility name which is
+defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
-local1, local2, local3, local4, local5, local6 and local7\&. The default
-is daemon\&.  This setting has no effect if the "log file" setting is a
+local1, local2, local3, local4, local5, local6 and local7. The default
+is daemon.  This setting has no effect if the \(lqlog file\(rq setting is a
 non-empty string (either set in the per-modules settings, or inherited
-from the global settings)\&.
+from the global settings).
 .IP 
 .IP "\fBmax verbosity\fP"
-The "max verbosity" option allows you to control
-the maximum amount of verbose information that you\&'ll allow the daemon to
-generate (since the information goes into the log file)\&. The default is 1,
-which allows the client to request one level of verbosity\&.
+The \(lqmax verbosity\(rq option allows you to control
+the maximum amount of verbose information that you'll allow the daemon to
+generate (since the information goes into the log file). The default is 1,
+which allows the client to request one level of verbosity.
 .IP 
 .IP "\fBlock file\fP"
-The "lock file" option specifies the file to use to
-support the "max connections" option\&. The rsync daemon uses record
+The \(lqlock file\(rq option specifies the file to use to
+support the \(lqmax connections\(rq option. The rsync daemon uses record
 locking on this file to ensure that the max connections limit is not
-exceeded for the modules sharing the lock file\&.
-The default is \f(CW/var/run/rsyncd\&.lock\fP\&.
+exceeded for the modules sharing the lock file.
+The default is \f(CW/var/run/rsyncd.lock\fP.
 .IP 
 .IP "\fBread only\fP"
-The "read only" option determines whether clients
-will be able to upload files or not\&. If "read only" is true then any
-attempted uploads will fail\&. If "read only" is false then uploads will
-be possible if file permissions on the daemon side allow them\&. The default
-is for all modules to be read only\&.
+The \(lqread only\(rq option determines whether clients
+will be able to upload files or not. If \(lqread only\(rq is true then any
+attempted uploads will fail. If \(lqread only\(rq is false then uploads will
+be possible if file permissions on the daemon side allow them. The default
+is for all modules to be read only.
 .IP 
 .IP "\fBwrite only\fP"
-The "write only" option determines whether clients
-will be able to download files or not\&. If "write only" is true then any
-attempted downloads will fail\&. If "write only" is false then downloads
-will be possible if file permissions on the daemon side allow them\&.  The
-default is for this option to be disabled\&.
+The \(lqwrite only\(rq option determines whether clients
+will be able to download files or not. If \(lqwrite only\(rq is true then any
+attempted downloads will fail. If \(lqwrite only\(rq is false then downloads
+will be possible if file permissions on the daemon side allow them.  The
+default is for this option to be disabled.
 .IP 
 .IP "\fBlist\fP"
-The "list" option determines if this module should be
-listed when the client asks for a listing of available modules\&. By
-setting this to false you can create hidden modules\&. The default is
-for modules to be listable\&.
+The \(lqlist\(rq option determines if this module should be
+listed when the client asks for a listing of available modules. By
+setting this to false you can create hidden modules. The default is
+for modules to be listable.
 .IP 
 .IP "\fBuid\fP"
-The "uid" option specifies the user name or user ID that
+The \(lquid\(rq option specifies the user name or user ID that
 file transfers to and from that module should take place as when the daemon
-was run as root\&. In combination with the "gid" option this determines what
-file permissions are available\&. The default is uid \-2, which is normally
-the user "nobody"\&.
+was run as root. In combination with the \(lqgid\(rq option this determines what
+file permissions are available. The default is uid \-2, which is normally
+the user \(lqnobody\(rq.
 .IP 
 .IP "\fBgid\fP"
-The "gid" option specifies the group name or group ID that
+The \(lqgid\(rq option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
-was run as root\&. This complements the "uid" option\&. The default is gid \-2,
-which is normally the group "nobody"\&.
+was run as root. This complements the \(lquid\(rq option. The default is gid \-2,
+which is normally the group \(lqnobody\(rq.
+.IP 
+.IP "\fBfake super\fP"
+Setting \(lqfake super = yes\(rq for a module causes the
+daemon side to behave as if the \fB\-\-fake\-user\fP command-line option had
+been specified.  This allows the full attributes of a file to be stored
+without having to have the daemon actually running as root.
 .IP 
 .IP "\fBfilter\fP"
-The "filter" option allows you to specify a space-separated
-list of filter rules that the daemon will not allow to be read or written\&.
+The \(lqfilter\(rq option allows you to specify a space-separated
+list of filter rules that the daemon will not allow to be read or written.
 This is only superficially equivalent to the client specifying these
-patterns with the \fB\-\-filter\fP option\&.  Only one "filter" option may be
+patterns with the \fB\-\-filter\fP option.  Only one \(lqfilter\(rq option may be
 specified, but it may contain as many rules as you like, including
-merge-file rules\&.  Note that per-directory merge-file rules do not provide
+merge-file rules.  Note that per-directory merge-file rules do not provide
 as much protection as global rules, but they can be used to make \fB\-\-delete\fP
-work better when a client downloads the daemon\&'s files (if the per-dir
-merge files are included in the transfer)\&.
+work better when a client downloads the daemon's files (if the per-dir
+merge files are included in the transfer).
 .IP 
 .IP "\fBexclude\fP"
-The "exclude" option allows you to specify a
+The \(lqexclude\(rq option allows you to specify a
 space-separated list of patterns that the daemon will not allow to be read
-or written\&.  This is only superficially equivalent to the client
-specifying these patterns with the \fB\-\-exclude\fP option\&.  Only one "exclude"
-option may be specified, but you can use "\-" and "+" before patterns to
-specify exclude/include\&.
+or written.  This is only superficially equivalent to the client
+specifying these patterns with the \fB\-\-exclude\fP option.  Only one \(lqexclude\(rq
+option may be specified, but you can use \(lq\-\(rq and \(lq+\(rq before patterns to
+specify exclude/include.
 .IP 
 Because this exclude list is not passed to the client it only applies on
 the daemon: that is, it excludes files received by a client when receiving
 from a daemon and files deleted on a daemon when sending to a daemon, but
-it doesn\&'t exclude files from being deleted on a client when receiving
-from a daemon\&.
+it doesn't exclude files from being deleted on a client when receiving
+from a daemon.
+.IP 
+When you want to exclude a directory and all its contents, it is safest to
+use a rule that does both, such as \(lq/some/dir/***\(rq (the three stars tells
+rsync to exclude the directory itself and everything inside it).  This is
+better than just excluding the directory alone with \(lq/some/dir/\(rq, as it
+helps to guard against attempts to trick rsync into accessing files deeper
+in the hierarchy.
 .IP 
 .IP "\fBexclude from\fP"
-The "exclude from" option specifies a filename
-on the daemon that contains exclude patterns, one per line\&.
+The \(lqexclude from\(rq option specifies a filename
+on the daemon that contains exclude patterns, one per line.
 This is only superficially equivalent
-to the client specifying the \fB\-\-exclude\-from\fP option with an equivalent file\&.
-See the "exclude" option above\&.
+to the client specifying the \fB\-\-exclude\-from\fP option with an equivalent file.
+See the \(lqexclude\(rq option above.
 .IP 
 .IP "\fBinclude\fP"
-The "include" option allows you to specify a
-space-separated list of patterns which rsync should not exclude\&. This is
+The \(lqinclude\(rq option allows you to specify a
+space-separated list of patterns which rsync should not exclude. This is
 only superficially equivalent to the client specifying these patterns with
-the \fB\-\-include\fP option because it applies only on the daemon\&.  This is
-useful as it allows you to build up quite complex exclude/include rules\&.
-Only one "include" option may be specified, but you can use "+" and "\-"
-before patterns to switch include/exclude\&.  See the "exclude" option
-above\&.
+the \fB\-\-include\fP option because it applies only on the daemon.  This is
+useful as it allows you to build up quite complex exclude/include rules.
+Only one \(lqinclude\(rq option may be specified, but you can use \(lq+\(rq and \(lq\-\(rq
+before patterns to switch include/exclude.  See the \(lqexclude\(rq option
+above.
 .IP 
 .IP "\fBinclude from\fP"
-The "include from" option specifies a filename
-on the daemon that contains include patterns, one per line\&. This is
+The \(lqinclude from\(rq option specifies a filename
+on the daemon that contains include patterns, one per line. This is
 only superficially equivalent to the client specifying the
-\fB\-\-include\-from\fP option with a equivalent file\&.
-See the "exclude" option above\&.
+\fB\-\-include\-from\fP option with a equivalent file.
+See the \(lqexclude\(rq option above.
 .IP 
 .IP "\fBincoming chmod\fP"
 This option allows you to specify a set of
 comma-separated chmod strings that will affect the permissions of all
-incoming files (files that are being received by the daemon)\&.  These
+incoming files (files that are being received by the daemon).  These
 changes happen after all other permission calculations, and this will
 even override destination-default and/or existing permissions when the
-client does not specify \fB\-\-perms\fP\&.
+client does not specify \fB\-\-perms\fP.
 See the description of the \fB\-\-chmod\fP rsync option and the \fBchmod\fP(1)
-manpage for information on the format of this string\&.
+manpage for information on the format of this string.
 .IP 
 .IP "\fBoutgoing chmod\fP"
 This option allows you to specify a set of
 comma-separated chmod strings that will affect the permissions of all
-outgoing files (files that are being sent out from the daemon)\&.  These
+outgoing files (files that are being sent out from the daemon).  These
 changes happen first, making the sent permissions appear to be different
-than those stored in the filesystem itself\&.  For instance, you could
+than those stored in the filesystem itself.  For instance, you could
 disable group write permissions on the server while having it appear to
-be on to the clients\&.
+be on to the clients.
 See the description of the \fB\-\-chmod\fP rsync option and the \fBchmod\fP(1)
-manpage for information on the format of this string\&.
+manpage for information on the format of this string.
 .IP 
 .IP "\fBauth users\fP"
-The "auth users" option specifies a comma and
+The \(lqauth users\(rq option specifies a comma and
 space-separated list of usernames that will be allowed to connect to
-this module\&. The usernames do not need to exist on the local
-system\&. The usernames may also contain shell wildcard characters\&. If
-"auth users" is set then the client will be challenged to supply a
-username and password to connect to the module\&. A challenge response
-authentication protocol is used for this exchange\&. The plain text
+this module. The usernames do not need to exist on the local
+system. The usernames may also contain shell wildcard characters. If
+\(lqauth users\(rq is set then the client will be challenged to supply a
+username and password to connect to the module. A challenge response
+authentication protocol is used for this exchange. The plain text
 usernames and passwords are stored in the file specified by the
-"secrets file" option\&. The default is for all users to be able to
-connect without a password (this is called "anonymous rsync")\&.
+\(lqsecrets file\(rq option. The default is for all users to be able to
+connect without a password (this is called \(lqanonymous rsync\(rq).
 .IP 
-See also the "CONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
-PROGRAM" section in \fBrsync\fP(1) for information on how handle an
-rsyncd\&.conf\-level username that differs from the remote-shell-level
-username when using a remote shell to connect to an rsync daemon\&.
+See also the \(lqCONNECTING TO AN RSYNC DAEMON OVER A REMOTE SHELL
+PROGRAM\(rq section in \fBrsync\fP(1) for information on how handle an
+rsyncd.conf\-level username that differs from the remote-shell-level
+username when using a remote shell to connect to an rsync daemon.
 .IP 
 .IP "\fBsecrets file\fP"
-The "secrets file" option specifies the name of
+The \(lqsecrets file\(rq option specifies the name of
 a file that contains the username:password pairs used for
-authenticating this module\&. This file is only consulted if the "auth
-users" option is specified\&. The file is line based and contains
-username:password pairs separated by a single colon\&. Any line starting
-with a hash (#) is considered a comment and is skipped\&. The passwords
+authenticating this module. This file is only consulted if the \(lqauth
+users\(rq option is specified. The file is line based and contains
+username:password pairs separated by a single colon. Any line starting
+with a hash (#) is considered a comment and is skipped. The passwords
 can contain any characters but be warned that many operating systems
 limit the length of passwords that can be typed at the client end, so
-you may find that passwords longer than 8 characters don\&'t work\&.
+you may find that passwords longer than 8 characters don't work.
 .IP 
-There is no default for the "secrets file" option, you must choose a name
-(such as \f(CW/etc/rsyncd\&.secrets\fP)\&.  The file must normally not be readable
-by "other"; see "strict modes"\&.
+There is no default for the \(lqsecrets file\(rq option, you must choose a name
+(such as \f(CW/etc/rsyncd.secrets\fP).  The file must normally not be readable
+by \(lqother\(rq; see \(lqstrict modes\(rq.
 .IP 
 .IP "\fBstrict modes\fP"
-The "strict modes" option determines whether or not
-the permissions on the secrets file will be checked\&.  If "strict modes" is
+The \(lqstrict modes\(rq option determines whether or not
+the permissions on the secrets file will be checked.  If \(lqstrict modes\(rq is
 true, then the secrets file must not be readable by any user ID other
-than the one that the rsync daemon is running under\&.  If "strict modes" is
-false, the check is not performed\&.  The default is true\&.  This option
-was added to accommodate rsync running on the Windows operating system\&.
+than the one that the rsync daemon is running under.  If \(lqstrict modes\(rq is
+false, the check is not performed.  The default is true.  This option
+was added to accommodate rsync running on the Windows operating system.
 .IP 
 .IP "\fBhosts allow\fP"
-The "hosts allow" option allows you to specify a
+The \(lqhosts allow\(rq option allows you to specify a
 list of patterns that are matched against a connecting clients
-hostname and IP address\&. If none of the patterns match then the
-connection is rejected\&.
+hostname and IP address. If none of the patterns match then the
+connection is rejected.
 .IP 
 Each pattern can be in one of five forms:
 .IP 
 .RS 
 .IP o 
-a dotted decimal IPv4 address of the form a\&.b\&.c\&.d, or an IPv6 address
-of the form a:b:c::d:e:f\&. In this case the incoming machine\&'s IP address
-must match exactly\&.
+a dotted decimal IPv4 address of the form a.b.c.d, or an IPv6 address
+of the form a:b:c::d:e:f. In this case the incoming machine's IP address
+must match exactly.
 .IP o 
 an address/mask in the form ipaddr/n where ipaddr is the IP address
-and n is the number of one bits in the netmask\&.  All IP addresses which
-match the masked IP address will be allowed in\&.
+and n is the number of one bits in the netmask.  All IP addresses which
+match the masked IP address will be allowed in.
 .IP o 
 an address/mask in the form ipaddr/maskaddr where ipaddr is the
 IP address and maskaddr is the netmask in dotted decimal notation for IPv4,
-or similar for IPv6, e\&.g\&. ffff:ffff:ffff:ffff:: instead of /64\&. All IP
-addresses which match the masked IP address will be allowed in\&.
+or similar for IPv6, e.g. ffff:ffff:ffff:ffff:: instead of /64. All IP
+addresses which match the masked IP address will be allowed in.
 .IP o 
-a hostname\&. The hostname as determined by a reverse lookup will
-be matched (case insensitive) against the pattern\&. Only an exact
-match is allowed in\&.
-.IP o 
-a hostname pattern using wildcards\&. These are matched using the
-same rules as normal unix filename matching\&. If the pattern matches
-then the client is allowed in\&.
+a hostname. The hostname as determined by a reverse lookup will
+be matched (case insensitive) against the pattern. Only an exact
+match is allowed in.
+.IP o 
+a hostname pattern using wildcards. These are matched using the
+same rules as normal unix filename matching. If the pattern matches
+then the client is allowed in.
 .RE
 
 .IP 
 Note IPv6 link-local addresses can have a scope in the address specification:
 .IP 
 .RS 
@@ -415,98 +514,98 @@
 .br 
 \f(CW    fe80::%link1/ffff:ffff:ffff:ffff::\fP
 .br 
 .RE
 
 .IP 
-You can also combine "hosts allow" with a separate "hosts deny"
-option\&. If both options are specified then the "hosts allow" option s
+You can also combine \(lqhosts allow\(rq with a separate \(lqhosts deny\(rq
+option. If both options are specified then the \(lqhosts allow\(rq option s
 checked first and a match results in the client being able to
-connect\&. The "hosts deny" option is then checked and a match means
-that the host is rejected\&. If the host does not match either the
-"hosts allow" or the "hosts deny" patterns then it is allowed to
-connect\&.
+connect. The \(lqhosts deny\(rq option is then checked and a match means
+that the host is rejected. If the host does not match either the
+\(lqhosts allow\(rq or the \(lqhosts deny\(rq patterns then it is allowed to
+connect.
 .IP 
-The default is no "hosts allow" option, which means all hosts can connect\&.
+The default is no \(lqhosts allow\(rq option, which means all hosts can connect.
 .IP 
 .IP "\fBhosts deny\fP"
-The "hosts deny" option allows you to specify a
+The \(lqhosts deny\(rq option allows you to specify a
 list of patterns that are matched against a connecting clients
-hostname and IP address\&. If the pattern matches then the connection is
-rejected\&. See the "hosts allow" option for more information\&.
+hostname and IP address. If the pattern matches then the connection is
+rejected. See the \(lqhosts allow\(rq option for more information.
 .IP 
-The default is no "hosts deny" option, which means all hosts can connect\&.
+The default is no \(lqhosts deny\(rq option, which means all hosts can connect.
 .IP 
 .IP "\fBignore errors\fP"
-The "ignore errors" option tells rsyncd to
+The \(lqignore errors\(rq option tells rsyncd to
 ignore I/O errors on the daemon when deciding whether to run the delete
-phase of the transfer\&. Normally rsync skips the \fB\-\-delete\fP step if any
+phase of the transfer. Normally rsync skips the \fB\-\-delete\fP step if any
 I/O errors have occurred in order to prevent disastrous deletion due
-to a temporary resource shortage or other I/O error\&. In some cases this
+to a temporary resource shortage or other I/O error. In some cases this
 test is counter productive so you can use this option to turn off this
-behavior\&.
+behavior.
 .IP 
 .IP "\fBignore nonreadable\fP"
 This tells the rsync daemon to completely
-ignore files that are not readable by the user\&. This is useful for
+ignore files that are not readable by the user. This is useful for
 public archives that may have some non-readable files among the
-directories, and the sysadmin doesn\&'t want those files to be seen at all\&.
+directories, and the sysadmin doesn't want those files to be seen at all.
 .IP 
 .IP "\fBtransfer logging\fP"
-The "transfer logging" option enables per-file
+The \(lqtransfer logging\(rq option enables per-file
 logging of downloads and uploads in a format somewhat similar to that
-used by ftp daemons\&.  The daemon always logs the transfer at the end, so
-if a transfer is aborted, no mention will be made in the log file\&.
+used by ftp daemons.  The daemon always logs the transfer at the end, so
+if a transfer is aborted, no mention will be made in the log file.
 .IP 
-If you want to customize the log lines, see the "log format" option\&.
+If you want to customize the log lines, see the \(lqlog format\(rq option.
 .IP 
 .IP "\fBlog format\fP"
-The "log format" option allows you to specify the
-format used for logging file transfers when transfer logging is enabled\&.
+The \(lqlog format\(rq option allows you to specify the
+format used for logging file transfers when transfer logging is enabled.
 The format is a text string containing embedded single-character escape
-sequences prefixed with a percent (%) character\&.  An optional numeric
+sequences prefixed with a percent (%) character.  An optional numeric
 field width may also be specified between the percent and the escape
-letter (e\&.g\&. "%\-50n %8l %07p")\&.
+letter (e.g. \(lq\fB%\-50n %8l %07p\fP\(rq).
 .IP 
-The default log format is "%o %h [%a] %m (%u) %f %l", and a "%t [%p] "
-is always prefixed when using the "log file" option\&.
+The default log format is \(lq%o %h [%a] %m (%u) %f %l\(rq, and a \(lq%t [%p] \(rq
+is always prefixed when using the \(lqlog file\(rq option.
 (A perl script that will summarize this default log format is included
-in the rsync source code distribution in the "support" subdirectory:
-rsyncstats\&.)
+in the rsync source code distribution in the \(lqsupport\(rq subdirectory:
+rsyncstats.)
 .IP 
 The single-character escapes that are understood are as follows:
 .IP 
 .RS 
 .IP o 
 %a the remote IP address
 .IP o 
 %b the number of bytes actually transferred
 .IP o 
-%B the permission bits of the file (e\&.g\&. rwxrwxrwt)
+%B the permission bits of the file (e.g. rwxrwxrwt)
 .IP o 
 %c the checksum bytes received for this file (only when sending)
 .IP o 
-%f the filename (long form on sender; no trailing "/")
+%f the filename (long form on sender; no trailing \(lq/\(rq)
 .IP o 
-%G the gid of the file (decimal) or "DEFAULT"
+%G the gid of the file (decimal) or \(lqDEFAULT\(rq
 .IP o 
 %h the remote host name
 .IP o 
 %i an itemized list of what is being updated
 .IP o 
 %l the length of the file in bytes
 .IP o 
-%L the string " \-> SYMLINK", " => HARDLINK", or "" (where \fBSYMLINK\fP or \fBHARDLINK\fP is a filename)
+%L the string \(lq \-> SYMLINK\(rq, \(lq => HARDLINK\(rq, or \(lq\(rq (where \fBSYMLINK\fP or \fBHARDLINK\fP is a filename)
 .IP o 
 %m the module name
 .IP o 
 %M the last-modified time of the file
 .IP o 
-%n the filename (short form; trailing "/" on dir)
+%n the filename (short form; trailing \(lq/\(rq on dir)
 .IP o 
-%o the operation, which is "send", "recv", or "del\&." (the latter includes the trailing period)
+%o the operation, which is \(lqsend\(rq, \(lqrecv\(rq, or \(lqdel.\(rq (the latter includes the trailing period)
 .IP o 
 %p the process ID of this rsync session
 .IP o 
 %P the module path
 .IP o 
 %t the current date time
@@ -514,137 +613,140 @@
 %u the authenticated username or an empty string
 .IP o 
 %U the uid of the file (decimal)
 .RE
 
 .IP 
-For a list of what the characters mean that are output by "%i", see the
-\fB\-\-itemize\-changes\fP option in the rsync manpage\&.
+For a list of what the characters mean that are output by \(lq%i\(rq, see the
+\fB\-\-itemize\-changes\fP option in the rsync manpage.
 .IP 
 Note that some of the logged output changes when talking with older
-rsync versions\&.  For instance, deleted files were only output as verbose
-messages prior to rsync 2\&.6\&.4\&.
+rsync versions.  For instance, deleted files were only output as verbose
+messages prior to rsync 2.6.4.
 .IP 
 .IP "\fBtimeout\fP"
-The "timeout" option allows you to override the
-clients choice for I/O timeout for this module\&. Using this option you
-can ensure that rsync won\&'t wait on a dead client forever\&. The timeout
-is specified in seconds\&. A value of zero means no timeout and is the
-default\&. A good choice for anonymous rsync daemons may be 600 (giving
-a 10 minute timeout)\&.
+The \(lqtimeout\(rq option allows you to override the
+clients choice for I/O timeout for this module. Using this option you
+can ensure that rsync won't wait on a dead client forever. The timeout
+is specified in seconds. A value of zero means no timeout and is the
+default. A good choice for anonymous rsync daemons may be 600 (giving
+a 10 minute timeout).
 .IP 
 .IP "\fBrefuse options\fP"
-The "refuse options" option allows you to
+The \(lqrefuse options\(rq option allows you to
 specify a space-separated list of rsync command line options that will
-be refused by your rsync daemon\&.
+be refused by your rsync daemon.
 You may specify the full option name, its one-letter abbreviation, or a
-wild-card string that matches multiple options\&.
+wild-card string that matches multiple options.
 For example, this would refuse \fB\-\-checksum\fP (\fB\-c\fP) and all the various
 delete options:
 .IP 
 .RS 
 \f(CW    refuse options = c delete\fP
 .RE
 
 .IP 
 The reason the above refuses all delete options is that the options imply
-\fB\-\-delete\fP, and implied options are refused just like explicit options\&.
-As an additional safety feature, the refusal of "delete" also refuses
-\fBremove-sent-files\fP when the daemon is the sender; if you want the latter
-without the former, instead refuse "delete\-*" -- that refuses all the
-delete modes without affecting \fB\-\-remove\-sent\-files\fP\&.
+\fB\-\-delete\fP, and implied options are refused just like explicit options.
+As an additional safety feature, the refusal of \(lqdelete\(rq also refuses
+\fBremove-source-files\fP when the daemon is the sender; if you want the latter
+without the former, instead refuse \(lqdelete\-*\(rq \(em that refuses all the
+delete modes without affecting \fB\-\-remove\-source\-files\fP.
 .IP 
-When an option is refused, the daemon prints an error message and exits\&.
+When an option is refused, the daemon prints an error message and exits.
 To prevent all compression when serving files,
-you can use "dont compress = *" (see below)
-instead of "refuse options = compress" to avoid returning an error to a
-client that requests compression\&.
+you can use \(lqdont compress = *\(rq (see below)
+instead of \(lqrefuse options = compress\(rq to avoid returning an error to a
+client that requests compression.
 .IP 
 .IP "\fBdont compress\fP"
-The "dont compress" option allows you to select
+The \(lqdont compress\(rq option allows you to select
 filenames based on wildcard patterns that should not be compressed
 when pulling files from the daemon (no analogous option exists to
-govern the pushing of files to a daemon)\&.
+govern the pushing of files to a daemon).
 Compression is expensive in terms of CPU usage, so it
-is usually good to not try to compress files that won\&'t compress well,
-such as already compressed files\&.
-.IP 
-The "dont compress" option takes a space-separated list of
-case-insensitive wildcard patterns\&. Any source filename matching one
-of the patterns will not be compressed during transfer\&.
+is usually good to not try to compress files that won't compress well,
+such as already compressed files.
 .IP 
-The default setting is \f(CW*\&.gz *\&.tgz *\&.zip *\&.z *\&.rpm *\&.deb *\&.iso *\&.bz2 *\&.tbz\fP
+The \(lqdont compress\(rq option takes a space-separated list of
+case-insensitive wildcard patterns. Any source filename matching one
+of the patterns will not be compressed during transfer.
+.IP 
+See the \fB\-\-skip\-compress\fP option in the \fBrsync\fP(1) manpage for the list
+of file suffixes that are not compressed by default.  Specifying a value
+for the \(lqdont compress\(rq option changes the default when the daemon is
+the sender.
 .IP 
 .IP "\fBpre-xfer exec\fP, \fBpost-xfer exec\fP"
 You may specify a command to be run
-before and/or after the transfer\&.  If the \fBpre-xfer exec\fP command fails, the
-transfer is aborted before it begins\&.
+before and/or after the transfer.  If the \fBpre-xfer exec\fP command fails, the
+transfer is aborted before it begins.
 .IP 
 The following environment variables will be set, though some are
 specific to the pre-xfer or the post-xfer environment:
 .IP 
 .RS 
 .IP o 
-\fBRSYNC_MODULE_NAME\fP: The name of the module being accessed\&.
+\fBRSYNC_MODULE_NAME\fP: The name of the module being accessed.
 .IP o 
-\fBRSYNC_MODULE_PATH\fP: The path configured for the module\&.
+\fBRSYNC_MODULE_PATH\fP: The path configured for the module.
 .IP o 
-\fBRSYNC_HOST_ADDR\fP: The accessing host\&'s IP address\&.
+\fBRSYNC_HOST_ADDR\fP: The accessing host's IP address.
 .IP o 
-\fBRSYNC_HOST_NAME\fP: The accessing host\&'s name\&.
+\fBRSYNC_HOST_NAME\fP: The accessing host's name.
 .IP o 
-\fBRSYNC_USER_NAME\fP: The accessing user\&'s name (empty if no user)\&.
+\fBRSYNC_USER_NAME\fP: The accessing user's name (empty if no user).
 .IP o 
-\fBRSYNC_PID\fP: A unique number for this transfer\&.
+\fBRSYNC_PID\fP: A unique number for this transfer.
 .IP o 
 \fBRSYNC_REQUEST\fP: (pre-xfer only) The module/path info specified
 by the user (note that the user can specify multiple source files,
-so the request can be something like "mod/path1 mod/path2", etc\&.)\&.
+so the request can be something like \(lqmod/path1 mod/path2\(rq, etc.).
 .IP o 
 \fBRSYNC_ARG#\fP: (pre-xfer only) The pre-request arguments are set
-in these numbered values\&. RSYNC_ARG0 is always "rsyncd", and the last
-value contains a single period\&.
+in these numbered values. RSYNC_ARG0 is always \(lqrsyncd\(rq, and the last
+value contains a single period.
 .IP o 
-\fBRSYNC_EXIT_STATUS\fP: (post-xfer only) the server side\&'s exit value\&.
+\fBRSYNC_EXIT_STATUS\fP: (post-xfer only) the server side's exit value.
 This will be 0 for a successful run, a positive value for an error that the
-server generated, or a \-1 if rsync failed to exit properly\&.  Note that an
+server generated, or a \-1 if rsync failed to exit properly.  Note that an
 error that occurs on the client side does not currently get sent to the
-server side, so this is not the final exit status for the whole transfer\&.
+server side, so this is not the final exit status for the whole transfer.
 .IP o 
 \fBRSYNC_RAW_STATUS\fP: (post-xfer only) the raw exit value from 
 \f(CWwaitpid()\fP
 \&.
 .RE
 
 .IP 
 Even though the commands can be associated with a particular module, they
 are run using the permissions of the user that started the daemon (not the
-module\&'s uid/gid setting) without any chroot restrictions\&.
+module's uid/gid setting) without any chroot restrictions.
 .IP 
 .SH "AUTHENTICATION STRENGTH"
 
 .PP 
 The authentication protocol used in rsync is a 128 bit MD4 based
-challenge response system\&. This is fairly weak protection, though (with
+challenge response system. This is fairly weak protection, though (with
 at least one brute-force hash-finding algorithm publicly available), so
 if you want really top-quality security, then I recommend that you run
-rsync over ssh\&.  (Yes, a future version of rsync will switch over to a
-stronger hashing method\&.)
+rsync over ssh.  (Yes, a future version of rsync will switch over to a
+stronger hashing method.)
 .PP 
 Also note that the rsync daemon protocol does not currently provide any
-encryption of the data that is transferred over the connection\&. Only
-authentication is provided\&. Use ssh as the transport if you want
-encryption\&.
+encryption of the data that is transferred over the connection. Only
+authentication is provided. Use ssh as the transport if you want
+encryption.
 .PP 
 Future versions of rsync may support SSL for better authentication and
-encryption, but that is still being investigated\&.
+encryption, but that is still being investigated.
 .PP 
 .SH "EXAMPLES"
 
 .PP 
-A simple rsyncd\&.conf file that allow anonymous rsync to a ftp area at
+A simple rsyncd.conf file that allow anonymous rsync to a ftp area at
 \f(CW/home/ftp\fP would be:
 .PP 
 .nf 
 
 [ftp]
         path = /home/ftp
@@ -656,56 +758,56 @@
 A more sophisticated example would be:
 .PP 
 .nf 
 
 uid = nobody
 gid = nobody
-use chroot = no
+use chroot = yes
 max connections = 4
 syslog facility = local5
-pid file = /var/run/rsyncd\&.pid
+pid file = /var/run/rsyncd.pid
 
 [ftp]
-        path = /var/ftp/pub
-        comment = whole ftp area (approx 6\&.1 GB)
+        path = /var/ftp/./pub
+        comment = whole ftp area (approx 6.1 GB)
 
 [sambaftp]
-        path = /var/ftp/pub/samba
+        path = /var/ftp/./pub/samba
         comment = Samba ftp area (approx 300 MB)
 
 [rsyncftp]
-        path = /var/ftp/pub/rsync
+        path = /var/ftp/./pub/rsync
         comment = rsync ftp area (approx 6 MB)
 
 [sambawww]
         path = /public_html/samba
         comment = Samba WWW pages (approx 240 MB)
 
 [cvs]
         path = /data/cvs
         comment = CVS repository (requires authentication)
         auth users = tridge, susan
-        secrets file = /etc/rsyncd\&.secrets
+        secrets file = /etc/rsyncd.secrets
 
 .fi 
 
 .PP 
-The /etc/rsyncd\&.secrets file would look something like this:
+The /etc/rsyncd.secrets file would look something like this:
 .PP 
 .RS 
 \f(CWtridge:mypass\fP
 .br 
 \f(CWsusan:herpass\fP
 .br 
 .RE
 
 .PP 
 .SH "FILES"
 
 .PP 
-/etc/rsyncd\&.conf or rsyncd\&.conf
+/etc/rsyncd.conf or rsyncd.conf
 .PP 
 .SH "SEE ALSO"
 
 .PP 
 \fBrsync\fP(1)
 .PP 
@@ -713,45 +815,45 @@
 
 .PP 
 .SH "BUGS"
 
 .PP 
 Please report bugs! The rsync bug tracking system is online at
-http://rsync\&.samba\&.org/
+http://rsync.samba.org/
 .PP 
 .SH "VERSION"
 
 .PP 
-This man page is current for version 2\&.6\&.9 of rsync\&.
+This man page is current for version 3.0.0 of rsync.
 .PP 
 .SH "CREDITS"
 
 .PP 
-rsync is distributed under the GNU public license\&.  See the file
-COPYING for details\&.
+rsync is distributed under the GNU public license.  See the file
+COPYING for details.
 .PP 
 The primary ftp site for rsync is
-ftp://rsync\&.samba\&.org/pub/rsync\&.
+ftp://rsync.samba.org/pub/rsync.
 .PP 
 A WEB site is available at
-http://rsync\&.samba\&.org/
+http://rsync.samba.org/
 .PP 
-We would be delighted to hear from you if you like this program\&.
+We would be delighted to hear from you if you like this program.
 .PP 
 This program uses the zlib compression library written by Jean-loup
-Gailly and Mark Adler\&.
+Gailly and Mark Adler.
 .PP 
 .SH "THANKS"
 
 .PP 
 Thanks to Warren Stanley for his original idea and patch for the rsync
-daemon\&. Thanks to Karsten Thygesen for his many suggestions and
+daemon. Thanks to Karsten Thygesen for his many suggestions and
 documentation!
 .PP 
 .SH "AUTHOR"
 
 .PP 
-rsync was written by Andrew Tridgell and Paul Mackerras\&.
-Many people have later contributed to it\&.
+rsync was written by Andrew Tridgell and Paul Mackerras.
+Many people have later contributed to it.
 .PP 
 Mailing lists for support and development are available at
-http://lists\&.samba\&.org
+http://lists.samba.org
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsyncd.conf.yo	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsyncd.conf.yo	2008-03-02 04:12:04.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(6 Nov 2006)()()
+manpage(rsyncd.conf)(5)(1 Mar 2008)()()
 manpagename(rsyncd.conf)(configuration file for rsync in daemon mode)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -14,13 +14,13 @@
 available modules.
 
 manpagesection(FILE FORMAT)
 
 The file consists of modules and parameters. A module begins with the
 name of the module in square brackets and continues until the next
-module begins. Modules contain parameters of the form 'name = value'.
+module begins. Modules contain parameters of the form "name = value".
 
 The file is line-based -- that is, each newline-terminated line represents
 either a comment, a module name or a parameter.
 
 Only the first equals sign in a parameter is significant. Whitespace before
 or after the first equals sign is discarded. Leading, trailing and internal
@@ -82,13 +82,14 @@
 dit(bf(motd file)) The "motd file" option allows you to specify a
 "message of the day" to display to clients on each connect. This
 usually contains site information and any legal notices. The default
 is no motd file.
 
 dit(bf(pid file)) The "pid file" option tells the rsync daemon to write
-its process ID to that file.
+its process ID to that file.  If the file already exists, the rsync
+daemon will abort rather than overwrite the file.
 
 dit(bf(port)) You can override the default port the daemon will listen on
 by specifying this value (defaults to 873).  This is ignored if the daemon
 is being run by inetd, and is superseded by the bf(--port) command-line option.
 
 dit(bf(address)) You can override the default IP address the daemon
@@ -109,12 +110,16 @@
 manpagesection(MODULE OPTIONS)
 
 After the global options you should define a number of modules, each
 module exports a directory tree as a symbolic name. Modules are
 exported by specifying a module name in square brackets [module]
 followed by the options for that module.
+The module name cannot contain a slash or a closing square bracket.  If the
+name contains whitespace, each internal sequence of whitespace will be
+changed into a single space, while leading or trailing whitespace will be
+discarded.
 
 startdit()
 
 dit(bf(comment)) The "comment" option specifies a description string
 that is displayed next to the module name when clients obtain a list
 of available modules. The default is no comment.
@@ -125,46 +130,124 @@
 
 dit(bf(use chroot)) If "use chroot" is true, the rsync daemon will chroot
 to the "path" before starting the file transfer with the client.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges,
 of not being able to follow symbolic links that are either absolute or outside
-of the new root path, and of complicating the preservation of usernames and groups
-(see below).  When "use chroot" is false, for security reasons,
-symlinks may only be relative paths pointing to other files within the root
-path, and leading slashes are removed from most absolute paths (options
-such as bf(--backup-dir), bf(--compare-dest), etc. interpret an absolute path as
-rooted in the module's "path" dir, just as if chroot was specified).
-The default for "use chroot" is true.
+of the new root path, and of complicating the preservation of users and groups
+by name (see below).
 
-In order to preserve usernames and groupnames, rsync needs to be able to
+As an additional safety feature, you can specify a dot-dir in the module's
+"path" to indicate the point where the chroot should occur.  This allows rsync
+to run in a chroot with a non-"/" path for the top of the transfer hierarchy.
+Doing this guards against unintended library loading (since those absolute
+paths will not be inside the transfer hierarchy unless you have used an unwise
+pathname), and lets you setup libraries for the chroot that are outside of the
+transfer.  For example, specifying "/var/rsync/./module1" will chroot to the
+"/var/rsync" directory and set the inside-chroot path to "/module1".  If you
+had omitted the dot-dir, the chroot would have used the whole path, and the
+inside-chroot path would have been "/".
+
+When "use chroot" is false or the inside-chroot path is not "/", rsync will:
+(1) munge symlinks by
+default for security reasons (see "munge symlinks" for a way to turn this
+off, but only if you trust your users), (2) substitute leading slashes in
+absolute paths with the module's path (so that options such as
+bf(--backup-dir), bf(--compare-dest), etc. interpret an absolute path as
+rooted in the module's "path" dir), and (3) trim ".." path elements from
+args if rsync believes they would escape the module hierarchy.
+The default for "use chroot" is true, and is the safer choice (especially
+if the module is not read-only).
+
+When this option is enabled, rsync will not attempt to map users and groups
+by name (by default), but instead copy IDs as though bf(--numeric-ids) had
+been specified.  In order to enable name-mapping, rsync needs to be able to
 use the standard library functions for looking up names and IDs (i.e.
-code(getpwuid()), code(getgrgid()), code(getpwname()), and code(getgrnam())).  This means a
-process in the chroot namespace will need to have access to the resources
+code(getpwuid()), code(getgrgid()), code(getpwname()), and code(getgrnam())).
+This means the rsync
+process in the chroot hierarchy will need to have access to the resources
 used by these library functions (traditionally /etc/passwd and
-/etc/group).  If these resources are not available, rsync will only be
-able to copy the IDs, just as if the bf(--numeric-ids) option had been
-specified.
-
-Note that you are free to setup user/group information in the chroot area
-differently from your normal system.  For example, you could abbreviate
-the list of users and groups.  Also, you can protect this information from
-being downloaded/uploaded by adding an exclude rule to the rsyncd.conf file
-(e.g. "exclude = /etc/**").  Note that having the exclusion affect uploads
-is a relatively new feature in rsync, so make sure your daemon is
-at least 2.6.3 to effect this.  Also note that it is safest to exclude a
-directory and all its contents combining the rule "/some/dir/" with the
-rule "/some/dir/**" just to be sure that rsync will not allow deeper
-access to some of the excluded files inside the directory (rsync tries to
-do this automatically, but you might as well specify both to be extra
-sure).
+/etc/group, but perhaps additional dynamic libraries as well).
+
+If you copy the necessary resources into the module's chroot area, you
+should protect them through your OS's normal user/group or ACL settings (to
+prevent the rsync module's user from being able to change them), and then
+hide them from the user's view via "exclude" (see how in the discussion of
+that option).  At that point it will be safe to enable the mapping of users
+and groups by name using the "numeric ids" daemon option (see below).
+
+Note also that you are free to setup custom user/group information in the
+chroot area that is different from your normal system.  For example, you
+could abbreviate the list of users and groups.
+
+dit(bf(numeric ids)) Enabling the "numeric ids" option disables the mapping
+of users and groups by name for the current daemon module.  This prevents
+the daemon from trying to load any user/group-related files or libraries.
+Enabling this option makes the transfer behave as if the client had passed
+the bf(--numeric-ids) command-line option.  By default, this parameter is
+enabled for chroot modules and disabled for non-chroot modules.
+
+A chroot-enabled module should not have this option enabled unless you've
+taken steps to ensure that the module has the necessary resources it needs
+to translate names, and that it is not possible for a user to change those
+resources.
+
+dit(bf(munge symlinks))  The "munge symlinks" option tells rsync to modify
+all incoming symlinks in a way that makes them unusable but recoverable
+(see below).  This should help protect your files from user trickery when
+your daemon module is writable.  The default is disabled when "use chroot"
+is on and the inside-chroot path is "/", otherwise it is enabled.
+
+If you disable this option on a daemon that is not read-only, there
+are tricks that a user can play with uploaded symlinks to access
+daemon-excluded items (if your module has any), and, if "use chroot"
+is off, rsync can even be tricked into showing or changing data that
+is outside the module's path (as access-permissions allow).
+
+The way rsync disables the use of symlinks is to prefix each one with
+the string "/rsyncd-munged/".  This prevents the links from being used
+as long as that directory does not exist.  When this option is enabled,
+rsync will refuse to run if that path is a directory or a symlink to
+a directory.  When using the "munge symlinks" option in a chroot area
+that has an inside-chroot path of "/", you should add "/rsyncd-munged/"
+to the exclude setting for the module so that
+a user can't try to create it.
+
+Note:  rsync makes no attempt to verify that any pre-existing symlinks in
+the hierarchy are as safe as you want them to be.  If you setup an rsync
+daemon on a new area or locally add symlinks, you can manually protect your
+symlinks from being abused by prefixing "/rsyncd-munged/" to the start of
+every symlink's value.  There is a perl script in the support directory
+of the source code named "munge-symlinks" that can be used to add or remove
+this prefix from your symlinks.
+
+When this option is disabled on a writable module and "use chroot" is off
+(or the inside-chroot path is not "/"),
+incoming symlinks will be modified to drop a leading slash and to remove ".."
+path elements that rsync believes will allow a symlink to escape the module's
+hierarchy.  There are tricky ways to work around this, though, so you had
+better trust your users if you choose this combination of options.
+
+dit(bf(charset)) This specifies the name of the character set in which the
+module's filenames are stored.  If the client uses an bf(--iconv) option,
+the daemon will use the value of the "charset" parameter regardless of the
+character set the client actually passed.  This allows the daemon to
+support charset conversion in a chroot module without extra files in the
+chroot area, and also ensures that name-translation is done in a consistent
+manner.  If the "charset" parameter is not set, the bf(--iconv) option is
+refused, just as if "iconv" had been specified via "refuse options".
+
+If you wish to force users to always use bf(--iconv) for a particular
+module, add "no-iconv" to the "refuse options" parameter.  Keep in mind
+that this will restrict access to your module to very new rsync clients.
 
 dit(bf(max connections)) The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow.
 Any clients connecting when the maximum has been reached will receive a
-message telling them to try later.  The default is 0 which means no limit.
+message telling them to try later.  The default is 0, which means no limit.
+A negative value disables the module.
 See also the "lock file" option.
 
 dit(bf(log file)) When the "log file" option is set to a non-empty
 string, the rsync daemon will log messages to the indicated file rather
 than using syslog. This is particularly useful on systems (such as AIX)
 where code(syslog()) doesn't work for chrooted programs.  The file is
@@ -223,12 +306,17 @@
 
 dit(bf(gid)) The "gid" option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. This complements the "uid" option. The default is gid -2,
 which is normally the group "nobody".
 
+dit(bf(fake super)) Setting "fake super = yes" for a module causes the
+daemon side to behave as if the bf(--fake-user) command-line option had
+been specified.  This allows the full attributes of a file to be stored
+without having to have the daemon actually running as root.
+
 dit(bf(filter)) The "filter" option allows you to specify a space-separated
 list of filter rules that the daemon will not allow to be read or written.
 This is only superficially equivalent to the client specifying these
 patterns with the bf(--filter) option.  Only one "filter" option may be
 specified, but it may contain as many rules as you like, including
 merge-file rules.  Note that per-directory merge-file rules do not provide
@@ -246,12 +334,19 @@
 Because this exclude list is not passed to the client it only applies on
 the daemon: that is, it excludes files received by a client when receiving
 from a daemon and files deleted on a daemon when sending to a daemon, but
 it doesn't exclude files from being deleted on a client when receiving
 from a daemon.
 
+When you want to exclude a directory and all its contents, it is safest to
+use a rule that does both, such as "/some/dir/***" (the three stars tells
+rsync to exclude the directory itself and everything inside it).  This is
+better than just excluding the directory alone with "/some/dir/", as it
+helps to guard against attempts to trick rsync into accessing files deeper
+in the hierarchy.
+
 dit(bf(exclude from)) The "exclude from" option specifies a filename
 on the daemon that contains exclude patterns, one per line.
 This is only superficially equivalent
 to the client specifying the bf(--exclude-from) option with an equivalent file.
 See the "exclude" option above.
 
@@ -399,13 +494,13 @@
 
 dit(bf(log format)) The "log format" option allows you to specify the
 format used for logging file transfers when transfer logging is enabled.
 The format is a text string containing embedded single-character escape
 sequences prefixed with a percent (%) character.  An optional numeric
 field width may also be specified between the percent and the escape
-letter (e.g. "%-50n %8l %07p").
+letter (e.g. "bf(%-50n %8l %07p)").
 
 The default log format is "%o %h [%a] %m (%u) %f %l", and a "%t [%p] "
 is always prefixed when using the "log file" option.
 (A perl script that will summarize this default log format is included
 in the rsync source code distribution in the "support" subdirectory:
 rsyncstats.)
@@ -458,15 +553,15 @@
 
 quote(tt(    refuse options = c delete))
 
 The reason the above refuses all delete options is that the options imply
 bf(--delete), and implied options are refused just like explicit options.
 As an additional safety feature, the refusal of "delete" also refuses
-bf(remove-sent-files) when the daemon is the sender; if you want the latter
+bf(remove-source-files) when the daemon is the sender; if you want the latter
 without the former, instead refuse "delete-*" -- that refuses all the
-delete modes without affecting bf(--remove-sent-files).
+delete modes without affecting bf(--remove-source-files).
 
 When an option is refused, the daemon prints an error message and exits.
 To prevent all compression when serving files,
 you can use "dont compress = *" (see below)
 instead of "refuse options = compress" to avoid returning an error to a
 client that requests compression.
@@ -480,13 +575,16 @@
 such as already compressed files.
 
 The "dont compress" option takes a space-separated list of
 case-insensitive wildcard patterns. Any source filename matching one
 of the patterns will not be compressed during transfer.
 
-The default setting is tt(*.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz)
+See the bf(--skip-compress) option in the bf(rsync)(1) manpage for the list
+of file suffixes that are not compressed by default.  Specifying a value
+for the "dont compress" option changes the default when the daemon is
+the sender.
 
 dit(bf(pre-xfer exec), bf(post-xfer exec)) You may specify a command to be run
 before and/or after the transfer.  If the bf(pre-xfer exec) command fails, the
 transfer is aborted before it begins.
 
 The following environment variables will be set, though some are
@@ -549,27 +647,27 @@
 
 A more sophisticated example would be:
 
 verb(
 uid = nobody
 gid = nobody
-use chroot = no
+use chroot = yes
 max connections = 4
 syslog facility = local5
 pid file = /var/run/rsyncd.pid
 
 [ftp]
-        path = /var/ftp/pub
+        path = /var/ftp/./pub
         comment = whole ftp area (approx 6.1 GB)
 
 [sambaftp]
-        path = /var/ftp/pub/samba
+        path = /var/ftp/./pub/samba
         comment = Samba ftp area (approx 300 MB)
 
 [rsyncftp]
-        path = /var/ftp/pub/rsync
+        path = /var/ftp/./pub/rsync
         comment = rsync ftp area (approx 6 MB)
 
 [sambawww]
         path = /public_html/samba
         comment = Samba WWW pages (approx 240 MB)
 
@@ -601,13 +699,13 @@
 
 Please report bugs! The rsync bug tracking system is online at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 2.6.9 of rsync.
+This man page is current for version 3.0.0 of rsync.
 
 manpagesection(CREDITS)
 
 rsync is distributed under the GNU public license.  See the file
 COPYING for details.
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.h	2006-10-24 11:31:30.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.h	2008-03-02 04:12:04.000000000 +0800
@@ -1,25 +1,24 @@
 /*
  * Copyright (C) 1996, 2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #define False 0
 #define True 1
 
 #define BLOCK_SIZE 700
@@ -30,47 +29,75 @@
 /* RSYNCD_SYSCONF is now set in config.h */
 #define RSYNCD_USERCONF "rsyncd.conf"
 
 #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
 #define URL_PREFIX "rsync://"
 
+#define SYMLINK_PREFIX "/rsyncd-munged/"
+#define SYMLINK_PREFIX_LEN ((int)sizeof SYMLINK_PREFIX - 1)
+
 #define BACKUP_SUFFIX "~"
 
 /* a non-zero CHAR_OFFSET makes the rolling sum stronger, but is
    incompatible with older versions :-( */
 #define CHAR_OFFSET 0
 
 /* These flags are only used during the flist transfer. */
 
 #define XMIT_TOP_DIR (1<<0)
 #define XMIT_SAME_MODE (1<<1)
-#define XMIT_EXTENDED_FLAGS (1<<2)
-#define XMIT_SAME_RDEV_pre28 XMIT_EXTENDED_FLAGS /* Only in protocols < 28 */
+#define XMIT_SAME_RDEV_pre28 (1<<2)	/* protocols 20 - 27  */
+#define XMIT_EXTENDED_FLAGS (1<<2)	/* protocols 28 - now */
 #define XMIT_SAME_UID (1<<3)
 #define XMIT_SAME_GID (1<<4)
 #define XMIT_SAME_NAME (1<<5)
 #define XMIT_LONG_NAME (1<<6)
 #define XMIT_SAME_TIME (1<<7)
-#define XMIT_SAME_RDEV_MAJOR (1<<8)
-#define XMIT_HAS_IDEV_DATA (1<<9)
-#define XMIT_SAME_DEV (1<<10)
-#define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
+#define XMIT_SAME_RDEV_MAJOR (1<<8)	/* protocols 28 - now (devices only) */
+#define XMIT_NO_CONTENT_DIR (1<<8)	/* protocols 30 - now (dirs only) */
+#define XMIT_HLINKED (1<<9)		/* protocols 28 - now */
+#define XMIT_SAME_DEV_pre30 (1<<10)	/* protocols 28 - 29  */
+#define XMIT_USER_NAME_FOLLOWS (1<<10)	/* protocols 30 - now */
+#define XMIT_RDEV_MINOR_8_pre30 (1<<11)	/* protocols 28 - 29  */
+#define XMIT_GROUP_NAME_FOLLOWS (1<<11) /* protocols 30 - now */
+#define XMIT_HLINK_FIRST (1<<12)	/* protocols 30 - now (HLINKED files only) */
 
 /* These flags are used in the live flist data. */
 
-#define FLAG_TOP_DIR (1<<0)
-#define FLAG_SENT (1<<1)	/* sender */
-#define FLAG_HLINK_EOL (1<<1)	/* receiver/generator */
-#define FLAG_MOUNT_POINT (1<<2)	/* sender/generator */
-#define FLAG_DEL_HERE (1<<3)	/* receiver/generator */
-#define FLAG_HLINK_TOL (1<<4)	/* receiver/generator */
-#define FLAG_NO_FUZZY (1<<5)	/* generator */
-#define FLAG_MISSING (1<<6)	/* generator */
+#define FLAG_TOP_DIR (1<<0)	/* sender/receiver/generator */
+#define FLAG_FILE_SENT (1<<1)	/* sender/receiver/generator */
+#define FLAG_DIR_CREATED (1<<1)	/* generator */
+#define FLAG_CONTENT_DIR (1<<2)	/* sender/receiver/generator */
+#define FLAG_MOUNT_DIR (1<<3)	/* sender/generator */
+#define FLAG_DUPLICATE (1<<4)	/* sender */
+#define FLAG_MISSING_DIR (1<<4)	/* generator */
+#define FLAG_HLINKED (1<<5)	/* receiver/generator (checked on all types) */
+#define FLAG_HLINK_FIRST (1<<6)	/* receiver/generator (w/FLAG_HLINKED) */
+#define FLAG_IMPLIED_DIR (1<<6)	/* sender/receiver/generator (dirs only) */
+#define FLAG_HLINK_LAST (1<<7)	/* receiver/generator */
+#define FLAG_HLINK_DONE (1<<8)	/* receiver/generator (checked on all types) */
+#define FLAG_LENGTH64 (1<<9)	/* sender/receiver/generator */
+#define FLAG_SKIP_GROUP (1<<10)	/* receiver/generator */
+#define FLAG_TIME_FAILED (1<<11)/* generator */
+
+/* These flags are passed to functions but not stored. */
+
+#define FLAG_DIVERT_DIRS (1<<16)/* sender */
+
+#define BITS_SET(val,bits) (((val) & (bits)) == (bits))
+#define BITS_SETnUNSET(val,onbits,offbits) (((val) & ((onbits)|(offbits))) == (onbits))
+#define BITS_EQUAL(b1,b2,mask) (((unsigned)(b1) & (unsigned)(mask)) \
+			     == ((unsigned)(b2) & (unsigned)(mask)))
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 29
+#define PROTOCOL_VERSION 30
+
+/* This is used when working on a new protocol version in CVS, and should
+ * be a new non-zero value for each CVS change that affects the protocol.
+ * It must ALWAYS be 0 when the protocol goes final! */
+#define SUBPROTOCOL_VERSION 0
 
 /* We refuse to interoperate with versions that are not in this range.
  * Note that we assume we'll work with later versions: the onus is on
  * people writing them to make sure that they don't send us anything
  * we won't understand.
  *
@@ -87,20 +114,22 @@
  * MAX_PROTOCOL_VERSION. */
 
 #define MIN_PROTOCOL_VERSION 20
 #define OLD_PROTOCOL_VERSION 25
 #define MAX_PROTOCOL_VERSION 40
 
+#define FILECNT_LOOKAHEAD 1000
+
 #define RSYNC_PORT 873
 
 #define SPARSE_WRITE_SIZE (1024)
 #define WRITE_SIZE (32*1024)
 #define CHUNK_SIZE (32*1024)
 #define MAX_MAP_SIZE (256*1024)
 #define IO_BUFFER_SIZE (4092)
-#define MAX_BLOCK_SIZE ((int32)1 << 29)
+#define MAX_BLOCK_SIZE ((int32)1 << 17)
 
 #define IOERR_GENERAL	(1<<0) /* For backward compatibility, this must == 1 */
 #define IOERR_VANISHED	(1<<1)
 #define IOERR_DEL_LIMIT (1<<2)
 
 #define MAX_ARGS 1000
@@ -150,34 +179,55 @@
 #define ITEM_IS_NEW (1<<13)
 #define ITEM_LOCAL_CHANGE (1<<14)
 #define ITEM_TRANSFER (1<<15)
 /* These are outside the range of the transmitted flags. */
 #define ITEM_MISSING_DATA (1<<16)	   /* used by log_formatted() */
 #define ITEM_DELETED (1<<17)		   /* used by log_formatted() */
+#define ITEM_MATCHED (1<<18)		   /* used by itemize() */
 
 #define SIGNIFICANT_ITEM_FLAGS (~(\
 	ITEM_BASIS_TYPE_FOLLOWS | ITEM_XNAME_FOLLOWS | ITEM_LOCAL_CHANGE))
 
-
-/* Log-message categories.  Only FERROR and FINFO get sent over the socket,
- * but FLOG and FSOCKERR can be sent over the receiver -> generator pipe.
- * FLOG only goes to the log file, not the client; FCLIENT is the opposite. */
-enum logcode { FNONE=0, FERROR=1, FINFO=2, FLOG=3, FCLIENT=4, FSOCKERR=5 };
+#define CFN_KEEP_LEADING_DOT_DIR (1<<0)
+#define CFN_KEEP_TRAILING_SLASH (1<<1)
+#define CFN_DROP_TRAILING_DOT_DIR (1<<2)
+#define CFN_COLLAPSE_DOT_DOT_DIRS (1<<3)
+
+/* Log-message categories.  FLOG only goes to the log file, not the client;
+ * FCLIENT is the opposite. */
+enum logcode {
+    FNONE=0, /* never sent */
+    FERROR_XFER=1, FINFO=2, /* sent over socket for any protocol */
+    FERROR=3, FWARNING=4, /* sent over socket for protocols >= 30 */
+    FERROR_SOCKET=5, FLOG=6, /* only sent via receiver -> generator pipe */
+    FCLIENT=7 /* never transmitted (e.g. server converts to FINFO) */
+};
 
 /* Messages types that are sent over the message channel.  The logcode
  * values must all be present here with identical numbers. */
 enum msgcode {
 	MSG_DATA=0,	/* raw data on the multiplexed stream */
-	MSG_ERROR=FERROR, MSG_INFO=FINFO, /* remote logging */
-	MSG_LOG=FLOG, MSG_SOCKERR=FSOCKERR, /* sibling logging */
+	MSG_ERROR_XFER=FERROR_XFER, MSG_INFO=FINFO, /* remote logging */
+	MSG_ERROR=FERROR, MSG_WARNING=FWARNING, /* protocol-30 remote logging */
+	MSG_ERROR_SOCKET=FERROR_SOCKET, /* sibling logging */
+	MSG_LOG=FLOG, MSG_CLIENT=FCLIENT, /* sibling logging */
 	MSG_REDO=9,	/* reprocess indicated flist index */
+	MSG_FLIST=20,	/* extra file list over sibling socket */
+	MSG_FLIST_EOF=21,/* we've transmitted all the file lists */
+	MSG_IO_ERROR=22,/* the sending side had an I/O error */
+	MSG_NOOP=42,	/* a do-nothing message */
 	MSG_SUCCESS=100,/* successfully updated indicated flist index */
 	MSG_DELETED=101,/* successfully deleted a file on receiving side */
+	MSG_NO_SEND=102,/* sender failed to open a file we wanted */
 	MSG_DONE=86	/* current phase is done */
 };
 
+#define NDX_DONE -1
+#define NDX_FLIST_EOF -2
+#define NDX_FLIST_OFFSET -101
+
 #include "errcode.h"
 
 #include "config.h"
 
 /* The default RSYNC_RSH is always set in config.h. */
 
@@ -202,12 +252,18 @@
 # endif
 # include <string.h>
 #endif
 #ifdef HAVE_STRINGS_H
 # include <strings.h>
 #endif
+#ifdef HAVE_INTTYPES_H
+# include <inttypes.h>
+#endif
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
 
 #ifdef HAVE_SYS_PARAM_H
 #include <sys/param.h>
@@ -283,13 +339,15 @@
 #include <pwd.h>
 #include <grp.h>
 
 #include <stdarg.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
+#ifdef HAVE_NETDB_H
 #include <netdb.h>
+#endif
 #include <syslog.h>
 #include <sys/file.h>
 
 #ifdef HAVE_DIRENT_H
 # include <dirent.h>
 #else
@@ -325,33 +383,86 @@
 #endif
 
 #ifdef HAVE_LIMITS_H
 # include <limits.h>
 #endif
 
+#if defined HAVE_ICONV_OPEN && defined HAVE_ICONV_H
+#include <iconv.h>
+#ifndef ICONV_CONST
+#define ICONV_CONST
+#endif
+#else
+#ifdef ICONV_CONST
+#undef ICONV_CONST
+#endif
+#ifdef ICONV_OPTION
+#undef ICONV_OPTION
+#endif
+#ifdef iconv_t
+#undef iconv_t
+#endif
+#define iconv_t int
+#endif
+
 #include <assert.h>
 
 #include "lib/pool_alloc.h"
 
+#ifndef HAVE_ID_T
+typedef unsigned int id_t;
+#endif
+#ifndef HAVE_PID_T
+typedef int pid_t;
+#endif
+#ifndef HAVE_MODE_T
+typedef unsigned int mode_t;
+#endif
+#ifndef HAVE_OFF_T
+typedef long off_t;
+#endif
+#ifndef HAVE_SIZE_T
+typedef unsigned int size_t;
+#endif
+
 #define BOOL int
 
 #ifndef uchar
 #define uchar unsigned char
 #endif
 
 #ifdef SIGNED_CHAR_OK
 #define schar signed char
 #else
 #define schar char
 #endif
 
+#ifndef int16
+#if SIZEOF_INT16_T == 2
+# define int16 int16_t
+#else
+# define int16 short
+#endif
+#endif
+
+#ifndef uint16
+#if SIZEOF_UINT16_T == 2
+# define uint16 uint16_t
+#else
+# define uint16 unsigned int16
+#endif
+#endif
+
 /* Find a variable that is either exactly 32-bits or longer.
  * If some code depends on 32-bit truncation, it will need to
  * take special action in a "#if SIZEOF_INT32 > 4" section. */
 #ifndef int32
-#if SIZEOF_INT == 4
+#if SIZEOF_INT32_T == 4
+# define int32 int32_t
+# define SIZEOF_INT32 4
+#elif SIZEOF_INT == 4
 # define int32 int
 # define SIZEOF_INT32 4
 #elif SIZEOF_LONG == 4
 # define int32 long
 # define SIZEOF_INT32 4
 #elif SIZEOF_SHORT == 4
@@ -368,13 +479,17 @@
 #endif
 #else
 # define SIZEOF_INT32 4
 #endif
 
 #ifndef uint32
-#define uint32 unsigned int32
+#if SIZEOF_UINT32_T == 4
+# define uint32 uint32_t
+#else
+# define uint32 unsigned int32
+#endif
 #endif
 
 #if SIZEOF_OFF_T == 8 || !SIZEOF_OFF64_T || !defined HAVE_STRUCT_STAT64
 #define OFF_T off_t
 #define STRUCT_STAT struct stat
 #else
@@ -386,13 +501,16 @@
 /* CAVEAT: on some systems, int64 will really be a 32-bit integer IFF
  * that's the maximum size the file system can handle and there is no
  * 64-bit type available.  The rsync source must therefore take steps
  * to ensure that any code that really requires a 64-bit integer has
  * it (e.g. the checksum code uses two 32-bit integers for its 64-bit
  * counter). */
-#if SIZEOF_LONG == 8
+#if SIZEOF_INT64_T == 8
+# define int64 int64_t
+# define SIZEOF_INT64 8
+#elif SIZEOF_LONG == 8
 # define int64 long
 # define SIZEOF_INT64 8
 #elif SIZEOF_INT == 8
 # define int64 int
 # define SIZEOF_INT64 8
 #elif SIZEOF_LONG_LONG == 8
@@ -416,57 +534,45 @@
 #else
 /* As long as it gets... */
 # define int64 off_t
 # define SIZEOF_INT64 SIZEOF_OFF_T
 #endif
 
-/* Starting from protocol version 26, we always use 64-bit
- * ino_t and dev_t internally, even if this platform does not
- * allow files to have 64-bit inums.  That's because the
- * receiver needs to find duplicate (dev,ino) tuples to detect
- * hardlinks, and it might have files coming from a platform
- * that has 64-bit inums.
- *
- * The only exception is if we're on a platform with no 64-bit type at
- * all.
- *
- * Because we use read_longint() to get these off the wire, if you
- * transfer devices or hardlinks with dev or inum > 2**32 to a machine
- * with no 64-bit types then you will get an overflow error.  Probably
- * not many people have that combination of machines, and you can
- * avoid it by not preserving hardlinks or not transferring device
- * nodes.  It's not clear that any other behaviour is better.
- *
- * Note that if you transfer devices from a 64-bit-devt machine (say,
- * Solaris) to a 32-bit-devt machine (say, Linux-2.2/x86) then the
- * device numbers will be truncated.  But it's a kind of silly thing
- * to do anyhow.
- *
- * FIXME: I don't think the code in flist.c has ever worked on a system
- * where dev_t is a struct.
- */
+struct hashtable {
+	void *nodes;
+	int32 size, entries;
+	uint32 node_size;
+	int key64;
+};
+
+struct ht_int32_node {
+	void *data;
+	int32 key;
+};
 
-struct idev {
-	int64 inode;
-	int64 dev;
+struct ht_int64_node {
+	void *data;
+	int64 key;
 };
 
+#define HT_NODE(tbl, bkts, i) ((void*)((char*)(bkts) + (i)*(tbl)->node_size))
+#define HT_KEY(node, k64) ((k64)? ((struct ht_int64_node*)(node))->key \
+			 : (int64)((struct ht_int32_node*)(node))->key)
+
 #ifndef MIN
 #define MIN(a,b) ((a)<(b)?(a):(b))
 #endif
 
 #ifndef MAX
 #define MAX(a,b) ((a)>(b)?(a):(b))
 #endif
 
 #ifndef MAXHOSTNAMELEN
 #define MAXHOSTNAMELEN 256
 #endif
 
-/* the length of the md4 checksum */
-#define MD4_SUM_LENGTH 16
 #define SUM_LENGTH 16
 #define SHORT_SUM_LENGTH 2
 #define BLOCKSUM_BIAS 10
 
 #ifndef MAXPATHLEN
 #define MAXPATHLEN 1024
@@ -489,82 +595,142 @@
 #endif
 
 #ifndef IN_LOOPBACKNET
 #define IN_LOOPBACKNET 127
 #endif
 
-#define GID_NONE ((gid_t)-1)
+#if HAVE_UNIXWARE_ACLS|HAVE_SOLARIS_ACLS|HAVE_HPUX_ACLS
+#define ACLS_NEED_MASK 1
+#endif
 
-#define HL_CHECK_MASTER	0
-#define HL_SKIP		1
+union file_extras {
+	int32 num;
+	uint32 unum;
+};
 
-struct hlink {
-	int32 next;
-	int32 hlindex;
-	unsigned short link_dest_used;
+struct file_struct {
+	const char *dirname;	/* The dir info inside the transfer */
+	time_t modtime;		/* When the item was last modified */
+	uint32 len32;		/* Lowest 32 bits of the file's length */
+	uint16 mode;		/* The item's type and permissions */
+	uint16 flags;		/* The FLAG_* bits for this item */
+	const char basename[1];	/* The basename (AKA filename) follows */
 };
 
-#define F_DEV	link_u.idev->dev
-#define F_INODE	link_u.idev->inode
+extern int file_extra_cnt;
+extern int inc_recurse;
+extern int uid_ndx;
+extern int gid_ndx;
+extern int acls_ndx;
+extern int xattrs_ndx;
+
+#define FILE_STRUCT_LEN (offsetof(struct file_struct, basename))
+#define EXTRA_LEN (sizeof (union file_extras))
+#define PTR_EXTRA_CNT ((sizeof (char *) + EXTRA_LEN - 1) / EXTRA_LEN)
+#define DEV_EXTRA_CNT 2
+#define DIRNODE_EXTRA_CNT 3
+#define SUM_EXTRA_CNT ((MAX_DIGEST_LEN + EXTRA_LEN - 1) / EXTRA_LEN)
+
+#define REQ_EXTRA(f,ndx) ((union file_extras*)(f) - (ndx))
+#define OPT_EXTRA(f,bump) ((union file_extras*)(f) - file_extra_cnt - 1 - (bump))
+
+#define LEN64_BUMP(f) ((f)->flags & FLAG_LENGTH64 ? 1 : 0)
+#define HLINK_BUMP(f) ((f)->flags & (FLAG_HLINKED|FLAG_HLINK_DONE) ? inc_recurse+1 : 0)
+#define ACL_BUMP(f) (acls_ndx ? 1 : 0)
+
+/* The length applies to all items. */
+#if SIZEOF_INT64 < 8
+#define F_LENGTH(f) ((int64)(f)->len32)
+#else
+#define F_LENGTH(f) ((int64)(f)->len32 + ((f)->flags & FLAG_LENGTH64 \
+		   ? (int64)OPT_EXTRA(f, 0)->unum << 32 : 0))
+#endif
 
-#define F_HLINDEX link_u.links->hlindex
-#define F_NEXT	link_u.links->next
+/* If there is a symlink string, it is always right after the basename */
+#define F_SYMLINK(f) ((f)->basename + strlen((f)->basename) + 1)
 
-struct file_struct {
-	union {
-		dev_t rdev;	/* The device number, if this is a device */
-		char *sum;	/* Only a normal file can have a checksum */
-		char *link;	/* Points to symlink string, if a symlink */
-	} u;
-	OFF_T length;
-	char *basename;		/* The current item's name (AKA filename) */
-	char *dirname;		/* The directory info inside the transfer */
-	union {
-		char *root;	/* Sender-side dir info outside transfer */
-		int depth;	/* Receiver-side directory depth info */
-	} dir;
-	union {
-		struct idev *idev;
-		struct hlink *links;
-	} link_u;
-	time_t modtime;
-	uid_t uid;
-	gid_t gid;
-	mode_t mode;
-	uchar flags;	/* this item MUST remain last */
-};
+/* The sending side always has this available: */
+#define F_PATHNAME(f) (*(const char**)REQ_EXTRA(f, PTR_EXTRA_CNT))
+
+/* The receiving side always has this available: */
+#define F_DEPTH(f) REQ_EXTRA(f, 1)->num
+
+/* When the associated option is on, all entries will have these present: */
+#define F_OWNER(f) REQ_EXTRA(f, uid_ndx)->unum
+#define F_GROUP(f) REQ_EXTRA(f, gid_ndx)->unum
+#define F_ACL(f) REQ_EXTRA(f, acls_ndx)->num
+#define F_XATTR(f) REQ_EXTRA(f, xattrs_ndx)->num
+#define F_NDX(f) REQ_EXTRA(f, unsort_ndx)->num
+
+/* These items are per-entry optional: */
+#define F_HL_GNUM(f) OPT_EXTRA(f, LEN64_BUMP(f))->num /* non-dirs */
+#define F_HL_PREV(f) OPT_EXTRA(f, LEN64_BUMP(f)+inc_recurse)->num /* non-dirs */
+#define F_DIR_NODE_P(f) (&OPT_EXTRA(f, LEN64_BUMP(f) \
+				+ DIRNODE_EXTRA_CNT - 1)->num) /* sender dirs */
+#define F_DIR_RELNAMES_P(f) (&OPT_EXTRA(f, LEN64_BUMP(f) + DIRNODE_EXTRA_CNT \
+				+ PTR_EXTRA_CNT - 1)->num) /* sender dirs */
+#define F_DIR_DEFACL(f) OPT_EXTRA(f, LEN64_BUMP(f))->unum /* receiver dirs */
+#define F_DIR_DEV_P(f) (&OPT_EXTRA(f, LEN64_BUMP(f) + ACL_BUMP(f) \
+				+ DEV_EXTRA_CNT - 1)->unum) /* receiver dirs */
+
+/* This optional item might follow an F_HL_*() item.
+ * (Note: a device doesn't need to check LEN64_BUMP(f).) */
+#define F_RDEV_P(f) (&OPT_EXTRA(f, HLINK_BUMP(f) + DEV_EXTRA_CNT - 1)->unum)
+
+/* The sum is only present on regular files. */
+#define F_SUM(f) ((char*)OPT_EXTRA(f, LEN64_BUMP(f) + HLINK_BUMP(f) \
+				    + SUM_EXTRA_CNT - 1))
+
+/* Some utility defines: */
+#define F_IS_ACTIVE(f) (f)->basename[0]
+#define F_IS_HLINKED(f) ((f)->flags & FLAG_HLINKED)
+
+#define F_HLINK_NOT_FIRST(f) BITS_SETnUNSET((f)->flags, FLAG_HLINKED, FLAG_HLINK_FIRST)
+#define F_HLINK_NOT_LAST(f) BITS_SETnUNSET((f)->flags, FLAG_HLINKED, FLAG_HLINK_LAST)
+
+/* These access the F_DIR_DEV_P() and F_RDEV_P() values: */
+#define DEV_MAJOR(a) (a)[0]
+#define DEV_MINOR(a) (a)[1]
+
+/* These access the F_DIRS_NODE_P() values: */
+#define DIR_PARENT(a) (a)[0]
+#define DIR_FIRST_CHILD(a) (a)[1]
+#define DIR_NEXT_SIBLING(a) (a)[2]
 
 /*
  * Start the flist array at FLIST_START entries and grow it
  * by doubling until FLIST_LINEAR then grow by FLIST_LINEAR
  */
 #define FLIST_START	(32 * 1024)
 #define FLIST_LINEAR	(FLIST_START * 512)
 
 /*
- * Extent size for allocation pools A minimum size of 128KB
+ * Extent size for allocation pools: A minimum size of 128KB
  * is needed to mmap them so that freeing will release the
  * space to the OS.
  *
  * Larger sizes reduce leftover fragments and speed free calls
- * (when they happen) Smaller sizes increase the chance of
+ * (when they happen). Smaller sizes increase the chance of
  * freed allocations freeing whole extents.
  */
-#define FILE_EXTENT	(256 * 1024)
-#define HLINK_EXTENT	(128 * 1024)
+#define NORMAL_EXTENT	(256 * 1024)
+#define SMALL_EXTENT	(128 * 1024)
 
-#define WITH_HLINK	1
-#define WITHOUT_HLINK	0
+#define FLIST_TEMP	(1<<1)
 
 struct file_list {
-	struct file_struct **files;
+	struct file_list *next, *prev;
+	struct file_struct **files, **sorted;
 	alloc_pool_t file_pool;
-	alloc_pool_t hlink_pool;
-	int count;
-	int malloced;
-	int low, high;
+	void *pool_boundary;
+	int used, malloced;
+	int low, high;  /* 0-relative index values excluding empties */
+	int ndx_start;  /* the start offset for inc_recurse mode */
+	int flist_num;  /* 1-relative file_list number or 0 */
+	int parent_ndx; /* dir_flist index of parent directory */
+	int in_progress, to_redo;
 };
 
 #define SUMFLG_SAME_OFFSET	(1<<0)
 
 struct sum_buf {
 	OFF_T offset;		/**< offset in file of this chunk */
@@ -612,16 +778,18 @@
 #define MATCHFLG_FINISH_SETUP	(1<<13)/* per-dir merge file needs setup */
 #define MATCHFLG_NEGATE 	(1<<14)/* rule matches when pattern does not */
 #define MATCHFLG_CVS_IGNORE	(1<<15)/* rule was -C or :C */
 #define MATCHFLG_SENDER_SIDE	(1<<16)/* rule applies to the sending side */
 #define MATCHFLG_RECEIVER_SIDE	(1<<17)/* rule applies to the receiving side */
 #define MATCHFLG_CLEAR_LIST 	(1<<18)/* this item is the "!" token */
+#define MATCHFLG_PERISHABLE	(1<<19)/* perishable if parent dir goes away */
 
 #define MATCHFLGS_FROM_CONTAINER (MATCHFLG_ABS_PATH | MATCHFLG_INCLUDE \
 				| MATCHFLG_DIRECTORY | MATCHFLG_SENDER_SIDE \
-				| MATCHFLG_NEGATE | MATCHFLG_RECEIVER_SIDE)
+				| MATCHFLG_NEGATE | MATCHFLG_RECEIVER_SIDE \
+				| MATCHFLG_PERISHABLE)
 
 struct filter_struct {
 	struct filter_struct *next;
 	char *pattern;
 	uint32 match_flags;
 	union {
@@ -642,38 +810,98 @@
 	int64 total_written;
 	int64 total_read;
 	int64 literal_data;
 	int64 matched_data;
 	int64 flist_buildtime;
 	int64 flist_xfertime;
-	int flist_size;
+	int64 flist_size;
 	int num_files;
 	int num_transferred_files;
-	int current_file_index;
 };
 
 struct chmod_mode_struct;
 
+#define EMPTY_ITEM_LIST {NULL, 0, 0}
+
+typedef struct {
+	void *items;
+	size_t count;
+	size_t malloced;
+} item_list;
+
+#define EXPAND_ITEM_LIST(lp, type, incr) \
+	(type*)expand_item_list(lp, sizeof (type), #type, incr)
+
+#define EMPTY_XBUF {NULL, 0, 0, 0}
+
+typedef struct {
+	char *buf;
+	size_t pos;  /* pos = read pos in the buf */
+	size_t len;  /* len = chars following pos */
+	size_t size; /* size = total space in buf */
+} xbuf;
+
+#define INIT_XBUF(xb, str, ln, sz) (xb).buf = (str), (xb).len = (ln), (xb).size = (sz), (xb).pos = 0
+#define INIT_XBUF_STRLEN(xb, str) (xb).buf = (str), (xb).len = strlen((xb).buf), (xb).size = (-1), (xb).pos = 0
+/* This one is used to make an output xbuf based on a char[] buffer: */
+#define INIT_CONST_XBUF(xb, bf) (xb).buf = (bf), (xb).size = sizeof (bf), (xb).len = (xb).pos = 0
+
+#define ICB_EXPAND_OUT (1<<0)
+#define ICB_INCLUDE_BAD (1<<1)
+#define ICB_INCLUDE_INCOMPLETE (1<<2)
+
+#define RL_EOL_NULLS (1<<0)
+#define RL_DUMP_COMMENTS (1<<1)
+#define RL_CONVERT (1<<2)
+
+typedef struct {
+	char name_type;
+	char fname[1]; /* has variable size */
+} relnamecache;
+
 #include "byteorder.h"
-#include "lib/mdfour.h"
+#include "lib/mdigest.h"
 #include "lib/wildmatch.h"
 #include "lib/permstring.h"
 #include "lib/addrinfo.h"
 
-#if !defined __GNUC__ || defined __APPLE__
-/* Apparently the OS X port of gcc gags on __attribute__.
- *
- * <http://www.opensource.apple.com/bugs/X/gcc/2512150.html> */
+#ifndef __GNUC__
 #define __attribute__(x)
+#else
+# if __GNUC__ <= 2
+# define NORETURN
+# endif
 #endif
 
 #define UNUSED(x) x __attribute__((__unused__))
+#ifndef NORETURN
 #define NORETURN __attribute__((__noreturn__))
+#endif
+
+typedef struct {
+    STRUCT_STAT st;
+#ifdef SUPPORT_ACLS
+    struct rsync_acl *acc_acl; /* access ACL */
+    struct rsync_acl *def_acl; /* default ACL */
+#endif
+#ifdef SUPPORT_XATTRS
+    item_list *xattr;
+#endif
+} stat_x;
+
+#define ACL_READY(sx) ((sx).acc_acl != NULL)
+#define XATTR_READY(sx) ((sx).xattr != NULL)
 
 #include "proto.h"
 
+#ifndef SUPPORT_XATTRS
+#define x_stat(fn,fst,xst) do_stat(fn,fst)
+#define x_lstat(fn,fst,xst) do_lstat(fn,fst)
+#define x_fstat(fd,fst,xst) do_fstat(fd,fst)
+#endif
+
 /* We have replacement versions of these if they're missing. */
 #ifndef HAVE_ASPRINTF
 int asprintf(char **ptr, const char *format, ...);
 #endif
 
 #ifndef HAVE_VASPRINTF
@@ -684,13 +912,13 @@
 #define vsnprintf rsync_vsnprintf
 int vsnprintf(char *str, size_t count, const char *fmt, va_list args);
 #endif
 
 #if !defined HAVE_SNPRINTF || !defined HAVE_C99_VSNPRINTF
 #define snprintf rsync_snprintf
-int snprintf(char *str,size_t count,const char *fmt,...);
+int snprintf(char *str, size_t count, const char *fmt,...);
 #endif
 
 
 #ifndef HAVE_STRERROR
 extern char *sys_errlist[];
 #define strerror(i) sys_errlist[i]
@@ -823,15 +1051,17 @@
 #define INITACCESSPERMS 0700
 
 /* handler for null strings in printf format */
 #define NS(s) ((s)?(s):"<NULL>")
 
 /* Convenient wrappers for malloc and realloc.  Use them. */
-#define new(type) ((type *)malloc(sizeof(type)))
-#define new_array(type, num) ((type *)_new_array(sizeof(type), (num)))
-#define realloc_array(ptr, type, num) ((type *)_realloc_array((ptr), sizeof(type), (num)))
+#define new(type) ((type*)malloc(sizeof (type)))
+#define new0(type) ((type*)calloc(1, sizeof (type)))
+#define new_array(type, num) ((type*)_new_array((num), sizeof (type), 0))
+#define new_array0(type, num) ((type*)_new_array((num), sizeof (type), 1))
+#define realloc_array(ptr, type, num) ((type*)_realloc_array((ptr), sizeof(type), (num)))
 
 /* use magic gcc attributes to catch format errors */
  void rprintf(enum logcode , const char *, ...)
      __attribute__((format (printf, 2, 3)))
 ;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/rsync.yo	2006-11-07 12:39:47.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/rsync.yo	2008-03-02 04:12:04.000000000 +0800
@@ -1,38 +1,43 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(6 Nov 2006)()()
-manpagename(rsync)(faster, flexible replacement for rcp)
+manpage(rsync)(1)(1 Mar 2008)()()
+manpagename(rsync)(a fast, versatile, remote (and local) file-copying tool)
 manpagesynopsis()
 
-rsync [OPTION]... SRC [SRC]... DEST
+verb(Local:  rsync [OPTION...] SRC... [DEST]
 
-rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
+Access via remote shell:
+  Pull: rsync [OPTION...] [USER@]HOST:SRC... [DEST]
+  Push: rsync [OPTION...] SRC... [USER@]HOST:DEST
+
+Access via rsync daemon:
+  Pull: rsync [OPTION...] [USER@]HOST::SRC... [DEST]
+        rsync [OPTION...] rsync://[USER@]HOST[:PORT]/SRC... [DEST]
+  Push: rsync [OPTION...] SRC... [USER@]HOST::DEST
+        rsync [OPTION...] SRC... rsync://[USER@]HOST[:PORT]/DEST)
 
-rsync [OPTION]... SRC [SRC]... [USER@]HOST::DEST
-
-rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST
-
-rsync [OPTION]... SRC
-
-rsync [OPTION]... [USER@]HOST:SRC [DEST]
-
-rsync [OPTION]... [USER@]HOST::SRC [DEST]
-
-rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
+Usages with just one SRC arg and no DEST arg will list the source files
+instead of copying.
 
 manpagedescription()
 
-rsync is a program that behaves in much the same way that rcp does,
-but has many more options and uses the rsync remote-update protocol to
-greatly speed up file transfers when the destination file is being
-updated.
-
-The rsync remote-update protocol allows rsync to transfer just the
-differences between two sets of files across the network connection, using
-an efficient checksum-search algorithm described in the technical
-report that accompanies this package.
+Rsync is a fast and extraordinarily versatile file copying tool.  It can
+copy locally, to/from another host over any remote shell, or to/from a
+remote rsync daemon.  It offers a large number of options that control
+every aspect of its behavior and permit very flexible specification of the
+set of files to be copied.  It is famous for its delta-transfer algorithm,
+which reduces the amount of data sent over the network by sending only the
+differences between the source files and the existing files in the
+destination.  Rsync is widely used for backups and mirroring and as an
+improved copy command for everyday use.
+
+Rsync finds files that need to be transferred using a "quick check"
+algorithm (by default) that looks for files that have changed in size or
+in last-modified time.  Any changes in the other preserved attributes (as
+requested by options) are made on the destination file directly when the
+quick check indicates that the file's data does not need to be updated.
 
 Some of the additional features of rsync are:
 
 itemization(
   it() support for copying links, devices, owners, groups, and permissions
   it() exclude and exclude-from options similar to GNU tar
@@ -140,39 +145,35 @@
 quote(tt(rsync somehost.mydomain.com::))
 
 See the following section for more details.
 
 manpagesection(ADVANCED USAGE)
 
-The syntax for requesting multiple files from a remote host involves using
-quoted spaces in the SRC.  Some examples:
+The syntax for requesting multiple files from a remote host is done by
+specifying additional remote-host args in the same style as the first,
+or with the hostname omitted.  For instance, all these work:
 
-quote(tt(rsync host::'modname/dir1/file1 modname/dir2/file2' /dest))
+quote(tt(rsync -av host:file1 :file2 host:file{3,4} /dest/)nl()
+tt(rsync -av host::modname/file{1,2} host::modname/file3 /dest/)nl()
+tt(rsync -av host::modname/file1 ::modname/file{3,4}))
 
-This would copy file1 and file2 into /dest from an rsync daemon.  Each
-additional arg must include the same "modname/" prefix as the first one,
-and must be preceded by a single space.  All other spaces are assumed
-to be a part of the filenames.
-
-quote(tt(rsync -av host:'dir1/file1 dir2/file2' /dest))
-
-This would copy file1 and file2 into /dest using a remote shell.  This
-word-splitting is done by the remote shell, so if it doesn't work it means
-that the remote shell isn't configured to split its args based on
-whitespace (a very rare setting, but not unknown).  If you need to transfer
-a filename that contains whitespace, you'll need to either escape the
-whitespace in a way that the remote shell will understand, or use wildcards
-in place of the spaces.  Two examples of this are:
+Older versions of rsync required using quoted spaces in the SRC, like these
+examples:
 
-quote(
-tt(rsync -av host:'file\ name\ with\ spaces' /dest)nl()
-tt(rsync -av host:file?name?with?spaces /dest)nl()
-)
+quote(tt(rsync -av host:'dir1/file1 dir2/file2' /dest)nl()
+tt(rsync host::'modname/dir1/file1 modname/dir2/file2' /dest))
+
+This word-splitting still works (by default) in the latest rsync, but is
+not as easy to use as the first method.
 
-This latter example assumes that your shell passes through unmatched
-wildcards.  If it complains about "no match", put the name in quotes.
+If you need to transfer a filename that contains whitespace, you can either
+specify the bf(--protect-args) (bf(-s)) option, or you'll need to escape
+the whitespace in a way that the remote shell will understand.  For
+instance:
+
+quote(tt(rsync -av host:'file\ name\ with\ spaces' /dest))
 
 manpagesection(CONNECTING TO AN RSYNC DAEMON)
 
 It is also possible to use rsync without a remote shell as the transport.
 In this case you will directly connect to a remote rsync daemon, typically
 using TCP port 873.  (This obviously requires the daemon to be running on
@@ -210,12 +211,27 @@
 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
 your web proxy.  Note that your web proxy's configuration must support
 proxy connections to port 873.
 
+You may also establish a daemon connection using a program as a proxy by
+setting the environment variable RSYNC_CONNECT_PROG to the commands you
+wish to run in place of making a direct socket connection.  The string may
+contain the escape "%H" to represent the hostname specified in the rsync
+command (so use "%%" if you need a single "%" in your string).  For
+example:
+
+verb(  export RSYNC_CONNECT_PROG='ssh proxyhost nc %H 873'
+  rsync -av targethost1::module/src/ /dest/
+  rsync -av rsync:://targethost2/module/src/ /dest/ )
+
+The command specified above uses ssh to run nc (netcat) on a proxyhost,
+which forwards all data to port 873 (the rsync daemon) on the targethost
+(%H).
+
 manpagesection(USING RSYNC-DAEMON FEATURES VIA A REMOTE-SHELL CONNECTION)
 
 It is sometimes useful to use various features of an rsync daemon (such as
 named modules) without actually allowing any new socket connections into a
 system (other than what is already required to allow remote-shell access).
 Rsync supports connecting to a host using a remote shell and then spawning
@@ -298,89 +314,97 @@
 Here is a short summary of the options available in rsync. Please refer
 to the detailed description below for a complete description.  verb(
  -v, --verbose               increase verbosity
  -q, --quiet                 suppress non-error messages
      --no-motd               suppress daemon-mode MOTD (see caveat)
  -c, --checksum              skip based on checksum, not mod-time & size
- -a, --archive               archive mode; same as -rlptgoD (no -H)
+ -a, --archive               archive mode; equals -rlptgoD (no -H,-A,-X)
      --no-OPTION             turn off an implied OPTION (e.g. --no-D)
  -r, --recursive             recurse into directories
  -R, --relative              use relative path names
      --no-implied-dirs       don't send implied dirs with --relative
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir=DIR        make backups into hierarchy based in DIR
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                skip files that are newer on the receiver
      --inplace               update destination files in-place
      --append                append data onto shorter files
+     --append-verify         --append w/old data in file checksum
  -d, --dirs                  transfer directories without recursing
  -l, --links                 copy symlinks as symlinks
  -L, --copy-links            transform symlink into referent file/dir
      --copy-unsafe-links     only "unsafe" symlinks are transformed
      --safe-links            ignore symlinks that point outside the tree
  -k, --copy-dirlinks         transform symlink to dir into referent dir
  -K, --keep-dirlinks         treat symlinked dir on receiver as dir
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
  -E, --executability         preserve executability
      --chmod=CHMOD           affect file and/or directory permissions
+ -A, --acls                  preserve ACLs (implies -p)
+ -X, --xattrs                preserve extended attributes
  -o, --owner                 preserve owner (super-user only)
  -g, --group                 preserve group
      --devices               preserve device files (super-user only)
      --specials              preserve special files
  -D                          same as --devices --specials
- -t, --times                 preserve times
- -O, --omit-dir-times        omit directories when preserving times
+ -t, --times                 preserve modification times
+ -O, --omit-dir-times        omit directories from --times
      --super                 receiver attempts super-user activities
+     --fake-super            store/recover privileged attrs using xattrs
  -S, --sparse                handle sparse files efficiently
- -n, --dry-run               show what would have been transferred
- -W, --whole-file            copy files whole (without rsync algorithm)
+ -n, --dry-run               perform a trial run with no changes made
+ -W, --whole-file            copy files whole (w/o delta-xfer algorithm)
  -x, --one-file-system       don't cross filesystem boundaries
  -B, --block-size=SIZE       force a fixed checksum block-size
  -e, --rsh=COMMAND           specify the remote shell to use
      --rsync-path=PROGRAM    specify the rsync to run on remote machine
      --existing              skip creating new files on receiver
      --ignore-existing       skip updating files that exist on receiver
      --remove-source-files   sender removes synchronized files (non-dir)
      --del                   an alias for --delete-during
      --delete                delete extraneous files from dest dirs
      --delete-before         receiver deletes before transfer (default)
      --delete-during         receiver deletes during xfer, not before
+     --delete-delay          find deletions during, delete after
      --delete-after          receiver deletes after transfer, not before
      --delete-excluded       also delete excluded files from dest dirs
      --ignore-errors         delete even if there are I/O errors
      --force                 force deletion of dirs even if not empty
      --max-delete=NUM        don't delete more than NUM files
      --max-size=SIZE         don't transfer any file larger than SIZE
      --min-size=SIZE         don't transfer any file smaller than SIZE
      --partial               keep partially transferred files
      --partial-dir=DIR       put a partially transferred file into DIR
      --delay-updates         put all updated files into place at end
  -m, --prune-empty-dirs      prune empty directory chains from file-list
      --numeric-ids           don't map uid/gid values by user/group name
-     --timeout=TIME          set I/O timeout in seconds
+     --timeout=SECONDS       set I/O timeout in seconds
+     --contimeout=SECONDS    set daemon connection timeout in seconds
  -I, --ignore-times          don't skip files that match size and time
      --size-only             skip files that match in size
      --modify-window=NUM     compare mod-times with reduced accuracy
  -T, --temp-dir=DIR          create temporary files in directory DIR
  -y, --fuzzy                 find similar file for basis if no dest file
      --compare-dest=DIR      also compare received files relative to DIR
      --copy-dest=DIR         ... and include copies of unchanged files
      --link-dest=DIR         hardlink to files in DIR when unchanged
  -z, --compress              compress file data during the transfer
      --compress-level=NUM    explicitly set compression level
+     --skip-compress=LIST    skip compressing files with suffix in LIST
  -C, --cvs-exclude           auto-ignore files in the same way CVS does
  -f, --filter=RULE           add a file-filtering RULE
  -F                          same as --filter='dir-merge /.rsync-filter'
                              repeated: --filter='- .rsync-filter'
      --exclude=PATTERN       exclude files matching PATTERN
      --exclude-from=FILE     read exclude patterns from FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     read include patterns from FILE
      --files-from=FILE       read list of source-file names from FILE
  -0, --from0                 all *from/filter files are delimited by 0s
+ -s, --protect-args          no space-splitting; wildcard chars only
      --address=ADDRESS       bind address for outgoing socket to daemon
      --port=PORT             specify double-colon alternate port number
      --sockopts=OPTIONS      specify custom TCP options
      --blocking-io           use blocking I/O for the remote shell
      --stats                 give some file-transfer stats
  -8, --8-bit-output          leave high-bit chars unescaped in output
@@ -388,19 +412,20 @@
      --progress              show progress during transfer
  -P                          same as --partial --progress
  -i, --itemize-changes       output a change-summary for all updates
      --out-format=FORMAT     output updates using the specified FORMAT
      --log-file=FILE         log what we're doing to the specified FILE
      --log-file-format=FMT   log updates using the specified FMT
-     --password-file=FILE    read password from FILE
+     --password-file=FILE    read daemon-access password from FILE
      --list-only             list the files instead of copying them
      --bwlimit=KBPS          limit I/O bandwidth; KBytes per second
      --write-batch=FILE      write a batched update to FILE
      --only-write-batch=FILE like --write-batch but w/o updating dest
      --read-batch=FILE       read a batched update from FILE
      --protocol=NUM          force an older protocol version to be used
+     --iconv=CONVERT_SPEC    request charset conversion of filenames
      --checksum-seed=NUM     set block/file checksum seed (advanced)
  -4, --ipv4                  prefer IPv4
  -6, --ipv6                  prefer IPv6
      --version               print version number
 (-h) --help                  show this help (see below for -h comment))
 
@@ -460,48 +485,54 @@
 
 dit(bf(--no-motd)) This option affects the information that is output
 by the client at the start of a daemon transfer.  This suppresses the
 message-of-the-day (MOTD) text, but it also affects the list of modules
 that the daemon sends in response to the "rsync host::" request (due to
 a limitation in the rsync protocol), so omit this option if you want to
-request the list of modules from the deamon.
+request the list of modules from the daemon.
 
 dit(bf(-I, --ignore-times)) Normally rsync will skip any files that are
-already the same size and have the same modification time-stamp.
+already the same size and have the same modification timestamp.
 This option turns off this "quick check" behavior, causing all files to
 be updated.
 
-dit(bf(--size-only)) Normally rsync will not transfer any files that are
-already the same size and have the same modification time-stamp. With the
-bf(--size-only) option, files will not be transferred if they have the same size,
-regardless of timestamp. This is useful when starting to use rsync
-after using another mirroring system which may not preserve timestamps
-exactly.
+dit(bf(--size-only)) This modifies rsync's "quick check" algorithm for
+finding files that need to be transferred, changing it from the default of
+transferring files with either a changed size or a changed last-modified
+time to just looking for files that have changed in size.  This is useful
+when starting to use rsync after using another mirroring system which may
+not preserve timestamps exactly.
 
 dit(bf(--modify-window)) When comparing two timestamps, rsync treats the
 timestamps as being equal if they differ by no more than the modify-window
 value.  This is normally 0 (for an exact match), but you may find it useful
 to set this to a larger value in some situations.  In particular, when
 transferring to or from an MS Windows FAT filesystem (which represents
 times with a 2-second resolution), bf(--modify-window=1) is useful
 (allowing times to differ by up to 1 second).
 
-dit(bf(-c, --checksum)) This forces the sender to checksum em(every)
-regular file using a 128-bit MD4 checksum.  It does this during the initial
-file-system scan as it builds the list of all available files. The receiver
-then checksums its version of each file (if it exists and it has the same
-size as its sender-side counterpart) in order to decide which files need to
-be updated: files with either a changed size or a changed checksum are
-selected for transfer.  Since this whole-file checksumming of all files on
-both sides of the connection occurs in addition to the automatic checksum
-verifications that occur during a file's transfer, this option can be quite
-slow.
-
-Note that rsync always verifies that each em(transferred) file was correctly
-reconstructed on the receiving side by checking its whole-file checksum, but
-that automatic after-the-transfer verification has nothing to do with this
+dit(bf(-c, --checksum)) This changes the way rsync checks if the files have
+been changed and are in need of a transfer.  Without this option, rsync
+uses a "quick check" that (by default) checks if each file's size and time
+of last modification match between the sender and receiver.  This option
+changes this to compare a 128-bit MD4 checksum for each file that has a
+matching size.  Generating the checksums means that both sides will expend
+a lot of disk I/O reading all the data in the files in the transfer (and
+this is prior to any reading that will be done to transfer changed files),
+so this can slow things down significantly.
+
+The sending side generates its checksums while it is doing the file-system
+scan that builds the list of the available files.  The receiver generates
+its checksums when it is scanning for changed files, and will checksum any
+file that has the same size as the corresponding sender's file:  files with
+either a changed size or a changed checksum are selected for transfer.
+
+Note that rsync always verifies that each em(transferred) file was
+correctly reconstructed on the receiving side by checking a whole-file
+checksum that is generated as the file is transferred, but that
+automatic after-the-transfer verification has nothing to do with this
 option's before-the-transfer "Does this file need to be updated?" check.
 
 dit(bf(-a, --archive)) This is equivalent to bf(-rlptgoD). It is a quick
 way of saying you want recursion and want to preserve almost
 everything (with -H being a notable omission).
 The only exception to the above equivalence is when bf(--files-from) is
@@ -530,12 +561,31 @@
 changes the meaning of bf(-a) (see the bf(--files-from) option for more
 details).
 
 dit(bf(-r, --recursive)) This tells rsync to copy directories
 recursively.  See also bf(--dirs) (bf(-d)).
 
+Beginning with rsync 3.0.0, the recursive algorithm used is now an
+incremental scan that uses much less memory than before and begins the
+transfer after the scanning of the first few directories have been
+completed.  This incremental scan only affects our recursion algorithm, and
+does not change a non-recursive transfer.  It is also only possible when
+both ends of the transfer are at least version 3.0.0.
+
+Some options require rsync to know the full file list, so these options
+disable the incremental recursion mode.  These include: bf(--delete-before),
+bf(--delete-after), bf(--prune-empty-dirs), and bf(--delay-updates).
+Because of this, the default delete mode when you specify bf(--delete) is now
+bf(--delete-during) when both ends of the connection are at least 3.0.0
+(use bf(--del) or bf(--delete-during) to request this improved deletion mode
+explicitly).  See also the bf(--delete-delay) option that is a better choice
+than using bf(--delete-after).
+
+Incremental recursion can be disabled using the bf(--no-inc-recursive)
+option or its shorter bf(--no-i-r) alias.
+
 dit(bf(-R, --relative)) Use relative paths. This means that the full path
 names specified on the command line are sent to the server rather than
 just the last parts of the filenames. This is particularly useful when
 you want to send several different directories at the same time. For
 example, if you used this command:
 
@@ -544,30 +594,43 @@
 ... this would create a file named baz.c in /tmp/ on the remote
 machine. If instead you used
 
 quote(tt(   rsync -avR /foo/bar/baz.c remote:/tmp/))
 
 then a file named /tmp/foo/bar/baz.c would be created on the remote
-machine -- the full path name is preserved.  To limit the amount of
-path information that is sent, you have a couple options:  (1) With
-a modern rsync on the sending side (beginning with 2.6.7), you can
-insert a dot and a slash into the source path, like this:
+machine, preserving its full path.  These extra path elements are called
+"implied directories" (i.e. the "foo" and the "foo/bar" directories in the
+above example).
+
+Beginning with rsync 3.0.0, rsync always sends these implied directories as
+real directories in the file list, even if a path element is really a
+symlink on the sending side.  This prevents some really unexpected
+behaviors when copying the full path of a file that you didn't realize had
+a symlink in its path.  If you want to duplicate a server-side symlink,
+include both the symlink via its path, and referent directory via its real
+path.  If you're dealing with an older rsync on the sending side, you may
+need to use the bf(--no-implied-dirs) option.
+
+It is also possible to limit the amount of path information that is sent as
+implied directories for each path you specify.  With a modern rsync on the
+sending side (beginning with 2.6.7), you can insert a dot and a slash into
+the source path, like this:
 
 quote(tt(   rsync -avR /foo/./bar/baz.c remote:/tmp/))
 
 That would create /tmp/bar/baz.c on the remote machine.  (Note that the
 dot must be followed by a slash, so "/foo/." would not be abbreviated.)
 (2) For older rsync versions, you would need to use a chdir to limit the
 source path.  For example, when pushing files:
 
 quote(tt(   (cd /foo; rsync -avR bar/baz.c remote:/tmp/) ))
 
 (Note that the parens put the two commands into a sub-shell, so that the
 "cd" command doesn't remain in effect for future commands.)
-If you're pulling files, use this idiom (which doesn't work with an
-rsync daemon):
+If you're pulling files from an older rsync, use this idiom (but only
+for a non-daemon transfer):
 
 quote(
 tt(   rsync -avR --rsync-path="cd /foo; rsync" \ )nl()
 tt(       remote:bar/baz.c /tmp/)
 )
 
@@ -575,45 +638,39 @@
 bf(--relative) option.  When it is specified, the attributes of the implied
 directories from the source names are not included in the transfer.  This
 means that the corresponding path elements on the destination system are
 left unchanged if they exist, and any missing implied directories are
 created with default attributes.  This even allows these implied path
 elements to have big differences, such as being a symlink to a directory on
-one side of the transfer, and a real directory on the other side.
+the receiving side.
 
 For instance, if a command-line arg or a files-from entry told rsync to
 transfer the file "path/foo/file", the directories "path" and "path/foo"
 are implied when bf(--relative) is used.  If "path/foo" is a symlink to
 "bar" on the destination system, the receiving rsync would ordinarily
 delete "path/foo", recreate it as a directory, and receive the file into
 the new directory.  With bf(--no-implied-dirs), the receiving rsync updates
 "path/foo/file" using the existing path elements, which means that the file
 ends up being created in "path/bar".  Another way to accomplish this link
 preservation is to use the bf(--keep-dirlinks) option (which will also
 affect symlinks to directories in the rest of the transfer).
 
-In a similar but opposite scenario, if the transfer of "path/foo/file" is
-requested and "path/foo" is a symlink on the sending side, running without
-bf(--no-implied-dirs) would cause rsync to transform "path/foo" on the
-receiving side into an identical symlink, and then attempt to transfer
-"path/foo/file", which might fail if the duplicated symlink did not point
-to a directory on the receiving side.  Another way to avoid this sending of
-a symlink as an implied directory is to use bf(--copy-unsafe-links), or
-bf(--copy-dirlinks) (both of which also affect symlinks in the rest of the
-transfer -- see their descriptions for full details).
+When pulling files from an rsync older than 3.0.0, you may need to use this
+option if the sending side has a symlink in the path you request and you
+wish the implied directories to be transferred as normal directories.
 
 dit(bf(-b, --backup)) With this option, preexisting destination files are
 renamed as each file is transferred or deleted.  You can control where the
 backup file goes and what (if any) suffix gets appended using the
 bf(--backup-dir) and bf(--suffix) options.
 
 Note that if you don't specify bf(--backup-dir), (1) the
 bf(--omit-dir-times) option will be implied, and (2) if bf(--delete) is
 also in effect (without bf(--delete-excluded)), rsync will add a "protect"
 filter-rule for the backup suffix to the end of all your existing excludes
-(e.g. -f "P *~").  This will prevent previously backed-up files from being
+(e.g. bf(-f "Pp *~")).  This will prevent previously backed-up files from being
 deleted.  Note that if you are supplying your own filter rules, you may
 need to manually insert your own exclude/protect rule somewhere higher up
 in the list so that it has a high enough priority to be effective (e.g., if
 your rules specify a trailing inclusion/exclusion of '*', the auto-added
 rule would never be reached).
 
@@ -627,22 +684,21 @@
 dit(bf(--suffix=SUFFIX)) This option allows you to override the default
 backup suffix used with the bf(--backup) (bf(-b)) option. The default suffix is a ~
 if no -bf(-backup-dir) was specified, otherwise it is an empty string.
 
 dit(bf(-u, --update)) This forces rsync to skip any files which exist on
 the destination and have a modified time that is newer than the source
-file.  (If an existing destination file has a modify time equal to the
+file.  (If an existing destination file has a modification time equal to the
 source file's, it will be updated if the sizes are different.)
 
-In the current implementation of bf(--update), a difference of file format
-between the sender and receiver is always
-considered to be important enough for an update, no matter what date
-is on the objects.  In other words, if the source has a directory or a
-symlink where the destination has a file, the transfer would occur
-regardless of the timestamps.  This might change in the future (feel
-free to comment on this on the mailing list if you have an opinion).
+Note that this does not affect the copying of symlinks or other special
+files.  Also, a difference of file format between the sender and receiver
+is always considered to be important enough for an update, no matter what
+date is on the objects.  In other words, if the source has a directory
+where the destination has a file, the transfer would occur regardless of
+the timestamps.
 
 dit(bf(--inplace)) This causes rsync not to create a new copy of the file
 and then move it into place.  Instead rsync will overwrite the existing
 file, meaning that the rsync algorithm can't accomplish the full amount of
 network reduction it might be able to otherwise (since it does not yet try
 to sort data matches).  One exception to this is if you combine the option
@@ -664,28 +720,43 @@
 rsync will be unable to update a file in-place that is not writable by the
 receiving user.
 
 dit(bf(--append)) This causes rsync to update a file by appending data onto
 the end of the file, which presumes that the data that already exists on
 the receiving side is identical with the start of the file on the sending
-side.  If that is not true, the file will fail the checksum test, and the
-resend will do a normal bf(--inplace) update to correct the mismatched data.
-Only files on the receiving side that are shorter than the corresponding
-file on the sending side (as well as new files) are sent.
-Implies bf(--inplace), but does not conflict with bf(--sparse) (though the
-bf(--sparse) option will be auto-disabled if a resend of the already-existing
-data is required).
+side.  Any files that are the same size or shorter on the receiving size
+are skipped.  Files that do not yet exist on the receiving side are also
+sent, since they are considered to have 0 length.  Implies bf(--inplace),
+but does not conflict with bf(--sparse) (since it is always extending a
+file's length).
+
+dit(bf(--append-verify)) This works just like the bf(--append) option, but
+the existing data on the receiving side is included in the full-file
+checksum verification step, which will cause a file to be resent if the
+final verification step fails (rsync uses a normal, non-appending
+bf(--inplace) transfer for the resend).
+
+Note: prior to rsync 3.0.0, the bf(--append) option worked like
+bf(--append-verify), so if you are interacting with an older rsync (or the
+transfer is using a protocol prior to 30), specifying either append option
+will initiate an bf(--append-verify) transfer.
 
 dit(bf(-d, --dirs)) Tell the sending side to include any directories that
 are encountered.  Unlike bf(--recursive), a directory's contents are not copied
 unless the directory name specified is "." or ends with a trailing slash
 (e.g. ".", "dir/.", "dir/", etc.).  Without this option or the
 bf(--recursive) option, rsync will skip all directories it encounters (and
 output a message to that effect for each one).  If you specify both
 bf(--dirs) and bf(--recursive), bf(--recursive) takes precedence.
 
+This option is implied by the bf(--list-only) option (including an implied
+bf(--list-only) usage) if bf(--recursive) wasn't specified (so that
+directories are seen in the listing).  Specify bf(--no-dirs) (or bf(--no-d))
+if you want to override this.  This option is also implied by
+bf(--files-from).
+
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
 symlink on the destination.
 
 dit(bf(-L, --copy-links)) When symlinks are encountered, the item that
 they point to (the referent) is copied, rather than the symlink.  In older
 versions of rsync, this option also had the side-effect of telling the
@@ -703,13 +774,13 @@
 
 dit(bf(--safe-links)) This tells rsync to ignore any symbolic links
 which point outside the copied tree. All absolute symlinks are
 also ignored. Using this option in conjunction with bf(--relative) may
 give unexpected results.
 
-dit(bf(-K, --copy-dirlinks)) This option causes the sending side to treat
+dit(bf(-k, --copy-dirlinks)) This option causes the sending side to treat
 a symlink to a directory as though it were a real directory.  This is
 useful if you don't want symlinks to non-directories to be affected, as
 they would be using bf(--copy-links).
 
 Without this option, if the sending side has replaced a directory with a
 symlink to a directory, the receiving side will delete anything that is in
@@ -728,21 +799,48 @@
 "file", but "foo" is a symlink to directory "bar" on the receiver.  Without
 bf(--keep-dirlinks), the receiver deletes symlink "foo", recreates it as a
 directory, and receives the file into the new directory.  With
 bf(--keep-dirlinks), the receiver keeps the symlink and "file" ends up in
 "bar".
 
+One note of caution:  if you use bf(--keep-dirlinks), you must trust all
+the symlinks in the copy!  If it is possible for an untrusted user to
+create their own symlink to any directory, the user could then (on a
+subsequent copy) replace the symlink with a real directory and affect the
+content of whatever directory the symlink references.  For backup copies,
+you are better off using something like a bind mount instead of a symlink
+to modify your receiving hierarchy.
+
 See also bf(--copy-dirlinks) for an analogous option for the sending side.
 
 dit(bf(-H, --hard-links)) This tells rsync to look for hard-linked files in
 the transfer and link together the corresponding files on the receiving
 side.  Without this option, hard-linked files in the transfer are treated
 as though they were separate files.
 
-Note that rsync can only detect hard links if both parts of the link
-are in the list of files being sent.
+When you are updating a non-empty destination, this option only ensures
+that files that are hard-linked together on the source are hard-linked
+together on the destination.  It does NOT currently endeavor to break
+already existing hard links on the destination that do not exist between
+the source files.  Note, however, that if one or more extra-linked files
+have content changes, they will become unlinked when updated (assuming you
+are not using the bf(--inplace) option).
+
+Note that rsync can only detect hard links between files that are inside
+the transfer set.  If rsync updates a file that has extra hard-link
+connections to files outside the transfer, that linkage will be broken.  If
+you are tempted to use the bf(--inplace) option to avoid this breakage, be
+very careful that you know how your files are being updated so that you are
+certain that no unintended changes happen due to lingering hard links (and
+see the bf(--inplace) option for more caveats).
+
+If incremental recursion is active (see bf(--recursive)), rsync may transfer
+a missing hard-linked file before it finds that another link for that contents
+exists elsewhere in the hierarchy.  This does not affect the accuracy of
+the transfer, just its efficiency.  One way to avoid this is to disable
+incremental recursion using the bf(--no-inc-recursive) option.
 
 dit(bf(-p, --perms)) This option causes the receiving rsync to set the
 destination permissions to be the same as the source permissions.  (See
 also the bf(--chmod) option for a way to modify what rsync considers to
 be the source permissions.)
 
@@ -750,13 +848,15 @@
 
 quote(itemization(
   it() Existing files (including updated files) retain their existing
   permissions, though the bf(--executability) option might change just
   the execute permission for the file.
   it() New files get their "normal" permission bits set to the source
-  file's permissions masked with the receiving end's umask setting, and
+  file's permissions masked with the receiving directory's default
+  permissions (either the receiving process's umask, or the permissions
+  specified via the destination directory's default ACL), and
   their special permission bits disabled except in the case where a new
   directory inherits a setgid bit from its parent directory.
 ))
 
 Thus, when bf(--perms) and bf(--executability) are both disabled,
 rsync's behavior is the same as that of other file-copy utilities,
@@ -765,31 +865,33 @@
 In summary: to give destination files (both old and new) the source
 permissions, use bf(--perms).  To give new files the destination-default
 permissions (while leaving existing files unchanged), make sure that the
 bf(--perms) option is off and use bf(--chmod=ugo=rwX) (which ensures that
 all non-masked bits get enabled).  If you'd care to make this latter
 behavior easier to type, you could define a popt alias for it, such as
-putting this line in the file ~/.popt (this defines the bf(-s) option,
+putting this line in the file ~/.popt (the following defines the bf(-Z) option,
 and includes --no-g to use the default group of the destination dir):
 
-quote(tt(   rsync alias -s --no-p --no-g --chmod=ugo=rwX))
+quote(tt(   rsync alias -Z --no-p --no-g --chmod=ugo=rwX))
 
 You could then use this new option in a command such as this one:
 
-quote(tt(   rsync -asv src/ dest/))
+quote(tt(   rsync -avZ src/ dest/))
 
-(Caveat: make sure that bf(-a) does not follow bf(-s), or it will re-enable
-the "--no-*" options.)
+(Caveat: make sure that bf(-a) does not follow bf(-Z), or it will re-enable
+the two "--no-*" options mentioned above.)
 
 The preservation of the destination's setgid bit on newly-created
 directories when bf(--perms) is off was added in rsync 2.6.7.  Older rsync
 versions erroneously preserved the three special permission bits for
 newly-created files when bf(--perms) was off, while overriding the
-destination's setgid bit setting on a newly-created directory.  (Keep in
-mind that it is the version of the receiving rsync that affects this
-behavior.)
+destination's setgid bit setting on a newly-created directory.  Default ACL
+observance was added to the ACL patch for rsync 2.6.7, so older (or
+non-ACL-enabled) rsyncs use the umask even if default ACLs are present.
+(Keep in mind that it is the version of the receiving rsync that affects
+these behaviors.)
 
 dit(bf(-E, --executability)) This option causes rsync to preserve the
 executability (or non-executability) of regular files when bf(--perms) is
 not enabled.  A regular file is considered to be executable if at least one
 'x' is turned on in its permissions.  When an existing destination file's
 executability differs from that of the corresponding source file, rsync
@@ -801,12 +903,28 @@
   it() To make a file executable, rsync turns on each 'x' permission that
   has a corresponding 'r' permission enabled.
 ))
 
 If bf(--perms) is enabled, this option is ignored.
 
+dit(bf(-A, --acls)) This option causes rsync to update the destination
+ACLs to be the same as the source ACLs.
+The option also implies bf(--perms).
+
+The source and destination systems must have compatible ACL entries for this
+option to work properly.  See the bf(--fake-super) option for a way to backup
+and restore ACLs that are not compatible.
+
+dit(bf(-X, --xattrs)) This option causes rsync to update the remote
+extended attributes to be the same as the local ones.
+
+For systems that support extended-attribute namespaces, a copy being done by a
+super-user copies all namespaces except system.*.  A normal user only copies
+the user.* namespace.  To be able to backup and restore non-user namespaces as
+a normal user, see the bf(--fake-super) option.
+
 dit(bf(--chmod)) This option tells rsync to apply one or more
 comma-separated "chmod" strings to the permission of the files in the
 transfer.  The resulting value is treated as though it was the permissions
 that the sending side supplied for the file, which means that this option
 can seem to have no effect on existing files if bf(--perms) is not enabled.
 
@@ -823,15 +941,15 @@
 See the bf(--perms) and bf(--executability) options for how the resulting
 permission value can be applied to the files in the transfer.
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
 destination file to be the same as the source file, but only if the
 receiving rsync is being run as the super-user (see also the bf(--super)
-option to force rsync to attempt super-user activities).
-Without this option, the owner is set to the invoking user on the
-receiving side.
+and bf(--fake-super) options).
+Without this option, the owner of new and/or transferred files are set to
+the invoking user on the receiving side.
 
 The preservation of ownership will associate matching names by default, but
 may fall back to using the ID number in some circumstances (see also the
 bf(--numeric-ids) option for a full discussion).
 
 dit(bf(-g, --group)) This option causes rsync to set the group of the
@@ -846,13 +964,13 @@
 default, but may fall back to using the ID number in some circumstances
 (see also the bf(--numeric-ids) option for a full discussion).
 
 dit(bf(--devices)) This option causes rsync to transfer character and
 block device files to the remote system to recreate these devices.
 This option has no effect if the receiving rsync is not run as the
-super-user and bf(--super) is not specified.
+super-user (see also the bf(--super) and bf(--fake-super) options).
 
 dit(bf(--specials)) This option causes rsync to transfer special files
 such as named sockets and fifos.
 
 dit(bf(-D)) The bf(-D) option is equivalent to bf(--devices) bf(--specials).
 
@@ -876,24 +994,67 @@
 option, and copying devices via the bf(--devices) option.  This is useful
 for systems that allow such activities without being the super-user, and
 also for ensuring that you will get errors if the receiving side isn't
 being running as the super-user.  To turn off super-user activities, the
 super-user can use bf(--no-super).
 
+dit(bf(--fake-super)) When this option is enabled, rsync simulates
+super-user activities by saving/restoring the privileged attributes via
+special extended attributes that are attached to each file (as needed).  This
+includes the file's owner and group (if it is not the default), the file's
+device info (device & special files are created as empty text files), and
+any permission bits that we won't allow to be set on the real file (e.g.
+the real file gets u-s,g-s,o-t for safety) or that would limit the owner's
+access (since the real super-user can always access/change a file, the
+files we create can always be accessed/changed by the creating user).
+This option also handles ACLs (if bf(--acls) was specified) and non-user
+extended attributes (if bf(--xattrs) was specified).
+
+This is a good way to backup data without using a super-user, and to store
+ACLs from incompatible systems.
+
+The bf(--fake-super) option only affects the side where the option is used.
+To affect the remote side of a remote-shell connection, specify an rsync
+path:
+
+quote(tt(  rsync -av --rsync-path="rsync --fake-super" /src/ host:/dest/))
+
+Since there is only one "side" in a local copy, this option affects both
+the sending and receiving of files.  You'll need to specify a copy using
+"localhost" if you need to avoid this, possibly using the "lsh" shell
+script (from the support directory) as a substitute for an actual remote
+shell (see bf(--rsh)).
+
+This option is overridden by both bf(--super) and bf(--no-super).
+
+See also the "fake super" setting in the daemon's rsyncd.conf file.
+
 dit(bf(-S, --sparse)) Try to handle sparse files efficiently so they take
 up less space on the destination.  Conflicts with bf(--inplace) because it's
 not possible to overwrite data in a sparse fashion.
 
 NOTE: Don't use this option when the destination is a Solaris "tmpfs"
 filesystem. It doesn't seem to handle seeks over null regions
 correctly and ends up corrupting the files.
 
-dit(bf(-n, --dry-run)) This tells rsync to not do any file transfers,
-instead it will just report the actions it would have taken.
+dit(bf(-n, --dry-run)) This makes rsync perform a trial run that doesn't
+make any changes (and produces mostly the same output as a real run).  It
+is most commonly used in combination with the bf(-v, --verbose) and/or
+bf(-i, --itemize-changes) options to see what an rsync command is going
+to do before one actually runs it.
+
+The output of bf(--itemize-changes) is supposed to be exactly the same on a
+dry run and a subsequent real run (barring intentional trickery and system
+call failures); if it isn't, that's a bug.  Other output is the same to the
+extent practical, but may differ in some areas.  Notably, a dry run does not
+send the actual data for file transfers, so bf(--progress) has no effect,
+the "bytes sent", "bytes received", "literal data", and "matched data"
+statistics are too small, and the "speedup" value is equivalent to a run
+where no file transfers are needed.
 
-dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
+dit(bf(-W, --whole-file)) With this option the delta-transfer algorithm
 is not used and the whole file is sent as-is instead.  The transfer may be
 faster if this option is used when the bandwidth between the source and
 destination machines is higher than the bandwidth to disk (especially when the
 "disk" is actually a networked filesystem).  This is the default when both
 the source and destination are specified as local paths.
 
@@ -916,17 +1077,25 @@
 by this option.
 
 dit(bf(--existing, --ignore-non-existing)) This tells rsync to skip
 creating files (including directories) that do not exist
 yet on the destination.  If this option is
 combined with the bf(--ignore-existing) option, no files will be updated
-(which can be useful if all you want to do is to delete extraneous files).
+(which can be useful if all you want to do is delete extraneous files).
 
 dit(bf(--ignore-existing)) This tells rsync to skip updating files that
 already exist on the destination (this does em(not) ignore existing
-directores, or nothing would get done).  See also bf(--existing).
+directories, or nothing would get done).  See also bf(--existing).
+
+This option can be useful for those doing backups using the bf(--link-dest)
+option when they need to continue a backup run that got interrupted.  Since
+a bf(--link-dest) run is copied into a new directory hierarchy (when it is
+used properly), using bf(--ignore existing) will ensure that the
+already-handled files don't get tweaked (which avoids a change in
+permissions on the hard-linked files).  This does mean that this option
+is only looking at the existing files in the destination hierarchy itself.
 
 dit(bf(--remove-source-files)) This tells rsync to remove from the sending
 side the files (meaning non-directories) that are a part of the transfer
 and have been successfully duplicated on the receiving side.
 
 dit(bf(--delete)) This tells rsync to delete extraneous files from the
@@ -938,53 +1107,66 @@
 the files' parent directory.  Files that are excluded from transfer are
 also excluded from being deleted unless you use the bf(--delete-excluded)
 option or mark the rules as only matching on the sending side (see the
 include/exclude modifiers in the FILTER RULES section).
 
 Prior to rsync 2.6.7, this option would have no effect unless bf(--recursive)
-was in effect.  Beginning with 2.6.7, deletions will also occur when bf(--dirs)
-(bf(-d)) is in effect, but only for directories whose contents are being copied.
+was enabled.  Beginning with 2.6.7, deletions will also occur when bf(--dirs)
+(bf(-d)) is enabled, but only for directories whose contents are being copied.
 
-This option can be dangerous if used incorrectly!  It is a very good idea
-to run first using the bf(--dry-run) option (bf(-n)) to see what files would be
-deleted to make sure important files aren't listed.
+This option can be dangerous if used incorrectly!  It is a very good idea to
+first try a run using the bf(--dry-run) option (bf(-n)) to see what files are
+going to be deleted.
 
 If the sending side detects any I/O errors, then the deletion of any
 files at the destination will be automatically disabled. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
 destination.  You can override this with the bf(--ignore-errors) option.
 
 The bf(--delete) option may be combined with one of the --delete-WHEN options
 without conflict, as well as bf(--delete-excluded).  However, if none of the
---delete-WHEN options are specified, rsync will currently choose the
-bf(--delete-before) algorithm.  A future version may change this to choose the
-bf(--delete-during) algorithm.  See also bf(--delete-after).
+--delete-WHEN options are specified, rsync will choose the
+bf(--delete-during) algorithm when talking to an rsync 3.0.0 or newer, and
+the bf(--delete-before) algorithm when talking to an older rsync.  See also
+bf(--delete-delay) and bf(--delete-after).
 
 dit(bf(--delete-before)) Request that the file-deletions on the receiving
-side be done before the transfer starts.  This is the default if bf(--delete)
-or bf(--delete-excluded) is specified without one of the --delete-WHEN options.
+side be done before the transfer starts.
 See bf(--delete) (which is implied) for more details on file-deletion.
 
 Deleting before the transfer is helpful if the filesystem is tight for space
 and removing extraneous files would help to make the transfer possible.
 However, it does introduce a delay before the start of the transfer,
 and this delay might cause the transfer to timeout (if bf(--timeout) was
-specified).
+specified).  It also forces rsync to use the old, non-incremental recursion
+algorithm that requires rsync to scan all the files in the transfer into
+memory at once (see bf(--recursive)).
 
 dit(bf(--delete-during, --del)) Request that the file-deletions on the
 receiving side be done incrementally as the transfer happens.  This is
 a faster method than choosing the before- or after-transfer algorithm,
 but it is only supported beginning with rsync version 2.6.4.
 See bf(--delete) (which is implied) for more details on file-deletion.
 
+dit(bf(--delete-delay)) Request that the file-deletions on the receiving
+side be computed during the transfer, and then removed after the transfer
+completes.  If the number of removed files overflows an internal buffer, a
+temporary file will be created on the receiving side to hold the names (it
+is removed while open, so you shouldn't see it during the transfer).  If
+the creation of the temporary file fails, rsync will try to fall back to
+using bf(--delete-after) (which it cannot do if bf(--recursive) is doing an
+incremental scan).
+
 dit(bf(--delete-after)) Request that the file-deletions on the receiving
 side be done after the transfer has completed.  This is useful if you
 are sending new per-directory merge files as a part of the transfer and
 you want their exclusions to take effect for the delete phase of the
-current transfer.
+current transfer.  It also forces rsync to use the old, non-incremental
+recursion algorithm that requires rsync to scan all the files in the
+transfer into memory at once (see bf(--recursive)).
 See bf(--delete) (which is implied) for more details on file-deletion.
 
 dit(bf(--delete-excluded)) In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see bf(--exclude)).
 See the FILTER RULES section for a way to make individual exclusions behave
@@ -1001,14 +1183,21 @@
 
 Note for older rsync versions: bf(--force) used to still be required when
 using bf(--delete-after), and it used to be non-functional unless the
 bf(--recursive) option was also enabled.
 
 dit(bf(--max-delete=NUM)) This tells rsync not to delete more than NUM
-files or directories (NUM must be non-zero).
-This is useful when mirroring very large trees to prevent disasters.
+files or directories.  If that limit is exceeded, a warning is output
+and rsync exits with an error code of 25 (new for 3.0.0).
+
+Also new for version 3.0.0, you may specify bf(--max-delete=0) to be warned
+about any extraneous files in the destination without removing any of them.
+Older clients interpreted this as "unlimited", so if you don't know what
+version the client is, you can use the less obvious bf(--max-delete=-1) as
+a backward-compatible way to specify that no deletions be allowed (though
+older versions didn't warn when the limit was exceeded).
 
 dit(bf(--max-size=SIZE)) This tells rsync to avoid transferring any
 file that is larger than the specified SIZE. The SIZE value can be
 suffixed with a string to indicate a size multiplier, and
 may be a fractional value (e.g. "bf(--max-size=1.5m)").
 
@@ -1074,26 +1263,27 @@
 not corrupt the standard-in & standard-out that rsync is using to
 communicate.
 
 One tricky example is to set a different default directory on the remote
 machine for use with the bf(--relative) option.  For instance:
 
-quote(tt(    rsync -avR --rsync-path="cd /a/b && rsync" hst:c/d /e/))
+quote(tt(    rsync -avR --rsync-path="cd /a/b && rsync" host:c/d /e/))
 
 dit(bf(-C, --cvs-exclude)) This is a useful shorthand for excluding a
 broad range of files that you often don't want to transfer between
-systems. It uses the same algorithm that CVS uses to determine if
+systems. It uses a similar algorithm to CVS to determine if
 a file should be ignored.
 
-The exclude list is initialized to:
+The exclude list is initialized to exclude the following items (these
+initial items are marked as perishable -- see the FILTER RULES section):
 
 quote(quote(tt(RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS .make.state
-.nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig *.rej
-.del-* *.a *.olb *.o *.obj *.so *.exe *.Z *.elc *.ln core .svn/)))
+.nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig *.rej .del-*
+*.a *.olb *.o *.obj *.so *.exe *.Z *.elc *.ln core .svn/ .git/ .bzr/)))
 
-then files listed in a $HOME/.cvsignore are added to the list and any
+then, files listed in a $HOME/.cvsignore are added to the list and any
 files listed in the CVSIGNORE environment variable (all cvsignore names
 are delimited by whitespace).
 
 Finally, any file is ignored if it is in the same directory as a
 .cvsignore file and matches one of the patterns listed therein.  Unlike
 rsync's filter/exclude files, these patterns are split on whitespace.
@@ -1113,13 +1303,16 @@
 
 dit(bf(-f, --filter=RULE)) This option allows you to add rules to selectively
 exclude certain files from the list of files to be transferred. This is
 most useful in combination with a recursive transfer.
 
 You may use as many bf(--filter) options on the command line as you like
-to build up the list of files to exclude.
+to build up the list of files to exclude.  If the filter contains whitespace,
+be sure to quote it so that the shell gives the rule to rsync as a single
+argument.  The text below also mentions that you can use an underscore to
+replace the space that separates a rule from its arg.
 
 See the FILTER RULES section for detailed information on this option.
 
 dit(bf(-F)) The bf(-F) option is a shorthand for adding two bf(--filter) rules to
 your command.  The first time it is used is a shorthand for this rule:
 
@@ -1176,13 +1369,13 @@
   it() These side-effects change the default state of rsync, so the position
   of the bf(--files-from) option on the command-line has no bearing on how
   other options are parsed (e.g. bf(-a) works the same before or after
   bf(--files-from), as does bf(--no-R) and all other options).
 ))
 
-The file names that are read from the FILE are all relative to the
+The filenames that are read from the FILE are all relative to the
 source dir -- any leading slashes are removed and no ".." references are
 allowed to go higher than the source dir.  For example, take this
 command:
 
 quote(tt(   rsync -a --files-from=/tmp/foo /usr remote:/backup))
 
@@ -1214,20 +1407,35 @@
 file are terminated by a null ('\0') character, not a NL, CR, or CR+LF.
 This affects bf(--exclude-from), bf(--include-from), bf(--files-from), and any
 merged files specified in a bf(--filter) rule.
 It does not affect bf(--cvs-exclude) (since all names read from a .cvsignore
 file are split on whitespace).
 
+If the bf(--iconv) and bf(--protect-args) options are specified and the
+bf(--files-from) filenames are being sent from one host to another, the
+filenames will be translated from the sending host's charset to the
+receiving host's charset.
+
+dit(bf(-s, --protect-args)) This option sends all filenames and some options to
+the remote rsync without allowing the remote shell to interpret them.  This
+means that spaces are not split in names, and any non-wildcard special
+characters are not translated (such as ~, $, ;, &, etc.).  Wildcards are
+expanded on the remote host by rsync (instead of the shell doing it).
+
+If you use this option with bf(--iconv), the args will also be translated
+from the local to the remote character-set.  The translation happens before
+wild-cards are expanded.  See also the bf(--files-from) option.
+
 dit(bf(-T, --temp-dir=DIR)) This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files transferred
 on the receiving side.  The default behavior is to create each temporary
 file in the same directory as the associated destination file.
 
 This option is most often used when the receiving disk partition does not
 have enough free space to hold a copy of the largest file in the transfer.
-In this case (i.e. when the scratch directory in on a different disk
+In this case (i.e. when the scratch directory is on a different disk
 partition), rsync will not be able to rename each received temporary file
 over the top of the associated destination file, but instead must copy it
 into place.  Rsync does this by copying the file over the top of the
 destination file, which means that the destination file will contain
 truncated data during this copy.  If this were not done this way (even if
 the destination file were first removed, the data locally copied to a
@@ -1306,12 +1514,18 @@
 for an exact match.
 If a match is found that differs only in attributes, a local copy is made
 and the attributes updated.
 If a match is not found, a basis file from one of the em(DIR)s will be
 selected to try to speed up the transfer.
 
+This option works best when copying into an empty destination hierarchy, as
+rsync treats existing files as definitive (so it never looks in the link-dest
+dirs when a destination file already exists), and as malleable (so it might
+change the attributes of a destination file, which affects all the hard-linked
+versions).
+
 Note that if you combine this option with bf(--ignore-times), rsync will not
 link any files together because it only links identical files together as a
 substitute for transferring the file, never as an additional check after the
 file is updated.
 
 If em(DIR) is a relative path, it is relative to the destination directory.
@@ -1328,16 +1542,46 @@
 
 Note that this option typically achieves better compression ratios than can
 be achieved by using a compressing remote shell or a compressing transport
 because it takes advantage of the implicit information in the matching data
 blocks that are not explicitly sent over the connection.
 
+See the bf(--skip-compress) option for the default list of file suffixes
+that will not be compressed.
+
 dit(bf(--compress-level=NUM)) Explicitly set the compression level to use
 (see bf(--compress)) instead of letting it default.  If NUM is non-zero,
 the bf(--compress) option is implied.
 
+dit(bf(--skip-compress=LIST)) Override the list of file suffixes that will
+not be compressed.  The bf(LIST) should be one or more file suffixes
+(without the dot) separated by slashes (/).
+
+You may specify an empty string to indicate that no file should be skipped.
+
+Simple character-class matching is supported: each must consist of a list
+of letters inside the square brackets (e.g. no special classes, such as
+"[:alpha:]", are supported).
+
+The characters asterisk (*) and question-mark (?) have no special meaning.
+
+Here's an example that specifies 6 suffixes to skip (since 1 of the 5 rules
+matches 2 suffixes):
+
+verb(    --skip-compress=gz/jpg/mp[34]/7z/bz2)
+
+The default list of suffixes that will not be compressed is this (several
+of these are newly added for 3.0.0):
+
+verb(    gz/zip/z/rpm/deb/iso/bz2/t[gb]z/7z/mp[34]/mov/avi/ogg/jpg/jpeg)
+
+This list will be replaced by your bf(--skip-compress) list in all but one
+situation: a copy from a daemon rsync will add your skipped suffixes to
+its list of non-compressing files (and its list may be configured to a
+different default).
+
 dit(bf(--numeric-ids)) With this option rsync will transfer numeric group
 and user IDs rather than using user and group names and mapping them
 at both ends.
 
 By default rsync will use the username and groupname to determine
 what ownership to give files. The special uid 0 and the special group
@@ -1352,12 +1596,16 @@
 users and groups and what you can do about it.
 
 dit(bf(--timeout=TIMEOUT)) This option allows you to set a maximum I/O
 timeout in seconds. If no data is transferred for the specified time
 then rsync will exit. The default is 0, which means no timeout.
 
+dit(bf(--contimeout)) This option allows you to set the amount of time
+that rsync will wait for its connection to an rsync daemon to succeed.
+If the timeout is reached, rsync exits with an error.
+
 dit(bf(--address)) By default rsync will bind to the wildcard address when
 connecting to an rsync daemon.  The bf(--address) option allows you to
 specify a specific IP address (or hostname) to bind to.  See also this
 option in the bf(--daemon) mode section.
 
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
@@ -1386,14 +1634,14 @@
 This is exactly the same as specifying bf(--out-format='%i %n%L').
 If you repeat the option, unchanged files will also be output, but only
 if the receiving rsync is at least version 2.6.7 (you can use bf(-vv)
 with older versions of rsync, but that also turns on the output of other
 verbose messages).
 
-The "%i" escape has a cryptic output that is 9 letters long.  The general
-format is like the string bf(YXcstpogz), where bf(Y) is replaced by the
+The "%i" escape has a cryptic output that is 11 letters long.  The general
+format is like the string bf(YXcstpoguax), where bf(Y) is replaced by the
 type of update being done, bf(X) is replaced by the file-type, and the
 other letters represent attributes that may be output if they are being
 modified.
 
 The update types that replace the bf(Y) are as follows:
 
@@ -1405,12 +1653,14 @@
   it() A bf(c) means that a local change/creation is occurring for the item
   (such as the creation of a directory or the changing of a symlink, etc.).
   it() A bf(h) means that the item is a hard link to another item (requires
   bf(--hard-links)).
   it() A bf(.) means that the item is not being updated (though it might
   have attributes that are being modified).
+  it() A bf(*) means that the rest of the itemized-output area contains
+  a message (e.g. "deleting").
 ))
 
 The file-types that replace the bf(X) are: bf(f) for a file, a bf(d) for a
 directory, an bf(L) for a symlink, a bf(D) for a device, and a bf(S) for a
 special file (e.g. named sockets and fifos).
 
@@ -1427,22 +1677,24 @@
   it() A bf(c) means the checksum of the file is different and will be
   updated by the file transfer (requires bf(--checksum)).
   it() A bf(s) means the size of the file is different and will be updated
   by the file transfer.
   it() A bf(t) means the modification time is different and is being updated
   to the sender's value (requires bf(--times)).  An alternate value of bf(T)
-  means that the time will be set to the transfer time, which happens
-  anytime a symlink is transferred, or when a file or device is transferred
-  without bf(--times).
+  means that the modification time will be set to the transfer time, which happens
+  when a file/symlink/device is updated without bf(--times) and when a
+  symlink is changed and the receiver can't set its time.
   it() A bf(p) means the permissions are different and are being updated to
   the sender's value (requires bf(--perms)).
   it() An bf(o) means the owner is different and is being updated to the
   sender's value (requires bf(--owner) and super-user privileges).
   it() A bf(g) means the group is different and is being updated to the
   sender's value (requires bf(--group) and the authority to set the group).
-  it() The bf(z) slot is reserved for future use.
+  it() The bf(u) slot is reserved for future use.
+  it() The bf(a) means that the ACL information changed.
+  it() The bf(x) means that the extended attribute information changed.
 ))
 
 One other output is possible:  when deleting files, the "%i" will output
 the string "*deleting" for each item that is being removed (assuming that
 you are talking to a recent enough rsync that it logs deletions instead of
 outputting them as a verbose message).
@@ -1560,26 +1812,26 @@
 dir as data to speed up the resumption of the transfer and then delete it
 after it has served its purpose.
 
 Note that if bf(--whole-file) is specified (or implied), any partial-dir
 file that is found for a file that is being updated will simply be removed
 (since
-rsync is sending files without using the incremental rsync algorithm).
+rsync is sending files without using the delta transfer algorithm).
 
 Rsync will create the em(DIR) if it is missing (just the last dir -- not
 the whole path).  This makes it easy to use a relative path (such as
 "bf(--partial-dir=.rsync-partial)") to have rsync create the
 partial-directory in the destination file's directory when needed, and then
 remove it again when the partial file is deleted.
 
 If the partial-dir value is not an absolute path, rsync will add an exclude
 rule at the end of all your existing excludes.  This will prevent the
 sending of any partial-dir files that may exist on the sending side, and
 will also prevent the untimely deletion of partial-dir items on the
 receiving side.  An example: the above bf(--partial-dir) option would add
-the equivalent of "bf(--exclude=.rsync-partial/)" at the end of any other
+the equivalent of "bf(-f '-p .rsync-partial/')" at the end of any other
 filter rules.
 
 If you are supplying your own exclude rules, you may need to add your own
 exclude/hide/protect rule for the partial-dir because (1) the auto-added
 rule may be ineffective at the end of your other rules, or (2) you may wish
 to override rsync's exclude choice.  For instance, if you want to make
@@ -1615,13 +1867,13 @@
 succession.  This attempts to make the updating of the files a little more
 atomic.  By default the files are placed into a directory named ".~tmp~" in
 each file's destination directory, but if you've specified the
 bf(--partial-dir) option, that directory will be used instead.  See the
 comments in the bf(--partial-dir) section for a discussion of how this
 ".~tmp~" dir will be excluded from the transfer, and what you can do if
-you wnat rsync to cleanup old ".~tmp~" dirs that might be lying around.
+you want rsync to cleanup old ".~tmp~" dirs that might be lying around.
 Conflicts with bf(--inplace) and bf(--append).
 
 This option uses more memory on the receiving side (one bit per file
 transferred) and also requires enough free disk space on the receiving
 side to hold an additional copy of all the updated files.  Note also that
 you should not use an absolute path to bf(--partial-dir) unless (1)
@@ -1660,13 +1912,13 @@
 that any superfluous files and directories in the destination are removed
 (note the hide filter of non-directories being used instead of an exclude):
 
 quote(     rsync -avm --del --include='*.pdf' -f 'hide,! */' src/ dest)
 
 If you didn't want to remove superfluous destination files, the more
-time-honored options of "--include='*/' --exclude='*'" would work fine
+time-honored options of "bf(--include='*/' --exclude='*')" would work fine
 in place of the hide-filter (if that is more natural to you).
 
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
 Implies bf(--verbose) if it wasn't already specified.
@@ -1678,13 +1930,13 @@
 
 In this example, the receiver has reconstructed 782448 bytes or 63% of the
 sender's file, which is being reconstructed at a rate of 110.64 kilobytes
 per second, and the transfer will finish in 4 seconds if the current rate
 is maintained until the end.
 
-These statistics can be misleading if the incremental transfer algorithm is
+These statistics can be misleading if the delta transfer algorithm is
 in use.  For example, if the sender's file consists of the basis file
 followed by additional data, the reported rate will probably drop
 dramatically when the receiver gets to the literal data, and the transfer
 will probably take much longer to finish than the receiver estimated as it
 was finishing the matched part of the file.
 
@@ -1701,33 +1953,43 @@
 the 396 total files in the file-list.
 
 dit(bf(-P)) The bf(-P) option is equivalent to bf(--partial) bf(--progress).  Its
 purpose is to make it much easier to specify these two options for a long
 transfer that may be interrupted.
 
-dit(bf(--password-file)) This option allows you to provide a password
-in a file for accessing a remote rsync daemon. Note that this option
-is only useful when accessing an rsync daemon using the built in
-transport, not when using a remote shell as the transport. The file
-must not be world readable. It should contain just the password as a
-single line.
+dit(bf(--password-file)) This option allows you to provide a password in a
+file for accessing an rsync daemon.  The file must not be world readable.
+It should contain just the password as a single line.
+
+This option does not supply a password to a remote shell transport such as
+ssh; to learn how to do that, consult the remote shell's documentation.
+When accessing an rsync daemon using a remote shell as the transport, this
+option only comes into effect after the remote shell finishes its
+authentication (i.e. if you have also specified a password in the daemon's
+config file).
 
 dit(bf(--list-only)) This option will cause the source files to be listed
 instead of transferred.  This option is inferred if there is a single source
 arg and no destination specified, so its main uses are: (1) to turn a copy
 command that includes a
-destination arg into a file-listing command, (2) to be able to specify more
-than one local source arg (note: be sure to include the destination), or
-(3) to avoid the automatically added "bf(-r --exclude='/*/*')" options that
-rsync usually uses as a compatibility kluge when generating a non-recursive
-listing.  Caution: keep in mind that a source arg with a wild-card is expanded
-by the shell into multiple args, so it is never safe to try to list such an arg
+destination arg into a file-listing command, or (2) to be able to specify
+more than one source arg (note: be sure to include the destination).
+Caution: keep in mind that a source arg with a wild-card is expanded by the
+shell into multiple args, so it is never safe to try to list such an arg
 without using this option.  For example:
 
 verb(    rsync -av --list-only foo* dest/)
 
+Compatibility note:  when requesting a remote listing of files from an rsync
+that is version 2.6.3 or older, you may encounter an error if you ask for a
+non-recursive listing.  This is because a file listing implies the bf(--dirs)
+option w/o bf(--recursive), and older rsyncs don't have that option.  To
+avoid this problem, either specify the bf(--no-dirs) option (if you don't
+need to expand a directory's content), or turn on recursion and exclude
+the content of subdirectories: bf(-r --exclude='/*/*').
+
 dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
 transfer rate in kilobytes per second. This option is most effective when
 using rsync with large files (several megabytes and up). Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block. The
 result is an average transfer rate equaling the specified limit. A value
@@ -1764,17 +2026,51 @@
 version of rsync.  For instance, if rsync 2.6.4 is being used with the
 bf(--write-batch) option, but rsync 2.6.3 is what will be used to run the
 bf(--read-batch) option, you should use "--protocol=28" when creating the
 batch file to force the older protocol version to be used in the batch
 file (assuming you can't upgrade the rsync on the reading system).
 
+dit(bf(--iconv=CONVERT_SPEC)) Rsync can convert filenames between character
+sets using this option.  Using a CONVERT_SPEC of "." tells rsync to look up
+the default character-set via the locale setting.  Alternately, you can
+fully specify what conversion to do by giving a local and a remote charset
+separated by a comma in the order bf(--iconv=LOCAL,REMOTE), e.g.
+bf(--iconv=utf8,iso88591).  This order ensures that the option
+will stay the same whether you're pushing or pulling files.
+Finally, you can specify either bf(--no-iconv) or a CONVERT_SPEC of "-"
+to turn off any conversion.
+The default setting of this option is site-specific, and can also be
+affected via the RSYNC_ICONV environment variable.
+
+For a list of what charset names your local iconv library supports, you can
+run "iconv --list".
+
+If you specify the bf(--protect-args) option (bf(-s)), rsync will translate
+the filenames you specify on the command-line that are being sent to the
+remote host.  See also the bf(--files-from) option.
+
+Note that rsync does not do any conversion of names in filter files
+(including include/exclude files).  It is up to you to ensure that you're
+specifying matching rules that can match on both sides of the transfer.
+For instance, you can specify extra include/exclude rules if there are
+filename differences on the two sides that need to be accounted for.
+
+When you pass an bf(--iconv) option to an rsync daemon that allows it, the
+daemon uses the charset specified in its "charset" configuration parameter
+regardless of the remote charset you actually pass.  Thus, you may feel free to
+specify just the local charset for a daemon transfer (e.g. bf(--iconv=utf8)).
+
 dit(bf(-4, --ipv4) or bf(-6, --ipv6)) Tells rsync to prefer IPv4/IPv6
 when creating sockets.  This only affects sockets that rsync has direct
 control over, such as the outgoing socket when directly contacting an
 rsync daemon.  See also these options in the bf(--daemon) mode section.
 
+If rsync was complied without support for IPv6, the bf(--ipv6) option
+will have no effect.  The bf(--version) output will tell you if this
+is the case.
+
 dit(bf(--checksum-seed=NUM)) Set the MD4 checksum seed to the integer
 NUM.  This 4 byte checksum seed is included in each block and file
 MD4 checksum calculation.  By default the checksum seed is generated
 by the server and defaults to the current code(time()).  This option
 is used to set a specific checksum seed, which is useful for
 applications that want repeatable block and file checksums, or
@@ -1851,12 +2147,16 @@
 when creating the incoming sockets that the rsync daemon will use to
 listen for connections.  One of these options may be required in older
 versions of Linux to work around an IPv6 bug in the kernel (if you see
 an "address already in use" error when nothing else is using the port,
 try specifying bf(--ipv6) or bf(--ipv4) when starting the daemon).
 
+If rsync was complied without support for IPv6, the bf(--ipv6) option
+will have no effect.  The bf(--version) output will tell you if this
+is the case.
+
 dit(bf(-h, --help)) When specified after bf(--daemon), print a short help
 page describing the options available for starting an rsync daemon.
 enddit()
 
 manpagesection(FILTER RULES)
 
@@ -1927,26 +2227,25 @@
 
 itemization(
   it() if the pattern starts with a / then it is anchored to a
   particular spot in the hierarchy of files, otherwise it is matched
   against the end of the pathname.  This is similar to a leading ^ in
   regular expressions.
-  Thus "/foo" would match a file named "foo" at either the "root of the
+  Thus "/foo" would match a name of "foo" at either the "root of the
   transfer" (for a global rule) or in the merge-file's directory (for a
   per-directory rule).
-  An unqualified "foo" would match any file or directory named "foo"
-  anywhere in the tree because the algorithm is applied recursively from
-  the
+  An unqualified "foo" would match a name of "foo" anywhere in the
+  tree because the algorithm is applied recursively from the
   top down; it behaves as if each path component gets a turn at being the
-  end of the file name.  Even the unanchored "sub/foo" would match at
+  end of the filename.  Even the unanchored "sub/foo" would match at
   any point in the hierarchy where a "foo" was found within a directory
   named "sub".  See the section on ANCHORING INCLUDE/EXCLUDE PATTERNS for
   a full discussion of how to specify a pattern that matches at the root
   of the transfer.
   it() if the pattern ends with a / then it will only match a
-  directory, not a file, link, or device.
+  directory, not a regular file, symlink, or device.
   it() rsync chooses between doing a simple string match and wildcard
   matching by checking if the pattern contains one of these three wildcard
   characters: '*', '?', and '[' .
   it() a '*' matches any non-empty path component (it stops at slashes).
   it() use '**' to match anything, including slashes.
   it() a '?' matches any character except a slash (/).
@@ -1958,15 +2257,15 @@
   directories. If the pattern doesn't contain a / or a "**", then it is
   matched only against the final component of the filename.
   (Remember that the algorithm is applied recursively so "full filename"
   can actually be any portion of a path from the starting directory on
   down.)
   it() a trailing "dir_name/***" will match both the directory (as if
-  "dir_name/" had been specified) and all the files in the directory
-  (as if "dir_name/**" had been specified).  (This behavior is new for
-  version 2.6.7.)
+  "dir_name/" had been specified) and everything in the directory
+  (as if "dir_name/**" had been specified).  This behavior was added in
+  version 2.6.7.
 )
 
 Note that, when using the bf(--recursive) (bf(-r)) option (which is implied by
 bf(-a)), every subcomponent of every path is visited from the top down, so
 include/exclude patterns get applied recursively to each subcomponent's
 full name (e.g. to include "/foo/bar/baz" the subcomponents "/foo" and
@@ -2001,13 +2300,13 @@
 tt(- *)nl()
 )
 
 Here are some examples of exclude/include matching:
 
 itemization(
-  it() "- *.o" would exclude all filenames matching *.o
+  it() "- *.o" would exclude all names matching *.o
   it() "- /foo" would exclude a file (or directory) named foo in the
   transfer-root directory
   it() "- foo/" would exclude any directory named foo
   it() "- /foo/*/bar" would exclude any file named bar which is at two
   levels below a directory named foo in the transfer-root directory
   it() "- /foo/**/bar" would exclude any file named bar two
@@ -2075,19 +2374,19 @@
   per-directory rules apply only on the sending side.
 )
 
 The following modifiers are accepted after a "+" or "-":
 
 itemization(
-  it() A "/" specifies that the include/exclude rule should be matched
+  it() A bf(/) specifies that the include/exclude rule should be matched
   against the absolute pathname of the current item.  For example,
   "-/ /etc/passwd" would exclude the passwd file any time the transfer
   was sending files from the "/etc" directory, and "-/ subdir/foo"
   would always exclude "foo" when it is in a dir named "subdir", even
   if "foo" is at the root of the current transfer.
-  it() A "!" specifies that the include/exclude should take effect if
+  it() A bf(!) specifies that the include/exclude should take effect if
   the pattern fails to match.  For instance, "-! */" would exclude all
   non-directories.
   it() A bf(C) is used to indicate that all the global CVS-exclude rules
   should be inserted as excludes in place of the "-C".  No arg should
   follow.
   it() An bf(s) is used to indicate that the rule applies to the sending
@@ -2098,12 +2397,17 @@
   which are an alternate way to specify sending-side includes/excludes.
   it() An bf(r) is used to indicate that the rule applies to the receiving
   side.  When a rule affects the receiving side, it prevents files from
   being deleted.  See the bf(s) modifier for more info.  See also the
   protect (P) and risk (R) rules, which are an alternate way to
   specify receiver-side includes/excludes.
+  it() A bf(p) indicates that a rule is perishable, meaning that it is
+  ignored in directories that are being deleted.  For instance, the bf(-C)
+  option's default rules that exclude things like "CVS" and "*.o" are
+  marked as perishable, and will not prevent a directory that was removed
+  on the source from being deleted on the destination.
 )
 
 Per-directory rules are inherited in all subdirectories of the directory
 where the merge-file was found unless the 'n' modifier was used.  Each
 subdirectory's rules are prefixed to the inherited per-directory rules
 from its parents, which gives the newest rules a higher priority than the
@@ -2185,13 +2489,13 @@
 the per-directory .cvsignore rules in the middle of the list rather than
 at the end.  This allows their dir-specific rules to supersede the rules
 that follow the :C instead of being subservient to all your rules.  To
 affect the other CVS exclude rules (i.e. the default list of exclusions,
 the contents of $HOME/.cvsignore, and the value of $CVSIGNORE) you should
 omit the bf(-C) command-line option and instead insert a "-C" rule into
-your filter rules; e.g. "--filter=-C".
+your filter rules; e.g. "bf(--filter=-C)".
 
 manpagesection(LIST-CLEARING FILTER RULE)
 
 You can clear the current include/exclude list by using the "!" filter
 rule (as introduced in the FILTER RULES section above).  The "current"
 list is either the global list of rules (if the rule is encountered while
@@ -2431,13 +2735,13 @@
 bf(--copy-unsafe-links) will cause any links to be copied as the file
 they point to on the destination.  Using bf(--safe-links) will cause
 unsafe links to be omitted altogether.  (Note that you must specify
 bf(--links) for bf(--safe-links) to have any effect.)
 
 Symbolic links are considered unsafe if they are absolute symlinks
-(start with bf(/)), empty, or if they contain enough bf("..")
+(start with bf(/)), empty, or if they contain enough ".."
 components to ascend from the directory being copied.
 
 Here's a summary of how the symlink options are interpreted.  The list is
 in order of precedence, so if your combination of options isn't mentioned,
 use the first line that is a complete subset of your options:
 
@@ -2502,30 +2806,34 @@
 dit(bf(21)) Some error returned by code(waitpid())
 dit(bf(22)) Error allocating core memory buffers
 dit(bf(23)) Partial transfer due to error
 dit(bf(24)) Partial transfer due to vanished source files
 dit(bf(25)) The --max-delete limit stopped deletions
 dit(bf(30)) Timeout in data send/receive
+dit(bf(35)) Timeout waiting for daemon connection
 enddit()
 
 manpagesection(ENVIRONMENT VARIABLES)
 
 startdit()
 dit(bf(CVSIGNORE)) The CVSIGNORE environment variable supplements any
 ignore patterns in .cvsignore files. See the bf(--cvs-exclude) option for
 more details.
+dit(bf(RSYNC_ICONV)) Specify a default bf(--iconv) setting using this
+environment variable.
 dit(bf(RSYNC_RSH)) The RSYNC_RSH environment variable allows you to
 override the default shell used as the transport for rsync.  Command line
 options are permitted after the command name, just as in the bf(-e) option.
 dit(bf(RSYNC_PROXY)) The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
 rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
 dit(bf(RSYNC_PASSWORD)) Setting RSYNC_PASSWORD to the required
 password allows you to run authenticated rsync connections to an rsync
 daemon without user intervention. Note that this does not supply a
-password to a shell transport such as ssh.
+password to a remote shell transport such as ssh; to learn how to do that,
+consult the remote shell's documentation.
 dit(bf(USER) or bf(LOGNAME)) The USER or LOGNAME environment variables
 are used to determine the default username sent to an rsync daemon.
 If neither is set, the username defaults to "nobody".
 dit(bf(HOME)) The HOME environment variable is used to find the user's
 default .cvsignore file.
 enddit()
@@ -2548,18 +2856,18 @@
 
 file permissions, devices, etc. are transferred as native numerical
 values
 
 see also the comments on the bf(--delete) option
 
-Please report bugs! See the website at
+Please report bugs! See the web site at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
 
 manpagesection(VERSION)
 
-This man page is current for version 2.6.9 of rsync.
+This man page is current for version 3.0.0 of rsync.
 
 manpagesection(INTERNAL OPTIONS)
 
 The options bf(--server) and bf(--sender) are used internally by rsync,
 and should never be typed by a user under normal circumstances.  Some
 awareness of these options may be needed in certain scenarios, such as
@@ -2579,26 +2887,28 @@
 manual page.
 
 The primary ftp site for rsync is
 url(ftp://rsync.samba.org/pub/rsync)(ftp://rsync.samba.org/pub/rsync).
 
 We would be delighted to hear from you if you like this program.
+Please contact the mailing-list at rsync@lists.samba.org.
 
 This program uses the excellent zlib compression library written by
 Jean-loup Gailly and Mark Adler.
 
 manpagesection(THANKS)
 
-Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
-and David Bell for helpful suggestions, patches and testing of rsync.
-I've probably missed some people, my apologies if I have.
+Especial thanks go out to: John Van Essen, Matt McCutchen, Wesley W. Terpstra,
+David Dykstra, Jos Backus, Sebastian Krahmer, Martin Pool, and our
+gone-but-not-forgotten compadre, J.W. Schultz.
 
-Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer,
-Martin Pool, Wayne Davison, J.W. Schultz.
+Thanks also to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
+and David Bell.  I've probably missed some people, my apologies if I have.
 
 manpageauthor()
 
 rsync was originally written by Andrew Tridgell and Paul Mackerras.
-Many people have later contributed to it.
+Many people have later contributed to it.  It is currently maintained
+by Wayne Davison.
 
 Mailing lists for support and development are available at
 url(http://lists.samba.org)(lists.samba.org)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/runtests.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/runtests.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/runtests.sh	2006-11-04 08:18:49.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/runtests.sh	2007-06-03 00:44:23.000000000 +0800
@@ -46,14 +46,14 @@
 # srcdir gives the location of the source tree, which lets us find the
 # build scripts.  At the moment we assume we are invoked from the
 # source directory.
 
 # This script must be invoked from the build directory.  
 
-# A scratch directory, 'testtmp', is created in the build directory to
-# hold working files.
+# A scratch directory, 'testtmp', is used in the build directory to
+# hold per-test subdirectories.
 
 # This script also uses the $loglevel environment variable.  1 is the
 # default value, and 10 the most verbose.  You can set this from the
 # Make command line.  It's also set by the build farm to give more
 # detail for failing builds.
 
@@ -178,18 +178,21 @@
 if [ "x$preserve_scratch" = xyes ]; then
     echo "    preserve_scratch=yes"
 else
     echo "    preserve_scratch=no"
 fi    
 
-# Check if setfacl is around and if it supports the -k or -s option.
-if setfacl --help 2>&1 | grep ' -k,\|\[-[a-z]*k' >/dev/null; then
+# Check if setacl/setfacl is around and if it supports the -k or -s option.
+if setacl -k u::7,g::5,o:5 testsuite 2>/dev/null; then
+    setfacl_nodef='setacl -k'
+elif setfacl --help 2>&1 | grep ' -k,\|\[-[a-z]*k' >/dev/null; then
     setfacl_nodef='setfacl -k'
 elif setfacl -s u::7,g::5,o:5 testsuite 2>/dev/null; then
     setfacl_nodef='setfacl -s u::7,g::5,o:5'
 else
+    # The "true" command runs successfully, but does nothing.
     setfacl_nodef=true
 fi
 
 export setfacl_nodef
 
 if [ ! -f "$rsync_bin" ]; then
@@ -204,28 +207,32 @@
 
 skipped=0
 missing=0
 passed=0
 failed=0
 
-# Prefix for scratch directory.  We create separate directories for
-# each test case, so that they can be left behind in case of failure
-# to aid investigation.
+# Directory that holds the other test subdirs.  We create separate dirs
+# inside for each test case, so that they can be left behind in case of
+# failure to aid investigation.  We don't remove the testtmp subdir at
+# the end so that it can be configured as a symlink to a filesystem that
+# has ACLs and xattr support enabled (if desired).
 scratchbase="$TOOLDIR"/testtmp
 echo "    scratchbase=$scratchbase"
+[ -d "$scratchbase" ] || mkdir "$scratchbase"
 
 suitedir="$srcdir/testsuite"
 
 export scratchdir suitedir
 
 prep_scratch() {
-    [ -d "$scratchdir" ] && rm -rf "$scratchdir"
+    [ -d "$scratchdir" ] && chmod -R u+rwX "$scratchdir" && rm -rf "$scratchdir"
     mkdir "$scratchdir"
     # Get rid of default ACLs and dir-setgid to avoid confusing some tests.
     $setfacl_nodef "$scratchdir" || true
     chmod g-s "$scratchdir"
+    ln -s "$srcdir" "$scratchdir/src"
     return 0
 }
 
 maybe_discard_scratch() {
     [ x"$preserve_scratch" != xyes ] && [ -d "$scratchdir" ] && rm -rf "$scratchdir"
     return 0
@@ -235,13 +242,13 @@
     whichtests="*.test"
 fi
 
 for testscript in $suitedir/$whichtests
 do
     testbase=`echo $testscript | sed -e 's!.*/!!' -e 's/.test\$//'`
-    scratchdir="$scratchbase.$testbase"
+    scratchdir="$scratchbase/$testbase"
 
     prep_scratch
 
     set +e
     sh $RUNSHFLAGS "$testscript" >"$scratchdir/test.log" 2>&1
     result=$?
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/sender.c	2006-09-20 09:53:32.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/sender.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,53 +1,53 @@
 /*
  * Routines only used by the sending process.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 extern int verbose;
+extern int dry_run;
 extern int do_xfers;
 extern int am_server;
 extern int am_daemon;
+extern int inc_recurse;
 extern int log_before_transfer;
 extern int stdout_format_has_i;
 extern int logfile_format_has_i;
 extern int csum_length;
 extern int append_mode;
 extern int io_error;
 extern int allowed_lull;
+extern int preserve_xattrs;
 extern int protocol_version;
 extern int remove_source_files;
 extern int updating_basis_file;
 extern int make_backups;
 extern int do_progress;
 extern int inplace;
 extern int batch_fd;
 extern int write_batch;
 extern struct stats stats;
-extern struct file_list *the_file_list;
-extern char *stdout_format;
-
+extern struct file_list *cur_flist, *first_flist, *dir_flist;
 
 /**
  * @file
  *
  * The sender gets checksums from the generator, calculates deltas,
  * and transmits them to the receiver.  The sender process runs on the
@@ -73,13 +73,13 @@
 
 	if (verbose > 3) {
 		rprintf(FINFO, "count=%.0f n=%ld rem=%ld\n",
 			(double)s->count, (long)s->blength, (long)s->remainder);
 	}
 
-	if (append_mode) {
+	if (append_mode > 0) {
 		s->flength = (OFF_T)s->count * s->blength;
 		if (s->remainder)
 			s->flength -= s->blength - s->remainder;
 		return s;
 	}
 
@@ -119,237 +119,227 @@
 }
 
 void successful_send(int ndx)
 {
 	char fname[MAXPATHLEN];
 	struct file_struct *file;
-	unsigned int offset;
+	struct file_list *flist;
 
-	if (ndx < 0 || ndx >= the_file_list->count)
+	if (!remove_source_files)
 		return;
 
-	file = the_file_list->files[ndx];
-	if (file->dir.root) {
-		offset = stringjoin(fname, sizeof fname,
-				    file->dir.root, "/", NULL);
-	} else
-		offset = 0;
-	f_name(file, fname + offset);
-	if (remove_source_files) {
-		if (do_unlink(fname) == 0) {
-			if (verbose > 1)
-				rprintf(FINFO, "sender removed %s\n", fname + offset);
-		} else
-			rsyserr(FERROR, errno, "sender failed to remove %s", fname + offset);
+	if (!(flist = flist_for_ndx(ndx))) {
+		rprintf(FERROR,
+			"INTERNAL ERROR: unable to find flist for item %d\n",
+			ndx);
+		return;
 	}
+
+	file = flist->files[ndx - flist->ndx_start];
+	if (!push_pathname(F_PATHNAME(file), -1))
+		return;
+	f_name(file, fname);
+
+	if (do_unlink(fname) == 0) {
+		if (verbose > 1)
+			rprintf(FINFO, "sender removed %s\n", fname);
+	} else
+		rsyserr(FERROR, errno, "sender failed to remove %s", fname);
 }
 
 static void write_ndx_and_attrs(int f_out, int ndx, int iflags,
+				const char *fname, struct file_struct *file,
 				uchar fnamecmp_type, char *buf, int len)
 {
-	write_int(f_out, ndx);
+	write_ndx(f_out, ndx);
 	if (protocol_version < 29)
 		return;
 	write_shortint(f_out, iflags);
 	if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
 		write_byte(f_out, fnamecmp_type);
 	if (iflags & ITEM_XNAME_FOLLOWS)
 		write_vstring(f_out, buf, len);
+#ifdef SUPPORT_XATTRS
+	if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && !dry_run)
+		send_xattr_request(fname, file, f_out);
+#endif
 }
 
-/* This is also used by receive.c with f_out = -1. */
-int read_item_attrs(int f_in, int f_out, int ndx, uchar *type_ptr,
-		    char *buf, int *len_ptr)
-{
-	int len;
-	uchar fnamecmp_type = FNAMECMP_FNAME;
-	int iflags = protocol_version >= 29 ? read_shortint(f_in)
-		   : ITEM_TRANSFER | ITEM_MISSING_DATA;
-
-	/* Handle the new keep-alive (no-op) packet. */
-	if (ndx == the_file_list->count && iflags == ITEM_IS_NEW)
-		;
-	else if (ndx < 0 || ndx >= the_file_list->count) {
-		rprintf(FERROR, "Invalid file index: %d (count=%d) [%s]\n",
-			ndx, the_file_list->count, who_am_i());
-		exit_cleanup(RERR_PROTOCOL);
-	} else if (iflags == ITEM_IS_NEW) {
-		rprintf(FERROR, "Invalid itemized flag word: %x [%s]\n",
-			iflags, who_am_i());
-		exit_cleanup(RERR_PROTOCOL);
-	}
-
-	if (iflags & ITEM_BASIS_TYPE_FOLLOWS)
-		fnamecmp_type = read_byte(f_in);
-	*type_ptr = fnamecmp_type;
-
-	if (iflags & ITEM_XNAME_FOLLOWS) {
-		if ((len = read_vstring(f_in, buf, MAXPATHLEN)) < 0)
-			exit_cleanup(RERR_PROTOCOL);
-	} else {
-		*buf = '\0';
-		len = -1;
-	}
-	*len_ptr = len;
-
-	if (iflags & ITEM_TRANSFER) {
-		if (!S_ISREG(the_file_list->files[ndx]->mode)) {
-			rprintf(FERROR,
-				"received request to transfer non-regular file: %d [%s]\n",
-				ndx, who_am_i());
-			exit_cleanup(RERR_PROTOCOL);
-		}
-	} else if (f_out >= 0) {
-		write_ndx_and_attrs(f_out, ndx, iflags,
-				    fnamecmp_type, buf, len);
-	}
-
-	return iflags;
-}
-
-void send_files(struct file_list *flist, int f_out, int f_in)
+void send_files(int f_in, int f_out)
 {
 	int fd = -1;
 	struct sum_struct *s;
 	struct map_struct *mbuf = NULL;
 	STRUCT_STAT st;
-	char *fname2, fname[MAXPATHLEN];
-	char xname[MAXPATHLEN];
+	char fname[MAXPATHLEN], xname[MAXPATHLEN];
+	const char *path, *slash;
 	uchar fnamecmp_type;
 	int iflags, xlen;
 	struct file_struct *file;
 	int phase = 0, max_phase = protocol_version >= 29 ? 2 : 1;
 	struct stats initial_stats;
-	int save_make_backups = make_backups;
 	int itemizing = am_server ? logfile_format_has_i : stdout_format_has_i;
 	enum logcode log_code = log_before_transfer ? FLOG : FINFO;
 	int f_xfer = write_batch < 0 ? batch_fd : f_out;
-	int i, j;
+	int ndx, j;
 
 	if (verbose > 2)
 		rprintf(FINFO, "send_files starting\n");
 
 	while (1) {
-		unsigned int offset;
+		if (inc_recurse)
+			send_extra_file_list(f_out, FILECNT_LOOKAHEAD);
 
-		i = read_int(f_in);
-		if (i == -1) {
+		/* This call also sets cur_flist. */
+		ndx = read_ndx_and_attrs(f_in, &iflags, &fnamecmp_type,
+					 xname, &xlen);
+		if (ndx == NDX_DONE) {
+			if (inc_recurse && first_flist) {
+				flist_free(first_flist);
+				if (first_flist) {
+					write_ndx(f_out, NDX_DONE);
+					continue;
+				}
+			}
 			if (++phase > max_phase)
 				break;
-			csum_length = SUM_LENGTH;
 			if (verbose > 2)
 				rprintf(FINFO, "send_files phase=%d\n", phase);
-			write_int(f_out, -1);
-			/* For inplace: redo phase turns off the backup
-			 * flag so that we do a regular inplace send. */
-			make_backups = 0;
-			append_mode = 0;
+			write_ndx(f_out, NDX_DONE);
 			continue;
 		}
 
-		iflags = read_item_attrs(f_in, f_out, i, &fnamecmp_type,
-					 xname, &xlen);
-		if (iflags == ITEM_IS_NEW) /* no-op packet */
-			continue;
+		if (inc_recurse)
+			send_extra_file_list(f_out, FILECNT_LOOKAHEAD);
 
-		file = flist->files[i];
-		if (file->dir.root) {
-			/* N.B. We're sure that this fits, so offset is OK. */
-			offset = strlcpy(fname, file->dir.root, sizeof fname);
-			if (!offset || fname[offset-1] != '/')
-				fname[offset++] = '/';
-		} else
-			offset = 0;
-		fname2 = f_name(file, fname + offset);
+		if (ndx - cur_flist->ndx_start >= 0)
+			file = cur_flist->files[ndx - cur_flist->ndx_start];
+		else
+			file = dir_flist->files[cur_flist->parent_ndx];
+		if (F_PATHNAME(file)) {
+			path = F_PATHNAME(file);
+			slash = "/";
+		} else {
+			path = slash = "";
+		}
+		if (!push_pathname(F_PATHNAME(file), -1))
+			continue;
+		f_name(file, fname);
 
 		if (verbose > 2)
-			rprintf(FINFO, "send_files(%d, %s)\n", i, fname);
+			rprintf(FINFO, "send_files(%d, %s%s%s)\n", ndx, path,slash,fname);
+
+#ifdef SUPPORT_XATTRS
+		if (preserve_xattrs && iflags & ITEM_REPORT_XATTR && !dry_run)
+			recv_xattr_request(file, f_in);
+#endif
 
 		if (!(iflags & ITEM_TRANSFER)) {
 			maybe_log_item(file, iflags, itemizing, xname);
+			write_ndx_and_attrs(f_out, ndx, iflags, fname, file,
+					    fnamecmp_type, xname, xlen);
 			continue;
 		}
 		if (phase == 2) {
 			rprintf(FERROR,
 				"got transfer request in phase 2 [%s]\n",
 				who_am_i());
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
+		if (file->flags & FLAG_FILE_SENT) {
+			if (csum_length == SHORT_SUM_LENGTH) {
+				/* For inplace: redo phase turns off the backup
+				 * flag so that we do a regular inplace send. */
+				make_backups = -make_backups;
+				append_mode = -append_mode;
+				csum_length = SUM_LENGTH;
+			}
+		} else {
+			if (csum_length != SHORT_SUM_LENGTH) {
+				make_backups = -make_backups;
+				append_mode = -append_mode;
+				csum_length = SHORT_SUM_LENGTH;
+			}
+		}
+
 		updating_basis_file = inplace && (protocol_version >= 29
-			? fnamecmp_type == FNAMECMP_FNAME : !make_backups);
+			? fnamecmp_type == FNAMECMP_FNAME : make_backups <= 0);
 
-		stats.current_file_index = i;
+		if (!am_server && do_progress)
+			set_current_file_index(file, ndx);
 		stats.num_transferred_files++;
-		stats.total_transferred_size += file->length;
+		stats.total_transferred_size += F_LENGTH(file);
 
 		if (!do_xfers) { /* log the transfer */
 			log_item(FCLIENT, file, &stats, iflags, NULL);
-			write_ndx_and_attrs(f_out, i, iflags, fnamecmp_type,
-					    xname, xlen);
+			write_ndx_and_attrs(f_out, ndx, iflags, fname, file,
+					    fnamecmp_type, xname, xlen);
 			continue;
 		}
 
 		initial_stats = stats;
 
 		if (!(s = receive_sums(f_in))) {
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR, "receive_sums failed\n");
-			return;
+			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		fd = do_open(fname, O_RDONLY, 0);
 		if (fd == -1) {
 			if (errno == ENOENT) {
 				enum logcode c = am_daemon
 				    && protocol_version < 28 ? FERROR
-							     : FINFO;
+							     : FWARNING;
 				io_error |= IOERR_VANISHED;
 				rprintf(c, "file has vanished: %s\n",
 					full_fname(fname));
 			} else {
 				io_error |= IOERR_GENERAL;
-				rsyserr(FERROR, errno,
+				rsyserr(FERROR_XFER, errno,
 					"send_files failed to open %s",
 					full_fname(fname));
 			}
 			free_sums(s);
+			if (protocol_version >= 30)
+				send_msg_int(MSG_NO_SEND, ndx);
 			continue;
 		}
 
 		/* map the local file */
 		if (do_fstat(fd, &st) != 0) {
 			io_error |= IOERR_GENERAL;
 			rsyserr(FERROR, errno, "fstat failed");
 			free_sums(s);
 			close(fd);
-			return;
+			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		if (st.st_size) {
 			int32 read_size = MAX(s->blength * 3, MAX_MAP_SIZE);
 			mbuf = map_file(fd, st.st_size, read_size, s->blength);
 		} else
 			mbuf = NULL;
 
 		if (verbose > 2) {
-			rprintf(FINFO, "send_files mapped %s of size %.0f\n",
-				fname, (double)st.st_size);
+			rprintf(FINFO, "send_files mapped %s%s%s of size %.0f\n",
+				path,slash,fname, (double)st.st_size);
 		}
 
-		write_ndx_and_attrs(f_out, i, iflags, fnamecmp_type,
-				    xname, xlen);
+		write_ndx_and_attrs(f_out, ndx, iflags, fname, file,
+				    fnamecmp_type, xname, xlen);
 		write_sum_head(f_xfer, s);
 
 		if (verbose > 2)
-			rprintf(FINFO, "calling match_sums %s\n", fname);
+			rprintf(FINFO, "calling match_sums %s%s%s\n", path,slash,fname);
 
 		if (log_before_transfer)
 			log_item(FCLIENT, file, &initial_stats, iflags, NULL);
 		else if (!am_server && verbose && do_progress)
-			rprintf(FCLIENT, "%s\n", fname2);
+			rprintf(FCLIENT, "%s\n", fname);
 
 		set_compression(fname);
 
 		match_sums(f_xfer, s, mbuf, st.st_size);
 		if (do_progress)
 			end_progress(st.st_size);
@@ -357,30 +347,31 @@
 		log_item(log_code, file, &initial_stats, iflags, NULL);
 
 		if (mbuf) {
 			j = unmap_file(mbuf);
 			if (j) {
 				io_error |= IOERR_GENERAL;
-				rsyserr(FERROR, j,
+				rsyserr(FERROR_XFER, j,
 					"read errors mapping %s",
 					full_fname(fname));
 			}
 		}
 		close(fd);
 
 		free_sums(s);
 
 		if (verbose > 2)
-			rprintf(FINFO, "sender finished %s\n", fname);
+			rprintf(FINFO, "sender finished %s%s%s\n", path,slash,fname);
 
 		/* Flag that we actually sent this entry. */
-		file->flags |= FLAG_SENT;
+		file->flags |= FLAG_FILE_SENT;
 	}
-	make_backups = save_make_backups;
+	if (make_backups < 0)
+		make_backups = -make_backups;
 
 	if (verbose > 2)
 		rprintf(FINFO, "send files finished\n");
 
 	match_report();
 
-	write_int(f_out, -1);
+	write_ndx(f_out, NDX_DONE);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/socket.c	2006-11-01 03:21:57.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/socket.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,40 +1,41 @@
 /*
  * Socket functions used in rsync.
  *
  * Copyright (C) 1992-2001 Andrew Tridgell <tridge@samba.org>
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* This file is now converted to use the new-style getaddrinfo()
  * interface, which supports IPv6 but is also supported on recent
  * IPv4-only machines.  On systems that don't have that interface, we
  * emulate it using the KAME implementation. */
 
 #include "rsync.h"
+#include "ifuncs.h"
 #include <netinet/in_systm.h>
 #include <netinet/ip.h>
 #include <netinet/tcp.h>
 
 extern char *bind_address;
 extern int default_af_hint;
+extern int connect_timeout;
 
 #ifdef HAVE_SIGACTION
 static struct sigaction sigact;
 #endif
 
 /**
@@ -92,13 +93,13 @@
 		*cp = '\0';
 	if (strncmp(buffer, "HTTP/", 5) != 0) {
 		rprintf(FERROR, "bad response from proxy -- %s\n",
 			buffer);
 		return -1;
 	}
-	for (cp = &buffer[5]; isdigit(*(uchar*)cp) || *cp == '.'; cp++) {}
+	for (cp = &buffer[5]; isDigit(cp) || *cp == '.'; cp++) {}
 	while (*cp == ' ')
 		cp++;
 	if (*cp != '2') {
 		rprintf(FERROR, "bad response from proxy -- %s\n",
 			buffer);
 		return -1;
@@ -154,12 +155,17 @@
 	 * creation of the socket but not binding, perhaps if the
 	 * machine has no ipv6 address of this name. */
 	freeaddrinfo(bres_all);
 	return -1;
 }
 
+/* connect() timeout handler based on alarm() */
+static RETSIGTYPE contimeout_handler(UNUSED(int val))
+{
+	connect_timeout = -1;
+}
 
 /**
  * Open a socket to a tcp remote host with the specified port .
  *
  * Based on code from Warren.  Proxy support by Stephen Rothwell.
  * getaddrinfo() rewrite contributed by KAME.net.
@@ -258,17 +264,33 @@
 		 && try_bind_local(s, res->ai_family, type,
 				   bind_addr) == -1) {
 			close(s);
 			s = -1;
 			continue;
 		}
-		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
+		if (connect_timeout > 0) {
+			SIGACTION(SIGALRM, contimeout_handler);
+			alarm(connect_timeout);
+		}
+
+		while (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
+			if (connect_timeout < 0)
+				exit_cleanup(RERR_CONTIMEOUT);
+			if (errno == EINTR)
+				continue;
 			close(s);
 			s = -1;
-			continue;
+			break;
 		}
+
+		if (connect_timeout > 0)
+			alarm(0);
+
+		if (s < 0)
+			continue;
+
 		if (proxied
 		 && establish_proxy_connection(s, host, port,
 					       proxy_user, proxy_pass) != 0) {
 			close(s);
 			s = -1;
 			continue;
@@ -298,12 +320,48 @@
  **/
 int open_socket_out_wrapped(char *host, int port, const char *bind_addr,
 			    int af_hint)
 {
 	char *prog = getenv("RSYNC_CONNECT_PROG");
 
+	if (prog && strchr(prog, '%')) {
+		int hlen = strlen(host);
+		int len = strlen(prog) + 1;
+		char *f, *t;
+		for (f = prog; *f; f++) {
+			if (*f != '%')
+				continue;
+			/* Compute more than enough room. */
+			if (f[1] == '%')
+				f++;
+			else
+				len += hlen;
+		}
+		f = prog;
+		if (!(prog = new_array(char, len)))
+			out_of_memory("open_socket_out_wrapped");
+		for (t = prog; *f; f++) {
+			if (*f == '%') {
+				switch (*++f) {
+				case '%':
+					/* Just skips the extra '%'. */
+					break;
+				case 'H':
+					memcpy(t, host, hlen);
+					t += hlen;
+					continue;
+				default:
+					f--; /* pass % through */
+					break;
+				}
+			}
+			*t++ = *f;
+		}
+		*t = '\0';
+	}
+
 	if (verbose >= 2) {
 		rprintf(FINFO, "%sopening tcp connection to %s port %d\n",
 			prog ? "Using RSYNC_CONNECT_PROG instead of " : "",
 			host, port);
 	}
 	if (prog)
@@ -407,13 +465,13 @@
 		freeaddrinfo(all_ai);
 
 	/* Only output the socket()/bind() messages if we were totally
 	 * unsuccessful, or if the daemon is being run with -vv. */
 	for (s = 0; s < ecnt; s++) {
 		if (!i || verbose > 1)
-			rwrite(FLOG, errmsgs[s], strlen(errmsgs[s]));
+			rwrite(FLOG, errmsgs[s], strlen(errmsgs[s]), 0);
 		free(errmsgs[s]);
 	}
 	free(errmsgs);
 
 	if (!i) {
 		rprintf(FERROR,
@@ -664,41 +722,12 @@
 		}
 	}
 
 	free(options);
 }
 
-/**
- * Become a daemon, discarding the controlling terminal
- **/
-void become_daemon(void)
-{
-	int i;
-
-	if (fork()) {
-		_exit(0);
-	}
-
-	/* detach from the terminal */
-#ifdef HAVE_SETSID
-	setsid();
-#elif defined TIOCNOTTY
-	i = open("/dev/tty", O_RDWR);
-	if (i >= 0) {
-		ioctl(i, (int)TIOCNOTTY, (char *)0);
-		close(i);
-	}
-#endif
-	/* make sure that stdin, stdout an stderr don't stuff things
-	 * up (library functions, for example) */
-	for (i = 0; i < 3; i++) {
-		close(i);
-		open("/dev/null", O_RDWR);
-	}
-}
-
 
 /**
  * This is like socketpair but uses tcp. It is used by the Samba
  * regression test code.
  *
  * The function guarantees that nobody else can attach to the socket,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/cull_options /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/cull_options
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/cull_options	2006-09-18 08:13:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/cull_options	2007-09-17 14:02:09.000000000 +0800
@@ -39,13 +39,13 @@
 print <<EOT;
 
 # These options are the only options that rsync might send to the server,
 # and only in the option format that the stock rsync produces.
 
 # To disable a short-named option, add its letter to this string:
-our \$short_disabled = '';
+our \$short_disabled = 's';
 
 our \$short_no_arg = '$short_no_arg'; # DO NOT REMOVE ANY
 our \$short_with_num = '$short_with_num'; # DO NOT REMOVE ANY
 
 # To disable a long-named option, change its value to a -1.  The values mean:
 # 0 = the option has no arg; 1 = the arg doesn't need any checking; 2 = only
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/cvs2includes /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/cvs2includes
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/cvs2includes	2005-05-20 05:42:20.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/cvs2includes	2007-03-21 21:51:54.000000000 +0800
@@ -8,13 +8,13 @@
 #
 # That ensures that all checked-in files/dirs are included in the transfer.
 # (You could alternately put ": .cvsinclude" into an .rsync-filter file and
 # use the -F option, which is easier to type.)
 #
 # The downside is that you need to remember to re-run cvs2includes whenever
-# You add a new file to the project.
+# you add a new file to the project.
 use strict;
 
 open(FIND, 'find . -name CVS -type d |') or die $!;
 while (<FIND>) {
     chomp;
     s#^\./##;
@@ -28,13 +28,13 @@
     while (<ENTRIES>) {
 	push(@includes, $1) if m#/(.+?)/#;
     }
     close ENTRIES;
     if (@includes) {
 	open(FILTER, ">$filter") or die "Unable to write $filter: $!\n";
-	print FILTER '+ /', join("\n+ /", @includes), "\n";
+	print FILTER map "+ /$_\n", @includes;
 	close FILTER;
 	print "Updated $filter\n";
     } elsif (-f $filter) {
 	unlink($filter);
 	print "Removed $filter\n";
     }
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support: extern-squish
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/file-attr-restore /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/file-attr-restore
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/file-attr-restore	2006-09-03 04:05:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/file-attr-restore	2006-12-20 08:50:17.000000000 +0800
@@ -29,21 +29,21 @@
 
 my $detail_line = qr{
     ^ \s* \d+ \s+             # ignore inode
     \d+ \s+                   # ignore size
     ([-bcdlps])               # 1. File type
     ( [-r][-w][-xsS]          # 2. user-permissions
-      [-r][-w][-xsS]          # 3. group-permissions
-      [-r][-w][-xtT] ) \s+    # 4. other-permissions
+      [-r][-w][-xsS]          #    group-permissions
+      [-r][-w][-xtT] ) \s+    #    other-permissions
     \d+ \s+                   # ignore number of links
-    (\S+) \s+                 # 5. owner
-    (\S+) \s+                 # 6. group
+    (\S+) \s+                 # 3. owner
+    (\S+) \s+                 # 4. group
     (?: \d+ \s+ )?            # ignore size (when present)
     \w+ \s+ \d+ \s+           # ignore month and date
     \d+ (?: : \d+ )? \s+      # ignore time or year
-    ([^\r\n]+) $              # 7. name
+    ([^\r\n]+) $              # 5. name
 }x;
 
 while (<>) {
     my($type, $perms, $owner, $group, $name) = /$detail_line/;
     die "Invalid input line $.:\n$_" unless defined $name;
     die "A filename is not properly escaped:\n$_" unless $name =~ /^[^"\\]*(\\(\d\d\d|\D)[^"\\]*)*$/;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support: git-set-file-times
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support: lsh
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support: munge-symlinks
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support: patch-update
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/rrsync /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/rrsync
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/rrsync	2006-09-18 08:16:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/rrsync	2007-09-17 14:02:09.000000000 +0800
@@ -45,15 +45,15 @@
 ### START of options data produced by the cull_options script. ###
 
 # These options are the only options that rsync might send to the server,
 # and only in the option format that the stock rsync produces.
 
 # To disable a short-named option, add its letter to this string:
-our $short_disabled = '';
+our $short_disabled = 's';
 
-our $short_no_arg = 'CDEHIKLORSWbcdgklmnoprtuvxz'; # DO NOT REMOVE ANY
+our $short_no_arg = 'ACDEHIKLORSWXbcdgklmnoprstuvxz'; # DO NOT REMOVE ANY
 our $short_with_num = 'B'; # DO NOT REMOVE ANY
 
 # To disable a long-named option, change its value to a -1.  The values mean:
 # 0 = the option has no arg; 1 = the arg doesn't need any checking; 2 = only
 # check the arg when receiving; and 3 = always check the arg.
 our %long_opt = (
@@ -67,29 +67,32 @@
   'copy-unsafe-links' => 0,
   'daemon' => 0,
   'delay-updates' => 0,
   'delete' => 0,
   'delete-after' => 0,
   'delete-before' => 0,
+  'delete-delay' => 0,
   'delete-during' => 0,
   'delete-excluded' => 0,
   'existing' => 0,
   'files-from' => 3,
   'force' => 0,
   'from0' => 0,
   'fuzzy' => 0,
+  'iconv' => 1,
   'ignore-errors' => 0,
   'ignore-existing' => 0,
   'inplace' => 0,
   'link-dest' => 2,
   'list-only' => 0,
   'log-format' => 1,
   'max-delete' => 1,
   'max-size' => 1,
   'min-size' => 1,
   'modify-window' => 1,
+  'no-i-r' => 0,
   'no-implied-dirs' => 0,
   'no-r' => 0,
   'no-relative' => 0,
   'no-specials' => 0,
   'numeric-ids' => 0,
   'only-write-batch' => 1,
@@ -98,12 +101,13 @@
   'remove-sent-files' => $ro ? -1 : 0,
   'remove-source-files' => $ro ? -1 : 0,
   'safe-links' => 0,
   'sender' => 0,
   'server' => 0,
   'size-only' => 0,
+  'skip-compress' => 1,
   'specials' => 0,
   'suffix' => 1,
   'super' => 0,
   'temp-dir' => 2,
   'timeout' => 1,
 );
@@ -132,13 +136,13 @@
     $check_type = 0;
   } elsif ($in_options) {
     push(@opts, $_);
     if ($_ eq '.') {
       $in_options = 0;
     } else {
-      next if /^-$short_no_arg+$/o || /^-$short_with_num\d+$/o;
+      next if /^-$short_no_arg+(e\d+\.\d+)?$/o || /^-$short_with_num\d+$/o;
 
       my($opt,$arg) = /^--([^=]+)(?:=(.*))?$/;
       my $disabled;
       if (defined $opt) {
 	my $ct = $long_opt{$opt};
 	last unless defined $ct;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/savetransfer.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/savetransfer.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/support/savetransfer.c	2005-12-20 00:57:55.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/support/savetransfer.c	2006-12-18 15:24:24.000000000 +0800
@@ -24,12 +24,16 @@
  */
 
 #include "../rsync.h"
 
 #define TIMEOUT_SECONDS 30
 
+#ifdef HAVE_SIGACTION
+static struct sigaction sigact;
+#endif
+
 void run_program(char **command);
 
 char buf[4096];
 int save_data_from_program = 0;
 
 int
@@ -61,13 +65,13 @@
     if ((fd_file = open(*argv, O_WRONLY|O_TRUNC|O_CREAT|O_BINARY, 0644)) < 0) {
 	fprintf(stderr, "Unable to write to `%s': %s\n", *argv, strerror(errno));
 	exit(1);
     }
     set_blocking(fd_file);
 
-    signal(SIGPIPE, SIG_IGN);
+    SIGACTION(SIGPIPE, SIG_IGN);
 
     run_program(argv + 1);
 
 #if defined HAVE_SETMODE && O_BINARY
     setmode(STDIN_FILENO, O_BINARY);
     setmode(STDOUT_FILENO, O_BINARY);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/syscall.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/syscall.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,39 +1,43 @@
 /*
  * Syscall wrappers to ensure that nothing gets done in dry_run mode
  * and to handle system peculiarities.
  *
  * Copyright (C) 1998 Andrew Tridgell
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 #if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H
 #include <sys/un.h>
 #endif
+#ifdef HAVE_SYS_ATTR_H
+#include <sys/attr.h>
+#endif
 
 extern int dry_run;
+extern int am_root;
 extern int read_only;
 extern int list_only;
 extern int preserve_perms;
+extern int preserve_executability;
 
 #define RETURN_ERROR_IF(x,e) \
 	do { \
 		if (x) { \
 			errno = (e); \
 			return -1; \
@@ -72,32 +76,42 @@
 #ifndef HAVE_LCHOWN
 #define lchown chown
 #endif
 	return lchown(path, owner, group);
 }
 
-int do_mknod(char *pathname, mode_t mode, dev_t dev)
+int do_mknod(const char *pathname, mode_t mode, dev_t dev)
 {
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
+
+	/* For --fake-super, we create a normal file with mode 0600. */
+	if (am_root < 0) {
+		int fd = open(pathname, O_WRONLY|O_CREAT|O_TRUNC, S_IWUSR|S_IRUSR);
+		if (fd < 0 || close(fd) < 0)
+			return -1;
+		return 0;
+	}
+
 #if !defined MKNOD_CREATES_FIFOS && defined HAVE_MKFIFO
 	if (S_ISFIFO(mode))
 		return mkfifo(pathname, mode);
 #endif
 #if !defined MKNOD_CREATES_SOCKETS && defined HAVE_SYS_UN_H
 	if (S_ISSOCK(mode)) {
 		int sock;
 		struct sockaddr_un saddr;
-		unsigned int len;
-
-		saddr.sun_family = AF_UNIX;
-		len = strlcpy(saddr.sun_path, pathname, sizeof saddr.sun_path);
+#ifdef HAVE_SOCKADDR_UN_LEN
+		unsigned int len =
+#endif
+		    strlcpy(saddr.sun_path, pathname, sizeof saddr.sun_path);
 #ifdef HAVE_SOCKADDR_UN_LEN
 		saddr.sun_len = len >= sizeof saddr.sun_path
 			      ? sizeof saddr.sun_path : len + 1;
 #endif
+		saddr.sun_family = AF_UNIX;
 
 		if ((sock = socket(PF_UNIX, SOCK_STREAM, 0)) < 0
 		    || (unlink(pathname) < 0 && errno != ENOENT)
 		    || (bind(sock, (struct sockaddr*)&saddr, sizeof saddr)) < 0)
 			return -1;
 		close(sock);
@@ -138,18 +152,26 @@
 	int code;
 	if (dry_run) return 0;
 	RETURN_ERROR_IF_RO_OR_LO;
 	if (S_ISLNK(mode)) {
 #ifdef HAVE_LCHMOD
 		code = lchmod(path, mode & CHMOD_BITS);
+#elif defined HAVE_SETATTRLIST
+		struct attrlist attrList;
+		uint32_t m = mode & CHMOD_BITS; /* manpage is wrong: not mode_t! */
+
+		memset(&attrList, 0, sizeof attrList);
+		attrList.bitmapcount = ATTR_BIT_MAP_COUNT;
+		attrList.commonattr = ATTR_CMN_ACCESSMASK;
+		code = setattrlist(path, &attrList, &m, sizeof m, FSOPT_NOFOLLOW);
 #else
 		code = 1;
 #endif
 	} else
 		code = chmod(path, mode & CHMOD_BITS);
-	if (code != 0 && preserve_perms)
+	if (code != 0 && (preserve_perms || preserve_executability))
 	    return code;
 	return 0;
 }
 #endif
 
 int do_rename(const char *fname1, const char *fname2)
@@ -187,12 +209,13 @@
 
 /* like mkstemp but forces permissions */
 int do_mkstemp(char *template, mode_t perms)
 {
 	RETURN_ERROR_IF(dry_run, 0);
 	RETURN_ERROR_IF(read_only, EROFS);
+	perms |= S_IWUSR;
 
 #if defined HAVE_SECURE_MKSTEMP && defined HAVE_FCHMOD && (!defined HAVE_OPEN64 || defined HAVE_MKSTEMP64)
 	{
 		int fd = mkstemp(template);
 		if (fd == -1)
 			return -1;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite: acls.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/backup.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/backup.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/backup.test	2005-06-11 04:04:42.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/backup.test	2007-09-04 04:43:58.000000000 +0800
@@ -8,59 +8,59 @@
 # Test that the --backup option works right.
 
 . "$suitedir/rsync.fns"
 
 bakdir="$tmpdir/bak"
 
-mkdir "$fromdir" "$bakdir"
-name1="$fromdir/name1"
-name2="$fromdir/name2"
+makepath "$fromdir/deep" "$bakdir"
+name1="$fromdir/deep/name1"
+name2="$fromdir/deep/name2"
 
 outfile="$scratchdir/rsync.out"
 
 cat "$srcdir"/[gr]*.[ch] > "$name1"
 cat "$srcdir"/[et]*.[ch] > "$name2"
 
-checkit "$RSYNC -avv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -avv '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
-checkit "$RSYNC -avv \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
+checkit "$RSYNC -avv '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
 cat "$srcdir"/[fgpr]*.[ch] > "$name1"
 cat "$srcdir"/[etw]*.[ch] > "$name2"
 
 $RSYNC -avv --no-whole-file --backup "$fromdir/" "$todir/" \
     | tee "$outfile"
-for fn in name1 name2; do
+for fn in deep/name1 deep/name2; do
     grep "backed up $fn to $fn~" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
-    diff $diffopt "$fromdir/$fn" "$todir" || test_fail "copy of $fn failed"
+    diff $diffopt "$fromdir/$fn" "$todir/$fn" || test_fail "copy of $fn failed"
     diff $diffopt "$chkdir/$fn" "$todir/$fn~" || test_fail "backup of $fn to $fn~ failed"
     mv "$todir/$fn~" "$todir/$fn"
 done
 
 echo deleted-file >"$todir/dname"
 cp -p "$todir/dname" "$chkdir"
 
-checkit "$RSYNC -avv --no-whole-file --delete-after \
-    --backup --backup-dir=\"$bakdir\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
+checkit "$RSYNC -avv --no-whole-file --delete-delay \
+    --backup --backup-dir='$bakdir' '$fromdir/' '$todir/'" "$fromdir" "$todir" \
     | tee "$outfile"
 
-for fn in name1 name2; do
+for fn in deep/name1 deep/name2; do
     grep "backed up $fn to .*/$fn$" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
 done
 diff -r $diffopt "$chkdir" "$bakdir" || test_fail "backup dir contents are bogus"
 rm "$bakdir/dname"
 
-checkit "$RSYNC -avv --del \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
+checkit "$RSYNC -avv --del '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
 cat "$srcdir"/[efgr]*.[ch] > "$name1"
 cat "$srcdir"/[ew]*.[ch] > "$name2"
 
-checkit "$RSYNC -avv --inplace --no-whole-file --backup --backup-dir=\"$bakdir\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
+checkit "$RSYNC -avv --inplace --no-whole-file --backup --backup-dir='$bakdir' '$fromdir/' '$todir/'" "$fromdir" "$todir" \
     | tee "$outfile"
 
-for fn in name1 name2; do
+for fn in deep/name1 deep/name2; do
     grep "backed up $fn to .*/$fn$" "$outfile" >/dev/null || test_fail "no backup message output for $fn"
 done
 diff -r $diffopt "$chkdir" "$bakdir" || test_fail "backup dir contents are bogus"
 
-checkit "$RSYNC -avv --inplace --no-whole-file \"$fromdir/\" \"$bakdir/\"" "$fromdir" "$bakdir"
+checkit "$RSYNC -avv --inplace --no-whole-file '$fromdir/' '$bakdir/'" "$fromdir" "$bakdir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/batch-mode.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/batch-mode.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/batch-mode.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/batch-mode.test	2008-02-10 13:30:49.000000000 +0800
@@ -13,12 +13,18 @@
 
 cd "$tmpdir"
 
 # Build chkdir for the daemon tests using a normal rsync and an --exclude.
 $RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
 
+$RSYNC -av --only-write-batch=BATCH --exclude=foobar.baz "$fromdir/" "$todir/missing/"
+test -d "$todir/missing" && test_fail "--only-write-batch should not have created destination dir"
+
+runtest "--read-batch (only)" 'checkit "$RSYNC -av --read-batch=BATCH \"$todir\"" "$chkdir" "$todir"'
+
+rm -rf "$todir" BATCH*
 runtest "local --write-batch" 'checkit "$RSYNC -av --write-batch=BATCH \"$fromdir/\" \"$todir\"" "$fromdir" "$todir"'
 
 rm -rf "$todir"
 runtest "--read-batch" 'checkit "$RSYNC -av --read-batch=BATCH \"$todir\"" "$fromdir" "$todir"'
 
 build_rsyncd_conf
@@ -34,10 +40,10 @@
 
 rm -rf "$todir"
 runtest "BATCH.sh use of --read-batch" 'checkit "./BATCH.sh" "$chkdir" "$todir"'
 
 rm -rf "$todir"
 mkdir "$todir" || test_fail "failed to restore empty destination directory"
-runtest "daemon recv --write-batch" 'checkit "$RSYNC -av --write-batch=BATCH \"$fromdir/\" rsync://localhost/test-to" "$chkdir" "$todir"'
+runtest "daemon recv --write-batch" 'checkit "\"$ignore23\" $RSYNC -av --write-batch=BATCH \"$fromdir/\" rsync://localhost/test-to" "$chkdir" "$todir"'
 
 # The script would have aborted on error, so getting here means we pass.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/chgrp.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/chgrp.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/chgrp.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/chgrp.test	2007-09-04 04:43:58.000000000 +0800
@@ -21,10 +21,10 @@
     name="$fromdir/foo-$g"
     date > "$name"
     chgrp "$g" "$name" || fail "Can't chgrp"
 done
 sleep 2
 
-checkit "$RSYNC -rtgpvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -rtgpvvv '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/chmod-option.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/chmod-option.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/chmod-option.test	2006-10-13 12:59:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/chmod-option.test	2007-09-04 04:43:58.000000000 +0800
@@ -26,30 +26,29 @@
 
 chmod 4700 "$name1" || test_skipped "Can't chmod"
 chmod 700 "$dir1"
 chmod 770 "$dir2"
 
 # Copy the files we've created over to another directory
-checkit "$RSYNC -avv \"$fromdir/\" \"$checkdir/\"" "$fromdir" "$checkdir"
+checkit "$RSYNC -avv '$fromdir/' '$checkdir/'" "$fromdir" "$checkdir"
 
 # And then manually make the changes which should occur 
 umask 002
 chmod ug-s,a+rX "$checkdir"/*
 chmod +w "$checkdir" "$checkdir"/dir*
 
-checkit "$RSYNC -avv --chmod ug-s,a+rX,D+w \"$fromdir/\" \"$todir/\"" "$checkdir" "$todir"
+checkit "$RSYNC -avv --chmod ug-s,a+rX,D+w '$fromdir/' '$todir/'" "$checkdir" "$todir"
 
 rm -r "$fromdir" "$checkdir" "$todir"
-makepath "$todir"
-makepath "$fromdir/foo"
+makepath "$todir" "$fromdir/foo"
 touch "$fromdir/bar"
 
-checkit "$RSYNC -avv \"$fromdir/\" \"$checkdir/\"" "$fromdir" "$checkdir"
+checkit "$RSYNC -avv '$fromdir/' '$checkdir/'" "$fromdir" "$checkdir"
 chmod o+x "$fromdir"/bar
 
-checkit "$RSYNC -avv --chmod=Fo-x \"$fromdir/\" \"$todir/\"" "$checkdir" "$todir"
+checkit "$RSYNC -avv --chmod=Fo-x '$fromdir/' '$todir/'" "$checkdir" "$todir"
 
 # Tickle a bug in rsync 2.6.8: if you push a new directory with --perms off to
 # a daemon with an incoming chmod, the daemon pretends the directory is a file
 # for the purposes of the second application of the incoming chmod.
 
 build_rsyncd_conf
@@ -63,10 +62,10 @@
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 rm -r "$todir"
 makepath "$todir"
 
-checkit "$RSYNC -rtvv \"$fromdir/\" localhost::test-incoming-chmod/" "$checkdir" "$todir"
+checkit "$RSYNC -avv --no-perms '$fromdir/' localhost::test-incoming-chmod/" "$checkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/chown.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/chown.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/chown.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/chown.test	2007-04-29 07:47:16.000000000 +0800
@@ -10,33 +10,58 @@
 
 # We don't know what users will be present on this system, so we just
 # use random numeric uids and gids.
 
 . "$suitedir/rsync.fns"
 
-case `id -u` in
-'') ;; # If "id" failed, try to continue...
-0)  ;;
-*)  if [ -f /usr/bin/fakeroot ]; then
-	echo "Let's try re-running the script under fakeroot..."
-	exec /usr/bin/fakeroot /bin/sh "$0"
-    fi
+case $0 in
+*fake*)
+    $RSYNC --version | grep ", xattrs" >/dev/null || test_skipped "Rsync needs xattrs for fake device tests"
+    RSYNC="$RSYNC --fake-super"
+    TLS_ARGS=--fake-super
+    case "`xattr 2>&1`" in
+    *--list:*)
+	chown() {
+	    own=$1
+	    shift
+	    xattr -s 'rsync.%stat' "100644 0,0 $own" "${@}"
+	}
+	;;
+    *)
+	chown() {
+	    own=$1
+	    shift
+	    setfattr -n 'user.rsync.%stat' -v "100644 0,0 $own" "${@}"
+	}
+	;;
+    esac
+    ;;
+*)
+    RSYNC="$RSYNC --super"
+    case `id -u` in
+    '') ;; # If "id" failed, try to continue...
+    0)  ;;
+    *)  if [ -f /usr/bin/fakeroot ]; then
+	    echo "Let's try re-running the script under fakeroot..."
+	    exec /usr/bin/fakeroot /bin/sh "$0"
+	fi
+	;;
+    esac
     ;;
 esac
 
 # Build some hardlinks
 
 mkdir "$fromdir"
 name1="$fromdir/name1"
 name2="$fromdir/name2"
 echo "This is the file" > "$name1"
 echo "This is the other file" > "$name2"
 
-chown 5000 "$name1" || test_skipped "Can't chown (probably need root)"
-chown 5001 "$name2" || test_skipped "Can't chown (probably need root)"
-chgrp 5002 "$name1" || test_skipped "Can't chgrp (probably need root)"
-chgrp 5003 "$name2" || test_skipped "Can't chgrp (probably need root)"
+chown 5000:5002 "$name1" || test_skipped "Can't chown (probably need root)"
+chown 5001:5003 "$name2" || test_skipped "Can't chown (probably need root)"
 
-checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+cd "$fromdir/.."
+checkit "$RSYNC -aHvv from/ to/" "$fromdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/compare-dest.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/compare-dest.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/compare-dest.test	2006-02-05 03:29:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/compare-dest.test	2007-09-04 04:43:58.000000000 +0800
@@ -24,14 +24,14 @@
 touch "$fromdir/dir/text"
 
 $RSYNC -av --exclude=/text --exclude=etc-ltr-list "$fromdir/" "$chkdir/"
 
 # Let's do it!
 checkit "$RSYNC -avv --no-whole-file \
-    --compare-dest=\"$alt1dir\" --compare-dest=\"$alt2dir\" \
-    \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+    --compare-dest='$alt1dir' --compare-dest='$alt2dir' \
+    '$fromdir/' '$todir/'" "$chkdir" "$todir"
 checkit "$RSYNC -avv --no-whole-file \
-    --copy-dest=\"$alt1dir\" --copy-dest=\"$alt2dir\" \
-    \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+    --copy-dest='$alt1dir' --copy-dest='$alt2dir' \
+    '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/daemon-gzip-download.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/daemon-gzip-download.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/daemon-gzip-download.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/daemon-gzip-download.test	2007-09-04 04:43:58.000000000 +0800
@@ -28,10 +28,10 @@
 
 hands_setup
 
 # Build chkdir with a normal rsync and an --exclude.
 $RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
 
-checkit "$RSYNC -avvvvz localhost::test-from/ \"$todir/\"" "$chkdir" "$todir"
+checkit "$RSYNC -avvvvz localhost::test-from/ '$todir/'" "$chkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/daemon-gzip-upload.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/daemon-gzip-upload.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/daemon-gzip-upload.test	2006-10-12 11:01:18.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/daemon-gzip-upload.test	2008-02-10 13:30:49.000000000 +0800
@@ -22,10 +22,10 @@
 
 hands_setup
 
 # Build chkdir with a normal rsync and an --exclude.
 $RSYNC -av --exclude=foobar.baz "$fromdir/" "$chkdir/"
 
-checkit "$RSYNC -avvvvz \"$fromdir/\" localhost::test-to/" "$chkdir" "$todir"
+checkit "'$ignore23' $RSYNC -avvvvz '$fromdir/' localhost::test-to/" "$chkdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite: default-acls.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/delete.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/delete.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/delete.test	2006-09-01 08:43:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/delete.test	2007-09-04 04:43:58.000000000 +0800
@@ -8,21 +8,37 @@
 # Test rsync handling of various delete directives.  
 
 . "$suitedir/rsync.fns"
 
 hands_setup
 
-makepath "$chkdir"
+makepath "$chkdir" "$todir/extradir" "$todir/emptydir/subdir"
+
+echo extra >"$todir"/remove1
+echo extra >"$todir"/remove2
+echo extra >"$todir"/extradir/remove3
+echo extra >"$todir"/emptydir/subdir/remove4
 
 # Create two chk dirs, one with a copy of the source files, and one with
-# what we expect to be left behind by the copy using --remove-sent-files.
-$RSYNC -av "$fromdir/" "$chkdir/copy/"
+# what we expect to be left behind by the copy using --remove-source-files.
+# Also, make sure that --dry-run --del doesn't output anything extraneous.
+$RSYNC -av "$fromdir/" "$chkdir/copy/" >"$tmpdir/copy.out" 2>&1
+cat "$tmpdir/copy.out"
+egrep -v '^(created directory|sent|total size) ' "$tmpdir/copy.out" >"$tmpdir/copy.new"
+mv "$tmpdir/copy.new" "$tmpdir/copy.out"
+
+$RSYNC -avn --del "$fromdir/" "$chkdir/copy2/" >"$tmpdir/copy2.out" 2>&1 || true
+cat "$tmpdir/copy2.out"
+egrep -v '^(created directory|sent|total size) ' "$tmpdir/copy2.out" >"$tmpdir/copy2.new"
+mv "$tmpdir/copy2.new" "$tmpdir/copy2.out"
+
+diff $diffopt "$tmpdir/copy.out" "$tmpdir/copy2.out"
+
 $RSYNC -av -f 'exclude,! */' "$fromdir/" "$chkdir/empty/"
 
-checkit "$RSYNC -avv --remove-sent-files \
-    \"$fromdir/\" \"$todir/\"" "$chkdir/copy" "$todir"
+checkit "$RSYNC -avv --del --remove-source-files '$fromdir/' '$todir/'" "$chkdir/copy" "$todir"
 
 diff -r "$chkdir/empty" "$fromdir"
 
 # Make sure that "P" but not "-" per-dir merge-file filters take effect with
 # --delete-excluded.
 cat >"$todir/filters" <<EOF
@@ -30,12 +46,12 @@
 - bar
 EOF
 touch "$todir/foo" "$todir/bar" "$todir/baz"
 
 $RSYNC -r --exclude=baz --filter=': filters' --delete-excluded "$fromdir/" "$todir/"
 
-test -f "$todir/foo" || test_fail "rsync deleted $todir/foo"
-test -f "$todir/bar" && test_fail "rsync did not delete $todir/bar"
-test -f "$todir/baz" && test_fail "rsync did not delete $todir/baz"
+test -f "$todir/foo" || test_fail "rsync should NOT have deleted $todir/foo"
+test -f "$todir/bar" && test_fail "rsync SHOULD have deleted $todir/bar"
+test -f "$todir/baz" && test_fail "rsync SHOULD have deleted $todir/baz"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/devices.test	2006-02-09 09:17:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/devices.test	2008-02-28 09:57:29.000000000 +0800
@@ -11,83 +11,139 @@
 
 chkfile="$scratchdir/rsync.chk"
 outfile="$scratchdir/rsync.out"
 
 # Build some hardlinks
 
-case `id -u` in
-'') ;; # If "id" failed, try to continue...
-0)  ;;
-*)  if [ -f /usr/bin/fakeroot ]; then
-	echo "Let's try re-running the script under fakeroot..."
-	exec /usr/bin/fakeroot /bin/sh $RUNSHFLAGS "$0"
-    fi
-    test_skipped "Rsync won't copy devices unless we're root"
+case $0 in
+*fake*)
+    $RSYNC --version | grep ", xattrs" >/dev/null || test_skipped "Rsync needs xattrs for fake device tests"
+    RSYNC="$RSYNC --fake-super"
+    TLS_ARGS=--fake-super
+    case "`xattr 2>&1`" in
+    *--list:*)
+	mknod() {
+	    fn="$1"
+	    case "$2" in
+	    p) mode=10644 ;;
+	    c) mode=20644 ;;
+	    b) mode=60644 ;;
+	    esac
+	    maj="${3:-0}"
+	    min="${4:-0}"
+	    touch "$fn"
+	    xattr -s 'rsync.%stat' "$mode $maj,$min 0:0" "$fn"
+	}
+	;;
+    *)
+	mknod() {
+	    fn="$1"
+	    case "$2" in
+	    p) mode=10644 ;;
+	    c) mode=20644 ;;
+	    b) mode=60644 ;;
+	    esac
+	    maj="${3:-0}"
+	    min="${4:-0}"
+	    touch "$fn"
+	    setfattr -n 'user.rsync.%stat' -v "$mode $maj,$min 0:0" "$fn"
+	}
+	;;
+    esac
+    ;;
+*)
+    case `id -u` in
+    '') ;; # If "id" failed, try to continue...
+    0)  ;;
+    *)  if [ -f /usr/bin/fakeroot ]; then
+	    echo "Let's try re-running the script under fakeroot..."
+	    exec /usr/bin/fakeroot /bin/sh $RUNSHFLAGS "$0"
+	fi
+	test_skipped "Rsync needs root/fakeroot for device tests"
+	;;
+    esac
     ;;
 esac
 
 # TODO: Need to test whether hardlinks are possible on this OS/filesystem
 
 mkdir "$fromdir"
 mkdir "$todir"
-mknod "$fromdir/char" c 41 67  || test_skipped "Can't create char device node unless root"
-mknod "$fromdir/char2" c 42 68  || test_skipped "Can't create char device node unless root"
-mknod "$fromdir/char3" c 42 69  || test_skipped "Can't create char device node unless root"
-mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node unless root"
-mknod "$fromdir/block2" b 42 73 || test_skipped "Can't create block device node unless root"
-mknod "$fromdir/block3" b 105 73 || test_skipped "Can't create block device node unless root"
+mknod "$fromdir/char" c 41 67  || test_skipped "Can't create char device node"
+mknod "$fromdir/char2" c 42 68  || test_skipped "Can't create char device node"
+mknod "$fromdir/char3" c 42 69  || test_skipped "Can't create char device node"
+mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node"
+mknod "$fromdir/block2" b 42 73 || test_skipped "Can't create block device node"
+mknod "$fromdir/block3" b 105 73 || test_skipped "Can't create block device node"
 ln "$fromdir/block3" "$fromdir/block2.5" || echo "Skipping hard-linked device test..."
-mkfifo "$fromdir/fifo" || test_skipped "Can't run mkfifo"
+mkfifo "$fromdir/fifo" || mknod "$fromdir/fifo" p || test_skipped "Can't run mkfifo"
 touch -r "$fromdir/block" "$fromdir/block2"
 
 $RSYNC -ai "$fromdir/block" "$todir/block2" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD+++++++ block
+cD$all_plus block
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
 
 $RSYNC -ai "$fromdir/block2" "$todir/block" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD+++++++ block2
+cD$all_plus block2
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 2 failed"
 
 sleep 1
 
 $RSYNC -Di "$fromdir/block3" "$todir/block" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cD..T.... block3
+cD..T.$dots block3
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
 
 $RSYNC -aiHvv "$fromdir/" "$todir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-.d..t.... ./
-cD..t.... block
-cD....... block2
-cD+++++++ block3
-hD+++++++ block2.5 => block3
-cD+++++++ char
-cD+++++++ char2
-cD+++++++ char3
-cS+++++++ fifo
+.d..t.$dots ./
+cD..t.$dots block
+cD$allspace block2
+cD$all_plus block3
+hD$all_plus block2.5 => block3
+cD$all_plus char
+cD$all_plus char2
+cD$all_plus char3
+cS$all_plus fifo
 EOT
-if test ! -b "$fromdir/block2.5"; then
-    sed -e '/block2\.5/d' \
-	<"$chkfile" >"$chkfile.new"
+if test ! -r "$fromdir/block2.5"; then
+    sed -e '/block2\.5/d' <"$chkfile" >"$chkfile.new"
     mv "$chkfile.new" "$chkfile"
 fi
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 4 failed"
 
 echo "check how the directory listings compare with diff:"
 echo ""
 ( cd "$fromdir" && rsync_ls_lR . ) > "$tmpdir/ls-from"
 ( cd "$todir" && rsync_ls_lR . ) > "$tmpdir/ls-to"
 diff $diffopt "$tmpdir/ls-from" "$tmpdir/ls-to"
 
+if test -b "$fromdir/block2.5"; then
+    set -x
+    $RSYNC -aii --link-dest="$todir" "$fromdir/" "$chkdir/" \
+	| tee "$outfile"
+    cat <<EOT >"$chkfile"
+cd$allspace ./
+hD$allspace block
+hD$allspace block2
+hD$allspace block2.5
+hD$allspace block3
+hD$allspace char
+hD$allspace char2
+hD$allspace char3
+hS$allspace fifo
+EOT
+    diff $diffopt "$chkfile" "$outfile" || test_fail "test 4 failed"
+fi
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/duplicates.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/duplicates.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/duplicates.test	2006-02-05 03:29:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/duplicates.test	2007-09-04 04:43:58.000000000 +0800
@@ -28,13 +28,13 @@
 name2="$fromdir/name2"
 echo "This is the file" > "$name1"
 ln -s "$name1" "$name2" || fail "can't create symlink"
 
 outfile="$scratchdir/rsync.out"
 
-checkit "$RSYNC -avv \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir" \
+checkit "$RSYNC -avv '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$fromdir/' '$todir/'" "$fromdir" "$todir" \
     | tee "$outfile"
 
 # Make sure each file was only copied once...
 if [ `grep -c '^name1$' "$outfile"` != 1 ]
 then
     test_fail "name1 was not copied exactly once"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/exclude.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/exclude.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/exclude.test	2006-03-17 04:02:36.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/exclude.test	2007-09-04 04:43:58.000000000 +0800
@@ -2,13 +2,13 @@
 
 # Copyright (C) 2003, 2004, 2005 by Wayne Davison <wayned@samba.org>
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
-# Test rsync handling of exclude/include directives.  
+# Test rsync handling of exclude/include directives.
 
 # Test some of the more obscure wildcard handling of exclude/include
 # processing.
 
 . "$suitedir/rsync.fns"
 
@@ -73,13 +73,12 @@
 cat >"$fromdir/mid/.filt" <<EOF
 :C
 EOF
 echo cvsin >"$fromdir/mid/for/one-in-one-out"
 echo expunged >"$fromdir/mid/for/foo/extra"
 echo retained >"$fromdir/mid/for/foo/keep"
-ln -s too "$fromdir/bar/down/to/foo/sym"
 
 # Setup our test exclude/include files.
 
 excl="$scratchdir/exclude-from"
 cat >"$excl" <<EOF
 !
@@ -103,18 +102,23 @@
 EOF
 
 cat >"$scratchdir/.cvsignore" <<EOF
 home-cvs-exclude
 EOF
 
-# Create the chk dir with what we expect to be excluded
+# Start with a check of --prune-empty-dirs:
+$RSYNC -av -f -_foo/too/ -f -_foo/down/ -f -_foo/and/ -f -_new/ "$fromdir/" "$chkdir/"
+checkit "$RSYNC -av --prune-empty-dirs '$fromdir/' '$todir/'" "$chkdir" "$todir"
+rm -rf "$todir"
 
-checkit "$RSYNC -avv \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
+# Add a directory symlink.
+ln -s too "$fromdir/bar/down/to/foo/sym"
 
+# Create chkdir with what we expect to be excluded.
+checkit "$RSYNC -avv '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
 sleep 1 # Ensures that the rm commands will tweak the directory times.
-
 rm -r "$chkdir"/foo/down
 rm -r "$chkdir"/mid/for/foo/and
 rm -r "$chkdir"/new/keep/this
 rm -r "$chkdir"/new/lose
 rm "$chkdir"/foo/file[235-9]
 rm "$chkdir"/bar/down/to/foo/to "$chkdir"/bar/down/to/foo/file[235-9]
@@ -123,14 +127,14 @@
 # Un-tweak the directory times in our first (weak) exclude test (though
 # it's a good test of the --existing option).
 $RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
 
 # Now, test if rsync excludes the same files.
 
-checkit "$RSYNC -avv --exclude-from=\"$excl\" \
-    --delete-during \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+checkit "$RSYNC -avv --exclude-from='$excl' \
+    --delete-during '$fromdir/' '$todir/'" "$chkdir" "$todir"
 
 # Modify the chk dir by removing cvs-ignored files and then tweaking the dir times.
 
 rm "$chkdir"/foo/*.old
 rm "$chkdir"/bar/down/to/foo/*.bak
 rm "$chkdir"/bar/down/to/foo/*.junk
@@ -139,14 +143,14 @@
 
 $RSYNC -av --existing --filter='exclude,! */' "$fromdir/" "$chkdir/"
 
 # Now, test if rsync excludes the same files, this time with --cvs-exclude
 # and --delete-excluded.
 
-checkit "$RSYNC -avvC --filter=\"merge $excl\" --delete-excluded \
-    --delete-during \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+checkit "$RSYNC -avvC --filter='merge $excl' --delete-excluded \
+    --delete-during '$fromdir/' '$todir/'" "$chkdir" "$todir"
 
 # Modify the chk dir for our merge-exclude test and then tweak the dir times.
 
 rm "$chkdir"/foo/file1
 rm "$chkdir"/bar/down/to/bar/baz/*.deep
 cp -p "$fromdir"/bar/down/to/foo/*.junk "$chkdir"/bar/down/to/foo
@@ -159,15 +163,15 @@
 
 $RSYNC -av --existing --filter='-! */' "$fromdir/" "$chkdir/"
 
 # Now, test if rsync excludes the same files, this time with a merge-exclude
 # file.
 
-checkit "sed '/!/d' \"$excl\" |
+checkit "sed '/!/d' '$excl' |
     $RSYNC -avv -f dir-merge_.filt -f merge_- \
-    --delete-during \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+    --delete-during '$fromdir/' '$todir/'" "$chkdir" "$todir"
 
 # Remove the files that will be deleted.
 
 rm "$chkdir"/.filt
 rm "$chkdir"/bar/.filt
 rm "$chkdir"/bar/down/to/.filt2
@@ -177,15 +181,15 @@
 
 $RSYNC -av --protocol=28 --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
 
 # Now, try the prior command with --delete-before and some side-specific
 # rules.
 
-checkit "sed '/!/d' \"$excl\" |
+checkit "sed '/!/d' '$excl' |
     $RSYNC -avv -f :s_.filt -f .s_- -f P_nodel.deep \
-    --delete-before \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+    --delete-before '$fromdir/' '$todir/'" "$chkdir" "$todir"
 
 # Next, we'll test some rule-restricted filter files.
 
 cat >"$fromdir/bar/down/.excl" <<EOF
 file3
 EOF
@@ -198,18 +202,18 @@
 rm "$chkdir/bar/down/to/foo/file3"
 rm "$chkdir/bar/down/to/foo/+ file3"
 $RSYNC -av --existing --filter='-! */' "$fromdir/" "$chkdir/"
 $RSYNC -av --delete-excluded --exclude='*' "$fromdir/" "$todir/"
 
 checkit "$RSYNC -avv -f dir-merge,-_.excl \
-    \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+    '$fromdir/' '$todir/'" "$chkdir" "$todir"
 
 relative_opts='--relative --chmod=Du+w --copy-unsafe-links'
 $RSYNC -av $relative_opts "$fromdir/foo" "$chkdir/"
 rm -rf "$chkdir$fromdir/foo/down"
 $RSYNC -av $relative_opts --existing --filter='-! */' "$fromdir/foo" "$chkdir/"
 
-checkit "$RSYNC -avv $relative_opts --exclude=\"$fromdir/foo/down\" \
-    \"$fromdir/foo\" \"$todir\"" "$chkdir$fromdir/foo" "$todir$fromdir/foo"
+checkit "$RSYNC -avv $relative_opts --exclude='$fromdir/foo/down' \
+    '$fromdir/foo' '$todir'" "$chkdir$fromdir/foo" "$todir$fromdir/foo"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/fuzzy.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/fuzzy.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/fuzzy.test	2006-02-05 03:29:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/fuzzy.test	2007-09-04 04:43:58.000000000 +0800
@@ -11,13 +11,14 @@
 
 mkdir "$fromdir"
 mkdir "$todir"
 
 cp -p "$srcdir"/rsync.c "$fromdir"/rsync.c
 cp -p "$fromdir"/rsync.c "$todir"/rsync2.c
+sleep 1
 
 # Let's do it!
-checkit "$RSYNC -avvi --no-whole-file --fuzzy --delete-after \
-    \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -avvi --no-whole-file --fuzzy --delete-delay \
+    '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/hands.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/hands.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/hands.test	2005-04-24 02:17:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/hands.test	2007-03-19 04:40:01.000000000 +0800
@@ -22,8 +22,15 @@
 echo "extra line" >> "$todir/text"
 runtest "extra data" 'checkit "$RSYNC -avH --no-whole-file \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
 cp "$fromdir/text" "$todir/ThisShouldGo"
 runtest " --delete" 'checkit "$RSYNC --delete -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"'
 
+cd "$tmpdir"
+rm -rf to from/*dir
+
+# Do the real copy, touch up the parent-dir's time, and then check the copy.
+$RSYNC -av from/* to/
+checkit "$RSYNC -av --exclude='*' from/ to/" "$fromdir" "$todir"
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/hardlinks.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/hardlinks.test	2007-09-04 14:57:57.000000000 +0800
@@ -2,19 +2,20 @@
 
 # Copyright (C) 2002 by Martin Pool <mbp@samba.org>
 
 # This program is distributable under the terms of the GNU GPL (see
 # COPYING).
 
-# Test rsync handling of hardlinks.  By default (in 2.5.1) rsync does
-# not detect symlinks and they get split into different files.  If you
-# specify -H, then hard links are detected and recreated as hardlinks
-# on the other end.
+# Test rsync handling of hardlinks.  By default, rsync does not detect
+# hard links and they get sent as separate files.  If you specify -H,
+# then hard links are detected and linked together on the receiver.
 
 . "$suitedir/rsync.fns"
 
+outfile="$scratchdir/rsync.out"
+
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
 
 # TODO: Need to test whether hardlinks are possible on this OS/filesystem
@@ -27,32 +28,40 @@
 echo "This is the file" > "$name1"
 ln "$name1" "$name2" || fail "Can't create hardlink"
 ln "$name2" "$name3" || fail "Can't create hardlink"
 cp "$name2" "$name4" || fail "Can't copy file"
 cat $srcdir/*.c >"$fromdir/text"
 
-checkit "$RSYNC -aHivv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -aHivv '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 echo "extra extra" >>"$todir/name1"
 
-checkit "$RSYNC -aHivv --no-whole-file \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -aHivv --no-whole-file '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # Add a new link in a new subdirectory to test that we don't try to link
 # the files before the directory gets created.
 mkdir "$fromdir/subdir"
 ln "$name1" "$fromdir/subdir/new-file"
 rm "$todir/text"
 
-checkit "$RSYNC -aHivv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
+checkit "$RSYNC -aHivv '$fromdir/' '$todir/'" "$fromdir" "$todir"
 
 # Do some duplicate copies using --link-dest and --copy-dest to test that
 # we hard-link all locally-inherited items.
-checkit "$RSYNC -aHivv --link-dest=\"$todir\" \"$fromdir/\" \"$chkdir/\"" "$todir" "$chkdir"
+checkit "$RSYNC -aHivv --link-dest='$todir' '$fromdir/' '$chkdir/'" "$todir" "$chkdir"
 
 rm -rf "$chkdir"
-checkit "$RSYNC -aHivv --copy-dest=\"$todir\" \"$fromdir/\" \"$chkdir/\"" "$fromdir" "$chkdir"
+checkit "$RSYNC -aHivv --copy-dest='$todir' '$fromdir/' '$chkdir/'" "$fromdir" "$chkdir"
+
+# Create a hard link that has only one part in the hierarchy.
+echo "This is another file" >"$fromdir/solo"
+ln "$fromdir/solo" "$chkdir/solo" || fail "Can't create hardlink"
+
+# Make sure that the checksum data doesn't slide due to an HLINK_BUMP() change.
+$RSYNC -aHivc "$fromdir/" "$chkdir/" | tee "$outfile"
+grep solo "$outfile" && test_fail "Erroneous copy of solo file occurred!"
 
 # Make sure there's nothing wrong with sending a single file with -H
 # enabled (this has broken twice so far, so we need this test).
 rm -rf "$todir"
 $RSYNC -aHivv "$name1" "$todir/"
 diff $diffopt "$name1" "$todir" || test_fail "solo copy of name1 failed"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/itemize.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/itemize.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/itemize.test	2006-10-11 08:51:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/itemize.test	2008-02-28 09:57:29.000000000 +0800
@@ -7,13 +7,13 @@
 
 # Test the output of various copy commands to ensure itemized output
 # and double-verbose output is correct.
 
 . "$suitedir/rsync.fns"
 
-lddir="$tmpdir/ld"
+to2dir="$tmpdir/to2"
 
 chkfile="$scratchdir/rsync.chk"
 outfile="$scratchdir/rsync.out"
 
 makepath "$fromdir/foo"
 makepath "$fromdir/bar/baz"
@@ -23,39 +23,63 @@
 chmod 600 "$fromdir"/foo/config? "$fromdir/bar/baz/rsync"
 umask 0
 ln -s ../bar/baz/rsync "$fromdir/foo/sym"
 umask 022
 ln "$fromdir/foo/config1" "$fromdir/foo/extra"
 
+# Check if the OS can hard-link symlinks or not.
+# (Note: the link we check MUST NOT point to a valid file!)
+ln -s no-such-dir "$to2dir"
+if ln "$to2dir" "$to2dir.test" 2>/dev/null; then
+    L=hL
+else
+    L=cL
+fi
+rm -f "$to2dir" "$to2dir.test"
+
+# Check if rsync can preserve time on symlinks
+case "$RSYNC" in
+*protocol=2*)
+    T=.T
+    ;;
+*)
+    if $RSYNC --version | grep ", symtimes" >/dev/null; then
+	T=.t
+    else
+	T=.T
+    fi
+    ;;
+esac
+
 $RSYNC -iplr "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
->f+++++++ bar/baz/rsync
-cd+++++++ foo/
->f+++++++ foo/config1
->f+++++++ foo/config2
->f+++++++ foo/extra
-cL+++++++ foo/sym -> ../bar/baz/rsync
+cd$all_plus ./
+cd$all_plus bar/
+cd$all_plus bar/baz/
+>f$all_plus bar/baz/rsync
+cd$all_plus foo/
+>f$all_plus foo/config1
+>f$all_plus foo/config2
+>f$all_plus foo/extra
+cL$all_plus foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 1 failed"
 
 # Ensure there are no accidental directory-time problems.
 $RSYNC -a -f '-! */' "$fromdir/" "$todir"
 
 cp -p "$srcdir/configure.in" "$fromdir/foo/config2"
 chmod 601 "$fromdir/foo/config2"
 $RSYNC -iplrH "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
->f..T.... bar/baz/rsync
->f..T.... foo/config1
->f.sTp... foo/config2
-hf..T.... foo/extra => foo/config1
+>f..T.$dots bar/baz/rsync
+>f..T.$dots foo/config1
+>f.sTp$dots foo/config2
+hf..T.$dots foo/extra => foo/config1
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 2 failed"
 
 $RSYNC -a -f '-! */' "$fromdir/" "$todir"
 sleep 1 # For directory mod below to ensure time difference
 rm "$todir/foo/sym"
@@ -66,17 +90,17 @@
 chmod 600 "$fromdir/foo/config2"
 chmod 777 "$todir/bar/baz/rsync"
 
 $RSYNC -iplrtc "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.f..tp... bar/baz/rsync
-.d..t.... foo/
-.f..t.... foo/config1
->fcstp... foo/config2
-cL..T.... foo/sym -> ../bar/baz/rsync
+.f..tp$dots bar/baz/rsync
+.d..t.$dots foo/
+.f..t.$dots foo/config1
+>fcstp$dots foo/config2
+cL.$T.$dots foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 3 failed"
 
 cp -p "$srcdir/configure.in" "$fromdir/foo/config2"
 chmod 600 "$fromdir/foo/config2"
 # Lack of -t is for unchanged hard-link stress-test!
@@ -84,32 +108,32 @@
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
 bar/baz/rsync is uptodate
 foo/config1 is uptodate
 foo/config2
-"foo/extra" is a hard link
+foo/extra is uptodate
 foo/sym is uptodate
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 4 failed"
 
 chmod 747 "$todir/bar/baz/rsync"
 $RSYNC -a -f '-! */' "$fromdir/" "$todir"
 $RSYNC -ivvplrtH "$fromdir/" "$todir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-.d        ./
-.d        bar/
-.d        bar/baz/
-.f...p... bar/baz/rsync
-.d        foo/
-.f        foo/config1
->f..t.... foo/config2
-hf        foo/extra
-.L        foo/sym -> ../bar/baz/rsync
+.d$allspace ./
+.d$allspace bar/
+.d$allspace bar/baz/
+.f...p$dots bar/baz/rsync
+.d$allspace foo/
+.f$allspace foo/config1
+>f..t.$dots foo/config2
+hf$allspace foo/extra
+.L$allspace foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 5 failed"
 
 chmod 757 "$todir/foo/config1"
 touch "$todir/foo/config2"
 $RSYNC -vplrtH "$fromdir/" "$todir/" \
@@ -122,162 +146,158 @@
 
 chmod 757 "$todir/foo/config1"
 touch "$todir/foo/config2"
 $RSYNC -iplrtH "$fromdir/" "$todir/" \
     | tee "$outfile"
 cat <<EOT >"$chkfile"
-.f...p... foo/config1
->f..t.... foo/config2
+.f...p$dots foo/config1
+>f..t.$dots foo/config2
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 7 failed"
 
-mv "$todir" "$lddir"
-$RSYNC -ivvplrtH --copy-dest=../ld "$fromdir/" "$todir/" \
+$RSYNC -ivvplrtH --copy-dest=../to "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
-cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-cf        bar/baz/rsync
-cd+++++++ foo/
-cf        foo/config1
-cf        foo/config2
-hf        foo/extra => foo/config1
-cL..T.... foo/sym -> ../bar/baz/rsync
+case `tail -1 "$outfile"` in
+cL..t*)
+    sym_dots="..t.$dots"
+    L_sym_dots="cL$sym_dots"
+    is_uptodate='-> ../bar/baz/rsync'
+    echo "cL$sym_dots foo/sym $is_uptodate" >"$chkfile.extra"
+    L=cL
+    ;;
+*)
+    sym_dots="$allspace"
+    L_sym_dots=".L$allspace"
+    is_uptodate='is uptodate'
+    touch "$chkfile.extra"
+    ;;
+esac
+cat <<EOT >"$chkfile"
+cd$allspace ./
+cd$allspace bar/
+cd$allspace bar/baz/
+cf$allspace bar/baz/rsync
+cd$allspace foo/
+cf$allspace foo/config1
+cf$allspace foo/config2
+hf$allspace foo/extra => foo/config1
+cL$sym_dots foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 8 failed"
 
-rm -rf "$todir"
-$RSYNC -iplrtH --copy-dest=../ld "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -iplrtH --copy-dest=../to "$fromdir/" "$to2dir/" \
     | tee "$outfile"
-cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-cd+++++++ foo/
-hf        foo/extra => foo/config1
+cat - "$chkfile.extra" <<EOT >"$chkfile"
+hf$allspace foo/extra => foo/config1
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 9 failed"
 
-rm -rf "$todir"
-$RSYNC -vvplrtH --copy-dest="$lddir" "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -vvplrtH --copy-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-./
-bar/
-bar/baz/
+./ is uptodate
+bar/ is uptodate
+bar/baz/ is uptodate
 bar/baz/rsync is uptodate
-foo/
+foo/ is uptodate
 foo/config1 is uptodate
 foo/config2 is uptodate
-"foo/extra" is a hard link
 foo/extra => foo/config1
-foo/sym is uptodate
+foo/sym $is_uptodate
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 10 failed"
 
-rm -rf "$todir"
-$RSYNC -ivvplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -ivvplrtH --link-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-hf        bar/baz/rsync
-cd+++++++ foo/
-hf        foo/config1
-hf        foo/config2
-hf        foo/extra => foo/config1
-hL        foo/sym -> ../bar/baz/rsync
+cd$allspace ./
+cd$allspace bar/
+cd$allspace bar/baz/
+hf$allspace bar/baz/rsync
+cd$allspace foo/
+hf$allspace foo/config1
+hf$allspace foo/config2
+hf$allspace foo/extra => foo/config1
+$L$sym_dots foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 11 failed"
 
-rm -rf "$todir"
-$RSYNC -iplrtH --dry-run --link-dest=../ld "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -iplrtH --dry-run --link-dest=../to "$fromdir/" "$to2dir/" \
     | tee "$outfile"
-cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-cd+++++++ foo/
+cat - "$chkfile.extra" <<EOT >"$chkfile"
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 12 failed"
 
-rm -rf "$todir"
-$RSYNC -iplrtH --link-dest=../ld "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -iplrtH --link-dest=../to "$fromdir/" "$to2dir/" \
     | tee "$outfile"
-cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-cd+++++++ foo/
+cat - "$chkfile.extra" <<EOT >"$chkfile"
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 13 failed"
 
-rm -rf "$todir"
-$RSYNC -vvplrtH --link-dest="$lddir" "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -vvplrtH --link-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-./
-bar/
-bar/baz/
+./ is uptodate
+bar/ is uptodate
+bar/baz/ is uptodate
 bar/baz/rsync is uptodate
-foo/
+foo/ is uptodate
 foo/config1 is uptodate
 foo/config2 is uptodate
-"foo/extra" is a hard link
-foo/sym is uptodate
+foo/extra is uptodate
+foo/sym $is_uptodate
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 14 failed"
 
-rm -rf "$todir"
-$RSYNC -ivvplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -ivvplrtH --compare-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
-# TODO fix really-old problem when combining -H with --compare-dest:
-# missing output for foo/extra hard-link (and it might not be updated)!
 cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-.f        bar/baz/rsync
-cd+++++++ foo/
-.f        foo/config1
-.f        foo/config2
-.L        foo/sym -> ../bar/baz/rsync
+cd$allspace ./
+cd$allspace bar/
+cd$allspace bar/baz/
+.f$allspace bar/baz/rsync
+cd$allspace foo/
+.f$allspace foo/config1
+.f$allspace foo/config2
+.f$allspace foo/extra
+$L_sym_dots foo/sym -> ../bar/baz/rsync
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 15 failed"
 
-rm -rf "$todir"
-$RSYNC -iplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -iplrtH --compare-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
-cat <<EOT >"$chkfile"
-cd+++++++ ./
-cd+++++++ bar/
-cd+++++++ bar/baz/
-cd+++++++ foo/
+cat - "$chkfile.extra" <<EOT >"$chkfile"
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 16 failed"
 
-rm -rf "$todir"
-$RSYNC -vvplrtH --compare-dest="$lddir" "$fromdir/" "$todir/" \
+rm -rf "$to2dir"
+$RSYNC -vvplrtH --compare-dest="$todir" "$fromdir/" "$to2dir/" \
     | tee "$outfile"
 filter_outfile
 cat <<EOT >"$chkfile"
-./
-bar/
-bar/baz/
+./ is uptodate
+bar/ is uptodate
+bar/baz/ is uptodate
 bar/baz/rsync is uptodate
-foo/
+foo/ is uptodate
 foo/config1 is uptodate
 foo/config2 is uptodate
-"foo/extra" is a hard link
-foo/sym is uptodate
+foo/extra is uptodate
+foo/sym $is_uptodate
 EOT
 diff $diffopt "$chkfile" "$outfile" || test_fail "test 17 failed"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/longdir.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/longdir.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/longdir.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/longdir.test	2007-09-04 04:43:58.000000000 +0800
@@ -17,10 +17,10 @@
 date > "$longdir/1"
 if [ -r /etc ]; then
     ls -la /etc >"$longdir/2"
 else
     ls -la / >"$longdir/2"
 fi
-checkit "$RSYNC --delete -avH \"$fromdir/\" \"$todir\"" "$fromdir/" "$todir"
+checkit "$RSYNC --delete -avH '$fromdir/' '$todir'" "$fromdir/" "$todir"
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/merge.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/merge.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/merge.test	2006-02-04 01:58:48.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/merge.test	2007-05-25 22:32:08.000000000 +0800
@@ -8,45 +8,50 @@
 # Make sure we can merge files from multiple directories into one.
 
 . "$suitedir/rsync.fns"
 
 # Build some files/dirs/links to copy
 
-from1dir="${fromdir}1"
-from2dir="${fromdir}2"
-from3dir="${fromdir}3"
-
-mkdir "$from1dir" "$from2dir" "$from3dir"
-mkdir "$from2dir"/sub1 "$from3dir"/sub1
-mkdir "$from3dir"/sub2 "$from1dir"/dir-and-not-dir
-mkdir "$chkdir" "$chkdir"/sub1 "$chkdir"/sub2 "$chkdir"/dir-and-not-dir
-echo "one" >"$from1dir"/one
-cp -p "$from1dir"/one "$from2dir"/one
-cp -p "$from1dir"/one "$from3dir"/one
-echo "two" >"$from1dir"/two
-echo "three" >"$from2dir"/three
-echo "four" >"$from3dir"/four
-echo "five" >"$from1dir"/five
-echo "six" >"$from3dir"/six
-echo "sub1" >"$from2dir"/sub1/uno
-cp -p "$from2dir"/sub1/uno "$from3dir"/sub1/uno
-echo "sub2" >"$from3dir"/sub1/dos
-echo "sub3" >"$from2dir"/sub1/tres
-echo "subby" >"$from3dir"/sub2/subby
-echo "extra" >"$from1dir"/dir-and-not-dir/inside
-echo "not-dir" >"$from3dir"/dir-and-not-dir
-
-cp -p "$from1dir"/one "$from1dir"/two "$from2dir"/three "$from3dir"/four "$from1dir"/five "$from3dir"/six "$chkdir"
-cp -p "$from1dir"/dir-and-not-dir/inside "$chkdir"/dir-and-not-dir
-cp -p "$from2dir"/sub1/uno "$from3dir"/sub1/dos "$from2dir"/sub1/tres "$chkdir"/sub1
-cp -p "$from3dir"/sub2/subby "$chkdir"/sub2
+# Use local dirnames to better exercise the arg-parsing code.
+cd "$tmpdir"
+
+mkdir from1 from2 from3 deep
+mkdir from2/sub1 from3/sub1
+mkdir from3/sub2 from1/dir-and-not-dir
+mkdir chk chk/sub1 chk/sub2 chk/dir-and-not-dir
+echo "one" >from1/one
+cp -p from1/one from2/one
+cp -p from1/one from3/one
+echo "two" >from1/two
+echo "three" >from2/three
+echo "four" >from3/four
+echo "five" >from1/five
+echo "six" >from3/six
+echo "sub1" >from2/sub1/uno
+cp -p from2/sub1/uno from3/sub1/uno
+echo "sub2" >from3/sub1/dos
+echo "sub3" >from2/sub1/tres
+echo "subby" >from3/sub2/subby
+echo "extra" >from1/dir-and-not-dir/inside
+echo "not-dir" >from3/dir-and-not-dir
+echo "arg-test" >deep/arg-test
+echo "shallow" >shallow
+
+cp -p from1/one from1/two from2/three from3/four from1/five from3/six chk
+cp -p deep/arg-test shallow chk
+cp -p from1/dir-and-not-dir/inside chk/dir-and-not-dir
+cp -p from2/sub1/uno from3/sub1/dos from2/sub1/tres chk/sub1
+cp -p from3/sub2/subby chk/sub2
+
+# Make sure that time has moved on.
+sleep 1
 
 # Get rid of any directory-time differences
-$RSYNC -av --existing -f 'exclude,! */' "$from1dir/" "$from2dir/"
-$RSYNC -av --existing -f 'exclude,! */' "$from2dir/" "$from3dir/"
-$RSYNC -av --existing -f 'exclude,! */' "$from1dir/" "$chkdir/"
-$RSYNC -av --existing -f 'exclude,! */' "$from3dir/" "$chkdir/"
+$RSYNC -av --existing -f 'exclude,! */' from1/ from2/
+$RSYNC -av --existing -f 'exclude,! */' from2/ from3/
+$RSYNC -av --existing -f 'exclude,! */' from1/ chk/
+$RSYNC -av --existing -f 'exclude,! */' from3/ chk/
 
-checkit "$RSYNC -aHvv \"$from1dir/\" \"$from2dir/\" \"$from3dir/\" \"$todir/\"" "$chkdir" "$todir"
+checkit "$RSYNC -avv deep/arg-test shallow from1/ from2/ from3/ to/" chk to
 
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/relative.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/relative.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/relative.test	2005-05-28 02:09:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/relative.test	2007-09-23 10:18:57.000000000 +0800
@@ -5,35 +5,56 @@
 # This program is distributable under the terms of the GNU GPL (see COPYING)
 
 . "$suitedir/rsync.fns"
 
 deepstr='down/3/deep'
 deepdir="$fromdir/$deepstr"
-mkdir -p "$deepdir"
+extradir="$fromdir/extra"
+makepath "$deepdir" "$extradir/$deepstr" "$chkdir"
+
 fromdir="$deepdir"
 hands_setup
 fromdir="$tmpdir/from"
 
+extrafile="$extradir/./$deepstr/extra.added.value"
+echo wowza >"$extrafile"
+
+$RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$extradir/"
+
 outfile="$scratchdir/rsync.out"
 
 cd "$fromdir"
 
 # Main script starts here
 
-echo "$fromdir"
-runtest "basic relative" 'checkit "$RSYNC -avR ./$deepstr \"$todir\"" "$fromdir/" "$todir"'
+$RSYNC -ai --include=/down/ --exclude='/*' "$fromdir/" "$chkdir/"
 
-ln "$deepdir/filelist" "$deepdir/dir"
-runtest "hard links" 'checkit "$RSYNC -avHR ./$deepstr/ \"$todir\"" "$fromdir/" "$todir"'
+sleep 1
+runtest "basic relative" 'checkit "$RSYNC -avR ./$deepstr \"$todir\"" "$chkdir" "$todir"'
+
+ln $deepstr/filelist $deepstr/dir
+ln ../chk/$deepstr/filelist ../chk/$deepstr/dir
+runtest "hard links" 'checkit "$RSYNC -avHR ./$deepstr/ \"$todir\"" "$chkdir" "$todir"'
 
 cp "$deepdir/text" "$todir/$deepstr/ThisShouldGo"
 cp "$deepdir/text" "$todir/$deepstr/dir/ThisShouldGoToo"
-runtest "deletion" 'checkit "$RSYNC -avHR --delete ./$deepstr/ \"$todir\"" "$fromdir/" "$todir"'
+runtest "deletion" 'checkit "$RSYNC -avHR --del ./$deepstr/ \"$todir\"" "$chkdir" "$todir"'
 
-runtest "non-deletion" 'checkit "$RSYNC -aiHR --delete ./$deepstr/ \"$todir\"" "$fromdir/" "$todir"' \
+runtest "non-deletion" 'checkit "$RSYNC -aiHR --del ./$deepstr/ \"$todir\"" "$chkdir" "$todir"' \
     | tee "$outfile"
 
 # Make sure no files were deleted
 grep 'deleting ' "$outfile" && test_fail "Erroneous deletions occurred!"
 
+# Relative with merging.
+$RSYNC -ai "$extradir/down" "$chkdir/"
+
+checkit "$RSYNC -aiR $deepstr '$extrafile' '$todir'" "$chkdir" "$todir"
+
+checkit "$RSYNC -aiR --del $deepstr '$extrafile' '$todir'" "$chkdir" "$todir" \
+    | tee "$outfile"
+
+# Make sure no files were deleted
+grep 'deleting ' "$outfile" && test_fail "Erroneous deletions occurred! (2)"
+
 # The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/rsync.fns	2006-05-31 02:26:17.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/rsync.fns	2008-02-28 09:57:29.000000000 +0800
@@ -20,12 +20,17 @@
 
 tmpdir="$scratchdir"
 fromdir="$tmpdir/from"
 todir="$tmpdir/to"
 chkdir="$tmpdir/chk"
 
+# For itemized output:
+all_plus='+++++++++'
+allspace='         '
+dots='.....' # trailing dots after changes
+
 # Berkley's nice.
 PATH="$PATH:/usr/ucb"
 
 if diff -u "$srcdir/testsuite/rsync.fns" "$srcdir/testsuite/rsync.fns" >/dev/null 2>&1; then
     diffopt="-u"
 else
@@ -49,27 +54,30 @@
 
 # Call this if you want to filter out verbose messages (-v or -vv) from
 # the output of an rsync run (whittling the output down to just the file
 # messages).  This isn't needed if you use -i without -v.
 filter_outfile() {
     sed -e '/^building file list /d' \
+	-e '/^sending incremental file list/d' \
 	-e '/^created directory /d' \
 	-e '/^done$/d' \
 	-e '/ --whole-file$/d' \
 	-e '/^total: /d' \
+	-e '/^client charset: /d' \
+	-e '/^server charset: /d' \
 	-e '/^$/,$d' \
 	<"$outfile" >"$outfile.new"
     mv "$outfile.new" "$outfile"
 }
 
 printmsg() {
     echo "$1"
 }
 
 rsync_ls_lR() {
-    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls"
+    find "$@" -print | sort | sed 's/ /\\ /g' | xargs "$TOOLDIR/tls" $TLS_ARGS
 }
 
 check_perms() {
     perms=`"$TOOLDIR/tls" "$1" | sed 's/^[-d]\(.........\).*/\1/'`
     if test $perms = $2; then
 	return 0
@@ -142,32 +150,32 @@
 
 
 ####################
 # Many machines do not have "mkdir -p", so we have to build up long paths.
 # How boring.  
 makepath() {
-    echo "        makepath $1"
-    p="$1"
-    (
+    for p in "${@}"; do
+	(echo "        makepath $p"
+
 	# Absolut Unix.
 	if echo $p | grep '^/' >/dev/null
 	then
 	    cd /
 	fi
     
-	# This will break if $1 contains a space.
+	# This will break if $p contains a space.
 	for c in `echo $p | tr '/' ' '`
 	do 
 	    if [ -d "$c" ] || mkdir "$c" 
 	    then
 		cd "$c" || return $?
 	    else
 		echo "failed to create $c" >&2; return $?
 	    fi
-	done
-    )
+	done)
+    done
 }
 
 
 
 ###########################
 # Run a test (in '$1') then compare directories $2 and $3 to see if
@@ -228,13 +236,14 @@
 
     cat >"$conf" <<EOF
 # rsyncd configuration file autogenerated by $0
 
 pid file = $pidfile
 use chroot = no
-hosts allow = localhost 127.0.0.1 $hostname
+munge symlinks = no
+hosts allow = localhost 127.0.0.0/24 192.168.0.0/16 10.0.0.0/8 $hostname
 log file = $logfile
 log format = %i %h [%a] %m (%u) %l %f%L
 transfer logging = yes
 exclude = foobar.baz
 max verbosity = 9
 uid = 0
@@ -249,12 +258,31 @@
 	read only = no
 
 [test-scratch]
 	path = $scratchdir
 	read only = no
 EOF
+
+    # Build a helper script to ignore exit code 23
+    ignore23="$scratchdir/ignore23"
+    echo "building help script $ignore23"
+
+    cat >"$ignore23" <<'EOT'
+if "${@}"; then
+    exit
+fi
+
+ret=$?
+
+if test $ret = 23; then
+    exit
+fi
+
+exit $ret
+EOT
+chmod +x "$ignore23"
 }
 
 
 build_symlinks() {
     mkdir "$fromdir"
     date >"$fromdir/referent"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/ssh-basic.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/ssh-basic.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/testsuite/ssh-basic.test	2005-01-18 06:23:09.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite/ssh-basic.test	2007-09-09 04:16:28.000000000 +0800
@@ -7,37 +7,41 @@
 # COPYING)
 
 # This script tests ssh, if possible.  It's called by runtests.sh
 
 . "$suitedir/rsync.fns"
 
-if [ "x$rsync_enable_ssh_tests" != xyes ]
-then
-    test_skipped "Skipping SSH tests because \$rsync_enable_ssh_tests is not set"
-fi
+SSH="$scratchdir/pretend-ssh"
 
-if ! type ssh >/dev/null ; then
-    test_skipped "Skipping SSH tests because ssh is not in the path"
+cat >"$SSH" <<'EOT'
+while : ; do
+    case "$1" in
+    -*) shift ;;
+    localhost) shift; break ;;
+    *) exit 1 ;;
+    esac
+done
+
+eval "${@}"
+EOT
+chmod +x "$SSH"
+
+if test x"$rsync_enable_ssh_tests" = xyes; then
+    if type ssh >/dev/null ; then
+	SSH=ssh
+    fi
 fi
 
-if ! [ "`ssh -o'BatchMode yes' localhost echo yes`" = "yes" ]; then
+if ! [ "`"$SSH" -o'BatchMode yes' localhost echo yes`" = "yes" ]; then
     test_skipped "Skipping SSH tests because ssh conection to localhost not authorised"
 fi
 
-# Added by Steve Bonds Feb 2 2003
-# Without this, there are no files in the $fromdir directory, so rsync has
-# nothing to do.
-hands_setup
+echo "Using remote shell: $SSH"
 
-runtest "ssh: basic test" 'checkit "$RSYNC -avH -e ssh --rsync-path=\"$RSYNC\" \"$fromdir/\" \"localhost:$todir\"" "$fromdir/" "$todir"'
+# Create some files for rsync to copy
+hands_setup
 
-# Added by Steve Bonds Feb 2 2003
-# I assumed that "F1" was intended to hold a single file for testing if
-# rsync could detect a renamed file over ssh.  Without this line below
-# it was unset so the "mv" tried to move a parent directory into a
-# subdirectory of itself.  There is probably a better way of pulling out
-# a sample file to rename.
-F1=`ls "$todir" | head -5 | tail -1`
+runtest "ssh: basic test" 'checkit "$RSYNC -avH -e \"$SSH\" --rsync-path=\"$RSYNC\" \"$fromdir/\" \"localhost:$todir\"" "$fromdir/" "$todir"'
 
-mv "$todir/$F1" "$todir/ThisShouldGo"
+mv "$todir/text" "$todir/ThisShouldGo"
 
-runtest "ssh: renamed file" 'checkit "$RSYNC --delete -avH -e ssh --rsync-path=\"$RSYNC\" \"$fromdir/\" \"localhost:$todir\"" "$fromdir/" "$todir"'
+runtest "ssh: renamed file" 'checkit "$RSYNC --delete -avH -e \"$SSH\" --rsync-path=\"$RSYNC\" \"$fromdir/\" \"localhost:$todir\"" "$fromdir/" "$todir"'
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/testsuite: xattrs.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/tls.c	2006-10-14 07:42:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/tls.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,15 +1,16 @@
 /*
  * Trivial ls for comparing two directories after running an rsync.
  *
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License version
- * 2 as published by the Free Software Foundation.
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 3 of the License, or
+ * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
@@ -31,20 +32,81 @@
  *
  * A key requirement for this program is that the output be "very
  * reproducible."  So we mask away information that can accidentally
  * change. */
 
 #include "rsync.h"
+#include "popt.h"
+#include "lib/sysxattrs.h"
 
 #define PROGRAM "tls"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
+int am_root = 0;
 int read_only = 1;
 int list_only = 0;
 int preserve_perms = 0;
+int preserve_executability = 0;
+
+#ifdef SUPPORT_XATTRS
+
+#ifdef HAVE_LINUX_XATTRS
+#define XSTAT_ATTR "user.rsync.%stat"
+#else
+#define XSTAT_ATTR "rsync.%stat"
+#endif
+
+static int stat_xattr(const char *fname, STRUCT_STAT *fst)
+{
+	int mode, rdev_major, rdev_minor, uid, gid, len;
+	char buf[256];
+
+	if (am_root >= 0 || IS_DEVICE(fst->st_mode) || IS_SPECIAL(fst->st_mode))
+		return -1;
+
+	len = sys_lgetxattr(fname, XSTAT_ATTR, buf, sizeof buf - 1);
+	if (len >= (int)sizeof buf) {
+		len = -1;
+		errno = ERANGE;
+	}
+	if (len < 0) {
+		if (errno == ENOTSUP || errno == ENOATTR)
+			return -1;
+		if (errno == EPERM && S_ISLNK(fst->st_mode)) {
+			fst->st_uid = 0;
+			fst->st_gid = 0;
+			return 0;
+		}
+		fprintf(stderr, "failed to read xattr %s for %s: %s\n",
+			XSTAT_ATTR, fname, strerror(errno));
+		return -1;
+	}
+	buf[len] = '\0';
+
+	if (sscanf(buf, "%o %d,%d %d:%d",
+		   &mode, &rdev_major, &rdev_minor, &uid, &gid) != 5) {
+		fprintf(stderr, "Corrupt %s xattr attached to %s: \"%s\"\n",
+			XSTAT_ATTR, fname, buf);
+		exit(1);
+	}
+
+#if _S_IFLNK != 0120000
+	if ((mode & (_S_IFMT)) == 0120000)
+		mode = (mode & ~(_S_IFMT)) | _S_IFLNK;
+#endif
+	fst->st_mode = mode;
+
+	fst->st_rdev = MAKEDEV(rdev_major, rdev_minor);
+	fst->st_uid = uid;
+	fst->st_gid = gid;
+
+	return 0;
+}
+
+#endif
 
 static void failed(char const *what, char const *where)
 {
 	fprintf(stderr, PROGRAM ": %s %s: %s\n",
 		what, where, strerror(errno));
 	exit(1);
@@ -57,12 +119,16 @@
 	struct tm *mt;
 	char datebuf[50];
 	char linkbuf[4096];
 
 	if (do_lstat(fname, &buf) < 0)
 		failed("stat", fname);
+#ifdef SUPPORT_XATTRS
+	if (am_root < 0)
+		stat_xattr(fname, &buf);
+#endif
 
 	/* The size of anything but a regular file is probably not
 	 * worth thinking about. */
 	if (!S_ISREG(buf.st_mode))
 		buf.st_size = 0;
 
@@ -113,21 +179,60 @@
 		printf("%12.0f", (double)buf.st_size);
 	printf(" %6ld.%-6ld %6ld %s %s%s\n",
 	       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,
 	       datebuf, fname, linkbuf);
 }
 
+static struct poptOption long_options[] = {
+  /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
+#ifdef SUPPORT_XATTRS
+  {"fake-super",      'f', POPT_ARG_VAL,    &am_root, -1, 0, 0 },
+#endif
+  {"help",            'h', POPT_ARG_NONE,   0, 'h', 0, 0 },
+  {0,0,0,0,0,0,0}
+};
+
+static void tls_usage(int ret)
+{
+  FILE *F = ret ? stderr : stdout;
+  fprintf(F,"usage: " PROGRAM " [OPTIONS] FILE ...\n");
+  fprintf(F,"Trivial file listing program for portably checking rsync\n");
+  fprintf(F,"\nOptions:\n");
+#ifdef SUPPORT_XATTRS
+  fprintf(F," -f, --fake-super            display attributes including fake-super xattrs\n");
+#endif
+  fprintf(F," -h, --help                  show this help\n");
+  exit(ret);
+}
+
 int
 main(int argc, char *argv[])
 {
-	if (argc < 2) {
-		fprintf(stderr, "usage: " PROGRAM " DIR ...\n"
-			"Trivial file listing program for portably checking rsync\n");
-		return 1;
+	poptContext pc;
+	const char **extra_args;
+	int opt;
+
+	pc = poptGetContext(PROGRAM, argc, (const char **)argv,
+			    long_options, 0);
+	while ((opt = poptGetNextOpt(pc)) != -1) {
+		switch (opt) {
+		case 'h':
+			tls_usage(0);
+		default:
+			fprintf(stderr,
+			        "%s: %s\n",
+				poptBadOption(pc, POPT_BADOPTION_NOALIAS),
+				poptStrerror(opt));
+			tls_usage(1);
+		}
 	}
 
-	for (argv++; *argv; argv++) {
-		list_file(*argv);
-	}
+	extra_args = poptGetArgs(pc);
+	if (!extra_args || *extra_args == NULL)
+		tls_usage(1);
+
+	for (; *extra_args; extra_args++)
+		list_file(*extra_args);
+	poptFreeContext(pc);
 
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/TODO	2006-02-04 04:49:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/TODO	2007-01-10 04:03:34.000000000 +0800
@@ -362,50 +362,24 @@
   do this is to just disable gzip (with a warning) when talking to old
   versions.
 
                       --          --
 
 
-TDB								2002/03/12
-
-  Rather than storing the file list in memory, store it in a TDB.
-
-  This *might* make memory usage lower while building the file list.
-
-  Hashtable lookup will mean files are not transmitted in order,
-  though... hm.
-
-  This would neatly eliminate one of the major post-fork shared data
-  structures.
-
-                      --          --
-
-
 Splint								2002/03/12
 
   Build rsync with SPLINT to try to find security holes.  Add
   annotations as necessary.  Keep track of the number of warnings
   found initially, and see how many of them are real bugs, or real
   security bugs.  Knowing the percentage of likely hits would be
   really interesting for other projects.
 
                       --          --
 
 PERFORMANCE ----------------------------------------------------------
 
-Traverse just one directory at a time
-
-  Traverse just one directory at a time.  Tridge says it's possible.
-
-  At the moment rsync reads the whole file list into memory at the
-  start, which makes us use a lot of memory and also not pipeline
-  network access as much as we could.
-
-                      --          --
-
-
 Allow skipping MD4 file_sum					2002/04/08
 
   If we're doing a local transfer, or using -W, then perhaps don't
   send the file checksum.  If we're doing a local transfer, then
   calculating MD4 checksums uses 90% of CPU and is unlikely to be
   useful.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/token.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/token.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,86 +1,214 @@
 /*
  * Routines used by the file-transfer code.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2003, 2004, 2005 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
 #include "zlib/zlib.h"
 
 extern int do_compression;
 extern int module_id;
 extern int def_compress_level;
+extern char *skip_compress;
 
 static int compression_level, per_file_default_level;
 
-/* determine the compression level based on a wildcard filename list */
-void set_compression(char *fname)
+struct suffix_tree {
+	struct suffix_tree *sibling;
+	struct suffix_tree *child;
+	char letter, word_end;
+};
+
+static char *match_list;
+static struct suffix_tree *suftree;
+
+static void add_suffix(struct suffix_tree **prior, char ltr, const char *str)
 {
-	static char *match_list;
-	char *s;
+	struct suffix_tree *node, *newnode;
 
-	if (!do_compression)
+	if (ltr == '[') {
+		const char *after = strchr(str, ']');
+		/* Just skip bogus character classes. */
+		if (!after++)
+			return;
+		while ((ltr = *str++) != ']')
+			add_suffix(prior, ltr, after);
 		return;
+	}
 
-	if (!match_list) {
-		char *t, *f = lp_dont_compress(module_id);
-		int len = strlen(f);
-		if (!(match_list = t = new_array(char, len + 2)))
-			out_of_memory("set_compression");
-		while (*f) {
-			if (*f == ' ') {
-				f++;
-				continue;
-			}
-			do {
-				if (isupper(*(unsigned char *)f))
-					*t++ = tolower(*(unsigned char *)f);
-				else
-					*t++ = *f;
-			} while (*++f != ' ' && *f);
-			*t++ = '\0';
-		}
-		/* Optimize a match-string of "*". */
-		if (t - match_list == 2 && match_list[0] == '*') {
-			t = match_list;
-			per_file_default_level = 0;
-		} else
-			per_file_default_level = def_compress_level;
+	for (node = *prior; node; prior = &node->sibling, node = node->sibling) {
+		if (node->letter == ltr) {
+			if (*str)
+				add_suffix(&node->child, *str, str+1);
+			else
+				node->word_end = 1;
+			return;
+		}
+		if (node->letter > ltr)
+			break;
+	}
+	if (!(newnode = new(struct suffix_tree)))
+		out_of_memory("add_suffix");
+	newnode->sibling = node;
+	newnode->child = NULL;
+	newnode->letter = ltr;
+	*prior = newnode;
+	if (*str) {
+		add_suffix(&newnode->child, *str, str+1);
+		newnode->word_end = 0;
+	} else
+		newnode->word_end = 1;
+}
+
+static void add_nocompress_suffixes(const char *str)
+{
+	char *buf, *t;
+	const char *f = str;
+
+	if (!(buf = new_array(char, strlen(f) + 1)))
+		out_of_memory("add_nocompress_suffixes");
+
+	while (*f) {
+		if (*f == '/') {
+			f++;
+			continue;
+		}
+
+		t = buf;
+		do {
+			if (isUpper(f))
+				*t++ = toLower(f);
+			else
+				*t++ = *f;
+		} while (*++f != '/' && *f);
+		*t++ = '\0';
+
+		fprintf(stderr, "adding `%s'\n", buf);
+		add_suffix(&suftree, *buf, buf+1);
+	}
+
+	free(buf);
+}
+
+static void init_set_compression(void)
+{
+	const char *f;
+	char *t, *start;
+
+	if (skip_compress)
+		add_nocompress_suffixes(skip_compress);
+
+	/* A non-daemon transfer skips the default suffix list if the
+	 * user specified --skip-compress. */
+	if (skip_compress && module_id < 0)
+		f = "";
+	else
+		f = lp_dont_compress(module_id);
+
+	if (!(match_list = t = new_array(char, strlen(f) + 2)))
+		out_of_memory("set_compression");
+
+	per_file_default_level = def_compress_level;
+
+	while (*f) {
+		if (*f == ' ') {
+			f++;
+			continue;
+		}
+
+		start = t;
+		do {
+			if (isUpper(f))
+				*t++ = toLower(f);
+			else
+				*t++ = *f;
+		} while (*++f != ' ' && *f);
 		*t++ = '\0';
+
+		if (t - start == 1+1 && *start == '*') {
+			/* Optimize a match-string of "*". */
+			*match_list = '\0';
+			suftree = NULL;
+			per_file_default_level = 0;
+			break;
+		}
+
+		/* Move *.foo items into the stuffix tree. */
+		if (*start == '*' && start[1] == '.' && start[2]
+		 && !strpbrk(start+2, ".?*")) {
+			add_suffix(&suftree, start[2], start+3);
+			t = start;
+		}
 	}
+	*t++ = '\0';
+}
+
+/* determine the compression level based on a wildcard filename list */
+void set_compression(const char *fname)
+{
+	const struct suffix_tree *node;
+	const char *s;
+	char ltr;
+
+	if (!do_compression)
+		return;
+
+	if (!match_list)
+		init_set_compression();
 
 	compression_level = per_file_default_level;
 
-	if (!*match_list)
+	if (!*match_list && !suftree)
 		return;
 
 	if ((s = strrchr(fname, '/')) != NULL)
 		fname = s + 1;
 
 	for (s = match_list; *s; s += strlen(s) + 1) {
 		if (iwildmatch(s, fname)) {
 			compression_level = 0;
-			break;
+			return;
+		}
+	}
+
+	if (!(node = suftree) || !(s = strrchr(fname, '.'))
+	 || s == fname || !(ltr = *++s))
+		return;
+
+	while (1) {
+		while (node->letter != ltr) {
+			if (node->letter > ltr)
+				return;
+			if (!(node = node->sibling))
+				return;
+		}
+		if ((ltr = *++s) == '\0') {
+			if (node->word_end)
+				compression_level = 0;
+			return;
 		}
+		if (!(node = node->child))
+			return;
 	}
 }
 
 /* non-compressing recv token */
 static int32 simple_recv_token(int f, char **data)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/trimslash.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/trimslash.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/trimslash.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/trimslash.c	2008-01-26 08:57:02.000000000 +0800
@@ -3,32 +3,33 @@
  *
  * Copyright (C) 2002 Martin Pool
  * Copyright (C) 2003 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 /* These are to make syscall.o shut up. */
 int dry_run = 0;
+int am_root = 0;
 int read_only = 1;
 int list_only = 0;
 int preserve_perms = 0;
+int preserve_executability = 0;
 
 int
 main(int argc, char **argv)
 {
 	int i;
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/t_stub.c	2006-09-24 11:11:41.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/t_stub.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,37 +1,37 @@
 /*
  * This file contains really simple implementations for rsync global
  * functions, so that module test harnesses can run standalone.
  *
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
 
 int modify_window = 0;
 int module_id = -1;
 int relative_paths = 0;
 int human_readable = 0;
 int module_dirlen = 0;
 mode_t orig_umask = 002;
 char *partial_dir;
+char *module_dir;
 struct filter_list_struct server_filter_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
 	va_start(ap, format);
@@ -61,25 +61,25 @@
 {
 	/* This function doesn't really get called in this test context, so
 	 * just return 0. */
 	return 0;
 }
 
+ int make_bak_dir(UNUSED(const char *fullpath))
+{
+	return -1;
+}
+
  char *lp_name(UNUSED(int mod))
 {
 	return NULL;
 }
 
  BOOL lp_use_chroot(UNUSED(int mod))
 {
 	return 0;
 }
 
- char *lp_path(UNUSED(int mod))
-{
-	return NULL;
-}
-
  const char *who_am_i(void)
 {
 	return "tester";
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/t_unsafe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/t_unsafe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/t_unsafe.c	2006-04-26 07:51:15.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/t_unsafe.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,34 +1,38 @@
 /*
  * Test harness for unsafe_symlink().  Not linked into rsync itself.
  *
  * Copyright (C) 2002 Martin Pool
- * Copyright (C) 2003 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* Prints either "safe" or "unsafe" depending on the two arguments.
  * Always returns 0 unless something extraordinary happens. */
 
 #include "rsync.h"
 
-int dry_run, read_only, list_only, verbose;
+int dry_run = 0;
+int am_root = 0;
+int read_only = 0;
+int list_only = 0;
+int verbose = 0;
 int preserve_perms = 0;
+int preserve_executability = 0;
 
 int
 main(int argc, char **argv)
 {
 	if (argc != 3) {
 		fprintf(stderr, "usage: t_unsafe LINKDEST SRCDIR\n");
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: tweak_manpage
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9: tweak_manpage_dashes
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/uidlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/uidlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/uidlist.c	2006-10-14 07:35:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/uidlist.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,96 +1,101 @@
 /*
  * Handle the mapping of uid/gid and user/group names between systems.
  *
  * Copyright (C) 1996 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
- * Copyright (C) 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2004-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /* If the source username/group does not exist on the target then use
  * the numeric IDs.  Never do any mapping for uid=0 or gid=0 as these
  * are special. */
 
 #include "rsync.h"
+#include "io.h"
+
+extern int verbose;
+extern int am_root;
+extern int preserve_uid;
+extern int preserve_gid;
+extern int preserve_acls;
+extern int numeric_ids;
 
 #ifdef HAVE_GETGROUPS
 # ifndef GETGROUPS_T
 #  define GETGROUPS_T gid_t
 # endif
 #endif
 
-extern int verbose;
-extern int preserve_uid;
-extern int preserve_gid;
-extern int numeric_ids;
-extern int am_root;
+#define GID_NONE ((gid_t)-1)
 
 struct idlist {
 	struct idlist *next;
-	int id, id2;
-	char *name;
+	const char *name;
+	id_t id, id2;
+	uint16 flags;
 };
 
 static struct idlist *uidlist;
 static struct idlist *gidlist;
 
-static struct idlist *add_to_list(struct idlist **root, int id, char *name,
-				  int id2)
+static struct idlist *add_to_list(struct idlist **root, id_t id, const char *name,
+				  id_t id2, uint16 flags)
 {
 	struct idlist *node = new(struct idlist);
 	if (!node)
 		out_of_memory("add_to_list");
 	node->next = *root;
 	node->name = name;
 	node->id = id;
 	node->id2 = id2;
+	node->flags = flags;
 	*root = node;
 	return node;
 }
 
 /* turn a uid into a user name */
-static char *uid_to_name(uid_t uid)
+static const char *uid_to_name(uid_t uid)
 {
 	struct passwd *pass = getpwuid(uid);
 	if (pass)
 		return strdup(pass->pw_name);
 	return NULL;
 }
 
 /* turn a gid into a group name */
-static char *gid_to_name(gid_t gid)
+static const char *gid_to_name(gid_t gid)
 {
 	struct group *grp = getgrgid(gid);
 	if (grp)
 		return strdup(grp->gr_name);
 	return NULL;
 }
 
-static int map_uid(int id, char *name)
+static uid_t map_uid(uid_t id, const char *name)
 {
 	uid_t uid;
 	if (id != 0 && name_to_uid(name, &uid))
 		return uid;
 	return id;
 }
 
-static int map_gid(int id, char *name)
+static gid_t map_gid(gid_t id, const char *name)
 {
 	gid_t gid;
 	if (id != 0 && name_to_gid(name, &gid))
 		return gid;
 	return id;
 }
@@ -145,54 +150,53 @@
 
 #else
 	static gid_t mygid = GID_NONE;
 	if (mygid == GID_NONE) {
 		mygid = MY_GID();
 		if (verbose > 3)
-			rprintf(FINFO, "process has gid %d\n", (int)mygid);
+			rprintf(FINFO, "process has gid %u\n", (unsigned)mygid);
 	}
 	return gid == mygid;
 #endif
 }
 
 /* Add a uid to the list of uids.  Only called on receiving side. */
-static struct idlist *recv_add_uid(int id, char *name)
+static struct idlist *recv_add_uid(uid_t id, const char *name)
 {
-	int id2 = name ? map_uid(id, name) : id;
+	uid_t id2 = name ? map_uid(id, name) : id;
 	struct idlist *node;
 
-	node = add_to_list(&uidlist, id, name, id2);
+	node = add_to_list(&uidlist, id, name, id2, 0);
 
 	if (verbose > 3) {
-		rprintf(FINFO, "uid %d(%s) maps to %d\n",
-		    id, name ? name : "", id2);
+		rprintf(FINFO, "uid %u(%s) maps to %u\n",
+			(unsigned)id, name ? name : "", (unsigned)id2);
 	}
 
 	return node;
 }
 
 /* Add a gid to the list of gids.  Only called on receiving side. */
-static struct idlist *recv_add_gid(int id, char *name)
+static struct idlist *recv_add_gid(gid_t id, const char *name)
 {
-	int id2 = name ? map_gid(id, name) : id;
+	gid_t id2 = name ? map_gid(id, name) : id;
 	struct idlist *node;
 
-	if (!am_root && !is_in_group(id2))
-		id2 = GID_NONE;
-	node = add_to_list(&gidlist, id, name, id2);
+	node = add_to_list(&gidlist, id, name, id2,
+		!am_root && !is_in_group(id2) ? FLAG_SKIP_GROUP : 0);
 
 	if (verbose > 3) {
-		rprintf(FINFO, "gid %d(%s) maps to %d\n",
-		    id, name ? name : "", id2);
+		rprintf(FINFO, "gid %u(%s) maps to %u\n",
+			(unsigned)id, name ? name : "", (unsigned)id2);
 	}
 
 	return node;
 }
 
 /* this function is a definate candidate for a faster algorithm */
-static uid_t match_uid(uid_t uid)
+uid_t match_uid(uid_t uid)
 {
 	static uid_t last_in, last_out;
 	struct idlist *list;
 
 	if (uid == 0)
 		return 0;
@@ -200,148 +204,176 @@
 	if (uid == last_in)
 		return last_out;
 
 	last_in = uid;
 
 	for (list = uidlist; list; list = list->next) {
-		if (list->id == (int)uid)
-			return last_out = (uid_t)list->id2;
+		if (list->id == uid)
+			return last_out = list->id2;
 	}
 
 	return last_out = uid;
 }
 
-static gid_t match_gid(gid_t gid)
+gid_t match_gid(gid_t gid, uint16 *flags_ptr)
 {
-	static gid_t last_in = GID_NONE, last_out = GID_NONE;
+	static struct idlist *last = NULL;
 	struct idlist *list;
 
-	if (gid == GID_NONE)
-		return GID_NONE;
-
-	if (gid == last_in)
-		return last_out;
-
-	last_in = gid;
-
-	for (list = gidlist; list; list = list->next) {
-		if (list->id == (int)gid)
-			return last_out = (gid_t)list->id2;
+	if (last && gid == last->id)
+		list = last;
+	else {
+		for (list = gidlist; list; list = list->next) {
+			if (list->id == gid)
+				break;
+		}
+		if (!list)
+			list = recv_add_gid(gid, NULL);
+		last = list;
 	}
 
-	list = recv_add_gid(gid, NULL);
-	return last_out = list->id2;
+	if (flags_ptr && list->flags & FLAG_SKIP_GROUP)
+		*flags_ptr |= FLAG_SKIP_GROUP;
+	return list->id2;
 }
 
 /* Add a uid to the list of uids.  Only called on sending side. */
-void add_uid(uid_t uid)
+const char *add_uid(uid_t uid)
 {
 	struct idlist *list;
+	struct idlist *node;
 
 	if (uid == 0)	/* don't map root */
-		return;
+		return NULL;
 
 	for (list = uidlist; list; list = list->next) {
-		if (list->id == (int)uid)
-			return;
+		if (list->id == uid)
+			return NULL;
 	}
 
-	add_to_list(&uidlist, (int)uid, uid_to_name(uid), 0);
+	node = add_to_list(&uidlist, uid, uid_to_name(uid), 0, 0);
+	return node->name;
 }
 
 /* Add a gid to the list of gids.  Only called on sending side. */
-void add_gid(gid_t gid)
+const char *add_gid(gid_t gid)
 {
 	struct idlist *list;
+	struct idlist *node;
 
 	if (gid == 0)	/* don't map root */
-		return;
+		return NULL;
 
 	for (list = gidlist; list; list = list->next) {
-		if (list->id == (int)gid)
-			return;
+		if (list->id == gid)
+			return NULL;
 	}
 
-	add_to_list(&gidlist, (int)gid, gid_to_name(gid), 0);
+	node = add_to_list(&gidlist, gid, gid_to_name(gid), 0, 0);
+	return node->name;
 }
 
-
 /* send a complete uid/gid mapping to the peer */
-void send_uid_list(int f)
+void send_id_list(int f)
 {
 	struct idlist *list;
 
-	if (numeric_ids)
-		return;
-
-	if (preserve_uid) {
+	if (preserve_uid || preserve_acls) {
 		int len;
 		/* we send sequences of uid/byte-length/name */
 		for (list = uidlist; list; list = list->next) {
 			if (!list->name)
 				continue;
 			len = strlen(list->name);
-			write_int(f, list->id);
+			write_varint30(f, list->id);
 			write_byte(f, len);
 			write_buf(f, list->name, len);
 		}
 
 		/* terminate the uid list with a 0 uid. We explicitly exclude
 		 * 0 from the list */
-		write_int(f, 0);
+		write_varint30(f, 0);
 	}
 
-	if (preserve_gid) {
+	if (preserve_gid || preserve_acls) {
 		int len;
 		for (list = gidlist; list; list = list->next) {
 			if (!list->name)
 				continue;
 			len = strlen(list->name);
-			write_int(f, list->id);
+			write_varint30(f, list->id);
 			write_byte(f, len);
 			write_buf(f, list->name, len);
 		}
-		write_int(f, 0);
+		write_varint30(f, 0);
 	}
 }
 
+uid_t recv_user_name(int f, uid_t uid)
+{
+	struct idlist *node;
+	int len = read_byte(f);
+	char *name = new_array(char, len+1);
+	if (!name)
+		out_of_memory("recv_user_name");
+	read_sbuf(f, name, len);
+	if (numeric_ids < 0) {
+		free(name);
+		name = NULL;
+	}
+	node = recv_add_uid(uid, name); /* node keeps name's memory */
+	return node->id2;
+}
+
+gid_t recv_group_name(int f, gid_t gid, uint16 *flags_ptr)
+{
+	struct idlist *node;
+	int len = read_byte(f);
+	char *name = new_array(char, len+1);
+	if (!name)
+		out_of_memory("recv_group_name");
+	read_sbuf(f, name, len);
+	if (numeric_ids < 0) {
+		free(name);
+		name = NULL;
+	}
+	node = recv_add_gid(gid, name); /* node keeps name's memory */
+	if (flags_ptr && node->flags & FLAG_SKIP_GROUP)
+		*flags_ptr |= FLAG_SKIP_GROUP;
+	return node->id2;
+}
+
 /* recv a complete uid/gid mapping from the peer and map the uid/gid
  * in the file list to local names */
-void recv_uid_list(int f, struct file_list *flist)
+void recv_id_list(int f, struct file_list *flist)
 {
-	int id, i;
-	char *name;
+	id_t id;
+	int i;
 
-	if (preserve_uid && !numeric_ids) {
+	if ((preserve_uid || preserve_acls) && numeric_ids <= 0) {
 		/* read the uid list */
-		while ((id = read_int(f)) != 0) {
-			int len = read_byte(f);
-			name = new_array(char, len+1);
-			if (!name)
-				out_of_memory("recv_uid_list");
-			read_sbuf(f, name, len);
-			recv_add_uid(id, name); /* node keeps name's memory */
-		}
+		while ((id = read_varint30(f)) != 0)
+			recv_user_name(f, id);
 	}
 
-	if (preserve_gid && !numeric_ids) {
+	if ((preserve_gid || preserve_acls) && numeric_ids <= 0) {
 		/* read the gid list */
-		while ((id = read_int(f)) != 0) {
-			int len = read_byte(f);
-			name = new_array(char, len+1);
-			if (!name)
-				out_of_memory("recv_uid_list");
-			read_sbuf(f, name, len);
-			recv_add_gid(id, name); /* node keeps name's memory */
-		}
+		while ((id = read_varint30(f)) != 0)
+			recv_group_name(f, id, NULL);
 	}
 
 	/* Now convert all the uids/gids from sender values to our values. */
+#ifdef SUPPORT_ACLS
+	if (preserve_acls && !numeric_ids)
+		match_acl_ids();
+#endif
 	if (am_root && preserve_uid && !numeric_ids) {
-		for (i = 0; i < flist->count; i++)
-			flist->files[i]->uid = match_uid(flist->files[i]->uid);
+		for (i = 0; i < flist->used; i++)
+			F_OWNER(flist->files[i]) = match_uid(F_OWNER(flist->files[i]));
 	}
 	if (preserve_gid && (!am_root || !numeric_ids)) {
-		for (i = 0; i < flist->count; i++)
-			flist->files[i]->gid = match_gid(flist->files[i]->gid);
+		for (i = 0; i < flist->used; i++) {
+			F_GROUP(flist->files[i]) = match_gid(F_GROUP(flist->files[i]),
+							     &flist->files[i]->flags);
+		}
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/util.c	2006-10-15 04:31:33.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/util.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,37 +1,38 @@
 /*
  * Utility routines used in rsync.
  *
  * Copyright (C) 1996-2000 Andrew Tridgell
  * Copyright (C) 1996 Paul Mackerras
  * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>
- * Copyright (C) 2003, 2004, 2005, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 #include "rsync.h"
+#include "ifuncs.h"
 
 extern int verbose;
 extern int dry_run;
 extern int module_id;
 extern int modify_window;
 extern int relative_paths;
 extern int human_readable;
+extern char *module_dir;
 extern unsigned int module_dirlen;
 extern mode_t orig_umask;
 extern char *partial_dir;
 extern struct filter_list_struct server_filter_list;
 
 int sanitize_paths = 0;
@@ -87,15 +88,15 @@
 		set_nonblocking(fd[1]);
 	}
 
 	return ret;
 }
 
-void print_child_argv(char **cmd)
+void print_child_argv(const char *prefix, char **cmd)
 {
-	rprintf(FCLIENT, "opening connection using ");
+	rprintf(FCLIENT, "%s ", prefix);
 	for (; *cmd; cmd++) {
 		/* Look for characters that ought to be quoted.  This
 		* is not a great quoting algorithm, but it's
 		* sufficient for a log message. */
 		if (strspn(*cmd, "abcdefghijklmnopqrstuvwxyz"
 			   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
@@ -106,25 +107,25 @@
 			rprintf(FCLIENT, "%s ", *cmd);
 		}
 	}
 	rprintf(FCLIENT, "\n");
 }
 
-NORETURN void out_of_memory(char *str)
+NORETURN void out_of_memory(const char *str)
 {
 	rprintf(FERROR, "ERROR: out of memory in %s [%s]\n", str, who_am_i());
 	exit_cleanup(RERR_MALLOC);
 }
 
-NORETURN void overflow_exit(char *str)
+NORETURN void overflow_exit(const char *str)
 {
 	rprintf(FERROR, "ERROR: buffer overflow in %s [%s]\n", str, who_am_i());
 	exit_cleanup(RERR_MALLOC);
 }
 
-int set_modtime(char *fname, time_t modtime, mode_t mode)
+int set_modtime(const char *fname, time_t modtime, mode_t mode)
 {
 #if !defined HAVE_LUTIMES || !defined HAVE_UTIMES
 	if (S_ISLNK(mode))
 		return 1;
 #endif
 
@@ -142,17 +143,20 @@
 		struct timeval t[2];
 		t[0].tv_sec = time(NULL);
 		t[0].tv_usec = 0;
 		t[1].tv_sec = modtime;
 		t[1].tv_usec = 0;
 # ifdef HAVE_LUTIMES
-		if (S_ISLNK(mode))
-			return lutimes(fname, t);
+		if (S_ISLNK(mode)) {
+			if (lutimes(fname, t) < 0)
+				return errno == ENOSYS ? 1 : -1;
+			return 0;
+		}
 # endif
 		return utimes(fname, t);
-#elif defined HAVE_UTIMBUF
+#elif defined HAVE_STRUCT_UTIMBUF
 		struct utimbuf tbuf;
 		tbuf.actime = time(NULL);
 		tbuf.modtime = modtime;
 		return utime(fname,&tbuf);
 #elif defined HAVE_UTIME
 		time_t t[2];
@@ -211,13 +215,13 @@
  * @retval len upon success
  *
  * @retval <0 write's (negative) error code
  *
  * Derived from GNU C's cccp.c.
  */
-int full_write(int desc, char *ptr, size_t len)
+int full_write(int desc, const char *ptr, size_t len)
 {
 	int total_written;
 
 	total_written = 0;
 	while (len > 0) {
 		int written = write(desc, ptr, len);
@@ -255,64 +259,67 @@
 		n_chars = read(desc, ptr, len);
 	} while (n_chars < 0 && errno == EINTR);
 
 	return n_chars;
 }
 
-/** Copy a file.
+/* Copy a file.  If ofd < 0, copy_file unlinks and opens the "dest" file.
+ * Otherwise, it just writes to and closes the provided file descriptor.
  *
  * This is used in conjunction with the --temp-dir, --backup, and
  * --copy-dest options. */
-int copy_file(const char *source, const char *dest, mode_t mode)
+int copy_file(const char *source, const char *dest, int ofd,
+	      mode_t mode, int create_bak_dir)
 {
 	int ifd;
-	int ofd;
 	char buf[1024 * 8];
 	int len;   /* Number of bytes read into `buf'. */
 
-	ifd = do_open(source, O_RDONLY, 0);
-	if (ifd == -1) {
-		rsyserr(FERROR, errno, "open %s", full_fname(source));
+	if ((ifd = do_open(source, O_RDONLY, 0)) < 0) {
+		rsyserr(FERROR_XFER, errno, "open %s", full_fname(source));
 		return -1;
 	}
 
-	if (robust_unlink(dest) && errno != ENOENT) {
-		rsyserr(FERROR, errno, "unlink %s", full_fname(dest));
-		return -1;
-	}
+	if (ofd < 0) {
+		if (robust_unlink(dest) && errno != ENOENT) {
+			rsyserr(FERROR_XFER, errno, "unlink %s", full_fname(dest));
+			return -1;
+		}
 
-	ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode);
-	if (ofd == -1) {
-		rsyserr(FERROR, errno, "open %s", full_fname(dest));
-		close(ifd);
-		return -1;
+		if ((ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0
+		 && (!create_bak_dir || errno != ENOENT || make_bak_dir(dest) < 0
+		  || (ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0)) {
+			rsyserr(FERROR_XFER, errno, "open %s", full_fname(dest));
+			close(ifd);
+			return -1;
+		}
 	}
 
 	while ((len = safe_read(ifd, buf, sizeof buf)) > 0) {
 		if (full_write(ofd, buf, len) < 0) {
-			rsyserr(FERROR, errno, "write %s", full_fname(dest));
+			rsyserr(FERROR_XFER, errno, "write %s", full_fname(dest));
 			close(ifd);
 			close(ofd);
 			return -1;
 		}
 	}
 
 	if (len < 0) {
-		rsyserr(FERROR, errno, "read %s", full_fname(source));
+		rsyserr(FERROR_XFER, errno, "read %s", full_fname(source));
 		close(ifd);
 		close(ofd);
 		return -1;
 	}
 
 	if (close(ifd) < 0) {
-		rsyserr(FINFO, errno, "close failed on %s",
+		rsyserr(FWARNING, errno, "close failed on %s",
 			full_fname(source));
 	}
 
 	if (close(ofd) < 0) {
-		rsyserr(FERROR, errno, "close failed on %s",
+		rsyserr(FERROR_XFER, errno, "close failed on %s",
 			full_fname(dest));
 		return -1;
 	}
 
 	return 0;
 }
@@ -362,13 +369,13 @@
 		snprintf(&path[pos], MAX_RENAMES_DIGITS+1, "%03d", counter);
 		if (++counter >= MAX_RENAMES)
 			counter = 1;
 	} while ((rc = access(path, 0)) == 0 && counter != start);
 
 	if (verbose > 0) {
-		rprintf(FINFO,"renaming %s to %s because of text busy\n",
+		rprintf(FWARNING, "renaming %s to %s because of text busy\n",
 			fname, path);
 	}
 
 	/* maybe we should return rename()'s exit status? Nah. */
 	if (do_rename(fname, path) != 0) {
 		errno = ETXTBSY;
@@ -379,13 +386,13 @@
 }
 
 /* Returns 0 on successful rename, 1 if we successfully copied the file
  * across filesystems, -2 if copy_file() failed, and -1 on other errors.
  * If partialptr is not NULL and we need to do a copy, copy the file into
  * the active partial-dir instead of over the destination file. */
-int robust_rename(char *from, char *to, char *partialptr,
+int robust_rename(const char *from, const char *to, const char *partialptr,
 		  int mode)
 {
 	int tries = 4;
 
 	while (tries--) {
 		if (do_rename(from, to) == 0)
@@ -401,13 +408,13 @@
 		case EXDEV:
 			if (partialptr) {
 				if (!handle_partial_dir(partialptr,PDIR_CREATE))
 					return -1;
 				to = partialptr;
 			}
-			if (copy_file(from, to, mode) != 0)
+			if (copy_file(from, to, -1, mode, 0) != 0)
 				return -2;
 			do_unlink(from);
 			return 1;
 		default:
 			return -1;
 		}
@@ -456,37 +463,33 @@
 
 		kill(p, sig);
 	}
 }
 
 /** Turn a user name into a uid */
-int name_to_uid(char *name, uid_t *uid)
+int name_to_uid(const char *name, uid_t *uid_p)
 {
 	struct passwd *pass;
 	if (!name || !*name)
 		return 0;
-	pass = getpwnam(name);
-	if (pass) {
-		*uid = pass->pw_uid;
-		return 1;
-	}
-	return 0;
+	if (!(pass = getpwnam(name)))
+		return 0;
+	*uid_p = pass->pw_uid;
+	return 1;
 }
 
 /** Turn a group name into a gid */
-int name_to_gid(char *name, gid_t *gid)
+int name_to_gid(const char *name, gid_t *gid_p)
 {
 	struct group *grp;
 	if (!name || !*name)
 		return 0;
-	grp = getgrnam(name);
-	if (grp) {
-		*gid = grp->gr_gid;
-		return 1;
-	}
-	return 0;
+	if (!(grp = getgrnam(name)))
+		return 0;
+	*gid_p = grp->gr_gid;
+	return 1;
 }
 
 /** Lock a byte range in a open file */
 int lock_range(int fd, int offset, int len)
 {
 	struct flock lock;
@@ -514,23 +517,22 @@
 			*s++ = '/';
 		}
 	}
 	return 0;
 }
 
-static void glob_expand_one(char *s, char ***argv_ptr, int *argc_ptr,
-			    int *maxargs_ptr)
+void glob_expand(char *s, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr)
 {
 	char **argv = *argv_ptr;
 	int argc = *argc_ptr;
 	int maxargs = *maxargs_ptr;
 #if !defined HAVE_GLOB || !defined HAVE_GLOB_H
 	if (argc == maxargs) {
 		maxargs += MAX_ARGS;
 		if (!(argv = realloc_array(argv, char *, maxargs)))
-			out_of_memory("glob_expand_one");
+			out_of_memory("glob_expand");
 		*argv_ptr = argv;
 		*maxargs_ptr = maxargs;
 	}
 	if (!*s)
 		s = ".";
 	s = argv[argc++] = strdup(s);
@@ -541,82 +543,83 @@
 	if (maxargs <= argc)
 		return;
 	if (!*s)
 		s = ".";
 
 	if (sanitize_paths)
-		s = sanitize_path(NULL, s, "", 0, NULL);
+		s = sanitize_path(NULL, s, "", 0);
 	else
 		s = strdup(s);
+	if (!s)
+		out_of_memory("glob_expand");
 
 	memset(&globbuf, 0, sizeof globbuf);
 	if (!filter_server_path(s))
 		glob(s, 0, NULL, &globbuf);
 	if (MAX((int)globbuf.gl_pathc, 1) > maxargs - argc) {
 		maxargs += globbuf.gl_pathc + MAX_ARGS;
 		if (!(argv = realloc_array(argv, char *, maxargs)))
-			out_of_memory("glob_expand_one");
+			out_of_memory("glob_expand");
 		*argv_ptr = argv;
 		*maxargs_ptr = maxargs;
 	}
 	if (globbuf.gl_pathc == 0)
 		argv[argc++] = s;
 	else {
 		int i;
 		free(s);
 		for (i = 0; i < (int)globbuf.gl_pathc; i++) {
 			if (!(argv[argc++] = strdup(globbuf.gl_pathv[i])))
-				out_of_memory("glob_expand_one");
+				out_of_memory("glob_expand");
 		}
 	}
 	globfree(&globbuf);
 #endif
 	*argc_ptr = argc;
 }
 
 /* This routine is only used in daemon mode. */
-void glob_expand(char *base1, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr)
+void glob_expand_module(char *base1, char *arg, char ***argv_ptr, int *argc_ptr, int *maxargs_ptr)
 {
-	char *s = (*argv_ptr)[*argc_ptr];
-	char *p, *q;
+	char *p, *s;
 	char *base = base1;
 	int base_len = strlen(base);
 
-	if (!s || !*s)
+	if (!arg || !*arg)
 		return;
 
-	if (strncmp(s, base, base_len) == 0)
-		s += base_len;
+	if (strncmp(arg, base, base_len) == 0)
+		arg += base_len;
 
-	if (!(s = strdup(s)))
-		out_of_memory("glob_expand");
+	if (!(arg = strdup(arg)))
+		out_of_memory("glob_expand_module");
 
 	if (asprintf(&base," %s/", base1) <= 0)
-		out_of_memory("glob_expand");
+		out_of_memory("glob_expand_module");
 	base_len++;
 
-	for (q = s; *q; q = p + base_len) {
-		if ((p = strstr(q, base)) != NULL)
+	for (s = arg; *s; s = p + base_len) {
+		if ((p = strstr(s, base)) != NULL)
 			*p = '\0'; /* split it at this point */
-		glob_expand_one(q, argv_ptr, argc_ptr, maxargs_ptr);
+		glob_expand(s, argv_ptr, argc_ptr, maxargs_ptr);
 		if (!p)
 			break;
 	}
 
-	free(s);
+	free(arg);
 	free(base);
 }
 
 /**
  * Convert a string to lower case
  **/
 void strlower(char *s)
 {
 	while (*s) {
-		if (isupper(*(unsigned char *)s))
-			*s = tolower(*(unsigned char *)s);
+		if (isUpper(s))
+			*s = toLower(s);
 		s++;
 	}
 }
 
 /* Join strings p1 & p2 into "dest" with a guaranteed '/' between them.  (If
  * p1 ends with a '/', no extra '/' is inserted.)  Returns the length of both
@@ -681,41 +684,50 @@
 			cnt++;
 		}
 	}
 	return cnt;
 }
 
-/* Turns multiple adjacent slashes into a single slash, gets rid of "./"
- * elements (but not a trailing dot dir), removes a trailing slash, and
- * optionally collapses ".." elements (except for those at the start of the
- * string).  If the resulting name would be empty, change it into a ".". */
-unsigned int clean_fname(char *name, BOOL collapse_dot_dot)
+/* Turns multiple adjacent slashes into a single slash, drops interior "."
+ * elements, drops an intial "./" unless CFN_KEEP_LEADING_DOT_DIR is flagged,
+ * will even drop a trailing '.' after a '/' if CFN_DROP_TRAILING_DOT_DIR is
+ * flagged, removes a trailing slash (perhaps after removing the aforementioned
+ * dot) unless CFN_KEEP_TRAILING_SLASH is flagged, will even collapse ".."
+ * elements (except at the start of the string) if CFN_COLLAPSE_DOT_DOT_DIRS
+ * is flagged.  If the resulting name would be empty, we return ".". */
+unsigned int clean_fname(char *name, int flags)
 {
 	char *limit = name - 1, *t = name, *f = name;
 	int anchored;
 
 	if (!name)
 		return 0;
 
 	if ((anchored = *f == '/') != 0)
 		*t++ = *f++;
+	else if (flags & CFN_KEEP_LEADING_DOT_DIR && *f == '.' && f[1] == '/') {
+		*t++ = *f++;
+		*t++ = *f++;
+	}
 	while (*f) {
 		/* discard extra slashes */
 		if (*f == '/') {
 			f++;
 			continue;
 		}
 		if (*f == '.') {
-			/* discard "." dirs (but NOT a trailing '.'!) */
+			/* discard interior "." dirs */
 			if (f[1] == '/') {
 				f += 2;
 				continue;
 			}
+			if (f[1] == '\0' && flags & CFN_DROP_TRAILING_DOT_DIR)
+				break;
 			/* collapse ".." dirs */
-			if (collapse_dot_dot
-			    && f[1] == '.' && (f[2] == '/' || !f[2])) {
+			if (flags & CFN_COLLAPSE_DOT_DOT_DIRS
+			 && f[1] == '.' && (f[2] == '/' || !f[2])) {
 				char *s = t - 1;
 				if (s == name && anchored) {
 					f += 2;
 					continue;
 				}
 				while (s > limit && *--s != '/') {}
@@ -727,13 +739,13 @@
 				limit = t + 2;
 			}
 		}
 		while (*f && (*t++ = *f++) != '/') {}
 	}
 
-	if (t > name+anchored && t[-1] == '/')
+	if (t > name+anchored && t[-1] == '/' && !(flags & CFN_KEEP_TRAILING_SLASH))
 		t--;
 	if (t == name)
 		*t++ = '.';
 	*t = '\0';
 
 	return t - name;
@@ -745,42 +757,35 @@
  *
  * If dest is NULL, a buffer is allocated to hold the result.  It is legal
  * to call with the dest and the path (p) pointing to the same buffer, but
  * rootdir will be ignored to avoid expansion of the string.
  *
  * The rootdir string contains a value to use in place of a leading slash.
- * Specify NULL to get the default of lp_path(module_id).
+ * Specify NULL to get the default of "module_dir".
  *
  * The depth var is a count of how many '..'s to allow at the start of the
- * path.  If symlink is set, combine its value with the "p" value to get
- * the target path, and **return NULL if any '..'s try to escape**.
+ * path.
  *
  * We also clean the path in a manner similar to clean_fname() but with a
  * few differences:
  *
  * Turns multiple adjacent slashes into a single slash, gets rid of "." dir
  * elements (INCLUDING a trailing dot dir), PRESERVES a trailing slash, and
  * ALWAYS collapses ".." elements (except for those at the start of the
  * string up to "depth" deep).  If the resulting name would be empty,
  * change it into a ".". */
-char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth,
-		    const char *symlink)
+char *sanitize_path(char *dest, const char *p, const char *rootdir, int depth)
 {
-	char *start, *sanp, *save_dest = dest;
+	char *start, *sanp;
 	int rlen = 0, leave_one_dotdir = relative_paths;
 
-	if (symlink && *symlink == '/') {
-		p = symlink;
-		symlink = "";
-	}
-
 	if (dest != p) {
 		int plen = strlen(p);
 		if (*p == '/') {
 			if (!rootdir)
-				rootdir = lp_path(module_id);
+				rootdir = module_dir;
 			rlen = strlen(rootdir);
 			depth = 0;
 			p++;
 		}
 		if (dest) {
 			if (rlen + plen + 1 >= MAXPATHLEN)
@@ -792,24 +797,13 @@
 			if (rlen > 1)
 				dest[rlen++] = '/';
 		}
 	}
 
 	start = sanp = dest + rlen;
-	while (1) {
-		if (*p == '\0') {
-			if (!symlink || !*symlink)
-				break;
-			while (sanp != start && sanp[-1] != '/') {
-				/* strip last element */
-				sanp--;
-			}
-			/* Append a relative symlink */
-			p = symlink;
-			symlink = "";
-		}
+	while (*p) {
 		/* discard leading or extra slashes */
 		if (*p == '/') {
 			p++;
 			continue;
 		}
 		/* this loop iterates once per filename component in p.
@@ -825,17 +819,12 @@
 				continue;
 			}
 		}
 		if (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\0')) {
 			/* ".." component followed by slash or end */
 			if (depth <= 0 || sanp != start) {
-				if (symlink && sanp == start) {
-					if (!save_dest)
-						free(dest);
-					return NULL;
-				}
 				p += 2;
 				if (sanp != start) {
 					/* back up sanp one level */
 					--sanp; /* now pointing at slash */
 					while (sanp > start && sanp[-1] != '/') {
 						/* skip back up to slash */
@@ -861,13 +850,13 @@
 	return dest;
 }
 
 /* Like chdir(), but it keeps track of the current directory (in the
  * global "curr_dir"), and ensures that the path size doesn't overflow.
  * Also cleans the path using the clean_fname() function. */
-int push_dir(char *dir, int set_path_only)
+int push_dir(const char *dir, int set_path_only)
 {
 	static int initialised;
 	unsigned int len;
 
 	if (!initialised) {
 		initialised = 1;
@@ -879,14 +868,16 @@
 		return 0;
 
 	len = strlen(dir);
 	if (len == 1 && *dir == '.')
 		return 1;
 
-	if ((*dir == '/' ? len : curr_dir_len + 1 + len) >= sizeof curr_dir)
+	if ((*dir == '/' ? len : curr_dir_len + 1 + len) >= sizeof curr_dir) {
+		errno = ENAMETOOLONG;
 		return 0;
+	}
 
 	if (!set_path_only && chdir(dir))
 		return 0;
 
 	if (*dir == '/') {
 		memcpy(curr_dir, dir, len + 1);
@@ -894,37 +885,43 @@
 	} else {
 		curr_dir[curr_dir_len++] = '/';
 		memcpy(curr_dir + curr_dir_len, dir, len + 1);
 		curr_dir_len += len;
 	}
 
-	curr_dir_len = clean_fname(curr_dir, 1);
+	curr_dir_len = clean_fname(curr_dir, CFN_COLLAPSE_DOT_DOT_DIRS);
 	if (sanitize_paths) {
 		if (module_dirlen > curr_dir_len)
 			module_dirlen = curr_dir_len;
 		curr_dir_depth = count_dir_elements(curr_dir + module_dirlen);
 	}
 
+	if (verbose >= 5 && !set_path_only)
+		rprintf(FINFO, "[%s] push_dir(%s)\n", who_am_i(), curr_dir);
+
 	return 1;
 }
 
 /**
  * Reverse a push_dir() call.  You must pass in an absolute path
  * that was copied from a prior value of "curr_dir".
  **/
-int pop_dir(char *dir)
+int pop_dir(const char *dir)
 {
 	if (chdir(dir))
 		return 0;
 
 	curr_dir_len = strlcpy(curr_dir, dir, sizeof curr_dir);
 	if (curr_dir_len >= sizeof curr_dir)
 		curr_dir_len = sizeof curr_dir - 1;
 	if (sanitize_paths)
 		curr_dir_depth = count_dir_elements(curr_dir + module_dirlen);
 
+	if (verbose >= 5)
+		rprintf(FINFO, "[%s] pop_dir(%s)\n", who_am_i(), curr_dir);
+
 	return 1;
 }
 
 /**
  * Return a quoted string with the full pathname of the indicated filename.
  * The string " (in MODNAME)" may also be appended.  The returned pointer
@@ -1123,36 +1120,34 @@
 	s = bufs[n] + sizeof bufs[0] - 1;
 	*s = '\0';
 
 	if (!num)
 		*--s = '0';
 	while (num) {
-		*--s = (num % 10) + '0';
+		*--s = (char)(num % 10) + '0';
 		num /= 10;
 	}
 	return s;
 }
 
 /* Return the double number as a string.  If the --human-readable option was
  * specified, we may output the number in K, M, or G units.  We use a buffer
  * from human_num() to return our result. */
 char *human_dnum(double dnum, int decimal_digits)
 {
 	char *buf = human_num(dnum);
 	int len = strlen(buf);
-	if (isdigit(*(uchar*)(buf+len-1))) {
+	if (isDigit(buf + len - 1)) {
 		/* There's extra room in buf prior to the start of the num. */
 		buf -= decimal_digits + 1;
 		snprintf(buf, len + decimal_digits + 2, "%.*f", decimal_digits, dnum);
 	}
 	return buf;
 }
 
-/**
- * Return the date and time as a string
- **/
+/* Return the date and time as a string.  Some callers tweak returned buf. */
 char *timestring(time_t t)
 {
 	static char TimeBuf[200];
 	struct tm *tm = localtime(&t);
 	char *p;
 
@@ -1250,24 +1245,23 @@
 	return ret;
 }
 #endif
 
 #define MALLOC_MAX 0x40000000
 
-void *_new_array(unsigned int size, unsigned long num)
+void *_new_array(unsigned long num, unsigned int size, int use_calloc)
 {
 	if (num >= MALLOC_MAX/size)
 		return NULL;
-	return malloc(size * num);
+	return use_calloc ? calloc(num, size) : malloc(num * size);
 }
 
 void *_realloc_array(void *ptr, unsigned int size, unsigned long num)
 {
 	if (num >= MALLOC_MAX/size)
 		return NULL;
-	/* No realloc should need this, but just in case... */
 	if (!ptr)
 		return malloc(size * num);
 	return realloc(ptr, size * num);
 }
 
 /* Take a filename and filename length and return the most significant
@@ -1304,21 +1298,21 @@
 			 || strcmp(s+1, "old") == 0)
 				continue;
 		} else if (s_len == 5) {
 			if (strcmp(s+1, "orig") == 0)
 				continue;
 		} else if (s_len > 2 && had_tilde
-		    && s[1] == '~' && isdigit(*(uchar*)(s+2)))
+		    && s[1] == '~' && isDigit(s + 2))
 			continue;
 		*len_ptr = s_len;
 		suf = s;
 		if (s_len == 1)
 			break;
 		/* Determine if the suffix is all digits. */
 		for (s++, s_len--; s_len > 0; s++, s_len--) {
-			if (!isdigit(*(uchar*)s))
+			if (!isDigit(s))
 				return suf;
 		}
 		/* An all-digit suffix may not be that signficant. */
 		s = suf;
 	}
 
@@ -1465,6 +1459,34 @@
 			return -1; /* impossible... */
 		}
 	}
 
 	return -1;
 }
+
+void *expand_item_list(item_list *lp, size_t item_size,
+		       const char *desc, int incr)
+{
+	/* First time through, 0 <= 0, so list is expanded. */
+	if (lp->malloced <= lp->count) {
+		void *new_ptr;
+		size_t new_size = lp->malloced;
+		if (incr < 0)
+			new_size += -incr; /* increase slowly */
+		else if (new_size < (size_t)incr)
+			new_size += incr;
+		else
+			new_size *= 2;
+		new_ptr = realloc_array(lp->items, char, new_size * item_size);
+		if (verbose >= 4) {
+			rprintf(FINFO, "[%s] expand %s to %.0f bytes, did%s move\n",
+				who_am_i(), desc, (double)new_size * item_size,
+				new_ptr == lp->items ? " not" : "");
+		}
+		if (!new_ptr)
+			out_of_memory("expand_item_list");
+
+		lp->items = new_ptr;
+		lp->malloced = new_size;
+	}
+	return (char*)lp->items + (lp->count++ * item_size);
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/wildtest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/wildtest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/wildtest.c	2006-04-26 07:51:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/wildtest.c	2008-03-02 04:01:41.000000000 +0800
@@ -1,24 +1,23 @@
 /*
  * Test suite for the wildmatch code.
  *
- * Copyright (C) 2003, 2004, 2006 Wayne Davison
+ * Copyright (C) 2003-2008 Wayne Davison
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
+ * the Free Software Foundation; either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
+ * with this program; if not, visit the http://fsf.org website.
  */
 
 /*#define COMPARE_WITH_FNMATCH*/
 
 #define WILD_TEST_ITERATIONS
 #include "lib/wildmatch.c"
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0: xattrs.c
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/zlib/inflate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/zlib/inflate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/zlib/inflate.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/zlib/inflate.c	2007-05-21 18:20:18.000000000 +0800
@@ -646,40 +646,44 @@
             }
             if (state->head != Z_NULL)
                 state->head->text = (int)((hold >> 8) & 1);
             if (state->flags & 0x0200) CRC2(state->check, hold);
             INITBITS();
             state->mode = TIME;
+	    /* FALL THROUGH */
         case TIME:
             NEEDBITS(32);
             if (state->head != Z_NULL)
                 state->head->time = hold;
             if (state->flags & 0x0200) CRC4(state->check, hold);
             INITBITS();
             state->mode = OS;
+	    /* FALL THROUGH */
         case OS:
             NEEDBITS(16);
             if (state->head != Z_NULL) {
                 state->head->xflags = (int)(hold & 0xff);
                 state->head->os = (int)(hold >> 8);
             }
             if (state->flags & 0x0200) CRC2(state->check, hold);
             INITBITS();
             state->mode = EXLEN;
+	    /* FALL THROUGH */
         case EXLEN:
             if (state->flags & 0x0400) {
                 NEEDBITS(16);
                 state->length = (unsigned)(hold);
                 if (state->head != Z_NULL)
                     state->head->extra_len = (unsigned)hold;
                 if (state->flags & 0x0200) CRC2(state->check, hold);
                 INITBITS();
             }
             else if (state->head != Z_NULL)
                 state->head->extra = Z_NULL;
             state->mode = EXTRA;
+	    /* FALL THROUGH */
         case EXTRA:
             if (state->flags & 0x0400) {
                 copy = state->length;
                 if (copy > have) copy = have;
                 if (copy) {
                     if (state->head != Z_NULL &&
@@ -696,12 +700,13 @@
                     state->length -= copy;
                 }
                 if (state->length) goto inf_leave;
             }
             state->length = 0;
             state->mode = NAME;
+	    /* FALL THROUGH */
         case NAME:
             if (state->flags & 0x0800) {
                 if (have == 0) goto inf_leave;
                 copy = 0;
                 do {
                     len = (unsigned)(next[copy++]);
@@ -717,12 +722,13 @@
                 if (len) goto inf_leave;
             }
             else if (state->head != Z_NULL)
                 state->head->name = Z_NULL;
             state->length = 0;
             state->mode = COMMENT;
+	    /* FALL THROUGH */
         case COMMENT:
             if (state->flags & 0x1000) {
                 if (have == 0) goto inf_leave;
                 copy = 0;
                 do {
                     len = (unsigned)(next[copy++]);
@@ -737,12 +743,13 @@
                 next += copy;
                 if (len) goto inf_leave;
             }
             else if (state->head != Z_NULL)
                 state->head->comment = Z_NULL;
             state->mode = HCRC;
+	    /* FALL THROUGH */
         case HCRC:
             if (state->flags & 0x0200) {
                 NEEDBITS(16);
                 if (hold != (state->check & 0xffff)) {
                     strm->msg = (char *)"header crc mismatch";
                     state->mode = BAD;
@@ -760,21 +767,24 @@
 #endif
         case DICTID:
             NEEDBITS(32);
             strm->adler = state->check = REVERSE(hold);
             INITBITS();
             state->mode = DICT;
+	    /* FALL THROUGH */
         case DICT:
             if (state->havedict == 0) {
                 RESTORE();
                 return Z_NEED_DICT;
             }
             strm->adler = state->check = adler32(0L, Z_NULL, 0);
             state->mode = TYPE;
+	    /* FALL THROUGH */
         case TYPE:
             if (flush == Z_BLOCK) goto inf_leave;
+	    /* FALL THROUGH */
         case TYPEDO:
             if (state->last) {
                 BYTEBITS();
                 state->mode = CHECK;
                 break;
             }
@@ -814,12 +824,13 @@
             }
             state->length = (unsigned)hold & 0xffff;
             Tracev((stderr, "inflate:       stored length %u\n",
                     state->length));
             INITBITS();
             state->mode = COPY;
+	    /* FALL THROUGH */
         case COPY:
             copy = state->length;
             if (copy) {
                 if (copy > have) copy = have;
                 if (copy > left) copy = left;
                 if (copy == 0) goto inf_leave;
@@ -849,12 +860,13 @@
                 break;
             }
 #endif
             Tracev((stderr, "inflate:       table sizes ok\n"));
             state->have = 0;
             state->mode = LENLENS;
+	    /* FALL THROUGH */
         case LENLENS:
             while (state->have < state->ncode) {
                 NEEDBITS(3);
                 state->lens[order[state->have++]] = (unsigned short)BITS(3);
                 DROPBITS(3);
             }
@@ -870,12 +882,13 @@
                 state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       code lengths ok\n"));
             state->have = 0;
             state->mode = CODELENS;
+	    /* FALL THROUGH */
         case CODELENS:
             while (state->have < state->nlen + state->ndist) {
                 for (;;) {
                     this = state->lencode[BITS(state->lenbits)];
                     if ((unsigned)(this.bits) <= bits) break;
                     PULLBYTE();
@@ -944,12 +957,13 @@
                 strm->msg = (char *)"invalid distances set";
                 state->mode = BAD;
                 break;
             }
             Tracev((stderr, "inflate:       codes ok\n"));
             state->mode = LEN;
+	    /* FALL THROUGH */
         case LEN:
             if (have >= 6 && left >= 258) {
                 RESTORE();
                 inflate_fast(strm, out);
                 LOAD();
                 break;
@@ -987,20 +1001,22 @@
                 strm->msg = (char *)"invalid literal/length code";
                 state->mode = BAD;
                 break;
             }
             state->extra = (unsigned)(this.op) & 15;
             state->mode = LENEXT;
+	    /* FALL THROUGH */
         case LENEXT:
             if (state->extra) {
                 NEEDBITS(state->extra);
                 state->length += BITS(state->extra);
                 DROPBITS(state->extra);
             }
             Tracevv((stderr, "inflate:         length %u\n", state->length));
             state->mode = DIST;
+	    /* FALL THROUGH */
         case DIST:
             for (;;) {
                 this = state->distcode[BITS(state->distbits)];
                 if ((unsigned)(this.bits) <= bits) break;
                 PULLBYTE();
             }
@@ -1020,12 +1036,13 @@
                 state->mode = BAD;
                 break;
             }
             state->offset = (unsigned)this.val;
             state->extra = (unsigned)(this.op) & 15;
             state->mode = DISTEXT;
+	    /* FALL THROUGH */
         case DISTEXT:
             if (state->extra) {
                 NEEDBITS(state->extra);
                 state->offset += BITS(state->extra);
                 DROPBITS(state->extra);
             }
@@ -1040,12 +1057,13 @@
                 strm->msg = (char *)"invalid distance too far back";
                 state->mode = BAD;
                 break;
             }
             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
             state->mode = MATCH;
+	    /* FALL THROUGH */
         case MATCH:
             if (left == 0) goto inf_leave;
             copy = out - left;
             if (state->offset > copy) {         /* copy from window */
                 copy = state->offset - copy;
                 if (copy > state->write) {
@@ -1095,12 +1113,13 @@
                 }
                 INITBITS();
                 Tracev((stderr, "inflate:   check matches trailer\n"));
             }
 #ifdef GUNZIP
             state->mode = LENGTH;
+	    /* FALL THROUGH */
         case LENGTH:
             if (state->wrap && state->flags) {
                 NEEDBITS(32);
                 if (hold != (state->total & 0xffffffffUL)) {
                     strm->msg = (char *)"incorrect length check";
                     state->mode = BAD;
@@ -1108,12 +1127,13 @@
                 }
                 INITBITS();
                 Tracev((stderr, "inflate:   length matches trailer\n"));
             }
 #endif
             state->mode = DONE;
+	    /* FALL THROUGH */
         case DONE:
             ret = Z_STREAM_END;
             goto inf_leave;
         case BAD:
             ret = Z_DATA_ERROR;
             goto inf_leave;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/zlib/zutil.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/zlib/zutil.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.9/zlib/zutil.c	2005-07-22 23:54:43.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-3.0.0/zlib/zutil.c	2007-05-22 07:45:26.000000000 +0800
@@ -32,33 +32,33 @@
 uLong ZEXPORT zlibCompileFlags()
 {
     uLong flags;
 
     flags = 0;
     switch (sizeof(uInt)) {
-    case 2:     break;
-    case 4:     flags += 1;     break;
-    case 8:     flags += 2;     break;
+    case 2:     break;				/* CONSTANT CONDITION */
+    case 4:     flags += 1;     break;		/* CONSTANT CONDITION */
+    case 8:     flags += 2;     break;		/* CONSTANT CONDITION */
     default:    flags += 3;
     }
     switch (sizeof(uLong)) {
-    case 2:     break;
-    case 4:     flags += 1 << 2;        break;
-    case 8:     flags += 2 << 2;        break;
+    case 2:     break;				/* CONSTANT CONDITION */
+    case 4:     flags += 1 << 2;        break;	/* CONSTANT CONDITION */
+    case 8:     flags += 2 << 2;        break;	/* CONSTANT CONDITION */
     default:    flags += 3 << 2;
     }
     switch (sizeof(voidpf)) {
-    case 2:     break;
-    case 4:     flags += 1 << 4;        break;
-    case 8:     flags += 2 << 4;        break;
+    case 2:     break;				/* CONSTANT CONDITION */
+    case 4:     flags += 1 << 4;        break;	/* CONSTANT CONDITION */
+    case 8:     flags += 2 << 4;        break;	/* CONSTANT CONDITION */
     default:    flags += 3 << 4;
     }
     switch (sizeof(z_off_t)) {
-    case 2:     break;
-    case 4:     flags += 1 << 6;        break;
-    case 8:     flags += 2 << 6;        break;
+    case 2:     break;				/* CONSTANT CONDITION */
+    case 4:     flags += 1 << 6;        break;	/* CONSTANT CONDITION */
+    case 8:     flags += 2 << 6;        break;	/* CONSTANT CONDITION */
     default:    flags += 3 << 6;
     }
 #ifdef DEBUG
     flags += 1 << 8;
 #endif
 #if defined(ASMV) || defined(ASMINF)
