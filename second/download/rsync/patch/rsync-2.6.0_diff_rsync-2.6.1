Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0: acconfig.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/authenticate.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/authenticate.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/authenticate.c	2003-07-30 14:12:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/authenticate.c	2004-04-02 02:05:40.000000000 +0800
@@ -21,22 +21,22 @@
 #include "rsync.h"
 
 /***************************************************************************
 encode a buffer using base64 - simple and slow algorithm. null terminates
 the result.
   ***************************************************************************/
-static void base64_encode(char *buf, int len, char *out)
+void base64_encode(char *buf, int len, char *out)
 {
 	char *b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
 	int bit_offset, byte_offset, idx, i;
 	unsigned char *d = (unsigned char *)buf;
 	int bytes = (len*8 + 5)/6;
 
 	memset(out, 0, bytes+1);
 
-	for (i=0;i<bytes;i++) {
+	for (i = 0; i < bytes; i++) {
 		byte_offset = (i*6)/8;
 		bit_offset = (i*6)%8;
 		if (bit_offset < 3) {
 			idx = (d[byte_offset] >> (2-bit_offset)) & 0x3F;
 		} else {
 			idx = (d[byte_offset] << (bit_offset-2)) & 0x3F;
@@ -266,13 +266,14 @@
 void auth_client(int fd, char *user, char *challenge)
 {
 	char *pass;
 	char pass2[30];
 	extern char *password_file;
 
-	if (!user || !*user) return;
+	if (!user || !*user)
+		user = "nobody";
 
 	if (!(pass=getpassf(password_file)) && !(pass=getenv("RSYNC_PASSWORD"))) {
 		/* XXX: cyeoh says that getpass is deprecated, because
 		 * it may return a truncated password on some systems,
 		 * and it is not in the LSB.
                  *
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/backup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/backup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/backup.c	2003-09-11 12:53:05.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/backup.c	2004-03-14 04:18:03.000000000 +0800
@@ -1,49 +1,53 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1999
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /* backup handling code */
 
 #include "rsync.h"
 
 extern int verbose;
 extern int backup_suffix_len;
 extern int backup_dir_len;
+extern unsigned int backup_dir_remainder;
+extern char backup_dir_buf[MAXPATHLEN];
 extern char *backup_suffix;
 extern char *backup_dir;
 
 extern int am_root;
 extern int preserve_devices;
 extern int preserve_links;
 extern int preserve_hard_links;
+extern int orig_umask;
 
 /* simple backup creates a backup with a suffix in the same directory */
 static int make_simple_backup(char *fname)
 {
 	char fnamebak[MAXPATHLEN];
-	if (strlen(fname) + backup_suffix_len > MAXPATHLEN-1) {
+
+	if (stringjoin(fnamebak, sizeof fnamebak, fname, backup_suffix, NULL)
+	    >= sizeof fnamebak) {
 		rprintf(FERROR, "backup filename too long\n");
 		return 0;
 	}
 
-	snprintf(fnamebak, sizeof(fnamebak), "%s%s", fname, backup_suffix);
 	if (do_rename(fname, fnamebak) != 0) {
 		/* cygwin (at least version b19) reports EINVAL */
 		if (errno != ENOENT && errno != EINVAL) {
 			rsyserr(FERROR, errno, "rename %s to backup %s", fname, fnamebak);
 			return 0;
 		}
@@ -51,251 +55,193 @@
 		rprintf(FINFO, "backed up %s to %s\n", fname, fnamebak);
 	}
 	return 1;
 }
 
 
-/* recursively make a directory path */
-static int make_dir(char *name, int mask)
-{
-	char newdir [MAXPATHLEN];
-	char *p, *d;
-
-	/* copy pathname over, look for last '/' */
-	for (p = d = newdir; *name; *d++ = *name++)
-		if (*name == '/')
-			p = d;
-	if (p == newdir)
-		return 0;
-	*p = 0;
-
-	/* make the new directory, if that fails then make its parent */
-	while (do_mkdir (newdir, mask) != 0)
-		if ((errno != ENOENT) || !make_dir (newdir, mask))
-			return 0;
-
-	return 1;
-} /* make_dir */
-
-
 /****************************************************************************
 Create a directory given an absolute path, perms based upon another directory
 path
 ****************************************************************************/
-static int make_bak_dir(char *fname, char *bak_path)
+static int make_bak_dir(char *fullpath)
 {
 	STRUCT_STAT st;
-	STRUCT_STAT *st2;
-	char fullpath[MAXPATHLEN];
-	extern int orig_umask;
-	char *p;
-	char *q;
-
-	while(strncmp(bak_path, "./", 2) == 0) bak_path += 2;
-
-	if(bak_path[strlen(bak_path)-1] != '/') {
-		snprintf(fullpath, sizeof(fullpath), "%s/", bak_path);
-	} else {
-		snprintf(fullpath, sizeof(fullpath), "%s", bak_path);
-	}
-	p = fullpath;
-	q = &fullpath[strlen(fullpath)];  /* End of bak_path string */
-	strcat(fullpath, fname);
-
-	/* Make the directories */
-	while ((p = strchr(p, '/'))) {
-		*p = 0;
-		if(do_lstat(fullpath, &st) != 0) {
-			do_mkdir(fullpath, 0777 & ~orig_umask);
-			if(p>q) {
-				if(do_lstat(q, &st) != 0) {
-					rprintf(FERROR, "make_bak_dir stat %s failed: %s\n",
-						full_fname(fullpath), strerror(errno));
-				} else {
-					st2 = &st;
-					set_modtime(fullpath, st2->st_mtime);
-					if(do_lchown(fullpath, st2->st_uid, st2->st_gid) != 0) {
-						rprintf(FERROR, "make_bak_dir chown %s failed: %s\n",
-							full_fname(fullpath), strerror(errno));
-					}
-					if(do_chmod(fullpath, st2->st_mode) != 0) {
-						rprintf(FERROR, "make_bak_dir failed to set permissions on %s: %s\n",
-							full_fname(fullpath), strerror(errno));
-					}
-				}
+	char *rel = fullpath + backup_dir_len;
+	char *end = rel + strlen(rel);
+	char *p = end;
+
+	while (strncmp(fullpath, "./", 2) == 0)
+		fullpath += 2;
+
+	/* Try to find an existing dir, starting from the deepest dir. */
+	while (1) {
+		if (--p == fullpath) {
+			p += strlen(p);
+			goto failure;
+		}
+		if (*p == '/') {
+			*p = '\0';
+			if (do_mkdir(fullpath, 0777 & ~orig_umask) == 0)
+				break;
+			if (errno != ENOENT) {
+				rprintf(FERROR,
+				    "make_bak_dir mkdir %s failed: %s\n",
+				    full_fname(fullpath), strerror(errno));
+				goto failure;
+			}
+		}
+	}
+
+	/* Make all the dirs that we didn't find on the way here. */
+	while (1) {
+		if (p >= rel) {
+			/* Try to transfer the directory settings of the
+			 * actual dir that the files are coming from. */
+			if (do_lstat(rel, &st) != 0) {
+				rprintf(FERROR,
+				    "make_bak_dir stat %s failed: %s\n",
+				    full_fname(rel), strerror(errno));
+			} else {
+				set_modtime(fullpath, st.st_mtime);
+				do_lchown(fullpath, st.st_uid, st.st_gid);
+				do_chmod(fullpath, st.st_mode);
 			}
 		}
 		*p = '/';
-		p++;
+		p += strlen(p);
+		if (p == end)
+			break;
+		if (do_mkdir(fullpath, 0777 & ~orig_umask) < 0) {
+			rprintf(FERROR,
+			    "make_bak_dir mkdir %s failed: %s\n",
+			    full_fname(fullpath), strerror(errno));
+			goto failure;
+		}
 	}
 	return 0;
+
+failure:
+	while (p != end) {
+		*p = '/';
+		p += strlen(p);
+	}
+	return -1;
 }
 
 /* robustly move a file, creating new directory structures if necessary */
 static int robust_move(char *src, char *dst)
 {
-	int keep_trying = 4;
-	int keep_path_extfs = 0;
-	int failed;
-
-	while (keep_trying) {
-		if (keep_path_extfs) {
-			failed = copy_file(src, dst, 0755);
-			if (!failed) {
-				do_unlink(src);
-			}
-		} else {
-			failed = robust_rename (src, dst);
-		}
-
-		if (failed) {
-			if (verbose > 2)
-				rprintf (FERROR, "robust_move failed: %s(%d)\n",
-				    strerror (errno), errno);
-			switch (errno) {
-				/* external filesystem */
-				case EXDEV:
-					keep_path_extfs = 1;
-					keep_trying--;
-					break;
-				/* no directory to write to */
-				case ENOENT:
-					make_dir(dst, 0700);
-					keep_trying--;
-					break;
-				default:
-					keep_trying = 0;
-			} /* switch */
-		} else
-			keep_trying = 0;
-	} /* while */
-	return (!failed);
-} /* robust_move */
+	if (robust_rename(src, dst, 0755) < 0 && (errno != ENOENT
+	    || make_bak_dir(dst) < 0 || robust_rename(src, dst, 0755) < 0))
+		return -1;
+	return 0;
+}
 
 
-/* if we have a backup_dir, then we get here from make_backup().
-   We will move the file to be deleted into a parallel directory tree */
+/* If we have a --backup-dir, then we get here from make_backup().
+ * We will move the file to be deleted into a parallel directory tree. */
 static int keep_backup(char *fname)
 {
-
-	static int initialised;
-
-	char keep_name [MAXPATHLEN];
 	STRUCT_STAT st;
 	struct file_struct *file;
-
 	int kept = 0;
 	int ret_code;
 
-	if (!initialised) {
-		if (backup_dir_len && backup_dir[backup_dir_len - 1] == '/')
-			backup_dir[--backup_dir_len] = '\0';
-		if (verbose > 0)
-			rprintf (FINFO, "backup_dir is %s\n", backup_dir);
-		initialised = 1;
-	}
-
 	/* return if no file to keep */
 #if SUPPORT_LINKS
-	if (do_lstat (fname, &st)) return 1;
+	if (do_lstat(fname, &st)) return 1;
 #else
-	if (do_stat (fname, &st)) return 1;
+	if (do_stat(fname, &st)) return 1;
 #endif
 
 	file = make_file(fname, NULL, NO_EXCLUDES);
 
 	/* the file could have disappeared */
 	if (!file) return 1;
 
 	/* make a complete pathname for backup file */
-	if (backup_dir_len+strlen(fname)+backup_suffix_len > MAXPATHLEN-1) {
-		rprintf (FERROR, "keep_backup filename too long\n");
+	if (stringjoin(backup_dir_buf + backup_dir_len, backup_dir_remainder,
+	    fname, backup_suffix, NULL) >= backup_dir_remainder) {
+		rprintf(FERROR, "keep_backup filename too long\n");
 		return 0;
 	}
 
-	snprintf(keep_name, sizeof (keep_name), "%s/%s%s",
-	    backup_dir, fname, backup_suffix);
-
 #ifdef HAVE_MKNOD
 	/* Check to see if this is a device file, or link */
-	if(IS_DEVICE(file->mode)) {
-		if(am_root && preserve_devices) {
-			make_bak_dir(fname, backup_dir);
-			if(do_mknod(keep_name, file->mode, file->rdev) != 0) {
+	if (IS_DEVICE(file->mode)) {
+		if (am_root && preserve_devices) {
+			make_bak_dir(backup_dir_buf);
+			if (do_mknod(backup_dir_buf, file->mode, file->u.rdev) != 0) {
 				rprintf(FERROR, "mknod %s failed: %s\n",
-					full_fname(keep_name), strerror(errno));
-			} else if(verbose>2) {
-				rprintf(FINFO, "make_backup: DEVICE %s successful.\n", fname);
+					full_fname(backup_dir_buf), strerror(errno));
+			} else if (verbose > 2) {
+				rprintf(FINFO,
+					"make_backup: DEVICE %s successful.\n",
+					fname);
 			}
 		}
 		kept = 1;
 		do_unlink(fname);
 	}
 #endif
 
-	if(!kept && S_ISDIR(file->mode)) {
+	if (!kept && S_ISDIR(file->mode)) {
 		/* make an empty directory */
-		make_bak_dir(fname, backup_dir);
-		do_mkdir(keep_name, file->mode);
+		make_bak_dir(backup_dir_buf);
+		do_mkdir(backup_dir_buf, file->mode);
 		ret_code = do_rmdir(fname);
 
-		if(verbose>2) {
+		if (verbose > 2) {
 			rprintf(FINFO, "make_backup: RMDIR %s returns %i\n",
 				full_fname(fname), ret_code);
 		}
 		kept = 1;
 	}
 
 #if SUPPORT_LINKS
-	if(!kept && preserve_links && S_ISLNK(file->mode)) {
+	if (!kept && preserve_links && S_ISLNK(file->mode)) {
 		extern int safe_symlinks;
-		if (safe_symlinks && unsafe_symlink(file->link, keep_name)) {
+		if (safe_symlinks && unsafe_symlink(file->u.link, backup_dir_buf)) {
 			if (verbose) {
 				rprintf(FINFO, "ignoring unsafe symlink %s -> %s\n",
-					full_fname(keep_name), file->link);
+					full_fname(backup_dir_buf), file->u.link);
 			}
 			kept = 1;
 		}
-		make_bak_dir(fname, backup_dir);
-		if(do_symlink(file->link, keep_name) != 0) {
+		make_bak_dir(backup_dir_buf);
+		if (do_symlink(file->u.link, backup_dir_buf) != 0) {
 			rprintf(FERROR, "link %s -> %s : %s\n",
-				full_fname(keep_name), file->link, strerror(errno));
+				full_fname(backup_dir_buf), file->u.link, strerror(errno));
 		}
 		do_unlink(fname);
 		kept = 1;
 	}
 #endif
-	if(!kept && preserve_hard_links && check_hard_link(file)) {
-		if(verbose > 1)
-			rprintf(FINFO, "%s is a hard link\n", f_name(file));
-	}
 
-	if(!kept && !S_ISREG(file->mode)) {
+	if (!kept && !S_ISREG(file->mode)) {
 		rprintf(FINFO, "make_bak: skipping non-regular file %s\n",
-		    fname);
+			fname);
 	}
 
 	/* move to keep tree if a file */
-	if(!kept) {
-		if (!robust_move (fname, keep_name)) {
+	if (!kept) {
+		if (robust_move(fname, backup_dir_buf) != 0) {
 			rprintf(FERROR, "keep_backup failed: %s -> \"%s\": %s\n",
-				full_fname(fname), keep_name, strerror(errno));
+				full_fname(fname), backup_dir_buf, strerror(errno));
 		}
 	}
-	set_perms (keep_name, file, NULL, 0);
-	free_file (file);
-	free (file);
+	set_perms(backup_dir_buf, file, NULL, 0);
+	free(file);
 
 	if (verbose > 1)
-		rprintf (FINFO, "keep_backup %s -> %s\n", fname, keep_name);
+		rprintf(FINFO, "keep_backup %s -> %s\n", fname, backup_dir_buf);
 	return 1;
-} /* keep_backup */
+}
 
 
 /* main backup switch routine */
 int make_backup(char *fname)
 {
 	if (backup_dir)
-		return (keep_backup(fname));
-	else
-		return (make_simple_backup(fname));
+		return keep_backup(fname);
+	return make_simple_backup(fname);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/batch.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/batch.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/batch.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/batch.c	2004-03-06 15:45:52.000000000 +0800
@@ -1,462 +1,233 @@
 /* -*- c-file-style: "linux" -*-
-   
+
    Weiss 1/1999
    Batch utilities for rsync.
 
 */
 
 #include "rsync.h"
 #include <time.h>
 
 extern char *batch_prefix;
+extern int csum_length;
+extern int protocol_version;
+extern struct stats stats;
 
 struct file_list *batch_flist;
 
 static char rsync_flist_file[] = ".rsync_flist";
 static char rsync_csums_file[] = ".rsync_csums";
 static char rsync_delta_file[] = ".rsync_delta";
 static char rsync_argvs_file[] = ".rsync_argvs";
 
-static int fdb;
-static int fdb_delta;
-static int fdb_open;
-static int fdb_close;
+static int f_csums = -1;
+static int f_delta = -1;
 
-void write_batch_flist_file(char *buff, int bytes_to_write)
+void write_batch_flist_info(int flist_count, struct file_struct **files)
 {
 	char filename[MAXPATHLEN];
+	int i, f, save_pv;
+	int64 save_written;
 
-	if (fdb_open) {
-		/* Set up file extension */
-		strlcpy(filename, batch_prefix, sizeof(filename));
-		strlcat(filename, rsync_flist_file, sizeof(filename));
+	stringjoin(filename, sizeof filename,
+	    batch_prefix, rsync_flist_file, NULL);
 
-		/*
-		 * Open batch flist file for writing;
-		 * create it if it doesn't exist
-		 */
-		fdb = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-			    S_IREAD | S_IWRITE);
-		if (fdb == -1) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-				filename, strerror(errno));
-			close(fdb);
-			exit_cleanup(1);
-		}
-		fdb_open = 0;
-	}
-
-	/* Write buffer to batch flist file */
-
-	if (write(fdb, buff, bytes_to_write) == -1) {
-		rprintf(FERROR, "Batch file %s write error: %s\n",
-			filename, strerror(errno));
-		close(fdb);
+	f = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
+	if (f < 0) {
+		rprintf(FERROR, "Batch file %s open error: %s\n",
+		    filename, strerror(errno));
 		exit_cleanup(1);
 	}
 
-	if (fdb_close) {
-		close(fdb);
-	}
-}
-
-void write_batch_flist_info(int flist_count, struct file_struct **fptr)
-{
-	int i;
-	int bytes_to_write;
-
-	/* Write flist info to batch file */
-
-	bytes_to_write =
-	    sizeof(unsigned) +
-	    sizeof(time_t) +
-	    sizeof(OFF_T) +
-	    sizeof(mode_t) +
-	    sizeof(INO64_T) +
-	    sizeof(DEV64_T) +
-	    sizeof(DEV64_T) +
-	    sizeof(uid_t) +
-	    sizeof(gid_t);
-
-	fdb_open = 1;
-	fdb_close = 0;
+	save_written = stats.total_written;
+	save_pv = protocol_version;
+	protocol_version = PROTOCOL_VERSION;
+	write_int(f, protocol_version);
+	write_int(f, flist_count);
 
 	for (i = 0; i < flist_count; i++) {
-		write_batch_flist_file((char *) fptr[i], bytes_to_write);
-		write_char_bufs(fptr[i]->basename);
-		write_char_bufs(fptr[i]->dirname);
-		write_char_bufs(fptr[i]->basedir);
-		write_char_bufs(fptr[i]->link);
-		if (i == flist_count - 1) {
-			fdb_close = 1;
-		}
-		write_char_bufs(fptr[i]->sum);
+		send_file_entry(files[i], f,
+		    files[i]->flags & FLAG_TOP_DIR ?  XMIT_TOP_DIR : 0);
 	}
-}
+	send_file_entry(NULL, f, 0);
 
-void write_char_bufs(char *buf)
-{
-	/* Write the size of the string which will follow  */
-
-	char b[4];
-
-	SIVAL(b, 0, buf != NULL ? strlen(buf) : 0);
-
-	write_batch_flist_file(b, sizeof(int));
+	protocol_version = save_pv;
+	stats.total_written = save_written;
 
-	/*  Write the string if there is one */
-
-	if (buf != NULL) {
-		write_batch_flist_file(buf, strlen(buf));
-	}
+	close(f);
 }
 
+
 void write_batch_argvs_file(int argc, char *argv[])
 {
-	int fdb;
+	int f;
 	int i;
 	char buff[256]; /* XXX */
 	char buff2[MAXPATHLEN + 6];
 	char filename[MAXPATHLEN];
 
-	/* Set up file extension */
-	strlcpy(filename, batch_prefix, sizeof(filename));
-	strlcat(filename, rsync_argvs_file, sizeof(filename));
-
-	/*
-	 * Open batch argvs file for writing;
-	 * create it if it doesn't exist
-	 */
-	fdb = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-		      S_IREAD | S_IWRITE | S_IEXEC);
-	if (fdb == -1) {
+	stringjoin(filename, sizeof filename,
+	    batch_prefix, rsync_argvs_file, NULL);
+
+	f = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
+	    S_IRUSR | S_IWUSR | S_IEXEC);
+	if (f < 0) {
 		rprintf(FERROR, "Batch file %s open error: %s\n",
-			filename, strerror(errno));
-		close(fdb);
+		    filename, strerror(errno));
 		exit_cleanup(1);
 	}
 	buff[0] = '\0';
 
 	/* Write argvs info to batch file */
 
 	for (i = 0; i < argc; ++i) {
 		if (i == argc - 2) /* Skip source directory on cmdline */
-		    continue;
+			continue;
 		/*
 		 * FIXME:
 		 * I think directly manipulating argv[] is probably bogus
 		 */
 		if (!strncmp(argv[i], "--write-batch",
-			strlen("--write-batch"))) {
+		    strlen("--write-batch"))) {
 			/* Safer to change it here than script */
 			/*
 			 * Change to --read-batch=prefix
 			 * to get ready for remote
 			 */
-			strlcat(buff, "--read-batch=", sizeof(buff));
-			strlcat(buff, batch_prefix, sizeof(buff));
+			strlcat(buff, "--read-batch=", sizeof buff);
+			strlcat(buff, batch_prefix, sizeof buff);
 		} else
 		if (i == argc - 1) {
-		    snprintf(buff2, sizeof(buff2), "${1:-%s}", argv[i]);
-		    strlcat(buff, buff2, sizeof(buff));
+			snprintf(buff2, sizeof buff2, "${1:-%s}", argv[i]);
+			strlcat(buff, buff2, sizeof buff);
 		}
 		else {
-			strlcat(buff, argv[i], sizeof(buff));
+			strlcat(buff, argv[i], sizeof buff);
 		}
 
 		if (i < (argc - 1)) {
-			strlcat(buff, " ", sizeof(buff));
+			strlcat(buff, " ", sizeof buff);
 		}
 	}
-	strlcat(buff, "\n", sizeof(buff));
-	if (!write(fdb, buff, strlen(buff))) {
+	strlcat(buff, "\n", sizeof buff);
+	if (!write(f, buff, strlen(buff))) {
 		rprintf(FERROR, "Batch file %s write error: %s\n",
-			filename, strerror(errno));
-		close(fdb);
+		    filename, strerror(errno));
+		close(f);
 		exit_cleanup(1);
 	}
-	close(fdb);
+	close(f);
 }
 
 struct file_list *create_flist_from_batch(void)
 {
-	unsigned char flags;
-
-	fdb_open = 1;
-	fdb_close = 0;
-
-	batch_flist = new(struct file_list);
-	if (!batch_flist) {
-		out_of_memory("create_flist_from_batch");
-	}
-	batch_flist->count = 0;
-	batch_flist->malloced = 1000;
-	batch_flist->files = new_array(struct file_struct *,
-				       batch_flist->malloced);
-	if (!batch_flist->files) {
-		out_of_memory("create_flist_from_batch");
-	}
-
-	for (flags = read_batch_flags(); flags; flags = read_batch_flags()) {
-
-		int i = batch_flist->count;
-
-		if (i >= batch_flist->malloced) {
-			if (batch_flist->malloced < 1000)
-				batch_flist->malloced += 1000;
-			else
-				batch_flist->malloced *= 2;
-			batch_flist->files
-				= realloc_array(batch_flist->files,
-						struct file_struct *,
-						batch_flist->malloced);
-			if (!batch_flist->files)
-				out_of_memory("create_flist_from_batch");
-		}
-		read_batch_flist_info(&batch_flist->files[i]);
-		batch_flist->files[i]->flags = flags;
-
-		batch_flist->count++;
-	}
-
-	return batch_flist;
-}
-
-int read_batch_flist_file(char *buff, int len)
-{
-	int bytes_read;
 	char filename[MAXPATHLEN];
+	unsigned short flags;
+	int i, f, save_pv;
+	int64 save_read;
 
-	if (fdb_open) {
-		/* Set up file extension */
-		strlcpy(filename, batch_prefix, sizeof(filename));
-		strlcat(filename, rsync_flist_file, sizeof(filename));
-
-		/* Open batch flist file for reading */
-		fdb = do_open(filename, O_RDONLY, 0);
-		if (fdb == -1) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-				filename, strerror(errno));
-			close(fdb);
-			exit_cleanup(1);
-		}
-		fdb_open = 0;
-	}
-
-	/* Read flist batch file */
+	stringjoin(filename, sizeof filename,
+	    batch_prefix, rsync_flist_file, NULL);
 
-	switch (bytes_read = read(fdb, buff, len)) {
-	    case -1:
-		rprintf(FERROR, "Batch file %s read error: %s\n",
-			filename, strerror(errno));
-		close(fdb);
+	f = do_open(filename, O_RDONLY, 0);
+	if (f < 0) {
+		rprintf(FERROR, "Batch file %s open error: %s\n",
+		    filename, strerror(errno));
 		exit_cleanup(1);
-		break;
-	    case 0:	/* EOF */
-		close(fdb);
 	}
 
-	return bytes_read;
-}
-
-unsigned char read_batch_flags(void)
-{
-	int flags;
-
-	if (read_batch_flist_file((char *) &flags, 4)) {
-		return 1;
-	} else {
-		return 0;
-	}
-}
+	batch_flist = flist_new(WITH_HLINK, "create_flist_from_batch");
 
-void read_batch_flist_info(struct file_struct **fptr)
-{
-	int int_str_len;
-	char char_str_len[4];
-	char buff[256];
-	struct file_struct *file;
-
-	file = new(struct file_struct);
-	if (!file)
-		out_of_memory("read_batch_flist_info");
-	memset((char *) file, 0, sizeof(*file));
-
-	*fptr = file;
-
-	/*
-	 * Keep these in sync with bytes_to_write assignment
-	 * in write_batch_flist_info()
-	 */
-	read_batch_flist_file((char *) &file->modtime, sizeof(time_t));
-	read_batch_flist_file((char *) &file->length, sizeof(OFF_T));
-	read_batch_flist_file((char *) &file->mode, sizeof(mode_t));
-	read_batch_flist_file((char *) &file->inode, sizeof(INO64_T));
-	read_batch_flist_file((char *) &file->dev, sizeof(DEV64_T));
-	read_batch_flist_file((char *) &file->rdev, sizeof(DEV64_T));
-	read_batch_flist_file((char *) &file->uid, sizeof(uid_t));
-	read_batch_flist_file((char *) &file->gid, sizeof(gid_t));
-	read_batch_flist_file(char_str_len, sizeof(char_str_len));
-	int_str_len = IVAL(char_str_len, 0);
-	if (int_str_len > 0) {
-		read_batch_flist_file(buff, int_str_len);
-		buff[int_str_len] = '\0';
-		file->basename = strdup(buff);
-	} else {
-		file->basename = NULL;
-	}
+	save_read = stats.total_read;
+	save_pv = protocol_version;
+	protocol_version = read_int(f);
 
-	read_batch_flist_file(char_str_len, sizeof(char_str_len));
-	int_str_len = IVAL(char_str_len, 0);
-	if (int_str_len > 0) {
-		read_batch_flist_file(buff, int_str_len);
-		buff[int_str_len] = '\0';
-		file[0].dirname = strdup(buff);
-	} else {
-		file[0].dirname = NULL;
-	}
+	batch_flist->count = read_int(f);
+	flist_expand(batch_flist);
 
-	read_batch_flist_file(char_str_len, sizeof(char_str_len));
-	int_str_len = IVAL(char_str_len, 0);
-	if (int_str_len > 0) {
-		read_batch_flist_file(buff, int_str_len);
-		buff[int_str_len] = '\0';
-		file[0].basedir = strdup(buff);
-	} else {
-		file[0].basedir = NULL;
+	for (i = 0; (flags = read_byte(f)) != 0; i++) {
+		if (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))
+			flags |= read_byte(f) << 8;
+		receive_file_entry(&batch_flist->files[i], flags, batch_flist, f);
 	}
+	receive_file_entry(NULL, 0, NULL, 0); /* Signal that we're done. */
 
-	read_batch_flist_file(char_str_len, sizeof(char_str_len));
-	int_str_len = IVAL(char_str_len, 0);
-	if (int_str_len > 0) {
-		read_batch_flist_file(buff, int_str_len);
-		buff[int_str_len] = '\0';
-		file[0].link = strdup(buff);
-	} else {
-		file[0].link = NULL;
-	}
+	protocol_version = save_pv;
+	stats.total_read = save_read;
 
-	read_batch_flist_file(char_str_len, sizeof(char_str_len));
-	int_str_len = IVAL(char_str_len, 0);
-	if (int_str_len > 0) {
-		read_batch_flist_file(buff, int_str_len);
-		buff[int_str_len] = '\0';
-		file[0].sum = strdup(buff);
-	} else {
-		file[0].sum = NULL;
-	}
+	return batch_flist;
 }
 
 void write_batch_csums_file(void *buff, int bytes_to_write)
 {
-	static int fdb_open = 1;
-	char filename[MAXPATHLEN];
-
-	if (fdb_open) {
-		/* Set up file extension */
-		strlcpy(filename, batch_prefix, sizeof(filename));
-		strlcat(filename, rsync_csums_file, sizeof(filename));
-
-		/*
-		 * Open batch csums file for writing;
-		 * create it if it doesn't exist
-		 */
-		fdb = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-			    S_IREAD | S_IWRITE);
-		if (fdb == -1) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-				filename, strerror(errno));
-			close(fdb);
-			exit_cleanup(1);
-		}
-		fdb_open = 0;
-	}
-
-	/* Write buffer to batch csums file */
-
-	if (write(fdb, buff, bytes_to_write) == -1) {
-		rprintf(FERROR, "Batch file %s write error: %s\n",
-			filename, strerror(errno));
-		close(fdb);
+	if (write(f_csums, buff, bytes_to_write) < 0) {
+		rprintf(FERROR, "Batch file write error: %s\n",
+		    strerror(errno));
+		close(f_csums);
 		exit_cleanup(1);
 	}
 }
 
 void close_batch_csums_file(void)
 {
-	close(fdb);
+	close(f_csums);
+	f_csums = -1;
 }
 
 
 /**
- * Write csum info to batch file 
+ * Write csum info to batch file
  *
  * @todo This will break if s->count is ever larger than maxint.  The
  * batch code should probably be changed to consistently use the
  * variable-length integer routines, which is probably a compatible
  * change.
  **/
-void write_batch_csum_info(int *flist_entry, int flist_count,
-			   struct sum_struct *s)
+void write_batch_csum_info(int *flist_entry, struct sum_struct *s)
 {
 	size_t i;
 	int int_count;
-	extern int csum_length;
+	char filename[MAXPATHLEN];
 
-	fdb_open = 1;
+	if (f_csums < 0) {
+		stringjoin(filename, sizeof filename,
+		    batch_prefix, rsync_csums_file, NULL);
+
+		f_csums = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
+		    S_IRUSR | S_IWUSR);
+		if (f_csums < 0) {
+			rprintf(FERROR, "Batch file %s open error: %s\n",
+			    filename, strerror(errno));
+			close(f_csums);
+			exit_cleanup(1);
+		}
+	}
 
-	write_batch_csums_file(flist_entry, sizeof(int));
+	write_batch_csums_file(flist_entry, sizeof (int));
 	int_count = s ? (int) s->count : 0;
 	write_batch_csums_file(&int_count, sizeof int_count);
-	
+
 	if (s) {
 		for (i = 0; i < s->count; i++) {
-			write_batch_csums_file(&s->sums[i].sum1, sizeof(uint32));
-			if ((*flist_entry == flist_count - 1)
-			    && (i == s->count - 1)) {
-				fdb_close = 1;
-			}
+			write_batch_csums_file(&s->sums[i].sum1,
+			    sizeof (uint32));
 			write_batch_csums_file(s->sums[i].sum2, csum_length);
 		}
 	}
 }
 
 int read_batch_csums_file(char *buff, int len)
 {
-	static int fdb_open = 1;
 	int bytes_read;
-	char filename[MAXPATHLEN];
-
-	if (fdb_open) {
-		/* Set up file extension */
-		strlcpy(filename, batch_prefix, sizeof(filename));
-		strlcat(filename, rsync_csums_file, sizeof(filename));
-
-		/* Open batch flist file for reading */
-		fdb = do_open(filename, O_RDONLY, 0);
-		if (fdb == -1) {
-			rprintf(FERROR, "Batch file %s open error: %s\n",
-				filename, strerror(errno));
-			close(fdb);
-			exit_cleanup(1);
-		}
-		fdb_open = 0;
-	}
-
-	/* Read csums batch file */
 
-	bytes_read = read(fdb, buff, len);
-
-	if (bytes_read == -1) {
-		rprintf(FERROR, "Batch file %s read error: %s\n",
-			filename, strerror(errno));
-		close(fdb);
+	if ((bytes_read = read(f_csums, buff, len)) < 0) {
+		rprintf(FERROR, "Batch file read error: %s\n", strerror(errno));
+		close(f_csums);
 		exit_cleanup(1);
 	}
-
 	return bytes_read;
 }
 
 void read_batch_csum_info(int flist_entry, struct sum_struct *s,
 			  int *checksums_match)
 {
@@ -462,110 +233,103 @@
 {
 	int i;
 	int file_flist_entry;
 	int file_chunk_ct;
 	uint32 file_sum1;
 	char file_sum2[SUM_LENGTH];
-	extern int csum_length;
+	char filename[MAXPATHLEN];
+
+	if (f_csums < 0) {
+		stringjoin(filename, sizeof filename,
+		    batch_prefix, rsync_csums_file, NULL);
 
-	read_batch_csums_file((char *) &file_flist_entry, sizeof(int));
+		f_csums = do_open(filename, O_RDONLY, 0);
+		if (f_csums < 0) {
+			rprintf(FERROR, "Batch file %s open error: %s\n",
+			    filename, strerror(errno));
+			close(f_csums);
+			exit_cleanup(1);
+		}
+	}
+
+	read_batch_csums_file((char *) &file_flist_entry, sizeof (int));
 	if (file_flist_entry != flist_entry) {
 		rprintf(FINFO, "file_flist_entry (%d) != flist_entry (%d)\n",
-			file_flist_entry, flist_entry);
-		close(fdb);
+		    file_flist_entry, flist_entry);
+		close(f_csums);
 		exit_cleanup(1);
 
 	} else {
-		read_batch_csums_file((char *) &file_chunk_ct,
-				      sizeof(int));
+		read_batch_csums_file((char *) &file_chunk_ct, sizeof (int));
 		*checksums_match = 1;
 		for (i = 0; i < file_chunk_ct; i++) {
-
 			read_batch_csums_file((char *) &file_sum1,
-					      sizeof(uint32));
+			    sizeof (uint32));
 			read_batch_csums_file(file_sum2, csum_length);
 
-			if ((s->sums[i].sum1 != file_sum1) ||
-			    (memcmp(s->sums[i].sum2, file_sum2, csum_length)
-				!= 0)) {
+			if ((s->sums[i].sum1 != file_sum1)
+			    || memcmp(s->sums[i].sum2, file_sum2, csum_length))
 				*checksums_match = 0;
-			}
 		}		/*  end for  */
 	}
 }
 
 void write_batch_delta_file(char *buff, int bytes_to_write)
 {
-	static int fdb_delta_open = 1;
 	char filename[MAXPATHLEN];
 
-	if (fdb_delta_open) {
-		/* Set up file extension */
-		strlcpy(filename, batch_prefix, sizeof(filename));
-		strlcat(filename, rsync_delta_file, sizeof(filename));
-
-		/*
-		 * Open batch delta file for writing;
-		 * create it if it doesn't exist
-		 */
-		fdb_delta = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
-			    S_IREAD | S_IWRITE);
-		if (fdb_delta == -1) {
+	if (f_delta < 0) {
+		stringjoin(filename, sizeof filename,
+		    batch_prefix, rsync_delta_file, NULL);
+
+		f_delta = do_open(filename, O_WRONLY | O_CREAT | O_TRUNC,
+				  S_IRUSR | S_IWUSR);
+		if (f_delta < 0) {
 			rprintf(FERROR, "Batch file %s open error: %s\n",
 				filename, strerror(errno));
-			close(fdb_delta);
 			exit_cleanup(1);
 		}
-		fdb_delta_open = 0;
 	}
 
-	/* Write buffer to batch delta file */
-
-	if (write(fdb_delta, buff, bytes_to_write) == -1) {
+	if (write(f_delta, buff, bytes_to_write) < 0) {
 		rprintf(FERROR, "Batch file %s write error: %s\n",
-			filename, strerror(errno));
-		close(fdb_delta);
+		    filename, strerror(errno));
+		close(f_delta);
 		exit_cleanup(1);
 	}
 }
 
 void close_batch_delta_file(void)
 {
-	close(fdb_delta);
+	close(f_delta);
+	f_delta = -1;
 }
 
 int read_batch_delta_file(char *buff, int len)
 {
-	static int fdb_delta_open = 1;
 	int bytes_read;
 	char filename[MAXPATHLEN];
 
-	if (fdb_delta_open) {
-		/* Set up file extension */
-		strlcpy(filename, batch_prefix, sizeof(filename));
-		strlcat(filename, rsync_delta_file, sizeof(filename));
-
-		/* Open batch flist file for reading */
-		fdb_delta = do_open(filename, O_RDONLY, 0);
-		if (fdb_delta == -1) {
+	if (f_delta < 0) {
+		stringjoin(filename, sizeof filename,
+		    batch_prefix, rsync_delta_file, NULL);
+
+		f_delta = do_open(filename, O_RDONLY, 0);
+		if (f_delta < 0) {
 			rprintf(FERROR, "Batch file %s open error: %s\n",
-				filename, strerror(errno));
-			close(fdb_delta);
+			    filename, strerror(errno));
+			close(f_delta);
 			exit_cleanup(1);
 		}
-		fdb_delta_open = 0;
 	}
 
-	/* Read delta batch file */
-
-	bytes_read = read(fdb_delta, buff, len);
-
-	if (bytes_read == -1) {
+	bytes_read = read(f_delta, buff, len);
+	if (bytes_read < 0) {
 		rprintf(FERROR, "Batch file %s read error: %s\n",
-			filename, strerror(errno));
-		close(fdb_delta);
+		    filename, strerror(errno));
+		close(f_delta);
 		exit_cleanup(1);
 	}
 
 	return bytes_read;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/checksum.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/checksum.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/checksum.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/checksum.c	2004-02-10 02:32:52.000000000 +0800
@@ -20,13 +20,13 @@
 #include "rsync.h"
 
 int csum_length=2; /* initial value */
 
 #define CSUM_CHUNK 64
 
-int checksum_seed = 0;
+extern int checksum_seed;
 extern int protocol_version;
 
 /*
   a simple 32 bit checksum that can be upadted from either end
   (inspired by Mark Adler's Adler-32 checksum)
   */
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/cleanup.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/cleanup.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/cleanup.c	2003-12-15 16:08:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/cleanup.c	2004-01-27 16:14:33.000000000 +0800
@@ -69,13 +69,13 @@
 
 static char *cleanup_fname;
 static char *cleanup_new_fname;
 static struct file_struct *cleanup_file;
 static int cleanup_fd1, cleanup_fd2;
 static struct map_struct *cleanup_buf;
-static int cleanup_pid = 0;
+static pid_t cleanup_pid = 0;
 extern int io_error;
 
 pid_t cleanup_child_pid = -1;
 
 /**
  * Eventually calls exit(), passing @p code, therefore does not return.
@@ -115,19 +115,19 @@
 		cleanup_fname = NULL;
 		if (cleanup_buf) unmap_file(cleanup_buf);
 		if (cleanup_fd1 != -1) close(cleanup_fd1);
 		if (cleanup_fd2 != -1) close(cleanup_fd2);
 		finish_transfer(cleanup_new_fname, fname, cleanup_file);
 	}
-	io_flush();
+	io_flush(FULL_FLUSH);
 	if (cleanup_fname)
 		do_unlink(cleanup_fname);
 	if (code) {
 		kill_all(SIGUSR1);
 	}
-	if ((cleanup_pid != 0) && (cleanup_pid == (int) getpid())) {
+	if (cleanup_pid && cleanup_pid == getpid()) {
 		char *pidf = lp_pid_file();
 		if (pidf && *pidf) {
 			unlink(lp_pid_file());
 		}
 	}
 
@@ -163,10 +163,10 @@
 	cleanup_file = file;
 	cleanup_buf = buf;
 	cleanup_fd1 = fd1;
 	cleanup_fd2 = fd2;
 }
 
-void cleanup_set_pid(int pid)
+void cleanup_set_pid(pid_t pid)
 {
 	cleanup_pid = pid;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/clientname.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/clientname.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/clientname.c	2003-01-11 10:05:56.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/clientname.c	2004-04-02 05:39:35.000000000 +0800
@@ -1,31 +1,31 @@
 /* -*- c-file-style: "linux" -*-
-   
+
    rsync -- fast file replication program
-   
+
    Copyright (C) 1992-2001 by Andrew Tridgell <tridge@samba.org>
    Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /**
  * @file clientname.c
- * 
+ *
  * Functions for looking up the remote name or addr of a socket.
  *
  * This file is now converted to use the new-style getaddrinfo()
  * interface, which supports IPv6 but is also supported on recent
  * IPv4-only machines.  On systems that don't have that interface, we
  * emulate it using the KAME implementation.
@@ -36,36 +36,35 @@
 static const char default_name[] = "UNKNOWN";
 extern int am_daemon;
 extern int am_server;
 
 
 /**
- * Return the IP addr of the client as a string 
+ * Return the IP addr of the client as a string
  **/
 char *client_addr(int fd)
 {
 	struct sockaddr_storage ss;
 	socklen_t length = sizeof ss;
 	char *ssh_client, *p;
 	int len;
 	static char addr_buf[100];
 	static int initialised;
 
-	if (initialised) return addr_buf;
+	if (initialised)
+		return addr_buf;
 
 	initialised = 1;
 
-	if (am_server) {
-		/* daemon over --rsh mode */
+	if (am_server) {	/* daemon over --rsh mode */
 		strcpy(addr_buf, "0.0.0.0");
 		if ((ssh_client = getenv("SSH_CLIENT")) != NULL) {
 			/* truncate SSH_CLIENT to just IP address */
-			p = strchr(ssh_client, ' ');
-			if (p) {
-				len = MIN((unsigned int) (p - ssh_client), 
-						sizeof(addr_buf) - 1);
+			if ((p = strchr(ssh_client, ' ')) != NULL) {
+				len = MIN((unsigned int) (p - ssh_client),
+				    sizeof addr_buf - 1);
 				strncpy(addr_buf, ssh_client, len);
 				*(addr_buf + len) = '\0';
 			}
 		}
 	} else {
 		client_sockaddr(fd, &ss, &length);
@@ -98,64 +97,60 @@
  **/
 char *client_name(int fd)
 {
 	static char name_buf[100];
 	static char port_buf[100];
 	static int initialised;
-	struct sockaddr_storage ss, *ssp;
-	struct sockaddr_in sin;
-#ifdef INET6
-	struct sockaddr_in6 sin6;
-#endif
+	struct sockaddr_storage ss;
 	socklen_t ss_len;
 
-	if (initialised) return name_buf;
+	if (initialised)
+		return name_buf;
 
 	strcpy(name_buf, default_name);
 	initialised = 1;
 
-	if (am_server) {
-		/* daemon over --rsh mode */
+	memset(&ss, 0, sizeof ss);
 
+	if (am_server) {	/* daemon over --rsh mode */
 		char *addr = client_addr(fd);
-#ifdef INET6
-		int dots = 0;
-		char *p;
+		struct addrinfo hint, *answer;
+		int err;
+
+		memset(&hint, 0, sizeof hint);
+
+		hint.ai_flags = AI_NUMERICHOST;
+		hint.ai_socktype = SOCK_STREAM;
 
-		for (p = addr; *p && (dots <= 3); p++) {
-		    if (*p == '.')
-			dots++;
+		if ((err = getaddrinfo(addr, NULL, &hint, &answer)) != 0) {
+			rprintf(FERROR, RSYNC_NAME ": malformed address %s: %s\n",
+			        addr, gai_strerror(err));
+			return name_buf;
 		}
-		if (dots > 3) {
-			/* more than 4 parts to IP address, must be ipv6 */
-			ssp = (struct sockaddr_storage *) &sin6;
-			ss_len = sizeof sin6;
-			memset(ssp, 0, ss_len);
-			inet_pton(AF_INET6, addr, &sin6.sin6_addr);
-			sin6.sin6_family = AF_INET6;
-		} else
+
+		switch (answer->ai_family) {
+		case AF_INET:
+			ss_len = sizeof (struct sockaddr_in);
+			memcpy(&ss, answer->ai_addr, ss_len);
+			break;
+#ifdef INET6
+		case AF_INET6:
+			ss_len = sizeof (struct sockaddr_in6);
+			memcpy(&ss, answer->ai_addr, ss_len);
+			break;
 #endif
-		{
-			ssp = (struct sockaddr_storage *) &sin;
-			ss_len = sizeof sin;
-			memset(ssp, 0, ss_len);
-			inet_pton(AF_INET, addr, &sin.sin_addr);
-			sin.sin_family = AF_INET;
 		}
-
+		freeaddrinfo(answer);
 	} else {
 		ss_len = sizeof ss;
-		ssp = &ss;
-
 		client_sockaddr(fd, &ss, &ss_len);
-
 	}
 
-	if (!lookup_name(fd, ssp, ss_len, name_buf, sizeof name_buf, 
+	if (!lookup_name(fd, &ss, ss_len, name_buf, sizeof name_buf,
 			port_buf, sizeof port_buf))
-		check_name(fd, ssp, name_buf);
+		check_name(fd, &ss, name_buf);
 
 	return name_buf;
 }
 
 
 
@@ -166,48 +161,48 @@
  * convert it back to a regular IPv4.
  **/
 void client_sockaddr(int fd,
 		     struct sockaddr_storage *ss,
 		     socklen_t *ss_len)
 {
-	memset(ss, 0, sizeof(*ss));
+	memset(ss, 0, sizeof *ss);
 
 	if (getpeername(fd, (struct sockaddr *) ss, ss_len)) {
 		/* FIXME: Can we really not continue? */
 		rprintf(FERROR, RSYNC_NAME ": getpeername on fd%d failed: %s\n",
 			fd, strerror(errno));
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
 #ifdef INET6
-        if (get_sockaddr_family(ss) == AF_INET6 && 
+	if (get_sockaddr_family(ss) == AF_INET6 &&
 	    IN6_IS_ADDR_V4MAPPED(&((struct sockaddr_in6 *)ss)->sin6_addr)) {
 		/* OK, so ss is in the IPv6 family, but it is really
 		 * an IPv4 address: something like
 		 * "::ffff:10.130.1.2".  If we use it as-is, then the
 		 * reverse lookup might fail or perhaps something else
 		 * bad might happen.  So instead we convert it to an
 		 * equivalent address in the IPv4 address family.  */
 		struct sockaddr_in6 sin6;
 		struct sockaddr_in *sin;
 
-		memcpy(&sin6, ss, sizeof(sin6));
+		memcpy(&sin6, ss, sizeof sin6);
 		sin = (struct sockaddr_in *)ss;
-		memset(sin, 0, sizeof(*sin));
+		memset(sin, 0, sizeof *sin);
 		sin->sin_family = AF_INET;
-		*ss_len = sizeof(struct sockaddr_in);
-#ifdef HAVE_SOCKADDR_LEN
+		*ss_len = sizeof (struct sockaddr_in);
+#if HAVE_SOCKADDR_IN_LEN
 		sin->sin_len = *ss_len;
 #endif
 		sin->sin_port = sin6.sin6_port;
 
 		/* There is a macro to extract the mapped part
 		 * (IN6_V4MAPPED_TO_SINADDR ?), but it does not seem
 		 * to be present in the Linux headers. */
 		memcpy(&sin->sin_addr, &sin6.sin6_addr.s6_addr[12],
-			sizeof(sin->sin_addr));
+		    sizeof sin->sin_addr);
         }
 #endif
 }
 
 
 /**
@@ -218,13 +213,13 @@
 int lookup_name(int fd, const struct sockaddr_storage *ss,
 		socklen_t ss_len,
 		char *name_buf, size_t name_buf_len,
 		char *port_buf, size_t port_buf_len)
 {
 	int name_err;
-	
+
 	/* reverse lookup */
 	name_err = getnameinfo((struct sockaddr *) ss, ss_len,
 			       name_buf, name_buf_len,
 			       port_buf, port_buf_len,
 			       NI_NAMEREQD | NI_NUMERICSERV);
 	if (name_err != 0) {
@@ -247,13 +242,13 @@
  **/
 int compare_addrinfo_sockaddr(const struct addrinfo *ai,
 			      const struct sockaddr_storage *ss)
 {
 	int ss_family = get_sockaddr_family(ss);
 	const char fn[] = "compare_addrinfo_sockaddr";
-		      
+
 	if (ai->ai_family != ss_family) {
 		rprintf(FERROR,
 			"%s: response family %d != %d\n",
 			fn, ai->ai_family, ss_family);
 		return 1;
 	}
@@ -261,24 +256,25 @@
 	/* The comparison method depends on the particular AF. */
 	if (ss_family == AF_INET) {
 		const struct sockaddr_in *sin1, *sin2;
 
 		sin1 = (const struct sockaddr_in *) ss;
 		sin2 = (const struct sockaddr_in *) ai->ai_addr;
-		
+
 		return memcmp(&sin1->sin_addr, &sin2->sin_addr,
 			      sizeof sin1->sin_addr);
 	}
+
 #ifdef INET6
-	else if (ss_family == AF_INET6) {
+	if (ss_family == AF_INET6) {
 		const struct sockaddr_in6 *sin1, *sin2;
 
 		sin1 = (const struct sockaddr_in6 *) ss;
 		sin2 = (const struct sockaddr_in6 *) ai->ai_addr;
 
-		if (ai->ai_addrlen < sizeof(struct sockaddr_in6)) {
+		if (ai->ai_addrlen < sizeof (struct sockaddr_in6)) {
 			rprintf(FERROR,
 				"%s: too short sockaddr_in6; length=%d\n",
 				fn, ai->ai_addrlen);
 			return 1;
 		}
 
@@ -290,16 +286,15 @@
 		if (sin1->sin6_scope_id != sin2->sin6_scope_id)
 			return 1;
 #endif
 		return 0;
 	}
 #endif /* INET6 */
-	else {
-		/* don't know */
-		return 1;
-	}
+
+	/* don't know */
+	return 1;
 }
 
 
 /**
  * Do a forward lookup on @p name_buf and make sure it corresponds to
  * @p ss -- otherwise we may be being spoofed.  If we suspect we are,
@@ -315,13 +310,13 @@
 	       char *name_buf)
 {
 	struct addrinfo hints, *res, *res0;
 	int error;
 	int ss_family = get_sockaddr_family(ss);
 
-	memset(&hints, 0, sizeof(hints));
+	memset(&hints, 0, sizeof hints);
 	hints.ai_family = ss_family;
 	hints.ai_flags = AI_CANONNAME;
 	hints.ai_socktype = SOCK_STREAM;
 	error = getaddrinfo(name_buf, NULL, &hints, &res0);
 	if (error) {
 		rprintf(FERROR,
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/clientserver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/clientserver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/clientserver.c	2003-09-11 12:00:19.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/clientserver.c	2004-04-15 07:33:34.000000000 +0800
@@ -24,23 +24,37 @@
  * The socket based protocol for setting up a connection with
  * rsyncd.
  **/
 
 #include "rsync.h"
 
+extern int am_sender;
+extern int am_server;
+extern int am_daemon;
+extern int am_root;
 extern int module_id;
 extern int read_only;
 extern int verbose;
 extern int rsync_port;
-char *auth_user;
+extern int kludge_around_eof;
+extern int daemon_over_rsh;
+extern int list_only;
 extern int sanitize_paths;
 extern int filesfrom_fd;
 extern int remote_protocol;
 extern int protocol_version;
-extern struct exclude_struct **server_exclude_list;
+extern int io_timeout;
+extern int orig_umask;
+extern int no_detach;
+extern int default_af_hint;
+extern char *bind_address;
+extern struct exclude_list_struct server_exclude_list;
 extern char *exclude_path_prefix;
+extern char *config_file;
+
+char *auth_user;
 
 /**
  * Run a client connected to an rsyncd.  The alternative to this
  * function for remote-shell connections is do_cmd().
  *
  * After negotiating which module to use and reading the server's
@@ -54,14 +68,12 @@
  * Either way, it eventually gets passed to exit_cleanup().
  **/
 int start_socket_client(char *host, char *path, int argc, char *argv[])
 {
 	int fd, ret;
 	char *p, *user=NULL;
-	extern char *bind_address;
-	extern int default_af_hint;
 
 	/* this is redundant with code in start_inband_exchange(), but
 	 * this short-circuits a problem before we open a socket, and
 	 * the extra check won't hurt */
 	if (*path == '/') {
 		rprintf(FERROR,"ERROR: The remote path must start with a module name not a /\n");
@@ -72,24 +84,16 @@
 	if (p) {
 		user = host;
 		host = p+1;
 		*p = 0;
 	}
 
-	if (verbose >= 2) {
-		/* FIXME: If we're going to use a socket program for
-		 * testing, then this message is wrong.  We need to
-		 * say something like "(except really using %s)" */
-		rprintf(FINFO, "opening tcp connection to %s port %d\n",
-			host, rsync_port);
-	}
 	fd = open_socket_out_wrapped(host, rsync_port, bind_address,
 				     default_af_hint);
-	if (fd == -1) {
+	if (fd == -1)
 		exit_cleanup(RERR_SOCKETIO);
-	}
 
 	ret = start_inband_exchange(user, path, fd, fd, argc);
 
 	return ret < 0? ret : client_run(fd, fd, -1, argc, argv);
 }
 
@@ -97,16 +101,12 @@
 {
 	int i;
 	char *sargs[MAX_ARGS];
 	int sargc = 0;
 	char line[MAXPATHLEN];
 	char *p;
-	extern int kludge_around_eof;
-	extern int am_sender;
-	extern int daemon_over_rsh;
-	extern int list_only;
 
 	if (argc == 0 && !am_sender)
 		list_only = 1;
 
 	if (*path == '/') {
 		rprintf(FERROR, "ERROR: The remote path must start with a module name\n");
@@ -126,13 +126,13 @@
 
 	if (path && *path)
 		sargs[sargc++] = path;
 
 	sargs[sargc] = NULL;
 
-	io_printf(f_out, "@RSYNCD: %d\n", PROTOCOL_VERSION);
+	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
 
 	if (!read_line(f_in, line, sizeof(line)-1)) {
 		rprintf(FERROR, "rsync: did not see server greeting\n");
 		return -1;
 	}
 
@@ -189,13 +189,13 @@
 	for (i = 0; i < sargc; i++) {
 		io_printf(f_out, "%s\n", sargs[i]);
 	}
 	io_printf(f_out, "\n");
 
 	if (protocol_version < 23) {
-		if (protocol_version == 22 || (protocol_version > 17 && !am_sender))
+		if (protocol_version == 22 || !am_sender)
 			io_start_multiplex_in(f_in);
 	}
 
 	return 0;
 }
 
@@ -214,16 +214,12 @@
 	char *host = client_name(f_in);
 	char *name = lp_name(i);
 	int use_chroot = lp_use_chroot(i);
 	int start_glob=0;
 	int ret;
 	char *request=NULL;
-	extern int am_sender;
-	extern int am_server;
-	extern int am_daemon;
-	extern int am_root;
 
 	if (!allow_access(addr, host, lp_hosts_allow(i), lp_hosts_deny(i))) {
 		rprintf(FERROR,"rsync denied on module %s from %s (%s)\n",
 			name, host, addr);
 		io_printf(f_out, "@ERROR: access denied to %s from %s (%s)\n",
 			  name, host, addr);
@@ -259,13 +255,13 @@
 		io_printf(f_out, "@ERROR: auth failed on module %s\n", name);
 		return -1;
 	}
 
 	module_id = i;
 
-	am_root = (getuid() == 0);
+	am_root = (MY_UID() == 0);
 
 	if (am_root) {
 		p = lp_uid(i);
 		if (!name_to_uid(p, &uid)) {
 			if (!isdigit(* (unsigned char *) p)) {
 				rprintf(FERROR,"Invalid uid %s\n", p);
@@ -295,22 +291,25 @@
 
 	exclude_path_prefix = use_chroot? "" : lp_path(i);
 	if (*exclude_path_prefix == '/' && !exclude_path_prefix[1])
 		exclude_path_prefix = "";
 
 	p = lp_include_from(i);
-	add_exclude_file(&server_exclude_list, p, MISSING_FATAL, ADD_INCLUDE);
+	add_exclude_file(&server_exclude_list, p,
+			 XFLG_FATAL_ERRORS | XFLG_DEF_INCLUDE);
 
 	p = lp_include(i);
-	add_exclude_line(&server_exclude_list, p, ADD_INCLUDE);
+	add_exclude(&server_exclude_list, p,
+		    XFLG_WORD_SPLIT | XFLG_DEF_INCLUDE);
 
 	p = lp_exclude_from(i);
-	add_exclude_file(&server_exclude_list, p, MISSING_FATAL, ADD_EXCLUDE);
+	add_exclude_file(&server_exclude_list, p,
+			 XFLG_FATAL_ERRORS);
 
 	p = lp_exclude(i);
-	add_exclude_line(&server_exclude_list, p, ADD_EXCLUDE);
+	add_exclude(&server_exclude_list, p, XFLG_WORD_SPLIT);
 
 	exclude_path_prefix = NULL;
 
 	log_init();
 
 	if (use_chroot) {
@@ -329,20 +328,20 @@
 		if (chroot(lp_path(i))) {
 			rsyserr(FERROR, errno, "chroot %s failed", lp_path(i));
 			io_printf(f_out, "@ERROR: chroot failed\n");
 			return -1;
 		}
 
-		if (!push_dir("/", 0)) {
+		if (!push_dir("/")) {
 			rsyserr(FERROR, errno, "chdir %s failed\n", lp_path(i));
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 
 	} else {
-		if (!push_dir(lp_path(i), 0)) {
+		if (!push_dir(lp_path(i))) {
 			rsyserr(FERROR, errno, "chdir %s failed\n", lp_path(i));
 			io_printf(f_out, "@ERROR: chdir failed\n");
 			return -1;
 		}
 		sanitize_paths = 1;
 	}
@@ -376,13 +375,13 @@
 		if (setuid(uid)) {
 			rsyserr(FERROR, errno, "setuid %d failed", (int) uid);
 			io_printf(f_out, "@ERROR: setuid failed\n");
 			return -1;
 		}
 
-		am_root = (getuid() == 0);
+		am_root = (MY_UID() == 0);
 	}
 
 	io_printf(f_out, "@RSYNCD: OK\n");
 
 	argv[argc++] = "rsyncd";
 
@@ -416,25 +415,12 @@
 
 		if (argc == MAX_ARGS) {
 			return -1;
 		}
 	}
 
-	if (sanitize_paths) {
-		/*
-		 * Note that this is applied to all parameters, whether or not
-		 *    they are filenames, but no other legal parameters contain
-		 *    the forms that need to be sanitized so it doesn't hurt;
-		 *    it is not known at this point which parameters are files
-		 *    and which aren't.
-		 */
-		for (i = 1; i < argc; i++) {
-			sanitize_path(argv[i], NULL);
-		}
-	}
-
 	argp = argv;
 	ret = parse_arguments(&argc, (const char ***) &argp, 0);
 
 	if (filesfrom_fd == 0)
 		filesfrom_fd = f_in;
 
@@ -450,17 +436,18 @@
 		}
 		free(request);
 	}
 
 #ifndef DEBUG
 	/* don't allow the logs to be flooded too fast */
-	if (verbose > 1) verbose = 1;
+	if (verbose > lp_max_verbosity())
+		verbose = lp_max_verbosity();
 #endif
 
 	if (protocol_version < 23) {
-		if (protocol_version == 22 || (protocol_version > 17 && am_sender))
+		if (protocol_version == 22 || am_sender)
 			io_start_multiplex_out(f_out);
 	}
 
 	/* For later protocol versions, we don't start multiplexing
 	 * until we've configured nonblocking in start_server.  That
 	 * means we're in a sticky situation now: there's no way to
@@ -472,13 +459,12 @@
 	if (!ret) {
 		option_error();
 		exit_cleanup(RERR_UNSUPPORTED);
 	}
 
 	if (lp_timeout(i)) {
-		extern int io_timeout;
 		io_timeout = lp_timeout(i);
 	}
 
 	start_server(f_in, f_out, argc, argp);
 
 	return 0;
@@ -504,14 +490,12 @@
    here */
 int start_daemon(int f_in, int f_out)
 {
 	char line[200];
 	char *motd;
 	int i = -1;
-	extern char *config_file;
-	extern int am_server;
 
 	if (!lp_load(config_file, 0)) {
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	log_init();
@@ -519,13 +503,13 @@
 	if (!am_server) {
 		set_socket_options(f_in, "SO_KEEPALIVE");
 		set_socket_options(f_in, lp_socket_options());
 		set_nonblocking(f_in);
 	}
 
-	io_printf(f_out, "@RSYNCD: %d\n", PROTOCOL_VERSION);
+	io_printf(f_out, "@RSYNCD: %d\n", protocol_version);
 
 	motd = lp_motd_file();
 	if (motd && *motd) {
 		FILE *f = fopen(motd,"r");
 		while (f && !feof(f)) {
 			int len = fread(line, 1, sizeof(line)-1, f);
@@ -576,16 +560,13 @@
 	return rsync_module(f_in, f_out, i);
 }
 
 
 int daemon_main(void)
 {
-	extern char *config_file;
-	extern int orig_umask;
 	char *pid_file;
-	extern int no_detach;
 
 	if (is_a_socket(STDIN_FILENO)) {
 		int i;
 
 		/* we are running via inetd - close off stdout and
 		 * stderr so that library functions (and getopt) don't
@@ -613,21 +594,21 @@
 	 * address too.  In fact, why not just do inet_ntop on the
 	 * local address??? */
 
 	if (((pid_file = lp_pid_file()) != NULL) && (*pid_file != '\0')) {
 		char pidbuf[16];
 		int fd;
-		int pid = (int) getpid();
+		pid_t pid = getpid();
 		cleanup_set_pid(pid);
 		if ((fd = do_open(lp_pid_file(), O_WRONLY|O_CREAT|O_TRUNC,
 					0666 & ~orig_umask)) == -1) {
 			cleanup_set_pid(0);
 			rsyserr(FLOG, errno, "failed to create pid file %s", pid_file);
 			exit_cleanup(RERR_FILEIO);
 		}
-		snprintf(pidbuf, sizeof(pidbuf), "%d\n", pid);
+		snprintf(pidbuf, sizeof pidbuf, "%ld\n", (long)pid);
 		write(fd, pidbuf, strlen(pidbuf));
 		close(fd);
 	}
 
 	start_accept_loop(rsync_port, start_daemon);
 	return -1;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/compat.c	2003-09-11 12:48:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/compat.c	2004-02-10 02:32:53.000000000 +0800
@@ -82,15 +81,13 @@
 		rprintf(FERROR, "--protocol must be no more than %d on the %s.\n",
 			PROTOCOL_VERSION, am_server? "Server" : "Client");
 		exit_cleanup(RERR_PROTOCOL);
 	}
 
 	if (am_server) {
-		if (read_batch || write_batch)
-			checksum_seed = 32761;
-		else
+		if (!checksum_seed)
 			checksum_seed = time(NULL);
-		write_int(f_out,checksum_seed);
+		write_int(f_out, checksum_seed);
 	} else {
 		checksum_seed = read_int(f_in);
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.guess /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/config.guess
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.guess	2003-01-23 06:24:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/config.guess	2004-03-06 15:00:47.000000000 +0800
@@ -1,12 +1,12 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2003-01-10'
+timestamp='2003-10-03'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
 # (at your option) any later version.
 #
@@ -103,12 +103,13 @@
 set_cc_for_build='
 trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
 trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
 : ${TMPDIR=/tmp} ;
  { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
+ { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
 dummy=$tmp/dummy ;
 tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
 case $CC_FOR_BUILD,$HOST_CC,$CC in
  ,,)    echo "int x;" > $dummy.c ;
 	for c in cc gcc c89 c99 ; do
@@ -232,80 +233,62 @@
     wgrisc:OpenBSD:*:*)
 	echo mipsel-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
     *:OpenBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
-    *:MicroBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-microbsd${UNAME_RELEASE}
-	exit 0 ;;
     alpha:OSF1:*:*)
 	if test $UNAME_RELEASE = "V4.0"; then
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
 	fi
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE="alpha" ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE="alpha" ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE="alphaev5" ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE="alphaev56" ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE="alphapca56" ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE="alphapca57" ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE="alphaev6" ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE="alphaev67" ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE="alphaev68" ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE="alphaev69" ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE="alphaev7" ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE="alphaev79" ;;
+	esac
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
-	eval $set_cc_for_build
-	cat <<EOF >$dummy.s
-	.data
-\$Lformat:
-	.byte 37,100,45,37,120,10,0	# "%d-%x\n"
-
-	.text
-	.globl main
-	.align 4
-	.ent main
-main:
-	.frame \$30,16,\$26,0
-	ldgp \$29,0(\$27)
-	.prologue 1
-	.long 0x47e03d80 # implver \$0
-	lda \$2,-1
-	.long 0x47e20c21 # amask \$2,\$1
-	lda \$16,\$Lformat
-	mov \$0,\$17
-	not \$1,\$18
-	jsr \$26,printf
-	ldgp \$29,0(\$26)
-	mov 0,\$16
-	jsr \$26,exit
-	.end main
-EOF
-	$CC_FOR_BUILD -o $dummy $dummy.s 2>/dev/null
-	if test "$?" = 0 ; then
-		case `$dummy` in
-			0-0)
-				UNAME_MACHINE="alpha"
-				;;
-			1-0)
-				UNAME_MACHINE="alphaev5"
-				;;
-			1-1)
-				UNAME_MACHINE="alphaev56"
-				;;
-			1-101)
-				UNAME_MACHINE="alphapca56"
-				;;
-			2-303)
-				UNAME_MACHINE="alphaev6"
-				;;
-			2-307)
-				UNAME_MACHINE="alphaev67"
-				;;
-			2-1307)
-				UNAME_MACHINE="alphaev68"
-				;;
-			3-1307)
-				UNAME_MACHINE="alphaev7"
-				;;
-		esac
-	fi
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
 	exit 0 ;;
+    Alpha*:OpenVMS:*:*)
+	echo alpha-hp-vms
+	exit 0 ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
 	# of the specific Alpha model?
 	echo alpha-pc-interix
 	exit 0 ;;
@@ -338,12 +321,15 @@
 		echo pyramid-pyramid-bsd
 	fi
 	exit 0 ;;
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
 	exit 0 ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit 0 ;;
     DRS?6000:UNIX_SV:4.2*:7*)
 	case `/usr/bin/uname -p` in
 	    sparc) echo sparc-icl-nx7 && exit 0 ;;
 	esac ;;
     sun4H:SunOS:5.*:*)
 	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
@@ -745,13 +731,13 @@
 	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     CRAY*SV1:*:*:*)
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     *:UNICOS/mp:*:*)
-	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
+	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
         FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
         FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
         echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
@@ -762,37 +748,40 @@
     sparc*:BSD/OS:*:*)
 	echo sparc-unknown-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
 	exit 0 ;;
-    *:FreeBSD:*:*)
+    *:FreeBSD:*:*|*:GNU/FreeBSD:*:*)
 	# Determine whether the default compiler uses glibc.
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <features.h>
 	#if __GLIBC__ >= 2
 	LIBC=gnu
 	#else
 	LIBC=
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
+	# GNU/FreeBSD systems have a "k" prefix to indicate we are using
+	# FreeBSD's kernel, but not the complete OS.
+	case ${LIBC} in gnu) kernel_only='k' ;; esac
+	echo ${UNAME_MACHINE}-unknown-${kernel_only}freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
 	exit 0 ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
 	exit 0 ;;
     i*:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit 0 ;;
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit 0 ;;
-    x86:Interix*:3*)
-	echo i586-pc-interix3
+    x86:Interix*:[34]*)
+	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
 	exit 0 ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
 	exit 0 ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
@@ -815,12 +804,15 @@
     i*86:Minix:*:*)
 	echo ${UNAME_MACHINE}-pc-minix
 	exit 0 ;;
     arm*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
+    cris:Linux:*:*)
+	echo cris-axis-linux-gnu
+	exit 0 ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
     m68*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
@@ -893,12 +885,15 @@
     parisc64:Linux:*:* | hppa64:Linux:*:*)
 	echo hppa64-unknown-linux-gnu
 	exit 0 ;;
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
 	exit 0 ;;
+    sh64*:Linux:*:*)
+    	echo ${UNAME_MACHINE}-unknown-linux-gnu
+	exit 0 ;;
     sh*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
     sparc:Linux:*:* | sparc64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
@@ -950,12 +945,15 @@
 	#ifdef __INTEL_COMPILER
 	LIBC=gnu
 	#else
 	LIBC=gnuaout
 	#endif
 	#endif
+	#ifdef __dietlibc__
+	LIBC=dietlibc
+	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
 	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
 	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
 	;;
     i*86:DYNIX/ptx:4*:*)
@@ -1051,13 +1049,13 @@
 	exit 0 ;;
     M680?0:D-NIX:5.3:*)
 	echo m68k-diab-dnix
 	exit 0 ;;
     M68*:*:R3V[567]*:*)
 	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0)
+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
 	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
 	  && echo i486-ncr-sysv4.3${OS_REL} && exit 0
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
@@ -1166,13 +1164,13 @@
 	fi
 	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
 	exit 0 ;;
     *:QNX:*:4*)
 	echo i386-pc-qnx
 	exit 0 ;;
-    NSR-[DGKLNPTVW]:NONSTOP_KERNEL:*:*)
+    NSR-[DGKLNPTVWY]:NONSTOP_KERNEL:*:*)
 	echo nsr-tandem-nsk${UNAME_RELEASE}
 	exit 0 ;;
     *:NonStop-UX:*:*)
 	echo mips-compaq-nonstopux
 	exit 0 ;;
     BS2000:POSIX*:*:*)
@@ -1207,12 +1205,15 @@
     *:TOPS-20:*:*)
 	echo pdp10-unknown-tops20
 	exit 0 ;;
     *:ITS:*:*)
 	echo pdp10-unknown-its
 	exit 0 ;;
+    SEI:*:*:SEIUX)
+        echo mips-sei-seiux${UNAME_RELEASE}
+	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
 eval $set_cc_for_build
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.h.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/config.h.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.h.in	2003-07-30 14:12:38.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/config.h.in	2004-04-10 02:09:30.000000000 +0800
@@ -1,18 +1,7 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
-#undef ino_t
-#undef HAVE_CONNECT
-#undef HAVE_SHORT_INO_T
-#undef HAVE_GETOPT_LONG
-#undef REPLACE_INET_NTOA
-#undef REPLACE_INET_ATON
-#undef HAVE_GETTIMEOFDAY_TZ
-#undef ENABLE_IPV6
-#undef HAVE_SOCKADDR_LEN
-#undef HAVE_SOCKADDR_IN6_SCOPE_ID
-#undef HAVE_SOCKETPAIR
 
 /* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
    systems. This function is required for `alloca.c' support on those systems.
    */
 #undef CRAY_STACKSEG_END
 
@@ -82,12 +71,21 @@
 /* Define if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
 /* Define to 1 if you have the `getcwd' function. */
 #undef HAVE_GETCWD
 
+/* Define to 1 if you have the `getegid' function. */
+#undef HAVE_GETEGID
+
+/* Define to 1 if you have the `geteuid' function. */
+#undef HAVE_GETEUID
+
+/* Define to 1 if you have the `getgroups' function. */
+#undef HAVE_GETGROUPS
+
 /* Define to 1 if you have the `getnameinfo' function. */
 #undef HAVE_GETNAMEINFO
 
 /* */
 #undef HAVE_GETTIMEOFDAY_TZ
 
@@ -187,12 +185,21 @@
 /* */
 #undef HAVE_SHORT_INO_T
 
 /* Define to 1 if you have the `snprintf' function. */
 #undef HAVE_SNPRINTF
 
+/* Do we have sockaddr_in6.sin6_scope_id? */
+#undef HAVE_SOCKADDR_IN6_SCOPE_ID
+
+/* Do we have sockaddr_in.sin_len? */
+#undef HAVE_SOCKADDR_IN_LEN
+
+/* Do we have sockaddr.sa_len? */
+#undef HAVE_SOCKADDR_LEN
+
 /* Define if you have strct sockaddr_storage. */
 #undef HAVE_SOCKADDR_STORAGE
 
 /* */
 #undef HAVE_SOCKETPAIR
 
@@ -318,12 +325,20 @@
 /* Define to 1 if you have the `waitpid' function. */
 #undef HAVE_WAITPID
 
 /* true if you have IPv6 */
 #undef INET6
 
+/* Define to 1 if `major', `minor', and `makedev' are declared in <mkdev.h>.
+   */
+#undef MAJOR_IN_MKDEV
+
+/* Define to 1 if `major', `minor', and `makedev' are declared in
+   <sysmacros.h>. */
+#undef MAJOR_IN_SYSMACROS
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
 /* Define to the full name of this package. */
 #undef PACKAGE_NAME
 
@@ -342,12 +357,15 @@
 /* */
 #undef REPLACE_INET_NTOA
 
 /* Define as the return type of signal handlers (`int' or `void'). */
 #undef RETSIGTYPE
 
+/* location of configuration file for rsync server */
+#undef RSYNCD_SYSCONF
+
 /* location of rsync on remote machine */
 #undef RSYNC_PATH
 
 /* default -e command */
 #undef RSYNC_RSH
 
@@ -393,15 +411,17 @@
 /* Define for large files, on AIX-style hosts. */
 #undef _LARGE_FILES
 
 /* Define to `int' if <sys/types.h> doesn't define. */
 #undef gid_t
 
-/* Define as `__inline' if that's what the C compiler calls it, or to nothing
-   if it is not supported. */
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
 #undef inline
+#endif
 
 /* Define to `unsigned' if <sys/types.h> does not define. */
 #undef ino_t
 
 /* Define to `int' if <sys/types.h> does not define. */
 #undef mode_t
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.sub /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/config.sub
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/config.sub	2003-01-23 06:24:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/config.sub	2004-03-06 15:00:16.000000000 +0800
@@ -1,12 +1,12 @@
 #! /bin/sh
 # Configuration validation subroutine script.
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2003-01-22'
+timestamp='2003-08-18'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
 #
 # This file is free software; you can redistribute it and/or modify
@@ -115,13 +115,13 @@
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | linux-dietlibc | kfreebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
   *)
     basic_machine=`echo $1 | sed 's/-[^-]*$//'`
     if [ $basic_machine != $1 ]
@@ -225,46 +225,48 @@
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
 	1750a | 580 \
 	| a29k \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
+	| am33_2.0 \
 	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| clipper \
+	| c4x | clipper \
 	| d10v | d30v | dlx | dsp16xx \
 	| fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
-	| ip2k \
+	| ip2k | iq2000 \
 	| m32r | m68000 | m68k | m88k | mcore \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
 	| mips64vr | mips64vrel \
 	| mips64orion | mips64orionel \
 	| mips64vr4100 | mips64vr4100el \
 	| mips64vr4300 | mips64vr4300el \
 	| mips64vr5000 | mips64vr5000el \
 	| mipsisa32 | mipsisa32el \
 	| mipsisa32r2 | mipsisa32r2el \
 	| mipsisa64 | mipsisa64el \
+	| mipsisa64r2 | mipsisa64r2el \
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
 	| mn10200 | mn10300 \
 	| msp430 \
 	| ns16k | ns32k \
 	| openrisc | or32 \
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
 	| pyramid \
-	| sh | sh[1234] | sh3e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[23]e | sh[34]eb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
 	| strongarm \
-	| tahoe | thumb | tic80 | tron \
+	| tahoe | thumb | tic4x | tic80 | tron \
 	| v850 | v850e \
 	| we32k \
 	| x86 | xscale | xstormy16 | xtensa \
 	| z8k)
 		basic_machine=$basic_machine-unknown
 		;;
@@ -293,21 +295,21 @@
 	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
 	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* \
 	| bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* \
+	| c[123]* | c30-* | [cjt]90-* | c4x-* | c54x-* | c55x-* | c6x-* \
 	| clipper-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
 	| elxsi-* \
 	| f30[01]-* | f700-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* \
+	| ip2k-* | iq2000-* \
 	| m32r-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | mcore-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -316,27 +318,30 @@
 	| mips64vr4100-* | mips64vr4100el-* \
 	| mips64vr4300-* | mips64vr4300el-* \
 	| mips64vr5000-* | mips64vr5000el-* \
 	| mipsisa32-* | mipsisa32el-* \
 	| mipsisa32r2-* | mipsisa32r2el-* \
 	| mipsisa64-* | mipsisa64el-* \
+	| mipsisa64r2-* | mipsisa64r2el-* \
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
 	| msp430-* \
 	| none-* | np1-* | nv1-* | ns16k-* | ns32k-* \
 	| orion-* \
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
 	| pyramid-* \
 	| romp-* | rs6000-* \
-	| sh-* | sh[1234]-* | sh3e-* | sh[34]eb-* | shbe-* \
+	| sh-* | sh[1234]-* | sh[23]e-* | sh[34]eb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc86x-* | sparclet-* | sparclite-* \
 	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* | tic30-* | tic4x-* | tic54x-* | tic80-* | tron-* \
+	| tahoe-* | thumb-* \
+	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
+	| tron-* \
 	| v850-* | v850e-* | vax-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
 	| xtensa-* \
 	| ymp-* \
 	| z8k-*)
@@ -368,12 +373,15 @@
 		basic_machine=m68k-altos
 		;;
 	am29k)
 		basic_machine=a29k-none
 		os=-bsd
 		;;
+	amd64)
+		basic_machine=x86_64-pc
+		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
 		;;
 	amiga | amiga-*)
 		basic_machine=m68k-unknown
@@ -763,24 +771,30 @@
 	pentium | p5 | k5 | k6 | nexgen | viac3)
 		basic_machine=i586-pc
 		;;
 	pentiumpro | p6 | 6x86 | athlon | athlon_*)
 		basic_machine=i686-pc
 		;;
-	pentiumii | pentium2)
+	pentiumii | pentium2 | pentiumiii | pentium3)
 		basic_machine=i686-pc
 		;;
+	pentium4)
+		basic_machine=i786-pc
+		;;
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumii-* | pentium2-*)
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
+	pentium4-*)
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
+		;;
 	pn)
 		basic_machine=pn-gould
 		;;
 	power)	basic_machine=power-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
@@ -833,19 +847,26 @@
 	sb1)
 		basic_machine=mipsisa64sb1-unknown
 		;;
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
+	sei)
+		basic_machine=mips-sei
+		os=-seiux
+		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
 	sh)
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
+	sh64)
+		basic_machine=sh64-unknown
+		;;
 	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
 		;;
 	sps7)
 		basic_machine=m68k-bull
@@ -914,20 +935,24 @@
 		os=-unicos
 		;;
 	t90)
 		basic_machine=t90-cray
 		os=-unicos
 		;;
-        tic4x | c4x*)
-		basic_machine=tic4x-unknown
-		os=-coff
-		;;
 	tic54x | c54x*)
 		basic_machine=tic54x-unknown
 		os=-coff
 		;;
+	tic55x | c55x*)
+		basic_machine=tic55x-unknown
+		os=-coff
+		;;
+	tic6x | c6x*)
+		basic_machine=tic6x-unknown
+		os=-coff
+		;;
 	tx39)
 		basic_machine=mipstx39-unknown
 		;;
 	tx39el)
 		basic_machine=mipstx39el-unknown
 		;;
@@ -1024,13 +1049,13 @@
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
 		;;
-	sh3 | sh4 | sh3eb | sh4eb | sh[1234]le | sh3ele)
+	sh3 | sh4 | sh[34]eb | sh[1234]le | sh[23]ele)
 		basic_machine=sh-unknown
 		;;
 	sh64)
 		basic_machine=sh64-unknown
 		;;
 	sparc | sparcv9 | sparcv9b)
@@ -1103,25 +1128,25 @@
 	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -sunos | -sunos[34]*\
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -solaris* | -sym* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -kfreebsd* | -freebsd* | -riscix* \
 	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
 	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -microbsd*)
+	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
 		case $basic_machine in
 		    x86-* | i*86-*)
 			;;
@@ -1139,12 +1164,15 @@
 	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
 	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
 		;;
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
+	-linux-dietlibc)
+		os=-linux-dietlibc
+		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
 	-sunos5*)
 		os=`echo $os | sed -e 's|sunos5|solaris2|'`
 		;;
@@ -1227,12 +1255,15 @@
 	-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
 		os=-mint
 		;;
 	-aros*)
 		os=-aros
 		;;
+	-kaos*)
+		os=-kaos
+		;;
 	-none)
 		;;
 	*)
 		# Get rid of the `-' at the beginning of $os.
 		os=`echo $os | sed 's/[^-]*-//'`
 		echo Invalid configuration \`$1\': system \`$os\' not recognized 1>&2
@@ -1258,12 +1289,15 @@
 	arm*-rebel)
 		os=-linux
 		;;
 	arm*-semi)
 		os=-aout
 		;;
+    c4x-* | tic4x-*)
+        os=-coff
+        ;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
 		;;
 	pdp11-*)
 		os=-none
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/configure
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure	2004-01-02 03:09:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/configure	2004-04-27 11:54:05.000000000 +0800
@@ -1,12 +1,11 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.57.
+# Generated by GNU Autoconf 2.59.
 #
-# Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
-# Free Software Foundation, Inc.
+# Copyright (C) 2003 Free Software Foundation, Inc.
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## --------------------- ##
 ## M4sh Initialization.  ##
 ## --------------------- ##
 
@@ -17,15 +16,16 @@
   # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
 fi
 
 
@@ -38,13 +38,13 @@
 # NLS nuisances.
 for as_var in \
   LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
   LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
   LC_TELEPHONE LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
   fi
 done
 
@@ -215,22 +215,23 @@
 fi
 rm -f conf$$ conf$$.exe conf$$.file
 
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
 else
+  test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
 # Sed expression to map a string onto a valid variable name.
-as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 # IFS
 # We need space, tab and new line, in precisely that order.
 as_nl='
 '
@@ -305,13 +306,13 @@
 # endif
 #endif
 #if HAVE_UNISTD_H
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH EGREP LIBOBJS ALLOCA OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS RSYNC_VERSION build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT CPP EGREP INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA HAVE_REMSH LIBOBJS ALLOCA OBJ_SAVE OBJ_RESTORE CC_SHOBJ_FLAG BUILD_POPT LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
 ac_init_help=
 ac_init_version=false
 # The variables have the same names as the options, with
@@ -854,12 +855,14 @@
 
 Optional Packages:
   --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-included-popt    use bundled popt library, not from system
   --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)
+  --with-rsyncd-conf=PATH set configuration file for rsync server to PATH
+                          (default: /etc/rsyncd.conf)
   --with-rsh=CMD          set remote shell command to CMD (default: ssh)
 
 Some influential environment variables:
   CC          C compiler command
   CFLAGS      C compiler flags
   LDFLAGS     linker flags, e.g. -L<lib dir> if you have libraries in a
@@ -901,18 +904,51 @@
     ac_srcdir=$srcdir$ac_dir_suffix;
     ac_top_srcdir=$srcdir ;;
   *) # Relative path.
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
     cd $ac_dir
     # Check for guested configure; otherwise get Cygnus style configure.
     if test -f $ac_srcdir/configure.gnu; then
       echo
       $SHELL $ac_srcdir/configure.gnu  --help=recursive
@@ -923,34 +959,33 @@
            test -f $ac_srcdir/configure.in; then
       echo
       $ac_configure --help
     else
       echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
     fi
-    cd $ac_popdir
+    cd "$ac_popdir"
   done
 fi
 
 test -n "$ac_init_help" && exit 0
 if $ac_init_version; then
   cat <<\_ACEOF
 
-Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
-Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
   exit 0
 fi
 exec 5>config.log
 cat >&5 <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by $as_me, which was
-generated by GNU Autoconf 2.57.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   $ $0 $@
 
 _ACEOF
 {
 cat <<_ASUNAME
@@ -1120,13 +1155,13 @@
       echo
     fi
     test "$ac_signal" != 0 &&
       echo "$as_me: caught signal $ac_signal"
     echo "$as_me: exit $exit_status"
   } >&5
-  rm -f core core.* *.core &&
+  rm -f core *.core &&
   rm -rf conftest* confdefs* conf$$* $ac_clean_files &&
     exit $exit_status
      ' 0
 for ac_signal in 1 2 13 15; do
   trap 'ac_signal='$ac_signal'; { (exit 1); exit 1; }' $ac_signal
 done
@@ -1276,13 +1311,13 @@
 
 
           ac_config_headers="$ac_config_headers config.h"
 
 
 
-RSYNC_VERSION=2.6.0
+RSYNC_VERSION=2.6.1
 
 { echo "$as_me:$LINENO: Configuring rsync $RSYNC_VERSION" >&5
 echo "$as_me: Configuring rsync $RSYNC_VERSION" >&6;}
 
 
 cat >>confdefs.h <<_ACEOF
@@ -1733,13 +1768,12 @@
   (eval $ac_compiler -V </dev/null >&5) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -1753,14 +1787,14 @@
 _ACEOF
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files a.out a.exe b.out"
 # Try to create an executable without -o first, disregard a.out.
 # It will help us diagnose broken compilers, and finding out an intuition
 # of exeext.
-echo "$as_me:$LINENO: checking for C compiler default output" >&5
-echo $ECHO_N "checking for C compiler default output... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking for C compiler default output file name" >&5
+echo $ECHO_N "checking for C compiler default output file name... $ECHO_C" >&6
 ac_link_default=`echo "$ac_link" | sed 's/ -o *conftest[^ ]*//'`
 if { (eval echo "$as_me:$LINENO: \"$ac_link_default\"") >&5
   (eval $ac_link_default) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; then
@@ -1890,13 +1924,12 @@
 echo "$as_me:$LINENO: checking for suffix of object files" >&5
 echo $ECHO_N "checking for suffix of object files... $ECHO_C" >&6
 if test "${ac_cv_objext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -1941,13 +1974,12 @@
 echo "$as_me:$LINENO: checking whether we are using the GNU C compiler" >&5
 echo $ECHO_N "checking whether we are using the GNU C compiler... $ECHO_C" >&6
 if test "${ac_cv_c_compiler_gnu+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -1961,16 +1993,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -1978,13 +2019,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_compiler_gnu=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_cv_c_compiler_gnu=$ac_compiler_gnu
 
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_compiler_gnu" >&5
 echo "${ECHO_T}$ac_cv_c_compiler_gnu" >&6
 GCC=`test $ac_compiler_gnu = yes && echo yes`
@@ -1994,13 +2035,12 @@
 echo "$as_me:$LINENO: checking whether $CC accepts -g" >&5
 echo $ECHO_N "checking whether $CC accepts -g... $ECHO_C" >&6
 if test "${ac_cv_prog_cc_g+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -2011,16 +2051,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -2028,13 +2077,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_prog_cc_g=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_prog_cc_g" >&5
 echo "${ECHO_T}$ac_cv_prog_cc_g" >&6
 if test "$ac_test_CFLAGS" = set; then
   CFLAGS=$ac_save_CFLAGS
 elif test $ac_cv_prog_cc_g = yes; then
@@ -2055,13 +2104,12 @@
 if test "${ac_cv_prog_cc_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_prog_cc_stdc=no
 ac_save_CC=$CC
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdarg.h>
@@ -2083,12 +2131,22 @@
   va_list v;
   va_start (v,p);
   s = g (p, va_arg (v,int));
   va_end (v);
   return s;
 }
+
+/* OSF 4.0 Compaq cc is some sort of almost-ANSI by default.  It has
+   function prototypes and stuff, but not '\xHH' hex character constants.
+   These don't provoke an error unfortunately, instead are silently treated
+   as 'x'.  The following induces an error, until -std1 is added to get
+   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
+   array size at least.  It's necessary to write '\x00'==0 to get something
+   that's true only with -std1.  */
+int osf4_cc_array ['\x00' == 0 ? 1 : -1];
+
 int test (int i, double x);
 struct s1 {int (*f) (int a);};
 struct s2 {int (*f) (double a);};
 int pairnames (int, char **, FILE *(*)(struct buf *, struct stat *, int), int, int);
 int argc;
 char **argv;
@@ -2109,16 +2167,25 @@
 # SVR4			-Xc -D__EXTENSIONS__
 for ac_arg in "" -qlanglvl=ansi -std1 -Ae "-Aa -D_HPUX_SOURCE" "-Xc -D__EXTENSIONS__"
 do
   CC="$ac_save_CC $ac_arg"
   rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -2126,13 +2193,13 @@
 break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext
+rm -f conftest.err conftest.$ac_objext
 done
 rm -f conftest.$ac_ext conftest.$ac_objext
 CC=$ac_save_CC
 
 fi
 
@@ -2154,54 +2221,70 @@
 #ifndef __cplusplus
   choke me
 #endif
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   for ac_declaration in \
-   ''\
-   '#include <stdlib.h>' \
+   '' \
    'extern "C" void std::exit (int) throw (); using std::exit;' \
    'extern "C" void std::exit (int); using std::exit;' \
    'extern "C" void exit (int) throw ();' \
    'extern "C" void exit (int);' \
    'void exit (int);'
 do
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <stdlib.h>
 $ac_declaration
+#include <stdlib.h>
 int
 main ()
 {
 exit (42);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -2209,15 +2292,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 continue
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_declaration
@@ -2228,29 +2310,38 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 rm -f conftest*
 if test -n "$ac_declaration"; then
   echo '#ifdef __cplusplus' >>confdefs.h
   echo $ac_declaration      >>confdefs.h
   echo '#endif'             >>confdefs.h
@@ -2258,13 +2349,13 @@
 
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
@@ -2293,13 +2384,12 @@
   # with a fresh cross-compiler works.
   # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
   # <limits.h> exists even on freestanding compilers.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #ifdef __STDC__
@@ -2316,12 +2406,13 @@
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -2336,13 +2427,12 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
@@ -2354,12 +2444,13 @@
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -2400,13 +2491,12 @@
   # with a fresh cross-compiler works.
   # Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
   # <limits.h> exists even on freestanding compilers.
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp. "Syntax error" is here to catch this case.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #ifdef __STDC__
@@ -2423,12 +2513,13 @@
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -2443,13 +2534,12 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 
   # OK, works on sane cases.  Now check whether non-existent headers
   # can be detected and how.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <ac_nonexistent.h>
@@ -2461,12 +2551,13 @@
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -2499,23 +2590,39 @@
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
 ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
 ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
+
+
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
 # incompatible versions:
 # SysV /etc/install, /usr/sbin/install
 # SunOS /usr/etc/install
 # IRIX /sbin/install
 # AIX /bin/install
 # AmigaOS /C/install, which installs bootblocks on floppy discs
 # AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
 # AFS /usr/afsws/bin/install, which mishandles nonexistent args
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
 # ./install, which can be erroneously created by make from ./install.sh.
 echo "$as_me:$LINENO: checking for a BSD-compatible install" >&5
 echo $ECHO_N "checking for a BSD-compatible install... $ECHO_C" >&6
 if test -z "$INSTALL"; then
 if test "${ac_cv_path_install+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
@@ -2526,12 +2633,13 @@
   IFS=$as_save_IFS
   test -z "$as_dir" && as_dir=.
   # Account for people who put trailing slashes in PATH elements.
 case $as_dir/ in
   ./ | .// | /cC/* | \
   /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:\\/os2\\/install\\/* | ?:\\/OS2\\/INSTALL\\/* | \
   /usr/ucb/* ) ;;
   *)
     # OSF1 and SCO ODT 3.0 have their own names for install.
     # Don't use installbsd from OSF since it installs stuff as root
     # by default.
     for ac_prog in ginstall scoinst install; do
@@ -2674,12 +2782,43 @@
 cat >>confdefs.h <<_ACEOF
 #define RSYNC_PATH "$RSYNC_PATH"
 _ACEOF
 
 
 
+# Check whether --with-rsyncd-conf or --without-rsyncd-conf was given.
+if test "${with_rsyncd_conf+set}" = set; then
+  withval="$with_rsyncd_conf"
+   if test ! -z "$with_rsyncd_conf" ; then
+		case $with_rsyncd_conf in
+			yes|no)
+				RSYNCD_SYSCONF="/etc/rsyncd.conf"
+				;;
+			/*)
+				RSYNCD_SYSCONF="$with_rsyncd_conf"
+				;;
+			*)
+                                { { echo "$as_me:$LINENO: error: You must specify an absolute path to --with-rsyncd-conf=PATH" >&5
+echo "$as_me: error: You must specify an absolute path to --with-rsyncd-conf=PATH" >&2;}
+   { (exit 1); exit 1; }; }
+				;;
+		esac
+	else
+		RSYNCD_SYSCONF="/etc/rsyncd.conf"
+	fi
+else
+   RSYNCD_SYSCONF="/etc/rsyncd.conf"
+fi;
+
+
+cat >>confdefs.h <<_ACEOF
+#define RSYNCD_SYSCONF "$RSYNCD_SYSCONF"
+_ACEOF
+
+
+
 # Check whether --with-rsh or --without-rsh was given.
 if test "${with_rsh+set}" = set; then
   withval="$with_rsh"
 
 fi;
 
@@ -2748,13 +2887,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_BROKEN_LARGEFILE=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -2803,13 +2941,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_BROKEN_LARGEFILE=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_BROKEN_LARGEFILE" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_BROKEN_LARGEFILE" >&6
 if test x"$rsync_cv_HAVE_BROKEN_LARGEFILE" != x"yes"; then
    # Check whether --enable-largefile or --disable-largefile was given.
@@ -2828,13 +2966,12 @@
      if test "$GCC" != yes; then
        ac_save_CC=$CC
        while :; do
      	 # IRIX 6.2 and later do not support large files by default,
      	 # so use the C compiler's -n32 option if that helps.
          cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -2853,49 +2990,67 @@
   ;
   return 0;
 }
 _ACEOF
      	 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext
+rm -f conftest.err conftest.$ac_objext
      	 CC="$CC -n32"
      	 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_largefile_CC=' -n32'; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext
+rm -f conftest.err conftest.$ac_objext
          break
        done
        CC=$ac_save_CC
        rm -f conftest.$ac_ext
     fi
 fi
@@ -2910,13 +3065,12 @@
 if test "${ac_cv_sys_file_offset_bits+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   while :; do
   ac_cv_sys_file_offset_bits=no
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -2935,31 +3089,39 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #define _FILE_OFFSET_BITS 64
@@ -2979,29 +3141,38 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_file_offset_bits=64; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   break
 done
 fi
 echo "$as_me:$LINENO: result: $ac_cv_sys_file_offset_bits" >&5
 echo "${ECHO_T}$ac_cv_sys_file_offset_bits" >&6
 if test "$ac_cv_sys_file_offset_bits" != no; then
@@ -3017,13 +3188,12 @@
 if test "${ac_cv_sys_large_files+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   while :; do
   ac_cv_sys_large_files=no
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -3042,31 +3212,39 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #define _LARGE_FILES 1
@@ -3086,29 +3264,38 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_sys_large_files=1; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   break
 done
 fi
 echo "$as_me:$LINENO: result: $ac_cv_sys_large_files" >&5
 echo "${ECHO_T}$ac_cv_sys_large_files" >&6
 if test "$ac_cv_sys_large_files" != no; then
@@ -3139,29 +3326,13 @@
 echo $ECHO_N "checking ipv6 stack type... $ECHO_C" >&6
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
 		case $i in
 		inria)
 			# http://www.kame.net/
 
-echo "$as_me:$LINENO: checking for egrep" >&5
-echo $ECHO_N "checking for egrep... $ECHO_C" >&6
-if test "${ac_cv_prog_egrep+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
-    then ac_cv_prog_egrep='grep -E'
-    else ac_cv_prog_egrep='egrep'
-    fi
-fi
-echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
-echo "${ECHO_T}$ac_cv_prog_egrep" >&6
- EGREP=$ac_cv_prog_egrep
-
-
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3183,13 +3354,12 @@
 rm -f conftest*
 
 			;;
 		kame)
 			# http://www.kame.net/
 			cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3210,13 +3380,12 @@
 rm -f conftest*
 
 			;;
 		linux-glibc)
 			# http://www.v6.linux.or.jp/
 			cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3251,13 +3420,12 @@
 
 				CFLAGS="-I/usr/inet6/include $CFLAGS"
 			fi
 			;;
 		toshiba)
 			cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3279,13 +3447,12 @@
 fi
 rm -f conftest*
 
 			;;
 		v6d)
 			cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3307,13 +3474,12 @@
 fi
 rm -f conftest*
 
 			;;
 		zeta)
 			cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3349,13 +3515,12 @@
 if test "${ac_cv_search_getaddrinfo+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_getaddrinfo=no
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3373,34 +3538,43 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_getaddrinfo="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_getaddrinfo" = no; then
   for ac_lib in inet6; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3418,16 +3592,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3435,13 +3618,14 @@
 break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_search_getaddrinfo" >&5
 echo "${ECHO_T}$ac_cv_search_getaddrinfo" >&6
@@ -3471,13 +3655,12 @@
 echo $ECHO_N "checking whether byte ordering is bigendian... $ECHO_C" >&6
 if test "${ac_cv_c_bigendian+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   # See if sys/param.h defines the BYTE_ORDER macro.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -3493,25 +3676,33 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   # It does; now see whether it defined to BIG_ENDIAN or not.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -3527,16 +3718,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3544,23 +3744,22 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_c_bigendian=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 # It does not; compile a test program.
 if test "$cross_compiling" = yes; then
   # try to guess the endianness by grepping values into an object file
   ac_cv_c_bigendian=unknown
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };
@@ -3576,16 +3775,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3602,16 +3810,15 @@
 fi
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 int
@@ -3644,16 +3851,16 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 ac_cv_c_bigendian=yes
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_bigendian" >&5
 echo "${ECHO_T}$ac_cv_c_bigendian" >&6
 case $ac_cv_c_bigendian in
   yes)
 
@@ -3682,13 +3889,12 @@
 echo "$as_me:$LINENO: checking for $ac_hdr that defines DIR" >&5
 echo $ECHO_N "checking for $ac_hdr that defines DIR... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -3702,16 +3908,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3719,13 +3934,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_Header=no"
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_hdr" | $as_tr_cpp` 1
@@ -3742,13 +3957,12 @@
 if test "${ac_cv_search_opendir+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_opendir=no
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3766,34 +3980,43 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_opendir="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_opendir" = no; then
   for ac_lib in dir; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3811,16 +4034,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3828,13 +4060,14 @@
 break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
 echo "${ECHO_T}$ac_cv_search_opendir" >&6
@@ -3849,13 +4082,12 @@
 if test "${ac_cv_search_opendir+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_func_search_save_LIBS=$LIBS
 ac_cv_search_opendir=no
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3873,34 +4105,43 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_search_opendir="none required"
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 if test "$ac_cv_search_opendir" = no; then
   for ac_lib in x; do
     LIBS="-l$ac_lib  $ac_func_search_save_LIBS"
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -3918,16 +4159,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3935,13 +4185,14 @@
 break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
   done
 fi
 LIBS=$ac_func_search_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_search_opendir" >&5
 echo "${ECHO_T}$ac_cv_search_opendir" >&6
@@ -3955,13 +4206,12 @@
 echo "$as_me:$LINENO: checking whether time.h and sys/time.h may both be included" >&5
 echo $ECHO_N "checking whether time.h and sys/time.h may both be included... $ECHO_C" >&6
 if test "${ac_cv_header_time+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -3976,16 +4226,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -3993,13 +4252,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_header_time=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_time" >&5
 echo "${ECHO_T}$ac_cv_header_time" >&6
 if test $ac_cv_header_time = yes; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -4011,13 +4270,12 @@
 echo "$as_me:$LINENO: checking for sys/wait.h that is POSIX.1 compatible" >&5
 echo $ECHO_N "checking for sys/wait.h that is POSIX.1 compatible... $ECHO_C" >&6
 if test "${ac_cv_header_sys_wait_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -4038,16 +4296,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4055,13 +4322,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_header_sys_wait_h=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_sys_wait_h" >&5
 echo "${ECHO_T}$ac_cv_header_sys_wait_h" >&6
 if test $ac_cv_header_sys_wait_h = yes; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -4073,13 +4340,12 @@
 echo "$as_me:$LINENO: checking for ANSI C header files" >&5
 echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
 if test "${ac_cv_header_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdlib.h>
@@ -4094,16 +4360,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4111,18 +4386,17 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_header_stdc=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
 if test $ac_cv_header_stdc = yes; then
   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <string.h>
@@ -4138,13 +4412,12 @@
 
 fi
 
 if test $ac_cv_header_stdc = yes; then
   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdlib.h>
@@ -4163,13 +4436,12 @@
 if test $ac_cv_header_stdc = yes; then
   # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
   if test "$cross_compiling" = yes; then
   :
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <ctype.h>
@@ -4213,13 +4485,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 ac_cv_header_stdc=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 fi
 echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
 echo "${ECHO_T}$ac_cv_header_stdc" >&6
 if test $ac_cv_header_stdc = yes; then
@@ -4247,28 +4519,36 @@
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
 
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4276,13 +4556,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_Header=no"
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
@@ -4298,13 +4578,36 @@
 
 
 
 
 
 
-for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h unistd.h utime.h grp.h
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
+    unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
+    sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
+    sys/un.h glob.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h \
+    netdb.h malloc.h float.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
@@ -4314,27 +4617,35 @@
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 else
   # Is the header compilable?
 echo "$as_me:$LINENO: checking $ac_header usability" >&5
 echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
 #include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4342,21 +4653,20 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_header_compiler=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
 echo "$as_me:$LINENO: checking $ac_header presence" >&5
 echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <$ac_header>
@@ -4368,12 +4678,13 @@
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -4387,50 +4698,49 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
     { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
 echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
     ;;
-  no:yes )
+  no:yes:* )
     { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
 echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: $ac_header: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: $ac_header:     section \"Present But Cannot Be Compiled\"" >&2;}
     { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
 echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: $ac_header: in the future, the compiler will take precedence" >&2;}
     (
       cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
 _ASBOX
     ) |
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
 echo "$as_me:$LINENO: checking for $ac_header" >&5
 echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  eval "$as_ac_Header=$ac_header_preproc"
+  eval "$as_ac_Header=\$ac_header_preproc"
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 
 fi
 if test `eval echo '${'$as_ac_Header'}'` = yes; then
@@ -4439,48 +4749,104 @@
 _ACEOF
 
 fi
 
 done
 
+echo "$as_me:$LINENO: checking whether sys/types.h defines makedev" >&5
+echo $ECHO_N "checking whether sys/types.h defines makedev... $ECHO_C" >&6
+if test "${ac_cv_header_sys_types_h_makedev+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+int
+main ()
+{
+return makedev(0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_header_sys_types_h_makedev=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+ac_cv_header_sys_types_h_makedev=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_types_h_makedev" >&5
+echo "${ECHO_T}$ac_cv_header_sys_types_h_makedev" >&6
 
-
-
-for ac_header in compat.h sys/param.h ctype.h sys/wait.h sys/ioctl.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+if test $ac_cv_header_sys_types_h_makedev = no; then
+if test "${ac_cv_header_sys_mkdev_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for sys/mkdev.h" >&5
+echo $ECHO_N "checking for sys/mkdev.h... $ECHO_C" >&6
+if test "${ac_cv_header_sys_mkdev_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_mkdev_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_mkdev_h" >&6
 else
   # Is the header compilable?
-echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking sys/mkdev.h usability" >&5
+echo $ECHO_N "checking sys/mkdev.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <$ac_header>
+#include <sys/mkdev.h>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4488,38 +4854,38 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_header_compiler=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking sys/mkdev.h presence" >&5
+echo $ECHO_N "checking sys/mkdev.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <$ac_header>
+#include <sys/mkdev.h>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -4533,101 +4899,101 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: sys/mkdev.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: sys/mkdev.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
     ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: sys/mkdev.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: sys/mkdev.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: sys/mkdev.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: sys/mkdev.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: sys/mkdev.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/mkdev.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: sys/mkdev.h: in the future, the compiler will take precedence" >&2;}
     (
       cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
 _ASBOX
     ) |
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+echo "$as_me:$LINENO: checking for sys/mkdev.h" >&5
+echo $ECHO_N "checking for sys/mkdev.h... $ECHO_C" >&6
+if test "${ac_cv_header_sys_mkdev_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  eval "$as_ac_Header=$ac_header_preproc"
+  ac_cv_header_sys_mkdev_h=$ac_header_preproc
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_mkdev_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_mkdev_h" >&6
 
 fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+if test $ac_cv_header_sys_mkdev_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define MAJOR_IN_MKDEV 1
 _ACEOF
 
 fi
 
-done
-
-
-
 
 
-
-
-for ac_header in sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h sys/un.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  if test $ac_cv_header_sys_mkdev_h = no; then
+    if test "${ac_cv_header_sys_sysmacros_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for sys/sysmacros.h" >&5
+echo $ECHO_N "checking for sys/sysmacros.h... $ECHO_C" >&6
+if test "${ac_cv_header_sys_sysmacros_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_sysmacros_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_sysmacros_h" >&6
 else
   # Is the header compilable?
-echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking sys/sysmacros.h usability" >&5
+echo $ECHO_N "checking sys/sysmacros.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <$ac_header>
+#include <sys/sysmacros.h>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -4635,38 +5001,38 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_header_compiler=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking sys/sysmacros.h presence" >&5
+echo $ECHO_N "checking sys/sysmacros.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <$ac_header>
+#include <sys/sysmacros.h>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } >/dev/null; then
   if test -s conftest.err; then
     ac_cpp_err=$ac_c_preproc_warn_flag
+    ac_cpp_err=$ac_cpp_err$ac_c_werror_flag
   else
     ac_cpp_err=
   fi
 else
   ac_cpp_err=yes
 fi
@@ -4680,731 +5046,176 @@
 fi
 rm -f conftest.err conftest.$ac_ext
 echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
 echo "${ECHO_T}$ac_header_preproc" >&6
 
 # So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
+case $ac_header_compiler:$ac_header_preproc:$ac_c_preproc_warn_flag in
+  yes:no: )
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: sys/sysmacros.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: proceeding with the compiler's result" >&5
+echo "$as_me: WARNING: sys/sysmacros.h: proceeding with the compiler's result" >&2;}
+    ac_header_preproc=yes
     ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+  no:yes:* )
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: sys/sysmacros.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h:     check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: sys/sysmacros.h:     check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: see the Autoconf documentation" >&5
+echo "$as_me: WARNING: sys/sysmacros.h: see the Autoconf documentation" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h:     section \"Present But Cannot Be Compiled\"" >&5
+echo "$as_me: WARNING: sys/sysmacros.h:     section \"Present But Cannot Be Compiled\"" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: sys/sysmacros.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: sys/sysmacros.h: in the future, the compiler will take precedence" >&5
+echo "$as_me: WARNING: sys/sysmacros.h: in the future, the compiler will take precedence" >&2;}
     (
       cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
+## ------------------------------------------ ##
+## Report this to the AC_PACKAGE_NAME lists.  ##
+## ------------------------------------------ ##
 _ASBOX
     ) |
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+echo "$as_me:$LINENO: checking for sys/sysmacros.h" >&5
+echo $ECHO_N "checking for sys/sysmacros.h... $ECHO_C" >&6
+if test "${ac_cv_header_sys_sysmacros_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  eval "$as_ac_Header=$ac_header_preproc"
+  ac_cv_header_sys_sysmacros_h=$ac_header_preproc
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+echo "$as_me:$LINENO: result: $ac_cv_header_sys_sysmacros_h" >&5
+echo "${ECHO_T}$ac_cv_header_sys_sysmacros_h" >&6
 
 fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+if test $ac_cv_header_sys_sysmacros_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define MAJOR_IN_SYSMACROS 1
 _ACEOF
 
 fi
 
-done
-
-
-
 
+  fi
+fi
 
 
-for ac_header in glob.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+echo "$as_me:$LINENO: checking for int" >&5
+echo $ECHO_N "checking for int... $ECHO_C" >&6
+if test "${ac_cv_type_int+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 else
-  # Is the header compilable?
-echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
+  cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <$ac_header>
+int
+main ()
+{
+if ((int *) 0)
+  return 0;
+if (sizeof (int))
+  return 0;
+  ;
+  return 0;
+}
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_header_compiler=yes
+  ac_cv_type_int=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_header_compiler=no
+ac_cv_type_int=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_int" >&5
+echo "${ECHO_T}$ac_cv_type_int" >&6
 
-# Is the header present?
-echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking size of int" >&5
+echo $ECHO_N "checking size of int... $ECHO_C" >&6
+if test "${ac_cv_sizeof_int+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$ac_cv_type_int" = yes; then
+  # The cast to unsigned long works around a bug in the HP C Compiler
+  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
+  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
+  # This bug is HP SR number 8606223364.
+  if test "$cross_compiling" = yes; then
+  # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=$ac_header_preproc"
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in netdb.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-else
-  # Is the header compilable?
-echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_header_compiler=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6
-
-# Is the header present?
-echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=$ac_header_preproc"
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in malloc.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-else
-  # Is the header compilable?
-echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_header_compiler=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6
-
-# Is the header present?
-echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
-  ac_status=$?
-  grep -v '^ *+' conftest.er1 >conftest.err
-  rm -f conftest.er1
-  cat conftest.err >&5
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=$ac_header_preproc"
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-for ac_header in float.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-else
-  # Is the header compilable?
-echo "$as_me:$LINENO: checking $ac_header usability" >&5
-echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-#include <$ac_header>
+$ac_includes_default
+int
+main ()
+{
+static int test_array [1 - 2 * !(((long) (sizeof (int))) >= 0)];
+test_array [0] = 0
+
+  ;
+  return 0;
+}
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_header_compiler=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_header_compiler=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
-echo "${ECHO_T}$ac_header_compiler" >&6
-
-# Is the header present?
-echo "$as_me:$LINENO: checking $ac_header presence" >&5
-echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <$ac_header>
-_ACEOF
-if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
-  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
   grep -v '^ *+' conftest.er1 >conftest.err
   rm -f conftest.er1
   cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } >/dev/null; then
-  if test -s conftest.err; then
-    ac_cpp_err=$ac_c_preproc_warn_flag
-  else
-    ac_cpp_err=
-  fi
-else
-  ac_cpp_err=yes
-fi
-if test -z "$ac_cpp_err"; then
-  ac_header_preproc=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-  ac_header_preproc=no
-fi
-rm -f conftest.err conftest.$ac_ext
-echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
-echo "${ECHO_T}$ac_header_preproc" >&6
-
-# So?  What about this header?
-case $ac_header_compiler:$ac_header_preproc in
-  yes:no )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-  no:yes )
-    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
-echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
-    (
-      cat <<\_ASBOX
-## ------------------------------------ ##
-## Report this to bug-autoconf@gnu.org. ##
-## ------------------------------------ ##
-_ASBOX
-    ) |
-      sed "s/^/$as_me: WARNING:     /" >&2
-    ;;
-esac
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  eval "$as_ac_Header=$ac_header_preproc"
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-
-fi
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-
-done
-
-
-echo "$as_me:$LINENO: checking for int" >&5
-echo $ECHO_N "checking for int... $ECHO_C" >&6
-if test "${ac_cv_type_int+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-if ((int *) 0)
-  return 0;
-if (sizeof (int))
-  return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_type_int=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_cv_type_int=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: $ac_cv_type_int" >&5
-echo "${ECHO_T}$ac_cv_type_int" >&6
-
-echo "$as_me:$LINENO: checking size of int" >&5
-echo $ECHO_N "checking size of int... $ECHO_C" >&6
-if test "${ac_cv_sizeof_int+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if test "$ac_cv_type_int" = yes; then
-  # The cast to unsigned long works around a bug in the HP C Compiler
-  # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
-  # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
-  # This bug is HP SR number 8606223364.
-  if test "$cross_compiling" = yes; then
-  # Depending upon the size, compute the lo and hi bounds.
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-$ac_includes_default
-int
-main ()
-{
-static int test_array [1 - 2 * !(((long) (sizeof (int))) >= 0)];
-test_array [0] = 0
-
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5417,16 +5228,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5439,20 +5259,19 @@
                     if test $ac_lo -le $ac_mid; then
                       ac_lo= ac_hi=
                       break
                     fi
                     ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5465,26 +5284,34 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5497,16 +5324,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5519,28 +5355,27 @@
                        if test $ac_mid -le $ac_hi; then
                          ac_lo= ac_hi=
                          break
                        fi
                        ac_mid=`expr 2 '*' $ac_mid`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_lo= ac_hi=
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5553,16 +5388,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5570,32 +5414,29 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_int=$ac_lo;;
 '') { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
+  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
+echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5651,13 +5492,13 @@
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (int), 77
 See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.val
 else
   ac_cv_sizeof_int=0
 fi
@@ -5672,13 +5513,12 @@
 echo "$as_me:$LINENO: checking for long" >&5
 echo $ECHO_N "checking for long... $ECHO_C" >&6
 if test "${ac_cv_type_long+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5692,16 +5532,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5709,13 +5558,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_long=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_long" >&5
 echo "${ECHO_T}$ac_cv_type_long" >&6
 
 echo "$as_me:$LINENO: checking size of long" >&5
 echo $ECHO_N "checking size of long... $ECHO_C" >&6
@@ -5727,13 +5576,12 @@
   # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
   # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
   # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5746,26 +5594,34 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5778,16 +5634,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5800,20 +5665,19 @@
                     if test $ac_lo -le $ac_mid; then
                       ac_lo= ac_hi=
                       break
                     fi
                     ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5826,26 +5690,34 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5858,16 +5730,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5880,28 +5761,27 @@
                        if test $ac_mid -le $ac_hi; then
                          ac_lo= ac_hi=
                          break
                        fi
                        ac_mid=`expr 2 '*' $ac_mid`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_lo= ac_hi=
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -5914,16 +5794,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -5931,32 +5820,29 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_long=$ac_lo;;
 '') { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
+  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
+echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6012,13 +5898,13 @@
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (long), 77
 See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.val
 else
   ac_cv_sizeof_long=0
 fi
@@ -6033,13 +5919,12 @@
 echo "$as_me:$LINENO: checking for short" >&5
 echo $ECHO_N "checking for short... $ECHO_C" >&6
 if test "${ac_cv_type_short+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6053,16 +5938,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6070,13 +5964,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_short=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_short" >&5
 echo "${ECHO_T}$ac_cv_type_short" >&6
 
 echo "$as_me:$LINENO: checking size of short" >&5
 echo $ECHO_N "checking size of short... $ECHO_C" >&6
@@ -6088,13 +5982,12 @@
   # version HP92453-01 B.11.11.23709.GP, which incorrectly rejects
   # declarations like `int a3[[(sizeof (unsigned char)) >= 0]];'.
   # This bug is HP SR number 8606223364.
   if test "$cross_compiling" = yes; then
   # Depending upon the size, compute the lo and hi bounds.
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6107,26 +6000,34 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_lo=0 ac_mid=0
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6139,16 +6040,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6161,20 +6071,19 @@
                     if test $ac_lo -le $ac_mid; then
                       ac_lo= ac_hi=
                       break
                     fi
                     ac_mid=`expr 2 '*' $ac_mid + 1`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6187,26 +6096,34 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_hi=-1 ac_mid=-1
   while :; do
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6219,16 +6136,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6241,28 +6167,27 @@
                        if test $ac_mid -le $ac_hi; then
                          ac_lo= ac_hi=
                          break
                        fi
                        ac_mid=`expr 2 '*' $ac_mid`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
   done
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_lo= ac_hi=
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 # Binary search between lo and hi bounds.
 while test "x$ac_lo" != "x$ac_hi"; do
   ac_mid=`expr '(' $ac_hi - $ac_lo ')' / 2 + $ac_lo`
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6275,16 +6200,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6292,32 +6226,29 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_lo=`expr '(' $ac_mid ')' + 1`
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 case $ac_lo in
 ?*) ac_cv_sizeof_short=$ac_lo;;
 '') { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; } ;;
 esac
 else
   if test "$cross_compiling" = yes; then
-  { { echo "$as_me:$LINENO: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&5
-echo "$as_me: error: cannot run test program while cross compiling
-See \`config.log' for more details." >&2;}
+  { { echo "$as_me:$LINENO: error: internal error: not reached in cross-compile" >&5
+echo "$as_me: error: internal error: not reached in cross-compile" >&2;}
    { (exit 1); exit 1; }; }
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6373,13 +6304,13 @@
 { { echo "$as_me:$LINENO: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&5
 echo "$as_me: error: cannot compute sizeof (short), 77
 See \`config.log' for more details." >&2;}
    { (exit 1); exit 1; }; }
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 rm -f conftest.val
 else
   ac_cv_sizeof_short=0
 fi
@@ -6397,13 +6328,12 @@
 if test "${ac_cv_c_inline+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_cv_c_inline=no
 for ac_kw in inline __inline__ __inline; do
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #ifndef __cplusplus
@@ -6412,55 +6342,67 @@
 $ac_kw foo_t foo () {return 0; }
 #endif
 
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_c_inline=$ac_kw; break
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 done
 
 fi
 echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
 echo "${ECHO_T}$ac_cv_c_inline" >&6
+
+
 case $ac_cv_c_inline in
   inline | yes) ;;
-  no)
-cat >>confdefs.h <<\_ACEOF
-#define inline
-_ACEOF
- ;;
-  *)  cat >>confdefs.h <<_ACEOF
-#define inline $ac_cv_c_inline
+  *)
+    case $ac_cv_c_inline in
+      no) ac_val=;;
+      *) ac_val=$ac_cv_c_inline;;
+    esac
+    cat >>confdefs.h <<_ACEOF
+#ifndef __cplusplus
+#define inline $ac_val
+#endif
 _ACEOF
- ;;
+    ;;
 esac
 
 
 echo "$as_me:$LINENO: checking return type of signal handlers" >&5
 echo $ECHO_N "checking return type of signal handlers... $ECHO_C" >&6
 if test "${ac_cv_type_signal+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -6481,16 +6423,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6498,13 +6449,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_signal=int
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_signal" >&5
 echo "${ECHO_T}$ac_cv_type_signal" >&6
 
 cat >>confdefs.h <<_ACEOF
 #define RETSIGTYPE $ac_cv_type_signal
@@ -6514,13 +6465,12 @@
 echo "$as_me:$LINENO: checking for uid_t in sys/types.h" >&5
 echo $ECHO_N "checking for uid_t in sys/types.h... $ECHO_C" >&6
 if test "${ac_cv_type_uid_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -6553,13 +6503,12 @@
 echo "$as_me:$LINENO: checking for mode_t" >&5
 echo $ECHO_N "checking for mode_t... $ECHO_C" >&6
 if test "${ac_cv_type_mode_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6573,16 +6522,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6590,13 +6548,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_mode_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_mode_t" >&5
 echo "${ECHO_T}$ac_cv_type_mode_t" >&6
 if test $ac_cv_type_mode_t = yes; then
   :
 else
@@ -6610,13 +6568,12 @@
 echo "$as_me:$LINENO: checking for off_t" >&5
 echo $ECHO_N "checking for off_t... $ECHO_C" >&6
 if test "${ac_cv_type_off_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6630,16 +6587,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6647,13 +6613,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_off_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
 echo "${ECHO_T}$ac_cv_type_off_t" >&6
 if test $ac_cv_type_off_t = yes; then
   :
 else
@@ -6667,13 +6633,12 @@
 echo "$as_me:$LINENO: checking for size_t" >&5
 echo $ECHO_N "checking for size_t... $ECHO_C" >&6
 if test "${ac_cv_type_size_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6687,16 +6652,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6704,13 +6678,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_size_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
 echo "${ECHO_T}$ac_cv_type_size_t" >&6
 if test $ac_cv_type_size_t = yes; then
   :
 else
@@ -6724,13 +6698,12 @@
 echo "$as_me:$LINENO: checking for pid_t" >&5
 echo $ECHO_N "checking for pid_t... $ECHO_C" >&6
 if test "${ac_cv_type_pid_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6744,16 +6717,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6761,13 +6743,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_pid_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_pid_t" >&5
 echo "${ECHO_T}$ac_cv_type_pid_t" >&6
 if test $ac_cv_type_pid_t = yes; then
   :
 else
@@ -6784,13 +6766,12 @@
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   if test "$cross_compiling" = yes; then
   ac_cv_type_getgroups=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 /* Thanks to Mike Rendell for this test.  */
@@ -6833,17 +6814,16 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 ac_cv_type_getgroups=int
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 if test $ac_cv_type_getgroups = cross; then
         cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <unistd.h>
@@ -6870,13 +6850,12 @@
 echo "$as_me:$LINENO: checking for struct stat.st_rdev" >&5
 echo $ECHO_N "checking for struct stat.st_rdev... $ECHO_C" >&6
 if test "${ac_cv_member_struct_stat_st_rdev+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6889,29 +6868,37 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_member_struct_stat_st_rdev=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6924,16 +6911,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -6941,15 +6937,15 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_member_struct_stat_st_rdev=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_member_struct_stat_st_rdev" >&5
 echo "${ECHO_T}$ac_cv_member_struct_stat_st_rdev" >&6
 if test $ac_cv_member_struct_stat_st_rdev = yes; then
 
 cat >>confdefs.h <<_ACEOF
@@ -6963,13 +6959,12 @@
 echo "$as_me:$LINENO: checking for ino_t" >&5
 echo $ECHO_N "checking for ino_t... $ECHO_C" >&6
 if test "${ac_cv_type_ino_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
@@ -6983,16 +6978,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7000,13 +7004,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_ino_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_ino_t" >&5
 echo "${ECHO_T}$ac_cv_type_ino_t" >&6
 if test $ac_cv_type_ino_t = yes; then
   :
 else
@@ -7021,13 +7025,12 @@
    echo "$as_me:$LINENO: checking for socklen_t" >&5
 echo $ECHO_N "checking for socklen_t... $ECHO_C" >&6
 if test "${ac_cv_type_socklen_t+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -7043,16 +7046,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7060,13 +7072,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_type_socklen_t=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_type_socklen_t" >&5
 echo "${ECHO_T}$ac_cv_type_socklen_t" >&6
 if test $ac_cv_type_socklen_t = yes; then
   :
 else
@@ -7080,13 +7092,12 @@
          # Systems have either "struct sockaddr *" or
          # "void *" as the second argument to getpeername
          rsync_cv_socklen_t_equiv=
          for arg2 in "struct sockaddr" void; do
             for t in int size_t unsigned long "unsigned long"; do
                cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7105,16 +7116,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7124,13 +7144,13 @@
 
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
             done
          done
 
          if test "x$rsync_cv_socklen_t_equiv" = x; then
             { { echo "$as_me:$LINENO: error: Cannot find a type to use in place of socklen_t" >&5
 echo "$as_me: error: Cannot find a type to use in place of socklen_t" >&2;}
@@ -7154,13 +7174,12 @@
 echo $ECHO_N "checking for errno in errno.h... $ECHO_C" >&6
 if test "${rsync_cv_errno+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
     cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <errno.h>
@@ -7171,16 +7190,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7188,13 +7216,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 rsync_cv_have_errno_decl=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_errno" >&5
 echo "${ECHO_T}$rsync_cv_errno" >&6
 if test x"$rsync_cv_errno" = x"yes"; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -7218,27 +7246,34 @@
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -7263,16 +7298,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7280,13 +7324,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
@@ -7304,13 +7349,12 @@
 if test "${ac_cv_lib_nsl_s_printf+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnsl_s  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7328,16 +7372,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7345,13 +7398,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_lib_nsl_s_printf=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_s_printf" >&5
 echo "${ECHO_T}$ac_cv_lib_nsl_s_printf" >&6
 if test $ac_cv_lib_nsl_s_printf = yes; then
   cat >>confdefs.h <<_ACEOF
@@ -7371,13 +7425,12 @@
 if test "${ac_cv_lib_nsl_printf+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lnsl  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7395,16 +7448,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7412,13 +7474,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_lib_nsl_printf=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_printf" >&5
 echo "${ECHO_T}$ac_cv_lib_nsl_printf" >&6
 if test $ac_cv_lib_nsl_printf = yes; then
   cat >>confdefs.h <<_ACEOF
@@ -7438,13 +7501,12 @@
 if test "${ac_cv_lib_socket_connect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lsocket  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7462,16 +7524,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7479,13 +7550,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_lib_socket_connect=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_socket_connect" >&5
 echo "${ECHO_T}$ac_cv_lib_socket_connect" >&6
 if test $ac_cv_lib_socket_connect = yes; then
   cat >>confdefs.h <<_ACEOF
@@ -7505,13 +7577,12 @@
 if test "${ac_cv_lib_inet_connect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-linet  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7529,16 +7600,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7546,13 +7626,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_lib_inet_connect=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_inet_connect" >&5
 echo "${ECHO_T}$ac_cv_lib_inet_connect" >&6
 if test $ac_cv_lib_inet_connect = yes; then
   cat >>confdefs.h <<_ACEOF
@@ -7582,13 +7663,12 @@
 if test "${ac_cv_lib_resolv_inet_ntop+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lresolv  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7606,16 +7686,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7623,13 +7712,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_lib_resolv_inet_ntop=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_inet_ntop" >&5
 echo "${ECHO_T}$ac_cv_lib_resolv_inet_ntop" >&6
 if test $ac_cv_lib_resolv_inet_ntop = yes; then
   cat >>confdefs.h <<_ACEOF
@@ -7649,27 +7739,34 @@
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -7694,16 +7791,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7711,23 +7817,31 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 else
-  LIBOBJS="$LIBOBJS lib/inet_ntop.$ac_objext"
+  case $LIBOBJS in
+    "lib/inet_ntop.$ac_objext"   | \
+  *" lib/inet_ntop.$ac_objext"   | \
+    "lib/inet_ntop.$ac_objext "* | \
+  *" lib/inet_ntop.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/inet_ntop.$ac_objext" ;;
+esac
+
 fi
 done
 
 
 for ac_func in inet_pton
 do
@@ -7735,27 +7849,34 @@
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -7780,16 +7901,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7797,23 +7927,31 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 else
-  LIBOBJS="$LIBOBJS lib/inet_pton.$ac_objext"
+  case $LIBOBJS in
+    "lib/inet_pton.$ac_objext"   | \
+  *" lib/inet_pton.$ac_objext"   | \
+    "lib/inet_pton.$ac_objext "* | \
+  *" lib/inet_pton.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/inet_pton.$ac_objext" ;;
+esac
+
 fi
 done
 
 
 # Irix 6.5 has getaddrinfo but not the corresponding defines, so use
 #   builtin getaddrinfo if one of the defines don't exist
@@ -7821,13 +7959,12 @@
 echo $ECHO_N "checking whether defines needed by getaddrinfo exist... $ECHO_C" >&6
 if test "${rsync_cv_HAVE_GETADDR_DEFINES+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
 			cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -7860,27 +7997,34 @@
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -7905,16 +8049,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7922,26 +8075,26 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 else
   echo "$as_me:$LINENO: checking for getaddrinfo by including <netdb.h>" >&5
 echo $ECHO_N "checking for getaddrinfo by including <netdb.h>... $ECHO_C" >&6
 		cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -7954,16 +8107,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -7977,15 +8139,23 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 echo "$as_me:$LINENO: result: no" >&5
 echo "${ECHO_T}no" >&6
-			LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
+			case $LIBOBJS in
+    "lib/getaddrinfo.$ac_objext"   | \
+  *" lib/getaddrinfo.$ac_objext"   | \
+    "lib/getaddrinfo.$ac_objext "* | \
+  *" lib/getaddrinfo.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext" ;;
+esac
+
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 done
 
 
 for ac_func in getnameinfo
 do
@@ -7993,27 +8163,34 @@
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -8038,16 +8215,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -8055,39 +8241,59 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
 else
-  LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext"
+  case $LIBOBJS in
+    "lib/getnameinfo.$ac_objext"   | \
+  *" lib/getnameinfo.$ac_objext"   | \
+    "lib/getnameinfo.$ac_objext "* | \
+  *" lib/getnameinfo.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext" ;;
+esac
+
 fi
 done
 
 else
-	LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext"
-	LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext"
-fi
+	case $LIBOBJS in
+    "lib/getaddrinfo.$ac_objext"   | \
+  *" lib/getaddrinfo.$ac_objext"   | \
+    "lib/getaddrinfo.$ac_objext "* | \
+  *" lib/getaddrinfo.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/getaddrinfo.$ac_objext" ;;
+esac
+
+	case $LIBOBJS in
+    "lib/getnameinfo.$ac_objext"   | \
+  *" lib/getnameinfo.$ac_objext"   | \
+    "lib/getnameinfo.$ac_objext "* | \
+  *" lib/getnameinfo.$ac_objext "* ) ;;
+  *) LIBOBJS="$LIBOBJS lib/getnameinfo.$ac_objext" ;;
+esac
 
+fi
 
 echo "$as_me:$LINENO: checking for struct sockaddr.sa_len" >&5
 echo $ECHO_N "checking for struct sockaddr.sa_len... $ECHO_C" >&6
 if test "${ac_cv_member_struct_sockaddr_sa_len+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -8104,29 +8310,37 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
   ac_cv_member_struct_sockaddr_sa_len=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -8143,16 +8357,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -8160,80 +8383,33 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_member_struct_sockaddr_sa_len=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_sa_len" >&5
 echo "${ECHO_T}$ac_cv_member_struct_sockaddr_sa_len" >&6
 if test $ac_cv_member_struct_sockaddr_sa_len = yes; then
-   cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_LEN 1
-_ACEOF
-
-fi
-
-
-echo "$as_me:$LINENO: checking struct sockaddr_storage" >&5
-echo $ECHO_N "checking struct sockaddr_storage... $ECHO_C" >&6
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#include <sys/types.h>
-#include <sys/socket.h>
-int
-main ()
-{
-struct sockaddr_storage x;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  echo "$as_me:$LINENO: result: yes" >&5
-echo "${ECHO_T}yes" >&6
 
 cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_STORAGE 1
+#define HAVE_SOCKADDR_LEN 1
 _ACEOF
 
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-echo "$as_me:$LINENO: result: no" >&5
-echo "${ECHO_T}no" >&6
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
 
-echo "$as_me:$LINENO: checking for struct sockaddr_in6.sin6_scope_id" >&5
-echo $ECHO_N "checking for struct sockaddr_in6.sin6_scope_id... $ECHO_C" >&6
-if test "${ac_cv_member_struct_sockaddr_in6_sin6_scope_id+set}" = set; then
+
+echo "$as_me:$LINENO: checking for struct sockaddr_in.sin_len" >&5
+echo $ECHO_N "checking for struct sockaddr_in.sin_len... $ECHO_C" >&6
+if test "${ac_cv_member_struct_sockaddr_in_sin_len+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -8242,504 +8418,317 @@
 #include <netinet/in.h>
 
 
 int
 main ()
 {
-static struct sockaddr_in6 ac_aggr;
-if (ac_aggr.sin6_scope_id)
+static struct sockaddr_in ac_aggr;
+if (ac_aggr.sin_len)
 return 0;
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#include <sys/socket.h>
-#include <netinet/in.h>
-
-
-int
-main ()
-{
-static struct sockaddr_in6 ac_aggr;
-if (sizeof ac_aggr.sin6_scope_id)
-return 0;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
-else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-ac_cv_member_struct_sockaddr_in6_sin6_scope_id=no
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f conftest.$ac_objext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&5
-echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&6
-if test $ac_cv_member_struct_sockaddr_in6_sin6_scope_id = yes; then
-   cat >>confdefs.h <<\_ACEOF
-#define HAVE_SOCKADDR_IN6_SCOPE_ID 1
-_ACEOF
-
-fi
-
-
-# if we can't find strcasecmp, look in -lresolv (for Unixware at least)
-#
-
-for ac_func in strcasecmp
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-char (*f) () = $ac_func;
-#endif
-#ifdef __cplusplus
-}
-#endif
-
-int
-main ()
-{
-return f != $ac_func;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  ac_cv_member_struct_sockaddr_in_sin_len=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-eval "$as_ac_var=no"
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
-fi
-done
-
-if test x"$ac_cv_func_strcasecmp" = x"no"; then
-
-echo "$as_me:$LINENO: checking for strcasecmp in -lresolv" >&5
-echo $ECHO_N "checking for strcasecmp in -lresolv... $ECHO_C" >&6
-if test "${ac_cv_lib_resolv_strcasecmp+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lresolv  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char strcasecmp ();
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+
 int
 main ()
 {
-strcasecmp ();
+static struct sockaddr_in ac_aggr;
+if (sizeof ac_aggr.sin_len)
+return 0;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_resolv_strcasecmp=yes
+  ac_cv_member_struct_sockaddr_in_sin_len=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_resolv_strcasecmp=no
+ac_cv_member_struct_sockaddr_in_sin_len=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_strcasecmp" >&5
-echo "${ECHO_T}$ac_cv_lib_resolv_strcasecmp" >&6
-if test $ac_cv_lib_resolv_strcasecmp = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBRESOLV 1
-_ACEOF
-
-  LIBS="-lresolv $LIBS"
-
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
+echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in_sin_len" >&5
+echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in_sin_len" >&6
+if test $ac_cv_member_struct_sockaddr_in_sin_len = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_SOCKADDR_IN_LEN 1
+_ACEOF
 
 fi
 
 
-echo "$as_me:$LINENO: checking whether utime accepts a null argument" >&5
-echo $ECHO_N "checking whether utime accepts a null argument... $ECHO_C" >&6
-if test "${ac_cv_func_utime_null+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  rm -f conftest.data; >conftest.data
-# Sequent interprets utime(file, 0) to mean use start of epoch.  Wrong.
-if test "$cross_compiling" = yes; then
-  ac_cv_func_utime_null=no
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
+echo "$as_me:$LINENO: checking struct sockaddr_storage" >&5
+echo $ECHO_N "checking struct sockaddr_storage... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
+#include <sys/types.h>
+#include <sys/socket.h>
 int
 main ()
 {
-struct stat s, t;
-  exit (!(stat ("conftest.data", &s) == 0
-          && utime ("conftest.data", (long *)0) == 0
-          && stat ("conftest.data", &t) == 0
-          && t.st_mtime >= s.st_mtime
-          && t.st_mtime - s.st_mtime < 120));
+struct sockaddr_storage x;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_func_utime_null=yes
-else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
-
-( exit $ac_status )
-ac_cv_func_utime_null=no
-fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-rm -f core core.* *.core
-fi
-echo "$as_me:$LINENO: result: $ac_cv_func_utime_null" >&5
-echo "${ECHO_T}$ac_cv_func_utime_null" >&6
-if test $ac_cv_func_utime_null = yes; then
+  echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6
 
 cat >>confdefs.h <<\_ACEOF
-#define HAVE_UTIME_NULL 1
+#define HAVE_SOCKADDR_STORAGE 1
 _ACEOF
 
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-rm -f conftest.data
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 
-# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
-# for constant arguments.  Useless!
-echo "$as_me:$LINENO: checking for working alloca.h" >&5
-echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
-if test "${ac_cv_working_alloca_h+set}" = set; then
+echo "$as_me:$LINENO: checking for struct sockaddr_in6.sin6_scope_id" >&5
+echo $ECHO_N "checking for struct sockaddr_in6.sin6_scope_id... $ECHO_C" >&6
+if test "${ac_cv_member_struct_sockaddr_in6_sin6_scope_id+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <alloca.h>
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
+
 int
 main ()
 {
-char *p = (char *) alloca (2 * sizeof (int));
+static struct sockaddr_in6 ac_aggr;
+if (ac_aggr.sin6_scope_id)
+return 0;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_working_alloca_h=yes
+  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_working_alloca_h=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-fi
-echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
-echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
-if test $ac_cv_working_alloca_h = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ALLOCA_H 1
-_ACEOF
-
-fi
-
-echo "$as_me:$LINENO: checking for alloca" >&5
-echo $ECHO_N "checking for alloca... $ECHO_C" >&6
-if test "${ac_cv_func_alloca_works+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#ifdef __GNUC__
-# define alloca __builtin_alloca
-#else
-# ifdef _MSC_VER
-#  include <malloc.h>
-#  define alloca _alloca
-# else
-#  if HAVE_ALLOCA_H
-#   include <alloca.h>
-#  else
-#   ifdef _AIX
- #pragma alloca
-#   else
-#    ifndef alloca /* predefined by HP cc +Olibcalls */
-char *alloca ();
-#    endif
-#   endif
-#  endif
-# endif
-#endif
+
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+
 
 int
 main ()
 {
-char *p = (char *) alloca (1);
+static struct sockaddr_in6 ac_aggr;
+if (sizeof ac_aggr.sin6_scope_id)
+return 0;
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_func_alloca_works=yes
+  ac_cv_member_struct_sockaddr_in6_sin6_scope_id=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_func_alloca_works=no
+ac_cv_member_struct_sockaddr_in6_sin6_scope_id=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
-echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
-
-if test $ac_cv_func_alloca_works = yes; then
-
-cat >>confdefs.h <<\_ACEOF
-#define HAVE_ALLOCA 1
-_ACEOF
-
-else
-  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
-# that cause trouble.  Some versions do not even contain alloca or
-# contain a buggy version.  If you still want to use their alloca,
-# use ar to extract alloca.o from them instead of compiling alloca.c.
-
-ALLOCA=alloca.$ac_objext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&5
+echo "${ECHO_T}$ac_cv_member_struct_sockaddr_in6_sin6_scope_id" >&6
+if test $ac_cv_member_struct_sockaddr_in6_sin6_scope_id = yes; then
 
 cat >>confdefs.h <<\_ACEOF
-#define C_ALLOCA 1
-_ACEOF
-
-
-echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
-echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
-if test "${ac_cv_os_cray+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
+#define HAVE_SOCKADDR_IN6_SCOPE_ID 1
 _ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-#if defined(CRAY) && ! defined(CRAY2)
-webecray
-#else
-wenotbecray
-#endif
 
-_ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "webecray" >/dev/null 2>&1; then
-  ac_cv_os_cray=yes
-else
-  ac_cv_os_cray=no
 fi
-rm -f conftest*
 
-fi
-echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
-echo "${ECHO_T}$ac_cv_os_cray" >&6
-if test $ac_cv_os_cray = yes; then
-  for ac_func in _getb67 GETB67 getb67; do
-    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+
+# if we can't find strcasecmp, look in -lresolv (for Unixware at least)
+#
+
+for ac_func in strcasecmp
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -8764,16 +8753,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -8781,61 +8779,130 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
-
-cat >>confdefs.h <<_ACEOF
-#define CRAY_STACKSEG_END $ac_func
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
 _ACEOF
 
-    break
 fi
+done
 
-  done
-fi
+if test x"$ac_cv_func_strcasecmp" = x"no"; then
 
-echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
-echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
-if test "${ac_cv_c_stack_direction+set}" = set; then
+echo "$as_me:$LINENO: checking for strcasecmp in -lresolv" >&5
+echo $ECHO_N "checking for strcasecmp in -lresolv... $ECHO_C" >&6
+if test "${ac_cv_lib_resolv_strcasecmp+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  if test "$cross_compiling" = yes; then
-  ac_cv_c_stack_direction=0
-else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lresolv  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char strcasecmp ();
 int
-find_stack_direction ()
+main ()
 {
-  static char *addr = 0;
-  auto char dummy;
-  if (addr == 0)
-    {
-      addr = &dummy;
-      return find_stack_direction ();
-    }
-  else
-    return (&dummy > addr) ? 1 : -1;
+strcasecmp ();
+  ;
+  return 0;
 }
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_resolv_strcasecmp=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_resolv_strcasecmp=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_resolv_strcasecmp" >&5
+echo "${ECHO_T}$ac_cv_lib_resolv_strcasecmp" >&6
+if test $ac_cv_lib_resolv_strcasecmp = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBRESOLV 1
+_ACEOF
+
+  LIBS="-lresolv $LIBS"
+
+fi
+
+fi
+
 
+echo "$as_me:$LINENO: checking whether utime accepts a null argument" >&5
+echo $ECHO_N "checking whether utime accepts a null argument... $ECHO_C" >&6
+if test "${ac_cv_func_utime_null+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  rm -f conftest.data; >conftest.data
+# Sequent interprets utime(file, 0) to mean use start of epoch.  Wrong.
+if test "$cross_compiling" = yes; then
+  ac_cv_func_utime_null=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
 int
 main ()
 {
-  exit (find_stack_direction () < 0);
+struct stat s, t;
+  exit (!(stat ("conftest.data", &s) == 0
+	  && utime ("conftest.data", (long *)0) == 0
+	  && stat ("conftest.data", &t) == 0
+	  && t.st_mtime >= s.st_mtime
+	  && t.st_mtime - s.st_mtime < 120));
+  ;
+  return 0;
 }
 _ACEOF
 rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
@@ -8843,158 +8910,252 @@
   (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_c_stack_direction=1
+  ac_cv_func_utime_null=yes
 else
   echo "$as_me: program exited with status $ac_status" >&5
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
-ac_cv_c_stack_direction=-1
+ac_cv_func_utime_null=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
+rm -f core *.core
 fi
-echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
-echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+echo "$as_me:$LINENO: result: $ac_cv_func_utime_null" >&5
+echo "${ECHO_T}$ac_cv_func_utime_null" >&6
+if test $ac_cv_func_utime_null = yes; then
 
-cat >>confdefs.h <<_ACEOF
-#define STACK_DIRECTION $ac_cv_c_stack_direction
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_UTIME_NULL 1
 _ACEOF
 
-
 fi
+rm -f conftest.data
 
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
+	 { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
 
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
 
+fi
 
-
-
-
-
-
-for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
+#ifdef __GNUC__
+# define alloca __builtin_alloca
 #else
-char (*f) () = $ac_func;
-#endif
-#ifdef __cplusplus
-}
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
 #endif
 
 int
 main ()
 {
-return f != $ac_func;
+char *p = (char *) alloca (1);
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  ac_cv_func_alloca_works=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-eval "$as_ac_var=no"
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+ac_cv_func_alloca_works=no
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
-
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
-done
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
 
+if test $ac_cv_func_alloca_works = yes; then
 
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
 
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
 
+ALLOCA=alloca.$ac_objext
 
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
 
 
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
 
-for ac_func in fchmod fstat strchr readlink link utime utimes strftime
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -9019,16 +9180,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -9036,145 +9206,164 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
 _ACEOF
 
+    break
 fi
-done
-
-
-
-
-
-
-
 
+  done
+fi
 
-for ac_func in memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
+int
+find_stack_direction ()
 {
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-char (*f) () = $ac_func;
-#endif
-#ifdef __cplusplus
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
 }
-#endif
 
 int
 main ()
 {
-return f != $ac_func;
-  ;
-  return 0;
+  exit (find_stack_direction () < 0);
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
+rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  ac_cv_c_stack_direction=1
 else
-  echo "$as_me: failed program was:" >&5
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-eval "$as_ac_var=no"
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
 _ACEOF
 
+
 fi
-done
 
 
 
 
 
 
 
-for ac_func in strlcat strlcpy strtol mtrace mallinfo setgroups
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
+    fchmod fstat strchr readlink link utime utimes strftime mtrace \
+    memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk \
+    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid
 do
 as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
 echo "$as_me:$LINENO: checking for $ac_func" >&5
 echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
 if eval "test \"\${$as_ac_var+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+/* Define $ac_func to an innocuous variant, in case <limits.h> declares $ac_func.
+   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
+#define $ac_func innocuous_$ac_func
+
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func (); below.
     Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
     <limits.h> exists even on freestanding compilers.  */
+
 #ifdef __STDC__
 # include <limits.h>
 #else
 # include <assert.h>
 #endif
+
+#undef $ac_func
+
 /* Override any gcc2 internal prototype to avoid an error.  */
 #ifdef __cplusplus
 extern "C"
 {
 #endif
 /* We use char because int might match the return type of a gcc2
@@ -9199,16 +9388,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -9216,13 +9414,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 eval "$as_ac_var=no"
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
 echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
 if test `eval echo '${'$as_ac_var'}'` = yes; then
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
@@ -9239,13 +9438,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SOCKETPAIR=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -9274,13 +9472,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_SOCKETPAIR=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SOCKETPAIR" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SOCKETPAIR" >&6
 if test x"$rsync_cv_HAVE_SOCKETPAIR" = x"yes"; then
 
@@ -9298,13 +9496,12 @@
 if test "${ac_cv_lib_popt_poptGetContext+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
 LIBS="-lpopt  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -9322,16 +9519,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+  (eval $ac_link) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -9339,13 +9545,14 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ac_cv_lib_popt_poptGetContext=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext \
+      conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
 echo "$as_me:$LINENO: result: $ac_cv_lib_popt_poptGetContext" >&5
 echo "${ECHO_T}$ac_cv_lib_popt_poptGetContext" >&6
 if test $ac_cv_lib_popt_poptGetContext = yes; then
   cat >>confdefs.h <<_ACEOF
@@ -9387,13 +9594,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_LONGLONG=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdio.h>
@@ -9416,13 +9622,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_LONGLONG=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_LONGLONG" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_LONGLONG" >&6
 if test x"$rsync_cv_HAVE_LONGLONG" = x"yes"; then
 
@@ -9439,13 +9645,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_OFF64_T=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdio.h>
@@ -9469,13 +9674,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_OFF64_T=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_OFF64_T" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_OFF64_T" >&6
 if test x"$rsync_cv_HAVE_OFF64_T" = x"yes"; then
 
@@ -9492,13 +9697,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SHORT_INO_T=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdio.h>
@@ -9523,13 +9727,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_SHORT_INO_T=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SHORT_INO_T" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SHORT_INO_T" >&6
 if test x"$rsync_cv_HAVE_SHORT_INO_T" = x"yes"; then
 
@@ -9546,13 +9750,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_UNSIGNED_CHAR=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdio.h>
@@ -9575,13 +9778,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_UNSIGNED_CHAR=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_UNSIGNED_CHAR" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_UNSIGNED_CHAR" >&6
 if test x"$rsync_cv_HAVE_UNSIGNED_CHAR" = x"yes"; then
 
@@ -9598,13 +9801,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_BROKEN_READDIR=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -9630,13 +9832,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_BROKEN_READDIR=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_BROKEN_READDIR" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_BROKEN_READDIR" >&6
 if test x"$rsync_cv_HAVE_BROKEN_READDIR" = x"yes"; then
 
@@ -9650,13 +9852,12 @@
 echo $ECHO_N "checking for utimbuf... $ECHO_C" >&6
 if test "${rsync_cv_HAVE_UTIMBUF+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
 
 cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <sys/types.h>
@@ -9668,16 +9869,25 @@
   ;
   return 0;
 }
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+  (eval $ac_compile) 2>conftest.er1
   ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
+	 { ac_try='test -z "$ac_c_werror_flag"			 || test ! -s conftest.err'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; } &&
          { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
@@ -9685,13 +9895,13 @@
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 rsync_cv_HAVE_UTIMBUF=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_UTIMBUF" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_UTIMBUF" >&6
 if test x"$rsync_cv_HAVE_UTIMBUF" = x"yes"; then
 
 cat >>confdefs.h <<\_ACEOF
@@ -9707,13 +9917,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_GETTIMEOFDAY_TZ=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -9738,13 +9947,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_GETTIMEOFDAY_TZ=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_GETTIMEOFDAY_TZ" >&6
 if test x"$rsync_cv_HAVE_GETTIMEOFDAY_TZ" = x"yes"; then
 
@@ -9761,13 +9970,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_C99_VSNPRINTF=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -9807,13 +10015,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_C99_VSNPRINTF=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_C99_VSNPRINTF" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_C99_VSNPRINTF" >&6
 if test x"$rsync_cv_HAVE_C99_VSNPRINTF" = x"yes"; then
 
@@ -9831,13 +10039,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_HAVE_SECURE_MKSTEMP=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 #include <stdlib.h>
@@ -9872,13 +10079,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_HAVE_SECURE_MKSTEMP=no
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_HAVE_SECURE_MKSTEMP" >&5
 echo "${ECHO_T}$rsync_cv_HAVE_SECURE_MKSTEMP" >&6
 if test x"$rsync_cv_HAVE_SECURE_MKSTEMP" = x"yes"; then
 
@@ -9896,13 +10103,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_REPLACE_INET_NTOA=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -9932,13 +10138,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_REPLACE_INET_NTOA=yes
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_REPLACE_INET_NTOA" >&5
 echo "${ECHO_T}$rsync_cv_REPLACE_INET_NTOA" >&6
 if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
 
@@ -9956,13 +10162,12 @@
 else
 
 if test "$cross_compiling" = yes; then
   rsync_cv_REPLACE_INET_ATON=cross
 else
   cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
@@ -9990,13 +10195,13 @@
 echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
 ( exit $ac_status )
 rsync_cv_REPLACE_INET_ATON=yes
 fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+rm -f core *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
 fi
 echo "$as_me:$LINENO: result: $rsync_cv_REPLACE_INET_ATON" >&5
 echo "${ECHO_T}$rsync_cv_REPLACE_INET_ATON" >&6
 if test x"$rsync_cv_REPLACE_INET_ATON" = x"yes"; then
 
@@ -10108,19 +10313,19 @@
 
 # VPATH may cause trouble with some makes, so we remove $(srcdir),
 # ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[ 	]*VPATH[ 	]*=/{
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
 s/:*\$(srcdir):*/:/;
 s/:*\${srcdir}:*/:/;
 s/:*@srcdir@:*/:/;
-s/^\([^=]*=[ 	]*\):*/\1/;
+s/^\([^=]*=[	 ]*\):*/\1/;
 s/:*$//;
-s/^[^=]*=[ 	]*$//;
+s/^[^=]*=[	 ]*$//;
 }'
 fi
 
 DEFS=-DHAVE_CONFIG_H
 
 ac_libobjs=
@@ -10169,15 +10374,16 @@
   # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
   # is contrary to our usage.  Disable this feature.
   alias -g '${1+"$@"}'='"$@"'
 elif test -n "${BASH_VERSION+set}" && (set -o posix) >/dev/null 2>&1; then
   set -o posix
 fi
+DUALCASE=1; export DUALCASE # for MKS sh
 
 # Support unset when possible.
-if (FOO=FOO; unset FOO) >/dev/null 2>&1; then
+if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
   as_unset=unset
 else
   as_unset=false
 fi
 
 
@@ -10190,13 +10396,13 @@
 # NLS nuisances.
 for as_var in \
   LANG LANGUAGE LC_ADDRESS LC_ALL LC_COLLATE LC_CTYPE LC_IDENTIFICATION \
   LC_MEASUREMENT LC_MESSAGES LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER \
   LC_TELEPHONE LC_TIME
 do
-  if (set +x; test -n "`(eval $as_var=C; export $as_var) 2>&1`"); then
+  if (set +x; test -z "`(eval $as_var=C; export $as_var) 2>&1`"); then
     eval $as_var=C; export $as_var
   else
     $as_unset $as_var
   fi
 done
 
@@ -10369,22 +10575,23 @@
 fi
 rm -f conf$$ conf$$.exe conf$$.file
 
 if mkdir -p . 2>/dev/null; then
   as_mkdir_p=:
 else
+  test -d ./-p && rmdir ./-p
   as_mkdir_p=false
 fi
 
 as_executable_p="test -f"
 
 # Sed expression to map a string onto a valid CPP name.
-as_tr_cpp="sed y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g"
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
 
 # Sed expression to map a string onto a valid variable name.
-as_tr_sh="sed y%*+%pp%;s%[^_$as_cr_alnum]%_%g"
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
 # IFS
 # We need space, tab and new line, in precisely that order.
 as_nl='
 '
@@ -10405,13 +10612,13 @@
 ## Running $as_me. ##
 _ASBOX
 } >&5
 cat >&5 <<_CSEOF
 
 This file was extended by $as_me, which was
-generated by GNU Autoconf 2.57.  Invocation command line was
+generated by GNU Autoconf 2.59.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
   CONFIG_LINKS    = $CONFIG_LINKS
   CONFIG_COMMANDS = $CONFIG_COMMANDS
   $ $0 $@
@@ -10465,17 +10672,16 @@
 Report bugs to <bug-autoconf@gnu.org>."
 _ACEOF
 
 cat >>$CONFIG_STATUS <<_ACEOF
 ac_cs_version="\\
 config.status
-configured by $0, generated by GNU Autoconf 2.57,
+configured by $0, generated by GNU Autoconf 2.59,
   with options \\"`echo "$ac_configure_args" | sed 's/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
+Copyright (C) 2003 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 srcdir=$srcdir
 INSTALL="$INSTALL"
 _ACEOF
 
@@ -10679,17 +10885,17 @@
 s,@LDFLAGS@,$LDFLAGS,;t t
 s,@CPPFLAGS@,$CPPFLAGS,;t t
 s,@ac_ct_CC@,$ac_ct_CC,;t t
 s,@EXEEXT@,$EXEEXT,;t t
 s,@OBJEXT@,$OBJEXT,;t t
 s,@CPP@,$CPP,;t t
+s,@EGREP@,$EGREP,;t t
 s,@INSTALL_PROGRAM@,$INSTALL_PROGRAM,;t t
 s,@INSTALL_SCRIPT@,$INSTALL_SCRIPT,;t t
 s,@INSTALL_DATA@,$INSTALL_DATA,;t t
 s,@HAVE_REMSH@,$HAVE_REMSH,;t t
-s,@EGREP@,$EGREP,;t t
 s,@LIBOBJS@,$LIBOBJS,;t t
 s,@ALLOCA@,$ALLOCA,;t t
 s,@OBJ_SAVE@,$OBJ_SAVE,;t t
 s,@OBJ_RESTORE@,$OBJ_RESTORE,;t t
 s,@CC_SHOBJ_FLAG@,$CC_SHOBJ_FLAG,;t t
 s,@BUILD_POPT@,$BUILD_POPT,;t t
@@ -10811,30 +11017,58 @@
     ac_srcdir=$srcdir$ac_dir_suffix;
     ac_top_srcdir=$srcdir ;;
   *) # Relative path.
     ac_srcdir=$ac_top_builddir$srcdir$ac_dir_suffix
     ac_top_srcdir=$ac_top_builddir$srcdir ;;
 esac
-# Don't blindly perform a `cd "$ac_dir"/$ac_foo && pwd` since $ac_foo can be
-# absolute.
-ac_abs_builddir=`cd "$ac_dir" && cd $ac_builddir && pwd`
-ac_abs_top_builddir=`cd "$ac_dir" && cd ${ac_top_builddir}. && pwd`
-ac_abs_srcdir=`cd "$ac_dir" && cd $ac_srcdir && pwd`
-ac_abs_top_srcdir=`cd "$ac_dir" && cd $ac_top_srcdir && pwd`
+
+# Do not use `cd foo && pwd` to compute absolute paths, because
+# the directories may not exist.
+case `pwd` in
+.) ac_abs_builddir="$ac_dir";;
+*)
+  case "$ac_dir" in
+  .) ac_abs_builddir=`pwd`;;
+  [\\/]* | ?:[\\/]* ) ac_abs_builddir="$ac_dir";;
+  *) ac_abs_builddir=`pwd`/"$ac_dir";;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_builddir=${ac_top_builddir}.;;
+*)
+  case ${ac_top_builddir}. in
+  .) ac_abs_top_builddir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_builddir=${ac_top_builddir}.;;
+  *) ac_abs_top_builddir=$ac_abs_builddir/${ac_top_builddir}.;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_srcdir=$ac_srcdir;;
+*)
+  case $ac_srcdir in
+  .) ac_abs_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_srcdir=$ac_srcdir;;
+  *) ac_abs_srcdir=$ac_abs_builddir/$ac_srcdir;;
+  esac;;
+esac
+case $ac_abs_builddir in
+.) ac_abs_top_srcdir=$ac_top_srcdir;;
+*)
+  case $ac_top_srcdir in
+  .) ac_abs_top_srcdir=$ac_abs_builddir;;
+  [\\/]* | ?:[\\/]* ) ac_abs_top_srcdir=$ac_top_srcdir;;
+  *) ac_abs_top_srcdir=$ac_abs_builddir/$ac_top_srcdir;;
+  esac;;
+esac
 
 
   case $INSTALL in
   [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
   *) ac_INSTALL=$ac_top_builddir$INSTALL ;;
   esac
 
-  if test x"$ac_file" != x-; then
-    { echo "$as_me:$LINENO: creating $ac_file" >&5
-echo "$as_me: creating $ac_file" >&6;}
-    rm -f "$ac_file"
-  fi
   # Let's still pretend it is `configure' which instantiates (i.e., don't
   # use $as_me), people would be surprised to read:
   #    /* config.h.  Generated by config.status.  */
   if test x"$ac_file" = x-; then
     configure_input=
   else
@@ -10851,28 +11085,34 @@
       -) echo $tmp/stdin ;;
       [\\/$]*)
          # Absolute (can't be DOS-style, as IFS=:)
          test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 echo "$f";;
       *) # Relative
          if test -f "$f"; then
            # Build tree
-           echo $f
+	   echo "$f"
          elif test -f "$srcdir/$f"; then
            # Source tree
-           echo $srcdir/$f
+	   echo "$srcdir/$f"
          else
            # /dev/null tree
            { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
          fi;;
       esac
     done` || { (exit 1); exit 1; }
+
+  if test x"$ac_file" != x-; then
+    { echo "$as_me:$LINENO: creating $ac_file" >&5
+echo "$as_me: creating $ac_file" >&6;}
+    rm -f "$ac_file"
+  fi
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF
   sed "$ac_vpsub
 $extrasub
 _ACEOF
 cat >>$CONFIG_STATUS <<\_ACEOF
@@ -10906,18 +11146,18 @@
 #
 
 # These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
 # NAME is the cpp macro being defined and VALUE is the value it is being given.
 #
 # ac_d sets the value in "#define NAME VALUE" lines.
-ac_dA='s,^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
-ac_dB='[ 	].*$,\1#\2'
+ac_dA='s,^\([	 ]*\)#\([	 ]*define[	 ][	 ]*\)'
+ac_dB='[	 ].*$,\1#\2'
 ac_dC=' '
 ac_dD=',;t'
 # ac_u turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
-ac_uA='s,^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
+ac_uA='s,^\([	 ]*\)#\([	 ]*\)undef\([	 ][	 ]*\)'
 ac_uB='$,\1#\2define\3'
 ac_uC=' '
 ac_uD=',;t'
 
 for ac_file in : $CONFIG_HEADERS; do test "x$ac_file" = x: && continue
   # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
@@ -10942,30 +11182,31 @@
       -) echo $tmp/stdin ;;
       [\\/$]*)
          # Absolute (can't be DOS-style, as IFS=:)
          test -f "$f" || { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
-         echo $f;;
+	 # Do quote $f, to prevent DOS paths from being IFS'd.
+	 echo "$f";;
       *) # Relative
          if test -f "$f"; then
            # Build tree
-           echo $f
+	   echo "$f"
          elif test -f "$srcdir/$f"; then
            # Source tree
-           echo $srcdir/$f
+	   echo "$srcdir/$f"
          else
            # /dev/null tree
            { { echo "$as_me:$LINENO: error: cannot find input file: $f" >&5
 echo "$as_me: error: cannot find input file: $f" >&2;}
    { (exit 1); exit 1; }; }
          fi;;
       esac
     done` || { (exit 1); exit 1; }
   # Remove the trailing spaces.
-  sed 's/[ 	]*$//' $ac_file_inputs >$tmp/in
+  sed 's/[	 ]*$//' $ac_file_inputs >$tmp/in
 
 _ACEOF
 
 # Transform confdefs.h into two sed scripts, `conftest.defines' and
 # `conftest.undefs', that substitutes the proper values into
 # config.h.in to produce config.h.  The first handles `#define'
@@ -10982,15 +11223,15 @@
 # See the Autoconf documentation for `clear'.
 cat >confdef2sed.sed <<\_ACEOF
 s/[\\&,]/\\&/g
 s,[\\$`],\\&,g
 t clear
 : clear
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	(][^ 	(]*\)\(([^)]*)\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*\)\(([^)]*)\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1\2${ac_dC}\3${ac_dD},gp
 t end
-s,^[ 	]*#[ 	]*define[ 	][ 	]*\([^ 	][^ 	]*\)[ 	]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
+s,^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)$,${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD},gp
 : end
 _ACEOF
 # If some macros were called several times there might be several times
 # the same #defines, which is useless.  Nevertheless, we may not want to
 # sort them, since we want the *last* AC-DEFINE to be honored.
 uniq confdefs.h | sed -n -f confdef2sed.sed >conftest.defines
@@ -10998,28 +11239,28 @@
 rm -f confdef2sed.sed
 
 # This sed command replaces #undef with comments.  This is necessary, for
 # example, in the case of _POSIX_SOURCE, which is predefined and required
 # on some systems where configure will not decide to define it.
 cat >>conftest.undefs <<\_ACEOF
-s,^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
+s,^[	 ]*#[	 ]*undef[	 ][	 ]*[a-zA-Z_][a-zA-Z_0-9]*,/* & */,
 _ACEOF
 
 # Break up conftest.defines because some shells have a limit on the size
 # of here documents, and old seds have small limits too (100 cmds).
 echo '  # Handle all the #define templates only if necessary.' >>$CONFIG_STATUS
-echo '  if grep "^[ 	]*#[ 	]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
+echo '  if grep "^[	 ]*#[	 ]*define" $tmp/in >/dev/null; then' >>$CONFIG_STATUS
 echo '  # If there are no defines, we may have an empty if/fi' >>$CONFIG_STATUS
 echo '  :' >>$CONFIG_STATUS
 rm -f conftest.tail
 while grep . conftest.defines >/dev/null
 do
   # Write a limited-size here document to $tmp/defines.sed.
   echo '  cat >$tmp/defines.sed <<CEOF' >>$CONFIG_STATUS
   # Speed up: don't consider the non `#define' lines.
-  echo '/^[ 	]*#[ 	]*define/!b' >>$CONFIG_STATUS
+  echo '/^[	 ]*#[	 ]*define/!b' >>$CONFIG_STATUS
   # Work around the forget-to-reset-the-flag bug.
   echo 't clr' >>$CONFIG_STATUS
   echo ': clr' >>$CONFIG_STATUS
   sed ${ac_max_here_lines}q conftest.defines >>$CONFIG_STATUS
   echo 'CEOF
   sed -f $tmp/defines.sed $tmp/in >$tmp/out
@@ -11040,13 +11281,13 @@
 rm -f conftest.tail
 while grep . conftest.undefs >/dev/null
 do
   # Write a limited-size here document to $tmp/undefs.sed.
   echo '  cat >$tmp/undefs.sed <<CEOF' >>$CONFIG_STATUS
   # Speed up: don't consider the non `#undef'
-  echo '/^[ 	]*#[ 	]*undef/!b' >>$CONFIG_STATUS
+  echo '/^[	 ]*#[	 ]*undef/!b' >>$CONFIG_STATUS
   # Work around the forget-to-reset-the-flag bug.
   echo 't clr' >>$CONFIG_STATUS
   echo ': clr' >>$CONFIG_STATUS
   sed ${ac_max_here_lines}q conftest.undefs >>$CONFIG_STATUS
   echo 'CEOF
   sed -f $tmp/undefs.sed $tmp/in >$tmp/out
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/configure.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/configure.in	2004-01-02 03:09:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/configure.in	2004-04-27 11:54:05.000000000 +0800
@@ -2,25 +2,26 @@
 
 AC_INIT()
 AC_CONFIG_SRCDIR([byteorder.h])
 AC_CONFIG_HEADER(config.h)
 AC_PREREQ(2.52)
 
-RSYNC_VERSION=2.6.0
+RSYNC_VERSION=2.6.1
 AC_SUBST(RSYNC_VERSION)
 AC_MSG_NOTICE([Configuring rsync $RSYNC_VERSION])
 
 AC_DEFINE_UNQUOTED(RSYNC_VERSION, ["$RSYNC_VERSION"], [rsync release version])
 
 LDFLAGS=${LDFLAGS-""}
 
 AC_CANONICAL_TARGET([])
 
 dnl Checks for programs.
 AC_PROG_CC
 AC_PROG_CPP
+AC_PROG_EGREP
 AC_PROG_INSTALL
 AC_PROG_CC_STDC
 AC_SUBST(SHELL)
 
 AC_DEFINE([_GNU_SOURCE], 1,
           [Define _GNU_SOURCE so that we get all necessary prototypes])
@@ -93,12 +94,33 @@
 	[  --with-rsync-path=PATH  set default --rsync-path to PATH (default: rsync)],
 	[ RSYNC_PATH="$with_rsync_path" ],
 	[ RSYNC_PATH="rsync" ])
 
 AC_DEFINE_UNQUOTED(RSYNC_PATH, "$RSYNC_PATH", [location of rsync on remote machine])
 
+AC_ARG_WITH(rsyncd-conf,
+	AC_HELP_STRING([--with-rsyncd-conf=PATH], [set configuration file for rsync server to PATH (default: /etc/rsyncd.conf)]),
+	[ if test ! -z "$with_rsyncd_conf" ; then
+		case $with_rsyncd_conf in
+			yes|no)
+				RSYNCD_SYSCONF="/etc/rsyncd.conf"
+				;;
+			/*)
+				RSYNCD_SYSCONF="$with_rsyncd_conf"
+				;;
+			*)
+                                AC_MSG_ERROR(You must specify an absolute path to --with-rsyncd-conf=PATH)
+				;;
+		esac
+	else
+		RSYNCD_SYSCONF="/etc/rsyncd.conf"
+	fi ],
+	[ RSYNCD_SYSCONF="/etc/rsyncd.conf" ])
+
+AC_DEFINE_UNQUOTED(RSYNCD_SYSCONF, "$RSYNCD_SYSCONF", [location of configuration file for rsync server])
+
 AC_ARG_WITH(rsh,
 	AC_HELP_STRING([--with-rsh=CMD], [set remote shell command to CMD (default: ssh)]))
 
 AC_CHECK_PROG(HAVE_REMSH, remsh, 1, 0)
 AC_DEFINE_UNQUOTED(HAVE_REMSH, $HAVE_REMSH, [remote shell is remsh not rsh])
 
@@ -118,13 +140,13 @@
 #define _FILE_OFFSET_BITS 64
 #include <stdio.h>
 #include <fcntl.h>
 #include <sys/types.h>
 #include <sys/wait.h>
 
-int main(void) 
+int main(void)
 {
 	struct flock lock;
         int status;
 	int fd = open("conftest.dat", O_CREAT|O_RDWR, 0600);
 	lock.l_type = F_WRLCK;
 	lock.l_whence = SEEK_SET;
@@ -148,13 +170,13 @@
 fi
 
 ipv6type=unknown
 ipv6lib=none
 ipv6trylibc=yes
 
-AC_ARG_ENABLE(ipv6, 
+AC_ARG_ENABLE(ipv6,
 	AC_HELP_STRING([--disable-ipv6], [don't even try to use IPv6]))
 
 if test "x$enable_ipv6" != xno
 then
 	AC_MSG_CHECKING([ipv6 stack type])
 	for i in inria kame linux-glibc linux-inet6 toshiba v6d zeta; do
@@ -174,13 +196,13 @@
 			# http://www.kame.net/
 			AC_EGREP_CPP(yes, [
 #include <netinet/in.h>
 #ifdef __KAME__
 yes
 #endif],
-				[ipv6type=$i; 
+				[ipv6type=$i;
 				AC_DEFINE(INET6, 1, [true if you have IPv6])])
 			;;
 		linux-glibc)
 			# http://www.v6.linux.or.jp/
 			AC_EGREP_CPP(yes, [
 #include <features.h>
@@ -244,29 +266,28 @@
 	AC_SEARCH_LIBS(getaddrinfo, inet6)
 fi
 
 AC_MSG_CHECKING([whether to call shutdown on all sockets])
 case $host_os in
 	*cygwin* ) AC_MSG_RESULT(yes)
-                   AC_DEFINE(SHUTDOWN_ALL_SOCKETS, 1, 
+                   AC_DEFINE(SHUTDOWN_ALL_SOCKETS, 1,
 			    [Define if sockets need to be shutdown])
 		   ;;
 	       * ) AC_MSG_RESULT(no);;
 esac
 
 AC_C_BIGENDIAN
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
-AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h unistd.h utime.h grp.h)
-AC_CHECK_HEADERS(compat.h sys/param.h ctype.h sys/wait.h sys/ioctl.h)
-AC_CHECK_HEADERS(sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h sys/un.h)
-AC_CHECK_HEADERS(glob.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h)
-AC_CHECK_HEADERS(netdb.h)
-AC_CHECK_HEADERS(malloc.h)
-AC_CHECK_HEADERS(float.h)
+AC_CHECK_HEADERS(sys/fcntl.h sys/select.h fcntl.h sys/time.h sys/unistd.h \
+    unistd.h utime.h grp.h compat.h sys/param.h ctype.h sys/wait.h \
+    sys/ioctl.h sys/filio.h string.h stdlib.h sys/socket.h sys/mode.h \
+    sys/un.h glob.h mcheck.h sys/sysctl.h arpa/inet.h arpa/nameser.h \
+    netdb.h malloc.h float.h)
+AC_HEADER_MAJOR
 
 AC_CHECK_SIZEOF(int)
 AC_CHECK_SIZEOF(long)
 AC_CHECK_SIZEOF(short)
 
 AC_C_INLINE
@@ -315,38 +336,38 @@
     case "$LIBS" in
     *-linet*) ;;
     *) AC_CHECK_LIB(inet, connect) ;;
     esac
     dnl We can't just call AC_CHECK_FUNCS(connect) here, because the value
     dnl has been cached.
-    if test x"$ac_cv_lib_socket_connect" = x"yes" || 
+    if test x"$ac_cv_lib_socket_connect" = x"yes" ||
        test x"$ac_cv_lib_inet_connect" = x"yes"; then
         # ac_cv_func_connect=yes
         # don't!  it would cause AC_CHECK_FUNC to succeed next time configure is run
         AC_DEFINE(HAVE_CONNECT, 1, [ ])
     fi
 fi
 
 AC_CHECK_LIB(resolv, inet_ntop)
 
 dnl AC_MSG_NOTICE([Looking in libraries: $LIBS])
 
-AC_CHECK_FUNCS(inet_ntop, , AC_LIBOBJ(lib/inet_ntop)) 
-AC_CHECK_FUNCS(inet_pton, , AC_LIBOBJ(lib/inet_pton))
+AC_CHECK_FUNCS(inet_ntop, , [AC_LIBOBJ(lib/inet_ntop)])
+AC_CHECK_FUNCS(inet_pton, , [AC_LIBOBJ(lib/inet_pton)])
 
 # Irix 6.5 has getaddrinfo but not the corresponding defines, so use
 #   builtin getaddrinfo if one of the defines don't exist
 AC_CACHE_CHECK([whether defines needed by getaddrinfo exist],
                rsync_cv_HAVE_GETADDR_DEFINES,[
 			AC_EGREP_CPP(yes, [
 			#include <sys/types.h>
 			#include <sys/socket.h>
 			#include <netdb.h>
 			#ifdef AI_PASSIVE
 			yes
-			#endif], 
+			#endif],
 			rsync_cv_HAVE_GETADDR_DEFINES=yes,
 			rsync_cv_HAVE_GETADDR_DEFINES=no)])
 if test x"$rsync_cv_HAVE_GETADDR_DEFINES" = x"yes"; then
 	# Tru64 UNIX has getaddrinfo() but has it renamed in libc as
 	# something else so we must include <netdb.h> to get the
 	# redefinition.
@@ -357,38 +378,46 @@
 		#include <netdb.h>],[getaddrinfo(NULL, NULL, NULL, NULL);],
 			[AC_MSG_RESULT([yes])
 			AC_DEFINE(HAVE_GETADDRINFO, 1,
 				[Define if you have the `getaddrinfo' function.])],
 			[AC_MSG_RESULT([no])
 			AC_LIBOBJ(lib/getaddrinfo)])])
-	AC_CHECK_FUNCS(getnameinfo, , AC_LIBOBJ(lib/getnameinfo))
+	AC_CHECK_FUNCS(getnameinfo, , [AC_LIBOBJ(lib/getnameinfo)])
 else
 	AC_LIBOBJ(lib/getaddrinfo)
 	AC_LIBOBJ(lib/getnameinfo)
 fi
 
+AC_CHECK_MEMBER([struct sockaddr.sa_len],
+		[ AC_DEFINE(HAVE_SOCKADDR_LEN, 1, [Do we have sockaddr.sa_len?]) ],
+		[],
+		[
+#include <sys/types.h>
+#include <sys/socket.h>
+])
 
-AC_CHECK_MEMBER([struct sockaddr.sa_len], 
-		[ AC_DEFINE(HAVE_SOCKADDR_LEN) ],
+AC_CHECK_MEMBER([struct sockaddr_in.sin_len],
+		[ AC_DEFINE(HAVE_SOCKADDR_IN_LEN, 1, [Do we have sockaddr_in.sin_len?]) ],
 		[],
 		[
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <netinet/in.h>
 ])
 
 AC_MSG_CHECKING(struct sockaddr_storage)
 AC_TRY_COMPILE([#include <sys/types.h>
 #include <sys/socket.h>],
 [struct sockaddr_storage x;],
 	AC_MSG_RESULT(yes)
-	AC_DEFINE(HAVE_SOCKADDR_STORAGE, 1, 
+	AC_DEFINE(HAVE_SOCKADDR_STORAGE, 1,
 		[Define if you have strct sockaddr_storage.] ),
 	AC_MSG_RESULT(no))
 
 AC_CHECK_MEMBER([struct sockaddr_in6.sin6_scope_id],
-		[ AC_DEFINE(HAVE_SOCKADDR_IN6_SCOPE_ID) ],
+		[ AC_DEFINE(HAVE_SOCKADDR_IN6_SCOPE_ID, 1, [Do we have sockaddr_in6.sin6_scope_id?]) ],
 		[],
 		[
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 ])
@@ -399,21 +428,21 @@
 if test x"$ac_cv_func_strcasecmp" = x"no"; then
     AC_CHECK_LIB(resolv, strcasecmp)
 fi
 
 dnl At the moment we don't test for a broken memcmp(), because all we
 dnl need to do is test for equality, not comparison, and it seems that
-dnl every platform has a memcmp that can do at least that.  
+dnl every platform has a memcmp that can do at least that.
 dnl AC_FUNC_MEMCMP
 
 AC_FUNC_UTIME_NULL
 AC_FUNC_ALLOCA
-AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo)
-AC_CHECK_FUNCS(fchmod fstat strchr readlink link utime utimes strftime)
-AC_CHECK_FUNCS(memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk)
-AC_CHECK_FUNCS(strlcat strlcpy strtol mtrace mallinfo setgroups)
+AC_CHECK_FUNCS(waitpid wait4 getcwd strdup strerror chown chmod mknod mkfifo \
+    fchmod fstat strchr readlink link utime utimes strftime mtrace \
+    memmove lchown vsnprintf snprintf asprintf setsid glob strpbrk \
+    strlcat strlcpy strtol mallinfo getgroups setgroups geteuid getegid)
 
 AC_CACHE_CHECK([for working socketpair],rsync_cv_HAVE_SOCKETPAIR,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #include <sys/socket.h>
 
@@ -513,13 +542,13 @@
 fi
 
 AC_CACHE_CHECK([for C99 vsnprintf],rsync_cv_HAVE_C99_VSNPRINTF,[
 AC_TRY_RUN([
 #include <sys/types.h>
 #include <stdarg.h>
-void foo(const char *format, ...) { 
+void foo(const char *format, ...) {
        va_list ap;
        int len;
        char buf[5];
 
        va_start(ap, format);
        len = vsnprintf(0, 0, format, ap);
@@ -540,16 +569,16 @@
 
 AC_CACHE_CHECK([for secure mkstemp],rsync_cv_HAVE_SECURE_MKSTEMP,[
 AC_TRY_RUN([#include <stdlib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
-main() { 
+main() {
   struct stat st;
-  char tpl[20]="/tmp/test.XXXXXX"; 
-  int fd = mkstemp(tpl); 
+  char tpl[20]="/tmp/test.XXXXXX";
+  int fd = mkstemp(tpl);
   if (fd == -1) exit(1);
   unlink(tpl);
   if (fstat(fd, &st) != 0) exit(1);
   if ((st.st_mode & 0777) != 0600) exit(1);
   exit(0);
 }],
@@ -566,13 +595,13 @@
 #include <stdio.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
 main() { struct in_addr ip; ip.s_addr = 0x12345678;
 if (strcmp(inet_ntoa(ip),"18.52.86.120") &&
-    strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(1); } 
+    strcmp(inet_ntoa(ip),"120.86.52.18")) { exit(1); }
 exit(0);}],
            rsync_cv_REPLACE_INET_NTOA=no,rsync_cv_REPLACE_INET_NTOA=yes,rsync_cv_REPLACE_INET_NTOA=cross)])
 if test x"$rsync_cv_REPLACE_INET_NTOA" = x"yes"; then
     AC_DEFINE(REPLACE_INET_NTOA, 1, [ ])
 fi
 
@@ -580,13 +609,13 @@
 AC_CACHE_CHECK([for broken inet_aton],rsync_cv_REPLACE_INET_ATON,[
 AC_TRY_RUN([
 #include <stdio.h>
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-main() { struct in_addr ip; 
+main() { struct in_addr ip;
 if (inet_aton("example", &ip) == 0) exit(0); exit(1);}],
            rsync_cv_REPLACE_INET_ATON=no,rsync_cv_REPLACE_INET_ATON=yes,rsync_cv_REPLACE_INET_ATON=cross)])
 if test x"$rsync_cv_REPLACE_INET_ATON" = x"yes"; then
     AC_DEFINE(REPLACE_INET_ATON, 1, [ ])
 fi
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/exclude.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/exclude.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/exclude.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/exclude.c	2004-04-27 09:36:06.000000000 +0800
@@ -24,97 +24,99 @@
 
 /* include/exclude cluestick added by Martin Pool <mbp@samba.org> */
 
 #include "rsync.h"
 
 extern int verbose;
-
-struct exclude_struct **exclude_list;
-struct exclude_struct **local_exclude_list;
-struct exclude_struct **server_exclude_list;
+extern int eol_nulls;
+extern int list_only;
+extern int recurse;
+
+extern char curr_dir[];
+
+struct exclude_list_struct exclude_list = { 0, 0, "" };
+struct exclude_list_struct local_exclude_list = { 0, 0, "per-dir .cvsignore " };
+struct exclude_list_struct server_exclude_list = { 0, 0, "server " };
 char *exclude_path_prefix = NULL;
 
 /** Build an exclude structure given a exclude pattern */
-static struct exclude_struct *make_exclude(const char *pattern, int include)
+static void make_exclude(struct exclude_list_struct *listp, const char *pattern,
+			 int pat_len, int include)
 {
 	struct exclude_struct *ret;
-	char *cp;
-	int pat_len;
+	const char *cp;
+	int ex_len;
 
 	ret = new(struct exclude_struct);
-	if (!ret) out_of_memory("make_exclude");
-
-	memset(ret, 0, sizeof(*ret));
+	if (!ret)
+		out_of_memory("make_exclude");
 
-	if (strncmp(pattern,"- ",2) == 0) {
-		pattern += 2;
-	} else if (strncmp(pattern,"+ ",2) == 0) {
-		ret->include = 1;
-		pattern += 2;
-	} else {
-		ret->include = include;
-	}
+	memset(ret, 0, sizeof ret[0]);
+	ret->include = include;
 
 	if (exclude_path_prefix)
 		ret->match_flags |= MATCHFLG_ABS_PATH;
-	if (exclude_path_prefix && *pattern == '/') {
-		ret->pattern = new_array(char,
-			strlen(exclude_path_prefix) + strlen(pattern) + 1);
-		if (!ret->pattern) out_of_memory("make_exclude");
-		sprintf(ret->pattern, "%s%s", exclude_path_prefix, pattern);
-	}
-	else {
-		ret->pattern = strdup(pattern);
-		if (!ret->pattern) out_of_memory("make_exclude");
-	}
+	if (exclude_path_prefix && *pattern == '/')
+		ex_len = strlen(exclude_path_prefix);
+	else
+		ex_len = 0;
+	ret->pattern = new_array(char, ex_len + pat_len + 1);
+	if (!ret->pattern)
+		out_of_memory("make_exclude");
+	if (ex_len)
+		memcpy(ret->pattern, exclude_path_prefix, ex_len);
+	strlcpy(ret->pattern + ex_len, pattern, pat_len + 1);
+	pat_len += ex_len;
 
-	if (strpbrk(pattern, "*[?")) {
+	if (strpbrk(ret->pattern, "*[?")) {
 		ret->match_flags |= MATCHFLG_WILD;
-		if (strstr(pattern, "**")) {
+		if ((cp = strstr(ret->pattern, "**")) != NULL) {
 			ret->match_flags |= MATCHFLG_WILD2;
 			/* If the pattern starts with **, note that. */
-			if (*pattern == '*' && pattern[1] == '*')
+			if (cp == ret->pattern)
 				ret->match_flags |= MATCHFLG_WILD2_PREFIX;
 		}
 	}
 
-	pat_len = strlen(ret->pattern);
 	if (pat_len > 1 && ret->pattern[pat_len-1] == '/') {
 		ret->pattern[pat_len-1] = 0;
 		ret->directory = 1;
 	}
 
 	for (cp = ret->pattern; (cp = strchr(cp, '/')) != NULL; cp++)
 		ret->slash_cnt++;
 
-	return ret;
+	if (!listp->tail)
+		listp->head = listp->tail = ret;
+	else {
+		listp->tail->next = ret;
+		listp->tail = ret;
+	}
 }
 
 static void free_exclude(struct exclude_struct *ex)
 {
 	free(ex->pattern);
-	memset(ex,0,sizeof(*ex));
 	free(ex);
 }
 
-
-void free_exclude_list(struct exclude_struct ***listp)
+void free_exclude_list(struct exclude_list_struct *listp)
 {
-	struct exclude_struct **list = *listp;
-
-	if (verbose > 2)
-		rprintf(FINFO,"clearing exclude list\n");
+	struct exclude_struct *ent, *next;
 
-	if (!list)
-		return;
+	if (verbose > 2) {
+		rprintf(FINFO, "[%s] clearing %sexclude list\n",
+			who_am_i(), listp->debug_type);
+	}
 
-	while (*list)
-		free_exclude(*list++);
+	for (ent = listp->head; ent; ent = next) {
+		next = ent->next;
+		free_exclude(ent);
+	}
 
-	free(*listp);
-	*listp = NULL;
+	listp->head = listp->tail = NULL;
 }
 
 static int check_one_exclude(char *name, struct exclude_struct *ex,
                              int name_is_dir)
 {
 	char *p;
@@ -127,16 +129,14 @@
 	if (!ex->slash_cnt && !(ex->match_flags & MATCHFLG_WILD2)) {
 		if ((p = strrchr(name,'/')) != NULL)
 			name = p+1;
 	}
 	else if ((ex->match_flags & MATCHFLG_ABS_PATH) && *name != '/') {
 		static char full_name[MAXPATHLEN];
-		extern char curr_dir[];
 		int plus = curr_dir[1] == '\0'? 1 : 0;
-		snprintf(full_name, sizeof full_name,
-			 "%s/%s", curr_dir+plus, name);
+		pathjoin(full_name, sizeof full_name, curr_dir+plus, name);
 		name = full_name;
 	}
 
 	if (!name[0]) return 0;
 
 	if (ex->directory && !name_is_dir) return 0;
@@ -195,263 +195,252 @@
 	return 0;
 }
 
 
 static void report_exclude_result(char const *name,
                                   struct exclude_struct const *ent,
-                                  int name_is_dir)
+                                  int name_is_dir, const char *type)
 {
 	/* If a trailing slash is present to match only directories,
 	 * then it is stripped out by make_exclude.  So as a special
 	 * case we add it back in here. */
 
-	if (verbose >= 2)
-		rprintf(FINFO, "%s %s %s because of pattern %s%s\n",
-			ent->include ? "including" : "excluding",
-			name_is_dir ? "directory" : "file",
-			name, ent->pattern,
-			ent->directory ? "/" : "");
+	if (verbose >= 2) {
+		rprintf(FINFO, "[%s] %scluding %s %s because of %spattern %s%s\n",
+			who_am_i(), ent->include ? "in" : "ex",
+			name_is_dir ? "directory" : "file", name, type,
+			ent->pattern, ent->directory ? "/" : "");
+	}
 }
 
 
 /*
- * Return true if file NAME is defined to be excluded by either
- * LOCAL_EXCLUDE_LIST or the globals EXCLUDE_LIST.
+ * Return -1 if file "name" is defined to be excluded by the specified
+ * exclude list, 1 if it is included, and 0 if it was not matched.
  */
-int check_exclude(struct exclude_struct **list, char *name, int name_is_dir)
+int check_exclude(struct exclude_list_struct *listp, char *name, int name_is_dir)
 {
 	struct exclude_struct *ent;
 
-	while ((ent = *list++) != NULL) {
+	for (ent = listp->head; ent; ent = ent->next) {
 		if (check_one_exclude(name, ent, name_is_dir)) {
-			report_exclude_result(name, ent, name_is_dir);
-			return !ent->include;
+			report_exclude_result(name, ent, name_is_dir,
+					      listp->debug_type);
+			return ent->include ? 1 : -1;
 		}
 	}
 
 	return 0;
 }
 
 
-void add_exclude(struct exclude_struct ***listp, const char *pattern, int include)
+/* Get the next include/exclude arg from the string.  The token will not
+ * be '\0' terminated, so use the returned length to limit the string.
+ * Also, be sure to add this length to the returned pointer before passing
+ * it back to ask for the next token.  This routine will not parse the +/-
+ * prefixes or the "!" token when xflags contains XFLG_WORDS_ONLY.  The
+ * *incl_ptr value will be 1 for an include, 0 for an exclude, and -1 for
+ * the list-clearing "!" token.
+ */
+static const char *get_exclude_tok(const char *p, int *len_ptr, int *incl_ptr,
+				   int xflags)
 {
-	struct exclude_struct **list = *listp;
-	int len = 0;
+	const unsigned char *s = (const unsigned char *)p;
+	int len;
 
-	if (*pattern == '!' && !pattern[1]) {
-	    free_exclude_list(listp);
-	    return;
+	if (xflags & XFLG_WORD_SPLIT) {
+		/* Skip over any initial whitespace. */
+		while (isspace(*s))
+			s++;
+		/* Update for "!" check. */
+		p = (const char *)s;
 	}
 
-	if (list)
-		for (; list[len]; len++) {}
+	/* Is this a '+' or '-' followed by a space (not whitespace)? */
+	if (!(xflags & XFLG_WORDS_ONLY)
+	    && (*s == '-' || *s == '+') && s[1] == ' ') {
+		*incl_ptr = *s == '+';
+		s += 2;
+	} else
+		*incl_ptr = xflags & XFLG_DEF_INCLUDE;
 
- 	list = *listp = realloc_array(list, struct exclude_struct *, len+2);
+	if (xflags & XFLG_WORD_SPLIT) {
+		const unsigned char *cp = s;
+		/* Token ends at whitespace or the end of the string. */
+		while (!isspace(*cp) && *cp != '\0')
+			cp++;
+		len = cp - s;
+	} else
+		len = strlen(s);
 
-	if (!list || !(list[len] = make_exclude(pattern, include)))
-		out_of_memory("add_exclude");
+	if (*p == '!' && len == 1 && !(xflags & XFLG_WORDS_ONLY))
+		*incl_ptr = -1;
 
-	if (verbose > 2) {
-		rprintf(FINFO,"add_exclude(%s,%s)\n",pattern,
-			include ? "include" : "exclude");
-	}
+	*len_ptr = len;
+	return (const char *)s;
+}
 
-	list[len+1] = NULL;
+
+void add_exclude(struct exclude_list_struct *listp, const char *pattern,
+		 int xflags)
+{
+	int pat_len, incl;
+	const char *cp;
+
+	if (!pattern)
+		return;
+
+	cp = pattern;
+	pat_len = 0;
+	while (1) {
+		cp = get_exclude_tok(cp + pat_len, &pat_len, &incl, xflags);
+		if (!pat_len)
+			break;
+		/* If we got the special "!" token, clear the list. */
+		if (incl < 0)
+			free_exclude_list(listp);
+		else {
+			make_exclude(listp, cp, pat_len, incl);
+
+			if (verbose > 2) {
+				rprintf(FINFO, "[%s] add_exclude(%.*s, %s%s)\n",
+					who_am_i(), pat_len, cp,
+					listp->debug_type,
+					incl ? "include" : "exclude");
+			}
+		}
+	}
 }
 
 
-void add_exclude_file(struct exclude_struct ***listp, const char *fname,
-		      int fatal, int include)
+void add_exclude_file(struct exclude_list_struct *listp, const char *fname,
+		      int xflags)
 {
-	int fd;
+	FILE *fp;
 	char line[MAXPATHLEN];
 	char *eob = line + MAXPATHLEN - 1;
-	extern int eol_nulls;
+	int word_split = xflags & XFLG_WORD_SPLIT;
 
 	if (!fname || !*fname)
 		return;
 
 	if (*fname != '-' || fname[1])
-		fd = open(fname, O_RDONLY|O_BINARY);
+		fp = fopen(fname, "rb");
 	else
-		fd = 0;
-	if (fd < 0) {
-		if (fatal) {
+		fp = stdin;
+	if (!fp) {
+		if (xflags & XFLG_FATAL_ERRORS) {
 			rsyserr(FERROR, errno,
 				"failed to open %s file %s",
-				include ? "include" : "exclude",
+				xflags & XFLG_DEF_INCLUDE ? "include" : "exclude",
 				fname);
 			exit_cleanup(RERR_FILEIO);
 		}
 		return;
 	}
 
 	while (1) {
-		char ch, *s = line;
-		int cnt;
+		char *s = line;
+		int ch;
 		while (1) {
-			if ((cnt = read(fd, &ch, 1)) <= 0) {
-				if (cnt < 0 && errno == EINTR)
+			if ((ch = getc(fp)) == EOF) {
+				if (ferror(fp) && errno == EINTR)
 					continue;
 				break;
 			}
+			if (word_split && isspace(ch))
+				break;
 			if (eol_nulls? !ch : (ch == '\n' || ch == '\r'))
 				break;
 			if (s < eob)
 				*s++ = ch;
 		}
 		*s = '\0';
-		if (*line && *line != ';' && *line != '#') {
-			/* Skip lines starting with semicolon or pound.
-			 * It probably wouldn't cause any harm to not skip
-			 * them but there's no need to save them. */
-			add_exclude(listp, line, include);
-		}
-		if (cnt <= 0)
+		/* Skip an empty token and (when line parsing) comments. */
+		if (*line && (word_split || (*line != ';' && *line != '#')))
+			add_exclude(listp, line, xflags);
+		if (ch == EOF)
 			break;
 	}
-	close(fd);
+	fclose(fp);
 }
 
 
 void send_exclude_list(int f)
 {
-	int i;
-	extern int protocol_version;
-	extern int list_only, recurse;
+	struct exclude_struct *ent;
 
 	/* This is a complete hack - blame Rusty.
 	 *
 	 * FIXME: This pattern shows up in the output of
 	 * report_exclude_result(), which is not ideal. */
 	if (list_only && !recurse)
-		add_exclude(&exclude_list, "/*/*", ADD_EXCLUDE);
+		add_exclude(&exclude_list, "/*/*", 0);
 
-	if (!exclude_list) {
-		write_int(f,0);
-		return;
-	}
-
-	for (i=0;exclude_list[i];i++) {
-		int l;
-		char pattern[MAXPATHLEN];
-
-		strlcpy(pattern,exclude_list[i]->pattern,sizeof(pattern));
-		if (exclude_list[i]->directory) strlcat(pattern,"/", sizeof(pattern));
-
-		l = strlen(pattern);
-		if (l == 0) continue;
-		if (exclude_list[i]->include) {
-			if (protocol_version < 19) {
-				rprintf(FERROR,"remote rsync does not support include syntax - aborting\n");
-				exit_cleanup(RERR_UNSUPPORTED);
-			}
-			write_int(f,l+2);
-			write_buf(f,"+ ",2);
-		} else {
-			write_int(f,l);
+	for (ent = exclude_list.head; ent; ent = ent->next) {
+		unsigned int l;
+		char p[MAXPATHLEN+1];
+
+		l = strlcpy(p, ent->pattern, sizeof p);
+		if (l == 0 || l >= MAXPATHLEN)
+			continue;
+		if (ent->directory) {
+			p[l++] = '/';
+			p[l] = '\0';
 		}
-		write_buf(f,pattern,l);
+
+		if (ent->include) {
+			write_int(f, l + 2);
+			write_buf(f, "+ ", 2);
+		} else if ((*p == '-' || *p == '+') && p[1] == ' ') {
+			write_int(f, l + 2);
+			write_buf(f, "- ", 2);
+		} else
+			write_int(f, l);
+		write_buf(f, p, l);
 	}
 
-	write_int(f,0);
+	write_int(f, 0);
 }
 
 
 void recv_exclude_list(int f)
 {
-	char line[MAXPATHLEN];
+	char line[MAXPATHLEN+1]; /* Allows a trailing slash on a max-len dir */
 	unsigned int l;
 
-	while ((l=read_int(f))) {
-		if (l >= MAXPATHLEN) overflow("recv_exclude_list");
-		read_sbuf(f,line,l);
-		add_exclude(&exclude_list, line, ADD_EXCLUDE);
-	}
-}
-
-/* Get the next include/exclude arg from the string. It works in a similar way
-** to strtok - initially an arg is sent over, from then on NULL. This
-** routine takes into account any +/- in the strings and does not
-** consider the space following it as a delimeter.
-*/
-char *get_exclude_tok(char *p)
-{
-	static char *s;
-	static int more;
-	char *t;
-
-	if (p) {
-		s=p;
-		if (*p)
-			more=1;
+	while ((l = read_int(f)) != 0) {
+		if (l >= sizeof line)
+			overflow("recv_exclude_list");
+		read_sbuf(f, line, l);
+		add_exclude(&exclude_list, line, 0);
 	}
-
-	if (!more)
-		return(NULL);
-
-	/* Skip over any initial spaces */
-	while (isspace(* (unsigned char *) s))
-		s++;
-
-	/* Are we at the end of the string? */
-	if (*s) {
-		/* remember the beginning of the token */
-		t=s;
-
-		/* Is this a '+' or '-' followed by a space (not whitespace)? */
-		if ((*s=='+' || *s=='-') && *(s+1)==' ')
-			s+=2;
-
-		/* Skip to the next space or the end of the string */
-		while (!isspace(* (unsigned char *) s) && *s != '\0')
-			s++;
-	} else {
-		t=NULL;
-	}
-
-	/* Have we reached the end of the string? */
-	if (*s)
-		*s++='\0';
-	else
-		more=0;
-	return(t);
 }
 
 
-void add_exclude_line(struct exclude_struct ***listp,
-		      const char *line, int include)
-{
-	char *tok, *p;
-	if (!line || !*line) return;
-	p = strdup(line);
-	if (!p) out_of_memory("add_exclude_line");
-	for (tok=get_exclude_tok(p); tok; tok=get_exclude_tok(NULL))
-		add_exclude(listp, tok, include);
-	free(p);
-}
-
-
-static char *cvs_ignore_list[] = {
-  "RCS/", "SCCS/", "CVS/", ".svn/", "CVS.adm", "RCSLOG", "cvslog.*",
-  "tags", "TAGS", ".make.state", ".nse_depinfo",
-  "*~", "#*", ".#*", ", *", "*.old", "*.bak", "*.BAK", "*.orig",
-  "*.rej", ".del-*", "*.a", "*.o", "*.obj", "*.so", "*.Z", "*.elc", "*.ln",
-  "core", NULL};
-
+static char default_cvsignore[] = 
+	/* These default ignored items come from the CVS manual. */
+	"RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS"
+	" .make.state .nse_depinfo *~ #* .#* ,* _$* *$"
+	" *.old *.bak *.BAK *.orig *.rej .del-*"
+	" *.a *.olb *.o *.obj *.so *.exe"
+	" *.Z *.elc *.ln core"
+	/* The rest we added to suit ourself. */
+	" .svn/";
 
 void add_cvs_excludes(void)
 {
 	char fname[MAXPATHLEN];
 	char *p;
-	int i;
 
-	for (i=0; cvs_ignore_list[i]; i++)
-		add_exclude(&exclude_list, cvs_ignore_list[i], ADD_EXCLUDE);
+	add_exclude(&exclude_list, default_cvsignore,
+		    XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
 
-	if ((p=getenv("HOME")) && strlen(p) < (MAXPATHLEN-12)) {
-		snprintf(fname,sizeof(fname), "%s/.cvsignore",p);
-		add_exclude_file(&exclude_list,fname,MISSING_OK,ADD_EXCLUDE);
+	if ((p = getenv("HOME"))
+	    && pathjoin(fname, sizeof fname, p, ".cvsignore") < sizeof fname) {
+		add_exclude_file(&exclude_list, fname,
+				 XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
 	}
 
-	add_exclude_line(&exclude_list, getenv("CVSIGNORE"), ADD_EXCLUDE);
+	add_exclude(&exclude_list, getenv("CVSIGNORE"),
+		    XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/fileio.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/fileio.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/fileio.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/fileio.c	2004-01-05 11:57:15.000000000 +0800
@@ -1,27 +1,27 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1998
    Copyright (C) 2002 by Martin Pool
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /*
-  File IO utilities used in rsync 
+  File IO utilities used in rsync
   */
 #include "rsync.h"
 
 static char last_byte;
 static int last_sparse;
 extern int sparse_files;
@@ -39,54 +39,93 @@
 
 static int write_sparse(int f,char *buf,size_t len)
 {
 	size_t l1=0, l2=0;
 	int ret;
 
-	for (l1=0;l1<len && buf[l1]==0;l1++) ;
-	for (l2=0;l2<(len-l1) && buf[len-(l2+1)]==0;l2++) ;
+	for (l1 = 0; l1 < len && buf[l1] == 0; l1++) {}
+	for (l2 = 0; l2 < len-l1 && buf[len-(l2+1)] == 0; l2++) {}
 
 	last_byte = buf[len-1];
 
 	if (l1 == len || l2 > 0)
 		last_sparse=1;
 
 	if (l1 > 0) {
-		do_lseek(f,l1,SEEK_CUR);  
+		do_lseek(f,l1,SEEK_CUR);
 	}
 
-	if (l1 == len) 
+	if (l1 == len)
 		return len;
 
 	ret = write(f, buf + l1, len - (l1+l2));
 	if (ret == -1 || ret == 0)
 		return ret;
-	else if (ret != (int) (len - (l1+l2))) 
+	else if (ret != (int) (len - (l1+l2)))
 		return (l1+ret);
 
 	if (l2 > 0)
 		do_lseek(f,l2,SEEK_CUR);
-	
+
 	return len;
 }
 
+
+static char *wf_writeBuf;
+static size_t wf_writeBufSize;
+static size_t wf_writeBufCnt;
+
+int flush_write_file(int f)
+{
+	int ret = 0;
+	char *bp = wf_writeBuf;
+
+	while (wf_writeBufCnt > 0) {
+		if ((ret = write(f, bp, wf_writeBufCnt)) < 0) {
+			if (errno == EINTR)
+				continue;
+			return ret;
+		}
+		wf_writeBufCnt -= ret;
+		bp += ret;
+	}
+	return ret;
+}
+
 /*
  * write_file does not allow incomplete writes.  It loops internally
  * until len bytes are written or errno is set.
  */
 int write_file(int f,char *buf,size_t len)
 {
 	int ret = 0;
 
-	while (len>0) {
+	while (len > 0) {
 		int r1;
 		if (sparse_files) {
 			int len1 = MIN(len, SPARSE_WRITE_SIZE);
 			r1 = write_sparse(f, buf, len1);
 		} else {
-			r1 = write(f, buf, len);
+			if (!wf_writeBuf) {
+				wf_writeBufSize = MAX_MAP_SIZE;
+				wf_writeBufCnt  = 0;
+				wf_writeBuf = new_array(char, MAX_MAP_SIZE);
+				if (!wf_writeBuf)
+					out_of_memory("write_file");
+			}
+			r1 = MIN(len, wf_writeBufSize - wf_writeBufCnt);
+			if (r1) {
+				memcpy(wf_writeBuf + wf_writeBufCnt, buf, r1);
+				wf_writeBufCnt += r1;
+			}
+			if (wf_writeBufCnt == wf_writeBufSize) {
+				if (flush_write_file(f) < 0)
+					return -1;
+				if (!r1 && len)
+					continue;
+			}
 		}
 		if (r1 <= 0) {
 			if (ret > 0) return ret;
 			return r1;
 		}
 		len -= r1;
@@ -134,13 +173,13 @@
 	/* can't go beyond the end of file */
 	if (len > (map->file_size - offset)) {
 		len = map->file_size - offset;
 	}
 
 	/* in most cases the region will already be available */
-	if (offset >= map->p_offset && 
+	if (offset >= map->p_offset &&
 	    offset+len <= map->p_offset+map->p_len) {
 		return (map->p + (offset - map->p_offset));
 	}
 
 
 	/* nope, we are going to have to do a read. Work out our desired window */
@@ -203,14 +242,14 @@
 		}
 		map->p_fd_offset += nread;
 	}
 
 	map->p_offset = window_start;
 	map->p_len = window_size;
-  
-	return map->p + (offset - map->p_offset); 
+
+	return map->p + (offset - map->p_offset);
 }
 
 
 int unmap_file(struct map_struct *map)
 {
 	int	ret;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/flist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/flist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/flist.c	2003-12-15 16:10:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/flist.c	2004-04-27 09:36:10.000000000 +0800
@@ -18,37 +18,38 @@
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /** @file flist.c
  * Generate and receive file lists
  *
- * @todo Get rid of the string_area optimization.  Efficiently
- * allocating blocks is the responsibility of the system's malloc
- * library, not of rsync.
- *
  * @sa http://lists.samba.org/pipermail/rsync/2000-June/002351.html
  *
  **/
 
 #include "rsync.h"
 
 extern struct stats stats;
 
 extern int verbose;
 extern int do_progress;
+extern int am_root;
 extern int am_server;
+extern int am_daemon;
 extern int always_checksum;
+extern int module_id;
+extern int ignore_errors;
+extern int numeric_ids;
 
 extern int cvs_exclude;
 
 extern int recurse;
+extern char curr_dir[MAXPATHLEN];
 extern char *files_from;
 extern int filesfrom_fd;
 
 extern int one_file_system;
-extern int make_backups;
 extern int preserve_links;
 extern int preserve_hard_links;
 extern int preserve_perms;
 extern int preserve_devices;
 extern int preserve_uid;
 extern int preserve_gid;
@@ -60,21 +61,31 @@
 extern int protocol_version;
 extern int sanitize_paths;
 
 extern int read_batch;
 extern int write_batch;
 
-extern struct exclude_struct **exclude_list;
-extern struct exclude_struct **server_exclude_list;
-extern struct exclude_struct **local_exclude_list;
+extern struct exclude_list_struct exclude_list;
+extern struct exclude_list_struct server_exclude_list;
+extern struct exclude_list_struct local_exclude_list;
 
 int io_error;
 
-static struct file_struct null_file;
+static char empty_sum[MD4_SUM_LENGTH];
+static unsigned int file_struct_len;
 
 static void clean_flist(struct file_list *flist, int strip_root, int no_dups);
+static void output_flist(struct file_list *flist);
+
+void init_flist(void)
+{
+	struct file_struct f;
+
+	/* Figure out how big the file_struct is without trailing padding */
+	file_struct_len = offsetof(struct file_struct, flags) + sizeof f.flags;
+}
 
 
 static int show_filelist_p(void)
 {
 	return verbose && (recurse || files_from) && !am_server;
 }
@@ -104,98 +115,44 @@
 static void finish_filelist_progress(const struct file_list *flist)
 {
 	if (do_progress) {
 		/* This overwrites the progress line */
 		rprintf(FINFO, "%d file%sto consider\n",
 			flist->count, flist->count == 1 ? " " : "s ");
-	} else {
+	} else
 		rprintf(FINFO, "done\n");
-	}
 }
 
 void show_flist_stats(void)
 {
 	/* Nothing yet */
 }
 
 
-static struct string_area *string_area_new(int size)
-{
-	struct string_area *a;
-
-	if (size <= 0)
-		size = ARENA_SIZE;
-	a = new(struct string_area);
-	if (!a)
-		out_of_memory("string_area_new");
-	a->current = a->base = new_array(char, size);
-	if (!a->current)
-		out_of_memory("string_area_new buffer");
-	a->end = a->base + size;
-	a->next = NULL;
-
-	return a;
-}
-
-static void string_area_free(struct string_area *a)
-{
-	struct string_area *next;
-
-	for (; a; a = next) {
-		next = a->next;
-		free(a->base);
-	}
-}
-
-static char *string_area_malloc(struct string_area **ap, int size)
-{
-	char *p;
-	struct string_area *a;
-
-	/* does the request fit into the current space? */
-	a = *ap;
-	if (a->current + size >= a->end) {
-		/* no; get space, move new string_area to front of the list */
-		a = string_area_new(size > ARENA_SIZE ? size : ARENA_SIZE);
-		a->next = *ap;
-		*ap = a;
-	}
-
-	/* have space; do the "allocation." */
-	p = a->current;
-	a->current += size;
-	return p;
-}
-
-static char *string_area_strdup(struct string_area **ap, const char *src)
-{
-	char *dest = string_area_malloc(ap, strlen(src) + 1);
-	return strcpy(dest, src);
-}
-
 static void list_file_entry(struct file_struct *f)
 {
 	char perms[11];
 
 	if (!f->basename)
 		/* this can happen if duplicate names were removed */
 		return;
 
 	permstring(perms, f->mode);
 
+#if SUPPORT_LINKS
 	if (preserve_links && S_ISLNK(f->mode)) {
 		rprintf(FINFO, "%s %11.0f %s %s -> %s\n",
 			perms,
 			(double) f->length, timestring(f->modtime),
-			f_name(f), f->link);
-	} else {
+			f_name(f), f->u.link);
+	} else
+#endif
 		rprintf(FINFO, "%s %11.0f %s %s\n",
 			perms,
 			(double) f->length, timestring(f->modtime),
 			f_name(f));
-	}
 }
 
 
 /**
  * Stat either a symlink or its referent, depending on the settings of
  * copy_links, copy_unsafe_links, etc.
@@ -207,24 +164,21 @@
  * @post If @p path is a symlink, then @p linkbuf (of size @c
  * MAXPATHLEN) contains the symlink target.
  *
  * @post @p buffer contains information about the link or the
  * referrent as appropriate, if they exist.
  **/
-int readlink_stat(const char *path, STRUCT_STAT * buffer, char *linkbuf)
+int readlink_stat(const char *path, STRUCT_STAT *buffer, char *linkbuf)
 {
 #if SUPPORT_LINKS
-	if (copy_links) {
+	if (copy_links)
 		return do_stat(path, buffer);
-	}
-	if (do_lstat(path, buffer) == -1) {
+	if (do_lstat(path, buffer) == -1)
 		return -1;
-	}
 	if (S_ISLNK(buffer->st_mode)) {
-		int l;
-		l = readlink((char *) path, linkbuf, MAXPATHLEN - 1);
+		int l = readlink((char *) path, linkbuf, MAXPATHLEN - 1);
 		if (l == -1)
 			return -1;
 		linkbuf[l] = 0;
 		if (copy_unsafe_links && unsafe_symlink(linkbuf, path)) {
 			if (verbose > 1) {
 				rprintf(FINFO,"copying unsafe symlink \"%s\" -> \"%s\"\n",
@@ -239,29 +193,29 @@
 #endif
 }
 
 int link_stat(const char *path, STRUCT_STAT * buffer)
 {
 #if SUPPORT_LINKS
-	if (copy_links) {
+	if (copy_links)
 		return do_stat(path, buffer);
-	} else {
-		return do_lstat(path, buffer);
-	}
+	return do_lstat(path, buffer);
 #else
 	return do_stat(path, buffer);
 #endif
 }
 
 /*
  * This function is used to check if a file should be included/excluded
  * from the list of files based on its name and type etc.  The value of
  * exclude_level is set to either SERVER_EXCLUDES or ALL_EXCLUDES.
  */
 static int check_exclude_file(char *fname, int is_dir, int exclude_level)
 {
+	int rc;
+
 #if 0 /* This currently never happens, so avoid a useless compare. */
 	if (exclude_level == NO_EXCLUDES)
 		return 0;
 #endif
 	if (fname) {
 		/* never exclude '.', even if somebody does --exclude '*' */
@@ -271,21 +225,22 @@
 		if (fname[0] == '/') {
 			int len = strlen(fname);
 			if (fname[len-1] == '.' && fname[len-2] == '/')
 				return 0;
 		}
 	}
-	if (server_exclude_list
-	 && check_exclude(server_exclude_list, fname, is_dir))
+	if (server_exclude_list.head
+	    && check_exclude(&server_exclude_list, fname, is_dir) < 0)
 		return 1;
 	if (exclude_level != ALL_EXCLUDES)
 		return 0;
-	if (exclude_list && check_exclude(exclude_list, fname, is_dir))
-		return 1;
-	if (local_exclude_list
-	 && check_exclude(local_exclude_list, fname, is_dir))
+	if (exclude_list.head
+	    && (rc = check_exclude(&exclude_list, fname, is_dir)) != 0)
+		return rc < 0;
+	if (local_exclude_list.head
+	    && check_exclude(&local_exclude_list, fname, is_dir) < 0)
 		return 1;
 	return 0;
 }
 
 /* used by the one_file_system code */
 static dev_t filesystem_dev;
@@ -298,359 +253,472 @@
 	filesystem_dev = st.st_dev;
 }
 
 
 static int to_wire_mode(mode_t mode)
 {
-	if (S_ISLNK(mode) && (_S_IFLNK != 0120000)) {
+#if SUPPORT_LINKS
+	if (S_ISLNK(mode) && (_S_IFLNK != 0120000))
 		return (mode & ~(_S_IFMT)) | 0120000;
-	}
+#endif
 	return (int) mode;
 }
 
 static mode_t from_wire_mode(int mode)
 {
-	if ((mode & (_S_IFMT)) == 0120000 && (_S_IFLNK != 0120000)) {
+	if ((mode & (_S_IFMT)) == 0120000 && (_S_IFLNK != 0120000))
 		return (mode & ~(_S_IFMT)) | _S_IFLNK;
-	}
 	return (mode_t) mode;
 }
 
 
 static void send_directory(int f, struct file_list *flist, char *dir);
 
 static char *flist_dir;
+static int flist_dir_len;
 
 
 /**
  * Make sure @p flist is big enough to hold at least @p flist->count
  * entries.
  **/
-static void flist_expand(struct file_list *flist)
+void flist_expand(struct file_list *flist)
 {
-	if (flist->count >= flist->malloced) {
-		void *new_ptr;
+	void *new_ptr;
 
-		if (flist->malloced < 1000)
-			flist->malloced += 1000;
-		else
-			flist->malloced *= 2;
-
-		if (flist->files) {
-			new_ptr = realloc_array(flist->files,
-						struct file_struct *,
-						flist->malloced);
-		} else {
-			new_ptr = new_array(struct file_struct *,
-					    flist->malloced);
-		}
+	if (flist->count < flist->malloced)
+		return;
 
-		if (verbose >= 2) {
-			rprintf(FINFO, "expand file_list to %.0f bytes, did%s move\n",
-				(double)sizeof(flist->files[0])
-				* flist->malloced,
-				(new_ptr == flist->files) ? " not" : "");
-		}
+	if (flist->malloced < FLIST_START)
+		flist->malloced = FLIST_START;
+	else if (flist->malloced >= FLIST_LINEAR)
+		flist->malloced += FLIST_LINEAR;
+	else
+		flist->malloced *= 2;
 
-		flist->files = (struct file_struct **) new_ptr;
+	/*
+	 * In case count jumped or we are starting the list
+	 * with a known size just set it.
+	 */
+	if (flist->malloced < flist->count)
+		flist->malloced = flist->count;
+
+	if (flist->files) {
+		new_ptr = realloc_array(flist->files,
+		    struct file_struct *, flist->malloced);
+	} else {
+		new_ptr = new_array(struct file_struct *, flist->malloced);
+	}
 
-		if (!flist->files)
-			out_of_memory("flist_expand");
+	if (verbose >= 2) {
+		rprintf(FINFO, "[%s] expand file_list to %.0f bytes, did%s move\n",
+		    who_am_i(),
+		    (double) sizeof flist->files[0] * flist->malloced,
+		    (new_ptr == flist->files) ? " not" : "");
 	}
-}
 
+	flist->files = (struct file_struct **) new_ptr;
+
+	if (!flist->files)
+		out_of_memory("flist_expand");
+}
 
-static void send_file_entry(struct file_struct *file, int f,
-			    unsigned base_flags)
+void send_file_entry(struct file_struct *file, int f, unsigned short base_flags)
 {
-	unsigned char flags;
-	static time_t last_time;
-	static mode_t last_mode;
-	static DEV64_T last_rdev;
-	static uid_t last_uid;
-	static gid_t last_gid;
+	unsigned short flags;
+	static time_t modtime;
+	static mode_t mode;
+	static uint64 dev;
+	static dev_t rdev;
+	static uint32 rdev_major;
+	static uid_t uid;
+	static gid_t gid;
 	static char lastname[MAXPATHLEN];
-	char *fname;
+	char *fname, fbuf[MAXPATHLEN];
 	int l1, l2;
 
 	if (f == -1)
 		return;
 
 	if (!file) {
 		write_byte(f, 0);
+		modtime = 0, mode = 0;
+		dev = 0, rdev = makedev(0, 0);
+		rdev_major = 0;
+		uid = 0, gid = 0;
+		*lastname = '\0';
 		return;
 	}
 
 	io_write_phase = "send_file_entry";
 
-	fname = f_name(file);
+	fname = f_name_to(file, fbuf);
 
 	flags = base_flags;
 
-	if (file->mode == last_mode)
-		flags |= SAME_MODE;
-	if (file->rdev == last_rdev)
-		flags |= SAME_RDEV;
-	if (file->uid == last_uid)
-		flags |= SAME_UID;
-	if (file->gid == last_gid)
-		flags |= SAME_GID;
-	if (file->modtime == last_time)
-		flags |= SAME_TIME;
+	if (file->mode == mode)
+		flags |= XMIT_SAME_MODE;
+	else
+		mode = file->mode;
+	if (preserve_devices) {
+		if (protocol_version < 28) {
+			if (IS_DEVICE(mode)) {
+				if (file->u.rdev == rdev)
+					flags |= XMIT_SAME_RDEV_pre28;
+				else
+					rdev = file->u.rdev;
+			} else
+				rdev = makedev(0, 0);
+		} else if (IS_DEVICE(mode)) {
+			rdev = file->u.rdev;
+			if ((uint32)major(rdev) == rdev_major)
+				flags |= XMIT_SAME_RDEV_MAJOR;
+			else
+				rdev_major = major(rdev);
+			if ((uint32)minor(rdev) <= 0xFFu)
+				flags |= XMIT_RDEV_MINOR_IS_SMALL;
+		}
+	}
+	if (file->uid == uid)
+		flags |= XMIT_SAME_UID;
+	else
+		uid = file->uid;
+	if (file->gid == gid)
+		flags |= XMIT_SAME_GID;
+	else
+		gid = file->gid;
+	if (file->modtime == modtime)
+		flags |= XMIT_SAME_TIME;
+	else
+		modtime = file->modtime;
+
+#if SUPPORT_HARD_LINKS
+	if (file->link_u.idev) {
+		if (file->F_DEV == dev) {
+			if (protocol_version >= 28)
+				flags |= XMIT_SAME_DEV;
+		} else
+			dev = file->F_DEV;
+		flags |= XMIT_HAS_IDEV_DATA;
+	}
+#endif
 
 	for (l1 = 0;
-	     lastname[l1] && (fname[l1] == lastname[l1]) && (l1 < 255);
-	     l1++) {}
-	l2 = strlen(fname) - l1;
+	    lastname[l1] && (fname[l1] == lastname[l1]) && (l1 < 255);
+	    l1++) {}
+	l2 = strlen(fname+l1);
 
 	if (l1 > 0)
-		flags |= SAME_NAME;
+		flags |= XMIT_SAME_NAME;
 	if (l2 > 255)
-		flags |= LONG_NAME;
-
-	/* we must make sure we don't send a zero flags byte or the other
-	   end will terminate the flist transfer */
-	if (flags == 0 && !S_ISDIR(file->mode))
-		flags |= FLAG_DELETE;
-	if (flags == 0)
-		flags |= LONG_NAME;
+		flags |= XMIT_LONG_NAME;
 
-	write_byte(f, flags);
-	if (flags & SAME_NAME)
+	/* We must make sure we don't send a zero flag byte or the
+	 * other end will terminate the flist transfer.  Note that
+	 * the use of XMIT_TOP_DIR on a non-dir has no meaning, so
+	 * it's harmless way to add a bit to the first flag byte. */
+	if (protocol_version >= 28) {
+		if (!flags && !S_ISDIR(mode))
+			flags |= XMIT_TOP_DIR;
+		if ((flags & 0xFF00) || !flags) {
+			flags |= XMIT_EXTENDED_FLAGS;
+			write_byte(f, flags);
+			write_byte(f, flags >> 8);
+		} else
+			write_byte(f, flags);
+	} else {
+		if (!(flags & 0xFF) && !S_ISDIR(mode))
+			flags |= XMIT_TOP_DIR;
+		if (!(flags & 0xFF))
+			flags |= XMIT_LONG_NAME;
+		write_byte(f, flags);
+	}
+	if (flags & XMIT_SAME_NAME)
 		write_byte(f, l1);
-	if (flags & LONG_NAME)
+	if (flags & XMIT_LONG_NAME)
 		write_int(f, l2);
 	else
 		write_byte(f, l2);
 	write_buf(f, fname + l1, l2);
 
 	write_longint(f, file->length);
-	if (!(flags & SAME_TIME))
-		write_int(f, (int) file->modtime);
-	if (!(flags & SAME_MODE))
-		write_int(f, to_wire_mode(file->mode));
-	if (preserve_uid && !(flags & SAME_UID)) {
-		add_uid(file->uid);
-		write_int(f, (int) file->uid);
-	}
-	if (preserve_gid && !(flags & SAME_GID)) {
-		add_gid(file->gid);
-		write_int(f, (int) file->gid);
-	}
-	if (preserve_devices && IS_DEVICE(file->mode)
-	    && !(flags & SAME_RDEV))
-		write_int(f, (int) file->rdev);
+	if (!(flags & XMIT_SAME_TIME))
+		write_int(f, modtime);
+	if (!(flags & XMIT_SAME_MODE))
+		write_int(f, to_wire_mode(mode));
+	if (preserve_uid && !(flags & XMIT_SAME_UID)) {
+		if (!numeric_ids)
+			add_uid(uid);
+		write_int(f, uid);
+	}
+	if (preserve_gid && !(flags & XMIT_SAME_GID)) {
+		if (!numeric_ids)
+			add_gid(gid);
+		write_int(f, gid);
+	}
+	if (preserve_devices && IS_DEVICE(mode)) {
+		if (protocol_version < 28) {
+			if (!(flags & XMIT_SAME_RDEV_pre28))
+				write_int(f, (int)rdev);
+		} else {
+			if (!(flags & XMIT_SAME_RDEV_MAJOR))
+				write_int(f, major(rdev));
+			if (flags & XMIT_RDEV_MINOR_IS_SMALL)
+				write_byte(f, minor(rdev));
+			else
+				write_int(f, minor(rdev));
+		}
+	}
 
 #if SUPPORT_LINKS
-	if (preserve_links && S_ISLNK(file->mode)) {
-		write_int(f, strlen(file->link));
-		write_buf(f, file->link, strlen(file->link));
+	if (preserve_links && S_ISLNK(mode)) {
+		int len = strlen(file->u.link);
+		write_int(f, len);
+		write_buf(f, file->u.link, len);
 	}
 #endif
 
 #if SUPPORT_HARD_LINKS
-	if (preserve_hard_links && S_ISREG(file->mode)) {
+	if (flags & XMIT_HAS_IDEV_DATA) {
 		if (protocol_version < 26) {
 			/* 32-bit dev_t and ino_t */
-			write_int(f, (int) file->dev);
-			write_int(f, (int) file->inode);
+			write_int(f, dev);
+			write_int(f, file->F_INODE);
 		} else {
 			/* 64-bit dev_t and ino_t */
-			write_longint(f, file->dev);
-			write_longint(f, file->inode);
+			if (!(flags & XMIT_SAME_DEV))
+				write_longint(f, dev);
+			write_longint(f, file->F_INODE);
 		}
 	}
 #endif
 
 	if (always_checksum) {
-		if (protocol_version < 21) {
-			write_buf(f, file->sum, 2);
-		} else {
-			write_buf(f, file->sum, MD4_SUM_LENGTH);
+		char *sum;
+		if (S_ISREG(mode))
+			sum = file->u.sum;
+		else if (protocol_version < 28) {
+			/* Prior to 28, we sent a useless set of nulls. */
+			sum = empty_sum;
+		} else
+			sum = NULL;
+		if (sum) {
+			write_buf(f, sum,
+			    protocol_version < 21 ? 2 : MD4_SUM_LENGTH);
 		}
 	}
 
-	last_mode = file->mode;
-	last_rdev = file->rdev;
-	last_uid = file->uid;
-	last_gid = file->gid;
-	last_time = file->modtime;
-
 	strlcpy(lastname, fname, MAXPATHLEN);
-	lastname[MAXPATHLEN - 1] = 0;
 
 	io_write_phase = "unknown";
 }
 
 
 
-static void receive_file_entry(struct file_struct **fptr,
-			       unsigned flags, int f)
+void receive_file_entry(struct file_struct **fptr, unsigned short flags,
+    struct file_list *flist, int f)
 {
-	static time_t last_time;
-	static mode_t last_mode;
-	static DEV64_T last_rdev;
-	static uid_t last_uid;
-	static gid_t last_gid;
-	static char lastname[MAXPATHLEN];
+	static time_t modtime;
+	static mode_t mode;
+	static uint64 dev;
+	static dev_t rdev;
+	static uint32 rdev_major;
+	static uid_t uid;
+	static gid_t gid;
+	static char lastname[MAXPATHLEN], *lastdir;
+	static int lastdir_len = -1;
 	char thisname[MAXPATHLEN];
 	unsigned int l1 = 0, l2 = 0;
-	char *p;
+	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
+	OFF_T file_length;
+	char *basename, *dirname, *bp;
 	struct file_struct *file;
 
-	if (flags & SAME_NAME)
+	if (!fptr) {
+		modtime = 0, mode = 0;
+		dev = 0, rdev = makedev(0, 0);
+		rdev_major = 0;
+		uid = 0, gid = 0;
+		*lastname = '\0';
+		return;
+	}
+
+	if (flags & XMIT_SAME_NAME)
 		l1 = read_byte(f);
 
-	if (flags & LONG_NAME)
+	if (flags & XMIT_LONG_NAME)
 		l2 = read_int(f);
 	else
 		l2 = read_byte(f);
 
-	file = new(struct file_struct);
-	if (!file)
-		out_of_memory("receive_file_entry");
-	memset((char *) file, 0, sizeof(*file));
-	(*fptr) = file;
-
 	if (l2 >= MAXPATHLEN - l1) {
 		rprintf(FERROR,
 			"overflow: flags=0x%x l1=%d l2=%d lastname=%s\n",
 			flags, l1, l2, lastname);
 		overflow("receive_file_entry");
 	}
 
 	strlcpy(thisname, lastname, l1 + 1);
 	read_sbuf(f, &thisname[l1], l2);
 	thisname[l1 + l2] = 0;
 
 	strlcpy(lastname, thisname, MAXPATHLEN);
-	lastname[MAXPATHLEN - 1] = 0;
 
 	clean_fname(thisname);
 
-	if (sanitize_paths) {
+	if (sanitize_paths)
 		sanitize_path(thisname, NULL);
+
+	if ((basename = strrchr(thisname, '/')) != NULL) {
+		dirname_len = ++basename - thisname; /* counts future '\0' */
+		if (lastdir_len == dirname_len - 1
+		    && strncmp(thisname, lastdir, lastdir_len) == 0) {
+			dirname = lastdir;
+			dirname_len = 0; /* indicates no copy is needed */
+		} else
+			dirname = thisname;
+	} else {
+		basename = thisname;
+		dirname = NULL;
+		dirname_len = 0;
+	}
+	basename_len = strlen(basename) + 1; /* count the '\0' */
+
+	file_length = read_longint(f);
+	if (!(flags & XMIT_SAME_TIME))
+		modtime = (time_t)read_int(f);
+	if (!(flags & XMIT_SAME_MODE))
+		mode = from_wire_mode(read_int(f));
+
+	if (preserve_uid && !(flags & XMIT_SAME_UID))
+		uid = (uid_t)read_int(f);
+	if (preserve_gid && !(flags & XMIT_SAME_GID))
+		gid = (gid_t)read_int(f);
+
+	if (preserve_devices) {
+		if (protocol_version < 28) {
+			if (IS_DEVICE(mode)) {
+				if (!(flags & XMIT_SAME_RDEV_pre28))
+					rdev = (dev_t)read_int(f);
+			} else
+				rdev = makedev(0, 0);
+		} else if (IS_DEVICE(mode)) {
+			uint32 rdev_minor;
+			if (!(flags & XMIT_SAME_RDEV_MAJOR))
+				rdev_major = read_int(f);
+			if (flags & XMIT_RDEV_MINOR_IS_SMALL)
+				rdev_minor = read_byte(f);
+			else
+				rdev_minor = read_int(f);
+			rdev = makedev(rdev_major, rdev_minor);
+		}
 	}
 
-	if ((p = strrchr(thisname, '/'))) {
-		static char *lastdir;
-		*p = 0;
-		if (lastdir && strcmp(thisname, lastdir) == 0) {
-			file->dirname = lastdir;
-		} else {
-			file->dirname = strdup(thisname);
-			lastdir = file->dirname;
+#if SUPPORT_LINKS
+	if (preserve_links && S_ISLNK(mode)) {
+		linkname_len = read_int(f) + 1; /* count the '\0' */
+		if (linkname_len <= 0 || linkname_len > MAXPATHLEN) {
+			rprintf(FERROR, "overflow: linkname_len=%d\n",
+				linkname_len - 1);
+			overflow("receive_file_entry");
 		}
-		file->basename = strdup(p + 1);
-	} else {
-		file->dirname = NULL;
-		file->basename = strdup(thisname);
 	}
+	else
+#endif
+		linkname_len = 0;
 
-	if (!file->basename)
-		out_of_memory("receive_file_entry 1");
+	sum_len = always_checksum && S_ISREG(mode) ? MD4_SUM_LENGTH : 0;
 
+	alloc_len = file_struct_len + dirname_len + basename_len
+		  + linkname_len + sum_len;
+	bp = pool_alloc(flist->file_pool, alloc_len, "receive_file_entry");
+
+	file = *fptr = (struct file_struct *)bp;
+	memset(bp, 0, file_struct_len);
+	bp += file_struct_len;
+
+	file->flags = flags & XMIT_TOP_DIR ? FLAG_TOP_DIR : 0;
+	file->modtime = modtime;
+	file->length = file_length;
+	file->mode = mode;
+	file->uid = uid;
+	file->gid = gid;
+
+	if (dirname_len) {
+		file->dirname = lastdir = bp;
+		lastdir_len = dirname_len - 1;
+		memcpy(bp, dirname, dirname_len - 1);
+		bp += dirname_len;
+		bp[-1] = '\0';
+	} else if (dirname)
+		file->dirname = dirname;
+
+	file->basename = bp;
+	memcpy(bp, basename, basename_len);
+	bp += basename_len;
 
-	file->flags = flags;
-	file->length = read_longint(f);
-	file->modtime =
-	    (flags & SAME_TIME) ? last_time : (time_t) read_int(f);
-	file->mode =
-	    (flags & SAME_MODE) ? last_mode : from_wire_mode(read_int(f));
-	if (preserve_uid)
-		file->uid =
-		    (flags & SAME_UID) ? last_uid : (uid_t) read_int(f);
-	if (preserve_gid)
-		file->gid =
-		    (flags & SAME_GID) ? last_gid : (gid_t) read_int(f);
-	if (preserve_devices && IS_DEVICE(file->mode))
-		file->rdev =
-		    (flags & SAME_RDEV) ? last_rdev : (DEV64_T) read_int(f);
-
-	if (preserve_links && S_ISLNK(file->mode)) {
-		int l = read_int(f);
-		if (l < 0) {
-			rprintf(FERROR, "overflow: l=%d\n", l);
-			overflow("receive_file_entry");
-		}
-		file->link = new_array(char, l + 1);
-		if (!file->link)
-			out_of_memory("receive_file_entry 2");
-		read_sbuf(f, file->link, l);
-		if (sanitize_paths) {
-			sanitize_path(file->link, file->dirname);
-		}
+	if (preserve_devices && IS_DEVICE(mode))
+		file->u.rdev = rdev;
+
+#if SUPPORT_LINKS
+	if (linkname_len) {
+		file->u.link = bp;
+		read_sbuf(f, bp, linkname_len - 1);
+		if (sanitize_paths)
+			sanitize_path(bp, lastdir);
+		bp += linkname_len;
 	}
+#endif
+
 #if SUPPORT_HARD_LINKS
-	if (preserve_hard_links && S_ISREG(file->mode)) {
+	if (preserve_hard_links && protocol_version < 28 && S_ISREG(mode))
+		flags |= XMIT_HAS_IDEV_DATA;
+	if (flags & XMIT_HAS_IDEV_DATA) {
+		uint64 inode;
 		if (protocol_version < 26) {
-			file->dev = read_int(f);
-			file->inode = read_int(f);
+			dev = read_int(f);
+			inode = read_int(f);
 		} else {
-			file->dev = read_longint(f);
-			file->inode = read_longint(f);
+			if (!(flags & XMIT_SAME_DEV))
+				dev = read_longint(f);
+			inode = read_longint(f);
+		}
+		if (flist->hlink_pool) {
+			file->link_u.idev = pool_talloc(flist->hlink_pool,
+			    struct idev, 1, "inode_table");
+			file->F_INODE = inode;
+			file->F_DEV = dev;
 		}
 	}
 #endif
 
 	if (always_checksum) {
-		file->sum = new_array(char, MD4_SUM_LENGTH);
-		if (!file->sum)
-			out_of_memory("md4 sum");
-		if (protocol_version < 21) {
-			read_buf(f, file->sum, 2);
-		} else {
-			read_buf(f, file->sum, MD4_SUM_LENGTH);
+		char *sum;
+		if (sum_len) {
+			file->u.sum = sum = bp;
+			/*bp += sum_len;*/
+		} else if (protocol_version < 28) {
+			/* Prior to 28, we get a useless set of nulls. */
+			sum = empty_sum;
+		} else
+			sum = NULL;
+		if (sum) {
+			read_buf(f, sum,
+			    protocol_version < 21 ? 2 : MD4_SUM_LENGTH);
 		}
 	}
 
-	last_mode = file->mode;
-	last_rdev = file->rdev;
-	last_uid = file->uid;
-	last_gid = file->gid;
-	last_time = file->modtime;
-
 	if (!preserve_perms) {
 		extern int orig_umask;
 		/* set an appropriate set of permissions based on original
-		   permissions and umask. This emulates what GNU cp does */
+		 * permissions and umask. This emulates what GNU cp does */
 		file->mode &= ~orig_umask;
 	}
 }
 
 
-/* determine if a file in a different filesstem should be skipped
-   when one_file_system is set. We bascally only want to include
-   the mount points - but they can be hard to find! */
-static int skip_filesystem(char *fname, STRUCT_STAT * st)
-{
-	STRUCT_STAT st2;
-	char *p = strrchr(fname, '/');
-
-	/* skip all but directories */
-	if (!S_ISDIR(st->st_mode))
-		return 1;
-
-	/* if its not a subdirectory then allow */
-	if (!p)
-		return 0;
-
-	*p = 0;
-	if (link_stat(fname, &st2)) {
-		*p = '/';
-		return 0;
-	}
-	*p = '/';
-
-	return (st2.st_dev != filesystem_dev);
-}
-
-#define STRDUP(ap, p)	(ap ? string_area_strdup(ap, p) : strdup(p))
-/* IRIX cc cares that the operands to the ternary have the same type. */
-#define MALLOC(ap, i)	(ap ? (void*) string_area_malloc(ap, i) : malloc(i))
-
 /**
  * Create a file_struct for a named file by reading its stat()
  * information and performing extensive checks against global
  * options.
  *
  * @return the new file, or NULL if there was an error or this file
@@ -660,138 +728,191 @@
  * stat()ing the file in some circumstances, which has a certain cost.
  * We are called immediately after doing readdir(), and so we may
  * already know the d_type of the file.  We could for example avoid
  * statting directories if we're not recursing, but this is not a very
  * important case.  Some systems may not have d_type.
  **/
-struct file_struct *make_file(char *fname, struct string_area **ap,
-			      int exclude_level)
+struct file_struct *make_file(char *fname,
+    struct file_list *flist, int exclude_level)
 {
+	static char *lastdir;
+	static int lastdir_len = -1;
 	struct file_struct *file;
 	STRUCT_STAT st;
 	char sum[SUM_LENGTH];
-	char *p;
-	char cleaned_name[MAXPATHLEN];
-	char linkbuf[MAXPATHLEN];
-	extern int module_id;
-
-	strlcpy(cleaned_name, fname, MAXPATHLEN);
-	cleaned_name[MAXPATHLEN - 1] = 0;
-	clean_fname(cleaned_name);
-	if (sanitize_paths) {
-		sanitize_path(cleaned_name, NULL);
+	char thisname[MAXPATHLEN];
+	char linkname[MAXPATHLEN];
+	int alloc_len, basename_len, dirname_len, linkname_len, sum_len;
+	char *basename, *dirname, *bp;
+	unsigned short flags = 0;
+
+	if (!flist)	/* lastdir isn't valid if flist is NULL */
+		lastdir_len = -1;
+
+	if (strlcpy(thisname, fname, sizeof thisname)
+	    >= sizeof thisname - flist_dir_len) {
+		rprintf(FINFO, "skipping overly long name: %s\n", fname);
+		return NULL;
 	}
-	fname = cleaned_name;
+	clean_fname(thisname);
+	if (sanitize_paths)
+		sanitize_path(thisname, NULL);
 
 	memset(sum, 0, SUM_LENGTH);
 
-	if (readlink_stat(fname, &st, linkbuf) != 0) {
+	if (readlink_stat(thisname, &st, linkname) != 0) {
 		int save_errno = errno;
-		if (errno == ENOENT && exclude_level != NO_EXCLUDES) {
+		if (errno == ENOENT) {
+			enum logcode c = am_daemon && protocol_version < 28
+			    ? FERROR : FINFO;
 			/* either symlink pointing nowhere or file that
 			 * was removed during rsync run; see if excluded
 			 * before reporting an error */
-			if (check_exclude_file(fname, 0, exclude_level)) {
+			if (exclude_level != NO_EXCLUDES
+			    && check_exclude_file(thisname, 0, exclude_level)) {
 				/* file is excluded anyway, ignore silently */
 				return NULL;
 			}
+			io_error |= IOERR_VANISHED;
+			rprintf(c, "file has vanished: %s\n",
+			    full_fname(thisname));
+		}
+		else {
+			io_error |= IOERR_GENERAL;
+			rprintf(FERROR, "readlink %s failed: %s\n",
+			    full_fname(thisname), strerror(save_errno));
 		}
-		io_error |= IOERR_GENERAL;
-		rprintf(FERROR, "readlink %s failed: %s\n",
-			full_fname(fname), strerror(save_errno));
 		return NULL;
 	}
 
 	/* backup.c calls us with exclude_level set to NO_EXCLUDES. */
 	if (exclude_level == NO_EXCLUDES)
 		goto skip_excludes;
 
 	if (S_ISDIR(st.st_mode) && !recurse && !files_from) {
-		rprintf(FINFO, "skipping directory %s\n", fname);
+		rprintf(FINFO, "skipping directory %s\n", thisname);
 		return NULL;
 	}
 
-	if (one_file_system && st.st_dev != filesystem_dev) {
-		if (skip_filesystem(fname, &st))
-			return NULL;
-	}
+	/* We only care about directories because we need to avoid recursing
+	 * into a mount-point directory, not to avoid copying a symlinked
+	 * file if -L (or similar) was specified. */
+	if (one_file_system && st.st_dev != filesystem_dev
+	    && S_ISDIR(st.st_mode))
+		flags |= FLAG_MOUNT_POINT;
 
-	if (check_exclude_file(fname, S_ISDIR(st.st_mode) != 0, exclude_level))
+	if (check_exclude_file(thisname, S_ISDIR(st.st_mode) != 0, exclude_level))
 		return NULL;
 
-	if (lp_ignore_nonreadable(module_id) && access(fname, R_OK) != 0)
+	if (lp_ignore_nonreadable(module_id) && access(thisname, R_OK) != 0)
 		return NULL;
 
-      skip_excludes:
+skip_excludes:
 
-	if (verbose > 2)
-		rprintf(FINFO, "make_file(%s,*,%d)\n", fname, exclude_level);
+	if (verbose > 2) {
+		rprintf(FINFO, "[%s] make_file(%s,*,%d)\n",
+			who_am_i(), thisname, exclude_level);
+	}
 
-	file = new(struct file_struct);
-	if (!file)
-		out_of_memory("make_file");
-	memset((char *) file, 0, sizeof(*file));
+	if ((basename = strrchr(thisname, '/')) != NULL) {
+		dirname_len = ++basename - thisname; /* counts future '\0' */
+		if (lastdir_len == dirname_len - 1
+		    && strncmp(thisname, lastdir, lastdir_len) == 0) {
+			dirname = lastdir;
+			dirname_len = 0; /* indicates no copy is needed */
+		} else
+			dirname = thisname;
+	} else {
+		basename = thisname;
+		dirname = NULL;
+		dirname_len = 0;
+	}
+	basename_len = strlen(basename) + 1; /* count the '\0' */
 
-	if ((p = strrchr(fname, '/'))) {
-		static char *lastdir;
-		*p = 0;
-		if (lastdir && strcmp(fname, lastdir) == 0) {
-			file->dirname = lastdir;
-		} else {
-			file->dirname = strdup(fname);
-			lastdir = file->dirname;
-		}
-		file->basename = STRDUP(ap, p + 1);
-		*p = '/';
+#if SUPPORT_LINKS
+	linkname_len = S_ISLNK(st.st_mode) ? strlen(linkname) + 1 : 0;
+#else
+	linkname_len = 0;
+#endif
+
+	sum_len = always_checksum && S_ISREG(st.st_mode) ? MD4_SUM_LENGTH : 0;
+
+	alloc_len = file_struct_len + dirname_len + basename_len
+	    + linkname_len + sum_len;
+	if (flist) {
+		bp = pool_alloc(flist->file_pool, alloc_len,
+		    "receive_file_entry");
 	} else {
-		file->dirname = NULL;
-		file->basename = STRDUP(ap, fname);
+		if (!(bp = new_array(char, alloc_len)))
+			out_of_memory("receive_file_entry");
 	}
 
+	file = (struct file_struct *)bp;
+	memset(bp, 0, file_struct_len);
+	bp += file_struct_len;
+
+	file->flags = flags;
 	file->modtime = st.st_mtime;
 	file->length = st.st_size;
 	file->mode = st.st_mode;
 	file->uid = st.st_uid;
 	file->gid = st.st_gid;
-	file->dev = st.st_dev;
-	file->inode = st.st_ino;
+
+#if SUPPORT_HARD_LINKS
+	if (flist && flist->hlink_pool) {
+		if (protocol_version < 28) {
+			if (S_ISREG(st.st_mode))
+				file->link_u.idev = pool_talloc(
+				    flist->hlink_pool, struct idev, 1,
+				    "inode_table");
+		} else {
+			if (!S_ISDIR(st.st_mode) && st.st_nlink > 1)
+				file->link_u.idev = pool_talloc(
+				    flist->hlink_pool, struct idev, 1,
+				    "inode_table");
+		}
+	}
+	if (file->link_u.idev) {
+		file->F_DEV = st.st_dev;
+		file->F_INODE = st.st_ino;
+	}
+#endif
+
+	if (dirname_len) {
+		file->dirname = lastdir = bp;
+		lastdir_len = dirname_len - 1;
+		memcpy(bp, dirname, dirname_len - 1);
+		bp += dirname_len;
+		bp[-1] = '\0';
+	} else if (dirname)
+		file->dirname = dirname;
+
+	file->basename = bp;
+	memcpy(bp, basename, basename_len);
+	bp += basename_len;
+
 #ifdef HAVE_STRUCT_STAT_ST_RDEV
-	file->rdev = st.st_rdev;
+	if (preserve_devices && IS_DEVICE(st.st_mode))
+		file->u.rdev = st.st_rdev;
 #endif
 
 #if SUPPORT_LINKS
-	if (S_ISLNK(st.st_mode)) {
-		file->link = STRDUP(ap, linkbuf);
+	if (linkname_len) {
+		file->u.link = bp;
+		memcpy(bp, linkname, linkname_len);
+		bp += linkname_len;
 	}
 #endif
 
-	if (always_checksum) {
-		file->sum = (char *) MALLOC(ap, MD4_SUM_LENGTH);
-		if (!file->sum)
-			out_of_memory("md4 sum");
-		/* drat. we have to provide a null checksum for non-regular
-		   files in order to be compatible with earlier versions
-		   of rsync */
-		if (S_ISREG(st.st_mode)) {
-			file_checksum(fname, file->sum, st.st_size);
-		} else {
-			memset(file->sum, 0, MD4_SUM_LENGTH);
-		}
+	if (sum_len) {
+		file->u.sum = bp;
+		file_checksum(thisname, bp, st.st_size);
+		/*bp += sum_len;*/
 	}
 
-	if (flist_dir) {
-		static char *lastdir;
-		if (lastdir && strcmp(lastdir, flist_dir) == 0) {
-			file->basedir = lastdir;
-		} else {
-			file->basedir = strdup(flist_dir);
-			lastdir = file->basedir;
-		}
-	} else {
-		file->basedir = NULL;
-	}
+	file->basedir = flist_dir;
 
 	if (!S_ISDIR(st.st_mode))
 		stats.total_size += st.st_size;
 
 	return file;
 }
@@ -794,87 +915,84 @@
 		stats.total_size += st.st_size;
 
 	return file;
 }
 
 
-
 void send_file_name(int f, struct file_list *flist, char *fname,
-		    int recursive, unsigned base_flags)
+		    int recursive, unsigned short base_flags)
 {
 	struct file_struct *file;
+	char fbuf[MAXPATHLEN];
 	extern int delete_excluded;
 
 	/* f is set to -1 when calculating deletion file list */
-	file = make_file(fname, &flist->string_area,
-			 f == -1 && delete_excluded? SERVER_EXCLUDES
-						   : ALL_EXCLUDES);
+	file = make_file(fname, flist,
+	    f == -1 && delete_excluded? SERVER_EXCLUDES : ALL_EXCLUDES);
 
 	if (!file)
 		return;
 
 	maybe_emit_filelist_progress(flist);
 
 	flist_expand(flist);
 
-	if (write_batch)	/*  dw  */
-		file->flags = FLAG_DELETE;
+	if (write_batch)
+		file->flags |= FLAG_TOP_DIR;
 
 	if (file->basename[0]) {
 		flist->files[flist->count++] = file;
 		send_file_entry(file, f, base_flags);
 	}
 
-	if (S_ISDIR(file->mode) && recursive) {
-		struct exclude_struct **last_exclude_list =
-		    local_exclude_list;
-		send_directory(f, flist, f_name(file));
-		local_exclude_list = last_exclude_list;
-		return;
+	if (recursive && S_ISDIR(file->mode)
+	    && !(file->flags & FLAG_MOUNT_POINT)) {
+		struct exclude_list_struct last_list = local_exclude_list;
+		local_exclude_list.head = local_exclude_list.tail = NULL;
+		send_directory(f, flist, f_name_to(file, fbuf));
+		free_exclude_list(&local_exclude_list);
+		local_exclude_list = last_list;
 	}
 }
 
 
-
 static void send_directory(int f, struct file_list *flist, char *dir)
 {
 	DIR *d;
 	struct dirent *di;
 	char fname[MAXPATHLEN];
-	int l;
+	unsigned int offset;
 	char *p;
 
 	d = opendir(dir);
 	if (!d) {
 		io_error |= IOERR_GENERAL;
 		rprintf(FERROR, "opendir %s failed: %s\n",
 			full_fname(dir), strerror(errno));
 		return;
 	}
 
-	strlcpy(fname, dir, MAXPATHLEN);
-	l = strlen(fname);
-	if (fname[l - 1] != '/') {
-		if (l == MAXPATHLEN - 1) {
+	offset = strlcpy(fname, dir, MAXPATHLEN);
+	p = fname + offset;
+	if (offset >= MAXPATHLEN || p[-1] != '/') {
+		if (offset >= MAXPATHLEN - 1) {
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR, "skipping long-named directory: %s\n",
 				full_fname(fname));
 			closedir(d);
 			return;
 		}
-		strlcat(fname, "/", MAXPATHLEN);
-		l++;
+		*p++ = '/';
+		offset++;
 	}
-	p = fname + strlen(fname);
-
-	local_exclude_list = NULL;
 
 	if (cvs_exclude) {
-		if (strlen(fname) + strlen(".cvsignore") <= MAXPATHLEN - 1) {
-			strcpy(p, ".cvsignore");
-			add_exclude_file(&exclude_list,fname,MISSING_OK,ADD_EXCLUDE);
+		if (strlcpy(p, ".cvsignore", MAXPATHLEN - offset)
+		    < MAXPATHLEN - offset) {
+			add_exclude_file(&local_exclude_list, fname,
+					 XFLG_WORD_SPLIT | XFLG_WORDS_ONLY);
 		} else {
 			io_error |= IOERR_GENERAL;
 			rprintf(FINFO,
 				"cannot cvs-exclude in long-named directory %s\n",
 				full_fname(fname));
 		}
@@ -882,24 +1000,27 @@
 
 	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
 		if (dname[0] == '.' && (dname[1] == '\0'
 		    || (dname[1] == '.' && dname[2] == '\0')))
 			continue;
-		strlcpy(p, dname, MAXPATHLEN - l);
-		send_file_name(f, flist, fname, recurse, 0);
+		if (strlcpy(p, dname, MAXPATHLEN - offset) < MAXPATHLEN - offset)
+			send_file_name(f, flist, fname, recurse, 0);
+		else {
+			io_error |= IOERR_GENERAL;
+			rprintf(FINFO,
+				"cannot send long-named file %s\n",
+				full_fname(fname));
+		}
 	}
 	if (errno) {
 		io_error |= IOERR_GENERAL;
 		rprintf(FERROR, "readdir(%s): (%d) %s\n",
-		    dir, errno, strerror(errno));
+			dir, errno, strerror(errno));
 	}
 
-	if (local_exclude_list)
-		free_exclude_list(&local_exclude_list); /* Zeros pointer too */
-
 	closedir(d);
 }
 
 
 /**
  * The delete_files() function in receiver.c sets f to -1 so that we just
@@ -908,29 +1029,30 @@
  * is set (so that the delete list includes user-excluded files).
  **/
 struct file_list *send_file_list(int f, int argc, char *argv[])
 {
 	int l;
 	STRUCT_STAT st;
-	char *p, *dir, *olddir;
+	char *p, *dir, olddir[sizeof curr_dir];
 	char lastpath[MAXPATHLEN] = "";
 	struct file_list *flist;
 	int64 start_write;
 	int use_ff_fd = 0;
 
 	if (show_filelist_p() && f != -1)
 		start_filelist_progress("building file list");
 
 	start_write = stats.total_written;
 
-	flist = flist_new();
+	flist = flist_new(f == -1 ? WITHOUT_HLINK : WITH_HLINK,
+	    "send_file_list");
 
 	if (f != -1) {
-		io_start_buffering(f);
+		io_start_buffering_out(f);
 		if (filesfrom_fd >= 0) {
-			if (argv[0] && !push_dir(argv[0], 0)) {
+			if (argv[0] && !push_dir(argv[0])) {
 				rprintf(FERROR, "push_dir %s failed: %s\n",
 					full_fname(argv[0]), strerror(errno));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			use_ff_fd = 1;
 		}
@@ -954,14 +1076,15 @@
 
 		l = strlen(fname);
 		if (fname[l - 1] == '/') {
 			if (l == 2 && fname[0] == '.') {
 				/* Turn "./" into just "." rather than "./." */
 				fname[1] = '\0';
-			} else {
-				strlcat(fname, ".", MAXPATHLEN);
+			} else if (l < MAXPATHLEN) {
+				fname[l++] = '.';
+				fname[l] = '\0';
 			}
 		}
 
 		if (link_stat(fname, &st) != 0) {
 			if (f != -1) {
 				io_error |= IOERR_GENERAL;
@@ -974,13 +1097,13 @@
 		if (S_ISDIR(st.st_mode) && !recurse && !files_from) {
 			rprintf(FINFO, "skipping directory %s\n", fname);
 			continue;
 		}
 
 		dir = NULL;
-		olddir = NULL;
+		olddir[0] = '\0';
 
 		if (!relative_paths) {
 			p = strrchr(fname, '/');
 			if (p) {
 				*p = 0;
 				if (p == fname)
@@ -1025,152 +1148,163 @@
 		}
 
 		if (!*fname)
 			fname = ".";
 
 		if (dir && *dir) {
-			olddir = push_dir(dir, 1);
+			static char *lastdir;
+			static int lastdir_len;
+
+			strcpy(olddir, curr_dir); /* can't overflow */
 
-			if (!olddir) {
+			if (!push_dir(dir)) {
 				io_error |= IOERR_GENERAL;
 				rprintf(FERROR, "push_dir %s failed: %s\n",
 					full_fname(dir), strerror(errno));
 				continue;
 			}
 
-			flist_dir = dir;
+			if (lastdir && strcmp(lastdir, dir) == 0) {
+				flist_dir = lastdir;
+				flist_dir_len = lastdir_len;
+			} else {
+				flist_dir = lastdir = strdup(dir);
+				flist_dir_len = lastdir_len = strlen(dir);
+			}
 		}
 
 		if (one_file_system)
 			set_filesystem(fname);
 
-		send_file_name(f, flist, fname, recurse, FLAG_DELETE);
+		send_file_name(f, flist, fname, recurse, XMIT_TOP_DIR);
 
-		if (olddir != NULL) {
+		if (olddir[0]) {
 			flist_dir = NULL;
-			if (pop_dir(olddir) != 0) {
+			flist_dir_len = 0;
+			if (!pop_dir(olddir)) {
 				rprintf(FERROR, "pop_dir %s failed: %s\n",
 					full_fname(dir), strerror(errno));
 				exit_cleanup(RERR_FILESELECT);
 			}
 		}
 	}
 
 	if (f != -1) {
 		send_file_entry(NULL, f, 0);
+
+		if (show_filelist_p())
+			finish_filelist_progress(flist);
 	}
 
-	if (show_filelist_p() && f != -1) {
-		finish_filelist_progress(flist);
+	if (flist->hlink_pool) {
+		pool_destroy(flist->hlink_pool);
+		flist->hlink_pool = NULL;
 	}
 
 	clean_flist(flist, 0, 0);
 
-	/* now send the uid/gid list. This was introduced in protocol
-	   version 15 */
 	if (f != -1) {
+		/* Now send the uid/gid list. This was introduced in
+		 * protocol version 15 */
 		send_uid_list(f);
-	}
 
-	/* send the io_error flag */
-	if (f != -1) {
-		extern int module_id;
+		/* send the io_error flag */
 		write_int(f, lp_ignore_errors(module_id) ? 0 : io_error);
-	}
 
-	if (f != -1) {
 		io_end_buffering();
 		stats.flist_size = stats.total_written - start_write;
 		stats.num_files = flist->count;
-		if (write_batch)	/*  dw  */
+		if (write_batch)
 			write_batch_flist_info(flist->count, flist->files);
 	}
 
+	if (verbose > 3)
+		output_flist(flist);
+
 	if (verbose > 2)
 		rprintf(FINFO, "send_file_list done\n");
 
 	return flist;
 }
 
 
 struct file_list *recv_file_list(int f)
 {
 	struct file_list *flist;
-	unsigned char flags;
+	unsigned short flags;
 	int64 start_read;
 	extern int list_only;
 
 	if (show_filelist_p())
 		start_filelist_progress("receiving file list");
 
 	start_read = stats.total_read;
 
-	flist = new(struct file_list);
-	if (!flist)
-		goto oom;
+	flist = flist_new(WITH_HLINK, "recv_file_list");
 
 	flist->count = 0;
 	flist->malloced = 1000;
 	flist->files = new_array(struct file_struct *, flist->malloced);
 	if (!flist->files)
 		goto oom;
 
 
-	for (flags = read_byte(f); flags; flags = read_byte(f)) {
+	while ((flags = read_byte(f)) != 0) {
 		int i = flist->count;
 
 		flist_expand(flist);
 
-		receive_file_entry(&flist->files[i], flags, f);
+		if (protocol_version >= 28 && (flags & XMIT_EXTENDED_FLAGS))
+			flags |= read_byte(f) << 8;
+		receive_file_entry(&flist->files[i], flags, flist, f);
 
 		if (S_ISREG(flist->files[i]->mode))
 			stats.total_size += flist->files[i]->length;
 
 		flist->count++;
 
 		maybe_emit_filelist_progress(flist);
 
-		if (verbose > 2)
+		if (verbose > 2) {
 			rprintf(FINFO, "recv_file_name(%s)\n",
 				f_name(flist->files[i]));
+		}
 	}
-
+	receive_file_entry(NULL, 0, NULL, 0); /* Signal that we're done. */
 
 	if (verbose > 2)
 		rprintf(FINFO, "received %d names\n", flist->count);
 
-	clean_flist(flist, relative_paths, 1);
-
-	if (show_filelist_p()) {
+	if (show_filelist_p())
 		finish_filelist_progress(flist);
-	}
 
-	/* now recv the uid/gid list. This was introduced in protocol version 15 */
+	clean_flist(flist, relative_paths, 1);
+
 	if (f != -1) {
+		/* Now send the uid/gid list. This was introduced in
+		 * protocol version 15 */
 		recv_uid_list(f, flist);
-	}
 
-	/* recv the io_error flag */
-	if (f != -1 && !read_batch) {	/* dw-added readbatch */
-		extern int module_id;
-		extern int ignore_errors;
-		if (lp_ignore_errors(module_id) || ignore_errors) {
-			read_int(f);
-		} else {
-			io_error |= read_int(f);
+		if (!read_batch) {
+			/* Recv the io_error flag */
+			if (lp_ignore_errors(module_id) || ignore_errors)
+				read_int(f);
+			else
+				io_error |= read_int(f);
 		}
 	}
 
+	if (verbose > 3)
+		output_flist(flist);
+
 	if (list_only) {
 		int i;
-		for (i = 0; i < flist->count; i++) {
+		for (i = 0; i < flist->count; i++)
 			list_file_entry(flist->files[i]);
-		}
 	}
 
-
 	if (verbose > 2)
 		rprintf(FINFO, "recv_file_list done\n");
 
 	stats.flist_size = stats.total_read - start_read;
 	stats.num_files = flist->count;
 
@@ -1173,33 +1307,32 @@
 
 	stats.flist_size = stats.total_read - start_read;
 	stats.num_files = flist->count;
 
 	return flist;
 
-      oom:
+oom:
 	out_of_memory("recv_file_list");
 	return NULL;		/* not reached */
 }
 
 
-/*
- * XXX: This is currently the hottest function while building the file
- * list, because building f_name()s every time is expensive.
- **/
-int file_compare(struct file_struct **f1, struct file_struct **f2)
+int file_compare(struct file_struct **file1, struct file_struct **file2)
 {
-	if (!(*f1)->basename && !(*f2)->basename)
+	struct file_struct *f1 = *file1;
+	struct file_struct *f2 = *file2;
+
+	if (!f1->basename && !f2->basename)
 		return 0;
-	if (!(*f1)->basename)
+	if (!f1->basename)
 		return -1;
-	if (!(*f2)->basename)
+	if (!f2->basename)
 		return 1;
-	if ((*f1)->dirname == (*f2)->dirname)
-		return u_strcmp((*f1)->basename, (*f2)->basename);
-	return u_strcmp(f_name(*f1), f_name(*f2));
+	if (f1->dirname == f2->dirname)
+		return u_strcmp(f1->basename, f2->basename);
+	return f_name_cmp(f1, f2);
 }
 
 
 int flist_find(struct file_list *flist, struct file_struct *f)
 {
 	int low = 0, high = flist->count - 1;
@@ -1208,21 +1341,19 @@
 
 	if (high < 0)
 		return -1;
 
 	while (low != high) {
 		int mid = (low + high) / 2;
-		int ret =
-		    file_compare(&flist->files[flist_up(flist, mid)], &f);
+		int ret = file_compare(&flist->files[flist_up(flist, mid)],&f);
 		if (ret == 0)
 			return flist_up(flist, mid);
-		if (ret > 0) {
+		if (ret > 0)
 			high = mid;
-		} else {
+		else
 			low = mid + 1;
-		}
 	}
 
 	if (file_compare(&flist->files[flist_up(flist, low)], &f) == 0)
 		return flist_up(flist, low);
 	return -1;
 }
@@ -1224,50 +1355,49 @@
 
 	if (file_compare(&flist->files[flist_up(flist, low)], &f) == 0)
 		return flist_up(flist, low);
 	return -1;
 }
 
-
 /*
- * free up one file
+ * Free up any resources a file_struct has allocated
+ * and clear the file.
  */
-void free_file(struct file_struct *file)
+void clear_file(int i, struct file_list *flist)
 {
-	if (!file)
-		return;
-	if (file->basename)
-		free(file->basename);
-	if (file->link)
-		free(file->link);
-	if (file->sum)
-		free(file->sum);
-	*file = null_file;
+	if (flist->hlink_pool && flist->files[i]->link_u.idev)
+		pool_free(flist->hlink_pool, 0, flist->files[i]->link_u.idev);
+	memset(flist->files[i], 0, file_struct_len);
 }
 
 
 /*
  * allocate a new file list
  */
-struct file_list *flist_new(void)
+struct file_list *flist_new(int with_hlink, char *msg)
 {
 	struct file_list *flist;
 
 	flist = new(struct file_list);
 	if (!flist)
-		out_of_memory("send_file_list");
+		out_of_memory(msg);
 
-	flist->count = 0;
-	flist->malloced = 0;
-	flist->files = NULL;
+	memset(flist, 0, sizeof (struct file_list));
 
-#if ARENA_SIZE > 0
-	flist->string_area = string_area_new(0);
-#else
-	flist->string_area = NULL;
+	if (!(flist->file_pool = pool_create(FILE_EXTENT, 0,
+	    out_of_memory, POOL_INTERN)))
+		out_of_memory(msg);
+
+#if SUPPORT_HARD_LINKS
+	if (with_hlink && preserve_hard_links) {
+		if (!(flist->hlink_pool = pool_create(HLINK_EXTENT,
+		    sizeof (struct idev), out_of_memory, POOL_INTERN)))
+			out_of_memory(msg);
+	}
 #endif
+
 	return flist;
 }
 
 /*
  * free up all elements in a flist
  */
@@ -1270,83 +1400,57 @@
 
 /*
  * free up all elements in a flist
  */
 void flist_free(struct file_list *flist)
 {
-	int i;
-	for (i = 1; i < flist->count; i++) {
-		if (!flist->string_area)
-			free_file(flist->files[i]);
-		free(flist->files[i]);
-	}
-	/* FIXME: I don't think we generally need to blank the flist
-	 * since it's about to be freed.  This will just cause more
-	 * memory traffic.  If you want a freed-memory debugger, you
-	 * know where to get it. */
-	memset((char *) flist->files, 0,
-	       sizeof(flist->files[0]) * flist->count);
+	pool_destroy(flist->file_pool);
+	pool_destroy(flist->hlink_pool);
 	free(flist->files);
-	if (flist->string_area)
-		string_area_free(flist->string_area);
-	memset((char *) flist, 0, sizeof(*flist));
 	free(flist);
 }
 
 
 /*
  * This routine ensures we don't have any duplicate names in our file list.
  * duplicate names can cause corruption because of the pipelining
  */
 static void clean_flist(struct file_list *flist, int strip_root, int no_dups)
 {
 	int i, prev_i = 0;
-	char *name, *prev_name = NULL;
 
 	if (!flist || flist->count == 0)
 		return;
 
 	qsort(flist->files, flist->count,
-	      sizeof(flist->files[0]), (int (*)()) file_compare);
+	    sizeof flist->files[0], (int (*)()) file_compare);
 
 	for (i = no_dups? 0 : flist->count; i < flist->count; i++) {
 		if (flist->files[i]->basename) {
 			prev_i = i;
-			prev_name = f_name(flist->files[i]);
 			break;
 		}
 	}
 	while (++i < flist->count) {
 		if (!flist->files[i]->basename)
 			continue;
-		name = f_name(flist->files[i]);
-		if (strcmp(name, prev_name) == 0) {
+		if (f_name_cmp(flist->files[i], flist->files[prev_i]) == 0) {
 			if (verbose > 1 && !am_server) {
 				rprintf(FINFO,
 					"removing duplicate name %s from file list %d\n",
-					name, i);
+					f_name(flist->files[i]), i);
 			}
 			/* Make sure that if we unduplicate '.', that we don't
 			 * lose track of a user-specified starting point (or
 			 * else deletions will mysteriously fail with -R). */
-			if (flist->files[i]->flags & FLAG_DELETE)
-				flist->files[prev_i]->flags |= FLAG_DELETE;
-			/* it's not great that the flist knows the semantics of
-			 * the file memory usage, but i'd rather not add a flag
-			 * byte to that struct.
-			 * XXX can i use a bit in the flags field? */
-			if (flist->string_area)
-				flist->files[i][0] = null_file;
-			else
-				free_file(flist->files[i]);
-		}
-		else
+			if (flist->files[i]->flags & FLAG_TOP_DIR)
+				flist->files[prev_i]->flags |= FLAG_TOP_DIR;
+
+			clear_file(i, flist);
+		} else
 			prev_i = i;
-		/* We set prev_name every iteration to avoid it becoming
-		 * invalid when names[][] in f_name() wraps around. */
-		prev_name = name;
 	}
 
 	if (strip_root) {
 		/* we need to strip off the root directory in the case
 		   of relative paths, but this must be done _after_
 		   the sorting phase */
@@ -1361,51 +1465,133 @@
 			if (flist->files[i]->dirname &&
 			    !flist->files[i]->dirname[0]) {
 				flist->files[i]->dirname = NULL;
 			}
 		}
 	}
+}
 
-	if (verbose <= 3)
-		return;
+static void output_flist(struct file_list *flist)
+{
+	char uidbuf[16], gidbuf[16];
+	struct file_struct *file;
+	int i;
 
 	for (i = 0; i < flist->count; i++) {
-		rprintf(FINFO, "[%d] i=%d %s %s mode=0%o len=%.0f\n",
-			(int) getpid(), i,
-			NS(flist->files[i]->dirname),
-			NS(flist->files[i]->basename),
-			(int) flist->files[i]->mode,
-			(double) flist->files[i]->length);
+		file = flist->files[i];
+		if (am_root && preserve_uid)
+			sprintf(uidbuf, " uid=%ld", (long)file->uid);
+		else
+			*uidbuf = '\0';
+		if (preserve_gid && file->gid != GID_NONE)
+			sprintf(gidbuf, " gid=%ld", (long)file->gid);
+		else
+			*gidbuf = '\0';
+		rprintf(FINFO, "[%s] i=%d %s %s %s mode=0%o len=%.0f%s%s\n",
+			who_am_i(), i, NS(file->basedir), NS(file->dirname),
+			NS(file->basename), (int) file->mode,
+			(double) file->length, uidbuf, gidbuf);
 	}
 }
 
 
-/*
- * return the full filename of a flist entry
- *
- * This function is too expensive at the moment, because it copies
- * strings when often we only want to compare them.  In any case,
- * using strlcat is silly because it will walk the string repeatedly.
+enum fnc_state { fnc_DIR, fnc_SLASH, fnc_BASE };
+
+/* Compare the names of two file_struct entities, just like strcmp()
+ * would do if it were operating on the joined strings.  We assume
+ * that there are no 0-length strings.
  */
-char *f_name(struct file_struct *f)
+int f_name_cmp(struct file_struct *f1, struct file_struct *f2)
 {
-	static char names[10][MAXPATHLEN];
-	static int n;
-	char *p = names[n];
+	int dif;
+	const uchar *c1, *c2;
+	enum fnc_state state1, state2;
+
+	if (!f1 || !f1->basename) {
+		if (!f2 || !f2->basename)
+			return 0;
+		return -1;
+	}
+	if (!f2 || !f2->basename)
+		return 1;
+
+	if (!(c1 = (uchar*)f1->dirname)) {
+		state1 = fnc_BASE;
+		c1 = (uchar*)f1->basename;
+	} else
+		state1 = fnc_DIR;
+	if (!(c2 = (uchar*)f2->dirname)) {
+		state2 = fnc_BASE;
+		c2 = (uchar*)f2->basename;
+	} else
+		state2 = fnc_DIR;
+
+	while (1) {
+		if ((dif = (int)*c1 - (int)*c2) != 0)
+			break;
+		if (!*++c1) {
+			switch (state1) {
+			case fnc_DIR:
+				state1 = fnc_SLASH;
+				c1 = (uchar*)"/";
+				break;
+			case fnc_SLASH:
+				state1 = fnc_BASE;
+				c1 = (uchar*)f1->basename;
+				break;
+			case fnc_BASE:
+				break;
+			}
+		}
+		if (!*++c2) {
+			switch (state2) {
+			case fnc_DIR:
+				state2 = fnc_SLASH;
+				c2 = (uchar*)"/";
+				break;
+			case fnc_SLASH:
+				state2 = fnc_BASE;
+				c2 = (uchar*)f2->basename;
+				break;
+			case fnc_BASE:
+				if (!*c1)
+					return 0;
+				break;
+			}
+		}
+	}
+
+	return dif;
+}
 
+
+/* Return a copy of the full filename of a flist entry, using the indicated
+ * buffer.  No size-checking is done because we checked the size when creating
+ * the file_struct entry.
+ */
+char *f_name_to(struct file_struct *f, char *fbuf)
+{
 	if (!f || !f->basename)
 		return NULL;
 
-	n = (n + 1) % 10;
-
 	if (f->dirname) {
-		int off;
+		int len = strlen(f->dirname);
+		memcpy(fbuf, f->dirname, len);
+		fbuf[len] = '/';
+		strcpy(fbuf + len + 1, f->basename);
+	} else
+		strcpy(fbuf, f->basename);
+	return fbuf;
+}
 
-		off = strlcpy(p, f->dirname, MAXPATHLEN);
-		off += strlcpy(p + off, "/", MAXPATHLEN - off);
-		off += strlcpy(p + off, f->basename, MAXPATHLEN - off);
-	} else {
-		strlcpy(p, f->basename, MAXPATHLEN);
-	}
 
-	return p;
+/* Like f_name_to(), but we rotate through 5 static buffers of our own.
+ */
+char *f_name(struct file_struct *f)
+{
+	static char names[5][MAXPATHLEN];
+	static unsigned int n;
+
+	n = (n + 1) % (sizeof names / sizeof names[0]);
+
+	return f_name_to(f, names[n]);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/generator.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/generator.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/generator.c	2003-12-24 09:14:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/generator.c	2004-04-16 00:55:23.000000000 +0800
@@ -27,67 +27,69 @@
 extern int dry_run;
 extern int relative_paths;
 extern int preserve_links;
 extern int am_root;
 extern int preserve_devices;
 extern int preserve_hard_links;
+extern int preserve_perms;
+extern int preserve_uid;
+extern int preserve_gid;
 extern int update_only;
 extern int opt_ignore_existing;
 extern int csum_length;
 extern int ignore_times;
 extern int size_only;
 extern int io_timeout;
 extern int protocol_version;
 extern int always_checksum;
-extern int modify_window;
 extern char *compare_dest;
 extern int link_dest;
+extern int whole_file;
+extern int local_server;
+extern int write_batch;
+extern int list_only;
+extern int only_existing;
+extern int orig_umask;
+extern int safe_symlinks;
 
 
 /* choose whether to skip a particular file */
-static int skip_file(char *fname,
-		     struct file_struct *file, STRUCT_STAT *st)
+static int skip_file(char *fname, struct file_struct *file, STRUCT_STAT *st)
 {
 	if (st->st_size != file->length) {
 		return 0;
 	}
 	if (link_dest) {
-		extern int preserve_perms;
-		extern int preserve_uid;
-		extern int preserve_gid;
-
-		if(preserve_perms
-		    && (st->st_mode & ~_S_IFMT) !=  (file->mode & ~_S_IFMT))
+		if (preserve_perms
+		    && (st->st_mode & CHMOD_BITS) != (file->mode & CHMOD_BITS))
 			return 0;
 
-		if (preserve_uid && st->st_uid != file->uid)
+		if (am_root && preserve_uid && st->st_uid != file->uid)
 			return 0;
 
-		if (preserve_gid && st->st_gid != file->gid)
+		if (preserve_gid && file->gid != GID_NONE
+		    && st->st_gid != file->gid)
 			return 0;
 	}
 
 	/* if always checksum is set then we use the checksum instead
 	   of the file time to determine whether to sync */
 	if (always_checksum && S_ISREG(st->st_mode)) {
 		char sum[MD4_SUM_LENGTH];
 		char fnamecmpdest[MAXPATHLEN];
 
 		if (compare_dest != NULL) {
 			if (access(fname, 0) != 0) {
-				snprintf(fnamecmpdest,MAXPATHLEN,"%s/%s",
-					 compare_dest,fname);
+				pathjoin(fnamecmpdest, sizeof fnamecmpdest,
+					 compare_dest, fname);
 				fname = fnamecmpdest;
 			}
 		}
 		file_checksum(fname,sum,st->st_size);
-		if (protocol_version < 21) {
-			return (memcmp(sum,file->sum,2) == 0);
-		} else {
-			return (memcmp(sum,file->sum,MD4_SUM_LENGTH) == 0);
-		}
+		return memcmp(sum, file->u.sum, protocol_version < 21 ? 2
+							: MD4_SUM_LENGTH) == 0;
 	}
 
 	if (size_only) {
 		return 1;
 	}
 
@@ -97,20 +99,19 @@
 
 	return (cmp_modtime(st->st_mtime,file->modtime) == 0);
 }
 
 
 /*
- * 	NULL sum_struct means we have no checksums
+ * NULL sum_struct means we have no checksums
  */
-
 void write_sum_head(int f, struct sum_struct *sum)
 {
 	static struct sum_struct null_sum;
 
-	if (sum == (struct sum_struct *)NULL)
+	if (sum == NULL)
 		sum = &null_sum;
 
 	write_int(f, sum->count);
 	write_int(f, sum->blength);
 	if (protocol_version >= 27)
 		write_int(f, sum->s2length);
@@ -134,14 +135,15 @@
  *
  * This might be made one of several selectable heuristics.
  */
 
 static void sum_sizes_sqroot(struct sum_struct *sum, uint64 len)
 {
-	extern int block_size;
-	int blength, s2length, b;
+	extern unsigned int block_size;
+	unsigned int blength;
+	int s2length;
 	uint32 c;
 	uint64 l;
 
 	if (block_size) {
 		blength = block_size;
 	} else if (len <= BLOCK_SIZE * BLOCK_SIZE) {
@@ -164,13 +166,13 @@
 
 	if (protocol_version < 27) {
 		s2length = csum_length;
 	} else if (csum_length == SUM_LENGTH) {
 		s2length = SUM_LENGTH;
 	} else {
-		b = BLOCKSUM_BIAS;
+		int b = BLOCKSUM_BIAS;
 		l = len;
 		while (l >>= 1) {
 			b += 2;
 		}
 		c = blength;
 		while (c >>= 1 && b) {
@@ -189,16 +191,15 @@
 	sum->blength	= blength;
 	sum->s2length	= s2length;
 	sum->count	= (len + (blength - 1)) / blength;
 	sum->remainder	= (len % blength);
 
 	if (sum->count && verbose > 2) {
-		rprintf(FINFO, "count=%ld rem=%ld blength=%ld s2length=%ld flength=%.0f\n",
-			(long) sum->count, (long) sum->remainder,
-			(long) sum->blength, (long) sum->s2length,
-			(double) sum->flength);
+		rprintf(FINFO, "count=%.0f rem=%u blength=%u s2length=%d flength=%.0f\n",
+			(double)sum->count, sum->remainder, sum->blength,
+			sum->s2length, (double)sum->flength);
 	}
 }
 
 /**
  * Perhaps we want to just send an empty checksum set for this file,
  * which will force the whole thing to be literally transferred.
@@ -207,16 +208,12 @@
  * want the whole thing, or if { they haven't explicitly
  * requested a delta, and it's local but not batch mode.}
  *
  * Whew. */
 static BOOL disable_deltas_p(void)
 {
-	extern int whole_file;
-	extern int local_server;
-	extern int write_batch;
-
 	if (whole_file > 0)
 		return True;
 	if (whole_file == 0 || write_batch)
 		return False;
 	return local_server;
 }
@@ -224,34 +221,35 @@
 
 /*
  * Generate and send a stream of signatures/checksums that describe a buffer
  *
  * Generate approximately one checksum every block_len bytes.
  */
-static void generate_and_send_sums(struct map_struct *buf, OFF_T len, int f_out)
+static void generate_and_send_sums(struct map_struct *buf, size_t len, int f_out)
 {
 	size_t i;
 	struct sum_struct sum;
 	OFF_T offset = 0;
 
 	sum_sizes_sqroot(&sum, len);
 
 	write_sum_head(f_out, &sum);
 
 	for (i = 0; i < sum.count; i++) {
-		int n1 = MIN(len, sum.blength);
+		unsigned int n1 = MIN(len, sum.blength);
 		char *map = map_ptr(buf, offset, n1);
 		uint32 sum1 = get_checksum1(map, n1);
 		char sum2[SUM_LENGTH];
 
 		get_checksum2(map, n1, sum2);
 
 		if (verbose > 3) {
 			rprintf(FINFO,
-				"chunk[%ld] offset=%.0f len=%d sum1=%08lx\n",
-				(long)i,(double)offset,n1,(unsigned long)sum1);
+				"chunk[%.0f] offset=%.0f len=%u sum1=%08lx\n",
+				(double)i, (double)offset, n1,
+				(unsigned long)sum1);
 		}
 		write_int(f_out, sum1);
 		write_buf(f_out, sum2, sum.s2length);
 		len -= n1;
 		offset += n1;
 	}
@@ -264,28 +262,23 @@
  *
  * First fixes up permissions, then generates checksums for the file.
  *
  * @note This comment was added later by mbp who was trying to work it
  * out.  It might be wrong.
  **/
-void recv_generator(char *fname, struct file_list *flist, int i, int f_out)
+void recv_generator(char *fname, struct file_struct *file, int i, int f_out)
 {
 	int fd;
 	STRUCT_STAT st;
-	struct map_struct *buf;
+	struct map_struct *mapbuf;
 	int statret;
-	struct file_struct *file = flist->files[i];
 	char *fnamecmp;
 	char fnamecmpbuf[MAXPATHLEN];
-	extern char *compare_dest;
-	extern int list_only;
-	extern int preserve_perms;
-	extern int only_existing;
-	extern int orig_umask;
 
-	if (list_only) return;
+	if (list_only)
+		return;
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_generator(%s,%d)\n",fname,i);
 
 	statret = link_stat(fname,&st);
 
@@ -298,13 +291,14 @@
 	if (statret == 0 &&
 	    !preserve_perms &&
 	    (S_ISDIR(st.st_mode) == S_ISDIR(file->mode))) {
 		/* if the file exists already and we aren't perserving
 		 * permissions then act as though the remote end sent
 		 * us the file permissions we already have */
-		file->mode = (file->mode & _S_IFMT) | (st.st_mode & ~_S_IFMT);
+		file->mode = (file->mode & ~CHMOD_BITS)
+			   | (st.st_mode & CHMOD_BITS);
 	}
 
 	if (S_ISDIR(file->mode)) {
 		/* The file to be received is a directory, so we need
 		 * to prepare appropriately.  If there is already a
 		 * file of that name and it is *not* a directory, then
@@ -337,61 +331,60 @@
 	}
 
 	if (preserve_links && S_ISLNK(file->mode)) {
 #if SUPPORT_LINKS
 		char lnk[MAXPATHLEN];
 		int l;
-		extern int safe_symlinks;
 
-		if (safe_symlinks && unsafe_symlink(file->link, fname)) {
+		if (safe_symlinks && unsafe_symlink(file->u.link, fname)) {
 			if (verbose) {
 				rprintf(FINFO, "ignoring unsafe symlink %s -> \"%s\"\n",
-					full_fname(fname), file->link);
+					full_fname(fname), file->u.link);
 			}
 			return;
 		}
 		if (statret == 0) {
 			l = readlink(fname,lnk,MAXPATHLEN-1);
 			if (l > 0) {
 				lnk[l] = 0;
 				/* A link already pointing to the
 				 * right place -- no further action
 				 * required. */
-				if (strcmp(lnk,file->link) == 0) {
+				if (strcmp(lnk,file->u.link) == 0) {
 					set_perms(fname,file,&st,1);
 					return;
 				}
 			}
 			/* Not a symlink, so delete whatever's
 			 * already there and put a new symlink
 			 * in place. */
 			delete_file(fname);
 		}
-		if (do_symlink(file->link,fname) != 0) {
+		if (do_symlink(file->u.link,fname) != 0) {
 			rprintf(FERROR, "symlink %s -> \"%s\" failed: %s\n",
-				full_fname(fname), file->link, strerror(errno));
+				full_fname(fname), file->u.link, strerror(errno));
 		} else {
 			set_perms(fname,file,NULL,0);
 			if (verbose) {
-				rprintf(FINFO,"%s -> %s\n", fname,file->link);
+				rprintf(FINFO,"%s -> %s\n", fname,file->u.link);
 			}
 		}
 #endif
 		return;
 	}
 
 #ifdef HAVE_MKNOD
 	if (am_root && preserve_devices && IS_DEVICE(file->mode)) {
 		if (statret != 0 ||
 		    st.st_mode != file->mode ||
-		    (DEV64_T)st.st_rdev != file->rdev) {
+		    st.st_rdev != file->u.rdev) {
 			delete_file(fname);
 			if (verbose > 2)
 				rprintf(FINFO,"mknod(%s,0%o,0x%x)\n",
-					fname,(int)file->mode,(int)file->rdev);
-			if (do_mknod(fname,file->mode,file->rdev) != 0) {
+					fname,(int)file->mode,(int)file->u.rdev);
+			if (do_mknod(fname,file->mode,file->u.rdev) != 0) {
 				rprintf(FERROR, "mknod %s failed: %s\n",
 					full_fname(fname), strerror(errno));
 			} else {
 				set_perms(fname,file,NULL,0);
 				if (verbose)
 					rprintf(FINFO,"%s\n",fname);
@@ -400,51 +393,50 @@
 			set_perms(fname,file,&st,1);
 		}
 		return;
 	}
 #endif
 
-	if (preserve_hard_links && check_hard_link(file)) {
-		if (verbose > 1)
-			rprintf(FINFO, "recv_generator: \"%s\" is a hard link\n",f_name(file));
+	if (preserve_hard_links && hard_link_check(file, HL_CHECK_MASTER))
 		return;
-	}
 
 	if (!S_ISREG(file->mode)) {
 		rprintf(FINFO, "skipping non-regular file \"%s\"\n",fname);
 		return;
 	}
 
 	fnamecmp = fname;
 
-	if ((statret == -1) && (compare_dest != NULL)) {
+	if (statret == -1 && compare_dest != NULL) {
 		/* try the file at compare_dest instead */
 		int saveerrno = errno;
-		snprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",compare_dest,fname);
+		pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, compare_dest, fname);
 		statret = link_stat(fnamecmpbuf,&st);
 		if (!S_ISREG(st.st_mode))
 			statret = -1;
 		if (statret == -1)
 			errno = saveerrno;
 #if HAVE_LINK
 		else if (link_dest && !dry_run) {
 			if (do_link(fnamecmpbuf, fname) != 0) {
-				if (verbose > 0)
+				if (verbose > 0) {
 					rprintf(FINFO,"link %s => %s : %s\n",
-						fnamecmpbuf,
-						fname,
+						fnamecmpbuf, fname,
 						strerror(errno));
+				}
 			}
 			fnamecmp = fnamecmpbuf;
 		}
 #endif
 		else
 			fnamecmp = fnamecmpbuf;
 	}
 
 	if (statret == -1) {
+		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+			return;
 		if (errno == ENOENT) {
 			write_int(f_out,i);
 			if (!dry_run) write_sum_head(f_out, NULL);
 		} else if (verbose > 1) {
 			rprintf(FERROR,
 				"recv_generator: failed to open %s: %s\n",
@@ -456,12 +448,14 @@
 	if (!S_ISREG(st.st_mode)) {
 		if (delete_file(fname) != 0) {
 			return;
 		}
 
 		/* now pretend the file didn't exist */
+		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+			return;
 		write_int(f_out,i);
 		if (!dry_run) write_sum_head(f_out, NULL);
 		return;
 	}
 
 	if (opt_ignore_existing && fnamecmp == fname) {
@@ -497,46 +491,50 @@
 	fd = do_open(fnamecmp, O_RDONLY, 0);
 
 	if (fd == -1) {
 		rprintf(FERROR, "failed to open %s, continuing: %s\n",
 			full_fname(fnamecmp), strerror(errno));
 		/* pretend the file didn't exist */
+		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+			return;
 		write_int(f_out,i);
 		write_sum_head(f_out, NULL);
 		return;
 	}
 
-	if (st.st_size > 0) {
-		buf = map_file(fd,st.st_size);
-	} else {
-		buf = NULL;
+	if (st.st_size > 0)
+		mapbuf = map_file(fd,st.st_size);
+	else
+		mapbuf = NULL;
+
+	if (verbose > 3) {
+		rprintf(FINFO,"gen mapped %s of size %.0f\n", fnamecmp,
+			(double)st.st_size);
 	}
 
-	if (verbose > 3)
-		rprintf(FINFO,"gen mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
-
 	if (verbose > 2)
 		rprintf(FINFO, "generating and sending sums for %d\n", i);
 
 	write_int(f_out,i);
-	generate_and_send_sums(buf, st.st_size, f_out);
+	generate_and_send_sums(mapbuf, st.st_size, f_out);
 
 	close(fd);
-	if (buf) unmap_file(buf);
+	if (mapbuf) unmap_file(mapbuf);
 }
 
 
-
-void generate_files(int f,struct file_list *flist,char *local_name,int f_recv)
+void generate_files(int f, struct file_list *flist, char *local_name)
 {
 	int i;
 	int phase=0;
+	char fbuf[MAXPATHLEN];
 
-	if (verbose > 2)
-		rprintf(FINFO,"generator starting pid=%d count=%d\n",
-			(int)getpid(),flist->count);
+	if (verbose > 2) {
+		rprintf(FINFO, "generator starting pid=%ld count=%d\n",
+			(long)getpid(), flist->count);
+	}
 
 	if (verbose >= 2) {
 		rprintf(FINFO,
 			disable_deltas_p()
 			? "delta-transmission disabled for local transfer or --whole-file\n"
 			: "delta transmission enabled\n");
@@ -546,27 +544,29 @@
 	   timeout. If we really get a timeout then the other process should
 	   exit */
 	io_timeout = 0;
 
 	for (i = 0; i < flist->count; i++) {
 		struct file_struct *file = flist->files[i];
-		mode_t saved_mode = file->mode;
-		if (!file->basename) continue;
+		struct file_struct copy;
 
+		if (!file->basename)
+			continue;
 		/* we need to ensure that any directories we create have writeable
 		   permissions initially so that we can create the files within
 		   them. This is then fixed after the files are transferred */
-		if (!am_root && S_ISDIR(file->mode)) {
-			file->mode |= S_IWUSR; /* user write */
+		if (!am_root && S_ISDIR(file->mode) && !(file->mode & S_IWUSR)) {
+			copy = *file;
 			/* XXX: Could this be causing a problem on SCO?  Perhaps their
 			 * handling of permissions is strange? */
+			copy.mode |= S_IWUSR; /* user write */
+			file = &copy;
 		}
 
-		recv_generator(local_name?local_name:f_name(file), flist,i,f);
-
-		file->mode = saved_mode;
+		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
+			       file, i, f);
 	}
 
 	phase++;
 	csum_length = SUM_LENGTH;
 	ignore_times=1;
 
@@ -574,17 +574,33 @@
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f,-1);
 
 	/* files can cycle through the system more than once
 	 * to catch initial checksum errors */
-	for (i=read_int(f_recv); i != -1; i=read_int(f_recv)) {
+	while ((i = get_redo_num()) != -1) {
 		struct file_struct *file = flist->files[i];
-		recv_generator(local_name?local_name:f_name(file), flist,i,f);
+		recv_generator(local_name ? local_name : f_name_to(file, fbuf),
+			       file, i, f);
 	}
 
 	phase++;
 	if (verbose > 2)
 		rprintf(FINFO,"generate_files phase=%d\n",phase);
 
 	write_int(f,-1);
+
+	if (preserve_hard_links)
+		do_hard_links();
+
+	/* now we need to fix any directory permissions that were
+	 * modified during the transfer */
+	for (i = 0; i < flist->count; i++) {
+		struct file_struct *file = flist->files[i];
+		if (!file->basename || !S_ISDIR(file->mode)) continue;
+		recv_generator(local_name ? local_name : f_name(file),
+			       file, i, -1);
+	}
+
+	if (verbose > 2)
+		rprintf(FINFO,"generate_files finished\n");
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/getgroups.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/getgroups.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/getgroups.c	2003-09-10 16:27:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/getgroups.c	2004-02-21 01:01:33.000000000 +0800
@@ -23,28 +23,46 @@
  * like `id -G` on Linux, but it's too hard to find a portable
  * equivalent.
  **/
 
 #include "rsync.h"
 
-#ifndef NGROUPS
-/* It ought to be defined, but just in case. */
-#  define NGROUPS 32
-#endif
-
 int
 main(UNUSED(int argc), UNUSED(char *argv[]))
 {
 	int n, i;
-	gid_t list[NGROUPS];
+	gid_t *list;
+	gid_t gid = MY_GID();
+	int gid_in_list = 0;
 
-	if ((n = getgroups(NGROUPS, list)) == -1) {
+#ifdef HAVE_GETGROUPS
+	if ((n = getgroups(0, NULL)) < 0) {
 		perror("getgroups");
 		return 1;
 	}
+#else
+	n = 0;
+#endif
+
+	list = (gid_t*)malloc(sizeof (gid_t) * (n + 1));
+	if (!list) {
+		fprintf(stderr, "out of memory!\n");
+		exit(1);
+	}
+
+#ifdef HAVE_GETGROUPS
+	if (n > 0)
+		n = getgroups(n, list);
+#endif
 
-	for (i = 0; i < n; i++) 
-		printf("%u ", list[i]);
+	for (i = 0; i < n; i++)  {
+		printf("%lu ", (unsigned long)list[i]);
+		if (list[i] == gid)
+			gid_in_list = 1;
+	}
+	/* The default gid might not be in the list on some systems. */
+	if (!gid_in_list)
+		printf("%lu", (unsigned long)gid);
 	printf("\n");
 		
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/hlink.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/hlink.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/hlink.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/hlink.c	2004-03-27 00:46:20.000000000 +0800
@@ -1,53 +1,108 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
    Copyright (C) 2002 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 #include "rsync.h"
 
 extern int dry_run;
 extern int verbose;
+extern int make_backups;
 
 #if SUPPORT_HARD_LINKS
-static int hlink_compare(struct file_struct *f1, struct file_struct *f2)
+static int hlink_compare(struct file_struct **file1, struct file_struct **file2)
 {
-	if (!S_ISREG(f1->mode) && !S_ISREG(f2->mode))
-		return 0;
-	if (!S_ISREG(f1->mode))
-		return -1;
-	if (!S_ISREG(f2->mode))
-		return 1;
+	struct file_struct *f1 = *file1;
+	struct file_struct *f2 = *file2;
 
-	if (f1->dev != f2->dev)
-		return (int) (f1->dev > f2->dev ? 1 : -1);
+	if (f1->F_DEV != f2->F_DEV)
+		return (int) (f1->F_DEV > f2->F_DEV ? 1 : -1);
 
-	if (f1->inode != f2->inode)
-		return (int) (f1->inode > f2->inode ? 1 : -1);
+	if (f1->F_INODE != f2->F_INODE)
+		return (int) (f1->F_INODE > f2->F_INODE ? 1 : -1);
 
-	return file_compare(&f1, &f2);
+	return file_compare(file1, file2);
 }
 
-
-static struct file_struct *hlink_list;
+static struct file_struct **hlink_list;
 static int hlink_count;
+
+#define LINKED(p1,p2) ((p1)->F_DEV == (p2)->F_DEV \
+		    && (p1)->F_INODE == (p2)->F_INODE)
+
+/* Analyze the data in the hlink_list[], remove items that aren't multiply
+ * linked, and replace the dev+inode data with the hlindex+next linked list. */
+static void link_idev_data(struct file_list *flist)
+{
+	struct file_struct *head;
+	int from, to, start;
+
+	alloc_pool_t hlink_pool;
+	alloc_pool_t idev_pool = flist->hlink_pool;
+
+	hlink_pool = pool_create(128 * 1024, sizeof (struct hlink),
+	    out_of_memory, POOL_INTERN);
+
+	for (from = to = 0; from < hlink_count; from++) {
+		start = from;
+		head = hlink_list[start];
+		while (from < hlink_count-1
+		    && LINKED(hlink_list[from], hlink_list[from+1])) {
+			pool_free(idev_pool, 0, hlink_list[from]->link_u.idev);
+			hlink_list[from]->link_u.links = pool_talloc(hlink_pool,
+			    struct hlink, 1, "hlink_list");
+
+			hlink_list[from]->F_HLINDEX = to;
+			hlink_list[from]->F_NEXT = hlink_list[from+1];
+			from++;
+		}
+		if (from > start) {
+			pool_free(idev_pool, 0, hlink_list[from]->link_u.idev);
+			hlink_list[from]->link_u.links = pool_talloc(hlink_pool,
+			    struct hlink, 1, "hlink_list");
+
+			hlink_list[from]->F_HLINDEX = to;
+			hlink_list[from]->F_NEXT = head;
+			hlink_list[from]->flags |= FLAG_HLINK_EOL;
+			hlink_list[to++] = head;
+		} else {
+			pool_free(idev_pool, 0, head->link_u.idev);
+			head->link_u.idev = NULL;
+		}
+	}
+
+	if (!to) {
+		free(hlink_list);
+		hlink_list = NULL;
+		pool_destroy(hlink_pool);
+		hlink_pool = NULL;
+	} else {
+		hlink_count = to;
+		if (!(hlink_list = realloc_array(hlink_list,
+		    struct file_struct *, hlink_count)))
+			out_of_memory("init_hard_links");
+	}
+	flist->hlink_pool = hlink_pool;
+	pool_destroy(idev_pool);
+}
 #endif
 
 void init_hard_links(struct file_list *flist)
 {
 #if SUPPORT_HARD_LINKS
 	int i;
@@ -54,131 +110,102 @@
 	if (flist->count < 2)
 		return;
 
 	if (hlink_list)
 		free(hlink_list);
 
-	if (!(hlink_list = new_array(struct file_struct, flist->count)))
+	if (!(hlink_list = new_array(struct file_struct *, flist->count)))
 		out_of_memory("init_hard_links");
 
-	for (i = 0; i < flist->count; i++)
-		memcpy(&hlink_list[i], flist->files[i],
-		       sizeof(hlink_list[0]));
+	hlink_count = 0;
+	for (i = 0; i < flist->count; i++) {
+		if (flist->files[i]->link_u.idev)
+			hlink_list[hlink_count++] = flist->files[i];
+	}
 
-	qsort(hlink_list, flist->count,
-	      sizeof(hlink_list[0]), (int (*)()) hlink_compare);
+	qsort(hlink_list, hlink_count,
+	    sizeof hlink_list[0], (int (*)()) hlink_compare);
 
-	hlink_count = flist->count;
+	if (!hlink_count) {
+		free(hlink_list);
+		hlink_list = NULL;
+	} else
+		link_idev_data(flist);
 #endif
 }
 
-/* check if a file should be skipped because it is the same as an
-   earlier hard link */
-int check_hard_link(struct file_struct *file)
+int hard_link_check(struct file_struct *file, int skip)
 {
-#if SUPPORT_HARD_LINKS
-	int low = 0, high = hlink_count - 1;
-	int ret = 0;
-
-	if (!hlink_list || !S_ISREG(file->mode))
+	if (!hlink_list || !file->link_u.links)
 		return 0;
-
-	while (low != high) {
-		int mid = (low + high) / 2;
-		ret = hlink_compare(&hlink_list[mid], file);
-		if (ret == 0) {
-			low = mid;
-			break;
-		}
-		if (ret > 0)
-			high = mid;
-		else
-			low = mid + 1;
-	}
-
-	/* XXX: To me this looks kind of dodgy -- why do we use [low]
-	 * here and [low-1] below? -- mbp */
-	if (hlink_compare(&hlink_list[low], file) != 0)
-		return 0;
-
-	if (low > 0 &&
-	    S_ISREG(hlink_list[low - 1].mode) &&
-	    file->dev == hlink_list[low - 1].dev &&
-	    file->inode == hlink_list[low - 1].inode) {
-		if (verbose >= 2) {
-			rprintf(FINFO, "check_hard_link: \"%s\" is a hard link to file %d, \"%s\"\n",
-				f_name(file), low-1, f_name(&hlink_list[low-1]));
+	if (skip && !(file->flags & FLAG_HLINK_EOL))
+		hlink_list[file->F_HLINDEX] = file->F_NEXT;
+	if (hlink_list[file->F_HLINDEX] != file) {
+		if (verbose > 1) {
+			rprintf(FINFO, "\"%s\" is a hard link\n",
+			    f_name(file));
 		}
 		return 1;
 	}
-#endif
-
 	return 0;
 }
 
-
 #if SUPPORT_HARD_LINKS
-static void hard_link_one(int i)
+static void hard_link_one(char *hlink1, char *hlink2)
 {
-	STRUCT_STAT st1, st2;
-
-	if (link_stat(f_name(&hlink_list[i - 1]), &st1) != 0)
-		return;
-
-	if (link_stat(f_name(&hlink_list[i]), &st2) != 0) {
-		if (do_link
-		    (f_name(&hlink_list[i - 1]),
-		     f_name(&hlink_list[i])) != 0) {
-			if (verbose > 0)
-				rprintf(FINFO, "link %s => %s : %s\n",
-					f_name(&hlink_list[i]),
-					f_name(&hlink_list[i - 1]),
-					strerror(errno));
-			return;
-		}
-	} else {
-		if (st2.st_dev == st1.st_dev && st2.st_ino == st1.st_ino)
-			return;
-
-		if (robust_unlink(f_name(&hlink_list[i])) != 0 ||
-		    do_link(f_name(&hlink_list[i - 1]),
-			    f_name(&hlink_list[i])) != 0) {
-			if (verbose > 0)
-				rprintf(FINFO, "link %s => %s : %s\n",
-					f_name(&hlink_list[i]),
-					f_name(&hlink_list[i - 1]),
-					strerror(errno));
-			return;
+	if (do_link(hlink1, hlink2)) {
+		if (verbose) {
+			rprintf(FINFO, "link %s => %s failed: %s\n",
+			    hlink2, hlink1, strerror(errno));
 		}
 	}
-	if (verbose > 0)
-		rprintf(FINFO, "%s => %s\n",
-			f_name(&hlink_list[i]),
-			f_name(&hlink_list[i - 1]));
+	else if (verbose)
+		rprintf(FINFO, "%s => %s\n", hlink2, hlink1);
 }
 #endif
 
 
 
 /**
  * Create any hard links in the global hlink_list.  They were put
  * there by running init_hard_links on the filelist.
  **/
 void do_hard_links(void)
 {
 #if SUPPORT_HARD_LINKS
+	struct file_struct *file, *first;
+	char hlink1[MAXPATHLEN];
+	char *hlink2;
+	STRUCT_STAT st1, st2;
 	int i;
 
 	if (!hlink_list)
 		return;
 
-	for (i = 1; i < hlink_count; i++) {
-		if (S_ISREG(hlink_list[i].mode) &&
-		    S_ISREG(hlink_list[i - 1].mode) &&
-		    hlink_list[i].basename && hlink_list[i - 1].basename &&
-		    hlink_list[i].dev == hlink_list[i - 1].dev &&
-		    hlink_list[i].inode == hlink_list[i - 1].inode) {
-			hard_link_one(i);
+	for (i = 0; i < hlink_count; i++) {
+		first = file = hlink_list[i];
+		if (link_stat(f_name_to(first, hlink1), &st1) != 0)
+			continue;
+		while ((file = file->F_NEXT) != first) {
+			hlink2 = f_name(file);
+			if (link_stat(hlink2, &st2) == 0) {
+				if (st2.st_dev == st1.st_dev
+				    && st2.st_ino == st1.st_ino)
+					continue;
+				if (make_backups) {
+					if (!make_backup(hlink2))
+						continue;
+				} else if (robust_unlink(hlink2)) {
+					if (verbose > 0) {
+						rprintf(FINFO,
+						    "unlink %s failed: %s\n",
+						    full_fname(hlink2), 
+						    strerror(errno));
+					}
+					continue;
+				}
+			}
+			hard_link_one(hlink1, hlink2);
 		}
 	}
 #endif
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/io.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/io.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/io.c	2003-12-27 07:04:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/io.c	2004-01-17 00:31:47.000000000 +0800
@@ -38,20 +38,23 @@
 
 /** If no timeout is specified then use a 60 second select timeout */
 #define SELECT_TIMEOUT 60
 
 static int io_multiplexing_out;
 static int io_multiplexing_in;
-static int multiplex_in_fd;
-static int multiplex_out_fd;
+static int multiplex_in_fd = -1;
+static int multiplex_out_fd = -1;
 static time_t last_io;
 static int no_flush;
 
 extern int bwlimit;
 extern int verbose;
 extern int io_timeout;
+extern int am_server;
+extern int am_daemon;
+extern int am_sender;
 extern struct stats stats;
 
 
 const char phase_unknown[] = "unknown";
 
 /**
@@ -71,31 +74,62 @@
 const char *io_read_phase = phase_unknown;
 
 /** Ignore EOF errors while reading a module listing if the remote
     version is 24 or less. */
 int kludge_around_eof = False;
 
+int msg_fd_in = -1;
+int msg_fd_out = -1;
 
-static int io_error_fd = -1;
 static int io_filesfrom_f_in = -1;
 static int io_filesfrom_f_out = -1;
 static char io_filesfrom_buf[2048];
 static char *io_filesfrom_bp;
 static char io_filesfrom_lastchar;
 static int io_filesfrom_buflen;
 
 static void read_loop(int fd, char *buf, size_t len);
 
+struct redo_list {
+	struct redo_list *next;
+	int num;
+};
+
+static struct redo_list *redo_list_head;
+static struct redo_list *redo_list_tail;
+
+struct msg_list {
+	struct msg_list *next;
+	char *buf;
+	int len;
+};
+
+static struct msg_list *msg_list_head;
+static struct msg_list *msg_list_tail;
+
+static void redo_list_add(int num)
+{
+	struct redo_list *rl;
+
+	if (!(rl = new(struct redo_list)))
+		exit_cleanup(RERR_MALLOC);
+	rl->next = NULL;
+	rl->num = num;
+	if (redo_list_tail)
+		redo_list_tail->next = rl;
+	else
+		redo_list_head = rl;
+	redo_list_tail = rl;
+}
+
 static void check_timeout(void)
 {
-	extern int am_server, am_daemon;
 	time_t t;
 
-	err_list_push();
-
-	if (!io_timeout) return;
+	if (!io_timeout)
+		return;
 
 	if (!last_io) {
 		last_io = time(NULL);
 		return;
 	}
 
@@ -107,47 +141,166 @@
 				(int)(t-last_io));
 		}
 		exit_cleanup(RERR_TIMEOUT);
 	}
 }
 
-/** Setup the fd used to propagate errors */
-void io_set_error_fd(int fd)
+/** Setup the fd used to receive MSG_* messages.  Only needed when
+ * we're the generator because the sender and receiver both use the
+ * multiplexed IO setup. */
+void set_msg_fd_in(int fd)
 {
-	io_error_fd = fd;
+	msg_fd_in = fd;
 }
 
-/** Read some data from the error fd and write it to the write log code */
-static void read_error_fd(void)
+/** Setup the fd used to send our MSG_* messages.  Only needed when
+ * we're the receiver because the generator and the sender both use
+ * the multiplexed IO setup. */
+void set_msg_fd_out(int fd)
+{
+	msg_fd_out = fd;
+	set_nonblocking(msg_fd_out);
+}
+
+/* Add a message to the pending MSG_* list. */
+static void msg_list_add(int code, char *buf, int len)
+{
+	struct msg_list *ml;
+
+	if (!(ml = new(struct msg_list)))
+		exit_cleanup(RERR_MALLOC);
+	ml->next = NULL;
+	if (!(ml->buf = new_array(char, len+4)))
+		exit_cleanup(RERR_MALLOC);
+	SIVAL(ml->buf, 0, ((code+MPLEX_BASE)<<24) | len);
+	memcpy(ml->buf+4, buf, len);
+	ml->len = len+4;
+	if (msg_list_tail)
+		msg_list_tail->next = ml;
+	else
+		msg_list_head = ml;
+	msg_list_tail = ml;
+}
+
+void send_msg(enum msgcode code, char *buf, int len)
+{
+	msg_list_add(code, buf, len);
+	msg_list_push(NORMAL_FLUSH);
+}
+
+/** Read a message from the MSG_* fd and dispatch it.  This is only
+ * called by the generator. */
+static void read_msg_fd(void)
 {
 	char buf[200];
 	size_t n;
-	int fd = io_error_fd;
+	int fd = msg_fd_in;
 	int tag, len;
 
-	/* io_error_fd is temporarily disabled -- is this meant to
-	 * prevent indefinite recursion? */
-	io_error_fd = -1;
+	/* Temporarily disable msg_fd_in.  This is needed because we
+	 * may call a write routine that could try to call us back. */
+	msg_fd_in = -1;
 
 	read_loop(fd, buf, 4);
 	tag = IVAL(buf, 0);
 
 	len = tag & 0xFFFFFF;
-	tag = tag >> 24;
-	tag -= MPLEX_BASE;
+	tag = (tag >> 24) - MPLEX_BASE;
 
-	while (len) {
-		n = len;
-		if (n > (sizeof buf - 1))
-			n = sizeof buf - 1;
-		read_loop(fd, buf, n);
-		rwrite((enum logcode)tag, buf, n);
-		len -= n;
+	switch (tag) {
+	case MSG_DONE:
+		if (len != 0) {
+			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
+			exit_cleanup(RERR_STREAMIO);
+		}
+		redo_list_add(-1);
+		break;
+	case MSG_REDO:
+		if (len != 4) {
+			rprintf(FERROR, "invalid message %d:%d\n", tag, len);
+			exit_cleanup(RERR_STREAMIO);
+		}
+		read_loop(fd, buf, 4);
+		redo_list_add(IVAL(buf,0));
+		break;
+	case MSG_INFO:
+	case MSG_ERROR:
+	case MSG_LOG:
+		while (len) {
+			n = len;
+			if (n >= sizeof buf)
+				n = sizeof buf - 1;
+			read_loop(fd, buf, n);
+			rwrite((enum logcode)tag, buf, n);
+			len -= n;
+		}
+		break;
+	default:
+		rprintf(FERROR, "unknown message %d:%d\n", tag, len);
+		exit_cleanup(RERR_STREAMIO);
+	}
+
+	msg_fd_in = fd;
+}
+
+/* Try to push messages off the list onto the wire.  If we leave with more
+ * to do, return 0.  On error, return -1.  If everything flushed, return 1.
+ * This is only called by the receiver. */
+int msg_list_push(int flush_it_all)
+{
+	static int written = 0;
+	struct timeval tv;
+	fd_set fds;
+
+	if (msg_fd_out < 0)
+		return -1;
+
+	while (msg_list_head) {
+		struct msg_list *ml = msg_list_head;
+		int n = write(msg_fd_out, ml->buf + written, ml->len - written);
+		if (n < 0) {
+			if (errno == EINTR)
+				continue;
+			if (errno != EWOULDBLOCK && errno != EAGAIN)
+				return -1;
+			if (!flush_it_all)
+				return 0;
+			FD_ZERO(&fds);
+			FD_SET(msg_fd_out, &fds);
+			tv.tv_sec = io_timeout ? io_timeout : SELECT_TIMEOUT;
+			tv.tv_usec = 0;
+			if (!select(msg_fd_out+1, NULL, &fds, NULL, &tv))
+				check_timeout();
+		} else if ((written += n) == ml->len) {
+			free(ml->buf);
+			msg_list_head = ml->next;
+			if (!msg_list_head)
+				msg_list_tail = NULL;
+			free(ml);
+			written = 0;
+		}
 	}
+	return 1;
+}
+
+int get_redo_num(void)
+{
+	struct redo_list *next;
+	int num;
+
+	while (!redo_list_head)
+		read_msg_fd();
+
+	num = redo_list_head->num;
+	next = redo_list_head->next;
+	free(redo_list_head);
+	redo_list_head = next;
+	if (!next)
+		redo_list_tail = NULL;
 
-	io_error_fd = fd;
+	return num;
 }
 
 /**
  * When we're the receiver and we have a local --files-from list of names
  * that needs to be sent over the socket to the sender, we have to do two
  * things at the same time: send the sender a list of what files we're
@@ -214,70 +367,72 @@
  * started by looking e.g. at whether the remote version is known yet.
  */
 static int read_timeout(int fd, char *buf, size_t len)
 {
 	int n, ret=0;
 
-	io_flush();
+	io_flush(NORMAL_FLUSH);
 
 	while (ret == 0) {
 		/* until we manage to read *something* */
 		fd_set r_fds, w_fds;
 		struct timeval tv;
 		int fd_count = fd+1;
 		int count;
 
 		FD_ZERO(&r_fds);
 		FD_SET(fd, &r_fds);
-		if (io_error_fd != -1) {
-			FD_SET(io_error_fd, &r_fds);
-			if (io_error_fd >= fd_count) fd_count = io_error_fd+1;
+		if (msg_fd_in >= 0) {
+			FD_SET(msg_fd_in, &r_fds);
+			if (msg_fd_in >= fd_count)
+				fd_count = msg_fd_in+1;
 		}
-		if (io_filesfrom_f_out != -1) {
+		if (io_filesfrom_f_out >= 0) {
 			int new_fd;
 			if (io_filesfrom_buflen == 0) {
-				if (io_filesfrom_f_in != -1) {
+				if (io_filesfrom_f_in >= 0) {
 					FD_SET(io_filesfrom_f_in, &r_fds);
 					new_fd = io_filesfrom_f_in;
 				} else {
 					io_filesfrom_f_out = -1;
 					new_fd = -1;
 				}
 			} else {
 				FD_ZERO(&w_fds);
 				FD_SET(io_filesfrom_f_out, &w_fds);
 				new_fd = io_filesfrom_f_out;
 			}
-			if (new_fd >= fd_count) fd_count = new_fd+1;
+			if (new_fd >= fd_count)
+				fd_count = new_fd+1;
 		}
 
 		tv.tv_sec = io_timeout?io_timeout:SELECT_TIMEOUT;
 		tv.tv_usec = 0;
 
 		errno = 0;
 
 		count = select(fd_count, &r_fds,
 			       io_filesfrom_buflen? &w_fds : NULL,
 			       NULL, &tv);
 
 		if (count == 0) {
+			msg_list_push(NORMAL_FLUSH);
 			check_timeout();
 		}
 
 		if (count <= 0) {
 			if (errno == EBADF) {
 				exit_cleanup(RERR_SOCKETIO);
 			}
 			continue;
 		}
 
-		if (io_error_fd != -1 && FD_ISSET(io_error_fd, &r_fds)) {
-			read_error_fd();
-		}
+		if (msg_fd_in >= 0 && FD_ISSET(msg_fd_in, &r_fds))
+			read_msg_fd();
 
-		if (io_filesfrom_f_out != -1) {
+		if (io_filesfrom_f_out >= 0) {
 			if (io_filesfrom_buflen) {
 				if (FD_ISSET(io_filesfrom_f_out, &w_fds)) {
 					int l = write(io_filesfrom_f_out,
 						      io_filesfrom_bp,
 						      io_filesfrom_buflen);
 					if (l > 0) {
@@ -287,13 +442,13 @@
 							io_filesfrom_bp += l;
 					} else {
 						/* XXX should we complain? */
 						io_filesfrom_f_out = -1;
 					}
 				}
-			} else if (io_filesfrom_f_in != -1) {
+			} else if (io_filesfrom_f_in >= 0) {
 				if (FD_ISSET(io_filesfrom_f_in, &r_fds)) {
 					int l = read(io_filesfrom_f_in,
 						     io_filesfrom_buf,
 						     sizeof io_filesfrom_buf);
 					if (l <= 0) {
 						/* Send end-of-file marker */
@@ -349,13 +504,13 @@
 			if (io_timeout)
 				last_io = time(NULL);
 			continue;
 		} else if (n == 0) {
 			whine_about_eof();
 			return -1; /* doesn't return */
-		} else if (n == -1) {
+		} else if (n < 0) {
 			if (errno == EINTR || errno == EWOULDBLOCK ||
 			    errno == EAGAIN) 
 				continue;
 			die_from_readerr(errno);
 		}
 	}
@@ -437,54 +592,75 @@
  */
 static int read_unbuffered(int fd, char *buf, size_t len)
 {
 	static size_t remaining;
 	int tag, ret = 0;
 	char line[1024];
+	static char *buffer;
+	static size_t bufferIdx = 0;
+	static size_t bufferSz;
 
-	if (!io_multiplexing_in || fd != multiplex_in_fd)
+	if (fd != multiplex_in_fd)
 		return read_timeout(fd, buf, len);
 
+	if (!io_multiplexing_in && remaining == 0) {
+		if (!buffer) {
+			bufferSz = 2 * IO_BUFFER_SIZE;
+			buffer   = new_array(char, bufferSz);
+			if (!buffer) out_of_memory("read_unbuffered");
+		}
+		remaining = read_timeout(fd, buffer, bufferSz);
+		bufferIdx = 0;
+	}
+
 	while (ret == 0) {
 		if (remaining) {
 			len = MIN(len, remaining);
-			read_loop(fd, buf, len);
+			memcpy(buf, buffer + bufferIdx, len);
+			bufferIdx += len;
 			remaining -= len;
 			ret = len;
-			continue;
+			break;
 		}
 
 		read_loop(fd, line, 4);
 		tag = IVAL(line, 0);
 
 		remaining = tag & 0xFFFFFF;
-		tag = tag >> 24;
-
-		if (tag == MPLEX_BASE)
-			continue;
+		tag = (tag >> 24) - MPLEX_BASE;
 
-		tag -= MPLEX_BASE;
-
-		if (tag != FERROR && tag != FINFO) {
+		switch (tag) {
+		case MSG_DATA:
+			if (!buffer || remaining > bufferSz) {
+				buffer = realloc_array(buffer, char, remaining);
+				if (!buffer) out_of_memory("read_unbuffered");
+				bufferSz = remaining;
+			}
+			read_loop(fd, buffer, remaining);
+			bufferIdx = 0;
+			break;
+		case MSG_INFO:
+		case MSG_ERROR:
+			if (remaining >= sizeof line) {
+				rprintf(FERROR, "multiplexing overflow %d:%ld\n\n",
+					tag, (long)remaining);
+				exit_cleanup(RERR_STREAMIO);
+			}
+			read_loop(fd, line, remaining);
+			rwrite((enum logcode)tag, line, remaining);
+			remaining = 0;
+			break;
+		default:
 			rprintf(FERROR, "unexpected tag %d\n", tag);
 			exit_cleanup(RERR_STREAMIO);
 		}
-
-		if (remaining > sizeof line - 1) {
-			rprintf(FERROR, "multiplexing overflow %ld\n\n",
-				(long)remaining);
-			exit_cleanup(RERR_STREAMIO);
-		}
-
-		read_loop(fd, line, remaining);
-		line[remaining] = 0;
-
-		rprintf((enum logcode) tag, "%s", line);
-		remaining = 0;
 	}
 
+	if (remaining == 0)
+		io_flush(NORMAL_FLUSH);
+
 	return ret;
 }
 
 
 
 /**
@@ -495,14 +671,12 @@
 static void readfd(int fd, char *buffer, size_t N)
 {
 	int  ret;
 	size_t total=0;  
 
 	while (total < N) {
-		io_flush();
-
 		ret = read_unbuffered(fd, buffer + total, N-total);
 		total += ret;
 	}
 
 	stats.total_read += total;
 }
@@ -596,66 +770,62 @@
 {
 	size_t total = 0;
 	fd_set w_fds, r_fds;
 	int fd_count, count;
 	struct timeval tv;
 
-	err_list_push();
+	msg_list_push(NORMAL_FLUSH);
 
 	no_flush++;
 
 	while (total < len) {
 		FD_ZERO(&w_fds);
 		FD_SET(fd,&w_fds);
 		fd_count = fd;
 
-		if (io_error_fd != -1) {
+		if (msg_fd_in >= 0) {
 			FD_ZERO(&r_fds);
-			FD_SET(io_error_fd,&r_fds);
-			if (io_error_fd > fd_count) 
-				fd_count = io_error_fd;
+			FD_SET(msg_fd_in,&r_fds);
+			if (msg_fd_in > fd_count) 
+				fd_count = msg_fd_in;
 		}
 
 		tv.tv_sec = io_timeout?io_timeout:SELECT_TIMEOUT;
 		tv.tv_usec = 0;
 
 		errno = 0;
-
-		count = select(fd_count+1,
-			       io_error_fd != -1?&r_fds:NULL,
-			       &w_fds,NULL,
-			       &tv);
+		count = select(fd_count+1, msg_fd_in >= 0 ? &r_fds : NULL,
+			       &w_fds, NULL, &tv);
 
 		if (count == 0) {
+			msg_list_push(NORMAL_FLUSH);
 			check_timeout();
 		}
 
 		if (count <= 0) {
 			if (errno == EBADF) {
 				exit_cleanup(RERR_SOCKETIO);
 			}
 			continue;
 		}
 
-		if (io_error_fd != -1 && FD_ISSET(io_error_fd, &r_fds)) {
-			read_error_fd();
-		}
+		if (msg_fd_in >= 0 && FD_ISSET(msg_fd_in, &r_fds))
+			read_msg_fd();
 
 		if (FD_ISSET(fd, &w_fds)) {
 			int ret;
 			size_t n = len-total;
 			ret = write(fd,buf+total,n);
 
-			if (ret == -1 && errno == EINTR) {
-				continue;
-			}
-
-			if (ret == -1 && 
-			    (errno == EWOULDBLOCK || errno == EAGAIN)) {
-				msleep(1);
-				continue;
+			if (ret < 0) {
+				if (errno == EINTR)
+					continue;
+				if (errno == EWOULDBLOCK || errno == EAGAIN) {
+					msleep(1);
+					continue;
+				}
 			}
 
 			if (ret <= 0) {
 				/* Don't try to write errors back
 				 * across the stream */
 				io_multiplexing_close();
@@ -679,26 +849,31 @@
 }
 
 
 static char *io_buffer;
 static int io_buffer_count;
 
-void io_start_buffering(int fd)
+void io_start_buffering_out(int fd)
 {
 	if (io_buffer) return;
 	multiplex_out_fd = fd;
 	io_buffer = new_array(char, IO_BUFFER_SIZE);
 	if (!io_buffer) out_of_memory("writefd");
 	io_buffer_count = 0;
 }
 
+void io_start_buffering_in(int fd)
+{
+	multiplex_in_fd = fd;
+}
+
 /**
  * Write an message to a multiplexed stream. If this fails then rsync
  * exits.
  **/
-static void mplex_write(int fd, enum logcode code, char *buf, size_t len)
+static void mplex_write(int fd, enum msgcode code, char *buf, size_t len)
 {
 	char buffer[4096];
 	size_t n = len;
 
 	SIVAL(buffer, 0, ((MPLEX_BASE + (int)code)<<24) + len);
 
@@ -715,43 +890,43 @@
 	if (len) {
 		writefd_unbuffered(fd, buf, len);
 	}
 }
 
 
-void io_flush(void)
+void io_flush(int flush_it_all)
 {
 	int fd = multiplex_out_fd;
+	
+	msg_list_push(flush_it_all);
 
-	err_list_push();
-
-	if (!io_buffer_count || no_flush) return;
+	if (!io_buffer_count || no_flush)
+		return;
 
-	if (io_multiplexing_out) {
-		mplex_write(fd, FNONE, io_buffer, io_buffer_count);
-	} else {
+	if (io_multiplexing_out)
+		mplex_write(fd, MSG_DATA, io_buffer, io_buffer_count);
+	else
 		writefd_unbuffered(fd, io_buffer, io_buffer_count);
-	}
 	io_buffer_count = 0;
 }
 
 
 void io_end_buffering(void)
 {
-	io_flush();
+	io_flush(NORMAL_FLUSH);
 	if (!io_multiplexing_out) {
 		free(io_buffer);
 		io_buffer = NULL;
 	}
 }
 
 static void writefd(int fd,char *buf,size_t len)
 {
 	stats.total_written += len;
 
-	err_list_push();
+	msg_list_push(NORMAL_FLUSH);
 
 	if (!io_buffer || fd != multiplex_out_fd) {
 		writefd_unbuffered(fd, buf, len);
 		return;
 	}
 
@@ -761,13 +936,14 @@
 			memcpy(io_buffer+io_buffer_count, buf, n);
 			buf += n;
 			len -= n;
 			io_buffer_count += n;
 		}
 
-		if (io_buffer_count == IO_BUFFER_SIZE) io_flush();
+		if (io_buffer_count == IO_BUFFER_SIZE)
+			io_flush(NORMAL_FLUSH);
 	}
 }
 
 
 void write_int(int f,int32 x)
 {
@@ -873,40 +1049,40 @@
 	if (len < 0) exit_cleanup(RERR_STREAMIO);
 
 	write_sbuf(fd, buf);
 }
 
 
-/** Setup for multiplexing an error stream with the data stream */
+/** Setup for multiplexing a MSG_* stream with the data stream. */
 void io_start_multiplex_out(int fd)
 {
 	multiplex_out_fd = fd;
-	io_flush();
-	io_start_buffering(fd);
+	io_flush(NORMAL_FLUSH);
+	io_start_buffering_out(fd);
 	io_multiplexing_out = 1;
 }
 
-/** Setup for multiplexing an error stream with the data stream */
+/** Setup for multiplexing a MSG_* stream with the data stream. */
 void io_start_multiplex_in(int fd)
 {
 	multiplex_in_fd = fd;
-	io_flush();
+	io_flush(NORMAL_FLUSH);
 	io_multiplexing_in = 1;
 }
 
-/** Write an message to the multiplexed error stream */
-int io_multiplex_write(enum logcode code, char *buf, size_t len)
+/** Write an message to the multiplexed data stream. */
+int io_multiplex_write(enum msgcode code, char *buf, size_t len)
 {
 	if (!io_multiplexing_out) return 0;
 
-	io_flush();
+	io_flush(NORMAL_FLUSH);
 	stats.total_written += (len+4);
 	mplex_write(multiplex_out_fd, code, buf, len);
 	return 1;
 }
 
-/** Stop output multiplexing */
+/** Stop output multiplexing. */
 void io_multiplexing_close(void)
 {
 	io_multiplexing_out = 0;
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/addrinfo.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/addrinfo.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/addrinfo.h	2001-12-05 21:19:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/addrinfo.h	2004-02-27 15:22:37.000000000 +0800
@@ -104,19 +104,12 @@
 
 extern void freehostent(struct hostent *);
 extern char *gai_strerror(int);
 #endif /* AI_PASSIVE */
 #endif /* HAVE_GETADDRINFO */
 
-
-
 #ifndef HAVE_SOCKADDR_STORAGE
 struct sockaddr_storage {
-#ifdef HAVE_SOCKADDR_LEN
-	uchar		ss_len;		/* address length */
-	uchar		ss_family;	/* address family */
-#else
-	unsigned short	ss_family;
-#endif
-	unsigned char   fill[126];
+	unsigned long	align;
+	unsigned char	fill[128 - sizeof (unsigned long)];
 };
-#endif /* ndef HAVE_SOCKADDR_STORAGE */
+#endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/compat.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/compat.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/compat.c	2002-04-08 11:40:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/compat.c	2004-01-20 08:59:26.000000000 +0800
@@ -113,16 +113,18 @@
  * @return index of the terminating byte.
  **/
  size_t strlcpy(char *d, const char *s, size_t bufsize)
 {
 	size_t len = strlen(s);
 	size_t ret = len;
-	if (bufsize <= 0) return 0;
-	if (len >= bufsize) len = bufsize-1;
-	memcpy(d, s, len);
-	d[len] = 0;
+	if (bufsize > 0) {
+		if (len >= bufsize)
+			len = bufsize-1;
+		memcpy(d, s, len);
+		d[len] = 0;
+	}
 	return ret;
 }
 #endif
 
 #ifndef HAVE_STRLCAT
 /**
@@ -135,16 +137,15 @@
  size_t strlcat(char *d, const char *s, size_t bufsize)
 {
 	size_t len1 = strlen(d);
 	size_t len2 = strlen(s);
 	size_t ret = len1 + len2;
 
-	if (len1+len2 >= bufsize) {
-		len2 = bufsize - (len1+1);
-	}
-	if (len2 > 0) {
+	if (len1 < bufsize - 1) {
+		if (len2 >= bufsize - len1)
+			len2 = bufsize - len1 - 1;
 		memcpy(d+len1, s, len2);
 		d[len1+len2] = 0;
 	}
 	return ret;
 }
 #endif
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/getaddrinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/getaddrinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/getaddrinfo.c	2003-01-11 06:38:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/getaddrinfo.c	2004-03-16 09:26:36.000000000 +0800
@@ -159,22 +159,22 @@
 		return 0;
 	memcpy(*to_ai, pai, sizeof(struct addrinfo));
 	(*to_ai)->ai_addr = (struct sockaddr *)((*to_ai) + 1);
 	memset((*to_ai)->ai_addr, 0, (afd)->a_socklen);
 	(*to_ai)->ai_addrlen = (afd)->a_socklen;
 #if HAVE_SOCKADDR_LEN
-	(*to_ai)->ai_addr->sa_len= (afd)->a_socklen;
+	(*to_ai)->ai_addr->sa_len = (afd)->a_socklen;
 #endif
 	(*to_ai)->ai_addr->sa_family = (*to_ai)->ai_family = (afd)->a_af;
 	((struct sockinet *)(*to_ai)->ai_addr)->si_port = port;
 	p = (char *)((*to_ai)->ai_addr);
 	memcpy(p + (afd)->a_off, (addr), (afd)->a_addrlen);
 	return 1;
 }
 
-#define ERR(err) { error = (err); goto bad; }
+#define ERR(err) do { error = (err); if (1) goto bad; } while (0)
 
 char *
 gai_strerror(ecode)
 	int ecode;
 {
 	if (ecode < 0 || ecode > EAI_MAX)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/getnameinfo.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/getnameinfo.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/lib/getnameinfo.c	2003-01-11 06:38:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib/getnameinfo.c	2004-03-16 09:26:36.000000000 +0800
@@ -96,15 +96,15 @@
 	char numserv[512];
 	char numaddr[512];
 
 	if (sa == NULL)
 		return ENI_NOSOCKET;
 
-#ifdef HAVE_SOCKADDR_LEN
+#if HAVE_SOCKADDR_LEN
 	if (sa->sa_len != salen) return ENI_SALEN;
-#endif /* HAVE_SOCKADDR_LEN */
+#endif
 	
 	family = sa->sa_family;
 	for (i = 0; afdl[i].a_af; i++)
 		if (afdl[i].a_af == family) {
 			afd = &afdl[i];
 			goto found;
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib: pool_alloc.3
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib: pool_alloc.c
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/lib: pool_alloc.h
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/loadparm.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/loadparm.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/loadparm.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/loadparm.c	2004-02-04 15:31:29.000000000 +0800
@@ -98,20 +98,20 @@
  */
 typedef struct
 {
 	char *motd_file;
 	char *log_file;
 	char *pid_file;
-	int syslog_facility;
 	char *socket_options;
+	int syslog_facility;
+	int max_verbosity;
 } global;
 
 static global Globals;
 
 
-
 /*
  * This structure describes a single service.
  */
 typedef struct
 {
 	char *name;
@@ -265,12 +265,13 @@
 {
   {"motd file",        P_STRING,  P_GLOBAL, &Globals.motd_file,    NULL,   0},
   {"syslog facility",  P_ENUM,    P_GLOBAL, &Globals.syslog_facility, enum_facilities,0},
   {"socket options",   P_STRING,  P_GLOBAL, &Globals.socket_options,NULL,  0},
   {"log file",         P_STRING,  P_GLOBAL, &Globals.log_file,      NULL,  0},
   {"pid file",         P_STRING,  P_GLOBAL, &Globals.pid_file,      NULL,  0},
+  {"max verbosity",    P_INTEGER, P_GLOBAL, &Globals.max_verbosity, NULL,  0},
 
   {"timeout",          P_INTEGER, P_LOCAL,  &sDefault.timeout,     NULL,  0},
   {"max connections",  P_INTEGER, P_LOCAL,  &sDefault.max_connections,NULL, 0},
   {"name",             P_STRING,  P_LOCAL,  &sDefault.name,        NULL,   0},
   {"comment",          P_STRING,  P_LOCAL,  &sDefault.comment,     NULL,   0},
   {"lock file",        P_STRING,  P_LOCAL,  &sDefault.lock_file,   NULL,   0},
@@ -301,16 +302,17 @@
 
 /***************************************************************************
 Initialise the global parameter structure.
 ***************************************************************************/
 static void init_globals(void)
 {
-	memset(&Globals, 0, sizeof(Globals));
+	memset(&Globals, 0, sizeof Globals);
 #ifdef LOG_DAEMON
 	Globals.syslog_facility = LOG_DAEMON;
 #endif
+	Globals.max_verbosity = 1;
 }
 
 /***************************************************************************
 Initialise the sDefault parameter structure.
 ***************************************************************************/
 static void init_locals(void)
@@ -344,12 +346,13 @@
 
 FN_GLOBAL_STRING(lp_motd_file, &Globals.motd_file)
 FN_GLOBAL_STRING(lp_log_file, &Globals.log_file)
 FN_GLOBAL_STRING(lp_pid_file, &Globals.pid_file)
 FN_GLOBAL_STRING(lp_socket_options, &Globals.socket_options)
 FN_GLOBAL_INTEGER(lp_syslog_facility, &Globals.syslog_facility)
+FN_GLOBAL_INTEGER(lp_max_verbosity, &Globals.max_verbosity)
 
 FN_LOCAL_STRING(lp_name, name)
 FN_LOCAL_STRING(lp_comment, comment)
 FN_LOCAL_STRING(lp_path, path)
 FN_LOCAL_STRING(lp_lock_file, lock_file)
 FN_LOCAL_BOOL(lp_read_only, read_only)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/log.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/log.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/log.c	2003-12-15 16:06:52.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/log.c	2004-01-20 13:15:14.000000000 +0800
@@ -24,16 +24,24 @@
 
   Mapping to human-readable messages added by Martin Pool
   <mbp@samba.org>, Oct 2000.
   */
 #include "rsync.h"
 
+extern int am_daemon;
+extern int am_server;
+extern int am_sender;
+extern int quiet;
+extern int module_id;
+extern int msg_fd_out;
+extern char *auth_user;
+extern char *log_format;
+
 static int log_initialised;
 static char *logfname;
 static FILE *logfile;
-static int log_error_fd = -1;
 struct stats stats;
 
 int log_got_error=0;
 
 struct {
         int code;
@@ -74,67 +82,12 @@
 		if (rerr_names[i].code == code)
 			return rerr_names[i].name;
 	}
 	return NULL;
 }
 
-struct err_list {
-	struct err_list *next;
-	char *buf;
-	int len;
-	int written; /* how many bytes we have written so far */
-};
-
-static struct err_list *err_list_head;
-static struct err_list *err_list_tail;
-
-/* add an error message to the pending error list */
-static void err_list_add(int code, char *buf, int len)
-{
-	struct err_list *el;
-	el = new(struct err_list);
-	if (!el) exit_cleanup(RERR_MALLOC);
-	el->next = NULL;
-	el->buf = new_array(char, len+4);
-	if (!el->buf) exit_cleanup(RERR_MALLOC);
-	memcpy(el->buf+4, buf, len);
-	SIVAL(el->buf, 0, ((code+MPLEX_BASE)<<24) | len);
-	el->len = len+4;
-	el->written = 0;
-	if (err_list_tail) {
-		err_list_tail->next = el;
-	} else {
-		err_list_head = el;
-	}
-	err_list_tail = el;
-}
-
-
-/* try to push errors off the error list onto the wire */
-void err_list_push(void)
-{
-	if (log_error_fd == -1) return;
-
-	while (err_list_head) {
-		struct err_list *el = err_list_head;
-		int n = write(log_error_fd, el->buf+el->written, el->len - el->written);
-		/* don't check for an error if the best way of handling the error is
-		 * to ignore it */
-		if (n == -1) break;
-		if (n > 0) {
-			el->written += n;
-		}
-		if (el->written == el->len) {
-			free(el->buf);
-			err_list_head = el->next;
-			if (!err_list_head) err_list_tail = NULL;
-			free(el);
-		}
-	}
-}
-
 
 static void logit(int priority, char *buf)
 {
 	if (logfname) {
 		if (!logfile)
 			log_open();
@@ -200,52 +153,40 @@
 	if (logfile) {
 		fclose(logfile);
 		logfile = NULL;
 	}
 }
 
-/* setup the error file descriptor - used when we are a server
- * that is receiving files */
-void set_error_fd(int fd)
-{
-	log_error_fd = fd;
-	set_nonblocking(log_error_fd);
-}
-
 /* this is the underlying (unformatted) rsync debugging function. Call
  * it with FINFO, FERROR or FLOG */
 void rwrite(enum logcode code, char *buf, int len)
 {
 	FILE *f=NULL;
-	extern int am_daemon;
-	extern int am_server;
-	extern int quiet;
 	/* recursion can happen with certain fatal conditions */
 
-	if (quiet && code == FINFO) return;
+	if (quiet && code == FINFO)
+		return;
 
-	if (len < 0) exit_cleanup(RERR_MESSAGEIO);
+	if (len < 0)
+		exit_cleanup(RERR_MESSAGEIO);
 
 	buf[len] = 0;
 
 	if (code == FLOG) {
 		if (am_daemon) logit(LOG_INFO, buf);
 		return;
 	}
 
-	/* first try to pass it off to our sibling */
-	if (am_server && log_error_fd != -1) {
-		err_list_add(code, buf, len);
-		err_list_push();
-		return;
-	}
-
-	/* next, if we are a server and multiplexing is enabled,
-	 * pass it to the other side.  */
-	if (am_server && io_multiplex_write(code, buf, len)) {
-		return;
+	if (am_server) {
+		/* Pass it to non-server side, perhaps through our sibling. */
+		if (msg_fd_out >= 0) {
+			send_msg((enum msgcode)code, buf, len);
+			return;
+		}
+		if (io_multiplex_write((enum msgcode)code, buf, len))
+			return;
 	}
 
 	/* otherwise, if in daemon mode and either we are not a server
 	 *  (that is, we are not running --daemon over a remote shell) or
 	 *  the log has already been initialised, log the message on this
 	 *  side because we don't want the client to see most errors for
@@ -376,13 +317,12 @@
 
 
 
 void rflush(enum logcode code)
 {
 	FILE *f = NULL;
-	extern int am_daemon;
 	
 	if (am_daemon) {
 		return;
 	}
 
 	if (code == FLOG) {
@@ -391,13 +331,12 @@
 
 	if (code == FERROR) {
 		f = stderr;
 	}
 
 	if (code == FINFO) {
-		extern int am_server;
 		if (am_server)
 			f = stderr;
 		else
 			f = stdout;
 	}
 
@@ -410,21 +349,16 @@
 /* a generic logging routine for send/recv, with parameter
  * substitiution */
 static void log_formatted(enum logcode code,
 			  char *format, char *op, struct file_struct *file,
 			  struct stats *initial_stats)
 {
-	extern int module_id;
-	extern char *auth_user;
 	char buf[1024];
 	char buf2[1024];
 	char *p, *s, *n;
 	size_t l;
-	extern struct stats stats;		
-	extern int am_sender;
-	extern int am_daemon;
 	int64 b;
 
 	/* We expand % codes one by one in place in buf.  We don't
 	 * copy in the terminating nul of the inserted strings, but
 	 * rather keep going until we reach the nul of the format.
 	 * Just to make sure we don't clobber that nul and therefore
@@ -448,14 +382,14 @@
 			snprintf(buf2,sizeof(buf2),"%d",
 				 (int)getpid());
 			n = buf2;
 			break;
 		case 'o': n = op; break;
 		case 'f':
-			snprintf(buf2, sizeof(buf2), "%s/%s",
-				 file->basedir?file->basedir:"",
+			pathjoin(buf2, sizeof buf2,
+				 file->basedir ? file->basedir : "",
 				 f_name(file));
 			clean_fname(buf2);
 			n = buf2;
 			if (*n == '/') n++;
 			break;
 		case 'm': n = lp_name(module_id); break;
@@ -516,30 +450,22 @@
 	rprintf(code,"%s\n", buf);
 }
 
 /* log the outgoing transfer of a file */
 void log_send(struct file_struct *file, struct stats *initial_stats)
 {
-	extern int module_id;
-	extern int am_server;
-	extern char *log_format;
-
 	if (lp_transfer_logging(module_id)) {
 		log_formatted(FLOG, lp_log_format(module_id), "send", file, initial_stats);
 	} else if (log_format && !am_server) {
 		log_formatted(FINFO, log_format, "send", file, initial_stats);
 	}
 }
 
 /* log the incoming transfer of a file */
 void log_recv(struct file_struct *file, struct stats *initial_stats)
 {
-	extern int module_id;
-	extern int am_server;
-	extern char *log_format;
-
 	if (lp_transfer_logging(module_id)) {
 		log_formatted(FLOG, lp_log_format(module_id), "recv", file, initial_stats);
 	} else if (log_format && !am_server) {
 		log_formatted(FINFO, log_format, "recv", file, initial_stats);
 	}
 }
@@ -553,13 +479,12 @@
  * Code is one of the RERR_* codes from errcode.h, or terminating
  * successfully.
  */
 void log_exit(int code, const char *file, int line)
 {
 	if (code == 0) {
-		extern struct stats stats;		
 		rprintf(FLOG,"wrote %.0f bytes  read %.0f bytes  total size %.0f\n",
 			(double)stats.total_written,
 			(double)stats.total_read,
 			(double)stats.total_size);
 	} else {
 		const char *name;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/main.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/main.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/main.c	2003-12-21 00:57:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/main.c	2004-02-10 11:54:47.000000000 +0800
@@ -21,20 +21,46 @@
 
 #include "rsync.h"
 
 time_t starttime = 0;
 
 extern struct stats stats;
-extern char *files_from;
-extern int filesfrom_fd;
-extern char *remote_filesfrom_file;
+extern int am_root;
 extern int am_server;
 extern int am_sender;
+extern int am_generator;
 extern int am_daemon;
 extern int verbose;
+extern int blocking_io;
+extern int cvs_exclude;
+extern int delete_mode;
+extern int delete_excluded;
+extern int delete_after;
+extern int daemon_over_rsh;
+extern int do_stats;
+extern int dry_run;
+extern int list_only;
+extern int local_server;
+extern int log_got_error;
+extern int module_id;
+extern int orig_umask;
+extern int preserve_hard_links;
 extern int protocol_version;
+extern int recurse;
+extern int relative_paths;
+extern int rsync_port;
+extern int read_batch;
+extern int write_batch;
+extern int filesfrom_fd;
+extern pid_t cleanup_child_pid;
+extern char *files_from;
+extern char *remote_filesfrom_file;
+extern char *rsync_path;
+extern char *shell_cmd;
+extern struct file_list *batch_flist;
+
 
 /* there's probably never more than at most 2 outstanding child processes,
  * but set it higher just in case.
  */
 #define MAXCHILDPROCS 5
 
@@ -52,13 +78,13 @@
 {
 	pid_t waited_pid;
 	int cnt;
 
 	while ((waited_pid = waitpid(pid, status, WNOHANG)) == 0) {
 		msleep(20);
-		io_flush();
+		io_flush(FULL_FLUSH);
 	}
 
 	if ((waited_pid == -1) && (errno == ECHILD)) {
 		/* status of requested child no longer available.
 		 * check to see if it was processed by the sigchld_handler.
 		 */
@@ -79,29 +105,29 @@
 	*status = WEXITSTATUS(*status);
 }
 
 static void report(int f)
 {
 	time_t t = time(NULL);
-	extern int do_stats;
-	int send_stats;
 
 	if (do_stats && verbose > 1) {
 		/* These come out from every process */
 		show_malloc_stats();
 		show_flist_stats();
 	}
 
+	if (am_generator)
+		return;
+
 	if (am_daemon) {
 		log_exit(0, __FILE__, __LINE__);
 		if (f == -1 || !am_sender) return;
 	}
 
-	send_stats = verbose || protocol_version >= 20;
 	if (am_server) {
-		if (am_sender && send_stats) {
+		if (am_sender) {
 			int64 w;
 			/* store total_written in a temporary
 			 * because write_longint changes it */
 			w = stats.total_written;
 			write_longint(f,stats.total_read);
 			write_longint(f,w);
@@ -109,28 +135,22 @@
 		}
 		return;
 	}
 
 	/* this is the client */
 
-	if (!am_sender && send_stats) {
+	if (!am_sender) {
 		int64 r;
 		stats.total_written = read_longint(f);
 		/* store total_read in a temporary, read_longint changes it */
 		r = read_longint(f);
 		stats.total_size = read_longint(f);
 		stats.total_read = r;
 	}
 
 	if (do_stats) {
-		if (!am_sender && !send_stats) {
-			/* missing the bytes written by the generator */
-			rprintf(FINFO, "\nCannot show stats as receiver because remote protocol version is less than 20\n");
-			rprintf(FINFO, "Use --stats -v to show stats\n");
-			return;
-		}
 		rprintf(FINFO,"\nNumber of files: %d\n", stats.num_files);
 		rprintf(FINFO,"Number of files transferred: %d\n",
 			stats.num_transferred_files);
 		rprintf(FINFO,"Total file size: %.0f bytes\n",
 			(double)stats.total_size);
 		rprintf(FINFO,"Total transferred file size: %.0f bytes\n",
@@ -172,54 +192,51 @@
 	mi = mallinfo();
 
 	rprintf(FINFO, "\n" RSYNC_NAME "[%d] (%s%s%s) heap statistics:\n",
 		getpid(),
 		am_server ? "server " : "",
 		am_daemon ? "daemon " : "",
-		am_sender ? "sender" : "receiver");
+		who_am_i());
 	rprintf(FINFO, "  arena:     %10d   (bytes from sbrk)\n", mi.arena);
 	rprintf(FINFO, "  ordblks:   %10d   (chunks not in use)\n", mi.ordblks);
 	rprintf(FINFO, "  smblks:    %10d\n", mi.smblks);
 	rprintf(FINFO, "  hblks:     %10d   (chunks from mmap)\n", mi.hblks);
 	rprintf(FINFO, "  hblkhd:    %10d   (bytes from mmap)\n", mi.hblkhd);
+	rprintf(FINFO, "  allmem:    %10d   (bytes from sbrk + mmap)\n",
+	    mi.arena + mi.hblkhd);
 	rprintf(FINFO, "  usmblks:   %10d\n", mi.usmblks);
 	rprintf(FINFO, "  fsmblks:   %10d\n", mi.fsmblks);
 	rprintf(FINFO, "  uordblks:  %10d   (bytes used)\n", mi.uordblks);
 	rprintf(FINFO, "  fordblks:  %10d   (bytes free)\n", mi.fordblks);
 	rprintf(FINFO, "  keepcost:  %10d   (bytes in releasable chunk)\n", mi.keepcost);
 #endif /* HAVE_MALLINFO */
 }
 
 
 /* Start the remote shell.   cmd may be NULL to use the default. */
-static pid_t do_cmd(char *cmd,char *machine,char *user,char *path,int *f_in,int *f_out)
+static pid_t do_cmd(char *cmd, char *machine, char *user, char *path,
+		    int *f_in, int *f_out)
 {
+	int i, argc = 0;
 	char *args[100];
-	int i,argc=0;
 	pid_t ret;
-	char *tok,*dir=NULL;
+	char *tok, *dir = NULL;
 	int dash_l_set = 0;
-	extern int local_server;
-	extern char *rsync_path;
-	extern int blocking_io;
-	extern int daemon_over_rsh;
-	extern int read_batch;
 
 	if (!read_batch && !local_server) {
 		char *rsh_env = getenv(RSYNC_RSH_ENV);
 		if (!cmd)
 			cmd = rsh_env;
 		if (!cmd)
 			cmd = RSYNC_RSH;
 		cmd = strdup(cmd);
 		if (!cmd)
 			goto oom;
 
-		for (tok=strtok(cmd," ");tok;tok=strtok(NULL," ")) {
+		for (tok = strtok(cmd, " "); tok; tok = strtok(NULL, " "))
 			args[argc++] = tok;
-		}
 
 		/* check to see if we've already been given '-l user' in
 		 * the remote-shell command */
 		for (i = 0; i < argc-1; i++) {
 			if (!strcmp(args[i], "-l") && args[i+1][0] != '-')
 				dash_l_set = 1;
@@ -257,12 +274,17 @@
 
 	args[argc++] = ".";
 
 	if (!daemon_over_rsh && path && *path)
 		args[argc++] = path;
 
+	if (argc >= (int)(sizeof args / sizeof args[0])) {
+		rprintf(FERROR, "internal: args[] overflowed in do_cmd()\n");
+		exit_cleanup(RERR_MALLOC); /* XXX Need better RERR? */
+	}
+
 	args[argc] = NULL;
 
 	if (verbose > 3) {
 		rprintf(FINFO,"cmd=");
 		for (i=0;i<argc;i++)
 			rprintf(FINFO,"%s ",args[i]);
@@ -284,30 +306,27 @@
 oom:
 	out_of_memory("do_cmd");
 	return 0; /* not reached */
 }
 
 
-
-
 static char *get_local_name(struct file_list *flist,char *name)
 {
 	STRUCT_STAT st;
 	int e;
-	extern int orig_umask;
 
 	if (verbose > 2)
 		rprintf(FINFO,"get_local_name count=%d %s\n",
 			flist->count, NS(name));
 
 	if (!name)
 		return NULL;
 
 	if (do_stat(name,&st) == 0) {
 		if (S_ISDIR(st.st_mode)) {
-			if (!push_dir(name, 0)) {
+			if (!push_dir(name)) {
 				rprintf(FERROR, "push_dir %s failed: %s (1)\n",
 					full_fname(name), strerror(errno));
 				exit_cleanup(RERR_FILESELECT);
 			}
 			return NULL;
 		}
@@ -327,13 +346,13 @@
 		exit_cleanup(RERR_FILEIO);
 	} else {
 		if (verbose > 0)
 			rprintf(FINFO,"created directory %s\n",name);
 	}
 
-	if (!push_dir(name, 0)) {
+	if (!push_dir(name)) {
 		rprintf(FERROR, "push_dir %s failed: %s (2)\n",
 			full_fname(name), strerror(errno));
 		exit_cleanup(RERR_FILESELECT);
 	}
 
 	return NULL;
@@ -337,26 +356,24 @@
 	}
 
 	return NULL;
 }
 
 
-
-
 static void do_server_sender(int f_in, int f_out, int argc,char *argv[])
 {
 	int i;
 	struct file_list *flist;
 	char *dir = argv[0];
-	extern int relative_paths;
-	extern int recurse;
 
-	if (verbose > 2)
-		rprintf(FINFO,"server_sender starting pid=%d\n",(int)getpid());
+	if (verbose > 2) {
+		rprintf(FINFO, "server_sender starting pid=%ld\n",
+			(long)getpid());
+	}
 
-	if (!relative_paths && !push_dir(dir, 0)) {
+	if (!relative_paths && !push_dir(dir)) {
 		rprintf(FERROR, "push_dir %s failed: %s (3)\n",
 			full_fname(dir), strerror(errno));
 		exit_cleanup(RERR_FILESELECT);
 	}
 	argc--;
 	argv++;
@@ -377,140 +394,130 @@
 
 	flist = send_file_list(f_out,argc,argv);
 	if (!flist || flist->count == 0) {
 		exit_cleanup(0);
 	}
 
+	io_start_buffering_in(f_in);
+	io_start_buffering_out(f_out);
 	send_files(flist,f_out,f_in);
-	io_flush();
+	io_flush(FULL_FLUSH);
 	report(f_out);
 	if (protocol_version >= 24) {
 		/* final goodbye message */
  		read_int(f_in);
  	}
-	io_flush();
+	io_flush(FULL_FLUSH);
 	exit_cleanup(0);
 }
 
 
 static int do_recv(int f_in,int f_out,struct file_list *flist,char *local_name)
 {
 	int pid;
 	int status=0;
-	int recv_pipe[2];
 	int error_pipe[2];
-	extern int preserve_hard_links;
-	extern int delete_after;
-	extern int recurse;
-	extern int delete_mode;
 
 	if (preserve_hard_links)
 		init_hard_links(flist);
 
 	if (!delete_after) {
 		/* I moved this here from recv_files() to prevent a race condition */
 		if (recurse && delete_mode && !local_name && flist->count>0) {
 			delete_files(flist);
 		}
 	}
 
-	if (fd_pair(recv_pipe) < 0) {
-		rprintf(FERROR,"pipe failed in do_recv\n");
-		exit_cleanup(RERR_SOCKETIO);
-	}
-
 	if (fd_pair(error_pipe) < 0) {
 		rprintf(FERROR,"error pipe failed in do_recv\n");
 		exit_cleanup(RERR_SOCKETIO);
 	}
 
-	io_flush();
+	io_flush(NORMAL_FLUSH);
 
 	if ((pid=do_fork()) == 0) {
-		close(recv_pipe[0]);
 		close(error_pipe[0]);
 		if (f_in != f_out) close(f_out);
 
 		/* we can't let two processes write to the socket at one time */
 		io_multiplexing_close();
 
 		/* set place to send errors */
-		set_error_fd(error_pipe[1]);
+		set_msg_fd_out(error_pipe[1]);
 
-		recv_files(f_in,flist,local_name,recv_pipe[1]);
-		io_flush();
+		recv_files(f_in,flist,local_name);
+		io_flush(FULL_FLUSH);
 		report(f_in);
 
-		write_int(recv_pipe[1],1);
-		close(recv_pipe[1]);
-		io_flush();
+		send_msg(MSG_DONE, "", 0);
+		io_flush(FULL_FLUSH);
 		/* finally we go to sleep until our parent kills us
 		 * with a USR2 signal. We sleep for a short time as on
 		 * some OSes a signal won't interrupt a sleep! */
-		while (msleep(20))
-			;
+		while (1)
+			msleep(20);
 	}
 
-	close(recv_pipe[1]);
+	am_generator = 1;
+
 	close(error_pipe[1]);
 	if (f_in != f_out) close(f_in);
 
-	io_start_buffering(f_out);
+	io_start_buffering_out(f_out);
 
-	io_set_error_fd(error_pipe[0]);
+	set_msg_fd_in(error_pipe[0]);
 
-	generate_files(f_out,flist,local_name,recv_pipe[0]);
+	generate_files(f_out, flist, local_name);
 
-	read_int(recv_pipe[0]);
-	close(recv_pipe[0]);
+	get_redo_num(); /* Read final MSG_DONE and any prior messages. */
+	report(-1);
+	io_flush(FULL_FLUSH);
 	if (protocol_version >= 24) {
 		/* send a final goodbye message */
 		write_int(f_out, -1);
 	}
-	io_flush();
+	io_flush(FULL_FLUSH);
 
-	io_set_error_fd(-1);
+	set_msg_fd_in(-1);
 	kill(pid, SIGUSR2);
 	wait_process(pid, &status);
 	return status;
 }
 
 
 static void do_server_recv(int f_in, int f_out, int argc,char *argv[])
 {
 	int status;
 	struct file_list *flist;
-	char *local_name=NULL;
+	char *local_name = NULL;
 	char *dir = NULL;
-	extern int delete_mode;
-	extern int delete_excluded;
-	extern int module_id;
-	extern int read_batch;
-	extern struct file_list *batch_flist;
 
-	if (verbose > 2)
-		rprintf(FINFO,"server_recv(%d) starting pid=%d\n",argc,(int)getpid());
+	if (verbose > 2) {
+		rprintf(FINFO, "server_recv(%d) starting pid=%ld\n",
+			argc, (long)getpid());
+	}
 
 	if (am_daemon && lp_read_only(module_id) && !am_sender) {
 		rprintf(FERROR,"ERROR: module is read only\n");
 		exit_cleanup(RERR_SYNTAX);
 		return;
 	}
 
 
 	if (argc > 0) {
 		dir = argv[0];
 		argc--;
 		argv++;
-		if (!am_daemon && !push_dir(dir, 0)) {
+		if (!am_daemon && !push_dir(dir)) {
 			rprintf(FERROR, "push_dir %s failed: %s (4)\n",
 				full_fname(dir), strerror(errno));
 			exit_cleanup(RERR_FILESELECT);
 		}
 	}
 
+	io_start_buffering_in(f_in);
 	if (delete_mode && !delete_excluded)
 		recv_exclude_list(f_in);
 
 	if (filesfrom_fd >= 0) {
 		/* We're receiving the file info from the sender, so we need
 		 * the IO routines to automatically write out the names onto
@@ -548,15 +555,12 @@
 	return 0;
 }
 
 
 void start_server(int f_in, int f_out, int argc, char *argv[])
 {
-	extern int cvs_exclude;
-	extern int read_batch;
-
 	setup_protocol(f_out, f_in);
 
 	set_nonblocking(f_in);
 	set_nonblocking(f_out);
 
 	if (protocol_version >= 23)
@@ -582,16 +586,12 @@
  */
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[])
 {
 	struct file_list *flist = NULL;
 	int status = 0, status2 = 0;
 	char *local_name = NULL;
-	extern pid_t cleanup_child_pid;
-	extern int write_batch;
-	extern int read_batch;
-	extern struct file_list *batch_flist;
 
 	cleanup_child_pid = pid;
 	if (read_batch)
 		flist = batch_flist;
 
 	set_nonblocking(f_in);
@@ -600,43 +600,43 @@
 	setup_protocol(f_out,f_in);
 
 	if (protocol_version >= 23)
 		io_start_multiplex_in(f_in);
 
 	if (am_sender) {
-		extern int cvs_exclude;
-		extern int delete_mode;
-		extern int delete_excluded;
+		io_start_buffering_out(f_out);
 		if (cvs_exclude)
 			add_cvs_excludes();
 		if (delete_mode && !delete_excluded)
 			send_exclude_list(f_out);
 		if (remote_filesfrom_file)
 			filesfrom_fd = f_in;
-		if (!read_batch) /*  dw -- don't write to pipe */
+		if (!read_batch) /* don't write to pipe */
 			flist = send_file_list(f_out,argc,argv);
 		if (verbose > 3)
 			rprintf(FINFO,"file list sent\n");
 
+		io_flush(NORMAL_FLUSH);
 		send_files(flist,f_out,f_in);
+		io_flush(FULL_FLUSH);
 		if (protocol_version >= 24) {
 			/* final goodbye message */
 			read_int(f_in);
 		}
 		if (pid != -1) {
 			if (verbose > 3)
 				rprintf(FINFO,"client_run waiting on %d\n", (int) pid);
-			io_flush();
+			io_flush(FULL_FLUSH);
 			wait_process(pid, &status);
 		}
 		report(-1);
+		io_flush(FULL_FLUSH);
 		exit_cleanup(status);
 	}
 
 	if (argc == 0) {
-		extern int list_only;
 		list_only = 1;
 	}
 
 	if (!write_batch)
 		send_exclude_list(f_out);
 
@@ -657,13 +657,13 @@
 
 	status2 = do_recv(f_in,f_out,flist,local_name);
 
 	if (pid != -1) {
 		if (verbose > 3)
 			rprintf(FINFO,"client_run2 waiting on %d\n", (int) pid);
-		io_flush();
+		io_flush(FULL_FLUSH);
 		wait_process(pid, &status);
 	}
 
 	return MAX(status, status2);
 }
 
@@ -697,17 +697,12 @@
 	char *shell_machine = NULL;
 	char *shell_path = NULL;
 	char *shell_user = NULL;
 	int ret;
 	pid_t pid;
 	int f_in,f_out;
-	extern int local_server;
-	extern char *shell_cmd;
-	extern int rsync_port;
-	extern int daemon_over_rsh;
-	extern int read_batch;
 	int rc;
 
 	/* Don't clobber argv[] so that ps(1) can still show the right
 	 * command line. */
 	if ((rc = copy_argv(argv)))
 		return rc;
@@ -830,13 +825,13 @@
 		am_sender = 1;
 		local_server = 1;
 		shell_path = argv[argc-1];
 	}
 
 	if (shell_machine) {
-		p = strchr(shell_machine,'@');
+		p = strrchr(shell_machine,'@');
 		if (p) {
 			*p = 0;
 			shell_user = shell_machine;
 			shell_machine = p+1;
 		}
 	}
@@ -852,13 +847,12 @@
 	if (!am_sender && argc > 1) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (argc == 0 && !am_sender) {
-		extern int list_only;
 		list_only = 1;
 	}
 
 	pid = do_cmd(shell_cmd,shell_machine,shell_user,shell_path,
 		     &f_in,&f_out);
 
@@ -885,13 +879,12 @@
 {
 	exit_cleanup(RERR_SIGNAL);
 }
 
 static RETSIGTYPE sigusr2_handler(UNUSED(int val))
 {
-	extern int log_got_error;
 	if (log_got_error) _exit(RERR_PARTIAL);
 	_exit(0);
 }
 
 static RETSIGTYPE sigchld_handler(UNUSED(int val))
 {
@@ -968,17 +961,13 @@
 }
 #endif
 
 
 int main(int argc,char *argv[])
 {
-	extern int am_root;
-	extern int orig_umask;
-	extern int dry_run;
 	int ret;
-	extern int write_batch;
 	int orig_argc;
 	char **orig_argv;
 
 	orig_argc = argc;
 	orig_argv = argv;
 
@@ -990,13 +979,13 @@
 	signal(SIGFPE, rsync_panic_handler);
 	signal(SIGABRT, rsync_panic_handler);
 	signal(SIGBUS, rsync_panic_handler);
 #endif /* def MAINTAINER_MODE */
 
 	starttime = time(NULL);
-	am_root = (getuid() == 0);
+	am_root = (MY_UID() == 0);
 
 	memset(&stats, 0, sizeof(stats));
 
 	if (argc < 2) {
 		usage(FERROR);
 		exit_cleanup(RERR_SYNTAX);
@@ -1022,13 +1011,15 @@
 	signal(SIGPIPE, SIG_IGN);
 
 	/* Initialize push_dir here because on some old systems getcwd
 	 * (implemented by forking "pwd" and reading its output) doesn't
 	 * work when there are other child processes.  Also, on all systems
 	 * that implement getcwd that way "pwd" can't be found after chroot. */
-	push_dir(NULL,0);
+	push_dir(NULL);
+
+	init_flist();
 
 	if (write_batch && !am_server) {
 		write_batch_argvs_file(orig_argc, orig_argv);
 	}
 
 	if (am_daemon && !am_server)
@@ -1039,19 +1030,12 @@
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (dry_run)
 		verbose = MAX(verbose,1);
 
-#ifndef SUPPORT_LINKS
-	if (!am_server && preserve_links) {
-		rprintf(FERROR,"ERROR: symbolic links not supported\n");
-		exit_cleanup(RERR_UNSUPPORTED);
-	}
-#endif
-
 	if (am_server) {
 		set_nonblocking(STDIN_FILENO);
 		set_nonblocking(STDOUT_FILENO);
 		if (am_daemon)
 			return start_daemon(STDIN_FILENO, STDOUT_FILENO);
 		start_server(STDIN_FILENO, STDOUT_FILENO, argc, argv);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/Makefile.in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/Makefile.in
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/Makefile.in	2003-07-30 14:12:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/Makefile.in	2004-02-11 01:06:11.000000000 +0800
@@ -22,15 +22,15 @@
 
 VERSION=@VERSION@
 
 .SUFFIXES:
 .SUFFIXES: .c .o
 
-HEADERS=byteorder.h config.h errcode.h proto.h rsync.h
+HEADERS=byteorder.h config.h errcode.h proto.h rsync.h lib/pool_alloc.h
 LIBOBJ=lib/wildmatch.o lib/compat.o lib/snprintf.o lib/mdfour.o \
-	lib/permstring.o @LIBOBJS@
+	lib/permstring.o lib/pool_alloc.o @LIBOBJS@
 ZLIBOBJ=zlib/deflate.o zlib/infblock.o zlib/infcodes.o zlib/inffast.o \
 	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
 	zlib/zutil.o zlib/adler32.o
 OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
 	main.o checksum.o match.o syscall.o log.o backup.o
 OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/match.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/match.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/match.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/match.c	2004-01-04 03:28:03.000000000 +0800
@@ -23,13 +23,13 @@
 extern int am_server;
 extern int do_progress;
 
 typedef unsigned short tag;
 
 #define TABLESIZE (1<<16)
-#define NULL_TAG (-1)
+#define NULL_TAG ((size_t)-1)
 
 static int false_alarms;
 static int tag_hits;
 static int matches;
 static int64 data_transfer;
 
@@ -38,50 +38,50 @@
 static int total_matches;
 
 extern struct stats stats;
 
 struct target {
 	tag t;
-	int i;
+	size_t i;
 };
 
 static struct target *targets;
 
-static int *tag_table;
+static size_t *tag_table;
 
 #define gettag2(s1,s2) (((s1) + (s2)) & 0xFFFF)
 #define gettag(sum) gettag2((sum)&0xFFFF,(sum)>>16)
 
 static int compare_targets(struct target *t1,struct target *t2)
 {
 	return (int)t1->t - (int)t2->t;
 }
 
 
 static void build_hash_table(struct sum_struct *s)
 {
-	int i;
+	size_t i;
 
 	if (!tag_table)
-		tag_table = new_array(int, TABLESIZE);
+		tag_table = new_array(size_t, TABLESIZE);
 
 	targets = new_array(struct target, s->count);
 	if (!tag_table || !targets)
 		out_of_memory("build_hash_table");
 
-	for (i = 0; i < (int)s->count; i++) {
+	for (i = 0; i < s->count; i++) {
 		targets[i].i = i;
 		targets[i].t = gettag(s->sums[i].sum1);
 	}
 
 	qsort(targets,s->count,sizeof(targets[0]),(int (*)())compare_targets);
 
 	for (i = 0; i < TABLESIZE; i++)
 		tag_table[i] = NULL_TAG;
 
-	for (i = s->count-1; i >= 0; i--)
+	for (i = s->count; i-- > 0; )
 		tag_table[targets[i].t] = i;
 }
 
 
 static OFF_T last_match;
 
@@ -102,13 +102,13 @@
 		    OFF_T offset,int i)
 {
 	OFF_T n = offset - last_match;
 	OFF_T j;
 
 	if (verbose > 2 && i >= 0)
-		rprintf(FINFO,"match at %.0f last_match=%.0f j=%d len=%d n=%.0f\n",
+		rprintf(FINFO,"match at %.0f last_match=%.0f j=%d len=%u n=%.0f\n",
 			(double)offset,(double)last_match,i,s->sums[i].len,(double)n);
 
 	send_token(f,i,buf,last_match,n,i<0?0:s->sums[i].len);
 	data_transfer += n;
 
 	if (i >= 0) {
@@ -127,78 +127,84 @@
 	else
 		last_match = offset;
 
 	if (buf && do_progress) {
 		show_progress(last_match, buf->file_size);
 
-		if (i == -1) end_progress(buf->file_size);
+		if (i == -1)
+			end_progress(buf->file_size);
 	}
 }
 
 
 static void hash_search(int f,struct sum_struct *s,
-			struct map_struct *buf,OFF_T len)
+			struct map_struct *buf, OFF_T len)
 {
 	OFF_T offset, end;
-	int j,k, last_i;
+	unsigned int k;
+	size_t last_i;
 	char sum2[SUM_LENGTH];
 	uint32 s1, s2, sum;
 	schar *map;
 
 	/* last_i is used to encourage adjacent matches, allowing the RLL coding of the
 	   output to work more efficiently */
-	last_i = -1;
+	last_i = (size_t)-1;
 
-	if (verbose > 2)
-		rprintf(FINFO,"hash search b=%ld len=%.0f\n",
-			(long) s->blength, (double)len);
+	if (verbose > 2) {
+		rprintf(FINFO,"hash search b=%u len=%.0f\n",
+			s->blength, (double)len);
+	}
 
-	k = MIN(len, (OFF_T)s->blength);
+	k = MIN(len, s->blength);
 
-	map = (schar *)map_ptr(buf,0,k);
+	map = (schar *)map_ptr(buf, 0, k);
 
 	sum = get_checksum1((char *)map, k);
 	s1 = sum & 0xFFFF;
 	s2 = sum >> 16;
 	if (verbose > 3)
-		rprintf(FINFO, "sum=%.8x k=%d\n", sum, k);
+		rprintf(FINFO, "sum=%.8x k=%u\n", sum, k);
 
 	offset = 0;
 
 	end = len + 1 - s->sums[s->count-1].len;
 
-	if (verbose > 3)
-		rprintf(FINFO, "hash search s->blength=%ld len=%.0f count=%ld\n",
-			(long) s->blength, (double) len, (long) s->count);
+	if (verbose > 3) {
+		rprintf(FINFO, "hash search s->blength=%u len=%.0f count=%.0f\n",
+			s->blength, (double)len, (double)s->count);
+	}
 
 	do {
 		tag t = gettag2(s1,s2);
 		int done_csum2 = 0;
+		size_t j = tag_table[t];
 
-		j = tag_table[t];
 		if (verbose > 4)
 			rprintf(FINFO,"offset=%.0f sum=%08x\n",(double)offset,sum);
 
-		if (j == NULL_TAG) {
+		if (j == NULL_TAG)
 			goto null_tag;
-		}
 
 		sum = (s1 & 0xffff) | (s2 << 16);
 		tag_hits++;
-		for (; j < (int) s->count && targets[j].t == t; j++) {
-			int l, i = targets[j].i;
+		for (; j < s->count && targets[j].t == t; j++) {
+			unsigned int l;
+			size_t i = targets[j].i;
 
-			if (sum != s->sums[i].sum1) continue;
+			if (sum != s->sums[i].sum1)
+				continue;
 
 			/* also make sure the two blocks are the same length */
 			l = MIN((OFF_T)s->blength, len-offset);
-			if (l != s->sums[i].len) continue;
+			if (l != s->sums[i].len)
+				continue;
 
 			if (verbose > 3)
-				rprintf(FINFO,"potential match at %.0f target=%d %d sum=%08x\n",
-					(double)offset,j,i,sum);
+				rprintf(FINFO,"potential match at %.0f target=%.0f %.0f sum=%08x\n",
+					(double)offset,(double)j,(double)i,sum);
 
 			if (!done_csum2) {
 				map = (schar *)map_ptr(buf,offset,l);
 				get_checksum2((char *)map,l,sum2);
 				done_csum2 = 1;
 			}
@@ -207,50 +213,51 @@
 				false_alarms++;
 				continue;
 			}
 
 			/* we've found a match, but now check to see
 			 * if last_i can hint at a better match */
-			for (j++; j < (int) s->count && targets[j].t == t; j++) {
-				int i2 = targets[j].i;
+			for (j++; j < s->count && targets[j].t == t; j++) {
+				size_t i2 = targets[j].i;
 				if (i2 == last_i + 1) {
-					if (sum != s->sums[i2].sum1) break;
-					if (memcmp(sum2,s->sums[i2].sum2,s->s2length) != 0) break;
+					if (sum != s->sums[i2].sum1)
+						break;
+					if (memcmp(sum2,s->sums[i2].sum2,s->s2length) != 0)
+						break;
 					/* we've found an adjacent match - the RLL coder
 					 * will be happy */
 					i = i2;
 					break;
 				}
 			}
 
 			last_i = i;
 
 			matched(f,s,buf,offset,i);
 			offset += s->sums[i].len - 1;
-			k = MIN((OFF_T)s->blength, len-offset);
-			map = (schar *)map_ptr(buf,offset,k);
+			k = MIN(s->blength, len-offset);
+			map = (schar *)map_ptr(buf, offset, k);
 			sum = get_checksum1((char *)map, k);
 			s1 = sum & 0xFFFF;
 			s2 = sum >> 16;
 			matches++;
 			break;
 		}
 
 	null_tag:
 		/* Trim off the first byte from the checksum */
-		map = (schar *)map_ptr(buf,offset,k+1);
+		map = (schar *)map_ptr(buf, offset, k+1);
 		s1 -= map[0] + CHAR_OFFSET;
 		s2 -= k * (map[0]+CHAR_OFFSET);
 
 		/* Add on the next byte (if there is one) to the checksum */
 		if (k < (len-offset)) {
 			s1 += (map[k]+CHAR_OFFSET);
 			s2 += s1;
-		} else {
+		} else
 			--k;
-		}
 
 		/* By matching early we avoid re-reading the
 		   data 3 times in the case where a token
 		   match comes a long way after last
 		   match. The 3 reads are caused by the
 		   running match, the checksum update and the
@@ -281,13 +288,13 @@
  *
  * @param len Length of the file to send.
  **/
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len)
 {
 	char file_sum[MD4_SUM_LENGTH];
-	extern int write_batch;  /*  dw */
+	extern int write_batch;
 
 	last_match = 0;
 	false_alarms = 0;
 	tag_hits = 0;
 	matches = 0;
 	data_transfer = 0;
@@ -316,13 +323,13 @@
 
 	sum_end(file_sum);
 
 	if (verbose > 2)
 		rprintf(FINFO,"sending file_sum\n");
 	write_buf(f,file_sum,MD4_SUM_LENGTH);
-	if (write_batch) /* dw */
+	if (write_batch)
 		write_batch_delta_file(file_sum, MD4_SUM_LENGTH);
 
 	if (targets) {
 		free(targets);
 		targets=NULL;
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/mkproto.awk /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/mkproto.awk
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/mkproto.awk	1998-11-15 07:31:58.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/mkproto.awk	2004-01-02 05:10:50.000000000 +0800
@@ -55,13 +55,13 @@
 }
 
 /^static|^extern/ || !/^[a-zA-Z]/ || /[;]/ {
   next;
 }
 
-!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^struct|^BOOL|^void|^time/ {
+!/^OFF_T|^size_t|^off_t|^pid_t|^unsigned|^mode_t|^DIR|^user|^int|^char|^uint|^struct|^BOOL|^void|^time|^const/ {
   next;
 }
 
 
 /[(].*[)][ \t]*$/ {
     printf "%s;\n",$0;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/NEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/NEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/NEWS	2003-12-27 08:14:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/NEWS	2004-04-27 11:53:28.000000000 +0800
@@ -1,134 +1,190 @@
-NEWS for rsync 2.6.0 (1 Jan 2004)
-Protocol: 27 (changed)
-Changes since 2.5.7:
+NEWS for rsync 2.6.1 (26 Apr 2004)
+Protocol: 28 (changed)
+Changes since 2.6.0:
+
+  SECURITY FIXES:
+
+    - Paths sent to an rsync daemon are more thoroughly sanitized when
+      chroot is not used.  If you're running a non-read-only rsync
+      daemon with chroot disabled, *please upgrade*, ESPECIALLY if the
+      user privs you run rsync under is anything above "nobody".
 
   ENHANCEMENTS:
 
-    * "ssh" is now the default remote shell for rsync.  If you want to
-      change this, configure like this:  "./configure --with-rsh=rsh".
+    - Lower memory use, more optimal transfer of data over the socket,
+      and lower CPU usage (see the INTERNAL section for details).
 
-    * Added --files-from, --no-relative, --no-implied-dirs, and --from0.
-      Note that --from0 affects the line-ending character for all the
-      files read by the --*-from options. (Wayne Davison)
-
-    * Length of csum2 is now per-file starting with protocol version
-      27. (J.W. Schultz)
-
-    * Per-file dynamic block size is now sqrt(file length).  The
-      per-file checksum size is determined according to an algorithm
-      provided by Donovan Baarda which reduces the probability of rsync
-      algorithm corrupting data and falling back using the whole md4
-      checksums. (J.W. Schultz, Donovan Baarda)
-
-    * The --stats option no longer includes the (debug) malloc summary
-      unless the verbose option was specified at least twice.
-
-    * Added a new error/warning code for when files vanish from the
-      sending side.  Made vanished source files not interfere with the
-      file-deletion pass when --delete-after was specified.
+    - The RSYNC_PROXY environment variable can now contain a
+      "USER:PASS@" prefix before the "HOST:PORT" information.
+      (Bardur Arantsson)
+
+    - The --progress output now mentions how far along in the transfer
+      we are, including both a count of files transferred and a
+      percentage of the total file-count that we've processed.  It also
+      shows better current-rate-of-transfer and remaining-transfer-time
+      values.
 
-    * Various trailing-info sections are now preceded by a newline.
+    - The configure script now accepts --with-rsyncd-conf=PATH to
+      override the default value of the /etc/rsyncd.conf file.
 
-  BUG FIXES:
-
-    * Fixed several exclude/include matching bugs when using wild-cards.
-      This has a several user-visible effects, all of which make the
-      matching more consistent and intuitive.  This should hopefully not
-      cause anyone problems since it makes the matching work more like
-      what people are expecting. (Wayne Davison)
-
-      - A pattern with a "**" no longer causes a "*" to match slashes.
-        For example, with "/*/foo/**", "foo" must be 2 levels deep.
-
-      - "**/foo" now matches at the base of the transfer (i.e. /foo).
-
-      - An non-anchored wildcard term floats to match beyond the base of
-        the transfer.  E.g. "CVS/R*" matches at the end of the path,
-        just like the non-wildcard term "CVS/Root" does.
-
-      - Including a "**" in the match term causes it to be matched
-        against the entire path, not just the name portion, even if
-        there aren't any interior slashes in the term.  E.g. "foo**bar"
-        would exclude "/path/foo-bar" (just like before) as well as
-        "/foo-path/baz-bar" (unlike before).
-
-    * The exclude list specified in the daemon's config file is now
-      properly applied to the pulled items no matter how deep the
-      user's file-args are in the source tree.  (Wayne Davison)
-
-    * For protocol version >= 27, mdfour_tail() is called when the
-      block size (including checksum_seed) is a multiple of 64.
-      Previously it was not called, giving the wrong MD4 checksum.
-      (Craig Barratt)
-
-    * For protocol version >= 27, a 64 bit bit counter is used in
-      mdfour.c as required by the RFC.  Previously only a 32 bit bit
-      counter was used, causing incorrect MD4 file checksums for
-      file sizes >= 512MB - 4.  (Craig Barratt)
-
-    * Fixed a crash bug when interacting with older rsync versions and
-      multiple files of the same name are destined for the same dir.
-      (Wayne Davison)
-
-    * Keep tmp names from overflowing MAXPATHLEN.
+    - Added a couple extra diffs in the "patches" dir, removed the ones
+      that got applied, and rebuilt the rest.
 
-    * Make --link-dest honor the absence of -p, -o, and -g.
+    - Documentation changes now attempt to describe some often mis-
+      understood features more clearly.
 
-    * Made rsync treat a trailing slash in the destination in a more
-      consistent manner.
-
-    * Fixed file I/O error detection.  (John Van Essen)
-
-    * Fixed bogus "malformed address {hostname}" message in rsyncd log
-      when checking IP address against hostnames from "hosts allow"
-      and "hosts deny" parameters in config file.
-
-    * Print heap statistics when verbose >= 2 instead of when >= 1.
-
-    * Fixed a compression (-z) bug when syncing a mostly-matching file
-      that contains already-compressed data.  (Yasuoka Masahiko and
-      Wayne Davison)
-
-    * Fixed a bug in the --backup code that could cause deleted files
-      to not get backed up.
-
-    * When the backup code makes new directories, create them with mode
-      0700 instead of 0755 (since the directory permissions in the
-      backup tree are not yet copied from the main tree).
-
-    * Call setgroups() in a more portable manner.
-
-    * Improved file-related error messages to better indicate exactly
-      what pathname failed. (Wayne Davison)
-
-    * Fixed some bugs in the handling of --delete and --exclude when
-      using the --relative (-R) option. (Wayne Davison)
-
-    * Fixed bug that prevented regular files from replacing
-      special files and caused a directory in --link-dest or
-      --compare-dest to block the creation of a file with the
-      same path.  A directory still cannot be replaced by a
-      regular file unless --delete specified.  (J.W. Schultz)
+  BUG FIXES:
 
-    * Detect and report when open or opendir succeed but read and
-      readdir fail caused by network filesystems issues and truncated
-      files.  (David Norwood, Michael Brown, J.W. Schultz)
+    - When -x (--one-file-system) is combined with -L (--copy-links) or
+      --copy-unsafe-links, no symlinked files are skipped, even if the
+      referent file is on a different filesystem.
+
+    - The --link-dest code now works properly for a non-root user when
+      (1) the UIDs of the source and destination differ and -o was
+      specified, or (2) when the group of the source can't be used on
+      the destination and -g was specified.
+
+    - Fixed a bug in the handling of -H (hard-links) that might cause
+      the expanded PATH/NAME value of the current item to get
+      overwritten (due to an expanded-name caching bug).
+      
+    - We now reset the "new data has been sent" flag at the start of
+      each file we send.  This makes sure that an interrupted transfer
+      with the --partial option set doesn't keep a shorter temp file
+      than the current basis file when no new data has been transfered
+      over the wire for that file.
+
+    - Fixed a byte-order problem in --batch-mode on big-endian machines.
+      (Jay Fenlason)
+
+    - Fixed configure bug when running "./configure --disable-ipv6".
+
+    - Fixed "make test" bug when build dir is not the source dir.
+
+    - When using --cvs-exclude, the exclude items we get from a
+      per-directory's .cvsignore file once again only affect that one
+      directory (not all following directories too).  The items are also
+      now properly word-split and parsed without any +/- prefix parsing.
+
+    - When specifying the USER@HOST: prefix for a file, the USER part
+      can now contain an '@', if needed (i.e. the last '@' is used to
+      find the HOST, not the first).
+
+    - Fixed some bugs in the handling of group IDs for non-root users:
+      (1) It properly handles a group that the sender didn't have a name
+      for (it would previously skip changing the group on any files in
+      that group).  (2) If --numeric-ids is used, rsync no longer
+      attempts to set groups that the user doesn't have the permission
+      to set.
+
+    - Fixed the "refuse options" setting in the rsyncd.conf file.
+
+    - Improved the -x (--one-file-system) flag's handling of any mount-
+      point directories we encounter.  It is both more optimal (in that
+      it no longer does a useless scan of the contents of the mount-
+      point dirs) and also fixes a bug where a remapped mount of the
+      original filesystem could get discovered in a subdir we should be
+      ignoring.
+
+    - Rsync no longer discards a double-slash at the start of a filename
+      when trying to open the file.  It also no longer constructs names
+      that start with a double slash (unless the user supplied them).
+
+    - Path-specifying options to a daemon should now work the same with
+      or without chroot turned on.  Previously, such a option (such as
+      --link-dest) would get its absolute path munged into a relative
+      one if chroot was not on, making that setting fairly useless.
+      Rsync now transforms the path into one that is based on the
+      module's base dir when chroot is not enabled.
+
+    - Fixed compilation problem on Tru64 Unix (having to do with
+      sockaddr.sa_len and sockaddr.sin_len).
+
+    - Fixed a compatibility problem interacting with older rsync
+      versions that might send us an empty --suffix value without
+      telling us that --backup-dir was specified.
+
+    - The "hosts allow" option for a daemon-over-remote-shell process
+      now has improved support for IPv6 addresses and a fix for systems
+      that have a length field in their socket structs.
 
-    * Added a fix that should give ssh time to restore the tty settings
-      if the user presses Ctrl-C at an ssh password prompt.
+    - Fixed the ability to request an empty backup --suffix when sending
+      files to an rsync daemon.
 
   INTERNAL:
 
-    * Eliminated vestigial support for old versions that we stopped
-      supporting. (J.W. Schultz)
+    - Most of the I/O is now buffered, which results in a pretty large
+      speedup when running under MS Windows.  (Craig Barratt)
 
-    * Simplified some of the option-parsing code. (Wayne Davison)
+    - Optimizations to the name-handling/comparing code have made some
+      significant reductions in user-CPU time for large file sets.
 
-    * Some cleanup made to the exclude code, as well as some new
-      defines added to enhance readability. (Wayne Davison)
+    - Some cleanup of the variable types make the code more consistent.
 
-    * Changed the protocol-version code so that it can interact at a
-      lower protocol level than the maximum supported by both sides.
-      Added an undocumented option, --protocol=N, to force the value
-      we advertise to the other side (primarily for testing purposes).
-      (Wayne Davison)
+    - Reduced memory requirements of hard link preservation.
+      (J.W. Schultz)
+
+    - Implemented a new algorithm for hard-link handling that speeds up
+      the code significantly.  (J.W. Schultz and Wayne Davison)
+
+    - The --hard-link option now uses the first existing file in the
+      group of linked files as the basis for the transfer.  This
+      prevents the sub-optimal transfer of a file's data when a new
+      hardlink is added on the sending side and it sorts alphabetically
+      earlier in the list than the files that are already present on the
+      receiving side.
+
+    - Dropped support for protocol versions less than 20 (2.3.0 released
+      15 Mar 1999) and activated warnings for protocols less than 25
+      (2.5.0 released 23 Aug 2001). (Wayne Davison and J.W. Schultz,
+      severally)
+
+    - More optimal data transmission for --hard-links (protocol 28).
+
+    - More optimal data transmission for --checksum (protocol 28).
+
+    - Less memory is used when --checksum is specified.
+
+    - Less memory is used in the file list (a per-file savings).
+
+    - The generator is now better about not modifying the file list
+      during the transfer in order to avoid a copy-on-write memory
+      bifurcation (on systems where fork() uses shared memory).
+      Previously, rsync's shared memory would slowly become unshared,
+      resulting in real memory usage nearly doubling on the receiving
+      side by the end of the transfer.  Now, as long as permissions
+      are being preserved, the shared memory should remain that way
+      for the entire transfer.
+
+    - Changed hardlink info and file_struct + strings to use allocation
+      pools.  This reduces memory use for large file-sets and permits
+      freeing memory to the OS.  (J.W. Schultz) 
+
+    - The 2 pipes used between the receiver and generator processes
+      (which are forked on the same machine) were reduced to 1 pipe and
+      the protocol improved so that (1) it is now impossible to have the
+      "redo" pipe fill up and hang rsync, and (2) trailing messages from
+      the receiver don't get lost on their way through the generator
+      over to the sender (which mainly affected hard-link messages and
+      verbose --stats output).
+
+    - Improved the internal uid/gid code to be more portable and a
+      little more optimized.
+
+    - The device numbers sent when using --devices are now sent as
+      separate major/minor values with 32-bit accuracy (protocol 28).
+      Previously, the copied devices were sent as a single 32-bit
+      number.  This will make inter-operation of 64-bit binaries more
+      compatible with their 32-bit brethren (with both ends of the
+      connection are using protocol 28).  Note that optimizations in the
+      binary protocol for sending the device numbers often results in
+      fewer bytes being used than before, even though more precision is
+      now available.
+
+    - Some cleanup of the exclude/include structures and its code made
+      things clearer (internally), simpler, and more efficient.
+
+    - The reading & writing of the file-list in batch-mode is now
+      handled by the same code that sends & receives the list over the
+      wire.  This makes it much easier to maintain.  (Note that the
+      batch code is still considered to be experimental.)
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/OLDNEWS /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/OLDNEWS
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/OLDNEWS	2003-12-27 08:14:21.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/OLDNEWS	2004-03-05 03:35:57.000000000 +0800
@@ -1,6 +1,148 @@
+NEWS for rsync 2.6.0 (1 Jan 2004)
+Protocol: 27 (changed)
+Changes since 2.5.7:
+
+  ENHANCEMENTS:
+
+    * "ssh" is now the default remote shell for rsync.  If you want to
+      change this, configure like this:  "./configure --with-rsh=rsh".
+
+    * Added --files-from, --no-relative, --no-implied-dirs, and --from0.
+      Note that --from0 affects the line-ending character for all the
+      files read by the --*-from options. (Wayne Davison)
+
+    * Length of csum2 is now per-file starting with protocol version
+      27. (J.W. Schultz)
+
+    * Per-file dynamic block size is now sqrt(file length).  The
+      per-file checksum size is determined according to an algorithm
+      provided by Donovan Baarda which reduces the probability of rsync
+      algorithm corrupting data and falling back using the whole md4
+      checksums. (J.W. Schultz, Donovan Baarda)
+
+    * The --stats option no longer includes the (debug) malloc summary
+      unless the verbose option was specified at least twice.
+
+    * Added a new error/warning code for when files vanish from the
+      sending side.  Made vanished source files not interfere with the
+      file-deletion pass when --delete-after was specified.
+
+    * Various trailing-info sections are now preceded by a newline.
+
+  BUG FIXES:
+
+    * Fixed several exclude/include matching bugs when using wild-cards.
+      This has a several user-visible effects, all of which make the
+      matching more consistent and intuitive.  This should hopefully not
+      cause anyone problems since it makes the matching work more like
+      what people are expecting. (Wayne Davison)
+
+      - A pattern with a "**" no longer causes a "*" to match slashes.
+        For example, with "/*/foo/**", "foo" must be 2 levels deep.
+	[If your string has BOTH "*" and "**" wildcards, changing the
+	"*" wildcards to "**" will provide the old behavior in all
+	versions.]
+
+      - "**/foo" now matches at the base of the transfer (like /foo
+        does).  [Use "/**/foo" to get the old behavior in all versions.]
+
+      - A non-anchored wildcard term floats to match beyond the base of
+        the transfer.  E.g. "CVS/R*" matches at the end of the path,
+        just like the non-wildcard term "CVS/Root" does. [Use "/CVS/R*"
+        to get the old behavior in all versions.]
+
+      - Including a "**" in the match term causes it to be matched
+        against the entire path, not just the name portion, even if
+        there aren't any interior slashes in the term.  E.g. "foo**bar"
+        would exclude "/path/foo-bar" (just like before) as well as
+        "/foo-path/baz-bar" (unlike before).  [Use "foo*bar" to get the
+        old behavior in all versions.]
+
+    * The exclude list specified in the daemon's config file is now
+      properly applied to the pulled items no matter how deep the
+      user's file-args are in the source tree.  (Wayne Davison)
+
+    * For protocol version >= 27, mdfour_tail() is called when the
+      block size (including checksum_seed) is a multiple of 64.
+      Previously it was not called, giving the wrong MD4 checksum.
+      (Craig Barratt)
+
+    * For protocol version >= 27, a 64 bit bit counter is used in
+      mdfour.c as required by the RFC.  Previously only a 32 bit bit
+      counter was used, causing incorrect MD4 file checksums for
+      file sizes >= 512MB - 4.  (Craig Barratt)
+
+    * Fixed a crash bug when interacting with older rsync versions and
+      multiple files of the same name are destined for the same dir.
+      (Wayne Davison)
+
+    * Keep tmp names from overflowing MAXPATHLEN.
+
+    * Make --link-dest honor the absence of -p, -o, and -g.
+
+    * Made rsync treat a trailing slash in the destination in a more
+      consistent manner.
+
+    * Fixed file I/O error detection.  (John Van Essen)
+
+    * Fixed bogus "malformed address {hostname}" message in rsyncd log
+      when checking IP address against hostnames from "hosts allow"
+      and "hosts deny" parameters in config file.
+
+    * Print heap statistics when verbose >= 2 instead of when >= 1.
+
+    * Fixed a compression (-z) bug when syncing a mostly-matching file
+      that contains already-compressed data.  (Yasuoka Masahiko and
+      Wayne Davison)
+
+    * Fixed a bug in the --backup code that could cause deleted files
+      to not get backed up.
+
+    * When the backup code makes new directories, create them with mode
+      0700 instead of 0755 (since the directory permissions in the
+      backup tree are not yet copied from the main tree).
+
+    * Call setgroups() in a more portable manner.
+
+    * Improved file-related error messages to better indicate exactly
+      what pathname failed. (Wayne Davison)
+
+    * Fixed some bugs in the handling of --delete and --exclude when
+      using the --relative (-R) option. (Wayne Davison)
+
+    * Fixed bug that prevented regular files from replacing
+      special files and caused a directory in --link-dest or
+      --compare-dest to block the creation of a file with the
+      same path.  A directory still cannot be replaced by a
+      regular file unless --delete specified.  (J.W. Schultz)
+
+    * Detect and report when open or opendir succeed but read and
+      readdir fail caused by network filesystem issues and truncated
+      files.  (David Norwood, Michael Brown, J.W. Schultz)
+
+    * Added a fix that should give ssh time to restore the tty settings
+      if the user presses Ctrl-C at an ssh password prompt.
+
+  INTERNAL:
+
+    * Eliminated vestigial support for old versions that we stopped
+      supporting. (J.W. Schultz)
+
+    * Simplified some of the option-parsing code. (Wayne Davison)
+
+    * Some cleanup made to the exclude code, as well as some new
+      defines added to enhance readability. (Wayne Davison)
+
+    * Changed the protocol-version code so that it can interact at a
+      lower protocol level than the maximum supported by both sides.
+      Added an undocumented option, --protocol=N, to force the value
+      we advertise to the other side (primarily for testing purposes).
+      (Wayne Davison)
+
+
 NEWS for rsync 2.5.7 (4 Dec 2003)
 Protocol: 26 (unchanged)
 Changes since 2.5.6:
 
   SECURITY FIXES:
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/options.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/options.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/options.c	2003-12-31 02:16:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/options.c	2004-04-18 01:07:23.000000000 +0800
@@ -18,13 +18,15 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
 #include "popt.h"
 
-extern struct exclude_struct **exclude_list;
+extern int sanitize_paths;
+extern char curr_dir[MAXPATHLEN];
+extern struct exclude_list_struct exclude_list;
 
 int make_backups = 0;
 
 /**
  * If 1, send the whole file as literal data rather than trying to
  * create an incremental diff.
@@ -43,54 +45,56 @@
 int preserve_devices = 0;
 int preserve_uid = 0;
 int preserve_gid = 0;
 int preserve_times = 0;
 int update_only = 0;
 int cvs_exclude = 0;
-int dry_run=0;
-int local_server=0;
-int ignore_times=0;
-int delete_mode=0;
-int delete_excluded=0;
-int one_file_system=0;
+int dry_run = 0;
+int local_server = 0;
+int ignore_times = 0;
+int delete_mode = 0;
+int delete_excluded = 0;
+int one_file_system = 0;
 int protocol_version = PROTOCOL_VERSION;
-int sparse_files=0;
-int do_compression=0;
-int am_root=0;
-int orig_umask=0;
+int sparse_files = 0;
+int do_compression = 0;
+int am_root = 0;
+int orig_umask = 0;
 int relative_paths = -1;
 int implied_dirs = 1;
 int numeric_ids = 0;
 int force_delete = 0;
 int io_timeout = 0;
 int read_only = 0;
 int module_id = -1;
 int am_server = 0;
 int am_sender = 0;
+int am_generator = 0;
 char *files_from = NULL;
 int filesfrom_fd = -1;
 char *remote_filesfrom_file = NULL;
 int eol_nulls = 0;
 int recurse = 0;
 int am_daemon = 0;
 int daemon_over_rsh = 0;
-int do_stats=0;
-int do_progress=0;
-int keep_partial=0;
-int safe_symlinks=0;
-int copy_unsafe_links=0;
-int block_size=0;
-int size_only=0;
-int bwlimit=0;
-int delete_after=0;
-int only_existing=0;
-int opt_ignore_existing=0;
-int max_delete=0;
-int ignore_errors=0;
-int modify_window=0;
-int blocking_io=-1;
+int do_stats = 0;
+int do_progress = 0;
+int keep_partial = 0;
+int safe_symlinks = 0;
+int copy_unsafe_links = 0;
+int size_only = 0;
+int bwlimit = 0;
+int delete_after = 0;
+int only_existing = 0;
+int opt_ignore_existing = 0;
+int max_delete = 0;
+int ignore_errors = 0;
+int modify_window = 0;
+int blocking_io = -1;
+int checksum_seed = 0;
+unsigned int block_size = 0;
 
 
 /** Network address family. **/
 #ifdef INET6
 int default_af_hint = 0;	/* Any protocol */
 #else
@@ -103,32 +107,37 @@
 int no_detach = 0;
 
 int write_batch = 0;
 int read_batch = 0;
 int backup_dir_len = 0;
 int backup_suffix_len;
+unsigned int backup_dir_remainder;
 
 char *backup_suffix = NULL;
 char *tmpdir = NULL;
 char *compare_dest = NULL;
 char *config_file = NULL;
 char *shell_cmd = NULL;
 char *log_format = NULL;
 char *password_file = NULL;
 char *rsync_path = RSYNC_PATH;
 char *backup_dir = NULL;
+char backup_dir_buf[MAXPATHLEN];
 int rsync_port = RSYNC_PORT;
 int link_dest = 0;
 
 int verbose = 0;
 int quiet = 0;
 int always_checksum = 0;
 int list_only = 0;
 
+#define FIXED_CHECKSUM_SEED 32761
+#define MAX_BATCH_PREFIX_LEN 256	/* Must be less than MAXPATHLEN-13 */
 char *batch_prefix = NULL;
 
+static int daemon_opt;   /* sets am_daemon after option error-reporting */
 static int modify_window_set;
 
 /** Local address to bind.  As a character string because it's
  * interpreted by the IPv6 layer: should be a numeric IP4 or ip6
  * address, or a hostname. **/
 char *bind_address;
@@ -162,22 +171,22 @@
 		RSYNC_NAME, RSYNC_VERSION, PROTOCOL_VERSION);
 	rprintf(f,
 		"Copyright (C) 1996-2004 by Andrew Tridgell and others\n");
 	rprintf(f, "<http://rsync.samba.org/>\n");
 	rprintf(f, "Capabilities: %d-bit files, %ssocketpairs, "
 		"%shard links, %ssymlinks, batchfiles, \n",
-		(int) (sizeof(OFF_T) * 8),
+		(int) (sizeof (OFF_T) * 8),
 		got_socketpair, hardlinks, links);
 
 	/* Note that this field may not have type ino_t.  It depends
 	 * on the complicated interaction between largefile feature
 	 * macros. */
 	rprintf(f, "              %sIPv6, %d-bit system inums, %d-bit internal inums\n",
 		ipv6,
-		(int) (sizeof(dumstat->st_ino) * 8),
-		(int) (sizeof(INO64_T) * 8));
+		(int) (sizeof dumstat->st_ino * 8),
+		(int) (sizeof (uint64) * 8));
 #ifdef MAINTAINER_MODE
 	rprintf(f, "              panic action: \"%s\"\n",
 		get_panic_action());
 #endif
 
 #ifdef NO_INT64
@@ -220,15 +229,15 @@
   rprintf(F,"     --no-implied-dirs       don't send implied dirs with -R\n");
   rprintf(F," -b, --backup                make backups (see --suffix & --backup-dir)\n");
   rprintf(F,"     --backup-dir            make backups into this directory\n");
   rprintf(F,"     --suffix=SUFFIX         backup suffix (default %s w/o --backup-dir)\n",BACKUP_SUFFIX);
   rprintf(F," -u, --update                update only (don't overwrite newer files)\n");
   rprintf(F," -l, --links                 copy symlinks as symlinks\n");
-  rprintf(F," -L, --copy-links            copy the referent of symlinks\n");
-  rprintf(F,"     --copy-unsafe-links     copy links outside the source tree\n");
-  rprintf(F,"     --safe-links            ignore links outside the destination tree\n");
+  rprintf(F," -L, --copy-links            copy the referent of all symlinks\n");
+  rprintf(F,"     --copy-unsafe-links     copy the referent of \"unsafe\" symlinks\n");
+  rprintf(F,"     --safe-links            ignore \"unsafe\" symlinks\n");
   rprintf(F," -H, --hard-links            preserve hard links\n");
   rprintf(F," -p, --perms                 preserve permissions\n");
   rprintf(F," -o, --owner                 preserve owner (root only)\n");
   rprintf(F," -g, --group                 preserve group\n");
   rprintf(F," -D, --devices               preserve devices (root only)\n");
   rprintf(F," -t, --times                 preserve times\n");
@@ -241,19 +250,19 @@
   rprintf(F," -e, --rsh=COMMAND           specify the remote shell\n");
   rprintf(F,"     --rsync-path=PATH       specify path to rsync on the remote machine\n");
   rprintf(F,"     --existing              only update files that already exist\n");
   rprintf(F,"     --ignore-existing       ignore files that already exist on receiving side\n");
   rprintf(F,"     --delete                delete files that don't exist on the sending side\n");
   rprintf(F,"     --delete-excluded       also delete excluded files on the receiving side\n");
-  rprintf(F,"     --delete-after          delete after transferring, not before\n");
-  rprintf(F,"     --ignore-errors         delete even if there are IO errors\n");
+  rprintf(F,"     --delete-after          receiver deletes after transferring, not before\n");
+  rprintf(F,"     --ignore-errors         delete even if there are I/O errors\n");
   rprintf(F,"     --max-delete=NUM        don't delete more than NUM files\n");
   rprintf(F,"     --partial               keep partially transferred files\n");
   rprintf(F,"     --force                 force deletion of directories even if not empty\n");
   rprintf(F,"     --numeric-ids           don't map uid/gid values by user/group name\n");
-  rprintf(F,"     --timeout=TIME          set IO timeout in seconds\n");
+  rprintf(F,"     --timeout=TIME          set I/O timeout in seconds\n");
   rprintf(F," -I, --ignore-times          turn off mod time & file size quick check\n");
   rprintf(F,"     --size-only             ignore mod time for quick check (use size)\n");
   rprintf(F,"     --modify-window=NUM     compare mod times with reduced accuracy\n");
   rprintf(F," -T  --temp-dir=DIR          create temporary files in directory DIR\n");
   rprintf(F,"     --compare-dest=DIR      also compare destination files relative to DIR\n");
   rprintf(F,"     --link-dest=DIR         create hardlinks to DIR for unchanged files\n");
@@ -264,18 +273,18 @@
   rprintf(F,"     --exclude-from=FILE     exclude patterns listed in FILE\n");
   rprintf(F,"     --include=PATTERN       don't exclude files matching PATTERN\n");
   rprintf(F,"     --include-from=FILE     don't exclude patterns listed in FILE\n");
   rprintf(F,"     --files-from=FILE       read FILE for list of source-file names\n");
   rprintf(F," -0  --from0                 all *-from file lists are delimited by nulls\n");
   rprintf(F,"     --version               print version number\n");
-  rprintf(F,"     --daemon                run as a rsync daemon\n");
+  rprintf(F,"     --daemon                run as an rsync daemon\n");
   rprintf(F,"     --no-detach             do not detach from the parent\n");
   rprintf(F,"     --address=ADDRESS       bind to the specified address\n");
   rprintf(F,"     --config=FILE           specify alternate rsyncd.conf file\n");
   rprintf(F,"     --port=PORT             specify alternate rsyncd port number\n");
-  rprintf(F,"     --blocking-io           use blocking IO for the remote shell\n");
+  rprintf(F,"     --blocking-io           use blocking I/O for the remote shell\n");
   rprintf(F,"     --no-blocking-io        turn off --blocking-io\n");
   rprintf(F,"     --stats                 give some file transfer stats\n");
   rprintf(F,"     --progress              show progress during transfer\n");
   rprintf(F,"     --log-format=FORMAT     log file transfers using specified format\n");
   rprintf(F,"     --password-file=FILE    get password from FILE\n");
   rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth, KBytes per second\n");
@@ -293,13 +302,14 @@
   rprintf(F,"See http://rsync.samba.org/ for updates, bug reports, and answers\n");
 }
 
 enum {OPT_VERSION = 1000, OPT_SENDER, OPT_EXCLUDE, OPT_EXCLUDE_FROM,
       OPT_DELETE_AFTER, OPT_DELETE_EXCLUDED, OPT_LINK_DEST,
       OPT_INCLUDE, OPT_INCLUDE_FROM, OPT_MODIFY_WINDOW,
-      OPT_READ_BATCH, OPT_WRITE_BATCH};
+      OPT_READ_BATCH, OPT_WRITE_BATCH,
+      OPT_REFUSED_BASE = 9000};
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"version",          0,  POPT_ARG_NONE,   0,              OPT_VERSION, 0, 0},
   {"suffix",           0,  POPT_ARG_STRING, &backup_suffix, 0, 0, 0 },
   {"rsync-path",       0,  POPT_ARG_STRING, &rsync_path,	0, 0, 0 },
@@ -348,16 +358,16 @@
   {"rsh",             'e', POPT_ARG_STRING, &shell_cmd, 0, 0, 0 },
   {"block-size",      'B', POPT_ARG_INT,    &block_size, 0, 0, 0 },
   {"max-delete",       0,  POPT_ARG_INT,    &max_delete, 0, 0, 0 },
   {"timeout",          0,  POPT_ARG_INT,    &io_timeout, 0, 0, 0 },
   {"temp-dir",        'T', POPT_ARG_STRING, &tmpdir, 0, 0, 0 },
   {"compare-dest",     0,  POPT_ARG_STRING, &compare_dest, 0, 0, 0 },
-  {"link-dest",        0,  POPT_ARG_STRING, 0,              OPT_LINK_DEST, 0, 0 },
+  {"link-dest",        0,  POPT_ARG_STRING, &compare_dest,  OPT_LINK_DEST, 0, 0 },
   /* TODO: Should this take an optional int giving the compression level? */
   {"compress",        'z', POPT_ARG_NONE,   &do_compression, 0, 0, 0 },
-  {"daemon",           0,  POPT_ARG_NONE,   &am_daemon, 0, 0, 0 },
+  {"daemon",           0,  POPT_ARG_NONE,   &daemon_opt, 0, 0, 0 },
   {"no-detach",        0,  POPT_ARG_NONE,   &no_detach, 0, 0, 0 },
   {"stats",            0,  POPT_ARG_NONE,   &do_stats, 0, 0, 0 },
   {"progress",         0,  POPT_ARG_NONE,   &do_progress, 0, 0, 0 },
   {"partial",          0,  POPT_ARG_NONE,   &keep_partial, 0, 0, 0 },
   {"ignore-errors",    0,  POPT_ARG_NONE,   &ignore_errors, 0, 0, 0 },
   {"blocking-io",      0,  POPT_ARG_VAL,    &blocking_io, 1, 0, 0 },
@@ -404,39 +414,40 @@
 			 "option may be supported on client but not on server?\n");
 	}
 }
 
 
 /**
- * Check to see if we should refuse this option
+ * Tweak the option table to disable all options that the rsyncd.conf
+ * file has told us to refuse.
  **/
-static int check_refuse_options(char *ref, int opt)
+static void set_refuse_options(char *bp)
 {
-	int i, len;
-	char *p;
-	const char *name;
+	struct poptOption *op;
+	char *cp;
 
-	for (i=0; long_options[i].longName; i++) {
-		if (long_options[i].val == opt) break;
-	}
-
-	if (!long_options[i].longName) return 0;
-
-	name = long_options[i].longName;
-	len = strlen(name);
-
-	while ((p = strstr(ref,name))) {
-		if ((p==ref || p[-1]==' ') &&
-		    (p[len] == ' ' || p[len] == 0)) {
-			snprintf(err_buf,sizeof(err_buf),
-				 "The '%s' option is not supported by this server\n", name);
-			return 1;
+	while (1) {
+		if ((cp = strchr(bp, ' ')) != NULL)
+			*cp= '\0';
+		for (op = long_options; ; op++) {
+			if (!op->longName) {
+				rprintf(FLOG,
+				    "Unknown option %s in \"refuse options\" setting\n",
+				    bp);
+				break;
+			}
+			if (strcmp(bp, op->longName) == 0) {
+				op->val = (op - long_options)+OPT_REFUSED_BASE;
+				break;
+			}
 		}
-		ref += len;
+		if (!cp)
+			break;
+		*cp = ' ';
+		bp = cp + 1;
 	}
-	return 0;
 }
 
 
 static int count_args(char const **argv)
 {
 	int i = 0;
@@ -457,25 +468,25 @@
  * @retval 0 on error, with err_buf containing an explanation
  **/
 int parse_arguments(int *argc, const char ***argv, int frommain)
 {
 	int opt;
 	char *ref = lp_refuse_options(module_id);
+	const char *arg;
 	poptContext pc;
 
+	if (ref && *ref)
+		set_refuse_options(ref);
+
 	/* TODO: Call poptReadDefaultConfig; handle errors. */
 
 	/* The context leaks in case of an error, but if there's a
 	 * problem we always exit anyhow. */
 	pc = poptGetContext(RSYNC_NAME, *argc, *argv, long_options, 0);
 
 	while ((opt = poptGetNextOpt(pc)) != -1) {
-		if (ref) {
-			if (check_refuse_options(ref, opt)) return 0;
-		}
-
 		/* most options are handled automatically by popt;
 		 * only special cases are returned and listed here. */
 
 		switch (opt) {
 		case OPT_VERSION:
 			print_rsync_version(FINFO);
@@ -496,59 +507,47 @@
 		case OPT_DELETE_EXCLUDED:
 			delete_excluded = 1;
 			delete_mode = 1;
 			break;
 
 		case OPT_EXCLUDE:
-			add_exclude(&exclude_list, poptGetOptArg(pc),
-				    ADD_EXCLUDE);
+			add_exclude(&exclude_list, poptGetOptArg(pc), 0);
 			break;
 
 		case OPT_INCLUDE:
 			add_exclude(&exclude_list, poptGetOptArg(pc),
-				    ADD_INCLUDE);
+				    XFLG_DEF_INCLUDE);
 			break;
 
 		case OPT_EXCLUDE_FROM:
-			add_exclude_file(&exclude_list, poptGetOptArg(pc),
-					 MISSING_FATAL, ADD_EXCLUDE);
+			arg = poptGetOptArg(pc);
+			if (sanitize_paths)
+				arg = alloc_sanitize_path(arg, curr_dir);
+			add_exclude_file(&exclude_list, arg,
+					 XFLG_FATAL_ERRORS);
 			break;
 
 		case OPT_INCLUDE_FROM:
-			add_exclude_file(&exclude_list, poptGetOptArg(pc),
-					 MISSING_FATAL, ADD_INCLUDE);
+			arg = poptGetOptArg(pc);
+			if (sanitize_paths)
+				arg = alloc_sanitize_path(arg, curr_dir);
+			add_exclude_file(&exclude_list, arg,
+					 XFLG_FATAL_ERRORS | XFLG_DEF_INCLUDE);
 			break;
 
 		case 'h':
 			usage(FINFO);
 			exit_cleanup(0);
 
-		case 'H':
-#if SUPPORT_HARD_LINKS
-			preserve_hard_links=1;
-#else
-			/* FIXME: Don't say "server" if this is
-			 * happening on the client. */
-			/* FIXME: Why do we have the duplicated
-			 * rprintf?  Everybody who gets this message
-			 * ought to send it to the client and also to
-			 * the logs. */
-			snprintf(err_buf, sizeof err_buf,
-				 "hard links are not supported on this %s\n",
-				 am_server ? "server" : "client");
-			rprintf(FERROR, "ERROR: %s", err_buf);
-			return 0;
-#endif /* SUPPORT_HARD_LINKS */
-			break;
-
 		case 'v':
 			verbose++;
 			break;
 
 		case 'q':
-			if (frommain) quiet++;
+			if (frommain)
+				quiet++;
 			break;
 
 		case OPT_SENDER:
 			if (!am_server) {
 				usage(FERROR);
 				exit_cleanup(RERR_SYNTAX);
@@ -561,22 +560,23 @@
 			keep_partial = 1;
 			break;
 
 		case OPT_WRITE_BATCH:
 			/* popt stores the filename in batch_prefix for us */
 			write_batch = 1;
+			checksum_seed = FIXED_CHECKSUM_SEED;
 			break;
 
 		case OPT_READ_BATCH:
 			/* popt stores the filename in batch_prefix for us */
 			read_batch = 1;
+			checksum_seed = FIXED_CHECKSUM_SEED;
 			break;
 
 		case OPT_LINK_DEST:
 #if HAVE_LINK
-			compare_dest = (char *)poptGetOptArg(pc);
 			link_dest = 1;
 			break;
 #else
 			snprintf(err_buf, sizeof err_buf,
 				 "hard links are not supported on this %s\n",
 				 am_server ? "server" : "client");
@@ -581,30 +581,72 @@
 				 "hard links are not supported on this %s\n",
 				 am_server ? "server" : "client");
 			rprintf(FERROR, "ERROR: %s", err_buf);
 			return 0;
 #endif
 
-
 		default:
-			/* FIXME: If --daemon is specified, then errors for later
-			 * parameters seem to disappear. */
-			snprintf(err_buf, sizeof(err_buf),
-				 "%s%s: %s\n",
-				 am_server ? "on remote machine: " : "",
-				 poptBadOption(pc, POPT_BADOPTION_NOALIAS),
-				 poptStrerror(opt));
+			/* A large opt value means that set_refuse_options()
+			 * turned this option off (opt-BASE is its index). */
+			if (opt >= OPT_REFUSED_BASE) {
+				struct poptOption *op =
+				    &long_options[opt-OPT_REFUSED_BASE];
+				int n = snprintf(err_buf, sizeof err_buf,
+				    "This server does not support --%s\n",
+				    op->longName) - 1;
+				if (op->shortName) {
+					snprintf(err_buf+n, sizeof err_buf-n,
+					    " (-%c)\n", op->shortName);
+				}
+			} else {
+				snprintf(err_buf, sizeof err_buf,
+				    "%s%s: %s\n",
+				    am_server ? "on remote machine: " : "",
+				    poptBadOption(pc, POPT_BADOPTION_NOALIAS),
+				    poptStrerror(opt));
+			}
 			return 0;
 		}
 	}
 
+#if !SUPPORT_LINKS
+	if (preserve_links && !am_sender) {
+		snprintf(err_buf, sizeof err_buf,
+			 "symlinks are not supported on this %s\n",
+			 am_server ? "server" : "client");
+		rprintf(FERROR, "ERROR: %s", err_buf);
+		return 0;
+	}
+#endif
+
+#if !SUPPORT_HARD_LINKS
+	if (preserve_hard_links) {
+		snprintf(err_buf, sizeof err_buf,
+			 "hard links are not supported on this %s\n",
+			 am_server ? "server" : "client");
+		rprintf(FERROR, "ERROR: %s", err_buf);
+		return 0;
+	}
+#endif
+
 	if (write_batch && read_batch) {
 		rprintf(FERROR,
 			"write-batch and read-batch can not be used together\n");
 		exit_cleanup(RERR_SYNTAX);
 	}
+	if (batch_prefix && strlen(batch_prefix) > MAX_BATCH_PREFIX_LEN) {
+		rprintf(FERROR,
+			"the batch-file prefix must be %d characters or less.\n",
+			MAX_BATCH_PREFIX_LEN);
+		exit_cleanup(RERR_SYNTAX);
+	}
+
+	if (tmpdir && strlen(tmpdir) >= MAXPATHLEN - 10) {
+		rprintf(FERROR, "the --temp-dir path is WAY too long.\n");
+		exit_cleanup(RERR_SYNTAX);
+	}
 
 	if (do_compression && (write_batch || read_batch)) {
 		rprintf(FERROR,
 			"compress can not be used with write-batch or read-batch\n");
 		exit_cleanup(RERR_SYNTAX);
 	}
@@ -622,40 +664,71 @@
 		preserve_devices = 1;
 	}
 
 	if (relative_paths < 0)
 		relative_paths = files_from? 1 : 0;
 
+	*argv = poptGetArgs(pc);
+	if (*argv)
+		*argc = count_args(*argv);
+	else
+		*argc = 0;
+
+	if (sanitize_paths) {
+		int i;
+		for (i = *argc; i-- > 0; )
+			(*argv)[i] = alloc_sanitize_path((*argv)[i], NULL);
+		if (tmpdir)
+			tmpdir = alloc_sanitize_path(tmpdir, curr_dir);
+		if (compare_dest)
+			compare_dest = alloc_sanitize_path(compare_dest, curr_dir);
+		if (backup_dir)
+			backup_dir = alloc_sanitize_path(backup_dir, curr_dir);
+		if (files_from)
+			files_from = alloc_sanitize_path(files_from, curr_dir);
+	}
+
+	if (daemon_opt) {
+		daemon_opt = 0;
+		am_daemon = 1;
+		return 1;
+	}
+
 	if (!backup_suffix)
-		backup_suffix = backup_dir? "" : BACKUP_SUFFIX;
+		backup_suffix = backup_dir ? "" : BACKUP_SUFFIX;
 	backup_suffix_len = strlen(backup_suffix);
 	if (strchr(backup_suffix, '/') != NULL) {
 		rprintf(FERROR, "--suffix cannot contain slashes: %s\n",
 			backup_suffix);
 		exit_cleanup(RERR_SYNTAX);
 	}
-	if (backup_dir)
-		backup_dir_len = strlen(backup_dir);
-	else if (!backup_suffix_len) {
+	if (backup_dir) {
+		backup_dir_len = strlcpy(backup_dir_buf, backup_dir, sizeof backup_dir_buf);
+		backup_dir_remainder = sizeof backup_dir_buf - backup_dir_len;
+		if (backup_dir_remainder < 32) {
+			rprintf(FERROR, "the --backup-dir path is WAY too long.\n");
+			exit_cleanup(RERR_SYNTAX);
+		}
+		if (backup_dir_buf[backup_dir_len - 1] != '/') {
+			backup_dir_buf[backup_dir_len++] = '/';
+			backup_dir_buf[backup_dir_len] = '\0';
+		}
+		if (verbose > 1 && !am_sender)
+			rprintf(FINFO, "backup_dir is %s\n", backup_dir_buf);
+	} else if (!backup_suffix_len && (!am_server || !am_sender)) {
 		rprintf(FERROR,
 			"--suffix cannot be a null string without --backup-dir\n");
 		exit_cleanup(RERR_SYNTAX);
 	}
 
 	if (do_progress && !verbose)
 		verbose = 1;
 
-	*argv = poptGetArgs(pc);
-	if (*argv)
-		*argc = count_args(*argv);
-	else
-		*argc = 0;
-
 	if (files_from) {
 		char *colon;
-		if (*argc != 2) {
+		if (*argc != 2 && !(am_server && am_sender && *argc == 1)) {
 			usage(FERROR);
 			exit_cleanup(RERR_SYNTAX);
 		}
 		if (strcmp(files_from, "-") == 0) {
 			filesfrom_fd = 0;
 			if (am_server)
@@ -669,15 +742,12 @@
 			remote_filesfrom_file = colon+1 + (colon[1] == ':');
 			if (strcmp(remote_filesfrom_file, "-") == 0) {
 				rprintf(FERROR, "Invalid --files-from remote filename\n");
 				exit_cleanup(RERR_SYNTAX);
 			}
 		} else {
-			extern int sanitize_paths;
-			if (sanitize_paths)
-				sanitize_path(strdup(files_from), NULL);
 			filesfrom_fd = open(files_from, O_RDONLY|O_BINARY);
 			if (filesfrom_fd < 0) {
 				rsyserr(FERROR, errno,
 					"failed to open files-from file %s",
 					files_from);
 				exit_cleanup(RERR_FILEIO);
@@ -698,19 +768,13 @@
  * locally.
  **/
 void server_options(char **args,int *argc)
 {
 	int ac = *argc;
 	static char argstr[50];
-	static char bsize[30];
-	static char iotime[30];
-	static char mdelete[30];
-	static char mwindow[30];
-	static char bw[50];
-	/* Leave room for ``--(write|read)-batch='' */
-	static char fext[MAXPATHLEN + 15];
+	char *arg;
 
 	int i, x;
 
 	if (blocking_io == -1)
 		blocking_io = 0;
 
@@ -725,13 +789,13 @@
 
 	if (!am_sender)
 		args[ac++] = "--sender";
 
 	x = 1;
 	argstr[0] = '-';
-	for (i=0;i<verbose;i++)
+	for (i = 0; i < verbose; i++)
 		argstr[x++] = 'v';
 
 	/* the -q option is intentionally left out */
 	if (make_backups)
 		argstr[x++] = 'b';
 	if (update_only)
@@ -784,73 +848,71 @@
 	   more useful */
 	if (list_only && !recurse)
 		argstr[x++] = 'r';
 
 	argstr[x] = 0;
 
-	if (x != 1) args[ac++] = argstr;
+	if (x != 1)
+		args[ac++] = argstr;
 
 	if (block_size) {
-		snprintf(bsize,sizeof(bsize),"-B%d",block_size);
-		args[ac++] = bsize;
+		if (asprintf(&arg, "-B%u", block_size) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
 	if (max_delete && am_sender) {
-		snprintf(mdelete,sizeof(mdelete),"--max-delete=%d",max_delete);
-		args[ac++] = mdelete;
+		if (asprintf(&arg, "--max-delete=%d", max_delete) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
-	if (batch_prefix != NULL) {
-		char *fmt = "";
-		if (write_batch)
-			fmt = "--write-batch=%s";
-		else
-		if (read_batch)
-			fmt = "--read-batch=%s";
-		snprintf(fext,sizeof(fext),fmt,batch_prefix);
-		args[ac++] = fext;
+	if (batch_prefix) {
+		char *r_or_w = write_batch ? "write" : "read";
+		if (asprintf(&arg, "--%s-batch=%s", r_or_w, batch_prefix) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
 	if (io_timeout) {
-		snprintf(iotime,sizeof(iotime),"--timeout=%d",io_timeout);
-		args[ac++] = iotime;
+		if (asprintf(&arg, "--timeout=%d", io_timeout) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
 	if (bwlimit) {
-		snprintf(bw,sizeof(bw),"--bwlimit=%d",bwlimit);
-		args[ac++] = bw;
+		if (asprintf(&arg, "--bwlimit=%d", bwlimit) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
 	if (backup_dir) {
 		args[ac++] = "--backup-dir";
 		args[ac++] = backup_dir;
 	}
 
 	/* Only send --suffix if it specifies a non-default value. */
-	if (strcmp(backup_suffix, backup_dir? "" : BACKUP_SUFFIX) != 0) {
-		char *s = new_array(char, 9+backup_suffix_len+1);
-		if (!s)
-			out_of_memory("server_options");
+	if (strcmp(backup_suffix, backup_dir ? "" : BACKUP_SUFFIX) != 0) {
 		/* We use the following syntax to avoid weirdness with '~'. */
-		sprintf(s, "--suffix=%s", backup_suffix);
-		args[ac++] = s;
+		if (asprintf(&arg, "--suffix=%s", backup_suffix) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
-	if (delete_mode && !delete_excluded)
-		args[ac++] = "--delete";
-
 	if (delete_excluded)
 		args[ac++] = "--delete-excluded";
+	else if (delete_mode)
+		args[ac++] = "--delete";
 
 	if (size_only)
 		args[ac++] = "--size-only";
 
 	if (modify_window_set) {
-		snprintf(mwindow,sizeof(mwindow),"--modify-window=%d",
-			 modify_window);
-		args[ac++] = mwindow;
+		if (asprintf(&arg, "--modify-window=%d", modify_window) < 0)
+			goto oom;
+		args[ac++] = arg;
 	}
 
 	if (keep_partial)
 		args[ac++] = "--partial";
 
 	if (force_delete)
@@ -901,26 +963,32 @@
 			args[ac++] = "--files-from=-";
 			args[ac++] = "--from0";
 		}
 	}
 
 	*argc = ac;
+	return;
+
+    oom:
+	out_of_memory("server_options");
 }
 
 /**
  * Return the position of a ':' IF it is not part of a filename (i.e. as
  * long as it doesn't occur after a slash.
  */
 char *find_colon(char *s)
 {
 	char *p, *p2;
 
 	p = strchr(s,':');
-	if (!p) return NULL;
+	if (!p)
+		return NULL;
 
 	/* now check to see if there is a / in the string before the : - if there is then
 	   discard the colon on the assumption that the : is part of a filename */
 	p2 = strchr(s,'/');
-	if (p2 && p2 < p) return NULL;
+	if (p2 && p2 < p)
+		return NULL;
 
 	return p;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/packaging/lsb/rsync.spec /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/packaging/lsb/rsync.spec
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/packaging/lsb/rsync.spec	2004-01-02 03:09:16.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/packaging/lsb/rsync.spec	2004-04-27 11:54:05.000000000 +0800
@@ -1,9 +1,9 @@
 Summary: Program for efficient remote updates of files.
 Name: rsync
-Version: 2.6.0
+Version: 2.6.1
 Release: 1
 Copyright: GPL
 Group: Applications/Networking
 Source:	ftp://samba.anu.edu.au/pub/rsync/rsync-%{version}.tar.gz
 URL: http://samba.anu.edu.au/rsync/
 Packager: Andrew Tridgell <tridge@samba.anu.edu.au>
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: chmod-option.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: copy-atimes.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: craigb-perf.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: date-only.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: db3l_ignore-case.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: delete-sent-files.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: early-chmod.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches/gzip-rsyncable.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches/gzip-rsyncable.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches/gzip-rsyncable.diff	2002-04-08 09:41:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches/gzip-rsyncable.diff	2004-02-27 16:52:09.000000000 +0800
@@ -1,30 +1,18 @@
-In message <20020403094739.GA5434@samba.org> you write:
-> On  3 Apr 2002, Rusty Russell <rusty@rustcorp.com.au> wrote:
-> > In message <20020403020455.GC18851@samba.org> you write:
-> > > Hi,
-> > > 
-> > > I think you said the other day that you had a working --rsyncable
-> > > patch for gzip.  Could I have it please?
-> 
-> Thanks for that.  I'll put it in with our contrib patches and probably
-> merge it soon.
-> 
-> I was actually after the patch to gzip, rather than the fuzzy patch
-> for rsync.  I'd like to try it myself and also distribute it along
-> with rsync.
+From: Rusty Russell <rusty@rustcorp.com.au>
+
+[NOTE: this patch is for _gzip_! --Wayne]
 
 It's pending for actual gzip inclusion!  The maintainer was dug up and
 everything: it'll even be on by default.
 
 But here's the old patch,
 Rusty.
 --
   Anyone who quotes me in their sig is an idiot. -- Rusty Russell.
 
-diff -ur gzip-1.2.4.orig/deflate.c gzip-1.2.4-rsync/deflate.c
 --- gzip-1.2.4.orig/deflate.c	Fri Aug 13 22:35:31 1993
 +++ gzip-1.2.4-rsync/deflate.c	Sat Dec 30 15:33:25 2000
 @@ -121,6 +121,14 @@
  #endif
  /* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
  
@@ -197,13 +185,12 @@
 +	    }
              match_available = 1;
 +	    RSYNC_ROLL(strstart, 1);
              strstart++;
              lookahead--;
          }
-diff -ur gzip-1.2.4.orig/gzip.c gzip-1.2.4-rsync/gzip.c
 --- gzip-1.2.4.orig/gzip.c	Thu Aug 19 23:39:43 1993
 +++ gzip-1.2.4-rsync/gzip.c	Fri Dec 29 21:20:54 2000
 @@ -239,6 +239,7 @@
  unsigned insize;           /* valid bytes in inbuf */
  unsigned inptr;            /* index of next byte to be processed in inbuf */
  unsigned outcnt;           /* bytes in output buffer */
@@ -234,13 +221,12 @@
 +	case 'R':
 +	    rsync = 1; break;
 +
  	case 'S':
  #ifdef NO_MULTIPLE_DOTS
              if (*optarg == '.') optarg++;
-diff -ur gzip-1.2.4.orig/gzip.h gzip-1.2.4-rsync/gzip.h
 --- gzip-1.2.4.orig/gzip.h	Fri Aug 13 22:35:33 1993
 +++ gzip-1.2.4-rsync/gzip.h	Sat Dec 30 15:26:56 2000
 @@ -131,6 +131,7 @@
  extern unsigned insize; /* valid bytes in inbuf */
  extern unsigned inptr;  /* index of next byte to be processed in inbuf */
  extern unsigned outcnt; /* bytes in output buffer */
@@ -254,13 +240,12 @@
  int  ct_tally    OF((int dist, int lc));
 -ulg  flush_block OF((char *buf, ulg stored_len, int eof));
 +ulg  flush_block OF((char *buf, ulg stored_len, int pad, int eof));
  
          /* in bits.c */
  void     bi_init    OF((file_t zipfile));
-diff -ur gzip-1.2.4.orig/gzip.texi gzip-1.2.4-rsync/gzip.texi
 --- gzip-1.2.4.orig/gzip.texi	Thu Aug 19 06:42:50 1993
 +++ gzip-1.2.4-rsync/gzip.texi	Fri Dec 29 21:20:54 2000
 @@ -316,6 +316,14 @@
  into the directory and compress all the files it finds there (or
  decompress them in the case of @code{gunzip}).
  
@@ -272,13 +257,12 @@
 +this flag.  @code{gunzip} cannot tell the difference between a
 +compressed file created with this option, and one created without it.
 +
  @item --suffix @var{suf}
  @itemx -S @var{suf}
  Use suffix @samp{@var{suf}} instead of @samp{.gz}. Any suffix can be
-diff -ur gzip-1.2.4.orig/trees.c gzip-1.2.4-rsync/trees.c
 --- gzip-1.2.4.orig/trees.c	Wed Aug 18 03:36:32 1993
 +++ gzip-1.2.4-rsync/trees.c	Sat Dec 30 15:37:00 2000
 @@ -850,9 +850,10 @@
   * trees or store, and output the encoded block to the zip file. This function
   * returns the total compressed length for the file so far.
   */
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: ignore-case.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: jjb-date-only.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: kikuchi_set_rsyncdconf_location.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: link-by-hash.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: marco_soften-links.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: merge-exclude-file.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: netgroup-auth.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: ODBC-dblog.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: openssl-support.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: proxy-auth.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: rsync-chmod-v1.patch
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches: rsync_zoong_tru64.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches/rusty-fuzzy.diff /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches/rusty-fuzzy.diff
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/patches/rusty-fuzzy.diff	2002-04-03 17:56:50.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches/rusty-fuzzy.diff	2004-04-23 07:56:58.000000000 +0800
@@ -1,226 +1,70 @@
-From rusty@rustcorp.com.au Wed Apr  3 17:18:42 2002
-Return-Path: <rusty@rustcorp.com.au>
-Delivered-To: mbp@samba.org
-Received: from wagner.rustcorp.com.au (sydney1.au.ibm.com [202.135.142.193])
-	by lists.samba.org (Postfix) with ESMTP id EA7B849DC
-	for <mbp@samba.org>; Tue,  2 Apr 2002 23:06:29 -0800 (PST)
-Received: from wagner.rustcorp.com.au ([127.0.0.1] helo=rustcorp.com.au)
-	by wagner.rustcorp.com.au with esmtp (Exim 3.35 #1 (Debian))
-	id 16set7-0000pL-00
-	for <mbp@samba.org>; Wed, 03 Apr 2002 17:08:57 +1000
 From: Rusty Russell <rusty@rustcorp.com.au>
-To: Martin Pool <mbp@samba.org>
-Subject: Re: gzip patch 
-In-reply-to: Your message of "Wed, 03 Apr 2002 12:04:59 +1000."
-             <20020403020455.GC18851@samba.org> 
 Date: Wed, 03 Apr 2002 17:08:57 +1000
-Sender: rusty@rustcorp.com.au
-Message-Id: <E16set7-0000pL-00@wagner.rustcorp.com.au>
-Status: RO
-X-Status: A
-Content-Length: 12810
-Lines: 461
 
-In message <20020403020455.GC18851@samba.org> you write:
-> Hi,
-> 
-> I think you said the other day that you had a working --rsyncable
-> patch for gzip.  Could I have it please?
-
-Hi Martin,
-
-	Just got your mail, sorry for the delay.  Found old patch on
-google, and updated it for 2.5.4 (I know, but that's what apt-get
-source gave me).
+Found old patch on google, and updated it for 2.5.4 (I know, but that's what
+apt-get source gave me).
 
 Compiles, otherwise untested.
 Rusty.
+
+[Updated for current CVS version by Wayne Davison.  Passes *MOST* of the
+test suite, but otherwise UNTESTED.]
 --
   Anyone who quotes me in their sig is an idiot. -- Rusty Russell.
 
-diff -urN rsync-2.5.4/Makefile.in rsync-2.5.4-fuzzy/Makefile.in
---- rsync-2.5.4/Makefile.in	Tue Feb 26 05:48:25 2002
-+++ rsync-2.5.4-fuzzy/Makefile.in	Wed Apr  3 16:35:55 2002
-@@ -28,7 +28,7 @@
- ZLIBOBJ=zlib/deflate.o zlib/infblock.o zlib/infcodes.o zlib/inffast.o \
+--- Makefile.in	10 Feb 2004 17:06:11 -0000	1.98
++++ Makefile.in	22 Apr 2004 23:48:20 -0000
+@@ -32,7 +32,7 @@ ZLIBOBJ=zlib/deflate.o zlib/infblock.o z
  	zlib/inflate.o zlib/inftrees.o zlib/infutil.o zlib/trees.o \
- 	zlib/zutil.o zlib/adler32.o 
--OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o main.o checksum.o match.o syscall.o log.o backup.o
-+OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o main.o checksum.o match.o syscall.o log.o backup.o alternate.o
- OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o fileio.o batch.o \
- 	clientname.o
- DAEMON_OBJ = params.o loadparm.o clientserver.o access.o connection.o authenticate.o
-diff -urN rsync-2.5.4/alternate.c rsync-2.5.4-fuzzy/alternate.c
---- rsync-2.5.4/alternate.c	Thu Jan  1 10:00:00 1970
-+++ rsync-2.5.4-fuzzy/alternate.c	Wed Apr  3 17:04:15 2002
-@@ -0,0 +1,117 @@
-+#include "rsync.h"
-+
-+extern char *compare_dest;
-+extern int verbose;
-+
-+/* Alternate methods for opening files, if local doesn't exist */
-+/* Sanity check that we are about to open regular file */
-+int do_open_regular(char *fname)
-+{
-+	STRUCT_STAT st;
-+
-+	if (do_stat(fname, &st) == 0 && S_ISREG(st.st_mode))
-+		return do_open(fname, O_RDONLY, 0);
-+
-+	return -1;
-+}
-+
-+static void split_names(char *fname, char **dirname, char **basename)
-+{
-+	char *slash;
-+
-+	slash = strrchr(fname, '/');
-+	if (slash) {
-+		*dirname = fname;
-+		*slash = '\0';
-+		*basename = slash+1;
-+	} else {
-+		*basename = fname;
-+		*dirname = ".";
-+	}
-+}
-+
-+static unsigned int measure_name(const char *name,
-+				 const char *basename,
-+				 const char *ext)
-+{
-+	int namelen = strlen(name);
-+	int extlen = strlen(ext);
-+	unsigned int score = 0;
-+
-+	/* Extensions must match */
-+	if (namelen <= extlen || strcmp(name+namelen-extlen, ext) != 0)
-+		return 0;
-+
-+	/* Now score depends on similarity of prefix */
-+	for (; *name==*basename && *name; name++, basename++)
-+		score++;
-+	return score;
-+}
-+
-+int open_alternate_base_fuzzy(const char *fname)
-+{
-+	DIR *d;
-+	struct dirent *di;
-+	char *basename, *dirname;
-+	char mangled_name[MAXPATHLEN];
-+	char bestname[MAXPATHLEN];
-+	unsigned int bestscore = 0;
-+	const char *ext;
-+
-+	/* FIXME: can we assume fname fits here? */
-+	strcpy(mangled_name, fname);
-+
-+	split_names(mangled_name, &dirname, &basename);
-+	d = opendir(dirname);
-+	if (!d) {
-+		rprintf(FERROR,"recv_generator opendir(%s): %s\n",
-+			dirname,strerror(errno));
-+		return -1;
-+	}
-+
-+	/* Get final extension, eg. .gz; never full basename though. */
-+	ext = strrchr(basename + 1, '.');
-+	if (!ext)
-+		ext = basename + strlen(basename); /* ext = "" */
-+
-+	while ((di = readdir(d)) != NULL) {
-+		const char *dname = d_name(di);
-+		unsigned int score;
-+
-+		if (strcmp(dname,".")==0 ||
-+		    strcmp(dname,"..")==0)
-+			continue;
-+		
-+		score = measure_name(dname, basename, ext);
-+		if (verbose > 4)
-+			rprintf(FINFO,"fuzzy score for %s = %u\n",
-+				dname, score);
-+		if (score > bestscore) {
-+			strcpy(bestname, dname); 
-+			bestscore = score;
-+		}
-+	}
-+	closedir(d);
-+
-+	/* Found a candidate. */
-+	if (bestscore != 0) {
-+		char fuzzyname[MAXPATHLEN];
-+
-+		snprintf(fuzzyname,MAXPATHLEN,"%s/%s", dirname, bestname);
-+		if (verbose > 2)
-+			rprintf(FINFO,"fuzzy match %s->%s\n",
-+				fname, fuzzyname);
-+		return do_open_regular(fuzzyname);
-+	}
-+	return -1;
-+}
-+
-+int open_alternate_base_comparedir(const char *fname)
-+{
-+	char fnamebuf[MAXPATHLEN];
-+	/* try the file at compare_dest instead */
-+	snprintf(fnamebuf,MAXPATHLEN,"%s/%s",compare_dest,fname);
-+
-+	/* FIXME: now follows symlinks... */
-+	return do_open_regular(fnamebuf);
-+}
-diff -urN rsync-2.5.4/generator.c rsync-2.5.4-fuzzy/generator.c
---- rsync-2.5.4/generator.c	Fri Feb  8 03:36:12 2002
-+++ rsync-2.5.4-fuzzy/generator.c	Wed Apr  3 17:00:06 2002
-@@ -42,11 +42,12 @@
- extern int always_checksum;
- extern int modify_window;
- extern char *compare_dest;
+ 	zlib/zutil.o zlib/adler32.o
+ OBJS1=rsync.o generator.o receiver.o cleanup.o sender.o exclude.o util.o \
+-	main.o checksum.o match.o syscall.o log.o backup.o
++	main.o checksum.o match.o syscall.o log.o backup.o alternate.o
+ OBJS2=options.o flist.o io.o compat.o hlink.o token.o uidlist.o socket.o \
+ 	fileio.o batch.o clientname.o
+ OBJS3=progress.o pipe.o
+--- generator.c	15 Apr 2004 16:55:23 -0000	1.79
++++ generator.c	22 Apr 2004 23:48:20 -0000
+@@ -50,6 +50,7 @@ extern int list_only;
+ extern int only_existing;
+ extern int orig_umask;
+ extern int safe_symlinks;
 +extern int fuzzy;
  
  
  /* choose whether to skip a particular file */
- static int skip_file(char *fname,
--		     struct file_struct *file, STRUCT_STAT *st)
-+		     struct file_struct *file, const STRUCT_STAT *st)
- {
- 	if (st->st_size != file->length) {
- 		return 0;
-@@ -185,7 +186,61 @@
- 	return s;
+@@ -255,7 +256,62 @@ static void generate_and_send_sums(struc
+ 	}
  }
  
 +/* Returns -1 for can't open (null file), -2 for skip */
-+static int open_base_file(struct file_struct *file,
-+			  char *fname, 
-+			  int statret, 
++static int open_base_file(struct file_struct *file, char *fname, int statret,
 +			  STRUCT_STAT *st)
 +{
 +	int fd = -1;
-+
+ 
 +	if (statret == 0) {
 +		if (S_ISREG(st->st_mode)) {
 +			if (update_only
 +			    && cmp_modtime(st->st_mtime, file->modtime) > 0) {
 +				if (verbose > 1)
-+					rprintf(FINFO,"%s is newer\n",fname);
++					rprintf(FINFO, "%s is newer\n", fname);
 +				return -2;
 +			}
 +			if (skip_file(fname, file, st)) {
 +				set_perms(fname, file, st, 1);
 +				return -2;
 +			}
 +		 	fd = do_open(fname, O_RDONLY, 0);
 +			if (fd == -1) {
-+				rprintf(FERROR,"failed to open %s, continuing : %s\n",fname,strerror(errno));
++				rprintf(FERROR, "failed to open %s, continuing : %s\n",
++				    full_fname(fname), strerror(errno));
 +				return -1;
-+			} else
-+				return fd;
++			}
++			return fd;
 +		} else {
 +			/* Try to use symlink contents */
 +			if (S_ISLNK(st->st_mode)) {
 +				fd = do_open_regular(fname);
 +				/* Don't delete yet; receiver will need it */
 +			} else {
@@ -232,254 +76,283 @@
 +			}
 +		}
 +	}
 +
 +	if (fd == -1 && compare_dest != NULL)
 +		fd = open_alternate_base_comparedir(fname);
- 
++
 +	if (fd == -1 && fuzzy)
 +		fd = open_alternate_base_fuzzy(fname);
 +
 +	/* Update stat to understand size */
 +	if (fd != -1) {
-+		if (do_fstat(fd, st) != 0)
-+			rprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
++		if (do_fstat(fd, st) != 0) {
++			rprintf(FERROR, "fstat %s : %s\n",
++			    full_fname(fname), strerror(errno));
++		}
 +	}
 +
 +	return fd;
 +}
  
- /*
-  * Acts on file number I from FLIST, whose name is fname.
-@@ -203,9 +258,6 @@
- 	struct sum_struct *s;
+ /**
+  * Acts on file number @p i from @p flist, whose name is @p fname.
+@@ -271,8 +327,6 @@ void recv_generator(char *fname, struct 
+ 	STRUCT_STAT st;
+ 	struct map_struct *mapbuf;
  	int statret;
- 	struct file_struct *file = flist->files[i];
 -	char *fnamecmp;
 -	char fnamecmpbuf[MAXPATHLEN];
--	extern char *compare_dest;
- 	extern int list_only;
- 	extern int preserve_perms;
- 	extern int only_existing;
-@@ -341,82 +393,29 @@
+ 
+ 	if (list_only)
  		return;
+@@ -396,108 +450,38 @@ void recv_generator(char *fname, struct 
  	}
+ #endif
  
+-	if (preserve_hard_links && hard_link_check(file, HL_CHECK_MASTER))
+-		return;
+-
+-	if (!S_ISREG(file->mode)) {
+-		rprintf(FINFO, "skipping non-regular file \"%s\"\n",fname);
+-		return;
+-	}
+-
 -	fnamecmp = fname;
 -
--	if ((statret == -1) && (compare_dest != NULL)) {
+-	if (statret == -1 && compare_dest != NULL) {
 -		/* try the file at compare_dest instead */
 -		int saveerrno = errno;
--		snprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",compare_dest,fname);
+-		pathjoin(fnamecmpbuf, sizeof fnamecmpbuf, compare_dest, fname);
 -		statret = link_stat(fnamecmpbuf,&st);
 -		if (!S_ISREG(st.st_mode))
 -			statret = -1;
 -		if (statret == -1)
 -			errno = saveerrno;
+-#if HAVE_LINK
+-		else if (link_dest && !dry_run) {
+-			if (do_link(fnamecmpbuf, fname) != 0) {
+-				if (verbose > 0) {
+-					rprintf(FINFO,"link %s => %s : %s\n",
+-						fnamecmpbuf, fname,
+-						strerror(errno));
+-				}
+-			}
+-			fnamecmp = fnamecmpbuf;
+-		}
+-#endif
 -		else
 -			fnamecmp = fnamecmpbuf;
 -	}
 -
 -	if (statret == -1) {
+-		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+-			return;
 -		if (errno == ENOENT) {
 -			write_int(f_out,i);
--			if (!dry_run) send_sums(NULL,f_out);
--		} else {
--			if (verbose > 1)
--				rprintf(FERROR, RSYNC_NAME
--					": recv_generator failed to open \"%s\": %s\n",
--					fname, strerror(errno));
+-			if (!dry_run) write_sum_head(f_out, NULL);
+-		} else if (verbose > 1) {
++	/* Failed to stat for some reason besides "not found". */
++	if (statret == -1 && errno != ENOENT) {
++		if (verbose > 1)
+ 			rprintf(FERROR,
+-				"recv_generator: failed to open %s: %s\n",
++				"recv_generator failed to stat %s: %s\n",
+ 				full_fname(fname), strerror(errno));
 -		}
--		return;
--	}
--
+ 		return;
+ 	}
+ 
 -	if (!S_ISREG(st.st_mode)) {
 -		if (delete_file(fname) != 0) {
 -			return;
 -		}
 -
 -		/* now pretend the file didn't exist */
+-		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+-			return;
 -		write_int(f_out,i);
--		if (!dry_run) send_sums(NULL,f_out);    
--		return;
+-		if (!dry_run) write_sum_head(f_out, NULL);
++	if ((fd = open_base_file(file, fname, statret, &st)) == -2)
+ 		return;
 -	}
 -
--	if (opt_ignore_existing && fnamecmp == fname) { 
+-	if (opt_ignore_existing && fnamecmp == fname) {
 -		if (verbose > 1)
 -			rprintf(FINFO,"%s exists\n",fname);
 -		return;
--	} 
--
+-	}
+ 
 -	if (update_only && cmp_modtime(st.st_mtime,file->modtime)>0 && fnamecmp == fname) {
-+	/* Failed to stat for some other reason. */
-+	if (statret == -1 && errno != ENOENT) {
- 		if (verbose > 1)
+-		if (verbose > 1)
 -			rprintf(FINFO,"%s is newer\n",fname);
-+			rprintf(FERROR, RSYNC_NAME
-+				": recv_generator failed to open \"%s\": %s\n",
-+				fname, strerror(errno));
- 		return;
+-		return;
++	if ((disable_deltas_p() || dry_run) && fd != -1) {
++		close(fd);
++		fd = -1;
  	}
  
 -	if (skip_file(fname, file, &st)) {
 -		if (fnamecmp == fname)
 -			set_perms(fname,file,&st,1);
 -		return;
 -	}
 -
 -	if (dry_run) {
 -		write_int(f_out,i);
-+	fd = open_base_file(file, fname, statret, &st);
-+	if (fd == -2)
- 		return;
+-		return;
 -	}
 -
--	if (whole_file) {
+-	if (disable_deltas_p()) {
 -		write_int(f_out,i);
--		send_sums(NULL,f_out);    
+-		write_sum_head(f_out, NULL);
 -		return;
 -	}
 -
--	/* open the file */  
+-	/* open the file */
 -	fd = do_open(fnamecmp, O_RDONLY, 0);
- 
--	if (fd == -1) {
--		rprintf(FERROR,RSYNC_NAME": failed to open \"%s\", continuing : %s\n",fnamecmp,strerror(errno));
+-
+ 	if (fd == -1) {
+-		rprintf(FERROR, "failed to open %s, continuing: %s\n",
+-			full_fname(fnamecmp), strerror(errno));
 -		/* pretend the file didn't exist */
-+	if ((whole_file || dry_run) && fd != -1) {
-+		close(fd);
-+		fd = -1;
-+ 	}
-+ 
-+ 	if (fd == -1) {
 +		/* the file didn't exist, or we can pretend it doesn't */
- 		write_int(f_out,i);
--		send_sums(NULL,f_out);
+ 		if (preserve_hard_links && hard_link_check(file, HL_SKIP))
+ 			return;
+-		write_int(f_out,i);
+-		write_sum_head(f_out, NULL);
++ 		write_int(f_out, i);
 +		if (!dry_run)
-+			send_sums(NULL,f_out);
++			write_sum_head(f_out, NULL);
++ 		return;
++ 	}
++
++	if (preserve_hard_links && hard_link_check(file, HL_CHECK_MASTER))
++		return;
++
++	if (!S_ISREG(file->mode)) {
++		rprintf(FINFO, "skipping non-regular file \"%s\"\n",fname);
  		return;
  	}
  
-@@ -427,7 +426,7 @@
+@@ -507,7 +491,7 @@ void recv_generator(char *fname, struct 
+ 		mapbuf = NULL;
+ 
+ 	if (verbose > 3) {
+-		rprintf(FINFO,"gen mapped %s of size %.0f\n", fnamecmp,
++		rprintf(FINFO, "gen mapped %s of size %.0f\n", fname,
+ 			(double)st.st_size);
  	}
  
- 	if (verbose > 3)
--		rprintf(FINFO,"gen mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
-+		rprintf(FINFO,"gen mapped %s of size %.0f\n",fname,(double)st.st_size);
- 
- 	s = generate_sums(buf,st.st_size,adapt_block_size(file, block_size));
- 
-diff -urN rsync-2.5.4/options.c rsync-2.5.4-fuzzy/options.c
---- rsync-2.5.4/options.c	Thu Feb 28 09:49:57 2002
-+++ rsync-2.5.4-fuzzy/options.c	Wed Apr  3 16:43:54 2002
-@@ -73,6 +73,7 @@
- #else
- int modify_window=0;
- #endif
-+int fuzzy=0;
- int blocking_io=-1;
+--- options.c	17 Apr 2004 17:07:23 -0000	1.147
++++ options.c	22 Apr 2004 23:48:20 -0000
+@@ -91,6 +91,7 @@ int ignore_errors = 0;
+ int modify_window = 0;
+ int blocking_io = -1;
+ int checksum_seed = 0;
++int fuzzy = 0;
+ unsigned int block_size = 0;
  
- /** Network address family. **/
-@@ -245,6 +246,7 @@
+ 
+@@ -290,6 +291,7 @@ void usage(enum logcode F)
    rprintf(F,"     --bwlimit=KBPS          limit I/O bandwidth, KBytes per second\n");
    rprintf(F,"     --write-batch=PREFIX    write batch fileset starting with PREFIX\n");
    rprintf(F,"     --read-batch=PREFIX     read batch fileset starting with PREFIX\n");
-+  rprintf(F,"     --fuzzy	          use similar file as basis if it does't exist\n");
++  rprintf(F,"     --fuzzy                 use similar file as basis if it does't exist\n");
    rprintf(F," -h, --help                  show this help screen\n");
  #ifdef INET6
    rprintf(F," -4                          prefer IPv4\n");
-@@ -340,6 +342,7 @@
-   {"hard-links",      'H', POPT_ARG_NONE,   &preserve_hard_links},
-   {"read-batch",       0,  POPT_ARG_STRING, &batch_prefix, OPT_READ_BATCH},
-   {"write-batch",      0,  POPT_ARG_STRING, &batch_prefix, OPT_WRITE_BATCH},
-+  {"fuzzy",	       0,  POPT_ARG_NONE,   &fuzzy},
+@@ -385,6 +387,7 @@ static struct poptOption long_options[] 
+   {"files-from",       0,  POPT_ARG_STRING, &files_from, 0, 0, 0 },
+   {"from0",           '0', POPT_ARG_NONE,   &eol_nulls, 0, 0, 0},
+   {"no-implied-dirs",  0,  POPT_ARG_VAL,    &implied_dirs, 0, 0, 0 },
++  {"fuzzy",            0,  POPT_ARG_NONE,   &fuzzy, 0, 0, 0 },
+   {"protocol",         0,  POPT_ARG_INT,    &protocol_version, 0, 0, 0 },
  #ifdef INET6
-   {0,		      '4', POPT_ARG_VAL,    &default_af_hint,   AF_INET },
-   {0,		      '6', POPT_ARG_VAL,    &default_af_hint,   AF_INET6 },
-@@ -757,7 +760,9 @@
- 		args[ac++] = "--compare-dest";
- 		args[ac++] = compare_dest;
+   {0,		      '4', POPT_ARG_VAL,    &default_af_hint, AF_INET, 0, 0 },
+@@ -964,6 +967,9 @@ void server_options(char **args,int *arg
+ 			args[ac++] = "--from0";
+ 		}
  	}
--
-+	
++
 +	if (fuzzy && am_sender)
 +		args[ac++] = "--fuzzy";
  
  	*argc = ac;
- }
-diff -urN rsync-2.5.4/proto.h rsync-2.5.4-fuzzy/proto.h
---- rsync-2.5.4/proto.h	Sat Feb 23 11:05:06 2002
-+++ rsync-2.5.4-fuzzy/proto.h	Wed Apr  3 16:35:25 2002
-@@ -256,3 +256,6 @@
- int cmp_modtime(time_t file1, time_t file2);
- int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6);
- int sys_gettimeofday(struct timeval *tv);
-+int do_open_regular(char *fname);
-+int open_alternate_base_fuzzy(const char *fname);
-+int open_alternate_base_comparedir(const char *fname);
-diff -urN rsync-2.5.4/receiver.c rsync-2.5.4-fuzzy/receiver.c
---- rsync-2.5.4/receiver.c	Thu Feb 14 05:42:20 2002
-+++ rsync-2.5.4-fuzzy/receiver.c	Wed Apr  3 16:46:46 2002
-@@ -36,6 +36,7 @@
- extern char *compare_dest;
- extern int make_backups;
- extern char *backup_suffix;
+ 	return;
+--- receiver.c	23 Mar 2004 16:50:40 -0000	1.75
++++ receiver.c	22 Apr 2004 23:48:20 -0000
+@@ -45,6 +45,7 @@ extern int cleanup_got_literal;
+ extern int module_id;
+ extern int ignore_errors;
+ extern int orig_umask;
 +extern int fuzzy;
  
- static struct delete_list {
- 	DEV64_T dev;
-@@ -307,8 +308,6 @@
- 	char *fname;
+ static void delete_one(char *fn, int is_dir)
+ {
+@@ -292,8 +293,6 @@ int recv_files(int f_in,struct file_list
+ 	char *fname, fbuf[MAXPATHLEN];
  	char template[MAXPATHLEN];
  	char fnametmp[MAXPATHLEN];
 -	char *fnamecmp;
 -	char fnamecmpbuf[MAXPATHLEN];
- 	struct map_struct *buf;
+ 	struct map_struct *mapbuf;
  	int i;
  	struct file_struct *file;
-@@ -366,28 +365,24 @@
+@@ -356,35 +355,31 @@ int recv_files(int f_in,struct file_list
  		if (verbose > 2)
  			rprintf(FINFO,"recv_files(%s)\n",fname);
  
 -		fnamecmp = fname;
 -
- 		/* open the file */  
+ 		/* open the file */
 -		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 +		fd1 = do_open(fname, O_RDONLY, 0);
  
--		if ((fd1 == -1) && (compare_dest != NULL)) {
+-		if (fd1 == -1 && compare_dest != NULL) {
 -			/* try the file at compare_dest instead */
--			snprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",
--						compare_dest,fname);
+-			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
+-				 compare_dest, fname);
 -			fnamecmp = fnamecmpbuf;
 -			fd1 = do_open(fnamecmp, O_RDONLY, 0);
 -		}
 +		if (fd1 == -1 && compare_dest != NULL)
 +			fd1 = open_alternate_base_comparedir(fname);
 +
 +		if (fd1 == -1 && fuzzy)
 +			fd1 = open_alternate_base_fuzzy(fname);
  
  		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
--			rprintf(FERROR,"fstat %s : %s\n",fnamecmp,strerror(errno));
-+			rprintf(FERROR,"fstat %s : %s\n",fname,strerror(errno));
+ 			rprintf(FERROR, "fstat %s failed: %s\n",
+-				full_fname(fnamecmp), strerror(errno));
++				full_fname(fname), strerror(errno));
  			receive_data(f_in,NULL,-1,NULL,file->length);
  			close(fd1);
  			continue;
  		}
  
- 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
--			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fnamecmp);
-+			rprintf(FERROR,"%s : not a regular file (recv_files)\n",fname);
- 			receive_data(f_in,NULL,-1,NULL,file->length);
+-		if (fd1 != -1 && S_ISDIR(st.st_mode) && fnamecmp == fname) {
++		if (fd1 != -1 && S_ISDIR(st.st_mode)) {
+ 			/* this special handling for directories
+ 			 * wouldn't be necessary if robust_rename()
+ 			 * and the underlying robust_unlink could cope
+ 			 * with directories
+ 			 */
+ 			rprintf(FERROR,"recv_files: %s is a directory\n",
+-				full_fname(fnamecmp));
++				full_fname(fname));
+ 			receive_data(f_in, NULL, -1, NULL, file->length);
  			close(fd1);
  			continue;
-@@ -403,7 +398,7 @@
+@@ -405,8 +400,10 @@ int recv_files(int f_in,struct file_list
+ 
  		if (fd1 != -1 && st.st_size > 0) {
- 			buf = map_file(fd1,st.st_size);
- 			if (verbose > 2)
+ 			mapbuf = map_file(fd1,st.st_size);
+-			if (verbose > 2)
 -				rprintf(FINFO,"recv mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
-+				rprintf(FINFO,"recv mapped %s of size %.0f\n",fname,(double)st.st_size);
- 		} else {
- 			buf = NULL;
- 		}
-
++			if (verbose > 2) {
++				rprintf(FINFO, "recv mapped %s of size %.0f\n",
++				    fname, (double)st.st_size);
++			}
+ 		} else
+ 			mapbuf = NULL;
+ 
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: soften-links.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: time-limit.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: tru64.diff
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: verify-patches
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/patches: write-only.diff
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/pipe.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/pipe.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/pipe.c	2003-12-16 02:45:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/pipe.c	2004-01-28 06:35:15.000000000 +0800
@@ -18,12 +18,19 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
 
+extern int am_sender;
+extern int am_server;
+extern int blocking_io;
+extern int orig_umask;
+extern int read_batch;
+extern int filesfrom_fd;
+
 /**
  * Create a child connected to use on stdin/stdout.
  *
  * This is derived from CVS code 
  * 
  * Note that in the child STDIN is set to blocking and STDOUT
@@ -36,13 +43,12 @@
  **/
 pid_t piped_child(char **command, int *f_in, int *f_out)
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
-	extern int blocking_io;
 	
 	if (verbose >= 2) {
 		print_child_argv(command);
 	}
 
 	if (fd_pair(to_child_pipe) < 0 || fd_pair(from_child_pipe) < 0) {
@@ -55,13 +61,12 @@
 	if (pid == -1) {
 		rprintf(FERROR, "fork: %s\n", strerror(errno));
 		exit_cleanup(RERR_IPC);
 	}
 
 	if (pid == 0) {
-		extern int orig_umask;
 		if (dup2(to_child_pipe[0], STDIN_FILENO) < 0 ||
 		    close(to_child_pipe[1]) < 0 ||
 		    close(from_child_pipe[0]) < 0 ||
 		    dup2(from_child_pipe[1], STDOUT_FILENO) < 0) {
 			rprintf(FERROR, "Failed to dup/close : %s\n",
 				strerror(errno));
@@ -95,16 +100,12 @@
 pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
 		  int (*child_main)(int, char*[]))
 {
 	pid_t pid;
 	int to_child_pipe[2];
 	int from_child_pipe[2];
-	extern int read_batch;
-	extern int am_sender;
-	extern int am_server;
-	extern int filesfrom_fd;
 
 	if (fd_pair(to_child_pipe) < 0 ||
 	    fd_pair(from_child_pipe) < 0) {
 		rprintf(FERROR,"pipe: %s\n",strerror(errno));
 		exit_cleanup(RERR_IPC);
 	}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/popt.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/popt.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/popt.c	2003-01-19 03:00:07.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/popt.c	2004-01-28 00:27:05.000000000 +0800
@@ -904,16 +904,16 @@
 		    if ((opt->argInfo & POPT_ARG_MASK) == POPT_ARG_DOUBLE) {
 			*((double *) opt->arg) = aDouble;
 		    } else {
 #ifndef DBL_EPSILON
 #define DBL_EPSILON 2.2204460492503131e-16
 #endif
-#define _ABS(a)	((((a) - 0.0) < DBL_EPSILON) ? -(a) : (a))
-			if ((_ABS(aDouble) - FLT_MAX) > DBL_EPSILON)
+#define MY_ABS(a) ((((a) - 0.0) < DBL_EPSILON) ? -(a) : (a))
+			if ((MY_ABS(aDouble) - FLT_MAX) > DBL_EPSILON)
 			    return POPT_ERROR_OVERFLOW;
-			if ((FLT_MIN - _ABS(aDouble)) > DBL_EPSILON)
+			if ((FLT_MIN - MY_ABS(aDouble)) > DBL_EPSILON)
 			    return POPT_ERROR_OVERFLOW;
 			*((float *) opt->arg) = aDouble;
 		    }
 		}   /*@switchbreak@*/ break;
 		default:
 		    fprintf(stdout,
@@ -1052,13 +1052,13 @@
     
     con = _free(con);
     return con;
 }
 
 int poptAddAlias(poptContext con, struct poptAlias alias,
-		/*@unused@*/ int flags)
+		/*@unused@*/ UNUSED(int flags))
 {
     poptItem item = (poptItem) alloca(sizeof(*item));
     memset(item, 0, sizeof(*item));
     item->option.longName = alias.longName;
     item->option.shortName = alias.shortName;
     item->option.argInfo = POPT_ARGFLAG_DOC_HIDDEN;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/poptconfig.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/poptconfig.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/poptconfig.c	2003-01-12 03:01:31.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/poptconfig.c	2004-01-28 08:04:57.000000000 +0800
@@ -7,13 +7,13 @@
    ftp://ftp.rpm.org/pub/rpm/dist. */
 
 #include "system.h"
 #include "poptint.h"
 
 /*@-compmempass@*/	/* FIX: item->option.longName kept, not dependent. */
-static void configLine(poptContext con, char * line)
+static void configLine(poptContext con, unsigned char * line)
 	/*@modifies con @*/
 {
     /*@-type@*/
     int nameLength = strlen(con->appName);
     /*@=type@*/
     const char * entryType;
@@ -89,15 +89,15 @@
     /*@=nullstate@*/
 }
 /*@=compmempass@*/
 
 int poptReadConfigFile(poptContext con, const char * fn)
 {
-    const char * file, * chptr, * end;
-    char * buf;
-/*@dependent@*/ char * dst;
+    const unsigned char * file, * chptr, * end;
+    unsigned char * buf;
+/*@dependent@*/ unsigned char * dst;
     int fd, rc;
     off_t fileLength;
 
     fd = open(fn, O_RDONLY);
     if (fd < 0)
 	return (errno == ENOENT ? 0 : POPT_ERROR_ERRNO);
@@ -156,13 +156,14 @@
     }
     /*@=infloops@*/
 
     return 0;
 }
 
-int poptReadDefaultConfig(poptContext con, /*@unused@*/ int useEnv) {
+int poptReadDefaultConfig(poptContext con, /*@unused@*/ UNUSED(int useEnv))
+{
     char * fn, * home;
     int rc;
 
     /*@-type@*/
     if (!con->appName) return 0;
     /*@=type@*/
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/popt.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/popt.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/popt.h	2002-07-28 02:32:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/popt.h	2004-01-28 00:27:05.000000000 +0800
@@ -360,13 +360,13 @@
  * be free'd.
  *
  * @param s		string to parse
  * @retval argcPtr	address of returned no. of arguments
  * @retval argvPtr	address of returned argument array
  */
-int poptParseArgvString(const char * s,
+int poptParseArgvString(const unsigned char * s,
 		/*@out@*/ int * argcPtr, /*@out@*/ const char *** argvPtr)
 	/*@modifies *argcPtr, *argvPtr @*/;
 
 /** \ingroup popt
  * Return formatted error string for popt failure.
  * @param error		popt error
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/popthelp.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/popthelp.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/popthelp.c	2003-01-15 05:37:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/popthelp.c	2004-01-28 00:27:05.000000000 +0800
@@ -14,15 +14,15 @@
 
 /**
  * @param con		context
  * @param key		option(s)
  */
 static void displayArgs(poptContext con,
-		/*@unused@*/ enum poptCallbackReason foo,
+		/*@unused@*/ UNUSED(enum poptCallbackReason foo),
 		struct poptOption * key, 
-		/*@unused@*/ const char * arg, /*@unused@*/ void * data)
+		/*@unused@*/ UNUSED(const char * arg), /*@unused@*/ UNUSED(void * data))
 	/*@globals fileSystem@*/
 	/*@modifies fileSystem@*/
 {
     if (key->shortName == '?')
 	poptPrintHelp(con, stdout, 0);
     else
@@ -81,13 +81,13 @@
  * @param opt		option(s)
  * @param translation_domain	translation domain
  */
 /*@observer@*/ /*@null@*/ static const char *const
 getArgDescrip(const struct poptOption * opt,
 		/*@-paramuse@*/		/* FIX: wazzup? */
-		/*@null@*/ const char * translation_domain)
+		/*@null@*/ UNUSED(const char * translation_domain))
 		/*@=paramuse@*/
 	/*@*/
 {
     if (!(opt->argInfo & POPT_ARG_MASK)) return NULL;
 
     if (opt == (poptHelpOptions + 1) || opt == (poptHelpOptions + 2))
@@ -112,13 +112,13 @@
  * @param translation_domain	translation domain
  */
 static /*@only@*/ /*@null@*/ char *
 singleOptionDefaultValue(int lineLength,
 		const struct poptOption * opt,
 		/*@-paramuse@*/	/* FIX: i18n macros disable with lclint */
-		/*@null@*/ const char * translation_domain)
+		/*@null@*/ UNUSED(const char * translation_domain))
 		/*@=paramuse@*/
 	/*@*/
 {
     const char * defstr = D_(translation_domain, "default");
     char * le = malloc(4*lineLength + 1);
     char * l = le;
@@ -188,17 +188,17 @@
 		/*@null@*/ const char * translation_domain)
 	/*@globals fileSystem @*/
 	/*@modifies *fp, fileSystem @*/
 {
     int indentLength = maxLeftCol + 5;
     int lineLength = 79 - indentLength;
-    const char * help = D_(translation_domain, opt->descrip);
+    const unsigned char * help = D_(translation_domain, opt->descrip);
     const char * argDescrip = getArgDescrip(opt, translation_domain);
     int helpLength;
-    char * defs = NULL;
-    char * left;
+    unsigned char * defs = NULL;
+    unsigned char * left;
     int nb = maxLeftCol + 1;
 
     /* Make sure there's more than enough room in target buffer. */
     if (opt->longName)	nb += strlen(opt->longName);
     if (argDescrip)	nb += strlen(argDescrip);
 
@@ -311,13 +311,13 @@
     if (defs) {
 	help = defs; defs = NULL;
     }
 
     helpLength = strlen(help);
     while (helpLength > lineLength) {
-	const char * ch;
+	const unsigned char * ch;
 	char format[10];
 
 	ch = help + lineLength - 1;
 	while (ch > help && !isspace(*ch)) ch--;
 	if (ch == help) break;		/* give up */
 	while (ch > (help + 1) && isspace(*ch)) ch--;
@@ -472,13 +472,13 @@
 	len += strlen(fn) + 1;
     }
 
     return len;
 }
 
-void poptPrintHelp(poptContext con, FILE * fp, /*@unused@*/ int flags)
+void poptPrintHelp(poptContext con, FILE * fp, /*@unused@*/ UNUSED(int flags))
 {
     int leftColWidth;
 
     (void) showHelpIntro(con, fp);
     if (con->otherHelp)
 	fprintf(fp, " %s\n", con->otherHelp);
@@ -631,13 +631,13 @@
 	return 0;
 
     fprintf(fp, " [-%s]", s);
     return strlen(s) + 4;
 }
 
-void poptPrintUsage(poptContext con, FILE * fp, /*@unused@*/ int flags)
+void poptPrintUsage(poptContext con, FILE * fp, /*@unused@*/ UNUSED(int flags))
 {
     int cursor;
 
     cursor = showHelpIntro(con, fp);
     cursor += showShortOptions(con->options, fp, NULL);
     (void) singleTableUsage(con, fp, cursor, con->options, NULL);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/poptparse.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/poptparse.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/poptparse.c	2002-07-28 02:32:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/poptparse.c	2004-01-28 00:27:05.000000000 +0800
@@ -48,16 +48,16 @@
     }
     if (argcPtr)
 	*argcPtr = argc;
     return 0;
 }
 
-int poptParseArgvString(const char * s, int * argcPtr, const char *** argvPtr)
+int poptParseArgvString(const unsigned char * s, int * argcPtr, const char *** argvPtr)
 {
-    const char * src;
-    char quote = '\0';
+    const unsigned char * src;
+    unsigned char quote = '\0';
     int argvAlloced = POPT_ARGV_ARRAY_GROW_DELTA;
     const char ** argv = malloc(sizeof(*argv) * argvAlloced);
     int argc = 0;
     int buflen = strlen(s) + 1;
     char * buf = memset(alloca(buflen), 0, buflen);
     int rc = POPT_ERROR_MALLOC;
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/system.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/system.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/popt/system.h	2003-01-13 05:49:44.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/popt/system.h	2004-04-27 09:36:00.000000000 +0800
@@ -66,8 +66,9 @@
 #define	vmefail()	(fprintf(stderr, "virtual memory exhausted.\n"), exit(EXIT_FAILURE), NULL)
 #define xstrdup(_str)   (strcpy((malloc(strlen(_str)+1) ? : vmefail()), (_str)))
 #else
 #define	xstrdup(_str)	strdup(_str)
 #endif  /* HAVE_MCHECK_H && defined(__GNUC__) */
 
+#define UNUSED(x) x __attribute__((__unused__))
 
 #include "popt.h"
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/progress.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/progress.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/progress.c	2003-12-13 01:13:22.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/progress.c	2004-02-28 10:00:57.000000000 +0800
@@ -18,20 +18,29 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include "rsync.h"
 
-static OFF_T  last_ofs;
-static struct timeval print_time;
-static struct timeval start_time;
-static OFF_T  start_ofs;
+extern struct stats stats;
+extern int am_server;
+
+#define PROGRESS_HISTORY_SECS 5
+
+struct progress_history {
+	struct timeval time;
+	OFF_T ofs;
+};
+
+static struct progress_history ph_start;
+static struct progress_history ph_list[PROGRESS_HISTORY_SECS];
+static int newest_hpos, oldest_hpos;
 
 static unsigned long msdiff(struct timeval *t1, struct timeval *t2)
 {
-	return (t2->tv_sec - t1->tv_sec) * 1000
+	return (t2->tv_sec - t1->tv_sec) * 1000L
 	     + (t2->tv_usec - t1->tv_usec) / 1000;
 }
 
 
 /**
  * @param ofs Current position in file
@@ -40,25 +49,35 @@
  * printed for this file, so we should output a newline.  (Not
  * necessarily the same as all bytes being received.)
  **/
 static void rprint_progress(OFF_T ofs, OFF_T size, struct timeval *now,
 			    int is_last)
 {
-	int pct = (ofs == size) ? 100 : (int)((100.0*ofs)/size);
-	unsigned long diff = msdiff(&start_time, now);
-	double rate = diff ? (double) (ofs-start_ofs) * 1000.0 / diff / 1024.0 : 0;
+	char eol[256];
 	const char *units;
-	/* If we've finished transferring this file, show the time taken;
-	 * otherwise show expected time to complete.  That's kind of
-	 * inconsistent, but people can probably cope.  Hopefully we'll
-	 * get more consistent and complete progress reporting soon. --
-	 * mbp */
-	double remain = is_last ? (double) diff / 1000.0
-	              : rate ? (double) (size-ofs) / rate / 1000.0 : 0.0;
+	int pct = ofs == size ? 100 : (int) (100.0 * ofs / size);
+	unsigned long diff;
+	double rate, remain;
 	int remain_h, remain_m, remain_s;
 
+	if (is_last) {
+		/* Compute stats based on the starting info. */
+		diff = msdiff(&ph_start.time, now);
+		if (!diff)
+			diff = 1;
+		rate = (double) (ofs - ph_start.ofs) * 1000.0 / diff / 1024.0;
+		/* Switch to total time taken for our last update. */
+		remain = (double) diff / 1000.0;
+	} else {
+		/* Compute stats based on recent progress. */
+		diff = msdiff(&ph_list[oldest_hpos].time, now);
+		rate = diff ? (double) (ofs - ph_list[oldest_hpos].ofs) * 1000.0
+		    / diff / 1024.0 : 0;
+		remain = rate ? (double) (size - ofs) / rate / 1000.0 : 0.0;
+	}
+
 	if (rate > 1024*1024) {
 		rate /= 1024.0 * 1024.0;
 		units = "GB/s";
 	} else if (rate > 1024) {
 		rate /= 1024.0;
 		units = "MB/s";
@@ -67,53 +86,69 @@
 	}
 
 	remain_s = (int) remain % 60;
 	remain_m = (int) (remain / 60.0) % 60;
 	remain_h = (int) (remain / 3600.0);
 
+	if (is_last) {
+		snprintf(eol, sizeof eol, "  (%d, %.1f%% of %d)\n",
+			stats.num_transferred_files,
+			(float)((stats.current_file_index+1) * 100)
+				/ stats.num_files,
+			stats.num_files);
+	} else
+		strcpy(eol, "\r");
 	rprintf(FINFO, "%12.0f %3d%% %7.2f%s %4d:%02d:%02d%s",
 		(double) ofs, pct, rate, units,
-		remain_h, remain_m, remain_s,
-		is_last ? "\n" : "\r");
+		remain_h, remain_m, remain_s, eol);
 }
 
 void end_progress(OFF_T size)
 {
-	extern int am_server;
-
 	if (!am_server) {
 		struct timeval now;
 		gettimeofday(&now, NULL);
 		rprint_progress(size, size, &now, True);
 	}
-	last_ofs = 0;
-	start_ofs = 0;
-	print_time.tv_sec = print_time.tv_usec = 0;
-	start_time.tv_sec = start_time.tv_usec = 0;
+	memset(&ph_start, 0, sizeof ph_start);
 }
 
 void show_progress(OFF_T ofs, OFF_T size)
 {
-	extern int am_server;
 	struct timeval now;
 
-	if (!start_time.tv_sec) {
-		gettimeofday(&now, NULL);
-		start_time.tv_sec = now.tv_sec;
-		start_time.tv_usec = now.tv_usec;
-		start_ofs = ofs;
-		if (am_server)
-			return;
+	if (am_server)
+		return;
+
+	gettimeofday(&now, NULL);
+
+	if (!ph_start.time.tv_sec) {
+		int i;
+
+		/* Try to guess the real starting time when the sender started
+		 * to send us data by using the time we last received some data
+		 * in the last file (if it was recent enough). */
+		if (msdiff(&ph_list[newest_hpos].time, &now) <= 1500) {
+			ph_start.time = ph_list[newest_hpos].time;
+			ph_start.ofs = 0;
+		} else {
+			ph_start.time.tv_sec = now.tv_sec;
+			ph_start.time.tv_usec = now.tv_usec;
+			ph_start.ofs = ofs;
+		}
+
+		for (i = 0; i < PROGRESS_HISTORY_SECS; i++)
+			ph_list[i] = ph_start;
 	}
 	else {
-		if (am_server)
+		if (msdiff(&ph_list[newest_hpos].time, &now) < 1000)
 			return;
-		gettimeofday(&now, NULL);
-	}
 
-	if (ofs > last_ofs + 1000 && msdiff(&print_time, &now) > 250) {
-		rprint_progress(ofs, size, &now, False);
-		last_ofs = ofs;
-		print_time.tv_sec = now.tv_sec;
-		print_time.tv_usec = now.tv_usec;
+		newest_hpos = oldest_hpos;
+		oldest_hpos = (oldest_hpos + 1) % PROGRESS_HISTORY_SECS;
+		ph_list[newest_hpos].time.tv_sec = now.tv_sec;
+		ph_list[newest_hpos].time.tv_usec = now.tv_usec;
+		ph_list[newest_hpos].ofs = ofs;
 	}
+
+	rprint_progress(ofs, size, &now, False);
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/proto.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/proto.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/proto.h	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/proto.h	2004-04-22 17:58:09.000000000 +0800
@@ -1,24 +1,19 @@
 /* This file is automatically generated with "make proto". DO NOT EDIT */
 
 int allow_access(char *addr, char *host, char *allow_list, char *deny_list);
+void base64_encode(char *buf, int len, char *out);
 char *auth_server(int f_in, int f_out, int module, char *addr, char *leader);
 void auth_client(int fd, char *user, char *challenge);
 int make_backup(char *fname);
-void write_batch_flist_file(char *buff, int bytes_to_write);
-void write_batch_flist_info(int flist_count, struct file_struct **fptr);
-void write_char_bufs(char *buf);
+void write_batch_flist_info(int flist_count, struct file_struct **files);
 void write_batch_argvs_file(int argc, char *argv[]);
 struct file_list *create_flist_from_batch(void);
-int read_batch_flist_file(char *buff, int len);
-unsigned char read_batch_flags(void);
-void read_batch_flist_info(struct file_struct **fptr);
 void write_batch_csums_file(void *buff, int bytes_to_write);
 void close_batch_csums_file(void);
-void write_batch_csum_info(int *flist_entry, int flist_count,
-			   struct sum_struct *s);
+void write_batch_csum_info(int *flist_entry, struct sum_struct *s);
 int read_batch_csums_file(char *buff, int len);
 void read_batch_csum_info(int flist_entry, struct sum_struct *s,
 			  int *checksums_match);
 void write_batch_delta_file(char *buff, int bytes_to_write);
 void close_batch_delta_file(void);
 int read_batch_delta_file(char *buff, int len);
@@ -32,13 +27,13 @@
 void sum_end(char *sum);
 void close_all(void);
 void _exit_cleanup(int code, const char *file, int line);
 void cleanup_disable(void);
 void cleanup_set(char *fnametmp, char *fname, struct file_struct *file,
 		 struct map_struct *buf, int fd1, int fd2);
-void cleanup_set_pid(int pid);
+void cleanup_set_pid(pid_t pid);
 char *client_addr(int fd);
 char *client_name(int fd);
 void client_sockaddr(int fd,
 		     struct sockaddr_storage *ss,
 		     socklen_t *ss_len);
 int lookup_name(int fd, const struct sockaddr_storage *ss,
@@ -53,76 +48,88 @@
 int start_socket_client(char *host, char *path, int argc, char *argv[]);
 int start_inband_exchange(char *user, char *path, int f_in, int f_out, int argc);
 int start_daemon(int f_in, int f_out);
 int daemon_main(void);
 void setup_protocol(int f_out,int f_in);
 int claim_connection(char *fname,int max_connections);
-void free_exclude_list(struct exclude_struct ***listp);
-int check_exclude(struct exclude_struct **list, char *name, int name_is_dir);
-void add_exclude(struct exclude_struct ***listp, const char *pattern, int include);
-void add_exclude_file(struct exclude_struct ***listp, const char *fname,
-		      int fatal, int include);
+void free_exclude_list(struct exclude_list_struct *listp);
+int check_exclude(struct exclude_list_struct *listp, char *name, int name_is_dir);
+void add_exclude(struct exclude_list_struct *listp, const char *pattern,
+		 int xflags);
+void add_exclude_file(struct exclude_list_struct *listp, const char *fname,
+		      int xflags);
 void send_exclude_list(int f);
 void recv_exclude_list(int f);
-char *get_exclude_tok(char *p);
-void add_exclude_line(struct exclude_struct ***listp,
-		      const char *line, int include);
 void add_cvs_excludes(void);
 int sparse_end(int f);
+int flush_write_file(int f);
 int write_file(int f,char *buf,size_t len);
 struct map_struct *map_file(int fd,OFF_T len);
 char *map_ptr(struct map_struct *map,OFF_T offset,int len);
 int unmap_file(struct map_struct *map);
+void init_flist(void);
 void show_flist_stats(void);
-int readlink_stat(const char *path, STRUCT_STAT * buffer, char *linkbuf);
+int readlink_stat(const char *path, STRUCT_STAT *buffer, char *linkbuf);
 int link_stat(const char *path, STRUCT_STAT * buffer);
-struct file_struct *make_file(char *fname, struct string_area **ap,
-			      int exclude_level);
+void flist_expand(struct file_list *flist);
+void send_file_entry(struct file_struct *file, int f, unsigned short base_flags);
+void receive_file_entry(struct file_struct **fptr, unsigned short flags,
+    struct file_list *flist, int f);
+struct file_struct *make_file(char *fname,
+    struct file_list *flist, int exclude_level);
 void send_file_name(int f, struct file_list *flist, char *fname,
-		    int recursive, unsigned base_flags);
+		    int recursive, unsigned short base_flags);
 struct file_list *send_file_list(int f, int argc, char *argv[]);
 struct file_list *recv_file_list(int f);
-int file_compare(struct file_struct **f1, struct file_struct **f2);
+int file_compare(struct file_struct **file1, struct file_struct **file2);
 int flist_find(struct file_list *flist, struct file_struct *f);
-void free_file(struct file_struct *file);
-struct file_list *flist_new(void);
+void clear_file(int i, struct file_list *flist);
+struct file_list *flist_new(int with_hlink, char *msg);
 void flist_free(struct file_list *flist);
+int f_name_cmp(struct file_struct *f1, struct file_struct *f2);
+char *f_name_to(struct file_struct *f, char *fbuf);
 char *f_name(struct file_struct *f);
 void write_sum_head(int f, struct sum_struct *sum);
-void recv_generator(char *fname, struct file_list *flist, int i, int f_out);
-void generate_files(int f,struct file_list *flist,char *local_name,int f_recv);
+void recv_generator(char *fname, struct file_struct *file, int i, int f_out);
+void generate_files(int f, struct file_list *flist, char *local_name);
 void init_hard_links(struct file_list *flist);
-int check_hard_link(struct file_struct *file);
+int hard_link_check(struct file_struct *file, int skip);
 void do_hard_links(void);
-void io_set_error_fd(int fd);
+void set_msg_fd_in(int fd);
+void set_msg_fd_out(int fd);
+void send_msg(enum msgcode code, char *buf, int len);
+int msg_list_push(int flush_it_all);
+int get_redo_num(void);
 void io_set_filesfrom_fds(int f_in, int f_out);
 int read_filesfrom_line(int fd, char *fname);
 int32 read_int(int f);
 int64 read_longint(int f);
 void read_buf(int f,char *buf,size_t len);
 void read_sbuf(int f,char *buf,size_t len);
 unsigned char read_byte(int f);
-void io_start_buffering(int fd);
-void io_flush(void);
+void io_start_buffering_out(int fd);
+void io_start_buffering_in(int fd);
+void io_flush(int flush_it_all);
 void io_end_buffering(void);
 void write_int(int f,int32 x);
 void write_int_named(int f, int32 x, const char *phase);
 void write_longint(int f, int64 x);
 void write_buf(int f,char *buf,size_t len);
 void write_byte(int f,unsigned char c);
 int read_line(int f, char *buf, size_t maxlen);
 void io_printf(int fd, const char *format, ...);
 void io_start_multiplex_out(int fd);
 void io_start_multiplex_in(int fd);
-int io_multiplex_write(enum logcode code, char *buf, size_t len);
+int io_multiplex_write(enum msgcode code, char *buf, size_t len);
 void io_multiplexing_close(void);
 char *lp_motd_file(void);
 char *lp_log_file(void);
 char *lp_pid_file(void);
 char *lp_socket_options(void);
 int lp_syslog_facility(void);
+int lp_max_verbosity(void);
 char *lp_name(int );
 char *lp_comment(int );
 char *lp_path(int );
 char *lp_lock_file(int );
 BOOL lp_read_only(int );
 BOOL lp_list(int );
@@ -146,28 +153,27 @@
 char *lp_dont_compress(int );
 int lp_timeout(int );
 int lp_max_connections(int );
 BOOL lp_load(char *pszFname, int globals_only);
 int lp_numservices(void);
 int lp_number(char *name);
-void err_list_push(void);
 void log_init(void);
 void log_open(void);
 void log_close(void);
-void set_error_fd(int fd);
 void rwrite(enum logcode code, char *buf, int len);
 void rprintf(enum logcode code, const char *format, ...);
 void rsyserr(enum logcode code, int errcode, const char *format, ...);
 void rflush(enum logcode code);
 void log_send(struct file_struct *file, struct stats *initial_stats);
 void log_recv(struct file_struct *file, struct stats *initial_stats);
 void log_exit(int code, const char *file, int line);
 void wait_process(pid_t pid, int *status);
 int child_main(int argc, char *argv[]);
 void start_server(int f_in, int f_out, int argc, char *argv[]);
 int client_run(int f_in, int f_out, pid_t pid, int argc, char *argv[]);
+const char *get_panic_action(void);
 int main(int argc,char *argv[]);
 void match_sums(int f, struct sum_struct *s, struct map_struct *buf, OFF_T len);
 void match_report(void);
 void usage(enum logcode F);
 void option_error(void);
 int parse_arguments(int *argc, const char ***argv, int frommain);
@@ -179,30 +185,28 @@
 pid_t piped_child(char **command, int *f_in, int *f_out);
 pid_t local_child(int argc, char **argv,int *f_in,int *f_out,
 		  int (*child_main)(int, char*[]));
 void end_progress(OFF_T size);
 void show_progress(OFF_T ofs, OFF_T size);
 void delete_files(struct file_list *flist);
-int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen);
+int recv_files(int f_in,struct file_list *flist,char *local_name);
 void free_sums(struct sum_struct *s);
 int delete_file(char *fname);
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
 		int report);
 void sig_int(void);
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file);
+const char *who_am_i(void);
 void read_sum_head(int f, struct sum_struct *sum);
 void send_files(struct file_list *flist, int f_out, int f_in);
-int try_bind_local(int s,
-		   int ai_family, int ai_socktype,
+int try_bind_local(int s, int ai_family, int ai_socktype,
 		   const char *bind_address);
 int open_socket_out(char *host, int port, const char *bind_address,
 		    int af_hint);
-int open_socket_out_wrapped (char *host,
-			     int port,
-			     const char *bind_address,
-			     int af_hint);
+int open_socket_out_wrapped(char *host, int port, const char *bind_address,
+			    int af_hint);
 int is_a_socket(int fd);
 void start_accept_loop(int port, int (*fn)(int, int));
 void set_socket_options(int fd, char *options);
 void become_daemon(void);
 int sock_exec(const char *prog);
 int do_unlink(char *fname);
@@ -239,23 +243,26 @@
 void out_of_memory(char *str);
 void overflow(char *str);
 int set_modtime(char *fname, time_t modtime);
 int create_directory_path(char *fname, int base_umask);
 int copy_file(char *source, char *dest, mode_t mode);
 int robust_unlink(char *fname);
-int robust_rename(char *from, char *to);
+int robust_rename(char *from, char *to, int mode);
 pid_t do_fork(void);
 void kill_all(int sig);
 int name_to_uid(char *name, uid_t *uid);
 int name_to_gid(char *name, gid_t *gid);
 int lock_range(int fd, int offset, int len);
 void glob_expand(char *base1, char **argv, int *argc, int maxargs);
 void strlower(char *s);
+size_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2);
+size_t stringjoin(char *dest, size_t destsize, ...);
 void clean_fname(char *name);
 void sanitize_path(char *p, char *reldir);
-char *push_dir(char *dir, int save);
+char *alloc_sanitize_path(const char *path, const char *rootdir);
+int push_dir(char *dir);
 int pop_dir(char *dir);
 char *full_fname(char *fn);
 int u_strcmp(const char *cs1, const char *cs2);
 int unsafe_symlink(const char *dest, const char *src);
 char *timestring(time_t t);
 int msleep(int t);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/receiver.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/receiver.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/receiver.c	2003-12-15 16:14:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/receiver.c	2004-03-24 00:50:40.000000000 +0800
@@ -20,71 +20,34 @@
 
 #include "rsync.h"
 
 extern int verbose;
 extern int recurse;
 extern int delete_mode;
-extern int protocol_version;
+extern int delete_after;
+extern int max_delete;
 extern int csum_length;
 extern struct stats stats;
 extern int dry_run;
 extern int am_server;
 extern int relative_paths;
 extern int preserve_hard_links;
+extern int preserve_perms;
 extern int cvs_exclude;
 extern int io_error;
 extern char *tmpdir;
 extern char *compare_dest;
 extern int make_backups;
 extern int do_progress;
 extern char *backup_dir;
 extern char *backup_suffix;
 extern int backup_suffix_len;
-
-static struct delete_list {
-	DEV64_T dev;
-	INO64_T inode;
-} *delete_list;
-static int dlist_len, dlist_alloc_len;
-
-/* yuck! This function wouldn't have been necessary if I had the sorting
- * algorithm right. Unfortunately fixing the sorting algorithm would introduce
- * a backward incompatibility as file list indexes are sent over the link.
- */
-static int delete_already_done(struct file_list *flist,int j)
-{
-	int i;
-	STRUCT_STAT st;
-
-	if (link_stat(f_name(flist->files[j]), &st)) return 1;
-
-	for (i = 0; i < dlist_len; i++) {
-		if (st.st_ino == delete_list[i].inode &&
-		    (DEV64_T)st.st_dev == delete_list[i].dev)
-			return 1;
-	}
-
-	return 0;
-}
-
-static void add_delete_entry(struct file_struct *file)
-{
-	if (dlist_len == dlist_alloc_len) {
-		dlist_alloc_len += 1024;
-		delete_list = realloc_array(delete_list, struct delete_list,
-					    dlist_alloc_len);
-		if (!delete_list) out_of_memory("add_delete_entry");
-	}
-
-	delete_list[dlist_len].dev = file->dev;
-	delete_list[dlist_len].inode = file->inode;
-	dlist_len++;
-
-	if (verbose > 3)
-		rprintf(FINFO,"added %s to delete list\n", f_name(file));
-}
+extern int cleanup_got_literal;
+extern int module_id;
+extern int ignore_errors;
+extern int orig_umask;
 
 static void delete_one(char *fn, int is_dir)
 {
 	if (!is_dir) {
 		if (robust_unlink(fn) != 0) {
 			rprintf(FERROR, "delete_one: unlink %s failed: %s\n",
@@ -109,57 +72,48 @@
 {
 	int k = strlen(fn) - backup_suffix_len;
 	return k > 0 && strcmp(fn+k, backup_suffix) == 0;
 }
 
 
-/* this deletes any files on the receiving side that are not present
- * on the sending side. For version 1.6.4 I have changed the behaviour
- * to match more closely what most people seem to expect of this option */
+/* This deletes any files on the receiving side that are not present
+ * on the sending side. */
 void delete_files(struct file_list *flist)
 {
 	struct file_list *local_file_list;
 	int i, j;
-	char *name;
-	extern int module_id;
-	extern int ignore_errors;
-	extern int max_delete;
+	char *argv[1], fbuf[MAXPATHLEN];
 	static int deletion_count;
 
 	if (cvs_exclude)
 		add_cvs_excludes();
 
 	if (io_error && !(lp_ignore_errors(module_id) || ignore_errors)) {
 		rprintf(FINFO,"IO error encountered - skipping file deletion\n");
 		return;
 	}
 
-	for (j=0;j<flist->count;j++) {
-		if (!S_ISDIR(flist->files[j]->mode) ||
-		    !(flist->files[j]->flags & FLAG_DELETE)) continue;
-
-		if (protocol_version < 19 &&
-		    delete_already_done(flist, j)) continue;
+	for (j = 0; j < flist->count; j++) {
+		if (!(flist->files[j]->flags & FLAG_TOP_DIR)
+		    || !S_ISDIR(flist->files[j]->mode))
+			continue;
 
-		name = strdup(f_name(flist->files[j]));
+		argv[0] = f_name_to(flist->files[j], fbuf);
 
-		if (!(local_file_list = send_file_list(-1,1,&name))) {
-			free(name);
+		if (!(local_file_list = send_file_list(-1, 1, argv)))
 			continue;
-		}
 
 		if (verbose > 1)
-			rprintf(FINFO,"deleting in %s\n", name);
+			rprintf(FINFO, "deleting in %s\n", fbuf);
 
-		for (i=local_file_list->count-1;i>=0;i--) {
-			if (max_delete && deletion_count > max_delete) break;
-			if (!local_file_list->files[i]->basename) continue;
-			if (protocol_version < 19 &&
-			    S_ISDIR(local_file_list->files[i]->mode))
-				add_delete_entry(local_file_list->files[i]);
-			if (-1 == flist_find(flist,local_file_list->files[i])) {
+		for (i = local_file_list->count-1; i >= 0; i--) {
+			if (max_delete && deletion_count > max_delete)
+				break;
+			if (!local_file_list->files[i]->basename)
+				continue;
+			if (flist_find(flist,local_file_list->files[i]) < 0) {
 				char *f = f_name(local_file_list->files[i]);
 				if (make_backups && (backup_dir || !is_backup_file(f))) {
 					(void) make_backup(f);
 					if (verbose)
 						rprintf(FINFO, "deleting %s\n", f);
 				} else {
@@ -167,13 +121,12 @@
 					delete_one(f, S_ISDIR(mode) != 0);
 				}
 				deletion_count++;
 			}
 		}
 		flist_free(local_file_list);
-		free(name);
 	}
 }
 
 
 /*
  * get_tmpname() - create a tmp filename for a given filename
@@ -200,28 +153,27 @@
 {
 	char *f;
 	int     length = 0;
 	int	maxname;
 
 	if (tmpdir) {
-		strlcpy(fnametmp, tmpdir, MAXPATHLEN - 2);
-		length = strlen(fnametmp);
+		/* Note: this can't overflow, so the return value is safe */
+		length = strlcpy(fnametmp, tmpdir, MAXPATHLEN - 2);
 		fnametmp[length++] = '/';
 		fnametmp[length] = '\0';	/* always NULL terminated */
 	}
 
 	if ((f = strrchr(fname, '/')) != NULL) {
 		++f;
 		if (!tmpdir) {
 			length = f - fname;
 			/* copy up to and including the slash */
 			strlcpy(fnametmp, fname, length + 1);
 		}
-	} else {
+	} else
 		f = fname;
-	}
 	fnametmp[length++] = '.';
 	fnametmp[length] = '\0';		/* always NULL terminated */
 
 	maxname = MIN(MAXPATHLEN - 7 - length, NAME_MAX - 8);
 
 	if (maxname < 1) {
@@ -234,13 +186,13 @@
 	strcat(fnametmp + length, ".XXXXXX");
 
 	return 1;
 }
 
 
-static int receive_data(int f_in,struct map_struct *buf,int fd,char *fname,
+static int receive_data(int f_in,struct map_struct *mapbuf,int fd,char *fname,
 			OFF_T total_size)
 {
 	int i;
 	struct sum_struct sum;
 	unsigned int len;
 	OFF_T offset = 0;
@@ -251,19 +203,17 @@
 	char *map=NULL;
 
 	read_sum_head(f_in, &sum);
 
 	sum_init();
 
-	for (i=recv_token(f_in,&data); i != 0; i=recv_token(f_in,&data)) {
+	while ((i = recv_token(f_in, &data)) != 0) {
 		if (do_progress)
 			show_progress(offset, total_size);
 
 		if (i > 0) {
-			extern int cleanup_got_literal;
-
 			if (verbose > 3) {
 				rprintf(FINFO,"data recv %d at %.0f\n",
 					i,(double)offset);
 			}
 
 			stats.literal_data += i;
@@ -289,14 +239,14 @@
 		stats.matched_data += len;
 
 		if (verbose > 3)
 			rprintf(FINFO,"chunk[%d] of size %d at %.0f offset=%.0f\n",
 				i,len,(double)offset2,(double)offset);
 
-		if (buf) {
-			map = map_ptr(buf,offset2,len);
+		if (mapbuf) {
+			map = map_ptr(mapbuf,offset2,len);
 
 			see_token(map, len);
 			sum_update(map,len);
 		}
 
 		if (fd != -1 && write_file(fd,map,len) != (int) len) {
@@ -304,12 +254,14 @@
 				full_fname(fname), strerror(errno));
 			exit_cleanup(RERR_FILEIO);
 		}
 		offset += len;
 	}
 
+	flush_write_file(fd);
+
 	if (do_progress)
 		end_progress(total_size);
 
 	if (fd != -1 && offset > 0 && sparse_end(fd) != 0) {
 		rprintf(FERROR, "write failed on %s: %s\n",
 			full_fname(fname), strerror(errno));
@@ -330,66 +282,70 @@
 
 
 /**
  * main routine for receiver process.
  *
  * Receiver process runs on the same host as the generator process. */
-int recv_files(int f_in,struct file_list *flist,char *local_name,int f_gen)
+int recv_files(int f_in,struct file_list *flist,char *local_name)
 {
 	int fd1,fd2;
 	STRUCT_STAT st;
-	char *fname;
+	char *fname, fbuf[MAXPATHLEN];
 	char template[MAXPATHLEN];
 	char fnametmp[MAXPATHLEN];
 	char *fnamecmp;
 	char fnamecmpbuf[MAXPATHLEN];
-	struct map_struct *buf;
+	struct map_struct *mapbuf;
 	int i;
 	struct file_struct *file;
 	int phase=0;
 	int recv_ok;
-	extern struct stats stats;
-	extern int preserve_perms;
-	extern int delete_after;
-	extern int orig_umask;
 	struct stats initial_stats;
 
 	if (verbose > 2) {
 		rprintf(FINFO,"recv_files(%d) starting\n",flist->count);
 	}
 
+	if (flist->hlink_pool) {
+		pool_destroy(flist->hlink_pool);
+		flist->hlink_pool = NULL;
+	}
+
 	while (1) {
 		cleanup_disable();
 
 		i = read_int(f_in);
 		if (i == -1) {
-			if (phase==0) {
+			if (phase == 0) {
 				phase++;
 				csum_length = SUM_LENGTH;
 				if (verbose > 2)
 					rprintf(FINFO,"recv_files phase=%d\n",phase);
-				write_int(f_gen,-1);
+				send_msg(MSG_DONE, "", 0);
 				continue;
 			}
 			break;
 		}
 
 		if (i < 0 || i >= flist->count) {
 			rprintf(FERROR,"Invalid file index %d in recv_files (count=%d)\n",
 				i, flist->count);
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		file = flist->files[i];
-		fname = f_name(file);
 
+		stats.current_file_index = i;
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
+		cleanup_got_literal = 0;
 
 		if (local_name)
 			fname = local_name;
+		else
+			fname = f_name_to(file, fbuf);
 
 		if (dry_run) {
 			if (!am_server && verbose) {	/* log transfer */
 				rprintf(FINFO, "%s\n", fname);
 			}
 			continue;
@@ -402,16 +358,16 @@
 
 		fnamecmp = fname;
 
 		/* open the file */
 		fd1 = do_open(fnamecmp, O_RDONLY, 0);
 
-		if ((fd1 == -1) && (compare_dest != NULL)) {
+		if (fd1 == -1 && compare_dest != NULL) {
 			/* try the file at compare_dest instead */
-			snprintf(fnamecmpbuf,MAXPATHLEN,"%s/%s",
-						compare_dest,fname);
+			pathjoin(fnamecmpbuf, sizeof fnamecmpbuf,
+				 compare_dest, fname);
 			fnamecmp = fnamecmpbuf;
 			fd1 = do_open(fnamecmp, O_RDONLY, 0);
 		}
 
 		if (fd1 != -1 && do_fstat(fd1,&st) != 0) {
 			rprintf(FERROR, "fstat %s failed: %s\n",
@@ -434,37 +390,36 @@
 			continue;
 		}
 
 		if (fd1 != -1 && !S_ISREG(st.st_mode)) {
 			close(fd1);
 			fd1 = -1;
-			buf = NULL;
+			mapbuf = NULL;
 		}
 
 		if (fd1 != -1 && !preserve_perms) {
 			/* if the file exists already and we aren't preserving
 			 * permissions then act as though the remote end sent
 			 * us the file permissions we already have */
 			file->mode = st.st_mode;
 		}
 
 		if (fd1 != -1 && st.st_size > 0) {
-			buf = map_file(fd1,st.st_size);
+			mapbuf = map_file(fd1,st.st_size);
 			if (verbose > 2)
 				rprintf(FINFO,"recv mapped %s of size %.0f\n",fnamecmp,(double)st.st_size);
-		} else {
-			buf = NULL;
-		}
+		} else
+			mapbuf = NULL;
 
 		if (!get_tmpname(fnametmp,fname)) {
-			if (buf) unmap_file(buf);
+			if (mapbuf) unmap_file(mapbuf);
 			if (fd1 != -1) close(fd1);
 			continue;
 		}
 
-		strlcpy(template, fnametmp, sizeof(template));
+		strlcpy(template, fnametmp, sizeof template);
 
 		/* we initially set the perms without the
 		 * setuid/setgid bits to ensure that there is no race
 		 * condition. They are then correctly updated after
 		 * the lchown. Thanks to snabb@epipe.fi for pointing
 		 * this out.  We also set it initially without group
@@ -473,36 +428,36 @@
 
 		/* in most cases parent directories will already exist
 		 * because their information should have been previously
 		 * transferred, but that may not be the case with -R */
 		if (fd2 == -1 && relative_paths && errno == ENOENT &&
 		    create_directory_path(fnametmp, orig_umask) == 0) {
-			strlcpy(fnametmp, template, sizeof(fnametmp));
+			strlcpy(fnametmp, template, sizeof fnametmp);
 			fd2 = do_mkstemp(fnametmp, file->mode & INITACCESSPERMS);
 		}
 		if (fd2 == -1) {
 			rprintf(FERROR, "mkstemp %s failed: %s\n",
 				full_fname(fnametmp), strerror(errno));
-			receive_data(f_in,buf,-1,NULL,file->length);
-			if (buf) unmap_file(buf);
+			receive_data(f_in,mapbuf,-1,NULL,file->length);
+			if (mapbuf) unmap_file(mapbuf);
 			if (fd1 != -1) close(fd1);
 			continue;
 		}
 
-		cleanup_set(fnametmp, fname, file, buf, fd1, fd2);
+		cleanup_set(fnametmp, fname, file, mapbuf, fd1, fd2);
 
 		if (!am_server && verbose) {	/* log transfer */
 			rprintf(FINFO, "%s\n", fname);
 		}
 
 		/* recv file data */
-		recv_ok = receive_data(f_in,buf,fd2,fname,file->length);
+		recv_ok = receive_data(f_in,mapbuf,fd2,fname,file->length);
 
 		log_recv(file, &initial_stats);
 
-		if (buf) unmap_file(buf);
+		if (mapbuf) unmap_file(mapbuf);
 		if (fd1 != -1) {
 			close(fd1);
 		}
 		close(fd2);
 
 		if (verbose > 2)
@@ -514,35 +469,24 @@
 
 		if (!recv_ok) {
 			if (csum_length == SUM_LENGTH) {
 				rprintf(FERROR,"ERROR: file corruption in %s. File changed during transfer?\n",
 					full_fname(fname));
 			} else {
+				char buf[4];
 				if (verbose > 1)
 					rprintf(FINFO,"redoing %s(%d)\n",fname,i);
-				write_int(f_gen,i);
+				SIVAL(buf, 0, i);
+				send_msg(MSG_REDO, buf, 4);
 			}
 		}
 	}
 
-	if (delete_after) {
-		if (recurse && delete_mode && !local_name && flist->count>0) {
-			delete_files(flist);
-		}
-	}
-
-	if (preserve_hard_links)
-		do_hard_links();
-
-	/* now we need to fix any directory permissions that were
-	 * modified during the transfer */
-	for (i = 0; i < flist->count; i++) {
-		file = flist->files[i];
-		if (!file->basename || !S_ISDIR(file->mode)) continue;
-		recv_generator(local_name?local_name:f_name(file),flist,i,-1);
-	}
+	if (delete_after && recurse && delete_mode && !local_name
+	    && flist->count > 0)
+		delete_files(flist);
 
 	if (verbose > 2)
 		rprintf(FINFO,"recv_files finished\n");
 
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.1 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.1
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.1	2004-01-02 03:00:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.1	2004-04-27 11:54:11.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsync" "1" "1 Jan 2004" "" "" 
+.TH "rsync" "1" "26 Apr 2004" "" "" 
 .SH "NAME" 
 rsync \- faster, flexible replacement for rcp
 .SH "SYNOPSIS" 
 .PP 
 rsync [OPTION]\&.\&.\&. SRC [SRC]\&.\&.\&. [USER@]HOST:DEST
 .PP 
@@ -66,18 +66,18 @@
 using a remote shell program\&. This is invoked when the source
 contains a : separator\&.
 .IP 
 .IP o 
 for copying from a remote rsync server to the local
 machine\&. This is invoked when the source path contains a ::
-separator or a rsync:// URL\&.
+separator or an rsync:// URL\&.
 .IP 
 .IP o 
 for copying from the local machine to a remote rsync
 server\&. This is invoked when the destination path contains a ::
-separator or a rsync:// URL\&.
+separator or an rsync:// URL\&.
 .IP 
 .IP o 
 for copying from a remote machine using a remote shell
 program as the transport, using rsync server on the remote
 machine\&.  This is invoked when the source path contains a ::
 separator and the --rsh=COMMAND (aka "-e COMMAND") option is
@@ -85,13 +85,13 @@
 .IP 
 .IP o 
 for copying from the local machine to a remote machine
 using a remote shell program as the transport, using rsync
 server on the remote machine\&.  This is invoked when the
 destination path contains a :: separator and the
---rsh=COMMMAND option is also provided\&.
+--rsh=COMMAND option is also provided\&.
 .IP 
 .IP o 
 for listing files on a remote machine\&. This is done the
 same way as rsync transfers except that you leave off the
 local destination\&.  
 .PP 
@@ -119,13 +119,13 @@
 .PP 
 .SH "USAGE" 
 .PP 
 You use rsync in the same way you use rcp\&. You must specify a source
 and a destination, one of which may be remote\&.
 .PP 
-Perhaps the best way to explain the syntax is some examples:
+Perhaps the best way to explain the syntax is with some examples:
 .PP 
 .RS 
 rsync *\&.c foo:src/
 .RE 
 .PP 
 This would transfer all files matching the pattern *\&.c from the
@@ -138,13 +138,13 @@
 rsync -avz foo:src/bar /data/tmp
 .RE 
 .PP 
 This would recursively transfer all files from the directory src/bar on the
 machine foo into the /data/tmp/bar directory on the local machine\&. The
 files are transferred in "archive" mode, which ensures that symbolic
-links, devices, attributes, permissions, ownerships etc are preserved
+links, devices, attributes, permissions, ownerships, etc\&. are preserved
 in the transfer\&.  Additionally, compression will be used to reduce the
 size of data portions of the transfer\&.
 .PP 
 .RS 
 rsync -avz foo:src/bar/ /data/tmp
 .RE 
@@ -181,21 +181,21 @@
 It is also possible to use rsync without a remote shell as the
 transport\&. In this case you will connect to a remote rsync server
 running on TCP port 873\&. 
 .PP 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
-your web proxy\&.  Note that your web proxy\&'s configuration must allow
-proxying to port 873\&.
+your web proxy\&.  Note that your web proxy\&'s configuration must support
+proxy connections to port 873\&.
 .PP 
 Using rsync in this way is the same as using it with a remote shell except
 that:
 .PP 
 .IP o 
 you use a double colon :: instead of a single colon to
-separate the hostname from the path or a rsync:// URL\&.
+separate the hostname from the path or an rsync:// URL\&.
 .IP 
 .IP o 
 the remote server may print a message of the day when you
 connect\&.
 .IP 
 .IP o 
@@ -240,13 +240,13 @@
 .PP 
 The "ssh-user" will be used at the ssh level; the "rsync-user" will be
 used to check against the rsyncd\&.conf on the remote host\&.
 .PP 
 .SH "RUNNING AN RSYNC SERVER" 
 .PP 
-An rsync server is configured using a config file\&.  Please see the 
+An rsync server is configured using a configuration file\&.  Please see the 
 rsyncd\&.conf(5) man page for more information\&.  By default the configuration
 file is called /etc/rsyncd\&.conf, unless rsync is running over a remote
 shell program and is not running as root; in that case, the default name
 is rsyncd\&.conf in the current directory on the remote computer 
 (typically $HOME)\&.
 .PP 
@@ -324,15 +324,15 @@
      --no-implied-dirs       don\&'t send implied dirs with -R
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir            make backups into this directory
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                update only (don\&'t overwrite newer files)
  -l, --links                 copy symlinks as symlinks
- -L, --copy-links            copy the referent of symlinks
-     --copy-unsafe-links     copy links outside the source tree
-     --safe-links            ignore links outside the destination tree
+ -L, --copy-links            copy the referent of all symlinks
+     --copy-unsafe-links     copy the referent of "unsafe" symlinks
+     --safe-links            ignore "unsafe" symlinks
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
  -o, --owner                 preserve owner (root only)
  -g, --group                 preserve group
  -D, --devices               preserve devices (root only)
  -t, --times                 preserve times
@@ -345,19 +345,19 @@
  -e, --rsh=COMMAND           specify the remote shell
      --rsync-path=PATH       specify path to rsync on the remote machine
      --existing              only update files that already exist
      --ignore-existing       ignore files that already exist on receiver
      --delete                delete files that don\&'t exist on sender
      --delete-excluded       also delete excluded files on receiver
-     --delete-after          delete after transferring, not before
-     --ignore-errors         delete even if there are IO errors
+     --delete-after          receiver deletes after transfer, not before
+     --ignore-errors         delete even if there are I/O errors
      --max-delete=NUM        don\&'t delete more than NUM files
      --partial               keep partially transferred files
      --force                 force deletion of dirs even if not empty
      --numeric-ids           don\&'t map uid/gid values by user/group name
-     --timeout=TIME          set IO timeout in seconds
+     --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          turn off mod time & file size quick check
      --size-only             ignore mod time for quick check (use size)
      --modify-window=NUM     compare mod times with reduced accuracy
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare received files relative to DIR
      --link-dest=DIR         create hardlinks to DIR for unchanged files
@@ -368,18 +368,18 @@
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don\&'t exclude files matching PATTERN
      --include-from=FILE     don\&'t exclude patterns listed in FILE
      --files-from=FILE       read FILE for list of source-file names
  -0  --from0                 all file lists are delimited by nulls
      --version               print version number
-     --daemon                run as a rsync daemon
+     --daemon                run as an rsync daemon
      --no-detach             do not detach from the parent
      --address=ADDRESS       bind to the specified address
      --config=FILE           specify alternate rsyncd\&.conf file
      --port=PORT             specify alternate rsyncd port number
-     --blocking-io           use blocking IO for the remote shell
+     --blocking-io           use blocking I/O for the remote shell
      --no-blocking-io        turn off --blocking-io
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
@@ -426,15 +426,15 @@
 .IP "\fB-I, --ignore-times\fP" 
 Normally rsync will skip any files that are
 already the same size and have the same modification time-stamp\&.
 This option turns off this "quick check" behavior\&.
 .IP 
 .IP "\fB--size-only\fP" 
-Normally rsync will skip any files that are
+Normally rsync will not transfer any files that are
 already the same size and have the same modification time-stamp\&. With the
---size-only option files will be skipped if they have the same size,
+--size-only option, files will not be transferred if they have the same size,
 regardless of timestamp\&. This is useful when starting to use rsync
 after using another mirroring system which may not preserve timestamps
 exactly\&.
 .IP 
 .IP "\fB--modify-window\fP" 
 When comparing two timestamps rsync treats
@@ -446,13 +446,13 @@
 .IP 
 .IP "\fB-c, --checksum\fP" 
 This forces the sender to checksum all files using
 a 128-bit MD4 checksum before transfer\&. The checksum is then
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
-receiver are skipped\&.  This option can be quite slow\&.
+receiver are not transferred\&.  This option can be quite slow\&.
 .IP 
 .IP "\fB-a, --archive\fP" 
 This is equivalent to -rlptgoD\&. It is a quick
 way of saying you want recursion and want to preserve almost
 everything\&.  
 .IP 
@@ -521,40 +521,49 @@
 In combination with the --backup option, this
 tells rsync to store all backups in the specified directory\&. This is
 very useful for incremental backups\&.  You can additionally
 specify a backup suffix using the --suffix option
 (otherwise the files backed up in the specified directory
 will keep their original filenames)\&.
+If DIR is a relative path, it is relative to the destination directory
+(which changes in a recursive transfer)\&.
 .IP 
 .IP "\fB--suffix=SUFFIX\fP" 
 This option allows you to override the default
 backup suffix used with the --backup (-b) option\&. The default suffix is a ~
 if no --backup-dir was specified, otherwise it is an empty string\&.
 .IP 
 .IP "\fB-u, --update\fP" 
 This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file\&.
 .IP 
+In the currently implementation, a difference of file format is always
+considered to be important enough for an update, no matter what date
+is on the objects\&.  In other words, if the source has a directory or a
+symlink where the destination has a file, the transfer would occur
+regardless of the timestamps\&.  This might change in the future (feel
+free to comment on this on the mailing list if you have an opinion)\&.
+.IP 
 .IP "\fB-l, --links\fP" 
 When symlinks are encountered, recreate the
 symlink on the destination\&.
 .IP 
 .IP "\fB-L, --copy-links\fP" 
 When symlinks are encountered, the file that
-they point to is copied, rather than the symlink\&.
+they point to (the referent) is copied, rather than the symlink\&.
 .IP 
 .IP "\fB--copy-unsafe-links\fP" 
 This tells rsync to copy the referent of
-symbolic links that point outside the source tree\&.  Absolute symlinks
+symbolic links that point outside the copied tree\&.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
 source path itself when --relative is used\&.
 .IP 
 .IP "\fB--safe-links\fP" 
 This tells rsync to ignore any symbolic links
-which point outside the destination tree\&. All absolute symlinks are
+which point outside the copied tree\&. All absolute symlinks are
 also ignored\&. Using this option in conjunction with --relative may
 give unexpected results\&. 
 .IP 
 .IP "\fB-H, --hard-links\fP" 
 This tells rsync to recreate hard  links  on
 the  remote system  to  be the same as the local system\&. Without this
@@ -567,13 +576,13 @@
 .IP 
 .IP "\fB-W, --whole-file\fP" 
 With this option the incremental rsync algorithm
 is not used and the whole file is sent as-is instead\&.  The transfer may be
 faster if this option is used when the bandwidth between the source and
 target machines is higher than the bandwidth to disk (especially when the
-"disk" is actually a networked file system)\&.  This is the default when both
+"disk" is actually a networked filesystem)\&.  This is the default when both
 the source and target are on the local machine\&.
 .IP 
 .IP "\fB--no-whole-file\fP" 
 Turn off --whole-file, for use when it is the
 default\&.
 .IP 
@@ -586,22 +595,23 @@
 other files (including updated files) retain their existing permissions
 (which is the same behavior as other file-copy utilities, such as cp)\&.
 .IP 
 .IP "\fB-o, --owner\fP" 
 This option causes rsync to set the owner of the
 destination file to be the same as the source file\&.  On most systems,
-only the super-user can set file ownership\&.  Note that if the remote system
-is a daemon using chroot, the --numeric-ids option is implied because the
-remote system cannot get access to the usernames from /etc/passwd\&.
+only the super-user can set file ownership\&.  By default, the preservation
+is done by name, but may fall back to using the ID number in some
+circumstances\&.  See the --numeric-ids option for a full discussion\&.
 .IP 
 .IP "\fB-g, --group\fP" 
 This option causes rsync to set the group of the
 destination file to be the same as the source file\&.  If the receiving
 program is not running as the super-user, only groups that the
-receiver is a member of will be preserved (by group name, not group id
-number)\&.
+receiver is a member of will be preserved\&.  By default, the preservation
+is done by name, but may fall back to using the ID number in some
+circumstances\&.  See the --numeric-ids option for a full discussion\&.
 .IP 
 .IP "\fB-D, --devices\fP" 
 This option causes rsync to transfer character and
 block device information to the remote system to recreate these
 devices\&. This option is only available to the super-user\&.
 .IP 
@@ -652,33 +662,33 @@
 This option has no effect if directory recursion is not selected\&.
 .IP 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the dry run option (-n) to see what files would be
 deleted to make sure important files aren\&'t listed\&.
 .IP 
-If the sending side detects any IO errors then the deletion of any
+If the sending side detects any I/O errors then the deletion of any
 files at the destination will be automatically disabled\&. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
 destination\&.  You can override this with the --ignore-errors option\&.
 .IP 
 .IP "\fB--delete-excluded\fP" 
 In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see --exclude)\&.
 Implies --delete\&.
 .IP 
 .IP "\fB--delete-after\fP" 
-By default rsync does file deletions before
-transferring files to try to ensure that there is sufficient space on
-the receiving filesystem\&. If you want to delete after transferring
-then use the --delete-after switch\&. Implies --delete\&.
+By default rsync does file deletions on the
+receiving side before transferring files to try to ensure that there is
+sufficient space on the receiving filesystem\&. If you want to delete
+after transferring, use the --delete-after switch\&. Implies --delete\&.
 .IP 
 .IP "\fB--ignore-errors\fP" 
 Tells --delete to go ahead and delete files
-even when there are IO errors\&.
+even when there are I/O errors\&.
 .IP 
 .IP "\fB--force\fP" 
 This options tells rsync to delete directories even if
 they are not empty when they are to be replaced by non-directories\&.  This
 is only relevant without --delete because deletions are now done depth-first\&.
 Requires the --recursive option (which is implied by -a) to have any effect\&.
@@ -691,13 +701,13 @@
 This option allows you to choose an alternative
 remote shell program to use for communication between the local and
 remote copies of rsync\&. Typically, rsync is configured to use ssh by
 default, but you may prefer to use rsh on a local network\&.
 .IP 
 If this option is used with \fB[user@]host::module/path\fP, then the
-remote shell \fICOMMMAND\fP will be used to run an rsync server on the
+remote shell \fICOMMAND\fP will be used to run an rsync server on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
 running rsync server on the remote host\&.  See the section "CONNECTING
 TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" above\&.
 .IP 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
@@ -727,34 +737,34 @@
 systems\&. It uses the same algorithm that CVS uses to determine if
 a file should be ignored\&.
 .IP 
 The exclude list is initialized to:
 .IP 
 .RS 
-RCS/ SCCS/ CVS/ \&.svn/ CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
-\&.nse_depinfo *~ #* \&.#* ,* *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej \&.del-*
-*\&.a *\&.o *\&.obj *\&.so *\&.Z *\&.elc *\&.ln core
+RCS SCCS CVS CVS\&.adm RCSLOG cvslog\&.* tags TAGS \&.make\&.state
+\&.nse_depinfo *~ #* \&.#* ,* _$* *$ *\&.old *\&.bak *\&.BAK *\&.orig *\&.rej
+\&.del-* *\&.a *\&.olb *\&.o *\&.obj *\&.so *\&.exe *\&.Z *\&.elc *\&.ln core \&.svn/
 .RE 
 .IP 
 then files listed in a $HOME/\&.cvsignore are added to the list and any
-files listed in the CVSIGNORE environment variable (space delimited)\&.
+files listed in the CVSIGNORE environment variable (all cvsignore names
+are delimited by whitespace)\&.
 .IP 
 Finally, any file is ignored if it is in the same directory as a
-\&.cvsignore file and matches one of the patterns listed therein\&.  See
-the \fBcvs(1)\fP manual for more information\&.
+\&.cvsignore file and matches one of the patterns listed therein\&.
+See the \fBcvs(1)\fP manual for more information\&.
 .IP 
 .IP "\fB--exclude=PATTERN\fP" 
 This option allows you to selectively exclude
 certain files from the list of files to be transferred\&. This is most
 useful in combination with a recursive transfer\&.
 .IP 
 You may use as many --exclude options on the command line as you like
 to build up the list of files to exclude\&.
 .IP 
-See the EXCLUDE PATTERNS section for information on the syntax of 
-this option\&.
+See the EXCLUDE PATTERNS section for detailed information on this option\&.
 .IP 
 .IP "\fB--exclude-from=FILE\fP" 
 This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list\&.  Blank lines in FILE and lines starting with
 \&';\&' or \&'#\&' are ignored\&.
@@ -762,14 +772,13 @@
 .IP 
 .IP "\fB--include=PATTERN\fP" 
 This option tells rsync to not exclude the
 specified pattern of filenames\&. This is useful as it allows you to
 build up quite complex exclude/include rules\&.
 .IP 
-See the EXCLUDE PATTERNS section for information on the syntax of 
-this option\&.
+See the EXCLUDE PATTERNS section for detailed information on this option\&.
 .IP 
 .IP "\fB--include-from=FILE\fP" 
 This specifies a list of include patterns
 from a file\&.
 If \fIFILE\fP is \fB-\fP the list will be read from standard input\&.
 .IP 
@@ -816,12 +825,14 @@
 was located on the remote "src" host\&.
 .IP 
 .IP "\fB-0, --from0\fP" 
 This tells rsync that the filenames it reads from a
 file are terminated by a null (\&'\e0\&') character, not a NL, CR, or CR+LF\&.
 This affects --exclude-from, --include-from, and --files-from\&.
+It does not affect --cvs-exclude (since all names read from a \&.cvsignore
+file are split on whitespace)\&.
 .IP 
 .IP "\fB-T, --temp-dir=DIR\fP" 
 This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files
 transferred on the receiving side\&.  The default behavior is to create
 the temporary files in the receiving directory\&.
@@ -835,21 +846,32 @@
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
 although this skips files that haven\&'t changed; see also --link-dest)\&.
 This option increases the usefulness of --partial because partially
 transferred files will remain in the new temporary destination until they
 have a chance to be completed\&.  If DIR is a relative path, it is relative
-to the destination directory\&.
+to the destination directory (which changes in a recursive transfer)\&.
 .IP 
 .IP "\fB--link-dest=DIR\fP" 
 This option behaves like \fB--compare-dest\fP but
 also will create hard links from \fIDIR\fP to the destination directory for
 unchanged files\&.  Files with changed ownership or permissions will not be
 linked\&.
 Like \fB--compare-dest\fP if DIR is a relative path, it is relative
-to the destination directory\&.
+to the destination directory (which changes in a recursive transfer)\&.
+An example:
+.IP 
+
+.nf 
+ 
+
+    rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
+
+.fi 
+ 
+
 .IP 
 .IP "\fB-z, --compress\fP" 
 With this option, rsync compresses any data from
 the files that it sends to the destination machine\&.  This
 option is useful on slow connections\&.  The compression method used is the
 same method that gzip uses\&.
@@ -858,26 +880,29 @@
 that can be achieved by using a compressing remote shell, or a
 compressing transport, as it takes advantage of the implicit
 information sent for matching data blocks\&.
 .IP 
 .IP "\fB--numeric-ids\fP" 
 With this option rsync will transfer numeric group
-and user ids rather than using user and group names and mapping them
+and user IDs rather than using user and group names and mapping them
 at both ends\&.
 .IP 
-By default rsync will use the user name and group name to determine
+By default rsync will use the username and groupname to determine
 what ownership to give files\&. The special uid 0 and the special group
 0 are never mapped via user/group names even if the --numeric-ids
 option is not specified\&.
 .IP 
-If the source system is a daemon using chroot, or if a user or group
-name does not exist on the destination system, then the numeric id
-from the source system is used instead\&.
+If a user or group has no name on the source system or it has no match
+on the destination system, then the numeric ID
+from the source system is used instead\&.  See also the comments on the
+"use chroot" setting in the rsyncd\&.conf manpage for information on how
+the chroot setting affects rsync\&'s ability to look up the names of the
+users and groups and what you can do about it\&.
 .IP 
 .IP "\fB--timeout=TIMEOUT\fP" 
-This option allows you to set a maximum IO
+This option allows you to set a maximum I/O
 timeout in seconds\&. If no data is transferred for the specified time
 then rsync will exit\&. The default is 0, which means no timeout\&.
 .IP 
 .IP "\fB--daemon\fP" 
 This tells rsync that it is to run as a daemon\&.  The
 daemon may be accessed using the \fBhost::module\fP or
@@ -916,17 +941,17 @@
 .IP 
 .IP "\fB--port=PORT\fP" 
 This specifies an alternate TCP port number to use
 rather than the default port 873\&.
 .IP 
 .IP "\fB--blocking-io\fP" 
-This tells rsync to use blocking IO when launching
+This tells rsync to use blocking I/O when launching
 a remote shell transport\&.  If the remote shell is either rsh or remsh,
 rsync defaults to using
-blocking IO, otherwise it defaults to using non-blocking IO\&.  (Note that
-ssh prefers non-blocking IO\&.)
+blocking I/O, otherwise it defaults to using non-blocking I/O\&.  (Note that
+ssh prefers non-blocking I/O\&.)
 .IP 
 .IP "\fB--no-blocking-io\fP" 
 Turn off --blocking-io, for use when it is the
 default\&.
 .IP 
 .IP "\fB--log-format=FORMAT\fP" 
@@ -950,32 +975,67 @@
 .IP "\fB--progress\fP" 
 This option tells rsync to print information
 showing the progress of the transfer\&. This gives a bored user
 something to watch\&.
 Implies --verbose without incrementing verbosity\&.
 .IP 
+When the file is transferring, the data looks like this:
+.IP 
+
+.nf 
+ 
+
+      782448  63%  110\&.64kB/s    0:00:04
+
+.fi 
+ 
+
+.IP 
+This tells you the current file size, the percentage of the transfer that
+is complete, the current calculated file-completion rate (including both
+data over the wire and data being matched locally), and the estimated time
+remaining in this transfer\&.
+.IP 
+After the a file is complete, it the data looks like this:
+.IP 
+
+.nf 
+ 
+
+     1238099 100%  146\&.38kB/s    0:00:08  (5, 57\&.1% of 396)
+
+.fi 
+ 
+
+.IP 
+This tells you the final file size, that it\&'s 100% complete, the final
+transfer rate for the file, the amount of elapsed time it took to transfer
+the file, and the addition of a total-transfer summary in parentheses\&.
+These additional numbers tell you how many files have been updated, and
+what percent of the total number of files has been scanned\&.
+.IP 
 .IP "\fB-P\fP" 
 The -P option is equivalent to --partial --progress\&. I
 found myself typing that combination quite often so I created an
 option to make it easier\&.
 .IP 
 .IP "\fB--password-file\fP" 
 This option allows you to provide a password
 in a file for accessing a remote rsync server\&. Note that this option
-is only useful when accessing a rsync server using the built in
+is only useful when accessing an rsync server using the built in
 transport, not when using a remote shell as the transport\&. The file
 must not be world readable\&. It should contain just the password as a
 single line\&.
 .IP 
 .IP "\fB--bwlimit=KBPS\fP" 
 This option allows you to specify a maximum
 transfer rate in kilobytes per second\&. This option is most effective when
 using rsync with large files (several megabytes and up)\&. Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block\&. The
-result is an average transfer rate equalling the specified limit\&. A value
+result is an average transfer rate equaling the specified limit\&. A value
 of zero specifies no limit\&.
 .IP 
 .IP "\fB--write-batch=PREFIX\fP" 
 Generate a set of files that can be
 transferred as a batch update\&. Each filename in the set starts with
 PREFIX\&. See the "BATCH MODE" section for details\&.
@@ -988,30 +1048,81 @@
 .PP 
 .SH "EXCLUDE PATTERNS" 
 .PP 
 The exclude and include patterns specified to rsync allow for flexible
 selection of which files to transfer and which files to skip\&.
 .PP 
-rsync builds an ordered list of include/exclude options as specified on
+Rsync builds an ordered list of include/exclude options as specified on
 the command line\&. Rsync checks each file and directory 
 name against each exclude/include pattern in turn\&. The first matching
 pattern is acted on\&. If it is an exclude pattern, then that file is
 skipped\&. If it is an include pattern then that filename is not
 skipped\&. If no matching include/exclude pattern is found then the
 filename is not skipped\&.
 .PP 
-The filenames matched against the exclude/include patterns
-are relative to the destination directory, or "top
-directory", so patterns should not include the path elements
-of the source or destination directories\&.  The only way in
-which a pattern will match the absolute path of a file or
-directory is if the source path is the root directory\&.
+The filenames matched against the exclude/include patterns are relative
+to the "root of the transfer"\&.  If you think of the transfer as a
+subtree of names that are being sent from sender to receiver, the root
+is where the tree starts to be duplicated in the destination directory\&.
+This root governs where patterns that start with a / match (see below)\&.
+.PP 
+Because the matching is relative to the transfer-root, changing the
+trailing slash on a source path or changing your use of the --relative
+option affects the path you need to use in your matching (in addition to
+changing how much of the file tree is duplicated on the destination
+system)\&.  The following examples demonstrate this\&.
+.PP 
+Let\&'s say that we want to match two source files, one with an absolute
+path of "/home/me/foo/bar", and one with a path of "/home/you/bar/baz"\&.
+Here is how the various command choices differ for a 2-source transfer:
 .PP 
-Note that when used with -r (which is implied by -a), every subcomponent of
-every path is visited from top down, so include/exclude patterns get
+
+.nf 
+ 
+
+   Example cmd: rsync -a /home/me /home/you /dest
+   +/- pattern: /me/foo/bar
+   +/- pattern: /you/bar/baz
+   Target file: /dest/me/foo/bar
+   Target file: /dest/you/bar/baz
+
+   Example cmd: rsync -a /home/me/ /home/you/ /dest
+   +/- pattern: /foo/bar               (note missing "me")
+   +/- pattern: /bar/baz               (note missing "you")
+   Target file: /dest/foo/bar
+   Target file: /dest/bar/baz
+
+   Example cmd: rsync -a --relative /home/me/ /home/you /dest
+   +/- pattern: /home/me/foo/bar       (note full path)
+   +/- pattern: /home/you/bar/baz      (ditto)
+   Target file: /dest/home/me/foo/bar
+   Target file: /dest/home/you/bar/baz
+
+   Example cmd: cd /home; rsync -a --relative me/foo you/ /dest
+   +/- pattern: /me/foo/bar      (starts at specified path)
+   +/- pattern: /you/bar/baz     (ditto)
+   Target file: /dest/me/foo/bar
+   Target file: /dest/you/bar/baz
+
+.fi 
+ 
+
+.PP 
+The easiest way to see what name you should include/exclude is to just
+look at the output when using --verbose and put a / in front of the name
+(use the --dry-run option if you\&'re not yet ready to copy any files)\&.
+.PP 
+Note that, when using the --recursive (-r) option (which is implied by -a),
+every subcomponent of
+every path is visited from the top down, so include/exclude patterns get
 applied recursively to each subcomponent\&.
+The exclude patterns actually short-circuit the directory traversal stage
+when rsync finds the files to send\&.  If a pattern excludes a particular
+parent directory, it can render a deeper include pattern ineffectual
+because rsync did not descend through that excluded section of the
+hierarchy\&.
 .PP 
 Note also that the --include and --exclude options take one pattern
 each\&. To add multiple patterns use the --include-from and
 --exclude-from options or multiple --include and --exclude options\&. 
 .PP 
 The patterns can take several forms\&. The rules are:
@@ -1019,23 +1130,22 @@
 .IP 
 .IP o 
 if the pattern starts with a / then it is matched against the
 start of the filename, otherwise it is matched against the end of
 the filename\&.
 This is the equivalent of a leading ^ in regular expressions\&.
-Thus "/foo" would match a file called "foo" at the top of the
-transferred tree\&.
+Thus "/foo" would match a file called "foo" at the transfer-root
+(see above for how this is different from the filesystem-root)\&.
 On the other hand, "foo" would match any file called "foo"
 anywhere in the tree because the algorithm is applied recursively from
 top down; it behaves as if each path component gets a turn at being the
 end of the file name\&.
-The leading / does not make the pattern an absolute pathname\&.
 .IP 
 .IP o 
 if the pattern ends with a / then it will only match a
-directory, not a file, link or device\&.
+directory, not a file, link, or device\&.
 .IP 
 .IP o 
 if the pattern contains a wildcard character from the set
 *?[ then expression matching is applied using the shell filename
 matching rules\&. Otherwise a simple string match is used\&.
 .IP 
@@ -1051,48 +1161,80 @@
 remember that the algorithm is applied recursively so "full filename" can
 actually be any portion of a path below the starting directory\&.
 .IP 
 .IP o 
 if the pattern starts with "+ " (a plus followed by a space)
 then it is always considered an include pattern, even if specified as
-part of an exclude option\&. The "+ " part is discarded before matching\&.
+part of an exclude option\&. The prefix is discarded before matching\&.
 .IP 
 .IP o 
 if the pattern starts with "- " (a minus followed by a space)
 then it is always considered an exclude pattern, even if specified as
-part of an include option\&. The "- " part is discarded before matching\&.
+part of an include option\&. The prefix is discarded before matching\&.
 .IP 
 .IP o 
 if the pattern is a single exclamation mark ! then the current
 include/exclude list is reset, removing all previously defined patterns\&.
 .PP 
 The +/- rules are most useful in a list that was read from a file, allowing
 you to have a single exclude list that contains both include and exclude
-options\&.
+options in the proper order\&.
 .PP 
-If you end an exclude list with --exclude \&'*\&', note that since the
-algorithm is applied recursively that unless you explicitly include
-parent directories of files you want to include then the algorithm
-will stop at the parent directories and never see the files below
-them\&.  To include all directories, use --include \&'*/\&' before the
---exclude \&'*\&'\&.
+Remember that the matching occurs at every step in the traversal of the
+directory hierarchy, so you must be sure that all the parent directories of
+the files you want to include are not excluded\&.  This is particularly
+important when using a trailing \&'*\&' rule\&.  For instance, this won\&'t work:
 .PP 
-Here are some exclude/include examples:
+
+.nf 
+ 
+
+    + /some/path/this-file-will-not-be-found
+    + /file-is-included
+    - *
+
+.fi 
+ 
+
+.PP 
+This fails because the parent directory "some" is excluded by the \&'*\&' rule,
+so rsync never visits any of the files in the "some" or "some/path"
+directories\&.  One solution is to ask for all directories in the hierarchy
+to be included by using a single rule: --include=\&'*/\&' (put it somewhere
+before the --excludde=\&'*\&' rule)\&.  Another solution is to add specific
+include rules for all the parent dirs that need to be visited\&.  For
+instance, this set of rules works fine:
+.PP 
+
+.nf 
+ 
+
+    + /some/
+    + /some/path/
+    + /some/path/this-file-is-found
+    + /file-also-included
+    - *
+
+.fi 
+ 
+
+.PP 
+Here are some examples of exclude/include matching:
 .PP 
 .IP o 
 --exclude "*\&.o" would exclude all filenames matching *\&.o
 .IP o 
---exclude "/foo" would exclude a file called foo in the top directory
+--exclude "/foo" would exclude a file called foo in the transfer-root directory
 .IP o 
 --exclude "foo/" would exclude any directory called foo
 .IP o 
 --exclude "/foo/*/bar" would exclude any file called bar two
-levels below a directory called foo in the top directory
+levels below a directory called foo in the transfer-root directory
 .IP o 
 --exclude "/foo/**/bar" would exclude any file called bar two
-or more levels below a directory called foo in the top directory
+or more levels below a directory called foo in the transfer-root directory
 .IP o 
 --include "*/" --include "*\&.c" --exclude "*" would include all 
 directories and C source files
 .IP o 
 --include "foo/" --include "foo/bar\&.c" --exclude "*" would include
 only foo/bar\&.c (the foo/ directory must be explicitly included or
@@ -1146,17 +1288,17 @@
 Example:
 .PP 
 
 .nf 
  
 
-$ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
-$ rcp pfx\&.rsync_* remote:
-$ ssh remote rsync --read-batch=pfx -a /bdest/dir/
-# or alternatively
-$ ssh remote \&./pfx\&.rsync_argvs /bdest/dir/
+   $ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
+   $ rcp pfx\&.rsync_* remote:
+   $ ssh remote rsync --read-batch=pfx -a /bdest/dir/
+   # or alternatively
+   $ ssh remote \&./pfx\&.rsync_argvs /bdest/dir/
 
 .fi 
  
 
 .PP 
 In this example, rsync is used to update /adest/dir/ with /source/dir/
@@ -1207,13 +1349,13 @@
 rsync also distinguishes "safe" and "unsafe" symbolic links\&.  An
 example where this might be used is a web site mirror that wishes
 ensure the rsync module they copy does not include symbolic links to
 \fB/etc/passwd\fP in the public section of the site\&.  Using
 \fB--copy-unsafe-links\fP will cause any links to be copied as the file
 they point to on the destination\&.  Using \fB--safe-links\fP will cause
-unsafe links to be ommitted altogether\&.
+unsafe links to be omitted altogether\&.
 .PP 
 Symbolic links are considered unsafe if they are absolute symlinks
 (start with \fB/\fP), empty, or if they contain enough \fB"\&.\&."\fP
 components to ascend from the directory being copied\&.
 .PP 
 .SH "DIAGNOSTICS" 
@@ -1259,20 +1401,20 @@
 Protocol incompatibility 
 .IP "\fB3\fP" 
 Errors selecting input/output files, dirs
 .IP "\fB4\fP" 
 Requested action not supported: an attempt
 was made to manipulate 64-bit files on a platform that cannot support
-them; or an option was speciifed that is supported by the client and
+them; or an option was specifed that is supported by the client and
 not by the server\&.
 .IP "\fB5\fP" 
 Error starting client-server protocol
 .IP "\fB10\fP" 
-Error in socket IO 
+Error in socket I/O 
 .IP "\fB11\fP" 
-Error in file IO 
+Error in file I/O 
 .IP "\fB12\fP" 
 Error in rsync protocol data stream 
 .IP "\fB13\fP" 
 Errors with program diagnostics 
 .IP "\fB14\fP" 
 Error in IPC code 
@@ -1306,19 +1448,20 @@
 The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
 rsync daemon\&. You should set RSYNC_PROXY to a hostname:port pair\&.
 .IP 
 .IP "\fBRSYNC_PASSWORD\fP" 
 Setting RSYNC_PASSWORD to the required
-password allows you to run authenticated rsync connections to a rsync
+password allows you to run authenticated rsync connections to an rsync
 daemon without user intervention\&. Note that this does not supply a
 password to a shell transport such as ssh\&.
 .IP 
 .IP "\fBUSER\fP or \fBLOGNAME\fP" 
 The USER or LOGNAME environment variables
-are used to determine the default username sent to a rsync server\&.
+are used to determine the default username sent to an rsync server\&.
+If neither is set, the username defaults to "nobody"\&.
 .IP 
 .IP "\fBHOME\fP" 
 The HOME environment variable is used to find the user\&'s
 default \&.cvsignore file\&.
 .IP 
 .PP 
@@ -1333,17 +1476,17 @@
 .SH "DIAGNOSTICS" 
 .PP 
 .SH "BUGS" 
 .PP 
 times are transferred as unix time_t values
 .PP 
-When transferring to FAT filesystmes rsync may resync
+When transferring to FAT filesystems rsync may resync
 unmodified files\&.
 See the comments on the --modify-window option\&.
 .PP 
-file permissions, devices etc are transferred as native numerical
+file permissions, devices, etc\&. are transferred as native numerical
 values
 .PP 
 see also the comments on the --delete option
 .PP 
 Please report bugs! See the website at
 http://rsync\&.samba\&.org/
@@ -1369,21 +1512,16 @@
 .SH "THANKS" 
 .PP 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions, patches and testing of rsync\&.
 I\&'ve probably missed some people, my apologies if I have\&.
 .PP 
-Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer\&.
+Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer,
+Martin Pool, Wayne Davison\&.
 .PP 
 .SH "AUTHOR" 
 .PP 
-rsync was written by Andrew Tridgell <tridge@samba\&.org> and Paul
-Mackerras\&.
-.PP 
-rsync is now maintained by Martin Pool <mbp@samba\&.org>\&.  
+rsync was originally written by Andrew Tridgell and Paul Mackerras\&.
+Many people have later contributed to it\&.
 .PP 
 Mailing lists for support and development are available at
 http://lists\&.samba\&.org 
-.PP 
-If you suspect you have found a security vulnerability in rsync,
-please send it directly to Martin Pool and Andrew Tridgell\&.  For other
-enquiries, please use the mailing list\&.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.c	2003-12-19 14:52:02.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.c	2004-03-24 00:16:15.000000000 +0800
@@ -23,12 +23,15 @@
 #include "rsync.h"
 
 extern int verbose;
 extern int dry_run;
 extern int preserve_times;
 extern int am_root;
+extern int am_server;
+extern int am_sender;
+extern int am_generator;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int preserve_perms;
 extern int make_backups;
 
 
@@ -58,47 +61,47 @@
 
 #if SUPPORT_LINKS
 	ret = do_lstat(fname, &st);
 #else
 	ret = do_stat(fname, &st);
 #endif
-	if (ret) {
+	if (ret)
 		return -1;
-	}
 
 	if (!S_ISDIR(st.st_mode)) {
-		if (robust_unlink(fname) == 0 || errno == ENOENT) return 0;
+		if (robust_unlink(fname) == 0 || errno == ENOENT)
+			return 0;
 		rprintf(FERROR, "delete_file: unlink %s failed: %s\n",
 			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
-	if (do_rmdir(fname) == 0 || errno == ENOENT) return 0;
-	if (!force_delete || !recurse ||
-	    (errno != ENOTEMPTY && errno != EEXIST)) {
+	if (do_rmdir(fname) == 0 || errno == ENOENT)
+		return 0;
+	if (!force_delete || !recurse
+	    || (errno != ENOTEMPTY && errno != EEXIST)) {
 		rprintf(FERROR, "delete_file: rmdir %s failed: %s\n",
 			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
 	/* now we do a recsursive delete on the directory ... */
-	d = opendir(fname);
-	if (!d) {
+	if (!(d = opendir(fname))) {
 		rprintf(FERROR, "delete_file: opendir %s failed: %s\n",
 			full_fname(fname), strerror(errno));
 		return -1;
 	}
 
 	for (errno = 0, di = readdir(d); di; errno = 0, di = readdir(d)) {
 		char *dname = d_name(di);
-		if (strcmp(dname,".") == 0
-		    || strcmp(dname,"..") == 0)
+		if (dname[0] == '.' && (dname[1] == '\0'
+		    || (dname[1] == '.' && dname[2] == '\0')))
 			continue;
-		snprintf(buf, sizeof(buf), "%s/%s", fname, dname);
+		pathjoin(buf, sizeof buf, fname, dname);
 		if (verbose > 0)
-			rprintf(FINFO,"deleting %s\n", buf);
+			rprintf(FINFO, "deleting %s\n", buf);
 		if (delete_file(buf) != 0) {
 			closedir(d);
 			return -1;
 		}
 	}
 	if (errno) {
@@ -116,46 +119,12 @@
 		return -1;
 	}
 
 	return 0;
 }
 
-static int is_in_group(gid_t gid)
-{
-#ifdef GETGROUPS_T
-	static gid_t last_in = (gid_t) -2, last_out;
-	static int ngroups = -2;
-	static GETGROUPS_T *gidset;
-	int n;
-
-	if (gid == last_in)
-		return last_out;
-	if (ngroups < -1) {
-		/* treat failure (-1) as if not member of any group */
-		ngroups = getgroups(0, 0);
-		if (ngroups > 0) {
-			gidset = new_array(GETGROUPS_T, ngroups);
-			ngroups = getgroups(ngroups, gidset);
-		}
-	}
-
-	last_in = gid;
-	last_out = 0;
-	for (n = 0; n < ngroups; n++) {
-		if (gidset[n] == gid) {
-			last_out = 1;
-			break;
-		}
-	}
-	return last_out;
-
-#else
-	return 0;
-#endif
-}
-
 int set_perms(char *fname,struct file_struct *file,STRUCT_STAT *st,
 		int report)
 {
 	int updated = 0;
 	STRUCT_STAT st2;
 	int change_uid, change_gid;
@@ -171,44 +140,51 @@
 		st = &st2;
 	}
 
 	if (preserve_times && !S_ISLNK(st->st_mode) &&
 	    cmp_modtime(st->st_mtime, file->modtime) != 0) {
 		/* don't complain about not setting times on directories
-		   because some filesystems can't do it */
+		 * because some filesystems can't do it */
 		if (set_modtime(fname,file->modtime) != 0 &&
 		    !S_ISDIR(st->st_mode)) {
 			rprintf(FERROR, "failed to set times on %s: %s\n",
 				full_fname(fname), strerror(errno));
 			return 0;
-		} else {
-			updated = 1;
 		}
+		updated = 1;
 	}
 
 	change_uid = am_root && preserve_uid && st->st_uid != file->uid;
-	change_gid = preserve_gid && file->gid != (gid_t) -1 && \
-				st->st_gid != file->gid;
-	if (change_gid && !am_root) {
-		/* enforce bsd-style group semantics: non-root can only
-		    change to groups that the user is a member of */
-		change_gid = is_in_group(file->gid);
-	}
+	change_gid = preserve_gid && file->gid != GID_NONE
+		&& st->st_gid != file->gid;
 	if (change_uid || change_gid) {
+		if (verbose > 2) {
+			if (change_uid) {
+				rprintf(FINFO,
+				    "set uid of %s from %ld to %ld\n",
+				    fname, (long)st->st_uid, (long)file->uid);
+			}
+			if (change_gid) {
+				rprintf(FINFO,
+				    "set gid of %s from %ld to %ld\n",
+				    fname, (long)st->st_gid, (long)file->gid);
+			}
+		}
 		if (do_lchown(fname,
-			      change_uid?file->uid:st->st_uid,
-			      change_gid?file->gid:st->st_gid) != 0) {
+		    change_uid ? file->uid : st->st_uid,
+		    change_gid ? file->gid : st->st_gid) != 0) {
 			/* shouldn't have attempted to change uid or gid
-			     unless have the privilege */
-			rprintf(FERROR, "chown %s failed: %s\n",
-				full_fname(fname), strerror(errno));
+			 * unless have the privilege */
+			rprintf(FERROR, "%s %s failed: %s\n",
+			    change_uid ? "chown" : "chgrp",
+			    full_fname(fname), strerror(errno));
 			return 0;
 		}
 		/* a lchown had been done - we have to re-stat if the
-                   destination had the setuid or setgid bits set due
-                   to the side effect of the chown call */
+                 * destination had the setuid or setgid bits set due
+                 * to the side effect of the chown call */
 		if (st->st_mode & (S_ISUID | S_ISGID)) {
 			link_stat(fname, st);
 		}
 		updated = 1;
 	}
 
@@ -251,30 +227,27 @@
 
 
 /* finish off a file transfer, renaming the file and setting the permissions
    and ownership */
 void finish_transfer(char *fname, char *fnametmp, struct file_struct *file)
 {
+	int ret;
+
 	if (make_backups && !make_backup(fname))
 		return;
 
 	/* move tmp file over real file */
-	if (robust_rename(fnametmp,fname) != 0) {
-		if (errno == EXDEV) {
-			/* rename failed on cross-filesystem link.
-			   Copy the file instead. */
-			if (copy_file(fnametmp,fname, file->mode & INITACCESSPERMS)) {
-				rprintf(FERROR, "copy %s -> \"%s\": %s\n",
-					full_fname(fnametmp), fname,
-					strerror(errno));
-			} else {
-				set_perms(fname,file,NULL,0);
-			}
-		} else {
-			rprintf(FERROR,"rename %s -> \"%s\": %s\n",
-				full_fname(fnametmp), fname, strerror(errno));
-		}
+	ret = robust_rename(fnametmp, fname, file->mode & INITACCESSPERMS);
+	if (ret < 0) {
+		rprintf(FERROR, "%s %s -> \"%s\": %s\n",
+		    ret == -2 ? "copy" : "rename",
+		    full_fname(fnametmp), fname, strerror(errno));
 		do_unlink(fnametmp);
 	} else {
 		set_perms(fname,file,NULL,0);
 	}
 }
+
+const char *who_am_i(void)
+{
+    return am_sender ? "sender" : am_generator ? "generator" : "receiver";
+}
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.5 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsyncd.conf.5
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.5	2004-01-02 03:00:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsyncd.conf.5	2004-04-27 11:54:14.000000000 +0800
@@ -1,7 +1,7 @@
-.TH "rsyncd\&.conf" "5" "1 Jan 2004" "" "" 
+.TH "rsyncd\&.conf" "5" "26 Apr 2004" "" "" 
 .SH "NAME" 
 rsyncd\&.conf \- configuration file for rsync server
 .SH "SYNOPSIS" 
 .PP 
 rsyncd\&.conf
 .PP 
@@ -96,13 +96,13 @@
 messages to that file rather than using syslog\&. This is particularly
 useful on systems (such as AIX) where syslog() doesn\&'t work for
 chrooted programs\&.
 .IP 
 .IP "\fBpid file\fP" 
 The "pid file" option tells the rsync daemon to write
-its process id to that file\&.
+its process ID to that file\&.
 .IP 
 .IP "\fBsyslog facility\fP" 
 The "syslog facility" option allows you to
 specify the syslog facility name to use when logging messages from the
 rsync server\&. You may use any standard syslog facility name which is
 defined on your system\&. Common names are auth, authpriv, cron, daemon,
@@ -140,17 +140,37 @@
 .IP "\fBuse chroot\fP" 
 If "use chroot" is true, the rsync server will chroot
 to the "path" before starting the file transfer with the client\&.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges, 
 of not being able to follow symbolic links outside of the new root path
-when reading, and of implying the --numeric-ids option because /etc/passwd
-becomes inaccessible\&.  When "use chroot" is false, for security reasons
+when reading, and of complicating the preservation of usernames and groups
+(see below)\&.  When "use chroot" is false, for security reasons,
 symlinks may only be relative paths pointing to other files within the root
-path, and leading slashes are removed from absolute paths\&.  The default for
-"use chroot" is true\&.
+path, and leading slashes are removed from most absolute paths (options
+such as --backup-dir, --compare-dest, etc\&. interpret an absolute path as
+rooted in the module\&'s "path" dir, just as if chroot was specified)\&.
+The default for "use chroot" is true\&.
+.IP 
+In order to preserve usernames and groupnames, rsync needs to be able to
+use the standard library functions for looking up names and IDs (i\&.e\&.
+getpwuid(), getgrgid(), getpwname(), and getgrnam())\&.  This means a
+process in the chroot namespace will need to have access to the resources
+used by these library functions (traditionally /etc/passwd and
+/etc/group)\&.  If these resources are not available, rsync will only be
+able to copy the IDs, just as if the --numeric-ids option had been
+specified\&.
+.IP 
+Note that you are free to setup user/group information in the chroot area
+differently from your normal system\&.  For example, you could abbreviate
+the list of users and groups\&.  Also, you can protect this information
+from being downloaded by adding an exclude rule to the rsync\&.conf file
+(e\&.g\&. "exclude = /etc/")\&.  To protect it from being changed by an upload
+(if the module is not read only), be sure to set the permissions (or
+owner) on the files and/or parent directories so that they cannot be
+written by the daemon\&.
 .IP 
 .IP "\fBmax connections\fP" 
 The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow\&.
 Any clients connecting when the maximum has been reached will receive a
 message telling them to try later\&.  The default is 0 which means no limit\&.
@@ -174,20 +194,20 @@
 The "list" option determines if this module should be
 listed when the client asks for a listing of available modules\&. By
 setting this to false you can create hidden modules\&. The default is
 for modules to be listable\&.
 .IP 
 .IP "\fBuid\fP" 
-The "uid" option specifies the user name or user id that
+The "uid" option specifies the user name or user ID that
 file transfers to and from that module should take place as when the daemon
 was run as root\&. In combination with the "gid" option this determines what
 file permissions are available\&. The default is uid -2, which is normally
 the user "nobody"\&.
 .IP 
 .IP "\fBgid\fP" 
-The "gid" option specifies the group name or group id that
+The "gid" option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
 was run as root\&. This complements the "uid" option\&. The default is gid -2,
 which is normally the group "nobody"\&.
 .IP 
 .IP "\fBexclude\fP" 
 The "exclude" option allows you to specify a space
@@ -245,13 +265,13 @@
 "secrets file" option\&. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync")\&.
 .IP 
 See also the \fBCONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL
 PROGRAM\fP section in rsync(1) for information on how handle an
 rsyncd\&.conf-level username that differs from the remote-shell-level
-username when using a remote shell to connect to a rsync server\&.
+username when using a remote shell to connect to an rsync server\&.
 .IP 
 .IP "\fBsecrets file\fP" 
 The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module\&. This file is only consulted if the "auth
 users" option is specified\&. The file is line based and contains
@@ -265,13 +285,13 @@
 (such as \f(CW/etc/rsyncd\&.secrets\fP)\&.  The file must normally not be readable
 by "other"; see "strict modes"\&.
 .IP 
 .IP "\fBstrict modes\fP" 
 The "strict modes" option determines whether or not 
 the permissions on the secrets file will be checked\&.  If "strict modes" is
-true, then the secrets file must not be readable by any user id other
+true, then the secrets file must not be readable by any user ID other
 than the one that the rsync daemon is running under\&.  If "strict modes" is
 false, the check is not performed\&.  The default is true\&.  This option
 was added to accommodate rsync running on the Windows operating system\&.
 .IP 
 .IP "\fBhosts allow\fP" 
 The "hosts allow" option allows you to specify a
@@ -336,16 +356,16 @@
 rejected\&. See the "hosts allow" option for more information\&.
 .IP 
 The default is no "hosts deny" option, which means all hosts can connect\&.
 .IP 
 .IP "\fBignore errors\fP" 
 The "ignore errors" option tells rsyncd to
-ignore IO errors on the server when deciding whether to run the delete
+ignore I/O errors on the server when deciding whether to run the delete
 phase of the transfer\&. Normally rsync skips the --delete step if any
-IO errors have occurred in order to prevent disasterous deletion due
-to a temporary resource shortage or other IO error\&. In some cases this
+I/O errors have occurred in order to prevent disasterous deletion due
+to a temporary resource shortage or other I/O error\&. In some cases this
 test is counter productive so you can use this option to turn off this
 behaviour\&. 
 .IP 
 .IP "\fBignore nonreadable\fP" 
 This tells the rsync server to completely
 ignore files that are not readable by the user\&. This is useful for
@@ -370,13 +390,13 @@
 %h for the remote host name
 .IP o 
 %a for the remote IP address
 .IP o 
 %l for the length of the file in bytes
 .IP o 
-%p for the process id of this rsync session
+%p for the process ID of this rsync session
 .IP o 
 %o for the operation, which is either "send" or "recv"
 .IP o 
 %f for the filename
 .IP o 
 %P for the module path
@@ -397,13 +417,13 @@
 .IP 
 A perl script called rsyncstats to summarize this format is included
 in the rsync source code distribution\&.
 .IP 
 .IP "\fBtimeout\fP" 
 The "timeout" option allows you to override the
-clients choice for IO timeout for this module\&. Using this option you
+clients choice for I/O timeout for this module\&. Using this option you
 can ensure that rsync won\&'t wait on a dead client forever\&. The timeout
 is specified in seconds\&. A value of zero means no timeout and is the
 default\&. A good choice for anonymous rsync servers may be 600 (giving
 a 10 minute timeout)\&.
 .IP 
 .IP "\fBrefuse options\fP" 
@@ -468,13 +488,13 @@
 .PP 
 .RS 
 rsync --server --daemon \&.
 .RE 
 .PP 
 NOTE: rsync\&'s argument parsing expects the trailing "\&.", so make sure
-that it\&'s there\&.  If you want to use a rsyncd\&.conf(5)-style
+that it\&'s there\&.  If you want to use an rsyncd\&.conf(5)-style
 configuration file other than the default, you can added a
 --config option to the \fIcommand\fP:
 .PP 
 .RS 
 rsync --server --daemon --config=\fIfile\fP \&.
 .RE 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsyncd.conf.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsyncd.conf.yo	2004-01-02 03:00:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsyncd.conf.yo	2004-04-27 11:54:05.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsyncd.conf)(5)(1 Jan 2004)()()
+manpage(rsyncd.conf)(5)(26 Apr 2004)()()
 manpagename(rsyncd.conf)(configuration file for rsync server)
 manpagesynopsis()
 
 rsyncd.conf
 
 manpagedescription()
@@ -90,13 +90,13 @@
 dit(bf(log file)) The "log file" option tells the rsync daemon to log
 messages to that file rather than using syslog. This is particularly
 useful on systems (such as AIX) where syslog() doesn't work for
 chrooted programs.
 
 dit(bf(pid file)) The "pid file" option tells the rsync daemon to write
-its process id to that file.
+its process ID to that file.
 
 dit(bf(syslog facility)) The "syslog facility" option allows you to
 specify the syslog facility name to use when logging messages from the
 rsync server. You may use any standard syslog facility name which is
 defined on your system. Common names are auth, authpriv, cron, daemon,
 ftp, kern, lpr, mail, news, security, syslog, user, uucp, local0,
@@ -132,17 +132,37 @@
 
 dit(bf(use chroot)) If "use chroot" is true, the rsync server will chroot
 to the "path" before starting the file transfer with the client.  This has
 the advantage of extra protection against possible implementation security
 holes, but it has the disadvantages of requiring super-user privileges, 
 of not being able to follow symbolic links outside of the new root path
-when reading, and of implying the --numeric-ids option because /etc/passwd
-becomes inaccessible.  When "use chroot" is false, for security reasons
+when reading, and of complicating the preservation of usernames and groups
+(see below).  When "use chroot" is false, for security reasons,
 symlinks may only be relative paths pointing to other files within the root
-path, and leading slashes are removed from absolute paths.  The default for
-"use chroot" is true.
+path, and leading slashes are removed from most absolute paths (options
+such as --backup-dir, --compare-dest, etc. interpret an absolute path as
+rooted in the module's "path" dir, just as if chroot was specified).
+The default for "use chroot" is true.
+
+In order to preserve usernames and groupnames, rsync needs to be able to
+use the standard library functions for looking up names and IDs (i.e.
+getpwuid(), getgrgid(), getpwname(), and getgrnam()).  This means a
+process in the chroot namespace will need to have access to the resources
+used by these library functions (traditionally /etc/passwd and
+/etc/group).  If these resources are not available, rsync will only be
+able to copy the IDs, just as if the --numeric-ids option had been
+specified.
+
+Note that you are free to setup user/group information in the chroot area
+differently from your normal system.  For example, you could abbreviate
+the list of users and groups.  Also, you can protect this information
+from being downloaded by adding an exclude rule to the rsync.conf file
+(e.g. "exclude = /etc/").  To protect it from being changed by an upload
+(if the module is not read only), be sure to set the permissions (or
+owner) on the files and/or parent directories so that they cannot be
+written by the daemon.
 
 dit(bf(max connections)) The "max connections" option allows you to
 specify the maximum number of simultaneous connections you will allow.
 Any clients connecting when the maximum has been reached will receive a
 message telling them to try later.  The default is 0 which means no limit.
 See also the "lock file" option.
@@ -161,19 +181,19 @@
 
 dit(bf(list)) The "list" option determines if this module should be
 listed when the client asks for a listing of available modules. By
 setting this to false you can create hidden modules. The default is
 for modules to be listable.
 
-dit(bf(uid)) The "uid" option specifies the user name or user id that
+dit(bf(uid)) The "uid" option specifies the user name or user ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. In combination with the "gid" option this determines what
 file permissions are available. The default is uid -2, which is normally
 the user "nobody".
 
-dit(bf(gid)) The "gid" option specifies the group name or group id that
+dit(bf(gid)) The "gid" option specifies the group name or group ID that
 file transfers to and from that module should take place as when the daemon
 was run as root. This complements the "uid" option. The default is gid -2,
 which is normally the group "nobody".
 
 dit(bf(exclude)) The "exclude" option allows you to specify a space
 separated list of patterns to add to the exclude list.
@@ -226,13 +246,13 @@
 "secrets file" option. The default is for all users to be able to
 connect without a password (this is called "anonymous rsync").
 
 See also the bf(CONNECTING TO AN RSYNC SERVER OVER A REMOTE SHELL
 PROGRAM) section in rsync(1) for information on how handle an
 rsyncd.conf-level username that differs from the remote-shell-level
-username when using a remote shell to connect to a rsync server.
+username when using a remote shell to connect to an rsync server.
 
 dit(bf(secrets file)) The "secrets file" option specifies the name of
 a file that contains the username:password pairs used for
 authenticating this module. This file is only consulted if the "auth
 users" option is specified. The file is line based and contains
 username:password pairs separated by a single colon. Any line starting
@@ -244,13 +264,13 @@
 There is no default for the "secrets file" option, you must choose a name
 (such as tt(/etc/rsyncd.secrets)).  The file must normally not be readable
 by "other"; see "strict modes".
 
 dit(bf(strict modes)) The "strict modes" option determines whether or not 
 the permissions on the secrets file will be checked.  If "strict modes" is
-true, then the secrets file must not be readable by any user id other
+true, then the secrets file must not be readable by any user ID other
 than the one that the rsync daemon is running under.  If "strict modes" is
 false, the check is not performed.  The default is true.  This option
 was added to accommodate rsync running on the Windows operating system.
 
 dit(bf(hosts allow)) The "hosts allow" option allows you to specify a
 list of patterns that are matched against a connecting clients
@@ -303,16 +323,16 @@
 hostname and IP address. If the pattern matches then the connection is
 rejected. See the "hosts allow" option for more information.
 
 The default is no "hosts deny" option, which means all hosts can connect.
 
 dit(bf(ignore errors)) The "ignore errors" option tells rsyncd to
-ignore IO errors on the server when deciding whether to run the delete
+ignore I/O errors on the server when deciding whether to run the delete
 phase of the transfer. Normally rsync skips the --delete step if any
-IO errors have occurred in order to prevent disasterous deletion due
-to a temporary resource shortage or other IO error. In some cases this
+I/O errors have occurred in order to prevent disasterous deletion due
+to a temporary resource shortage or other I/O error. In some cases this
 test is counter productive so you can use this option to turn off this
 behaviour. 
 
 dit(bf(ignore nonreadable)) This tells the rsync server to completely
 ignore files that are not readable by the user. This is useful for
 public archives that may have some non-readable files among the
@@ -331,13 +351,13 @@
 The prefixes that are understood are:
 
 itemize(
   it() %h for the remote host name
   it() %a for the remote IP address
   it() %l for the length of the file in bytes
-  it() %p for the process id of this rsync session
+  it() %p for the process ID of this rsync session
   it() %o for the operation, which is either "send" or "recv"
   it() %f for the filename
   it() %P for the module path
   it() %m for the module name
   it() %t for the current date time
   it() %u for the authenticated username (or the null string)
@@ -350,13 +370,13 @@
 is always added to the beginning when using the "log file" option.
 
 A perl script called rsyncstats to summarize this format is included
 in the rsync source code distribution.
 
 dit(bf(timeout)) The "timeout" option allows you to override the
-clients choice for IO timeout for this module. Using this option you
+clients choice for I/O timeout for this module. Using this option you
 can ensure that rsync won't wait on a dead client forever. The timeout
 is specified in seconds. A value of zero means no timeout and is the
 default. A good choice for anonymous rsync servers may be 600 (giving
 a 10 minute timeout).
 
 dit(bf(refuse options)) The "refuse options" option allows you to
@@ -412,13 +432,13 @@
 "command=em(COMMAND)" syntax in the remote user's authorized_keys entry,
 where command would be
 
 quote(rsync --server --daemon .)
 
 NOTE: rsync's argument parsing expects the trailing ".", so make sure
-that it's there.  If you want to use a rsyncd.conf(5)-style
+that it's there.  If you want to use an rsyncd.conf(5)-style
 configuration file other than the default, you can added a
 --config option to the em(command):
 
 quote(rsync --server --daemon --config=em(file) .)
 
 Note that the "--server" here is the internal option that rsync uses to
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.h /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.h
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.h	2003-12-17 07:04:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.h	2004-04-27 09:36:16.000000000 +0800
@@ -24,37 +24,48 @@
 
 #define BLOCK_SIZE 700
 #define RSYNC_RSH_ENV "RSYNC_RSH"
 #define RSYNC_RSH_IO_ENV "RSYNC_RSH_IO"
 
 #define RSYNC_NAME "rsync"
-#define RSYNCD_SYSCONF "/etc/rsyncd.conf"
+/* RSYNCD_SYSCONF is now set in config.h */
 #define RSYNCD_USERCONF "rsyncd.conf"
 
 #define DEFAULT_LOCK_FILE "/var/run/rsyncd.lock"
 #define URL_PREFIX "rsync://"
 
 #define BACKUP_SUFFIX "~"
 
 /* a non-zero CHAR_OFFSET makes the rolling sum stronger, but is
    incompatible with older versions :-( */
 #define CHAR_OFFSET 0
 
+/* These flags are only used during the flist transfer. */
 
-#define FLAG_DELETE (1<<0)
-#define SAME_MODE (1<<1)
-#define SAME_RDEV (1<<2)
-#define SAME_UID (1<<3)
-#define SAME_GID (1<<4)
-#define SAME_DIR (1<<5)
-#define SAME_NAME SAME_DIR
-#define LONG_NAME (1<<6)
-#define SAME_TIME (1<<7)
+#define XMIT_TOP_DIR (1<<0)
+#define XMIT_SAME_MODE (1<<1)
+#define XMIT_EXTENDED_FLAGS (1<<2)
+#define XMIT_SAME_RDEV_pre28 XMIT_EXTENDED_FLAGS /* Only in protocols < 28 */
+#define XMIT_SAME_UID (1<<3)
+#define XMIT_SAME_GID (1<<4)
+#define XMIT_SAME_NAME (1<<5)
+#define XMIT_LONG_NAME (1<<6)
+#define XMIT_SAME_TIME (1<<7)
+#define XMIT_SAME_RDEV_MAJOR (1<<8)
+#define XMIT_HAS_IDEV_DATA (1<<9)
+#define XMIT_SAME_DEV (1<<10)
+#define XMIT_RDEV_MINOR_IS_SMALL (1<<11)
+
+/* These flags are used in the live flist data. */
+
+#define FLAG_TOP_DIR (1<<0)
+#define FLAG_HLINK_EOL (1<<1)	/* generator only */
+#define FLAG_MOUNT_POINT (1<<2)	/* sender only */
 
 /* update this if you make incompatible changes */
-#define PROTOCOL_VERSION 27
+#define PROTOCOL_VERSION 28
 
 /* We refuse to interoperate with versions that are not in this range.
  * Note that we assume we'll work with later versions: the onus is on
  * people writing them to make sure that they don't send us anything
  * we won't understand.
  *
@@ -67,14 +78,14 @@
  * MAX_PROTOCOL_VERSION: either to allow new major-rev versions that
  * do not interoperate with us, and (more likely) so that we can
  * detect an attempt to connect rsync to a non-rsync server, which is
  * unlikely to begin by sending a byte between MIN_PROTOCL_VERSION and
  * MAX_PROTOCOL_VERSION. */
 
-#define MIN_PROTOCOL_VERSION 17
-#define OLD_PROTOCOL_VERSION 20
+#define MIN_PROTOCOL_VERSION 20
+#define OLD_PROTOCOL_VERSION 25
 #define MAX_PROTOCOL_VERSION 40
 
 #define RSYNC_PORT 873
 
 #define SPARSE_WRITE_SIZE (1024)
 #define WRITE_SIZE (32*1024)
@@ -90,22 +101,33 @@
 #define MPLEX_BASE 7
 
 #define NO_EXCLUDES	0
 #define SERVER_EXCLUDES	1
 #define ALL_EXCLUDES	2
 
-#define MISSING_OK    0
-#define MISSING_FATAL 1
-
-#define ADD_INCLUDE 1
-#define ADD_EXCLUDE 0
-
-/* Log values.  I *think* what these mean is: FLOG goes to the server
- * logfile; FERROR and FINFO try to end up on the client, with
- * different levels of filtering. */
-enum logcode {FNONE=0, FERROR=1, FINFO=2, FLOG=3 };
+#define XFLG_FATAL_ERRORS	(1<<0)
+#define XFLG_DEF_INCLUDE	(1<<1)
+#define XFLG_WORDS_ONLY 	(1<<2)
+#define XFLG_WORD_SPLIT 	(1<<3)
+
+#define FULL_FLUSH	1
+#define NORMAL_FLUSH	0
+
+
+/* Log-message categories.  FLOG is only used on the daemon side to
+ * output messages to the log file. */
+enum logcode { FERROR=1, FINFO=2, FLOG=3 };
+
+/* Messages types that are sent over the message channel.  The logcode
+ * values must all be present here with identical numbers. */
+enum msgcode {
+	MSG_DATA=0,	/* raw data on the multiplexed stream */
+	MSG_ERROR=FERROR, MSG_INFO=FINFO, MSG_LOG=FLOG, /* remote logging */
+	MSG_REDO=4,	/* reprocess indicated flist index */
+	MSG_DONE=5,	/* current phase is done */
+};
 
 #include "errcode.h"
 
 #include "config.h"
 
 /* The default RSYNC_RSH is always set in config.h. */
@@ -221,18 +243,25 @@
 # endif
 # if HAVE_NDIR_H
 #  include <ndir.h>
 # endif
 #endif
 
+#if MAJOR_IN_MKDEV
+#include <sys/mkdev.h>
+#elif MAJOR_IN_SYSMACROS
+#include <sys/sysmacros.h>
+#endif
+
 #ifdef HAVE_COMPAT_H
 #include <compat.h>
 #endif
 
 #include <assert.h>
 
+#include "lib/pool_alloc.h"
 
 #define BOOL int
 
 #ifndef uchar
 #define uchar unsigned char
 #endif
@@ -313,23 +342,20 @@
  *
  * Note that if you transfer devices from a 64-bit-devt machine (say,
  * Solaris) to a 32-bit-devt machine (say, Linux-2.2/x86) then the
  * device numbers will be truncated.  But it's a kind of silly thing
  * to do anyhow.
  *
- * FIXME: In future, we should probable split the device number into
- * major/minor, and transfer the two parts as 32-bit ints.  That gives
- * you somewhat more of a chance that they'll come from a big machine
- * to a little one in a useful way.
- *
- * FIXME: Really we need an unsigned type, and we perhaps ought to
- * cope with platforms on which this is an unsigned int or even a
- * struct.  Later.
+ * FIXME: I don't think the code in flist.c has ever worked on a system
+ * where dev_t is a struct.
  */ 
-#define INO64_T uint64
-#define DEV64_T uint64
+
+struct idev {
+	uint64 inode;
+	uint64 dev;
+};
 
 #ifndef MIN
 #define MIN(a,b) ((a)<(b)?(a):(b))
 #endif
 
 #ifndef MAX
@@ -359,64 +385,93 @@
 #endif
 
 #ifndef IN_LOOPBACKNET
 #define IN_LOOPBACKNET 127
 #endif
 
-struct file_struct {
-	unsigned flags;
-	time_t modtime;
-	OFF_T length;
-	mode_t mode;
+#define GID_NONE (gid_t) -1
 
-	INO64_T inode;
-	/** Device this file lives upon */
-	DEV64_T dev;
+#define HL_CHECK_MASTER	0
+#define HL_SKIP		1
 
-	/** If this is a device node, the device number. */
-	DEV64_T rdev;
-	uid_t uid;
-	gid_t gid;
+struct hlink {
+	int hlindex;
+	struct file_struct *next;
+};
+
+#define F_DEV	link_u.idev->dev
+#define F_INODE	link_u.idev->inode
+
+#define F_HLINDEX link_u.links->hlindex
+#define F_NEXT	link_u.links->next
+
+struct file_struct {
+	union {
+		dev_t rdev;	/* The device number, if this is a device */
+		char *sum;	/* Only a normal file can have a checksum */
+		char *link;	/* Points to symlink string, if a symlink */
+	} u;
+	OFF_T length;
 	char *basename;
 	char *dirname;
 	char *basedir;
-	char *link;
-	char *sum;
+	union {
+		struct idev *idev;
+		struct hlink *links;
+	} link_u;
+	time_t modtime;
+	uid_t uid;
+	gid_t gid;
+	mode_t mode;
+	uchar flags;	/* this item MUST remain last */
 };
 
+/*
+ * Start the flist array at FLIST_START entries and grow it
+ * by doubling until FLIST_LINEAR then grow by FLIST_LINEAR
+ */
+#define FLIST_START	(32 * 1024)
+#define FLIST_LINEAR	(FLIST_START * 512)
+
+/*
+ * Extent size for allocation pools A minimum size of 128KB
+ * is needed to mmap them so that freeing will release the
+ * space to the OS.
+ *
+ * Larger sizes reduce leftover fragments and speed free calls
+ * (when they happen) Smaller sizes increase the chance of
+ * freed allocations freeing whole extents.
+ */
+#define FILE_EXTENT	(256 * 1024)
+#define HLINK_EXTENT	(128 * 1024)
 
-#define ARENA_SIZE	(32 * 1024)
-
-struct string_area {
-	char *base;
-	char *end;
-	char *current;
-	struct string_area *next;
-};
+#define WITH_HLINK	1
+#define WITHOUT_HLINK	0
 
 struct file_list {
 	int count;
 	int malloced;
+	alloc_pool_t file_pool;
+	alloc_pool_t hlink_pool;
 	struct file_struct **files;
-	struct string_area *string_area;
 };
 
 struct sum_buf {
 	OFF_T offset;		/**< offset in file of this chunk */
-	int len;		/**< length of chunk of file */
+	unsigned int len;	/**< length of chunk of file */
 	int i;			/**< index of this chunk */
 	uint32 sum1;	        /**< simple checksum */
 	char sum2[SUM_LENGTH];	/**< checksum  */
 };
 
 struct sum_struct {
 	OFF_T flength;		/**< total file length */
 	size_t count;		/**< how many chunks */
-	size_t remainder;	/**< flength % block_length */
-	size_t blength;		/**< block_length */
-	size_t s2length;	/**< sum2_length */
+	unsigned int blength;	/**< block_length */
+	unsigned int remainder;	/**< flength % block_length */
+	int s2length;		/**< sum2_length */
 	struct sum_buf *sums;	/**< points to info for each chunk */
 };
 
 struct map_struct {
 	char *p;		/* Window pointer			*/
 	int fd;			/* File Descriptor			*/
@@ -433,29 +488,37 @@
 
 #define MATCHFLG_WILD		(1<<0) /* pattern has '*', '[', and/or '?' */
 #define MATCHFLG_WILD2		(1<<1) /* pattern has '**' */
 #define MATCHFLG_WILD2_PREFIX	(1<<2) /* pattern starts with '**' */
 #define MATCHFLG_ABS_PATH	(1<<3) /* path-match on absolute path */
 struct exclude_struct {
+	struct exclude_struct *next;
 	char *pattern;
 	int match_flags;
 	int include;
 	int directory;
 	int slash_cnt;
 };
 
+struct exclude_list_struct {
+	struct exclude_struct *head;
+	struct exclude_struct *tail;
+	char *debug_type;
+};
+
 struct stats {
 	int64 total_size;
 	int64 total_transferred_size;
 	int64 total_written;
 	int64 total_read;
 	int64 literal_data;
 	int64 matched_data;
 	int flist_size;
 	int num_files;
 	int num_transferred_files;
+	int current_file_index;
 };
 
 
 /* we need this function because of the silly way in which duplicate
    entries are handled in the file lists - we can't change this
    without breaking existing versions */
@@ -532,12 +595,16 @@
 #endif
 
 #ifndef STDERR_FILENO
 #define STDERR_FILENO 2
 #endif
 
+#ifndef S_IRUSR
+#define S_IRUSR 0400
+#endif
+
 #ifndef S_IWUSR
 #define S_IWUSR 0200
 #endif
 
 #ifndef ACCESSPERMS
 #define ACCESSPERMS 0777
@@ -664,12 +731,23 @@
 #ifndef WEXITSTATUS
 #define	WEXITSTATUS(stat)	((int)(((stat)>>8)&0xFF))
 #endif
 
 #define exit_cleanup(code) _exit_cleanup(code, __FILE__, __LINE__)
 
+#ifdef HAVE_GETEUID
+#define MY_UID() geteuid()
+#else
+#define MY_UID() getuid()
+#endif
+
+#ifdef HAVE_GETEGID
+#define MY_GID() getegid()
+#else
+#define MY_GID() getgid()
+#endif
 
 extern int verbose;
 
 #ifndef HAVE_INET_NTOP
 const char *                 
 inet_ntop(int af, const void *src, char *dst, size_t size);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.yo /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.yo
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/rsync.yo	2004-01-02 03:00:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/rsync.yo	2004-04-27 11:54:05.000000000 +0800
@@ -1,8 +1,8 @@
 mailto(rsync-bugs@samba.org)
-manpage(rsync)(1)(1 Jan 2004)()()
+manpage(rsync)(1)(26 Apr 2004)()()
 manpagename(rsync)(faster, flexible replacement for rcp)
 manpagesynopsis()
 
 rsync [OPTION]... SRC [SRC]... [USER@]HOST:DEST
 
 rsync [OPTION]... [USER@]HOST:SRC DEST
@@ -58,29 +58,29 @@
 	it() for copying from a remote machine to the local machine
 	using a remote shell program. This is invoked when the source
 	contains a : separator.
 
 	it() for copying from a remote rsync server to the local
 	machine. This is invoked when the source path contains a ::
-	separator or a rsync:// URL.
+	separator or an rsync:// URL.
 
 	it() for copying from the local machine to a remote rsync
 	server. This is invoked when the destination path contains a ::
-	separator or a rsync:// URL.
+	separator or an rsync:// URL.
 
 	it() for copying from a remote machine using a remote shell
 	program as the transport, using rsync server on the remote
 	machine.  This is invoked when the source path contains a ::
 	separator and the --rsh=COMMAND (aka "-e COMMAND") option is
 	also provided.
 
 	it() for copying from the local machine to a remote machine
 	using a remote shell program as the transport, using rsync
 	server on the remote machine.  This is invoked when the
 	destination path contains a :: separator and the
-	--rsh=COMMMAND option is also provided.
+	--rsh=COMMAND option is also provided.
 
 	it() for listing files on a remote machine. This is done the
 	same way as rsync transfers except that you leave off the
 	local destination.  
 )
 
@@ -108,13 +108,13 @@
 
 manpagesection(USAGE)
 
 You use rsync in the same way you use rcp. You must specify a source
 and a destination, one of which may be remote.
 
-Perhaps the best way to explain the syntax is some examples:
+Perhaps the best way to explain the syntax is with some examples:
 
 quote(rsync *.c foo:src/)
 
 This would transfer all files matching the pattern *.c from the
 current directory to the directory src on the machine foo. If any of
 the files already exist on the remote system then the rsync
@@ -123,13 +123,13 @@
 
 quote(rsync -avz foo:src/bar /data/tmp)
 
 This would recursively transfer all files from the directory src/bar on the
 machine foo into the /data/tmp/bar directory on the local machine. The
 files are transferred in "archive" mode, which ensures that symbolic
-links, devices, attributes, permissions, ownerships etc are preserved
+links, devices, attributes, permissions, ownerships, etc. are preserved
 in the transfer.  Additionally, compression will be used to reduce the
 size of data portions of the transfer.
 
 quote(rsync -avz foo:src/bar/ /data/tmp)
 
 A trailing slash on the source changes this behavior to avoid creating an
@@ -159,21 +159,21 @@
 It is also possible to use rsync without a remote shell as the
 transport. In this case you will connect to a remote rsync server
 running on TCP port 873. 
 
 You may establish the connection via a web proxy by setting the
 environment variable RSYNC_PROXY to a hostname:port pair pointing to
-your web proxy.  Note that your web proxy's configuration must allow
-proxying to port 873.
+your web proxy.  Note that your web proxy's configuration must support
+proxy connections to port 873.
 
 Using rsync in this way is the same as using it with a remote shell except
 that:
 
 itemize(
 	it() you use a double colon :: instead of a single colon to
-	separate the hostname from the path or a rsync:// URL.
+	separate the hostname from the path or an rsync:// URL.
 
 	it() the remote server may print a message of the day when you
 	connect.
 
 	it() if you specify no path name on the remote server then the
 	list of accessible paths on the server will be shown.
@@ -214,13 +214,13 @@
 
 The "ssh-user" will be used at the ssh level; the "rsync-user" will be
 used to check against the rsyncd.conf on the remote host.
 
 manpagesection(RUNNING AN RSYNC SERVER)
 
-An rsync server is configured using a config file.  Please see the 
+An rsync server is configured using a configuration file.  Please see the 
 rsyncd.conf(5) man page for more information.  By default the configuration
 file is called /etc/rsyncd.conf, unless rsync is running over a remote
 shell program and is not running as root; in that case, the default name
 is rsyncd.conf in the current directory on the remote computer 
 (typically $HOME).
 
@@ -287,15 +287,15 @@
      --no-implied-dirs       don't send implied dirs with -R
  -b, --backup                make backups (see --suffix & --backup-dir)
      --backup-dir            make backups into this directory
      --suffix=SUFFIX         backup suffix (default ~ w/o --backup-dir)
  -u, --update                update only (don't overwrite newer files)
  -l, --links                 copy symlinks as symlinks
- -L, --copy-links            copy the referent of symlinks
-     --copy-unsafe-links     copy links outside the source tree
-     --safe-links            ignore links outside the destination tree
+ -L, --copy-links            copy the referent of all symlinks
+     --copy-unsafe-links     copy the referent of "unsafe" symlinks
+     --safe-links            ignore "unsafe" symlinks
  -H, --hard-links            preserve hard links
  -p, --perms                 preserve permissions
  -o, --owner                 preserve owner (root only)
  -g, --group                 preserve group
  -D, --devices               preserve devices (root only)
  -t, --times                 preserve times
@@ -308,19 +308,19 @@
  -e, --rsh=COMMAND           specify the remote shell
      --rsync-path=PATH       specify path to rsync on the remote machine
      --existing              only update files that already exist
      --ignore-existing       ignore files that already exist on receiver
      --delete                delete files that don't exist on sender
      --delete-excluded       also delete excluded files on receiver
-     --delete-after          delete after transferring, not before
-     --ignore-errors         delete even if there are IO errors
+     --delete-after          receiver deletes after transfer, not before
+     --ignore-errors         delete even if there are I/O errors
      --max-delete=NUM        don't delete more than NUM files
      --partial               keep partially transferred files
      --force                 force deletion of dirs even if not empty
      --numeric-ids           don't map uid/gid values by user/group name
-     --timeout=TIME          set IO timeout in seconds
+     --timeout=TIME          set I/O timeout in seconds
  -I, --ignore-times          turn off mod time & file size quick check
      --size-only             ignore mod time for quick check (use size)
      --modify-window=NUM     compare mod times with reduced accuracy
  -T  --temp-dir=DIR          create temporary files in directory DIR
      --compare-dest=DIR      also compare received files relative to DIR
      --link-dest=DIR         create hardlinks to DIR for unchanged files
@@ -331,18 +331,18 @@
      --exclude-from=FILE     exclude patterns listed in FILE
      --include=PATTERN       don't exclude files matching PATTERN
      --include-from=FILE     don't exclude patterns listed in FILE
      --files-from=FILE       read FILE for list of source-file names
  -0  --from0                 all file lists are delimited by nulls
      --version               print version number
-     --daemon                run as a rsync daemon
+     --daemon                run as an rsync daemon
      --no-detach             do not detach from the parent
      --address=ADDRESS       bind to the specified address
      --config=FILE           specify alternate rsyncd.conf file
      --port=PORT             specify alternate rsyncd port number
-     --blocking-io           use blocking IO for the remote shell
+     --blocking-io           use blocking I/O for the remote shell
      --no-blocking-io        turn off --blocking-io
      --stats                 give some file transfer stats
      --progress              show progress during transfer
      --log-format=FORMAT     log file transfers using specified format
      --password-file=FILE    get password from FILE
      --bwlimit=KBPS          limit I/O bandwidth, KBytes per second
@@ -381,15 +381,15 @@
 cron.
 
 dit(bf(-I, --ignore-times)) Normally rsync will skip any files that are
 already the same size and have the same modification time-stamp.
 This option turns off this "quick check" behavior.
 
-dit(bf(--size-only)) Normally rsync will skip any files that are
+dit(bf(--size-only)) Normally rsync will not transfer any files that are
 already the same size and have the same modification time-stamp. With the
---size-only option files will be skipped if they have the same size,
+--size-only option, files will not be transferred if they have the same size,
 regardless of timestamp. This is useful when starting to use rsync
 after using another mirroring system which may not preserve timestamps
 exactly.
 
 dit(bf(--modify-window)) When comparing two timestamps rsync treats
 the timestamps as being equal if they are within the value of
@@ -399,13 +399,13 @@
 with a 1 second resolution --modify-window=1 is useful.
 
 dit(bf(-c, --checksum)) This forces the sender to checksum all files using
 a 128-bit MD4 checksum before transfer. The checksum is then
 explicitly checked on the receiver and any files of the same name
 which already exist and have the same checksum and size on the
-receiver are skipped.  This option can be quite slow.
+receiver are not transferred.  This option can be quite slow.
 
 dit(bf(-a, --archive)) This is equivalent to -rlptgoD. It is a quick
 way of saying you want recursion and want to preserve almost
 everything.  
 
 Note however that bf(-a) bf(does not preserve hardlinks), because
@@ -455,34 +455,43 @@
 dit(bf(--backup-dir=DIR)) In combination with the --backup option, this
 tells rsync to store all backups in the specified directory. This is
 very useful for incremental backups.  You can additionally
 specify a backup suffix using the --suffix option
 (otherwise the files backed up in the specified directory
 will keep their original filenames).
+If DIR is a relative path, it is relative to the destination directory
+(which changes in a recursive transfer).
 
 dit(bf(--suffix=SUFFIX)) This option allows you to override the default
 backup suffix used with the --backup (-b) option. The default suffix is a ~
 if no --backup-dir was specified, otherwise it is an empty string.
 
 dit(bf(-u, --update)) This forces rsync to skip any files for which the
 destination file already exists and has a date later than the source
 file.
 
+In the currently implementation, a difference of file format is always
+considered to be important enough for an update, no matter what date
+is on the objects.  In other words, if the source has a directory or a
+symlink where the destination has a file, the transfer would occur
+regardless of the timestamps.  This might change in the future (feel
+free to comment on this on the mailing list if you have an opinion).
+
 dit(bf(-l, --links)) When symlinks are encountered, recreate the
 symlink on the destination.
 
 dit(bf(-L, --copy-links)) When symlinks are encountered, the file that
-they point to is copied, rather than the symlink.
+they point to (the referent) is copied, rather than the symlink.
 
 dit(bf(--copy-unsafe-links)) This tells rsync to copy the referent of
-symbolic links that point outside the source tree.  Absolute symlinks
+symbolic links that point outside the copied tree.  Absolute symlinks
 are also treated like ordinary files, and so are any symlinks in the
 source path itself when --relative is used.
 
 dit(bf(--safe-links)) This tells rsync to ignore any symbolic links
-which point outside the destination tree. All absolute symlinks are
+which point outside the copied tree. All absolute symlinks are
 also ignored. Using this option in conjunction with --relative may
 give unexpected results. 
 
 dit(bf(-H, --hard-links)) This tells rsync to recreate hard  links  on
 the  remote system  to  be the same as the local system. Without this
 option hard links are treated like regular files.
@@ -493,13 +502,13 @@
 This option can be quite slow, so only use it if you need it.
 
 dit(bf(-W, --whole-file)) With this option the incremental rsync algorithm
 is not used and the whole file is sent as-is instead.  The transfer may be
 faster if this option is used when the bandwidth between the source and
 target machines is higher than the bandwidth to disk (especially when the
-"disk" is actually a networked file system).  This is the default when both
+"disk" is actually a networked filesystem).  This is the default when both
 the source and target are on the local machine.
 
 dit(bf(--no-whole-file)) Turn off --whole-file, for use when it is the
 default.
 
 dit(bf(-p, --perms)) This option causes rsync to set the destination
@@ -509,21 +518,22 @@
 source file's permissions and the umask at the receiving end, while all
 other files (including updated files) retain their existing permissions
 (which is the same behavior as other file-copy utilities, such as cp).
 
 dit(bf(-o, --owner)) This option causes rsync to set the owner of the
 destination file to be the same as the source file.  On most systems,
-only the super-user can set file ownership.  Note that if the remote system
-is a daemon using chroot, the --numeric-ids option is implied because the
-remote system cannot get access to the usernames from /etc/passwd.
+only the super-user can set file ownership.  By default, the preservation
+is done by name, but may fall back to using the ID number in some
+circumstances.  See the --numeric-ids option for a full discussion.
 
 dit(bf(-g, --group)) This option causes rsync to set the group of the
 destination file to be the same as the source file.  If the receiving
 program is not running as the super-user, only groups that the
-receiver is a member of will be preserved (by group name, not group id
-number).
+receiver is a member of will be preserved.  By default, the preservation
+is done by name, but may fall back to using the ID number in some
+circumstances.  See the --numeric-ids option for a full discussion.
 
 dit(bf(-D, --devices)) This option causes rsync to transfer character and
 block device information to the remote system to recreate these
 devices. This option is only available to the super-user.
 
 dit(bf(-t, --times)) This tells rsync to transfer modification times along
@@ -566,30 +576,30 @@
 This option has no effect if directory recursion is not selected.
 
 This option can be dangerous if used incorrectly!  It is a very good idea
 to run first using the dry run option (-n) to see what files would be
 deleted to make sure important files aren't listed.
 
-If the sending side detects any IO errors then the deletion of any
+If the sending side detects any I/O errors then the deletion of any
 files at the destination will be automatically disabled. This is to
 prevent temporary filesystem failures (such as NFS errors) on the
 sending side causing a massive deletion of files on the
 destination.  You can override this with the --ignore-errors option.
 
 dit(bf(--delete-excluded)) In addition to deleting the files on the
 receiving side that are not on the sending side, this tells rsync to also
 delete any files on the receiving side that are excluded (see --exclude).
 Implies --delete.
 
-dit(bf(--delete-after)) By default rsync does file deletions before
-transferring files to try to ensure that there is sufficient space on
-the receiving filesystem. If you want to delete after transferring
-then use the --delete-after switch. Implies --delete.
+dit(bf(--delete-after)) By default rsync does file deletions on the
+receiving side before transferring files to try to ensure that there is
+sufficient space on the receiving filesystem. If you want to delete
+after transferring, use the --delete-after switch. Implies --delete.
 
 dit(bf(--ignore-errors)) Tells --delete to go ahead and delete files
-even when there are IO errors.
+even when there are I/O errors.
 
 dit(bf(--force)) This options tells rsync to delete directories even if
 they are not empty when they are to be replaced by non-directories.  This
 is only relevant without --delete because deletions are now done depth-first.
 Requires the --recursive option (which is implied by -a) to have any effect.
 
@@ -599,13 +609,13 @@
 dit(bf(-e, --rsh=COMMAND)) This option allows you to choose an alternative
 remote shell program to use for communication between the local and
 remote copies of rsync. Typically, rsync is configured to use ssh by
 default, but you may prefer to use rsh on a local network.
 
 If this option is used with bf([user@]host::module/path), then the
-remote shell em(COMMMAND) will be used to run an rsync server on the
+remote shell em(COMMAND) will be used to run an rsync server on the
 remote host, and all data will be transmitted through that remote
 shell connection, rather than through a direct socket connection to a
 running rsync server on the remote host.  See the section "CONNECTING
 TO AN RSYNC SERVER OVER A REMOTE SHELL PROGRAM" above.
 
 Command-line arguments are permitted in COMMAND provided that COMMAND is
@@ -630,45 +640,44 @@
 broad range of files that you often don't want to transfer between
 systems. It uses the same algorithm that CVS uses to determine if
 a file should be ignored.
 
 The exclude list is initialized to:
 
-quote(RCS/ SCCS/ CVS/ .svn/ CVS.adm RCSLOG cvslog.* tags TAGS .make.state
-.nse_depinfo *~ #* .#* ,* *.old *.bak *.BAK *.orig *.rej .del-*
-*.a *.o *.obj *.so *.Z *.elc *.ln core)
+quote(RCS SCCS CVS CVS.adm RCSLOG cvslog.* tags TAGS .make.state
+.nse_depinfo *~ #* .#* ,* _$* *$ *.old *.bak *.BAK *.orig *.rej
+.del-* *.a *.olb *.o *.obj *.so *.exe *.Z *.elc *.ln core .svn/)
 
 then files listed in a $HOME/.cvsignore are added to the list and any
-files listed in the CVSIGNORE environment variable (space delimited).
+files listed in the CVSIGNORE environment variable (all cvsignore names
+are delimited by whitespace).
 
 Finally, any file is ignored if it is in the same directory as a
-.cvsignore file and matches one of the patterns listed therein.  See
-the bf(cvs(1)) manual for more information.
+.cvsignore file and matches one of the patterns listed therein.
+See the bf(cvs(1)) manual for more information.
 
 dit(bf(--exclude=PATTERN)) This option allows you to selectively exclude
 certain files from the list of files to be transferred. This is most
 useful in combination with a recursive transfer.
 
 You may use as many --exclude options on the command line as you like
 to build up the list of files to exclude.
 
-See the EXCLUDE PATTERNS section for information on the syntax of 
-this option.
+See the EXCLUDE PATTERNS section for detailed information on this option.
 
 dit(bf(--exclude-from=FILE)) This option is similar to the --exclude
 option, but instead it adds all exclude patterns listed in the file
 FILE to the exclude list.  Blank lines in FILE and lines starting with
 ';' or '#' are ignored.
 If em(FILE) is bf(-) the list will be read from standard input.
 
 dit(bf(--include=PATTERN)) This option tells rsync to not exclude the
 specified pattern of filenames. This is useful as it allows you to
 build up quite complex exclude/include rules.
 
-See the EXCLUDE PATTERNS section for information on the syntax of 
-this option.
+See the EXCLUDE PATTERNS section for detailed information on this option.
 
 dit(bf(--include-from=FILE)) This specifies a list of include patterns
 from a file.
 If em(FILE) is bf(-) the list will be read from standard input.
 
 dit(bf(--files-from=FILE)) Using this option allows you to specify the
@@ -708,12 +717,14 @@
 This would copy all the files specified in the /path/file-list file that
 was located on the remote "src" host.
 
 dit(bf(-0, --from0)) This tells rsync that the filenames it reads from a
 file are terminated by a null ('\0') character, not a NL, CR, or CR+LF.
 This affects --exclude-from, --include-from, and --files-from.
+It does not affect --cvs-exclude (since all names read from a .cvsignore
+file are split on whitespace).
 
 dit(bf(-T, --temp-dir=DIR)) This option instructs rsync to use DIR as a
 scratch directory when creating temporary copies of the files
 transferred on the receiving side.  The default behavior is to create
 the temporary files in the receiving directory.
 
@@ -725,45 +736,53 @@
 flash-cutover when all files have been successfully transferred (for
 example by moving directories around and removing the old directory,
 although this skips files that haven't changed; see also --link-dest).
 This option increases the usefulness of --partial because partially
 transferred files will remain in the new temporary destination until they
 have a chance to be completed.  If DIR is a relative path, it is relative
-to the destination directory.
+to the destination directory (which changes in a recursive transfer).
 
 dit(bf(--link-dest=DIR)) This option behaves like bf(--compare-dest) but
 also will create hard links from em(DIR) to the destination directory for
 unchanged files.  Files with changed ownership or permissions will not be
 linked.
 Like bf(--compare-dest) if DIR is a relative path, it is relative
-to the destination directory.
+to the destination directory (which changes in a recursive transfer).
+An example:
+
+verb(
+    rsync -av --link-dest=$PWD/prior_dir host:src_dir/ new_dir/
+)
 
 dit(bf(-z, --compress)) With this option, rsync compresses any data from
 the files that it sends to the destination machine.  This
 option is useful on slow connections.  The compression method used is the
 same method that gzip uses.
 
 Note this this option typically achieves better compression ratios
 that can be achieved by using a compressing remote shell, or a
 compressing transport, as it takes advantage of the implicit
 information sent for matching data blocks.
 
 dit(bf(--numeric-ids)) With this option rsync will transfer numeric group
-and user ids rather than using user and group names and mapping them
+and user IDs rather than using user and group names and mapping them
 at both ends.
 
-By default rsync will use the user name and group name to determine
+By default rsync will use the username and groupname to determine
 what ownership to give files. The special uid 0 and the special group
 0 are never mapped via user/group names even if the --numeric-ids
 option is not specified.
 
-If the source system is a daemon using chroot, or if a user or group
-name does not exist on the destination system, then the numeric id
-from the source system is used instead.
+If a user or group has no name on the source system or it has no match
+on the destination system, then the numeric ID
+from the source system is used instead.  See also the comments on the
+"use chroot" setting in the rsyncd.conf manpage for information on how
+the chroot setting affects rsync's ability to look up the names of the
+users and groups and what you can do about it.
 
-dit(bf(--timeout=TIMEOUT)) This option allows you to set a maximum IO
+dit(bf(--timeout=TIMEOUT)) This option allows you to set a maximum I/O
 timeout in seconds. If no data is transferred for the specified time
 then rsync will exit. The default is 0, which means no timeout.
 
 dit(bf(--daemon)) This tells rsync that it is to run as a daemon.  The
 daemon may be accessed using the bf(host::module) or
 bf(rsync://host/module/) syntax.
@@ -796,17 +815,17 @@
 a remote shell program and the remote user is not root; in that case
 the default is rsyncd.conf in the current directory (typically $HOME).
 
 dit(bf(--port=PORT)) This specifies an alternate TCP port number to use
 rather than the default port 873.
 
-dit(bf(--blocking-io)) This tells rsync to use blocking IO when launching
+dit(bf(--blocking-io)) This tells rsync to use blocking I/O when launching
 a remote shell transport.  If the remote shell is either rsh or remsh,
 rsync defaults to using
-blocking IO, otherwise it defaults to using non-blocking IO.  (Note that
-ssh prefers non-blocking IO.)
+blocking I/O, otherwise it defaults to using non-blocking I/O.  (Note that
+ssh prefers non-blocking I/O.)
 
 dit(bf(--no-blocking-io)) Turn off --blocking-io, for use when it is the
 default.
 
 dit(bf(--log-format=FORMAT)) This allows you to specify exactly what the
 rsync client logs to stdout on a per-file basis. The log format is
@@ -825,29 +844,52 @@
 
 dit(bf(--progress)) This option tells rsync to print information
 showing the progress of the transfer. This gives a bored user
 something to watch.
 Implies --verbose without incrementing verbosity.
 
+When the file is transferring, the data looks like this:
+
+verb(
+      782448  63%  110.64kB/s    0:00:04
+)
+
+This tells you the current file size, the percentage of the transfer that
+is complete, the current calculated file-completion rate (including both
+data over the wire and data being matched locally), and the estimated time
+remaining in this transfer.
+
+After the a file is complete, it the data looks like this:
+
+verb(
+     1238099 100%  146.38kB/s    0:00:08  (5, 57.1% of 396)
+)
+
+This tells you the final file size, that it's 100% complete, the final
+transfer rate for the file, the amount of elapsed time it took to transfer
+the file, and the addition of a total-transfer summary in parentheses.
+These additional numbers tell you how many files have been updated, and
+what percent of the total number of files has been scanned.
+
 dit(bf(-P)) The -P option is equivalent to --partial --progress. I
 found myself typing that combination quite often so I created an
 option to make it easier.
 
 dit(bf(--password-file)) This option allows you to provide a password
 in a file for accessing a remote rsync server. Note that this option
-is only useful when accessing a rsync server using the built in
+is only useful when accessing an rsync server using the built in
 transport, not when using a remote shell as the transport. The file
 must not be world readable. It should contain just the password as a
 single line.
 
 dit(bf(--bwlimit=KBPS)) This option allows you to specify a maximum
 transfer rate in kilobytes per second. This option is most effective when
 using rsync with large files (several megabytes and up). Due to the nature
 of rsync transfers, blocks of data are sent, then if rsync determines the
 transfer was too fast, it will wait before sending the next data block. The
-result is an average transfer rate equalling the specified limit. A value
+result is an average transfer rate equaling the specified limit. A value
 of zero specifies no limit.
 
 dit(bf(--write-batch=PREFIX)) Generate a set of files that can be
 transferred as a batch update. Each filename in the set starts with
 PREFIX. See the "BATCH MODE" section for details.
 
@@ -859,30 +901,75 @@
 
 manpagesection(EXCLUDE PATTERNS)
 
 The exclude and include patterns specified to rsync allow for flexible
 selection of which files to transfer and which files to skip.
 
-rsync builds an ordered list of include/exclude options as specified on
+Rsync builds an ordered list of include/exclude options as specified on
 the command line. Rsync checks each file and directory 
 name against each exclude/include pattern in turn. The first matching
 pattern is acted on. If it is an exclude pattern, then that file is
 skipped. If it is an include pattern then that filename is not
 skipped. If no matching include/exclude pattern is found then the
 filename is not skipped.
 
-The filenames matched against the exclude/include patterns
-are relative to the destination directory, or "top
-directory", so patterns should not include the path elements
-of the source or destination directories.  The only way in
-which a pattern will match the absolute path of a file or
-directory is if the source path is the root directory.
+The filenames matched against the exclude/include patterns are relative
+to the "root of the transfer".  If you think of the transfer as a
+subtree of names that are being sent from sender to receiver, the root
+is where the tree starts to be duplicated in the destination directory.
+This root governs where patterns that start with a / match (see below).
+
+Because the matching is relative to the transfer-root, changing the
+trailing slash on a source path or changing your use of the --relative
+option affects the path you need to use in your matching (in addition to
+changing how much of the file tree is duplicated on the destination
+system).  The following examples demonstrate this.
+
+Let's say that we want to match two source files, one with an absolute
+path of "/home/me/foo/bar", and one with a path of "/home/you/bar/baz".
+Here is how the various command choices differ for a 2-source transfer:
 
-Note that when used with -r (which is implied by -a), every subcomponent of
-every path is visited from top down, so include/exclude patterns get
+verb(
+   Example cmd: rsync -a /home/me /home/you /dest
+   +/- pattern: /me/foo/bar
+   +/- pattern: /you/bar/baz
+   Target file: /dest/me/foo/bar
+   Target file: /dest/you/bar/baz
+
+   Example cmd: rsync -a /home/me/ /home/you/ /dest
+   +/- pattern: /foo/bar               (note missing "me")
+   +/- pattern: /bar/baz               (note missing "you")
+   Target file: /dest/foo/bar
+   Target file: /dest/bar/baz
+
+   Example cmd: rsync -a --relative /home/me/ /home/you /dest
+   +/- pattern: /home/me/foo/bar       (note full path)
+   +/- pattern: /home/you/bar/baz      (ditto)
+   Target file: /dest/home/me/foo/bar
+   Target file: /dest/home/you/bar/baz
+
+   Example cmd: cd /home; rsync -a --relative me/foo you/ /dest
+   +/- pattern: /me/foo/bar      (starts at specified path)
+   +/- pattern: /you/bar/baz     (ditto)
+   Target file: /dest/me/foo/bar
+   Target file: /dest/you/bar/baz
+)
+
+The easiest way to see what name you should include/exclude is to just
+look at the output when using --verbose and put a / in front of the name
+(use the --dry-run option if you're not yet ready to copy any files).
+
+Note that, when using the --recursive (-r) option (which is implied by -a),
+every subcomponent of
+every path is visited from the top down, so include/exclude patterns get
 applied recursively to each subcomponent.
+The exclude patterns actually short-circuit the directory traversal stage
+when rsync finds the files to send.  If a pattern excludes a particular
+parent directory, it can render a deeper include pattern ineffectual
+because rsync did not descend through that excluded section of the
+hierarchy.
 
 Note also that the --include and --exclude options take one pattern
 each. To add multiple patterns use the --include-from and
 --exclude-from options or multiple --include and --exclude options. 
 
 The patterns can take several forms. The rules are:
@@ -890,22 +977,21 @@
 itemize(
 
   it() if the pattern starts with a / then it is matched against the
   start of the filename, otherwise it is matched against the end of
   the filename.
   This is the equivalent of a leading ^ in regular expressions.
-  Thus "/foo" would match a file called "foo" at the top of the
-  transferred tree.
+  Thus "/foo" would match a file called "foo" at the transfer-root
+  (see above for how this is different from the filesystem-root).
   On the other hand, "foo" would match any file called "foo"
   anywhere in the tree because the algorithm is applied recursively from
   top down; it behaves as if each path component gets a turn at being the
   end of the file name.
-  The leading / does not make the pattern an absolute pathname.
 
   it() if the pattern ends with a / then it will only match a
-  directory, not a file, link or device.
+  directory, not a file, link, or device.
 
   it() if the pattern contains a wildcard character from the set
   *?[ then expression matching is applied using the shell filename
   matching rules. Otherwise a simple string match is used.
 
   it() the double asterisk pattern "**" will match slashes while a
@@ -917,43 +1003,63 @@
   matched only against the final component of the filename.  Again,
   remember that the algorithm is applied recursively so "full filename" can
   actually be any portion of a path below the starting directory.
 
   it() if the pattern starts with "+ " (a plus followed by a space)
   then it is always considered an include pattern, even if specified as
-  part of an exclude option. The "+ " part is discarded before matching.
+  part of an exclude option. The prefix is discarded before matching.
 
   it() if the pattern starts with "- " (a minus followed by a space)
   then it is always considered an exclude pattern, even if specified as
-  part of an include option. The "- " part is discarded before matching.
+  part of an include option. The prefix is discarded before matching.
 
   it() if the pattern is a single exclamation mark ! then the current
   include/exclude list is reset, removing all previously defined patterns.
 )
 
 The +/- rules are most useful in a list that was read from a file, allowing
 you to have a single exclude list that contains both include and exclude
-options.
+options in the proper order.
 
-If you end an exclude list with --exclude '*', note that since the
-algorithm is applied recursively that unless you explicitly include
-parent directories of files you want to include then the algorithm
-will stop at the parent directories and never see the files below
-them.  To include all directories, use --include '*/' before the
---exclude '*'.
+Remember that the matching occurs at every step in the traversal of the
+directory hierarchy, so you must be sure that all the parent directories of
+the files you want to include are not excluded.  This is particularly
+important when using a trailing '*' rule.  For instance, this won't work:
 
-Here are some exclude/include examples:
+verb(
+    + /some/path/this-file-will-not-be-found
+    + /file-is-included
+    - *
+)
+
+This fails because the parent directory "some" is excluded by the '*' rule,
+so rsync never visits any of the files in the "some" or "some/path"
+directories.  One solution is to ask for all directories in the hierarchy
+to be included by using a single rule: --include='*/' (put it somewhere
+before the --excludde='*' rule).  Another solution is to add specific
+include rules for all the parent dirs that need to be visited.  For
+instance, this set of rules works fine:
+
+verb(
+    + /some/
+    + /some/path/
+    + /some/path/this-file-is-found
+    + /file-also-included
+    - *
+)
+
+Here are some examples of exclude/include matching:
 
 itemize(
   it() --exclude "*.o" would exclude all filenames matching *.o
-  it() --exclude "/foo" would exclude a file called foo in the top directory
+  it() --exclude "/foo" would exclude a file called foo in the transfer-root directory
   it() --exclude "foo/" would exclude any directory called foo
   it() --exclude "/foo/*/bar" would exclude any file called bar two
-  levels below a directory called foo in the top directory
+  levels below a directory called foo in the transfer-root directory
   it() --exclude "/foo/**/bar" would exclude any file called bar two
-  or more levels below a directory called foo in the top directory
+  or more levels below a directory called foo in the transfer-root directory
   it() --include "*/" --include "*.c" --exclude "*" would include all 
   directories and C source files
   it() --include "foo/" --include "foo/bar.c" --exclude "*" would include
   only foo/bar.c (the foo/ directory must be explicitly included or
   it would be excluded by the "*")
 )
@@ -1001,17 +1107,17 @@
 be used to transfer the batch update files in parallel to many hosts at
 once, instead of sending the same data to every host individually.
 
 Example:
 
 verb(
-$ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
-$ rcp pfx.rsync_* remote:
-$ ssh remote rsync --read-batch=pfx -a /bdest/dir/
-# or alternatively
-$ ssh remote ./pfx.rsync_argvs /bdest/dir/
+   $ rsync --write-batch=pfx -a /source/dir/ /adest/dir/
+   $ rcp pfx.rsync_* remote:
+   $ ssh remote rsync --read-batch=pfx -a /bdest/dir/
+   # or alternatively
+   $ ssh remote ./pfx.rsync_argvs /bdest/dir/
 )
 
 In this example, rsync is used to update /adest/dir/ with /source/dir/
 and the information to repeat this operation is stored in the files
 pfx.rsync_*. These files are then copied to the machine named "remote".
 Rsync is then invoked on "remote" to update /bdest/dir/ the same way as
@@ -1059,13 +1165,13 @@
 rsync also distinguishes "safe" and "unsafe" symbolic links.  An
 example where this might be used is a web site mirror that wishes
 ensure the rsync module they copy does not include symbolic links to
 bf(/etc/passwd) in the public section of the site.  Using
 bf(--copy-unsafe-links) will cause any links to be copied as the file
 they point to on the destination.  Using bf(--safe-links) will cause
-unsafe links to be ommitted altogether.
+unsafe links to be omitted altogether.
 
 Symbolic links are considered unsafe if they are absolute symlinks
 (start with bf(/)), empty, or if they contain enough bf("..")
 components to ascend from the directory being copied.
 
 manpagesection(DIAGNOSTICS)
@@ -1101,17 +1207,17 @@
 dit(bf(0)) Success
 dit(bf(1)) Syntax or usage error 
 dit(bf(2)) Protocol incompatibility 
 dit(bf(3)) Errors selecting input/output files, dirs
 dit(bf(4)) Requested action not supported: an attempt
 was made to manipulate 64-bit files on a platform that cannot support
-them; or an option was speciifed that is supported by the client and
+them; or an option was specifed that is supported by the client and
 not by the server.
 dit(bf(5)) Error starting client-server protocol
-dit(bf(10)) Error in socket IO 
-dit(bf(11)) Error in file IO 
+dit(bf(10)) Error in socket I/O 
+dit(bf(11)) Error in file I/O 
 dit(bf(12)) Error in rsync protocol data stream 
 dit(bf(13)) Errors with program diagnostics 
 dit(bf(14)) Error in IPC code 
 dit(bf(20)) Received SIGUSR1 or SIGINT 
 dit(bf(21)) Some error returned by waitpid() 
 dit(bf(22)) Error allocating core memory buffers 
@@ -1134,18 +1240,19 @@
 
 dit(bf(RSYNC_PROXY)) The RSYNC_PROXY environment variable allows you to
 redirect your rsync client to use a web proxy when connecting to a
 rsync daemon. You should set RSYNC_PROXY to a hostname:port pair.
 
 dit(bf(RSYNC_PASSWORD)) Setting RSYNC_PASSWORD to the required
-password allows you to run authenticated rsync connections to a rsync
+password allows you to run authenticated rsync connections to an rsync
 daemon without user intervention. Note that this does not supply a
 password to a shell transport such as ssh.
 
 dit(bf(USER) or bf(LOGNAME)) The USER or LOGNAME environment variables
-are used to determine the default username sent to a rsync server.
+are used to determine the default username sent to an rsync server.
+If neither is set, the username defaults to "nobody".
 
 dit(bf(HOME)) The HOME environment variable is used to find the user's
 default .cvsignore file.
 
 enddit()
 
@@ -1160,17 +1267,17 @@
 manpagediagnostics()
 
 manpagebugs()
 
 times are transferred as unix time_t values
 
-When transferring to FAT filesystmes rsync may resync
+When transferring to FAT filesystems rsync may resync
 unmodified files.
 See the comments on the --modify-window option.
 
-file permissions, devices etc are transferred as native numerical
+file permissions, devices, etc. are transferred as native numerical
 values
 
 see also the comments on the --delete option
 
 Please report bugs! See the website at
 url(http://rsync.samba.org/)(http://rsync.samba.org/)
@@ -1196,22 +1303,16 @@
 manpagesection(THANKS)
 
 Thanks to Richard Brent, Brendan Mackay, Bill Waite, Stephen Rothwell
 and David Bell for helpful suggestions, patches and testing of rsync.
 I've probably missed some people, my apologies if I have.
 
-Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer.
-
+Especial thanks also to: David Dykstra, Jos Backus, Sebastian Krahmer,
+Martin Pool, Wayne Davison.
 
 manpageauthor()
 
-rsync was written by Andrew Tridgell <tridge@samba.org> and Paul
-Mackerras.
-
-rsync is now maintained by Martin Pool <mbp@samba.org>.  
+rsync was originally written by Andrew Tridgell and Paul Mackerras.
+Many people have later contributed to it.
 
 Mailing lists for support and development are available at
 url(http://lists.samba.org)(lists.samba.org) 
-
-If you suspect you have found a security vulnerability in rsync,
-please send it directly to Martin Pool and Andrew Tridgell.  For other
-enquiries, please use the mailing list.
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/runtests.sh /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/runtests.sh
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/runtests.sh	2003-01-22 03:27:11.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/runtests.sh	2004-02-04 13:34:29.000000000 +0800
@@ -139,13 +139,13 @@
 
 echo "============================================================"
 echo "$0 running in `pwd`"
 echo "    rsync_bin=$rsync_bin"
 echo "    srcdir=$srcdir"
 
-testuser=`whoami || echo UNKNOWN`
+testuser=`id -un || whoami || echo UNKNOWN`
 
 echo "    testuser=$testuser"
 echo "    os=`uname -a`"
 
 # It must be "yes", not just nonnull
 if test "x$preserve_scratch" = xyes
@@ -217,12 +217,17 @@
 
     if [ "x$always_log" = xyes -o \( $result != 0 -a $result != 77 -a $result != 78 \) ]
     then
 	echo "----- $testbase log follows"
 	cat "$scratchdir/test.log"
 	echo "----- $testbase log ends"
+	if [ -f "$scratchdir/rsyncd.log" ]; then
+	    echo "----- $testbase rsyncd.log follows"
+	    cat "$scratchdir/rsyncd.log"
+	    echo "----- $testbase rsyncd.log ends"
+	fi
     fi
 
     case $result in
     0)
 	echo "PASS    $testbase"
 	passed=`expr $passed + 1`
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/sender.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/sender.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/sender.c	2003-12-20 06:19:54.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/sender.c	2004-02-18 05:57:44.000000000 +0800
@@ -22,12 +22,14 @@
 extern int verbose;
 extern int csum_length;
 extern struct stats stats;
 extern int io_error;
 extern int dry_run;
 extern int am_server;
+extern int am_daemon;
+extern int protocol_version;
 
 
 /**
  * @file
  *
  * The sender gets checksums from the generator, calculates deltas,
@@ -31,18 +33,14 @@
  * @file
  *
  * The sender gets checksums from the generator, calculates deltas,
  * and transmits them to the receiver.  The sender process runs on the
  * machine holding the source files.
  **/
-
-
 void read_sum_head(int f, struct sum_struct *sum)
 {
-	extern int protocol_version;
-
 	sum->count = read_int(f);
 	sum->blength = read_int(f);
 	if (protocol_version < 27) {
 		sum->s2length = csum_length;
 	} else {
 		sum->s2length = read_int(f);
@@ -68,16 +66,16 @@
 	if (!s) out_of_memory("receive_sums");
 
 	read_sum_head(f, s);
 
 	s->sums = NULL;
 
-	if (verbose > 3)
-		rprintf(FINFO, "count=%ld n=%ld rem=%ld\n",
-			(long) s->count, (long) s->blength,
-			(long) s->remainder);
+	if (verbose > 3) {
+		rprintf(FINFO, "count=%ld n=%u rem=%u\n",
+			(long)s->count, s->blength, s->remainder);
+	}
 
 	if (s->count == 0)
 		return(s);
 
 	s->sums = new_array(struct sum_buf, s->count);
 	if (!s->sums) out_of_memory("receive_sums");
@@ -117,25 +115,25 @@
 	char fname[MAXPATHLEN];
 	int i;
 	struct file_struct *file;
 	int phase = 0;
 	extern struct stats stats;
 	struct stats initial_stats;
-	extern int write_batch;   /* dw */
-	extern int read_batch;    /* dw */
-	int checksums_match;   /* dw */
-	int buff_len;  /* dw */
-	char buff[CHUNK_SIZE];    /* dw */
-	int j;   /* dw */
-	int done;   /* dw */
+	extern int write_batch;
+	extern int read_batch;
+	int checksums_match;
+	int buff_len;
+	char buff[CHUNK_SIZE];
+	int j;
+	int done;
 
 	if (verbose > 2)
 		rprintf(FINFO, "send_files starting\n");
 
 	while (1) {
-		int offset = 0;
+		unsigned int offset;
 
 		i = read_int(f_in);
 		if (i == -1) {
 			if (phase == 0) {
 				phase++;
 				csum_length = SUM_LENGTH;
@@ -152,28 +150,24 @@
 				i, flist->count);
 			exit_cleanup(RERR_PROTOCOL);
 		}
 
 		file = flist->files[i];
 
+		stats.current_file_index = i;
 		stats.num_transferred_files++;
 		stats.total_transferred_size += file->length;
 
-		fname[0] = 0;
 		if (file->basedir) {
-			strlcpy(fname, file->basedir, MAXPATHLEN);
-			if (strlen(fname) == MAXPATHLEN-1) {
-				io_error |= IOERR_GENERAL;
-				rprintf(FERROR, "send_files failed on long-named directory %s\n",
-					full_fname(fname));
-				return;
-			}
-			strlcat(fname, "/", MAXPATHLEN);
-			offset = strlen(file->basedir)+1;
-		}
-		strlcat(fname, f_name(file), MAXPATHLEN);
+			/* N.B. We're sure that this fits, so offset is OK. */
+			offset = strlcpy(fname, file->basedir, sizeof fname);
+			if (!offset || fname[offset-1] != '/')
+				fname[offset++] = '/';
+		} else
+			offset = 0;
+		f_name_to(file, fname + offset);
 
 		if (verbose > 2)
 			rprintf(FINFO, "send_files(%d, %s)\n", i, fname);
 
 		if (dry_run) {
 			if (!am_server && verbose) {	/* log transfer */
@@ -190,20 +184,23 @@
 			io_error |= IOERR_GENERAL;
 			rprintf(FERROR, "receive_sums failed\n");
 			return;
 		}
 
 		if (write_batch)
-			write_batch_csum_info(&i, flist->count, s);
+			write_batch_csum_info(&i, s);
 
 		if (!read_batch) {
 			fd = do_open(fname, O_RDONLY, 0);
 			if (fd == -1) {
 				if (errno == ENOENT) {
+					enum logcode c = am_daemon
+					    && protocol_version < 28 ? FERROR
+								     : FINFO;
 					io_error |= IOERR_VANISHED;
-					rprintf(FINFO, "file has vanished: %s\n",
+					rprintf(c, "file has vanished: %s\n",
 			 			full_fname(fname));
 				} else {
 					io_error |= IOERR_GENERAL;
 					rprintf(FERROR, "send_files failed to open %s: %s\n",
 						full_fname(fname), strerror(errno));
 				}
@@ -230,13 +227,13 @@
 				rprintf(FINFO, "send_files mapped %s of size %.0f\n",
 					fname, (double)st.st_size);
 
 			write_int(f_out, i);
 
 			if (write_batch)
-				write_batch_delta_file((char *)&i, sizeof(i));
+				write_batch_delta_file((char *)&i, sizeof i);
 
 			write_sum_head(f_out, s);
 		}
 
 		if (verbose > 2 && !read_batch)
 			rprintf(FINFO, "calling match_sums %s\n", fname);
@@ -244,29 +241,29 @@
 		if (!am_server && verbose) {	/* log transfer */
 			rprintf(FINFO, "%s\n", fname+offset);
 		}
 
 		set_compression(fname);
 
-		if (read_batch) { /* dw */
+		if (read_batch) {
 			/* read checksums originally computed on sender side */
 			read_batch_csum_info(i, s, &checksums_match);
 			if (checksums_match) {
-				read_batch_delta_file( (char *) &j, sizeof(int) );
+				read_batch_delta_file((char*)&j, sizeof (int));
 				if (j != i) {    /* if flist index entries don't match*/
 					rprintf(FINFO, "index mismatch in send_files\n");
 					rprintf(FINFO, "read index = %d flist ndx = %d\n", j, i);
 					close_batch_delta_file();
 					close_batch_csums_file();
 					exit_cleanup(1);
 				} else {
 					write_int(f_out, j);
 					write_sum_head(f_out, s);
 					done = 0;
 					while (!done) {
-						read_batch_delta_file( (char *) &buff_len, sizeof(int) );
+						read_batch_delta_file((char*)&buff_len, sizeof (int));
 						write_int(f_out, buff_len);
 						if (buff_len == 0) {
 							done = 1;
 						} else {
 							if (buff_len > 0) {
 								read_batch_delta_file(buff, buff_len);
@@ -285,13 +282,13 @@
 			}
 		} else  {
 			match_sums(f_out, s, buf, st.st_size);
 			log_send(file, &initial_stats);
 		}
 
-		if (!read_batch) { /* dw */
+		if (!read_batch) {
 			if (buf) {
 				j = unmap_file(buf);
 				if (j) {
 					io_error |= IOERR_GENERAL;
 					rprintf(FERROR,
 					    "read errors mapping %s: (%d) %s\n",
@@ -310,13 +307,13 @@
 	if (verbose > 2)
 		rprintf(FINFO, "send files finished\n");
 
 	match_report();
 
 	write_int(f_out, -1);
-	if (write_batch || read_batch) { /* dw */
+	if (write_batch || read_batch) {
 		close_batch_csums_file();
 		close_batch_delta_file();
 	}
 
 }
 
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/socket.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/socket.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/socket.c	2003-08-22 13:04:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/socket.c	2004-04-15 00:51:48.000000000 +0800
@@ -1,31 +1,31 @@
 /* -*- c-file-style: "linux" -*-
-   
+
    rsync -- fast file replication program
-   
+
    Copyright (C) 1992-2001 by Andrew Tridgell <tridge@samba.org>
    Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /**
  * @file socket.c
- * 
+ *
  * Socket functions used in rsync.
  *
  * This file is now converted to use the new-style getaddrinfo()
  * interface, which supports IPv6 but is also supported on recent
  * IPv4-only machines.  On systems that don't have that interface, we
  * emulate it using the KAME implementation.
@@ -33,27 +33,51 @@
 
 #include "rsync.h"
 
 
 /**
  * Establish a proxy connection on an open socket to a web proxy by
- * using the HTTP CONNECT method.
+ * using the CONNECT method. If proxy_user and proxy_pass are not NULL,
+ * they are used to authenticate to the proxy using the "Basic"
+ * proxy-authorization protocol
  **/
-static int establish_proxy_connection(int fd, char *host, int port)
+static int establish_proxy_connection(int fd, char *host, int port,
+				      char *proxy_user, char *proxy_pass)
 {
-	char buffer[1024];
-	char *cp;
+	char *cp, buffer[1024];
+	char *authhdr, authbuf[1024];
+	int len;
+
+	if (proxy_user && proxy_pass) {
+		stringjoin(buffer, sizeof buffer,
+			 proxy_user, ":", proxy_pass, NULL);
+		len = strlen(buffer);
+
+		if ((len*8 + 5) / 6 >= (int)sizeof authbuf) {
+			rprintf(FERROR,
+				"authentication information is too long\n");
+			return -1;
+		}
 
-	snprintf(buffer, sizeof(buffer), "CONNECT %s:%d HTTP/1.0\r\n\r\n", host, port);
-	if (write(fd, buffer, strlen(buffer)) != (int) strlen(buffer)) {
+		base64_encode(buffer, len, authbuf);
+		authhdr = "\r\nProxy-Authorization: Basic ";
+	} else {
+		*authbuf = '\0';
+		authhdr = "";
+	}
+
+	snprintf(buffer, sizeof buffer, "CONNECT %s:%d HTTP/1.0%s%s\r\n\r\n",
+		 host, port, authhdr, authbuf);
+	len = strlen(buffer);
+	if (write(fd, buffer, len) != len) {
 		rprintf(FERROR, "failed to write to proxy: %s\n",
 			strerror(errno));
 		return -1;
 	}
 
-	for (cp = buffer; cp < &buffer[sizeof(buffer) - 1]; cp++) {
+	for (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {
 		if (read(fd, cp, 1) != 1) {
 			rprintf(FERROR, "failed to read from proxy: %s\n",
 				strerror(errno));
 			return -1;
 		}
 		if (*cp == '\n')
@@ -67,54 +91,51 @@
 		*cp = '\0';
 	if (strncmp(buffer, "HTTP/", 5) != 0) {
 		rprintf(FERROR, "bad response from proxy - %s\n",
 			buffer);
 		return -1;
 	}
-	for (cp = &buffer[5]; isdigit(* (unsigned char *) cp) || (*cp == '.'); cp++)
-		;
+	for (cp = &buffer[5]; isdigit(*(uchar*)cp) || *cp == '.'; cp++) {}
 	while (*cp == ' ')
 		cp++;
 	if (*cp != '2') {
 		rprintf(FERROR, "bad response from proxy - %s\n",
 			buffer);
 		return -1;
 	}
 	/* throw away the rest of the HTTP header */
 	while (1) {
-		for (cp = buffer; cp < &buffer[sizeof(buffer) - 1];
-		     cp++) {
+		for (cp = buffer; cp < &buffer[sizeof buffer - 1]; cp++) {
 			if (read(fd, cp, 1) != 1) {
 				rprintf(FERROR, "failed to read from proxy: %s\n",
 					strerror(errno));
 				return -1;
 			}
 			if (*cp == '\n')
 				break;
 		}
-		if ((cp > buffer) && (*cp == '\n'))
+		if (cp > buffer && *cp == '\n')
 			cp--;
-		if ((cp == buffer) && ((*cp == '\n') || (*cp == '\r')))
+		if (cp == buffer && (*cp == '\n' || *cp == '\r'))
 			break;
 	}
 	return 0;
 }
 
 
 /**
  * Try to set the local address for a newly-created socket.  Return -1
  * if this fails.
  **/
-int try_bind_local(int s,
-		   int ai_family, int ai_socktype,
+int try_bind_local(int s, int ai_family, int ai_socktype,
 		   const char *bind_address)
 {
 	int error;
 	struct addrinfo bhints, *bres_all, *r;
 
-	memset(&bhints, 0, sizeof(bhints));
+	memset(&bhints, 0, sizeof bhints);
 	bhints.ai_family = ai_family;
 	bhints.ai_socktype = ai_socktype;
 	bhints.ai_flags = AI_PASSIVE;
 	if ((error = getaddrinfo(bind_address, NULL, &bhints, &bres_all))) {
 		rprintf(FERROR, RSYNC_NAME ": getaddrinfo %s: %s\n",
 			bind_address, gai_strerror(error));
@@ -157,48 +178,65 @@
  * @param af_hint Address family, e.g. AF_INET or AF_INET6.
  **/
 int open_socket_out(char *host, int port, const char *bind_address,
 		    int af_hint)
 {
 	int type = SOCK_STREAM;
-	int error;
-	int s;
+	int error, s;
 	struct addrinfo hints, *res0, *res;
 	char portbuf[10];
-	char *h;
+	char *h, *cp;
 	int proxied = 0;
 	char buffer[1024];
-	char *cp;
+	char *proxy_user = NULL, *proxy_pass = NULL;
 
 	/* if we have a RSYNC_PROXY env variable then redirect our
-	 * connetcion via a web proxy at the given address. The format
-	 * is hostname:port */
+	 * connetcion via a web proxy at the given address. */
 	h = getenv("RSYNC_PROXY");
-	proxied = (h != NULL) && (*h != '\0');
+	proxied = h != NULL && *h != '\0';
 
 	if (proxied) {
-		strlcpy(buffer, h, sizeof(buffer));
-		cp = strchr(buffer, ':');
-		if (cp == NULL) {
+		strlcpy(buffer, h, sizeof buffer);
+
+		/* Is the USER:PASS@ prefix present? */
+		if ((cp = strchr(buffer, '@')) != NULL) {
+			*cp++ = '\0';
+			/* The remainder is the HOST:PORT part. */
+			h = cp;
+
+			if ((cp = strchr(buffer, ':')) == NULL) {
+				rprintf(FERROR,
+					"invalid proxy specification: should be USER:PASS@HOST:PORT\n");
+				return -1;
+			}
+			*cp++ = '\0';
+
+			proxy_user = buffer;
+			proxy_pass = cp;
+		} else {
+			/* The whole buffer is the HOST:PORT part. */
+			h = buffer;
+		}
+
+		if ((cp = strchr(h, ':')) == NULL) {
 			rprintf(FERROR,
 				"invalid proxy specification: should be HOST:PORT\n");
 			return -1;
 		}
 		*cp++ = '\0';
-		strcpy(portbuf, cp);
-		h = buffer;
+		strlcpy(portbuf, cp, sizeof portbuf);
 		if (verbose >= 2) {
 			rprintf(FINFO, "connection via http proxy %s port %s\n",
 				h, portbuf);
 		}
 	} else {
-		snprintf(portbuf, sizeof(portbuf), "%d", port);
+		snprintf(portbuf, sizeof portbuf, "%d", port);
 		h = host;
 	}
 
-	memset(&hints, 0, sizeof(hints));
+	memset(&hints, 0, sizeof hints);
 	hints.ai_family = af_hint;
 	hints.ai_socktype = type;
 	error = getaddrinfo(h, portbuf, &hints, &res0);
 	if (error) {
 		rprintf(FERROR, RSYNC_NAME ": getaddrinfo: %s %s: %s\n",
 			h, portbuf, gai_strerror(error));
@@ -212,32 +250,32 @@
 	 * address record tells us what protocol to use to try to connect. */
 	for (res = res0; res; res = res->ai_next) {
 		s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
 		if (s < 0)
 			continue;
 
-		if (bind_address)
-			if (try_bind_local(s, res->ai_family, type,
-					   bind_address) == -1) {
-				close(s);
-				s = -1;
-				continue;
-			}
-
+		if (bind_address
+		 && try_bind_local(s, res->ai_family, type,
+				   bind_address) == -1) {
+			close(s);
+			s = -1;
+			continue;
+		}
 		if (connect(s, res->ai_addr, res->ai_addrlen) < 0) {
 			close(s);
 			s = -1;
 			continue;
 		}
-		if (proxied &&
-		    establish_proxy_connection(s, host, port) != 0) {
+		if (proxied
+		 && establish_proxy_connection(s, host, port,
+					       proxy_user, proxy_pass) != 0) {
 			close(s);
 			s = -1;
 			continue;
-		} else
-			break;
+		}
+		break;
 	}
 	freeaddrinfo(res0);
 	if (s < 0) {
 		rprintf(FERROR, RSYNC_NAME ": failed to connect to %s: %s\n",
 			h, strerror(errno));
 		return -1;
@@ -255,110 +293,132 @@
  * cause security problems by really opening remote connections.
  *
  * This is based on the Samba LIBSMB_PROG feature.
  *
  * @param bind_address Local address to use.  Normally NULL to get the stack default.
  **/
-int open_socket_out_wrapped (char *host,
-			     int port,
-			     const char *bind_address,
-			     int af_hint)
-{
-	char *prog;
-
-	if ((prog = getenv ("RSYNC_CONNECT_PROG")) != NULL) 
-		return sock_exec (prog);
-	else 
-		return open_socket_out (host, port, bind_address,
-					af_hint);
+int open_socket_out_wrapped(char *host, int port, const char *bind_address,
+			    int af_hint)
+{
+	char *prog = getenv("RSYNC_CONNECT_PROG");
+
+	if (verbose >= 2) {
+		rprintf(FINFO, "%sopening tcp connection to %s port %d\n",
+			prog ? "Using RSYNC_CONNECT_PROG instead of " : "",
+			host, port);
+	}
+	if (prog)
+		return sock_exec(prog);
+	return open_socket_out(host, port, bind_address, af_hint);
 }
 
 
 
 /**
  * Open a socket of the specified type, port and address for incoming data
  *
  * Try to be better about handling the results of getaddrinfo(): when
  * opening an inbound socket, we might get several address results,
- * e.g. for the machine's ipv4 and ipv6 name.  
- * 
+ * e.g. for the machine's ipv4 and ipv6 name.
+ *
  * If binding a wildcard, then any one of them should do.  If an address
  * was specified but it's insufficiently specific then that's not our
- * fault.  
- * 
+ * fault.
+ *
  * However, some of the advertized addresses may not work because e.g. we
  * don't have IPv6 support in the kernel.  In that case go on and try all
  * addresses until one succeeds.
- * 
+ *
  * @param bind_address Local address to bind, or NULL to allow it to
  * default.
  **/
-static int open_socket_in(int type, int port, const char *bind_address,
-			  int af_hint)
+static int *open_socket_in(int type, int port, const char *bind_address,
+			   int af_hint)
 {
 	int one=1;
-	int s;
+	int s, *sp, *socks, maxs;
 	struct addrinfo hints, *all_ai, *resp;
 	char portbuf[10];
 	int error;
 
-	memset(&hints, 0, sizeof(hints));
+	memset(&hints, 0, sizeof hints);
 	hints.ai_family = af_hint;
 	hints.ai_socktype = type;
 	hints.ai_flags = AI_PASSIVE;
-	snprintf(portbuf, sizeof(portbuf), "%d", port);
+	snprintf(portbuf, sizeof portbuf, "%d", port);
 	error = getaddrinfo(bind_address, portbuf, &hints, &all_ai);
 	if (error) {
 		rprintf(FERROR, RSYNC_NAME ": getaddrinfo: bind address %s: %s\n",
 			bind_address, gai_strerror(error));
-		return -1;
+		return NULL;
+	}
+
+	/* Count max number of sockets we might open. */
+	for (maxs = 0, resp = all_ai; resp; resp = resp->ai_next, maxs++) {}
+	socks = new_array(int, maxs + 1);
+	if (!socks) {
+		rprintf(FERROR,
+			RSYNC_NAME "couldn't allocate memory for sockets");
+		return NULL;
 	}
 
 	/* We may not be able to create the socket, if for example the
 	 * machine knows about IPv6 in the C library, but not in the
 	 * kernel. */
+	sp = socks + 1; /* Leave room for count at start of array. */
 	for (resp = all_ai; resp; resp = resp->ai_next) {
 		s = socket(resp->ai_family, resp->ai_socktype,
 			   resp->ai_protocol);
 
-		if (s == -1) 
+		if (s == -1) {
 			/* See if there's another address that will work... */
 			continue;
-		
+		}
+
 		setsockopt(s, SOL_SOCKET, SO_REUSEADDR,
 			   (char *)&one, sizeof one);
-		
-		/* now we've got a socket - we need to bind it */
-		if (bind(s, all_ai->ai_addr, all_ai->ai_addrlen) < 0) {
+
+#ifdef IPV6_V6ONLY
+		if (resp->ai_family == AF_INET6) {
+			setsockopt(s, IPPROTO_IPV6, IPV6_V6ONLY,
+				   (char *)&one, sizeof one);
+		}
+#endif
+
+		/* Now we've got a socket - we need to bind it. */
+		if (bind(s, resp->ai_addr, resp->ai_addrlen) < 0) {
 			/* Nope, try another */
 			close(s);
 			continue;
 		}
 
-		freeaddrinfo(all_ai);
-		return s;
+		*sp++ = s;
 	}
+	*socks = sp - socks - 1;   /* Save count. */
 
-	rprintf(FERROR, RSYNC_NAME ": open inbound socket on port %d failed: "
-		"%s\n",
-		port, 
-		strerror(errno));
+	if (all_ai)
+		freeaddrinfo(all_ai);
 
-	freeaddrinfo(all_ai);
-	return -1; 
+	if (*socks == 0) {
+		rprintf(FERROR,
+			RSYNC_NAME ": open inbound socket on port %d failed: "
+			"%s\n", port, strerror(errno));
+		free(socks);
+		return NULL;
+	}
+	return socks;
 }
 
 
 /*
  * Determine if a file descriptor is in fact a socket
  */
 int is_a_socket(int fd)
 {
 	int v;
-	socklen_t l;
-	l = sizeof(int);
+	socklen_t l = sizeof (int);
 
         /* Parameters to getsockopt, setsockopt etc are very
          * unstandardized across platforms, so don't be surprised if
          * there are compiler warnings on e.g. SCO OpenSwerver or AIX.
          * It seems they all eventually get the right idea.
          *
@@ -367,77 +427,95 @@
          * 4.* and libc4 and libc5 have).  Some POSIX confusion
          * resulted in the present socklen_t.  The draft standard has
          * not been adopted yet, but glibc2 already follows it and
          * also has socklen_t [*]. See also accept(2).''
          *
          * We now return to your regularly scheduled programming.  */
-	return(getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&v, &l) == 0);
+	return getsockopt(fd, SOL_SOCKET, SO_TYPE, (char *)&v, &l) == 0;
 }
 
 
 static RETSIGTYPE sigchld_handler(UNUSED(int val))
 {
-	signal(SIGCHLD, sigchld_handler);
 #ifdef WNOHANG
 	while (waitpid(-1, NULL, WNOHANG) > 0) {}
 #endif
+	signal(SIGCHLD, sigchld_handler);
 }
 
 
 void start_accept_loop(int port, int (*fn)(int, int))
 {
-	int s;
+	fd_set deffds;
+	int *sp, maxfd, i, j;
 	extern char *bind_address;
 	extern int default_af_hint;
 
 	/* open an incoming socket */
-	s = open_socket_in(SOCK_STREAM, port, bind_address, default_af_hint);
-	if (s == -1)
+	sp = open_socket_in(SOCK_STREAM, port, bind_address, default_af_hint);
+	if (sp == NULL)
 		exit_cleanup(RERR_SOCKETIO);
 
 	/* ready to listen */
-	if (listen(s, 5) == -1) {
-		close(s);
-		exit_cleanup(RERR_SOCKETIO);
+	FD_ZERO(&deffds);
+	maxfd = -1;
+	for (i = 1; i <= *sp; i++) {
+		if (listen(sp[i], 5) == -1) {
+			for (j = 1; j <= i; j++)
+				close(sp[j]);
+			free(sp);
+			exit_cleanup(RERR_SOCKETIO);
+		}
+		FD_SET(sp[i], &deffds);
+		if (maxfd < sp[i])
+			maxfd = sp[i];
 	}
 
 
 	/* now accept incoming connections - forking a new process
-	   for each incoming connection */
+	 * for each incoming connection */
 	while (1) {
 		fd_set fds;
 		pid_t pid;
 		int fd;
 		struct sockaddr_storage addr;
 		socklen_t addrlen = sizeof addr;
 
 		/* close log file before the potentially very long select so
-		   file can be trimmed by another process instead of growing
-		   forever */
+		 * file can be trimmed by another process instead of growing
+		 * forever */
 		log_close();
 
-		FD_ZERO(&fds);
-		FD_SET(s, &fds);
+#ifdef FD_COPY
+		FD_COPY(&deffds, &fds);
+#else
+		fds = deffds;
+#endif
 
-		if (select(s+1, &fds, NULL, NULL, NULL) != 1) {
+		if (select(maxfd + 1, &fds, NULL, NULL, NULL) != 1)
 			continue;
-		}
 
-		if(!FD_ISSET(s, &fds)) continue;
-
-		fd = accept(s,(struct sockaddr *)&addr,&addrlen);
+		fd = -1;
+		for (i = 1; i <= *sp; i++) {
+			if (FD_ISSET(sp[i], &fds)) {
+				fd = accept(sp[i], (struct sockaddr *)&addr,
+					    &addrlen);
+				break;
+			}
+		}
 
-		if (fd == -1) continue;
+		if (fd < 0)
+			continue;
 
 		signal(SIGCHLD, sigchld_handler);
 
 		if ((pid = fork()) == 0) {
 			int ret;
-			close(s);
+			close(sp[i]);
 			/* open log file in child before possibly giving
-			   up privileges  */
+			 * up privileges  */
 			log_open();
 			ret = fn(fd, fd);
 			close_all();
 			_exit(ret);
 		} else if (pid < 0) {
 			rprintf(FERROR,
@@ -451,12 +529,13 @@
 			sleep(2);
 		} else {
 			/* Parent doesn't need this fd anymore. */
 			close(fd);
 		}
 	}
+	free(sp);
 }
 
 
 enum SOCK_OPT_TYPES {OPT_BOOL,OPT_INT,OPT_ON};
 
 struct
@@ -496,66 +575,72 @@
 #endif
 #ifdef SO_RCVTIMEO
   {"SO_RCVTIMEO",       SOL_SOCKET,    SO_RCVTIMEO,     0,                 OPT_INT},
 #endif
   {NULL,0,0,0,0}};
 
-	
+
 
 /**
  * Set user socket options
  **/
 void set_socket_options(int fd, char *options)
 {
 	char *tok;
-	if (!options || !*options) return;
+
+	if (!options || !*options)
+		return;
 
 	options = strdup(options);
-	
-	if (!options) out_of_memory("set_socket_options");
 
-	for (tok=strtok(options, " \t,"); tok; tok=strtok(NULL," \t,")) {
+	if (!options)
+		out_of_memory("set_socket_options");
+
+	for (tok = strtok(options, " \t,"); tok; tok = strtok(NULL," \t,")) {
 		int ret=0,i;
 		int value = 1;
 		char *p;
 		int got_value = 0;
 
 		if ((p = strchr(tok,'='))) {
 			*p = 0;
 			value = atoi(p+1);
 			got_value = 1;
 		}
 
-		for (i=0;socket_options[i].name;i++)
+		for (i = 0; socket_options[i].name; i++) {
 			if (strcmp(socket_options[i].name,tok)==0)
 				break;
+		}
 
 		if (!socket_options[i].name) {
 			rprintf(FERROR,"Unknown socket option %s\n",tok);
 			continue;
 		}
 
 		switch (socket_options[i].opttype) {
 		case OPT_BOOL:
 		case OPT_INT:
 			ret = setsockopt(fd,socket_options[i].level,
-					 socket_options[i].option,(char *)&value,sizeof(int));
+					 socket_options[i].option,
+					 (char *)&value, sizeof (int));
 			break;
-			
+
 		case OPT_ON:
 			if (got_value)
 				rprintf(FERROR,"syntax error - %s does not take a value\n",tok);
 
 			{
 				int on = socket_options[i].value;
 				ret = setsockopt(fd,socket_options[i].level,
-						 socket_options[i].option,(char *)&on,sizeof(int));
+						 socket_options[i].option,
+						 (char *)&on, sizeof (int));
 			}
-			break;	  
+			break;
 		}
-		
+
 		if (ret != 0)
 			rprintf(FERROR, "failed to set socket option %s: %s\n", tok,
 				strerror(errno));
 	}
 
 	free(options);
@@ -576,90 +661,99 @@
 #ifdef HAVE_SETSID
 	setsid();
 #else
 #ifdef TIOCNOTTY
 	i = open("/dev/tty", O_RDWR);
 	if (i >= 0) {
-		ioctl(i, (int) TIOCNOTTY, (char *)0);      
+		ioctl(i, (int)TIOCNOTTY, (char *)0);
 		close(i);
 	}
 #endif /* TIOCNOTTY */
 #endif
 	/* make sure that stdin, stdout an stderr don't stuff things
-           up (library functions, for example) */
-	for (i=0;i<3;i++) {
-		close(i); 
+	 * up (library functions, for example) */
+	for (i = 0; i < 3; i++) {
+		close(i);
 		open("/dev/null", O_RDWR);
 	}
 }
 
 
 /**
  * This is like socketpair but uses tcp. It is used by the Samba
  * regression test code.
- * 
+ *
  * The function guarantees that nobody else can attach to the socket,
  * or if they do that this function fails and the socket gets closed
  * returns 0 on success, -1 on failure the resulting file descriptors
  * are symmetrical.
  **/
 static int socketpair_tcp(int fd[2])
 {
 	int listener;
 	struct sockaddr_in sock;
 	struct sockaddr_in sock2;
-	socklen_t socklen = sizeof(sock);
+	socklen_t socklen = sizeof sock;
 	int connect_done = 0;
-	
+
 	fd[0] = fd[1] = listener = -1;
 
-	memset(&sock, 0, sizeof(sock));
-	
-	if ((listener = socket(PF_INET, SOCK_STREAM, 0)) == -1) goto failed;
-
-        memset(&sock2, 0, sizeof(sock2));
-#ifdef HAVE_SOCKADDR_LEN
-        sock2.sin_len = sizeof(sock2);
+	memset(&sock, 0, sizeof sock);
+
+	if ((listener = socket(PF_INET, SOCK_STREAM, 0)) == -1)
+		goto failed;
+
+	memset(&sock2, 0, sizeof sock2);
+#if HAVE_SOCKADDR_IN_LEN
+	sock2.sin_len = sizeof sock2;
 #endif
         sock2.sin_family = PF_INET;
 
-        bind(listener, (struct sockaddr *)&sock2, sizeof(sock2));
+	bind(listener, (struct sockaddr *)&sock2, sizeof sock2);
 
-	if (listen(listener, 1) != 0) goto failed;
+	if (listen(listener, 1) != 0)
+		goto failed;
 
-	if (getsockname(listener, (struct sockaddr *)&sock, &socklen) != 0) goto failed;
+	if (getsockname(listener, (struct sockaddr *)&sock, &socklen) != 0)
+		goto failed;
 
-	if ((fd[1] = socket(PF_INET, SOCK_STREAM, 0)) == -1) goto failed;
+	if ((fd[1] = socket(PF_INET, SOCK_STREAM, 0)) == -1)
+		goto failed;
 
 	set_nonblocking(fd[1]);
 
 	sock.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
 
-	if (connect(fd[1],(struct sockaddr *)&sock,sizeof(sock)) == -1) {
-		if (errno != EINPROGRESS) goto failed;
-	} else {
+	if (connect(fd[1], (struct sockaddr *)&sock, sizeof sock) == -1) {
+		if (errno != EINPROGRESS)
+			goto failed;
+	} else
 		connect_done = 1;
-	}
 
-	if ((fd[0] = accept(listener, (struct sockaddr *)&sock, &socklen)) == -1) goto failed;
+	if ((fd[0] = accept(listener, (struct sockaddr *)&sock, &socklen)) == -1)
+		goto failed;
 
 	close(listener);
 	if (connect_done == 0) {
-		if (connect(fd[1],(struct sockaddr *)&sock,sizeof(sock)) != 0
-		    && errno != EISCONN) goto failed;
+		if (connect(fd[1], (struct sockaddr *)&sock, sizeof sock) != 0
+		    && errno != EISCONN)
+			goto failed;
 	}
 
-	set_blocking (fd[1]);
+	set_blocking(fd[1]);
 
 	/* all OK! */
 	return 0;
 
  failed:
-	if (fd[0] != -1) close(fd[0]);
-	if (fd[1] != -1) close(fd[1]);
-	if (listener != -1) close(listener);
+	if (fd[0] != -1)
+		close(fd[0]);
+	if (fd[1] != -1)
+		close(fd[1]);
+	if (listener != -1)
+		close(listener);
 	return -1;
 }
 
 
 
 /**
@@ -671,33 +765,25 @@
  * "prog". stdin and stdout are attached. stderr is left attached to
  * the original stderr
  **/
 int sock_exec(const char *prog)
 {
 	int fd[2];
-	
+
 	if (socketpair_tcp(fd) != 0) {
-		rprintf (FERROR, RSYNC_NAME
-			 ": socketpair_tcp failed (%s)\n",
-			 strerror(errno));
+		rprintf(FERROR, RSYNC_NAME ": socketpair_tcp failed (%s)\n",
+			strerror(errno));
 		return -1;
 	}
+	if (verbose >= 2)
+		rprintf(FINFO, "Running socket program: \"%s\"\n", prog);
 	if (fork() == 0) {
 		close(fd[0]);
 		close(0);
 		close(1);
 		dup(fd[1]);
 		dup(fd[1]);
-		if (verbose > 3) {
-			/* Can't use rprintf because we've forked. */
-			fprintf (stderr,
-				 RSYNC_NAME ": execute socket program \"%s\"\n",
-				 prog);
-		}
-		exit (system (prog));
+		exit(system(prog));
 	}
-	close (fd[1]);
+	close(fd[1]);
 	return fd[0];
 }
-
-
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/syscall.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/syscall.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/syscall.c	2003-03-31 07:00:51.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/syscall.c	2004-02-19 06:33:21.000000000 +0800
@@ -28,89 +28,95 @@
 
 extern int dry_run;
 extern int read_only;
 extern int list_only;
 extern int preserve_perms;
 
-#define CHECK_RO if (read_only || list_only) {errno = EROFS; return -1;}
+#define RETURN_ERROR_IF(x,e) \
+	do { \
+		if (x) { \
+			errno = (e); \
+			return -1; \
+		} \
+	} while (0)
+
+#define RETURN_ERROR_IF_RO_OR_LO RETURN_ERROR_IF(read_only || list_only, EROFS)
 
 int do_unlink(char *fname)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return unlink(fname);
 }
 
 int do_symlink(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return symlink(fname1, fname2);
 }
 
 #if HAVE_LINK
 int do_link(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return link(fname1, fname2);
 }
 #endif
 
 int do_lchown(const char *path, uid_t owner, gid_t group)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return lchown(path, owner, group);
 }
 
 #if HAVE_MKNOD
 int do_mknod(char *pathname, mode_t mode, dev_t dev)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return mknod(pathname, mode, dev);
 }
 #endif
 
 int do_rmdir(char *pathname)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return rmdir(pathname);
 }
 
 int do_open(char *pathname, int flags, mode_t mode)
 {
 	if (flags != O_RDONLY) {
-	    if (dry_run) return -1;
-	    CHECK_RO
+		RETURN_ERROR_IF(dry_run, 0);
+		RETURN_ERROR_IF_RO_OR_LO;
 	}
-	/* some systems can't handle a double / */
-	if (pathname[0] == '/' && pathname[1] == '/') pathname++;
 
 	return open(pathname, flags | O_BINARY, mode);
 }
 
 #if HAVE_CHMOD
 int do_chmod(const char *path, mode_t mode)
 {
 	int code;
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	code = chmod(path, mode);
-	if ((code != 0) && preserve_perms)
+	if (code != 0 && preserve_perms)
 	    return code;
 	return 0;
 }
 #endif
 
 int do_rename(char *fname1, char *fname2)
 {
 	if (dry_run) return 0;
-	CHECK_RO
+	RETURN_ERROR_IF_RO_OR_LO;
 	return rename(fname1, fname2);
 }
 
 
 void trim_trailing_slashes(char *name)
 {
@@ -130,39 +136,42 @@
 	}
 }
 
 
 int do_mkdir(char *fname, mode_t mode)
 {
-	if (dry_run)
-		return 0;
-	CHECK_RO;
+	if (dry_run) return 0;
+	RETURN_ERROR_IF_RO_OR_LO;
 	trim_trailing_slashes(fname);	
 	return mkdir(fname, mode);
 }
 
 
 /* like mkstemp but forces permissions */
 int do_mkstemp(char *template, mode_t perms)
 {
-	if (dry_run) return -1;
-	if (read_only) {errno = EROFS; return -1;}
+	RETURN_ERROR_IF(dry_run, 0);
+	RETURN_ERROR_IF(read_only, EROFS);
 
 #if defined(HAVE_SECURE_MKSTEMP) && defined(HAVE_FCHMOD)
 	{
 		int fd = mkstemp(template);
-		if (fd == -1) return -1;
-		if ((fchmod(fd, perms) != 0) && preserve_perms) {
+		if (fd == -1)
+			return -1;
+		if (fchmod(fd, perms) != 0 && preserve_perms) {
+			int errno_save = errno;
 			close(fd);
 			unlink(template);
+			errno = errno_save;
 			return -1;
 		}
 		return fd;
 	}
 #else
-	if (!mktemp(template)) return -1;
+	if (!mktemp(template))
+		return -1;
 	return do_open(template, O_RDWR|O_EXCL|O_CREAT, perms);
 #endif
 }
 
 int do_stat(const char *fname, STRUCT_STAT *st)
 {
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/chgrp.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/chgrp.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/chgrp.test	2002-11-06 02:35:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/chgrp.test	2004-02-05 09:37:08.000000000 +0800
@@ -15,14 +15,12 @@
 
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
 
-# TODO: I guess some systems will not have 'id', and therefore we have
-# to ship or emulate it.
 mygrps="`rsync_getgroups`" || fail "Can't get groups"
 mkdir "$fromdir"
 
 for g in $mygrps
 do
     name="$fromdir/foo-$g"
@@ -30,9 +28,8 @@
     chgrp "$g" "$name" || fail "Can't chgrp"
 done
 sleep 2
 
 checkit "$RSYNC -rtgvvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
-# last [] may have failed but if we get here then we've won
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/chown.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/chown.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/chown.test	2002-12-24 15:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/chown.test	2004-02-05 02:24:41.000000000 +0800
@@ -30,9 +30,8 @@
 chown 5001 "$name2" || test_skipped "Can't chown (probably need root)"
 chgrp 5002 "$name1" || test_skipped "Can't chgrp (probably need root)"
 chgrp 5003 "$name2" || test_skipped "Can't chgrp (probably need root)"
 
 checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
-# last [] may have failed but if we get here then we've won
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/daemon-gzip-download.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/daemon-gzip-download.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/daemon-gzip-download.test	2003-01-22 04:19:53.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/daemon-gzip-download.test	2004-02-05 02:24:41.000000000 +0800
@@ -24,8 +24,10 @@
 build_rsyncd_conf
 
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 hands_setup
-checkit "$RSYNC -avvz localhost::test-from/ \"$TO/\"" "$FROM" "$TO"
+checkit "$RSYNC -avvvvz localhost::test-from/ \"$TO/\"" "$FROM" "$TO"
 
+# The script would have aborted on error, so getting here means we've won.
+exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/daemon-gzip-upload.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/daemon-gzip-upload.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/daemon-gzip-upload.test	2003-01-25 11:45:40.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/daemon-gzip-upload.test	2004-02-05 02:24:41.000000000 +0800
@@ -18,8 +18,10 @@
 build_rsyncd_conf
 
 RSYNC_CONNECT_PROG="$RSYNC --config=$conf --daemon"
 export RSYNC_CONNECT_PROG
 
 hands_setup
-checkit "$RSYNC -avvz \"$FROM/\" localhost::test-to/" "$FROM" "$TO"
+checkit "$RSYNC -avvvvz \"$FROM/\" localhost::test-to/" "$FROM" "$TO"
 
+# The script would have aborted on error, so getting here means we've won.
+exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/devices.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/devices.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/devices.test	2002-12-24 15:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/devices.test	2004-04-09 08:36:45.000000000 +0800
@@ -13,17 +13,26 @@
 
 # Build some hardlinks
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
 
+case `id -u` in
+'') ;; # If "id" failed, try to continue...
+0) ;;
+*) test_skipped "Rsync won't copy devices unless we're root" ;;
+esac
+
 # TODO: Need to test whether hardlinks are possible on this OS/filesystem
 
 mkdir "$fromdir"
-mknod "$fromdir/char" c 42 69  || test_skipped "Can't create char device node unless root"
+mknod "$fromdir/char" c 41 67  || test_skipped "Can't create char device node unless root"
+mknod "$fromdir/char2" c 42 68  || test_skipped "Can't create char device node unless root"
+mknod "$fromdir/char3" c 42 69  || test_skipped "Can't create char device node unless root"
 mknod "$fromdir/block" b 42 69 || test_skipped "Can't create block device node unless root"
+mknod "$fromdir/block2" b 42 73 || test_skipped "Can't create block device node unless root"
+mknod "$fromdir/block3" b 105 73 || test_skipped "Can't create block device node unless root"
 
 checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
-# last [] may have failed but if we get here then we've won
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/duplicates.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/duplicates.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/duplicates.test	2003-04-23 00:45:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/duplicates.test	2004-02-05 02:24:41.000000000 +0800
@@ -46,8 +46,8 @@
 fi
 if [ `grep -c '^name2 -> ' "$outfile"` != 1 ]
 then
     test_fail "name2 was not copied exactly once"
 fi
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
-# last [] may have failed but if we get here then we've won
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/exclude.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/exclude.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/exclude.test	2003-05-02 03:34:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/exclude.test	2004-04-15 04:50:32.000000000 +0800
@@ -11,29 +11,42 @@
 # processing.
 
 . $srcdir/testsuite/rsync.fns
 
 set -x
 
+HOME="$scratchdir"
+CVSIGNORE='*.junk'
+export HOME CVSIGNORE
+
 # Build some files/dirs/links to copy
 
 fromdir="$scratchdir/from"
 todir="$scratchdir/to"
 chkdir="$scratchdir/chk"
 
+echo home-cvs-exclude >"$scratchdir"/.cvsignore
 makepath "$fromdir/foo/down/to/you"
 makepath "$fromdir/bar/down/to/foo/too"
 makepath "$fromdir/mid/for/foo/and/that/is/who"
 echo kept >"$fromdir/foo/file1"
 echo removed >"$fromdir/foo/file2"
+echo cvsout >"$fromdir/foo/file2.old"
 echo keeper >"$fromdir/bar/down/to/foo/file1"
+echo cvsout >"$fromdir/bar/down/to/foo/file1.bak"
 echo gone >"$fromdir/bar/down/to/foo/file3"
 echo lost >"$fromdir/bar/down/to/foo/file4"
+echo cvsout >"$fromdir/bar/down/to/foo/file4.junk"
 echo smashed >"$fromdir/bar/down/to/foo/to"
+echo cvsout >"$fromdir/bar/down/to/home-cvs-exclude"
+echo cvsout >"$fromdir/mid/one-in-one-out"
+echo one-in-one-out >"$fromdir/mid/.cvsignore"
+echo cvsin >"$fromdir/mid/one-for-all"
 echo expunged >"$fromdir/mid/for/foo/extra"
 echo retained >"$fromdir/mid/for/foo/keep"
+echo cvsin >"$fromdir/mid/for/one-in-one-out"
 ln -s too "$fromdir/bar/down/to/foo/sym"
 
 # Setup our test exclude/include file.
 
 excl="$scratchdir/exclude-from"
 cat >"$excl" <<EOF
@@ -69,7 +82,24 @@
 $RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
 
 # Now, test if rsync excludes the same files.
 
 checkit "$RSYNC -avv --exclude-from=$excl \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
 
+# Modify the chk dir by removing cvs-ignored files and then tweaking the dir times.
+
+rm "$chkdir"/foo/*.old
+rm "$chkdir"/bar/down/to/foo/*.bak
+rm "$chkdir"/bar/down/to/foo/*.junk
+rm "$chkdir"/bar/down/to/home-cvs-exclude
+rm "$chkdir"/mid/one-in-one-out
+
+$RSYNC -av --existing --include='*/' --exclude='*' "$fromdir/" "$chkdir/"
+
+# Now, test if rsync excludes the same files, this time with --cvs-exclude
+# and --delete-excluded.
+
+checkit "$RSYNC -avvC --delete-excluded --exclude-from=$excl \
+    \"$fromdir/\" \"$todir/\"" "$chkdir" "$todir"
+
+# The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/hands.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/hands.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/hands.test	2002-03-26 18:36:45.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/hands.test	2004-02-05 02:24:41.000000000 +0800
@@ -22,7 +22,8 @@
 echo "extra line" >> ${TO}/text
 runtest "extra data" 'checkit "$RSYNC -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
 cp ${FROM}/text ${TO}/ThisShouldGo
 runtest " --delete" 'checkit "$RSYNC --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}'
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/hardlinks.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/hardlinks.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/hardlinks.test	2002-11-06 02:35:59.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/hardlinks.test	2004-02-05 02:24:41.000000000 +0800
@@ -30,9 +30,8 @@
 ln "$name1" "$name2" || fail "Can't create hardlink"
 ln "$name2" "$name3" || fail "Can't create hardlink"
 cp "$name2" "$name4" || fail "Can't copy file"
 
 checkit "$RSYNC -aHvv \"$fromdir/\" \"$todir/\"" "$fromdir" "$todir"
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
-# last [] may have failed but if we get here then we've won
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/longdir.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/longdir.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/longdir.test	2003-01-11 16:19:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/longdir.test	2004-02-05 02:24:41.000000000 +0800
@@ -16,6 +16,9 @@
 
 makepath $LONGDIR || test_skipped "unable to create long directory"
 touch $LONGDIR/1 || test_skipped "unable to create files in long directory"
 date > ${LONGDIR}/1
 ls -la / > ${LONGDIR}/2
 checkit "$RSYNC --delete -avH ${FROM}/ ${TO}" ${FROM}/ ${TO}
+
+# The script would have aborted on error, so getting here means we've won.
+exit 0
Only in /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite: merge.test
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/rsync.fns /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/rsync.fns
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/rsync.fns	2003-07-06 06:57:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/rsync.fns	2004-02-04 15:32:48.000000000 +0800
@@ -193,12 +193,13 @@
 # rsyncd configuration file autogenerated by $0
 
 pid file = $pidfile
 use chroot = no
 hosts allow = localhost, 127.0.0.1
 log file = $logfile
+max verbosity = 9
 
 uid = 0
 gid = 0
 
 [test-from]
 	path = $FROM
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/symlink-ignore.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/symlink-ignore.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/symlink-ignore.test	2002-12-24 15:25:25.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/symlink-ignore.test	2004-02-05 02:24:41.000000000 +0800
@@ -32,9 +32,8 @@
 
 if is_a_link "${todir}/absolute" 
 then
     test_fail "absolute symlink was copied"
 fi
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
-# last [] may have failed but if we get here then we've one
-
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/trimslash.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/trimslash.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/trimslash.test	2003-07-06 06:57:08.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/trimslash.test	2004-02-05 02:24:41.000000000 +0800
@@ -21,7 +21,8 @@
 /usr/local/bin
 //a
 /
 /Users/Wierd Macintosh Name/// Ooh, translucent plastic
 EOF
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/wildmatch.test /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/wildmatch.test
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/testsuite/wildmatch.test	2003-07-07 01:41:37.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/testsuite/wildmatch.test	2004-02-05 02:24:41.000000000 +0800
@@ -8,12 +8,13 @@
 # Test the wildmatch functionality
 
 . $srcdir/testsuite/rsync.fns
 
 set -x
 
-"$TOOLDIR/wildtest" >"$scratchdir/wild.out"
+"$TOOLDIR/wildtest" "$srcdir/wildtest.txt" >"$scratchdir/wild.out"
 diff $diffopt "$scratchdir/wild.out" - <<EOF
 No wildmatch errors found.
 EOF
 
+# The script would have aborted on error, so getting here means we've won.
 exit 0
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/tls.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/tls.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/tls.c	2003-09-10 16:27:34.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/tls.c	2004-04-10 04:22:44.000000000 +0800
@@ -1,19 +1,19 @@
 /* -*- c-file-style: "linux" -*-
  *
  * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License version
  * 2 as published by the Free Software Foundation.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /**
@@ -83,46 +83,48 @@
 		buf.st_mode &= ~0777;
 		buf.st_mtime = (time_t)0;
 		buf.st_uid = buf.st_gid = 0;
 		strcpy(linkbuf, " -> ");
 		/* const-cast required for silly UNICOS headers */
 		len = readlink((char *) fname, linkbuf+4, sizeof(linkbuf) - 4);
-		if (len == -1) 
+		if (len == -1)
 			failed("readlink", fname);
 		else
 			/* it's not nul-terminated */
 			linkbuf[4+len] = 0;
 	} else {
 		linkbuf[0] = 0;
 	}
 
 	permstring(permbuf, buf.st_mode);
 
 	if (buf.st_mtime) {
 		mt = gmtime(&buf.st_mtime);
-		
+
 		sprintf(datebuf, "%04d-%02d-%02d %02d:%02d:%02d",
 			mt->tm_year + 1900,
 			mt->tm_mon + 1,
 			mt->tm_mday,
 			mt->tm_hour,
 			mt->tm_min,
 			mt->tm_sec);
 	} else {
 		strcpy(datebuf, "                   ");
 	}
-	
+
 	/* TODO: Perhaps escape special characters in fname? */
-	
-	
-	/* NB: need to pass size as a double because it might be be
-	 * too large for a long. */
-	printf("%s %12.0f %6ld.%-6ld %6d %s %s%s\n",
-	       permbuf, (double) buf.st_size,
-	       (long) buf.st_uid, (long) buf.st_gid,
-	       buf.st_nlink,
+
+	printf("%s ", permbuf);
+	if (IS_DEVICE(buf.st_mode)) {
+		printf("%5ld,%6ld",
+		    (long)major(buf.st_rdev),
+		    (long)minor(buf.st_rdev));
+	} else /* NB: use double for size since it might not fit in a long. */
+		printf("%12.0f", (double)buf.st_size);
+	printf(" %6ld.%-6ld %6ld %s %s%s\n",
+	       (long)buf.st_uid, (long)buf.st_gid, (long)buf.st_nlink,
 	       datebuf, fname, linkbuf);
 }
 
 
 int
 main(int argc, char *argv[])
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/TODO /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/TODO
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/TODO	2003-12-17 08:52:01.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/TODO	2004-02-22 05:37:14.000000000 +0800
@@ -13,13 +13,12 @@
 Use chroot only if supported
 Allow supplementary groups in rsyncd.conf			2002/04/09
 Handling IPv6 on old machines
 Other IPv6 stuff:
 Add ACL support							2001/12/02
 Lazy directory creation
-Conditional -z for old protocols
 proxy authentication						2002/01/23
 SOCKS								2002/01/23
 FAT support
 Allow forcing arbitrary permissions				2002/03/12
 --diff						david.e.sewell	2002/03/15
 Add daemon --no-detach and --no-fork options
@@ -55,29 +54,26 @@
 Create release script
 Add machines to build farm
 
 PERFORMANCE ----------------------------------------------------------
 File list structure in memory
 Traverse just one directory at a time
-Hard-link handling
 Allow skipping MD4 file_sum					2002/04/08
 Accelerate MD4
-String area code
 
 TESTING --------------------------------------------------------------
 Torture test
 Cross-test versions						2001/08/22
 Test on kernel source
 Test large files
 Create mutator program for testing
 Create configure option to enable dangerous tests
 If tests are skipped, say why.
 Test daemon feature to disallow particular options.
 Create pipe program for testing
 Create test makefile target for some tests
-Test "refuse options" works
 
 RELATED PROJECTS -----------------------------------------------------
 rsyncsh
 http://rsync.samba.org/rsync-and-debian/
 rsyncable gzip patch
 rsyncsplit as alternative to real integration with gzip?
@@ -254,27 +250,12 @@
   can end up with many empty directories.  We might avoid this by
   lazily creating such directories.
 
                       --          --
 
 
-Conditional -z for old protocols
-
-  After we get the @RSYNCD greeting from the server, we know it's
-  version but we have not yet sent the command line, so we could just
-  remove the -z option if the server is too old.
-
-  For ssh invocation it's not so simple, because we actually use the
-  command line to start the remote process.  However, we only actually
-  do compression in token.c, and we could therefore once we discover
-  the remote version emit an error if it's too old.  I'm not sure if
-  that's a good tradeoff or not.
-
-                      --          --
-
-
 proxy authentication						2002/01/23
 
   Allow RSYNC_PROXY to be http://user:pass@proxy.foo:3128/, and do
   HTTP Basic Proxy-Authentication.
 
   Multiple schemes are possible, up to and including the insanity that
@@ -705,82 +686,12 @@
   start, which makes us use a lot of memory and also not pipeline
   network access as much as we could.
 
                       --          --
 
 
-Hard-link handling
-
-  At the moment hardlink handling is very expensive, so it's off by
-  default.  It does not need to be so.
-
-  Since most of the solutions are rather intertwined with the file
-  list it is probably better to fix that first, although fixing
-  hardlinks is possibly simpler.
-
-  We can rule out hardlinked directories since they will probably
-  screw us up in all kinds of ways.  They simply should not be used.
-
-  At the moment rsync only cares about hardlinks to regular files.  I
-  guess you could also use them for sockets, devices and other beasts,
-  but I have not seen them.
-
-  When trying to reproduce hard links, we only need to worry about
-  files that have more than one name (nlinks>1 && !S_ISDIR).
-
-  The basic point of this is to discover alternate names that refer to
-  the same file.  All operations, including creating the file and
-  writing modifications to it need only to be done for the first name.
-  For all later names, we just create the link and then leave it
-  alone.
-
-  If hard links are to be preserved:
-
-    Before the generator/receiver fork, the list of files is received
-    from the sender (recv_file_list), and a table for detecting hard
-    links is built.
-
-    The generator looks for hard links within the file list and does
-    not send checksums for them, though it does send other metadata.
-
-    The sender sends the device number and inode with file entries, so
-    that files are uniquely identified.
-
-    The receiver goes through and creates hard links (do_hard_links)
-    after all data has been written, but before directory permissions
-    are set.
-
-  At the moment device and inum are sent as 4-byte integers, which
-  will probably cause problems on large filesystems.  On Linux the
-  kernel uses 64-bit ino_t's internally, and people will soon have
-  filesystems big enough to use them.  We ought to follow NFS4 in
-  using 64-bit device and inode identification, perhaps with a
-  protocol version bump.
-
-  Once we've seen all the names for a particular file, we no longer
-  need to think about it and we can deallocate the memory.
-
-  We can also have the case where there are links to a file that are
-  not in the tree being transferred.  There's nothing we can do about
-  that.  Because we rename the destination into place after writing,
-  any hardlinks to the old file are always going to be orphaned.  In
-  fact that is almost necessary because otherwise we'd get really
-  confused if we were generating checksums for one name of a file and
-  modifying another.
-
-  At the moment the code seems to make a whole second copy of the file
-  list, which seems unnecessary.
-
-  We should have a test case that exercises hard links.  Since it
-  might be hard to compare ./tls output where the inodes change we
-  might need a little program to check whether several names refer to
-  the same file.
-
-                      --          --
-
-
 Allow skipping MD4 file_sum					2002/04/08
 
   If we're doing a local transfer, or using -W, then perhaps don't
   send the file checksum.  If we're doing a local transfer, then
   calculating MD4 checksums uses 90% of CPU and is unlikely to be
   useful.
@@ -803,20 +714,12 @@
 
   Make sure we call MD4 with properly-sized blocks whenever possible
   to avoid copying into the residue region?
 
                       --          --
 
-
-String area code
-
-  Test whether this is actually faster than just using malloc().  If
-  it's not (anymore), throw it out.
-
-                      --          --
-
 TESTING --------------------------------------------------------------
 
 Torture test
 
   Something that just keeps running rsync continuously over a data set
   likely to generate problems.
@@ -902,25 +805,12 @@
 
   Separate makefile target to run rough tests -- or perhaps
   just run them every time?
 
                       --          --
 
-
-Test "refuse options" works
-
-  What about for --recursive?
-
-  If you specify an unrecognized option here, you should get an error.
-
-  We need a test case for this...
-
-  Was this broken when we changed to popt?
-
-                      --          --
-
 RELATED PROJECTS -----------------------------------------------------
 
 rsyncsh
 
    Write a small emulation of interactive ftp as a Pythonn program
    that calls rsync.  Commands such as "cd", "ls", "ls *.c" etc map
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/token.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/token.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/token.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/token.c	2004-01-06 13:33:02.000000000 +0800
@@ -199,23 +199,24 @@
 			}
 		} else {
 			write_byte(f, (n==0? TOKEN_LONG: TOKENRUN_LONG));
 			write_int(f, run_start);
 			if (write_batch) {
 				temp_byte = (char)(n==0? TOKEN_LONG: TOKENRUN_LONG);
-				write_batch_delta_file(&temp_byte,sizeof(temp_byte));
+				write_batch_delta_file(&temp_byte,sizeof(char));
 				write_batch_delta_file((char *)&run_start,sizeof(run_start));
 			}
 		}
 		if (n != 0) {
 			write_byte(f, n);
 			write_byte(f, n >> 8);
 			if (write_batch) {
-				write_batch_delta_file((char *)&n,sizeof(char));
+				temp_byte = (char)n;
+				write_batch_delta_file(&temp_byte,sizeof(char));
 				temp_byte = (char)(n >> 8);
-				write_batch_delta_file(&temp_byte,sizeof(temp_byte));
+				write_batch_delta_file(&temp_byte,sizeof(char));
 			}
 		}
 		last_run_end = last_token;
 		run_start = token;
 	}
 
@@ -282,13 +283,13 @@
 
 	if (token == -1) {
 		/* end of file - clean up */
 		write_byte(f, END_FLAG);
 		if (write_batch) {
 			temp_byte = END_FLAG;
-			write_batch_delta_file((char *)&temp_byte,sizeof(temp_byte));
+			write_batch_delta_file(&temp_byte,sizeof(char));
 		}
 
 	} else if (token != -2) {
 		/* add the data in the current block to the compressor's
 		   history and hash table */
 		tx_strm.next_in = (Bytef *) map_ptr(buf, offset, toklen);
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/t_stub.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/t_stub.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/t_stub.c	2003-09-11 12:48:13.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/t_stub.c	2004-04-22 17:58:11.000000000 +0800
@@ -25,13 +25,13 @@
  * This file contains really simple implementations for rsync global
  * functions, so that module test harnesses can run standalone.
  **/
 
 int modify_window = 0;
 int module_id = -1;
-struct exclude_struct **server_exclude_list;
+struct exclude_list_struct server_exclude_list;
 
  void rprintf(UNUSED(enum logcode code), const char *format, ...)
 {
 	va_list ap;
 	va_start(ap, format);
 	vfprintf(stderr, format, ap);
@@ -42,13 +42,13 @@
 {
 	fprintf(stderr, "exit(%d): %s(%d)\n",
 		code, file, line);
 	exit(code);
 }
 
- int check_exclude(UNUSED(struct exclude_struct **list), UNUSED(char *name),
+ int check_exclude(UNUSED(struct exclude_list_struct *listp), UNUSED(char *name),
 		   UNUSED(int name_is_dir))
 {
 	/* This function doesn't really get called in this test context, so
 	 * just return 0. */
 	return 0;
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/uidlist.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/uidlist.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/uidlist.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/uidlist.c	2004-02-21 01:09:30.000000000 +0800
@@ -1,33 +1,40 @@
-/* 
+/*
    Copyright (C) Andrew Tridgell 1996
    Copyright (C) Paul Mackerras 1996
-   
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.
-   
+
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
-   
+
    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
 /* handle the mapping of uid/gid and user/group names between systems.
    If the source username/group does not exist on the target then use
-   the numeric ids. Never do any mapping for uid=0 or gid=0 as these
+   the numeric IDs. Never do any mapping for uid=0 or gid=0 as these
    are special.
 */
 
 #include "rsync.h"
 
+#ifdef HAVE_GETGROUPS
+# if !defined(GETGROUPS_T)
+#  define GETGROUPS_T gid_t
+# endif
+#endif
+
+extern int verbose;
 extern int preserve_uid;
 extern int preserve_gid;
 extern int numeric_ids;
 extern int am_root;
 
 struct idlist {
@@ -36,260 +43,308 @@
 	char *name;
 };
 
 static struct idlist *uidlist;
 static struct idlist *gidlist;
 
-static struct idlist *add_list(int id, char *name)
+static struct idlist *add_to_list(struct idlist **root, int id, char *name,
+				  int id2)
 {
-	struct idlist *list = new(struct idlist);
-	if (!list) out_of_memory("add_list");
-	list->next = NULL;
-	list->name = strdup(name);
-	if (!list->name) out_of_memory("add_list");
-	list->id = (int)id;
-	return list;
+	struct idlist *node = new(struct idlist);
+	if (!node)
+		out_of_memory("add_to_list");
+	node->next = *root;
+	node->name = name;
+	node->id = id;
+	node->id2 = id2;
+	*root = node;
+	return node;
 }
 
-
-
 /* turn a uid into a user name */
 static char *uid_to_name(uid_t uid)
 {
 	struct passwd *pass = getpwuid(uid);
-	if (pass) return(pass->pw_name);
+	if (pass)
+		return strdup(pass->pw_name);
 	return NULL;
 }
 
 /* turn a gid into a group name */
 static char *gid_to_name(gid_t gid)
 {
 	struct group *grp = getgrgid(gid);
-	if (grp) return(grp->gr_name);
+	if (grp)
+		return strdup(grp->gr_name);
 	return NULL;
 }
 
 static int map_uid(int id, char *name)
 {
 	uid_t uid;
-	if (name_to_uid(name, &uid) && uid != 0)
+	if (uid != 0 && name_to_uid(name, &uid))
 		return uid;
 	return id;
 }
 
 static int map_gid(int id, char *name)
 {
 	gid_t gid;
-	if (name_to_gid(name, &gid) && gid != 0)
+	if (gid != 0 && name_to_gid(name, &gid))
 		return gid;
 	return id;
 }
 
+static int is_in_group(gid_t gid)
+{
+#ifdef HAVE_GETGROUPS
+	static gid_t last_in = GID_NONE, last_out;
+	static int ngroups = -2;
+	static GETGROUPS_T *gidset;
+	int n;
+
+	if (gid == last_in)
+		return last_out;
+	if (ngroups < -1) {
+		gid_t mygid = MY_GID();
+		if ((ngroups = getgroups(0, NULL)) < 0)
+			ngroups = 0;
+		gidset = new_array(GETGROUPS_T, ngroups+1);
+		if (!gidset)
+			out_of_memory("is_in_group");
+		if (ngroups > 0)
+			ngroups = getgroups(ngroups, gidset);
+		/* The default gid might not be in the list on some systems. */
+		for (n = 0; n < ngroups; n++) {
+			if (gidset[n] == mygid)
+				break;
+		}
+		if (n == ngroups)
+			gidset[ngroups++] = mygid;
+		if (verbose > 3) {
+			int pos;
+			char *gidbuf = new_array(char, ngroups*21+32);
+			if (!gidbuf)
+				out_of_memory("is_in_group");
+			sprintf(gidbuf, "process has %d gid%s: ",
+			    ngroups, ngroups == 1? "" : "s");
+			pos = strlen(gidbuf);
+			for (n = 0; n < ngroups; n++) {
+				sprintf(gidbuf+pos, " %d", (int)gidset[n]);
+				pos += strlen(gidbuf+pos);
+			}
+			rprintf(FINFO, "%s\n", gidbuf);
+			free(gidbuf);
+		}
+	}
+
+	last_in = gid;
+	for (n = 0; n < ngroups; n++) {
+		if (gidset[n] == gid)
+			return last_out = 1;
+	}
+	return last_out = 0;
+
+#else
+	static gid_t mygid = GID_NONE;
+	if (mygid == GID_NONE) {
+		mygid = MY_GID();
+		if (verbose > 3)
+			rprintf(FINFO, "process has gid %d\n", (int)mygid);
+	}
+	return gid == mygid;
+#endif
+}
+
+/* Add a uid to the list of uids.  Only called on receiving side. */
+static struct idlist *recv_add_uid(int id, char *name)
+{
+	int id2 = name ? map_uid(id, name) : id;
+	struct idlist *node;
+
+	node = add_to_list(&uidlist, id, name, map_uid(id, name));
+
+	if (verbose > 3) {
+		rprintf(FINFO, "uid %d(%s) maps to %d\n",
+		    id, name ? name : "", id2);
+	}
+
+	return node;
+}
+
+/* Add a gid to the list of gids.  Only called on receiving side. */
+static struct idlist *recv_add_gid(int id, char *name)
+{
+	int id2 = name ? map_gid(id, name) : id;
+	struct idlist *node;
+
+	if (!am_root && !is_in_group(id2))
+		id2 = GID_NONE;
+	node = add_to_list(&gidlist, id, name, id2);
+
+	if (verbose > 3) {
+		rprintf(FINFO, "gid %d(%s) maps to %d\n",
+		    id, name ? name : "", id2);
+	}
+
+	return node;
+}
+
 /* this function is a definate candidate for a faster algorithm */
 static uid_t match_uid(uid_t uid)
 {
 	static uid_t last_in, last_out;
-	struct idlist *list = uidlist;
+	struct idlist *list;
 
-	if (uid == last_in) return last_out;
+	if (uid == 0)
+		return 0;
+
+	if (uid == last_in)
+		return last_out;
 
 	last_in = uid;
 
-	while (list) {
-		if (list->id == (int)uid) {
-			last_out = (uid_t)list->id2;
-			return last_out;
-		}
-		list = list->next;
+	for (list = uidlist; list; list = list->next) {
+		if (list->id == (int)uid)
+			return last_out = (uid_t)list->id2;
 	}
-	
-	last_out = uid;
-	return last_out;
+
+	return last_out = uid;
 }
 
 static gid_t match_gid(gid_t gid)
 {
-	static gid_t last_in, last_out;
-	struct idlist *list = gidlist;
+	static gid_t last_in = GID_NONE, last_out = GID_NONE;
+	struct idlist *list;
 
-	if (gid == last_in) return last_out;
+	if (gid == GID_NONE)
+		return GID_NONE;
+
+	if (gid == last_in)
+		return last_out;
 
 	last_in = gid;
 
-	while (list) {
-		if (list->id == (int)gid) {
-			last_out = (gid_t)list->id2;
-			return last_out;
-		}
-		list = list->next;
+	for (list = gidlist; list; list = list->next) {
+		if (list->id == (int)gid)
+			return last_out = (gid_t)list->id2;
 	}
-	
-	if (am_root)
-		last_out = gid;
-	else
-		last_out = (gid_t) -1;
-	return last_out;
+
+	list = recv_add_gid(gid, NULL);
+	return last_out = list->id2;
 }
 
-/* add a uid to the list of uids */
+/* Add a uid to the list of uids.  Only called on sending side. */
 void add_uid(uid_t uid)
 {
-	struct idlist *list = uidlist;
-	char *name;
-
-	if (numeric_ids) return;
-
-	/* don't map root */
-	if (uid==0) return;
+	struct idlist *list;
 
-	if (!list) {
-		if (!(name = uid_to_name(uid))) return;
-		uidlist = add_list((int)uid, name);
+	if (uid == 0)	/* don't map root */
 		return;
-	}
 
-	while (list->next) {
-		if (list->id == (int)uid) return;
-		list = list->next;
+	for (list = uidlist; list; list = list->next) {
+		if (list->id == (int)uid)
+			return;
 	}
 
-	if (list->id == (int)uid) return;
-
-	if (!(name = uid_to_name(uid))) return;
-
-	list->next = add_list((int)uid, name);
+	add_to_list(&uidlist, (int)uid, uid_to_name(uid), 0);
 }
 
-/* add a gid to the list of gids */
+/* Add a gid to the list of gids.  Only called on sending side. */
 void add_gid(gid_t gid)
 {
-	struct idlist *list = gidlist;
-	char *name;
-
-	if (numeric_ids) return;
-
-	/* don't map root */
-	if (gid==0) return;
+	struct idlist *list;
 
-	if (!list) {
-		if (!(name = gid_to_name(gid))) return;
-		gidlist = add_list((int)gid, name);
+	if (gid == 0)	/* don't map root */
 		return;
-	}
 
-	while (list->next) {
-		if (list->id == (int)gid) return;
-		list = list->next;
+	for (list = gidlist; list; list = list->next) {
+		if (list->id == (int)gid)
+			return;
 	}
 
-	if (list->id == (int)gid) return;
-
-	if (!(name = gid_to_name(gid))) return;
-
-	list->next = add_list((int)gid, name);
+	add_to_list(&gidlist, (int)gid, gid_to_name(gid), 0);
 }
 
 
 /* send a complete uid/gid mapping to the peer */
 void send_uid_list(int f)
 {
 	struct idlist *list;
 
-	if (numeric_ids) return;
+	if (numeric_ids)
+		return;
 
 	if (preserve_uid) {
+		int len;
 		/* we send sequences of uid/byte-length/name */
-		list = uidlist;
-		while (list) {
-			int len = strlen(list->name);
+		for (list = uidlist; list; list = list->next) {
+			if (!list->name)
+				continue;
+			len = strlen(list->name);
 			write_int(f, list->id);
 			write_byte(f, len);
 			write_buf(f, list->name, len);
-			list = list->next;
 		}
 
 		/* terminate the uid list with a 0 uid. We explicitly exclude
-		   0 from the list */
+		 * 0 from the list */
 		write_int(f, 0);
 	}
 
 	if (preserve_gid) {
-		list = gidlist;
-		while (list) {
-			int len = strlen(list->name);
+		int len;
+		for (list = gidlist; list; list = list->next) {
+			if (!list->name)
+				continue;
+			len = strlen(list->name);
 			write_int(f, list->id);
 			write_byte(f, len);
 			write_buf(f, list->name, len);
-			list = list->next;
 		}
 		write_int(f, 0);
 	}
 }
 
 /* recv a complete uid/gid mapping from the peer and map the uid/gid
-   in the file list to local names */
+ * in the file list to local names */
 void recv_uid_list(int f, struct file_list *flist)
 {
 	int id, i;
 	char *name;
-	struct idlist *list;
-
-	if (numeric_ids) return;
 
-	if (preserve_uid) {
+	if (preserve_uid && !numeric_ids) {
 		/* read the uid list */
-		list = uidlist;
-		id = read_int(f);
-		while (id != 0) {
+		while ((id = read_int(f)) != 0) {
 			int len = read_byte(f);
 			name = new_array(char, len+1);
-			if (!name) out_of_memory("recv_uid_list");
+			if (!name)
+				out_of_memory("recv_uid_list");
 			read_sbuf(f, name, len);
-			if (!list) {
-				uidlist = add_list(id, name);
-				list = uidlist;
-			} else {
-				list->next = add_list(id, name);
-				list = list->next;
-			}
-			list->id2 = map_uid(id, name);
-			free(name);
-			id = read_int(f);
+			recv_add_uid(id, name); /* node keeps name's memory */
 		}
 	}
 
 
-	if (preserve_gid) {
-		/* and the gid list */
-		list = gidlist;
-		id = read_int(f);
-		while (id != 0) {
+	if (preserve_gid && !numeric_ids) {
+		/* read the gid list */
+		while ((id = read_int(f)) != 0) {
 			int len = read_byte(f);
 			name = new_array(char, len+1);
-			if (!name) out_of_memory("recv_uid_list");
+			if (!name)
+				out_of_memory("recv_uid_list");
 			read_sbuf(f, name, len);
-			if (!list) {
-				gidlist = add_list(id, name);
-				list = gidlist;
-			} else {
-				list->next = add_list(id, name);
-				list = list->next;
-			}
-			list->id2 = map_gid(id, name);
-			free(name);
-			id = read_int(f);
+			recv_add_gid(id, name); /* node keeps name's memory */
 		}
 	}
 
-	if (!(am_root && preserve_uid) && !preserve_gid) return;
-
 	/* now convert the uid/gid of all files in the list to the mapped
-	   uid/gid */
-	for (i=0;i<flist->count;i++) {
-		if (am_root && preserve_uid && flist->files[i]->uid != 0) {
+	 * uid/gid */
+	if (am_root && preserve_uid && !numeric_ids) {
+		for (i = 0; i < flist->count; i++)
 			flist->files[i]->uid = match_uid(flist->files[i]->uid);
-		}
-		if (preserve_gid && flist->files[i]->gid != 0) {
+	}
+	if (preserve_gid && (!am_root || !numeric_ids)) {
+		for (i = 0; i < flist->count; i++)
 			flist->files[i]->gid = match_gid(flist->files[i]->gid);
-		}
 	}
 }
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/util.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/util.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/util.c	2003-12-07 05:07:27.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/util.c	2004-04-28 00:43:40.000000000 +0800
@@ -1,36 +1,37 @@
 /*  -*- c-file-style: "linux" -*-
- * 
- * Copyright (C) 1996-2000 by Andrew Tridgell 
+ *
+ * Copyright (C) 1996-2000 by Andrew Tridgell
  * Copyright (C) Paul Mackerras 1996
  * Copyright (C) 2001, 2002 by Martin Pool <mbp@samba.org>
- * 
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
  * (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 /**
  * @file
  *
- * Utilities used in rsync 
+ * Utilities used in rsync
  **/
 
 #include "rsync.h"
 
 extern int verbose;
+extern struct exclude_list_struct server_exclude_list;
 
 int sanitize_paths = 0;
 
 
 
 /**
@@ -64,13 +65,13 @@
 }
 
 
 /**
  * Create a file descriptor pair - like pipe() but use socketpair if
  * possible (because of blocking issues on pipes).
- * 
+ *
  * Always set non-blocking.
  */
 int fd_pair(int fd[2])
 {
 	int ret;
 
@@ -108,20 +109,20 @@
 	rprintf(FINFO, "\n");
 }
 
 
 void out_of_memory(char *str)
 {
-  rprintf(FERROR,"ERROR: out of memory in %s\n",str);
-  exit_cleanup(RERR_MALLOC);
+	rprintf(FERROR, "ERROR: out of memory in %s\n", str);
+	exit_cleanup(RERR_MALLOC);
 }
 
 void overflow(char *str)
 {
-  rprintf(FERROR,"ERROR: buffer overflow in %s\n",str);
-  exit_cleanup(RERR_MALLOC);
+	rprintf(FERROR, "ERROR: buffer overflow in %s\n", str);
+	exit_cleanup(RERR_MALLOC);
 }
 
 
 
 int set_modtime(char *fname, time_t modtime)
 {
@@ -131,16 +132,16 @@
 
 	if (verbose > 2) {
 		rprintf(FINFO, "set modtime of %s to (%ld) %s",
 			fname, (long) modtime,
 			asctime(localtime(&modtime)));
 	}
-	
+
 	{
 #ifdef HAVE_UTIMBUF
-		struct utimbuf tbuf;  
+		struct utimbuf tbuf;
 		tbuf.actime = time(NULL);
 		tbuf.modtime = modtime;
 		return utime(fname,&tbuf);
 #elif defined(HAVE_UTIME)
 		time_t t[2];
 		t[0] = time(NULL);
@@ -164,19 +165,21 @@
    on the umask
 **/
 int create_directory_path(char *fname, int base_umask)
 {
 	char *p;
 
-	while (*fname == '/') fname++;
-	while (strncmp(fname,"./",2)==0) fname += 2;
+	while (*fname == '/')
+		fname++;
+	while (strncmp(fname, "./", 2) == 0)
+		fname += 2;
 
 	p = fname;
-	while ((p=strchr(p,'/'))) {
+	while ((p = strchr(p,'/')) != NULL) {
 		*p = 0;
-		do_mkdir(fname, 0777 & ~base_umask); 
+		do_mkdir(fname, 0777 & ~base_umask);
 		*p = '/';
 		p++;
 	}
 	return 0;
 }
 
@@ -191,21 +194,19 @@
  *
  * Derived from GNU C's cccp.c.
  */
 static int full_write(int desc, char *ptr, size_t len)
 {
 	int total_written;
-	
+
 	total_written = 0;
 	while (len > 0) {
-		int written = write (desc, ptr, len);
+		int written = write(desc, ptr, len);
 		if (written < 0)  {
-#ifdef EINTR
 			if (errno == EINTR)
 				continue;
-#endif
 			return written;
 		}
 		total_written += written;
 		ptr += written;
 		len -= written;
 	}
@@ -224,24 +225,20 @@
  * @retval <0 for an error.
  *
  * Derived from GNU C's cccp.c. */
 static int safe_read(int desc, char *ptr, size_t len)
 {
 	int n_chars;
- 
+
 	if (len == 0)
 		return len;
- 
-#ifdef EINTR
+
 	do {
 		n_chars = read(desc, ptr, len);
 	} while (n_chars < 0 && errno == EINTR);
-#else
-	n_chars = read(desc, ptr, len);
-#endif
- 
+
 	return n_chars;
 }
 
 
 /** Copy a file.
  *
@@ -271,13 +268,13 @@
 		rprintf(FERROR,"open %s: %s\n",
 			dest,strerror(errno));
 		close(ifd);
 		return -1;
 	}
 
-	while ((len = safe_read(ifd, buf, sizeof(buf))) > 0) {
+	while ((len = safe_read(ifd, buf, sizeof buf)) > 0) {
 		if (full_write(ofd, buf, len) < 0) {
 			rprintf(FERROR,"write %s: %s\n",
 				dest,strerror(errno));
 			close(ifd);
 			close(ofd);
 			return -1;
@@ -317,36 +314,34 @@
 #else
 	static int counter = 1;
 	int rc, pos, start;
 	char path[MAXPATHLEN];
 
 	rc = do_unlink(fname);
-	if ((rc == 0) || (errno != ETXTBSY))
+	if (rc == 0 || errno != ETXTBSY)
 		return rc;
 
-	strlcpy(path, fname, MAXPATHLEN);
+	if ((pos = strlcpy(path, fname, MAXPATHLEN)) >= MAXPATHLEN)
+		pos = MAXPATHLEN - 1;
 
-	pos = strlen(path);
-	while((path[--pos] != '/') && (pos >= 0))
-		;
-	++pos;
-	strlcpy(&path[pos], ".rsync", MAXPATHLEN-pos);
-	pos += sizeof(".rsync")-1;
+	while (pos > 0 && path[pos-1] != '/')
+		pos--;
+	pos += strlcpy(path+pos, ".rsync", MAXPATHLEN-pos);
 
 	if (pos > (MAXPATHLEN-MAX_RENAMES_DIGITS-1)) {
 		errno = ETXTBSY;
 		return -1;
 	}
 
 	/* start where the last one left off to reduce chance of clashes */
 	start = counter;
 	do {
 		sprintf(&path[pos], "%03d", counter);
 		if (++counter >= MAX_RENAMES)
 			counter = 1;
-	} while (((rc = access(path, 0)) == 0) && (counter != start));
+	} while ((rc = access(path, 0)) == 0 && counter != start);
 
 	if (verbose > 0) {
 		rprintf(FINFO,"renaming %s to %s because of text busy\n",
 			fname, path);
 	}
 
@@ -356,35 +351,50 @@
 		return -1;
 	}
 	return 0;
 #endif
 }
 
-int robust_rename(char *from, char *to)
-{
-#ifndef ETXTBSY
-	return do_rename(from, to);
-#else
-	int rc = do_rename(from, to);
-	if ((rc == 0) || (errno != ETXTBSY))
-		return rc;
-	if (robust_unlink(to) != 0)
-		return -1;
-	return do_rename(from, to);
+/* Returns 0 on success, -1 on most errors, and -2 if we got an error
+ * trying to copy the file across file systems. */
+int robust_rename(char *from, char *to, int mode)
+{
+	int tries = 4;
+
+	while (tries--) {
+		if (do_rename(from, to) == 0)
+			return 0;
+
+		switch (errno) {
+#ifdef ETXTBSY
+		case ETXTBSY:
+			if (robust_unlink(to) != 0)
+				return -1;
+			break;
 #endif
+		case EXDEV:
+			if (copy_file(from, to, mode) != 0)
+				return -2;
+			do_unlink(from);
+			return 0;
+		default:
+			return -1;
+		}
+	}
+	return -1;
 }
 
 
 static pid_t all_pids[10];
 static int num_pids;
 
 /** Fork and record the pid of the child. **/
 pid_t do_fork(void)
 {
 	pid_t newpid = fork();
-	
+
 	if (newpid != 0  &&  newpid != -1) {
 		all_pids[num_pids++] = newpid;
 	}
 	return newpid;
 }
 
@@ -452,25 +462,24 @@
 
 	lock.l_type = F_WRLCK;
 	lock.l_whence = SEEK_SET;
 	lock.l_start = offset;
 	lock.l_len = len;
 	lock.l_pid = 0;
-	
+
 	return fcntl(fd,F_SETLK,&lock) == 0;
 }
 
 static int exclude_server_path(char *arg)
 {
 	char *s;
-	extern struct exclude_struct **server_exclude_list;
 
-	if (server_exclude_list) {
+	if (server_exclude_list.head) {
 		for (s = arg; (s = strchr(s, '/')) != NULL; ) {
 			*s = '\0';
-			if (check_exclude(server_exclude_list, arg, 1)) {
+			if (check_exclude(&server_exclude_list, arg, 1) < 0) {
 				/* We must leave arg truncated! */
 				return 1;
 			}
 			*s++ = '/';
 		}
 	}
@@ -493,27 +502,29 @@
 
 	s = argv[*argc] = strdup(s);
 	if (sanitize_paths) {
 		sanitize_path(s, NULL);
 	}
 
-	memset(&globbuf, 0, sizeof(globbuf));
+	memset(&globbuf, 0, sizeof globbuf);
 	if (!exclude_server_path(s))
 		glob(s, 0, NULL, &globbuf);
 	if (globbuf.gl_pathc == 0) {
 		(*argc)++;
 		globfree(&globbuf);
 		return;
 	}
-	for (i=0; i<(maxargs - (*argc)) && i < (int) globbuf.gl_pathc;i++) {
-		if (i == 0) free(s);
-		argv[(*argc) + i] = strdup(globbuf.gl_pathv[i]);
-		if (!argv[(*argc) + i]) out_of_memory("glob_expand");
+	for (i = 0; i < maxargs - *argc && i < (int)globbuf.gl_pathc; i++) {
+		if (i == 0)
+			free(s);
+		argv[*argc + i] = strdup(globbuf.gl_pathv[i]);
+		if (!argv[*argc + i])
+			out_of_memory("glob_expand");
 	}
 	globfree(&globbuf);
-	(*argc) += i;
+	*argc += i;
 #endif
 }
 
 /* This routine is only used in daemon mode. */
 void glob_expand(char *base1, char **argv, int *argc, int maxargs)
 {
@@ -531,20 +542,21 @@
 	if (!s) out_of_memory("glob_expand");
 
 	if (asprintf(&base," %s/", base1) <= 0) out_of_memory("glob_expand");
 	base_len++;
 
 	q = s;
-	while ((p = strstr(q,base)) && ((*argc) < maxargs)) {
+	while ((p = strstr(q,base)) != NULL && *argc < maxargs) {
 		/* split it at this point */
 		*p = 0;
 		glob_expand_one(q, argv, argc, maxargs);
 		q = p + base_len;
 	}
 
-	if (*q && (*argc < maxargs)) glob_expand_one(q, argv, argc, maxargs);
+	if (*q && *argc < maxargs)
+		glob_expand_one(q, argv, argc, maxargs);
 
 	free(s);
 	free(base);
 }
 
 /**
@@ -556,47 +568,99 @@
 		if (isupper(* (unsigned char *) s))
 			*s = tolower(* (unsigned char *) s);
 		s++;
 	}
 }
 
+/* Join strings p1 & p2 into "dest" with a guaranteed '/' between them.  (If
+ * p1 ends with a '/', no extra '/' is inserted.)  Returns the length of both
+ * strings + 1 (if '/' was inserted), regardless of whether the null-terminated
+ * string fits into destsize. */
+size_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2)
+{
+	size_t len = strlcpy(dest, p1, destsize);
+	if (len < destsize - 1) {
+		if (!len || dest[len-1] != '/')
+			dest[len++] = '/';
+		if (len < destsize - 1)
+			len += strlcpy(dest + len, p2, destsize - len);
+		else {
+			dest[len] = '\0';
+			len += strlen(p2);
+		}
+	}
+	else
+		len += strlen(p2) + 1; /* Assume we'd insert a '/'. */
+	return len;
+}
+
+/* Join any number of strings together, putting them in "dest".  The return
+ * value is the length of all the strings, regardless of whether the null-
+ * terminated whole fits in destsize.  Your list of string pointers must end
+ * with a NULL to indicate the end of the list. */
+size_t stringjoin(char *dest, size_t destsize, ...)
+{
+	va_list ap;
+	size_t len, ret = 0;
+	const char *src;
+
+	va_start(ap, destsize);
+	while (1) {
+		if (!(src = va_arg(ap, const char *)))
+			break;
+		len = strlen(src);
+		ret += len;
+		if (destsize > 1) {
+			if (len >= destsize)
+				len = destsize - 1;
+			memcpy(dest, src, len);
+			destsize -= len;
+			dest += len;
+		}
+	}
+	*dest = '\0';
+	va_end(ap);
+
+	return ret;
+}
+
 void clean_fname(char *name)
 {
 	char *p;
 	int l;
 	int modified = 1;
 
 	if (!name) return;
 
 	while (modified) {
 		modified = 0;
 
-		if ((p=strstr(name,"/./"))) {
+		if ((p = strstr(name,"/./")) != NULL) {
 			modified = 1;
 			while (*p) {
 				p[0] = p[2];
 				p++;
 			}
 		}
 
-		if ((p=strstr(name,"//"))) {
+		if ((p = strstr(name,"//")) != NULL) {
 			modified = 1;
 			while (*p) {
 				p[0] = p[1];
 				p++;
 			}
 		}
 
-		if (strncmp(p=name,"./",2) == 0) {      
+		if (strncmp(p = name, "./", 2) == 0) {
 			modified = 1;
 			do {
 				p[0] = p[2];
 			} while (*p++);
 		}
 
-		l = strlen(p=name);
+		l = strlen(p = name);
 		if (l > 1 && p[l-1] == '/') {
 			modified = 1;
 			p[l-1] = 0;
 		}
 	}
 }
@@ -649,125 +713,165 @@
 	}
 	while (*p != '\0') {
 		/* this loop iterates once per filename component in p.
 		 * both p (and sanp if the original had a slash) should
 		 * always be left pointing after a slash
 		 */
-		if ((*p == '.') && ((*(p+1) == '/') || (*(p+1) == '\0'))) {
+		if (*p == '.' && (p[1] == '/' || p[1] == '\0')) {
 			/* skip "." component */
 			while (*++p == '/') {
 				/* skip following slashes */
 				;
 			}
 			continue;
 		}
 		allowdotdot = 0;
-		if ((*p == '.') && (*(p+1) == '.') &&
-		    ((*(p+2) == '/') || (*(p+2) == '\0'))) {
+		if (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\0')) {
 			/* ".." component followed by slash or end */
-			if ((depth > 0) && (sanp == start)) {
+			if (depth > 0 && sanp == start) {
 				/* allow depth levels of .. at the beginning */
 				--depth;
 				allowdotdot = 1;
 			} else {
 				p += 2;
 				if (*p == '/')
 					p++;
 				if (sanp != start) {
 					/* back up sanp one level */
 					--sanp; /* now pointing at slash */
-					while ((sanp > start) && (*(sanp - 1) != '/')) {
+					while (sanp > start && sanp[-1] != '/') {
 						/* skip back up to slash */
 						sanp--;
 					}
 				}
 				continue;
 			}
 		}
 		while (1) {
 			/* copy one component through next slash */
 			*sanp++ = *p++;
-			if ((*p == '\0') || (*(p-1) == '/')) {
+			if (*p == '\0' || p[-1] == '/') {
 				while (*p == '/') {
 					/* skip multiple slashes */
 					p++;
 				}
 				break;
 			}
 		}
 		if (allowdotdot) {
 			/* move the virtual beginning to leave the .. alone */
 			start = sanp;
 		}
 	}
-	if ((sanp == start) && !allowdotdot) {
+	if (sanp == start && !allowdotdot) {
 		/* ended up with nothing, so put in "." component */
 		/*
 		 * note that the !allowdotdot doesn't prevent this from
 		 *  happening in all allowed ".." situations, but I didn't
 		 *  think it was worth putting in an extra variable to ensure
 		 *  it since an extra "." won't hurt in those situations.
 		 */
 		*sanp++ = '.';
 	}
 	*sanp = '\0';
 }
 
+/* Works much like sanitize_path(), with these differences:  (1) a new buffer
+ * is allocated for the sanitized path rather than modifying it in-place; (2)
+ * a leading slash gets transformed into the rootdir value (which can be empty
+ * or NULL if you just want the slash to get dropped); (3) no "reldir" can be
+ * specified. */
+char *alloc_sanitize_path(const char *path, const char *rootdir)
+{
+	char *buf;
+	int rlen, plen = strlen(path);
+
+	if (*path == '/' && rootdir) {
+		rlen = strlen(rootdir);
+		if (rlen == 1)
+			path++;
+	} else
+		rlen = 0;
+	if (!(buf = new_array(char, rlen + plen + 1)))
+		out_of_memory("alloc_sanitize_path");
+	if (rlen)
+		memcpy(buf, rootdir, rlen);
+	memcpy(buf + rlen, path, plen + 1);
+
+	if (rlen > 1)
+		rlen++;
+	sanitize_path(buf + rlen, NULL);
+	if (rlen && buf[rlen] == '.' && buf[rlen+1] == '\0') {
+		if (rlen > 1)
+			rlen--;
+		buf[rlen] = '\0';
+	}
+
+	return buf;
+}
 
 char curr_dir[MAXPATHLEN];
+unsigned int curr_dir_len;
 
 /**
- * Like chdir() but can be reversed with pop_dir() if @p save is set.
- * It is also much faster as it remembers where we have been.
+ * Like chdir(), but it keeps track of the current directory (in the
+ * global "curr_dir"), and ensures that the path size doesn't overflow.
+ * Also cleans the path using the clean_fname() function.
  **/
-char *push_dir(char *dir, int save)
+int push_dir(char *dir)
 {
-	char *ret = curr_dir;
 	static int initialised;
+	unsigned int len;
 
 	if (!initialised) {
 		initialised = 1;
-		getcwd(curr_dir, sizeof(curr_dir)-1);
+		getcwd(curr_dir, sizeof curr_dir - 1);
+		curr_dir_len = strlen(curr_dir);
 	}
 
-	if (!dir) return NULL; /* this call was probably just to initialize */
+	if (!dir)	/* this call was probably just to initialize */
+		return 0;
 
-	if (chdir(dir)) return NULL;
+	len = strlen(dir);
+	if (len == 1 && *dir == '.')
+		return 1;
 
-	if (save) {
-		ret = strdup(curr_dir);
-	}
+	if ((*dir == '/' ? len : curr_dir_len + 1 + len) >= sizeof curr_dir)
+		return 0;
+
+	if (chdir(dir))
+		return 0;
 
 	if (*dir == '/') {
-		strlcpy(curr_dir, dir, sizeof(curr_dir));
-	} else if (dir[0] != '.' || dir[1] != '\0') {
-		strlcat(curr_dir,"/", sizeof(curr_dir));
-		strlcat(curr_dir,dir, sizeof(curr_dir));
+		memcpy(curr_dir, dir, len + 1);
+		curr_dir_len = len;
+	} else {
+		curr_dir[curr_dir_len++] = '/';
+		memcpy(curr_dir + curr_dir_len, dir, len + 1);
+		curr_dir_len += len;
 	}
 
 	clean_fname(curr_dir);
 
-	return ret;
+	return 1;
 }
 
-/** Reverse a push_dir() call */
+/**
+ * Reverse a push_dir() call.  You must pass in an absolute path
+ * that was copied from a prior value of "curr_dir".
+ **/
 int pop_dir(char *dir)
 {
-	int ret;
-
-	ret = chdir(dir);
-	if (ret) {
-		free(dir);
-		return ret;
-	}
-
-	strlcpy(curr_dir, dir, sizeof(curr_dir));
+	if (chdir(dir))
+		return 0;
 
-	free(dir);
+	curr_dir_len = strlcpy(curr_dir, dir, sizeof curr_dir);
+	if (curr_dir_len >= sizeof curr_dir)
+		curr_dir_len = sizeof curr_dir - 1;
 
-	return 0;
+	return 1;
 }
 
 /**
  * Return a quoted string with the full pathname of the indicated filename.
  * The string " (in MODNAME)" may also be appended.  The returned pointer
  * remains valid until the next time full_fname() is called.
@@ -820,13 +924,13 @@
 	const uchar *s1 = (const uchar *)cs1;
 	const uchar *s2 = (const uchar *)cs2;
 
 	while (*s1 && *s2 && (*s1 == *s2)) {
 		s1++; s2++;
 	}
-	
+
 	return (int)*s1 - (int)*s2;
 }
 
 
 
 /**
@@ -861,13 +965,13 @@
 	/* all absolute and null symlinks are unsafe */
 	if (!dest || !*dest || *dest == '/') return 1;
 
 	/* find out what our safety margin is */
 	for (name = src; (slash = strchr(name, '/')) != 0; name = slash+1) {
 		if (strncmp(name, "../", 3) == 0) {
-			depth=0;
+			depth = 0;
 		} else if (strncmp(name, "./", 2) == 0) {
 			/* nothing */
 		} else {
 			depth++;
 		}
 	}
@@ -899,15 +1003,15 @@
 char *timestring(time_t t)
 {
 	static char TimeBuf[200];
 	struct tm *tm = localtime(&t);
 
 #ifdef HAVE_STRFTIME
-	strftime(TimeBuf,sizeof(TimeBuf)-1,"%Y/%m/%d %T",tm);
+	strftime(TimeBuf, sizeof TimeBuf - 1, "%Y/%m/%d %H:%M:%S", tm);
 #else
-	strlcpy(TimeBuf, asctime(tm), sizeof(TimeBuf));
+	strlcpy(TimeBuf, asctime(tm), sizeof TimeBuf);
 #endif
 
 	if (TimeBuf[strlen(TimeBuf)-1] == '\n') {
 		TimeBuf[strlen(TimeBuf)-1] = 0;
 	}
 
@@ -920,27 +1024,27 @@
  *
  * Always returns TRUE.  (In the future it might return FALSE if
  * interrupted.)
  **/
 int msleep(int t)
 {
-	int tdiff=0;
-	struct timeval tval,t1,t2;  
+	int tdiff = 0;
+	struct timeval tval, t1, t2;
 
 	gettimeofday(&t1, NULL);
 	gettimeofday(&t2, NULL);
-  
+
 	while (tdiff < t) {
 		tval.tv_sec = (t-tdiff)/1000;
 		tval.tv_usec = 1000*((t-tdiff)%1000);
- 
+
 		errno = 0;
 		select(0,NULL,NULL, NULL, &tval);
 
 		gettimeofday(&t2, NULL);
-		tdiff = (t2.tv_sec - t1.tv_sec)*1000 + 
+		tdiff = (t2.tv_sec - t1.tv_sec)*1000 +
 			(t2.tv_usec - t1.tv_usec)/1000;
 	}
 
 	return True;
 }
 
@@ -980,13 +1084,13 @@
 int _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6)
 {
 	static int (*fn)();
 	int ret;
 	char *cmd;
 
-	asprintf(&cmd, "/usr/X11R6/bin/xterm -display :0 -T Panic -n Panic -e /bin/sh -c 'cat /tmp/ierrs.*.%d ; gdb /proc/%d/exe %d'", 
+	asprintf(&cmd, "/usr/X11R6/bin/xterm -display :0 -T Panic -n Panic -e /bin/sh -c 'cat /tmp/ierrs.*.%d ; gdb /proc/%d/exe %d'",
 		getpid(), getpid(), getpid());
 
 	if (!fn) {
 		static void *h;
 		h = dlopen("/usr/local/parasoft/insure++lite/lib.linux2/libinsure.so", RTLD_LAZY);
 		fn = dlsym(h, "_Insure_trap_error");
diff -BEr -U 6 /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/wildtest.c /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/wildtest.c
--- /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.0/wildtest.c	2003-07-07 15:08:24.000000000 +0800
+++ /usr/info/code/cpp/LogMonitor/LogMonitor/second/download/rsync/repos/rsync-2.6.1/wildtest.c	2004-02-08 02:40:52.000000000 +0800
@@ -16,15 +16,12 @@
 #endif
 
 int wildmatch_errors = 0;
 
 typedef char bool;
 
-#define false 0
-#define true 1
-
 int output_iterations = 0;
 
 static struct poptOption long_options[] = {
   /* longName, shortName, argInfo, argPtr, value, descrip, argDesc */
   {"iterations",     'i', POPT_ARG_NONE,   &output_iterations, 0, 0, 0},
   {0,0,0,0, 0, 0, 0}
@@ -81,14 +78,20 @@
 		    poptBadOption(pc, POPT_BADOPTION_NOALIAS),
 		    poptStrerror(opt));
 	    exit(1);
 	}
     }
 
-    if ((fp = fopen("wildtest.txt", "r")) == NULL) {
-	fprintf(stderr, "Unable to open wildtest.txt.\n");
+    argv = (char**)poptGetArgs(pc);
+    if (!argv || argv[1]) {
+	fprintf(stderr, "Usage: wildtest TESTFILE\n");
+	exit(1);
+    }
+
+    if ((fp = fopen(*argv, "r")) == NULL) {
+	fprintf(stderr, "Unable to open %s\n", *argv);
 	exit(1);
     }
 
     line = 0;
     while (fgets(buf, sizeof buf, fp)) {
 	line++;
@@ -101,34 +104,34 @@
 		flag[i] = 0;
 	    else
 		flag[i] = -1;
 	    if (*++s != ' ' && *s != '\t')
 		flag[i] = -1;
 	    if (flag[i] < 0) {
-		fprintf(stderr, "Invalid flag syntax on line %d of wildtest.txt:%s\n",
-			line, buf);
+		fprintf(stderr, "Invalid flag syntax on line %d of %s:\n%s",
+			line, *argv, buf);
 		exit(1);
 	    }
 	    while (*++s == ' ' || *s == '\t') {}
 	}
 	for (i = 0; i <= 1; i++) {
 	    if (*s == '\'' || *s == '"' || *s == '`') {
 		char quote = *s++;
 		string[i] = s;
 		while (*s && *s != quote) s++;
 		if (!*s) {
-		    fprintf(stderr, "Unmatched quote on line %d of wildtest.txt:%s\n",
-			    line, buf);
+		    fprintf(stderr, "Unmatched quote on line %d of %s:\n%s",
+			    line, *argv, buf);
 		    exit(1);
 		}
 		end[i] = s;
 	    }
 	    else {
 		if (!*s || *s == '\n') {
-		    fprintf(stderr, "Not enough strings on line %d of wildtest.txt:%s\n",
-			    line, buf);
+		    fprintf(stderr, "Not enough strings on line %d of %s:\n%s",
+			    line, *argv, buf);
 		    exit(1);
 		}
 		string[i] = s;
 		while (*++s && *s != ' ' && *s != '\t' && *s != '\n') {}
 		end[i] = s;
 	    }
